I think C++ used to be compiled this way. I haven't really felt the need for this sort of thing in the past.
man , even before reading this , just gotta say thanks for the work you had 
 #include &lt;stdio.h&gt; int function1(int x, int y){ printf("%d:%d\n", x, y); } int function2(int x){ printf("%d\n", x); } int main(){ int f1 = &amp;function1; int f2 = &amp;function2; printf("%d\n", f2-f1);//difference (function2 - (f2-f1))(1); //will call function1 (function1 + (f2-f1))(2, 2); //will call function 2 } As for unions, I don't really use them that much.
That makes sense! Yes, all argues are evaluating before calling the function (rather than evaluating a variable every time a variable is referenced in the function body, which would likely lead to multiple side effects such as print statements). I find it very interesting while I'm taking a programming languages design course and having to think about some of those decisions. Thanks for sticking around for the long discussion! 
De nada!
What specifically do you do that requires no garbage collection? Or is it merely the idea of garbage collection? 
Indeed, I believe even the masters are still learning about it its just that good xD.
Haha I am studying C again for my thesis work (Placement problems in graph theory) I think I am going a bit too in depth though, it took me almost three days to make it through the first 100 pages of K&amp;R book because I read one page, take notes for revision, do the examples and some exercises, look shit up on the internet and stack overflow for more info on what I just read.. etc .. another weird C thing I stumbled upon which I hadn't the first time I did some stuff with C is this shit here: https://en.wikipedia.org/wiki/Comma_operator I'm gonna be looking for ways to use this in my for loops from now on ;)
Well put. A corollary to the ambient complexity argument is that since C is a small language you can routinely use almost the entire language in even small-medium sizes projects. I find this a very nice 'feature' compared to languages like Java or C++ (both of which are fine in their own respects) where you have to pick and choose because of their kitchen-sink approach. PS: Go doesn't have exceptions, does it? Its error handling approach is pretty close to C in that there isn't a special language feature to do that.
But isn't it redundant writing `func` or `fn` (or worse, `function`) when you can convey that information implicitly? I can't see anything to be gained by spending those extra characters.
I use the BSD queue(3) functions in some of my projects. I've also used Linux kernel's list/hash table implementations to some success.
&gt; Depends on how you define “embedded”. indeed. _my_ definition of 'embedded' would be anything without an mmu.
Personally I write 99% C in .Cpp files in the procedural way (vs. the Object Oriented way of Cpp/Java) and its the first way of programming where I feel comfortable and think I can do anything because I can write every function that I call if I want to. I tried (Learning/Teaching programming in a Object Oriented way like you have to with Java and get pushed toward with C++ using all the new types and templates etc. etc.. to me seems inhumane after trying to do it myself to myself) So what I love about learning C was the fewer types and core components I needed to learn and keep in my head while I wrote code. I write in C++ files because of a few features and functions overloading (I think that is C++ only right?) so just lowering the complexity, and being able to see how everything is written and how it is working just helped me a lot. ex. I only define structs and I haven't yet found a reason to set "private:" , I don't make Setters or Getters unless they are values I commonly calculate from other values. Others wrote this more poetically I see but I thought I would throw in my two cents, I'm sure I would hate programming as a underling in some company because of what they would make me change about what I do, but I really enjoy doing what I do the way I do it. Writing my own memory management, and basically treating a memory block like a HUGE array of bytes was a big win in demystifying programming for me.
Jupp this talk is really cool and includes some interesting tips/methods for debugging that I really like.
Check that you don't link and embed the whole standard library (or other libs) for just a couple of functions? Strip symbols?
I'd programmed in other languages for educational and experimental purposes, but C was an illuminating experience that truly allowed me to *get* how programming and computers worked at a low level and allowed me to start writing productive code. After slogging through some Python or R, and basic scripting languages, C gave me the grounding and confidence to just start programming in it as the tool of first choice to solve real problems requiring custom data manipulation. C was for once an opportunity rather than a burden. Every other language felt like it had conceptual overhead unnecessary to basic productivity and learning. I thought Rust looked promising as a next step from C, but gave up when I saw that its default "Hello, world!" binary was so large as to require three floppy disks, which gave me the strong impression that it would not be the language that could take me the places I wanted to go, which was things like embedded programming and learning to program graphics for tiny/old systems I loved.\* I think it is a major teaching failure that students are first taught Java or, today, Python. The whole paradigm of objects with constructors and methods was fuzzy and vague for me as a beginner. By contrast, C showed me the ground truth that there is only memory, and operations on that memory, and instructions are memory too that we jump around in. Suddenly I could see what compilers actually did, what it meant for data to be laid out structurally in memory, and how references to data got moved around.. --------- \* The 1984 Macintosh and the IBM PC both had around 128k of RAM, and were two of the greatest systems in computing history. Even with all optimizations enabled, it is not possible for normal Rust programs to load on those systems. Rust can't even necessarily fit into a PDP-11, a machine that to this day supervises nuclear power plants. This saddens me.
It’s just so damn simple and elegant. In college we used C++ for everything and it was a goddamn nightmare. My first job was doing embedded work in C and it was an absolute pleasure. Nowadays I write Java/Python/JavaScript for work, but I like writing audio plugins with C in my spare time. 
`emulator.c`, function `Head()`, line 96: char Input[256]; ... fgets(Input, 256, stdin); if(Input == NULL){ It doesn't work like that. You must test `fgets()` return, not `Input`. `Input` will never be `NULL`. ------------------------ char *Command = strtok(Input, " "); if(!strcmp(Input, "run")){ delim = strlen(Input); strtok(Input + delim + 1, " "); char *Filename = Input + delim + 1; char *Mode = strtok(Input + delim + 1 + strlen(Input + delim + 1) + 1, "\n"); That's not really the way `strtok()` is supposed to be used. Have a look at its man page. It should be something much simpler, like this: char *Command = strtok(Input, " "); if(!strcmp(Command, "run")){ char *Filename=strtok(NULL, " "); char *Mode = strtok(NULL, "\n"); But you should check that the value returned by `strtok()` in `Command`, `Filename` and `Mode` is not NULL (unless you are *100% sure* the format of the line will *always* be well formed).
The HTTP parsing is a little hacky right now. the deadline is this friday so I'm not proud of that section
Functionally this makes sense to me but what would a real use case be for this? 
There’s is no such thing as a dynamic/flexible array. What std::vector, ArrayList and NSMutableArray do is preallocate more than you need to allow the array to grow, and when you need more than they preallocated they reallocate an even bigger array and copy the elements of the full array to it. Sure, a lot of effort went into optimizing them, e.g using a he ora tree as a backing data structure, but the end result is still a static container that may need to be reallocated and copied, which you can do yourself. 
I wouldn't say there is any. In fact I would discourage anybody from using this. It doesn't change the fact that it's very neat.
* -Os compile flag enables only optimizations that don't increase code size * -ffunction-sections and -fdata-sections, and --gc-sections for the linker will strip out any code and data that aren't used * use LTO if supported by your compiler (if not and you're super desperate you could try unity builds, where you cat all .c files into one super file and compile it) * use const liberally * strip any symbols that you don't need from the resulting binary * reduce the size of your stack if possible * prefer functions over macros that are longer than a few lines. The former will compile into one implementation and a jump, the latter will inline the code everywhere the macro is called 
Can't show it, actually
Thanks!
Yeah, I don't think I've used any standard C lib functions yet. But I'll check if I'm using --strip or not
I do gotta wonder! As much as I love C and the occasional problem to solve, doing everything sounds like a pain haha. Although, I barely have any experience with Python. &amp;nbsp; Honestly, K &amp; R is meant to be read slowly imo. Take the time to learn as much as you can. But it is a ton of info, so it might be hard to retain so much if you're going through the whole deal. &amp;nbsp; The comma operator! Basically never used by anyone anymore, but it used to be really useful. It guarantees left to right evaluation and returns the evaluation of the second argument I believe. &amp;nbsp; while ((c = fgetc(file_stream), c != EOF)) { // Have some fun } I think something like this is okay. Not that's really any more beneficial then: &amp;nbsp; while ((c = fgetc(file_stream)) != EOF) { // Have some fun } 
indeed, but i was kind of disappointed that someone here thought that he was a n00b. oh well :(
Hanging around on any random sub-reddit doesn't automatically make any person any smarter. (I can also refer you to that persons detailed explanation of why he claims to hold that opinion... which at time of me writing this does not exist.)
It's fast. It's concise. You can build anything with it. It gives lots of freedom. There are lots of open-source libraries. There is a small learning curve, or an "ah-ha" moment that you'll need to pass when it comes to how C treats data and types. But once that clicks, you'll fall in love with the power. It would be nice to have C++ templates in C.
I just remembered something: I think I remember that I avoided using `strtok(NULL)` because it's not thread safe.
At the time I first started using C it was “long int”. I don’t recall any other language having a similar construct to allow code to work with decent sized integers in a portable yet relatively fast manner on smaller word sized machines - machines on which modern languages could never be made to run. Type casting wasn’t invented in C but understanding implementation defined behavior extremely well allowed one to utilize casting onto char arrays for wicked fast yet flexible binary IO which made for clean and fast IO in a way many modern languages still don’t do well. Most modern languages now have basic fixed width types from 8 to 64 bits, but the binary IO handling is still poor in many languages. I’d argue if you aren’t leveraging some aspect of implementation defined behavior (even the existence of int8_t and the like from &lt;stdint.h&gt; aren’t guaranteed to be universally available, including on word oriented machines like DSPs where chars may be 32-bits for example) you may be using the wrong language. The corollary for those of us who have basic systems skills like design and factoring and have worked on applications in the millions of lines and up category it’s clear most people who work in C never learned these techniques and every basic construct is written out incorrectly and in long hand over and over and over again to the point where I’ve had no trouble reducing decent sized sections of code by factors of 10-50, which one might call *concrete complexity*. By the time it hardens around your ankles you know it’s only a matter of time before it hardens around your neck which is why I stopped working at C shops despite the fact that I like the language. Ironically bad C++ houses will choke out far more quickly, but the few good ones I’ve worked with are far more effective than any large scale C shop I’ve seen.
Speed (C#, Javascript), Easier to debug ( C++ ), Familiarity ( Rust). Although I am using script for my day to day work, and deal with projects in C++. I don't feel stuck in C, I am learning quite a lot of stuff from other languages and try to adapt patterns that make the code more readable. But when it comes to debugging an issue with software, I really feel that debugging C code offer a more transparent experience.
Because I love feeding trolls, I am pretty certain you can achieve segfault in all languages, not because of their design, but of the eco-system they are put in.
"absolute precision" can not be used with "undefined behavior"
In the meantime use this library to deal with utf8 https://github.com/sheredom/utf8.h I have undef'd all the str* functions when I am in debug mode to force myself to use utf8 rather than assume ascii
You could remove a lot of C++ part to make it more predictable, turning it in a "souped up" version of C.
&gt;Last but not least, C is a comparably simple language. You can read the standard and pretty much understand what happens. Most developers write something on on version of one OS on one processor instance with one compiler with one set of flags and think “this is how C works!” This is why we’ve had nearly four decades of people claiming the compiler is broken when “c = c++;” does do what they want. Using the real benefits of C in large scale systems where everything changes underneath you over decades requires intensive study and the ability to understand and apply best practices. Even in the small, old people who can’t read man pages and young people who don’t understand the “restrict” keyword in the prototype thrown up by a good IDE use memcpy for overlapping arrays and when glibc introduced a minor and completely standards compliant optimization world of software died a horrible death, including Flash which after well over a decade of security failures clearly wasn’t run against any of a number of dynamic checking tools that would have found this before going out the door. For some advanced ways thing can go wrong where most developers won’t expect it, start with this paper: https://people.csail.mit.edu/nickolai/papers/wang-stack.pdf **tl;dr:** please stop saying C is easy. Any language is easy for your first temperature in F to C program but everything from security in the smallest applications to issues in large high performance systems good C requires real skills.
I would argue that it's still possible to get segfault in other languages too ( compared to C ), no matter how "memory safe" they are supposed to be.
I haven't finished it yet, but `int binsearch(int x, int v[], int n)` is from the book.
It doesn't work particularly when I do `binsearch(9, arr, 7)`. Works for other values. Btw, the function is copied from the book.
Despite the 1978 K&amp;R pointing out pointers are not integers too many who thought Pascal to be a personal affront assumed int could be used as an opaque type when either an integer or pointer needed to be passed and therefore cast pointers to integers and back. Everything from 68000 and large mode 8086 code to anything running on most 64-bit microprocessors broke such code, yet despite this people still wrote such code in the 2000s because even then they still thought “all the world is a VAX.” If you use a union with all the relevant subtypes it will always be big enough to carry any of those subtypes. 
I mean, sure. I still don't see how a union would be better than directly specifying type. Wouldn't there also be some memory overhead, albeit minimal, to using a type that is larger than what you need? I have yet to come across a practical use case for union.
C doesn't force you to do anything, OOP is C is pretty easy to do.
I was able to write portable code due to what I would call a lack of defined “execution model,” from bare iron to run to completion systems like MacOS to multithreaded single process sytems like the old base VxWorks to multiprocess single threaded systems (remember when System V had no IO multiplexing so even something simple like telnet needed to run as multiple processes?) to multithreaded multiprocess systems. Interrupts on bare iron, signals in *NIX, ASTs on VMS, etc... required a fairly sophisticated framework so the code that ran on top of it would just run regardless of the environment. C only recently came up with some base threaded primatives, atomics and a memory model. Event handling of any kind is still beyond the language and requires extensive knowledge of implementation defined behavior to write reasonably portable systems. Freedom for some - an inescapable pit for others.
&gt;You have private classes, public classes, interfaces, abstractions, inheritance and other other number of terms that seems to find their way into the ecosystem. In large scale C projects one ultimately invents every one of these things in less effective ways from incomplete types to trying to make some headers private to virtual function tables to... It’s often better to have the language manage common constructs to minimize code and corresponding fragility.
In *many* languages (like Java, Python, Ruby, etc) it is quite common to have null/nil/None errors. Someone can say that they are better to segfaults because they include a comprlete backtrace, and can be captured as an exception. However, they can be hard to debug, and break production code frequently.
Inertia - over 20 years of experience leads to familiarity. Performance - I still haven't found a language where I can't replace something with a quick hack in C and improve performance by a lot. Simplicity - it's a simple language. At least from my point of view where I started with actually understanding how computers work and then moving up the abstraction layers. Systems - even though I don't write huge amounts of operating system code anymore, I still dabble in systems programming from time to time. There are no palatable alternatives here. And by systems programming I mean "screw around with page tables, interrupt handlers and DMA", not "http interface for a database connection" that I've seen it mean in recent years. I do dislike where C is heading though. Both clang and gcc are reading the C standard like the devil reads the bible (not an english idiom, I know, but I find it particularly fitting in this situation) and both are using the nasal demons interpretation of undefined behavior rather than trying to be programmer friendly. I do use other languages for certain things. I like and use Go a lot in the past few years.
So, add the assertions, and the printed statements. Gather evidence about what is _actually_ happening. Figure out where that differs from what _should_ happen. That's the bug.
If you want to implement sum types (or algebraic datatypes in general) such as Rust’s Option type or similarily Haskell’s Maybe you need union types, consisting of a common tag and a specific data section that is union’d from several types.
Because all these language rely on runtimes that are usually coded in unsafe language, and that these runtime could trade some safety for better performance. And that in some case you have to rely or relying on library that are written in unsafe language, mean that because you are using these language, which try to avoid segfult by design, you are not totally avoiding them. Examples : - [Java](https://www.oracle.com/search/results?cat=bugs&amp;Ntk=S3&amp;Ntt=segfault) - [Python](https://bugs.python.org/issue?%40columns=id%2Cactivity%2Ctitle%2Ccreator%2Cassignee%2Cstatus%2Ctype&amp;%40sort=-activity&amp;%40filter=status&amp;%40action=searchid&amp;ignore=file%3Acontent&amp;%40search_text=segfault&amp;submit=search&amp;status=-1%2C1%2C2%2C3) - [Ruby](https://bugs.ruby-lang.org/search?utf8=%E2%9C%93&amp;scope=&amp;q=segfault) Thanks for your attention
&gt; These functions can cause a buffer overflow due to not checking the boundary value or in the case of misuse etc. Also these function can be dangerous in case of misuse: - memcpy - malloc - free - sqrt 
I should also put my list of dangerous operator if they are misused (all of them )
&gt; It's as fast as you can make a program go https://github.com/BurntSushi/ripgrep/blob/master/README.md
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [BurntSushi/ripgrep/.../**README.md** (master → d73a75d)](https://github.com/BurntSushi/ripgrep/blob/d73a75d6cd82068252c35c5718900b6a1acb296e/README.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
You can do it in a somewhat hacky way using macros. You create a source file that uses some GENERIC_TYPE macro, and declares all generic functions wrapped in another GENERIC(function_name) macro, to do token pasting and create a unique name for each function. Then from a new file, you define the macros, include the source file, undefine/redefine them, include again, etc. Then you can use C11 _Generic to create a single macro that will call the correct function based on the type of one of its arguments. Here’s an example I made a little while back: https://github.com/GavinHigham/Generic-Heap-Experiment?files=1
C doesn't have maps...?
Copying the definition from Wikipedia: "In computer science, a dynamic array [...] is a random access, variable-size list data structure that allows elements to be added or removed. [...] Dynamic arrays overcome a limit of static arrays, which have a fixed capacity that needs to be specified at allocation." The given examples seem to satisfy that definition. Therefore they are dynamic arrays. How they work internally or how you would implement them in C specifically is not important for determining what they are. This is how abstraction works. &gt; but the end result is still a static container that may need to be reallocated and copied, which you can do yourself Sure, I can do it myself, but as you mention yourself, a lot of effort went into optimizing the standard implementations. So why should I replicate all that effort when it serves me no benefit. I don't always need a custom implementation and if I do, I can write it when it becomes a bottleneck.
And you probably will not as it is a niche! 
I mostly hope that Rust replaces C++ as both are complex. But for a C replacement, I hope a new simple and efficient C like language appears! 
Biased! 
I usually start with plain vim and continue with IntelliJ when the project reaches a certain complexity where I feel that some IDE features would be useful. (IntelliJ taking so long to start up is really annoying though. It's almost a minute until the IDE is up and running, the project loaded and I can start working.)
I'm aware of it and I may use it when I write a C project, but I think it's telling when people try to replicate these generic data structures. Looking at the comments of stb_sb though: TYPE *myarray = NULL; When I see that in foreign code, I wouldn't know whether it's a regular array (and I know it's an array just because of the name, not the type!) or a special stb_sb. I wouldn't know which functions I'm allowed to call on myarray nor what I'm allowed to do with it in general (there are no private attributes in C) without documentation telling me (and documentation is often unsatisfactory in C codebases imo). I may also forget to call sb_free on it (valgrind helps with that.. but only if the code flow reaches a point where valgrind can detect it). It gets even worse when there are multiple different dynamic array implementations in a single project. (My own self-made void * implementation for example, has the disadvantage that the type is "struct vector", so you can't even find out the type of data stored in there without checking the vector_init call or documentation. It's also not type-safe.) Contrast this with std::vector or ArrayList where it's clear what you are dealing with (I think a declaration like "ArrayList&lt;Integer&gt; myarray" leaves no questions), because of OOP it's also clear which operations the ArrayList supports and it hides internal data (private attributes), so you don't mess with the state if you don't know what you're doing (and there are less talented programmers on the same project). Also, you don't have to worry about memory management.
&gt; I would normally use classes but I managed to make all the characters with structs. You do know that structs are just classes, right? And in C++ a struct *is* a class with attributes that are marked public by default. In other words: An abstract data type is just a struct coupled together with the operations/methods you can call on it (that would be the functions with the struct * parameter). &gt; And now that I am in the robotics team C is just amazing. Being able to program pins and different weird chips is really cool, although some stuff require assembly. Do you really have to write your whole project in C though? Can't you simply write a small C library that takes data and writes it to the pins... then you call that C library from Python, Java, ...?
Oh, I thought you were talking about Go. In C, I so far didn't have the need for a fast hash map or another data structure library either.
&gt; Pre-existing programs that need C to extend them, or C code to provide an interface to other code bases. This is probably one of the most important reasons why C is still used so much. Inertia. Nobody is going to rewrite the Linux kernel in a different language. C is also perfectly fine for small glue code that is used as a library in other higher-level languages.
Then it's going to be very hard to help you. Have you tried to find out which functions or variables occupy the bulk of the storage? Consider using `nm -S` to check this.
I know, there is in go tho IIRC.
&gt; I used to program in Java quite a lot, however it seems there is some perceived need to include the latest fad features from various new(er) languages. Many of these features while they (sometimes) help to reduce complexity for the coder, often make the code itself harder to read, and to see just whats going on. The functional programming features added in Java 8, lambdas and streams, are an example of this in my opinion. I still prefer classic imperative code, even if it might take a bit longer to write. Code is more often read than written.
&gt; PS: Go doesn't have exceptions, does it? Its error handling approach is pretty close to C in that there isn't a special language feature to do that. Go has exceptions (called “panics” in Go), but they aren't used for non-fatal error handling. According to the Go style, you should panic if a programming or otherwise strictly unrecoverable error occurs. Otherwise, you should make sure that panics do not escape the library they were created in so the caller doesn't have to deal with them.
No blog spam please.
If you already use other tools to generate code, then it’s quite natural to delegate this to the build system. Compile the same source file which uses an undefined type `T` (or constant value or sorting function name, etc.) into multiple objects with different macro definitions specified on the command line, such as `-D T=int` or `-D TYPEDECL="typedef void (*T)(int);"`, and wrap all exported symbols in a macro such as `int MANGLE(foo) (int bar) { ... }` which adds a suitable prefix/suffix to the name depending on other command line defined macros. Treat generics as code generation and use the C pre-processor or shell scripts to expand code and let the compiler compile C. Of course, this doesn’t work as well for libraries, as it puts expectations on the build system and it can be messy if you go overboard with this. It also makes the build system very integral in the definition of the program. It might sound like a nasty work-around for missing language features, but it in some ways I prefer it as I don’t have to limit myself to try to solve every problem in one language.
I agree that even though C's syntax is simple it is not a simple task to write complex and large software with C. But I cant agree that you are implying that it is an easier task to write large software in other languages. it is as difficult at least! 
yep. chit borrowed from C#
because I learned to program with C and you can't beat your first, platonic, love.
And that is why it is comparatively slower! 
&gt; then you call that C library from Python, Java, ...? And strain communication and performance with hardware just to write in other PL? why?! 
&gt; And strain communication and performance with hardware One has to evaluate whether that is a bottleneck of course. &gt; just to write in other PL That's a significant advantage. If it weren't, why don't you program in Assembly then? On the other hand, the robotics applications might be fairly small in scope. In that case, C is fine.
Yes
Hope you find it usefull. I also prefer using native solutions in vim. It seems like some plugins are created because someone did'nt read the manual. :D
Are you implying that large and complex software cannot be made in Vim or Emacs? Cause you are not fully aware that most systems and important tools were not made using IDEs
&gt; Most developers write something on on version of one OS on one processor instance with one compiler with one set of flags and think “this is how C works!” This is why we’ve had nearly four decades of people claiming the compiler is broken when “c = c++;” doesn’t do what they want on a new compiler. Using the real benefits of C in large scale systems where everything changes underneath you over decades requires intensive study and the ability to understand and apply best practices. I know that many developers have serious misconceptions about how C behaves. However, it is easy to get rid of these misconceptions by reading the undefined behaviour summary of the C standard, which isn't that much to read
One problem garbage collectors cause is that large arrays of pointers can cause significant delay in the collection phase as the garbage collector has to scan them front to back. For good performance, you have to understand how the garbage collector performs and use that knowledge in your data structure design. In general, just try to avoid piles of small structures connected with pointers (this is good advice when using `malloc`, too) and try to avoid using large arrays containing pointers. If an array only contains numbers instead of pointers, it doesn't need to be scanned, speeding up garbage collection.
Are you implying that programs writing in other languages do not have security holes? As in PL security holes are made mostly by not skilled people. C has a lot of best practices that full avoid all known security holes. You guys are dreaming boys imagining that new PLs are the only able to fix security! 
You mean declarations and statements. They do.
&gt; the suspicious code block uses the loop variable (i), which would be clear error at compile time It's a GNU89 extension, but I think you get a warning. GNU99 does not allow it.
There is already support for arbitrary character encodings which you can also use for UTF-8. Plus there is already `uchar.h` with basic Unicode support. But then, what stops you from just using the libicu for your Unicode needs?
I thought that most programmers in C sub was experienced ones but there are some arguments that even noobs cant debate with
That's undefined behaviour and won't work on systems where an int is too small to hold a pointer, e.g. amd64 or arm64.
What is your question? Where are you stuck?
The section numbers below are from the 1999 draft which can be seen on the web as n1124.pdf so if someone can find clauses which contradict what I say below everyone who is reading this can have a common reference point for followup. Arithmetic operations cannot be performed on either function pointers or function types per section 6.5.6 so I don't see how this is actual C. GCC defines sizeof *function_type* in violation of section 6.5.3.4 which appears to be how GCC can perform this kind of arithmetic on a function type. The same goes for sizeof(void) which is an incomplete type per section 6.2.5 which is another source of crap code that doesn't get through other compilers or static analysis tools. GCC doesn't seem to report the incompatible typing even with -Wpedantic -std99 which should be undefined behavior due to section 6.5.2.2. I'd bet less than 1% of developers ever opens the real standard so the tooling is the only way most will learn how not to write C (I read K&amp;R many times before there was a formal standard but lint forced me to learn things I didn't pick up from simply reading.) Just because it compiled and ran for you doesn't mean it's actual C.
yah it is an actual data from an antenna the first 24 rows which i added but the last 11 rows with 24 columns are the actual data. can you suggest me how can i make it a square matrix if i remove first 11 rows then 24 rows and 24 columns is Ok or it has to be a matrix with power of two well in that case the possible solution may be is to put extra zeros columns wise and rows wise to make it of order 32.. and thank you for your attention i really need to have a code to do fftshifting of the data and i am dont know how to do it.
I know what they are supposed to be. I like using NSMutableArray in ObjC and std::vector in C++. In one of my projects though I was tasked with improving the performance of an algorithm, and one of the things I did was replace std::vector with a plain ol’ C array. I had to run the loop twice first to calculate the size and then to stuff the array with elements but was still faster.
Generally speaking, using functions that let you specify the maximum amount of bytes to read is the preferred way of dealing with out-of-bounds accesses by making sure they never happen, e.g.: char *fgets(char *s, int size, FILE *stream); int snprintf(char *str, size_t size, const char *format, ...); Note that you'll have to manually ensure that strings created by fgets()/snprinf() are NULL-terminated. If you are writing your own functions that deal with dynamically-sized arrays, best practice is to specify input/output parameters for the array length, e.g.: /* * Sum up `len` elements of array `a`. */ int compute_sum(int *a, size_t len); /* * Calculate prime factors of `n`, and return them in heap-allocated array. * The length of the returned array is stored in `factorcount`. * The caller is responsible for freeing the returned array. */ int *prime_factors(int n, size_t *factorcount); 
In C, you should pass around the length of arrays so that you don't access an element beyond the end. As for strings, the best practice is to make sure you have enough space before writing to a buffer. For instance if you are reading from a file, you should put a max size on what you read so that you know you won't overrun the buffer. And OOB is "Out of Bounds" :) 
C doesn’t have a type which is both int and void pointer at the same time which is why the union is effective and casting everything to an int and back isn’t. The use of such opaque values is common for generic callback routines where different clients inevitably need different types.
Then you need to make your project smaller.
But as C and Ada...programming in ASM have the same performance. Python, C++ or Java one will need to sacrifice perf and its direct communication with hardware! But I agree, there are projects that C is overkill! 
There probably is, but this subreddit is for the C language, not the C++ language. Also, the sidebar has some resources to get you started, both here and in /r/cpp (probably, haven't checked).
I started by having a project in mind, and then taught myself step by step how to actually accomplish it. I had no prior experience with programming.
Woah
Actually, from my experience, OOP in C is kind of non supported. Of course you can do it if you want to (the resources are there), but ANSI C wasn't exactly created having OOP in mind. C++/Java on the other hand, are much more OOP oriented. 
If you pass an unterminated array to `strlen`, your bug is in the code that generates that error because you violate the invariants specified by `strlen`. That's the same kind of error as passing the wrong array length to a function that expects an explicit array length. Both errors cannot be avoided in the function themselves and you shouldn't worry about them.
C++ is off topic in this subreddit. Please post C++ questions elsewhere, e.g. to /r/cpp_questions.
How much code space does your MCU have? How much RAM? Does it have an MMU? How much space ( code and RAM ) does the RTOS take? Is it compiled with reentrancy enabled or disabled? 
Thanks
Thanks
Thanks
Unfortunately “easier” is an extremely subjective term. There are studies that suggest C++ results in both less code written with fewer bugs. This has certainly been the case with the best C++ teams I’ve worked with over the best C teams. As I note in another part of the replies, bad C++ projects will hit the wall far earlier than bad C projects despite the fact that so many bad C systems have countless copies of the same often broken long hand code. Some of it is culture. C++ developers programming in C would add an instance parameter to a chip driver’s APIs to accommodate two instances of the same part. C developers *have* cut and pasted whole separate drivers with different published APIs. This is from people with advanced degrees from top institutions, titles like Principal Engineer at Fortune 100 companies and decades of doing nothing but C so you can’t blame the local junior high school. 
&gt;I'm looking for more than the "make sure you don't write more than the array length". Stuff happens sometimes. I know it isn't what you are looking for, but this kind of stuff simply shouldn't happen. You should write you code so that it does not happen. It's like asking how to check, in the code, if there is a memory leak and having your program work around memory leaks. The answer is to not have memory leaks.
Source for that study?
That's an explanation that makes sense. But the result is ugly :-) Not only those long additions. The true problem is that `strtok()` points to the *start* of the previous token, so it doesn't help you with finding the start of the next one; so after going to the end of the token with `strtok()` you are put back at the start and you have to go through it again with `strlen()`, just to find the same position where `strtok()` placed its `'\0'` again. It hurts my feelings. If you can use POSIX functions, you have `strtok_r()` which is thread-safe. Otherwise, you can do it by hand, looping on characters. Or half-manually like this: char *Command=Input; char *separation=strchr(Command, ' '); *separation='\0'; char *Filename=separation+1; separation=strchr(Filename, ' '); *separation='\0'; char *Mode=separation+1; separation=strchr(Mode, '\n'); *separation='\0'; `strchr()` allows us to get the end of the current token (the position of the separation between 2 tokens actually), so moving to the next one is just a matter of adding `1`. Of course, same thing as before: if the input format is not 100% fixed, one should deal with incorrect format. In this case it means testing that `separation`, as returned by the various `strchr()`, is not NULL.
Apart from using the safe methods (e.g. snprintf), you will just have to be very careful. C doesn't provide any tricks for OOB checks because it's assuming you, the developer, with provide all the necessary domain knowledge to the system. As for the habit of using `calloc` to ensure you are getting a NUL-terminated memory block, be careful. One day, someone will put *just* the right amount of input into one of your apps, bypass a check, and somehow get a non-NUL-terminated string into your application, resulting in a runtime bug. I personally found getting into the habit of directly reading the man pages for any common functions I was using (you can do this from the console, e.g. `man 3 printf`). I found doing that to be much more effective than google answers etc.
 void SetReasonCode(char *Destination, int Code){ strcat(Destination, "HTTP/1.1 "); char ReasonPhrase[80]; switch(Code){ case 200: strcat(ReasonPhrase, "OK"); break; case 400: strcat(ReasonPhrase, "Bad Request"); break; /* ... */ case 503: strcat(ReasonPhrase, "Service Unavailable"); break; } char _Code[5]; sprintf(_Code, "%d ", Code); strcat(Destination, _Code); strcat(Destination, ReasonPhrase); strcat(Destination, "\r\n"); } Bad, bad, bad :-) `ReasonPhrase` is not initialised, it may contain anything. That means it is likely not to have a `'\0'` as first element, and the `strcat()` will only append the new text after it finds a `'\0'`, which can be anywhere, so you can end up with "%£ùZEDZ86Bad Request" in `ReasonPhrase`, or crash the program. You just need something simpler, as: char *ReasonPhrase; switch(Code){ case 200: ReasonPhrase="OK"; break; case 400: ReasonPhrase="Bad Request"; Unrelated and not important, but you can also avoid the call to `sprintf()` and one other `strcat()`: char *ReasonPhrase; switch(Code){ case 200: ReasonPhrase="200 OK"; break; case 400: ReasonPhrase="400 Bad Request"; /* ... */ case 503: ReasonPhrase="503 Service Unavailable"); break; } strcat(Destination, ReasonPhrase); strcat(Destination, "\r\n"); } 
Just a pet peeve but I always refer to it as out of bounds.
If you know it's going to be less than or greater than X number of bytes terminate the code block if too much is written by using exceptions that is to say used fixed lengths generally speaking you could use dynamic arrays but for me at least they are a bit of a nuisance to manage and often will be the source of bugs.
In file `libhttp.c`: /*Get size*/ fseek(Fp, 0, SEEK_END); unsigned long int size = ftell(Fp); rewind(Fp); /*Malloc buffer*/ (*Destination) = malloc(size); char c = 0; for(int i = 0; i &lt; size; i++){ (*Destination)[i] = fgetc(Fp); } Uargh... if you do not do anything with the characters, just use one `fread()` instead of this loop.
Oh, so any guy who wrote an OS in Rust is biased towards -- but those who don't aren't?
yep and really? Wow, this is new.
Yeah I'm not worrying about checking input right now. I just need something demo-able for my class and then I'm likely to delete libhttp entirely and start it over (if I continue with this porject at all). I don't like hardcoding all my endpoints, and want to develop a more robust MVC framework for things like this.
FYI, "OOB" in C and other programming languages stands for "out of *bounds*" (as in the bounds or [boundaries](https://en.wikipedia.org/wiki/Bounds_checking) of the array or object), not "out of *band*" (which would mean [extra data in addition to the main data stream](https://en.wikipedia.org/wiki/Out-of-band), as opposed to in-band data).
Doh!!! That's a great example of no matter how many times you check what you wrote (or your code), you're always bound to screw something up the first time around. I reckon that's why I check for out of bound arrays.
&gt; Python, C++ or Java one will need to sacrifice perf and its direct communication with hardware! Python and Java is true (although Java code, once running and compiled after application startup, is pretty fast too). C++ is about zero cost abstractions. You don't pay for what you don't use. Sometimes it's even faster than C, as in the qsort vs std::sort example. I don't know enough about C++ to say more about it and evaluate it in a more appropriate place. Also, again, another question is whether you really need the best performance. For hard real time systems (think: airbag controllers), Java and Python are out of question. However, I've heard Python seems to be a popular language for robotics for example.
&gt; In one of my projects though I was tasked with improving the performance of an algorithm The first and most important question here is: Can I replace it with a better (in terms of complexity) algorithm? I assume you did that. This is much more important than C++ vs C or std::vector vs custom. So, the C array was faster than std::vector? I believe that's true. However, they are different things and have different purposes. If you know that you will never have to store more than some natural number n of elements, of course you will pick a C array of size n (or this new std::array stuff, I don't know). Nothing will be faster. &gt; I had to run the loop twice first to calculate the size and then to stuff the array with elements, more CPU time but was still faster. Try running it with input sizes that don't fit the problem you solved. std::vector uses relatively good reallocation strategies for general input sizes. I managed to write a vector clone in C that's faster for "small" amounts (because of bigger reallocation sizes..), but slower for "larger" ones. std::vector scaled better. Even if it is faster, you're still not dealing with the same thing. std::vector is generic for example. Trying to do that in C sucks a lot.
&gt; then check if the last element in the array is '\0' or not before attempting to access it. If it's not '\0', this tells me that more data was written into the array than it's sized for allowing me to gracefully handle the situation without segfaulting You should do everything possible to *avoid* writing more than the array length, not just checking to see if you did. Overflowing your buffer *will* eventually cause a problem. Writing past the end of array doesn't just send the extra data off to the void, it writes over something else.
I appreciate your point but did lol a little bit at measuring size in floppy disks
You are right. It was a typo on my part, and now it's cemented in history as there's no way that I know of to edit the subject title.
Nope. I've seen a test comparing the performance of most used PL and C++ was almost with the same perf as Java. C, Rust, and ASM were twice faster than both! And Go was just behind both too! I cant find it....
Both are biased. We need numbers, not arguments....haha
hang in there ... I am juggling a few items and I want to come back to this. It is actual experimental data and that is fine and I spent a lot of years in labs working problems like this and it has simply been a few years since I bothered with FFT/DFT. 
Well then. I'd just say: Rust is lowlevel enough to do everything but highlevel enough to make things more easily secured. So it's a really nice language for doing things like secure microprocessors. It's not provable (like OCaml) but close and iirc there were aims to even change that. This'd be nice for some really important systems.
I think you're confusing two completely different things. If you're running the program in a debugger, it will try to print the source code at the point of the fault. But unless you've installed the source code for your libc, you won't have that available. That is most likely what the "strsep.c: no such file or directory" message is referring to, but that has nothing to do with the error, and you're only seeing that because you're running it in the debugger. It has nothing at all to do with including `&lt;string.h&gt;` or anything like that. (And by the way, headers usually *declare* functions, they don't *define* them. The definition of the function is in `strsep.c`, while the declaration is in `string.h`.) Your problem you're having is that you're trying to use a string literal with `strsep()`. That function expects to modify the string, but string literals may not be modified. You need to use a modifiable string if you're going to use `strsep()` (or `strtok()`) for that matter. 
A niche probably, but for what market?
https://duckduckgo.com/
It is nice indeed yet too complex. But I still hope for a simpler language with safety and concurrent in mind to replace C! Who knows? C2x might be it! haha
Are telling me that I should search what Ada is used for?
* Use a global variable * Pass the structure as a parameter * Pass a pointer to the structure as a parameter
i cant use global variable school work.
how do u Pass a pointer to the structure as a parameter
sry about that 
Well, most of what Rust team claims of a good reason to use Rust were highly based on Ada.
This project isn't possible in C. It is more suited for Python
`person` only lives within the scope of `function()`. The only functions that could access it are those that are called from within `function()`, and only if you passed it in as a parameter: struct data { char id[X]; }; void function(void) { struct data person[Y]; foo(person) }
thank you very much
In the scanf format string, a single space matches any amount of whitespace, and %s matches a string of non-whitespace characters. So maybe you can just do char buffer[1024]; // something big enough int numread = fscanf(file, "%s ", buf); until numread becomes zero (meaning that it fails to match), and then maybe try it with just "%s" once to see if there is one word that is not followed by whitespace. I guess that the words are separated by whitespace, if they're separated by something else then you will have to adjust this.
It's a matter of measure. As many replies have said, writing out-of-bounds is a software bug. Ideally you'd catch such things during implementation or some sort of QA process. When I've written a code module that I feel was particularly complex, I actually do code review of my own code after it's stable with an eye toward catching certain bugs. I often catch edge cases this way, and they're caught early. Team reviews are even better if applicable. Sometimes, though, there are circumstances where you might be particularly worried about out-of-bounds. For example, you might have a scratch array that's used like a stack. In this case, it's not uncommon to use a special [canary value](https://en.wikipedia.org/wiki/Buffer_overflow_protection#Canaries) at the end of the array. You might declare the array to be one word larger than is truly needed, and you write the canary to that final word during initialization. Occasionally you check whether the canary value is still present - if it's changed then you can declare the array went out-of-bounds. The rest of your logic should assume that value doesn't even exist in the array which means being careful with uses of sizeof(), etc. The canary is only a part of the array to ensure it's immediately adjacent to the end of the array. However, you don't want to take this approach with all arrays because overuse would add undo complexity to your codebase and would just be a band-aid against sloppy coding.
I don't see why it should be too complex. It's not that kind of complexity that requires an IDE or some other magic -- it's a language that promotes some implicit logic to a syntactical level, ie. things that you should put thought to (at least in a security background) are now written explicitly and checked. It's like arguing for dynamic type systems because you "don't need to think about it". It's right, and it's totally ok for many applications -- but not for systems development. And for security you want even more things to explicitly stated by the programmer. Out of security you still have those advantages like safe concurrency and, once you've wegded your thoughts around it, it comes natural and ain't more difficult than writing it in C. Some things are also far easier in Rust. There's zlang which is probably more like your idea, but C2x won't do it of course xD
If I understand your question correctly you could read the file line by line and then split your lines by the space character using `strtok`. char line[1024], *word; while (fgets(line,sizeof(line),fp)) { word = strtok(line, " "); while (word != NULL) { if (*word != ' ' &amp;&amp; *word != '\n') { printf("Word: %s\n", word); } word = strtok(NULL, " "); } } I'm guessing you'll want to do more validation (I'm just skipping the word if it's a space or newline), but that's a start. It's important to note that `strtok` has been made obsolete for various reasons and the newer function is `strsep` so you could look that up and use it instead. 
With C, you can do anything. 
I will give it a try in next years for sure. For now, I don't even see any jobs for Rust! Even less embedded jobs! 
No. Since 2010, I believe.
It's worth a look but not too easy for sure. There's much focus in academia for sure but the latest Rust survey does show an increment in jobs, so this is changing right now :) Most is in concurrent stuff rn though.
Thank you. What tools, if any, do you use to do your code reviews? Are you simply looking over the code over? Are you using tools like valgrind? A combination perhaps? I've use valgrind, but perhaps it's due to my lack of in-depth knowledge of it, it was not helpful in catching OOB for me. Most often, it ends up complaining about at an external library (say libxml2, libsqlplus, ...) leaking memory, but those are items that I have no control over.
It is possible in C though? How would it not be? It might not be the easiest or best suited language but it works.
Yeah I have Adhd and my short term memory is horrible so I have to repeat or reread things 3 times for it to stick
This advice is spot on. One way to modify your code to make it work is to change the way you define 'lat': char lat[] = "28-35-21.9970N"; Now you can modify it and everything should work. 
You can't edit titles on reddit unfortunately. Thankfully everyone here got the gist of what you meant :) 
Templating programs like M4 can do this, as part of the make file you can spit out whatever data structures you need.
You have to do more than just change to an array. `strsep()` updates the pointer passed as the first arg, which won't work if you try to pass the address of the array. You need to pass a pointer. char lat[] = "28-35-21.9970N", *ptr = lat; strsep(&amp;ptr, "-"); Now `ptr` points to the '3' in 35. 
You're right. I forgot that it modifies the pointer as well. Updated my comment.
Tbh, I've lost track of their updates but I was sure this wasn't the case for longer, but maybe it was due to me only having access to older MSVC versions since somehow nobody upgraded at the company ever.
&gt; Are you implying that programs writing in other languages do not have security holes? No. So the rest of your post is mostly a [strawman argument](https://yourlogicalfallacyis.com/strawman). &gt; C has a lot of best practices that full avoid all known security holes. Yes, and these have been known for a long time. However, the fact that these are known doesn't automatically mean that programs always make use of all best practices. As an example, [here is some very old advice about how to write a safe setuid program](https://adam.shostack.org/setuid.7.html) which wasn't taken into account by the very smart and security aware software developers at OpenBSD until it was pointed out to them [and they made a systematic fix](https://ftp.openbsd.org/pub/OpenBSD/patches/2.3/common/fdalloc.patch). That was a rare security vulnerability in the OpenBSD base install (allowing an attacker to send arbitrary data out of a raw socket without needing to be root). There was similarly a vulnerability with the same cause in Solaris (in which a secure administration tool could be used to inject arbitrary data into an authorization config file just by making a symlink to the tool's binary and invoking it incorrectly (so that it issued an error message in stderr - so that the error message went into the config file). &gt; You guys are dreaming boys imagining that new PLs are the only able to fix security holes! Well, if you were to (re-) read what I wrote, you might notice that I didn't say that. But the fact is that in any process involving humans, some proportion of the time a mistake will be made. This is inevitable. To deal with this situation we adopt techniques where there are redundant protections. For example, training on best practice _and_ code reviews _and_ minimally privileged designs. Selecting a programming language that is less prone to security vulnerabilities should just be another tool available to us to reduce the number of security vulnerabilities we introduce. 
I think you could make the same argument about the `struct`keyword and a few other things. Don’t necessarily agree.
Still, you are ignoring that before C arrives, Fortran based languages were said to be insecure. C was a safer replacement. Now C is the insecure one. In the next years, Rust and alike will be the insecure ones. As hackers find flaws in its design What makes great, safe and reliable software are humans not PLs. PS: Sorry if it seemed that I was trying to insult you!
I still hope for a simpler PL than Rust to replace C in system programming...haha
No surveys unless they are about programming in C.
&gt; Still, you are ignoring that before C arrives, Fortran based languages were said to be insecure. Interesting! The only FORTRAN-based language I know of is [Ratfor](https://en.wikipedia.org/wiki/Ratfor). That's really a transpiler (as we would term it today). What other FORTRAN-based languages were there, and what security problems were blamed on them?
**Ratfor** Ratfor (short for Rational Fortran) is a programming language implemented as a preprocessor for Fortran 66. It provided modern control structures, unavailable in Fortran 66, to replace GOTOs and statement numbers. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
I got confused in the ancient language... Whatever...you understood but preferred to attain in a minor detail that does not nullify the argument! A fallacy called Smokescreen
If you want to improve then just write code. Start off with some small utilities that you want to use and go from there.
I don't understand this, could you explain please?
&gt; fallacy called Smokescreen https://www.coursehero.com/file/p6n3di4/Smokescreen-This-fallacy-occurs-by-offering-too-many-details-in-order-either-to/
Books, reading GitHub repos, annoying senior ...
Well some semblence of memory safety is already amazing. Even the best programmers in the world sometimes make an off-by-one mistake or forgets to initialize a variable in a hurry, just to say something. Using a language where minor technical mistakes like this result in an exception instead of just trampling all over writeable memory are a fucking big improvement.
Can't believe you're being downvoted, it's the truth.
This wouldn't work for words that are followed by punctuation (commas, dots, dashes etc.). I'd define a word as a contiguous glob of isalpha() characters, and skip everything else. This way a simple loop to collect a word is all that is needed and is obviously correct whereas scanf format strings are more of a black magic kind of thing :) 
Uh, Python is/was (?) written in C. And even if it wasn't, when it is run on Linux the underlying operating system that it runs on is written in C. While it might be true that Python provides libraries/classes or other high level abstractions that make it easier to solve the problem in Python, C is a Turing complete programming language that can solve any problem that Python can - in the case of CPython _is_ solving the problem.
fgets and snprintf and in general every other function in C that create "strings" will always put a terminating nil byte because otherwise they wouldn't be creating C "strings".
Can't help with the code size, but for the debuggingz if you aren't already you can probably do most of it on your machine with unit tests. You can probably ifdef your way through hardware/is access.
Any function that says it will create a C string WILL put a '\0' at the end of the string. Any function that you give the size of your buffer to WILL NOT write past the end of the buffer. These are the assumptions, so then, as long as you don't introduce bugs with your own code, checking if other functions followed contract is taking defensive programming a notch too far imo.
Is there a way to do it without making `lat` an array? After some tinkering, I found that this also works char *lat = strdup("A-BB-CCC-DDD.D"); char *tok; tok = strsep(&amp;lat, "-"); It works almost perfectly, but there seems to be an issue when it gets to the last token `"DDD.D"`. 
Why can you not use an array? Using `strdup()` performs a dynamic allocation which is pointless. And as written it's also a memory leak, because you lose the original pointer so it can't be freed. I can't do anything with "there seems to be an issue." Post a complete but minimal testcase that demonstrates what you're doing and describe exactly how it doesn't work. 
Okay. What is your question?
The program says core dumped after i run it only sometimes 
When the sidebar says to begin every line with four of those weird characters, it means spaces, not literally those characters. Furthermore, you haven't told us what the problem is, nor what your program does, nor what it should do.
The program says core dumped after i run it only sometimes
`i` is used uninitialised
&gt; uninitialised thank you for your help
I would be really interested in your insight, on which argument you find profoundly stupid. 
%d is for a signed integer. Compile with warnings and it should tell you.
"%d" tells printf to display the value as a signed integer. 
You actually have a couple things going wrong here.'%d' is not the correct format code for unsigned types, '%u' is, so if you did printf("%u",y); You would see '4294967295' output by printf. The reason that char and short types seem to work is because these are getting zero extended when the value is passed to printf. On my machine, the output of your main is this: 0: 55 push %rbp 1: 48 83 ec 20 sub $0x20,%rsp 5: 48 8d 6c 24 20 lea 0x20(%rsp),%rbp a: e8 00 00 00 00 callq f &lt;main+0xf&gt; f: 48 8d 0d 00 00 00 00 lea 0x0(%rip),%rcx # 16 &lt;main+0x16&gt; 16: ba ff 00 00 00 mov $0xff,%edx 1b: e8 00 00 00 00 callq 20 &lt;main+0x20&gt; 20: 48 8d 0d 0b 00 00 00 lea 0xb(%rip),%rcx # 32 &lt;main+0x32&gt; 27: ba ff ff 00 00 mov $0xffff,%edx 2c: e8 00 00 00 00 callq 31 &lt;main+0x31&gt; 31: 48 8d 0d 16 00 00 00 lea 0x16(%rip),%rcx # 4e &lt;main+0x4e&gt; 38: ba ff ff ff ff mov $0xffffffff,%edx 3d: e8 00 00 00 00 callq 42 &lt;main+0x42&gt; 42: 48 8d 0d 21 00 00 00 lea 0x21(%rip),%rcx # 6a &lt;main+0x6a&gt; 49: ba ff ff ff ff mov $0xffffffff,%edx 4e: e8 00 00 00 00 callq 53 &lt;main+0x53&gt; 53: 31 c0 xor %eax,%eax 55: 48 83 c4 20 add $0x20,%rsp 59: 5d pop %rbp 5a: c3 retq Offsets 16, 27, 38, and 49 are the most interesting; this is where we pass w, x, y, and z to printf, respectively. You can see 0xff (w), 0xffff(x), 0xffffffff(y) and 0xffffffff(z) being passed. 0xff and 0xffff are equal to 255 and 65535 regardless of whether the number is being interpreted as signed or unsigned for 32 bit integers, which '%d' prints out. Though, 0xffffffff is -1 when signed, 4294967295 when unsigned. So tl;dr is use the correct format code. 
What warn level detects for signed / unsigned mismatch for printf parameters? On my machine (clang5.0 on msys2, 64 bit windows 10), compiling the code OP posted with clang -Weverything test.c only produces the following test.c:8:11: warning: implicit conversion loses integer precision: 'unsigned short' to 'unsigned char' [-Wconversion] w = x = y = z = ~0; ~ ~~^~~~~~~~~~~~ test.c:8:15: warning: implicit conversion loses integer precision: 'unsigned int' to 'unsigned short' [-Wconversion] w = x = y = z = ~0; ~ ~~^~~~~~~~ test.c:8:21: warning: implicit conversion changes signedness: 'int' to 'unsigned long' [-Wsign-conversion] w = x = y = z = ~0; 
You're right, my bad. I thought it did, but it seems only to warn about mismatched precision, rather than signed.
Great. One of the things I googled for was the appropriate `%` codes for printf. Unfortunately, I must not have known where to look. Is there an official reference?
http://pubs.opengroup.org/onlinepubs/009695399/functions/fprintf.html The posix spec is as good as any imo. But there is undoubtedly a reference somewhere in the standard somewhere.
It's explained on the page you linked.
At $dayjob, we use c11. For my own code, I use vanilla Ansi C because I like it when my code compiles and runs on every operating system.
Preface: I wouldnt consider myself an expert, as Im still a srudent at University, but I can certainly provide some insight. Personally, I would suggest a language such as Python or Java for a beginner programmer. Both have limitless support, are relatively simple, and may be more up your alley of Web Dev stuff is what youre into. However, considering this is the C programming subreddit, many people believe that C is the perfect starting language due to its deceptive simplicity. Although learning C would be more difficult at first, it will make transitioning into other languages easier. As for projects amd actual work, Ive not got any advice. Best of luck though!
Optimized how? What do you mean when you say "syntactic sugar"? For what other more verbose concept is a do while loop "sugar"?
I fixed it. The issue was that if I put `strsep()` in a loop, when it accesses the last token, it segfaulted. For example: char *lat = strdup("A-BB-CCC-DDD.D"); tok = strsep(&amp;lat, "-"); while(tok != NULL) { tok = strsep(&amp;lat, "-"); // Once it got to the "DDD.D" part of the string it would segfault } I fixed this by doing `char *tempStr = strcat(&amp;lat, "-");`, thus adding a delimiter at the end of the string. The reason I don't want to make `lat` an array is because the function I'm trying to make doesn't pass an array, but a `char*`. I didn't want to post the thing I was working on, but it basically looks roughly like this. void parse(char *lat) // Where lat is a string separate by "-" { char *tempStr = strcat(lat, "-"); // The string being passed normally produces a segfault, but I fix it by adding an extra "-" at the end of the string char *tok; tok = strsep(&amp;tempStr, "-"); while(tok != NULL) { tok = strsep(&amp;tempStr, "-"); } } We're never actually going to use the `strdup()` function anywhere in the program. I was just trying to make `lat` into a `char*` in my original problem, because that's what my function was taking as input. 
if you want to do automation, and you are on linux, you can use BASH scripting for that. you might be able to automate with another language (maybe utilizing system calls etc.) but i think BASH is pretty neat for automating repeated task or batch file processing. I dunno on windows tho, maybe you can use the batch scripting? if you want to learn programming in general yes, then pick C or C++! my first language is C and as said by deman1027, learning other programming language is a breeze. except haskell (or functional programming in general), fuck those.
you dont need else if on line 27, just put if ( (numbers[i] % 2 != 0) &amp;&amp; (numprinted&lt;19) ){ on line 24 and add the numprinted++ after line 25 same method for func #3
When you write something like : ` doSomething(); while(condition){ doSomething(); } ` Maybe I'm mistaken but I think it is the same thing as do{ doSomething(); } while(condition) ` So if I'm not wrong, this is syntactic sugar as the foreach loop of C# as been called a syntactic sugar. And by "optimized" I wanna know if there is a difference for the compiler or if it produces the exact same micro-instructions for both. If it does, it is just syntactic sugar. 
They're not the same. A do while loop performs the contents of the loop at least once, where a while loop may perform it exactly zero times.
Yes I know that. But if you write exactly the same instructions above the while loop than into the while loop you have the same functionality as a do while loop, don't you? 
Yes.
So I'm asking, how is it more than just syntactic sugar for just that. Given that other languages have not this do while loop, could it be that the C compiler knows how to optimize it somehow? 
If I were you, I'd go to r/learnprogramming 
This is the output i get from function 2 when I remove the else. For some reason, it's still not counting numbers correctly. Driving me nuts since it's the same method as used in the first function, but refuses to cooperate. Strangely, the third function prints uniformly, with 10 numbers per line instead of 20, using the exact same formatting code. 479-665 269-501 763-591 869-843 683 497 -565-115-585 23 389 973-573 193-815 179 -381-807-111-515 281-675-865-807-213 887 433-501 493-985 77-219 883 343 649 151-561 763-825 737-267 601 -75 421-639 209 719 37 913-795 973-515-129 317 223 667 269-327-245 -15-915 221-745 -55-687 787 419-933 751 169-255 247-651-999 307 941 301-745-879-385-561 461-395-933-117 ...etc. 
For example I know GCC is able to optimize for loops by predicting the number of iterations. So it is not syntactic sugar for a while loop with a counter initialized before and incremented at the end of the loop. 
Here's a site where you can write program solutions for math-based questions if you want: https://projecteuler.net/
can you put space after %4d to make the formatting better, and what is that dash? i think my first solution, which move some lines of codes is the right one, it is because if you just delete the else, the numberprinted will be incremented no matter what (as long as it is &lt;19 that is).
You also might check out node.js. You can write JavaScript code to make dynamic web applications.
I got it figured out...thank you
Note that a do-while-loop is essential for other syntatic sugar in function-like macros. See https://stackoverflow.com/questions/257418/do-while-0-what-is-it-good-for
It's not syntactic sugar, it's just ... well, syntax. You are correct that in your example, the two ways are indeed identicial (they probably even produce the same assembly). It's just two different ways of writing the same thing. The reason other languages don't have a do while loop is because those language designers didn't add it to their languages. Probably because a do while loop isn't terribly useful in the first place.
If the foreach loop in C# has been considered syntactic sugar for a for loop and a for loop is not considered syntactic sugar because it is optimized by the compiler, I have reasons to believe that the do..while loop is either syntactic sugar either 'just syntax' because it is compiled differently. 
Thanks I didn't know that. So in that specific example, it means the compiler is interpreting the do while loop as a curly bracket block where it wouldn't work in another way? Does that mean it could also be different for my previous example? ' doSomething(); while(condition){ doSomething(); } ` Being different to : ` do{ doSomething() ; } while(condition) `
&gt; So in that specific example, it means the compiler is interpreting the do while loop as a curly bracket block where it wouldn't work in another way? Yeahnope. The do-while basically serves as a block here, but the only reason it is used instead of a while-loop is a grammatical one: do-while-loops end with a semicolon.
Simon Allardice did a really good beginners course, you can find it [here](https://www.lynda.com/Programming-Foundations-tutorials/Foundations-Programming-Fundamentals/83603-2.html) The course is great in my opinion because it just talks about the general concepts of programming without being specifically about a certain language. You learn the concepts of how the most common features of a programming languages work and then you can go on your route and learn the actual syntax (which pretty much means grammar) and nuances for the language you decide to go for. Lynda costs money but I think there's a free week (or trial) if you're new to it. After that, I hear Python is meant to be great for automation. I've heard a lot about a book called "Automate the Boring Stuff with Python" which might interest you! Finally, when you say "Can you use programming to...." The answer is pretty much always "yes" - It just depends what language you choose and how far you wish to go. Everything you do on a computer had to be programmed by someone!
Yes. Reading other people's code is also helpful.
I understand that hope but I think this'd not be the right way, simply because we need this kind of security. If it were simpler, we wouldn't have it.
&gt; Any function that says it will create a C string WILL put a '\0' at the end of the string. &gt; Any function that you give the size of your buffer to WILL NOT write past the end of the buffer. strncpy is the exception to these rules. It's almost useless.
Not sure why folks have down-voted, because you're right; the meaning of each is right there under "Naming Conventions". Took me all of 30 seconds to find.
I don't know if I totally grok what you're asking me here, but to me your comment boils down to one question: Is do-while snytactic sugar or *just* syntax and/or what's the difference between snytactic sugar and syntax, ie. does the compiler treat them differently? Syntactic sugar by definition is syntax, that makes a thing; which can already be written in "normal" syntax; easier or more convenient to express in code. So yeah, do-while can be considered syntactic sugar around a simple while-loop, or for-loop at least. Answering the compiler part: No, the compiler does not treat them differently. In fact, the compiler doesn't know anything about syntactic sugar. Syntactic sugar is a term that is only relevant to programmers, not compilers. All a compiler sees is syntax; it has no concept of syntactic sugar. Let me know if I did or did-not completely miss your point.
If you're interested in starting with C then I recommend "C Programming: A Modern Approach" second edition by K.N. King. There's 100s of exercises and small programming projects at the end of each chapter that really help drive home what you've learned. Python is another great choice.
Yes, thank you, that's what I was wondering about. I was making a maybe a bit too implied difference between 'syntax' and 'syntactic sugar', I can elaborate : I know that a for loop is optimized by a compiler, it is not only a wrapping around a while loop. Since the compiler is able to predict accurately the number of iterations, it can optimize the number of registers used by the micro-instructions for instance. Since it is not the same thing at a micro-instruction level, I call that "proper syntax". Foreach (in C#), on the other hand, does not implies an optimization at compile time, or so I've been told. So I call that "syntactic sugar", i.e. something that allows the programmer to write in a less wordly way something that would be completely equivalent at a micro-instructions level. So according to what you are saying I would fit the do .. while loop in syntactic sugar, even if I acknoledge the utility to be able to write source with less characters, of course. Maybe I phrased my question incorrectly at first. Sorry if it was the case, I am not a native English speaker and even in my mother tongue I had trouble to express this question to my professor.
I'd throw my hat into the ring with two, perhaps here counter-cultural, suggestions. If you have zero programming experience, have a play with MIT's scratch. It's made for kids but I've found it helpful teaching people the basics of procedural code execution and structured programming. Secondly, have a look at javascript. It's an ugly language with many warts and may even give some bad habits, but you can show your friends what you make and can make interactive things that you can see from the get go. Never underestimate such things for motivation and ability to inspire work!
If so that is too sad. To get things right we need to add complexity.what boring years it will be for programmers!
I did read almost all answers cant remember it anymore! haha
Stripping symbols won't help if the program is flashed onto a microcontroller.
As I said, it's not so much complexity in as that you should have thought about those things you now would need to specify explicitly anyway (imho). Also, programming itself is cool but just a tool, CS is where the interesting stuff is :)
Well, that's embarrassing. Thanks for the help!
In gcc ((Rev1, Built by MSYS2 project) 7.2.0) there is [`-Wformat-signedness` (use with `-Wformat`)](https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html): $ gcc -Wformat -Wformat-signedness ryanlue.c ryanlue.c: In function 'main': ryanlue.c:11:21: warning: format '%d' expects argument of type 'int', but argument 2 has type 'unsigned int' [-Wformat=] printf("INT: %d\n", y); ~^ %d ryanlue.c:11:21: warning: format '%d' expects argument of type 'int', but argument 2 has type 'unsigned int' [-Wformat=] printf("INT: %d\n", y); ~^ %d ryanlue.c:12:22: warning: format '%ld' expects argument of type 'long int', but argument 2 has type 'long unsigned int' [-Wformat=] printf("LONG: %ld\n", z); ~~^ %ld ryanlue.c:12:22: warning: format '%ld' expects argument of type 'long int', but argument 2 has type 'long unsigned int' [-Wformat=] printf("LONG: %ld\n", z); ~~^ %ld `-Wall` includes `-Wformat`, but neither `-Wextra` or any of them includes `-Wformat-signedness`. [It seems clang doesn't support it.](https://clang.llvm.org/docs/DiagnosticsReference.html#wformat)
You could look into a draft of the standard, which is AFAIK free to look at: http://port70.net/~nsz/c/c99/n1256.html#7.19.6.1p8 However I think it is easier to look in some other resource because they are usually easier to read, especially when checking something quickly.
thank you your co-operation
Ive read most source code of these Rust apps https://lists.fedoraproject.org/archives/list/devel@lists.fedoraproject.org/thread/D7PYBU7JKGLRYR2HKRXBM6EGZZEDCK33/
`getchar` returns the character that was typed. If you type `0`, the character returned is `'0'` (the character “0”). This character has value 48 in the common ASCII character set, which is different from the value 0 you want. By subtracting `'0'` from the character you got, you get the actual numerical value. This is possible because C guarantees that the characters representing digits are arranged right next to each other.
These things happen :-) I've overlooked my fair share as well. Comes with being human.
By that argument, aren't all loops just "syntactic sugar", when you could just use labels and gotos instead? At some point you have to acknowledge that language features are there to make programming easier. A do { } while() loop does have uses. I've often even seen stuff like this: do{ int err = stuff(); if (err) break; err = morestuff(); if (err) break; } while(0); /* Clean up goes here */ This lets you have one exit point from your function, and handle all the cleanup in one place, without using GOTO. Note, I'm not advocating FOR this programming style, just acknowledging that it exists and has it's purposes. 
IIRC there was something about for-each loops in C++ that makes them (potentially) faster than traditional for-loop-iterations. So they are far from being “only syntactic sugar”.
&gt; if the variable c is already the integer with the same value as the array position that needs to be modified. It does not contain such a value. I think you might be getting confused because `getchar()` returns `int`. But that does not mean it converts the character input. It returns a character value, represented in the wider `int` type. This is common across the standard library because it allows for signaling conditions like the end of file condition by using a signaling value that cannot be mistaken for any valid character value, and to do that you must use a type that can represent more values than `char` can. Anyway, the character '0' is what `getchar()` returns, and that character does not have the numerical value zero. Its value depends on the character encoding in use, but that's almost certainly ASCII, in which case the character '0' has a value of 48. The subtraction is necessary to get rid of that offset and turn the character value into a valid index into the array. 
What why dont the enters show up 
Because you need to put four blanks in front of every line of code. `␣` is not a blank, it's just something I use to visualize how much space you need to insert. For each `␣`, hit the space bar once. You also need to leave one free line between your code and the surrounding text. Also, do not put backticks around code formatted with four blanks, you can't use both methods at the same time. Click “edit” to fix your post.
Might as well use `goto` in that situation, IMO. It's much clearer.
Ok TNX 
Because there's minimal safety and maximum accountability for the programmer. Programming in C has a MacGyver feel to it, like I can create a laser with a rubber band, a staple and packing peanuts.
Your formatting is still wrong. Put four blanks in front of every line of code. 
From what i can tell, it looks like this is more of what i'm after, thanks! My only thoughts are, does this take into account tabs? My instructor says that the book's content will include either a space, tab, or newline between each pair of two consecutive words.
How should that help?
You can't have strings and integers in the same array, so you will need to create a separate array for the words: char words[4][3] = {"USD", "CAD", "EUR", "GBP"};
I think gcc can do the same optimization if you write a while loop, but I had to check. The reason why both `while` and `do ... while` exist is that the former requires either duplicate code or a jump for the initial test, whereas the latter form can do without. Compilers back in the day weren't smart, so if you wanted to program a loop that is guaranteed to execute at least once, there wasn't a way to get rid of that extra jump without a special loop construct. For reference, here is how `do X; while (Y);` is typically implemented: begin: X; if (Y) goto begin; and here are the two ways you can implement `while(X) Y;`: /* first way */ goto test; begin: Y; test: if (X) goto begin; /* second way */ begin: if (!X) goto end; Y; goto begin; end: ; The first way is faster but requires the compiler to remember `X` while compiling the loop so it can defer generating the code for `X` while processing the loop body. Compilers back in the day generally couldn't do such a thing, so they used the second way which allows them to immediately emit the code for `X` when they see the loop header. This is much easier to implement, especially if your compiler is a one-pass compiler like most early C compilers.
But plenty of "secure coding standards" don't allow GOTO...... for better or worse. 
ICU is a gargantuan pain in the ass, and about 500 times too big.
So what parts of ICU should we add to the C standard and what parts should we leave out? I propose that regardless of what part we add, Unicode support will be incomplete to the degree where you are probably going to need ICU anyway for serious projects that do Unicode specific things. If you don't care about Unicode specifically but just want support for multi-byte characters, there is already quite good tooling for that in the standard with locale support and all that stuff.
I'd rather recomm the Rust book, it's a nice resource
You appear to be shadow banned. Please talk to the admins to rectify this issue.
I can see this post, but not this user`s profile.
All loops are syntactic sugar for an `if` and a `goto` or two.
You are *way* overthinking this. Learn the language first, and learn it well. Worry about compilers later. They are an incredibly complex subject.
Thanks that was the sort of stuff I wanted to know
Yes I agree with you. But my question originated with the knowledge that a for loop *can* be optimized at compiling time, so I wondered, why not a do..while loop ? 
Those coding standards don't allow `break` either. The rule can be summarized as “only one exit from any block or function”, and the only way to exit a loop is by falsifying the loop condition. When working under those constraints, you generally end up with something like this made-up example: fd = open(path, O_RDONLY); if (fd &gt;= 0) { buf = malloc(1024); if (buf != NULL) { rsz = read(fd, buf, 1024); if (rsz &gt; 0) { process(buf, rsz); } else { perror("read()"); } free(buf); } else { perror("malloc()"); } close(fd); } else { perror("open()"); } This has the (possibly intentional) side effect of encouraging you to write short, simple functions.
Yes that's precisely my point. 
But I already learned it and I understand the difference between the loops, I've used them etc. I'm interested in compilers and assembly code now and I'm asking questions about that. It is written in the question. 
I manually approved his post, that's why you can see it. His profile is invisible which is a strong sign of something being wrong with his account.
but then how would you use them as lables 
https://gitlab.com/oldgaro/dots/blob/master/learning/rust/hello.rs
Ah well, but not "random" Rust repos ;)
**Classic Texts:** * [Compilers: Principles, Techniques, and Tools](https://www.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811) known as the dragon book, a historical book that covers the content very well. * [Modern Compiler Implementation in ML](https://www.amazon.ca/Modern-Compiler-Implementation-Andrew-Appel/dp/0521607647) which is another fantastic piece of literature. There is a version in C, but the code examples are subpar compared to ML. **"Modern" Texts:** * [Crafting a compiler with C](https://www.amazon.ca/Crafting-Compiler-Charles-N-Fischer/dp/0805321667) I haven't personally read this book but I've heard good things. * [Engineering a compiler](https://www.amazon.com/Engineering-Compiler-Keith-Cooper/dp/012088478X) I found this resource to be quite good in school. It covers all the important information and has some nice figures. * [Modern Compiler Design](https://www.amazon.ca/Modern-Compiler-Design-Dick-Grune/dp/1461446988) Again, I haven't read this book but colleagues in compiler research enjoyed it. That ought to cover enough readings for you ;)
For getting an introduction into automata and languages (the theoretic part of building a compiler) [Introduction to Automata Theory, Languages, and Computation](https://en.wikipedia.org/wiki/Introduction_to_Automata_Theory,_Languages,_and_Computation). For building an actual compiler obviously the best choice is the infamous dragon book: [Compilers: Principles, Techniques, and Tools](https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools). Some people go straight up for the dragon book but honestly I would recommend you to read the first one before digging through the dragon book. It serves as a very well-written tutorial, and it has almost zero prerequisites for studying it.
**Introduction to Automata Theory, Languages, and Computation** Introduction to Automata Theory, Languages, and Computation is an influential computer science textbook by John Hopcroft and Jeffrey Ullman on formal languages and the theory of computation. Rajeev Motwani contributed to the 2000, and later, edition. *** **Compilers: Principles, Techniques, and Tools** Compilers: Principles, Techniques, and Tools is a computer science textbook by Alfred V. Aho, Monica S. Lam, Ravi Sethi, and Jeffrey D. Ullman about compiler construction. First published in 1986, it is widely regarded as the classic definitive compiler technology text. It is affectionately known as the Dragon Book to a generation of computer scientists as its cover depicts a knight and a dragon in battle, a metaphor for conquering complexity. This name can also refer to Aho and Ullman's older Principles of Compiler Design. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
I can tell that you know C. I can also tell that you don't know it nearly as well as you think you do.
Even though I used project Euler before with C, I feel like most of the solutions rely more on mathematic and algorithmic knowledge than language knowledge. 
Anything can be optimized at compile time. C has a million different ways to do lots of tasks - but that doesn't mean that one of them has no benefit. a do { } while loop is often used when you need the loop to execute at least once, or when the condition you need to loop on is generated inside the loop. While you could put the code in the loop outside of it, and then do a normal while loop, you're duplicating code and introducing complexity and an opportunity for someone to mess things up later. For example: do { /* Ask the user for input or something */ value = parseAthing(); /* Do something with value */ } while( value!= 0 ); This saves you from having to preinitialize 'value'. It is more efficient. Generally, you should use the loop construct that most closely matches what you're trying to do. Optimize the algorithm, not the implementation. Optimizing and choosing which assembler constructs are best is up to the compiler. Why don't you make a few simple test programs that do things in a few different ways, and compare the generated assembler code? Which construct is most efficient? Does changing the compiler flags affect anything? Does the compiler sometimes turn different loops into the same code? 
And you are not answering a question I'm asking so what use is your comment exactly? I'm interested in a question and the only input you bring is some comptent. How is that helpful at all? I never said I was a C programming jedi, I asked a question somewhat simple and others tried to provide an answer. How are you in *any* way useful to this thread with this kind of input? 
I did not know I could read the compuled assembly code. Do I just cat the files.o? 
It depends on your compiler. If you're using gcc, you can look at it by asking GCC to output assembly: gcc -S test.c You can also disassemble the .o file using a disassembler of your choice. 
Thanks I'll try that right away. 
In your opinion, how does the first book compare to Sipser?
never reuse variables and always put them into the smallest possible scope. Since C has no RAII, I don't see any benefit in creating a new scope block like that though 
I am adding that term to my own lexicon.
This is more common in C++, where you're specifically using the lifetime of a variable to designate when a destructor should be called, but it's totally fine to use in C as well, and has many advantages. In fact, there's been a push in various languages to encourage limiting the scope of variables just to where they're needed. For example, in C99 the loop counter can be declared as part of the `for` loop, and only exists within that loop. &gt; I could/(should?) just have a number of reusable global variables, whats the pro's and con's Did you really mean "global variables" or just local variables with a larger scope? Global variables are still a no-no, of course. I'll start with some cons: * Clutter. Each scope adds more vertical space and complexity to keep track of. * It can be code smell when overused. It's very possible that these portions should be pulled out into their own function. But the pros: * Variables are declared where they're used. You don't have to look around for how they're declared, and there's less chance of new code stomping on a value you were relying on. * Fewer uninitialized variables. You declare when they're used, often initializing at the same time. * Variables are more likely to be named appropriately. Rather than reusing the same temporary for multiple purposes, you name each one for it's specific purpose. * Fewer variables for the programmer to track for any specific bit of code. Notice this conflicts with a con: there's a tradeoff in complexity you'll have to weigh. &gt; I assume what is happening is the variables in the block are just allocated on the stack for the life time of the block, is this correct ? I'm also assuming that this should be fairly quick too? Not necessarily. The compiler could allocate stack space for them along with all the other local variables. It could even reuse that same space with other local variables that don't overlap in lifespan. But yes, this is very quick. Even if it did allocate for just that one block, it's just adding a constant to the stack pointer two times.
Thank you for your opinion!
Submit a bug report!
I haven't read all of Sipser's book but they cover similar topics. It does seem though that Sipser's would be used as a complement for a college class. Ullman's book has great value on its own, in that it can be used standalone to learn about that stuff.
The dimensions of your arrays are off if you want to treat it as an array as strings.
I figured I should post it. There are some things that may be a little tricky like performing arithmetic on extremely large numbers. Simply writing programs helps, and if you like math, this is a good place to go.
Do you really want a return inside your loops? The way it is now you only print out one line. And double check the dimensions of your size array. It doesn't match up with how you initialize it.
Interesting, thanks for your input! If I may ask, what makes you say that Sipser seems more complementary to a course rather than standalone reading? For background, I'm actually reading Sipser's book at the moment. I didn't put much research into buying it though - I happened to find a copy for $8 at a book store and couldn't pass that deal up. So I'm curious how it compares to others. I am enjoying it though, and it's been fairly easy to find explanations and answers online to any questions I've had. 
Should be a `char[4][4]` to include the null terminator, right?
 old= ptr[i]-&gt;age; young = ptr[i]-&gt;age; Don't remember the highest and lowest age. Remember the index where you found the highest and lowest age. Then you can directly print the name. 
I haven't compiled this and there could be errors, but to the best of my recollection what you want is something like: int rates [5][3] = {{1,2,3},{4,5,6},{7,8,9},{10,11,12}}; char words[4][4] = {"USD", "CAD", "EUR", "GBP"}; int main() { for (int i = 0; i &lt; 5; ++ i) { printf("%s", words[i]); for (int j = 0; j &lt; 3; ++ j) { printf("%4d", rates[i][j]); } printf("\n"); } return 0; }
Yup.
Sorry for the incompetence, but how do you reach that index when its from a loop?
If `old` is the index where you found the highest age then you would do printf("The oldest person is %d and is called %s",ptr[old]-&gt;age, ptr[old]-&gt;name); (`ptr` is a poor name for an array of people. use `people` or `students` perhaps) 
The C version of the Appel book is _dreadful_. However, Maegan Kaufman have also published quite a few really good books in this area. I second the recommendation of Grune's work.
Somewhat confusingly, '0' is also an int.
Oh no I was just wondering if you're initializing that way why not set it as const just as a general question, not as part of the standard or anything.
You can't point it to a specific file, but the folder. also, you include header paths with -I, -L is for linking libraries. You can remember it this way. I = Include L = Library
lmao
 for (uint64_t YoungestStudent; YoungestStudent &lt; NumElementsInArray; YoungestStudent++) { }
There is also the fact that I'm some algorithms you don't know if you need to loop until you have processed the current item.
No. Also, you can't declare anything inside a struct. your struct should be typedef struct position Position; struct Snake { Position *Body; } InitSnake() { struct Snake *Snake1 = malloc(sizeof(struct Snake)); if (Snake == NULL) { // Log the error } else { Snake.Body = malloc(sizeof(Position)); } } (I haven't tried compiling this, you may need to switch the dot operator with the `-&gt;` one).
My professor recommended exactly this. Sipser for a college course, and Hopcroft and Ullman for independent study.
* [Let's Build a Compiler, by Jack Crenshaw](https://compilers.iecc.com/crenshaw/) This is in Pascal, but I think it's still quite helpful from a conceptual standpoint. * [Let's Build a Simple Interpreter](https://ruslanspivak.com/lsbasi-part1/) Again, not C but Python, but again, I still think it is useful. Also it's an interpreter rather than a proper compiler, but a lot of the principles are still the same, except instead of emitting assembly/machine code the interpreter emits bytecode or just executes the program itself.
It is a little hard to suggest topics if your introduction to C programming was in your OS course. Usually, OS is taught after people have a strong handle on C simply because a lot of the kernel needs it. That said, you can look at CMU's OS course (15-410) which has a series of 5 projects (writing a multithreaded, preemptive kernel being one of them). You can choose one that you're comfortable with. There are other OS courses too (MIT's xv6/JOS, NachOS etc.) but CMU's the one I'm most familiar with. I would suggest picking something which interacts with the hardware (try writing keyboard/console/timer drivers for x86 which you can emulate on QEMU) or having something to do with concurrency (eg. writing a userspace thread library is good practice for that).
Took a little break and got back at it, now it works. Thank you!!
A reference to the element? Do you mean a pointer? C doesn't have references.
yes exactly
I will read the dragon book first, then follow with the modern texts. Thanks for the suggestions!
Thank you very much, automata theory is something I have heard of but never digged into as well. Should be interesting!
No problem! Id recommend it for historical purposes but Apple's book is probably better overall.
I don't understand the input file format at all, or how you get from that to the output. So I can only give very generic information and hope that it's right and helps you. &gt; I need to create two different structure arrays but I have no idea how. Something like... struct pirate pirate_data[NUM_PIRATES]; struct map map_data[SIZE_X][SIZE_Y]; &gt; I tried using for loops and 2d arrays but it doesn't work. What does "it doesn't work" mean? Your code didn't compile? You got the wrong results? The program crashed? The program hung? Most importantly, can we see your code as you have it right now?
To further bring down your point in case anyone still doesn't get it. In ASCII the character '0' is the representation of the integer 48, '1' is the number 49, '2' is 50, etc. So if you read an input from user and he types "3321" that is NOT read as a number, that is read as one ASCII character at a time(which is how most input is read, either as single chars at a time or strings). So to figure out what **int** the **char** '3' is, you do the math ndigit[51-48] which is ndigit[3] and that gets incremented by 1.
Thank you I’ll try that. But how would I scanf it? 
No it's not, its a char. Don't confuse the data type **int** with integer numbers. The **char** type is much smaller in capacity than an **int** is, and it's used to carry character representation of numbers (ie. ASCII). 
It's hard to say without understanding the input file better. But you would do something like `fscanf("%d", &amp;map_data[i][j].sand)` inside a loop. If it helps, do two or more numbers at once with `fscanf("%d %d", &amp;map_data[i][j].sand, &amp;map_data[i][j].treasure)`. 
Thank you that helps a lot!
Client and data server that communicate might be a little too small but you could expand upon it
As a hobbyist myself, I'd suggest having a goal first. Pick something you'd like to do then learn how to get there with what language you think would be best for the job. Why buy a car if you've nowhere to go? 
In my code, the arrays are constant, but this isn't related to the warning, so I left it out.
Im just starting to learn C, and my ultimate goal is to write a compiler so this is some potentially great info for me thanks!
The write up was informative, but what is the intended audience and what do you expect them to take away from this? This reads like a 100-200 university level instruction where compiler writing is typically a 400-level type course. Don't get me wrong, this is well written, but it also feels a bit mixed with programming tutorial in general because the concept of registers, stack, memory layout, etc. are not included. Will those concepts be introduced in a later update or is that not the right audience?
Oh ok i do that too here. I just thought there was some hidden detail about const or static or something i didnt know.
The goal of writing a compiler is fine, but writing a C compiler isn't a very interesting goal I think. Maybe you should focus on a C-like language of your own invention given that (i.e. C) is your thing. C has "stood the test of time", but it isn't a good language, and its standard definition is full of subtleties which will lead to a lot of effort to get right and won't give you much insight on compiler writing (though it'll show how painful it is to give a "satisfactory" standard definition for a language).
sigwait() pauses at that point in code. the thread is on hold. another process or thread czn send a signal SIGUSR2 to the thread/process which will release that pause and resume execution after sigwait()
please message me if anyone knows how to deal with signals
yes but how would a signal be sent to release the thread
how are signals sent?
from CLI `kill -SIGUSR2 pid` or `kill -12 pid` or `kill -s USR2 pid` in code `kill(pid, SIGUSR2)` or `pthread_kill(threadid, SIGUSR2)` 
This is just one process, multithreaded though.
https://gist.github.com/RobertBedrosian/3e2f39726b5926f7100e744832610e83 -scheduler.c https://gist.github.com/RobertBedrosian/7f4a81bb8805bbf0a1d750089ebef9b9 - scheduler.h https://gist.github.com/RobertBedrosian/fc35b366febca453e21debf564fafdca - worker.c This is more or less the main project minus list.c and list.h and worker.h, list taking care of how the queue is implemented. The main thing i dont understand is what is going on in setup_sig_handlers in schedluer.c and why are we blocking sigalrm and sigusr2 and unblocking sigusr1 and sigterm in worker.c. It looks like i would be able to use cancel_thread() to kill a thread however it doesnt look like its passing a signal.
You could try to port an RTOS (such as contiki) to an ARM based microcontroller and use it to control some external peripherals (or read some sensors). Shouldn't be too hard with all the examples available and you'll be real close to hardware.
The date on your Reddit post would surely disprove charges of plagiarism, no?
You stand a better chance of getting help if you clearly explain where you are stuck, what you tried and why that didn't work.
Because I'm a hard guy.
You should show your actual code, and all of it, not bits and pieces of something like it.
That is actually all the code (some fprintfs apart, and as I said the error checking which doesn't matter with my problem). The client part is not coded by me and supposed to work well.
There are a bunch of what I assume are typos in that, no error checking (which *is* important), uninitialized variables... it's a mess. Show your real, compilable, code so we can actually help. 
Your time_difference() takes *pointers* to struct timespecs but you're trying to call it with struct timespec arguments.
https://pastebin.com/VdY15GQc This is the full main, with the auxiliar function. Didn't change the language to english, hope it's still understandable.
That's not all your code! What is HOST_SERVIDOR? Are you really supposed to be writing the port number out to that file as a binary representation and not as human readable text like most people would expect? Where's the client side code that presumably reads the file so we can tell what format it's supposed to be? Show **all** your code. It saves so much time and trouble instead of having to pry it out in bits and pieces. You need to check recvfrom()'s return value for errors. And you need to initialize lengthtu...
oh yeah, i forgot about that, i should have left a comment for myself lol. however even if i change inital to a pointer, i was still getting an error for info-&gt;suspend_time. Wouldnt it also have to be a const?
I'm not confused at all. You can check for yourself. Look at section 6.4.4.4 item 10 of the ISO C standard (I'm looking at the 1989 version): &gt; *Description* &gt; 2 An integer character constant is a sequence of one of more multibyte characters enclosed in single-quites, as in `'x'`. A wide character constant is [...] &gt; *Semantics* &gt; 10 An integer character constant has type `int`.
Update the gist or put the new code here.
I am currently working on a functional prototype (after putting together a quick proof of concept in Python couple of weeks ago) of a computer vision idea I have had for some months. Basically I use the IUP framework to quickly put together a testing UI (best GUI framework ever and their LED format is fantastic), OpenCV for the CV algorithms, some hacks for webcam access, Win32-specific bits (like threads) etc. Everything in 1 source file until I have something that I can easily start extracting modules.
i understand, i will make update soon with my current code and explain what is happening and what i want to accomplish
But in Rust the `;` serves an additional purpose: You can write eg. ``` fn five() -&gt; u8 { return 5; ``` equivalently as ``` fn five() -&gt; u8 { 5 } ``` Because a trailing expression works just as fine. There are better upsides to this than just that, but it's a good MWE.
Professionally I write custom in-house data reduction and data processing tools in C to support analysts. Using C lets me be precise with memory usage — I especially love memory mapping data — and performance, important for huge datasets. I also do research in [compiler-based binary diversification](http://skeeto.s3.amazonaws.com/share/p15-coffman.pdf) of C (and sometimes C++). Essentially the compiler makes certain decisions randomly, and each installation gets its own variant. We're finishing up another paper to be published next year. In the past year in my own time: * A couple of crypto tools: [Enchive](https://github.com/skeeto/enchive) and [Blowpipe](http://nullprogram.com/blog/2017/09/15/) (just a toy) * Experiments with [closures](http://nullprogram.com/blog/2017/01/08/), [control flow guard](http://nullprogram.com/blog/2017/01/21/), and [branchless UTF-8 decoding](http://nullprogram.com/blog/2017/10/06/) * [Evaluated some PRNGs](http://nullprogram.com/blog/2017/09/21/) written in C. * Experiments with video [processing](http://nullprogram.com/blog/2017/07/02/) and [rendering](http://nullprogram.com/blog/2017/11/03/O). * Wrote a couple of board games engines and AIs [based on Monte Carlo tree search](http://nullprogram.com/blog/2017/04/27/). 
Today I'm going to try and port my [Discrete Hartley Transform](https://en.wikipedia.org/wiki/Discrete_Hartley_transform) to both an [ATMega328](http://www.microchip.com/wwwproducts/en/ATmega328) and a [PIC16F688](http://www.microchip.com/wwwproducts/en/PIC16F688)
**Discrete Hartley transform** A discrete Hartley transform (DHT) is a Fourier-related transform of discrete, periodic data similar to the discrete Fourier transform (DFT), with analogous applications in signal processing and related fields. Its main distinction from the DFT is that it transforms real inputs to real outputs, with no intrinsic involvement of complex numbers. Just as the DFT is the discrete analogue of the continuous Fourier transform (FT), the DHT is the discrete analogue of the continuous Hartley transform (HT), introduced by Ralph V. L. Hartley in 1942. Because there are fast algorithms for the DHT analogous to the fast Fourier transform (FFT), the DHT was originally proposed by Ronald N. Bracewell in 1983 as a more efficient computational tool in the common case where the data are purely real. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Today I'm working on a high level assembler/asm-language I can use as a generic compiler back end. Plain ANSI C11.
It's a bit hard to relate your comment to /u/theboxingfox's as you only name the authors which he left out.
To the mod team - this would be a nice sticky to have once a week or something. I really like the idea of seeing what other people are working on to perhaps give me some inspiration in my own personal projects etc. I'm sure there are other people aligned with this notion too. 
I use C to write extension for Python programs that need to run fast :) The C API of Python is really simple and well documented, and it is so enjoyable to have program that run as fast as C with a Python API !
I love C, but for the sake of argument. Keywords greatly simplify language grammar. Moreover C has so many syntax quirks, like: 1. Function types typedef void(*baz)(void); void foo(void(*bar)(void)); 2. Pointers which are attached to the variable rather than type int* a, b; // it is really not what it looks like int * a, b; // nope still not there int *a, b; // makes some sense 3. In fact throwing in arrays, consts, pointers and functions you'll get pretty cryptic type definitions (which are readable, but require some time to figure out). typedef void(*(*foo_f(void(*[])(void)))(void)); typedef void(*foo_arg_f)(void); typedef void*(*foo_ret_f)(void); foo_ret_f foo(foo_arg_f fs[]) { return NULL; } void bar(foo_f f) {} // some code bar(foo); // valid call // sorry I lack fantasy for a more complex example 4. Ambiguity thanks to * foo * bar; // is it foo times bar or bar is a pointer to foo? 5. Niladic looking functions which are not actually niladic void foo(); // this one accepts arbitrary amount of arguments void foo(void); // this one does not accept any arguments 6. Legacy stuff like trigrams and oldstyle function definitions: int foo(a) int a; { return a; } 7. Ugly extended types with optional parts long int a; long a; 8. Weird increments int a = 1; a = a++-++a; a = a+++a; a = -a---++a;
&gt; Do not use -O0 unless you are actually trying to debug a piece of code that the optimizer has mangled beyond recognition. Many common mistakes (especially those relating to uninitialized or unused variables) cannot be detected with the optimizer turned off. I'm curious if you could provide more background on the mechanics behind no optimizations masking uninitialized variable issues? In any case, if you are going to test your code properly it should be tested at various optimization levels; if your code can't produce consistent results with zero optimization or all the (conservative) optimizations than either you have a very bad compiler or (more likely) your code is very bad. Plus, if you can't "detect" an uninitialized variable, your test cases clearly don't have the bare minimum coverage. &gt; Always use -Werror. Thats cute when you are the only developer writing a program from scratch. In reality, it is more important to understand which warnings are more serious and which are just whiny in order to meet budget and deadlines without sacrificing quality. &gt; Some of gcc's sanitizers (especially those enabled by -fsanitize=undefined) can have a serious performance impact. Don't use them when building production binaries. Thank you for clarifying. Standard practice is to turn on the bells and whistles during development then turn them off for the finished product. I personally don't care too much about the performance impacts, but from a security standpoint you really don't want things like detailed stack traces getting printed in the wild. 
I'm going to start writing an "Incremental Reading" program for the console, and eventually hook it up to a UI. I love the Supermemo concept but it is really terrible software and the guy who wrote it is a greedy hermit so I guess I have to write my own. To start: use libcurl to pull a user specified website (Wikipedia article or whatever). Strip the HTML. Display the text, and allow the user move the cursor (with vi-like keybindings) between words, sentences, and paragraphs, and create flashcards and clozures from there. It's my first big project so I'm excited :) if anyone has advice, feel free!
I can understand sticking to C99 due to POSIX. But why purposefully do a build with C89 when there is C11? gcc, clang, and icc have flags that allow you to specify and thus track the standard used. Building with an older standard just limits you. You can get away with this in C because the ABI is so solid but in other languages this is a lot more trouble. 
So I can ignore the right curly brace if a ; is there?
oh, no, you don't have to write the `return` statement, because an expression returns itself. In C this only works for assignments like: a = f() == 6; ie. the comparison expression "returns" a value that is stored in a. The missing brace was a typo
Oh, interesting. I kinda like that Cargo tool. There is one of that for C?
Today I need to write a multipart/form-data handler and maybe try to adapt some sensor fusion code for a different vendor's motion sensors.
Note that C is not a great language for writing compilers, or for learning about writing compilers. It's a great language, but not for that particular use case. If you've never written one before, I would **not** do it in C, even if it's a C compiler. Compilers have a lot of complex tree structures, and memory management becomes a pain. They also have a lot of variable-length strings. A compiler doesn't follow the same patterns as other programs where C shines. I mentioned Rust, OCaml, Go, Swift, or C++ as alternatives here: https://news.ycombinator.com/item?id=15470316 You could even do it in Python or Ruby. The implementation language is independent from the language you're compiling. Note that the C compilers you are likely to be using aren't written in C. Both GCC and Clang/LLVM are written in C++. GCC was written in C, but switched to C++ several years ago. 
Trying to write a Huffman file compressor. C is perfect for memory manipulation and precision. Almost finished with it.
I'm working on my latest pet project, which is a user daemon which listens to DBus signals sent by media players implementing the MPRIS interface, and submits the tracks being played to last.fm, libre.fm and/or listenbrainz.org.
* web scrapers for sites (using gumbo/libcurl) * Web server software for an internal product (using my own homegrown http server stack but I might migrate to libmicrohttpd) * A UI toolkit written in C/Xlib (on hold since October though).
I agree with you. I'd like to see any and all form of discussion and articles over homework questions. In fact ideally it would be nice if homework questions start with a score of -1 and have to be upvoted to be visible.
There've been some approaches but it's mostly to difficult, mostly because of the way C code is processed, specifically using `#include` instead of a module system. This makes it far more difficult for a build system to automatically link things together if needed. Also compile flags are so different amongst compilers etc.
Thanks! 
I'm avoiding C today while working on the Erlang parts of my project. But I'll be using hamlib to interface a a Raspberry Pi to an old Icom PCR-1000 radio receiver. 
[removed]
&gt; I'm curious if you could provide more background on the mechanics behind no optimizations masking uninitialized variable issues? In my experience, compilers avoid doing things like const propagation, variable liveness analysis etc. unless it is going to affect the end product, which it won't if optimizations are turned off. This will mask errors that the compiler would normally catch, such as variables that are initialized by one code path but not another; conversely, it can mask the fact that a variable which is only initialized in a conditional block is also only used in a later conditional block controlled by the same predicate, resulting in a spurious warning. This was particularly annoying with older versions of gcc where the scope of its analysis could depend on the optimization level—so your code might build fine at `O0` and `O2` but generate a spurious warning at `O1`. There are workaround for these things, but they generally involve doing things, like initializing a variable to a dummy value, which might prevent the compiler from noticing an error at *any* optimization level. &gt; In reality, it is more important to understand which warnings are more serious and which are just whiny I have only very rarely encountered warnings that were “just whiny” and did not, in fact, indicate a problem with the code. They are generally the result of using a bad API (such as the POSIX `iov` functions), of programming close to the metal, or of working with input with a fixed layout (such as network packets). Those warnings are so easily fixed that “budget and deadlines” is a crappy excuse not to do so. If you get warnings that require so much work to eliminate that it does in fact impact your budget and deadlines, they are almost certainly indicative of a real and potentially serious problem in the code.
did you initialize m and n?
Network programming, chat server! 
yes 
i only putted the part where i had the prooblem
This sounds super interesting!I have always heard of the FT and was wondering what you plan to do with it? I heard it does something about breaking down waves? Can you explain your project a little more?
i missed copyed
[removed]
Interesting. So there is not any other way to compile Rust code other than Cargo?
Super noob here. I'm trying to solve euler566 but (spoiler) it's hard!! 
I’d argue that if you’re using Java or C# and you don’t understand the memory impacts of what you’re doing, then you’ll never be a good programmer in either language. That to say, the idea that you don’t need to care about memory in languages with garbage collection and very opinionated stack/heap uses is absurd. If you don’t, you’ll never be as effective as someone who does learn it. 
You can manually call `rustc` but this the compiler will try to link everything as specified by your use mostly, the module system makes it quite easy for compilers to do their work
&gt; what you plan to do with it In the ATMega's case it's quite simply to light different LEDs in response to different frequencies within the sound received by a little microphone. It's for a friend's "party bar". As for the PIC, I've been wanting to have my own little spectral analysis toolkit for a long time, and I'm just making use of the opportunity to kill two birds with one stone. &gt; something about breaking down waves Music consists of different sounds. Different sounds are made up from adding a whole bunch of fundamental frequencies of varying strengths. FT is to sound sort of what a prism is to light: it "splits" it up into the things that make up the incoming light/sound. If you are wondering if the process can be reversed (that the "split stuff" can be "recombined" to recover the original), yes it can. Using this technique, one bunch of LEDs can be flashed *only* in response to low (bass) sounds, others flash to mid-tones, and so on. 
Put the arguments into an array and pass the array to the function instead of having a variable number of arguments.
I would probably go with the fixed two digit form, even for all zeros. But it's largely a question of personal taste, so everyone will have a different opinion. Maybe you could look at the Linux kernel for guidance, I'm sure there's numerous examples. 
I also would go for the 0x0x notation, also maybe using enums to have those values with meaningful names instead of hardcoded values.
Thats even cooler than I initially thought. Good luck!
Because fighting for an hour with the borrow checker on seemingly basic code is a pain in the ass?
Or standardizing that management across several? I completely agree that LeftPad is a total joke and telling of what can happen, but a decent recursive package manager that lets you focus on the code is not a bad thing IMO. 
I can understand the pros somewhat but especially for C I prefer it that way. I mean, in the end it's the dev who sets it up and they should be able to install a simple library. But as I'm migrating to Rust rn, I shouldn't speak that loud about this topic...
Good idea. Stickied!
I'm currently researching heuristic search for combination puzzles, extending my [Bachelor thesis](https://opus4.kobv.de/opus4-zib/frontdoor/index/index/docId/6558). You can find the code that was included in the Bachelor thesis [on Github](https://github.com/fuzxxl/24puzzle), but the code I'm currently writing (with some nice improvements) is going to be published when I write a publication about those improvements.
C++ is off topic in this subreddit. Please post C++ questions elsewhere, e.g. to /r/cpp_questions.
I hope you know that Anki is a free alternative in most plataforms, but a terminal app is way cooler imo. Is that what you're aiming at?
There are a number of contexts where build systems like to do something to ensure that a build is reproducible. Some organizations like to be able to verify the reproducibility of a built binary as part of some (internal usually, I suppose) compliance assurance process. Examples: [zero](https://www.ece.cmu.edu/~ganger/712.fall02/papers/p761-thompson.pdf), [one](https://reproducible-builds.org/docs/checksums/), [two](https://wiki.debian.org/ReproducibleBuilds/BuildinfoFiles), [three](https://news.ycombinator.com/item?id=9256844) (showing that build reproducibility is good for build performance, not just assurance). Are there any approaches to diversity that still allow for this kind of assurance check? I also just now came across [David A. Wheeler's related work](https://www.dwheeler.com/trusting-trust/) but haven;t looked at it yet, so I don't know how it related to either your work or build reproducibility. 
Yeah but I want to focus more on the incremental reading part which, last time I checked, anki doesn't do... 
Somewhat surprisingly, you can also use Fourier Transforms to [efficiently multiply large numbers](https://en.wikipedia.org/wiki/Sch%C3%B6nhage%E2%80%93Strassen_algorithm).
Still better, you can do a FT, manipulate the results, reverse the FT and then you've got a modified version of the original sound. I'm not familiar enough with the audio industry to know how extensively this is actually used. Similar transforms are used as the basis for MP3 compression of course, too.
Just reading through K&amp;R (2 chapters left) for the past 4 days, and today I'm also reading comp.lang.c FAQ which is amazing :) Need the knowledge to start working on my thesis, simulation of graphs and finding optimal positions for server placement and other service placements.
That makes sense, never thought of using it that way.
Beautiful - thanks mate!
wow amazing.... all that *today* ;)
The two diversifying compilers I've used and investigated, [Multicompiler](https://github.com/securesystemslab/multicompiler) and [Obfuscator-LLVM](https://github.com/obfuscator-llvm/obfuscator/wiki), allow the PRNG to be seeded from a command line argument. So you could still get reproducible builds by knowing which seed was used for a particular build. It's just one more little piece of information you need for the build. The main strength of diversification is that, for certain classes of vulnerabilities, a single exploit won't work against an entire population, just as a disease not affecting an entire population due to generic variation. In this case, the seed for a particular build isn't necessarily a sensitive value, and it's only important that it varies across installations. You could embed the seed as a piece of metadata, and anyone wanting to validate that build could retrieve the seed as part of reproducing it. However, there is additional value that an attacker targeting a particular build may not be able to construct an exploit without knowing the seed for that build. The binary would be unique to that system, and the exploit may depend on its particulars. One famous exception is [JIT-ROP](https://cs.unc.edu/~fabian/papers/oakland2013.pdf), where the exploit is constructed automatically on the target system using an information disclosure vulnerability, and diversification offers no defense. 
from memory python has a nice FFI and I'm soon going to be using it again... (as an embedded language)
youtube / screenies ?
I interpreted "today" as in "recently." :-)
:-P sorry couldn't resist....
I think someone is going through this thread and downvoting people. I don't know why, but I love hearing about everyone's cool projects. I think we should make it clear that if you don't enjoy someones project don't just downvote it. Downvoting is for if a comment is not constructive, not for if you don't find their project interesting.
No that will only tokenize between spaces. However since your instructor specified there will only be spaces, tabs, and newlines you can take care of tabs quite easily. fgets already handles newlines, so just replace any tabs on each line you read with spaces above the strtok loop.
No that will only tokenize between spaces. However since your instructor specified there will only be spaces, tabs, and newlines you can take care of tabs quite easily. fgets already handles newlines, so just replace any tabs on each line you read with spaces above the strtok loop.
Ah I'm going to start doing it this! I've had it in the back of my mind for a while. We are a Python shop but doesn't mean we can't still have some C goodies
I'm personally writing a page replacement simulator. First I'll be implementing Clock replace for a school project, but ideally I've made it modular enough to be able to implement any page replacement algorithm I like. At home I'm doing some experiments with curses/ncurses, as I've only really used the Stanford Portable Library for any graphics previously. These experiments should grow into some sort of IDE or development tool if all goes well.
its a bit pedantic but the U suffix is also worth remembering... = { 0x0U }; if you really want best practice its good to get into this habbit. 
[Suffix/postfix increment and decrement is done before dereferencing](http://en.cppreference.com/w/c/language/operator_precedence). So this can be rewritten as: *p = *q; /* a[0] = a[1] */ p++; /* was p = a, now p = a+1 */ q--; /* was q = a + 1, now q= a*/
Print out a, and what p and q now point to, and what their offsets from a now are, to get a better idea of what's going on.
Operator precedence dictates that `*p++` is `*(p++)` and `*q--` is `*(q--)`, and since the increment/decrement operators are on the right they have no effect until after the assignment. The assignment itself then is just `*p = *q`, or that the value at p is being written to with the value at q; the list becomes {22, 22, 33}. Then, the increments/decrements come into place by advancing the p pointer and decrementing the q pointer. When it comes to coding style, writing code like `*p++ = *q--` is generally considered bad practice -- such statements can be confusing to wrap one's head around, can often be mis-interpreted, and often just forget that source code is meant for humans (not compilers).
This sounds like quite a complicated exercise to do this on an evening. You should have started sooner, ask your teacher for an extension.
Why not compile it and see?
Interesting.
I know I put it off for way to long. By the looks of it’s gonna be a very busy night and day tomorrow
I'm not sure I understand which part is confusing you, but I believe you are mixing up associativity (left-to-right or right-to-left) and [precedence](https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence). Associativity determines what happens when you have multiple operators with the same precedence. Postfix increment and decrement (`++` and `--`) have higher precedence than the dereference operator `*`, thus associativity doesn't matter. This is not specific to pointer arithmetic. Also note the difference between prefix and postfix operators. `*p++ = *q--` boils down to: 1. `*p = *q` --&gt; `*a = *(a + 1)` --&gt; `a[0] = a[1]` --&gt; `a[0] = 22` 2. `p++` --&gt; `p = a + 1` --&gt; `p = &amp;a[1]` 3. `q--` --&gt; `q = a` --&gt; `q = &amp;a[0]` in that order I recommend you try this for yourself by using stdio to print the value of the variables, e.g. `printf("a = { %d, %d, %d }\np points to a[%td] = %d\nq points to a[%td] = %d", a[0], a[1], a[2], p - a, *p, q - a, *q)`. Play around with parentheses to force a certain precedence.
[removed]
I finally did. I'm wrapping my head around it rn and definitely need to know more about precedence that precedence idea.
ah. ty for the explanation! i did go myself ahead doing the associativity before of the precedence level. preced first!
i finally know. forgot about that; i mixed it up rushing to know getting the where the pointer goes to next. 
All this was assigned for a single night? I agree with the post above me, try for an extension.
Fixed it, thank you!
Perhaps (almost certainly) a ridiculous thing to write in C but this is my very first project in the language. I'm trying write a git prompt that has feature parity with the official git prompt that is written in bash. The reason I picked this as a first project is because I hate how the official git prompt has noticeable lag and I hope by writing it in C it'll be snappier. And I figured this is as good as any old problem to write a program for. It's been interesting learning how to parse the documentation for C libraries (I'm using libgit2) it's a much different experience from Python) I'm also on chapter 13 of C Programming a Modern Approach by K.N. King. https://github.com/Kareeeeem/c_modern_approach
&gt; When it comes to coding style, writing code like *p++ = *q-- is generally considered bad practice Define “generally”, or show me a widely used style guide that disallows or discourages its use. It is an extremely common and easily learned idiom which can greatly improve readability, especially in code that repeats it often, like any sort of text parsing or processing.
Please edit your post and insert four spaces at the start of each line of code.
Tell your professor that FR5 is mislabeled, as it is not a functional requirement :)
sorry about that it's done
Learning C functions! haha
I noticed that too. Sometimes it takes 1 second to load the prompt...terrible! 
oh great, I was after some interesting problems
We really don't have any way to know which parts you *do* know. Have you learned to get input from the user? Have you done file access before? You should at least start by writing out a detailed list of each step you need to accomplish.
I am currently writing a interpreter for a scripting language I made up in plain C. [https://github.com/Mithreindeir/nom](https://github.com/Mithreindeir/nom)
Ooooh, have fun. The day you learn that BNF is an LL-1 grammar is like being able to see the Matrix.
The first two lines contain the actual error you need to fix. It even provides a suggested solution.
It doesn't work after i fix them. The bottom paragraph error is still there and I don't know why.
where is the code?
It varies I write 0's all three ways. In an array initalizer, I would write `0x00` to keep the values aligned.
porting a 32bits to 64 one, so I have much to do because it has a lots structs with size_t members, so many crashes , but whata hell is fun to fix it
Agreed totally, especially if you want to get through code reviews and static analysis for critical applications. I would also add that you should have the number of digits to match the data size.. so 0x0000U for a U16. Its a bit painful for the 0U case in any event.
Is inputString a char[]? You can't compare pointers to chars. Did you mean to write: for (a = 0; inputString[a] != '\0'; ++a)
Wave your magic wand harder!
"Generally" here probably comes more from just what I've seen instead of rigorous study, but I do have a few things to point to: The style guide I have on hand, C Elements of Style by Steve Oualline (which I found a while ago on a quick search involving programming style in C) has a bit in chapter 4 on side effects and the increment/decrement operators, and the value of trying to keep C programs as simplified as possible: "But in C coding, you should do anything you can to simply the program. That means avoiding side effects.", with the example of a side effect being `current = count[index++]`. The increment operator is used throughout the section for examples of subtle issues introduced by such side-effects. If you've played along with Rust for a while, you'll find that it doesn't have the increment/decrement operators. [The short reason given in the FAQ about it](https://www.rust-lang.org/en-US/faq.html#why-doesnt-rust-have-increment-and-decrement-operators) echos the problem of their hidden complexities. I don't have any other explicit mentions of the increment/decrement operator, but from what other sources of coding style I know (like the one documented for Linux) there is heavy emphasis on writing code so simple it can't possibly be wrong. Having cleanly separated out increments/decrements and other side effects seems a pretty natural extension of this, especially when people quite a decent way into the language can have hard times dissecting statements mixing assignments with increments. As you mentioned, there are a few good exceptions where you cannot write a more readable line of code without mixing a `++` into an assignment or a conditional; but, splitting out the increments/decrements by default is a good behavior, avoiding a whole class of bugs without much sacrifice.
I'm writing a small C99 compiler inspired by 8cc. I never learned compilers at school (I'm an EE) so I figured I'll take a shot at that. I'm also writing a hobby kernel for x86 and playing with hypervisors on Intel VT-x.
Why does this matter?
 I'm working on a program for DIY hobbyist CNC toolpath generation directly from image input - obviating the need for dealing in models and conventional CAM software. It's written in C99 using SDL2 for platform abstraction and renders with OpenGL 3.0 compatibility context - specifically so that I could be lazy and use its bastardized GL pipeline with fixed-functionality and built-in projection/modelview matrices while also being able to use VBOs for faster rendering. I really didn't want to have to designate a vertex/fragment shader pair for every single thing I drew on the screen with this project as focus has been the novel algorithms I devised for a variety of toolpaths to be generated. I'm currently working on generating labyrinth maze-like toolpaths, as a sort of space-filling curve, purely to serve end-users as an artistic alternative to boring parallel toolpaths for surface contouring and as a feature to include as a selling point. I've been tweeting updates about its development http://www.twitter.com/BITPHORIA/ Most of the project's code is all there and there's just a few things to finish like this maze-toolpath operation code as well as project load/save functionality. Lastly I have planned a simple heightmap-based CNC simulation mode so that users can preview an approximation of their generated toolpaths to quickly determine if it will do what they had intended. After that it's down to iterating through the todo list of many little tiny things that could stand to be given some love.
Can't understand why you do certain things in the code but I can offer some advice. Also been 10+ years since I touched a PIC so can't help there. 1. First verify the sensor works by putting something in front and measuring the output with a scope or meter. Repeat at another distance. The results should approximately match spec sheet. 2. Make your code send alternating characters so that you verify your communications code is working correctly. 3. With electrical limits respected for your interface board/uc apply 0 and Vmax to the ADC, does the program output correct values? If the above all works the only thing off the top of my head is some sort mismatch between the adc and sensor that you will need to rectify. Also another thing to watch carefully are timings, the sensor has timing requirements and so does the adc.
I spent today writing a wrapper (in a different language) for libldap. I wasn't writing *in* C, but I was integrating with a C library, wrapping C types and functions, etc. It was a lot of fun. I really got to play around, building higher-level abstractions on top of a really simple (but sometimes unwieldy) C API.
its something i picked up writing MISRA compliant code so I will just quote MISRA. **Rule 10.6 (required): A “U” suffix shall be applied to all constants of unsigned type.** *The type of an integer constant is a potential source of confusion, because it is dependent on a complex combination of factors including:* * *The magnitude of the constant* * *The implemented sizes of the integer types* * *The presence of any suffixes* * *The number base in which the value is expressed (i.e. decimal, octal or hexadecimal).* .. *Signedness of constants should be explicit. Consistent signedness is an important principle in constructing well formed expressions. If a constant is of an unsigned type, it is helpful to avoid ambiguity by applying a “U” suffix. When applied to larger values, the suffix may be redundant (in the sense that it does not influence the type of the constant); however its presence is a valuable contribution towards clarity.* 
Why are you reassigning the value? Maintain both values and use an if statement to print the sand value if sand != 0, else print the treasure value. 
I think you should focus on making your code compile and work before trying to optimize it. Currently I'm getting the following errors &amp; warnings: $ cc -std=gnu11 -O2 -Wall -Wshadow -Wmissing-field-initializers -Wredundant-decls -Wstrict-prototypes -Wold-style-definition -Werror mmul.c -o mmul mmul.c:6:12: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘:’ token int i,j,s,x: ^ mmul.c:9:1: error: return type defaults to ‘int’ [-Werror=implicit-int] main() ^ mmul.c:9:1: error: function declaration isn’t a prototype [-Werror=strict-prototypes] mmul.c: In function ‘main’: mmul.c:9:1: error: old-style function definition [-Werror=old-style-definition] mmul.c:11:5: error: ‘p’ undeclared (first use in this function) p[0]=13; q[0]=5; ^ mmul.c:11:5: note: each undeclared identifier is reported only once for each function it appears in mmul.c:11:14: error: ‘q’ undeclared (first use in this function) p[0]=13; q[0]=5; ^ mmul.c:16:17: error: ‘n’ undeclared (first use in this function) for(i=0; i&lt;=n-1; i++) { ^ mmul.c:17:9: error: ‘m’ undeclared (first use in this function) m[i][i]=0; ^ mmul.c:20:22: error: left-hand operand of comma expression has no effect [-Werror=unused-value] for(j=0;j&lt;i-1,j++) ^ mmul.c:20:26: error: expected ‘;’ before ‘)’ token for(j=0;j&lt;i-1,j++) ^ mmul.c:29:17: error: ‘x’ undeclared (first use in this function) for(x=i; x&lt;=i+s-1; x++) ^ mmul.c:33:12: error: ‘nn’ undeclared (first use in this function) printf(nn); ^ mmul.c:36:20: error: expected expression before ‘%’ token printf(%7d,m[i][j]); ^ mmul.c:36:21: error: invalid suffix "d" on integer constant printf(%7d,m[i][j]); ^ mmul.c:37:16: error: expected expression before ‘/’ token printf(/n); Fixing the most obvious problems (missing space in #define, colon instead of semicolon as statement terminator, missing quotes for printf), I'm down to these errors &amp; warnings: $ cc -std=gnu11 -O2 -Wall -Wshadow -Wmissing-field-initializers -Wredundant-decls -Wstrict-prototypes -Wold-style-definition -Werror mmul.c -o mmul mmul.c:2:11: error: expected identifier or ‘(’ before numeric constant #define n 4 ^ mmul.c:7:20: note: in expansion of macro ‘n’ int p[n],q[n],m[n],n[n]; ^ mmul.c: In function ‘main’: mmul.c:17:13: error: subscripted value is neither array nor pointer nor vector m[i][i]=0; ^ mmul.c:19:17: error: subscripted value is neither array nor pointer nor vector m[i][j]=99999; ^ mmul.c:20:22: error: left-hand operand of comma expression has no effect [-Werror=unused-value] for(j=0;j&lt;i-1,j++) ^ mmul.c:20:26: error: expected ‘;’ before ‘)’ token for(j=0;j&lt;i-1,j++) ^ mmul.c:21:17: error: subscripted value is neither array nor pointer nor vector m[i][j]=0; ^ mmul.c:25:13: error: subscripted value is neither array nor pointer nor vector m[i][i+1]=p[i]*q[i]*q[i+1]; ^ mmul.c:30:25: error: subscripted value is neither array nor pointer nor vector if (m[i][x] +m[x+1][i+s] + p[i]*q[x]*q[i+s] &lt;m[i][i+s]) ^ mmul.c:30:36: error: subscripted value is neither array nor pointer nor vector if (m[i][x] +m[x+1][i+s] + p[i]*q[x]*q[i+s] &lt;m[i][i+s]) ^ mmul.c:30:66: error: subscripted value is neither array nor pointer nor vector if (m[i][x] +m[x+1][i+s] + p[i]*q[x]*q[i+s] &lt;m[i][i+s]) ^ mmul.c:31:25: error: subscripted value is neither array nor pointer nor vector m[i][i+s] = m[i][x] +m[x+1][i+s]+p[i]*q[x]*q[i+s]; ^ mmul.c:31:37: error: subscripted value is neither array nor pointer nor vector m[i][i+s] = m[i][x] +m[x+1][i+s]+p[i]*q[x]*q[i+s]; ^ mmul.c:31:48: error: subscripted value is neither array nor pointer nor vector m[i][i+s] = m[i][x] +m[x+1][i+s]+p[i]*q[x]*q[i+s]; ^ mmul.c:33:12: error: ‘nn’ undeclared (first use in this function) printf(nn); ^ mmul.c:33:12: note: each undeclared identifier is reported only once for each function it appears in mmul.c:36:30: error: subscripted value is neither array nor pointer nor vector printf("%7d",m[i][j]); Without knowing what your program is supposed to do, it's really hard to help. However, if you declare an array in C as `int a[4]`, you get an array of 4 elements which you can access as `a[0]`, `a[1]`, `a[2]`, and `a[3]` respectively. What you cannot do with a one-dimensional array is treat it a s a 2d array ("matrix").
Are you in BCIT by any chance?
I think a "simple" statement as this *p++ = *q-- is not complex enough for an "obfuscated" damage control to kick in. Maybe for an introduction to C that would confuse people but in writing good code that is hardly unacceptable and I would say common and not discouraged by K&amp;R or other resources.
The way you wrote it in your post doesn't work since *q and *r are undeclared when you assign a+1 and a+2 to them.
No, it isn't. Please insert four spaces at the start of every single line of code, even those that already started with spaces, and remove the blank lines that you added. If your editor uses tabs for indentation, you should convert them to spaces before pasting the code into reddit. Alternatively, upload the unmodified original to [Pastebin](https://pastebin.com/) and replace the code in your post with a link.
I don't get it, could you elaborate? Is it still a app to help remember things? Isn't the text structure, which is what I understand by incremental reading, limiting for most applications besides a play or a script?
I am at page 72 of K&amp;R. Weekend K&amp;R read anyone?
You're missing one `*` before `*x` in the function `creation`.
You're defining "x" as a pointer to an int but you use it as if it were a pointer to a pointer to an int. So change "int i, j, *x;" to "int i, j, * *x;". The program now compiles but it still crashes when calling the creation function.
Thank you!
I was thinking that it didn't matter because a hex literal is just describing what the bits are. Then I realized that's what any number representation/base does! I tend to use hex when dealing with bit flags, so signedness isn't really important, but this isn't always the case. I'm convinced. 
Thanks! Ok, now gonna try to find out that else did I do wrong...
The outer loop in the initialization code goes past the end of the array. The corresponding loop in `showing()` is correct.
Youre correct, the first loop needs to be "i&lt;n" instead of "j&lt;n*m"
Yeppi, It works! 
What is your question?
 struct dados{ long int id; char id_c[6]; char nome[52]; char cidade_partida[12]; char cidade_chegada[12]; int dia; int voo; char dia_c[3]; }; struct dados pessoa[max_linhas]; IN another function i have printf("Indique o seu nome completo (max 50 caracteres):"); fgets(pessoa[h].nome, 52, stdin); so pessoa.[h].nome prints what the user types followed by a \n and i wanted to print what the userr types followed by spaces till has reached 52
`"%10s"` as a `printf()` format specifier will ensure that the printed field has at least 10 characters, and will add spaces before the string as necessary. If you want the spaces after the name, use `"%-10s"`.
that dosent do it cuz after the spaces theres still a \n and i need to be all together 
Well in Supermemo, you can import an entire web page, PDF, or whatever, and that item gets treated the same way as a regular flashcard. It comes up in your "deck", but instead of a flashcard, you read the article until you get bored with it or whatever. While you're reading, though, you can highlight text (a paragraph, sentence, or whatever) and create an "reading item" out of that. This new item then shows up later in your deck. You can also create flashcards and clozures right from the article. So for instance if you're reading a Wikipedia article, you'll probably quickly read over the intro paragraph, skim over anything you already know or is easy to absorb, but if you get to a sentence that contains a date that needs remembering, you highlight the sentence and make a clozure out of the date. Now you have a flashcard with the date. I like it because while reading the article, you get the "big picture" while having the option to pin down the stuff you need to remember. It all sounds kind of clunky and convoluted, you could just as easily read an article in a browser while creating flashcards out of the important stuff in Anki, but I like the idea of having blocks of text that show up in my deck that I can re-read a few times, and create cards from that. So my main issue is, Supermemo is incredibly clunky and buggy. I think with vi-keys and within a console it could be very smooth and efficient. So we'll see :)
Do you have an example users.txt? Seems like a fun program to make. 
If you don't have a '\n' in your format string, then it must be in the input buffer. If that is the case, you need to remove the '\n' from the buffer. The easiest way to do this would be to replace the '\n' with a '\0'.
How do u do that ? Sry about that
A string in C is just an array of characters delimited by a '\0'. So, you will need to find the last character in the string (before the '\0'), then test it to see if it is a '\n'. If it is a '\n', then set it equal to '\0'. You can use `strlen()` to find the length of the string. You can check if you have a '\n' in your buffer by printing it out one char at a time: int i = 0; while(string[i] != '\0') { if(string[i] == '\n') { printf("string[%d] = '\\n'\n", i); } else { printf("string[%d] = '%c'\n", i, string[i]); } i++; } 
[removed]
[removed]
[removed]
Thanks 
Yeah I have the additional files I can attach them after I get off of work
&gt; isn't a good language It "isn't a good language" ? However the entire Linux kernel and nearly everything else that runs on top of it ( kernel modules etc ) is entirely written in C. Not sure how you defend such a statement or if you are just making noises.
Your account is still shadow banned. Please talk to the admins to rectificy this issue.
If you want to talk about how good C is or isn't based on software systems written in it, then you have to also consider the huge number of software projects people did in another language other than C (while they could have used C). Another interesting point is to consider the number of software systems which moved away from C (they were written in C, and later were changed to C++ for example). Sure, there are important systems written in C. However, that doesn't make it a good language. Why would it? There are important systems written in COBOL and PHP as well. Pick any of the mainstream languages (and also some of the not so mainstream) that you think is awful. I bet you can find highly important systems written in that language. That's simply because pretty much all of the "mainstream" languages have important systems written in them. It doesn't make the language particularly good. It just makes them used and useful. People use C more because it is a necessary evil and not that much for its qualities as a programming language. If you want to argue about how good the C language is, I encourage you to look for programming language experts (not me; I'm not one of them) and see what they have to say. I bet you'll find that it's surprisingly hard to defend that C is a good programming language based on its merits as a programming language. At least that is what I've found.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
Others already pointed you at your mistake. I think it is worth adding two additional sentences. * If a 2D array is allocated like this, its supporting memory is not a contiguous chunk of memory. There are two other ways to allocate it in a single piece of memory plus there is the option of emulating a 2D array using a 1D array. * The compiler messages might look cryptic at times but they never are (at least not in C).
A little-used feature of printf is that it returns the number of characters printed. So if you declare an int d, you can say d=printf(" [whatever you are printing] "), which will assign the number of characters just printed in your format string to the variable d. Then form a "for" loop whose counter goes from d to 50, and prints a space in each iteration. Voila, done. (Well, minus the error-checking.)
Thank you, everyone, for your answers and I've figured it out now
`"%-51s\n"`
What error are you getting?
C++ is off topic in this subreddit. Please post C++ questions elsewhere, e.g. in /r/cpp_questions.
I guess I am just old school having lived a life in assembly, Fortran and C systems for industrial applications and control systems. That and JTAG ports and hardware debugging.
man which part of this looks like c++ to you?
not an error, i just don't know how to print using a for loop. If i was to do this: for (int index = 0; index &lt; 3; index++) { printf("Name: %s %s || Age: %d || Nationality: %s", astronaut1.firstName, astronaut1.lastName, astronaut1.age, astronaut1.nation); } then it will only print astronaut1 info 3 times if i was to do this for (int index = 0; index &lt; 3; index++) { printf("Name: %s %s || Age: %d || Nationality: %s", astronaut[index].firstName, astronaut[index].lastName, astronaut[index].age, astronaut[index].nation); } then it wouldn't compile since it is not an array
You're telling scanf() it should be reading integers and then giving it input that doesn't have integers in those spots. Always check the return value of scanf() before trying to use variables it sets or you're going to have a bad time. In this case you **also** need to fix your format and use appropriate types like strings instead of ints.
The part where your file was named `structures.cpp` until you renamed it.
it was commented out, and it is the name of the program, the actual source code is in the C Programming Language
[removed]
But then wouldn't the variable store the String not the ascii number
Characters are just numbers...
Show your code. (And you multiply by using \*. For example, `f(1) * 5`)
my code is an absolute mess, should i post it with all the int and floats, or should i just cut this portion out, this is one of the things i have to do for the code
@raevnos This is the code so far #include&lt;stdio.h&gt; #include&lt;math.h&gt; int main () { float a, b, c, d, tfunc, z, n, beg, test, bug, pop, zeroc, deltax, zeroa, zerob, onea, end; int code = 0; float r=0; printf ("what is the degree of the polynomial? Insert 1-4 or -1 to quit\n"); scanf ("%d", &amp;code); while (code != -1) { switch (code) { case 1: printf ("what is the value of a?\n"); scanf ("%f", &amp;a); printf ("what is the value of z?\n"); scanf ("%f", &amp;z); printf ("what is the beginning interval?\n"); scanf ("%f", &amp;beg); printf ("what is the end interval?\n"); scanf ("%f", &amp;end); printf ("How many steps are there? (n=?) \n"); scanf ("%f", &amp;n); deltax = (end - beg) / n; zerob= (a*beg)+z; zeroa= (a*end)+z+zerob; bug=beg+deltax; pop=end-deltax; for(r=bug; r&lt;=pop; r+=deltax){ tfunc=2*(a*r+z); zeroc=zeroa+tfunc; printf("zeroa= %f \n", zeroa); printf("tfunc= %f \n", tfunc); } printf("answer:%f \n", zeroc); break;
Hey, Thanks for trying to help. It was my first time posting on this sub, idk why some people downvoted, but i figured out what was wrong! I had my for loop statement set to end on the wrong function, plus i had to have it (&lt;=) and not just (&lt;). So it had to look like for(i=1;i&lt;=a;i+=delta); instead of for(i=1;i&lt;b;i+=delta)
Thats also why you’re getting a lot of meaningless numbers there. It’s the eq. of the chars. 
Yeah so sick of « hey do my assignment, thanks! » type of posts
No, OP is seeing undefined behavior in action by using uninitialized variables.
Are you writing an actual device driver for this, or a userland program that reads from a file provided by the real driver?
I'm a junior in college for software development, and the only language we have been taught is Java. It's been three years of Java classes. I guess HTML, CSS, php, js count as well but they just teach enough to get by. I've always had a fascination with C and have always wanted to learn it. This weekend I decided it was time, I watched a 3 hour course on beginner c programming, and I'm in love. Today I played around with creating a struct, and having another struct create but not initialize it. Kinda inheritance like. Question from a total noob, what would be the best way to see if a structure contains a variable? 
If your source is in a cpp file, the compiler uses C++ mode to compile it. That makes your source clearly C++ source.
[removed]
As well as what /u/raevnos has already said, `0.789` isn't an integer, and `scanf` is has been given the format code `%d` which is expecting an integer, as well as your `amount` variable being defined as an integer. You need to fix this, check the `scanf` documentation for an appropriate format string, and whatever C reference you're using for an appropriate type of variable to use.
Your account seems to be better now. Try posting something again, let's see if it works now.
Yeah, I guess you wouldn't call it a driver. I'm running it from the command prompt.
even after changing it to a double it gives the same result and the numbers in give and recive are not the ASCII values for the words I put in 
If you're still doing the same `scanf` then it's going to fail - are you checking the return value from scanf yet? What are you actually trying to achieve by getting the ASCII value of the characters you're typing in? Although each character is a number in the ASCII table, there's not really a standard way of getting the numeric value of a given combination of characters.
One of my favorite interview questions when someone is claiming to be a C or C++ expert is, "What are some conditions where you would declare a variable with both the 'const' and 'volatile' qualifiers?"
`newNode == malloc(sizeof(Node))` This is a comparison operation, not an assignment. Use a single `=`.
Just as you responded I saw it :), I feel dumb. Thank you.
well I have a 2D array of different rates like this: USD CAD EUR GBP USD 1.000 1.268 0.857 0.758 CAD 0.789 1.000 0.676 0.598 EUR 1.167 1.479 1.000 0.884 GBP 1.319 1.720 1.131 1.000 and I want the user to update the table by entering "row"/"column"="the value"
Your going to have to come up with a method to convert "USD" to 0, "CAD" to 1 etc. Off the top of my head probably the simplest way would be with an `if`, `else if`, `else` chain. You won't be able to read it in with scanf and have it set those values automatically. Something like this should work though it's obviously incomplete: #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;errno.h&gt; int str_to_index(const char *in) { if (strcmp("USD", in) == 0) { return 0; } else if (strcmp("CAD", in) == 0) { return 1; } else if (strcmp("EUR", in) == 0) { return 2; } else if (strcmp("GBP", in) == 0) { return 3; } else { errno = ENOENT; return -1; } } int main(int argc, char **argv) { double rates[4][4], rate; /* I'm terrible at naming variables */ char first_string[4], second_string[4]; int res, i, j; res = scanf("%3s/%3s = %lf", first_string, second_string, &amp;rate); if (res != 3) { perror("Invalid input"); return 1; } i = str_to_index(first_string); j = str_to_index(second_string); if (i == -1 || j == -1) { perror("Couldn't get index"); return 1; } rates[i][j] = rate; printf("%d, %d, %f\n", i, j, rates[i][j]); return 0; } 
Right now I'm working on writing a homebrew replacement I'm calling [coldbrew](http://github.com/gwoplock/coldbrew). I'm also working on an operating system called [ExOS](http://github.com/gwoplock/exos)
My understanding is you use it when a line can't be optimized out. For inline asm it won't optimize they asm. 
I'm just guessing here but is it when using a pointer to read from rom?
Also, your format string is missing a newline.
When and how to use volatile: "unless you're setting a volatile sig_atomic_t global variable, volatile is either not sufficient or not necessary or both". 
When I'm reading from a hardware input register where the value is a result of what's on the pins and changes dynamically. When there's a value being updated in an ISR, but the rest of the code shouldn't mess with it. In other words, places where the value may be modified, but this code shouldn't be the one doing it.
Even in embedded systems?
Never done any embedded work so I was curious: https://embeddedgurus.com/barr-code/2012/01/combining-cs-volatile-and-const-keywords/
Today I'm going to try writing my command line parser for like the 5th time. I think I've got a good plan, but we'll see.
Another thing to think about: does your `traverse` function need to take in a length?
Any time I spoke to hardware and attempted to use volatile I ran into compiler bugs. GCC is notoriously badly debugged in this area. Just a couple of months ago in this subreddit someone posted where a single write to a single memory mapped volatile declared register was compiled into one read and two writes. Which is a gross violation of the standard. If you're writing to hardware registers and not doing it through assembler or meticulously handcrafted code that has been verified to work with all supported compilers you're irresponsible. I found this out the hard way 15 years ago when gcc decided that it was free to reorder three volatile writes so that my "lock; fiddle; unlock;" became "lock; unlock; fiddle;" (yes, volatile was theoretically sufficient in this case, the "lock" and "unlock" were meant to be read by the same CPU in interrupt handlers only). As evidenced by some example code a few months ago that I verified with the latest versions of gcc, this is still buggy. And probably even more buggy on non-mainstream architectures which embedded is likely to be. And if your embedded system is using any modern CPU, you're touching some hardware register to trigger some other hardware to do DMA or equivalent, in which case you're doubly fucked because even on i386 that's supposed to be fully cache coherent but in certain cases isn't. And on ARM or such, you're dealing with store buffers and non-coherent DMA. And the examples in the top answer in the link here are deluded. volatile for threads? Has whoever wrote that used a CPU built in the past 15 years? Has he even heard of multiprocessor systems?
You failed to mention the primary use of it: for reading and writing memory-mapped fields that may change externally to the program. Citing a gcc bug from 15 years ago is hardly justification for anything. Can you link to the gcc bug report thread for this bug?
Memory mapped fields that can change externally to the program pretty much always require much stronger synchronization than volatile can give you. 
just a thought but I take it you know about getopt ?
Can you at least post some code so people can take a look?
You realize that post is from 2011 and the paper from 2008? That's an eternity in CS terms.
Sounds like you were missing memory fences. It's hardly the compiler's fault when you misuse volatile.
You have to show code for this so at least someone else can submit a bug report to get it fixed. I've used volatile in embedded many times over the years and have never had the compiler mess with my volatile related operations that way.
Please explain how memory fences have any effect on a single CPU. You know that code can be disassembled and easily read and you can figure out what the compiler did from there?
I'd say you're going to have a much better time scraping websites with Python. Network programming in C can get pretty ugly and it's not going to gain you any significant time advantage if you're just grabbing a few values. 
Yes.
Assuming that `A` and `B` are sorted arrays of size `M` and `N`, respectively, it merges them into a sorted array `C` of size less `M + N`. I don't think it works, though, but I can't tell for sure without seeing how it is called. BTW, this sub is for C, not C++.
Can it work if you're setting b to -1 in the initialization part of the for loop and then checking if b is bigger than (or equal to) 0 in that very loop? Looks like a rather big (and stupid) bug to me, but maybe I'm missing something.
There's always libcurl...
The merit of those articles should not be discredited just because of its age. Besides, the embedded C world is a slow moving dinosaur. How many open source projects are fully C11 compliant in 2017?
No, it assumes that `B` is sorted in reverse order, that C / C++ arrays “know” their size and that the subscript operator wraps around so that `B[-1]` is equivalent to `B[N-1]`. The first may be true, but the rest is not.
It's doable. If you want to do it from scratch you need to build a TCP connection client and a HTTP client. TCP client is used to create TCP connections and send and receive data from a TCP server. HTTP client uses the TCP client to send and receive HTTP responses. After you have done that, you can then think about websockets. Alternatively you can find libraries that can do some of the work for you. E.g. libcurl https://curl.haxx.se/libcurl/
fair enough, easy to miss...
&gt;Are you sure this example is not intentionally incorrect? Is there, perhaps, an exercise asking the student to find and fix the bug? I'm not OP, but yeah, I wondered the same thing. That, and the fact that the string written to stdout literally says "U" instead of "you" made me think that this wasn't an actual book, but just class notes, but the format seems legit for a book. And yeah, I think the algorithm works for B reversed, but that seems a bit unnecessary to me; in most situations you can't expect the user will pass a reversed array because you're too lazy to use the array in the proper order. A promising book overall.
Yes, Libcurl makes this a lot easier: void send_request(const char * post_data) { CURL * curl; CURLcode res; curl = curl_easy_init(); if (curl == NULL) { exit(1); } struct curl_slist * headers = NULL; headers = curl_slist_append(headers, "Content-Type: application/json"); curl_easy_setopt(curl, CURLOPT_URL, "http://000.000.000.000:8080"); curl_easy_setopt(curl, CURLOPT_VERBOSE, 1 L); curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "POST"); curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers); curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post_data); curl_easy_setopt(curl, CURLOPT_USERAGENT, "libcrp/0.1"); res = curl_easy_perform(curl); curl_easy_cleanup(curl); }
A memory fence forces accesses to happen in a specific order. It is one of few ways a developer can explicitly limit what the optimizer can and can't do. Volatile is often insufficient without a memory fence. https://blog.regehr.org/archives/28 Basically, without a memory fence, volatile reads and writes can still be reordered, even in single threaded code. A proper MUTEX library should include memory fences around any locks/unlocks. 
As others have said, I would first do this either with shell scripts or python - figure out the HTTP API requests you need to pull the values you want. Once you've got that done, you can try doing it at a lower level. Work your way down the stack! 
This is the more idiomatic way of doing it, I'd say.
No need to be C11 compliant, it is sufficient that it can be compiled with a recent compiler. And it is less the age aspect but more the fact that the last GCC release in 2008 was 4.3.2. That leaves 3 major versions to fix the wrong compilation of 'volatile' (not saying that it actually has been fixed). 9 years IS a long time.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions. Also, don't post pictures of code. Always post code as text!
In addition you shouldn't return 0 for failures. If you'd returned something other than 0 you could have checked the return value and the problem would have been more obvious. Also if you set your compiler to produce more warnings this problem would have been a lot more obvious.
1. The blog post you link to has zero uses of the word "fence". 2. The blog post you link to says "accesses to volatiles should not be reordered". You link to a source that contradicts you. I know very well how memory fences work. I've actually written MP locking code that's in use in real systems in real production. Memory fences have nothing to do with volatile or what the compiler is or isn't allowed to do. Memory fences enforce memory operation ordering visible outside of the CPU that executes them (other than a few edge cases like virtually indexed caches with aliases, which should never be allowed to happen, store ordering is irrelevant when observed from inside the CPU that executed the store). That's why I asked "how memory fences have any effect on a single CPU", because they don't.
Are you checking feof and ferror in the full code? What os are you using?
https://software.intel.com/en-us/blogs/2007/11/30/volatile-almost-useless-for-multi-threaded-programming The volatile accesses must happen in order, but they do NOT guarantee that nonvolatile accesses around them will happen in any particular order. If you need to be assured of the order of other accesses, you need memory fences. 
Please choose one of C and C++.
Nope it an expale of merging arrays. Btw thank you very much for explaining as I was having problem in understanding that b=-1.
Yep, looks pretty easy. Thanks for asking, good luck with it.
Put four spaces before each line of code. Also, this is C++ code but you've posted in a C programming subreddit. Try /r/cpp_questions.
The code is completely C, although since I am used to cin and cout due to simplicity, I just use the C++ library for that.
[removed]
Hardcoding the length of the array seems questionable, especially since you only initialize 9 of the 13 elements of the array. Also, you access out of bounds elements.
I agree. I would do something along the lines of downloading the .html pages with wget in Bash. Then parse it to .html with tagsoup .jar. Then open up python and use minidom to parse the .html into a DOM structure. Navigate the DOM tree with python to extract the values. From the you can use python to load the data I to a mysql database and use php to play with the data inside the database.
What do you think happens in the following `if` statement when `i==8`? You may want to update your output lines to also show the index where the error occurs. if(array[i+1]&lt;array[i])
Running Ubuntu 16.04.03. I tried checking with feof and ferror and they never once return an error. I tried running ftell() to see where it thought it was in the file and it returns a mix of -1 and 0. Though I noticed that the program always stops working when ftell returns 0 even though it returns 0 many times before that point.
I found a guy who had done something similar yet not as fleshed out [with Ruby](http://barrenfrozenwasteland.com/2012/01/boogie-board-rip-on-linux/). And his never fails like mine even if I try and force it like with mine. Everything is similar except I notice that he does some things with threading. Though i'm not sure what reason he would do it for. 
Welcome to /r/doMyHomeworkForMe, how may we be of assistance?
C++ is off topic in this subreddit. Please post C++ questions elsewhere, e.g. to /r/cpp_questions.
Do you have a question? If yes, what is it?
/* fillArray Description: This function will fill an array of integers with either random or nearly sorted data between 0 and the array size Inputs: int* array -- pointer to an array of integers int size -- the size of the array and the number of values to be loaded bool random -- flag to indicate how the array should be filled true indicates all random values between 0 and size true indicates all random values between 0 and size Outputs: The array is filled as a side effect Date: 21 August 2017 Author: */ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdbool.h&gt; #include &lt;time.h&gt; #include &lt;string.h&gt; #define SET1 10 #define SET2 100 #define SET3 1000 #define SET4 10000 #define SET5 100000 #define R10file "RArray10.txt" #define R100file "RArray100.txt" #define R1000file "RArray1000.txt" #define R10000file "RArray10000.txt" #define R100000file "RArray100000.txt" #define NS10file "NSArray10.txt" #define NS100file "NSArray100.txt" #define NS1000file "NSArray1000.txt" #define NS10000file "NSArray10000.txt" #define NS100000file "NSArray100000.txt" #define RANDBUBBLE "RBub.txt" #define NEARBUBBLE "NSBub.txt" #define RANDSELECT "RSel.txt" #define NEARSELECT "NSSel.txt" #define RANDINSERT "RIns.txt" #define NEARSELECT "NSIns.txt" void writeArrayToFile (int ary[], int size, char filePath[]); /* fillArray Description: This function will fill an array of integers with either random or nearly sorted data between 0 and the array size Inputs: int* array -- pointer to an array of integers int size -- the size of the array and the number of values to be loaded bool random -- flag to indicate how the array should be filled true indicates all random values between 0 and size true indicates all random values between 0 and size Outputs: The array is filled as a side effect Date: 21 August 2017 Author: */ void fillArray(int* ary, int size, bool random, char filePath[]); /* randomFill Description: This function will fill an array of integers with random data between 0 and the array size Inputs: int* array -- pointer to an array of integers int size -- the size of the array and the number of values to be loaded Outputs: The array is filled as a side effect Date: 21 August 2017 Author: Gary Thompson */ void randomFill(int* ary, int size); /* nearlySortedFill Description: This function will fill an array of integers with nearly sorted data between 0 and the array (size - 1). Each element will be in numeric order beginning with 0 but every 10th element will have 5 subtracted from its value Inputs: int* array -- pointer to an array of integers int size -- the size of the array and the number of values to be loaded Outputs: The array is filled as a side effect Date: 21 August 2017 Author: */ void nearlySortedFill(int* ary, int size); /* copyArray Description: This function will copy an array of integers from source to target. Array sizes must be equal Inputs: int* source -- pointer to an source array of integers int* target -- pointer to an target array of integers int size -- the size of the arrays Outputs: The array is filled as a side effect Date: 21 August 2017 Author: */ void copyArray(int* source, int* target, int size); /* ================== selectionSort =================== Sorts by selecting smallest element in unsorted portion of array and exchanging it with element at the beginning of the unsorted list. Pre list must contain at least one item last contains the index of the last item in the list comparisons Post list rearranged smallest to largest Author: Modified to count comparisons of values and movements of values */ void selectionSort (int list[], int last, long* comparisonsptr, long* movesptr); /* ==================== bubbleSort ==================== Sort list using bubble sort. Adjacent elements are compared and exchanged until list is ordered. Pre the list must contain at least one item last contains index to last element in list Post list rearranged in sequence low to high */ void bubbleSort (int list [], int last, long* comparisonsptr, long* movesptr); /* ================== insertionSort ================== Sort list using Insertion Sort. The list is divided into sorted and unsorted lists. With each pass, first element in unsorted list is inserted into sorted list. Pre list must contain at least one element last contains index to last element in list Post list has been rearranged */ void insertionSort (int list[], int last, long* comparisonsptr, long* movesptr); /* writeSortData Description: This function writes collected data to the SelectionSort.txt output file. It creates the file the first time it is called and appends to it each time after. Inputs: int comparisons -- the number of data comparisons required to sort this data set int moves -- the number of data moves required to sort this data set int size -- the size of the data set bool random -- if true indicates the data is random, if false indicates the data is nearly sorted Outputs: The data is presented in a text file named SelectionSort.txt as a side effect. The data is labeled and formatted Date: 21 August 2017 Author: */
void writeSortData(long comparisons, long moves, int size, bool random, const char* header, char filePath[]); int main() { const char* selectionHeader = "\n\n\t\t\tSelection Sort Data\n\n\n"; const char* bubbleHeader = "\n\n\t\t\tBubble Sort Data\n\n\n"; const char* insertionHeader = "\n\n\t\t\tInsertion Sort Data\n\n\n"; int array1 [SET1]; int array2 [SET2]; int array3 [SET3]; int array4 [SET4]; int array5 [SET5]; char filePathFor10 [20]; char filePathFor100 [20]; char filePathFor1000 [20]; char filePathFor10000 [20]; char filePathFor100000 [20]; char filePathForSort [20]; bool random = false; long comparisons = 0; long moves = 0; /*This section sorts the data using selection sort. Written by: Date: 12/4/17 */ do { random = !random; if(random == true) { strcpy(filePathFor10, R10file); strcpy(filePathFor100, R100file); strcpy(filePathFor1000, R1000file); strcpy(filePathFor10000, R10000file); strcpy(filePathFor100000, R100000file); strcpy( filePathForSort , RANDSELECT); } else { strcpy(filePathFor10, NS10file); strcpy(filePathFor100, NS100file); strcpy(filePathFor1000, NS1000file); strcpy(filePathFor10000, NS10000file); strcpy(filePathFor100000, NS100000file); strcpy(filePathForSort , NEARSELECT); } fillArray(array1, SET1, random, filePathFor10); selectionSort(array1, SET1 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET1, random, selectionHeader, filePathForSort); comparisons = 0; moves = 0; fillArray(array2, SET2, random, filePathFor100); selectionSort(array2, SET2 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET2, random, selectionHeader, filePathForSort); comparisons = 0; moves = 0; fillArray(array3, SET3, random, filePathFor1000); selectionSort(array3, SET3 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET3, random, selectionHeader, filePathForSort); comparisons = 0; moves = 0; fillArray(array4, SET4, random, filePathFor10000); selectionSort(array4, SET4 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET4, random, selectionHeader, filePathForSort); comparisons = 0; moves = 0; fillArray(array5, SET5, random, filePathFor100000); selectionSort(array5, SET5 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET5, random, selectionHeader, filePathForSort); comparisons = 0; moves = 0; }while(random == true); /*This section sorts the data using Bubble Sort Written by: Date: 12/4/17 */ do { random = !random; if(random == true) { strcpy(filePathFor10, R10file); strcpy(filePathFor100, R100file); strcpy(filePathFor1000, R1000file); strcpy(filePathFor10000, R10000file); strcpy(filePathFor100000, R100000file); strcpy(filePathForSort, RANDBUBBLE); } else { strcpy(filePathFor10, NS10file); strcpy(filePathFor100, NS100file); strcpy(filePathFor1000, NS1000file); strcpy(filePathFor10000, NS10000file); strcpy(filePathFor100000, NS100000file); strcpy(filePathForSort, NEARBUBBLE); } fillArray(array1, SET1, random, filePathFor10); bubbleSort(array1, SET1 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET1, random, bubbleHeader, filePathForSort); comparisons = 0; moves = 0; fillArray(array2, SET2, random, filePathFor100); bubbleSort(array2, SET2 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET2, random, bubbleHeader, filePathForSort); comparisons = 0; moves = 0; fillArray(array3, SET3, random, filePathFor1000); bubbleSort(array3, SET3 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET3, random, bubbleHeader, filePathForSort); comparisons = 0; moves = 0; fillArray(array4, SET4, random, filePathFor10000); bubbleSort(array4, SET4 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET4, random, bubbleHeader, filePathForSort); comparisons = 0; moves = 0; fillArray(array5, SET5, random, filePathFor100000); bubbleSort(array5, SET5 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET5, random, bubbleHeader, filePathForSort); comparisons = 0; moves = 0; }while(random == true); /*This section sorts the data using Insertion sort Written by: Date: 12/4/17 */
 do { random = !random; if(random == true) { strcpy(filePathFor10, R10file); strcpy(filePathFor100, R100file); strcpy(filePathFor1000, R1000file); strcpy(filePathFor10000, R10000file); strcpy(filePathFor100000, R100000file); strcpy(filePathForSort, RANDINSERT); } else { strcpy(filePathFor10, NS10file); strcpy(filePathFor100, NS100file); strcpy(filePathFor1000, NS1000file); strcpy(filePathFor10000, NS10000file); strcpy(filePathFor100000, NS100000file); strcpy(filePathForSort, NEARSELECT); } fillArray(array1, SET1, random, filePathFor10); insertionSort(array1, SET1 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET1, random, insertionHeader, filePathForSort); comparisons = 0; moves = 0; fillArray(array2, SET2, random, filePathFor100); insertionSort(array2, SET2 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET2, random, insertionHeader, filePathForSort); comparisons = 0; moves = 0; fillArray(array3, SET3, random, filePathFor1000); insertionSort(array3, SET3 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET3, random, insertionHeader, filePathForSort); comparisons = 0; moves = 0; fillArray(array4, SET4, random, filePathFor10000); insertionSort(array4, SET4 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET4, random, insertionHeader, filePathForSort); comparisons = 0; moves = 0; fillArray(array5, SET5, random, filePathFor100000); insertionSort(array5, SET5 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET5, random, insertionHeader, filePathForSort); comparisons = 0; moves = 0; }while(random == true); printf("Goodbye world!\n"); return 0; } void fillArray(int* ary, int size, bool random, char filePath[]) { if (random) { randomFill(ary, size); writeArrayToFile(ary, size, filePath); return; } else { nearlySortedFill(ary, size); writeArrayToFile(ary, size, filePath); return; } } void randomFill(int* ary, int size) { // seed the random number generator srand(10); // so all random arrays are pseudorandom and repeatable int i; for(i = 0; i &lt; size; i++) { ary[i] = rand() % size; //limit the range of random values to the (size - 1) of the array } return; } void nearlySortedFill(int* ary, int size) { int i; for(i = 0; i &lt; size; i++) { if(i == 0 || i % 10 !=0) //is this element 0 or an element divisible by 10? { ary[i] = i; // is so, assign it the value of i } else { ary[i] = i - 5; // if divisible by 10, subtract 5 before assigning the value } } return;
} void copyArray(int* source, int* target, int size) { int i; for(i = 0; i &lt; size; i++) { target[i] = source[i]; //limit the range of random values to the (size - 1) of the array } return; } void selectionSort (int list[], int last, long* comparisonsptr, long* movesptr) { *comparisonsptr = 0; *movesptr = 0; // Local Declarations int smallest; int tempData; // Local Declarations // Statements // Outer Loop int current; int walk; for (current = 0; current &lt; last; current++) { smallest = current; // Inner Loop: One sort pass each loop for (walk = current + 1; walk &lt;= last; walk++) { (*comparisonsptr)++; if (list[walk] &lt; list[smallest]) { smallest = walk; } } // Smallest selected: exchange with current tempData = list[current]; list[current] = list[smallest]; list[smallest] = tempData; (*movesptr)++; } // for current return; } // selectionSort void bubbleSort (int list [], int last, long* comparisonsptr, long* movesptr) { *comparisonsptr = 0; *movesptr = 0; // Local Declarations int temp; int current; int walker; // Statements // Outer loop for(current = 0; current &lt; last; current++) { // Inner loop: Bubble up one element each pass for (walker = last; walker &gt; current; walker--) { (*comparisonsptr)++; if (list[walker] &lt; list[walker - 1]) { temp = list[walker]; list[walker] = list[walker - 1]; list[walker - 1] = temp; (*movesptr)++; } // if } } // for current return; } // bubbleSort void insertionSort (int list[], int last, long* comparisonsptr, long* movesptr) { // Statements *comparisonsptr = 0; *movesptr = 0; // Local Declarations int walk; int temp; bool located; int current; // Statements // Outer loop for (current = 1; current &lt;= last; current++) { // Inner loop: Select and move one element located = false; temp = list[current]; for (walk = current - 1; walk &gt;= 0 &amp;&amp; !located++;) { (*comparisonsptr)++; if (temp &lt; list[walk]) { list[walk + 1] = list[walk]; walk--; (*movesptr)++; } // if else located = true; } list [walk + 1] = temp; } // for return; } // insertionSort void writeSortData(long comparisons, long moves, int size, bool random, const char* header, char filePath[]) { // Local Declarations FILE* spSelSort; if (size == SET1) { if((spSelSort = fopen("C:\\Users\\Sam\\Documents\\Programming\\Chapter 8\\Sort\\NSSel", "w")) == NULL) //data collection { printf("\aERROR opening Sort.txt\n"); exit (100); } // if open else { fprintf(spSelSort, "%s", header); fprintf(spSelSort, "\n\nDataset Size\t\tComparisons\t\tMoves\t\tRandom\n\n"); fprintf(spSelSort, "%7d %22ld %20ld \t\t %u", size, comparisons, moves, random); printf("%s", header); printf("Dataset Size\t\tComparisons\t\tMoves\t\tRandom\n\n"); printf("%7d %26ld %18ld \t\t %u\n\n", size, comparisons, moves, random); if (fclose(spSelSort) == EOF) { printf("\aERROR closing Sort.txt\n"); exit (102); } // if close return; } } else if ((spSelSort = fopen("C:\\Users\\Sam\\Documents\\Programming\\Chapter 8\\Sort\\RSel", "a")) == NULL) //open for append { printf("\aERROR opening Sort.txt\n"); exit (100); } // if open fprintf(spSelSort, "%7d %22ld %20ld \t\t %u\n\n", size, comparisons, moves, random); printf("%7d %26ld %18ld\t\t %u\n\n", size, comparisons, moves, random); if (fclose(spSelSort) == EOF) { printf("\aERROR closing Sort.txt\n"); exit (102); } // if close } void writeArrayToFile (int ary[], int size, char filePath[]) { // Declaration statements FILE* arrayFile; if((arrayFile = fopen("C:\\Users\\Sam\\Documents\\Programming\\Chapter 8\\Sort\\RArray10", "w")) == NULL) { printf("\aERROR opening Sort.txt\n"); exit (100); } // if open else { int i; for (i = 0; i &lt; size; i++) { fprintf(arrayFile, "%d", ary[i]); } } if (fclose(arrayFile) == EOF) { printf("\aERROR closing Sort.txt\n"); exit (102); } // if close } void writeArrayToFile (int ary[], int size, char filePath[]); /* fillArray Description: This function will fill an array of integers with either random or nearly sorted data between 0 and the array size Inputs: int* array -- pointer to an array of integers int size -- the size of the array and the number of values to be loaded bool random -- flag to indicate how the array should be filled true indicates all random values between 0 and size true indicates all random values between 0 and size Outputs: The array is filled as a side effect Date: 21 August 2017 Author: */ void fillArray(int* ary, int size, bool random, char filePath[]); /* randomFill Description: This function will fill an array of integers with random data between 0 and the array size Inputs: int* array -- pointer to an array of integers int size -- the size of the array and the number of values to be loaded Outputs: The array is filled as a side effect Date: 21 August 2017 Author: */
void randomFill(int* ary, int size); /* nearlySortedFill Description: This function will fill an array of integers with nearly sorted data between 0 and the array (size - 1). Each element will be in numeric order beginning with 0 but every 10th element will have 5 subtracted from its value Inputs: int* array -- pointer to an array of integers int size -- the size of the array and the number of values to be loaded Outputs: The array is filled as a side effect Date: 21 August 2017 Author: */ void nearlySortedFill(int* ary, int size); /* copyArray Description: This function will copy an array of integers from source to target. Array sizes must be equal Inputs: int* source -- pointer to an source array of integers int* target -- pointer to an target array of integers int size -- the size of the arrays Outputs: The array is filled as a side effect Date: 21 August 2017 Author: */ void copyArray(int* source, int* target, int size); /* ================== selectionSort =================== Sorts by selecting smallest element in unsorted portion of array and exchanging it with element at the beginning of the unsorted list. Pre list must contain at least one item last contains the index of the last item in the list comparisons Post list rearranged smallest to largest Author: Modified to count comparisons of values and movements of values */ void selectionSort (int list[], int last, long* comparisonsptr, long* movesptr); /* ==================== bubbleSort ==================== Sort list using bubble sort. Adjacent elements are compared and exchanged until list is ordered. Pre the list must contain at least one item last contains index to last element in list Post list rearranged in sequence low to high */ void bubbleSort (int list [], int last, long* comparisonsptr, long* movesptr); /* ================== insertionSort ================== Sort list using Insertion Sort. The list is divided into sorted and unsorted lists. With each pass, first element in unsorted list is inserted into sorted list. Pre list must contain at least one element last contains index to last element in list Post list has been rearranged */ void insertionSort (int list[], int last, long* comparisonsptr, long* movesptr); /* writeSortData Description: This function writes collected data to the SelectionSort.txt output file. It creates the file the first time it is called and appends to it each time after. Inputs: int comparisons -- the number of data comparisons required to sort this data set int moves -- the number of data moves required to sort this data set int size -- the size of the data set bool random -- if true indicates the data is random, if false indicates the data is nearly sorted Outputs: The data is presented in a text file named SelectionSort.txt as a side effect. The data is labeled and formatted Date: 21 August 2017 Author: */ void writeSortData(long comparisons, long moves, int size, bool random, const char* header, char filePath[]); int main() { const char* selectionHeader = "\n\n\t\t\tSelection Sort Data\n\n\n"; const char* bubbleHeader = "\n\n\t\t\tBubble Sort Data\n\n\n"; const char* insertionHeader = "\n\n\t\t\tInsertion Sort Data\n\n\n"; int array1 [SET1]; int array2 [SET2]; int array3 [SET3]; int array4 [SET4]; int array5 [SET5]; char filePathFor10 [20]; char filePathFor100 [20]; char filePathFor1000 [20]; char filePathFor10000 [20]; char filePathFor100000 [20]; char filePathForSort [20]; bool random = false; long comparisons = 0; long moves = 0; /*This section sorts the data using selection sort. Written by: Date: 12/4/17 */ do { random = !random; if(random == true) { strcpy(filePathFor10, R10file); strcpy(filePathFor100, R100file); strcpy(filePathFor1000, R1000file); strcpy(filePathFor10000, R10000file); strcpy(filePathFor100000, R100000file); strcpy( filePathForSort , RANDSELECT); } else { strcpy(filePathFor10, NS10file); strcpy(filePathFor100, NS100file); strcpy(filePathFor1000, NS1000file); strcpy(filePathFor10000, NS10000file); strcpy(filePathFor100000, NS100000file); strcpy(filePathForSort , NEARSELECT); } fillArray(array1, SET1, random, filePathFor10); selectionSort(array1, SET1 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET1, random, selectionHeader, filePathForSort); comparisons = 0; moves = 0; fillArray(array2, SET2, random, filePathFor100); selectionSort(array2, SET2 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET2, random, selectionHeader, filePathForSort); comparisons = 0; moves = 0; fillArray(array3, SET3, random, filePathFor1000); selectionSort(array3, SET3 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET3, random, selectionHeader, filePathForSort); comparisons = 0; moves = 0; fillArray(array4, SET4, random, filePathFor10000); selectionSort(array4, SET4 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET4, random, selectionHeader, filePathForSort); comparisons = 0; moves = 0; fillArray(array5, SET5, random, filePathFor100000); selectionSort(array5, SET5 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET5, random, selectionHeader, filePathForSort); comparisons = 0; moves = 0; }while(random == true); /*This section sorts the data using Bubble Sort Written by: Sam Postlethwait Date: 12/4/17 */ do { random = !random; if(random == true) { strcpy(filePathFor10, R10file); strcpy(filePathFor100, R100file); strcpy(filePathFor1000, R1000file); strcpy(filePathFor10000, R10000file); strcpy(filePathFor100000, R100000file); strcpy(filePathForSort, RANDBUBBLE); } else { strcpy(filePathFor10, NS10file); strcpy(filePathFor100, NS100file); strcpy(filePathFor1000, NS1000file); strcpy(filePathFor10000, NS10000file); strcpy(filePathFor100000, NS100000file); strcpy(filePathForSort, NEARBUBBLE); }
 fillArray(array1, SET1, random, filePathFor10); bubbleSort(array1, SET1 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET1, random, bubbleHeader, filePathForSort); comparisons = 0; moves = 0; fillArray(array2, SET2, random, filePathFor100); bubbleSort(array2, SET2 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET2, random, bubbleHeader, filePathForSort); comparisons = 0; moves = 0; fillArray(array3, SET3, random, filePathFor1000); bubbleSort(array3, SET3 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET3, random, bubbleHeader, filePathForSort); comparisons = 0; moves = 0; fillArray(array4, SET4, random, filePathFor10000); bubbleSort(array4, SET4 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET4, random, bubbleHeader, filePathForSort); comparisons = 0; moves = 0; fillArray(array5, SET5, random, filePathFor100000); bubbleSort(array5, SET5 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET5, random, bubbleHeader, filePathForSort); comparisons = 0; moves = 0; }while(random == true); /*This section sorts the data using Insertion sort Written by: Date: 12/4/17 */ do { random = !random; if(random == true) { strcpy(filePathFor10, R10file); strcpy(filePathFor100, R100file); strcpy(filePathFor1000, R1000file); strcpy(filePathFor10000, R10000file); strcpy(filePathFor100000, R100000file); strcpy(filePathForSort, RANDINSERT); } else { strcpy(filePathFor10, NS10file); strcpy(filePathFor100, NS100file); strcpy(filePathFor1000, NS1000file); strcpy(filePathFor10000, NS10000file); strcpy(filePathFor100000, NS100000file); strcpy(filePathForSort, NEARSELECT); } fillArray(array1, SET1, random, filePathFor10); insertionSort(array1, SET1 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET1, random, insertionHeader, filePathForSort); comparisons = 0; moves = 0; fillArray(array2, SET2, random, filePathFor100); insertionSort(array2, SET2 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET2, random, insertionHeader, filePathForSort); comparisons = 0; moves = 0; fillArray(array3, SET3, random, filePathFor1000); insertionSort(array3, SET3 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET3, random, insertionHeader, filePathForSort); comparisons = 0; moves = 0; fillArray(array4, SET4, random, filePathFor10000); insertionSort(array4, SET4 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET4, random, insertionHeader, filePathForSort); comparisons = 0; moves = 0; fillArray(array5, SET5, random, filePathFor100000); insertionSort(array5, SET5 - 1, &amp;comparisons, &amp;moves); writeSortData(comparisons, moves, SET5, random, insertionHeader, filePathForSort); comparisons = 0; moves = 0; }while(random == true); printf("Goodbye world!\n"); return 0; } void fillArray(int* ary, int size, bool random, char filePath[]) { if (random) { randomFill(ary, size); writeArrayToFile(ary, size, filePath); return; } else { nearlySortedFill(ary, size); writeArrayToFile(ary, size, filePath); return; } } void randomFill(int* ary, int size) { // seed the random number generator srand(10); // so all random arrays are pseudorandom and repeatable int i; for(i = 0; i &lt; size; i++) { ary[i] = rand() % size; //limit the range of random values to the (size - 1) of the array } return; } void nearlySortedFill(int* ary, int size) { int i; for(i = 0; i &lt; size; i++) { if(i == 0 || i % 10 !=0) //is this element 0 or an element divisible by 10? { ary[i] = i; // is so, assign it the value of i } else { ary[i] = i - 5; // if divisible by 10, subtract 5 before assigning the value } } return; } void copyArray(int* source, int* target, int size) { int i; for(i = 0; i &lt; size; i++) { target[i] = source[i]; //limit the range of random values to the (size - 1) of the array } return; } void selectionSort (int list[], int last, long* comparisonsptr, long* movesptr) { *comparisonsptr = 0; *movesptr = 0; // Local Declarations int smallest; int tempData; // Local Declarations // Statements // Outer Loop int current; int walk; for (current = 0; current &lt; last; current++) { smallest = current; // Inner Loop: One sort pass each loop for (walk = current + 1; walk &lt;= last; walk++) { (*comparisonsptr)++; if (list[walk] &lt; list[smallest]) { smallest = walk; } } // Smallest selected: exchange with current tempData = list[current]; list[current] = list[smallest]; list[smallest] = tempData; (*movesptr)++; } // for current return; } // selectionSort void bubbleSort (int list [], int last, long* comparisonsptr, long* movesptr) { *comparisonsptr = 0; *movesptr = 0; // Local Declarations int temp; int current; int walker; // Statements // Outer loop for(current = 0; current &lt; last; current++) { // Inner loop: Bubble up one element each pass for (walker = last; walker &gt; current; walker--) { (*comparisonsptr)++; if (list[walker] &lt; list[walker - 1]) { temp = list[walker]; list[walker] = list[walker - 1]; list[walker - 1] = temp; (*movesptr)++; } // if } } // for current return; } // bubbleSort void insertionSort (int list[], int last, long* comparisonsptr, long* movesptr) { // Statements *comparisonsptr = 0; *movesptr = 0; // Local Declarations int walk; int temp; bool located; int current; // Statements // Outer loop for (current = 1; current &lt;= last; current++) { // Inner loop: Select and move one element located = false; temp = list[current]; for (walk = current - 1; walk &gt;= 0 &amp;&amp; !located++;) { (*comparisonsptr)++; if (temp &lt; list[walk]) { list[walk + 1] = list[walk]; walk--; (*movesptr)++; } // if else located = true; } list [walk + 1] = temp; } // for return; } // insertionSort void writeSortData(long comparisons, long moves, int size, bool random, const char* header, char filePath[]) { // Local Declarations FILE* spSelSort; if (size == SET1) { if((spSelSort = fopen("C:\\Users\\Sam\\Documents\\Programming\\Chapter 8\\Sort\\NSSel", "w")) == NULL) //data collection { printf("\aERROR opening Sort.txt\n"); exit (100); } // if open else { fprintf(spSelSort, "%s", header); fprintf(spSelSort, "\n\nDataset Size\t\tComparisons\t\tMoves\t\tRandom\n\n"); fprintf(spSelSort, "%7d %22ld %20ld \t\t %u", size, comparisons, moves, random); printf("%s", header); printf("Dataset Size\t\tComparisons\t\tMoves\t\tRandom\n\n"); printf("%7d %26ld %18ld \t\t %u\n\n", size, comparisons, moves, random); if (fclose(spSelSort) == EOF) { printf("\aERROR closing Sort.txt\n"); exit (102); } // if close return; } } else if ((spSelSort = fopen("C:\\Users\\Sam\\Documents\\Programming\\Chapter 8\\Sort\\RSel", "a")) == NULL) //open for append { printf("\aERROR opening Sort.txt\n"); exit (100); } // if open fprintf(spSelSort, "%7d %22ld %20ld \t\t %u\n\n", size, comparisons, moves, random); printf("%7d %26ld %18ld\t\t %u\n\n", size, comparisons, moves, random); if (fclose(spSelSort) == EOF) { printf("\aERROR closing Sort.txt\n"); exit (102); } // if close } void writeArrayToFile (int ary[], int size, char filePath[]) { // Declaration statements FILE* arrayFile; if((arrayFile = fopen("C:\\Users\\Sam\\Documents\\Programming\\Chapter 8\\Sort\\RArray10", "w")) == NULL) { printf("\aERROR opening Sort.txt\n"); exit (100); } // if open else { int i; for (i = 0; i &lt; size; i++) { fprintf(arrayFile, "%d", ary[i]); } } if (fclose(arrayFile) == EOF) { printf("\aERROR closing Sort.txt\n"); exit (102); } // if close }
That is everything I have so far. I am having trouble getting this to upload to my files. 
wait so the value of res is the number of inputs read? also other than that this really helped. tnx 
The timer isn't running at the specified 100ms like the title says. Do my specs look right for the timer?
Where do you get `HUNDRED_MS` and `ONE_MINUTE` from? These aren't standard definitions. Please show your full code.
Also, your code can't work the way you wrote it as `global_time` is not a global variable but you use it as such. And if you use a global variable for synchronisation like this, make it `_Atomic` or at least `volatile` so the compiler doesn't do weird things with it.
Updated the link. It's not finished, so I had other junk in there and got carried away deleting.
Updated the link. It's not finished, so I had other junk in there and got carried away deleting.
I'm not sure what is wrong with your code, but the arguments to `timer_settime` are definitely wrong, the second argument is supposed to be a set of flags instead of a pointer.
You're totally right. I read the description wrong. The example I saw had `timer_settime(timer_id, 0, &amp;tim, 0)` and thought `&amp;tim` was the old value argument, but it's the new. Thanks, I think you solved my problem.
Next time, enable warnings when compiling. My C compiler immediately complained.
Yup. From the man page: &gt; These functions return the number of input items successfully matched and assigned, which can be fewer than provided for, or even zero in the event of an early matching failure.
ⴰⵎⵛⵓⵎⴰ ⵉⵜⵉⵛ ⵉⵜ
How often do you run cccleaner or Malwarebytes on linux? ;) You're right though, for this kind of use case batch files or PowerShell are the correct options.
Can you provide some context? You only show fragments without giving us the big picture and critical information needed to understand what you are doing. For example, you could start by saying what operating system you are programming for.
You can check the edit for more info. OS is 32-Bit Debian. 
Do you know how i and j are passed to the function? int array1[M][N]; array1[i][j] Will result in the calculation array1[ i * N + j] So pass in i=0, j=1 and i=1, j=0 work out the displacement, and you'll get M and N 
What a bizarre approach. If you're going to use Python anyway, you might as well use it for the HTTP as well.
You are in the wrong subreddit my friend. (but also just FYI VS is fucking huge and usually takes forever to download)
Ight thanks
But how am I extrapolating the answer from the assembly?
You can write Python... (lib)curl or wget would probably be the closest requests equivalents written in C
You don't extrapolate. Set `i` to 1, execute the instructions and the offset you write to is N. Set j to 1, execute the instructions and the offset you read from is M
You can write almost any program in C that you can write in Python. You could literally write Python in C. The main difference in the outcome is that programs written in C can be optimized to run faster and take up much less space than Python code. C programs tend to require more syntax and a bit more explicit typing to achieve the same result as a Python script but, when implemented correctly, they will run faster and take up less memory than Python will to do the same thing. Consider Python to be like a luxury sedan and C to be a DIY motorcycle. If your only goal is to get from point A to point B the motorcycle will get you there quicker and use less gas. If anything goes wrong, you are pretty fucked on the motorcycle, a crash is worse on the motorcycle. Want more than 2 people onboard? You are going to need to build your own side car. Want to get there in comfort and style? Going to need to upgrade the motorcycle. You will be proud of your motorcycle, it will be quick and fuel efficient when it runs, and a verbose hunk of junk when it don't. On the other hand, you can drive the luxury sedan, it will work right off the lot, you can get there in safety and comfort. It's a reliable car although having 4 empty seats and a trunk in it with nothing but a spare tire is a lot of extra room you don't need all the time but it's handy to do it. My advice is write your scraper in Python, of something runs too slow, optimize it. If it's still going too slow, maybe try writing that part in C and have Python feed it arguments. You'll find Python is pretty great at handling what you throw at it. 
Anything that can be written in Python can be written in C. But depending a little bit on what you want to do the experience will vary. Web scraping I imagine would be text processing heavy, and native C strings is little more than syntactic sugar over raw chunks of memory. You could use a strings library of course, [this one](https://github.com/antirez/sds) seems popular. 
For webscraping libcurl is really good and simple, using it all the time with jansson for hitting all sorts of APIs.
you dont need those softwares on linux ;)
u should smoke weed instead
No surveys unless they are about the C programming language or programming in C specifically.
with C you can extend python, optimising just the parts that are time intensive... as both languages are potentially Turing complete (like many languages) they should both equally capable of roughly the same application.
Nah man, that's far too easy. You need to add some Akka actors in there too, set up a continuous integration pipeline, combined with Kubernetes. Don't forget to dump Docker somewhere in there too. Also, forget PHP. Angular 4 is where it's at, with NodeJS as a backend, talking to a Go daemon eventually so you can query the precious data.
Well what I’m curious of is how would you initiate a raw http request using C? 
With or without a library? With a library, take a look at libcurl. If you want to implement the protocol itself, you need to do all the TCP setup and teardown, have a look at a good TCP tutorial. I always refer to Beej's Socket Guide but it's pretty dated now, there are plenty of better ones. Once you've managed to bind() a socket, and connect() it, you then need to use read() and write() on the sockets to send raw TCP data. You will need to determine whether you want blocking or non-blocking IO and do fcntl(fd, O_NONBLOCK) etc. Aaaaand that's when you get to the HTTP RFC's and realise you still have a lot more work ahead of you. 
Both would be awesome. I’d really like to learn how to do network connections at a low level with all the different protocols, more for a learning experience than anything else. 
ITYM /r/C_Homework
C is completely unsafe and non-C devs aren't the only one to say it. What C devs say is that: 1) this lack of safety can be managed through strict conventions and adequate functions and that 2) this lack of safety is a tool that can admitedly chop your foot off but can also be used to build marvelous things. Most (not all) OS are written in C because when the OS that are popular today were written C was the only reasonnable option. Today they are too big to seriously consider a complete rewrite. That's about it.
C is “unsafe” in the sense that it allows you to do things that make your program crash and won't do any implicit sanity or consistency checks. However, if you write code without doing weird things (like abusing pointer arithmetic or reckless type punning), there isn't anything “unsafe” going on. Effectively, wrong C code typically behaves in much the same way as wrong code written in a “safe” language: it makes your program crash.
Wich PL can replace C with as much good performance?
A lot like guns, C remains dangerous whether in the hands of a novice or an expert. It boils down to where the dangerous end is pointing to.
Then what is unsafe is not C but its freedom in let whatever be written even reckless code? So what about type safety and so on? Is not that a real issue in C?
Rust is gaining a lot of love as a "safe" system-level PL.
So a total beginner as me will always write unsafe C code until a lot of years late? Or is there a "best practices C book" that could put me in the "sniper" path?
I've heard. I even asked if it was a good idea to begin with Rust, but they advised to learn C then Rust as there are not that much of jobs in Rust
Your closest bets would be C++ (allows you to shoot your foot off in exactly the same ways as C, but also supports many more modern programming constructs, so it really depends on what style of C++ programming you do), Rust, and maybe Ada or Fortran. These languages are all legitimately close to C in performance, but each has its own baggage too. Many proponents of other languages will claim C-like performance, but these are the only languages with a substantial following I'm aware of that it is actually true for.
C is deffo great to learn and will stand you in good stead in the future. I think though that there will be jobs in Rust in the coming years.
Chances are, you'll be writing "unsafe" (buggy) code even after years of practice because _errare humanum est_. No matter how good you are, you'll still introduce bugs in your code, just as well as lots of professional programmers out there. Yes, there are _lots_ of books, articles and sites devoted to teaching people whatever the authors think are the "best practices". Honestly, I think this is BS because there are books written by _the authors of the C language_, Dennis Ritchie and Brian Kernighan. Read the latest edition of "The C programming language" and practice, practice, practice. Then get acquainted with the newer standards. And practice again... 
Are you implying that most programmers that insert weird bugs in apps did not learn C as much as are necessary? I 've learned that it is wise to read CPU books too...is it necessary?
I've got my eyes in C cause I am focusing System programming. Is C++ that much used to write kernel, device driver and alike?
When they say "safe" 95% of the time they're referring to buffer overruns. For a long time, the vast, vast majority of security bugs were (and a substantial proportion still are) attributable to this class of issues. Most modern languages do automatic bounds checking and this class of bugs is simply not possible. This is a legitimate deficit in the design of C.
1) A programming language is, to my mind, very similar to any human language, like English. Now, do you _never_ make mistakes in English? Or any _foreign_ language? Even those who are native speakers of the English language (imagine, they were born in a society where people speak English, they've been taught this language literally literally since their birth!) still make mistakes in grammar and spelling. I'm not even talking about logic here. C is a foreign language. Would you expect people to make less mistakes in a foreign language? 2) Totally not. The only thing you should understand is how the computer works in general. Otherwise you'll be writing code without any idea about how it works, which kinda sucks. You'll probably find yourself in need of more knowledge about how the computer works some time. This is where you can dig deeper, study a bit of assembly, some physics (seriously, a CPU works because of physics).
Thank God, not much except maybe for Windows
&gt;Or is there a "best practices C book" that could put me in the "sniper" path? It might be more extreme than you're looking for, but it's worth looking over MISRA-C. It's a set of C rules developed for the automotive industry and in the strictest form it prohibits the use of a bunch of language features and techniques - including the use of malloc(). You can break the rules, but it makes you document why you're breaking them and how you're going to test the results. Even if you don't intend to follow such a restricted subset of the language, it's good to know the reasoning behind the restrictions. I've learned plenty of that through experience, too. Giving everything meaningful names, not making anything visible outside the minimum necessary scope, using parenthesis anywhere there's the slightest chance of confusion, and so on.
For anything practical and widely used, C is still the way to go. That said, there's a lot of interest in Rust right now for writing future systems, as it displays a lot of promise for alleviating some of the biggest flaws of C while still maintaining similar performance. From what I understand, it can still be somewhat difficult to work with though, and isn't quite ready for primetime.
Have you compared an strace of your program to that of hping3?
&gt; MISRA-C. Oh great. I've been concerned by this "safe" topic on C, I hope I get it right ...
Are you and u/will-ries in the same class or something? There's practically the same question [four posts below this one](https://www.reddit.com/r/C_Programming/comments/7hntcz/learning_how_to_take_values_from_websites/). void send_request(const char * post_data) { CURL * curl; CURLcode res; curl = curl_easy_init(); if (curl == NULL) { exit(1); } struct curl_slist * headers = NULL; headers = curl_slist_append(headers, "Content-Type: application/json"); curl_easy_setopt(curl, CURLOPT_URL, "http://000.000.000.000:8080"); curl_easy_setopt(curl, CURLOPT_VERBOSE, 1 L); curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "POST"); curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers); curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post_data); curl_easy_setopt(curl, CURLOPT_USERAGENT, "libcrp/0.1"); res = curl_easy_perform(curl); curl_easy_cleanup(curl); } Quick and dirty example for sending a JSON post request with libcurl. In this case the ```char *post_data``` argument is a JSON literal formatted string.
C is type safe. If you use a variable with a wrong type, you get a warning or an error. However, C lets you cut many more corners than other languages which is a thing people somehow think they are supposed to do, leading to terrible code.
haha! Searching for System programming jobs on indeed and monster there were not that many Windows as pre requisites ...I wonder why! 
`EOF` is an `int` value that is often equivalent to -1. Some C input functions will return `EOF` if there is no more data available in their source. If you share the code you're running, and how you're running it, we may be able to help you more.
EOF is just a macro that provides a more user-friendly name to negative number that is returned by some functions in special cases. I've only ever seen it defined as -1, but the C standard only guarantees it "expands to an integer constant expression, with type int and a negative value". Generally, it's a returned by a function that is reading from a stream to indicate there is no more data available to read. As for why your code isn't working -- you'd need to post a specific example.
To input EOF, use Ctrl-Z in a Windows OS or Ctrl-D in most others.
Assembly and CPU physics...Thanks!
#include &lt;stdio.h&gt; int main() { int c; while ((c = getchar()) != EOF) putchar(c); } So, that for example. Checks for EOF. This works, just prints back to the screen what I enter. How would I input EOF so the program quits? I guess that's what I don't understand. 
So it is a lack of knowledge of C rather than an unsafety feature
Oh, so it's literally just checking whether or not you break out? 
Yes. Exactly.
yes but EOF could technically be any key, it just makes more sense to use EOF than 'a'
C is as safe or as unsafe as you want it to be. C doesn't babysit you though, but it's not like you need to be super cautious about everything you do. I learned C as a kid almost 30 years ago... and I still prefer doing many things in straight C over C++... because C programming is straightforward and easier to debug when there is an issue.
There are no bad languages, only bad programmers
Okay thanks, I refactored the source to use the 0xXY form everywhere
On Windows, type Ctrl+Z to send EOF. On Linux, type Ctrl+D. Note that neither are EOF, but they tell the OS to send an EOF to the peocess.
Depends what you mean by break out. e.g. on mac/linux if you do Ctrl-C it'll stop* the program, and it won't receive an EOF. Ctrl-D sends the EOF and lets the program handle it. *Technically it sends the `INT` signal to the program, but the default action to take when receiving this signal is to stop running and exit.
Put four spaces in front of each line of code to indent it. As discussed, hit Ctrl-D in linux/mac to send EOF, or you could redirect the input from a file, e.g. ./a.out &lt; input.txt With the code you pasted that will print out the contents of the file input.txt.
haha...
It is kinda amazing how such an older PL is still so widely used and there is no signal that it will fade away so soon!...
On a modern OS, resources are virtualized and so the address space in a C program is limited to the running process (unless you break out some system calls). messing up pointers and dereferencing null pointers is only unsafe in that it will crash your own program, but the OS won't allow you to damage other processes. When it comes to writing an OS, however, there is no such thing as safety, at the lowest kernel level, since memory addressing is physical and not virtual. The only way a langauge could be considered unsafe for this purpose is if it is not consistent in what you expect it to do when addressing things. In this regard, C is "safe" because it's behavior is well defined, and it's undefined behavior is well known.
So I "must" not ignore Rust while learning C cause it might replace C in System programming late?
That is exactly where are aiming to work, System programming as tools. kernel fixing... It is kinda good news to me! haha
To understand how C blows up, you need to understand how C divides the address space and how the OS virtualizes memory. There are 3 types of main memory for C: stack, heap, and static memory. You can read this to understand the difference: https://stackoverflow.com/questions/32418750/stack-and-heap-locations-in-ram This diagram shows more detail, but essentially the three areas underneath "heap" are "static memory", though the author goes into detail about the different parts of it. A good project I did in school that really helped me understand dynamic memory allocation was this tutorial to write your own malloc function: https://danluu.com/malloc-tutorial/
I highly suggest reading through [this project](https://danluu.com/malloc-tutorial/) and trying to implement it yourself. It really gave me a great understanding of how dynamic memory allocation works and why things break
Rust has already been mentionned so I'll root for [D](https://dlang.org/). D, if used with its runtime, has about the same expression level as C# but being compiled it doesn't so it can easily solve most highlevel problems way faster while still being very safe. Without its runtime it can be used as a safe C: it has the exact same expression level and can be as unsafe if needs be, but provides templates, bound checking and other nice compile-time things to make programming easier and less error-prone while retaining the speed.
I will take good care reading it. As far I know, Aint Malloc the most nefast C feature? Cause I've heard only bad things about it...haha
D would be the best option, but it's struggling to get momentum. One reason may be that there's no giant corporation backing it.
EOF won't evaluate to any 'char' value. You might be able to write a custom shell that no longer uses the 'a' character so that you can press that to send an EOF, but it still won't be sending an 'a' to your program.
Even in the best case scenario for rust, only new things will get written in it. Even then that's many many years down the road. As a beginner starting your career you should absolutely stick to C. Do not learn rust unless you're interested and have the free time. Knowing C will be way more important than knowing rust.
I promptly avoid any PL backed by Corporation. Rust is backed by Mozilla but they are not evil..haha 
so: while ((c = getchar()) != 'a') wont work as i think? 
There is any reason why D is still not more widely used than I should?
Good luck writing any sort of advanced program without it. Its not evil.
I misunderstood what you meant. I thought you were implying that the value for EOF could be anything. Yes, you could make your loop break on anything other than EOF if you wanted to.
Yeah, considering that almost every chipset in the world, whether old or modern, runs on C... it's not going anywhere. :)
It's not backed by any big company so there is an advertisement issue. Furthermore it's a language that tries do to it all so while Rust for example can say "I'm all about memory safety" D isn't so easy to fit in a box (although it would fit well in many). Finally, and that's maybe linked in some way to both previous issues, D is a big language. When someone comes from C where you might think that you can learn it all in a few days because there are only so many constructs it's hard to accept that you might be proficient in D and not know all its features. It's an illusion though, most C programmers I know (myself included) don't quite know C as well as they think they do. There are so many corner cases, so many things that "almost always work that way" that C is really not that simple a language. Still D is mork akin to C++ than C when it comes to syntactical complexity.
ok ty 
Is it safe if I ignore all other PLs and study only C and Linux tools for the next years? I don't have that much info and insight in System programming but the jobs listed in Indeed and Monster... Thanks! 
There are so many good things to learn...I wish I live long to learn a lot haha
Yes, the calls to the kernel are the same 
C code is used in school buses that drive children to school, on airplanes that carry the world's population around the planet, on satellites in space that handle most of the world's communication systems, it is used to run experiments and simulations we derive important medicine from, and it's used to run and maintain the International Space Station, for some quick examples. So no, C is not unsafe. C is an inanimate object no different than a rock or a tree. Are rocks and trees unsafe? Depends on the context of usage!
Well all those people complaining about unsafe languages are they getting any work done? ;) JavaScript is incredibly popular and it’s use doesn’t seem to decrease. And in some ways it is a bit like C. It gets out of the way and let you get things done. 
As a dev who has spent most of the last 20 years writing in C I completely agree. And as I write in Swift on the side, besides the lack of safety, I'm annoyed with the amount of boiler plate code that has to get written. I've written nearly the same for loop thousands of times. It would help if C had closures, but I doubt that will ever happen.
haha...I don't think so! 
haha. If C is well used so one cant really argues it as unsafe! Thanks!
use "&amp;IID_IDirectSoundNotify8"
I couldn't tell you, honestly. I'm building games; I use a mix of lanaguages, C, C++, pascal, and even BASIC.
for an interesting discussion, ask those people to explain what "unsafe" means to them. Most of the time, I can't tell....
I'd recommend using a flat array and indexing. Say you have an array A, of size X by Y. size_t X = 10, Y = 20; float * A = malloc(sizeof(float) * X * Y); for (size_t iy = 0; iy &lt; Y; iy++) { for (size_t ix = 0; ix &lt; X; ix++) { A[ix + X * iy] = ix * iy; } } You'll need to get used to thinking about *innermost* and *outermost* dimensions, and *stride* vs row &amp; columns, but arrays like this are so much easier to generate and use. ALSO, flat or contiguous arrays like this are the convention found in numerical libraries like LAPACK and BLAS or NetCDF. 
Using C you can write safe code, and you can write unsafe code. Many people take the latter option which is what leads to the language's unsafe reputation.
Yes, it absolutely is. But the current era of unbridled C-hatred online is fueled mostly by people who either misunderstand its appropriate uses, or who are campaigning for a different language. C usage will probably lower over time until it's used kind of like assembly is today – a rare little nugget of specialized optimization in an otherwise higher-level code base – but I doubt it will drop that much for a very long time. "Safe" is a desirable trait of software. So are a bunch of other things. And right now, and for the foreseeable future, C's extremely high portability and 40 years of history (meaning 40 years of reusable libraries) will keep it dominant in some fields. Portability is a really major one. Bootstrapping a C compiler is really, really easy. Bootstrapping a Rust compiler is not. Look around the net and you'll find a million "embedded &lt;high-level-language&gt;" projects, almost all languishing abandoned, from the endless attempts to make high-level languages run on low-resource platforms. I'm all for Rust, and embedded Rust sounds great... but Rust targets a handful of higher-end platforms and C targets... well, nearly every single one ever made. That is a *lot* of ground to catch up. In the mean time, since we still depend on C, tooling for detecting software faults is getting much better, and OS support for limiting the damage of software faults is getting much better, and containerization and virtualization is sweeping the data centers. None of this makes C "safe", but it does a lot to reduce the damage, which also slows any demands to replace all C code. And here's a philosophical answer: C is not inherently unsafe, it's just very, very, very slow and expensive to write safe software with C. One of the ways to do it is to write a C program that interprets a stream of commands and data in a way that you have proven to be safe, and then force all of your software to communicate exclusively through that safe stream. In fact, you can reach a point where that safe stream of inputs is so capable that you can use it to make itself, recursively. That's called 'bootstrapping a compiler'. The first Rust compiler was originally written in C++. So, if Rust is safe, it's safe to say that C(/C++) can write safe software! https://github.com/rust-lang/rust/blob/16e4369fe3b5f00aa3cdc584a4e41c51c0d3ca8a/src/rt/rust_kernel.cpp 
I keep seeing the term closure around. What is a closure?
Reading through the rust book at the moment. Interesting language
If it is that expensive why a Rust did was created earlier one. It is said that newer PL solved all safety issues on C so why so late one new PL to shine? Thanks! 
So they are blaming the tool not themselves...interesting! 
I will sure ask them.
Thanks anyway! 
As an analogy, maybe consider a circular saw with no safety guard ... it would be valid to blame the tool for omitting the safety guard in that case, so those guys do have a valid point 
Could not be their lack of deep knowledge on the tool the real one to blame?
“If you write safe code then your code is safe” is what you seem to be saying. The fact is that it’s much easier to make silly mistakes in C that can turn into vulnerabilities very easily and are often quite hard to track down. Rust on the other hand makes it much harder to make silly errors without noticing.
That's not what I'm saying. What I say is "if you do weird hacks, don't be surprised to get weird errors."
I think it's safe to *focus* on C, but it's never safe to exclusively study one. Your goal should be to be "a programmer", not "a C programmer". Three reasons: 1) It's never safe to know only one tool. If the field changes unexpectedly, your knowledge is worthless. 2) You will write better C code if you learn the paradigms of other languages. 3) There's almost no such thing as a "pure C" project. There's usually a whole ecosystem of other software around it, written in high-level languages. Build scripts and test tools and debug interfaces and UIs and web backends. C+Python is currently the most common combination that I encounter, but Python is getting a lot of competition. 
But most vulnerabilities and ‘unsafety’ doesn’t arise from weird hacks.
Mostly the only "low-level" protocols you would use are TCP or UDP. Nearly all application level protocols that are important (DNS, SMTP, HTTP, IMAP, LDAP, etc) are implemented on top of one (or more in the case of DNS) of those two. So the mechanics of setting up a TCP connection for all those different protocols is basically the same. But the difference in complexity of the application level protocols can vary widely - just compare the on-the-wire specifications for HTTP and LDAP or IMAPv4). 
That's related for sure
It's sharp and easy to cut yourself badly with. But man it's powerfull, yet so simple and clean. I'd argue that C++ is much less safe because it has the same sharp bits but layers of complex fluff that make it seam like a high level language. When it's all razer blades, KISS is even more important than normal.
an LCD screen with a pic16f88, but it won't initialise and I have no idea why.
I actually found it very helpful to read computer architecture books early. You definitely need to spend some time programming first, but learning about how CPUs actually work makes it all "click". Unfortunately, it's tricky to find good resources. There's tons of very beginner books and tons of very advanced books, but that period in the middle is tough.
Go has decent performance with garbage collection. It's based on the Arif programming language from Plan9, an OS from the same people who created C and Unix. It's brilliant, like everything from Bell Labs.
&gt; I promptly avoid any PL backed by Corporation. Why? If the language is open source (which the vast majority of commonly-used programming languages are), what does it matter who "backs" it?
It's like an online function that gets passed to it's caller via a function variable.
Ignore it until you know C quite well. If rust starts to replace it that's still years away.
Mozilla employee working on Rust here. While Mozilla does pay people to work on Rust, we've strived to make sure that Mozilla does not control Rust. Only about 11 of the ~60 people who are on the various Rust teams are employed by Mozilla, and we operate by consensus. This topic is important to us!
Those vulnerabiloties arising from weird hacks have been fixed long ago already.
Rust core team member here. This is totally true. There are Rust jobs, but there are *way* more C jobs; this happens when your language is 2.5 years old vs 45 years old. If you're up for it, you should learn both. In fact, you should learn as many languages as you're able to. They change your perspective in ways that's useful. C will help you understand Rust, and vice versa.
I think you misread me. I’m saying that weird hacks aren’t the worrying bit - if you try hard enough you can do unsafe stuff in any language. The point is that there are trivial things like forgetting to add a null terminator, buffer overruns, null pointer dereferences, memory leaks etc that make it easy to slip up and introduce vulnerabilities that are far less common in higher level languages. Case in point: I’ve found two memory leaks in amazon’s open source TLS implementation (one quite benign) despite them having audited and tested the code base very heavily. C makes it very easy to make simple errors which is why I’d call it an unsafe language.
Even with fgetc there are better ways to do that, but you should use the scanf functions instead. int x, y; while (fscanf(p, "P%*d:(%d,%d),", &amp;x, &amp;y) &gt;= 2) { /* do your thing with x and y */ }
Oh ive seen you in Rust sub. haha I will gladly learn as much as I can. I just hope I will not feel overwhelmed by the much knowledge it seems to need to programming solid System tools! Thanks! 
I do hope you guys all the best. Firefox users since 2007 haha.... Eager to see more Rust in Firefox! 
I believe in you! It just takes time and practice.
That is why all experienced programmers call PL as hammers they are all replaceable it seems!
I'm mostly using scheme for this year, but earlier today I rattled off a C solution for day 6 for somebody else using C who was looking for suggestions to improve his. 
I am a GNU LINUX user...that is why...haha 
I am aware of P9, Kernigham, Ritchie, TCPL and alike haha... Go seems will have a big role in programming...
I found some here: http://wiki.osdev.org/Books
This is because of ABI stability. Implementing a C compiler isn't hard too.
As a DWM user...KISS is mandatory! ...Suckless! 
ah ok, ill try that
I’m sure you’re aware of clang’s blocks if you’ve used Swift. They’re not standard, but if you’re working on macOS or anything with clang they are quite nice to use in C. Probably not the most portable solution but it’s about the best we’ve got for now.
A closure is a function plus it's context (variables, state) that can be passed to other functions. Look into functional programming, that would make it clear in a matter of minutes. 
I use Python this year, so I do not have any C solutions to share. But I'd be happy to discuss any partial or full solutions in C. I do write C at my day job, so using python here is like starting the holiday wishlist 3 weeks early :) 
The important part of a closure is that it captures it's variables. It is the "inline function" AND its scope/environment ex: ... let number = 1; let logNumber = func() { print(number); }; ... logNumber has access to the variable "number" no matter where it is called from.
Show your code, have specific questions.
Could this be achieved with a struct of a pointer to a function and the variables?
The reference D compiler is not libre.
Echoing what the other guys said, focus on C for now if systems programming is your area of interest. If you get good at C you will be able to pick up Rust later if necessary. At this point no one even knows if Rust is the real deal or a fad that will fizzle out. It's simply not worth worrying about until major projects start getting written in it. I was only mentioning it as something to be aware of and because it's (relatively) new and cool.
I find many (fresh) college educated programmers blindly spew what their professors spewed in turn without true opinions or understanding on the matters
No I was not aware of this! Thanks for the tip!
Actually I more meant a lambda, which is an unnamed function, but a closure is a code block and the external environment that the closure makes use of, such as the current values of globals that the block references. Better to do a web search though and get a more rigorous definition than my half fast description.
Like int num; for (int i = 0; i &lt; num; i++) // do something
I am as well, but why does that mean you can't use products backed by corporations? Microsoft, Canonnical, IBM, and Oracle (all corporations) are some of the top contributors to the Linux kernel.
I wrote to them again the same they. They must have fixed it. Thanks!
Huh? DMD has the boost license, which is compatible with the GPL https://github.com/dlang/dmd/blob/master/LICENSE.txt and https://www.gnu.org/licenses/license-list.en.html#boost
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [dlang/dmd/.../**LICENSE.txt** (master → 270dddd)](https://github.com/dlang/dmd/blob/270dddd1ad9add101c0d1824f19bec2e055b9864/LICENSE.txt) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dqvtk2x.)^.
C is the common denominator of many modern programming languages and systems. It's not exceedingly difficult to implement a C compiler, nor does it expect very much from the underlying hardware. It's *just enough* complexity to be incredibly useful and flexible, but not enough that it makes it unwieldy in super-low-level situations.
Ooh, I'm interested in what you're using BASIC for.
A lambda expression, plus the context that it was constructed in.
&gt; Is not it time to replace C with those "safer" languages or are these claims just plain bollocks? A huge number of those "safer" languages are written in C or C++ and/or are dependent on the C runtime being present. For all the talk many programmers of rewriting OS's in a newer language, or creating new OS based around "safe language X", it hasn't happened to the degree that it would take to displace Microsoft/Linux/Apple etc. 
Go take a look at NodeJS, discover callback hell, all of a sudden C/C++ seem completely sane. 
some might take umbrage with NOT calling javascript a bad PL... lmao
Hmm. I don't think I'd use a tree for this at all (Unless you're required to or have a tree implementation handy and not other data structures). Probably use a hash table instead when counting the words, and then put all the keys and values into an array and sort that.
Go literally ignores any and all advancements that have been made in the last 40+ years of programming language design. From type system features to various abstractions to even the oh so loved GC, which sacrifices everything you could ever want in a GC purely to minimize latency. I would advise against using Go.
I know my format looks like poo but I don't know how to post on this subreddit I'm just desperate for help. Pls spare me
I've done quite a few of these in the past. The secret is that the only thing that counts is to get the correct answer. Your code doesn't need to be clean, it doesn't need to check for I/O errors, it doesn't need to worry about memory leaks, and speed is almost never an issue. I've solved all 12 problems so far and I used quadratic algorithms for five of them... there's no shame in that when you know in advance that your input will be small. Here's a solution for the first half of day 1 that reads from `stdin` and can handle multiple inputs: #include &lt;stdio.h&gt; int main(void) { char captcha[65536]; int i, j, n, sum; while (fgets(captcha, sizeof captcha, stdin) != NULL) { for (n = 0; captcha[n] &gt;= '0' &amp;&amp; captcha[n] &lt;= '9'; ++n) captcha[n] -= '0'; for (i = 0, j = 1, sum = 0; i &lt; n; ++i, ++j) if (captcha[i] == captcha[j % n]) sum += captcha[i]; printf("%d\n", sum); } return (0); } For the second half, you only have to change a few characters.
Insert four spaces at the start of each line, or use pastebin.
I'm using AGK BASIC to build the client for my MMO. The server shard is written in C and C++. I'm writing my resource editor in pascal (since, creating data apps and GUIs in Lazarus is sheer joy). It's very much in the early stages (5 months in, essentially). You can try the test client/server here: http://www.dymoria.com There's not much of a game there yet. :)
Yeey I am old.. 27..
Are you saying you wrote all that without once trying to compile it? In your header file, include the header which defines the type that is undefined.
Order of includes matters.
Probably somehow. This is something that is usually handled on the language level not the library level. You would probably have to indicate which variables to "capture" in a C implementation. And it would be hard (impossible?) to do in a generic/reusable way.
I wrote a web scraper in C using libcurl, and gumbo (html5 parsing library). As more and more sites switch to javascript it seems I might have to incorporate duktape in the future. I'm a bit too embarrassed to push it up into GitHub but feel free to ping me if you're interested.
Not doing your HW...
Kernel developers with deep knowledge and decades of experience writing C still write exploitable bugs. No one is perfect. And if you mess up in the wrong ways when you write C, your shit gets wrecked.
Thank you!
If we're talking about exploitable situations, JavaScript is the new C.
You hand me a programming language, and I can write you exploitable code, trust me. But C a lot of pitfalls that don't seem like a problem at first glance but are remarkably exploitable because of how it manages (or rather, doesn't manage) memory space. Buffer overruns continue to be a huge problem and it's easy to write one by accident. There are best practices that help, but you have to know about them and even then you can make a mistake. Higher level languages have different pitfalls (serialization issues that can be abused for code injection being my personal favorites) but they're a lot easier to spot. And easier to stay away from. You don't have to think about it every time you allocate a buffer or do weird pointer stuff, because you don't do those things at all. But anyone can write a logic bug, in any language, or mess up auth code, or write injectable database queries, the list goes on.
My pleasure!
When your program has a memory bug, the safe language will guarantee that you get a crash as soon as you hit that bug. But unsafe program may not crash and continue running, giving the attackers the full control over your program. 
You are correct, sorry. It used to be non-libre, now it is.
It means you posted to the wrong subreddit. And that [cppreference](http://en.cppreference.com/w/) is your friend.
&gt; The first Rust compiler was originally written in C++. It is not a compiler, but runtime (garbage collector). Compiler was written in OCaml initially and rewritten in rust, while runtime was omitted. &gt;So, if Rust is safe, it's safe to say that C(/C++) can write safe software! That's an obvious logical fallacy. C is unsafe because its type system does not let you check various invariants you wanna ensure. That's why things like misra exists. Rust is much safer though not perfect.
Yeah, and how much deaths had those chipsets caused? https://www.cbsnews.com/news/toyota-unintended-acceleration-has-killed-89/ Thank you, C.
Not legally, I'm sure.
This is not a scan of the original book. Someone re-typeset this.
May I invite you over to /r/rustjerk
I'll do that. Thank you
attackers can invade any program ever made. This kind of safety is utopia! 
There was any program in any language free of exploitable bugs? 
oh cool!
That is a paradox. I did know about that haha! 
All their contributions are for their own benefit. We are just side effect!
Get the fuck out with this C++ virus boy! 
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
Perhaps it was re-roffed from the original source?
&gt; That's an obvious logical fallacy. C is unsafe because its type system does not let you check various invariants you wanna ensure. That's why things like misra exists. Rust is much safer though not perfect. CPUs do not let you check various invariants you want to ensure. Ultimately we're building on the same old Von Neumann architecture, and it will always be "unsafe". But we can use those unsafe tools (C / assembly / machine code) to build more restrictive – and thus safer – programming environments. 
Sweet!
&gt; CPUs do not let you check various invariants you want to ensure. Yeap, that's why we are using programming languages instead of writing machine codes: to embrace convenient abstractions making our life better. &gt;But we can use those unsafe tools (C / assembly / machine code) to build more restrictive – and thus safer – programming environments. Even better: we can use safe tools (rust, ml, coq, idris, F*) to build a much safer software.
Washing your hands before you eat will not eliminate 100% of the germs, yet doing so is a very good idea. Using safe languages will not prevent 100% of vulnerabilities, yet doing so can significantly reduce your chance of getting one.
Studying properly germ potential risk one can know exactly how to deal with them safely! haha
Here is mine: #include &lt;stdio.h&gt; #include &lt;string.h&gt; int inverse_captcha(char *input) { int i, a, b; int sum = 0; int input_len = strlen(input); for (i = 0; i &lt; input_len - 1; ++i) { a = input[i]; b = input[i + 1]; if (a == b) { sum += a - '0'; } } if (b == input[0]) { sum += b - '0'; } return sum; } int main(int argc, char **argv) { if (argc == 1) { return 0; } printf("inverse captcha %s =&gt; %d\n", argv[1], inverse_captcha(argv[1])); return 0; }
It's funny that people think it's not copyright infringement if they do it on YouTube or the Internet Archive.
“NO COPYRIGHT INTENDED”
Yes, this is often "how" it's implemented in language with closures as first class constricts. I recommend SICP
They had two stdlibs a few years back and a community 'war' over which is best, so anyone joining at that time noped the fuck out 
With that definition of the word, a loaded gun in a kindergarden is unsafe.
yay!
The kindle download link doesn't seem to be working. =(
uh just paste the question man
When reading in your numbers and storing them in `e_m` you treat `e_m` as a one-dimensional array which stores your matrix in row-major format. Later in your fftshift, you are treating the same one-dimensional array as a two-dimensional array which is not allowed. You need to use expressions like `e_m[i*ord1+j]` instead of `e_m[i][j]` in your fftshift.
Please go to the link, it would literally take you 5 seconds to fill the password. Also the formatting is very nice there and every test case is uploaded.
no.
 for(i=0;i&lt;ord1;i++){ for(j=0;j&lt;COLS;j++){ e_m[i+ord1*j].r = real[i][j]; The calculation for the index should be `e_m[ i * COLS + j ]`
I am not going to click a link to a random website. Paste your problem here to get help.
Just bad programmers still others would argue
Can you figure out how to get rid of `a`, `b` and `input_len`?
Probably still less than the number of suicides caused by languages like Java. :D
`array1[i][j]` is the same as `*(*(array1 + i) + j)`. It is not a flat array, but it is an array to `M` pointers to `N` integers.
Sorry, not interested in registering on a website just to help you. Please post everything we need here.
 int array1[M][N]; is the declaration of a 2D array. Not an array of pointers.
`M` and `N` are (what it seems) constants that are used to declare the array. However, since C doesn't include any array-bounds checks, it doesn't know the size. (Althrough you can determine an arrays length at compile-time with some macros) So you won't find `M` and `N`.
Yeah. Definitely could, but I need to complete the other exercises up to today still, haha! Way behind. Work has been very busy. 
&gt; Probably these things shouldn't be written in C but it's fun and it's the language I know best. I don't thing **shouldn't** is the right word here hehe :P. I would say that they could be written in a different language *easier* than in C.
&gt; e_m[i*ord1+j] i tried to change it but still, there are errors can you please guide me how to the whole loop can be written according to your suggestion.
Then I'm sure it'd break your heart to know that Reddit is a corporation too. Also, as I mentioned, the Linux kernel recieves a large amount of contributions from corporations who, surprise, are contributing to it for their benefit.
In the [`README.md`](https://github.com/Isty001/mem-pool/blob/cbcfa7fa259fce03acb4729ab66acd930bb7a461/README.md): &gt; Ussage &amp; API Your [`.gitignore`](https://github.com/Isty001/mem-pool/blob/cbcfa7fa259fce03acb4729ab66acd930bb7a461/.gitignore) is pretty slim. Maybe use something like [gitignore.io](https://www.gitignore.io/api/c) to generate one. Also take a look about [`.gitattributes`](https://git-scm.com/docs/gitattributes) Some things to your [`Makefile`](https://github.com/Isty001/mem-pool/blob/cbcfa7fa259fce03acb4729ab66acd930bb7a461/Makefile): INCLUDE_DIR = /usr/local/include/mem_pool Why hardcode the include directory? sudo mv $(LIB) /usr/local/lib sudo mkdir -p $(INCLUDE_DIR) sudo cp include/*.h $(INCLUDE_DIR) Not every system has `sudo`. gcc $(CFLAGS) -D _POSIX_C_SOURCE=199309L $(TEST_SRC) -lmem_pool -o test.o Suddenly, one indention more (extra tab) and using `gcc` instead of `$(CC)` like before. Also, naming the executable `test.o` is a bit misleading because as I can see you don't generate a object file (`-c`) Let's take a look on your public header file [`include/mem_pool.h`](https://github.com/Isty001/mem-pool/blob/cbcfa7fa259fce03acb4729ab66acd930bb7a461/include/mem_pool.h): #define MEM_NO_BEST_FIT -1 What is it? By what is it returned? I would've used an enum, because to get debugger symbols (rather than a literal value `-1`). Also some other functions might be benefited to get some documentation. In the internal header file, [`src/internals.h`](https://github.com/Isty001/mem-pool/blob/cbcfa7fa259fce03acb4729ab66acd930bb7a461/src/internals.h): * [`check`](https://github.com/Isty001/mem-pool/blob/cbcfa7fa259fce03acb4729ab66acd930bb7a461/src/internals.h#L11-L15) macro * When `res` has eg. bit manipulation operators, the evaluation order isn't the one you expected. Use `(res)` inside the macro. * Maybe give a better name for the , like `check_or_fail`. * Why do you `exit` instead of returning an error? Also note that functions using them need some way to clean up in case of an error. Now let's dive into the implementation. Please note I haven't explicitly checked every line, especially because I'm too lazy to lookup pthread stuff. Let's start with [`src/utils.c`](https://github.com/Isty001/mem-pool/blob/cbcfa7fa259fce03acb4729ab66acd930bb7a461/src/utils.c): * [`mem_align`](https://github.com/Isty001/mem-pool/blob/cbcfa7fa259fce03acb4729ab66acd930bb7a461/src/utils.c#L5) seems to return an size rounded up to an alignment. I would have given it a better name. [`src/buffer.c`](https://github.com/Isty001/mem-pool/blob/cbcfa7fa259fce03acb4729ab66acd930bb7a461/src/buffer.c): * In [`buffer_new`](https://github.com/Isty001/mem-pool/blob/cbcfa7fa259fce03acb4729ab66acd930bb7a461/src/buffer.c#L6-L7), you allocate, twice, but never check if it was actually successfully allocated. [`src/fixed.c`](https://github.com/Isty001/mem-pool/blob/cbcfa7fa259fce03acb4729ab66acd930bb7a461/src/fixed.c): * Like previously, in [`pool_fixed_init`](https://github.com/Isty001/mem-pool/blob/cbcfa7fa259fce03acb4729ab66acd930bb7a461/src/fixed.c#L25) you also allocate without checking if it was actually successful. Also if you fix `buffer_new`, you probably also need to check the return value of `buffer_new`, so you don't make the same mistake. * In the same function, you use `mem_align` with a tenary operator (that just returns the lower value). Any reason not to define `min` like you did with `max` in [`src/internals.h`](https://github.com/Isty001/mem-pool/blob/cbcfa7fa259fce03acb4729ab66acd930bb7a461/src/internals.h)? * I've noticed that eg. in [`pool_fixed_free`](https://github.com/Isty001/mem-pool/blob/cbcfa7fa259fce03acb4729ab66acd930bb7a461/src/fixed.c#L95), you accept a `void*` parameter, yet you always convert it to an `Block*`. Any reason not to use `Block*` in the parameters directly? Sure, you need a declaration in the header file, but it doesn't hurt and is easier to see what it actually wants. [`src/variadic.h`](https://github.com/Isty001/mem-pool/blob/cbcfa7fa259fce03acb4729ab66acd930bb7a461/src/variadic.c): * Like before, [`pool_variadic_init`](https://github.com/Isty001/mem-pool/blob/cbcfa7fa259fce03acb4729ab66acd930bb7a461/src/variadic.c#L27) also doesn't check the return values of `malloc` (and, if fixed, `buffer_new`). (Stopped really reading because I'm tired)
this is the error which i am getting Description Resource Path Location Type assignment to expression with array type C/C++ Problem 
 this loop gives me the data in correct manner in the way i need them the problem is when i try to fftshift them Description Resource Path Location Type assignment to expression with array type C/C++ Problem 
The proper way to access `QueryInterface` of `dsBuffer` in C (COM) is actually: dsBuffer-&gt;lpVtbl-&gt;QueryInterface(xyz)
True, but I just used "pointers" it to make it simplier to understand (and it is used like that). Example from the [C99 draft section 6.5.2.1p4](https://port70.net/~nsz/c/c11/n1570.html#6.5.2.1p4): &gt; EXAMPLE Consider the array object defined by the declaration &gt; &gt; int x[3][5]; &gt; &gt; Here x is a 3 x 5 array of ints; more precisely, x is an array of three element objects, each of which is an array of five ints. In the expression x[i], which is equivalent to (*((x)+(i))), x is first converted to a pointer to the initial array of five ints. Then i is adjusted according to the type of x, which conceptually entails multiplying i by the size of the object to which the pointer points, namely an array of five int objects. The results are added and indirection is applied to yield an array of five ints. When used in the expression x[i][j], that array is in turn converted to a pointer to the first of the ints, so x[i][j] yields an int.
whatever...
Text like character names are normally stored in strings. The standard way to handle strings in C is as a null-terminated arrays of characters. You can then use functions like `fgets` to get the string and `printf` to display it. This topic is too big for a simple reddit comment, but the above should give you enough to google on. Just to get you started, though, here's a quick example: #include &lt;stdio.h&gt; int main() { char name[51]; // Allows for names up to 50 characters long, plus 1 more for terminator printf("What is your name? "); fgets(name, 51, stdin); printf("Hello, %s\n", name); }
Here's essentially a translation using better variable names. Is this clearer? void merge(int array [], int first_part_index, int second_part_index, int end, int other[]) { int current_first_part = first_part_index; int current_second_part = second_part_index; for (int i = first_part_index; i &lt; end; i++) { bool first_part_empty = current_first_part &gt;= second_part_index; bool second_part_empty = current_second_part &gt;= end; if (!first_part_empty &amp;&amp; (second_part_empty || array[current_first_part] &lt;= array [current_second_part]) { other[i] = array[current_first_part]; ++current_first_part; } else { other[i] = array[current_second_part]; ++current_second_part; } } }
Which describes exactly the equation array1[ i * N + j] If it were `*(*(array1 + i) + j)` then it would be reading a pointer from memory, and then reading an int from that pointer. Since we have the generated assembly, we can see that there is 1 memory read per operation, not 2. The supplied assembly shows that N is 9 and M is 15
Oh ok, I missed your point. Also I can't read x86 assembly, so I didn't looked a the generated assembly.
This isn't intended to create two ordered lists after being called once. It is called multiple times to sort many small subsections of a list, and then merge those sorted sections together, You really need to look at it within the context of the entire mergesort function. I recommend you check out the "bottom-up" implementation on the [wiki](https://en.wikipedia.org/wiki/Merge_sort), but here's my attempt to explain what happens. You start by breaking down the list into "runs" each containing one element of the array. You then call merge() to compare one run to the one next to it. In your example, merge() will be called six times to compare all of the pairs of sized-1 runs. After each iteration, other[] is copied to array[] and the process starts again. Here's what array[] will look like after each iteration: [3,5,8,7,6,2,1,4,9,11,10] [3,5,7,8,6,2,1,4,9,11,10] [3,5,7,8,2,6,1,4,9,11,10] [3,5,7,8,2,6,1,4,9,11,10] [3,5,7,8,2,6,1,4,9,11,10] [3,5,7,8,2,6,1,4,9,11,10] Not that the pairs [1,4], [9,11], and [10] are all already sorted. So, array[] isn't modified the last few iterations. From there, the size of each run is doubled, and you now look at sort together each sized-2 run. This time, it will compare the first element in each run, then copy it into other[] in order. Note that i is your index in the first run, and j is your index in the second run. Whenever you copy a value into other[], you increment the index in the run that value came from, so that you can now compare the next value in that run to the current value in the other. In the case of the first two runs you compare 3 and 7 (copy 3 to other[]), then 5 and 7 (copy 5 to other[]), then copy 7 and 8 over. Then, merge will be called to compare the third and fourth runs. Here we compare 2 and 1 (copy 1 to other[]), then 2 and 4 (copy 2 to other[]), then 6 and 4 (copy 4 to other[]), then place 6 at the end. Continue until all sized-2 runs are merged. Now your array should look like this: [3,5,7,8,1,2,4,6,9,10,11] Now, other[] is copied over into array[] and split your array into runs of size 4 and do it all over again, and keep doubling the run size until you've merged the whole array. tldr: This function doesn't create two ordered lists, it takes two ordered size n subset of a list and merges them together to make a size 2n ordered subset of a list. This pattern continues until the subset is the size of the full set. 
Except it's far, far easier to write vulnerable code in C than in a higher level language, even for an experienced programmer.
Can I write a kernel, systems tools with a managed language as those "higher level languages"... C main use as far I know is in System Programming, Embbedded and alike. So I could care less about the "higher" ones! haha
You can most definitely write system tools with languages other than C. You can do kernels too, albeit with a bit more difficulty. For embedded, C is often the only choice. However that's a different discussion entirely. It's totally possible to simultaneously recognise that C is incredibly unsafe and yet it's the only solution for a given problem. You seem to be saying that because it's the only option then it isn't unsafe (or perhaps that you just don't care). And obviously embedded/kernel work doesn't represent a good amount of the work that C is used for.
Incredible detail, thank you, I understand it now.
&gt; And obviously embedded/kernel work isn't the only thing C is used for these days. Good to know! haha...Maybe someday I will write some app in C! 
So you'll agree that C is unsafe?
I can tell you what the author meant for it to do, but not what it actually does, because the result of multiple consecutive calls to `ungetc()` is unspecified.
For all answers, nope! My question was not is C unsafe? but, Is C THAT unsafe?
Put 4 spaces in front of each line to format code for Reddit.
that would be great !
What have you figured out so far?
Put 4 spaces in front of each line to format code for Reddit.
There aren't multiple calls to ungetc in that.
You string is 8 characters long, but your loop is reading 10 of them. Why should it print `*H*I*`? What are the rules the program is meant to be following? You program doesn't have any code to print `*`, so it's not that surprising that it isn't doing so.
literally anything. Your job as a programmer is to figure out how to do X, how to convert it into code.
Yes, there are. It's a recursive function that calls `ungetc()` repeatedly while unwinding, with no intervening reads.
I haven't tested it, but with a `break` in the right place, I believe it should print `".H.I."`. An 's' in the input prints a period, a 'u' means to convert the next input character to upper-case and print it, any other character is printed as-is between angle brackets. So all OP needs to do is add the missing `break` and replace `"."` with `"*"`.
https://imgur.com/a/37bEY This is the full question, it's from a past final paper for my course.
i have edited the code ... sorry
thats the problem ... i have nothing 
It's telling you to rewrite the program so it produces the desired output, not look for the "bug" (though one does exist as has already been mentioned).
So we're not helping you fix *your* code. You sneakily tried to get the internet to do your homework.
Really? not even a little bit? Not even the first line?
**4 spaces in front of each line** please, and no blank lines between consecutive lines of code.
If you have nothing, start by looking up getchar, then figure out what the if condition is checking for, then figure out what the recursive call is doing. Finally, you'll need to look up ungetc, which is not central to the algorithm, but it could be important in the context of a larger program.
Do you really not understand the concept of *placing the cursor at the start of each line and hitting the space bar four times*?
printf is expecting an `int`, you're giving it a `char *`. That's not going to work well.
What do you think that second `printf()` does, exactly? Try to forget what you were thinking when you wrote the code and answer as if you had never seen it before. You need to take the two bytes at offsets 2 and 3 in `dataBuf` and compute the version number based on those. And read up on [endianness](https://en.wikipedia.org/wiki/Endianness) first. You could just use the struct from the documentation, but you will still have endianness issues, since HFS+ is big-endian and your system is almost certainly little-endian. (In theory, you also need to make sure the struct is packed; in practice, it already is.)
Something like an XML or JSON configuration file would work fine. You can even edit it by hand if you don't have the tool available. 
It's too complicated for some people. At least he didn't use funky underscores like some people - they can manage an obscure Unicode character but not a space? 
 wget -O book.mobi "$URL"
They copy-paste it from the submission guide that comes up when you create your post.
&gt; but the whole codebase has a ton of '#ifdef' and '#if' blocks that would break if the declaration statements are shifted from preprocessor blocks to variable (or functions that return variables) declarations. What's the best way to tackle this issue? Fix the dependence on the preprocessor for starters. You are going to have to store the config in a file of some type. A binary file will be the most efficient but some kind of text would be ideal if you can get it to fit in the Arduino. In your program you'll likely end up with a struct or two (depending on the logical ordering of the config) that the contents of the file will be read into, allowing you to perform runtime checks on the config as needed.
Thanks for the tip about endianness
Right, I removed "const". I was hoping I could just read all the data in one swoop. Is that not possible given the issues with size and endianness? Should I allocate memory for each header entry separately? I'm not used to parsing data at a low level so this is all new to me.
Well if you don't know about hackerrank you must be living under a rock.
didn't ask you to register anywhere
Look into ncurses.
Yes, but rather painfully. 
The problem with safety in C is that it involves a lot of "don't"-s and that's a lot of work. This being said, it's eminently doable. 
A classic case of this is the way we used to fake threads in DOS programs. You'd have an array of control blocks which contained all the state for the threads. Whether you added function pointers to those control blocks was up to you. But adding a state and writing the thing as a finite state machine was at least my preferred method. 
IMO, you have to constrain the behavior of C programs through design. Of course you're having to do manually what other systems provide for more automatically. 
&gt; Buffer overruns continue to be a huge problem and it's easy to write one by accident. I think it's the sort of thing that, once learned, isn't hard to maintain. It's kind of curious to me that there's apparently no good compendium on best practices for avoiding them. It shouldn't take that much - just divide the subject into synchronous/asynchronous I/O, ioctl() and memory moving. As I recall, it took a matter of weeks for me to get comfortable with not producing memory overwrites. 
Not "any program". It's possible to write perfectly unassailable things for say, a driver for a serial port protocol on an otherwise bare-metal machine.
There kind of isn't one, apparently. 
You really have to go well above and beyond MISRA it write safe C, I'm afraid. They're safe as in sfaety belts; not sufficient ( and in case, not all that helpful but nice in a group setting ) . 
 double fnord(double v) { int c = getchar(); if (c &gt;= ’0’ &amp;&amp; c &lt;= ’9’) { return fnord(v * 10 + (c - ’0’)); } ungetc(c, stdin); return v; } You can use http://jsbeautifier.org to beautify C code. (Doesn't work well with #include). As long as the first line is indented, the tool will add four spaces.
Well, you have to register with an email address to view your question. Not interested in doing that.
why so angry? 
C is not made to deal with string, if you write a C program that should deal with string, you will have to deal with a lot of pain. Most "safe" language usually got a string built-in type that handle most of the pain. 
You can print a carriage return \r and try printing over it, so long as it's on the same line
It's really hard trying to help when we only get snippets. You should make sure that your multiplications and additions to compute array indices in the fftshift code are evaluated in the right order. For example for `e_m1[d+ROW2*j]` do you want index `d + (ROW2*j)` or index `(d+ROW2) * j`?
GCC has an extension that lets you do local functions, which might also have closures. Not sure though. Many more "modern" features exist for C in extension form, which is better than bloating its core standard IMO.
Oh come on! This is one of the least voluminous programming books out there (only 272 pages including table of contents, introduction, appendices and index) but is regarded by many as one of the best, even though it's almost 3 decades old by now. It's a living classic. It's something you *want* to own, not just because it's a good read or a shining example of how to write textbooks, but also because acquiring it for yourself marks a significant stage in your life. You want that book like you want that framed diploma up on your wall to remind yourself, and others, of the journey you had taken to get where you are. It's inexpensive enough to go out and buy a physical copy.
This may be helpful: https://en.wikipedia.org/wiki/ANSI_escape_code . I'm using that as well to control the UI (see [here](https://github.com/krpors/hx/blob/3af45fd737a367c5ca982c630852d5dce2e65ae9/editor.c#L389), for example).
**ANSI escape code** ANSI escape sequences are a standard for in-band signaling to control the cursor location, color, and other options on video text terminals. Certain sequences of bytes, most starting with Esc and '[', are embedded into the text, which the terminal looks for and interprets as commands, not as character codes. ANSI sequences were introduced in the 1970s to replace vendor-specific sequences and became widespread in the computer equipment market by the early 1980s. They were used by the nascent bulletin board systems to offer improved displays compared to earlier systems lacking cursor movement, a primary reason they became a standard adopted by all manufacturers. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
1. Not a "quirk" but simply function pointers existing. Parenthesis clearly show what is being expressed (plus a real-life example would probably use spacing for further clarification). 2. Yup, hate this one too. 3. Again, real-life examples would probably use comments or formatting for readability. Plus typedefs are common for function pointers. 4. Applies to any symbol with context-dependent meaning. Usually clear from context (and, again, comments) what is meant. 5. Yea, that first example is strange. You sure modern compilers even allow this without spewing warnings? 6. Trigraphs, not trigrams. Old-style function definitions are an oddity, yes. ´-Wold-style-definition´ might help (for GCC anyway). 7. Omit the optional parts. If you want to be specific about integer widths you should be using ´stdint.h´ anyway. Typedefs or defines might also help. 8. Having ´a++´ and ´++a´ is a boon for writing concise code.
What about re-using them? Put your data structure in a header file (or header + source) and include that in future programs.
I know you're being sarcastic, but I do actually *like* segfaults personally. Find them quite nice to debug since you just `gdb` and let the program run until it segfaults and that's that. Having that be the one type of "exception" in C certainly is simpler than having many different kinds (or something ridiculous like sub-classing exceptions like in java).
What are you referring to about clang/gcc there? If you want the compiler to be stricter about the standard use `-pedantic-errors` (doesn't force standards compliance, but prevents you from unknowningly doing something that standard explicitly disallows).
Thank you for your notes!
As you can see in the main loop where I am reading the files and then storing them in the matrix e_m1[d*COLS+j].r = real1[d][j]; e_m1[d*COLS+j].i = imag1[d][j]; so i have to index them according to the above method so that i can get the correct data just fftshifted, Now the way the code of the fftshift has to be written is creating confusion for me. all things which are needed for this section i think i had included them in the code but if there is still need of some extra information, kindly guide me i will insert that information in the code to make it more clear and easy to understand so that you can help me in a more easy way.
Just finished [dvector](https://github.com/BareRose/dvector) and replaced ccVector in my main project with it today. Might even be useful for your project with it being 3D and all.
The egcs split and then gcc 2.95 was a paradigm shift in how gcc was developed. They went from strong stability and predictable behavior to much more aggressive optimizations. Before even if there was some dubious code and undefined behavior things behaved in ways that were possible to understand, debug and, dare I say it: rely on. Then a bit later Clang appeared as a serious competitor to GCC. Before Clang GCC had an almost unassailable market position as the only widely used compiler (at least on the unixy side of things) because of their vendor lockin (a very large amount of code was and still is written in gnuc, not c) and portability. Clang destroyed that position by generating better code and being almost entirely gnuc compatible. Since then (pretty much the past 10 years), GCC and Clang are competing not by stability and predictability, but through benchmarks. And the low hanging fruit for optimizations have all been used up. The best way to achieve great benchmark scores today is interpreting the standard in the most pedantic way possible. Where pedantic means "if anything comes even within sniffing distance of undefined behavior, generate code that will win benchmarks, screw everything else". A good example: #include &lt;stdio.h&gt; static void (*foo)(void) = NULL; static void never_called(void) { printf("this is never called\n"); } void never_called2(void) { foo = never_called; } int main(int argc, char **argv) { foo(); return 0; } What do you think happens when you compile this with clang and run it? Are you sure it will crash? It actually prints "this is never called". Since crashing is just one possible thing that happens when undefined behavior is encountered and calling a NULL function pointer is undefined behavior clang drew the conclusion that undefined behavior can't happen and therefore the only thing that makes sense is if magical pixies will call `never_called2` (since `foo` is static it can not be set outside of this compilation unit and the only thing from this compilation unit that sets it sets it to `never_called`). This is absolutely according to the standard. It also means that the compiler made your code undebuggable because crashing is our most valuable tool for finding errors. There are hundreds of examples like this. GCC once removed critical argument validation of system call arguments in the linux kernel because technically they were integer overflows and therefore undefined behavior which, while technically correct, also led to exploitable security holes. Sure, you can argue that everyone should be writing pedantically standards compliant code and this wouldn't be a problem, but I consider that argument the on the same level as the catholic churches attitude to condoms and HIV. Condoms encourage promiscuity, promiscuity leads to spread of HIV, therefore we'll stop HIV by outlawing condoms. Yes, abstinence is better than condoms for preventing HIV, but since abstinence has never worked in the history of humanity, condoms are a good second choice and you don't stop the spread of HIV by outlawing condoms to encourage abstinence. Same thing goes here, it would be nice if all code was perfect all the time, but it isn't and has never been, so it would be nice to have the compiler be a little helpful sometimes, not actively doing its best to fuck you over in the most unpredictable and undebuggable way as soon as you slip up once.
As far as I can see in this case, you want to use the single-subscript format for all the operations in fftshift. Looking at your code, you have missed one instance e_m1[d*COLS+j] = e_m1[d+ROW2][j+COLS2]; should be e_m1[d*COLS+j] = e_m1[(d+ROW2) * COLS + (j+COLS2)]; Looking at the rest of your fftshift, you seem to be missing a bunch of parentheses, and your indices are evaluated according to operator precedence, meaning that multiplications are evaluated before additions, leading to "wrong" indices. For example, you probably want e_m1[(d+ROW2)*COLS + (j+COLS2)] = tmp13; instead of e_m1[d+ROW2*j+COLS2] = tmp13; It may be helpful for you to define a macro which allows you to specify row and column individually, such as #define MATRIX(m, x, y) (m)[(x)*COLS + (y)] which you can then use in your fftshift code to simplify your statements. For example, when using the `MATRIX` macro, the statement e_m1[d*COLS+j] = e_m1[(d+ROW2) * COLS + (j+COLS2)]; becomes MATRIX(e_m1, d, j) = MATRIX(e_m1, d+ROW2, j+COLS2);\ Note that I kept the macro general, so you have to provide the array you wish to access as a matrix as the first argument.
Yea that does sound a bit bullshit. Would be much smarter if they had an option that warns on any undefined behaviour, instead of invisibly abusing it to win benchmarks. IIRC compiling in `-O0` should turn off all optimization and yield the more debuggable code, though if your issue is caused by optimizations in the first place you're pretty much on your own. 
I haven't seen a lot of c matrix math libraries. But I am curious why you are passing things by value in and out of your functions. The mat4 can get pretty big, so you are doing a lot of copying. Did you consider passing the data in/out using pointers? 
There is no such things as "turn off all optimization" the way most people seem to understand it. An eternity ago compilers would generate code for one statement at a time. Back then, turning off optimizations generated code that you could follow statement after statement and line after line. Those times are long gone. Many things that 30 years ago would be considered extravagant waste of CPU time and only enabled at the highest level of crazy slow optimizations are now done in the parser. Mostly because the compiler developers don't want to effectively maintain two different versions of the compiler in one source tree. So in that example, if the compiler keeps track of all the possible values of variables in some fundamental stage of the compilation and it would be more effort to disable that code sometimes, it will keep track of those values and the removal of undefined behavior will just happen naturally. `-O0` just means "don't put additional effort into making my code better". But it says nothing about what the base line for the lowest level of effort is. I've already read arguments in a compiler that -O0 shouldn't put all local variables on the stack (as gcc and clang still do) because it takes too much effort to maintain the dumb code rather than just always do proper register allocation. The debuggability argument still won, but it won't for much longer.
I wrote this to replace ccVector in my projects, which actually uses pointers for matrices. The main pro of that approach is that you can do `m[i][j]` directly by typedefing your matrix type as a 2D array. The downside is having to juggle pointers and needing a copy function. Passing by value makes things much easier to use, no need to copy a matrix into a buffer just to multiply it with another one, and you can chain functions. As far as size goes a mat4 of floats is 64bytes, which isn't all that much these days, plus local variables get put in registers/stack, which makes them faster. I did consider providing two versions for each matrix function, the normal one and one by pointer. Don't have a use for this personally so it was dropped, though I may in the future.
I got a 100% on my project, an 8080 emulator and operating simulator 
Cool, thanks for your explanation.
As someone who does about the opposite, I don't know how you can stand slumming it with us in interpreted languages. :)
&gt; which sacrifices everything you could ever want in a GC purely to minimize latency. What exactly does their garbage collector sacrifice? &gt; Go literally ignores any and all advancements that have been made in the last 40+ years of programming language design. From type system features to various abstractions to even the oh so loved GC, which sacrifices everything you could ever want in a GC purely to minimize latency. That's the whole fucking point of Go: To build a language with only those features you actually need to write real world applications and all features in the language implemented well without any cruft or complications. I think they succeeded in this regard and it's part of why Go is so popular. When you program in a “fancy” programming language like C++ that has every feature under the sun and a kitchen sink, you have to spend a lot of time thinking about these features, even if you don't use them yourself (for example, because libraries you want to use use them). I want to spend my valuable time thinking about my problem, not about the complications of the programming language I use. Go ticks all the boxes in this regard; it's so simple, there is no complexity to ponder about. Every line of code has clear semantics with no hidden magic going on. That's super useful when trying to be productive.
Too bad!
NASA does a pretty good job of avoiding them... But holy fuck does it take a lot of energy and time and money.
Do not post this sort of personal information on reddit. Also, note that this is a C subreddit, so I'm not sure how Mr. Stroustrup is on topic.
Ive read in two books that buffer overflow happens cause programmers lack proper system architecture knowledge while written programs in low-level programming languages as Fortran, C ...
Buffer overflow may well happen when someone has no clue what they're doing. But it mainly happens when programmers make mistakes. Even expert programmers who do this stuff professionally make such mistakes and even more professional programmers make similar mistakes when they don't catch the first programmer's error in code review. It happens quite regularly, or you wouldn't see such security vulnerabilities in literally every major low level project ever.
Judging by how faster corporations are eager to receive products one can easily pinpoint why those mistakes may be as recurrent.
Since this is a header library, all these functions are likely to be inlined, and so the argument passing semantics don't matter. If they're not being inlined, then you've got bigger issues. Besides, this is [a place where value semantics are desirable](https://www.youtube.com/watch?v=eR34r7HOU14#t=39m) as it eliminates aliasing issues. 
[removed]
The Creative Commons licenses are intended for content, not software. The closest equivalent for software is the ISC license.
Is this a C or C++ question? This sub is specifically for C. For C++, you want /r/cpp_questions or /r/learnprogramming. Regardless, what part are you having trouble with? What have you written so far?
If this is a C question, you really need to ask on /r/C_Homework.
ISC is closer to MIT than it is to Public Domain. Unlicense is a Public Domain license intended for software, though it has some fatal flaws that make it no better than informal Public Domain. Also, CC0 is actually the exception to what you've said, see the [CC0 FAQ](https://wiki.creativecommons.org/wiki/CC0_FAQ#May_I_apply_CC0_to_computer_software.3F_If_so.2C_is_there_a_recommended_implementation.3F). This is further confirmed by its appearance on [GNU's license list](https://www.gnu.org/licenses/license-list.html#CC0). As it stands, CC0 is in fact the only viable Public Domain license for software, as all alternatives are either not Public Domain (like MIT, ISC, which are close but require attribution), or not legally valid (Unlicense, informal).
&gt; Passing by value makes things much easier to use, no need to copy a matrix into a buffer ...because the compiler does it for you. The arguments are copied onto the stack when the function is called. Also, you probably don't want to use `DVECTOR_EXTERN`, ever. You are better off letting the compiler inline these functions, saving you the overhead of an indirect function call and in many cases avoiding the aforementioned copying of arguments.
I'm specifically referring to you *as the programmer* having to do the copy (by making a call to a copy function). Implicit copying is not only less effort on the programmer's part, but also allows more room for compiler optimization (as you mentioned yourself). Figured I'd include the option for extern anyway. Even externs can be inlined, usually not reliably, but with link time optimization definitely. `-flto` in GCC. I did seriously consider making `DVECTOR_STATIC` default, and may even make it so in the future. If I myself (or someone else) gets around to seriously testing this and shows that extern is truly just abysmal compared to static without LTO I would probably remove the extern option entirely.
Use CC0 if you must, but at least use it correctly. You need to include your name and the copyright year(s).
These are structs, so there is no “copy function”, just the assignment operator; otherwise, pass-by-value would not work.
i put it on “” 
That's not C's fault, smart ass: it's the fault of poor development practices that were also neglected by those in charge. You should actually read the audit results as well as the court transcript. The people who actually went through the entire code base were appalled at how poor the code was written. It wouldn't have made a difference if it was written in Java. You're probably just a Rust fanboy taking part in the resistence, trying to spread propaganda.
Way to be just another Rush shill.
At least a decade.
https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e lol no generics, lol if err != nil. I understand the benefits of simplicity, but Go is missing such damn essential features. Hell even the creators of Go said that it was made because their developers aren't good enough to handle a proper programming language. That alone should be enough for people to not want to touch it.
EOF isn't a real ASCII/Unicode value, it's simply set to negative 1, and the function sees that and errors on it. since -1 is stored in an unsigned char, it's value is equal to the size of the char (almost certainly 8 bits) being set to 1 aka 255.
I don't want generics. I never had a real life problem where generics were needed to solve it in a satisfactory way. I want explicit error handling. It's so much clearer than exception's implicit non-local gotos and need much less brain power to use than monads or other high-order function based error handling schemes.
&gt; I don't want generics. I never had a real life problem where generics were needed to solve it in a satisfactory way. That is honestly one of the dumber things I have heard. Have you literally never wanted any kind of generic data structure? &gt; I want explicit error handling. It's so much clearer than exception's implicit non-local gotos and need much less brain power to use than monads or other high-order function based error handling schemes. That just screams of anti intellectualism, `do` notation for errors is not complicated at all. Not to mention how silly it is that Go returns a product type of error and result instead of a sum type.
&gt; That is honestly one of the dumber things I have heard. Have you literally never wanted any kind of generic data structure? My needs are more than satisfied by the maps and arrays provided by Go. When I need a separate data structure, it has always been extremely specific to my use case, negating any need for generics. &gt; do notation for errors is not complicated at all. Having programmed in Haskell for 6 years before switching to C, I can say that it's not nearly as simple as explicit error handling with error codes as the entire control flow is implicit and thus extremely unclear once you leave the trivial case of a sequence of evaluations chained with `&gt;&gt;=` (or `do` notation, whatever you prefer). All these fancy combinators just make programs much harder to understand because they all do very similar things with minor nuances which have to be understood exactly to comprehend what actually happens on error. A series of error checks with if-statements is so much easier to read and understand, especially if you are reading code you haven't touched in the last few years, that the extra time you need to spell that out explicitly is a more than welcome trade off. &gt; Not to mention how silly it is that Go returns a product type of error and result instead of a sum type. Sum types are cumbersome to work with because you have to explicitly match against the type constructor. This just complicates the program for no apparent benefit.
I didn't receive a notification for this comment. Thank you for the detailed response!
Thanks again!
&gt; It's a living classic. It's something you want to own, not just because it's a good read or a shining example of how to write textbooks, but also because acquiring it for yourself marks a significant stage in your life. You want that book like you want that framed diploma up on your wall to remind yourself, and others, of the journey you had taken to get where you are. In the end it's just a programming language... still an important one, but you can do fine without C in many areas nowadays. Learning about general data structures, algorithms, other CS topics like networks, operating systems, compilers etc. and also domain knowledge (well.. you usually want to solve a problem with programming) is more important.
Your questions make little sense. What are you trying to do?
I'm trying to deck my system out, but first learn how to make a simple program that has a cool gui.
I found the Windows API reference on msdn but not sure if it's the same as the windows.h declarations??
Yes - everything in Windows.h, and the rest of the windows SDK, is documented on MSDN
GUIs in C are not trivial. You might want to either start with a simpler C project, or a GUI in a language that's more suitable.
Your post makes no sense. How is making a program in C going to "deck your system out"? If you don't know how to program, you should know that making a graphical program in C is like being handed a pickaxe and a shovel and being told to make a car. 
I love your analogy!! Although maybe because I am proud to say I made a car with a pickaxe and a shovel. It was a Win32 pickaxe and Win32 shovel but still. :)
Check his post history. He may be a very elaborate troll.
It's all in the name.
You should format it correctly and try to explain to us what you're trying to accomplish if you want us to be able to help you at all.
How do i do that? and I am trying to just make 5 char, booleans, integers,doubles and floats, and display an output for each of those, there is an error with it so i was just asking for help.
What is the error?
Missing type specifier- int assumed
&gt; Missing type specifier- int assumed 
Alright I just fixed your code enough so that (a) I can read it and (b) it is syntactically valid: https://pastebin.com/qarU6JDA First of all, your comment at the beginning wasn't correct. You start a multi-line (or inline) comment with `/*` and end it with `*/`. The `*` is needed. You can do single-line comments starting with `//`, which ends at the end of the line. Next, that's not the "conventional" way of defining primitive variables. char a = 'a'; bool THIS_IS_A_BOOLEAN = true; int ROBLOX = 9; double LIFE = 1000000; float MAGIC = 1.11; // etc. Also, make sure that you follow thisNamingConvention or this_naming_convention for local variables. Find something that works and stick to it. C doesn't have any rigid set of naming conventions like Java or Rust or C# or any other language does, so there's a lot of freedom is what is commonly accepted by the community as "correct naming". Also, you only actually tried to print one variable, `MONEY`. You defined a bunch of local variables but never printed any of them except for one. 
Thanks for the help! May I know what was wrong with the syntax so I don't make this mistake again?
The first thing I noticed is that your comment syntax was wrong. There might have been other things but GCC is smart enough to fix minor syntax issues for you so that it can collect as many errors at once for you to fix.
What happens when you fix your printf format to be the proper one for a short? day *is* a short, right? Is your file using the same endianess as the computer you're running it on? Are you sure you're reading from the right part of the file? Did the read succeed at all?
nothing changes when i use the proper format for short int ,i dont really know about endianess, im sure about the part of the file becuase i have other things behind and they all read fine and yes
Show a complete program and paste the exact output
What does the file contain? `fread()` is for reading binary data, so if your file contains an integer in text form, then that's not going to do what you think it does.
void Ler_ficheiro_binario(struct dados pessoa[]){ int i,j,bi; FILE *ficheiro_1; char doc[80]; char part[20]; char dest[20]; char chegada[11]; short int day; printf("Qual é o nome do ficheiro?\n"); scanf("%s",doc); ficheiro_1 = fopen(doc,"rb"); while (ficheiro_1==NULL){ printf("Erro"); printf("Qual é o nome do ficheiro?\n"); scanf("%s",doc); ficheiro_1 = fopen(doc,"rb"); } i=1; while(!feof(ficheiro_1)){ fread(&amp;bi, sizeof(int), 1, ficheiro_1); pessoa[i].id=bi; printf("%ld",pessoa[i].id); fread(pessoa[i].nome,sizeof(char), 51, ficheiro_1); pessoa[i].nome[51]='\0'; printf("%s",pessoa[i].nome); fread(pessoa[i].cidade_partida,sizeof(char), 11, ficheiro_1); pessoa[i].cidade_partida[11]='\0'; printf("%s", pessoa[i].cidade_partida); fread(pessoa[i].cidade_chegada,sizeof(char), 11, ficheiro_1); pessoa[i].cidade_chegada[11]='\0'; printf("%s", pessoa[i].cidade_chegada); fread(&amp;day, sizeof(short int) ,1, ficheiro_1); printf("%hd\n", day); fgetc(ficheiro_1); i++; }
the file only contains binary
Can you output a hexdump of th file (try `hd filename`) so I can understand your problem better?
Please don't post this kind of content.
C the complete reference
Would you like to explain why you believe so?
&gt; Thank you, ~~C~~ shitty programmers. FTFY 
I'd reccomend using libgen.io instead, and buying a book if you consider it worth keeping. For C, 'The C programming Language' by K&amp;R is a classic
&gt;"creating an algorithm to find the most efficient route from the list and to give him the new itinerary" what you want is dijktra's algorithm
None of your function calls check the return value. But the return value is how they communicate failure to you. Don't ignore the result of standard library (or other) functions.
&gt; My needs are more than satisfied by the maps and arrays provided by Go Maps and slices in Go are generics.
It's either an endianness issue or you've got the reads unaligned with your data. 4864 is 0x1300 and you're looking for 0x0013 Is the string before the day always 11 bytes long?
Yes. And because they are builtin, I don't actually need full blown generic programming. What exactly is your point?
My point was you aren't arguing against generic programming. You actually rely on it. You're campaigning against programmers being able to define their own generics, which is different and in my opinion an awkward stance to defend; even the Go team doesn't take that stance and they take some odd stances.
Yes, this will most likely not work. Your professor has given you a problem called "Traveling Salesman Problem" or short TSP. This is one of the most fundamental NP-complete problems and therefore it realistically solvable for larger Ns. It warrants the big amount of bonus points. 
This has nothing to do with Dijkstra since they don't use a graph for the distance calculation but lan/lot. At least if I understand OP correctly. 
I got i the binary file there was an extra space but thx too all who helped
It sounds like OP is supposed to create a complete graph with the edges weighted with the distances calculated from the coordinates 
Generic programming comes at a great complexity price. I am not willing to pay that price.
Tasks have a certain complexity and it will be payed in the solution in one way or another. You can’t take complexity from a tool used to solve complex tasks and still solve those same problems without reintroducing the complexity elsewhere. You could argue that some solutions aren’t optimal and complexity can be removed, but that doesn’t apply to generics in the way you’re saying. Basically, your argument holds if all you do with Go is simple things. I don’t mean simple in a demeaning way; I loved using Go inside Google where entry level engineers like me barely leave the IO boundary, just connecting and routing communications between other complex services. That’s *the point* of Go: give entry level engineers in a high turnover workforce enough rope to connect services and not enough to hang themselves. Once you leave the IO boundary and start doing complex things, the complexity Go omits is going to sneak in in other nasty ways and if you’re going to have that complexity regardless, it would be nice to have your language help organize it.
That would be one way to solve this and in this case probably the most inefficient. The way I would most likely solve this: Let N be the number of cities 1. Create NxN distance matrix of cities 2. Calculate travel length of the given city permutation 3a. If N &gt; 15 cosider if the points are worth implementing a complex heuristically algorithm 3b. IF N &lt;= 15 create all permutations and compute their travel length 4. return shortest permutation Note: A permutation this case could be the following Cities: New York : N Berlin: B Paris: P NBP NPB PNB PBN BPN BNP If we get fancy we could use symmetry to prune them by half. (BPN == NPB in our case)
It's _incredibly_ complex to imagine a function that takes some type T and then returns another but different type U.
That's not where the complexity comes from. The complexity comes from how generic functions interact with other features in the language, e.g. subtyping. Just look at how complicated all the nuances are in Java. I don't want to have to think about this.
&gt; Tasks have a certain complexity and it will be payed in the solution in one way or another. You can’t take complexity from a tool used to solve complex tasks and still solve those same problems without reintroducing the complexity elsewhere. Removing a layer of abstraction (e.g. a data structure being generic) removes complexity at no extra cost. I am writing my programs like this and I'm doing just fine. I don't see how the extra complexity received from using generic programming would help me solve my problems better. It's just useless extra complexity. &gt; Once you leave the IO boundary and start doing complex things, the complexity Go omits is going to sneak in in other nasty ways and if you’re going to have that complexity regardless, it would be nice to have your language help organize it. What sort of complex things are these? I always see people talk about mysterious complex things but I've never actually seen someone give a compelling use case that goes beyond “but I must totally have arbitrary generic data structures” which is not a use case per se as it isn't an actual problem you try to solve. Perhaps the underlying problem could be solved just as well without making the data structure you want to implement generic, and usually it can.
&gt; That's not C's fault, smart ass: it's the fault of poor development practices that were also neglected by those in charge. Nah, C still has dozens of stupid breaches in it's type system making it nearly impossible to build any huge secure program. Any typical C program/lib has a lot of unmaintainable macros, void* shit, NULL ptrs, unchecked array bounds, and is unmaintainable mess, just like openssl (and nearly any other big C project). It is a year 2017, we have dependent types, GADTs, parametric polymorphism, RAII/advanced GCs, and people still try to write something in a 40 years old language, where you can add character to an address or get 40th element of an array of size 30. That's silly. &gt; it was written in Java. Java is also an ugly algol descendant with nulls. &gt;Also, way to cite one meme-tier example out of literally thousands of mission critical projects If some invariants could be encoded with some help of the language, that should be done. There is a thing called progress, type systems and PL theory advanced a lot within last four decades.
&gt; A series of error checks with if-statements is so much easier to read and understand It might be easier to understand for someone who doesn't know anything more expressive, but for people who do, a wall of text is harder to read than a few simple expressions with a known meaning. I'm under the impression Go was created so that companies could hire less knowledgable = cheaper developers. 
I want to focus my mental capacity on the logic of my program, not on the subtle behaviour of the error handling monad. I've programmed enough Haskell to be able to appreciate the simplicity of not having to do that.
Isn't this just a statistics question? You say you want to plot expected values, not actual values. That would imply no need for a simulation.
The expected values could otherwise be referred to as the average values. The expectation values are calculated in the same way that a mean average is calculated; the sum of all values is divided by the number of values. 
Perhaps it would be more appropriate to say that the simulation is required to verify the statistical relationship
Great summation. I'd note that most of the approximation and the most efficient optimized algorithms are pretty challenging for someone who is in their first semester of programming. Actually implementing a reasonably accurate one is probably more work than the original assignment.
For the bonus problem T they're supposed to create a program that can generate a graph (itinerary) based on a list of cities. The graph is the output, not the input.
Dijktra's algorithm is for finding the shortest path between two nodes in a graph, i.e. passing through the fewest nodes and eventually the least weighted edges. OP needs to pass through all the nodes, there is no start and end node and there is no notion of an edge (nodes are connected to all other nodes)
Yes, the earth is a sphere A quick example with 3 cities: - Tokyo - New York: 11 000km - Tokyo - Sydney: 8 000 km - Sydney - New York: 16 000 km If I understand your algorithm right, it would give the route Tokyo - Sydney - New York (8000 km + 16 000 km = 24 000 km). The optimal route would be New York - Tokyo - Sydney (8000 km + 11 000 km = 19 000 km)
It reads a numeric string from standard input and converts it to a double
You left too much out of your question. People are filling in with their assumptions and preconceptions and answering based on what they think the assignment is. It would be better if you gave us all the details so we didn't have to guess.
I didn’t even think about this thanks.
Create a meaningful program.
next? go ask for the C++ boys in the correct sub: https://www.reddit.com/r/cpp/
C != C++
Do a project. Doing a project is the best way to learn about one language properly. 
Would you have the share the reward with your professor? [million dollar prize](https://en.m.wikipedia.org/wiki/Millennium_Prize_Problems) 
21st Century C htpps://www.amazon.com/21st-Century-Tips-New-School/dp/1491903899/ref=sr_1_2?ie=UTF8&amp;qid=1512881292&amp;sr=8-2&amp;keywords=21+c+programming
What do you mean subtle behaviors of the error handling monad? There is nothing subtle about `instance Monad Either`, it has extremely simple and well defined semantics. I personally want to focus my mental capacity on the logic of my program, not on figuring out the massive amount of boilerplate and scaffolding needed to actually express what I want my program to do.
You're missing the closing bracket to main and you have cout &lt; &lt; "exper.. delete the extra space &lt; &lt; -&gt; &lt;&lt;
Learn how to do it in C.
I believe gnu is the compiler and I appreciate the help. Any advice on making this code functional to my instructors specification?
This isn't a very difficult problem to solve. To my understanding their asking you supply an angle to sin and output the answer as a list of some fashion. You have everything you need to solve this problem. If you show me more progress i'll gladly help you debug it.
This is the C sub. Try /r/cppquestions
&gt;The expected values could otherwise be referred to as the average values. Expected value is a property of the *population*. The average you're talking about would be a *sample* mean. 
Because i've actually debugged it? The function and variable names are completely meaningless. There is a ridiculous number of function macros for absolutely no reason. The algorithms being defined are done so weirdly and it's made unreadable. They literally use pointer arithmetic to increment in a loop in multiple places for no discernible reason. FFmpeg is hands down the worst code base i have any experience with.