Yes, exactly. Identifiers starting with __ are reserved for the C library itself. http://stackoverflow.com/questions/1449181/what-does-double-underscore-const-mean-in-c/1449301#1449301
Yes, the C standard library will be linked to your program by default. You can change this by compiling with the `-nostdlib` option (assuming you're using gcc); then the C standard library won't be linked in. You might find this interesting: https://blogs.oracle.com/ksplice/entry/hello_from_a_libc_free The C standard library is usually linked as a "shared library", meaning that it's not actually entirely inserted into your executable, but rather a .so or .dll file is loaded at runtime. On Linux I can use the `ldd` command to see what shared libraries are loaded by a given program. For example: $ ldd ./a.out linux-gate.so.1 =&gt; (0xb779c000) libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb75d4000) /lib/ld-linux.so.2 (0xb779d000) The third line shows that this program (`a.out`) uses the C standard library (`libc`), which, in compiled form, is found in `/lib/i386-linux-gnu/libc.so.6`. A nice book about this stuff is [Linkers and Loaders](http://www.amazon.com/Linkers-Kaufmann-Software-Engineering-Programming/dp/1558604960) by John Levine.
The C standard library is linked to by default, and it's linked dynamically. But this is a special case. Let's pick a different library. zlib is commonly used for compression. If you #include &lt;zlib.h&gt; and then call the function "zlibVersion", and then compile and link your program, you will get a linker error. (This is for gcc on Linux) You have to manually specify the libraries you're linking against. You can either specify "libz.a" to statically link against the library, or "-lz" to dynamically link against libz.so. (You leave off the leading lib and the file extension when dynamically linking.) In the static library case, the .a file is really a bunch of .o files combined together. So the linker will go into the .a file and will only include the .o files that are needed by the symbols that you used.
Great link! Sometimes I spend all night searching for stuff that explains it as simple as that. That makes me wonder...my executable must contain code that loads the dynamic libraries at run time? Would I see it if I decompiled the code?
Sort of. Including the header doesn't cause linkage with libc, it just gives you the right prototypes and constants etc. to let your compiler type check your code. Libc is added to the link by the compiler driver by default. You can override that but almost never want to. 
Let me see if I understand this in my own words. When I compile a program it generates an object file with a symbol table that includes all the identifiers I used. Because I included zlib.h and made a function call to zlibVersion, the linker expects to find another object file with this code (since my code didn't have the function's definition). I tell it where to find it by passing the name of the library. It then checks that library's symbol table and then links in the code it finds. If it doesn't, then it creates an unresolved symbols error. 
&gt; Because I included zlib.h and made a function call to zlibVersion It's really only because you made the function call. (But the header file made the function call not a compile error.) But yeah, that's pretty much correct.
Thanks for making the distinction for me.
(For ELF:) There's a special field in a file that needs dynamic linking, that specifies an interpreter or loader; typically some variant of `/lib/ld.so`, but it could theoretically be anything. That loads in all of the dynamic stuff and sets up pointers, tables, etc. so that the file can run properly.
Helpful hint: If you want GCC to vomit up every last command it runs when it builds your program, use the `-v` (verbose) option. This will tell you where most of the system libraries are and how they're included.
To clarify further... libc is the library name on most open source platforms. On the Mac, libc is actually contained in libSystem. On Windows, msvcrt.dll contains this functionality. The linker for your platform knows where to get the standard C library and includes the linkage for your program automatically. If you link with -nostdlib, this automatic inclusion will be disabled and you'll need to manually link a copy of the C standard library.
Do you have a (possibly beginner's) book to recommend for learning more about the GNU toolchain? I don't want to get too deep, but am interested in learning more tips like using `ldd` to view the shared libraries.
Could you post the code for printf I've always been interested in what it looks like and have never been able to find it...
Well `main` takes `argv`, which gives you an ~array of ~strings that you can work with. If you're sticking solely with `if`/`else if`, you'll need to 1. Check to make sure you got enough arguments; `argc` should be 3, indicating you got the program name (`argv[0]`) plus two more arguments (`argv[1]` and `argv[2]`). 2. Convert the second argument from a string to a number. (Probably either `strtod`/`strtoul` from `stdlib.h`, or `sscanf` from `stdio.h` is your best bet---I'm not sure whether you actually want an `int`, which would be odd, a `float`, which would be okay but silly, or a `double`, which would make sense. These are non-intuitive if you're not used to them, so I threw some code at the bottom.) 3. Throw out an `if` or `else if` for each possible company name; `string.h` gives you `strcmp`, which you can use to check for string equality: [else] if(!strcmp(argv[1], "Company Name")) 4. In the body of the [`else`] `if`, call the company's function with the amount as its parameter. That said, this could be much, much simpler/more compact code with some other implementation techniques (e.g., `for` loop + arrays, or arrays of structures). Code for amount-arg-checking: // Gets you a double; needs &lt;stdlib.h&gt; char *tail; double amt; if(!*argv[3] || (amt=strtod(argv[3], &amp;tail), *tail)) // If you can't take negatives, do if(!*argv[3] || (amt=strtod(argv[3], &amp;tail)) &lt; 0 || *tail) // Gets you an unsigned long, which you can make into an int // Needs &lt;stdlib.h&gt; and &lt;limits.h&gt;. char *tail; unsigned long amt; if(!*argv[3] || (amt=strtoul(argv[3], &amp;tail, 0)) &gt; INT_MAX || *tail) // Gets you a float/double/int, but doesn't do a good check WHATEVER_TYPE amt; if(sscanf(argv[3], "%X", &amp;amt) != 1) // where %X is %f for float, %F for double, or %d for int The body of each `if` should be something like { fprintf(stderr, "invalid amount \"%s\"\n", argv[3]); return 1; } 
Apologies for the really late response! I've been considering switching to Ubuntu or Linux Mint on my laptop for a few weeks now and C development is giving me another push to do it. Thanks for your suggestion!
Apologies for the late response! I've been considering switching to Linux Mint or Ubuntu for a few weeks. Which would you recommend? Are there any big reasons to switch to Linux? I've got the K&amp;R book - it's fantastic! :-)
The third argument to your for loop is incorrect. for(i=low+width;i&lt;=high;i+width) Should read for(i=low+width;i&lt;=high;i+=width) The former only returns a value equal to i+width, the latter actually modifies i. Also, valueofi=1/(2*pow(e,((i*i)/2))); is nearly identical to valueofj=1/(2*pow(e,((j*j)/2))); which is a pretty good hint that you should just make a function called something like double integrand(double x) { return 1/(2*pow(e,((x*x)/2))); } Also also, "i" is usually used as a name for integers, not doubles.
Thanks alot for the corrections, but the reason I made another variable j, is (I was thinking) to keep adding iterations to the previous ones, sort of like fibonacci - if that makes sense.
That's a pretty typical timeframe for online lectures, at least compared to the freebie coursera and udacity courses I've seen. Have you tried working out the code logic in a different language first? C is a bit of a brute to jump into, since there's a lot of overhead in terms of preparation and understanding to make even simple things work. I've been learning C and python together the last few months, so nearly everything I write in C, I try first in python to make sure I can separate the method logic from implementation nuances. First of all, indent your code so that it formats properly. In the text editor you use, highlight all, hit tab, copy into reddit, and undo the tab. Second of all, and this snags new people (it snagged me), so I'll go ahead and fix it for you: int sample[6][6]; creates a 6x6 array, whose elements are indexed from 0 to 5. You want: int sample[7][7]; The rest of the code looks a little odd. You're asking the user to input 49 numbers one by one, that can't be fun. Either scan them from a file, or write them in manually and work with the hard-coded values. Everything else should take care of itself if you think through the problem. Understanding *exactly* what's being asked is what's important to learning how to program. The actual coding part of programming is a surprisingly small part of it. 
I am not a huge fan of Zed's style. I did quite like Head First C although it is not free like LCTHW. 
[libarchive](http://www.libarchive.org/) is your friend.
I had to do this a few years ago when I was writing a self extracting/installing archive on Palm Pilots for work. I've forgotten the bulk of the details, but as I do recall, the zlib library was fairly easy to use and get the task done with. EDIT: This seems like a good thing to link http://stackoverflow.com/questions/4696907/zlib-c-and-extracting-files
Agreed. I've put a small example of doing an extractall type operation using libzip in C99 at https://gist.github.com/rjw57/7119323. (Note that I just wrote this from the libzip documentation, I'm by no means a libzip expert.)
Sounds like you're on the right track already. Some remarks: &gt; some loop that goes on from i=0 until the number of structs If you know the number of data sets in advance, a for-loop is what you want. Otherwise, use a while loop with the [`feof`](http://www.cplusplus.com/reference/cstdio/feof/) function to go on until you reach the end of file. &gt; then I would go to fseek(f, ftell(f) + sizeof(someStruct), SEEK_SET) Remember that `fread` already moves the file cursor, so when you've already read the `double` and the `long`, you will already be at the beginning of the string. 
To add to my previous comment, i is your loop counter so you want to increment that, not the value 1. 
Maybe this will help... http://pastebin.com/Ws5s7sYa Sorry for the sloppy mess of a post.
Formally, ``;`` (a single semicolon). This is a statement which does nothing. You'd almost never need to use this in practice. Let's look at the three most common uses of ``pass``: **Empty functions** In Python: def foo(): pass In C, because braces are used to delimit blocks, just use an empty block. (This isn't valid in Python because there is nothing in an empty block to indent.) void foo() { } **Empty loops** In Python: while some_condition: pass In C, again use an empty block: while(some_condition) { } **Exceptions** In Python: try: # some code which can raise an Exception except: pass There are no analogues to exceptions built into the C language[1] and so this idiom has no equivalent. Note that ``{}`` is not the equivalent of ``pass``. It is roughly the equivalent of [increase indent], [decrease indent] if such a thing were possible to do in Python. Which is isn't, hence ``pass`` existing in the first place. [1] ``setjmp``/``longjmp`` aside
(After the edit) Your 'done' variable is never set, so you have an infinite loop in 'main'.
Going off this version: http://pastebin.com/QyznYKUQ *Always* initialise your variables --- you'll have problems later on if you don't. Yes, you've got a setup() function, but I'd expect to see that stuff done at the very top as soon as you declare the variables. You see the while loop? How are you going to get out of it if you don't do something with the done flag?
Since you were looping until done is true, or done == 1, then you should set it after your loop completes. http://pastebin.com/hpNU6CYV (see line 19)
Don't use global variables as temporaries for loop counters (unless you're programming on an embedded system with only a few bytes of stack). Make sections of code as self-contained as possible, e.g. int i; for ( i = 0; i &lt; 10; i++ ) { ... }
/r/learnprogramming for future reference
Look at this: while(!done) { loop(); } Where in there is "done" set to a value greater than zero? If you never set it, your program will never exit the while loop. Also, it looks like you don't even need the while loop, since you're looping through the data array inside of the loop() function. So if you get rid of the "while (!done)" loop all together, it *should* work.
You're right, but I think it needs to be clarified that there are many libc implementations and glibc is one of them (glibc stands for GNU libc). Here are the well known implementations: http://en.wikipedia.org/wiki/C_standard_library#Implementations Android appears to use Bionic (developed by Google), which is derived from BSD libc. The reason why Google had to come up with yet another libc that is based on BSD's, instead using one directly is that libc is also responsible for communicating with kernel, ad since Android wanted to run on Linux and not BSD, they had to modify it so it could communicate with Linux. It looks like they also removed some functionality to make it even smaller.
According to the C manual that will result in an undefined behavior, right? So there is a rare chance that the `done` variable might be 0. In any case, OP should assign a value to it.
Why include stdlib for just exit, when a simple return is enough?
Code clarity and semantic precision. Including stdlib doesn't incur any overhead at run time and negligible at compile time. I think what little impact it has is outweighed by the clarity of exit() vs return. Most non-trivial programs will include stdlib anyway -- it is a good habit to use exit() and it doesn't do any good to avoid it. eta: I also needed it for size_t which is the proper type for array indices.
done should be 0 and not undefined as it is static.. Someone correct me if I'm wrong.
You're right. That's why !done is true. If `int done;` was inside `main()` it would not be 0.
You're right, it has not even been initialized, so... undefined behaviour, which results in an infinite loop in this (and many other) implementation of the language.
I disagree with the idea that it's good to use `exit`. In general, you do not want functions exiting out from under you unless that's their specific purpose; you want them to `return` in a controlled fashion so that you can deal with what they do, and at no point does that suggest or require use of `exit`. Furthermore, there's nothing semantically wrong with calling back into `main` from within your program, although it's unusual, and using `exit` means that code from within `main` can't easily be moved around without careful rewrites. It's a function like any other, and it just happens to have a name that lower layers treat as special.
&gt; I disagree with the idea that it's good to use exit. In general, you do not want functions exiting out from under you unless that's their specific purpose; you want them to return in a controlled fashion so that you can deal with what they do, and at no point does that suggest or require use of exit. I never suggested that you use exit() in a confusing way. By definition the main() function is special and typically programmers use it as a launching point for the logic of the rest of the program. I very rarely (if ever) use exit() outside of main(). Your response implies a lot about how *I* or others typically use exit(). &gt; Furthermore, there's nothing semantically wrong with calling back into main from within your program, although it's unusual, and using exit means that code from within main can't easily be moved around without careful rewrites. It's a function like any other, and it just happens to have a name that lower layers treat as special. I never said there was anything semantically wrong about calling main(). It is unusual to do it but I understand that it is a function like any other. Still -- after programming professionally in C for approaching two decades, I've never seen it done in a practical non-novelty way (maybe some Obfuscated C submissions). My point about semantic clarity is that if you're reading code, it is clear that when you see the word exit() that the program terminates at that point and it is semantically distinct from return which might not have the same effect.
By middle of November? Go with something simpler, and do it really well rather than half completing this. Tip: when you estimate how long you think a project will take, double it. Then triple that. 
Good idea, I'll set it aside for a christmas/summer project, thanks. Sounds like a very handy trick to use!
If you're using ncurses, you could do something simple that will work in a text UI like snakes, a "pac man" type or a mine sweeper type game. Should be able to get something like that up and running by November.
Snake was on my list of ideas, I can't do a PacMan game because I've already done something similar for my coursework so far unfortunately.
You might also check out /r/learnprogramming, although that's more general-purpose than just C.
It's depressingly accurate too.
It would be excessively difficult to write the HALO game you described using only those libraries. While it's definitely possible, it'd be quite difficult. If you mean a text-based user interface---probably top-down unless you wanted to work out 3D rendering using NCurses---for this HALO game, that's slightly more possible, but still not as easy as something like TRON lightcycles or Frogger. I'd recommend the TRON lightcycles or Frogger-type games. They'll be terminal-based, and rather simple, I imagine, but still pretty good.
Adding to that: Tetris... The original russian version, as well as early DOS clones, all ran in a text terminal, and there happens to be tons of information around on how to create a Tetris clone. Tetris is fairly simple to make, once you understand how the rotation systems work. You could easily make a throwback to old school Tetris in that amount of time.
Personally I take the same stance on the Internet as I do when TAing a course: if you show the work you've done so far, and it's clear you've tried some things and are just a bit stuck, I'll give you appropriate hints to get past the sticking point. Otherwise, nope. In particular, if you just post something that's obviously a homework question straight up, absolutely not.
Sorry this might be a little out of place but do you know if ncurses works with windows or is it linux only?
Or the Project Time Circumference rule (PTC), to make it a little more fun. Total time = projected time * 2π
A curses based Missle-Command could be interesting too.
And then you would still not be finished on time. You know, Hofstadter's law.
Ideally I'd want it to be playable by the end of next week (7th Nov) which would then give me an extra week to polish it off and add some neat features. So Halo is definitely looking like an in my own time project. The originality part of it was definitely a key factor in my choice (my lecturer mentioned TRON lightcycles which was my initial plan, so that killed that idea for me).
There's also /r/learnprogramming :)
You don't declare a type when calling the pay_amount function unless you're type casting (you're not). ... int twenties, tens, fives, ones; pay_amount(dollars, &amp;twenties, &amp;tens, &amp;fives, &amp;ones); // Here printf("$20 bills: %d", twenties); ...
thank you! 
Step through the loop and write down the values of L and T at the end of each step. For example: 1. i = 0 t = { data= "06", next=NULL } l = { data= "06", next=NULL } ... Here are a couple of hints: A. T = the "tail" of the list, L = the list B. The FOR loop builds up the list (in what direction?) C. The while loop releases the list from memory It's good to struggle with this stuff a bit rather than just see the answer, but let me know if you still need help. **EDIT** As tsahyt points out, T is actually the head of the list. 
No problem. For those wondering, gcc -Wall -o "red_test1" "red_test1.c" (in directory: /home/reaper/Desktop) red_test1.c: In function ‘main’: red_test1.c:11:26: error: expected ‘)’ before ‘&amp;’ token red_test1.c:17:1: warning: control reaches end of non-void function [-Wreturn-type] Compilation failed. The error specifies the line number as 11, and says somewhere before the reference it expected a parentheses. Then it was just a matter of figuring out how that line didn't conform to an expected function call. The warning on line 17: your main function is declared as an int, and is thus expecting a return value, such as 0, 1, EXIT_SUCCESS, something. If main were declared to return a void type, then it wouldn't complain, or if one were to prepend a 'return 0;' to the int main function. Either way. 
Thanks for the explanation. Is it correct or incorrect that the new C compilers automatically return 0 if the programmer doesn't write it, like I didn't, in the main? 
It does, as why it's a warning rather than an error. If you put gcc on strict or whatever the option is, then it turns those warnings into errors and it wont work. Probably best to have it anyway. What's 1 line, for the sake of correctness and clarity?
makes sense. thanks 
You are right - I am wrong. That is actually the head of the list. 
More likely it returns garbage. But generally no one looks unless you define return codes to be tested by the program's caller (shell, for example).
Side node: prefix your code with four spaces to get funky formatting. It makes the code much easier to read.
/u/zifyiop is right, also never use printf(buffer) unless you /really/ know what you're doing. you probably meant puts(buffer) or printf("%s",buffer) 
Awesome. That worked perfectly. Thank you very much. 
Just so it's clear, the reason for this is because there's no such thing as an array type argument. Your `char buffer[]` argument is actually a `char* buffer` (the syntax just *looks* like an array). When you pass `buffer` to `writeFile`, array-to-pointer conversion is applied and `writeFile` receives a pointer to the array's first element.
&gt; P.S. When i run the program, I am getting all the results of the loops. Yes, because loops are not `if` statements. Your program will execute the first loop, and then the second loop, and then the third loop, because that is what you have written. === Why are you doing this? do{ printf("The sum is %i\n", 0); break; } while(number==0); That whole thing is exactly equivalent to just printf("The sum is 0\n");
I think I have to use the break statement as the program is going through infinite loops. Changing the printf is good.
Okay. Understood. The original probelm was: &gt; Write a program that calculates the sum of the digits of an integer. For example, the sum of the digits of the number 2155 is 2+1+5+5 or 13. The program should accept any arbitrary integer typed by the user This is in a chapter before introducing the if statement. So I am assuming that I am not supposed to use "if" and I am not sure how to deal with negative integers and zero.
Unless you have an assignment that specifically prohibits you from using the `if`&amp;nbsp;statement for some reason, it is silly not to use it. When writing a program, you should use the language constructs that are most appropriate for what you're trying to do. If you want the program to test a condition and perform one thing or another based on the result of that test, then you should use an `if`&amp;nbsp;statement. That's what `if`&amp;nbsp;statements are for. There is no advantage to avoiding `if`&amp;nbsp;statements, but there is a major disadvantage: avoiding `if`&amp;nbsp;statements when they are the natural and appropriate tool to use means that you will be writing strange, convoluted code for no reason other than a purely artificial restriction against `if`&amp;nbsp;statements. Don't do it.
Not an assignment. I am just learning for my own satisfaction.
&gt; Can you you tell my why that's bad? It's bad because the first argument to `printf` is a format string, not a string to be printed verbatim. So if you use `buffer` as the format string, and then `buffer` happens to contain `%s` or `%d` or something, `printf` will expect to be passed additional arguments. If you aren't providing those arguments, who knows what will happen. (Your program will have undefined behavior.)
I don't think there is any legitimate reason to ever use any of the printf functions (printf, fprintf, sprintf, ...) without a format specifier.
printf without the use of format specifiers on user supplied input is a known security issue. 
It depends on what you are calling a "format specifier," of course, but something like `printf("foo");`, where the argument to `printf` is a string constant, is perfectly fine.
Thanks everyone for your help and insight. You've all been very helpful. 
I don't know why splint is directing your attention to line 40 column 7 of flip.c but splint might be misdiagnosing a different problem. You have no header files but your Makefile rule presumes them. Fix that first to eliminate the unopenable file. That will prove splint is genuinely concerned with your declaration. BTW, were you to declare const char ext[] = ".flip" you could turn those magic numbers into sizeof expressions that explain themselves while providing a single point of modification if you wanted to change ".flip".
 $ splint *.c Splint 3.1.2 --- 14 Oct 2013 flip.c:40:7: Parse Error. (For help on parse errors, see splint -help parseerrors.) *** Cannot continue.
Well that's such a forehead slapper I had to grab your file and see for myself. Apparently, splint believes that "real" C is pure ANSI where variables must be declared before the first statement of a block. 
I'm gonna go look for a slutty Pikachu but might toss something this way later.
"main" is specifically defined to return 0 if a return is omitted: C99 standard: &gt; 5.1.2.2.3 Program termination &gt;1. If the return type of the main function is a type compatible with int, a return from the initial call to the main function is equivalent to calling the exit function with the value returned by the main function as its argument; **reaching the } that terminates the main function returns a value of 0**. If the return type is not compatible with int, the termination status returned to the host environment is unspecified.
http://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html -Werror= Make the specified warning into an error. Standards are all cool and all, but they're not the only component in this system.
Huh..that must be new for c99. TIL, thanks. 
What I'm trying to do here is on line 19 get a name from the user that includes a space between first and last name. Is there an effective way to do this? I've tried all sorts of variations on fgets() and scanf().
I thought fgets used newline as a terminating character?
What's wrong with the call to fgets() at line 19 currently? &gt;1 &gt;To add a student, enter the ID number of the New Student: &gt;John Johnson &gt;Great! Now enter the student's name: John Johnson
Yes, this is a needed fix. The name should be a longer array. Go to a Thai website and count the number of letters in a bunch of names. Double that. :-) I like long Thai names, like Prateeptingtong. I'd also read the name into a char buf[BUFSIZ] array. Do your cleanup and sanity checks with that, like checking name length with strlen(). For style, I'd define your list numbers like: #define MENU_END 6 I'd also put a loop in main along the lines of: do { ... ... } while (item != MENU_END); The above will also allow you to put your bad-input error string into the "default" of the switch. With that you can get rid of menu_test_input() and have main() call menu_options() directly. BTW, you're aware that the memory for "new" will only be allocated for the duration of the call to add_student. Right? 
In this case I think it's pretty clear that he meant format strings, it can't really be much else.
[Awfully relevant.](https://en.wikipedia.org/wiki/Bus_factor)
Also the behaviour of scanf(%d) is undefined if they type in a number that's out of range for int. And the result of fgets includes the newline so he has to check for that and remove it. @OP, what book are you using?
This is precisely it. 
You define and print array varibles using an index: myarray[0], myarray[1]. In your case you would be using "counter" as your index: myarray[counter] Btw, next time: pastbin.com, or something similar. Makes it easier to run and modify you code. EDIT: It's a long time since I did C, and I'm on my phone. But I'm pretty sure "array" isn't a valuable name for a variable.
Yes, yes. Let's encourage #defines first. Tomorrow, we'll do enums. :-) 
I get a better mark for having lots of comments so I figured it's better to have more and not need them than too little 
In practice only comment the peculiar stuff, if the code is good it'll be self explanatory
Couple notes: - "int array[numbergenerated];" may work on some compilers, but fail on others, as not all compilers support dynamically sized stack allocated arrays. Setting a hard limit to the number of elements in the array fixes that, but you also have to do buffer overflow checks. - I'm pretty sure what you want to be doing, for generating the random number is: "number = lowerlimit + (rand() % (upperlimit + 1 - lowerlimit));" ... If lowerlimit is 16 and upperlimit is 128, then that will give you a range of 16 to 128. - Array assignment is fairly easy. Just do "array[counter] = number;" ... Get rid of the counter++ at the top of the while loop, and move it to the bottom, otherwise your array will be shifted one element to the right.
There's a difference between school and the real world. In school you comment everything if the teacher asks you to.
What do you have so far? Where are you stuck? We aren't just going to write your programs for you. Do your own homework.
First off, "pi" is the spelling of the Greek letter π used to denote the mathematical constant. "Pie" is a different matter entirely, and is not typically far more tasty and not nearly as irrational. Second, what is it you're asking? You basically said you were having a hard time wrapping your head around an assignment and pasted same. What have you tried? Where are you getting stuck and why? What have you learned up until this point that can help you?
the grades entry are 22.5 19.25 49.75 when i enter them i get a wrong total i tried making it all float but that didnt work either , how can i work past that?
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; float main() { float first,second,final,total ; printf("Enter the student's grades in the exams:\n"); scanf("%f%f%f",&amp;first,&amp;second,&amp;final) ; total=first+second+final ; printf("Total=%.0f",total) ; return 0; } 
Ah yes, but I'm only at this 6 weeks so it helps me as well, for the moment at least
Agreed, but I made my comment because I'm not so sure professors make it clear that it's only for the purpose of seeing students' thinking and should not be a habit carried into the real world.
Thank you for your comment either way, I understand your motivations!
&gt; http://pastebin.com/ZDkXq4zb &gt; In the first loop here, is the syntax correct for the array? I think I'm grasping it but I'm not sure. &gt; Also for the second loop, I know it's wrong but I have tried many different avenues but I can't figure out how to make it print each of the values I have stored. &gt; Thanks again for any help! 
Change this: printf("Random number between %d and %d (inclusive): %d\n", lowerlimit, upperlimit, numbergenerated); To This: printf("Random number between %d and %d (inclusive): %d\n", lowerlimit, upperlimit, numberStorage[counter]); The syntax for storing a value in an array, is very similar to fetching a value from an array. So, you can just do "number = numberStorage[counter];", or "printf("%d\n", numberStorage[counter]);" to get the value out of the array.
Using only a while loop: int number = 1234; /* or from scanf or argv or whatever */ int sum = 0; while (number &gt; 0) { sum += number % 10; number /= 10; }
Thank you so much cleure, you've been big help and I think I understand now. Appreciate it a lot.
Some pointers unrelated to fixing the issue at hand: * **gets is a security issue** - this function is never recommended as it has a penchant for allowing buffer overflows to do nasty things with your code. Always use fgets when you want to get a raw string, as it allows you to impose a limit on how much is being received. * Generally it is good practice to not have multiple statements on a single line. Sticking both 'if' and 'else' on the same line is at best annoying - most people will expect the code block that is immediately below an if statement to correspond directly to that if statement, not its else. * encoded_str and str1_length seem to serve no real purpose. str2_length definitely serves no purpose as it is only declared and nothing is done with it. * Presumably this is an assignment and system("PAUSE") has been made a requirement. For general knowledge: this is a Windows-specific way to halt the program such that output can be seen. There are OS-agnostic options, the easiest of which is simply getchar(). This will wait for user input on any system (and return it, but since you're not assigning it to a variable, it will just be discarded) and then move on. If this program is run as is (with necessary fixes) on a non-Windows machine, it will complain about "PAUSE" not being found. **Fixing the issue at hand:** Your code actually works fine, with some caveats. Replace gets(str); with fgets(str, LIMIT-1, stdin); to safely read a string of up to LIMIT-1 characters into str. Your attempt to print encoded_str while it has a null string is what results in a segmentation fault. The %s specifier in printf breaks if it has to print an empty string. Otherwise, your program works fine as long as there is an 'S' outside of the first stream of numbers. If str[0] was 'S', you can have as long a chain of unbroken 'S's as you want, and then the program will terminate when it hits an 'S' after you've changed to another character at least once. If the string to be compressed contains no 'S', you will get some screwy results. **'\0' is the string termination character** (also the NULL character, in many C implementations NULL == 0 == '\0') and would be a good choice for something to break out of the while loop on, as fgets will automatically stick it in there.
Maybe I'm a bit of an old school programmer, but isn't it generally bad to declare new variables in the middle of functions? I've seen this practice quite a bit in this subreddit.
Oh I'm sorry! Thank you for this tip, I'm only at this six weeks and I hadn't realised. 
Your first loop is looking correct, you could however, since you never use "number" to anything, directly assign the random value to the array: numberStorage[counter] = rand() % (upperlimit - lowerlimit) + lowerlimit + offset; This may make it a little more or less readable, personal choice. Your second loop, you're printing the *amount* of random numbers and not the random numbers them self. To access the values inside the array you do it by index, just as before. printf("Random number between %d and %d (inclusive): %d\n", lowerlimit, upperlimit, numberStorage[counter]);
Oh thank you, that's why I was getting the same number tons of times!
I think the reason behind this thinking is that it makes it easier to see which kinds of variables your function uses and makes it much easier to debug. If you need to dynamically allocate memory in the middle of your function, just declare a pointer at the beginning and use calloc() to allocate the memory you need. Never assume the function successfully allocates the memory and always be sure to free() what you use. http://linux.die.net/man/3/calloc
How about checking the parsed elements of the line before you try to access them ?
Could you provide your a.out ?
The line overrun check is unnecessary. `fgets` will never read more than `sizeof(buffer) - 1` characters (the `- 1` is to leave space to null-terminate the string). Can you show the code you used when checking for empty lines?
strtok() returns NULL if it can't find a token, so passing that to strdup() would cause undefined behaviour. This seems likely to be the cause of your problem. Also, the behavour of atoi() is undefined in some cases (including if strtok returns NULL). One way to fix those two problems would be to check that the value returned by strtok is not NULL before using it. Or you could make a wrapper for strtok that exits if it encounters NULL. The behaviour of line 9 is undefined if you failed to #include &lt;stdlib.h&gt; . You should remove the "(Person\*)" from that line as it serves only to suppress compiler warnings when you did forget that include. In line 4, we don't know what BUFFER_SIZE is, but if it is equal to or greater than (sizeof buffer), then this test can never fail (fgets always generates a null-terminated string). Finally, line 18 is suspicious. Passing newPerson, rather than its address, would be normal. Obviously we can't say without seeing the rest of the code, but there could be a problem in AddNode. 
You're looking at assembly code for x86_64 processors.
Don't worry. It's only been valid for 14 years , that's a short time in the C programming community :)
In other words, it's not C at all. It just has the same comment and preprocessor syntax (`#include`, etc.).
And Assembly lets you do that? How is that possible?
&gt; Because I included zlib.h and made a function call to zlibVersion, the linker expects to find another object file with this code Not exactly. The linker just loads the object files and libraries which you specified via the linker commandline or linker script (some libraries are included by default). If it can't find zlibVersion in any of those files then it reports the unresolved symbol error. Including zlib.h is unrelated. The linker never sees that. The include just makes sure that the compiler knows what the data types of the parameters and return value are for zlibVersion, so it can generate the right code for passing arguments and returning a value. 
The preprocessing? Preprocessing happens first, then the assembly is translated to machine code.
You can run the C preprocessor on files that are not written in C. The preprocessor only evaluates directives (lines starting with an octothorpe [#]) and tries to expand macros. It's common to use the CPP for assembly to include constants etc. That said, assembly is a human-readable presentation of what the machine actually executes. You can't really go any lower if you want to be able to actually edit code.
The people that wrote the assembler (the program that translates the assembly code to machine code) made the comment syntax the same as for C. The assembler does not understand C preprocessor directives (e.g. #include ) though, but if you "compile" an assembly file with the gcc command, gcc will first run the C preprocessor on the file. (btw. when you compile C code with gcc, it produces assembly as an intermediate step, you can look at it with the -S argument, e.g. gcc -S myfile.c )
Not really. In this case he can't declare the array until "numbergenerated" has been entered. I can't agree with the advice to not use variable-length arrays, on the basis of compiler support. They have been standard for 14 years now. If OP has to code in dev environments that are 15 years older or more it's pretty safe to say that he's not going to be getting keyboard input with scanf("%d") either. But OP should check that "numbergenerated" is greater than zero and isn't too big. (A genuine reason to not use VLAs is that you can't control what happens if there's not enough memory to hold the array). BTW the most natural loop construction here is a "for" loop: for (counter = 0; counter &lt; numbergenerated; ++counter) { array[counter] = rand()......; } 
Hello, I see 3 main parts of your program: initialization (change to lower case), the whole do while for going through the string, and printing the answers. The first part can easily be made a function. I wouldn't change everything to lowercase before my code as a preference though, instead I would do that while checking the type of character if needed. The second part is relatively straight forward as well, you will just need some way to pass the information back to your variables. For this I would probably have all my count in an array with each index being each of the if statements. I would then return the index of what to increment. There are more than one way to do this step as well. The last part for outputting the information is up to you. Placing it in a function doesn't really add anything to the code. If you use an array for number 2 it may read a little better, but it wont really help with being modular. On a side note, looks like you really enjoy your do while loops, both seem like a for loop might read better than having an increment with a comparison. For mostly everything else it looks fine. For your if statements something to think about: an element in the string can be either a character (you are doing numbers and letter here) or a space, that will look amazingly in an if else statement! Edit: making things make more sense. Edit 2: added last part about if else.
A ncurses version of "Connect-four" could be cool. Then introduce a system for keeping score across multiple games, etc
I found [Practical API Design](http://www.amazon.com/Practical-API-Design-Confessions-Framework/dp/1430243171) very well written. One of the points it makes is that you can spend a lot of time on your API, but ultimately you need to write something that works, something that *does something*, that fulfills a goal. Along the way, some things will get messy, but as long as you keep some good design habits in mind, and as long as your code is mostly modular, it doesn't create much a of problem later. It sounds like what you're saying is have a main header that includes code of which all gets used, and then you have another header that includes dirty code. I'd say for a work environment where your code is constantly being worked on and updated this is probably a good general direction to be in.
One more thing I thought about while walking home from my car. Another great thing you could have done: make a isvowel function. You only used tolower to then check if a letter was a vowel. Making a simple switch with cases for all uppercase and lower case vowels with a default to return false. Or changing the character passed to lower and checking from there. This would have dropped the first loop and the first if would just change to a function. Just keep looking for: code that is there just to help another part of the code, anything that can be pulled out and used later, and of course duplicates. All of those make great functions instead of just lines in main.
&gt; Practical API Design Your link is busted. I assume http://www.amazon.com/Practical-API-Design-Confessions-Framework/dp/1430243171 is the correct one?
Another good reason to use the "for" loop is that it's more common than do...while and people can read your code better if it uses common structures. They could see at a glance that your "for" loop is going to run N times, but with the do..while loop they've got to mentally check it to make sure there isn't an off-by-one error. In fact there was an off-by-one error as you noticed; the 'do' loops count the null byte in the totChars, which is a bad idea. One of "totChars" and "whiteSpace" is redundant as they must add up to "keystrokes", since one comes from isspace and the other from !isspace. Finally, hopefully you're aware of the problems of "gets". 
Thanks. I appreciate the suggestions. I'm planning on rewriting the assignment in the next few days (when I have some down time). Ill try out these changes. I took an intro to programming a little while back and the teacher focused on for loops for the most part, to the point that I really didn't understand when to use the others. In this class, it seems most..actually almost all examples have been do while loops so I find myself gravitating to them. I need to just use what makes the most sense rather than do whatever the teacher is doing at that time. I get what you said about the redundant variables. That came from me throwing something in quickly to fix an issue I realized after I thought I was done. Ill have to take more time to think things through a bit more. Thanks again. 
Thanks! Your examples are very helpful. I know they are simple enough but they will take me a few trials and a little playing with to fully understand them as opposed to what I did because it made sense to me at the time. The gets and fgets makes total sense. Now that you mentioned it, the teacher did mention it about 6 classes ago and I just forgot it because it hasnt come up in an assignment yet. I'll remember it from now. 
Thank you, corrected.
Gotcha. Well, I'm not crystal clear, but I think I get the idea. I actually barely use Java anymore, since well before I read the book. The ideas themselves though are very general, and I wouldn't say they pertain solely to Java. I think the author's objective was to provide broad principles, but honestly beyond the examples a lot of it could probably be summed up in a cheat sheet.
Ok guys. Thanks for all the suggestions. I ended up splitting the first and last names up into their own struct members to bypass my original problem. As for the other suggestions: 1. I swapped back to scanf() when I split up the names. No need for fgets() shenanigans anymore. 2. I made the character arrays for first and last names much longer. 3. u/OldWolf2 asked what book I'm using. Mostly I'm winging it from an outdated C for Dummies and what I can decipher from the internet. My professor doesn't speak english well so isn't a good source of information for me. 4. I considered eliminating the function menu_test_input(), but because I'm not quite sure how to best implement defines or enums (the two alternative suggestions), and I'm under some serious time constraints, I'm going to leave it.
The C compiler has a bunch of substeps between the actual source code and the actual binary. One of the most commonly-known is object code compilation, for example. Another step is converting the C code into assembly (which is then passed on and converted into object code). Both happen internally if you don't do them individually. You can generate assembly by invoking a compiler like gcc as follows: gcc -S -c -o [output file].s [input file].c [flags] Most if not all C preprocessors and compilers use this kind of system and will therefore take assembly code in and deal with it.
The same idea applies in C++ if you ever learn that; when reading input it's best to read a whole line at once (std::getline) and then parse that line.
Definitely make your vowel test a function. You could also make each counting routine a function as well (numspaces(), numvowels(), etc.). I found that they each had the exact same pattern so I generalized it to counttype(). #include &lt;stdio.h&gt; #include &lt;ctype.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; int isvowel(int c) { int rc = 0; switch (c) { case 'a': case 'A': case 'e': case 'E': case 'i': case 'I': case 'o': case 'O': case 'u': case 'U': rc = 1; break; } return rc; } int counttype(const char *s, int (*func)(int)) { int rc = 0; for (; *s != '\0'; s++) rc += func(*s) ? 1 : 0; return rc; } int main(int argc, char *argv[]) { char sentence[1024]; while ((printf("Please enter a sentence: "), fgets(sentence, sizeof(sentence), stdin)) != NULL ) { printf("==================================================\n"); printf("Read: \"%s\"\n", sentence); printf("keystrokes: %zd\n", strlen(sentence)); printf("printable characters: %d\n", counttype(sentence, isprint)); printf("alphabetic characters: %d\n", counttype(sentence, isalpha)); printf("vowels: %d\n", counttype(sentence, isvowel)); printf("numeric: %d\n", counttype(sentence, isdigit)); printf("whitespace: %d\n", counttype(sentence, isspace)); } } 
This is great. Unfortunately it covers a few topics we haven't even discussed in class. Ill try these out. Maybe ill be ahead. 
Technically correct, yes. I just wanted to give OP both terms for googling them.
Why should I use this instead of Check?
Loops can be interchanged anywhere. It's only about which loop makes it easiest to read. If you haven't used while or do while lots then definitely try to use them more to see how they change your code. I'll add now that I'm a huge fan of refactoring, which is mainly re organizing and rewriting code to make it cleaner, more modular, and hopefully make it more efficient. You did it when you changed to for loops when turning it in. Your code is doing well, have fun.
Not trying to be negative here, but if your entire library is less than 40 lines of code including whitespace, wouldn't it make more sense to just use boilerplate code everywhere ? Or did you put it out here with the hope that more people will contribute to it ?
&gt; What is in top.h ? Exactly the header file that is 99.9% of C header files. The usual typedef's and function declarations which provide the public interface to your module. &gt; It's weird to include stuff before standard headers, normally you do this the other way around . Ok, so do the other way round. There is an old habit that you put sysincludes at the top in case you accidentally screw up something in the system include files. In general I work on the basis that if correctness depends on the order of #include's.... you're doing it wrong. Fortunately the gnu libc maintaners have that attitude too.
&gt; Practical API Design Ok, I now have digested largish chunks of it... (there seem to be a couple of pdf's floating around, my rule is if I like what I get for free, I'm prepare to throw real money at it). Alas, I can't say I like. The book feels like a large chunk of Java. Verbose, expedient, and floundering for around without finding the core principles. I love the notion of an API design book... but not that one.
thank you for your reply, i managed to find out what i did wrong and fixed it, the rectangles are the bounding box around the triangles, and I had some errors in that code as well that bugged the fillcolor.
glad you worked it out
The return value of main indicates the termination status of the program. return 0 implies success, anything else implies an error, a list of valid values can be obtained from errno.h, each value indicates a specific type of error. The return value indicates what happened to the program, not what kinda of variables you are dealing with in it. While it might get typecast as an int, an actual float return value is meaningless as it would not be a standard error value. A more detailed explanation can be found [here](http://stackoverflow.com/a/17715054/218337). tl;dr return type for main should always be int, or if you want to make some people angry, void 
THIS is the truth.
I agree with your comments about the ctype routines -- they all could be macros. I don't think using the comma operator to combine printing a prompt and reading data is necessarily code golf though. I've always thought it was a clean way to handle that problem and I use it quite often. 
Maybe code golf was the wrong term. To me, the loop condition gets obscured. The printf has nothing to do with the condition, so my opinion is it doesn't belong there. 
&gt; It's weird to include stuff before standard headers It depends on your development style, but often you want to do just that, since it will reveal any hidden dependencies on the standard library in your library header, which normally shouldn't depend on the include order.
Hey no worries. I didn't say it was perfect, just I remember it being useful when I was starting to build bigger projects. If you happen to come across a better one, particularly one geared toward C, please share :)
Test.c's source files are 230 lines in total, and it depends on [Macromap.h](https://github.com/mcinglis/macromap.h) which is another 120 lines. I'm not sure how you got the idea it was only 40 lines. You can copy and paste this into your project if you want to, but I think there are better ways to integrate it. I'm providing this as a git repository for numerous reasons: - updating to the newest version is as easy as `git pull` or `git submodule update` - it can include documentation materials beyond the header file, like examples (recently added) or tests - being on GitHub means it's really easy for people to browse the source code, contribute, and raise issues 
Not sure why the above question got downvoted. That is the first question that must be asked, when anyone is presenting their &lt;product&gt;. *Why* would i want to use &lt;it&gt; instead of &lt;alternate product&gt;? Show your features. And the author proveded a nice and clear answer. But, to be honest, it should had been provided before the question was asked. 
I've implemented per-test fixtures (and updated the example in the readme), and changed some other things. I've cut the [v1.0 release](https://github.com/mcinglis/test.c/releases/tag/v1.0), so you're welcome to take that and run with it. Cheers!
Alas, I haven't. Here's a C++'ish one.... http://www.amazon.com/API-Design-C-Martin-Reddy/dp/0123850037 Haven't found enough online for me to judge it though.
I've released [v1.1](https://github.com/mcinglis/test.c/releases/tag/v1.1) which lets you skip identification with `TEST_REQUIRE` if you give it a literal `0` as the identification expression.
He's made it confusing by using `ps` and `pt` but then `r` instead of `pr`. At the beginning of the function, the `p` variables are copies of the arguments. You could use either as long as you stick with it throughout the function (don't use `pr` and `r` for example because incrementing one won't affect the other). His code would have been easier to understand if he had used `pr` instead of `r`, but it behaves the same. In fact, the code would be even easier to understand if he hadn't copied the arguments at all and just use `s`, `t`, and `r`, but I presume he was trying to make it clear that modifying the pointers inside the function won't affect the arguments that were passed.
Thank you very much! If I could give you multiple upvotes, I would. I have an exam in about 10 hours, and this was the only thing that was tripping me up. I figured they were doing the same thing, but I really hate that he coded it that way. The rest of the exam is on arrays and string.h functions and I find those to be fairly easy. (Also, thanks to your post, I now know how to use code font in a normal text post.) 
Can someone help me making the FFT from the signal shown? I am new to C# and don't know a function which does it. I have looked into AForge but I don't know what they are saying.
His code is bugged, the lines "r++" and "*r = 0" should be pr. The result will probably be that the first byte of output contains the last matching charcter (since they all overwrote each other), and then there'll be some garbage bytes after that. In fact pr, ps, and pt are unnecessary. He should just use r,s,t throughout. Also, '/0' is a mistake, hopefully this is a typo on your part. Should be '\0' or more simply just 0. I'd do this: /* "out" must have at least as much space allocated as s1,s2 */ void matched( char const *s1, char const *s2, char *out ) { for ( ; *s1 &amp;&amp; *s2; ++s1, ++s2 ) if ( *s1 == *s2 ) *out++ = *s1; *out = 0; } 
What are you stuck on?
&gt; Let's say that my output if B5C15&gt;8 , I can't recapture it from the printf to use it again to do the compression. &gt; &gt; Like my printf is ("%c%d\n"); Two suggestions: 1. Keep track of how many characters you have printed as you go. Start a variable at&amp;nbsp;0, and then add to it every time you do a `printf`. At the end, the value of the variable should indicate how many characters have been printed. 2. The return value of `printf` is the number of characters that were printed. You will want to *use* this return value. Right now you aren't doing anything with it—it's just being thrown away.
There are a couple of different approaches. I would add a compressed size variable that you increment while you're printing: //Initialize in beginning int compressed_size = 0; //every time you print printf("%c%d", input, count); compressed_size += 2; //At the end of your function printf("Compressed size: %d\n", compressed_size); printf("Original size: %d\n", length_string) printf("Percent Difference: %f\n", float(length_string - compressed_size)/length_string) The other way to do this would be to modify your output string instead of printing to stdout. Then you could simply use scanf on the output string.
I did a quick hack for the second part of your question. Here's the [code](https://gist.github.com/BlurryRoots/7342487). It's kinda awful, but maybe you get inspired ;) Edit: updated code
&gt; //every time you print &gt; printf("%c%d", input, count); &gt; compressed_size += 2; This won't work right, because you aren't always printing 2&amp;nbsp;characters there. If `count`&amp;nbsp;≥&amp;nbsp;10, then you're printing more than two characters. What you should do is increment `compressed_size` by the number of characters which were printed. How do you get the number of characters that were printed? That's what the return value of `printf` gives. So: compressed_size += printf("%c%d", input, count);
I very much disapprove of cross-posting un-answered or un-illuminating SO questions to this sub-reddit for answer. Nonetheless, the answer you're looking for is a) learn what linking is, b) learn what a shared library is and c) read [dlopen(3)](http://linux.die.net/man/3/dlopen).
Why don't you just use strlen on the original and the compressed? 
Hi, Sorry to hijack this post, but my topic is filtered out. It is also compression related:http://www.reddit.com/r/C_Programming/comments/1q0hc2/http_post_gzip_compression_with_curl/
original size = strlen(input) compressed size = strlen(compressed) compression percent = (original - compressed size) / original size * 100.0; assuming you want bits, multiply by 8 for the sizes. won't change the percentage.
I am a little late in replying to this but while the MSVC compiler has better support for C99 the actual IDE sucks when coding in pure C. 
C::B is rough around the edges but it is pretty solid and supports every compiler I have ever heard of! It also has much better syntax parsing than VC++
Dev-C++ is old as hell and has some horrible bugs. I would avoid using it for your own sanity. 
Wow. That is much longer than my solution: #include &lt;stdio.h&gt; #include &lt;ctype.h&gt; int main(int argc, char *argv[]) { char c, prev = 0; unsigned count = 0, bytesin = 0, bytesout = 0; while (scanf("%c", &amp;c) == 1) { ++bytesin; if (tolower(c) &gt;= 'a' &amp;&amp; tolower(c) &lt;= 'z') { if (prev &amp;&amp; (c != prev)) { bytesout += printf("%c%d", prev, count); count = 0; } count++; prev = c; } } if (prev) bytesout += printf("%c%d", prev, count); printf("\ncompression ratio: %.2ld%%\n", (bytesout / (double)bytesin) * 100.0); } 
I've only browsed sections, but I've heard good things about [Learn C the Hard Way](http://c.learncodethehardway.org/). It's also free, so hard to beat the price. It's hard to say without knowing the kid. If he's pretty computer/electronics literate he can probably just dive into that - if not I would reccomend trying to find a book that introduces the basic concepts of programming, memory, computation, etc as it will make things much smoother, The intro to LCTHW actually reccomends working through Learn Python the Hard way first if you're totally green since it also doubles as a "intro to programming" book.
I have just been browsing around LCTHW and it seems alright. Not too keen on a lot of what Zed says about K&amp;R but that doesn't detract from the overall quality of the content. I have also been reading through a PDF copy of Head First C and it seems pretty good. The style isn't really my thing but the content is pretty damn good. They don't cover some pretty basic things which is a little weird but I think it might be the kind of thing he will be into then pick up C++ Primer or Accelerated C++. 
Reading "LPTHW" first is just recommended for those who have no experience in programming at all, because "LCTHW" isn't thought to be an introduction to totally programming-newbies.
I believe LCTHW is supposed to be preceded by LPTHW.
Yes, for the record "totally green" means "noob".
You can't really compare C Primer Plus and Head First C. Head First C is just a basic introduction, while C Primer Plus really goes into the depth of professional programming. I'm learning C at the moment to and I'm also not a fan of very dry material, but I don't see something better than C Primer Plus at the moment on the market. My strategy is to get an introduction with [Learn C The Hard Way](http://c.learncodethehardway.org/), like [teebrz](/u/teebrz) recommended it, and then to read C Primer Plus in the new version, that shall come out in a few days.
Yeah I didn't mean to directly compare Head First C and C Primer Plus as they are obviously very different in their target audience. Having a quick flick through LCTHW and Head First C I think I am going to recommend Head First C and then see where he feels like going next. Best of luck in your learning!
It will be very hard to learn C without the context someone gains from dealing with technology in general over a couple of years. From example, without knowing the way memory works, he won't have a clue why you have to declare variables. And this type of information is hard to find in C programming books, because they assume you have this basic understanding. Either look for C books that are targeted at people who have never programmed (which I don't think exists) or he needs a mentor that can verbally explain these things. But of course it could be that I was a stupid kid and can't imagine someone else not having trouble :)
I might be controversial in saying this, but in my opinion learning assembly is the best way to learn C. That was the case for me at least. I had a basic understanding of C, but when I learned x86 assembly everything about C just clicked.
The textbook I'm using in class is pretty good. [How To Program in C](http://www.pearsonhighered.com/bookseller/product/C-How-to-Program-7E/9780132990448.page)
You wouldn't happen to be at USF by any chance, would you? We just did this assignment.
For me the languages I first learned were BASIC (many dialects but mostly BBC), Pascal and then C. It took a good few years with BASIC and about one with Pascal before C started to make sense. BBC BASIC also had the advantages in that it supported pointer-like memory access and so I had that understanding going for me.
I'm working my way through The C Programming Language (K&amp;R2) right now and I'm pretty satisfied with it. The example problems I think are especially well done. 
At the risk of being downvoted... it should be noted that Learn C The Hard Way is a book that most proficient C programmers would suggest you avoid, see [here](http://www.iso-9899.info/wiki/Books#Stuff_that_should_be_avoided) You can find great learning resources available on that same website. That said, K&amp;R would be a great way to get started, provided he does the exercises in each chapter as well.
Thanks!
Here, from a randomly pulled page from that book: &gt;That leads to a certain realization: C thinks your whole computer is one massive array of bytes. Obviously this isn't very useful, but then C layers on top of this massive array of bytes the concept of types and sizes of those types. Where does the specification address this? :) I'm sure Learn C The Hard Way is fine if you're interested in writing programs for x86 Linux environments, but at that point it's more 'Learning C The Hard Way In A Specific Environment'.
That book is almost £100 here in the UK :-O edit: it also doesn't have very good reviews :-/
hell yes 
Neat blog. For the inverse matrix project, all those int variables...
You can remove restrict in the prototype declaration. Restrict is really only usefull for functions that operate on large data. It's your promise to the compiler that two pointers of the same type do not address the same memory. Why gcc doesn't like them in prototypes I would also like to know.
You call "sqrt" without declaring it (#include &lt;math.h&gt;). Surprising that the program still runs, as the library code will be returning a double but your code will be reading an int and performing conversion to float. The compiler probably 'did magic' to save you. 
Next exercise, rewrite the matrix program to let the user enter any dimensions :)
My thoughts exactly. 2x2 and 3x3 have easy tricks associated with them, but finding the inverse of a matrix of arbitrary dimension is a lot trickier.
No offence but if you're learning C you're probably not in the best place to judge the quality of a textbook. A common, major problem across books about learning C is failure to distinguish between standard constructs and platform-specific ones; and making assumptions both in understanding and coding that turn out to only be valid on some (or even one) platform. 
What error are you getting exactly?
 heraldge-script-pawn-data.h:51:65: error: expected ‘;’, ‘,’ or ‘)’ before ‘session’ int (*savedata) (struct DATA_GLOB *restrict session, data_id_h *restrict id, char *location);}; ^
`restrict` is a keyword that was introduced in C99. By default `gcc` does not use C99, it uses the older ANSI C standard. To use C99 features, including `restrict`, you need to enable C99 support by using the `-std=c99` switch.
Ah, I'll be face-palming over here.
Have you got the compiler in standard C99 mode? (-std=c99 , for GCC)
I believe that's some css/javascript libraries that you can drop in that will syntax highlight your code. Or use github and embed a [gist](https://github.com/blog/122-embedded-gists). All of your code is in main(). The problems you're solving seem like they should just be a small part of a real program. So the code should be organized into reusable functions.
Tindell man... dear god. I am so hopeless with him.
Use the Gauss-Jordan algorithm. It works like a charm but has O(n^3) runtime where n is the Dimension. EDIT: Remembered the name incorrectly
Hey, I'm Ruben4fun's (Luthien's) friend (Chromelon on the blog, I'm the one debugging and compiling). Me and Luth are beginners, we're taking our first C programming class. I've had some experience in Java and I've dabbled in HTML and Javascript, but I'm pretty new to C. I just wanted to say thanks for all of the advice (and views!) Edit: Forgot to include some proof, here it is -&gt; /r/chromeluthproject
Could you provide any advice or tutorials on how to do this? 
well rather than printing the whole triangle you could just increment the number of spaces before each '/' through each iteration and it would output the hypotenuse just like before. I think this would be a good exercises because it's a bit of a braintease to do, you just have to look at your triangle and see what you want to change in each iteration. For the right angled triangle, all you would want to change would be the hypotenuse. pseudo-code it'd be something like; for x amount of times draw '|' at the start add x amount of spaces before the '\' After the for loop is done draw '________' Granted the line count may actually be a similar length to before, this way would be much more flexible. As for other ideas, you should probably start using functions to make it a bit more modular rather than hard-coding into the main loop.
`restrict` is only necessary in a function definition, strictly speaking---anwhere else it basically serves as documentation, and *maybe* a way for the compiler to give some extra warnings. You're safe to remove them. (However, if GCC's in GNU99 mode, it shouldn't be giving you those errors; does it work with `__restrict__` instead?)
[snprintf](http://pubs.opengroup.org/onlinepubs/000095399/functions/printf.html) #include &lt;stdio.h&gt; int main() { char buf[64]; for (int i = 0; i &lt; 10; ++i) { snprintf(buf, 64, "ttyUSB%d", i); printf("%s\n", buf); } return 0; }
You could create the string on the fly with something like [snprintf](http://www.cplusplus.com/reference/cstdio/snprintf/). char deviceName[MAX_DEVICE_NAME_LENGTH]; for (int i=0; i &lt; DEVICE_COUNT; ++i) { snprintf(deviceName, MAX_DEVICE_NAME_LENGTH, "ttyUSB%d"); get_devicename("/dev/", deviceName); } 
Minor suggestion; don't repeat your size: snprintf(buf, sizeof buf, ...) Note: sizeof only works correctly if the type is an array and not a pointer.
+1. I prefer to use macro constants usually.
To code out what you desired, use the code below. char *devices[] = { "ttyUSB0", "ttyUSB1", "ttyUSB2", "ttyUSB3", "ttyUSB4" }; for (int i = 0; i &lt; (sizeof(devices) / sizeof(devices[0])); i++) { get_devicename("/dev/", devices[i]); }
This method will also allow you to include really cool things like "kmem"!
Hi, You should probably return your structure in the logic function (even if it's a "kindof" heavy structure in my opinion).
 return dis;
Just for fun, a solution without snprintf, but it only works for up to 10 devices. char device[] = "/dev/ttyUSB0"; for (i = 0; i &lt; 5; i++) { device[sizeof device - 2] = '0' + i; puts(device); } edit - same thing but a bit more obscure: char device[] = "/dev/ttyUSB0"; for (i = 0; i &lt; 5; i++) { puts(device); device[sizeof device - 2]++; } edit - even "better" :) char device[] = "/dev/ttyUSB0"; char* n = device + sizeof device - 2; for (; *n &lt; '5'; (*n)++) puts(device);
There's no need to include the '\n's in the scanfs. It will read on its own on a line feed. You *should* include '\n's at the end of your printfs in the if-then chain so that things print nicely. After removing the '\n's from the scanfs, it seems to work perfectly on my end. Calling pow to square a number is overkill and inefficient, so the delta calculation should really be b*b instead of pow(b, 2). There is a chance that a call to sqrt would be more optimized for square-rooting than pow(delta, 0.5), and it's definitely more readable, so I'd suggest replacing pow(delta, 0.5) with sqrt(delta).
Also, you need to pay attention to the order of operations in your formulas. Something like `-b/2*a` means `(-b/2)*a`, which is not what you mean. You need parentheses: `-b/(2*a)`.
Yep, good thing to point out. I was just looking at the code side of things but I really should've caught that.
Thank you so much ...It's working now.
Rather than modify the file, I believe the simplest course of action would be to write it to a new file (for example, *out.tmp*) then rename that file to the file you want it to replace once you're done writing. You could either load your entire original file into memory, make the changes, then write it to disk, or you could handle it a line at a time, reading the original file while writing to your temporary file. 
A good point. Also, would be interesting to hear how you would do the modify part too. Like, you read the file line by line, how do you load the contents of the whole file into memory to find the line you are looking to modify?
&gt; A good point. Also, would be interesting to hear how you would do the modify part too. I'm not sure I've ever actually *modified* a file beyond appending to it. I think it'd be more hassle than it's worth to start shifting parts of the file around and inserting new parts into the middle. I can only see it being much use if speed is a major issue, and you have a large file (several GB) which you're only going to be changing near the very end. Otherwise I would just copy to a temp file and rename. To read the file line by line you could just use fgets and check each line individually to see if it needs changing, then write the new line using fwrite. If you want to modify on a line-by-line basis this is probably the simplest choice. To load an entire file into memory you would use malloc to allocate enough space to hold the file, then use fread to load it into your allocated space. From there you could read through it and write the appropriate data to your temp file. 
What I am looking for is as simple as the following example situation: You have a pdf reader. When somebody opens a file, it opens a kind of bookmarks file which consists of `filename - pagenumber' entries each on its line. Then tries to find the line in bookmarks file which contains the filename of this newly opened file and then it will open the correspending page of this pdf file. Whenn the pdf reader is being closed, it will again open the bookmarks file and find the line which contains the filename of the currently opened pdf file and will update the pagenumber for that line. 
&gt; write the new line using fwrite. But I don't understand this part. How can I write _just_ that line, so that the rest of the contents of the file will be unaltered? 
mmap might be better suited to what you're trying to do than traditional file I/O. Give it a look.
PDF files require a specific type of application, the PDF Viewer, to be able to read the file. There are a number of PDF viewers available, but it doesn't mean they all share this data in a common state file like you describe. It is quite possible that opening a PDF using Adobe will not take you to the last page read if the file was previously read via the Chrome PDF plugin. It is viewer tool, not file, specific. So to do what you are looking to do you are likely going to need to create viewer program of some sort, and then have that be the tool used to read your files. It is the reader program that is able to track the last page read and record that. If your documents are simple text and accessible by other applications, say Word, Notepad or VI, those tools will not know anything about your last page read file.
No no, I want something completely different. I would use only one pdf reader. I would not alter the pdf file itself. I just need to keep a text file which contains a list of filenames with their corresponding page numbers, and I want to update that file by modifying only one line of it at a time, leaving the rest of the contents unchanged. 
Actually, it doesn't count the elements each time it loops since "(sizeof(devices) / sizeof(devices[0])" is resolved at compile-time. I personally have a huge preference for the sizeof trick except that I would replace devices[i] by (*devices) but that doesn't really matter.
Ok, thanks on correction.
You can't, unless the new line will be exactly the same length in bytes. That's because a file is serial on disk - in order to make a line one byte shorter, you'd have to rewrite the whole rest of the file one byte earlier. What he's saying is that you should read the file *in* one line at a time, and write out *another* file one line at a time - normally you just write out the line you read in, and sometimes you would change the line before writing it out. Modifying a file safely in-place is a pretty difficult thing to do *right*, because at any time your program could die, the computer could be shut off, etc.. and your file would end up with only some of the writes you asked for - the original file would be written on top of, though, so there's no way to recover. 
Thanks, it's very clear now :) 
First of all, this is an operating system question rather than a pure C question. Secondly, &gt;&gt; write the new line using fwrite. &gt;But I don't understand this part. How can I write _just_ that line, so that the rest of the contents of the file will be unaltered? I know what you mean. You might try popening \`ed\` and letting him deal with it. But you know what? I don't think most text editors even bother doing what you're trying to do, which is to *just* write out the parts of the file that were actually changed. I think they write the entire file out when you save. Because someone else could have changed part of that file in the meantime. If that approach is good enough for text editors it's probably good enough for everyone else. The mmap suggestion is interesting but not guaranteed to work for all files. Filesystems have to specially support mmap. All ed is, OTOH, is open, read, write, close, and *maybe* seeks (or the stdio.h equivalents beginning with 'f', I dunno). 
As I got suggestions now, it seems so simple, but it's amazing it grew as so long discussion within a matter of few hours :) thanks!
Yes I do, with the assignment we have also been given a graph to work with. It gives us the linear regression for the first 5 minutes of data.
I'm just horrible when it comes to programming. I know I will have to enter these values as arrays, but I don't know how I am going to register the values that aren't written, just assumed, such as if the user would like a temperature at 20 minutes. 
I would continue to draw the line in the graph to see where it landed at that point, aka I need to use the slope. 
That isn't a precise enough answer. You can't tell a computer to "continue to draw the line in the graph." Give me a precise answer. Exactly what steps would you perform?
The only other thing I can assume is that I would have to somehow input the slope of the line and have the program continue to take values from the value of the slope. 
&gt; I would have to somehow input the slope of the line No, you are supposed to use linear regression to *find* the slope of the line! That's what linear regression is all about. So, tell me, how do you do linear regression by hand? Can you show me the computations you would do to perform linear regression on the data set you gave in your original post?
Well I would have to use y=mx+b, and I have the equations to fine m and b in front of me, however it would be quite complicated to input these equations. To put it simply, I first have to find the values of m and b. 
Okay, so suppose you do that. Now you have values for m and&amp;nbsp;b. Now, back to my earlier question: What would you do by hand if I asked you the temperature at 20&amp;nbsp;minutes?
&gt;If the user wants to replace the old file, they can put &gt; oldfile at the end of the command That will generally not do what one expects - all of the elements in the pipeline (and the io redirection perfomed) happen roughly simultaneously, so you would generally end up overwriting your original file before you read it. If you need an in-line rewrite, you usually would just put it in a tmp file, and do an `&amp;&amp; mv a b` on the end of the command.
`mmap` is really only relevant if that bookmarks file can get *truly large* - otherwise you might as well just read in the whole file and write it back out again. `mmap` lets the virtual memory subsystem handle the paging for you, so you don't need to make room for the whole file in memory.. but that's really all it gets you. If he wrote a solution with `mmap`, he'd be just as able to do the same solution using `fseek`s and `fwrite`s.
Right. So now you understand how to do the necessary calculations by hand. That was an important first step. Now you just need to write code to do those calculations for you.
Thanks a ton for the help. I'm trying to figure out the code now, it's kind of hard to get specific help for coding though. Can't hurt to try and attempt to fix my own mistakes though! 
Perhaps you could just use a flag and an if? It think it's a bit more obvious doing it that way: int flag = 0; do { printf("Please enter a sentence: "); flag = fgets(sentence, sizeof(sentence), stdin) == NULL; if (!flag) { /* Code */ } } while (!flag); Honestly I can decide if I like your way of doing it better. Yours is probably slightly faster. You could also do it simply with a break in the middle of the loop in the conditional, but if possible I prefer to avoid mid-loop breaks.
Given that the title of this post is "Open→ modify→ write back", your main argument of "otherwise you might as well just read in the whole file and write it back out again" seems to have ignored the problem at hand.
What I like about my method is that it keeps most of the loop control logic in once place. Your example has it spread out over four lines and requires two blocks (the do {} while() and internal if(){}). I think people's resistance to it is lack of understanding of the comma operator. Printing the prompt and fetching the results are two very tightly coupled operations and I guess an alternative would be to make a function that combines them but using the comma is a more succinct. Really, look at the code you just wrote -- after writing loops like the ones in my previous post for long, your code looks incredibly ugly to me. You have a new variable that you have to initialize, assign, and test twice -- all because using a comma make you uncomfortable. Though I agree that my method is probably is faster, this isn't the type of thing that needs hand optimizing. I think its greatest advantage is code clarity.
 &gt; I think that, in general, if you start shoving commas everywhere there is probably a more easily understood way to do what you're doing. Well -- there is nothing wrong with using it where it is useful -- like in this case. I don't think it is necessary to use it *everywhere* for it to be understood. Again, it is part of C that anyone paid to program in C should understand IMHO. &gt; Also, a slight detail, but any reason why you didn't type it like this? : Eh -- I'm not opposed to that. Seems perfectly reasonable to me. Sometimes I can try too hard to preserve vertical space.
I think I may have been a bit to picky over the comma the more I think about it, I do like it's use in this case. I think the issue for me is every time I see the comma used, It's never in decent cases like this, but weird cases where the code starts looking crazy with commas and ?:'s thrown everywhere because nobody wanted to make it into a normal function and it just kept growing. So far I've only done C was on open-source projects, where nobody's getting paid and the level of experience from one person to the next varies widely (And I'd much prefer to help someone along with the programming then toss them aside and do all the programming myself). If I was working on a project and everyone was getting paid, I'd definitely expect knowledge of the comma operator just simply from their exposure to C. And with vertical space, I tend to be the same. However I try to split up long lines when possible, as I usually want to stick to a column width limit. It's more of a preference though, the line you had wasn't anything bad at that state.
 int A[2][2] == {2, 1, 5, 3}; This is a logical expression, not an assignment due to the double equals sign. So nothing is getting assigned to A[2][2]. Also, this is the incorrect way to initialize a 2d array. You should do int A[2][2] = {{2,1},{5,3}}; edit: fixed error pointed out by OldWolf2
My bad, i'm new at this, however the thing is that I assigned it from the for loop, so that line was mainly for demonstration purposes, i still get the unreasonably high numbers output from C[N]
In several places you use "==" (comparison) where you mean "=" (assignment). In fact, all of them in this code snippet. For example the line minimum == A[i][j]; just compares the existing values of "minimum" and "A[i][j]" and does nothing with the result ; it doesn't change any values. 
Yes, i fixed them just as he posted, only thing i forgot to fix was my OP :)
Both of those are syntax errors. Perhaps you meant: int A[2][2] = {{2,1},{5,3}}; 
Using a "for" loop makes your code easier to read. Also, why did you convert devices[i] to the other form? They both do the same thing obviously, but devices[i] is generally considered easier to read.
 minimum = A[0+i][0+i] Why not: minimum = A[i][i] Is this a Windows thing or something?
There's man pages and all sorts of assorted documentation, both online and offline for this.
I'm hoping OP's idea is to have a more user friendly resource than man pages
Even if someone already said what you saying, will upvote you just to make sure others who will try to use know they need to fix array.
I personally don't believe it is a good idea. I think it is the developer's role to be (or become) able to understand man pages and documentation (which are not especially non-user-friendly in my opinion). People who writes documentation for their APIs and stuffs are enough clear in their lines (not always I concede), but developers are not babies. That's just my thought though.
btw OP, as u/WannabeDijkstra mentioned, this might be more useful if you cover the more exotic ones like two's compliemnt, snprintf, [arr]1 etc
That initial push is to state that "printf("hello world");" will print hello world: I don't think you need a database for this kind of basic usage, and if you have to deal with more complicated usage of printf() or any other functions, I assume that you're at a point where you need to know how to read manuals and docs. Pragmatic approach. printf() is a quite bad example IMO since it has a big family and a lot of use cases, but the basic "hello world" example is spread everywhere over the internet. I get the idea of helping new programmers, and it really sounds like a great project, but I think it doesn't help them, and even more, it can give them bad habits about how to search the information they are looking for. That's what I think.
I'm not sure why it is being downvoted, however: Frankly, the code may work but there is something lacking about it. I can't put my finger on it because there are so many things not quite right that it is difficult to identify any fundamental flaws. Your function and structure names don't make much sense, you use mixed case in places an not in others, personally I don't care for typedefs, it looks a little more complex than necessary, etc. Not to say it isn't a very good effort but I think it needs significant work.
Please, this is reddit! You are expected to magically know what the downvoter's problem is. Also, a downvote is not an argument you can debunk. Perfect for lazy people who know they are always right. 
Why would you use tries if speed isn't a priority (like the link says)? 
Because tries, like any data structure, provide an abstraction that you can use to simplify your programs. It's a large part of the reason why people use languages like Python and Ruby.
I have to say I'm actually quite proud of Trie.c. Its dynamic alphabet-swapping ability is something that the [C Algorithms Library's trie implementation](http://c-algorithms.sourceforge.net/doc/trie_8h.html#f5808be7fb71b1ef0b1dcbe55da603ce) doesn't provide. I think Trie.c's source code is very readable: it isn't littered with `ifdef`s and it doesn't constrain itself to C89's limitations. It has a modern development process, build process, and modern tests. I posted this to Reddit in the (probably vain) hope of receiving feedback and criticism that would make me go "crap! they're right! I need to fix that". [I'm fully able to receive (helpful) criticism on the internet.](http://www.reddit.com/r/C_Programming/comments/1ni8oq/c_style_my_favorite_c_programming_practices/) Vague criticism like "there's something lacking about it" or "it needs work" isn't helpful, nor interesting to readers of this thread and subreddit. &gt; Your function and structure names don't make much sense Which names don't make sense? Could you suggest better names? &gt; you use mixed case in places an not in others Structs are `NamedLikeThis` and functions are `named_like_this`. The mixed case is intentional because it's informative. Some variant of this style is followed by most programming communities. I think it's much harder to glean information from code when all the identifiers are lowercase. &gt; personally I don't care for typedefs, it looks a little more complex than necessary, etc. Yeah, using typedef over structs does remove certainty about what's lying underneath. I consider the trade-off worth the visual clarity. Also, if you always give struct typedefs TitleCase names, they are recognizable enough, anyway. I've found that code with `struct` everywhere tends to be harder to read. Especially in my own code with my own conventions and rules, if I used `struct`, I'd always be reading the code and thinking "I don't need that! I already know it's a struct thanks to its name!". I think it was a mistake to give structs their own namespace. If they were in the same namespace as everything else, like most/all modern languages, the C programming community probably would be using the same convention: naming structs with TitleCase names.
Yep, [I've learned](http://www.reddit.com/r/C_Programming/comments/1ni8oq/c_style_my_favorite_c_programming_practices/) that this subreddit is very happy to downvote things they disagree with, in direct violation of reddiquette.
Right, but tries are generally used as an implemention of a key-store. So you'd use them as a concrete implementation of the abstract concept of a key(/value)-store in situations where speed matters more than memory. So generally tries are the concrete implementation of an abstract concept; I don't know any situations where you specifically need a trie as a datastructure to do what you're trying to do - replacing the trie with any other key-store structure generally gives the same results (but might use different resources).
Every subreddit does that. 
* Array sizes and indexes should be of type `size_t` (or `ssize_t`, if you need to pass negatives back for errors.) * I'm not a fan of the single- and double-character function argument names... For example: I realize that `sorted_printer` isn't a part of the API, but it's not clear what the arguments are just by looking at them. * It would be nice if the documentation in trie.h referred directly to each function argument by name and explained what it is. I foresee reading those entire paragraphs getting tedious every time you need to refresh yourself on what the functions do/take. * You might also want to put the documentation into a computer-parseable format, like Doxygen. * Maybe you should provide a make target to build as a library? * You should give make targets for specific purposes instead of showing how to override CFLAGS. * Why does clang get its optimizations turned off? * It'd be nice if you gave example output for your examples so that people can see how the library works without having to build it.
&gt; The particular structure choice of "Trie" seems to waste a lot more memory than is necessary. Yep, fair point. I'm working on a commit that will change `Trie`'s `alphabet` field to be a pointer. This should improve the memory efficiency - at the cost of run-time safety by risking null pointers. &gt; Is the compiler optimizing out the recursion you use? Otherwise, you're incurring a lot of extra function invocation cost traversing (and adding). I would assume so, but it's worth checking. This is a fair point, but speed isn't a priority for Trie.c. The functions will only recurse as far as the depth of the trie, or the length of the string, so I suspect the recursion cost won't be huge for most applications (e.g. word dictionaries). The stack frames of `trie_add` and `trie_has` are only a few bytes. &gt; I have a very different "trie" implementation in C (and Java) that I wrote many years ago. It optimizes for both speed and memory consumption, and the entire trie is actually encoded in a single large array in memory. A very nice side effect of this is that there are only offsets in the array, no pointers, which means the whole thing can be mmap'ed to persist it to disk. Cool. That makes sense; but it would only really improve speed when loading a previously-built trie, right? Also, with that structure based on offsets, I can't imagine client code was very pretty. Was it? Is the source code up somewhere? I'd be curious to see how much of a difference focusing on speed makes here. &gt; I think also, if you were intending this to be a reusable library, that the majority of C programmers tend to not typedef structs. That's a minor nit, and I think it's already been mentioned. Really? I see it quite often. Anyway, you can use `struct` in your client code if you want to.
&gt; This is a fair point, but speed isn't a priority for Trie.c. The functions will only recurse as far as the depth of the trie, or the length of the string, so I suspect the recursion cost won't be huge for most applications (e.g. word dictionaries). The stack frames of trie_add and trie_has are only a few bytes. Well, that's a problem if you're not vetting the input. It's a bug, IMO, to assume that one or the other of your inputs won't cause you to run the stack into the heap. &gt; Cool. That makes sense; but it would only really improve speed when loading a previously-built trie, right? Also, with that structure based on offsets, I can't imagine client code was very pretty. Was it? Is the source code up somewhere? I'd be curious to see how much of a difference focusing on speed makes here. It's very fast. But, code prettiness isn't something I was aiming for. I wanted to store large dictionaries in the smallest amount of space, and also run checks against the trie as quickly as possible. I'll see if I put the source for you someplace. To give you a flavor of what it's doing: each edge in the trie is encoded in 32 bits. The offset to where you go for the next edge is 24 bits, the letter is encoded in 6 bits (so, you can't have arbitrarily large alphabets), one bit is reserved to mark a valid terminal letter (1 means, the sequence you followed forms a word, 0 means this is only a word prefix), and one bit is reserved to denote "this is the last edge emanating from this node"... the edges emanating from a node are sequential in the array, so you need some way to mark that the following entry isn't for this node, but some other node. This saves quite a lot of memory, and at the time that I wrote it, I could get an entire dictionary into memory on a basic cell. phone (think 10 year old phones here, not iPhones). &gt; Really? I see it quite often. Anyway, you can use struct in your client code if you want to. I don't see if very often in the big open source code bases. 
My argument was that a trie is datastructure which is generally used not as an abstract datastructure but as a specific implementation of other general datastructures when one wants speed. Hence I was surprised that your implementation was not one that focused on speed.
Youtube videos and other articles/blogs/books could probably explain these concepts better than I, but the one piece of advice I'd offer is to try and learn a simple assembly language. I had tried to teach myself C for many years, but could never really understand just how pointers worked or what they could be used for, even though the definition of a 'pointer' totally made sense to me. But, when I had to learn assembly for a programming course, pointers immediately made sense. 
So I implemented it like this: FILE *bookmarks; FILE *tmp; char entry[LENGTH]; bookmarks = fopen(bookmarksfname, "r"); tmp = fopen(tmpfname, "w"); int unfamiliar_file = 1; while(fgets(entry, LENGTH, bookmarks) != NULL) { char *fname; int page; fname = strtok(entry, "\t"); if(!strcmp(fname, filename)) { unfamiliar_file = 0; fprintf(tmp, "%s\t%d\n", filename, gapp.pageno); } else { page = atoi(strtok(NULL, "\n")); fprintf(tmp, "%s\t%d\n", fname, page); } } if(unfamiliar_file) fprintf(tmp, "%s\t%d\n", filename, gapp.pageno); fclose(tmp); /* fclose(bookmarks); */ rename(tmpfname, bookmarksfname); How would you make this better? 
[Here](https://gist.github.com/silbak04/49cc5f4dfd0be0448578) is some code with comments, I hope this clears things up a bit. 
The first video in the first 15 seconds names the instructor as Mark Virtue and the material is from the Virtual Training Company (http://www.vtc.com/modules/content/pricing.php). Sign up for a user account if you feel that the content is worth it.
Holy cow they are running on Windows 95 or 98 in those videos!
It should also be noted to anybody using these to learn from that these videos were made in 2001 (at least that is what I can tell from the time stamps on the files seen in the video) and he is using a lot of bad/wrong syntactic styles. I would recommend using another source to learn from.
I'd be happy to help but you need to formulate a better question, you're just saying "tell me everything about pointers right now"
Ted Jensen has kindly put together [a great document](http://pdos.csail.mit.edu/6.828/2012/readings/pointers.pdf) that takes you through pointers step by step. It helped me a lot.
We use pointers for a number of different reasons, the main reason why I've used them is for altering values of variables in void functions (ones that don't return a value). For instance if you want to change multiple integers you could either do this: int change1(int x){ return x/5; } int change2(int j){ return j+6; } int main(){ int a = 4; int b = 2; change1(a); change2(b); return; } or by using pointers: void change(int *x,int *j){ *x = (*x / 5); *j = (*j + 6); return; } int main(){ int *a = 4; int *b = 2; change(a,b); return; } Both of these will return the same values, but the second method is "more simple" as we only have 1 function other than main, rather than 2 and we can get everything done in a single step. 
That would be "node-pointer pointer", or a pointer to a node pointer. You can stack pointers to various levels, I don't actually know if there is a limit to it. You'll also see `char**` in `int main(int argc, char** argv)` in some examples, and it would be a pointer to a `char` pointer. Usually if you have a pointer to a pointer, it's for (dynamically allocated/growing) arrays of arrays. In this case, it's a pointer to a pointer for `node`s, and it seems specifically for the base of a tree. Someone could probably give a more accurate answer than I, that's just my understanding and you shouldn't take my word for it until quite a few people say something similar.
tree is a pointer to a pointer to a node. Instead of node, lets use something simpler, an int. int a = 0; Now you want a point to a: int * ptr_a = &amp;a; Now you can get a pointer to ptr_a: int ** ptr_ptr_a = &amp;ptr_a; These 'double dereferenced pointers' are useful for when you call function that need to return pointers, but already have some other return value, like an error code. // pseudo code bool load_file(void **data) { // read the file into a memory location. void * buffer = malloc(1024); bool retval = read_data_into_buffer("aaa", buffer); // let the caller know where the buffer is. *data = buffer; return retval; } void * data; bool error = load_file(&amp;data);
Yup! I use C++ more often than pure C, but every once in awhile I prefer to mess around with "C with Classes" style code. So instead of having a std::vector&lt;std::vector&lt;Pixel&gt;&gt; pixels; for a `Canvas`, I'll have size_t width = 250, height = 250; Pixel** pixels = new Pixel*[height]; for(int i = 0; i &lt; height; i++) { pixels[i] = new Pixel[width]; } (And of course `delete[]` every `Pixel*` in `pixels` and then `pixels` itself in the destructor). I just realized that this probably made everyone reading it cringe in disgust. I don't do serious projects in that style, I just see how far from modern C++ I can get and have everything work as expected when I'm a bit bored.
The other answers are sufficient, but I just wanted to point out that you are essentially *grouping* them wrong. It is not a node (**) tree It is a node (* (* tree)) The thing in the outer set of parens is a node, and therefore the thing in the inner set of parens must *dereference* to a node! which means it is a node pointer. Likewise, the 'tree' must dereference to one of *those*, so it must be a pointer to a pointer. The memory address at which a node is held is also a thing that is in memory, and this thing can hold the address to *that*.
Also, you often see pointer-to-pointers in functions that NULL-out or modify the pointer passed to it (for instance *_free() style functions). Example: void bstree_free(bstree **tree) { ...free nodes... free(*tree); *tree = NULL; } This way the pointer passed to bstree_free() becomes a NULL pointer. If the user accidentally does something stupid, like call free(tree) after calling bstree_free(tree), then it won't cause a segfault.
what's the difference between char **argv and char *argv[]?
Not much, I don't think. At least not in practice- that isn't to say that, for example, `node* tree[]` is the same as `node** tree`, but the way the `char**` is passed to `main`, it doesn't matter if it uses `char* argv[]` or `char** argv`.
nothing. char[] == char*. 
Thank you both. Always wondered.
Dereferencing a pointer after it's been freed is undefined, yes, but what you would be doing here is simply setting the address of the pointer to NULL (remember that this is a pointer to a pointer, so dereferencing it gives you what the pointer points to, which in this case is bstree *tree). I can see how you could get confused, seeing the pointer dereference symbol. To clarify, how it would be called is like so: bstree *tree; ... bstree_free(&amp;tree); So by doing *tree = NULL, you're NULLing out the pointer that the user passed to the function, which from all practical standpoints is the same thing as: bstree *tree; ...allocate memory, do stuff... ...free nodes... free(tree); tree = NULL; 
There will be some code that calls the insert. That code will have a variable: node *tree; The root of the tree is just the node that happens to be first. There's not a special node_head type, in your example. So what happens if the node you're inserting needs to go to the top of the tree? If that happens, your "tree" variable needs to be updated and set to "item". But, all function arguments are passed by value. If insert were written as void insert(node *tree, node *item);, then it couldn't change tree, it could only change to what tree pointed to. But by making it a node pointer-pointer, you can call it like this: insert(&amp;tree, item); Insert then modifies your local variable named tree, because you passed it the address of your local variable (which happened to already be a pointer, thus making it a pointer-pointer), instead of only passing it the address of a node structure on the heap.
They are equivalent when they are used as the type of an argument to a function, because when an array is passed to a function it's actually a pointer to the first element of the array that is passed, and not the array itself. But these types are different if you are declaring a local variable. The following variable declarations are quite different: char **a; char *b[10]; The first declares `a` to be a pointer to a pointer to `char`. The second declares `b` to be an array of 10&amp;nbsp;pointers to `char`. Those are not the same.
It means the code was written by a [two star programmer](http://wordaligned.org/articles/two-star-programming).
It's a pointer to a pointer. "item" points to type "node" , "tree" points to type "node\*" . If you took the address of tree it would have type "node \*\*\*".
To be clear here, the programming concept "2-D array" can be implemented in C either as an array of pointers, or an array of arrays. If you go for an array of arrays (e.g. int x[3][4]) then you cannot use a pointer-to-pointer to reference the array members.
It's UB to read the value of \*tree after freeing, but you can assign to it. (Same reason that this is not undefined: char \*x; x = NULL; 
There is no difference whatsoever, if and only if it's in the formal parameter list. This is a quirk of the syntax for the formal parameter list. They are very different in other situations. Don't listen to the guys saying that arrays are syntactic sugar for pointers or other such rubbish. An array is a block of memory (could be very large); a pointer is a small unit (typically 32bit or 64bit) that typically contains the address of another memory location. There's a rule (called "The Rule") that if you use the name of an array in a context where an rvalue is required, then what you actually get is an rvalue pointer that points to the first element of the array. But to avoid confusing yourself it's important to remember that you have obtained a pointer in these situations , and the pointer is a different thing to the array. C would work just as well without "The Rule", but you'd need to use a few extra &amp; or [] operators than you do otherwise.
An array is like a row of houses on a street. A pointer is like a piece of paper with the address of a house on it. Or the paper could just have the name of the street. A 2-D array is like several parallel streets of the same length, each with a row of houses on them. An array of pointers is like a piece of lined paper with the address of a house on each line. 
&gt; You can stack pointers to various levels, I don't actually know if there is a limit to it. I get the feeling that there isn't: http://codepad.org/pQsPWtWa
With Linux your serial port would be [/dev/ttyS0](http://stackoverflow.com/questions/10242648/programming-linux-serial-port-ttys0) Your parallel port is /dev/parport0
Yeah this is the biggest difficulty I've been having. I've made the program completely fine for the arduino, but I can't get to the point of making a program to easily send commands to the arduino. Ultimately I'd love to be able to control it with an xbox controller by reading the inputs and then sending them out to a com port, but even just reading a simple scanf input and sending each letter input from a computer as a command is proving difficult. I've seen plenty of people using xbox controllers to control their RC cars/quadcopters, but no one links to the program they are using despite it being an almost identical setup to what I have. Sorry for the rant, I've frustrated myself to no end on this project so far today.
If this were stackoverflow, I'd select this as the correct answer. Thanks for the detailed response. 
Right, I was only referring to the notation in the function parameter.
Quick question I didn't want to ask on Stack Overflow: What is with all this foo business? I see examples always using it as a variable name, but in the 3 languages I've been formally taught I've not once seen foo.
foo, bar, baz and qux are placeholder variable names that are widely used in documentation, both formal and informal. It started off as an in-joke and pun on the military term FUBAR, but it's now a widely accepted standard. https://en.wikipedia.org/wiki/Foobar
Do you have a source for this code? I would be interested to see the code that requires a double pointer to the header of a Binary Search Tree (BST) for an insert. Usually a header (tree *) is used to avoid double pointers. Typically, the tree header is passed by reference with some basic information about the tree, including a pointer to the root of the tree. In this way, the root can be changed without the need for a double pointer. I have not seen a BST ADT that has arguments of this form and I would be very interested to see the implementation.
I sure do! #include&lt;stdlib.h&gt; #include&lt;stdio.h&gt; struct tree_el { int val; struct tree_el * right, * left; }; typedef struct tree_el node; void insert(node ** tree, node * item) { if(!(*tree)) { *tree = item; return; } if(item-&gt;val&lt;(*tree)-&gt;val) insert(&amp;(*tree)-&gt;left, item); else if(item-&gt;val&gt;(*tree)-&gt;val) insert(&amp;(*tree)-&gt;right, item); } void printout(node * tree) { if(tree-&gt;left) printout(tree-&gt;left); printf("%d\n",tree-&gt;val); if(tree-&gt;right) printout(tree-&gt;right); } void main() { node * curr, * root; int i; root = NULL; for(i=1;i&lt;=10;i++) { curr = (node *)malloc(sizeof(node)); curr-&gt;left = curr-&gt;right = NULL; curr-&gt;val = rand(); insert(&amp;root, curr); } printout(root); } 
Ah! So typically, we would expect the following: typedef struct tree_node_tag { struct tree_node_tag *left; struct tree_node_tag *right; void *data_prt; } tree_node_t; typedef struct tree_tag { struct tree_node_tag *root; int num_elements; int various_other_properties; } tree_t; Now we could use insert like this: void insert(tree_t *tree, tree_node_t *node) { //insert node into the bst } But this source has a unique approach! Instead of the header block (in the traditional case, the structure tree_t) there appears to be no need for a header, so the nodes are passed in as a double pointer. The reason this is done, is for the same reason we use a header. Take for example the first node inserted into the tree. If we only have a pointer to the root node, which is initially null, we cannot change the value from NULL to *node* with merely a pointer, so we need the address at which the NULL value is stored to change it to the address where *node* is stored. This tends to be a little confusing and some people opt to pass a header in, and change the value associated with the root node. The source code you provided is extremely lean and quite an impressive implementation. Edit: Clarity.
Ok, for a better question, could you demonstrate, possibly by example, how to use pointers inside of functions that use arrays?
C is, in my opinion, the "one true language". It is what has influenced pretty much every other major language out there today (lets ignore Haskell et al. for this post). It can be used to do *anything* you want. Yes it is manual but that is a positive in my books. It is elegant. It is beautiful. However they are all quite personal opinions of C really. As for why you would want to master it? Well I guess it is like mastering how to drive a manual rather than an automatic [car]. Why not? C is a fun language. It teaches you have to be more sensible when going things in higher level languages. Other languages are "better" than C for some things and C is better than those (or really your only option) in others. As you are getting an Arduino I would highly recommend sticking with C. Like you said you already "really, really like C" and you should! It is an amazing language. So small yet it has powered the world of computing for almost half a ~~decade~~ century! (typo: thanks for pointing it out Elite6809!) If you want to get into embedded systems in any serious way then C is the way to go without a doubt. I am biased though as I love C and all of my personal work is in C if it can be as I just love the language more than any other. 
One extra bit of advice: If you do decide to really stick with C then I suggest doing so on Linux rather than Windows if possible. I say this because you will want to use a decent compiler for C and sadly Microsoft's C++ Compiler isn't a good C compiler. I really enjoy Visual Studio for C++ but I just find it hard work for C as the editor doesn't really support it and there support for C90 and above is very hit and miss. Personally I use GCC and either Linux or Windows (only when I really have too) with MinGW.
Arduino is more C++ no? If you want a job try php or java. 
There's a saying that I've heard multiple times from different people in the tech and IT business "If you're good at C, you'll be sorted for life" (by which they mean, there's always jobs looking for C developers). A lot of job vacancies that I've seen posted don't actually ask for knowledge of a specific language anyway, more they just want people to have an understanding of what programming is.
I'd definitely recommend just using GCC in Linux, I use it for a on a 15GB Ubuntu VM and it's so simple to just get straight into everything.
&gt; Arduino is more C++ no? No, it's definitely C.
C is not the best for everything. If you want to be an app or web developer, there are better languages out there now. Another thing to keep in mind is that "mastery" tends to be domain-specific. The core of the language is not too too complicated. Becoming an expert in even a small piece of a project like the Linux kernel is a major undertaking, though. Likewise embedded development is probably its own skillset, concurrency is another, graphics is yet another... However: learning C if you're interested in system software is still a good idea as it's pretty dominant across the board there. There are [little](http://ertos.nicta.com.au/research/l4.verified/) [pockets](http://research.microsoft.com/en-us/projects/singularity/) of [people](http://hasp.cs.pdx.edu/) out there doing work in other languages to try to change that, but most of the kernels, drivers and low-level application libraries out there are in C, maybe more C++ if you're on Windows. In Linux, you've got (I think, double check me on some of these): * The kernel * libc * X.org * Apache * Some of git * OpenSSL and OpenSSH * Various language interpreters and runtimes: most JVMs, CPython, Perl, the GHC runtime, ... Just a few random companies off the top of my head where you'd be very likely to find openings for jobs where you'd be working mostly in C: * Microsoft * Redhat * Novell (SUSE) * Intel * SGI * Cray * Mellanox * Nvidia * AMD * IBM * Oracle * Cisco
Nah man that's definitely C syntax.
I love C because of how "truthful" it is. You really feel like you can communicate with the hardware. I always like to say "What you C is what you get!" 
The title says "mastering", but your post says "proficient", so I have two answers. If you "really, really like" C, I think that that, combined with its popularity, is more than sufficient reason to try to become proficient. I'm not sure what level of mastery you meant in the title, but I'd consider mastering C to include learning much of the trivia about the language: strict aliasing, many of the countless instances of undefined and unspecified behaviors, integer promotion rules, etc. I think it's worth almost no one's time to master C in that sense. If you do want to go that far, [Professor Regehr's blog](http://blog.regehr.org) is an excellent resource.
I don't think you need to master C (at first, that is - you should aim to master everything ~~eventually~~ at the appropriate time), but it is extremely useful and/or important to know it. It is literally a (slightly) human-friendly interpretation of exactly what is going on under the hood.
As a C developer with nearly 20 years experience, I've only recently gotten into the embedded world. So its not only for embedded. I've developed applications, internet infrastructure and even the occasional web app (CGI, ok, this was a long time ago), all in C. C is used every where. As one person noted, its the one true language. Its as close to assembly as you can get, without knowing assembly. That said, my C programming has gotten better, as I learned other languages. Especially the functional aspects of Python. Learning different languages gives you insights into other ways of thinking. C is also the glue language.. When you write modules or extensions for another language, you'll most likely have to write that extension in C.
On Windows you can use MinGW, which is essentially GCC ported to Windows. That's what my school told us to use for our projects and stuff.
I agree, In my opinion (and i may be quoting someone here), C makes good use of expensive computers, python makes good use of expensive computer programmers.
&gt; But this source has a unique approach! Its a nice technique. If you're doing a doubly-linked list, you can easily exploit this and further hide the tail pointer inside the head's `prev` pointer. So you can get to the end by going "backwards". (Note the tail's `next` pointer is still NULL). Then you have a doubly linked list without having to store `head` or `tail` seperately.
It's just a placeholder name. It's a longer version of FUBAR: fucked up beyond all repair (or recognition). It's part of hacker culture; there's no deeper meaning to it. :)
Ha, that is what happens when I write past my bed time ;)
Always happy to help :)
There are several C compilers available for Windows; not the least of which is GCC. You can program in Windows perfectly well without touching Microsoft's development tools. 
Yeah. I learned BASIC programming as a kid, and the first time I saw C I was instantly hooked because there was "no bullshit". Bitwise-AND always worked for example (in Basic, some dialects had AND as bitwise and some as logical, and some dialects even alternated its meaning based on context .. hate that shit) 
Amen to that. I use the development tools which were formerly Borland; I wrote a component about 13 years ago that wraps the serial port, got all the fiddly details right, and haven't touched the internals of it since, and wouldn't want to! 
By higher-level, you mean involving a language that is more high-level, such as in the field of website backend development? That's another thing I'm interested in.
Indeed which is why I mentioned MinGW. I was simply pointing out that MSVC doesn't make for a very good C compiler and that if you are looking at mastering C then doing so on Linux is generally a better environment (at least better in my opinion). 
This is a shameless plug, but you can use [Tenacious C](http://tenaciousc.com) to see how pointers and arrays function. TC is graphical IDE that depicts the same sort of arrows and memory boxes your instructor draws on the whiteboard, but you can step through the program at your own pace to get a full understanding. Many students and teachers have had success using it. The trial version is free and never expires.
and I think it means something that not many (non-emacs user) people use it.
Depends where you are. My work will do interships with the local tech high school, and if there was someone with C programming experience (and/or Linux experience) I'd be strongly inclined to pick them up. Your pay won't be amazing, but those internships would pay pretty well compared with the typical high school job. *Edit: in fact, the only students that had C/C++ experience were already taken by the time I had a chance to look through their resumes. *Edit 2: I would recommend reading the GNU C library reference, as well as K&amp;R second edition. The former is available either as 'info libc' on your command line, or as an online PDF.
Yes. I started with C and frankly it gave me a good solid base to build my skills from. Knowing a lower level language well gives you insight into how a system works. The C family of languages is easier to learn (usually) if you know the parent language too.
I would use fopen (from stdio.h) instead of open: int main(int argc, char **argv) { FILE *fp; // TODO: Check that argv[1] exists // Open a binary file to read fp = fopen(argv[1], "rb"); // TODO: Check that fp is not NULL, then use fread() } Then call this program from the command line like this: ./program example.dat 
I'm trying to read the file byte by byte, not as strings. Would it be the same with fread()? 
Only if the profiler says it's a hotspot, which it rarely is. Recursion is often the simplest, clearest way to express an algorithm, which is a massive win any time.
fgetc() for byte at a time input, fread() for multiple bytes at once.
You want `fread` then: size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) You want something like: int main(int argc, char **argv) { FILE *fp; // TODO: Check that argv[1] exists // Open a binary file to read fp = fopen(argv[1], "rb"); // TODO: Check that fp is not NULL for (;;) { // infinite loop char data[2048]; size_t i, nbytes_r = fread(data, 1, 2048, fp); // loop over each character for (i = 0; i &lt; nbytes_r; ++i) { char c = data[i]; // TODO: do what you need to do with each character } // TODO: if nbytes_r != 2048, we're probably at the end of file, // could also be an io error. Handle this condition properly. At // minimum, break out of the read loop. } } **EDIT:** `fgetc` can also be used in a loop, as it grabs one character at a time. The standard io libraries do buffering behind the scene so it will be pretty much identical in performance as using `fread` (it won't litteraly hit the disk for one character at a time, it'll read ahead a few at a time).
I don't believe the purpose of this subreddit is to help with assignments. The only thing I would suggest is to compile your code with stricter rules. When I learned c, I always used: -Wall -Werror -Wextra -ansi -pedantic You can find more about flags [here](http://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html).
Well I mean is there a place for help? because I thought this sub was about learning C programming, and that's what I'm trying to do, I'm trying to learn. I didn't come and ask you to write the code, just looking for a little guidance.
Take a look at these lines: if(answer &gt; 5 || answer &lt; 0) {/*..*/} and computerGuess=rand()%4+49; Why are you adding 49? I assume it has something to do with the [ASCII table](http://www.asciitable.com/). Try doing whatever you are doing in baby steps. Instead of breaking down when you can't get one of your branches to fire, consider inspecting the predicates. char c = getChar(); puts(c); // prints the value of c to console if (c &lt; 5) { puts("yay"); } else { puts("aww"); } Just remember not to return your assignment with `puts` in it.
That's just a compiler warning. Bottom line is, your variable may not be what it is. Try printing it out. You can try casting it, use a different printing function or step through it in `gdb`, just inspect the value and see if it matches the predicate.
Cool. Thanks :)
This is what I have now, but it now doesn't match up the numbers, it just keeps looping and never recognizes that the numbers match each other. #include &lt;stdio.h&gt; #include &lt;math.h&gt; #include &lt;stdlib.h&gt; int main(void) { int i, computerGuess; char answer; computerGuess = 0; printf("Input number between 1 and 4 to begin, input number : "); scanf("%d ", &amp;answer); if(answer &gt; 5 || answer &lt; 0) { printf("Your number is not valid, must be between 1 and 4"); } else { printf("I will now try to guess your number.\n"); for (i=1;i&lt;=20;i++) { computerGuess=rand()%4+49; printf("I guess %c? And you're number was %d\n",computerGuess, answer); if(answer == computerGuess) { printf("I have correctly guessed your number. \n"); break; } else { printf("I was wrong, I'll try again.\n"); } } } return 0; }
The functions `fopen`, `fread`, `fgetc`, etc. are standard C functions. The functions `open`, `read`, etc. are POSIX functions. The standard functions are suitable here, so as the other guy says: use `fopen(argv[1], "rb")` to open, and `fgetc` to read. Pitfall 1: `fgetc` returns a signed `int` value in the range 0-255 if it is a valid character, and the int `EOF` (usually `-1`) if it encounters end-of-file. So you **must not** assign the result of `fgetc` into a `char`, you have to put it into a variable of larger type such as `int` and then check if it equals `EOF`. Pitfall 2: `feof` does not trigger until you have already tried to read and failed. If you use `feof` to check if there is more data or not, you're doing it wrong. The only time to use `feof` is when trying to read a character fails, and you want to know whether it failed due to end-of-file, or a different error condition. 
`"r"` means read-only, and `"b"` means "binary mode". If you are not in binary mode then the operating system may translate characters; the most common example of this is if you're in Windows and do not open a file in binary mode, then if the file contained `0x10 0x13` and you read a character, it will just return a single `0x10` for that pair of characters.
In addition to what others have said here, have a look at `mmap`.
That's correct I don't see the issue Ps. Maybe use else ifs atm you are checking all the conditions even if the first one is correct 
scanf is a truly vile function. I would suggest an intermediary operation as follows: Say I wanted to parse a single number from stdin. #define LENGTH 256 int main(void) { char buffer[LENGTH]; int to_read_in; fgets(buffer, LENGTH, stdin); sscanf(buffer, "%d", &amp;to_read_in); printf("Your number: %d", to_read_in); return 0; } Using fgets allows you to read in a string of length LENGTH - 1 (with the character in position LENGTH being the null character, but don't quote me on that). This allows you to take the intermediary string and parse it with sscanf, which is a much safer alternative to scanf. With scanf there are many unintentional issues that can occur. This is the standard approach that you will see the most. If you are set on making scanf work, I can offer some suggestions, but only if you promise to avoid using it whenever possible. The buffer overflows that often occur with scanf make programs very vulnerable to attacks. try: scanf("%d/%d/%d", &amp;one.month, &amp;one.day, &amp;one.year); Remember, scanf is never desired, but that should do the trick.
See, I would do that, but prof. hates using fgets.
The issue is that I enter them Date 1: m1/d1/y1 newline m2 Date 2: d2/y2/irrelevant And it's shifting this random buffer character to become the 2nd month, and so on.. 
Thank you for your reply! Why did you choose an array size of 80 though? Care to explain? Is it okay to just use str[3]? Would there be problems with this? I'm a using strcpy to "initialize" the array so that it has something in it where I can use strcat to. Is it possible to just use strcat without strcopy? Thanks in advance!
I haven't dealt with these in a while, but it sounds like a buffering problem. You may need to do `fflush(stdout)` after the `printf`s; stdout is often line-buffered IIRC, so another possible solution would be adding newlines at the end of the prompts.
Ah! Windows... Thanks, marupiara aka UNIX bigot from the '70's.
In that case the scanf solution at the end should work. I compiled and tested it. Almost every professor I had refused to accept code with scanf, but I none of them ever mentioned fgets. Out of curiosity, what is his logic? 
Yet limits you to 50 lines of code per project...I'd blow through that with two functions. :\ I've also heard to NOT use IDE's when learning programming.
I think I get it! when p = &amp;x, and we use *p = 10, 10 basically goes to "p" and then the pointer sends that value up to the next *p, until we get to "p = &amp;x". So, pointers send the value up to the next pointer of the same variable until they meet an &amp;"variable". Am I right?
I agree, IDE's can be a hindrance in certain cases. You hear about programmers becoming so reliant on Intellisense they can't write a single line without help from their dev environment. But Tenacious C is a pretty "thin" IDE. It's certainly not a crutch -- to write programs with it, you will still have to understand basic C concepts like pointers, memory, and stack management. What TC does offer is the ability to see what's going on "under the hood", which for people who don't have a low-level or hardware background can greatly accelerate their understanding of said concepts. As for the line limit, message me and I would be happy to send you a license for the lite version (5000 lines per project).
PM'd you. I'll give it a go! Sounds like it could help me understand it a little better. Thanks!
did you add the dummy character to the end of the scanf ? is works for me when this is done 
&gt; I've solved my problem. Oddly enough it was completely different than I thought. It had to do with how the structs were initialized. 
That... was literally ALL I did, and it worked.
I can guarantee you that your struct initialization change makes no difference. Actually the change you've put in your original comment doesn't even compile because "day" is unknown. So you must have made other changes to what is currently in the pastebin. 
i don't see that being the issue 
Well I did that and it fixed the code. I really don't understand it either, but it worked.
why not just open it for reading and writing using r+ instead of just r , regardless you open it for reading twice 
okay well if you have to read bagel .seq twice why not use rewind instead of creating and closing file handlers?
 int fseek(FILE *stream, long offset, int whence); You don't have to open the file twice, just rewind `fseak(cfPtr, 0, SEEK_SET)` Or instead of immediately operating on the entries, since you're already storing them inside that `invent` struct, why not build up a linked list and traverse that the second time?
No. Each function that reads from a file returns a code indicating success or failure, and you act based on that. For example if you're scanning 10 items you could go: while ( 10 == fscanf("%16s.....) ) { Alternatively, for (;;) { if ( 10 != fscanf( "%16s...... ) ) break; 
I work exclusively in C and every job I've had over the last 7 years has been with device drivers. The network stack/block layer in Linux would be a great place to start at
Ok, here goes. Firstly you'd rarely be using pointers outside of an actual function, so that answers that part. An exception to this would be global pointers I'll go with the why part first. To start with, keep in mind that C only allows you to return values. Now suppose you created an arrayof numbers in a function foo that you want to return to the function bar that called foo. struct my_struct_type bar() { /*create structure nstruct of type my_struct_type here */ return nstruct; } void foo() { struct my_struct_type mstruct; mstruct = bar(); } While this is valid code, you are are creating multiple copies of nstruct. A better way to do this is as follows : struct my_struct_type * bar() { struct my_struct_type * nstruct = malloc(sizeof(struct my_struct_type)); /* fill nstruct with values here */ return nstruct; } void foo() { struct my_struct_type * mstruct; mstruct = bar(); /* Note that memory allocated must be freed at the end by calling free(mstruct) */ } Here, function foo no longer creates a second copy of nstruct, instead foo simply has a reference. Total space required by example 1 to obtain a copy of structure is 2 x sizeof(struct my_struct_type), total space required by example 2 is sizeof(struct my_struct_type) + sizeof(void *) (void *) here is basically saying the same thing as sizeof(pointer) which is generally 4 bytes on a 32bit machine, and 8 bytes on a 64 bit machine. I'd be happy to expand on any part of this example you did not understand
LISP was pretty prominent in the AI field. It's not widely used, because "to understand reccursion, you have to know reccursion" ! Also, the syntax is weird as well ! Having said that, I thing that functional programming is very useful to understand as a school of thought!
&gt; %lf is correct for double in the scanf family, but not printf. Incorrect in C99 where `%lf` is the same as `%f`
Can you share the contents of the Makefile?
Sounds like your obj line is not correct, but can't tell without the actual Makefile
You ~~initialized the array with their trash value~~ left the array with the default memory location value. Initialize it with 0 and also if i have less than 100 years there will always be a 0 in the end with the way you are trying to print it. 
Why is `age` an array? If you want to store an integer, you just do `int age;`. Your code will work fine if you change `int age[3];` to `int age;` and you take the address of `age` (`&amp;age`) when passing it to `scanf`. Remember that `scanf` takes a pointer to the object you want to read into, whereas `printf` just takes the object by value. It looks like you were thinking about it like a string, so you would need space for the `4`, the second `4`, and the null-terminator, but that's not what you're doing. When you do `scanf` with `%d`, it reads out an integer. What is currently happening in your code is that when you pass the array `age` to `scanf`, which is converted to a pointer to the first element of the array, and `scanf` reads into the first element. Then, when you pass `age` to `printf`, it is being converted to a pointer to its first element again, and you are simply printing out the value of the pointer - that is, you are printing out the address of the first element. If you actually want 3 integers, which is what `int age[3];` gives you, and you want to read into the first one, then you need to change the last two lines to: scanf("%d", &amp;age[0]); printf("You are %d years old", age[0]); This reads into the first element of the array and then prints the same element.
with scanf it should be: int age; printf("What age are you?\n&gt;&gt;&gt; "); scanf("%d", &amp;age); printf("You are %d years old", age); 
it's not aninitialised value but adress of the array
Correct. My mistake.
Thank you very much, I'm a huge noob at C and need to learn it pronto, appreciate this :)
I double that. All of these are perfectly equivalent: date one = {.day = 0, .month = 0, .year = 0}; date two = {0, 0, 0}; date three = {0};
It's conceivable that this change might trigger a compiler bug ... I couldn't reproduce though.
That's a great list of articles. Does any other C gurus have similar lists?
Nested menus. Options inside options. 
Agreed. I started learning C over 20 years ago, and I still use it regularly today for low-level work (particularly reading/troubleshooting kernel sources). Most of the other things I was learning at the time (gwbasic, how to write DOS TSRs, etc) are long forgotten or obsolete. As meygaera noted in another post, it is also extremely explicit (he called it "truthful"), which ensures that you are forced to deal explicitly with certain aspects of machine operation that you might otherwise not be required to. If you're really planning to get into nitty-gritty embedded work, you'll also want to learn the relevant assembler syntax at some point, as even C can be too high-level at times (fortunately you can usually just inline short bits of assembler in well-encapsulated sections of C). I'd recommend against starting straight at the assembler level in most instances however, as the learning curve can be pretty steep. If you do decide to learn C, I'd suggest you do yourself a favor and start off with clang for a compiler, rather than gcc; the error messages will be much easier to understand. Also: for probably the first 6 months you're learning C, chances are your problem is that you left off a trailing semicolon somewhere, or have mismatched braces/quotes ;-). A syntax-highlighting editor (I use vim, but to each his own) can really help find the problem in a hurry. (If the bottom half of your program is all a single color, chances are you're missing a matching brace/quote.) All in all, C has a lot of advantages (speed, explicitness, broad support, huge codebases deployed...). Perhaps the biggest negative I'd count against it is that because it is fairly low-level, it can have a tendency to cause one to spend more time wrestling with implementation details (recalling how to correctly terminate strings (char arrays) when using strncpy, checking the return value of errno after most system calls, etc), and less time thinking about your solution/problem domain. Languages like Perl and Python give you extremely powerful structures as language native types (hash/dict, for example). Such poweful facilities are not built into the C language. To counterpoint that, there are absolutely a ton of libraries available in/for C, but the trees can be hard to find for the forest. I know I spent a lot of my earlier time with C re-inventing wheels that had already been better solved by someone else in a library I wasn't aware of. As a result, I find I often rapid-prototype a solution in Python, and then, when I've hammered out the design and algorithm I wish to use, I work on moving it over to C, if need be for the project. Best of luck if you decide to learn it. I've certainly had fun with it.
That was a good answer. Thanks.
Just a normal array? Like int myArray[10]?
I'll put the code I'm working on to show
You can properly formate the code by adding 4 leading spaces. What specifically do you need help with thought?
/* "The format is not kept" */ /* " The format is kept" */ See the difference? Maybe it's just me but I'm still not sure what exactly you need help with. By the looks of the requirements it seems like you code needs to: 1. Read in 20 or less values and store them in an array. 2. Possibly implement a sort to sort the array of values (bubble sort?) 3. By doing step 2 you automatically find the smallest and largest values. 4. Output your results. Now, is there a specific step that you are stuck on?
Why can't you post it online? Somehow I doubt that you're allowed to seek outside help if you're forbidden from publicly posting it... But I'll help. PM me if you like.
I'm not sure if you're supposed to do this. Definitely since it's an exam. Nevertheless, if you want help you can try to describe the problem you're having rather than trying to shove code to people. If it's a problem with how calloc or structs work make the description have an example unrelated to your exam.
We just have to state where we got help, and with what. Something as basic as this: match *matchInterval = calloc(matchesInInterval, sizeof(match)); gives me matchInterval == NULL = true The struct for match looks like this #define TEAM_NAME_LENGTH 3 typedef struct tem { char name[TEAM_NAME_LENGTH + 1]; int wonOut, wonHome, tieMatches; int spectatorsHome; int points; } hold; matchesInInterval is = 107
Working on an english version. Going to post it here.. Yes I've included stdlib.h. if(matchInterval == NULL) { errorMessage("matchInterval"); } the errorMessage() is: void errorMessage(const char *error) { printf("ERROR - %s\n", error); exit(EXIT_FAILURE); }
Oh, since this is a can-i-ask-here topic, I would like to ask a question: i would like to ash something about parallel programming (pthreads/posix semaphores). I have to master it using the C language, so i'm not sure if I could make questions about parallel programming here or if i should go to another subreddit like for esample /r/learnprogramming
Assuming match is a typedef'ed struct, everything seems alright. Can't conclude, using the given information, what's wrong, really. If you really, **really** believe it's calloc is at fault, you could try using malloc with as parameters matchesInInterval*sizeof(match) and then doing a memset for to initialize it all to 0x00. Highly doubt that's the problem though.
Done.
The program runs without reporting a calloc error, for me. You have a buffer overflow *after* the calloc, but that ought not to cause `errorMessage("matchInterval")` to be triggered. Can you confirm that you actually are getting this message? What development environment and compiler are you using? The buffer overflow is that on line 247 the first `i` should be a `j`. The compiler should perhaps have warned that the value of `j` was never used. If I make that change then the output looks sensible.
Yeah, I can see that the i should be a j, however my code doesn't even reach that point, as it stops at line 239, trying to initialize the matchInterval, where it crashes. I am using Notepad++, and MinGW on Win7. I don't get any calloc errors too, but Windows just tells me that the program stopped working.
Also, the `fscanf` is very fragile; you could change 1 character in the datafile and send the program completely off the rails. But if you use the exact file as you sent me then it does walk the tightrope. If you change the "%s" to "%3s" in the scanf, that will at least guarantee you no buffer overflows; you'll just get screwy output if the datafile is wrong. Also, you should check that fopen() succeeded, and check that fscanf() succeeded each time (it will return 11, the number of items read, on success). 
Well, the file is always like this (given by the teacher), and he says we souldn't check for errors. Just make everything simple. PhDeezNutz just tried to run the code, he gets no errors and the exact output I want. He thinks something is wrong with my compiler or machine. No it doesn't, it crashes when it tries to calloc. I'm going to try a LiveUSB of a Linux distro, are there any that has MinGW (or what it is called in Linux) built in?
Yes I did, thank you. Right now I am installing Ubuntu on my laptop, can't do any programming while doing that..
Thank you for your help. I handed in the program, definitely not a F grade program now :)
Everything worked fine with Ubuntu, going to drop Windows from now on.. Thank you.
You'd better not write your `for` loop like that unless `NUMBER_OF_DIGITS` equals `strlen(str)`.
Is there a way to do this without using pointers? I'm quite new to C, and my course hasn't covered them yet. 
That guarantee can be made since the string is known at compile time (and it's contents won't change). Of course, it goes without saying that the number array doesn't need to be created dynamically from a string at all. Since the 1000-digit number is constant, it can be put directly in the source code. You just need code to translate a string of digits (`7316717...`) into something that looks like a C array (`{7, 3, 1, 6, 7, 1, 7, ... }`). That can be done either in C or, more easily, in a scripting language. You can then dump the array into your source code, with the concession that it's going to take up quite a bit of space.
&gt; That guarantee can be made since the string is known at compile time (and it's contents won't change). What I mean is that you need to make sure that you declare `NUMBER_OF_DIGITS` to be the same as `strlen(str)`. It's common to see constants like `MAXLEN` or something that are defined to give the length of an array that will be more than large enough to hold whatever is intended to go into the array, and when I first saw your code that's what I thought you were doing: just making `NUMBER_OF_DIGITS` sufficiently long so that `number_array` could hold all of the digits of `str`. But that code has a stricter requirement than that—the way it's written, `NUMBER_OF_DIGITS` must be *exactly* the length of `str`, no more, no less.
Change line&amp;nbsp;2 to this, if you prefer: char str[] = "73167176531330624919225119674426574742355349194934...";
If you're scared of the asterisk (you don't have to be), you can replace that line with char str[] = "7316..."; ... without changing the functionality of the code I just wrote. Of course, that changes the semantics of the program a little bit (for example, making it an array will probably cause a non-negligible performance penalty, although you gain the ability to mutate it). The string isn't technically even necessary. You can just put the array into the source code directly, if you can construct it with another program. (See my other reply to /u/zifyoip in this thread)
Ah, I see. Should have read the problem statement, I suppose.
Kind of. There are a couple differences: 1. There's always a terminating NUL byte (`'\0'`) after the bytes of a string. This means that even the "empty" string (`""`) is still a byte long. 2. The characters in a string are obviously character values rather than integer values. The string `"123"` is different from the string `"\001\002\003"`, which has the literal values `1`, `2`, and `3` embedded in it rather than the characters `'1'`, `'2'`, and `'3'`. To get `1` from `'1'`, you have to subtract `'0'`. In other words, `"123"` is equivalent to the `char` array `{ '1', '2', '3', '\0' }`.
In&amp;nbsp;C, a string is a `char` array, yes. More precisely, a string is a *null-terminated* `char` array, which means that the array contains all of the characters in the string, followed by the *null character*,&amp;nbsp;`'\0'`, to mark the end of the string.
Thanks!
I used an earlier edition of O'Reilly's [*Practical C Programming,* by Steve Oualline,](http://shop.oreilly.com/product/9781565923065.do) and thought it was really good. The thing is though that O'Reilly editions only get thicker, never thinner, and the book is over 450 pages at this point, so I can't give it an unqualified recommendation. But, going by the earlier edition that I used when I was getting started, I think it's definitely worth taking a look at.
Sure, happy to help. Turns out your code was correct on its own! 
Yeah. Weird..
Maybe it's writing the file in an unexpected location; try putting the full pathname in `fopen` . (Use either forward slashes, or double backslashes). 
BTW, `fclose(NULL)` is undefined behaviour, so shift that to be inside the `else` block.
This was exactly the problem, thank you! Can't believe I hadn't tried that lol.
Works fine for me (gcc 4.7 and Ubuntu 13.04), although I had to define `charToUpper` and `isInAlpha` myself. But since you said that console output looks fine, it's unlikely that the problem is in those functions. Have you checked the write permissions of the directory? Maybe try using an absolute file path to make sure that nothing strange is going on with the working directory path.
Ahh thanks! I had it in there before but moved it out thinking if I opened the file, that it needed to be closed, but forgot that the else was triggered with a successful file open.
The problem was absolute file path. I am using XCode 5.0.2 on OSX 10.9.
What resources have you used to learn scanf()'s use?
http://www.cplusplus.com/reference/cstdio/scanf/ http://msdn.microsoft.com/en-us/library/9y6s16x1.aspx and many other forums with similiar questions. All the examples seem to include spaces between the characters, but my users may not enter the spaces, (i.e 2*2 rather than 2 * 2). It works ok when the user uses spaces etc. My problem is, when the user input 1+ 1 (insead of 1 + 1 no spaces) it gets the 1, but not the rest (at least in the format I want). therfore, using printf("%d %s %d", op1, &amp;operation, op2) after scanning gives me output : 1 &lt;S@ 18729878981 instead of : 1 + 1
Sure thing. So when scanf see's a ' ' (space) in it's format string, it interprets this as "any ammount of white space, tabs, etc, **or none**". so scanf("%d %c %d", &amp;op1, &amp;operation, &amp;op2); should work fine for: 1 + 2, 1+2, 1 +3, 1 + 3, etc. Now that's fine but what if the user tries something like: 1 ancasdfweoj 3 You're going to get garbage. So what you can do is first of all specify a set of valid operators that match: scanf("%d %[+-*/] %d", &amp;op1, &amp;operator, &amp;op2); where operator is type char. If you check the return type of scanf(), its the number of matched values. so consider something like this to guard against dumb users: int count = scanf("%d %[+,-,*,/] %d", &amp;op1, &amp;operator, &amp;op2); if (count != 3) { puts("Bad input!"); return 1; } Hope this helps!
Spaces in the format string translate to zero or more whitespace characters [1] in the input, so "%d %1s %d" should work. [1] See [http://man.cx/scanf](http://man.cx/scanf): &gt; A directive composed of one or more white-space characters shall be &gt; executed by reading input until no more valid input can be read, or &gt; up to the first byte which is not a white-space character, which &gt; remains unread.
&gt;printf("%d %s %d", op1, &amp;operation, op2) What is `operation` ? If it's an array of char then you shouldn't use the `&amp;` with it, in both scanf and printf. (and rro99's suggestion of using %c will mean that you need to output it with %c rather than %s too). 
Woops, good point about the ouput
Thanks! this worked, I see what I was doing wrong before. Also thank for the useful checking the number of arguments tip. I think I will be using %[+, -, *, /, ^, sqrt, or, and, xor] to receive input. Do you see any issue with using string like sqrt or xor in there? it seems to append a heart or spade (and other various symbols) when I print the scanned info. 
operation would be on of the following: +, -, *, sqrt (i know to use %nd here) etc , so only one string per entry. I believe what you are saying is that if I decide the user can enter multiple operation in one go (like " (2 + 5 )/14 ) ", I should not be using the &amp;? 
If the function is moving only between adjacent cells that are the same color, none of them will ever be surrounded on all 4 sides by the opposite color. It sounds kind of like you're trying to use a modified version of [flood fill](https://en.wikipedia.org/wiki/Flood_fill). This is a perfectly valid and reasonable way to check all the connected cells in a grid, and the wiki points out that it is often used for checking things in Go. I assume you are using '+' to represent a specific color or a border character. I would suggest assigning this to a constant variable, or, better yet, an enum. It's much more self-documenting to have `if(thing == BLACK)` or `if(thing == BORDER)` than an arbitrary character. As to your actual function, there are a few problems: * You only ever return 0, and only then at your base case. I assume since you've given the function a return type of `char`, you have some desire to be able to check that return value. To have the values filter up, you'll need to prefix recursive calls to gridrec with `return` as well. * That said, it appears that you're just using `return 0` as a way to say "we've hit the end, don't continue" - if I'm correct about that, you can make this a `void` function and simply use `return` with no value. Use of `return` in a void function simply ends function execution, going back to whatever called it. * You are iterating through the four adjacent squares, but cutting that off as soon as any of those match `' '` or `'+'`. Thus, if the first adjacent side you check matches one of those, the function will return and none of the other adjacent sides will be checked at all. I doubt this is the behavior you want - while I don't know Go very well, I know that it does not particularly care about *which* adjacent side something is happening on.
&gt; operation would be on of the following: +, -, *, sqrt I mean, `operation` is the name of a variable but you didn't show its declaration . Is it an array of `char`, or what? I'm saying that if it is an array of `char` then the correct syntax for printf and scanf is to not put the `&amp;` symbol before it. Using `&amp;` is a mistake, although it is likely to work on most compilers.
Correct. Edited to reflect this.
&gt;it seems to append a heart or spade (and other various symbols) when I print Welcome to the world of C style strings. In C, a string is a null terminated sequence of characters. What I mean by that is when you write puts("Hello"); The compiler creates an array that looks like [H][e][l][l][o][NULL] Where NULL is the character '\0'. In the example I showed you, I'm copying to the memory location of operation one characeter (%c), which is why scanning 1 + 2 works, but scanning 1 asdf 2 does not. You'll need to store your result in a string, which is an array of characters and is referenced to by a pointer. int op1, op2; char operator[20]; scanf("%d %19s %d", &amp;op1, operator, &amp;op2); Afterwards you'll been to compare the result that was stored in **operator** to whatever it is you're trying to match it to (example the string "+" or "sqrt"). As someone pointed out elewhere, you'll notice that operator does not have &amp; in front of it. This is important. **operator** in this context is already a pointer to a character, whereas &amp;operator is a reference to the memory location of operator. The reason you see hearts and spades is because you're asking printf to print the string that begins at a character that you stored in **operator**, but its not null terminated, so it'll just continue to print whatever garbage is in memory until it encounters a null character by chance. Isn't C fun? 
Some resources and jumping-off points may be found at [Sensei's Library](http://senseis.xmp.net/?ComputerGoProgramming). Specifically, there are [algorithms](http://senseis.xmp.net/?ComputerGoAlgorithms) discussed for matters of connection, life and death, detection of eyes, etc. Rather than detecting the alive/dead status of a chain of stones with such an expensive algorithm all at once, you could consider maintaining an incremental set of data for each chain of stones that tracks the number of liberties the chain has. When each move is made, such incremental data structures can be updated with relative ease on any adjacent chains. Then the number of liberties (for example) can be read for any chain at any time, without calculation. This is oversimplified and there are always pros and cons, but maybe you'll find this approach useful.
Instead of that you could use some parsing logic to split it up into tokens so that even if spaces are omitted at input time, you still end up with a valid statement. For example: 1+ 1 can be parsed as below: 1 is a number, hence a token, + is a valid operator, hence a token, space is not used, discard 1 is a number hence a token Now convert and apply the operations before outputting the result. This may seem a bit complex to implement in C compared to say C++ or C#, but thats the fun part of C
Thanks! makes perfect sense now!
I think r/ObjectiveC might be more appropriate, or am I missing something? 
We're at /r/iOSProgramming
Actually this is /r/c_programming 
I'm not talking about library support, but language features like compound literals and designated initializers. This has been long overdue and it seems VS can now finally build ffmpeg. It's a bit surprising because not too long ago Herb said they will focus on C++ and not touch the C compiler which they keep around only for compability reasons. The only thing I miss now is dynamic arrays but that's not a biggie because of `_alloca`.
The value of a variable can change. It is able to vary. That's why it's called a variable. The value of a constant cannot change. That's why it's called a constant. I don't really understand what you're asking.
Supports these ISO C99 language features: * _Bool * Compound literals. * Designated initializers. * Mixing declarations with code. C99 Libraries: * Declarations and implementations are added for missing functions in these headers: math.h, ctype.h, wctype.h, stdio.h, stdlib.h, and wchar.h. Also added are the new headers complex.h, stdbool.h, fenv.h, and inttypes.h, and implementations for all the functions declared in them. There are new C++ wrapper headers (ccomplex, cfenv, cinttypes, ctgmath) and a number of others are updated (ccomplex, cctype, clocale, cmath, cstdint, cstdio, cstring, cwchar, and cwctype). For more information, see C99 library support in Visual Studio 2013. 
The `++` (and `--`) operator are often misunderstood. `++x` means: use the value `x+1`, and increment `x` at some stage. `x++` means: use the value `x`, and increment `x` at some stage. There's no ordering implied between the two aspects in each case, and if you think of `++x` as being "more definite" than `x++`, or something, then your thinking could do with updating :) As the article points out, "at some stage" means in-between sequence points, of which there are none introduced by the `+` and `*` operators. If a variable is written more than once, or read and written (where the read is not forced to be before the write) in between sequence points then the behaviour is undefined. 
`--atoms` and `atoms -= 1` are exactly equivalent, so I don't know why you call one of them good and one of them bad. Perhaps you would even trip up someone who is aware that they need to be careful using `--` but aren't aware that `-= 1` doesn't have a sequence point either. while ( --x ) is a normal idiom; if you want to avoid using a decrement in a condition then a "good" version would be --x; for (; x != 0; --x) I can't understand the suggestion of introducing a comma operator in a "good" version. Many style guides recommend to never use the comma operator. 
Various other comments: (Good page in general BTW, I'm not dissing you, just being pedantic :) ) &gt;Provide include guards for all headers Identifiers starting with `E` are reserved for the compiler; so using the style `H_INCLUDED_ALPHABET` avoids a clash. &gt;Immutability saves lives `sum(xs, sizeof xs)` should probably be `sum(xs, NELEM(xs))` &gt;Trie You use `Trie` in examples in various places but don't show a definition for it. If you're passing a tree by value, that could be considered inefficient; and if it's a pointer typedef then I would consider pointer typedefs to be "Bad" as there are a few surprises in store for a user who doesn't realize that a type is actually a pointer type. &gt;Don't be afraid of short variable names A trick I found is to use names like `ii`, `vv` instead of `i` `v` ; this means that when you search for them in your editor, they all pop up highlighted, without a dozen false positives! &gt; Explicitly compare values, don't rely on truthiness Disagree, truthiness is a valid programming concept and if the intent of the code is to measure truthiness , and the code tells the reader that we are measuring truthiness, then we have written good code. &gt;Always use brackets These are normally called "braces" or "curly braces"; "brackets" means square brackets in C. &gt;Avoid unsigned types Disagree; I think the unsigned conversion rules are clear and the signed rules are murky! For example you can cause undefined behaviour by assigning an out-of-range value to a signed type, but there are no such pitfalls when using unsigned types. The version of `NELEM` with the cast is bugged, it will give the wrong size if the number of elements exceeds `LONG_MAX`. The code example using `-1` in a variable that is later used as an array index would be considered "Bad" by most ; the language definition defines that the array is indexed by an unsigned type anyway. &gt;Using parentheses Come on, there's no ambiguity in `&amp;x-&gt;y` . Using parenthese here is just obfuscatory. &gt;Don't use switch Disagree completely; switch is very usable and easy to read. The only reason I would consider it bad is if you have non-trivial flow control happening as a result of the cases, then you can end up with code that is hard to read. But it is good in most cases. I consider it easier to read than a long series of `if ... else if` , you can easily see where the switch begins and ends, and easily pick out the cases. &gt;If a macro is specific to a function, #define it in the body (minimize scope) `#define` isn't scoped; if you do this then you should also `#undef` it at the end of the piece of code that uses it. &gt; Prefer compound literals to superfluous variables Disagree, I find the "Bad" version easier to read in both cases. As a rule of thumb if you have to split a call to a 3-parameter function over 4 lines then you probably had a better option! &gt; -Wwrite-strings This makes the compiler diverge from the C standard, but earlier in the document you advise sticking to a standard. In the earlier example, perhaps it depends on how you are using the strings ; it's rare to send null bytes in I/O . If the `write` function will also be called in other places where the data is generated at runtime, it'd be an undue constraint for it to be required to have a null byte on the end. &gt;Always prefer array indexing `i` should be a `size_t` here , although you could micro-optimize it to `int` if you knew that nobody was ever going to send a large string to your program (famous last words...) &gt;use `assert` This depends on what your code is going to be doing. For throwaway code, sure. But in production code that has a user interface, you really do not want your program to abort and toss up a cryptic assertion failure message. In production code you should have proper error handling for every single case where you would want to use `assert`. &gt;avoid void* `void *` has its place, IMHO. For example, if you're wrapping `malloc`. But "avoid" is a fair enough term, I suppose. Liek you, I dislike using it for polymorphism. One place I use it is for functions that expect an array of char, but for whatever reason you're unable to consistently use `char` or `unsigned char` in the code that calls it. By using `void *` you avoid having to fill your code with casts. (This is well-defined by the C standard). &gt; Use structs to name functions' optional arguments That's pretty clever, hadn't thought of that! I do program in an environment where sometimes C90 compatibility is important though. But having said that, I use the C99 variadic macro sequence and C99 comments a lot; and as time goes on these enviroments are going to get more scarce. 
It's impossible to answer these kind of questions with a snippet. The problem is usually not where you think it is -- if it was, you wouldn't have to ask. Post a complete testcase, something that we can independently compile and run to exhibit the problem. Remove everything non-essential to demonstrating the problem. Failing that, learn to use a debugger. A segfault is not a mystery, and a debugger will tell you exactly what statement caused the fault, as well as the complete call stack leading up to the faulting call frame. However, the faulting statement isn't always the actual source of the bug. Innocent code will fault if passed bad data, for instance. You have to use the information that the debugger gives you to work out where the actual problem lies. But it's a lot better than staring at code and guessing.
This is because C++11 requires some features or additions of C99. Microsoft considers C dead and their focus is C++ which is fine but if you're writing / programming in pure C your best bet is still with MinGW or Clang.
Now that you've posted a testcase (thanks), your problem is apparent: NodeRef ptr = (NodeRef) malloc(sizeof(Node)); ptr-&gt;next = NULL; ptr-&gt;prev = NULL; ptr-&gt;item-&gt;info = g; You never initialize `prev-&gt;item`, so dereferencing it is undefined behavior and the cause of the segfault. You need to either store an item by value in the node (instead of storing a pointer to an item), or you need to allocate an item object and make `ptr-&gt;item` point to it before you can assign to `ptr-&gt;item-&gt;info`. Stylistically, there is a school of thought that says you shouldn't use typedefs to obfuscate pointers. It just makes it harder to read. If you want `Node *`, write `Node *`, don't invent `NodeRef`. This code also leaks all the memory that was allocated. 
...which is odd because the Windows kernel and many system libraries are still pure C, and Microsoft eats its own dogfood, using MSVC to build the operating system. You would have thought that some of the people that must maintain all that would have long ago mutinied for a dialect of C that wasn't quite so 1980s-tacular, but apparently not. 
Yes, C++11 added many of the C99 stdlib functions, but this is the opposite. They added language constructs that won't compile in C++. Apparently there was overwhelming industry demmand, so I hope MS is rethinking their stance on C.
Oh, ok. Thank you very much! I'll test this out right now. Ninja edit: It works perfectly fine! Thank you so very much! &gt;This code also leaks all the memory that was allocated. This is only part of the code. Later on, I created some functions to deallocate the memory.
I don't think they are. Decrement has a higher resolution operator order than subtract and assign. 
For reference next time please use a gist.github.com or a pastebin.
Why are there two implementations of anything? There's size, performance, correctness, completeness, and licensing. And besides all of that, there are social issues, people getting along or not getting along, politics, etc. I'm not familiar with musl. I'm aware of eglibc: &gt; EGLIBC's goals include reduced footprint, configurable components, better support for cross-compilation and cross-testing. Edit: I think eglibc's [FAQ](http://www.eglibc.org/faq) answers a lot of your questions, at least wrt eglibc.
A minor caveat: not all compilers produce intermediate assembly code; some produce object code directly.
Hmm.. not sure this is entirely accurate. Libc has been around longer than most of the computer revolution, and the systems for which it was created in the 1970s were considerably smaller than most embedded systems are now (or have been for 10 years or more). C was created as a portable language for Unix to be written in on the PDP-11, which had a maximum memory configuration below 4 MB in the early models and usually had perhaps 256kb. These were 16 bit machines for the most part with (what we'd now consider) slow clock speeds. For an approximate modern comparison to these machines, imagine something like an Arduino fio with its clock speed cut in half, with 256k of extra (slow) memory attached. C libraries have expanded a lot with time and language variants like C++, but for the most part the basic functionality was there on the PDP-11. Modern libraries have for the most part grown in size with cheap storage... there usually isn't a reason to not have every library you might need available. I believe the main reason libC has been written more than once is that it's used on so many platforms. Each time a new piece of hardware comes out it's a no brainer to optimize libc for it to get the best performance. In most cases a working libc is among the first steps for getting an OS to run somewhere new. As has been mentioned, libc has to be implemented somewhat differently on each platform. Windows NT has different rules than embedded systems like QNX and different again from Linux. In a specific environment there are still a few reasons to have different libc implementations: * Static vs. dynamic linking * Debug vs. release libraries * Better performance on one vs. the other for a specific work load * Different license terms for use or distribution * Different/compatible CPU architectures (x86 and AMD64 are present on many Linux systems because the OS can run either 32 or 64 bit programs) * Development tools like a cross-compile environment (doing embedded development on a host computer will require use of the host's libC for tools plus the target libc for linking the final binaries) 
None of that has anything to do with my statement that **g**libc was specifically not designed to be used by embedded systems, and it shows. If you ask anyone who does embedded development why they don't use glibc, it's for the reasons that I outlined: they expect statically linked executables to be reasonable in size, which is not the case when statically linking with glibc. It consciously makes an effort to not be modularized in a way that would reduce static link sizes. 
&gt; If you statically link against glibc you get a huge executable Even dynamically linking against glibc produces huge executables. Any executable dynamically linked against glibc is bigger than the equivalent binary statically linked against musl (assuming no other libraries).
That's not the nature of libc, it's the nature of modern operating system implementations of it, and especially the nature of the static and run time linkers for those operating systems. So, it wasn't designed for a modern embedded system... it was designed for a minicomputer with a smaller hardware footprint than most modern embedded systems. Same difference. 
1. There are no #s before your includes 2. You've commented the function declaration out - while it's not an error, it can lead to one. 3. In the if else chain in the letterGrade function there's an unnecessary if before return 'A'; You should spend some time to get to know visual studio a bit better. You should be able to locate the window with compiler warnings and errors. I'm also assuming you are using the default VS compiler for writing your assignment - you might want to consider using mingw instead, it might be a bit more C-friendly.
1. for some odd reason #'s never pasted over 2. I made a correction on that. 3. I took out the if before return 'A'. Im using visual studio express 2013 for desktop and it's a lot different than the x-code im using at school. I will try mingw to try to build it because the warnings arent popping up for me.
I'm using the program you recommended and it compiled perfectly. Thanks for your help.
Did you actually read the question being asked before answering? The poster is explicitly asking why glibc is virtually always used with desktop Linux systems but rarely used with embedded Linux systems, and why you might want to make such a choice to use an alternative libc. That is the question I was answering. At no point did I claim this was a universal property of all C libraries. I made no claims about C's heritage or minicomputers or any of this nonsense. 
Actually, that's only part of his question, and I addressed that. I also covered the rest of his question, including some reasons why there are different libc implementations. Some of my reasons, by the way, did agree with bits of what you said. I also did what I set out to do, which was provide a bit of debunking for your hand waving assertions about low level system calls and your unjustified conclusion that "There is no way that you can write any of this stuff in a generic manner." Sorry, but what you said is not correct. It happens sometimes. Move on. 
Ok, fine. Go ask your mom for a hug so you feel better. 
I have to echo the above.... getting to know the IDE is VERY much worth the time. That being said, its a complicated one with a lot of windows and is highly configurable. Still worth the time. The "View" menu contains most of the windows you might want to access. In there is an output window and an error list window. You can toggle warnings on and off in the Error list window while output shows the raw compiler output. Be warned that the latter can be kind of cryptic and often takes a bit of experience to go from the raw error messages to zoom in on actual problems. You get the hang though eventually. I don't suggest going to mingw. There is nothing wrong with the toolset, but trying to build via command line and using a raw text editor for coding might be a bit difficult at first. Properly used, VS can be really powerful and easier to use than a mingw chain.
Reddit uses hashes for text markup or something. I believe if you type two #s it works: ##include &amp;amp;amp;lt;stdio.h&gt; edit: 2 didn't work ###include &amp;amp;lt;stdio.h&gt; edit: ok it's probably a backslash (\\#) \#include &amp;lt;stdio.h&gt;
Getting jobs and internships are tough for pre-college students. However, I currently use a bastardized version of C to program for JD Edwards ERP and I know there are lots of jobs out there for consultants who pretty much do free lancing/ contract gigs with companies that are contracted by OTHER companies who run JDE. At any rate, I would polish off your resume as best you can, put together some working code samples and projects and then just fire your stuff off left and right at recruiters and especially on contract sites or even to craigslist wanted ads. 
I viewed this to check if the OP was really asking how to do ``(x &gt;= 0) &amp;&amp; (x &lt;= 9)``. I'm relieved the title is more than a little misleading :).
True, I also poked in expecting to find some sort of bitwise wizardry :p
For loops might work here. int frequency,number,i = 0; for(number = 0; number &lt; 10; ++number){ for(i = 0; i &lt; sizeof(array); ++i){ if array[i] == number{ frequency++; } } printf(" Number of times %i appears is %i\n", number, frequency); } where array is the array you're wanting to find the numbers in. I think that should work quite well.
Could you also do: if(num/10==0)... Because the int return value truncates the decimal?
ahh alright. makes perfect sense. thank you 
That would accept ``num`` on the interval [-9, -1] too. You could use ``num == num % 10``, though. I suspect there are a plethora of ways to do it non-obviously.
Asking reddit to help with your school?
Well which is it, an array or a hash table? Not sure I understand what your test is about exactly.
Well they're pretty much the same thing. You could use a library to create the hash table, whereas you would directly create the array.
I hope you don't think that would be more efficient. "I got rid of those pesky two comparisons by replacing one with a divide!"
&gt; One is a conditional statement and the other a loop; No shit. &gt; they serve entirely different purposes. No. A while is a repeating if. Different, yes, but entirely related. Think about the logic. If X never gets as big (or bigger) than twice N, you only have to do it once...that's why you can cut the loop. I take it you don't need basic db dev knowledge to make rpg games?
Yes. A table directly translates to a 2D array, though I guess you could implement a table using node links. That would work for some database designs, but it would defeat the purpose of hashing.
You could have just replied with "Think about the logic. If X never gets as big (or bigger) than twice N, you only have to do it once...that's why you can cut the loop." and it would have been very friendly and informative.
&gt; and so fourth O_o
Not to offend you, but these functions are pretty well documented. you could try starting with Google next time you have such a question
This comment is like RTFM lite :-)
A lot of that can be addressed by documentation, but things like this always come down to a balancing act.
You can also read off a draft of the C standard. The text of the standard is quite formal but you get used to it, and you know it's not omitting any details. 
Use `typedef` when: * It will improve how your code documents itself * Optionally to shorten references to things that otherwise need to be pseudo-namespaced, like `struct`s or `enum`s (as you mentioned you do). * You want to expose the name of an entity (almost always a `struct`) without exposing its internals. This is a good way to allow code to interact with an ADT without being able to or needing to know how to directly reference its implementation. If you're going to `typedef` a pointer, name it something that makes it clear that it's a pointer. There's no way to be certain what's under the hood when you just see the end result of a `typedef`, and that can make things confusing.
Personally I almost never use `typedef`. I've just grepped a couple of middling size projects written by myself, and I find the following typedefs: 1. A couple of typedefs for function callback types. Yes, that makes sense, function types are a pain to write out otherwise. 2. A typedef for `uint32_t` as either `__uint32_t` (if present) or else a struct. Yes, not much choice there. 3. A typedef of `hash_t` as `uint64_t`. Whatever, makes sense in context. 4. A mystery typedef `EPICS_STRING`; don't go there. On the other hand, throughout these sources (a total of around 20,000 lines) the symbol `struct` occurs 840 times. So, no, I don't use `typedef` unless I feel forced to.
IMHO, typedefs do more harm than good about 99% of the time. I tend to agree with the [kernel CodingStyle](https://www.kernel.org/doc/Documentation/CodingStyle) on the matter. Edit: in &gt;100k lines of code that I have written, 'typedef' appears in only 45 lines. About 30 of those are function pointer types, and the remaining ones are a basically a synonym for certain types that cause portability problems.
Yeah, I try to use `typedef` sparingly, but I do find if it is used well it leads to self commenting code. One good use is to set up pseudoclasses with structs. Make sure your names are consistent and follow some rules. I always append an '_s' to my `struct` names, '_td' to the definition (do not use the _t suffix, this is reserved for POSIX and C standard library types) and I also add a pointer with a _p suffix. I avoid using the typed pointer whenever possible, but sometimes it is useful. The pseudoclass with `typedef` will look like: typedef struct name_s name_td, *name_p; /* some 'member functions' */ name_p name_new(name_td *self); void name_set_id(name_td *self, int id); struct name_s { int id; name_p parent; }; It's very difficult to do this without `typedef` as you can't do the following: struct name_s { int id; struct name_s *parent; }; You can't put a struct of the type you are defining inside of itself without `typedef`ing it on an earlier line. Also, defining the type without defining the `struct` allows you to define the `struct` elsewere in the code. You can also load up a `struct` with function pointers for some [crude polymorphism ala Quake 2](http://fabiensanglard.net/quake2/quake2Polymorphism.php).
Alternately you could make the code self documenting by giving things names that make sense and not using arcane prefixes and suffixes. 
I agree that the prefixes and suffixes are more or less useless. Sometimes it is good not to stray too far from the other devs on your team though, right? I everyone has agreed that _t's are the way to go and you're not doing it then it will probably lead to confusion for someone Edit: Perhaps I missed the point ala do NOT use prefixes and suffixes
I should have qualified this is only for building opaque types.
tried not to insult anyone :P I remember when I couldn't understand entirely what the manpages were going on about!
&gt; A couple of typedefs for function callback types. Yes, that makes sense, function types are a pain to write out otherwise. +1 
He also brought up a potentially interesting topic. Don't forget the side-effects! Humans are not pure. 
They should really clean up C syntax for function pointers. After std::function was added to STL, i've forgotten the syntax entirely!
I like to typedef number types to whatever makes sense in the context (i have a weird phobia that compiler will make sizeof(int) very small, so i typedef number to int32_t). I always think of typedefs as a kind of poor mans interface, not a typing shortcut. Since it is a quite bad interface system, make sure that its' actually usable with other types. Someone here posted hash_t typedefd to int64_t - presumably the hash computing algorithms wouldn't handle any other type of int, so I personally wouldn't typedef that. As a shortcut i've used it for function pointers which are so ugly and hard to get right - both when reading and writing. In rare cases I will typedef something i'm importing and that naturally has a much better typename in the context - i find that it helps to think clearly about problems. An example could be a type called ArrayBackedNoMultiedgeGraph which I'd typedef to Graph, or even Tree. The first case may be obvious, and comes up a lot when working with libraries. The latter case is a little more subtle. A tree is a graph but not the other way around, so I am using ArrayBacked... as a tree interface, although I am not guaranteed a tree. I find it helps when reading methods and coming up with algorithms. 
Exactly. And of the few typedefs that I have, I'd consider about 50% to be a flawed design, and I just haven't gone through to change them yet.
&gt; You can't put a struct of the type you are defining inside of itself without typedefing it on an earlier line. This is not true. This is valid and pretty common C: struct node { int data; struct node *next; }; Which compiler are you using?
The `^`&amp;nbsp;operator in&amp;nbsp;C is [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR). It has absolutely nothing to do with exponents.
okay thats what I thought. thank you for your quick response :) 
If you don't mind me asking, when doing that you would get x= 00011001 ??
One of your bits is wrong. Maybe it's just a copying error. Writing numbers in binary, the result of `00010110 ^ 00001011` is 00011101. But of course 00011101 won't be what's printed, because `printf("%d", x);` doesn't print the value of&amp;nbsp;`x` in binary.
yes, I did it again and my eyes just bunched them up. Thank you for all of your help :) 
&gt; after all, C is little more than a high-level assembly language. I don't know why people keep saying this - especially people who have written assembly code. You don't track register allocations in C. You don't manage memory location, size, availability. You don't manage your labels and branch targets. C is much closer to C++ or Java than it is to any assembly language I've programmed in. Otherwise the article is meh. Some good points but too many words to say the obvious. 
From [Wikipedia](http://en.wikipedia.org/wiki/C_programming_language#Design) - unsourced, but sounds about right: &gt; C is an imperative (procedural) language. It was designed to be compiled using a relatively straightforward compiler, to provide low-level access to memory, to provide language constructs that map efficiently to machine instructions, and to require minimal run-time support. C was therefore useful for many applications that had formerly been coded in assembly language, such as in system programming. Even after all these years people misunderstand this to mean that C is "like assembly". There's a more or less straightforward mapping between the two, but so many of the painful details are still abstracted away. EDIT: K&amp;R also mentions something like this in the introduction, fwiw. It's at least understandable where the idea comes from.
Though I agree with many of his points, I think the quality of most programs written in C has far more to do with the fact that most of them are 40+ years old, and many have been re-written at least once. That's a lot of time and effort that's been poured into debugging what are, at the end of the day, relatively small and not too complex programs. It's true that the community that grew up around UNIX has a (correct, IMO) massive hard-on for minimalism and re-use, so that certainly helps. But decades of debugging and a good culture are separate issues from the language itself. C has many virtues, and I'm glad to see someone championing it in an era of "embed JavaScript in ALL the things!" But let's not over-sell C. As Greenspun said: "A bad programer can program poorly in any language." Stop engaging in magic-wand mentality, people. [THERE IS NO SILVER BULLET!](http://en.wikipedia.org/wiki/No_Silver_Bullet) There is no single, simple, universal thing that you can just do by rote and then your code will be perfect. Life ain't that simple. Good code is hard because every situation is different, and if a problem had been solved well already, there'd be a library you could just take off the shelf and use with no thought. If you're getting paid to write code, you're getting paid to solve problems that are at least somewhat novel. (Or at least being paid to shave a yak, which by definition means there's no other way around.) tl;dr - C is good language, but don't claim that C programs are good just because they are written in a good language. Correlation is not causality, and there are other factors at work (we even know what some of them are). Also, plenty of the problems that we are asked to solve as programmers are inherently hard and would not be easy regardless of the language. There are no silver bullets, and quit believing there are.
I'm upvoting this for the discussion it is generating in our comments, not because it is a good essay (it isn't).
A couple of references I should have hyperlinked in originally, but I was on my way out the door... http://catb.org/jargon/html/Y/yak-shaving.html &gt; As Greenspun said: "A bad programer can program poorly in any language." Does anyone have a source for this? I googled a bunch but I can't find it. I seem to remember it was in some kind of news story that quoted Greenspun?
The main paradigms of C fit nicely with the Unix mentality - write small programs that do one thing, and do it well. C programs only become unmaintainable once they're big, so I think this lends well to their reliability if you keep them small.
the project is a menu of 25 different recursion functions...i just need the help with thie one. you dont have to act like a jerk!
You're the cheater asking for work to be done for you. We know who's the jerk here.
Well, what have you written so far? Can you at least explain in prose or pseudo-code a possible algorithm for reversing a string recursively? How are you going to handle memory management: are you going to reverse the string in-place, are you going to allocate and return a new buffer, or do you require that the caller passes an already-allocated destination buffer? And what's this nonsense about not using pointers? How are you supposed to pass a string to a function without using a pointer? (Note: If you thought a function declared like `void foo(char s[]);` was not taking a pointer as an argument, you were wrong.) Nobody is going to do your homework for you, but if you ask actual questions we will answer them. "How can I do this?" is not an actual question. 
im sorry...i should have been more specific...this is how for i got... void reverseStr(char str[]){ int length,lentemp; char temp[1000]={'\0'}; length=strlen(str)-1; lentemp=strlen(temp); if(length&lt;0) return ; temp[lentemp]=str[length]; str[length]='\0'; temp[lentemp+1]='\0'; reverseStr(str); } and the function has to return a string... any help would be appreciated...thanks!
Read the "formatting help" link for how to post code without it being mangled. This code has many issues. Each time you call a function, you get a completely new copy of all the local variables, like `temp`. Any information that you want to convey to the next iteration of the function has to be done by either return values or modifying variables that are shared between invocations. Because you get a new `temp` array every time the function is called, that means `lentemp` will only ever be zero. The only thing you ever really accomplish here is overwrite every character in `str` with a null character. Nothing you do to `temp` has any effect. It looks like you're trying to reverse the string in-place. If that's your goal, you don't need any char arrays like `temp`. You can just swap characters in `str`. Try to think of what a recursive algorithm for swapping pairs of characters would look like. If you were trying to build up the reversed string somewhere other than `str`, that's not going to work because the lifetime of a local variable ends when the function returns, so anything in `temp` when the function returns is unusable. Like I said, if you want to do that you will either need to allocate memory from the heap or have the user pass in a destination buffer. (And also, as I suspected, this is not really being doing "without pointers", because `str` is a pointer to char. The fact that it's declared as `char str[]` is a convenience that the language allows, but it's interpreted exactly as if you'd written `char *str`. It's *not* an array of char.) 
thanks man...think i got the big idea...going to work on it!
Your functions have the fileptr in the arguments, but when you call them, you dont pass any pointer to the file. Also, when you create the book file, you close the pointer in the end. Should leave it open for other functions to use and close it when the prog quits or a new book is created.
Look at how you're declared the addRecord function void addRecord(); and look at how you defined it : void addRecord( FILE *fPtr ) now look at how you call it : case 3: addRecord(); addRecord() is never given the file pointer. Your code is written extremely inconsistently as well, what is the need for unsigned int enterChoice( void ); when all you need is unsigned int enterChoice(); printf( "%s", "Welcome") is also bad practice printf("Welcome") is enough 
You can create struts with a [variable length array as the last element] (http://www.drdobbs.com/questions-answers-creating-variable-siz/184403480) Its a bit dodgy, and might not work in all compilers.
Do you know the last element of the bitfield upfront? If yes, memset with that value immediately after malloc.
Afaik C99 supports "flexible-array" members: struct foo { int size; char buf[]; };
[Yup](http://c-faq.com/struct/structhack.html)
 k-&gt;sender=(char*)malloc(sizeof(strlen(string)+1)); How many bytes of memory are you allocating there? Well, it's `sizeof(strlen(string)+1)`. Think about what that means. That means the output of `strlen(string)` (which is of type `size_t`), plus&amp;nbsp;1, and then you are taking the size of that number. Why are you taking the size of that number? The size of that number will be however many bytes a `size_t` requires. The number of bytes you want to allocate isn't the *size* of the length of the string—it's the length of the string itself.
It is asking you, given a file containing the string `"foo\tbar baz\tquux"`, where `\t` is the tab character, to produce the following output, assuming `n`&amp;nbsp;=&amp;nbsp;5: foo bar baz quux
Also Thank you very much for taking the time to assist! Out of curiosity why didn't that mess up the first reading of `k-&gt;sender`? If there isn't enough memory allocated for it then I'd guess that it would keep printing until it hit a `NULL` wouldn't it?
Well, here's another problem: k=(KEYS)malloc(sizeof(KEYS)); How much memory are you allocating there? Is that the amount of memory you want to be allocating?
Also, why are you doing this? fn=(char*)malloc(256); strcpy(fn,"keyfile.dat"); FILE* fp; fp=fopen(fn,"r"); You are unnecessarily allocating memory and doing a string copy, and your program has a memory leak because you never free this memory that you've allocated. Better and simpler: FILE* fp; fp=fopen("keyfile.dat","r"); You don't have calls to `free` anywhere in your code, in fact. This is bad programming practice. You are allocating memory but never freeing it. You should always free all of the memory you have allocated.
It's doable on windows, look here: http://msdn.microsoft.com/en-us/library/ff802693.aspx#serial_topic3 You need CreateFile(), ReadFile() and WriteFile(). I don't suggest doing overlapped IO. I know the post is pretty old but since the only replies are for linux I wanted to add this anyway.
To avoid this kind of error, I always write my `malloc` statements like this: k = malloc(sizeof(*k)); That way I know I am allocating the amount of memory that `*k` will require, however much that is. I don't have to worry about mistyping the type of&amp;nbsp;`*k`.
I'm only really responsible for the reading in of data part - I just threw together the rest to test it and sort of did it haphazardly. I can't really free memory here because I have to build my code with many other objects that were pre-compiled but not linked; though I should have in the main and actually did on my home test - just not the one in pastebin. Needless to say the program I have at home is significantly larger. I just wanted to eliminate everything else that wasn't needed... I doubt anyone would want to read through more lines of code than necessary to find a single error made by someone else. I probably should have been more clear about that, sorry. This is a bit of an odd case... I have 3 versions of the same code - the code I'm trying to get to work for the assignment; the 'test code' I'm using to test things out with - a stripped down version of the program the assignment has to work within; the pastebin all in one code (the others are modular making it easier to fix/break things).
I was thinking that if I tried to fit "HELLO" into only 5 bytes it would be: `[H][E][L][L][O]` instead of `[H][E][L][L][O][\0]` the first of which I thought would keep reading the string until it hit a `[\0]` so it would, I may be not understanding this, `HELLO...........` with the ... being randomness or whatever is in memory immediately after the O until it reached that `NULL`. That's what I was expecting to see for the first read too, not just the second.
wow... that's awesome. I wish our professor had shown us to do that instead but it completely makes sense.
No, the C&amp;nbsp;language does not make any guarantees about what will happen. You have undefined behavior, which means *anything* can happen. Anything at all. Don't try to figure out what would happen, because that's a pointless question—*anything* can happen if your program has undefined behavior. It is possible that the program could write the characters `'H'`,&amp;nbsp;`'E'`, `'L'`, `'L'`, and&amp;nbsp;`'O'` into the five allocated bytes, and then not write the null terminator because not enough memory has been allocated. That is possible. It is also possible that the program could write the characters `'H'`,&amp;nbsp;`'E'`, `'L'`, `'L'`, and&amp;nbsp;`'O'` into the five allocated bytes, and then write the null terminator into the next byte of memory, which might be a part of some other variable in your program, or maybe not. It is also possible that the program could crash, or run exactly as you intended, or write the characters `'H'`,&amp;nbsp;`'E'`, `'L'`, `'L'`, and&amp;nbsp;`'O'` into the five allocated bytes and then overwrite the `'H'` with a null terminator, or whatever. It is even possible that something might go wrong earlier in your program, before it even gets to the point where it is attempting to write `"HELLO"` into a too-small block of allocated memory. Anything at all is possible. That's what "undefined behavior" means.
Just read the file, if you encounter a tab character, print the desired number of spaces. for any other character, simply print that character. it should be very similar to the example program that counts spaces. just instead of looking for '\n' you look for '\t' and instead of incrementing an integer, you output some spaces. #include &lt;stdio.h&gt; int main() { unsigned ts = 4; /* tab size */ int c; while ((c = getchar()) != EOF) if (c == '\t') printf("%*s", ts, ""); else putchar(c); } 
Thank you for clarifying that. That makes much more sense.
Thanks, although I found an easy enough solution for the class project I'm working on, it isn't the true solution I want for my own personal project I want to do. I will definitely look into all of these options more when I have time to make progress on my personal project.
Sending you a PM.
Feel free to post questions on here. If you haven't been able to find the answers to your questions, perhaps you can help others as well. Consider editing this or making another post and editing with Q&amp;A as you receive your answers.
helpouts.google.com
C89 needs you to do struct thing { size_t size; unsigned char bits[1]; }; and adjust the size field and allocated size accordingly. [GNU C](http://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html) added a somewhat widely supported extension that lets you do struct thing { size_t size; unsigned char bits[0]; }; with no size adjustment necessary. However, both are obsolete with C99, as it lets you do struct thing { size_t size; unsigned char bits[]; }; and mean the same thing. Probably your best bet to stick with method 1 if you want to be as portable as possible (i.e. Windows and really old UNIXes), but you're probably fine to pick any of the three. Better to prefer one of the standard methods though, since you never know how long the code will end up being around...
Oh -- sorry. You're right. I should have read the description.
Funny thing about your comment and code is that is just about exactly what I came up with and then I started thinking that I wasn't understanding the exercise correctly. I really wasn't wanting code here, just help understanding the question(I should have included that in the post description). Thanks anyways though :)
I found the book [Cracking the Coding Interview](http://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/098478280X) to have good (but brief) coverage of most of the topics you're referencing. It's also got inside looks at the interview process at major tech companies like Amazon and Google. I wouldn't limit your search to these large companies though. You may need to start out somewhere smaller where you can gain some more practical experience with software development before moving on to a Google or Amazon job.
Linux kernel is so small, it fits into one screen :-)
Send me a PM if u/jahmez doesn't work out, or otherwise too. but like u/sdrawkcabsmurd said, just use this thread and ask away
test comment
All the functions are documented online at the documentation link provided generated from the code itself (using doxygen). It's just not in the README or on the main page of the documentation. You have to click through to the file/type you want to learn about. Also I think all code, especially C code is public. You shouldn't be using something/modifying members/variables you don't understand in any case and if you are it's an implicit acknowledgement that you know what you're doing, ie, you waive the right to any invariant/guarantee of the interface unless you follow it yourself. A simple example is my [clear](http://www.robertwinkler.com/Projects/cvector/vector__i_8h.html#aabafb56cc5807fbcd220d35bb5b88d41) functions. Why do I even have that function? All it does is set size to 0. For any plain old data type (int, double and anything generated with template 1) there's absolutely no reason to have that function and a programmer would be perfectly justified in just setting size to 0 manually. I constantly think about getting rid of it but I don't, to be consistent with the STL and with vector_str and vector_void where removing elements involves freeing them. With any interface, my view that everything can be/is public doesn't mean you have to know/understand or mess with the internals but that you can if you have a reason to. Standard library interfaces are a special case because they're abstracting platform specific code so unless you're willing to sacrifice portability you probably wouldn't want to mess with the internals (or you could just use platform specific IO calls like read and write in the first place). 
Indent each line of your code by 4 spaces to preserve whitespaces and linebreaks. This is unreadable.
You are correct that `sizeof(buf)` will return the number of bytes required to store an object of type `char *`. I don't know the context of this code, so I don't know whether that makes sense here.
That's almost definitely wrong, although I would like to see the rest of the code. I presume it will seem to work, since sizeof(char *) == 4 [0], and that is enough for a 3 digit number and a null terminator. 0: I'm assuming that since the Note 3 has an ARM processor with the ARM v7 instruction set which is for CPU's with an address space of 32 bits.
Here's another function doing this: static ssize_t show_waketime(struct device *dev, struct device_attribute *attr, char *buf) { if (!bamDmux_pkt_dev) return 0; return snprintf(buf, sizeof(buf), "%u\n", wakelock_timeout); } I haven't done any kernel development before, but this stuff looks weird. Looked through the code some more - this one seems to have something to do with sysfs. In the sysfs docs I find this: 168 To read or write attributes, show() or store() methods must be 169 specified when declaring the attribute. The method types should be as 170 simple as those defined for device attributes: 171 172 ssize_t (*show)(struct device *dev, struct device_attribute *attr, char *buf); 173 ssize_t (*store)(struct device *dev, struct device_attribute *attr, 174 const char *buf, size_t count); 175 176 IOW, they should take only an object, an attribute, and a buffer as parameters. 177 178 179 sysfs allocates a buffer of size (PAGE_SIZE) and passes it to the 180 method. Sysfs will call the method exactly once for each read or 181 write. This forces the following behavior on the method 182 implementations: ... So basically the buffer that is allocated is actually PAGE_SIZE bytes, not sizeof(char*). I'm not sure what the other functions that do this are used for.
Also, why is buf being explicitly casted (char \*)buf, when it's passed to the function as a char\* already?
It certainly is wrong ... but it's also rather pointless. For a start, the routine has no idea how large `*buf` is, so using `snprintf` is futile; secondly, you know exactly how long your `"%d\n"` will come out (well, anyway, 22 bytes is a fair upper bound, and twice that safe for all foreseeable possibilities); and thirdly, this looks like a sysfs node formatting routine, and I think they're passed a fixed length buffer of sensible size either 1K or 4K long -- this is worth checking. On a final note, calling the return value `rc` and returning a `ssize_t` (via an `int` no less!) is quite bogus -- check the man page for `snprintf`. In particular, it *cannot* fail and will never return a negative value. I supposed I should be relieved that this isn't actually in the Linux kernel, but that makes my point about the buffer size moot. However, yes, the code is wrong. If `msd.dstat.bright_level` is greater than 99 then the `'\n'` will be lost, and if larger than 999 the result will be quietly truncated. Go and smack the developer, if you can.
Well, as the text says, for showing and storing attributes. When you `cat` a certain file in `/sys/`, a `show` function is called and the data in `buf` will be printed. The same goes for writing in the file and calling `store`. That way, you can change kernel variables, like the intensity of the backlight, by manipulating simple text files.
sprintf can fail if you pass it a nonsense format string, e.g this returns -1 in glibc rc = sprintf(buf,"%#", 1) Ofcourse this should rarely, if ever, be an issue as guarding yourself against spelling errors in a format string is a bit extreme. Returning an int via a ssize_t isn't an issue though, they're both signed integers, and the caller likely expects the function to return -1 on failure or the number of bytes written. There's a bug though, snprintf (at least the user space variant) will return the number of bytes that *would have* been written if there was enough space. I.e. you risk telling the caller that you wrote 10 bytes, but in in reality you wrote just 4 due to the `sizeof(buf)` On another note, `pr_info("backlight : %d\n", *buf);` does look odd. Format and log the ascii code of the first digit written to buf ? What use is that ?
Ah, yes, I'd misread snprintf(1) on the number actually returned, and had forgotten about the possibility of a nonsense format string ... which fortunately the compiler will catch most of the time. Ah well, we can at least rejoice that this particular code isn't in the kernel (at least, lxr.linux.no hasn't heard of it), but alas there's much like it in there already.
&gt; I constantly think about getting rid of it but I don't, to be consistent with the STL and with vector_str and vector_void where removing elements involves freeing them. Personally I prefer to have them, I'd rather not poke at the internals unless I have to. I'd just move it the function back into the header and mark it `static inline` (&gt;= c99)
I want to keep it compatible with C89
Well it's pretty straight forward/simple and I point people to the tests for usage examples: &gt;To actually use the library just copy the appropriate c/h file pair(s) to your project or just use cvector.h. To get a good idea of how to use the library and see it in action and how it should behave, look at vector_tests.c EDIT: as for why it's better, I guess the biggest thing is the templates which certainly make it unique and I do mention them in the README (and docs) but in general: &gt;Why should I use this? &gt;Why is it better? &gt;Prove that it's better. I'm a programmer not a salesman/marketer. It'd be different if it were more complicated/larger/unique and especially if it's commercial but this is just a small tool/library and while someone can make a really bad vector library, I don't think there's a huge variation in API or performance among the decent ones so it's just personal preference.
&gt;If malloc fails, vec == NULL thus !vec is true, thus we satisfy the if condition. Why is assert(vec != NULL) in there? Thats always going to be false. You seem to have this assert condition everywhere (at least in vector_i.c) Does no one look at the documentation link? (or know how assert works?)? http://www.robertwinkler.com/Projects/cvector/ &gt;Memory allocations are checked and asserted. If not in debug mode (ie NDEBUG is defined) 0 is returned on allocation failure. In other words, if you're compiling the Release configuration, the assertions disappear. See the premake where I define NDEBUG for release configs. They're only in there for debugging. I can't use bools because I meant C89/90 and I want to be strict. I've never seen the benefit to bools over int's anyway. What's wrong with 0 and 1 (or non-zero?). &gt;-ansi In C mode, this is equivalent to -std=c90. In C++ mode, it is equivalent to -std=c++98. As for the duplication of code, I know about realloc but that is a bit more typing and does have at least a fractional amount more overhead than malloc. In addition using one constructor inside others adds overhead and indirection to only save 4 lines of code. I usually need a lot more common code used many times before I think about using a function. By indirection I mean when reading the code. I know this code base is small and the files are small but still making someone look up another function just to read a 5 line function or just to save 4 lines in 3 places seems like a bad trade. I like to keep as much locality as possible to enable linear reading with minimal jumping around. Again in this case since it's small and the functions are actually right next to each other this argument isn't as strong but it's my style and it makes more sense for larger projects.
I generally do too, especially for applications in general but libraries especially one like this where I want to be able to use it literally anywhere I'm a little more conservative. Even my other libraries that are (mostly unpublished) I want to write clean-C, ie C99 but compatible with C++ which means no designated initializers, no compound literals, and casting allocs. CVector isn't clean C for obvious reasons (C++ can just use std::vector) but I do have a larger project (a library) where I will have to make it compatible because I want the entire library to be C/C++ compatible and while CVector is superfluous in C++, this project won't be.
&gt; I want to write clean-C, ie C99 but compatible with C++ which means no designated initializers, no compound literals, and casting allocs. Sure it can. Use `extern "C"` in all your c headers, compile all C code with a c compiler into object files and then the c++ code with a c++ compiler and link it all together.
I didn't mean the asserts were for debugging CVector, but more for whatever application you're using it in. Maybe that's bad practice but again the fact that they don't show up in release is good enough for me. And what's wrong with it running in low memory environment? If they are, they're almost definitely not running it in debug mode since that takes more memory so the asserts wouldn't be there. I'm a little unclear on what you're arguing. Does returning 0 count as failing? I'd say returning 0 is reporting the memory error same as malloc. And that's what it will always do in release mode. It's more than 9 times and you're introducing a lot of overhead. You wouldn't be able to just use the constructor like your example so you'd have a vector resizing function that's probably more complicated/larger than every other function in the library (due to generality) and is used all over the place. You may save a little code, but again it's only a few lines from any given function and in terms of what actually get's executed it's far more code/overhead. As for having to fix a problem in multiple places, it's not like problems spontaneously appear. Once you fix one it's gone. And between the small size and simplicity of the code and the tests and the fact that I use it in all my other projects (I've always considered real life use better testing than formal tests ...) bugs are highly improbable. Not impossible but unlikely. Believe me I've fixed my share of bugs but it's easy to fix a bug in a few places (and I've only had a few bugs like that even in this project) and it's a small price to pay for better readability and simplicity. I just think your way is overkill/design especially for something so small. I actually have only 4 vectors. int, double, str, void are the core types with their own headers and they're included in vector_all and the all-in-one cvector.h. The other 2 vector_short and vector_f_struct are generated from the templates for demo and testing purposes. That's only 6 so what's the 7th you counted? 
I like being able to compile everything from code, statically. Dealing with libraries is a pain. I really like the style of the [stb_ libraries](http://nothings.org/) where everything is a simple, all in one, drop in header. That's what cvector.h is and I plan to do that with all my libraries at least as an option.
As I said in my previous comment, if they're running in a low memory environment, they would *not* be running in debug mode (heck they could even run in debug mode, -g but still define NDEBUG if they really wanted) so what you're suggesting is exactly what my library would do, ie return 0, passing on the notification. It's not 1 function call it's a bunch all throughout the library but more importantly, as I said, the function would have to be general for the 3 or so situations/types of resizings and thus would have extra logic. It wouldn't be a 1 to 1 where the only added overhead is the call but you're actually adding the call plus extra unnecessary work. About the overcommit thing, I think that's a common misconception: &gt; By default, Linux follows an optimistic memory allocation strategy. This means that when malloc() returns non-NULL there is no guarantee that the memory really is available. In other words, if it returns NULL, there is a failure but not the converse. So really what would you change? I don't think there's a way to check whether there's really sufficient memory if it returns non-NULL and even if there was this is platform specific behavior so I wouldn't want it in my library.
&gt; It's not 1 function call it's a bunch all throughout the library but more importantly, as I said, the function would have to be general for the 3 or so situations/types of resizings and thus would have extra logic. It wouldn't be a 1 to 1 where the only added overhead is the call but you're actually adding the call plus extra unnecessary work. Look, I want to emphasis I am speaking from experience here. You can absolutely do this with no overhead. Its been done. &gt; In other words, if it returns NULL, there is a failure but not the converse Its actually up to the user. Overcommitting memory is actually configurable. (see `/proc/sys/vm/overcommit_memory`). You're just describing the default behaviour. &gt; I don't think there's a way to check whether there's really sufficient memory if it returns non-NULL and even if there was this is platform specific behavior so I wouldn't want it in my library. I agree. And imho its yet another reason not to do the `assert` logic in the first place.
I know what object files are but couldn't you do the same thing with compiled libraries? Like how SFML, a C++ library can be linked into a C project but not compiled into it? Couldn't you do the reverse? That's what I thought you meant. As for your method, that's still an extra step and having to use both C and C++ compilers in the same project would be interesting. I'm not sure how I'd even do that with premake where I specify one or the other for a given project. https://github.com/rswinkle/CVector/blob/master/premake4.lua And who knows what hoops you'd have to jump through for other IDE's/ build methods. Part of the reason I love everything to be usable from code and the everything in a header style library especially is that it's the easiest thing to use everywhere. I don't use an IDE but every time I have used one, the only thing that was completely simple was adding code. Adding libraries/linking is different with every one and having to dig around in the build settings to get it working sucks. Using libraries with gcc/clang on the command line is a breeze by comparison but I want my stuff to be easy to use everywhere.
&gt; I know what object files are but couldn't you do the same thing with compiled libraries? Like how SFML, a C++ library can be linked into a C project but not compiled into it? Couldn't you do the reverse? That's what I thought you meant. You can't compile it in as is because of name mangling. You can wrap it with `extern "C"`, but then you lose a lot of c++ features. &gt; I'm not sure how I'd even do that with premake where I specify one or the other for a given project. No idea, but its possible with other tools like autoconf (and with raw Makefile).
The C standard says (section 7.19.6.5 paragraph 2): &gt; The `snprintf` function returns the number of characters that would have been written had n been sufficiently large, not counting the terminating null character, **or a negative value if an encoding error occurred**. Thus, the null-terminated output has been completely written if and only if the returned value is nonnegative and less than n. It can fail, just in rare circumstances.
Invalid format strings are undefined behaviour, so in this instance you can't rely on `*printf` functions returning `-1`. Section 7.19.6.1 paragraph 9: &gt; If a conversion specification is invalid, the behavior is undefined.&lt;sup&gt;248)&lt;/sup&gt; If any argument is not the correct type for the corresponding conversion specification, the behavior is undefined. The 248 footnote details future language directions that lowercase letters may be added to the conversion specifiers and that other characters can be used as extensions. So `%#` may in fact be a legitimate conversion specifier on some [imaginary] implementation.
Because whoever wrote this code isn't very good at C. 
In production code this would not be good enough, there should be an explicit buffer size check. 
&gt; it fails miserably This is not a useful description. What does it do exactly? &gt; I was hoping someone could point out what I'm doing wrong It sounds to me like you have the right idea. I have no idea what you are doing wrong, because I have no idea what your code looks like, and I have no idea what the problem even is ("it fails miserably," apparently, whatever that means).
It won't see any tabs meaning it won't print anything because I never print anything else However if I add an else else { printf("%s",c); } it still doesn't print anything.
http://pastebin.com/WyMZSm57 I just copied what I'm using on my computer and it compiles for me.
It's because I was saying `if(c = '\t')` instead of `if(c=='\t')` right? Because that seems to have fixed the problem. Thanks!
True enough, thanks. I believe that it prints 0, 1, 2, ... --&gt; 10, right? And yep, I think that I will actually code some actual projects, I was just hoping for a shortcut. 
You're correct in that this is awful C code, but I just wanted to counter the specific points you make, because they're wrong: &gt; "dev" and "attr" passed into a function which makes no use of them This is some kind of show function, i.e. the programmer does not control the function prototype. It's set by the kernel API. &gt; overwriting an input is generally not good practice I'm assuming by "input" you mean "buf", but that's an *output* buffer. An input buffer is/should be declared pointer to const char, or you're not const:ing enough. &gt; "buf" is being supplied for this function to use, instead of this function encapsulating that buffer It's the output buffer. You're probably supposed to return the string in it, and the number of characters in the string as the return value. &gt; "msd" is something in global space within the compilation unit Yes, since this is a show function and they normally return stuff global to the kernel module, or at least the compilation unit. What value would *not* be global to the compilation unit that would make sense for the function to show?
It's not at all obvious from OP's context that this is a kernel callback. I assumed it was part of the kernel itself. &gt; I'm assuming by "input" you mean "buf", but that's an output buffer. An input buffer is/should be declared pointer to const char, or you're not const:ing enough. In which case the API itself is broken, because the programmer isn't supplied with a length for the input buffer, and presumably has to rely on someone writing correct documentation for the exact code which calls this function to know what length that buffer is. &gt; I'm assuming by "input" you mean "buf", but that's an output buffer. An input buffer is/should be declared pointer to const char, or you're not const:ing enough. Fair enough. I would expect a parameter block API which encapsulates this into a structure. &gt; Yes, since this is a show function and they normally return stuff global to the kernel module, or at least the compilation unit. What value would not be global to the compilation unit that would make sense for the function to show? Also a broken API. If you're expected to supply a function for this, "msd" can be passed in, not used as a global. Even if "msd" is a user-supplied type, it can be set in a parameter block via an earlier call as a "void *" and passed in. One needn't rely on globals for this. Many APIs that use these sorts of callbacks do it this way, or supply signatures that include a "void *user_data" as one of the parameters. 
You don't "call a struct." That doesn't make sense. What do you mean? What are you trying to do?
Trying to use the data types in the struct in main. I don't know how to word it properly. Say I have: typedef struct ctryTvwatch_struct { char name[MaxCtryNameLength]; int mins; } ctryTvwatch; How do I go about using it in main?
Well, you have declared a struct called `ctryTvwatch_struct`, and you have `typedef`'d the symbol `ctryTvwatch` to be a synonym for the type `struct ctryTvwatch_struct`. So, if you want to declare a variable of this type, you can declare it like this: struct ctryTvwatch_struct x; or like this: ctryTvwatch x;
Where did you define the structure? You have to have either put it in the source file above main or (potentially better) in a header file which you include in the sourcefile with your main function. After that, to use the structure you declare a variable like so: struct ctryTvwatch_struct struct_instance; In your case since you did your structure declaration in a typedef, you can omit that first 'struct' keyword. After the declaration you can use the '.' operator to access members of the structure. Sometimes because it's expensive to pass around structures, we declare pointers to them as well and allocate the memory ourselves with malloc. If you have a pointer to a structure you must use '-&gt;' instead of '.' 
 int main() { ctryTvwatch_struct tv; snprintf( tv.name, MaxCtryNameLength, "Hello, world!" ); printf( "%s", tv.name ); return 0; } On that note, I'd seriously consider renaming your variables, they're confusing as fuck.
&gt; ctryTvwatch_struct tv; This won't work in C. You need to say either struct ctryTvwatch_struct tv; or ctryTvwatch tv;
Yeah, as soon as I hit submit I realized that
You're right, thanks. Do you know if people typically do the typedef for structures? I've always just used the full name with the struct keyword so I didn't get confused.
Yes, people do often use `typedef` to remove the need to write `struct` all over the place. (I mean, you can find that even in the C standard library with things like `FILE *`.) Whether or not that's a good idea is a subject of some debate.
PAGE_SIZE bytes are allocated for buf, it's documented in the sysfs docs, dunno for the rest.
&gt;&gt; I'm assuming by "input" you mean "buf", but that's an output buffer. An input buffer is/should be declared pointer to const char, or you're not const:ing enough. &gt; In which case the API itself is broken, because the programmer isn't supplied with a length for the input buffer, and presumably has to rely on someone writing correct documentation for the exact code which calls this function to know what length that buffer is. Yes and no. For sysfs show functions, for example, the length is always PAGE_SIZE and that's documented in the sysfs docs. While it's more inflexible and unintuitive, it also means you don't have to write generalized code. As you know the size of the buffer beforehand (and it's quite large), your code is nicer and more compact. &gt;&gt; Yes, since this is a show function and they normally return stuff global to the kernel module, or at least the compilation unit. What value would not be global to the compilation unit that would make sense for the function to show? &gt; Also a broken API. If you're expected to supply a function for this, "msd" can be passed in, not used as a global. Even if "msd" is a user-supplied type, it can be set in a parameter block via an earlier call as a "void *" and passed in. One needn't rely on globals for this. Many APIs that use these sorts of callbacks do it this way, or supply signatures that include a "void *user_data" as one of the parameters. Yes and no. When you're in user context, the output buffer will have a user type (and probably called something like "user_data"), but that doesn't seem to be the case here. Having compilation unit global variables makes for a neater API as you don't have to have callback types for every type the function may return. A kernel module can only be loaded once anyway, so having state global to the compilation unit doesn't matter much. This is pretty much the standard way of doing it.
&gt; I certify that writes through this pointer will not effect the values read through any other pointer available in the same context which is also declared as restricted. I can't decide if this is an attempt at [XKCD 326](http://xkcd.com/326/) or not...
In addition to the Linux Kernel source, you should also check out the Quake 3 engine :). They're both fairly large.
I'm not sure about in C, but in C++ a node** tree would be the same as a node* tree[]. Which means that tree it is an array of node pointers. This is most likely the case, unless the author likes extra levels of indirection.
There's one [in Linux](http://lxr.free-electrons.com/source/lib/btree.c).
This might be what you're looking for: https://github.com/torvalds/linux/blob/master/lib/btree.c Edit: more info from the source, if you're too lazy to click lib/btree.c - Simple In-memory B+Tree [...] A relatively simple B+Tree implementation. I have written it as a learning exercise to understand how B+Trees work. Turned out to be useful as well. B+Trees can be used similar to Linux radix trees (which don't have anything in common with textbook radix trees, beware). Prerequisite for them working well is that access to a random tree node is much faster than a large number of operations within each node. Disks have fulfilled the prerequisite for a long time. More recently DRAM has gained similar properties, as memory access times, when measured in cpu cycles, have increased. Cacheline sizes have increased as well, which also helps B+Trees. Compared to radix trees, B+Trees are more efficient when dealing with a sparsely populated address space. Between 25% and 50% of the memory is occupied with valid pointers. When densely populated, radix trees contain ~98% pointers - hard to beat. Very sparse radix trees contain only ~2% pointers. This particular implementation stores pointers identified by a long value. Storing NULL pointers is illegal, lookup will return NULL when no entry was found. A tricks was used that is not commonly found in textbooks. The lowest values are to the right, not to the left. All used slots within a node are on the left, all unused slots contain NUL values. Most operations simply loop once over all slots and terminate on the first NUL. 
Thanks! While I'd prefer a disk-based example, this will do the job! But if anyone else knows a B-link-tree example (ideally disk-based), please post!
Please don't try to shortcut this step. Knowing how to read code is actually an incredibly valuable skill set and entirely under-emphasized in both education and the workplace. I've worked with some people that were great coders, but couldn't read code to save their life. A lot of people just can't follow code that was written by other people and doesn't flow they way they might have done it. When you get into the "real world" and out of the candy-land of academia, you will be reading a lot of other people's code, and being able to scan through it and quickly comprehend what it does is incredibly useful. You don't want to be one of those people that can only work on your own code and no one else's. There are tons of open source projects out there; pick something of interest to you, download the source and just scan through pieces, figuring out what this or that function does. 
Take a look at this [StackOverflow Question](http://stackoverflow.com/questions/32376/what-is-a-good-open-source-b-tree-implementation-in-c) It lists a variety of b+tree implementations. I almost forgot! [Keyvaloo Data Store](http://www.tarsnap.com/kivaloo.html ) (from Tarsnap) implements a B+Tree.
I would really like to learn more about transactional memory. However, this blog post doesn't contain a single line of C code, nor discuss C programming at all. It links to an [Intel manual on TSX](http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf), and a [C++ library](https://github.com/amidvidy/xsync) using those features. According to the [Wikipedia page on transactional memory](https://en.wikipedia.org/wiki/Transactional_memory), there are no implementations available for C yet. I don't think this post is relevant to this subreddit.
You don't need the \0 in the string, it's done for you. That's not the problem though. "Hello, World!" is a const char *, not a char *. Casting it to char * like that is not allowed. Enabling compiler warnings should catch this for you. strfry scrambles the string in-place, which it can't do because the string literal is read-only memory. All you have to do to fix it is change "char *s" to "char s[]", which creates a copy of the string on the stack.
Thanks. I guess I should always try it out first with -Wall :) It does make sense that it should be a const char *, so it can't be modified in-place. Thanks for that. I tried with a char s[] also, it still gives the segfault. Here is a list of the warnings it gives: stuff.c:8:5: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘size_t’ [-Wformat=] printf("The length of the string is: %d\n", strlen(s)); This one is interesting because the manpage says strfry is defined in &lt;string.h&gt;... stuff.c:10:5: warning: implicit declaration of function ‘strfry’ [-Wimplicit-function-declaration] printf("The fried string: %s\n", strfry(s)); stuff.c:10:5: warning: format ‘%s’ expects argument of type ‘char *’, but argument 2 has type ‘int’ [-Wformat=] Also, correct me if I'm wrong, but I was under the impression that a char * and a char s[] were both just pointers to a character, the latter with a little "book-keeping" added.
&gt; "Hello, World!" is a const char *, not a char *. No, it is a `char []` (i.e. array of char). You can check that it is an array and not a pointer by doing `sizeof` on it (or by reading the C standard) &gt;Casting it to char * like that is not allowed. There is no cast in OP's code. (A cast is an explicit conversion indicated by a typename within parentheses). There is an implicit conversion from `char []` to `char *`, which is allowed and presents no problems. &gt; Enabling compiler warnings should catch this for you. This line is completely legal so it should not generate warnings. GCC has an extension `-Wwrite-strings` which will make string literals be arrays of const char, instead of arrays of char, and therefore generate a warning for this line. OP's program crash is explained by the fact that the behaviour is undefined if you attempt to write to a string literal. 
Changing %d to %zu should fix the first warning. strfry is nonstandard, as you know, and you might need to do something to get string.h to expose it -- I'm not sure. You can declare it yourself by inserting "char * strfry (char *string);" before main(). That should fix the other two warnings, and hopefully the crash.
You should always prototype functions before calling them. In the case of `strfry`, if this is being provided by glibc then there ought to be a header that you can include that contains the correct prototype for it. If you don't prototype a function then the compiler follows some rules for guessing and it won't always be right; for example it will always assume the function returns `int` . Then if the implementation handles `int` return values and pointer return values differently you will run into trouble. 
I am on a Linux distro with GNU libc, and according to the man-page, this function should be there when you include &lt;string.h&gt; A quick look in string.h reveals that it is in fact there, but only if __USE_GNU is defined. Apparently, this is not the default. If I define that symbol in my code, the warning goes away (implicit declaration) and the seg-fault stops, probably because it's assuming an int return type. Thanks, you're good at this :)
char * foo is the same as char foo[]. There is mention below that char foo[] = "Blah"; will give you an array on the stack. I'm not too sure about that; it could also be compiler-dependent as far as to where the variable is stored. Pointers and array-variables (the one doing the naming of the array) are functionally the same thing underneath with different notations based on use: foo[5] is the same as *(foo + 5)
Try going: #define _GNU_SOURCE #include &lt;string.h&gt; The symbols with double-underscores get set up depending on what switches you pass to GCC, and also it lets you write this `#define _GNU_SOURCE` to mean that the code has GNU extensions enabled. Obviously you wouldn't use a standard-C switch (e.g. `-ansi` or `-std=c99`) while doing this. NB. This is something you probably don't want to do in general, as then you get non-standard (C standard and POSIX standard) behaviour in other functions.
Not too sure about other APIs, but Win32 API uses it a lot. Apple uses it in a sense for ObjC objects in that it makes them all void* underneath. It can help with documentation in the case where you have a very large project where you are creating your own internal API. I've used it mostly when creating structs, and then it's probably just used to make pointers. Overall I'd say maybe the best case is if you're creating an API for someone else to use, having a typedef allows you to change the internal structure without requiring the API users alter their code.
 char *p = "hello, world" is different from char q[] = "hello, world"; You won't find a system where sizeof p == sizeof q and you cannot assign a new value to q.
To add to your comment: String literals behave as if they had type const char[] but for compatibility reasons they do not have a const type. Still, writing to a string literal is undefined behavior (i.e. it may crash your program, it may not work,it may work as intended or it may do something unexpected)
I would say they behave like `char[]` but the behaviour is undefined if you write to them. In 6.4.5/5 of C99 it says that the array are `char` and not `const char`. (I believe C90 also said the same, but the text for that is not freely available so I can't check). However gcc fails to compile the following code (with furniture): if ( 0 ) "abc"[0] = 0; This seems to be a bug in GCC, I'll see if I can obtain further advice in it. 
OK. I'm trying it in gcc 4.1.2 , perhaps it was fixed after that. (I don't normally develop with that version but it's what's installed on the system I scratch around on). 
I have found pointer to struct typedefs confusing except when the fact that it is a pointer is embedded in the new name. Things like typedef struct coordinate_t * coordinate really throw me off. 
You need `_GNU_SOURCE` defined or to compile with one of the various `-std=gnu*` standards. `gnu89` is default for gcc, so its likely not going to be a problem.
Also, importantly, in the `char q[]` case, "hello, world" is actually copied into the memory region of `q`. Its basically static initalization of an array.
What *exactly* are you trying to do? This type of thing can be very easy or hard depending on what you're trying to do, since C doesn't support functional programming of this type as a built-in language feature, but doesn't stop you from implementing a flexible framework yourself. For example, a simple iterative lazy thingy (thrown together sloppily ad-lib, ignore dumb errors): struct MyGenerator { int * data_current; int * data_end; GenFuncPtr SomeOperation; } might be assigned to perform function "next" on each next element of its data set: struct MyGenerator m; /* assign some data, data_current to start, end to end */ int myresult; lazy_next(&amp;m, &amp;myresult); // ..... int lazy_next(struct MyGenerator * m, int * result) { if (m-&gt;data_current &gt; m-&gt;data_end) return -1; *result = m-&gt;SomeOperation(m-&gt;data_current++); return 0; } Of course this example kind of sucks, but you get the idea. Basically, C will let you do anything you want, but you have to outline yourself and then implement how you want the framework to work. This is actually (sort of) how FILE streams work in the stdio lib- they add one character at a time to a buffer using a write_ptr and then perform a system call to write all at once when the buffer is full, or a buffer flush is otherwise requested. 
I've never heard of anything like that, and I'm not sure what the advantage would be. What kind of use case are you imagining?
&gt; What exactly are you trying to do? Have a look at [my other comment](http://www.reddit.com/r/C_Programming/comments/1tbz32/library_for_lazy_eval_in_c/ce6l4hb)
Well, what you're describing isn't really "lazy evaluation", per se. Lazy evaluation is just stalling the computation of a particular value until later. You're describing a framework for building expression trees at runtime, which are then evaluated lazily. As an example, we could have this: typedef enum { ADD, SUB, MULT, DIV, LSHIFT, RSHIFT } Operation; typedef enum { COMPOUND, SIMPLE } ExpressionType; /* An expression is either a compound expression (an operator and one or two operands) or a simple expression (just a literal integer value */ typedef struct { ExpressionType type; union { struct CompoundExpression *compound; int simple; } val; } Expression; typedef struct CompoundExpression { Operation op; Expression *ex1; Expression *ex2; } CompoundExpression; Using these structures, you could build up expression trees at runtime, and then pretty easily write functions to evaluate them. This would be a simple way to implement a form of lazy evaluation in C, with the drawback that building up the expression trees at runtime would incur a very significant runtime cost (what with all the memory allocations that would be necessary in the overwhelming majority of cases), to the point where eagerly evaluating everything (even if it's not necessary to evaluate) would probably be faster. What you're describing, moreso than lazy evaluation, is a form of expression-tree optimization. That is, you tell the "library" that anything multiplied by 0 is 0, and you want the tool to automatically replace any MULT trees that have 0 as an operand with the simple value 0. This kind of optimization is distinct from lazy evaluation and should be thought of as a separate step. In any case, compilers do this sort of thing all the time, but this kind of optimization generally isn't done at runtime (since building and evaluating expression trees at runtime generally isn't done). I'm still not convinced a tool of this sort would be useful, but I do agree that the idea is interesting, if not a little esoteric.
Okay, so here is a breakdown of every problem in this small program: * The %d should be a %zu as strlen returns a *size_t* and not an *int* * The char *s creates the string in a read-only section of the binary, and strfry() swaps the characters in-place. This obviously can't happen because it's read-only. * To fix this read-only problem, use char s[] - this creates the string in the call stack. * The declaration for strfry() is not included by default from &lt;string.h&gt;. There is a macro present which filters it out unless the symbol _GNU_SOURCE in defined. Also, importantly, here's a quote from *man 2 intro* - intro to library functions: In some cases, the programmer must define a feature test macro in order to obtain the declaration of a function from the header file specified in the man page SYNOPSIS section. (Where required, these feature test macros must be defined before including **any** header files.) * So, #define _GNU_SOURCE must be before any includes.
Phew! These computer thingies are awfully picky!
Yes, Ulrich Drepper (aka Ulrich cant-do-proper-versioned-symbols Drepper) is a dick. Talking to schily about cdrecord maked that absolutely clear.
Does compiling at -O3 automatically convert pass-by-value to pass-by-reference when appropriate? I believe that C++ compilers will do that with classes when they feel that it is due and I would be shocked if that didn't get ported to C as well. That would explain some of the leveling with higher optimization.
It would depend. The compiler have to generate code according to a calling convention. The compiler doesn't know if you're compiling one source file with -O3 and another with -O2 but they still have to be able to call each others functions. If the function is static and called directly, the compiler might do that though.
All right, I'm going to be the dick who drops a big, nauseatingly pedantic "this is iffy" posting. - The actual layout of a program's in-memory image is left entirely up to the operating system, and often the program itself as well. The article covers the traditional heap-goes-up/stack-goes-down layout that's been taught for ages as How Things Work, and it's more-or-less true when your program first starts. However, that layout goes right out the window as soon as you create another thread (generally with a stack whose memory has been allocated from the heap) or load a dynamic library (with its own code and data/BSS sections but sharing the heap and stack). The vast majority of C programs nowadays are dynamically linked to the C runtime library (e.g., libc.so in Linux), so they'll grow up without ever experiencing a nice, clean, traditional, God-fearing memory layout like the one the article describes. - The heap isn't necessarily a contiguous swath of address space, and it doesn't necessarily live at a particular position relative to the stack. Most allocators treat "big" and "small" allocations differently, and will place them in different fashions. (They're often allocated from the OS in different fashions too---e.g., via heap break/`brk` for small ones and `mmap` for large ones.) Big allocations will often get placed above the program stack. - The discussion of initialized data sections leaves out the read-only data section (`.rodata` per SysV ABI, `.RDATA` per Windows IIRC; most platforms have one), which typically sits in between code and initialized data. It's used for things like string constants (`"foo"`) or any global or `static` variable that's declared as `const`. static int x; // -&gt; .bss static int y = 4; // -&gt; .data static const int z = 8; // -&gt; .rodata If the platform supports memory protection, any write to the code or read-only data section will result in a page fault, which POSIX programs will see as a `SIGSEGV` that manifests as an angry `Segmentation fault` message. - The term "RAM" is used somewhat liberally in this article to mean "address space". On an ancient or embedded platform, the two will be roughly the same; if there's virtual memory, however, they're quite different. In the latter case, unless there's some good reason to fault pages in before booting the program, they'll be pulled in on an as-needed basis only---in fact, it's entirely possible that only a few pages of program's image will ever be loaded into actual, honest-to-goodness RAM before the program exits. This is especially true of BSS and stack pages, for example, which won't actually exist anywhere (not even in the binary file) until they're accessed, faulted in, and (hopefully) zeroed. - This article uses the term "segment" to refer to what would normally be called a "section". The terms are ~somewhat~ interchangeable, but "segment" almost always refers to the hardware's idea of things---a contiguous chunk of address space with the same access characteristics (e.g., .text or .text+.rodata in the code segment, .data+.bss in the data segment)---and "section" usually refers to the layout in binary files and how linkers see things.
PNG image decoder/encoder: http://lodev.org/lodepng
tinyjs : https://code.google.com/p/tiny-js/ A simple single-file javascript interpreter written in C++ (2000 lines) its c++ but i found it very useful.
I too love these kind of libraries! They are so easy and simple to integrate and maintain. No weird crossing-the-streams build system wrangling, dealing with webs of incompatible dependences, arcane shell scripts you need to port, etc. I'll add [GLEW](http://glew.sourceforge.net/). You get a whole bunch of stuff in the tgz but if you define GLEW_STATIC you can just take glew.c and the include folder and throw it in there.
Maybe not exactly what you were looking for, but there is always [gnulib!](http://www.gnu.org/software/gnulib/) It has some nice utility functions (crc32, rb-trees, etc.)
The standard costs money to obtain, but the working group makes drafts available. [n1570](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf) was the last draft before the final standard was ratified. 
thanks for wise pointers, as actual layout is entirely up to the OS. Here, it was tried to develop just an idea how a program runs. Thanks once again! 
There's lots of stuff in the [CCAN](http://ccodearchive.net/list.html).
The minute I read the title, I was about to make your first point. Ultimately, a program is compiled or interpreted to architecture specific machine code, regardless of the language in which it was originally written. Any language is essentially just a syntactically rigorous and human readable bridge from a programmers intent to a machine's actual executable code. At runtime, the OS sees only compiled/interpreted machine code and data read into memory, not the text of your C (or Python, C++, whatever) program. Anyway, thanks /u/nerd4code for pointing out that and many other essential details to those that might be mislead by this post. You said it all better than I could have.
thank you all. we will incorporate your comments in next update. 
RS-232 - http://www.teuniz.net/RS-232/
&gt; I have some bad habits of wanting every binary to be as self contained as possible and compiling everything statically. I don't consider this a bad habit, especially if you're deploying newly updated binaries which incorporate fixes regularly (and fixes to the libraries you are embedding). Modern web service environments do deployments all the time. 
There is an ECMAScript interpreter written in C: https://github.com/ndreynolds/flathead
APIs for hardware? Get a microcontroller development/evaluation kit, read the manufacturer's library and use it to build small applications. You can progress to Linux later. And get a simple microcontroller board, not a raspberry pi. If you are going to develop simple applications, its best to avoid an OS/RTOS
This. No matter whether you end up doing Windows or Linux drivers, this is a must 1st read.
I don't mean to be rude, but might I ask why you're writing an article on something you don't completely understand? To give a brief answer, the value of a pointer is an address. Functions have an address in the code segment of an executable. Execution jumps to this address when a function is called, and the functions code is executed, and then returns to the return address saved in the stack. If two function pointers point to the same address, they point to the same function. Since an address is an integer in general, comparing function pointers (or any pointers) is as simple as comparing two integers. Keep in mind this is a simple answer. I do not consider my knowledge great enough to write an article covering function pointers. Yet here I am trying to answer your question, which indicates to me that perhaps you should reconsider writing such an article yourself. I really don't mean any disrespect, the question just struck me as odd. Good luck either way my friend.
Thank you very much zifyoip. I was going through http://www.newty.de/fpt/fpt.html#compare link, where the author mentions 'You can use the comparison-operators (==, !=) the same way as usual.' but in the example code he uses greater than operation, so thought of asking if this is definite behavior. // C if(pt2Function &gt; 0){ // check if initialized if(pt2Function == &amp;DoIt) printf("Pointer points to DoIt\n"); } else printf("Pointer not initialized!!\n"); 
thanks curiousGambler
There are a lot of things wrong on that page, I'd suggest you don't refer to it at all. It juxtaposes C function pointers and C++ pointer-to-member function, which are quite different ideas. It has syntax errors, undefined behaviour, mistaken ideas about what is correct and what isn't, and it recommends poor coding style. If you want to make a function accept a pointer-to-function, or have an array of them, then the clearest thing to do is to typedef the function (NOT the pointer, pointer typedefs are to be avoided). typedef int MyFuncT(float, char, char); void func( MyFuncT *fptr, char arg) { MyFuncT *array[5]; array[0] = fptr; fptr(0, arg, 0); } 
Never thought I'd run into this: if(pt2Function &gt;0){ // check if initialized if(pt2Function == &amp;DoIt) printf("Pointer points to DoIt\n"); } else printf("Pointer not initialized!!\n"); Took me a moment to realize which 'if' the 'else' was actually on, that brace placement and spacing is just pure evil. There are definitely better places to look then that website.
Yeah. It's as if he's used to a language where the actual level of indentation defines the control structure, and is trying to simulate that in C. 
my late christmas present to r/C_Programming, enjoy. here is a [screenshot](http://i.imgur.com/hsIa1QD.png). see readme for more info.
There's not much you can do with function pointers aside from calling them. What you can do is * Compare them for equality and inequality with `==` and `!=` operators. * Cast to another kind of function pointer and back. In other words, a function pointer can store the address of any function. There is no pointer arithmetic or relation operations on function pointers. It is sometimes useful to use a default function instead of the null function pointer. For instance when a pointer is allowed to be "uninitialized" under some conditions and you don't want to null check before use (i.e. when you can perform the `else` part in the default function). But when a null pointer means that there's a bug in your program this is not very useful - your debugger should give you all the necessary information.
Good point. I meant using the "==" and "!=" operators only, thanks!
Looks good to me! No compiler warnings and it works as specified. If you wanted to go a bit further, you could add validation on your `scanf` call (make sure that its return value is `2`).
I wasn't sure if I should comment in this post, because I don't think I'd like to see this subreddit used for these kind of posts (certainly not the "help me with my homework" submissions). But, I'm quite particular about C coding style. I think that C is a beautiful language, but is marred by many C developers who don't give much thought to how they write and structure their programs. This is a blessing and a curse: on one hand, by not striving for beautiful interfaces, C developers have a strong culture of getting stuff done. On the other hand, C programs are usually only understandable by those who wrote it, and even then... So, congratulations and thanks for caring about how you write C. I've done a few things in Ruby too, and I love their culture of caring about their code. We need more C developers like you! :) As for your question, there are a few ~~crucial errors~~ things I thought were errors, but are still interesting to note: * `main` should be written like `int main( void )` if the program shouldn't take any arguments. Edit: as /u/dreamlax points out below, `()` and `( void )` are actually equivalent when defining a function. Still, you should write the `void` for consistency, flowers and such. * `scanf` should be error-checked; a more versatile program would probably use `fgets` (or even `get_line`) and then ~~atol~~ `strtol` (thanks /u/OldWolf2). Edit: actually, it should probably just take `op1` and `op2` as command-line arguments (i.e. in the `argv`); this is then easier to safely parse into integers, and makes the program easier to weave with the shell. * ~~as I understand the C (and POSIX) specification, `0` doesn't necessarily indicate success on all platforms. You can either use the fact that `main` will implicitly return a value that will indicate success on the host platform, or you can explicitly return `EXIT_SUCCESS` (defined in `stdlib.h`)~~. Edit: as /u/dreamlax points out below, this is completely wrong: the specification states that `0` or `EXIT_SUCCESS` will be translated to the host environment's success value. I've written [a pretty extensive survey of my favorite C programming practices](https://github.com/mcinglis/c-style), with justifications and reasoning. A few of those rules are a bit outdated; I've realized some aren't always the best way to do something, when I've said they were, and some I've completely changed my opinion on. Anyway, I noticed your code violates two of those rules, namely: * [use one line per variable definition; don't bunch same types together](https://github.com/mcinglis/c-style/blob/master/readme.md#use-one-line-per-variable-definition-dont-bunch-same-types-together). * [declare variables as late as possible](https://github.com/mcinglis/c-style/blob/master/readme.md#declare-variables-as-late-as-possible) - `total_sum` only needs to be declared above the `while`. There are a few other things which I think aren't ideal: * inconsistent parentheses spacing. * masking multiplication and division behind bit-shifts - why? I would recommend you use `/= 2` and `*= 2`. * trailing spaces on the `printf`s on lines 22 and 32. * trailing spaces in the actual source code; you should configure your editor to remove trailing spaces. * use of tab characters - I personally feel the tab character should just be forgotten. It was a mistake, and it doesn't work. For such a simple example program, it's an easy way to align stuff on lines, but to go for maximum versatility you should use the spacing format markers. * `total_sum` is a tautology - I would just call it `sum`. I would also call the `op1` and `op2` variables `a` and `b`; just as informative, but shorter, so its easier to read. On the program itself, you could improve its clarity by labeling the columns. Going further, you could try to work out how to purify the integer-progression sequence generation by separating it from the input-output handling. That is, implementing something like `int * * russian_multiplication( int a, int b )` that will generate an array of int-arrays representing the sequences your program prints. Haskell programmers (and users of other pure-functional programming languages) will know what I'm talking about. A commentator on the Gist said you should use `!(op1 % 2)` as the conditional expression rather than `op1 % 2 == 0`. I disagree; [this is why](https://github.com/mcinglis/c-style/blob/master/readme.md#explicitly-compare-values-dont-rely-on-truthiness).
&gt;atol This has undefined behaviour for some input, so it's better to use `strtol` . 
* `int main(){}` and `int main(void){}` are exactly the same. It only makes a difference for function prototypes. See ISO/IEC 9899:TC3 section 6.7.5.3 paragraph 14: &gt; An empty list in a function declarator that is part of a definition of that function specifies that the function has no parameters. * Returning a value from `main` is equivalent to calling `exit()` with the that same value. You can use either `0` or `EXIT_SUCCESS` (even if they are not the same) and this will be equivalent to a *successful termination*. See ISO/IEC 9899:TC3 section 5.1.2.2.3: &gt; If the return type of the `main` function is a type compatible with `int`, a return from the initial call to the `main` function is equivalent to calling the `exit` function with the value returned by the `main` function as its argument. and section 7.20.4.3 paragraph 5: &gt; Finally, control is returned to the host environment. If the value of status is zero or `EXIT_SUCCESS`, an implementation-defined form of the status successful termination is returned. [POSIX](http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdlib.h.html) requires `EXIT_SUCCESS == 0` even if C does not.
Thank you! Very interesting. I love being wrong :)
I think these kind of constructs are universally harmful, because they mask control flow in extra-syntactic ways, which makes code written with such constructs extremely hard to understand. But, the article was interesting and taught me a thing or two about the preprocessor. I'd like to see this subreddit become a sort of "planet C", so I'm happy to submit interesting links whether I agree with them or not.
By and large I think this is a pretty good analysis; I'd agree with much of what you say, but wanted to point out a couple of minor nits: First and foremost, your recommendation to "declare variables as late as possible" may or may not be valid, depending on the particular compiler and version(s) of the C standards that it supports. Notably, C89/ANSI C does not permit variable declaration wherever you feel like it. See [this discussion on stackoverflow](http://stackoverflow.com/questions/288441/variable-declaration-placement-in-c) for some discussion on this. Even if OP's compiler accepts this, it reduces portability, as he may wish to build for an environment where the compiler is older. Using the sample code listed in that link, I get the following from gcc in standards mode: -bash-3.2$ gcc -ansi -pedantic -c decs.c decs.c: In function 'main': decs.c:7: warning: ISO C90 forbids mixed declarations and code -bash-3.2$ And from the Sun C89 compiler: -bash-3.2$ c89 -V c89: Sun C 5.11 SunOS_i386 2010/08/13 usage: c89 [ options ] files. Use 'c89 -flags' for details -bash-3.2$ c89 -c decs.c "decs.c", line 7: warning: declaration can not follow a statement And from clang: $ clang -std=c89 -pedantic -c decs.c decs.c:7:15: warning: ISO C90 forbids mixing declarations and code [-pedantic,-Wdeclaration-after-statement] char *s; ^ 1 warning generated. The only other piece I would comment on, is your comment about masking multiplication and division behind bit-shifts, and why do it. There is a potentially valid performance speedup from executing a 'ror' (rotate right) instruction versus executing an 'idiv' (signed integer division), speaking here specifically for x86 architecture, but I'm sure other architectures are similar. Depending on the CPUID, it can be a fairly large factor: for CPUID OF_3H, latency for an 'idiv' is 66-80 clock cycles, and for an 'ror', only 1 clock. (Check out the ["Intel 64 and IA-32 Architectures Optimization Reference Manual"](http://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-optimization-manual.html) for more detail; information excerpted from Appendix C, Latency and Throughput). That said, a good optimizing compiler will convert division by 2 to a bitshift for you, where safe. I'd usually consider this premature optimization, although it does occur within the main loop in OP's code.
Agreed, it's a great exercise in preprocessor use, but the creation of non-standard syntactic candy for flow seems very harmful to the readability of a program.
One fun puzzle to solve is called "IQ Twist" - just google for images of the game. The game involves fitting a number of colored tetris-like pieces over the same color pegs on a board. Given the position of the various colored pegs, you have to find a way to fit all the pieces on the board. Definitely a fun programming example.
Project Euler?
Cheers, looks like i'll have to figure out if eclipse can support colour now
"SPOJ – [Sphere Online Judge](http://www.spoj.com/) – is a problemset archive, online judge and contest hosting service accepting solutions in many languages." — http://www.spoj.com/tutorials/ And the /r/learnprogramming wiki has an extensive list of [Programming Challenges](http://www.reddit.com/r/learnprogramming/wiki/index#wiki_programming_challenges) Also, although not strictly what you're looking for, don't forget to "[DoItAgainToLearn](http://c2.com/cgi/wiki?DoItAgainToLearn)".
Most of this stuff would be done with the guard pattern in C++ 98...
[Programming Challenges](http://www.programming-challenges.com/pg.php?page=index) is fun, too.
Have you seen Adrian Neumann's simple problem site? http://adriann.github.io/programming_problems.html
try [Learn C the Hard Way](http://c.learncodethehardway.org)
I think that for very specific cases, it can work. In particular, only used within a single source file, specific to a set of parameters (eg for-each-hippo type loops), and so on. For-eaching an internally used linked list might be useful in several places, for example. In those cases, it might make sense if changes to the flow control might be necessary, and it would be easier to use a macro than try to remember each place the boilerplate was used. But I'd agree that its a big can of worms, and even in the best case is probably impractical due to potential misuse by others in a project (eg, expanding old code way past initial design) more than issues directly related to code readability. 
I have an Arduino that I have played with, and I just picked up a TI Launchpad (Tiva) for a project I am involved with. I am looking to build off of the microcontroller and add in RFID, sound, and video components. Why would it be a good idea to avoid an RTOS?
Thank you so much. I began reading it this weekend, and it is already helping me understand a lot.
If you are going to do multiple tasks and have a lot of event based actions to do, I would recommend an RTOS. But if the application is as simple as communicating over a UART while blinking an LED then I think you will be better off without an OS. Of course if you are comfortable learning many concepts simultaneously then I would say you dive into something like FreeRTOS and get started with your application. Good luck.
Also a quick question. After a function has been 'designed', do I put a semi-colon or not? i.e. void stuff(void){ printf("stuff"); }; &lt;&lt;&lt;&lt;&lt; (yes or no)?
No.
Style is up to you. I would put spaces on both sides of my binary operators (like =), spaces after commas, and no spaces after my arrows (-&gt;). Some people like to typedef their structs so they don't have to write the word struct everywhere, and some people don't. Also some people follow java like camel casing in their struct names like struct RoomWithChair roomWithChair; Once your program involves multiple files, you'll want to put your forward declarations in a header file if they're exported to other modules. Functions and global variable that are private to a given file be made "static", which makes them private to the file. That will give you a warning that "change_dimensions" isn't used. You forgot to call srand(). I would be a new line before my #define to separate it logically from the include files. Depending on where you're going with this, you might want rooms to be malloc()ed instead of being global. Maybe you'll even want a struct that contains the array and the length of the array, and maybe you'll pass that struct to create_rooms() and print_rooms() instead of them being void.
As a general rule, global variables are frowned upon, as it can be hard to follow data flow. One way you could have manipulated the values within create_rooms is by using pointers. If at this moment in time you are not sure that you understand pointers, don't worry, they take some getting used to.
Woops, writing 'r' twice must've been a mistake. Thanks for the feedback :D Also I would usually do 'int i = 0' in for loops but I'm at work so I'm just using ideone to do all the compiling.
I understand pointers but have a hard-time incorporating them. I'll just keep drilling them in, and then one day it will click ^^^I ^^^hope
I'm not going anywhere in particular with this, I just wanted to touch upon structs and arrays of structs a bit more than I have previously. Also I haven't even touched any malloc() free() etc... yet. It's hard to believe such a small language can be so hard D:
try making a 1 player 3*3 tic tac toe game. It is simple enough, that it can be done in couple of hours, and the top level pseudo code should be enough to get you started. and you can pass the game board as a pointer though the player and (if you want) the AI functions. *I should mention that I said a couple of hours, because I imagined as a python dev, you would be able to sus out the algorythm ok, and would only strugle with the c aspect.
And functions that are declared static can be inlined and optimized out by the compiler, since the compiler can prove that they're not visible outside the module. The tip about the 'upside down' method of static declarations is golden. I only figured that out a short while ago and wish I'd known that trick earlier. It cuts down on so much vertical space wasted on forward declaration bookkeeping. Another nice thing about c99 is that it defines a native bool type. Useful for self-documenting utility functions, but the code here doesn't give much opportunity to use it. Because the OP asked specifically about style, I'll note that it's sort of customary to put a function's braces on a new line. OP's code: void create_rooms(void){ int i; int r= rand()%15; for (i=0; i&lt;ROOMS;i++){ rooms[i].width = r; rooms[i].height = r; r = rand()%15; } } What I'd write: static void create_rooms (void) { for (int i = 0; i &lt; ROOMS; i++) { rooms[i].width = rooms[i].height = rand() % 15; } } 
You might want to seed the RNG too; the way you have it, you'll get the same sequence of "random" numbers every time. (This may or may not be a good thing for testing!)
If you're using ideone, change your language to "C99 Strict."
Marking functions that don't need to be "public" as static: yes. Marking all variables as static: no (be careful). Making variables static can introduce unintended state into your library/application. I only make variables static if I want that behavior: "storing" the value of a variable between calls. You can also do it if the fact that the value of the variable will be stored between calls.
Looks like you have some good feedback so far. One important thing when going between an interpreted language and C is to remember there is a heap and a stack, what the differences are and where your values are. I'd recommend typedef for the structs. Saves some keystrokes and you can visualize usage of those structs as objects. Learn doxygen. Proper documentation early will make it easier to document your code as you continue to work in the language. Learn and master pointers now. The earlier the better as they're incredibly powerful and not learning them will limit what you're able to accomplish with the language.
(1) Not necessarily a C-ism but avoid global variables at all costs and pass the data around. So main() would look something like this: int main(void) { size_t nrooms = 10; struct room rooms[nrooms]; create_rooms(nrooms, rooms); print_rooms(nrooms, rooms); } And the definition of create_rooms() would look something like this: void create_rooms(size_t nrooms, struct room rooms[nrooms]) { ... } (2) I would use the One True Bracing Style but not for function definitions. (3) I might place main() at the end of the source file to avoid having to prototype functions. (4) Since you're starting out, I'd immediately jump on the C99/C11 bandwagon. Declare variables as late as possible and initialize them at the same time. Use variable declarations in your for(;;) loops. So create rooms should look something like (disregarding my previous comment about passing variables): void create_rooms(void) { for (size_t i = 0; i &lt; ROOMS; i++) { int r = rand() % 15; rooms[i].width = rooms[i].height = r; } } (5) Try to always return something useful. For example, it might be helpful for change_dimensions() to simply return *r. I cant think of a reason now but I do know from experience that you'll find a reason if you work on this code long enough. :^) 
easier than you think once you've used it a little bit
pointers are like enlightenment, you have to keep working at it until it all makes sense. 
&gt; 'designed' The word you're looking for is "defined".
Oops: I certainly don't mean to mark all function local variables as static!
Here's another exercise you might find useful to start learning pointers: implement a dynamically re-sizable array of items (which is basically what a list is in Python). For extra credit: use "void pointers" to create structures that can hold items of any type. 
what do you want to do? (besides it's not the best subreddit for this kind of question as it's in no way or just very little related to actual C programming) But you can google UI mods, but since it's an online game you will be banned if you try to modify your client since it's very much like cheating.
I learned programming in C# and thought C was impossible when I started learning it. It is a lower level language than C# but, like all other languages I've learned, the more you code in it the easier it becomes. The hardest part about C, for me anyhow, was the concept of pointers. C# doesn't really have equivalent syntax but once I got that it was pretty straight forward. 
This community is one of the most helpful ones I've come across, YOU'RE ALL SO FRIENDLY :'D
C# does actually have pointers with a syntax almost like C, it's just very seldom used.
unmanaged code lets you do pointer work, iirc
I'm on mobile, so here is MSDN's explanation instead: http://msdn.microsoft.com/en-us/library/y31yhkeb.aspx
Your struct contains pointers to arrays, so you need to alloc for the size of the arrays. Instead you were alloc'ing space to hold more pointers to arrays. This resulted in a bunch of garbage when I ran your program. See [my version](http://pastebin.com/As9GgGsz) and view the diff [here](http://pastebin.com/diff.php?i=As9GgGsz).
Wow! Thanks a lot. I will try it soon. The only problem is that I only have my tablet right now so ssh-ing and testing will suck lol.
I don't have much time right now, but here's my quick observation. Looking at this line: cfg-&gt;dates = (unsigned int(*)[3]) realloc(cfg-&gt;dates, newSize * sizeof(unsigned int(*)[3])); Okay, so lets do some digging: printf("startTimes: %llu %llu\n", sizeof(unsigned int(*)[2]), sizeof(*(cfg-&gt;startTimes))); printf("dates: %llu %llu\n", sizeof(unsigned int(*)[3]), sizeof(*(cfg-&gt;dates))); Which outputs: startTimes: 8 8 dates: 8 12 I *believe* what's happening is that you're not allocating enough memory for the dates array, and startTimes works incidentally because the size of the array is the same size as the pointer. Again, I literally only had 5 minutes to go over this, so don't hold me to that. I'll take a deeper look when I get back home. I can say you're problem is definitely with memory allocation, though.
I can confirm this works! Thank you for helping me.
Better yet, don't have those. 
You'll probably want to be aware (If you're not already), your program has a few memory issues, as well as some leaked resources. I've been messing with the program (Using valgrind to analyze it) and the biggest issues that jump out: readCFG leaks the memory allocated via malloc that you store a pointer to in 'buffer'. Keep in mind that buffer right after malloc points to the beginning of a 512 byte block of memory. The issues start arising in your loop. It's pretty common for you to do a buffer += (number of chars) to move to a new part of the string. It's a common technique and works well, however you have to realize it destroys your original pointer 'buffer'. Once you do that, 'buffer' points to a different location in your 512 byte block (IE. Not the beginning). The ending result is that you can't still consider buffer a 512 byte block after that point, because doing a buffer[511] will write to memory you don't have. If you added 5 to 'buffer' and then tried buffer[511], it would fail, because [511] is actually the [516] block from the start of the 512 bytes, which doesn't exist as far as your program knows. It's (thankfully) not to hard to fix really, I'll leave it up to you to think about though, feel free to ask if you're still having trouble. Besides that issue, you also never call free() on the malloced memory at the end of your function. You malloc'ed 512 bytes, so you need to free() then when you're done using them. You probably find it useful to simply use an array of chars instead of malloc when you have a fixed-length buffer like this one, that's the common approach. Noting that, you have one more issue in readCFG, and that's a simple issue that you used fopen() to open a file, but don't have a corresponding fclose() to close your fine when you're done using it. I'll leave that to you as well, this is a simple fix. The only other memory issue is that you don't ever free the contents of your 'struct config'. You allocate it as a variable in main, so the cfg variable itself doesn't require freeing, but everything you alloced into it (The strings, arrays of strings, and arrays of ints) all should be properly freed. Since it does exist in main(), you technically don't need to free it since it exists for the entire life of the program and then is freed when your program exists. At the same time though, it'd probably be a useful exercise to do, and it makes debugging easier as you can be sure everything in the program should be freed.
Thanks for the response! firstly, there are already permissible mods. Basically, you can change anything clientside (appearance of champs, your UI, etc.)... I would like to mod my graphics, and maybe alleviate some of the FPS issues. The people over at riot have been pretty clear about what's permitted and what isn't, so i'm not too concerned with getting banned. None of the UI mods I've seen have been very helpful at getting anywhere on this issue, so I was just looking for some inspiration / knowledge in general
Thanks a lot for the tips! Honestly I can't believe I forgot to fclose and free my buffer. As for freeing my structure it's because I send it to other functions from the main function and then free the content. The buffer+= thing is good to know but I'm only using it once per loop iteration since it only happens during one condition and I use strlen(buffer) to find the number of bytes I need to copy. Is using strlen safe though or could it give me an out of bound number since I'm directly changing my buffer pointer position?
Never mind my stupidity I started having segmentation faults so I used a second pointer instead of using buffer+=.
If you want to avoid such problems later on I'd strongly recommend using programs like valgrind. They can point out various problems like referencing memory you shouldn't reference(out of bound errors) and memory leaks amongst others.
Not a problem, I'm always happy to help :) The fgets call should fail at some point, since you use BUFFER_SIZE so you always have a max size of a 512 byte string ;) I'm guessing it didn't fail because you don't have very long lines, so you need lots of iterations before the buffer points to a piece of memory to small to store the line. strlen will fail if you give it a pointer that points to memory you simply don't have access to (Which with a big enough config file, assuming fgets doesn't fail before that, you'll run into eventually with your additions). Either way, I saw your comment down below and using a second pointer is what I'd recommend. Just keep one for the buffer and one for your temporary manipulations and you're good to go. If you want some more speed and a bit easier time, using an array of chars is really the way to go here since it'll be allocated on the stack: char buffer[BUFFER_SIZE], *tmp_ptr; /* code */ while (fgets(buffer, BUFFER_SIZE, settingsFD)) { tmp_ptr = buffer; /* code */ } /* Stack allocated, no free() call necessary for buffer */ In *general* I try to use arrays instead of dynamic allocating whenever I can, some things lend themselves better to dynamic allocation though. Reading lines from a file is somewhat borderline. Since you use fgets which requires you to specify the buffer size, you don't need to worry about fgets creating a buffer-overflow as long as the buffer size is right. If you look at the fgets docs though, you'll see that if fgets can't fit the entire line into the buffer, it simply reads a full buffer length and then continues the line on the next call. I've never actually tried checking it, but since fgets adds the '\n' (Or "\r\n" if you're on Windows), you could check if strlen(buffer) is equal to BUFFER_SIZE, and if so check if the endline is at the end. If you don't have an endline (And you didn't get an EOF), then your line was to long and was split. I personally don't know if it'd be worth bothering to do that check though, fgets won't fail either way so your parser will still work, it will just read a few invalid lines. Also, some useful info, this is the valgrind line I ran to test the program: valgrind --leak-check=full ./ctest (Where ./ctest is the program to test). Overall the output is fairly obvious. If you compile with debugging info enabled (The "-g" flag for GCC) then valgrind can even give you line numbers if stuff like seg-faults happen.
i'm not sure that you can do anything even if had the sourcecode, since UI mods and character appearance is basically just swapping a few image files. the best you can maybe do is to mess around with deeper settings from some internal settings (those can be pretty extensive, think skyrim) but really noting like this has to do much with any programming, if you want something you can mod you should choose an open source game, or something with extensive modding support.
Also, in this code: void cpyString(char** dest, char* src) { *dest = (char*) malloc(strlen(src) + 1); *dest[0] = '\0'; strncat(*dest, src, strlen(src)); } I think you meant: (*dest)[0] = '\0'; Actually both pieces of code have the same effect because `*dest` and `dest[0]` are the same, but it's confusing to the reader (and suggests you might have made the same precedence error elsewhere where it does actually matter). 
In terms of style recommendations, I would replace else if (strncmp(buffer, "start time:", 11) == 0) { buffer += 11 + getNextCharPosition(buffer + 11); strncpy(nbBuffer, buffer, 2); cfg-&gt;startTimes[i][0] = atoi(nbBuffer); strncpy(nbBuffer, buffer + 3, 2); cfg-&gt;startTimes[i][1] = atoi(nbBuffer); } with else if ( memcmp(buffer, "start time:", 11) == 0 ) { char const *buf_ptr = buffer + 11; buf_ptr += strspn(buf_ptr, " "); cfg-&gt;startTimes[i][0] = read_int(buf_ptr, 2); cfg-&gt;startTimes[i][1] = read_int(buf_ptr+3, 2); } where `read_int` is a function you make, whose function is hopefully obvious. As someone else pointed out, you don't want to muck around with `buffer` because it needs to be freed later. In fact, it seems to me that just using automatic allocation for `buffer` would be preferable to `malloc`. Note that this code still has a buffer overflow if the input were "start time: 1", etc. If you are writing code that is not just a throwaway program, where it's important to not have buffer overflows, then you should also protect against this, e.g. add in just before the call to read_int to check that there is no null-byte in the next five characters. 
what about range-finders and such? 
that is doable, but that's more like classical cheating than anything, and that isn't really a modification for the game. it is often done be looking out for variable changes in the memory space of the game that correlate to character movement, after that you know it's environment it's easier to get the values after that. But that's pretty much cheating as i said, and if that is somehow detectable by the client than you might get banned (anti-cheating systems can be pretty strong, some even ban players who use mouse macros).
The Sun compiler collection has supported c99 since about 2006 or so. gcc and clang have supported it for quite some time. Inline declarations was a gnu extension for even longer (going on 15 years now?). There is nothing wrong with inline declarations and you have to try pretty hard to find a compiler that doesn't support it these days.
Never typedef structs. It makes the code much harder to understand and follow.
The C# designers wanted to discourage raw pointer usage as much as possible. The framework accomplishes some pretty amazing sorcery by using exclusively managed resources. By using raw pointers you run into issues with relocation (e.g. you use raw pointers to a buffer but the framework can relocate that buffer whenever it wants). This could cause some very nasty non-determinant bugs. If you want to use raw pointers, you have to jump through several hoops to make sure things work (mark methods that use these pointers unsafe, and the pointers themselves as fixed). 
Never is a strong word. K&amp;R would disagree with that statement. typedef struct Context { ... } Context; Now you can use struct Context *ctx = (struct Context *)malloc(sizeof(struct Context)); or Context *ctx = (Context *)malloc(sizeof(Context)); Throw in a simple plugin for vim that shows me the expanded type and I'd take the second example any day. I know Linus does not like typedefs as well so I follow that rule for kernel development but I'll push for typdef'd structs on other things I work on.
Need more articles like that.
I know that it saves keystrokes, but i hurts readability tremendously. Your code should be readable as-is without any fancy plugins. Everybody can't install and use the same plugins you do. The linux CodingStyle is correct here. Looking at the code, you have no idea what "ctx" is. It could be a pointer to anything. I've personally been bitten by APIs that externally defines a typedef to void for a pointer type (and internally uses the correct struct type), which in reality disables basically all typechecking for the users of the API. If I had known that it was a braindead void* typedef, I would have used it differently. The keyword "struct" adds a lot of information, and is not long enough to be a nuisance. Quoting the chapter 5 of the linux kernel CodingStyle: &gt; Please don't use things like "vps_t". &gt; &gt; It's a _mistake_ to use typedef for structures and pointers. When you see a &gt; vps_t a; &gt; in the source, what does it mean? &gt; &gt; In contrast, if it says &gt; struct virtual_container *a; &gt; you can actually tell what "a" is. By the way, malloc() returns void*, so you should never cast the return value from malloc(). It hurts readability and is unnecessary because that exact type conversion is implicit and happens anyway.
&gt;I would put spaces on both sides of my binary operators (like =) Oh this takes me back to my really early days of programming in C. I was working on a piece of code and the compile was failing telling me I had an error at a line that I could not figure out. Took me a few hours to figure out the error was being caused higher up because I didn't use whitespace. As I recall the code looked something like: int doSomething( int *foo ) { int bar; bar=someValue/*foo; *foo=somethingNew(bar); if( *foo==someXValue ) return 0; return 1; } void otherFunc() { int x=5; /* should change X to something new */ if( doSomething(&amp;x) ) &lt;&lt;== error was listed as here doSomethingElse(); } This code is just a sample to show the problem, at the time there was valid reason for the approach but damned if I can remember what that was. Anway, the compiler said the error was occuring at the call to **doSomething** (marked with the &lt;&lt;==) because in the **doSomething** method, the line bar=someValue/*foo; started an open comment with the /* that didn't close until the * / in the **otherFunc** call. In the actual code, as I recall, the first closing * / was dozens of lines below the open not this close. Commenting wasn't a strong point either. Since then I've always put white space around operators bar = someValue / *foo; 
Thanks! Really good article.
 #define time_code(A) \ gettimeofday(&amp;start, 0); \ A ; \ gettimeofday(&amp;end, 0); \ printf("Time: %lld seconds\n", timediff(start, end)); //now declare struct timeval start, end at the top of your program :) Use backtick (`) or four spaces at the start of the start of the line to translate stuff into code. I also never feel comfortable with multiline preprocessor defines without wrapping them in do/while(0): #define time_code(A) do { \ gettimeofday(&amp;start, 0); \ A ; \ gettimeofday(&amp;end, 0); \ printf("Time: %lld seconds\n", timediff(start, end)); } while(0) edit: to use backtick, wrap code in them: \' code \' -&gt; `code` edit edit: backtick, not backslash
You're right about the do-while, I completely forgot that.
First, if you overlay a struct over memory you have to make sure to turn off data structure alignment, which needs to be supported by the compiler. You can't have variable length structs (with the exception of flex arrays, but they have too be the last member). You can parse the data into a separate struct which has a data pointer to the packet buffer with the correct offset. If that is not possible due to memory limitations you could have functions like pkt_get_checksum() that operate on the packet buffer and would have to do some address calculations every time it's called.
This is for timing specific sections of your program, not the entire thing.
Backtick, \ is a backslash
You could try buffering the received/sent data in the array inside your interrupt function. You could later fit it into the struct/union in a non-interrupt context. My approach to UART has been something like this: void UART_Interrupt(void) { static int counter = 0; UART_buffer[counter++] = UART_RX_REGISTER(); CHECK_COUNTER_OVERFLOW(counter,UART_BUFFER_SIZE); UART_buffer[counter] = '\0'; } Then modify a copy of buffer to your will in the main function
That makes sense, thanks.
Good article, but it's not completely a lost art. I went into this article excited to learn something new, and found I didn't really learn much. I already knew the meat of what you were getting at.
if you use a pointer to the content in the struct instead of an array you pretty much got what you wanted. You have to keep in mind that structs don't exist for the computer,it's just there to help the programmer, i list of pointers essentially. But i would no do it, not even close. this suggest that these messages will get dynamically allocated memory, which is one thing to avoid if you have little memory, i don't know how limited you chip is and how the UART is implemented or what kind of data you parse but what i'd do is make a ring buffer instead for the messages and process them as soon as possible, that is the best option if we are talking about under a few kilobytes. My advice could be misleading since i don't exactly know what kind of and how much data it have to process how fast and how often.
Normally, the variable width data field comes *last* in packets for precisely this reason (so you can overlay a struct in the same memory area using compiler-specific extensions). What protocol are you trying to parse? Oh and by the way, don't typedef structs. It makes your code harder to read because you don't know what "Packet" is in your code later on without looking up the declaration. Write out the "struct" keyword, it's important. EDIT: Considering this is correct, I wonder why this is being downvoted. It almost sounds like OP has invented his own protocol, in which case this problem should be approached differently than what he is asking. If this is a standard protocol, perhaps the protocol designers had a different solution in mind and the parsing should be done differently. It's a valid question.
We used C++ and the MPI libraries at the last company I was at, worked great. Sounds like hadoop is overkill for what you need, and java.
I know this is C_programming, but have you looked at [Thrust](http://docs.nvidia.com/cuda/thrust/)? It's a C++ template library that leverages nVidia's CUDA technologies in nVidia GPU's. It was built on top of CUDA subroutines for map reduce stuff to be easily coded and distributed on simple, and (relatively) cheap consumer grade hardware. The code is easy; it's not so bad to get started, but there's a learning curve (especially if your not big on map-reduce theory). But it is a **beast**; and I'm only running it on a GTX 660. Good luck!
Thanks for your answers guys, this is still way too low-level for me but I think I get the big picture now. The wrong assumption I made was to think that the code injected would be C, which didn't make sense in my head.
What size is the workload? Do you have many other similar problems to solve?
Here's one of my favorite explanations of how buffer overflow exploits work:http://insecure.org/stf/smashstack.html 
To put things in layman's terms, `machine instructions` and `data` are both represented by `1`'s and `0`'s, so your program might execute the `data` as `machine instructions`.
Use enum for constants, because debuggers usually know the values of those but don't know the expansions of #define macros.
Another common tactic, especially on systems where modules aren't loaded at random addresses, is to fill up both the "too small" buffer and the "padding" buffer with garbage, and then for the saved return address, give it an address which I will describe shortly, and then add in all the code to inject. Once the function returns, it will pop your modified address off the stack (which I haven't described yet), and then jump to it. At this point, rsp (stack pointer) is pointing to the start of your injected code. So all you need to do is somehow set the instruction pointer to rsp, or perform the asm instruction "jmp rsp". As it turns out, "jmp rsp" (and "jmp esp" in 32bit mode) is made up of the bytes 0xFF 0xE4. So all you need to do is find that byte string within a module loaded when your target program is loaded (on Windows, ntdll.dll, kernel32.dll, and user32.dll are common targets), even if that byte string doesn't correspond to an actual "jmp rsp" instruction, and put that address into the injected data in place of the saved return address.
Redis is short, clean, and has a great community: https://github.com/antirez/redis
What you want to do is generate a number that is within the limits of your array indices and then use that to access the array. Repeat as necessary. It'd be easier to use just one big array with all the symbols by the way.
Hint 1: the identifiers ``lowercase``, ``upperCase``, ``num`` and ``symbol`` appear only once in your code. Usually variable names appear at least twice, once where you define the contents of the variable and *at least* once where you use them. Hint 2: you code does not compile with ``-Wall``: genpass.c: In function ‘genPassword’: genpass.c:5:24: warning: multi-character character constant [-Wmultichar] genpass.c:5:2: warning: overflow in implicit constant conversion [-Woverflow] genpass.c:5:35: warning: multi-character character constant [-Wmultichar] genpass.c:5:2: warning: overflow in implicit constant conversion [-Woverflow] genpass.c:9:1: warning: implicit declaration of function ‘srand’ [-Wimplicit-function-declaration] genpass.c:9:1: warning: implicit declaration of function ‘time’ [-Wimplicit-function-declaration] genpass.c:9:12: error: ‘NULL’ undeclared (first use in this function) genpass.c:9:12: note: each undeclared identifier is reported only once for each function it appears in genpass.c:9:1: warning: implicit declaration of function ‘rand’ [-Wimplicit-function-declaration] genpass.c:9:1: warning: implicit declaration of function ‘printf’ [-Wimplicit-function-declaration] genpass.c:9:65: warning: incompatible implicit declaration of built-in function ‘printf’ [enabled by default] genpass.c:11:1: warning: implicit declaration of function ‘system’ [-Wimplicit-function-declaration] genpass.c:6:7: warning: variable ‘randChar’ set but not used [-Wunused-but-set-variable] genpass.c:5:7: warning: unused variable ‘symbol’ [-Wunused-variable] genpass.c:4:6: warning: unused variable ‘num’ [-Wunused-variable] genpass.c:3:7: warning: unused variable ‘lowercase’ [-Wunused-variable] genpass.c:2:6: warning: unused variable ‘upperCase’ [-Wunused-variable] Hint 2a: The "multi-character character constant" warnings are due to '£' and '€'. Finding out why would be instructive. Hint 3: (Security related) the pseudo-random number generator ``rand()`` is not defined to be cryptographically secure and may well be some form of linear congruential generator. Your ``% 70`` is using approximately the 6 or 7 low-order bits. From https://en.wikipedia.org/wiki/Linear_congruential_generator &gt; The low-order bits of LCGs when m is a power of 2 should never be relied on for any degree of randomness whatsoever. Indeed, simply substituting 2n for the modulus term reveals that the low order bits go through very short cycles. In particular, any full-cycle LCG when m is a power of 2 will produce alternately odd and even results.
&gt; It'd be easier to use just one big array with all the symbols by the way. And then remember that a big array of characters is exactly what a string is.
I wanted to have a look at Lisp anyhow. ( And hopefully some time in the immediate future.) So I would like to volunteer. My level of C experience is somewhat intermediate, I have written quite a bit in C but I need a lot of time until I could really call myself a veteran. 
I'd be interested in giving it a read (moderately experienced embedded developer here). Functional stuff always appeals, but I never have time to try it...
Sounds interesting, would love to give it a read and see what I could help with.
I'm interested. I've got solid C experience and I know Lisp forwards and backwards, having written two toy implementations ([Wisp](https://github.com/skeeto/wisp) interpeted, [BrianScheme](https://github.com/skeeto/brianscheme) compiled) and studied two others' sources in depth ([S9ES](http://www.t3x.org/s9book/index.html) with a book like yours, and Elisp).
Would love to help you out with suggestions and/or corrections, if any. :) I'm a BSc CS student. 
Please count me in. I was thinking of writing a lisp interpreter as a learning experience anyway.
Workload size - several minutes to several days up to several months if we get ambitious. Pretty unbounded as far as time goes. In the short term, we don't need anything too fancy, but in the long term, a sort of "resume processing" feature has been requested. If under "similar problems," a desire to run "different approaches" counts, then yes. Not sure outside of this project if making everything a library will be useful. However, I think it would help with being flexible for the different approaches we are going to try. It also would keep the code more simple in the long run. Separation of control logic and application logic, essentially. Do those answer your questions? Were you looking for something else?
I am an ancient programmer, have forgotten most of what I learnt, but am also experienced at editing and proofreading in many areas. I too would be willing to have a look - not at the technical aspects but at the writing. 
Sounds interesting, count me in. I've played with C and Scheme before. Also a BSc CS student.
I'm trying to learn C,and I would be happy to read your book.
My guess is your view on typedef'ing structs resulted in the downvotes. It's a perfect little holy war I hear from time to time because everyone has a personal preference but arguments from both camps are weak at best :)
Good article. While simpler, in my own experience there are a couple of problems with relying on a root stack as shown. First, its error prone and a bit cumbersome. It's easy to forget to push onto the stack before allocating again. It also forces you to tease expression apart so that a stack push occurs between allocations. For example, imagine you were building a linked list. This, Object cons(Object, Object); Object list3(Object a, Object b, Object c) { return cons(a, cons(b, cons(c, NIL))); } Becomes this, Object list3(Object a, Object b, Object c) { Object cons1, cons2, cons3; cons3 = cons(c, NIL); push(cons3); cons2 = cons(b, cons3); push(cons2); cons1 = cons(a, cons2); pop(); pop(); return cons1; } Second, you've limited your VMs evaluation semantics. For most languages this isn't a problem, but for a language that supports continuations (Scheme) or threads (both green and kernel) it will be. Under these two paradigms objects are not always popped in the same order they were pushed, due to multiple ways a call stack could unwind (continuations), or due to having multiple call stacks (threads). The solution to both these issues is to have the garbage collector scan the call stack so that anything on the call stack is a root. However, this technique is tricky to pull off, especially in a portable fashion. 
https://github.com/morpheusbeing/password - this is my attempt for creating passwords - have a look, and pull it to pieces.
I'd be very interested in this.
Always fun to [golf](http://codepad.org/YXbO6924): char pass[10]; int i; srand (time(NULL)); for(i = 0;i &lt; sizeof(pass);i++) { pass[i] = '!' + rand() % ']'; } printf("%s\n",pass);
&gt; function pointers are usual pointer variables and nothing special in anyway Except they *are* special in that unlike pointer to object types, there is no guarantee that they can be represented by `void *`. Pointer arithmetic is also not defined anywhere in the C standard for pointer to function types. 
I don't think it's very helpful or useful to repeatedly write examples that use the `(*foo)(arg)` style of calling function pointers, as opposed to the much more idiomatic `foo(arg)`. The difference is only mentioned in passing, and only in a comment in an example, not in the text. Moreover, the examples are inconsistent about which form to use, as they use `(*foo)(arg)` for the first several examples and then switch to the second form when the example uses an array (`arrayFp[0](a, b)`). If I were a beginner I'd find that terribly confusing. Use `foo(arg)` consistently in every example as that is idiomatic, and only mention `(*foo)(arg)` as a footnote. 
I'm in !
&gt; To put things in layman's terms, machine instructions and data are both represented by 1's and 0's, so your program might execute the data as machine instructions. Are you saying that any data (which I am assuming is input from the user) when written into the appropriate memory location can be executed by the processor? So, theoretically if you overflowed an array and wrote some code in the precise location of where a return statement would occur the processor would execute that code? Forgive me for my noobness but that is what I gathered from all of this. 
Correct.
regardless function pointers are very useful for some tasks(modularity and dynamic load of code) , this practice is used more and more this days, excessive use, for me, can lead to "javascrifycation" of your C code. something that we can see clearly (in c++) with libraries like ASIO and function bindings.
Thank you Rhomboid, will incorporate your comments in next upload. Thanks much again!
will update the text in next upload, thanks dreamlax!
That's **exactly** what a *buffer overflow* is. A malicious user would overwrite the return address with the start of the buffer, and the buffer would contain machine instructions that the program was not designed to execute. So instead of returning to the calling function as one would expect, the program returns to a wherever you specified it (preferably a large buffer that you can fill with machine instructions) and continues executing from there.
&gt; The code shouldn't be the problem since when I compile, it shows no mistakes. I remember when I had similarly optimistic thoughts :).
http://i.imgur.com/cgsgRjO.png if its any help
So it looks like what happened here is you called scanf with arguments it wasn't expecting (scanf arguments are not checked as strictly at compile time like most functions) and crashed, and then windows reported the problem to you because it occurred at runtime not compile time. Because it occurred at runtime wxdev could not have easily known that it would crash. In general just because it compiles doesn't mean there are not language usage errors. In fact proving a program does what it advertises without fail is a very time consuming problem even for short programs.
I read an article recently that showed that arbitrarily forcing alignment caused more problems than it solved in pipelined processors like the current Intel/AMD offerings. So there is some mis-information/incorrect information in this article that might not be up to date for all architectures. How Misaligning Data Can Increase Performance 12x by Reducing Cache Misses http://danluu.com/3c-conflict/
So, a person can literally put assembly into the beginning of the buffer and the processor will run that code? That just seems ridiculous... After reading there is a difference between assembly and machine instructions. Would you input opcodes/machine instructions or assembly directly into the program to change the programs behavior. I would imagine it would have to be the opcodes or the machine instructions directly since assembly has to be converted to machine instructions. Any further insight would be greatly appreciated.
No, not assembly code, assembly code is higher level than machine instructions. But you can inject machine instructions that do what your assembly code would do (basically by writing bytes instead of regular characters). Most processors have specific instructions for each assembly instruction so I guess you're half right though.
So, a specific byte refers to a specific instruction for a certain processor. I recall reading and not comprehending something like that at one point but that kind of makes sense now. 
[Pretty much, this should clear it up.](http://en.wikipedia.org/wiki/Opcode)
*Excerpt from linked Wikipedia article about* [***Opcode***](http://en.wikipedia.org/wiki/Opcode) : --- &gt;In computer science, an **opcode** (**operation code**) is the portion of a machine language instruction that specifies the operation to be performed. --- [^(about)](http://www.reddit.com/r/autowikibot/wiki/index) ^| *^(/u/obscene_banana can reply with 'delete' if required. Also deletes if comment's score is -1 or less.)*
&gt; GZIP support is enabled on the server side. What do you mean by this, exactly? It's very common for a web server to be configured to use gzip for *outgoing responses*, but exceedingly rare for a server to be configured to use it for *incoming requests*, if it even supports it. I would imagine that many servers don't even support that. Are you 100% absolutely sure that the server you're using even supports this, and if so, that you've actually enabled it for requests and not responses? 
PM sent.
Indeed it would. You are using scanf incorrectly as noted in the compiler output I posted. You're providing a format string to scanf consisting of the letters "%d, &amp;nbMph" but not a variable to write the result into. As a consequence, scanf writes the result to an unknown region of memory which, unsurprisingly, creates failure. Compare your line: scanf("%d, &amp;nbMph"); to what I suspect is the correct line: scanf("%d", &amp;nbMph); Ask yourself: "how does my version differ from the correct one and why does it not work". If you have difficulty seeing how your version is different, ask a member of teaching staff to explain it. The remainder of your code has similar mistakes.
&gt; expected something from wxdev to tell me something was wrong, If it were possible for a program to magically find all bugs in code, there wouldn't be bugs. Unfortunately we're not yet at that stage of technology. 
Sure, but then suddenly the structures in your headers would not correspond to the structures in memory... making your headers useless.
Maybe you didn't read into the article too closely, because it mentions exactly that. Enough unaligned access might yield better performance due to better cache performance, especially if the mis-alignment exploits locality.
The musl C library was designed for exactly this kind of thing.
I'd be interested in reading through as well. 
Not if the compiler did it consistently each time it encountered the same struct and all declarations had the pragma on them.
Well, there are things like platform calling conventions that dictate how this "implementation-dependent" thing is supposed to be implemented. 
&gt;I am trying to remove the pointer I passed into the function/procedure. For a singly-linked list, you can't do this without some other trickery, like actually using an array to manage the list elements, which would kind of defeat the purpose of a linked list. It's much easier for a doubly-linked list, where each element not only has a pointer to the next element, but also to the previous one. Also, this line looks very strange: &gt; entryToRemove = entryToRemove + 2; I guess you want the entry after the next one? For one, this would be entryToRemove-&gt;pointerToNextEntry-&gt;pointerToNextEntry assuming that `entryToRemove-&gt;pointerToNextEntry` is not a null pointer. Second, after your `+2` line, you will have a pointer that points to a memory location that might not even contain an `entry`. It might not even belong to your program, and that's a recipe for a crash. And finally: while(pointToFirstEntry != (struct entry *) 0xcccccccc) Please tell me that wasn't printed in the book you are using.
Rules for deleting element form linked list are thus * navigate the list until the element-&gt;Next equals the target to remove * create local pointer and set it to the target * set the element-&gt;Next equal to the target-&gt;Next (don't worry if it is null, as this means the target was at the end of the list) * Free the memory held by the local pointer, do delete the target
&gt; You can't remove an entry from a singly-linked-list unless you actually have the full list. What about this? It's removing from any (sub-)list with a single pointer to any node. struct list { int data; struct list *next; }; void list_insert(struct list **ref, int data) { struct list *node = malloc(sizeof *item); node-&gt;data = data; node-&gt;next = *ref; *ref = node; } struct list **list_find(struct list **ref, int n) { struct list **p = ref; while (*p &amp;&amp; (**p).data != n) { p = &amp;(**p).next; } return p; } void list_remove(struct list **ref) { struct list *node = *ref; *ref = node-&gt;next; free(node); } void list_test() { struct list *p, **q, *numbers = NULL; list_insert(&amp;numbers, 2); list_insert(&amp;numbers-&gt;next, 3); list_insert(&amp;numbers, 1); list_insert(&amp;numbers-&gt;next-&gt;next-&gt;next, 5); list_insert(&amp;numbers-&gt;next-&gt;next-&gt;next, 4); for (p = numbers; p; p = p-&gt;next) { printf("%d ", p-&gt;data); } printf("\n"); list_insert(&amp;numbers-&gt;next, -2); list_insert(list_find(&amp;numbers, 5), -5); for (p = numbers; p; p = p-&gt;next) { printf("%d ", p-&gt;data); } printf("\n"); q = list_find(&amp;numbers, -2); list_remove(q); /* remove using pointer to tail of numbers list */ q = list_find(q, -5); list_remove(q); for (p = numbers; p; p = p-&gt;next) { printf("%d ", p-&gt;data); } printf("\n"); }
&gt; Also, this line looks very strange: entryToRemove = entryToRemove + 2; The reason I did this was because I needed to get to the first item in the linked list. The above code allowed me to change the address to which entryToRemove pointed to. Example: If entryToRemove's memory address is 0x0055ca83 when I added 2 to it, it gave me 0x0055ca73 which is the address to the first item in the linked list. From there I changed entryToRemove-&gt;pointerToNextEntry to what entryToRemove-&gt;pointerToNextEntry had pointed to. Which completely removed it from the list. &gt; Please tell me that wasn't printed in the book you are using. My book doesn't use that syntax. That is something I came up with since the following didn't work: while(pointToFirstEntry != (struct entry *) 0xcccccccc) Should be: while(pointToFirstEntry != (struct entry *) 0) I am pretty sure that was just my compiler and I had spent 3 hours working on all of these exercises and didn't bother trying to change the settings in Visual Studio.
&gt; I think he is misinterpreting the project description. It's asking him to remove the NEXT entry from the given entry. You are 100% correct. I did misinterpret the exercise but that is why I said I am going to take this a step further and try and remove the entry I am pointing to. I realized it when typing out the problem here that I had made a mistake. I was just curious to see if there was a way to do what I was doing in the above code better. I haven't had the opportunity to try and implement this in the way that was intended but I have a feeling it will be much easier than what I did. The problem with what I was doing was that, I have no way to reference the address before the entry pointer I passed to my function. I managed to make this work only because I was able to change the address of entryToRemove using some simple math. Honestly, this was just me being curious and seeing if there was a better way to do what I just did.
&gt; You are 100% correct. I did misinterpret the exercise but that is why I said I am going to take this a step further and try and remove the entry I am pointing to. This is not possible. The logic involved in removing entry `A` is: - Entry before `A` needs to point to entry after `A` However, in your list you have no way of finding the entry before `A`. The list , and the function to remove an entry, is designed this way on purpose. 
&gt;You can't remove an entry from a singly-linked-list unless you actually have the full list. Yes you can, you just need the pointer to the parent of the element you want to remove. Plus a special case for removing the first element. 
 if (!entryToAdd-&gt;pointerToNextEntry) { entryToAdd-&gt;pointerToNextEntry = (struct entry *) 0; } This code has no effect. The expression `!entryToAdd-&gt;pointerToNextEntry` tests if the pointer is a null pointer. If it's already a null pointer then you set it to a null pointer, i.e. no change. The `insertEntry` function needs the following logic, to insert node `C` in between `A` and `B`: - `C` needs to point to `B` - `A` needs to point to `C` If this is unclear then draw a diagram on a piece of paper. So it should be: entryToAdd-&gt;pointerToNextEntry = whereToAddEntry-&gt;pointerToNextEntry; whereToAddEntry-&gt;pointerToNextEntry = entryToAdd; 
It is possible because I managed to make it work. I do get what you are saying though. I had to manipulate the address to make it work but I guess you could say I cheated. Since I used the debugger to figure out how many bytes I needed to add to get to the entry before the one passed to the function.
Hopefully it's clear that this is a bad idea. Your "working" code would actually stop working if you did some other operations on your list first, because the nodes would be in different locations. There's no requirement that the entries in a list be in adjacent or nearby memory locations (in fact, this is one of the advantages of using a list).
&gt; Hopefully it's clear that this is a bad idea. Your "working" code would actually stop working if you did some other operations on your list first, because the nodes would be in different locations. There's no requirement that the entries in a list be in adjacent or nearby memory locations (in fact, this is one of the advantages of using a list). It is crystal clear that this is a bad idea. Honestly, I was surprised to see that the memory locations were adjacent to one another. If it were an array that would make sense but I guess since I made all of the structs sequentially that is why it happened. 
The line &gt; entryToRemove = entryToRemove + 2; is just horrible. It depends on the entries being in this specific order on the stack. Declare them globally and it'll most likely crash. If your book uses such black magic, throw your book into the bin ASAP!
I made the post because I thought there might have been a better way of doing what I did. The conclusion I have drawn is that I shouldn't do it this way at all. &gt; That makes a little more sense. Do I understand correctly that your compiler complained about this line? Maybe try this instead: The compiler complained about the following: while(pointToFirstEntry != (struct entry *) 0) I will have to compile it again when I get home to give you the error I received but it definitely wouldn't let me compile.
&gt; is just horrible. It depends on the entries being in this specific order on the stack. Declare them globally and it'll most likely crash. If your book uses such black magic, throw your book into the bin ASAP! I literally laughed while reading this reply. My book definitely didn't tell me to do this. I was trying everything I could to make it work. I read the exercise wrong and know how to complete the exercise now. The joys of being a noob.
I think the problem is that when you touch (when running make) hello.c, the target is now considered 'new' again, so anything that depends on it has to be rebuilt. Is hello.c old? Yes Ok, I'll make it -&gt; touches hello.c Is hello old? Yes, hello.c is new, goto check if hello.c is old
The problem you are running into is that your use of `make` conflicts with `make`'s built-in implicit rules. The `make` program knows, by default, how to make lots of kinds of files from other kinds of files. If you ask `make` to make a file called `foo.o`, for example, and the directory contains a file called `foo.c`, then `make` will automatically run a C&amp;nbsp;compiler to create `foo.o` from `foo.c`. The `make` program has a built-in implicit rule for this, based on the file name suffixes, and it knows what to do even if you don't explicitly tell it how to do that—even if you don't have a makefile at all! One of these built-in implicit rules tells `make` how to make a file called `foo` from a file called `foo.c`: it runs a C&amp;nbsp;compiler on `foo.c` to create an executable file called `foo`. This is an implicit rule, and by default `make` assumes this rule is valid. So `foo.c` is a prerequisite for `foo`, by default, because of this implicit rule. But in your makefile you are additionally saying that `foo` is a prerequisite for `foo.c`. This does not override `make`'s implicit rule, because you aren't providing a rule that overrides `make`'s implicit rule for how to make `foo`. So `make` has a problem. According to the implicit rule, `foo.c` is a prerequisite for `foo`. But according to a rule in the makefile, `foo` is a prerequisite for `foo.c`. This is the circular dependency you're seeing. To turn off all of `make`'s built-in implicit rules based on the suffixes of file names, add this line to the beginning of your makefile: .SUFFIXES : For a list of `make`'s built-in implicit rules, see here: https://www.gnu.org/software/make/manual/html_node/Catalogue-of-Rules.html
Ah, you've got it. I knew it was a collision with an implicit rule, but I couldn't figure out which one. That makes total sense, thanks.
Is it possible to just turn off a specific built-in implicit rule? Edit: Briefly looked through your link, would .SUFFIXES: .c be enough to solve OP's problem and just turn off the `.c` rule?
Yes, absolutely. **Hint:** Instead of using individually named variables `a`, `b`, `c`, etc to store the digits, use an array: `int digits[16]`. Now make a for-loop to loop over the (number of) digits in the credit card number. On each iteration you can do something like `digits[i] = creditcard % 10;` (assuming `i` is the index variable in your for-loop) and `creditcard /= 10`.
Ok thanks. I haven't actually learned of arrays yet, but this is a not for credit problem, so it could be that I need arrays to solve it.
It seems strange to be storing a credit card number as a long long. Wouldn't it make more sense to store it as an array of chars (i.e. a string) since it's not really a number you'd ever need to manipulate mathematically. That way you can just iterate over the char array to get each digit and subtract '0' to get their numerical values.
Like I said, I haven't learned about arrays yet, so I was trying to solve the problem without them.
 #include &lt;stdio.h&gt; #define CARD_NUM_LENGTH 16 int main(void) { long creditcard = 1111222233334444; int i = CARD_NUM_LENGTH; int cardNumbers[CARD_NUM_LENGTH]; while (i--) { cardNumbers[i] = creditcard%10; creditcard = creditcard / 10; } // check result .. for (i=0;i&lt;CARD_NUM_LENGTH;i++) { printf("%i, ", cardNumbers[i]); } printf("\n"); } 
Ok sure, but if you have a tight screw to loosen and access to a screwdriver you might as well learn how to use the screwdriver instead of making things unnecessarily difficult by insisting on using your fingers.
That's a sensible analogy.
Hi! Dev here. This is a bit of a pet project, but I haven't found very many light weight / easy to use libraries that fit this niche (I have project X that is embarassingly distributable / parallelizable but I don't want to deal with writing all of the code to distribute it). I'm aware that hadoop / gridgain might be considered as having similar functions, but to me those both feel heavy and a pain if you're not writing in java in the first place. Anyway, if something like this already exists, please point me to it. If not, cool. Either way, opinions welcome. I haven't made a C++ library in a long time, so please forgive me if there are any embarassing facts about the way it's laid out. Ease of use was my #1 goal.
/r/cpp is a thing, huh? I probably do want that. Should I delete this, or?
yes. Sorry for the pollution! Thanks!
I think it'd be really cool to see a real language that uses a simple GC like this. His blog says Lua and Ruby used to have simple GC's, does anyone know languages that still do? 
It depends on what you want to do. What do you want to do?
In so far as the languages go: pick your poison. (Warning: opinions to follow.) C is pretty simple, but you're pretty close to the machine (i.e. you're more instructing the computer in how to do something rather than describing what you want), have to keep track of your own memory usage and have to play with pointers, which can be hard to understand when first encountered. Java dumps you into object-oriented land with a lot of complex interactions between different pieces of code based on how each bit fits into the object-oriented philosophy. It provides some extra language-enforced tools for organization that you don't have in C, and does some bookkeeping for you, but there's a bit of a learning curve associated with that. C++ is an impossibly complex monstrosity in the limbo between Java and C. It combines the low-level complications of C with the object-oriented mental overhead of Java. Whether this is an advantage depends on how masochistic you are, but it has its place. That place is probably not a place for beginners though. Of the choices, start C or Java depending on your ambitions.
Thanks!
Like An_Unhigned_Door said, I would say learning either C or Java is a good place to start. Learning C will definitely give you a solid and simple understanding of the flow of a computer program without the super high level object oriented stuff. However, you may not be able to do anything "useful" right away. If it's purely to learn a language then C is the one for you. Taking more of a leap into Java will allow you to do something useful. Like, for instance 1) search through your music library 2) go to each artists' wikipedia discography page and determine which albums you are missing 4) print the output in an excel spreadsheet. That's a pretty advanced program but there is no way you would do that with C. That may be considered "useful" to you if that's what you're looking for. Honestly, I would go with C. Object oriented languages like Java and C++ add a ton of complexity that may seem overwhelming for beginners.
JMagnum86 has a good point by saying what you're interested in doing is helpful, however, you need to start with the basics and it is likely that you won't learn only a single language. This is my opinion: Learn C, or Dr. Racket. Dr. Racket, (use [this](http://htdp.org/) freely available book) is a functional language and is a very interesting way to think and I found incredibly useful (this was my first language I picked up, and I really enjoyed it). C, is something I've more recently been putting a lot of effort into, and it is extremely fun to learn. At university, we use Java (almost exclusively), and there is a lot hidden from you in Java, which is of course very nice as a beginner, but I wish I could have been forced to learn these earlier (manual memory management with malloc and free, pointers, and not having exceptions... this may not make much sense right now, but trust me, C is much less forgiving than Java). Pick up [K&amp;R C](http://www.amazon.com/C-Programming-Language-2nd-Edition/dp/0131103628/ref=sr_1_1?ie=UTF8&amp;qid=1389754584&amp;sr=8-1&amp;keywords=K%26R+C) (You can find a pdf online for free with some searching), and try your best to work through it. There is a lot of stuff you will have to learn before you can do anything useful. I am far from a C expert, but I'd recommend looking into getting either a virtual box running some linux distro, or dual boot some linux distro (or switch to linux solely if you'd like) to get gcc for easy compiling. I don't believe the actual distro matters really (although others may have a better opinion than I do), I like Linux Mint, I recently installed version 16 (petra or cinnamon I believe) and it was EXTREMELY simple to dual boot. The process consisted of downloading the image from the mint site, burnt it to a dvd, and booted to the dvd and followed the wizard. If you do decide to go with Java, I really liked [Head First Java](http://www.amazon.com/s/ref=nb_sb_noss_1?url=search-alias%3Daps&amp;field-keywords=head%20first%20java&amp;sprefix=head+f%2Caps&amp;rh=i%3Aaps%2Ck%3Ahead%20first%20java), and [this](http://thenewboston.org/watch.php?cat=31&amp;number=1) video helped me a lot with installing the jdk when I began.
To expand......you can get gcc for windows as well and it works great. Just follow an online tutorial to get it set up.
Well I learned something new today! I suppose I didn't search too much, but I remember using codeblocks for c++ a while ago and didn't like the ide approach.
Oh definitely! Once you understand how one language works and how programming works in general picking up another language is not difficult. It's just learning the syntax. Good luck!
Go with C. You can learn the whole language in that time. Not so with java.
Please. For the love of everything holy drop all of the above and learn Python (or if you *really* have a passion for the internet/user interfaces, Javascript). Learn Python until you could code it while you're asleep on a plane that's crashing. Learn Python until you can start to feel the places where Python isn't the answer to every question in that contains "What programming language should I choose". Only when you've become this level of zen with python, should you even consider learning C/C++. It will take months or perhaps a year of playing with code. You will learn computer science along the way. Things like data structures will start coming into existence. You will understand what people are talking about when they say "algorithm to do X" or "what's the run time complexity of that". At the end of your journey through Python, you will start to get into questions like "how does this blob of data represent itself on disk" or "how does the kernel know what to do with this packet I'm sending", and when you start asking those questions, only then should you consider picking up C. Or perhaps you'll just find you're so happy with the language that you're not interested in going down into systems programming and instead move on to more powerful expressive languages like Java/C#/name-your-favorite-very-high-level-language-here. I'm a *huge* advocate for bottom-up learning in computer science. I love schools that dump software engineering students into assembly programming as a weed-out course, simply because that's one of the easiest courses to tell whether a student cares about computing or not - the interested ones will hate parts or even most of it, the inexpressiveness of the language they use, the complexity of the hardware that's all nicely hidden away from them, but they will absolutely love and come alive with the knowledge that comes with understanding how it works on the inside. The problem is, dumping a student into that level of complexity *without* some kind of computer science or programming background is only likely to bore or terrify them into leaving the field, or set them back in their education by some amount of time. You need to have the ability for structured and reasoned thought and a procedural mindset before approaching that level of programming, and it's far easier to learn that at a higher level like Python (or really, Philosophy if we had an educational system that actually taught Philosophy early enough) and apply it to lower level languages like C than it is to just pick up a book on C and understand computers. So, get comfortable with Python until parseltongue is your second language, and then dive deep and learn why Python isn't the One True Answer. (Note: this rant could have used Ruby or any Lisp variant as well, as well as Javascript. The point is, learn a "gateway language" that has mostly sane behavior and syntax, and one that explains what you're doing wrong in English instead of Gnuish/MicrosoftVisualStudioese. IMO, Python is the literal definition of a "gateway language".)
When I start a project with my usual src/include folders I add one more called 'doc' and put a text file in there. Each entry is dated and contains thoughts, notes, and designs for that particular project. I used to hand write all my notes, but keeping that with projects especially remote git stuff got difficult, so that's what I do now.
I use nvAlt and SimpleNote to keep track of my notes, no matter what kind they are.
nvALT seems good, i'll give it a try. Thanks
Any time.
That's a good point actually. Python, unlike C, has easy to understand error messages and is more forgiving. You can really screw up a C program and it will let you do anything like access array indexes that don't technically exist. You've convinced me hackingdreams! Python is a great language to start.
http://www.learnpython.org is pretty decent. It contains an online compiler so you don't have to download anything.
Glad to hear it worked out.
I use a docs directory in the project I'm working on. It's versioned, accessible via the repository gui, and easily greppable from any machine I might be working on. Similar to what shinobifunk says, except I use small individual files by topic, because I think they're easier to navigate and update.
todo.txt 
I leave it open on a second monitor. If you want to refer to document you might as well refer to the source anyways. Leave a comment in the code and remind yourself where you got it from. 
If I do it by date, I can roll a new text file each week/month and store them in subfolders if necessary. Topic sounds like a good way to do it too. I'll have to try that.
I also use this method, much like the linux documentation.
I've been seeing table driven state machines for years, I've written them on several occasions. Basically, if the input is defined well enough and is discrete enough, tables can be a very clear alternative to switch or if/else block. What's fun is when you have two variables driving the state transitions; I think I once had a 2D array for the state table. Of course, in some cases the switch block can be more clear or more easily maintained. As to why the switch statement may be more popular for teaching, I think it's because it's easier for early students to grasp, and more closely reflects our thought processes when doing things in real life. Think about the rules for many board games - they're almost always described as a set of "if ... then" sentences and paragraphs. 
That's a good point. I suppose it is easier to learn switch statement logic when beginning. I have meet very experienced programmers with no knowledge of table driven state machines. People who have their MS in computer science. I wonder if any CS classes teach this method. It's just……better imo.
I like implementing state machines using functions as Mark describes [here](http://www.conman.org/projects/essays/states.html). It completely eliminates the need to maintain a table and is quite flexible. I've used something similar in a networking management app and was quite pleasant with the maintainability/extensibility.
Interesting. To me though, that just looks like taking each case condition within a switch statement and putting it in a function. Am I missing something? So basically the same thing as a giant switch statement but in function form, right?
I think most people would recommend *The C Programming Language* By Kernighan and Ritchie as a starting place for learning C. I know I would.
I've been doing this with my current project and it works pretty well. Whenever I have a thought that's pertinent to the project, even if it's just something I'll have to keep in mind when I implement a feature in the future, I make sure to check it into doc/ somewhere. Really helps me stay organized, and it's a godsend when you actually need to write the actual user-facing documentation.
In my experience the switch statement is a bit easier to debug if things go wrong and you need to figure out where they went wrong. Function pointers in a look up table can be a bit vague at times.
good question! I use http://github.com to host the code. Then I use http://code.woboq.org to index the code which would allow me to browse it and copy and paste links to the code into any text document. I use google drive to host those notes.
I got ya. Yeah the table can be stored in ROM with the const keyword but yeah, it will take a performance hit with a bunch of reads to memory. You're right about that.
Seriously, thanks for posting your solution after discovering it. Too few people bother to do this and the question becomes search engine cruft. 
Fellow software engineer here! One of the first responsibilities in my current job was the maintenance of some very nasty code that contained half-a-dozen state machines implemented using switch statements. It really was a maintenance nightmare, and the code is now too old and fragile to fix. Thankfully, the product is soon to be obsolete :) Besides poor maintainability, large switch statements can also be a bottleneck to your system, so it's probably wise to avoid this kind of state machine when implementing a timing-critical or high-speed communications protocol (USB, TCP/IP, I2C, etc). I think that the switch statement is taught because it still has many useful applications; state machines just isn't one of them.
Sometimes the challenge when learning a programming language is not so much the language itself, but actually finding fun things to do with it. My personal suggestion would be to start learning C and then get yourself a cheap microcontroller board (like an [arduino](http://arduino.cc/) or [raspberry pi](http://www.raspberrypi.org/faqs), for example). You'll find help and tons of tutorials available online. First, get a decent book on C programming for beginners, preferably one that includes a CD containing a compiler and example code, work your way through it so you have the basics, and then jump right in with some embedded programming! I think it's so much more rewarding when you can actually see your code doing something real like switching LEDs on/off, driving a motor or reading a temperature sensor. That's just my two cents. EDIT: Links /r/embedded/ 
From what I've gathered, lisp is widely used in AI fields. If you haven't looked into lisp, I recommend spending a few days checking it out. It's an extremely interesting functional language with a bunch of crazy features. As for using only C, I'm sure it's possible, but you may want to do additional research outside of reddit before committing to using only one language for a year. I personally would recommend looking into many different languages before deciding how you want to tackle the problem you're trying to solve. Once you know all the tools available to you, you can make a better choice.
Machine learning, which neural networks can be an application of, are mostly statistical models. The subject is pretty difficult by itself, so you don't want to make it needlessly harder by caring about manual memory management and other details that you have to in C. Therefore researchers (and students) generally use tools and languages that had good support for linear algebra and math in general, such as Mathlab, R and python with scipy. Now, once you understand the theory of for instance neural networks, back propagation and maybe deep learning you might want to use C or something else that allows you to compute the learning algorithms on a graphics card. But implementing ML algorithms in C is only an optimization. You get the same results with easier to use tools, which also allows for experimentation, and you really have to know what you are doing to get better performance in C.
Your best bet is to run the program in a debugger, then pause it when it freezes and look at the backtrace. That should show you on what line the freeze occurs.
Thank you so much! You have saved me so much frustration :)
Yeah, i have written a few giant state machines with nasty switch statements. *cringe* Even though I'm very good at commenting and documenting my code, trying to fix bugs weeks after was no fun at all.
Whats up with the missing "case" statements in your switch? I've never seen that syntax before, but must assume it works since your code apparently compiles.
I don't see any missing *case*, but maybe you are getting confused by their extraneous usage of labels after each one.
I think what OP is going for is handling upper and lower case, so it must be a bug, and not some syntax I wasn't aware of.
You're likely calling your function before you declare it. Please use pastebin.com and paste the full code as is next time.
I've heard that C is a great language for neural mapping due to similarity on how it implements some aspects of the language and the simarity of these implementations to how neural nets perform. I know nothing more of this matter. This was old information, so maybe better tools for the application have been created, or maybe people don't use C as much for this topic because they are feeling unduly intimidated? But for those not involved in AI, you don't hear C talked about as an AI language like you do with matlab / Mathematica / functional languages / Haskell / python. You never really hear much from those who *are* involved in AI on the matter.
The difficulty of C doesn't really "interact" with the difficulty of something like neural networks, though. There's no tricky memory management to do, no real error-handling... The only thing that would make programming a NN simpler in another language is easier access to a matrix library. If C is the OP's best language I say stick with it.
Alright, I put up the rest of the code.
Also, not trying to be pedantic, but in C, the term is function. Methods are a concept from OOP. 
Why do you write the capital S in the following excerpt of your code? case 's': //Sin S: { /* ... */ } 
Without this the user MUST enter 's'... If they enter a capital 'S' it will return an error. With this they can enter either 's' or 'S'
Did you test that? It doesn't work. You need to have another *case* instead *S*, just like this: case 's': //Sin case 'S': { /* ... */ } Those braces aren't needed but I've kept them to have the same style as your code. Check your references to know what's happening behind your *switch* statement.
[Here is some reference material.](http://www.cs.bham.ac.uk/~jxb/NN/nn.html) It does not really answer the question, but you may find it helpful anyway.
You recommend making pointer typedefs, which is generally considered poor because it makes the code harder to read. It's more readable to actually see the `*` symbol when there is indirection, then the reader understands more quickly what is going on. Instead of &gt; typedef int (*ptrToFunct)(int, int); write: typedef int Funct(int, int); and then to declare a pointer Funct *ptrToFunct; Also you consistently use this syntax to invoke a function pointer: &gt; (*pFunct)(10, 20) It seems more arcane to me than just going: pFunct(10, 20); I guess it is personal preference though. Early on, you say that `&amp;foo` is the "correct" form for taking the address of a function. But then later on you use the "short" form: &gt; functionPtr arrayFp[4] = {getSum, getDifference, getProduct, getDivision}; You should follow your own advice, whatever it may be...:) Personally I prefer not to use the `&amp;`. In the `compareStrings` example, the `char *` should be `char const *` . 
&gt;First, examine the declaration for ptrMaxFunctin in main(). &gt; int (*ptrMaxFunctin)(int, int); &gt;This declaration tells the compiler that ptrMaxFunctin is a pointer to a function that has two int parameters, and returns an int result. The parentheses around ptrMaxFunctin are necessary because * is a prefix operator and it has lower precedence than (), so parentheses are necessary to force the proper association. This explanation is not quite right. The `*` here is not an operator, it's part of the syntax of a type-name. Operators only occur in expressions. But the parentheses are needed so that the return type is not parsed as `int *`. 
There're some excellent tips in there. I really appreciate the time you spent helping me! :) Maybe you could help me once more, for my errorflags none of them seem to be working. Do you see something silly that i'm doing wrong? I can't figure it out... [Here's](http://pastebin.com/cNiGAWzy) my most recent code.
Sorry, i'll use the first errorflag as example. printf("ERROR in function 1 ***ABEND*** \n\n\nPress any key to exit"); getchar(); exit(-1); Here I am wanting to give the user a message telling them in what function the error has occurred. So, for example if the user enters a letter instead of a number there should be an error reported back to them telling them that the error was in function 1 
Well I'm going to whine, don't typedef things unless they need to be opaque, no macro soup, put args to macros in () and make it simple. I'm not trying to be mean but it shows you come from a c++ or java background.
Well you need to stop doing `exit(-1)` then. The `exit` function aborts the program then and there. 
The typedef helps in this case because it allows me to define the data structure with a single token and simply concatenate that into the function names. Putting the macro args in parentheses also doesn't play well with the preprocessor concatentation. As far as "macro soup" and "keep it simple" goes, I get that those are likely common C newbie mistakes, but I disagree that they're relevant criticisms in this case, unless there's some way to get the functionality I'm after in the OP without some pretty hefty macro use. And I discussed the drawbacks a bit in the post -- obviously this technique is not a good idea for every programming context.
There is no "return function". The `return` statement returns from the current function (to the function that called it); the `exit` function aborts the program. I think the whole error flag thing is bogus if you are just going to be handling errors by exiting. If you want to be able to recover from errors and resume your program then it might be useful. 
Why not program in C++, and restrict yourself to C and templates?
I think that's likely a better choice in plenty of cases, but I was interested in exploring what is possible in straight C.
&gt;don't typedef things unless they need to be opaque Never program C++. 
 /* 2006/09/30 - Generate a random 20 character string suitable for a password. */ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; /* This code was written for OpenBSD where random() is available. On OpenBSD random() returns cryptographically useful random numbers once initialized by srandomdev(). These functions are part of stdlib.h on OpenBSD. */ int main() { srandomdev(); int i; char c; for(i = 0; i &lt; 20; ++i) { c = (char)(random() % 94); printf("%c", c + ' '); } printf("\n"); return 0; } 
I'm using C and Emacs, so I'm also very interested in Lisp, I'm in. 
You could just use the names instead of typedef'ing them, right? Typedefing loses information and makes your code harder to read. In C, typedefs are generally evil. Basically, /u/nwmcsween is right that you should only use them if you want a completely opaque type for some reason. EDIT: This: &gt; Putting the macro args in parentheses also doesn't play well with the preprocessor concatentation. makes me think you probably misunderstood /u/nwmcsween . He meant you should put macro arguments in parameters, i.e. "MUL(x,y) ((x) * (y))" and not "MUL(x,y) (x * y)". This doesn't affect preprocessor concatenation, but it does ensure no nasty side effects when the macro is called with multiple operands: "MUL(1 + 2, 3)" will evaluate correctly in the first parenthesis form, but not the latter.
That has no relevance to what is being discussed here. You shouldn't typedef in C, except in very, very special cases (when you need special opaque types, which you should use very sparingly).
&gt;You shouldn't typedef in C No why, just a statement as though it's a fact in and of itself? Very compelling. But given your enlightenment concerning `typedef`s, I'm sure you have better things to do than reply to comments on Reddit, like apply at Microsoft, I'm sure the Windows team could use your help eliminating all the `typedef`s that you pull in with `include &lt;windows.h&gt;`.
Thanks for the tip. I will check that out.
There are two coding styles made by programmers for programmers, and are generally regarded as the two most readable styles: The [linux kernel coding style](https://www.kernel.org/doc/Documentation/CodingStyle) and the [BSD coding style](http://www.freebsd.org/cgi/man.cgi?query=style&amp;sektion=9). You shouldn't look at what Microsoft uses; their styles are not as readable by programmers, because they're generally designed and/or enforced by non-programmers. For example, remember Microsoft invented and used [Hungarian notation](https://en.wikipedia.org/wiki/Hungarian_notation), the best way of filling your code with crap that doesn't add any new information. If you want to find out for yourself, try reading the BSD or linux kernel code: They're surprisingly easily understood and readable without many comments, because the code is very descriptive in itself. Regarding typedefs, there are seveal reasons, but I think the linux kernel CodingStyle puts it best: https://www.kernel.org/doc/Documentation/CodingStyle Look at "chapter 5: Typedefs". In short, the problem is that you don't really know what the type is when you use it. I myself have been bitten by library APIs which typedef void pointers (thereby disabling all type checking). There are reasons when you should use them, but they are so few you'd do best to regard them as generally evil. The BSD coding style tells you "Avoid using typedefs for structure types. Typedefs are problematic because they do not properly hide their underlying type; for example you need to know if the typedef is the structure itself or a pointer to the structure.[..]" (you need to ctrl+f for "typedef"). You should listen to them, because they're the two largest open source projects with tens of thousands of people churning through their code daily, and most of humanity's top-most and best programmers are involved in them. They've designed coding styles that work, for programmers by programmers, by long experience. Their code need to be extremely simple, readable and easily understood. Strive for that, and you will have it a lot easier in the long run. Look at the code yourself.
Thanks for the helpful tips. On putting the macro arguments in parameters, consider "#define TYPED_STRUCT(NAME, T) NAME ## _ ## T". This breaks when changed to "#define TYPED_STRUCT(NAME, T) (NAME) ## _ ## (T)". And while avoiding side effects is definitely important in macros where order of operation can easily affect the result, is that as much of a concern in macros which are simply pasting tokens together? Nonetheless, I did manage to find a few places in the code where the args could be put in parens, mostly in the _Generic selections. I've updated the Gists with those changes. I will also take a crack at taking out the typedefs, but here's an example of what I'm worried about with that approach. Say I have a new type 'struct somestruct'. In declaring the typed 'set' functions I'll have: chkd_array_int_set() chkd_array_float_set() chkd_array_somestruct_set() i.e., I will have to have different macros for splicing together function names depending on whether or not they are primitive data types. But that might not be so bad a thing. Taking the typedef off the chkd_array itself might be fairly straightfoward as well. FWIW, while I was working on this I did crib some style from the C Container Library: e.g. http://code.google.com/p/ccl/source/browse/trunk/listgen.h ... I should probably add it to the post acknowledgements as well. EDIT: Taking out the typedefs turned out to be pretty straightforward. I just added a third parameter to the XX lists so that the actual type and the name of the type (for splicing into functions or structs) could be specified separately.
As someone "in the field," I can confirm your instructors' opinions: most people have terrible programming habits. The best source of proper habits I've found is [Code Complete, by Steve McConnell](http://smile.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670). 
"Bad Habits" come from laziness, time, and planning. Namely the lack of both. "Acceptable Habits" come from restrictions in the environment. Some time based bad habits will fall into here. There are also perfectly fine programming habits that give CS majors conniption fits until they realize that it actually is a completely correct thing to do (like proper use of 'goto'). I assure you that you will develop all three once you are in the professional world :D For now, just practice commenting well, writing good documentation, and writing clear, understandable code. No matter what you write someone will eventually have to look at it and understand what it is supposed to do, what it actually does, and why it does it that way (note, that the first two can and will be different much of the time). Whether it is for fixing bugs, adding features, or replacing it whole cloth, someone is going to be reading the code and the easier it is to understand what you were thinking when you wrote it, the easier it will be to deal with. Aside from that, keep the code tidy, organized, and consistent. Beautifiers can clean up some mess, but don't rely on them and they can only do so much. Use reasonable variable and function names and try not to reuse them for other variables/functions that may be similar but not quite the same (last project I worked on had a 'erase' function for 6 different derived classes and each one worked differently.... don't do that unless their is really good reason. And document the hell out of it) Edit: At a previous job I liked to argue that there is a spectrum between 'pure math/academic programming style' and 'fuck it. it works' programming style. 'Production/Shippable code' falls somewhere in between the two. You aren't going to write perfect code with layers upon layers of abstraction; it takes too long and it really is a pain to maintain outside of special circumstances. You might occasionally write 'fuck it' code, but this will only be for short term, ugly solutions that you pray to god will get rewritten in a week (they won't. I promise :D). That middle ground will take some finding; where the code is a little bit ugly because it was written fast and it's fixing problems that no one knew about at first, but still has a bit of clarity and abstraction and the blocks just seem to work naturally together. It might require working on different teams (both good and bad quality) that can help get you there, but it's a beautiful spot to be once you land there.
I agree with all your points save the first. There are times when extern statics are required, and cannot be avoided. When you are looking at real time controllers or handling semaphores at ring 0 when they are the correct answer.
I've realized that once a piece of code works I don't touch it for the rest of the program. I can see now where that will cause problems in the long run. When it comes to variable and function naming, would short names be better than longer ones? I've found that my variables end up with somewhat descriptive, but short name such as "SideA", or "VeloLeft".
Read [this](http://arxiv.org/pdf/1210.0530v3.pdf) - (It's not just for scientists) 
My instructor says "Comments are almost more important than the code itself." After reviewing a fellow classmates code I could see what he meant by that.
I think I'm going to print this out, and pass it around the computer science department. 
That would be another rule: avoid side-effects. When your sort() function formats the data, it is a side effect. It becomes impossible to separate the two operations. Format may be an expensive operation, and if it's not required, is wasteful. Better would be to have sort() and format() functions. Not so good is to have sort(bool formatData). You end up with designs that look like doStuff(bool sortData, bool formatData, bool calcAddresses, bool doMoreStuff, ...). Better to have sort(), format(), calcAddresses(), doMoreStuff(), and have doStuff() call all of those. It drives me bonkers when I call a co-workers sort() function, and it's doing things like making database connections ಠ_ಠ 
&gt; It's also about as much as you should need to reason about at any one time. I think this is the essence of many best practices. For instance, one reason (mutable) global variables are bad is because you have to take every use into consideration when adding or changing code. If you're making a small command line utility with less than a few hundred lines of code it can be manageable to store a shared data structure in a global variable, but the larger the scope of the variable gets the harder it is to reason about. In the same vein: be consistent in code formatting so your eyes don't have to readjust all the time; make short functions for a single purpose with as few assumptions on the rest of the code as possible so the reader's context is minimal; and turn related and tightly coupled functions and data structures into a module with a simple interface. They're basically all saying "write code that can be understood in isolation".
On the last point: good code is self-documenting. There are much better practices than writing comments everywhere, such as using appropriate variables and function names, sticking to conventions, writing clear and concise code, using standard idioms, etc. Don't add comments just for the sake of it. Aim to write code that reads well. Use comments to explain why you did something that may not be clear or to explain complex code.