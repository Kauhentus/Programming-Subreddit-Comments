This is a great analysis. I have nothing to add on the Big O analysis, but I do want to supplement by saying don't forget about cache effects on modern hardware, which means your array is always going to win performance-wise. Linked lists are pointer chasing on every node which could amount to hundreds of CPU cycles stalling on every node. (One rough rule of thumb is 500 cycles for each lookup in RAM.) With arrays, you get prefetching, so we might be talking single digit cycles per node. Bjarne Stroustrup (C++ creator) gave a explaining that arrays are always faster than linked lists on modern architectures. https://www.youtube.com/watch?v=YQs6IC-vgmo 
So you would use a dynamic array over a linked list even in an extreme case of random conditional insertions and deletions in the middle (something linked lists have been considered the most optimal for)?
It depends on the size of the array and how the insertions are done. If you have a conditional insertion into a linked list where you already hold the node you're going to insert after, that's constant time. Removal from a linked list at the middle of the list when you hold the node is also constant time. It's unlikely for a array to beat this because even if the array is small you'll probably still have ~1 cache miss each. However, if you have to traverse list to find the place you're inserting, it will be O(n) and you'll have one cache miss per item. The array is O(n) to insert in the middle but it will have far fewer cache misses. Even if your array elements are larger, the hardware prefetcher will. Keep in mind a cache miss on modern hardware can be 200 cycles. It's a constant factor so high that it dominates almost anything else. If you want to get a more rigorous approach to understanding this you can look into [cache-oblivious algorithms](https://en.wikipedia.org/wiki/Cache-oblivious_algorithm) (note that this is a bad name -- oblivious here means they're oblivious to the specific size of your cache lines, and not that they pretend the cache does not exist).
**Cache-oblivious algorithm** In computing, a cache-oblivious algorithm (or cache-transcendent algorithm) is an algorithm designed to take advantage of a CPU cache without having the size of the cache (or the length of the cache lines, etc.) as an explicit parameter. An optimal cache-oblivious algorithm is a cache-oblivious algorithm that uses the cache optimally (in an asymptotic sense, ignoring constant factors). Thus, a cache-oblivious algorithm is designed to perform well, without modification, on multiple machines with different cache sizes, or for a memory hierarchy with different levels of cache having different sizes. Cache-oblivious algorithms are contrasted with explicit blocking, as in loop nest optimization, which explicitly breaks a problem into blocks that are optimally sized for a given cache. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Yes. That was Stroustrup's point. And he's not the only one. Clang/LLVM engineer, Chandler Carruth also makes the same point. Efficiency with Algorithms, Performance with Data Structures https://www.youtube.com/watch?v=fHNmRkzxHWs At 34:40, he talks about "Performance and Data Structures". Reveal: "Discontiguous data structures are the root of all (performance) evil". and "Just say NO to linked lists". "There is almost nothing more harmful you can do to the performance of an actual modern microprocessor than to use a linked list data structure." Cache effects are real and to be taken seriously. Or stated differently, modern RAM busses are extremely slow. 
It depends -- do you have a good way to "find" the insertion point in the linked list? If not, you might need to scan there. There *are* reasonable times to use linked lists, but there aren't many. Also, how big are the lists? If they're small, a growable array will be faster. Also: how many insertions do you need to do? If it's more than one, and you can batch them and do them all in linear time, a growable array might win again. For your original problem, consider these other solutions: 1. Make a "linked list of increasingly-large arrays". Could be faster than either solution -- linearly less copying than a growable array, and the same number of malloc. 2. Get an upper bound for the eventual array size somehow (some multiple of the input file size, or "ten terabytes" if you are on an OS like Linux that does allocation lazily) and don't bother to reallocate. 3. Memory map the input. 
If you can hold a position to the insertion point in a linked list, you can also probably hold the insertion array index, so the list doesn't necessarily get an advantage. Cache issues will still probably put the list at a disadvantage, because to insert, you will need to set/change the next/previous pointers of not only the node you are inserting, but the two immediate nodes around it (assuming doubly linked list). That's potentially 3 cache misses instead of just 1. 
If you're looking to search the data a lot a tree might be better, depends on the ratio of searching to random access. 
I recently finished up a csv read/write library for personal use. it went through 4-5 iterations before i was satisfied with the results. i started with having a pointer to every single field. eventually i just settled on one pointer. consider struct csv { char \* string; //entire content of a csv file. size\_t len; //length of the entire file. int \* offset; //array of integers. each integer is the index of where a newline or delim char appears. int num\_row; int num\_col; }; read entire file into buffer 'string'. the function also returns the length of the entire string. loop through the string twice. first loop counts delimiter and newline. the sum is used to allocate memory of \`int \* offset\` it also increments num\_row and num\_col second loop replaces each delimiter and newline character with '\\0' or the end of string character. it also sets the offset. for example offset\[0\] = 0; for(int i = 0, count = 1; i &lt; csv.len; i++) { char \* ptr\_c = string + i; if (\*ptr\_c == '\\n' || \*ptr\_c == ',') { \*ptr\_c = '\\0'; offset\[i\] = count; count++; } } since the first loop got you the number of columns and the number of row, all you need now is use row-major order to get the individual cells. no malloc required. int field\_index = csv.index\[row \* num\_col + col\]; char \* field = csv.string\[field\_index\]; since you have replaced all the newline/delimiter characters with a '/0' AND you have the index of where all the delimiters/newline are, all you need to do to access any csv field member is to use the offset. and the pointer will stop at '/0'. then if you know the datatype of said field (lets say int), then all you need to do is \`int field\_value = atoi(field)\` you don't need a multiple char \*, or even a char \*\*. one char to the string read from fopen, and replace every single newline/delimiter with '\\0', and then access the specific field using row-major order.
I have removed your post because it is not specifically about programming in C.
&gt; Prefer to implement functionality yourself if it isn't too difficult this is pretty much why it took me 5 months to learn how to link shared libraries.
I was thinking the same. I agree with you analysis.
You can do video series so more people can see it. I'm really intereseted in C programming but I know it at average level. What's your experience?
It is impossible to say in general as the C programming language doesn't have the notion of execution time. The answer to your question will differ depending on what architecture you are programming for. On many architectures, both loops will take the same time. On some (e.g. Alpha), (a) is slower than (b). On some (e.g. 8 bit micro controllers), (b) is slower than (a). One cannot say in general.
Ignoring that there is no 'byte' type in C.... There is no answer. These sorts of questions are not defined by the standard. In practice, there's also no answer to this. It would vary a lot from platform to platform. One platform may not have an instruction to load a byte, and so a load word followed by a mask operation would be performed, making (b) faster. Another platform may not have 32+-bit registers are be able to read 32+ bits in a single load operation, requiring multiple reads, in which case (a) would be faster.
Fair enough. So assuming it is indeed a microcontroller of 8 bits, (b) is slower than (a). Could you elaborate a little as of why? In terms of how the compiler and memory addresses are managed in that scenario. I imagine that in this architecture memory addresses have one byte each, so for the instruction (a) we only need to reserve one address in memory actually. But can't the compiler interpret the upper limit of the for loop in instruction (b) and reserve only one memory address for it also, despite being an unsigned long?
Sorry I forgot to assume an architecture. Assuming it's a microcontroller of 8 bits. If you don't mind see my answer in the upper comment. It contains my line of thought considering this matter. Would like to know what happens in reality in terms of compiler and memory management in this scenario. Thanks.
Note that there is no programming language named C/C++. Pick one. Note further that Arduinos are typically programming in C++, not C. C++ is off topic in this subreddit.
mine mine mine mine mine mine 
It's volatile. There's no reason to believe the value read from x will ever be less than 256. There's also no reason to believe that the loop will happen 256 times. It could very well be an infinite loop, from the compiler's perspective. Note that if it *weren't* volatile, the compiler would be free to remove the loop completely, since it doesn't have any side-effects.
&gt; Fair enough. So assuming it is indeed a microcontroller of 8 bits, (b) is slower than (a). Could you elaborate a little as of why? In terms of how the compiler and memory addresses are managed in that scenario. I imagine that in this architecture memory addresses have one byte each, so for the instruction (a) we only need to reserve one address in memory actually. But can't the compiler interpret the upper limit of the for loop in instruction (b) and reserve only one memory address for it also, despite being an unsigned long? The compiler can do all sorts of things normally, but most optimizations have been forbidden by the `volatile` qualifier to the `i` variable. `volatile` indicates that each read and write access to the variable declared so must happen exactly as writen. The compiler may not eliminate duplicate reads or writes and may not change anything about the size of the variable or keep it in a register. Without `volatile`, this question would be even harder to answer since it depended on how exactly the compiler optimises your code. The machine code for your source code should look like this: 1. set i = 0; 2. compare i with 255 3. if it is less than 255, goto 6. 4. add one to i 5. goto 2 6. done Note that since `i` is `volatile`, it has to be read from memory in steps 2, 3, and 4 and written to memory in steps 1 and 3. The pseudo code should rather look like this (note that some architectures can do a read-modify-write in one instruction, but the CPU still has to actually read and write the datum): 1. store 0 to i 2. load i into a register 3. compare the register with 255 4. if it is less than 255, goto done 5. load i into a register 6. add one to the register 7. store the register to i 8. goto 2 9. done Note that the compiler is not allowed to reuse the content of the register and omit step 5 as `i` is `volatile`. The key point why (a) is faster than (b) is that on an 8 bit micro controller, only one byte can be loader or stored in each cycle. So writing a one byte variable takes one unit of time whereas writing a `long` variable (generally four bytes) takes four units of time (simplified). Also,operating on four bytes is more involved than on a single byte, since you have to operate on each byte individually. So each of the steps 1, 2, 3, 5, 6, and 7 takes longer with a `long` variable `i`. On a 32 bit machine, operating on bytes takes as long as operating on 32 bit words as the registers and memory bus are 32 bit long. That's why on such machines, (a) should be as fast as (b). Some 32 bit machines (Alpha) cannot load and store single bytes, requiring more complex code for a `byte` variable `i`, making (a) slower than (b).
Or you malloc n-number of nodes like you would with a dynamic array. As the list grows you double the number of nodes. 
If the number of elements is truly unknown, I would employ a linked list of blocks. That is, the payload is a pointer to a block (array) you are filling in. When a block fills up, link a new block in its place. This avoids all the copying that will occur potentially if you realloc an array. Once the input read completes (no more insertions), at that point you could realloc just once if you truly need a flat array. But better in my view would be to count the number of blocks (# of elements in the linked list), allocate an array of pointers of that count, copy over all the block pointers from the linked list, then free the list nodes. Nothing but the block pointers are copied in this case, and you only have one pointer chase at most to get to your data. For very large amounts of data, the general realloc approach will have a huge overhead in copying you will have to overcome in the second half of your program. As stated in other posts, in modern HW, small payload linked lists are hard on the machines. First, as you traverse the list, branch prediction HW is stressed as that HW doesn’t really generally know when you will exit a traversal loop. So you tend to generally predict taken (continue traverse) which implies you always take one mispredict hit. More significantly, the loop iteration latency (the time it takes to spin around one iteration) is fixed to the speed you can read the next link pointer from system memory. If pointers are allocated somewhat sequentially, there will be some spatial locality, so caches will have some benefit, but clearly DRAM read latency will be a big factor.
Could something like this be what you're looking for? https://github.com/aleksandar-todorovic/awesome-c
Really nice answer, I got it all. Just for clarifying: where you say "if it is less than 255, goto done" shouldn't it be "if it is equal to 255 goto done"? So we can keep incrementing the variable i until it has a value bigger than 254. Thanks a lot for the effort in writing this well tailored answer.
&gt; Really nice answer, I got it all. Just for clarifying: where you say "if it is less than 255, goto done" shouldn't it be "if it is equal to 255 goto done"? So we can keep incrementing the variable i until it has a value bigger than 254. Yeah, should be “If it is greater than or equal to 255.” Indeed, you got me.
Or maybe do Skype tutoring but record it - could make for a good didactic style 
The compiler is free to remove the loops because the variable isn’t visible from outside the function and its address never escapes.
I'm interested in c myself. I would need an introductory level starting point. 
1. The number of buckets is fixed in your implementation. This may lead to bad performance when the table is greatly overloaded. 2. Given small keys, such as integers, [open addressing](https://en.wikipedia.org/wiki/Open_addressing) is much faster than chaining. 3. ds_node::prev may be convenient, but is not really necessary. 3. With chaining, you can implement a semi-[intrusive](https://attractivechaos.wordpress.com/2018/04/19/a-single-header-generic-intrusive-avl-tree-in-ansi-c/) hash table to achieve generics ("semi" because you have to call realloc() to grow the table). It will be cleaner and more general, though the API will be less intuitive.
**Open addressing** Open addressing, or closed hashing, is a method of collision resolution in hash tables. With this method a hash collision is resolved by probing, or searching through alternate locations in the array (the probe sequence) until either the target record is found, or an unused array slot is found, which indicates that there is no such key in the table. Well-known probe sequences include: Linear probing in which the interval between probes is fixed — often set to 1. Quadratic probing in which the interval between probes increases linearly (hence, the indices are described by a quadratic function). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I only took a quick glance, so from a purely end user POV: * Having strings as the only key type can be a nuance. Why would I use your library instead of POSIX `hcreate` and `hsearch`? Take for instance [uthash](https://troydhanson.github.io/uthash/), which is much more flexible. * It seems all I have to do is call `make` to build this library, and the code is simple enough for me to modify it to suit my needs if I have to (single file, about 400LOC). This scores a lot of points with me, both for hobby projects and for professional projects. * Your library does dynamic allocations. This can be hard to avoid, and both the `search.h` family as well as uthash do it also IIRC, but [it would be great if you could avoid it](http://nullprogram.com/blog/2018/06/10/)
Thanks for the feedback. I just modified it to have arbitrary key types and be generally more flexible. I rolled my own to see if I could do it. Also it's easier for me to learn all the concepts behind such things if I do it myself, this way I see why things are done the way they are.
I wanted to get the base of the implementation going before tackling reallocation to less or more buckets of the map. Regarding your 2nd point, optimizing the hash map for such cases is rather further down the to-do list. First I want a solid implementation of the basics before moving on.
You have a program that writes something to standard out? What do you expect to happen if you double click it? In general if you want a window to interact with you would have to program it. Sometimes if you click an exe like this a command window blinks open for an instant. 
The executable executes, its just that either it exits quickly or since no console window is created you see nothing. [Looking at a SO question](https://stackoverflow.com/questions/13100785/mingw-build-gui-application-with-console), try adding `-mconsole` when compiling/linking.
Closed/chaining and intrusive/non-intrusive are among the first few things to decide *before* implementing a hash table, or you will rewrite a significant part of code later.
Those two cache misses will happen at the same time on an out of order machine. The only case when you won't have at least two cache misses when inserting into an array is if it's very small and entirely fits in the cache (speculative prefetch is very unlikely to kick in before the second cache miss).
Good point on cache lines. It makes a huge difference.
Yes that is what happens, the command window blinks open for an instant. How do I make it just open the command window and display the text?
I tried that and it didn't make a difference. Is there a line of code I can add that will open a console window, or does it have to be done in the compiling stage?
You use `__DATSTRUC_H_`as include guard. In C "all identifiers that begin with an underscore and either an uppercase letter or another underscore are always reserved for any use" and "all identifiers that begin with an underscore are always reserved for use as identifiers with file scope in both the ordinary and tag name spaces." If you are planning to support C++ the rules are even more strict: "Each identifier that contains a double underscore __ or begins with an underscore followed by an uppercase letter is reserved to the implementation for any use" and "each identifier that begins with an underscore is reserved to the implementation for use as a name in the global namespace."
Wasn't aware of that restriction, thanks for pointing that out, will fix it.
Run command line programs from a command line, not a gui.
Try system("pause") before your main function exits. This works in visual studio but I dunno about mingw.
This was the solution! Thank you!
You're welcome.
The implementation strategies are completely different, and can cause you to have a differently shaped API (for example, C++'s std::unordered_map's API requires chaining, which is a big reason that it's never going to win any benchmarks).
The real solution is to first open a command prompt and run the program from there, instead of double clicking the exe file. If you type something like "ipconfig" you'll see that the command outputs and then exits without pausing. If you double clicked ipconfig.exe, a cmd window would blink too. It might be convenient to pause at the end if you're used to double clicking (which is not necessarily how other people might run your program), but it's inconsistent with the rest of the commands in the Windows environment.
That makes sense! Thank you for your input!
&gt; The compiler can do all sorts of things normally, but most optimizations have been forbidden by the volatile qualifier to the i variable. volatile indicates that each read and write access to the variable declared so must happen exactly as writen. Except `i` has no storage or scope outside the loop, and the loop has no body and no side effects, so the compiler is free to ignore it.
It is not free to ignore `i` since `i` is qualified `volatile`. Every read and write from/to `i` in the abstract machine must correspond to an actual read or write.
Have you tried compiling it to assembly?
No, it is not since `i` is `volatile`. The compiler must assume that random changes to the variable occur even if none occur in the program.
How big is an "unsigned long" on that micro? My guess is that the "byte" type is really an unsigned char, and a "long" type is at minimum 4 bytes. Just a guess. Also, since your loop variable is volatile, what's to say it isn't being modified somewhere else, like in an interrupt routine? If interrupts are enabled and the interrupt handler modifies the volatile i, the loop may never finish or it may prematurely finish. 
I did not as of yet. That's indeed a good idea, instead of making assumptions. Thanks.
Nope. The volatile qualifier means that the compiler must refer to the actual variable storage location when it needs "i". An interrupt routine might modify "i" and the loop might never finish or finish without stepping through every value of "i" in the for statement.
The unsigned long takes 32 bits while the byte takes, well, 8 bits. In this scenario it is assumed that there are no interrupts, just those two instructions solely. Well, I know, volatile keyword is mainly used to deal with interruptions and guarantee the reliability of the variable's value, but that's the scenario that was presented to me (without interrupts). 
Pre-C99 compilers usually support some sort of inline, but you have to use platform-specific macros to produce the right syntax for specifying the inline function!
&gt; The "name" of your program is always the first argument. *usually*, not *always*. E.g. The program might be invoked by an `exec` family function where the caller supplies NULL for `argv[0]`. 
The only way to be sure is to try it yourself. [Or get me to try it and link you to it.](https://godbolt.org/g/V3KxC1) If you really need to care about something like this, you should benchmark your program. Yes, your program, not just this snippet in isolation. And not just once, make it part of the build, so that you can catch regressions over time.
What exactly is your problem. You seem to already have the font, so what is it that you need?
There’s not really a problem, I just dislike this font because it looks old. I’m just having a hard time finding an other one
So you are actually asking for help with finding a font, not actually anything to do with programming , let alone C ?
You asked for “another array with the same value,” so I wonder how you expect a different font to have the same values. I'm confused.
No, I’m asking if somebody knows a link to a font or array of hexadecimal bytes for displaying chars. I’m not asking to find it for me, because I’ve already done alot of googling. And since I’m programming the library in C++ I figured why not ask it here
Same value yes. By that I mean [256] by [8]. 
Next time, say “same dimension” or “same size” so it's clear what you mean. Values are what goes in the array, not how large the array is.
Chances are the format is high (or low?) bits first, line by line, 8 pixels wide. If you really want to test that: #define FILENAME "/path/to/whatever.dat" #include &lt;stdio.h&gt; #define H 8 #define N 256 unsigned char data[H*N]; void test_char(unsigned char ch) { int c, n = ch*H; for(int j = 0; j &lt; H; j++) { for(x = 0x80; x; x &gt;&gt;= 1) { c = (data[n + j] &amp; x) ? '#' : '.'; putc(c, stdout); } putc('\n', stdout); } return; } int main() { FILE *f = fopen(FILENAME, "rb"); fread(data, H, N, f); fclose(f); for(c = 0; c &lt; N; c++) { printf("\ncodepoint: %d\n", c); test_char(c); } return 0; } If you actually downloaded a TTF file or anything not directly bits-&gt;pixels use something else. https://github.com/squix78/MAX7219LedMatrix/blob/master/cp437font.h
I figured the confusion and I’ve edited the post
Check out [font and bitmap generator](http://www.angelcode.com/products/bmfont/). At least I think that's the utility I used last time I needed to do this.
Thank you!
you can try writing a batch/shell-script wrapper around your executable that executes the a.exe through a command window, like cmd -C 'a.exe'
C++ is off topic in this subreddit though, as this subreddit is about programming in C only. Try /r/cpp_questions if you program in C++.
A linked list of arrays
Just so you are aware using system("pause") is not portable so will only work on Windows. A better solution is to use getchar() imho
&gt;The "name" of your program is always the first argument. Just check to make sure your argc is greater than 1 and then start your for loop at 1 instead of 0. This isn't a C specific concept by the way. Thanks for that. This works perfectly: #include &lt;stdio.h&gt; int main(int argc, char **argv) { for ( int i = 1; i &lt; argc; ++i) { printf("%s ", argv[i]); } printf("\n"); } 
&gt; Some 32 bit machines (Alpha) cannot load and store single bytes Pedantry: Alpha is 64-bit only. 
Ahh interesting note. Thank you.
No problem
Warning: This advice is problematic. It’s not portable and it’s a potential security flaw.
Thank you
This’ll generate some sort of copy pastable array?
Yeah, you can generate an array in column major or row major format. I used it to prep all of my fonts for a graphic OLED.
Allright thanks alot, I’ll have a look
The executable name, does it end in ".exe"? "a.out' won't work on Windows. 
Now I know why people warned me that majority of tutorials available in the internet are of poor quality. Above is a great example, simply teaches bad habits.
Indeed!
Please don't post these.
Please don't post these.
As others have said it all depends on the architecture, the optimization and the compiler. If performance is a concern, compile both codes with the highest optimization level and all available compilers and benchmark it. On an 8 bit architecture you'd expect the first one to be faster but the only way to be certain is to test it.
&gt; So is there anyway that i don't have to install Linux and still using Window to code ?? https://docs.microsoft.com/en-us/windows/wsl/install-win10 
you can use virtualbox to install and use linux on top of windows so you can keep up with course material, and you can also try visual studio which is free for download and has a ton of support but will likely have differences from what you are using in your class. you should ask your professor if that is a viable solution. https://www.visualstudio.com/ https://www.virtualbox.org/
In addition to the other answers, note that this sub is for the C programming language, not C++, so if you have further questions about C++ programming, you'd be better off asking in /r/learncpp.
This is the correct answer. I use vim / clang++ / gcc / ctags / make / etc etc on WSL regularly. And also you can easily use the community edition of Visual Studio (it's free) to (a) edit via a GUI and (b) confirm that your code works on all major compilers, then compile using make under WSL to satisfy the Linux requirement.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
YouTube is a bad place to find help about C programming as almost all tutorials are of shit quality. Many teach dangerously outdated or just plain wrong things about C. Get a good book on C programming and read that instead. Unions are like structures, but all members occupy the same storage. This means that when you write to a union member, the value of all other union members is overwritten, too. This is rarely useful, but when it is, it is invaluable. There are two main uses for unions: (a) storing one of a bunch of different data types when you don't know which it is going to be in advance and (b) *type punning,* i.e. interpreting the representation of a datum of one type as another type. Let me write a better answer later when I'm fully awake.
Possibly the best way of thinking about unions is that they are _exactly like structures_, except for one key difference: in structures the members are sequentially allocated &amp;mdash; that is, at different memory addresses, such that no two members overlap one another &amp;mdash; whereas in unions the members are overlapping, and all at the _same_ memory address. Many things about structures and unions are work identically. For example: * Both structures and unions can have padding, except prior to the first member. * A pointer to a structure is equivalent (after suitable conversion) to a pointer to its first member. Similarly, a pointer to a union is equivalent (after suitable conversion) to a pointer to _any_ of its members. * Both structures and unions can be "anonymous" (unnamed) when embedded within some other structure or union. But there are some key differences: * A structure, but not a union, can have as its final member a "flexible array member", an array of unspecified size. * All members of a structure can be used simultaneously. With a union, however, writing to one member _invalidates_ all other members. This last point is a bit subtle. "Type punning", whereby you write to one element of a union then read from another, results in _undefined behaviour_ according to the C standard. Some C implementations will perform optimisations that can break attempts to do this, though many have the ability to disable these optimisations. So what are the applications of unions? If you know you only need to use one of a set of members at any time, you can use a union to make your object smaller. For example, say you were implementing a programming language and you wanted a single data structure representing "either a string, or an integer, or a double-precision floating point number". You could write: enum value_type { STRING, INTEGER, FLOATING }; struct value { enum value_type type; char *string; int integer; double floating; } with the `type` member indicating which of the `string`, `integer`, or `floating` members has a valid value. But that wastes memory: you know only one of those fields is going to have something useful in it. If you use an embedded, anonymous union you can save memory: struct value { enum value_type type; union { char *string; int integer; double floating; }; } This will still work, since only one of `string`, `integer` and `floating` are valid at any time, and memory usage is decreased since these members are allocated at the _same_ memory address inside the object.
It's also useful in embedded with very tight resources and you have a bunch of scratch variables of different kinds not being used at once
There are two common use cases for unions. One is for when you want to store a value that might be one of several different types, which is called a tagged union. The example on [the Wikipedia page](https://en.wikipedia.org/wiki/Tagged_union) is good, but my favorite is: #include &lt;stdio.h&gt; enum NumberKind { FLOAT, INT }; struct Number { enum NumberKind kind; union { int i; float f; }; }; void output_number(struct Number * n) { switch (n-&gt;kind) { case INT: printf("The integer %d\n", n-&gt;i); break; case FLOAT: printf("The float %f\n", n-&gt;f); break; } } int main() { struct Number three = { .kind = INT, { .i = 3 } }; struct Number two_point_five = { .kind = FLOAT, { .f = 2.5 } }; output_number(&amp;three); output_number(&amp;two_point_five); return 0; } The `union` section of `struct Number` will hold either an `int i` or a `float f`, and the `enum NumberKind kind` field tells the programmer which it is. As with most things in C, there's a lot of room for mistakes; there's nothing stopping me from reading `n-&gt;i` regardless of what `n-&gt;kind` is, so a fair number of bugs arise from forgetting to check the tag of a tagged union and proceeding as if it were the variant one expects. That ability, though, is vital to the other use of unions, type punning. [Wikipedia](https://en.wikipedia.org/wiki/Type_punning) has a great article on type punning, which it defines as "any programming technique that subverts or circumvents the type system of a programming language in order to achieve an effect that would be difficult or impossible to achieve within the bounds of the formal language." In my experience, the most common use case for type punning is doing integer arithmetic on the bits of a pointer, but that's probably just because language and interpreter design is my hobby. In any case: #include &lt;stdint.h&gt; #include &lt;stdbool.h&gt; #include &lt;assert.h&gt; #include &lt;stdlib.h&gt; union TaggedPointer { void * p; uintptr_t i; }; void * tag_a_pointer(void * ptr) { union TaggedPointer tagged = { .p = ptr }; tagged.i |= 1; return tagged.p; } bool has_low_bit_set(void * ptr) { union TaggedPointer tagged = { .p = ptr }; return (tagged.i &amp; 1) == 1; } int main() { void * some_pointer = malloc(16); assert(!has_low_bit_set(some_pointer)); void * tagged = tag_a_pointer(some_pointer); assert(has_low_bit_set(tagged)); return 0; } Because `TaggedPointer.i` and `TaggedPointer.p` occupy the same block of memory, altering one (as in `tag_a_pointer`) changes the other. Many people thing this looks cleaner than a pointer-cast, which might look like: void * tag_a_pointer_but_with_pointer_casts(void * ptr) { uintptr_t i = *((uintptr_t *)(&amp;ptr)); i |= 1; return *((void **)(&amp;i)); } 
The "it's like structure but on the same space" approach isn't wrong and if it works for you that's good, but it's always felt more confusing than anything to me so here's another angle. In C we store things according to a type which describes roughly the memory layout of the object. Let's say you're writting an online game and want to make a monster appear on screen. The server sends the monster data to the client which has to store them somehow in order to use them. There are many enemies in this game, orcs, dwarves, leprechauns... They all happen to have different characteristics and you decided to make one type per monster (arguably not the best choice, but still). So the question is, if you were to write that function that receives informations about a monster and has to store the right type in memory, how do you do? The simplest but tedious way is to have a variable orc_t, a dwarf_t, a leprechaun_t, etc, and to initialize only the right one depending on what you received. This works, but it's a waste of memory (especially since it must be done for all enemies) and hard to maintain. enum monster_type { ORC, DWARF, LEPRECHAUN }; typedef struct { int health; } orc_t; typedef struct { int health; } dwarf_t; typedef struct { int health; } leprechaun_t; void show_health(Message msg) { int health; orc_t orc; dwarf_t dwarf; leprechaun_t leprechaun; monster_type msg_monster_type = get_monster_type(msg); switch (msg_monster_type) { case (ORC): orc = get_monster(msg); health = orc.health; break; case (DWARF): dwarf = get_monster(msg); health = dwarf.health; break; case (LEPRECHAUN): leprechaun = get_monster(msg); health = leprechaun.health; break; default: unknown_type_error(); } printf("Monster health: %d\n", health); } We only have one monster so we'd like to have only one representation even if we manage 20 different types, not 19 invalid and 1 useful. To solve that issue we can use a union: we will define some space that will hold the monster's data no matter its type and we'll interpret data in that space according to the type of the monster. We still have to hold the monster's type somewhere to know what our union is, but that's ok. It might look like this: enum monster_type { ORC, DWARF, LEPRECHAUN }; typedef union { orc_t orc; dwarf_t dwarf; leprechaun_t leprechaun; } monster_data; void show_health(Message msg) { int health; monster_data msg_monster = get_monster(msg); monster_type msg_monster_type = get_monster_type(msg); switch (msg_monster_type) { case (ORC): health = msg_monster.orc.health; break; case (DWARF): health = msg_monster.dwarf.health; break; case (LEPRECHAUN): health = msg_monster.leprechaun.health; break; default: unknown_type_error(); } printf("Monster health: %d\n", health); } Well, it might except that would be tedious too... I mean, in a single function it works, but if you're going to pass your monster arround you don't want to leave him without its type, that could leat to type confusions which are nasty bugs (and often security issues). So insteal we'll wrap it all in a struct: enum monster_type { ORC, DWARF, LEPRECHAUN }; typedef struct { monster_type type; typedef union { orc_t orc; dwarf_t dwarf; leprechaun_t leprechaun; } data; } monster; void show_health(Message msg) { int health; monster msg_monster; msg_monster.data = get_monster(msg); msg_monster.type = get_monster_type(msg); switch (msg_monster.type) { case (ORC): health = msg_monster.data.orc.health; break; case (DWARF): health = msg_monster.data.dwarf.health; break; case (LEPRECHAUN): health = msg_monster.data.leprechaun.health; break; default: unknown_type_error(); } printf("Monster health: %d\n", health); } Easy right? Now let's just take a step back and speak about that first solution where we had orc_t, dwarf_t and leprechaun_t. We made it work by having different variables within the function, but how would we have done it in a way that allowed us to pass the monster arround? We'd have used a struct: typedef struct { monster_type type; orc_t orc; dwarf_t dwarf; leprechaun_t leprechaun; } monster; void show_health(Message msg) { int health; monster msg_monster; msg_monster.type = get_monster_type(msg); switch (msg_monster_type) { case (ORC): msg_monster.orc = get_monster(msg); health = msg_monster.orc.health; break; case (DWARF): msg_monster.dwarf = get_monster(msg); health = msg_monster.dwarf.health; break; case (LEPRECHAUN): msg_monster.leprechaun = get_monster(msg); health = msg_monster.leprechaun.health; break; default: unknown_type_error(); } printf("Monster health: %d\n", health); } But as with many separate variables that struct would be very large and largely unused. Yet it looks very close to what we have with the union: we took each monster member and as we use only one at a time we united their spaces: the link is made as to why union are "exactly like structs but at the same place". I hope this clears up some confusion. Oh, and if you do a game, having one type per monster is generally not a good approach. Just saying. 
Please put four blanks in front of every line of code for your code to appear readably. Also note that Arduino code is actually C++ code, you might get better help in /r/arduino or /r/cpp_questions.
A struct stores variables linearly in memory, a union stores variables all at the same memory address, overlapping. Also, video coding tutorials = yucky. After all, you're on Reddit looking for text answers, so use text tutorials. Plus you can copy-pasta example code from a text tutorial. Video tuts are useful for learning how to use Photoshop or After Effects, but not writing code. https://www.tutorialspoint.com/cprogramming/c_unions.htm
If you're going to quote 5.1.2.3 in support of that then I'd say it's ambiguous at best. The compiler can trivially prove that there is no observable difference between executing the loop and not executing the loop.
It doesn't matter that the difference cannot be observed. The compiler has to emit code to read and write to the variable as written.
Chapter and verse, please.
Downvote because anonymous mask
That's Bruce Forsyth.
ISO/IEC 9899:2011 §6.7.3 ¶7. Footnote 134 expresses the intent rather clearly. As an example of such ways of modification unknown to the implementation, I have explicit license to halt the program, use a debugger to modify an automatic variable with volatile qualification, and then continue the program. The compiler must generate code as to anticipate this kind of modification.
That footnote is aboutusing `volatile` for MMIO and is not directly applicable to this case, since `i` here has block scope and automatic storage duration.
It seems you want to use dynamically allocated memory (malloc/free) but are using arrays instead. Is there a reason to not use the heap? Side note: If your memory locations aren't overlapping, you can use memcpy. memmove tends to be more expensive since it must perform extra checks to be able to handle overlapping memory.
I'm quite curious about this. I don't have access to a linux machine to test it out. Has anybody here tested this library? How did it go?
The section very clearly states that `volatile` gives license to modifications unknown to the compiler. The footnote gives some examples for such modifications. This list is not exhaustive. I gave another example which also applies to automatic variables with block scope (all automatic variables have block scope).
the data is supposed to be held in RAM on the device, originally I was under the impression that the heap could not be allocated to RAM, but that is not true. I can work on this method of implementation.
something similar https://github.com/featen/aehttpd
How would the interrupt routine be able to find `i` without `i`’s address escaping?
If the address of `i` doesn’t escape, the compiler doesn’t need to do anything, because there’s no means of getting at `i`. (Unless the ABI gives considerably stronger guarantees, and I haven’t seen one yet that does.) §5.1.2.3¶4 states &gt; An actual implementation need not evaluate part of an expression if it can deduce that its value is not used and that no needed side effects are produced (including any caused by calling a function or accessing a volatile object).
No problem. Also, listen to the people saying that it's bad to use system(). There are many reasons why they're right. It's almost never a good idea.
Make something that you yourself would find useful/interesting/neat. If you still don't have any ideas you could google for beginner coding challenges too. In my experience the best way to learn is to start working on something that you want to make and research in to it every time you hit a roadblock.
Make a BF interpreter. Pretty easy, but also goes pretty in depth in many things. No pointers needed unless you want them.
I generally agree with this. But he might give up out of difficultly say if I don't know, he tries writing an MMO out the door.
Just a heads up, the heap _is_ RAM.
I think your suggestion is awesome too. I tried searching google for sample projects and I saw that most c programming application they created was all console base. Is it really necessary to create console base application rather than creating an application with GUI?
LOL. MMO is not on my mind right now. I know it's pretty hard to implement. :)
I am looking into it right now. thanks so much..
I would assume those headers and accompanying comments were copied directly from a school assignment with little thought to actual usage.
It is. However there is no default or built in library for working with GUI. You will need a widget toolkit to do so. [Check this wikipedia page for specific examples.](https://en.wikipedia.org/wiki/List_of_widget_toolkits#Based_on_C_(including_bindings_to_other_languages)) 
Start doing Project Euler challenges
Thanks so much. I will surely take a look at it.
I wouldn't recommend doing your first project as a GUI application though. There is still much more to learn. If you are dead set on a GUI project though just know it will take patience and research. If you are willing to put in the time you'll eventually figure it out. Good luck.
I know that both clang and GCC will throw a warning unless you add a second set of parenthesis to show that you really mean it, like ((x = 0))
I got a refurbished laptop like this for less than $300 a few months ago: http://www.macmall.com/p/Lenovo-Notebook-Computers/product~dpno~41039252~pdp.bddcfjei I just use the latest release of Ubuntu. I like Linux over Mac because I had trouble setting up a dev toolchain in Mac in a canonical way. Maybe this was just my lack of familiarity with Macs, though. But why do you want new hardware? 
"New" hardware isn't always best for Linux. Thinkpad x230 are very popular and well regarded. But you would be better at /r/linux then here.
Fellow Arch user here (on my desktop and home servers). I have an ASUS Zenbook UX305F (Windows), an ASUS C201P (ChromeOS), and a Macbook Air. They're all between two and three years old now, so I should probably re-up soon. I've run Arch on the first two, but never put it on the Macbook. Anymore, I use the default OS for each because I do most of my development remotely, and free ssh clients aren't that hard to find (macOS comes with openssh by default). For most people I recommend macOS over Linux because they usually don't want to spend time customizing their environment. If you run Arch, and especially if you enjoy ricing, I would say that skipping macOS is probably the right call for you. It's not that you can't customize macOS, but the process is significantly different from Arch, and unless you want to relearn it your time could be better spent elsewhere. As for modern hardware recommendations, check out r/archlinux and r/suggestalaptop, they helped me pick up my UX305. Anything that will run Arch for you will likely be an acceptable machine for programming C, but you should bear in mind the kind of work you intend to do. Hope that helps.
I use both a Mac Book Pro and a desktop running Arch, and both are very pleasant to use and develop on. Homebrew and the AUR host most of tool/lib you may need, even if you're into "bare metal" programming. Between macOS and Arch, I definitely can't choose which one is the best. I don't know why you want to look for new hardware, ARM native development maybe ? Otherwise I can't think a something you should look for. 
IMHO homebrew is reasonably canonical, and provided me with all the tools I wanted.
Actually my hardware is pretty old. I5 3rd generation with 1366x768 screen. Do you think i should keep using it for now?
Thanks. Other than ricing, would you still prefer macOS over arch? If yes then why. Also, hows your asus UX305 Rocking so far? 
And kcgi: https://github.com/kristapsdz/kcgi
Since I do all my development in terminal, the difference is pretty marginal. I prefer Arch because it allows me to customize *everything*, and that helps me develop more efficiently, but when I need a laptop it's usually because I'm going somewhere to work with someone in person, and in those instances having all my custom shit can be a real hindrance. I still recommend macOS for most users because system administration usually isn't something people enjoy like I do, and macOS obfuscates most of that while still providing you with the tools you need to accomplish your goals. My UX305 is still trucking along, but I can safely say that it's the least used piece of hardware in my kit. When I ran Arch on it it worked beautifully, and it still works great now with Windows, but it's not the same. All the development I do on it now is through PuTTY, so I don't do any local compilation on it, but back when I had Arch I recall it taxing the CPU a bit to compile anything non-trivial. By now, I would definitely recommend looking at a newer model of Zenbook, as the UX305 is a little dated, but ASUS is still my go to brand for people looking for Windows or Linux books. That being said I would definitely check with the community to avoid unforeseen complications prior to purchase. At the end of the day your choice of OS and hardware will need to come down to what you intend to use it for, so it's hard for me to make explicit recommendations without knowing more.
Hey, I have an old Dell Latitude too! I run FreeBSD on mine, but I do most of my work on a FreeBSD workstation (8-core AMD 4.0ghz, 16GB RAM, i3 window manager). I use the laptop when I want to work remotely, but mostly as an X terminal for clients running on my workstation.
You connect putty to your PC? Also, What do you develop
This has nothing to do with C programming. Go somewhere else for OS circle jerking.
1366x768 is so shitty. I just upgraded my laptop and due to how expensive this shit is in my country I had to stay in this resolution. Every time I have to use two windows at once I want to kill myself. So if I were you I'd try to upgrade even if it's just for this.
How is this relevant to C programming?
Acer Chromebooks have very good specs for the price. ~$300 brand-new for full metal chassis, HD display, 12+ hour battery (mine is 12-14 hours after almost 2 years of regular use). I personally have been using mine "out of the box" in developer mode, which allows me to access most of the OS that I care about (got GCC toolchain on there, plus Anaconda, git, etc.). You can also do a bare-metal install of your own distro, but this of course means irreversibly tampering with the warranty and ChromeOS. I've heard good things about this approach but haven't tried myself.
I run PuTTY from my UX305 to connect to servers that tend to run Arch (although sometimes I work with people who prefer other flavors of Linux or BSD). I'm actually not allowed to talk about any of the interesting stuff I work on right now :X but the stuff I can talk about ranges from system utilities, to embedded IoT projects, to high performance systems for mathematical proof. It's not uncommon for me to help academic friends with backgrounds in physics or chemistry with software and IT related problems, and I've been known to edit and contribute to their code when asked.
I mostly code in-house so I end up using my PC gaming! hehe
One good overview of C on youtube is a series by Brian Will he goes over the whole language and even explains some low lever inner workings. (here)[https://www.youtube.com/playlist?list=PLEDF53DC200BAF48D]
&gt;Those who prefer MacBooks, why would you recommend macOS over Linux? Mac OS is just nice to use. It never gets in the way, and interoperates perfectly with Linux. I use my Mac to manage the dozen or so Linux servers. While the Linux desktop is usable, it's nowhere near as polished. It's quirky and rife with shortcomings. OSX eliminates those quirks and shortcomings. Most of what I do is through a shell anyway, so why trade a polished and consistent UI for clunky X11? A terminal is a terminal on both, but with the Mac, I get *so* much more.
But so is the stack :)
If you care about performance use `register`. Volatile is often misused and you should have a very specific case going for it.
What do you get when you said "I get so much more" with Mac? Other than polished UI
&gt; Those who prefer MacBooks, why would you recommend macOS over Linux? Because you can legally run Linux in a VM on macOS, but not legally run macOS in a VM on Linux. So you get the best of both worlds, really. 
Which macbook do you use and would recommend me buying?
Also, Which macbook do you use and would recommend me buying?
CGI technology... that's so 1990... Seriously, if you're going to use C for Web applications, consider [duda.io](http://duda.io/), [onion.io](https://onion.io) or (my personal biased favorite) [facil.io](http://facil.io).
I'm not down with the new models, but Apple is still selling the 2015 model. If you want to save a few bucks, Apple's refurbs are as good as new. Max out the RAM.
Ok. Should i get i5 or i7 model? (I.e. 13 inch vs 15 inch) with 16 gb ram.
I think it's a late 2013 13" Pro with SSD. It's fine for pretty much anything. Main machine is an iMac, though.
Stability is number one. I like that neither the OS or UI ever get in your way. Number two is consistency of keyboard shortcuts. You don't really appreciate this until you've had it, then go back to not having it. There are so many sweet little features in OSX that you don't realize are there, but when you feel like you need it, you reach for it and it's there. Go to /r/osx and search for the many threads listing hidden features. Things like dragging a icon from the desktop, or a file requester window into a terminal window and having the path paste into the spot where your cursor is. Or being able to move files while they're open and having the application using it be aware that it moved. The filesystem keeps all sorts of meta information, so files in your downloads folder from months or years ago still know what website you downloaded it from. I love Linux as much as OSX, but there's nothing I can think of from Linux that I miss on OSX. I have it all. Can't say the same about Linux. Maybe some day it'll catch up, but that's a long way away.
I think that depends on your budget and intended use. I got the 15", fully loaded because I never know what my job will require. I wanted every port possible, and I've put them all to good use. If you're doing development, and moving around a lot, maybe the 13" makes sense because it's lighter, but personally I'd rather deal with the extra weight for the better screen. Can't speak to the performance of the i5 on the Mac. It probably doesn't matter for development, unless you're compiling large code sets.
Note that `memmove` doesn't really move data. It actually copies data, just as `memcpy` does, except that the source and destination may overlap. I'm not sure why you'd want to change the location of an array though.
This. A union of an integer type (16, 32, or 64 bit) and a bitfield struct can make an embedded programmer's life easier. Send the entire int as part of a message or toggle individual bits as needed. I've also used a union of a float and a uint8_t[4] when I needed to serialize/deserialize floating point data as part of a message.
bchs &gt; *
this
That.
I've got a Dell XPS about three years old (before the prices went through the roof!) its got an ssd and a hyper threaded dual core cpu, nice and light but with an 8+hr battery, just the ticket... (it came with Ubuntu from back in the days before the distro morphed into another systemdOS variant) I use Void Linux, which is light weight and very fast. I prefer xfce because it gets out of my way... I don't bother with IDE's using geany as if it were a simple text editor While I use mainly GCC I also have Clang installed I can't decide if my next machine should be laptop or desktop, but I'll probably end up get a customised laptop so I can be sure of decent compatibility...
They're basically overlapping data structures on the same memory. But when to use them? 1. Mainly saves memory / disk space. If you have two or more exclusive use of some variables, having them overlap can save a lot of memory, bandwidth, etc and is faster than compression. 2. Speed. Sometimes architectures have specific instructions that operate faster than others. So being able to easily use those instructions by using a specific type can offer a speed up. You find unions used often when you have data structures used tens to millions of times or in very performance critical systems. However, they can introduce bugs if you're not careful.
&gt;I'm quite curious about this. I don't have access to a linux machine to test it out. Has anybody here tested this library? How did it go? Can you spin up a VM? VirtualBox with Minimal Ubuntu (like 50MB, or something silly.) RHEL has \*free\* DEV subscriptions now, too.
i5 is fine, unless you're doing advanced graphic stuff (video editing or something), then you want i7. If you're just writing C, i5 is more than sufficient. Same with the size. I use 15' and it's a good size for writing code. That being said, I do have a second monitor (one for documentation, the other for IDE) 16GB ram is excessive, again, unless you're doing something particularly advanced (hosting some VMs?) Unless you're gaming, video editing, or writing some massive application, 8GB is more than sufficient.
Using Arch on an Acer c720 chromebook. Upgraded SSD to 128GB and display to IPS. 4GB RAM and a dual-core Celeron.
int main(void){ int num= 57691; int final=0; int n; printf("num: %d\n",num); while(num!=0){ n=num%10; final=(final*10)+n; num=num/10; printf("n: %d\n",n); printf("num: %d\n",num); printf("final: %d\n",final); } } fuck sorry heres the code first time posting on reddit
Output: num: 57691 n: 1 num: 5769 final: 1 n: 9 num: 576 final: 19 n: 6 num: 57 final: 196 n: 7 num: 5 final: 1967 n: 5 num: 0 final: 19675 I hope this is right, correct me if it isn't, please.
+1 for that facil.io suggestion. It looks really good. Probably going to use it in a few of my own applications.
It's true that a failed `scanf()` match leaves the input in an uncertain state. However, that entire family of functions, including `sscanf()`, are inappropriate in programs that require robustness. In particular, it's undefined behavior when the input is an integer that's too large to be represented in the type that accepts it. This puts undefined behavior in control of potentially-untrusted input, which could be bad news. The robust option to locate and parse these integers using something like `strtol()`, carefully checking the result for errors. 
Thanks, I hadn't heard of these. I've been looking into kore.io for a toy web project in C. I'll have to look into these other projects more before I start.
Also I don't know why the code tag made the text highlighted that way so no one can see it.
I always thought that the utility of scanf ends after your first C course
Do you notice any warnings about your code when you compile it? Specifically these lines: int toInt1 = string1; int toInt2 = string2; For a quick solution, look up the function, `atoi`. You can use it to convert your strings to ints. In general, the function, `strtol`, is probably what you want to learn about for converting strings to integers. You might also find `sscanf` useful.
I took the code tag off, because it highlighted it that way. Maybe its just in my browser I don't know, but I couldn't read it.
&gt;Oh I see, `strtod` is a group? And in that group is `strtol`, which ouputs a long. Does it matter if it is a long and not a regular int? Thanks a lot, you age me a lot of good info! So if I used `strtol` would I need to use `%l`? Also can you easily see the things in code tags? I can't read it, I don't know if it is just my browser or not.
Kore author here. Awesome you are looking into using it, if you have any questions feel free to hit up my inbox :)
Perhaps. But I think that most of the courses suck. At least it was never properly explained to me until I read K&amp;R and did some self-studying. Case in point: just scroll down in this same subreddit - someone asked a scanf related question approximately 2 weeks ago so people aren't even immune here. 
Man I went through all of high school with the same setup. Those Chromebooks are an incredible value..
*atoi* is a bit evil because it can cause undefined behaviour. You should rather opt to use those two other functions.
"The C Programming Language" by Brian W. Kernighan and Dennis Ritchie. One of the best Books about a programming language ever written. 
Should I also get the answer book? Also are questions related to learning C not really welcome on this subreddit?
I think the problem is, that those questions have already been asked like a 1000 times :) No you don't need the answer book. Try to figure out the answers by yourself. 
The best way to learn C (or any programming language) is to write code. Just make programs for yourself. Challenge yourself and try to find answers to specific problems when you get stuck on something.
OK, can you rewrite the following more concisely with `fgets()` and `sscanf()`? for (wc = 0; scanf("%*s") != EOF; wc++) ; 
The problem with fgets() is that dealing with lines longer than the buffer you call it with can be a pain in the rear. In POSIX land we have getline(), but that doesn't help if you're stuck on Windows or something.
I could go through this but instead could you explain how yours does html templating? Mines uses libflate-2.0.1. That has a nice interface described here: https://github.com/featen/aehttpd/tree/master/deps/libflate-2.0.1
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [featen/aehttpd/.../**libflate-2.0.1** (master → 28895ad)](https://github.com/featen/aehttpd/tree/28895ad2aac9761a6eec5fe2f99eb38ee5548351/deps/libflate-2.0.1) ---- 
At least in my country ( Italy) most introduction courses are not C-specific but they use C as a support language to give an introduction to programming and algorithms in general and this is why they stick with scanf, fscanf etc instead of read the input as a string and then parse it. It would be unnecessary hard especially for those students who won't work with CS ever again after the exam, also the input in those kind of exams will be always nice so the scanf family functions will work fine and there's no need to make it harder
Yes, best way, that worked for me, is to define some project. Define what would you like to create, it can be anything and just start writing. At the beginning it would be hard but in my opinion this approach is most effective. In my case it was that I was using assembly for microcontrollers and just wanted to learn C, so I started to rewrite my assembly into C. Than I was starting to create some C code for desktop to control my devices.
&gt; technology 
When it comes to network programming in C I can recommend this very detailed free online book / tutorial : https://beej.us/guide/bgnet/ 
I don't know. I've been meaning to experiment with kcgi but haven't yet done so. The main man page mentions kcgihtml, which may be relevant: https://kristaps.bsd.lv/kcgi/kcgihtml.3.html. That's not quite templating though.
I personally recommend C how to program by Harvey Deitel and Paul Deitel,the 7th edition is the best in my opinion but the 8th is also great. Both editions offer an introduction to C++ once you feel you are ready and the book is well paced making sure it teaches every C concept to, although I was disappointed by the lack of it showing you more c libraries than just the standards,math and string. Overall I recommend you get it!
&gt; I don't know Then why recommend? Writing a websever (using iocompletion ports or epoll), parsing http etc. is a piece of cake. What is difficult is generating the html + javascript dynamically.
If you stuck at some problem you can easily find the answer on the internet. I've seen already a few of GitHub repositories with them.
Once you feel fairly comfortable with C, look into going some [Project Based Tutorials in C](https://github.com/rby90/Project-Based-Tutorials-in-C)
&gt; Then why recommend? Because it's a commonly recommended package for the [BCHS stack](https://learnbchs.org/) (BSD, C, httpd, SQLite) that I've heard good things about. Just putting it out there, people can make their own informed choices.
Also there's a list of books in the sidebar, but if Reddit has you on their new UI nothing shows up there. 
If you can, try to find a copy of Expert C Programming- Deep C Secrets, by Peter Van Der Linden. A lot of the information is dated, dealing with the x86 real mode segmented memory model and other ancient stuff, but there's still a lot of relevant information on the design and history of C, pointers vs. arrays, and more. I still take my copy to the bathroom every now and then when I need something to read. When I was learning C back in highschool, I had my school library's copy of C Primer Plus checked out pretty much constantly. I remember it being pretty good, but that was the early 90's edition; I haven't read the newer editions. These days, though, you can usually find answers to just about everything on the Internet. I suggest picking a subject that interests you and see what there is for open source/free software written in C, grab the code and start digging through it.
As a part of the project, an array is held in RAM, and when the device encounters an interrupt, the array is to be moved to a different location in RAM. My thought process was to utilize a circular linked list data structure to move the value to the next node and repeat the process each time an interrupt occurs
&gt; As a part of the project, an array is held in RAM, and when the device encounters an interrupt, the array is to be moved to a different location in RAM. Why is this needed? I don't understand this requirement. What I can imagine is that you have two arrays in the design pattern of a [double buffer](https://en.wikipedia.org/wiki/Multiple_buffering). But then, you don't actually move arrays around (way too slow). Instead, you simply exchange pointers to the arrays so all writes that previously went to one array now go to the other.
Packed structures are not standard C and have never been. If you want to write portable code, forget that they exist. In portable code, there is no way to control structure padding and all attempts to overlay externally imposed data layouts with structures in C programs are futile. Check out the Plan 9 source code for how to do this sort of thing correctly. Basically, the idea is to manually specify memory offsets from the hardware's base address and work with that. Don't use structures, regardless of how convenient they appear.
If you want to follow the spec to the tiniest detail, you can't even assume that a plain *int* doesn't have padding – for some [very obscure systems](https://en.wikipedia.org/wiki/Burroughs_MCP), there can be.
Another, slightly less obscure system is the MSP430X microcontroller from TI. It has a 20 bit ALU and an int is stored as a 32 bit number with 12 padding bits.
You can create a simple packed_enable/disable pair of macros that uses the proper preprocessor syntax depending on which compiler is in play, and manually achieve portability across however many platforms you're interested in building on.
21st Century C is a great little book on using C in modern times
Rob Pike's article about just this: [The byte order fallacy ](https://commandcenter.blogspot.com/2012/04/byte-order-fallacy.html)
Excellent idea. I'll give it a try. Thanks.
*int i;* is just undefined, and you're printing the garbage inside after *sscanf* failed to write anything to it. *sscanf* return the number of assigned elements, so if that's not equal to what you expect (i.e, one) you know the parsing failed. Alternatively, set *i* to something you know is invalid (like zero) beforehand, and then check if it's changed.
You should focus on school studies... But summer is coming. Alright then. Figure out how to use `chroot` and put a statically linked busybox and C compiler inside the jail (real hardware or VM). Bootstrap the system the best you can. GNU Make is fairly easy to compile without a pre-existing `make` for instance. Much of the infrastructure will be in C. You can get binaries from [here](http://tar.sabotage.tech/gcc640/). Don't expect to get too far without cheating somehow, that's the point.
&gt; int i; is just undefined gah - again, I keep doing that, bad habit from other languages...
 #include &lt;stdio.h&gt; int main () { char sentence1 []="Rudolph is 12 years old"; char sentence2 []="Rudolph is foo years old"; char str [20]; int i=-1; int n=0; n = sscanf (sentence2,"%s %*s %d",str,&amp;i); printf ("n=%i %s -&gt; %d\n", n, str, i); n = sscanf (sentence1,"%s %*s %d",str,&amp;i); printf ("n=%i %s -&gt; %d\n", n, str, i); return 0; } this makes it clearer
PDP-11 is the only true C machine.
What are you trying to do? *i* is going to be a garbage value because the first %s captures all of the input (which btw overflows *str*), so scanf is never going to touch *i*.
You should never scan with `%s` without also specifying the length of the buffer. Since your buffer holds 20 character, the length needs to be `%19s` or less. I advice you to foresake `sccanf` and build a proper parser if this becomes too complicated.
I want to use strtol because it seems to be the best one. I'm looking at example of how it is used, it takes 3 arguments. But I don't know what the pointer in the parameters are for. code: `char string[5] = "1234";` `char *some_point; //what is this pointer for?` `long some_int = strtol(string, &amp;some_point, 10); //I don't understand the parameters in this.` I'm going by this example [https://www.techonthenet.com/c\_language/standard\_library\_functions/stdlib\_h/strtol.php](https://www.techonthenet.com/c_language/standard_library_functions/stdlib_h/strtol.php) Anymore insight would be awesome. I have tried to understand it on my own, but I have not made much progress.
Incorrect, the %s specifier in the scanf family of functions only matches non-white-space characters. The first %s will stop at the first space.
&gt; In portable code, there is no way to control structure padding and all attempts to overlay externally imposed data layouts with structures in C programs are futile. With C2x in the works, maybe we need a way to control structure padding? I think WG21 already accepted proposals to add an attribute syntax, which allows things like `[[nodiscard]]` and `[[fallthrough]]`. A `[[packed]]` attribute makes sense to me. An attribute to control bitfield ordering might actually make those usable as well.
No, I don't think so. Every use of packed structures is a design mistake and can be replaced by equaivalent, portable code. Packed structures are difficult to implement on architectures that don't support misaligned memory access. If it is allowed to take pointers to members of misaligned structures (which is possible as soon as you allow an array to be a [transitive] member of a packed structure), you suddenly have the possibility to legally obtain misaligned pointers, something that is well-defined in C. A lot of changed would need to be made to get this right without breaking quite a few assumptions (like how arrays work in general).
You are correct. The declaration is in the for statement.
Reading from a volatile variable is a side effect (§5.1.2.3 ¶2). Assigning to a variable (any variable) most definitely is a side effect (ibid). I don't see any side-effect free expressions whose value is not used in OPs program, so why do you think that §5.1.2.3 ¶4 applies? Note further that §5.1.2.3 ¶4 explicitly states that accesses to volatile objects count as side effects that enforce evaluation of an expression. See also §6.7.2.4 ¶7 which clearly states that the compiler must assume that volatile variables can be modified by forces unknown to the compiler, even if it appears that there is no way. For OPs code, I could for example attach a debugger to the program and change `i` through the debugger. The C compiler must be able to deal with this as `i` is qualified `volatile`.
&gt; Every use of packed structures is a design mistake and can be replaced by equivalent, portable code. Why is it a design mistake, other than it's not portable? Writing the code manually is better because of portability ... but it's also less readable and maintainable, which is also a bad thing. Standardizing packed structures is a win overall. &gt; Packed structures are difficult to implement on architectures that don't support misaligned memory access. If it is allowed to take pointers to members of misaligned structures (which is possible as soon as you allow an array to be a [transitive] member of a packed structure), you suddenly have the possibility to legally obtain misaligned pointers, something that is well-defined in C. A lot of changed would need to be made to get this right without breaking quite a few assumptions (like how arrays work in general). Yes, there are some underappreciated complications to packing structures. Some of these are probably solvable (don't allow taking the address of a packed structure member, to start?), but I have no idea if all of them are. That's for smarter people than me to figure out. &gt; I do not see the point in these attributes either. The pragma mechanism already covers their use cases, this new syntax is just pointless. I suggest reading the C and C++ proposals, which discuss why `_Pragma` and `#pragma` aren't sufficient.
&gt; Why is it a design mistake, other than it's not portable? Writing the code manually is better because of portability ... but it's also less readable and maintainable, which is also a bad thing. Standardizing packed structures is a win overall. Writing code that only works on one combination of operating system and architecture for no good reason except your own laziness is a pretty damn design mistake in my opinion. It's not even hard to get it right, but doing it wrong is very painful when you need to eventually port your code anyway. &gt; Yes, there are some underappreciated complications to packing structures. Some of these are probably solvable (don't allow taking the address of a packed structure member, to start?), but I have no idea if all of them are. That's for smarter people than me to figure out. Yeah but then you can't have arrays in packed structures which makes the whole thing even more complicated. Plus you need to take into account how this meshes with the `_Alignof` operator and what exactly the constraints of packed structures are. For example, do packed structures have an alignment requirement of 1 or are higher requirements allowed? This is important if you want to overlay a packed structure over a buffer of characters you got. The former would kill what little performance advantage remains on architectures that can't do misaligned accesses whereas the latter would break half the applications where you could use packed structures. There are probably more considerations, but these are what comes to my mind immediately. &gt; I suggest reading the C and C++ proposals, which discuss why _Pragma and #pragma aren't sufficient. Having in my entire career never felt the need for even a single pragma, I can hardly imagine any reason. Can you give me a link to the canonical proposal?
Use arrays of machine word sized data.
&gt; Writing code that only works on one combination of operating system and architecture for no good reason except your own laziness is a pretty damn design mistake in my opinion. It's not even hard to get it right, but doing it wrong is very painful when you need to eventually port your code anyway. That's exactly my point -- packed structures create portability problems right now because there's no standardized way of doing them. But if there were a standardized `[[packed]]` attribute then it's a non-issue: your code will work on all operating systems and architectures, as long as the compiler is C2x compliant (hypothetically). &gt; Having in my entire career never felt the need for even a single pragma, I can hardly imagine any reason. Can you give me a link to the canonical proposal? You've never used OpenMP, then, I assume. There's also the standard pragmas `FENV_ACCESS`, `FP_CONTRACT`, and `CX_LIMITED_RANGE`, though few programmers will care about these. Pragmas are pretty much limited to implementation-specific behavior, so if you've never needed that then you've never need to write one. [Here's the latest C proposal](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2165.pdf). The committee apparently discussed this very issue, but [the meeting minutes](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2141.pdf) are rather terse. And [here's the final C++ proposal](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2761.pdf), which is important since the syntax and concept originally came from there.
&gt; That's exactly my point -- packed structures create portability problems right now because there's no standardized way of doing them. But if there were a standardized [[packed]] attribute then it's a non-issue: your code will work on all operating systems and architectures, as long as the compiler is C2x compliant (hypothetically). The problem is: only the most primitive use cases for packed structures (no arrays, no pointers to members, no overlaying packed structures over unaligned buffers) can be realized without either a small performance loss (negating any performance advantage) or substantial changes to the rules and invariants of the C language. Packed structures aren't a thing on architectures that don't support unaligned access. They have to be emulated with a lot of tricks and many common assumptions don't hold. Plus the whole endianess issue remains entirely unresolved. If I need to write code that makes assumptions about endianess, I have to cry. Don't make me cry. Write endianess-agnostic code. &gt; You've never used OpenMP, then, I assume. There's also the standard pragmas FENV_ACCESS, FP_CONTRACT, and CX_LIMITED_RANGE, though few programmers will care about these. Pragmas are pretty much limited to implementation-specific behavior, so if you've never needed that then you've never need to write one. Well, okay. I forgot about OpenMP. But OpenMP isn't really helped by attribute syntax either. And neither are the STDC pragmas as they don't affect declarations. Not that anybody (except Intel perhaps) really supports them correctly.
This is what the proposal says about `_Pragma`: &gt; ##_Pragma &gt; It was observed that C already has the ability to attach extra information to language constructs with the _Pragma preprocessor directive, and it was questioned whether an attribute syntax was required. &gt; &gt; The _Pragma preprocessor directive is unfit as a replacement for an attribute syntax. The string-literal provided to the directive is processed through translation phase 3 as though it was a series of pp-tokens, which are limited in their capabilities. Basically, just a bunch of hand waving. Not convincing.
You should use the function `sscanf` to do string to int conversions. Replace int toInt1 = string1; int toInt2 = string2; with int toInt1, toInt2; sscanf(string1, "%d", &amp;toInt1); sscanf(string2, "%d", &amp;toInt2); `sscanf` works like `scanf` and `fscanf`, but takes its input from a string. Like these functions, it returns the number of successful conversions, so, if you want to make sure that the conversion was successful, you should test that each of the functions returned 1. &gt;To do the reverse, you should use `sprintf`.
Writing a scheme interpreter ;)
&gt; endptr &gt; It is used by the strtol function to indicate where the conversion stopped. The strtol function will modify *endptr* (if *endptr* is not a null pointer) so that *endptr* points to the first character that was not converted. Basically, if `endptr` is not `NULL`, it is used to store a pointer to the first character in the string that isn't converted, usually after the number. This way you can (almost) determine whenever the whole string was a number and what part was actually the number. It's useful when you want to have more strict number conversation. 
Because `fgets`is designed to read a line from a file, so until a `\n'. If your buffer is smaller than the line it will read only the characters that fits in the buffer. You must also consider that in C all strings are null-terminated, so if you declare a `char a[2]` you have effectively a string of one character, because the other is the null terminator of the string (`\0`)
Hello, thanks for the prompt response. Since \`fgets\` only needs to read one character (e.g. 1, 2, 3 or 4) in the example above, wouldn't \`char a\[2\]\` be sufficient?
You need 3 characters `4` `\n` `\0`
It would somewhat work, because you would read a character and the null terminator. The problem is that you leave in the buffer the new line `\n` character so the next time you call `fgets` it will read only a string with `\n` in it, and thus pass it to `strtol`. To work properly you allocate a buffer of size of at least 3.
Ahhh I get it now. I was incorrectly under the impression that \`fgets\` needed only 2 spots in the array; one for the character and another for \`\\n'. Did not think about the NUL terminator. Thanks so much. I really appreciate your help.
&gt; I did not know that `fgets` appends `\n` to the input as well. You may have misunderstood alreghi's post. `fgets` does not gratuitously append a newline. It stores a newline because it reads a newline. In other words, `fgets` _does not discard_ newlines.
&gt; Having *in my entire career* never felt the need for even a single pragma, I can hardly imagine any reason. Hem... well, I usually avoid to get personal, but you are still a student, are you not? So, talking about "entire career" as if it covers a large surface is a bit of an overstatement. Packed structures are useful (or at least handy) and much used in industry, when one has to deal with low-level.
One advantage to packed structs can be smaller code size for reading and writing them (a single memcpy equivalent, vs. a bunch of individual assignments). If targeting an environment where space available for the binary is at a premium then this might be a motivation.
&gt; Hem... well, I usually avoid to get personal, but you are still a student, are you not? So, talking about "entire career" as if it covers a large surface is a bit of an overstatement. Well, I'm a grad student, that part is right. I am however writing C code for at least 6 years and writing C code has been my day job for the last 4 years. I have done operating systems development, and the only pragma I have encountered there is the occasional `#pragma weak`, for which the pragma mechanism is entirely sufficient (I have however not touched any of these), though I would prefer to solve this kind of thing through map files if possible as it's just a much cleaner approach. &gt; Packed structures are useful (or at least handy) and much used in industry, when one has to deal with low-level. I have already said what I think about packed structures in my previous comment. Rob Pike (one of the architects of Plan 9 and Go) wrote [this article](https://commandcenter.blogspot.com/2012/04/byte-order-fallacy.html) summarising what is essentially the point why packed structures and byte swapping are antipatterns.
&gt; One advantage to packed structs can be smaller code size for reading and writing them (a single memcpy equivalent, vs. a bunch of individual assignments). Code size is a point, but only relevant in ultra-constrained environments. The code emitted by the compiler for assigning each struct field individually is (a) typically only a few bytes longer than setting up a `memcpy` call and (b) is emitted only once for the entire program if you turn off inlining. In times like these where people think it is justified to use C++ templates with a carpet-bombing of inline functions on their microcontrollers, surely the few dozen bytes emitted for a proper marshalling procedure can be afforded.
I swear this is a suggestion in every one of these threads. I don't know how many people take it to heed, but having solved ~70 of them in C and Fortran I have not just learned how to write those languages, but how to break down solutions to problems. If you want to learn C, chances are it's for the speed or the portability or learning programming fundamentals; one cannot ignore the influence of mathematic reduction of problems to seek greatest efficiency and simplicity, which is applicable to all of those reasons. 
Any idea how it compares to [Modern C (pdf)](http://icube-icps.unistra.fr/img_auth.php/d/db/ModernC.pdf)?
Saying that declaring 'char a[2]' has space for only one non-zero byte is absolutely wrong.
Modern C is a book about learning to program with C. 21st Century is a book for C developers with some experience on good practices and behaviors. Both are worth reading.
Ah, alright. Thanks for the reply!
You could use it as a 2 element char array that won't work with anything intended to deal with strings, I suppose... So fread() instead of fgets(), no strtol(), etc...
IMHO the mods are already great at catching spam and I don't think formalizing rules about it would stop spammers, it would just make more work for the mods. The other rules rely on subjective terms like "low-effort," "beginner," "intermediate," etc... I'm not saying these things couldn't be defined in a manner that is clear, but it seems like an awful lot of work when the upvote/downvote system already provides a means of sifting through the dregs to find the diamonds. Just my two cents.
Not OP, but I was looking for just this, thanks!
Doesn't seem necessary to me. There's not too much noise and the upvote/downvote system seems to work OK. If you turn the squelch up too high you'll never hear anything interesting.
I don't like disallowing begginer questions as their own posts. For a higher-volume subreddit, I think it would make sense to aggregate them into one post, but for this subreddit, I don't find them too tedious or onerous. One thing I've been toying with is coding up a bot to help out with beginner level questions. It *does* get tedious being like "I can't read your code. Put 4 spaces before each line" over and over again, so it would be nice to have a bot reformat it automatically. Similarly, it gets tedious being like "Did you even try compiling this with warnings on?", so it would be nice to have a bot being like "your code generated these warnings". I've been lazy about it, though....
Here's an example of *checksum* : If the stack has 3 elements: 0xFE, 0x3F, 0x03, then print out the value of 0xF XOR 0xE XOR 0x3 X0R 0xF XOR 0x0 XOR 0x3
The bottom of the first page of new is four days old. I don't think any content is getting hidden by the posts you dislike. 
Well, to start with it sounds like your stack is supposed to hold unsigned chars, but that code (please post properly formatted actual code, not images!) just reads a bunch of strings into an array. Presumably the instructions to manipulate the stack? So start by getting the easy bits - push and pop working, then add support for the other instructions.
Am I suppose to implement the push/pop functions in stackChecksum function? I'm not entirely familiar with how you can define functions within functions. 
Which is the entire point of a thread for beginner questions. There are posts with interesting discussions (usually article posts) that get flooded by posts with beginner questions, even if they have low points.
You're supposed to implement all four instructions and then apply them to a stack according to the program that gets passed to that function. Essentially you're writing an interpreter for a very simple language.
There is no flood. This sub gets a modest number of top level posts. Anything less and the sub is going to look abandoned. Upvoted quality posts tend to generate a good amount of internal discussion and hang around a bit. Beginner questions and fluff get a few responses and drift out of the picture. Sounds perfect to me. 
I've already unsubbed from other C subreddits because I got tired of "ETExplains" posts.
I don't get the impression that beginner posts are created by regulars of the sub, but mostly from people that have spontaneous need and come to the first place they can think of. You can make all the rules you want but it won't change a thing for beginner posts, it's not as if they new the rules (otherwise they'd read the sidebar and post to other subs) and we don't have the army of mods necessary to quickly shoo them away. Even with a beginner thread my experience in other subs is that beginners will just create their own without noticing it or without thinking of their question as a beginner's question. I've got nothing against stopping spamming though.
There is /r/C_Homework for homework questions. Feel free to direct stuff there!
Sounds good to me, how does /u/FUZxxl feel? I know he was against it.
First, what is a low-effort tutorial? Unless you are just ripping off someone else's work, spamming or spreading misinformation, any tutorial should be welcome. Second, everyone started as beginner at some point, asking questions and following tutorials for the most basic concepts. Disallowing such content just makes the sub seem elitist and intimidating. If you don't like it, downvote it and/or hide it. Also, there's always things you may not know about some basic stuff in C. I consider myself intermediate C programmer and I spend a lot of time on this sub just reading beginner questions and people's answers to those questions. I find that valuable learning for myself. No issues with banning spammers, but that is much larger problem with reddit and mods can't do much about it until after the post has been made.
I disagree and I say that from the perspective of a beginner. It's annoying to see constant basic questions. I have a bookmarks folder full of resources that answer pretty much every beginner question I've ever had. Not once has reddit answered a question for me that wasn't easily available on a popular learning resource. I don't think this sub should be used as a supplement for those kinds of resources. Leave that to learning programming subs. I'm subbed here to see interesting posts on cool and creative shit built with C. I may be wrong but I think most beginners who aren't new to the internet as a whole will understand that this subreddit isn't meant to be a resource for answering 200 level questions.
Thanks for the clarification. So in the code example above, where does the `\n` get appended? When the user hits enter?
Are you a mod? You don't sound like a mod...
&gt; It's annoying to see constant basic questions. Why? I'm genuinely not trying to start conflict, I just struggle to understand this mentality.
I understand. There's sidebars and full separate subreddits, stack overflow, and uncountable "guides" and books tailored to beginners. MIT has a free course that I followed to finally grasp C in a beginners level. I don't use /r/php to find beginner php resources, I want news and new developments and I treat this sub the same way. The PHP sub is curated to give people who know how to use the language a little bit of news and resources to add on. Magbe I'm misunderstanding what this sub is for but I've always treated it the same way..
Here's a sneak peek of /r/PHP using the [top posts](https://np.reddit.com/r/PHP/top/?sort=top&amp;t=year) of the year! \#1: [Used PHP in a Hackathon was made fun of and it made me feel really shitty.](https://np.reddit.com/r/PHP/comments/8ed9tt/used_php_in_a_hackathon_was_made_fun_of_and_it/) \#2: [$emergency](https://i.redd.it/81besxu7lxy01.jpg) | [10 comments](https://np.reddit.com/r/PHP/comments/8kq9ke/emergency/) \#3: [So this is the crap PHP devs have to deal with.](https://i.redd.it/d9foiaexjtpz.png) | [218 comments](https://np.reddit.com/r/PHP/comments/748a4e/so_this_is_the_crap_php_devs_have_to_deal_with/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
r/php has nearly double our numbers. PHP as a language is less mature, so libraries with a wide audience are still developing and being shared. Beyond that it's not the de facto basis language for most higher level languages, or operating systems. In contrast C is very mature; most libraries in development are niche to the point that they aren't shared with the general community, and those libraries with a wide scope have been around for like 15 years. As a language C is changed very rarely because it is the foundation of most modern systems, so changes need to be carefully considered. But I think the biggest difference is development time. Getting something on your screen with PHP takes easily way less time than getting something going with C, even with a high level API. There's way more turnover in completed projects with PHP and similar languages so there's more to talk about. With C there's generally less news, so I feel like if you take away the opportunity for questions this sub would probably wither. In fairness, I enjoy helping beginners, so I'm probably biased.
I agree with everything you're saying and don't see why any point means more barebones C beginners should receive more posts. The way I see it this sub would be better off focusing on being productive for people who understand and work with the language rather than catering to people who are trying to becomr familiar.
&gt; Based on my research, it occurs automatically when the user hits "enter". That's right.
The way I see it the sub doesn't cater to either, but offers a forum for both to interact; the beginners get to see what the more advanced users are working on and how they work, while the advanced users can see how beginners learn and shape their projects to help ease new users into using them. My fear is that barring beginners from participating would hurt both groups, while allowing and encouraging them hurts neither.
OP is not a mod.
&gt; Why? I think "Beginner questions" simply don't have much in common with the topic at hand. When I want to read posts/articles about a language (or gamedev or painting or any other topic) I am simply not interested in a constant stream of "day one questions" about simple problems regarding the topic. I can ignore those questions (and I do), but they are still noise that has to be filtered out. To me it makes much more sense to have dedicated subs/threads for beginners. 
My problem with this is that nobody seems to care enough to make a parallel subreddit with the explicit goal of separating out beginner questions. It leads me to believe that for the people who would like to see a change they either don't think it's worth the effort, or they don't think the community could support both subs. Maybe I'm oversimplifying, because as I mention elsewhere I am biased, but if the community isn't what you want to see, then why not attempt to effect change in it instead of nagging the mods?
&gt; why not attempt to effect change I don't feel responsibility for subreddits. I visit this site, read a bit, post occasionally, and that's it. So, you're right, I don't care enough. (But I don't "nag the mods" either). I only answered here because I wanted to explain my reasons behind the "mentality" of separating beginners questions from the rest of information on a topic. 
My bad on the wording, I meant it more as a royal you than you in particular. I feel like I could reword it as: if there's a market for this demand why isn't it being filled?
You have space for 2 characters, but if you use it as a stribg only for a string of length 1, because in C every string must be null terminated 
&gt; if there's a market for this demand why isn't it being filled? I think OP is trying to do this by having a discussion about the options?! :)
For sure, but it's far from the first time, and the mods have consistently (and IMO reasonably) not made changes like the ones OP suggests. I see posts like this with relative frequency and, like clockwork, a majority of the sub leans in favor of not making changes. It's just a little shocking to me that a group would continue to lobby for change, be denied, and not attempt to effect it themselves.
The correct link is this one: [http://www.catb.org/esr/structure-packing/](http://www.catb.org/esr/structure-packing/)
&gt; My problem with this is that nobody seems to care enough to make a parallel subreddit with the explicit goal of separating out beginner questions. People tried both separating out homework questions (/r/C_Homework) and banning them (/r/Cprog). Neither was really successful. I don't think removing beginner's questions is a good idea, though I am not against higher quality standards.
Thanks so much again for your help!
&gt; First, what is a low-effort tutorial? Unless you are just ripping off someone else's work, spamming or spreading misinformation, any tutorial should be Some examples removed recently: * https://www.codelike.in/c/array/dynamic-allocation-of-array-in-c * https://www.reddit.com/r/C_Programming/comments/8lscvf/how_to_start_learning_c_programming/ * https://justdocodings.blogspot.com/2018/03/sudoku-visual-c.html * https://notesformsc.org/c-program-for-law-of-sine-problems/ Many of these are basically just thinly veiled solutions for common homework problems. A lot of the content is often copied from other sites or plain wrong.
&gt; I don't get the impression that beginner posts are created by regulars of the sub, but mostly from people that have spontaneous need and come to the first place they can think of. Very well said. That's why I was reluctant to add more rules, too: there is just no way to enforce them if you don't get repeated posters.
While I like the notion of giving this sub a bit more stability, I think you over estimate the amount of posts coming in. If the weekly beginner question rate was doubled, I still wouldn't consider it a flood of posts.
I totally agree.
An auto-moderator that hides/removes posts asking *how* to learn C would be good. The people asking have put in *zero* effort into researching beforehand. If they can't put in 10 minutes to read the sidebar resources or search for previous posts that cover the subject **extensively**, they should be redirected by the auto-moderator to /r/learnprogramming or the [CS50 course](https://www.edx.org/course/cs50s-introduction-computer-science-harvardx-cs50x) To be clear, there is a significant difference between asking *how* to get started in/learn C and asking *about* a specific subject in C
What are you trying to achieve?
Should not we have a sub-reddit just for questions? C\_Questions? And a fixed post referencing all the begginers books? 
https://www.amazon.com/C-Programming-Modern-Approach-2nd/dp/0393979504
I created a simple C program, imported windows.h and call MessageBox (nothing fancy). When I disassemble the executable, instead of 1 entry point there are 3 (start, TlsCallback_0 and TlsCallback_1). Also 2 extra sections are added (.crt and .tls), which make the .exe file bigger. So, I'm looking for a way to generate an executable with only one entry point and get rig of those TLS callbacks. Extra: Because those Thread Local Storage callbacks are executed before the actual program code (__start), a lot of malware have been using this as an Anti-Debugging technique. My sample is detected as a trojan on virustotal by 4 AVs, probably because of these callbacks?
Yeah.
I've seen this book mentioned here and there. Is it something one should read after K&amp;R and some experience, or is it like a modern substitute for learning C?
Yeah, this is just spam and it has been rightfully removed. So I don't understand what OP is complaining about.
\&gt; Don't create posts for beginner questions Where do you draw the line?
[removed]
Nice!
Awesome :D
Still legal C but gives a warning on most compilers.
N00b forget 2 #include&lt;studio.h&gt;
&gt; an error What is the actual text of the error? That's a really basic part of troubleshooting.
Interesting to see Kernighan does not use K&amp;R style.
Are you referring to these? ~/tmp $ gcc tmp.c tmp.c: In function ‘main’: tmp.c:28:13: warning: passing argument 1 of ‘reverse’ from incompatible pointer type [-Wincompatible-pointer-types] reverse(arr); ^~~ tmp.c:2:6: note: expected ‘int **’ but argument is of type ‘int *’ void reverse(int *a[]){ ^~~~~~~ Or the fact that it segfaults when you run it? 
C doesn't have pass by reference, only pass by value.
I like their style of writing but the code samples will never work. There is no point of buying this book.
It compiles and runs without it, at least with gcc it does.
Huh? That is K &amp; R style
I'm glad to see that Brian Kernighan draws braces about as well as I do. And by that I mean horribly.
Technically your passing a pointer by value, as C does not have pass by reference. Also you should avoid using sizeof too much, it just gets allocation size. Passing the size of a value is the recognized standard. Anyway your error is probably because your referencing past the end of the allocated array on the following lines. *a[i] = *a[(sizeof(*a)/sizeof(int))-i]; *a[(sizeof(*a)/sizeof(int))-i] = hold; Try this as a replacement. void reverse(int *a, size_t size) { int i, j, hold; for(i = 0; i &lt; (size &gt;&gt; 1); ++i) { j = size - i - 1; hold = a[i]; a[i] = a[j]; a[j] = hold; } }
On what planet?
What on earth are you talking about? This is the Second Edition.
Is this a thing? Does he sign books if you send them?
It isn't -- the opening brace of a function should be on its own line. The hello world example on Page 6 of K&amp;R is: #include &lt;stdio.h&gt; main() { printf("hello, world\n"); } 
You can follow their sample codes. They don't work. You would constantly need to ask Google like "Why does the code on page ** of K&amp;R not wokring?" I know I am on earth. I feel some decent gravity.
Ok, it seems there can only be one printf... It warms though.
What compilers are you using for the samples?
gcc from downloading XCode, which is very standard anyway. If you have a problem with using gcc, then you have a problem. 
Great. What flags do you use when compiling the samples?
*stdio
r/woosh
Ironic.
I don't remember. Sometime none, some time debug on. Why are you interrogating me?
He's not wrong. I was helping a friend to understand an error in an example he copied out of the book. They defined a function that at some point got defined in one of the system libraries so gcc was complaining about wrong arguments. 
I am not interrogating you, son. You are free to not reply. I am trying to help you understand how to compile and run those code samples that didn't work for you. Google isn't the answer. The Second Edition's Preface mentions that the examples are ANSI standard compliant. When you use gcc, make sure you use the -ansi or the -std=iso9899:1990 flag. [Reference](https://gcc.gnu.org/onlinedocs/gcc/Standards.html#Standards). All the examples will compile as is. 
So tabs or spaces?
ITT: people commenting on the coding style of a scribbled note.
GCC would be the issue here and not the book. Have you updated the include paths for GCC? If the "system libraries" are updated, that isn't any issue with the book that teaches the language itself. The code can be compiled if you know what header files your compiler is including and what libraries it is linking the object file with.
disgusting
It's kinda weird, it seems as if some people misread the title as "The Roast of Brian Kernighan"
legacy book, legacy code!
Think about how it will be effective teaching material to tell beginner programmer like C to use the flag and write it in preface with no context. It will be very easy for them to write a new edition, add something like "by the way, we recommend using gcc and with the flag. For example, in your terminal/console, instead of simply complie the program such as "gcc test.c -o test" you would want to type "gcc test.c -o test -ansi" or "gcc test.c -o test -std=iso9899". in case some of the example codes in this book may not work." When students find the problem, they are not going back to read Preface, they are going back to the chapter 1 to see if they miss something that cause the problem. 
For a book that's meant to teach C, that's quite a lot to ask to be honest. I think if examples in the book don't trivially compile on the most popular compilers something's wrong with the book, not the student who is within the first 20 pages of the book. 
Ah, but that is the student's problem if they choose to not read the Preface. The book by itself is self-contained and has all the necessary information. K&amp;R does not recommend any specific compiler. They specifically call it cc or C compiler. The purpose of the book is to teach the language not the compiler. &gt; "by the way, we recommend using gcc and with the flag. For example, in your terminal/console, instead of simply complie the program such as "gcc test.c -o test" you would want to type "gcc test.c -o test -ansi" or "gcc test.c -o test -std=iso9899". in case some of the example codes in this book may not work." There are [a hell lot of compilers other than gcc](https://en.wikipedia.org/wiki/List_of_compilers#C_compilers). If a next edition is written at all, do you expect Kernighan to appease all audiences and mention all flags? Kernighan or Ritchie do not recommend a specific compiler and probably never will. The book is about the language and does not (and should not) cater to a particular compiler. 
Say you want to learn Java. Would you not find out whether you need to install OpenJDK or Oracle's JDK to develop/run the example programs? What version of Java would be good for you? K&amp;R mentions that it uses ANSI C on the first page after the table of contents. Now, it is the reader's job to find out how to get an ANSI C compiler. These "most popular compilers" offer in depth documentation on how to run programs with certain specification of C, including ANSI C. Expecting a student to learn how to compile in ANSI C when they are trying to learn ANSI C, isn't a wrong expectation.
Next time I'll try to convince somebody to learn C I'll make sure to remind him to read all he can about compilers first -.-
Hahaha I see how my reply could be misinterpreted. Of course you shouldn't be an expert on compilers. But you should at least try to run code on a compatible compiler. The C language as u/Ikuyas mentioned, has changed over the past 30 years. Not all compilers will support ANSI C. But if you are learning through the book, it mentions that they comply with ANSI standard for C. And so using an ANSI C compliant compiler out of the box is the best bet while running the examples. 
Ah yeah, the old-style funcion declaration... anyway nice nail polish!
Haha, I'm glad someone noticed, thank you!
I haven't written c in years, what warning does it give?
I visit this subreddit to mostly see interesting stuff related to C, but I don't mind beginner questions. I think it's fine to ask "beginner" questions where it's genuinely a question about this specific programming language, what I think should be discouraged is: - Questions that are actually about *programming in general*, not about *C programming*. If it looks like the OP couldn't solve this problem in their favourite language, or if the OP's code / questions are about basic imperative programming constructs (usually control flow) then it's not a C programming question, and it should be asked in a general programming help subreddit. - Questions about C that arise from not understanding computer architecture, where the question looks like it's about C but really OP needs help understanding von neumann / turing machines / the stack / the heap / how CPUs work / twos complement / floating point / logic / memory addresses / calling conventions etc work. In these cases OP should be directed to some material on this, or maybe advised to learn just the basics of some assembly language (MIPS or just intro to x86) - Obvious intro-to-programming homework questions involving toy example programs - Badly formatted code
Missing return type, missing return statement and implicit declaration of printf
Fair enough. I guess I myself am not too familiar with what's in which standard and what exactly is supported by which compiler. I just get gcc enable all warnings and hit run. You're right in that they do specify the standard. I guess I should check if they give any warnings about using gcc. 
It's not that bad, actually. They \*only\* do it for functions. if, switch, etc. etc. are all same-line. I think it's a nice distinction visually, though I don't do it myself for most projects.
It is well written, which I mean they explain things very eloquently. But it is time to fix these quirks after 30 years. The way people learn programming has changed. What I mean is that learn to program something has become more common and require a quick way to learn multiple languages. You cannot spend so much time on learning C like 20 years ago when there are only handful of computer languages that are widely used.
So gcc doesn't follow the standard?
If you already know wtf ANSI is, then you won't be reading this book. Students and people would just understand it as some kind of standard and standard compiler like gcc which is freely available will work. 
There is nothing to fix. There are no quirks. And you are actually diverting from the topic (not being able to compile the sample code from the books). Each individual learns programming differently. You need not learn multiple languages. Learn the basics. Learn just 2-3 languages and be proficient at them. Also, I am unable to understand what you want to say when you say the following. &gt; You cannot spend so much time on learning C like 20 years ago when there are only handful of computer languages that are widely used. C was a widely used language 20 years ago. C is still a widely used language. No one loses anything in spending time to learn it today. If you need any help regarding the compiling and running the code samples, let me know. Otherwise, I tried my best to help you understand why the book is still valid today and let's agree to disagree on this. Have a nice day! :)
GCC complies with a lot of standards. It doesn't comply with a lot of things too. As I mentioned in the thread, use the appropriate flags to compile against a particular standard.
As I mentioned elsewhere gcc works. You need the right flags. The authors are not responsible for the compiler development. They are responsible for giving you a language.
Can we not become another hipster sub where half of the content is "check the picture of what I just got"? This post is *not* about programming at all.
&gt;This post is not about programming at all. Hence the 'Etc.' flair. This post might not be directly related to programming, but so what? It's about a historically important program, book, and author, all of which are directly related to C. I thought it was kinda cool and apparently so did 200 other people. As for your assertion that "half the content is "check the picture of what I just got"", this post is really the exception, not the rule. Of the 25 posts on hot right now, 16 are questions, 3 are articles, 2 are discussions, 1 is a project, 1 is a review, and 1 is this post. The sub is hardly being overrun by hipsters.
That's an old day computer science industry, sir. But C is a very good language to learn "precisely". You gets to learn about memory allocation, and what things are immutable and so on while you don't have a chance to learn those subjects in other languages. Maybe C++ is the next lowest level language to talk about a pointer. But not like "30" years ago, we have a lot of high level languages to become familiar with, which they didn't anticipate 30 years ago. Nobody really builds stuff in C like 30 years ago. Probably 1% or fewer programmers use C while back then probably like 30% or something. They are just arrogant to refuse to revise it, I think. Or making learning C more difficult than it should be to protect their colleagues. 
Side effects are explicitly covered by the bit I quoted, as is access to volatile objects, and I certainly didn’t/wouldn’t assert that the loop is side-effect-free. Assignment to `i` is a side effect, and `i++` has two side-effects in it, reading from `i` and updating `i`. But that’s irrelevant; it’s perfectly acceptable for the compiler to screw with expressions that have side-effects. E.g., in { int a; a = 4; b = c = a; } expression `a = 4` has a side effect, but it’s perfectly legal for the compiler to instead treat that block as just `b = c = 4;` because the side effect from `a=4` isn’t needed. Side effects aren’t necessarily globally visible, and unless there’s some actual data/control dependence on them (or some ABI/implementation requirement) there’s no need to generate code for them. Along these lines: OP’s loop declares `i` only to exist within the loop head and body, `i`’s address has no means of escaping its scope, and the loop only includes accesses to `i`. Thus there are no needed (i.e., visible from outside the loop) side effects, there are no used (i.e., referenced from outside the loop) values, and the externally-visible result of execution (i.e., what’s considered by the abstract machine definition and what any block of C code “means” per the standard) would be the same whether or not the loop, accesses to `i`, or `i` itself are there at all. Specific ABIs or compiler options could of course force accesses to `volatile`, or forbid this kind of optimization when `volatile` is involved. If `i` were defined as a non-`static` global or forcibly escaped otherwise, the loop wouldn’t be eliminable by the compiler, although LTO could still potentially kill it. In C11, AFAICT 6.7.2.4 is for `_Atomic`; 6.7.3¶7 covers `volatile`, and I’ll quote what I have for it: &gt; An object that has volatile-qualified type may be modified in ways unknown to the implementation or have other unknown side effects. Therefore any expression referring to such an object shall be evaluated strictly according to the rules of the abstract machine, as described in 5.1.2.3. Furthermore, at every sequence point the value last stored in the object shall agree with that prescribed by the abstract machine, except as modified by the unknown factors mentioned previously. What constitutes an access to an object that has volatile-qualified type is implementation-defined. The first sentence is governed by “may,” which leaves the implementation behavior open. The second sentence refers to the rules of the abstract machine as governing expression evaluation and actual value, and 5.1.2.3 explicitly provides for elimination of accesses to volatile objects, which would make no sense if “other unknown side effects” were mandatory. For the standard to require that the implementation deal with unexpected value updates etc., it would need to explicitly state that accesses to volatile objects can’t be eliminated, and it doesn’t state that anywhere. (And of course, what “access” means is left entirely up to the implementation, which renders most of this moot. `volatile` is a considerably weaker qualifier than what most people seem to expect of it.) If the debugger needs to be considered (it usually doesn’t), then the compiler still has plenty of options in terms of optimization. If the compiler doesn’t create any `i` at all, then there’s nothing for a debugger to update in the first place. If the compiler omits the loop but allocates `i` and initializes it to 255, the result of execution would still be the same regardless of the debugger; nothing happens. The compiler could emit a series of assignments to `i` (rolled or unrolled) without referring to `i`’s previous value; `volatile` does not make `++` atomic, so any update by the debugger would be everybody’s favorite race condition. More generally though, debugger visibility does not typically affect escape or dependence analysis; whether it affects a value being used or a side effect being “needed” per 5.1.2.3 is left entirely up to the implementation.
I agree with most of the things you are saying. Your numbers are off but the truth is percentage of programmers using C has reduced. Every few years a new ISO for C is released. C is revised and improved upon. Then compilers follow and try to comply with the new standard. Not all revisions are backward compatible. So, compilers introduce flags to ask the user for information on what version of C to be used. If you are interested in learning how C is revised and what is the latest version, please check [this link](https://www.iso.org/standard/57853.html). Nobody is making C more difficult to learn. But it is easier to learn C if you learn it the way the inventors wanted to use it. Reading K&amp;R is one good way to start. It may not necessarily be the best. But I have seen people become good C programmers after using it. 
Have you ever opened your mailbox and found junk mail? That is what these questions are. Most of them, as noted by others, are easily answered through a Google search. I doubt anyone would prefer high-volume junk mail to low-volume legitimate mail.
&gt; As for your assertion that "half the content is "check the picture of what I just got"", this post is really the exception, not the rule. Of the 25 posts on hot right now, 16 are questions, 3 are articles, 2 are discussions, 1 is a project, 1 is a review, and 1 is this post. The sub is hardly being overrun by hipsters. Don't you know what a slippery slope argument is? It's not always true, but when community discipline is involved it often is.
The slippery slope argument is not just "not always true", it's wrong so often that it's generally considered to be a [logical fallacy](https://www.logicallyfallacious.com/tools/lp/Bo/LogicalFallacies/162/Slippery-Slope). Why does one post about something related to C but not specifically about programming itself make you think this sub will inevitably go down the drain?
As of C99 anyway, `main` is allowed to have no return statement (implicitly returns 0).
It's called a tendency. When you see the same thing happens you extrapolate so you can avoid future disasters....
look at all execution process to swap array element. line by line [https://www.codelike.in/visualization/c-reverse-array-element/46](https://www.codelike.in/visualization/c-reverse-array-element/46)
look at list of top most c and c++ books [https://www.ideashare.in/c-and-c-plus-plus-books/](https://www.ideashare.in/c-and-c-plus-plus-books/) to learn about depth concept in c.
I might go back to finish K&amp;R with the flag. The book is very good and it goes pretty fast because it is such a pleasure to read it. 
It's hard to beat a contiguous vector. A linked list frequently won't have nodes in the same cache line (though I wish I had a resource to cite for this). To avoid vector resizes, you want to allocate the maximal memory up front assuming you're not doing huge allocations that will blow through the budget. One thing game engines might do; don't reserve any space in vectors, but instrument their containers to log the maximal effective sizes. Then spin a new build that for each vector reserves the effective maximal size at runtime. If you need more, it's still growable. (example: the max size we ever saw for the entity_array at runtime was 500; so malloc(500 * sizeof(entity)); thus no growing until we hit at least that). But don't forget that that the cost of copying is amortized as well.
Can you give me a more concrete example of case #2?
Oh god, I'm picturing code with only stack allocated unions. Yuck!
If you're passing size as size_t, then the indexes should be the same type.
For instance, say you have a color that is ARGB. With a union you can treat it as a 4 bytes independently, or a 32 bit number. The instruction set might have support for 32 bit instructions and 8 bit instructions. The 32 bit instructions take 2 cycles and the 8 bit instructions take 1 cycle. When ANDing the color you can do 2 cycles vs 4 if it was stored as 4 bytes, but when you just need to read a single color, you can use the 1 cycle operation. Another case is most embedded micro controllers lack FPUs and have to emulate the operation with software. So storing a float as a union is handy when you want to do bit manipulations on floats (for speed ups), and only use the full math when necessary. Unions basically are just more convenient casting.
It works because the implicit declaration is compatible with the real definition. The first time GCC sees your printf() statement it will see, for example, this: printf("hello, world!"); and decide the prototype is: int printf(const char *); Which is great, because the real definition is something like: void printf(const char *fmt, ...); So, come link time, everything is swell. If you add a second, conflicting, printf() you have a problem. The following, for example, is not compatible with the implicit definition (as it adds an integer argument): printf("There are %d minutes until my meeting.\n", 2); If your second printf(), instead, just had another string it would probably work. I haven't tested any of this, but it's based on the C standard's allowance for implicit declarations. Assume the return type is int, and assume the arguments match the types of those passed. Any conflicting definition becomes a compile-time error! I need to head to a meeting, but I'll do some experiments afterwards to make sure I'm right..!
Oh yes
Spaces you heretic! :)
Just curious - do you recall which function it was? I had worked through the book a few years back, and didn't face any problems as such. Was the function \`getline\` by any chance? C++ does have \`getline\` defined, so was your friend using a C++ compiler? 
I had worked through the book a few years back (not that long ago), and don't recall facing any problems. Could you, perhaps, list some examples?
To be fair, from what I recall, the very first chapter of K&amp;R (2nd Edition) contains a disclaimer from them that compiler specifics may vary, and that the user should consult their compiler'd documentation. Also that the code itself should work with any ANSI-compliant compiler (which it does in my experience). That being said, I agree that compilers today are very complicated beasts, and finding the right documentation from the official docs might be difficult for a beginner, but in that case, forums, IRC channels, and even Google can help out tremendously. Moreover, that is a one time effort because once you get the correct flags figured out for your specific compiler, you don't have to worry about that anymore.
I actually like it myself. It also makes for a nice contrast, visually, with say, Java.
Right. That's one of them. There are many posts about the exact questions on stackoverflow.
Take a look at: [http://www.deleveld.dds.nl/inherit.htm](http://www.deleveld.dds.nl/inherit.htm) You can do inheritance in a type safe manner. No casts and the compiler will warn you if you do an incorrect conversion.
The real definition returns int, not void. It returns the amount of characters that were successfully printed. I'm not sure I remember 100%, but I think if you don't declare, you can have multiple calls with multiple different numbers of arguments and it'll be fine. It'll just assume a return type of int and a variable number of arguments, like int printf(...).
&gt; An object shall have its stored value accessed only by an lvalue expression that has one of the following types:88) &gt; &gt; ... &gt; &gt; * ~~a character type~~ via a pointer with a properly aligned type. This kills the strict aliasing rules. Seriously, if you add this language, you can throw out the entire paragraph because you just added a catch-all that makes it completely pointless.
About half of the posts I remove are shitty tutorials like these. Roughly the other half are posts were people post C++ content. At least the spammers usually get the hint.
Object Oriented Programming is a design pattern. While many languages provide special language support for this design pattern, C does not. That doesn't mean that you can't do OOP in C, it just means that you have to do it yourself.
The best way to be ready for a programming interview is to be good at programming. You can try to fake being good at programming, but unless your company is shit, they are going to notice eventually and kick you out. Apart from that, calm yourself down, wear good clothes, remember to keep eye contact to the interviewer.
This subreddit is about the C programming language. How is your question related to C?
&gt; When I read from a file using standard I/O, how much memory should I allocate for the buffer? The stdio implementation should allocate a buffer of suitable size for its internal buffer. For the buffer you read data with `fread` into, &gt; should I allocate only enough for a chunk of structures or in the case of a text file, should I allocate only enough for a single line? seems about right. Remember, stdio does buffering for you. Choose your own buffer size according to what is the easiest to program with.
K&amp;R style has a very good reason, namely, it makes a lot of sense when you have K&amp;R-style function definitions which look like this: int main(argc, argv) int argc; char *argv[]; { ... }
That's the Million dollar question. But seriously, it really depends on your use case. A good rule of thumb is that you never try to read a whole file, instead read the minimum you need to do something useful, and loop over. Sometimes you *do need* to read the whole file, and that's ok too. Or you *know* the file will be small enough to fit the available memory, so reading it all once is more efficient. Again, in the end it depends on your concrete use case. Also don't overthink it. Remember Knuth's words: "Premature optimization is the root of all evil".
You're right, compiler warnings aside, size_t &gt;&gt; 1 could be greater than the max int value.
Thank you I guess your right I'm having a bit of trouble on pointers but with practice I hope to have them figured out, I'll avoid using sizeof() for now, I was just hoping to find an effficient way to get the size of an array without having to input anything into the parameters.I'll try your code as soon as possible thanks again!
Strange I saw something talking about passing by reference in C, maybe I was just seeing things,I'll remember this thanks!
Yes this is the error I'm geetting sorry for not sharing that in all future queries I may have I'll share it.
I found this version online https://m.ebay.com/itm/C-Programming-Language-by-Dennis-M-Ritchie-and-Brian-W-Kernighan-/232027402376?_mwBanner=1&amp;_rdt=1 and I wanted to know whether it’s the same as the US edition or if there’s a difference between the two
I just had a thought this morning. I wonder if there would be interest in a subreddit named something like /r/ThinkLikeAProgrammer. Essentially, it would be a language agnostic place to talk about *how* to do things. The idea would be that the seeker would be stepped through the logic -- what is happening during a sort, or doing a REPL. Being done in a language agnostic manner (or maybe choosing something like Pascal, unlikely to to be used in a class) forces the seeker to (a) think about the logic, and (b) apply that logic to the language in question. 
In all my years, I've never gotten around to using ncurses. Thank you, I now have a tool if I need it. This reminds me of some of the stuff I used to do in DOS, using the libraries that Borland provided. 
When people say that "C doesn't have pass-by-reference", they mean that C doesn't have a special language feature and syntax for passing by reference, like C++ has. In fact C++'s so called references are probably where the confusion comes from ([Reference (computer science)](https://en.wikipedia.org/wiki/Reference_(computer_science)) vs [Reference (C++)](https://en.wikipedia.org/wiki/Reference_(C%2B%2B))). Of course you can pass-by-reference in C. A reference is just a means to "refer" to some entity; in C you can use a pointer or array index for that. Pass-by-reference in C is usually done by passing a pointer.
To add to this, you can change the internal buffer with setvbuf, this might be handy when you want to disable it or provide your own.
Mail is private and directed to you specifically. This is a (relatively) public forum, and if people choose to (ab)use it to answer questions they could have googled so be it; rules wouldn't stop them, mods enforcing those rules would, and we have few enough that I don't feel right making more work for them. Instead, I posit we help people asking silly questions by pointing out that googling first would get them faster results. I would rather this community tolerate nonsense and help everyone than condemn newcomers in order to cater to people who see this forum as their own personal mailbox.
Very much appreciated!
 #define arrlen(x) (sizeof((x))/sizeof(*(x))) I used to use this long ago before I knew better.
I would expect the code in an introductory Java book to work the same on Oracle's OpenJDK and Oracle's Oracle JDK. Is this not usually the case?
Please keep posts from your site down to one post every few days. Nobody wants to have a subreddit spammed shut by posts from your site.
https://onlinegdb.com/B1NYxDFZm Here thanks for all the help i got it running with a swap function and without.
Ahh that's a great idea! A whole lot better than writing the whole sizeof(x)/sizeof(type).
cool! 
As somebody primarily focused on other languages, I've always found it absolutely bizarre that in C-land it's considered even remotely acceptable for "bad stuff" to result in invisible-to-the-user transformation of code instead of actual error handling. 
I understand but wholeheartedly disagree. Letting people trample this subreddit doesn't help anyone. If the issue is few moderators, by all means make a post to recruit more.
I agree. I should have used a better example. Python 2.7 vs Python 3. Introductory books need to mention which Python it is I think. 
The history of that situation is complex. IIRC I once read that Kernighan (or was it Ritchie?) was actually personally against the approach of excessive UB spec and exploitation of UB, and the writing in the standard actually says: " undefined behavior behavior, upon use of a **nonportable** or erroneous program construct or of erroneous data, for which this International Standard imposes no requirements 2 NOTE Possible undefined behavior ranges from ignoring the situation completely with unpredictable results, to **behaving during translation or program execution in a documented manner characteristic of the environment** (with or without the issuance of a diagnostic message), to terminating a translation or execution (**with the issuance of a diagnostic message**). 3 EXAMPLE An example of undefined behavior is the behavior on integer overflow. " And one who knows the history of C, and the usual old school styles of tons of programs, could reasonably deduce that some UB are "harmless", or that they can deduce the actual behavior on concrete computers. Sadly, some compiler writers actually had in mind since a long time the possibility of exploiting UB in quite insane ways, except that they actually do not see that at insane at all because they are focused on the implementation without understanding the big picture and the impact on the industry if they do so carelessly. Which I argue they have, unfortunately, done. So they have basically forget everything in that definition except "ignoring the situation completely with unpredictable results" -- and even then they have a rather, hm lets say audacious interpretation of that sentence. They are, however, wrong in several ways, in the sense that the resulting situation is extremely problematic. * the most useful transformations are done at the intermediate representation level ( see for ex https://www.youtube.com/watch?v=AeEwxtEOgH0 ) so one of the way to exploit the UB that are defined at programming language level is to simply forward "them" blindly (their consequences, the related constraints that can be immediately deduced from the hypothesis of the absence of UB in the program, etc.) to the intermediate repr. However, I argue that doing this is just lazy and *terrible* engineering. The compiler is making the assumption that a particular class of extremely nasty and extremely prevalent bugs do not exist, while everybody simultaneously know that the absolute opposite is actually true, and that a great proportion of bugs in programs in C / C++, if not most, comes from that class of issues. Moreover, the consequences with that bad approach is that the problems are amplified to potentially extremely critical levels. What would have historically resulted in a *mostly* sequentially consistent segfault can now literally delete all your files. No serious study is known justifying the hypothetical perf gains we obtain from such a dangerous approach. * The approach described in the linked video is actually possible for languages that have *NO* undefined behavior at language level. The compiler "just" have to actually *prove* the invariants that it wants to leverage. Not just make trivially false hypotheses (at least in non-trivial code bases) that there are no bugs. * The points often made by Linus are very reasonable and I could try to summarize them (hopefully not too poorly) with: C is a system programming language that has a successful track record of being used in OS kernels, low level libraries, and so over, in designs were some of the most exploited sources of UB have horrendous consequences both on the impact on bugs and even the very possibility to write some kind of code. As a personal anecdote continuing on that thema, I've recently tried to implement a memory allocator in C++, and I was unable to come with a design that I would be confident to not break source of pointer analysis. On a near subject, TBAA is, I believe, not performed by MSVC, and is explicitly disabled when we build the Linux kernel. The perf impact of the lack of TBAA is widely believe to be in at most low single digit percent, mean. The constraints that come from TBAA are very bad at source level. OTOH it prevents code from being written in portable and reasonably efficient C or C++ in a wide variety of infrastructure topic, like: memory copy / compare, crypto, serialization, etc. So TBAA might overall actually have negative perf results (+ as usual the increase of bug proba) * All of that is rendered even more problematic by the fact that C and C++ are widely used for (semi-)critical projects and all kind of infrastructure, and are represented by major legacy codebase written when the compilers were far less dangerous. I'm unimpressed by those who present the absurd following dichotomy when asked to react to that: A/ the software are buggy and always was, it is not the compiler fault (would be a completely useless answer) B/ compile with -O0 if you are not happy with modern optim (is *mostly* useless for production binary from C code bases, really useless in practice for C++ code bases, actually provides *no strong additional guarantee*, and is actually theoretically uneeded). * Some of the UB historically merely come from the difference of behaviors of *processor ISA*, yet any subtlety has been since lost and some major implementations largely consider all kind of UB to be an absolute sin even where it would be trivial (and it was historically considered safe) to assign (as permitted by the standard!) a deterministic behavior. Same thing for UB that are only there because this is basically the only way that the standard can says that something will crash in most cases (at least would with classical implementation, now the "most case" part is unfortunately less clear). For some UB, nobody has even been able to come with the beginning of a theory about how exploiting it could help optims (bit shifting comes to mind). So I too find the persistence of some compiler authors to use such dangerous techniques (mere hypothesis that no UB are aver present at source level) to be, at least, myopic. Prominent actors of the most important projects consider they are insane, or multinational companies would not implement some techniques, and only implement others with extreme care (MSVC is reportedly using heuristics to try to avoid removing e.g. signed overflow detection by comparison after add at source level, while trying to leverage it in e.g. index loops to promote to 64 bits which helps on at least x64, or after further transformations -- and again, if I'm not mistaking, not using TBAA, yet still has very good perf compared to the more aggressive competition) 
Think about it like this: x = a + 4*b y = c + 4*d so: x * y = (a + 4*b)(c + 4*d) = ac + 4*ad + 4*bc + 16*bd Taking your example: x = 8 =&gt; a = 0, b = 2 y = 7 =&gt; c = 3, d = 1 =&gt; x*y = 0*2 + 4*0*1 + 4*2*3 + 16*2*1 = 0 + 0 + 24 + 32 = 56
Could you be more specific? What have you tried? How did it not work?
I can get a line with fgets , but it has to stop with a specific word but got segfault 
If you're dead set on tunnelling a network connection through USB, https://en.wikipedia.org/wiki/Ethernet_over_USB suggests the USB-eth kernel module is probably the way to go.
I'm sorry but I need more detail than this. Could you provide a code snippet? What is your ultimate goal? Are you just trying to read up to a certain word?
My goal is : start to the line number three . Write six lines in a file Do thing with this file Remove that file Start over
Hmm I'm not following along, I get a different answer: 8 x 7 = 56 1000 x 0111 = 00111000 so... a b c d 1000 x 0111 = 00111000 ac + 4(ad) + 4(bc) + 16(bd) = 10 + 4(110) + 4(0) + 16(0) = 26 
&gt; through a direct USB 3.0 connection between both computers. Do you mean using a USB 3 crossover cable? I haven't used that, but read about one cable which seemed to use its own protocol and driver. 
It seems like we're going to try one of [these](https://www.amazon.com/UGREEN-Network-Ethernet-Supports-Nintendo/dp/B00MYTSN18/ref=sr_1_1_sspa?ie=UTF8&amp;qid=1529614326&amp;sr=8-1-spons&amp;keywords=usb+to+ethernet+adapter&amp;psc=1) usb-to-ethernet port connectors and see if it makes it a bit easier.
Are you trying to write 6 lines starting from line 3 or are you trying to read from line 3 before writing 6 lines? How many files are involved here? This would be a lot clearer if you could show me your code.
I only mean to say that one end of the cable is physically plugged into the windows PC running Simulink real-time and the other end is plugged into the linux machine. I am unsure about any sort of protocol that would be used to communicate data through this connection. That said, it looks like we're going to try something like [this](https://www.amazon.com/UGREEN-Network-Ethernet-Supports-Nintendo/dp/B00MYTSN18/ref=sr_1_1_sspa?ie=UTF8&amp;qid=1529614326&amp;sr=8-1-spons&amp;keywords=usb+to+ethernet+adapter&amp;psc=1) and see if it lets us use the better documented approach of communicating over an ethernet connection.
I might get some hate for this, but the `colouring` function is horribly formatted. It should be changed to something like this: void colouring() { if (!has_colors()) { addstr("Not colour capable\n"); refresh(); return; } if(!start_color() == OK) { addstr("Cannot start colours\n"); refresh(); return; } init_pair(1, COLOR_YELLOW, COLOR_RED); init_pair(2, COLOR_GREEN, COLOR_GREEN); init_pair(3, COLOR_MAGENTA, COLOR_CYAN); attrset(COLOR_PAIR(1)); addstr("Yellow and red\n\n"); refresh(); attroff(COLOR_PAIR(1)); attrset(COLOR_PAIR(2) | A_BOLD); addstr("Green and green A_BOLD\n\n"); refresh(); attroff(COLOR_PAIR(2)); attroff(A_BOLD); attrset(COLOR_PAIR(3)); addstr("Magenta and cyan\n"); refresh(); attroff(COLOR_PAIR(3)); } I know it's a bit nit-picky, but I get pretty tired of seeing triply and quadruply nested blocks of code
You switched around a vs. b and c vs. d. /u/richtw1 had x = a + 4*b which means `a` is the least-significant half and `b` the most-significant.
Two of these proposals would have significant negative performance effects which is why they would never be adopted. The first and second are underspecified, and fully specifying the first would either be really complicated or significantly reduce the portability of C. &gt; EXAMPLE Code that checks to see if an integer value has overflowed The original reason for this UB is that there isn't a reasonable way for the programmer to know what to overflowed result would look like. It depends on the implementation, so there's no way to reasonably make this code. Today this is leveraged for an important optimization. With signed overflow semantics being undefined, implementations can and do choose more optimal representations for these values. For example, on x86-64, a 32-bit `int` loop counter will often be implemented as a 64-bit integer, necessary to efficiently exploit `lea` instructions. If signed overflow had observable semantics — and an explicit overflow check isn't necessary for this to be the case — then this optimization would be forbidden. Besides, it's just as reasonable to check for overflow *before* doing an integer operation, and that's when it should normally be done. Allowing the check afterward doesn't gain anything. If anything, I'd prefer a formal way to access the machine's overflow flag — sort of like GCC's overflow built-ins. The real problem with overflow isn't that signed overflow is undefined, but that it's so easy to forget to check for overflow (signed or unsigned) when it *really* matters regardless of whether it's before or after the operation. The negative shift and null pointer check are the same sort of situation. There's little to be gained and a lot to lose by requiring compilers to allows checks after the fact when it's no more difficult to make these checks *before* the operation. &gt; EXAMPLE Code that checks to see if [...] an array index is past the &gt; limit of the array cannot be deleted or otherwise ignored during &gt; translation unless the overflow or out of bounds index is actually &gt; impossible in the implementation. The problem is that the check may not really be possible. For example: int foo(char *beg, char *end, size_t n) { char *p = beg + n; return p &lt; end; } If either `n` or the pointer's address is sufficiently large such that `p` goes significantly out of bounds, the pointer address itself could have overflowed and that check no longer works — which is why this is undefined. To make this work as you'd like, the compiler would have to insert additional checks for these hidden situations. &gt; A conforming implementation may not change semantics of a program as &gt; an “optimization” As pointed out by FUZxxl, this is already the case. &gt; via a pointer with a properly aligned type. Also as pointed out by FUZxxl, this would remove strict aliasing and eliminate lots of desirable optimizations. 
not c, but if anyone (also) uses python, the urwid lib is a lot of fun. currently using it to make a TUI training diary.
`10 + 110 + 00 + 00 = 1000` should be: `(10 &lt; 4) + (110 &lt; 2) + (00 &lt; 2) + 00 = 111000 (56)` or `100000 + 11000 + 0000 + 00 = 111000 (56)` You just forgot to left shift the components before adding them.
A double can't hold the value 47.57 The 2 values closest are 0x4047c8f5c28f5c28 = 47.5699999999999932 0x4047c8f5c28f5c29 = 47.5700000000000003 https://0.30000000000000004.com/ 
Huh. That's messed up, but I understand the reason. Pretty much every single coordinate I feed is like this. I'm guessing I'll have to work around this by using a pair of ints aren't I?
&gt; If you want it truncated, with no rounding, then print it to a string (sprintf) then truncate the string. That's what's weirding me out. I've tried that method, and similar happens. The number is as expected up until it goes back into a float. Then it rolls the counter back or forward a little bit. 
This cannot ne donne with a male to male USB cable (is not in the USB standard afaik, so even if exist is not standard) and also atvleastbone of the port has to be OTG as the USB work as master/slave, and PC are master. OTG is used in phone, that can be connected as slave to PC, or as master to keyboard and other stuff. Then with otg you can create a virtual ETH modem (aka what you do for USB thetering) and the rest is network configuration. Is much easier to just use two USB to Ethernet and a cross cable.
If you have USB ports then use USB to Eth adapters, wifi, bluetooth, direct IR, serial... Sounds like you need to go punch the person who spec'd this project with some common sense.
You probably don't actually need floating point accuracy, so one method of solving this problem is using 'fixed point' values. For example, if you store longitute and latitude x 10000, it's easy to truncate as needed. int longx10k = 535550; int latx10k = 476590; Just add the decimal point when you need to. What you've discovered is that base 10 decimal digits can't be represented exactly in floating point. In the same way that 1/3 is .3333333333, 1/10 in floating point can never be exactly represented. 
***Some*** base 10 decimal digits can't be represented exactly in floating point.
my research gave me the suspicion that was the case. We were tentatively planning to use the usb to ethernet converters. 
It wasn't really that the project was arbitrarily spec'd weird. We are just working with some very particular software/hardware, namely a robot whose controller is written in Simulink real-time that needs data from the camera/machine learning models on the DeepLens. We also expect that there will be a lot of data to pass in anything remotely close to real-time, so we were really hoping for a direct connection. And, lastly, The deeplens doesn't have an ethernet port. It seems like we're going to use some usb-to-ethernet converters and do it over ethernet.
From what i found on the net: 1)it has wifi 2)it runs ubuntu 16.04 so a USB ethernet card sounds easy.
Nah — it’s not nit picky. It’s way more readable if there’s an early return compared to nested if statements. 
You could use [mmap](http://man7.org/linux/man-pages/man2/mmap.2.html) and (probably) not bother.
`#define bufSize 2000` `void make_filter(char *file){` `FILE *fp ;` `fp=fopen(file,"r");` `char buf[bufSize];` `int count ;` `int i ;` `FILE *final ;` `final=fopen("zoo.txt","a");` `count=make_count(filename); // count the number of lines` `while(fgets(buf,bufSize,fp)!=NULL){` `buf[strlen(buf)-1]='\0';` `if (strstr(buf,"&lt;date&gt;")!=NULL){` `if (strstr(buf,"&lt;hour&gt;")!=NULL){` `if (strstr(buf,"&lt;machine&gt;")!=NULL){` `if (strstr(buf,"&lt;line&gt;")!=NULL){` `if (strstr(buf,"&lt;message&gt;")!=NULL){` `if (strstr(buf,"&lt;/event&gt;"))` `{` `fprintf(final, "%s\n",buf);` `}` `}` `}` `}` `}` `}` `}` `fclose(final);` `fclose(fp);` `}` Here it is 
ETH to USB is extremely easy, just set up 2 different static IP in the same subnet. Or buy a cheap switch to out in the middle, there are with 5/6 ports, and it will take care of assigning IP address, plus you can connect multiple stuff
For return 0, does 0 mean null?
You can format blocks of code by inserting for spaces before each line as follows: #define bufSize 2000 void make_filter(char *file){ FILE *fp ; fp=fopen(file,"r"); char buf[bufSize]; int count ; int i ; FILE *final ; final=fopen("zoo.txt","a"); count=make_count(filename); // count the number of lines while(fgets(buf,bufSize,fp)!=NULL){ buf[strlen(buf)-1]='\0'; if (strstr(buf,"&lt;date&gt;")!=NULL){ if (strstr(buf,"&lt;hour&gt;")!=NULL){ if (strstr(buf,"&lt;machine&gt;")!=NULL){ if (strstr(buf,"&lt;line&gt;")!=NULL){ if (strstr(buf,"&lt;message&gt;")!=NULL){ if (strstr(buf,"&lt;/event&gt;")){ fprintf(final, "%s\n",buf); } } } } } } } fclose(final); fclose(fp); } To start, the line `buf[strlen(buf)-1]='\0'` is superfluous, because `fgets()
if they're in 2 bit fields you have: 8 = 10 + 00 but here the + is actually a concatenation, not an addition which is why in the stackoverflow thread they're saying you need to scale by 32 bits or in our case 2 bits. so you have (10+00)*(01+11) = 10 + 110, but you have to remember when adding that the 10 and 01 from the first product need to be scaled by 2 bits, the + is misleading. You started with four 2 bit fields so you may need as much as 4 to store the result, you had: n1{h2, l2} * n2{h2, l2} = n3{h2, hl2, lh2, l2} in (10+00)*(01+11) = 10 + 110, 10 is the result of 2 high fields, each high field in the product means you have to store one to the right of the lowest field so in this case, 3rd field from the right in n3: hl2, with the potential carry in h2. 110 is the result of one high and one low field so it goes in lh2, and if we had a 2 nonzero low bit fields the result would go in l2. so you get `n3{h2 = 00, hl2 = 10, lh2 = 110, l2 = 00` but since the fields are only 2 bits wide you need to carry the extra 1 from lh2 into hl2 and you get `00 11 10 00` let's do it with a better example with more carries: (7*7) = (01+11)*(01+11) = (01*01) + (01*11) + (11*01) + (11*11) = 1 11 11 1001 1 goes into the third bit field from the left, 11 and 11 in the second and 1001 in the first, in order: = 00 01 (11+11)=110 1001 now we have to perform the carries 01 11 11 10 01 ___________+ 00 11 00 01 which is 32+16+1 = 49 = 7*7 and fits in 4 fields
what is the end ? 
Nice blog, nice article. Hope there will be new material anytime soon.
Please edit your post and put your code snippet on a paragraph on its own (surrounded by blank lines) and indent every line of code with four spaces. If you do so, reddit formats your code as code and it becomes readable. Right now it is a garbled mess.
Here you go: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct exp { int a,b,c;}; void main() { struct exp *t; t=(struct exp *)malloc(sizeof(struct exp)); int *ptr=&amp;t-&gt;c; printf("t:%llX\nt-&gt;c:%llX\n",(unsigned long long)t,(unsigned long long)ptr); } 
&amp;(t-&gt;a) this will give you the address of integer a of struct and you can replace "a" in &amp;(t-&gt;a) with b and c to get addresses of a and b.
You can get the address of a (public) member variable of a struct/class by accessing it and then getting the address via the &amp; operator as seen in the code below: `#include &lt;cstdlib&gt;` `struct exp` `{` `int a, b, c;` `};` `int main()` `{` `exp t;` `int *ptr = &amp;(t.a);` `return EXIT_SUCCESS;` `}` Also, you don't need to allocate memory through malloc if you instantiate an object of type struct exp on the stack. malloc is used to allocate a user specified block memory (specified in Bytes) on the heap and return a pointer to that memory.
Note that the parentheses are superfluous in this example. Operator precedence is such that `&amp;t-&gt;a` does the right thing.
You're not wrong, but I'd have figured most of us would be used to it by now.
Use `%p` rather than to convert it into an integer.
&gt; It seems like we're going to use some usb-to-ethernet converters and do it over ethernet. This was really your only choice. 
No, I think first it has to point to the integer and then get the address.
The point is, `-&gt;` has a higher precedence than unary `&amp;`, so `&amp;a-&gt;b` is parsed as `&amp;(a-&gt;b)`, not `(&amp;a)-&gt;b` as you seem to expect.
Ooh, sorry I can't understand your message first but now I understand your point. I hope you never mind. Thanks
[offsetof](https://en.wikipedia.org/wiki/Offsetof)
I often find doing the reddit code indenting unpleasant. Maybe it would be worthwhile to encourage questioners to write a gist on github and then share it here? Then people trying to answer get not only good format but also probably some highlighting.
Doing that is fine. I prefer if all resources are on-site in case the paste service you linked to goes down or the paste expires.
To post code on reddit, prefix each line with four spaces.
Thanks, but it seems to still be showing up the same way. Maybe I'm just not understanding, I've never been good at Reddit formatting.
Remove all the blank lines from the code, or prefix them with 4 spaces as well. And indent your code properly.
So if I'm interpreting your question correctly, you are saying that you get an infinite loop when the user enters a non-numeric character in the menu. The reason is because \`scanf\` leaves characters that don't match the specified format inside of the buffer. So when you enter an invalid character, your program loops to give the user input again, but the input buffer still contains the invalid character, causing the program to loop again, with this process repeating indefinitely. The solution would be to flush the buffer after receiving input. You can read more about this [here](https://stackoverflow.com/questions/1716013/why-is-scanf-causing-infinite-loop-in-this-code), where I more or less shamelessly stole the top answer.
Use pastebin, it's horrible reading code on smartphone
Thank you! I couldn't figure out why it wasn't asking for user input again if a character was entered, now I understand, thank you very much!
I fixed it, at least it looks fixed to me. My problem was the new reddit editor that I forgot about, so all the old stuff I'd bothered learning didn't work.
I think the code is showing up fine now. I'm unfamiliar with how pasebin work, but I know it's used a lot for code so I'll look into it soon.
There's a couple of other bugs as well around number01 and number02 (hint they're already pointers). Also when printing them or writing them to the file, you'll need to dereference the pointers (with *). 
So when you encounter a puzzle like this, a good first step is to keep cutting away code, until just the bare bones are left. You might end up with a simple program like this: #include &lt;stdio.h&gt; int main(int argc, char **argv) { int number; while (1) { printf("Enter a number, or 0 to exit: "); scanf("%d", &amp;number); if (number == 0) break; printf("You entered: %d\n", number); } return 0; } So what happens when you run this? Enter a number, or 0 to exit: 123 You entered: 123 Enter a number, or 0 to exit: 42 You entered: 42 Enter a number, or 0 to exit: abc Enter a number, or 0 to exit: You entered: 42 Enter a number, or 0 to exit: You entered: 42 Enter a number, or 0 to exit: You entered: 42 ... Aha, this also demonstrates the problem, and it's a lot easier to work with! So why does it do this? Think about what: scanf("%d', &amp;number); does. It reads characters from standard input, _but only if they are compatible with the format string_. In this particular instance, the format string is `"%d"`, which: * reads and discards whitespace characters; then * reads an integer. But the character `a` is not a digit, nor it a plus or minus sign, so it can't possibly be part of an integer! This is the point where `scanf` stops reading. It leaves the `a` in the input stream for subsequent read operations.... but the subsequent read operations are still only looking for whitespace and integers. There's no way for this code to "get past" the `a`, let alone the `b` or the `c`. This here is fundamentally why `scanf` is a poor choice for reading unstructured data &amp;mdash; and human input is just about the most unstructured you can get. Humans can input anything! You would be better off reading a whole line as a string (say, with `getline` or `fgets`), then using `strtol` to convert that string to a number. 
Thanks, I'm still new to pointers so I've been trying to include them in all my code the past few days to help practice them!
Thank you, this was very helpful!
this style - where you have a bunch of "sentinels" up front that return if preconditions aren't met - is really useful. but i've had it rejected in code review because "multiple returns are like gotos". i no longer work with those people, thankfully (and my c code is full of gotos to exit on error).
That is an interesting list. That will definitely give people a good basic foundation
 int r = scanf("%d",&amp;choice); if(r == EOF) { printf("Bye.\n"); exit(0); } printf("\n\n"); if (r != 1 || choice &lt; 1 || 9 &lt; choice){ printf("You must enter a number between 1 - 9\n"); choice = 0; continue; } else if(... 
Thanks dear for your feedback, this will increase my passion to support newbies.
While not knowing anything about python bindings, enums in C are just integers, so you could just convert it using any number-to-PyObject function, like [`PyLong_FromLong`](https://docs.python.org/3/c-api/long.html#c.PyLong_FromLong).
Thanks for the clarification :)
Assuming you're on UNIX, the command line tool, `bc`, can handle multiplying 64-bit values. For more info: `man bc`. 
I think you are adding `r` twice in your answer. Try doing the following. uint128_t u = add128(r, s); return add128(u,t); You can probably use [this](https://www.ttmath.org/online_calculator) to test. I have never used it before but found it on a quick Google search.
After struggling with so many programming books as a beginner, the Deitel books have become my favorite texts to work with. The amount of exercises per chapter to work with is what impressed me the most. I’m learning C before making the jump to JavaScript and other web back end stacks. But assuming I want to stay within C and be job ready say in embedded systems or any other domain, what path ways would you recommend after I read the Deitel C and C++ books which I plan to work through this summer? 
Ohhh you're right, whoops! Thanks for catching that.
Crosspost to r/learnprogramming you might get better answers there. 
Warning untested code ahead: // High-order and low-order 32 of 64 bits #define LO(x) ((x)&amp;UINT32_C(-1)) #define HI(x) ((x)&gt;&gt;32) // *** N.B. uses arithmetic shift if x signed *** // High-order 64 out of the 128 bits of a 64x64 bit product // Cf. the signed and unsigned MULH instructions on some processors. #define HL(x,y) (HI(x)*LO(y) +HI(LO(x)*LO(y))) // factor of MULH() #define MULH(x,y) (HI(x)*HI(y) +HI(HL(x,y)) +HI(LO(x)*HI(y) +LO(HL(x,y)))) #define MUL128(x,y) (MULH(x,y)&lt;&lt;64|(x*y)) uint128_t inline umul128(const uint64_t x, const uint64_t y){ return MUL128(x,y); } int128_t inline mul128(const int64_t x, const int64_t y){ return MUL128(x,y); } 
Since this sub is for C, not C++, you might get better responses in /r/cpp_questions or /r/learncpp.
The important part is the MULH macro, which you can use to calculate the high 64 bits of the product. You'll need to adjust the code after that to work with your 128 bit typedef. 
Probably not here, since this is a subreddit for C, not C#. Try e.g. /r/learnprogramming. (Now we're getting C# posts in addition to C++ posts, yay. /s)
Not relative to your issue but still : you can replace `/*...*/ else if (choice == n) { /*...*/ }` by `switch (choice) { case 0 : /*...*/ break; case 1 : /*...*/ break; /*...*/ case n : /*...*/ break;}`
This code shows an area where assembly is superior to C. In C there is no "overflow into an extra result", the carry bit, and "add with carry". So you emulate it checking if the "sum" is lower than a term. Reliable though it may be, that makes me cringe.
I'm sure someone somewhere in the world probably is. They're probably over on /r/csharp though, since it's a completely different language from C. I also highly doubt they're willing to teach you from scratch, for free. Check their sidebar, they probably have some resources on getting started.
If there is someone like that, they're probably not hanging around on the subreddit for a totally separate language. They're also probably not willing to tutor and handhold you from scratch since I assume by teach you, you mean teach you for free. Go to /r/csharp and look at their sidebar.
Well no
I’m paying and I found someone lol
good luck then
That's hilarious
beautiful 
My favourite part is that it ends on a segfault :)
Is register still a valid keyword ?
It's ignored.
Process received Signal SIGSEGV
One approach would be to have a single array, and working with elements of that array, i.e. example0 = my_array[0], example1 = my_array[1], etc. You could then loop over the elements of the array.
Our problem is that we want to assign example0 and example1 to the same thing, but we don't know how to make a for loop where it changes the 0 in example0 to be a 1 and then continue until 5.
Trying to dynamically create variable names is not idiomatic C (or idiomatic in many, or any, other programming languages that i'm aware of), regardless of whether or not it's actually possible. (i don't think it is, but i might be wrong.) Hence why i suggested using an array. So, do you mean, you want to set 'example0' and 'example1' to the same value? Then just assign that value to the appropriate element of the array: my_array[0] = 42; my_array[1] = 42. Or do you mean that you want to assign the same value to both elements, such that if it's changed in one, then it's changed in the other? Then you need to use pointers. In the former case, your loop will look like: for (int num = 0; num &lt; 6; num++) { my_array[num] = 0; }
In the actual code that we're using, we're using pre-designed functions from a tournament to move a robot in a 3d environment. One example of what we're doing is game.getItemLoc(itempos0, 0); game.getItemLoc(itempos1, 1); game.getItemLoc(itempos2, 2); game.getItemLoc(itempos3, 3); game.getItemLoc(itempos4, 4); game.getItemLoc(itempos5, 5); In the function game.getItemLoc(a, b) it assigns the x, y, z coordinates of item 'b' to the variable 'a'. So we're trying to assign the coordinates of each item to a variable named 'itemposx', x being whatever item that is. We could type out all 6 lines, but we could also make a for loop where we put 'num' instead of the number in the function and set num to the numbers 1 - 5. We also need to do this with 2 other commands that let us calculate the distance between our robot and the item. This is 18 lines overall but a for loop could do all 18 lines by just doing the same command 3 times and replacing the number with a certain variable that changes to be each number.
So use my_array[0] in place of itempos0, my_array[1] in place of itempos1, etc.
C# is off topic in this subreddit. Please post C# questions elsewhere, e.g. to /r/csharp.
Removed. Try /r/sailing.
&gt; Is this assessment correct? Don't ask us. Get the compiler to tell you: $ gcc -Wall -Wextra -g -o conversion conversion.c conversion.c: In function ‘main’: conversion.c:12:24: warning: ‘sprintf’ writing a terminating nul past the end of the destination [-Wformat-overflow=] sprintf(bString, "%.2f", b); ^ conversion.c:12:2: note: ‘sprintf’ output between 5 and 314 bytes into a destination of size 4 sprintf(bString, "%.2f", b); ^~~~~~~~~~~~~~~~~~~~~~~~~~~ 
Thanks for the reply. Even though the last message shows that bString needs to be put into 5 bytes or more, why does bString get stored and printed?
Am too fan of it, kinda sad that I see it in decline of usage!
So it is probably due to how these variables are allocated in your program's stack. Most likely, `bString` is at a lower memory address than `aString`, so writing past the end of `bString` is overwriting the contents of `aString`. I just looked into the Edit on my previous post. Turns out you need to use `-Wformat-overflow=2` if you don't want GCC to be conservative on how it diagnoses these issues: $ gcc -Wall -Wextra -Wformat-overflow=2 -g -o conversion conversion.c conversion.c: In function \u2018main\u2019: conversion.c:11:20: warning: \u2018%d\u2019 directive writing between 1 and 11 bytes into a region of size 4 [-Wformat-overflow=] sprintf(aString, "%d", a); ^~ conversion.c:11:2: note: \u2018sprintf\u2019 output between 2 and 12 bytes into a destination of size 4 sprintf(aString, "%d", a); ^~~~~~~~~~~~~~~~~~~~~~~~~ conversion.c:12:20: warning: \u2018%f\u2019 directive writing between 8 and 317 bytes into a region of size 4 [-Wformat-overflow=] sprintf(bString, "%f", b); ^~ conversion.c:12:2: note: \u2018sprintf\u2019 output between 9 and 318 bytes into a destination of size 4 sprintf(bString, "%f", b); ^~~~~~~~~~~~~~~~~~~~~~~~~ 
That works for most of the variables and we should be able to shorten it down using that, thanks. But the second and third function use a variable that is already an array. We couldn't get an array of arrays to work so how would we solve that?
Thank you for the suggestion. The reason I didn't use a switch case here is because I seem to encounter errors with switch casing if I need to declare or set a variable at the start of the case. EX: `fp = fopen()` at the top of a case will produce an error. If I'm misunderstanding something please let me know, as I'm always open to improving my knowledge of coding.
Take that OO. thanks it make my entire week end! 
Oh, C++ veteran trying to code in C, would not end differently!
&gt;I am not entirely sure why my compiler *isn't* complaining about \`aString\` as well, since 4 characters is certainly nowhere near enough to fit a decimal integer. This is odd! I tried it myself, and expected some weird behavior too... I tried changing \`int a = 123456789;\` but \`aString\` printed out OK... even though \`aString\` doesnt have enough bytes to contain \`123456789\`. When I changed the \`sprintf(bString, "&amp;#37;.9f", b);\` I got a stack smashing error though. But not when I changed it to \`&amp;#37;.5f\` for instance. 
The compiler figures this sort of stuff out and produces the sort of assembly you're talking about. Here's the output of `add128()` GCC 8.1.0, where you can see it using add-with-carry: add128: mov rax, rdi add rax, rdx adc rsi, rcx mov rdx, rsi ret 
Woooosh
If she sells seashells by the sea shore, then sure. I won't put much effort into it but give some pointers at least...
&gt; This is odd! I tried it myself, and expected some weird behavior too... I tried changing int a = 123456789; but aString printed out OK... even though aString doesnt have enough bytes to contain 123456789. That can happen if there's enough room on the stack past the end of the buffer, before the return address. That might certainly be the case depending on the order in which those local variables are allocated. (On x86 stacks grow _downward_, which means a sufficiently long buffer overflow will clobber the return address.) &gt; When I changed the sprintf(bString, "%.9f", b); I got a stack smashing error though. But not when I changed it to %.5f for instance. OK, so you've got GCC's stack protector turned on. In this case there's an extra hidden variable allocated just underneath the return address, and there's code on the function exit path which checks that this variable wasn't clobbered by anything. But again, depending on the order in which your local variables are allocated, a sufficiently short buffer overrun may not end up clobbering this hidden variable, in which case your error isn't detected. &gt; In any case, I always use snprintf and the likes to prevent overflowing the target buffer. That's a good idea. Just be aware that `snprintf` has a small gotcha: if its output has been truncated, then no trailing null byte is written. If you intend to use your buffer with a possibly-truncated value, you should probably always write a null to the last byte of the buffer.
 &gt;That's a good idea. Just be aware that `snprintf` has a small gotcha: if its output has been truncated, then no trailing null byte is written. If you intend to use your buffer with a possibly-truncated value, you should probably always write a null to the last byte of the buffer. Huh? snprintf() will always put in a trailing null byte unless given a 0 length.
This is C++, try /r/cpp_questions or /r/learnprogramming Your program exists after showing the rules because that's all that is in main int main() { ... Player::gameRules(); return 0; }
Reminds me of the book Deep C Secrets. It has a fish as its cover.
Even after adding something, such as Dice::rollDice(); it will not display any dice rolls. All it does is exit. 
I’m not sure where the confusion is. `make` is trying to build your C files into objects, and the compiler is telling you what went wrong. `INFINITY` redefined: Don’t redefine that. It’s in `&lt;math.h&gt;` already; if you neeed a different infinity, name it something else. `print_direction` storage class: You’re declaring it inside a function. Don’t do that. You can declare `extern` functions there, and GCC will let you declare `auto` functions as long as they’re entirely local, but `static` functions need to be declared in the global scope. (There’s not much reason to declare them anywhere else.) Implicit declaration: Because the `static` declaration didn’t take, the C compiler saw you calling a function without it having been declared first. Move the `static` prototype out to the global scope and this will go away. Conflicting types: Because there wasn’t a valid declaration for `print_directions`, the C compiler assumed it was of type `int()`, meaning a function taking any old arguments and returning an `int`. Since that’s not what you’re defining the function as (specifically, taking and returning nothing), there’s a mismatch. Again, `static` declaration out to the global scope will fix this. Static declaration follows non-static: Same problem; the compiler assumed `extern int()` and you’re doing `static void(void)`.
Thanks for the help 
If you’re optimizing at all, the compiler may be optimizing the first `sprintf` away and coming up with a perfectly normal `aString` value, possibly even one that’s big enough. Writing past the end of the buffer is undefined behavior, so it doesn’t have to consider that case, and it knows exactly what the contents of the string will be at compile time. The floating-point one may be touchier in terms of being subject to rounding rules and other environment-sensitive things, so the compiler may not be eliminating that `sprintf` in the same way.
Definitely don’t name your type `uint128_t`; that’s ~reserved for `&lt;stdint.h&gt;` types, and yours doesn’t work anything like one of those. On UNIXish machines, `bc`’s your best bet for arbitrary-precision ints. However, most compilers that can generate 64-bit code can handle 128-bit ints also. If you have GCC post-4.6 or Clang, on x86-64 you can get at 128-bit ints with typedef unsigned ui128 __attribute__((__mode__(__TI__))); typedef int i128 __attribute__((__mode__(__TI__))); and that’ll give you 128-bit integer types to play with. 64-bit-targeted MSVC and later Clang/GCC also have `unsigned __int128` and `__int128` as built-in types, and which on GNU are basically the same as `mode(TI)`. (You can detect `__int128` in GNUish compilers with the following:) #if defined(__SIZEOF_INT128__) &amp;&amp; (__SIZEOF_INT128__+0) &gt;= 16 ... #endif On GNU+x86-64, you can also do uint64_t in1 = …, in2 = …; uint64_t oHi, oHo; oLo = in1; __asm__("mulq %q2" : "+a"(oLo), "=d"(oHi) : "rm"(in2) : "cc"); which will do a 64×64→128 multiply of `in1`×`in2` for you, with bottom 64 bits of output in `oLo` and top 64 bit in `oHi`. Similarly, you can either do a 128-bit add with the proper 128-bit int types, or with uint64_t in1Lo = …, in1Hi = …, in2Lo = …, in2Hi = …; uint64_t oHi, oLo; oLo = in1Lo; oHi = in1Hi; __asm__( "addq %q2, %q0\n" "adcq %q3, %q1" : "+&amp;r,&amp;r,&amp;rm,&amp;rm"(oLo), "+r,rm,r,rm"(oHi) : "rm,rm,r,r"(in2Lo), "rm,r,rm,r"(in2Hi) : "cc");
I found your code exceptionally hard to navigate because your blocks seem to have arbitrary indentation levels; some curly brackets are in the left-most column and aren't the end of a function block which threw me for a loop several times. It's really a style thing, not technically speaking anything wrong with your code, but when writing code you should write it with an unfamiliar audience in mind. More than likely that audience will be you 6 months from now. That aside, it all looks fine to me with the exception of `deletexy()`. I'm going to go through it and come back with a more complete critique shortly, but for now suffice it to say I think there are cases where it will do things you don't want, and it has a control flow that is a little too messy for my taste.
That is a very good answer. Few know about that. Need to start meditation again. It is a Pilar of a good body, mind and spirit.
Thanks! I really appreciate it. 
No problem! Always happy to help.
Unless you know the length of each line ahead of time, you can't seek to a specific line And you can't overwrite just one line unless you're replacing it with the same number of chars. Create a new temp file, write to it so it's what you want in the final file, and then rename it to the original.
thank you!!!!
Text file lines generally have irregular lengths. You would either have to read the file one line at a time, or read whole block(s) of data and count the newlines within them (perhaps indexing those newlines if desired).
&gt; Huh? snprintf() will always put in a trailing null byte unless given a 0 length. Oh wow, you're right. I've always got that wrong. In my defence, the [`snprintf` manpage on Linux](https://linux.die.net/man/3/snprintf) doesn't make it very clear. It says: The functions `snprintf()` and `vsnprintf()` do not write more than `size` bytes (including the terminating null byte ('\0')). and I always interpreted that as talking about the terminating null byte that would be written _had there been enough space_. I hadn't actually checked the specs. Thanks for correcting me!
And for more sage advice, listen to [this](https://www.youtube.com/watch?v=XHosLhPEN3k).
What do you mean by "couldn't get an array of arrays to work"? Were you using [multidimensional arrays](https://en.wikipedia.org/wiki/C_syntax#Multidimensional_arrays)?
In other words, yes.
`fflush(stdin)`
I'm talking about the output buffer and is unlogical use fflush(stdin) 
I mistyped, should be `stdout`.
I'm talking about that the printf should only flush after the sleep... 
I haven’t read them standards in a while, but I don’t think there’s anything that forbids the buffers to flush at any time. The library can flush whenever it wants, and flushing right before a sleep is very user friendly. 
That was not clear from your post. Your grammar is... tortured, to say the least. You cannot prevent `printf()` from flushing the buffer. If the C library feels like flushing, it will flush. If you don't want your program to print anything until after the `sleep()` call, move the `printf()` call.
sleep is not a standard library function, 
&gt; It isn't suposed to flush stdout only when the program finish, recive a new line (\n) or when reach the max buffer size? That would be the behaviour if `stdout` is line buffered. The C11 standard says the standard output stream is "fully buffered if and only if the stream can be determined not to refer to an interactive device." Note that it does _not_ say that it must be line-buffered when referring to an interactive device; it is valid for it to be unbuffered.
What do u mean by fully buffered? 
&gt; What do u mean by fully buffered? I mean precisely what the spec means by it: &gt; When a stream is _fully buffered_, characters are intended to be transmitted to or from the host environment as a block when a buffer is filled.
But for me every printf flushes, even if a string with only one character. 
&gt; But for me every printf flushes, even if a string with only one character. Exactly. That would imply your stream is unbuffered, which is perfectly valid when it refers to an interactive device.
How do I make my stream buffered? 
Use `setbuf` or `setvbuf`.
What I put as parameters? 
Did you look at their documentation? I don't want to spoon-feed you. If you have a question about their documentation, I'm happy to help you with that though.
I couldn't find that :/
What C implementation are you using? If you were using glibc, for instance, you would refer to [this](https://www.gnu.org/software/libc/manual/html_node/Controlling-Buffering.html). But I'm pretty sure you _aren't_ using glibc, since its implementation-defined behaviour is not the behaviour you've described in this post.
As far as I know, the glibc actually sneakily sets `stdout` to unbuffered under certain circumstances to work around programming errors like these.
Please don't post this kind of content.
Really sorry, I did indent with 4 spaces, but somehow there must have been an error
Also remember to put a blank line between your code and the surrounding text. 
Alright, thank you
Try it out to see if it works!
Done boss!
Looks great! Thank you for your cooperation!
Anything that uses GTK+
GIMP is a good example. GTK (Gimp Toolkit) was developed just to write GIMP.
https://github.com/vurtun/nuklear Nuklear is an immediate-mode GUI library which can use multiple rendering backends. It can relatively easily be added to any C project.
you might want to ask on a C++ subreddit in C you might want to do something like for (int i=1; i&lt;100; i++) { prinf("%i red baloons\n"); } 
Adding two integers together is potentially undefined behaviour.
Windows 3.1
Take a look at the side bar, specifically under resources. I liked The C Programming Language personally.
How 'bout the sidebar. 
What is the side bar?
What is the side bar
I guess you're on mobile. Check if you have a "View sidebar" option somewhere. There are links for the more popular books and resources. 
Yes i am, will do, thank you
The right side of the subreddit, where you can subscribe/unsubscribe, submit a new post, see the moderators, etc
What exactly do you wanna know? Checked the man page already? Terminal —&gt; man sscanf
The sidebar has disappeared with the reddit redesign though. But it can still be seen via the "visit old reddit" link, here: [https://old.reddit.com/r/C\_Programming/comments/8tkpdc/starting\_fresh/](https://old.reddit.com/r/C_Programming/comments/8tkpdc/starting_fresh/)
What’s the difference between SCANF and SSCANF And how can it be useful (sscanf) in an example..
Do the hundreds of ncurses apps written in C count? (You didn't specify that you wanted only GUI examples.)
scanf is a foot-gun. sscanf is a foot-gun with a saftey.
srand is the seed of the random number, so most people use the current time as the srand. After you set srand, you can use rand, which will generate a random 32bit number I believe. You can use modulus to get a range: rand % 20 means a number between 0-19
😅🤦🏽‍♂️🤦🏽‍♂️
It probably makes sense but still hard for me to understand. Thanks tho! I'll keep digging.
C Programming : A modern approach, 2nd edition, by K. N. King is my favorite. 
kernighanghnagn and richoid
Scanf reads from stdin, keyboard (typically) input. Sscanf is used with a string (read: array of chars), thus you have a buffer full of chars that you can use for any pre-checking and data verification before you "scan" it.
they're not "really random". rand() generates a sequence of numbers that have a mathematical basis. they "look" random, but if you do sufficiently sophiticated statistical tests you'll see they're not. typically the maths uses is a linear congruential generator (look it up). if you want better (more nearly "really random") numbers you need to use a library. there are many out there. a reasonably good one algorithm is "mersenne twister", so you could look for a c library that implements that. if you want to know more you have to be clearer about what you don't understand.
Thanks for the clarity of your explanation.. can you please give me an example where you can use sscanf
Yea, sscanf reads formatted input from the specified string. So for example you could say something like: read something, thats max 10 chars long, only char a. 
There are many ways to generate (pseudo) random number generators and the standard doesn't specify a particular algorithm for rand(). That said, a [linear congruential generator](https://en.m.wikipedia.org/wiki/Linear_congruential_generator) is the usual for it in most implementations.
IUP http://webserver2.tecgraf.puc-rio.br/iup/
C# is off topi in this subreddit. Also, please don't post blog spam.
Have you read the man page? It explains this nicely.
I'll give you a simple example from my job. Theres a buffer obtained from keyboard input that I want to check for certain strings. If there exist no such strings, I scan it for a number with sscanf. That way, rather than trusting the user to enter valid input, I allow them to enter anything and validate it before I use it.
Thanks a lot It’s clearer on my mind now 😌
A lot of stuff build with [SDL](https://www.libsdl.org).
C++ is off topic, please post C++ questions to /r/cpp_questions. That said, try Visual Studio if you want a native Windows development environment, or mingw if you want something that looks like UNIX.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
&gt;C Programming : A modern approach, 2nd edition, by K. N. King is my favorite. \+1
for "0-18", read "0-19".
I know this doesn't answer your question directly, but you don't need to necessarily remove comments from your code in the lex stage if you run the c preprocessor on your input stream: If I make this \`test.c\` file: this should stay /\* this should not \*/ // neither should this but this should the comment should be pruned from here: // test comment And run it through the preprocessor: \`type test.c | cpp\`: C:\\Users\\Bob&gt;type test.c | cpp \# 1 "&lt;stdin&gt;" \# 1 "&lt;built-in&gt;" \# 1 "&lt;command-line&gt;" \# 1 "&lt;stdin&gt;" this should stay but this should the comment should be pruned from here:
Sadly i cannot use that, i must only do it via flex, and do it during the lex stage. Uni assignement. However i will keep this in mind, as the problems are getting each time more complex and with more programs added, i might be able to use this in the future. Thanks!
You have much more serious problems, such as: 1. Your input file and output file are the same (why are you not just using stdin and stdout?? It would be easier to code, easier to test, and easier to use) 1. You have no rule to print out non-comments. You should have a catchall `(.|\n) { printf("%s", yytext); }` at least That said, you do have two other problems that you would have to fix in the regular expressions you have: 1. Your block-comment regex is too greedy. It matches from the first /* to the *last* (note: **not** the *next*, but *last*) occurrence of */. You can make it less greedy by using a more complicated regular expression that will ensure no */ can be inbetween the first /* and the last */. [Here's an example of one](https://stackoverflow.com/questions/25395251/detecting-and-skipping-line-comments-with-flex): `[/][*][^*]*[*]+([^*/][^*]*[*]+)*[/]` (you can actually simplify that a bit) 1. You're right that you don't want to search for comments inside of strings. That means you must have another rule for string literals (which comes at the top of your rule list, before any comments). Unfortunately that one will also be a bit a nasty :(
Whoop, typo
that first problem is me being derp. I translated it from spanish to english so it was more understandable, they are 2 separate files I will use what you sent here and see if it works. Thanks!
&gt; which will generate a random 32bit number I believe Technically it generates an int between 0 and RAND_MAX. 16-bit (or smaller) numbers used to be super common, though I haven't seen any for a while. And yeah, for small ranges, % is a fine way to get it in a range. rand() % 35 + 15 will give you a pseudo-random number between 15 and 49, etc.
Yeah, I mean you can always disassemble any executable to get the assembly code. With a little more effort, you can get the C code for the assembly. 
I am beginner to but and i am doing it like this: First i call: srand((unsigned)time(NULL)); with this you get diff number every time. Next i call rand like this: int your_var=BB+(float)rand()/RAND_MAX*(UB-BB); BB= bottom border UB=upper border I hope it helps.
I got it. Thanks!
Here is [my solution](https://gist.github.com/fuzxxl/dd024fef98a80726fde06a20526f4ab3) to the same problem, just in case you are interested in a comparison. It doesn't use a lexer generator though.
Please use Markdown to format your answer. Also, don't use float.
Yea , if my variable is int you are right,but if you need float you need to cast something to get it or am I wrong?So I jst leave casting there because I dont need acurate numbers for rng. How do I use Markdown?
You're not wrong, Walter, you're just an asshole.
&gt; Yea , if my variable is int you are right,but if you need float you need to cast something to get it or am I wrong?So I jst leave casting there because I dont need acurate numbers for rng. Sorry for being imprecise. Prefer `double` to `float`. There is very little reason to use the latter in 2018. &gt; How do I use Markdown? See *Formatting Help* under the textarea.
You're not wrong, Walter, you're just an asshole.
Bad bot.
Thank you, kloetzl, for voting on BigLebowskiBot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
[Huh.](http://i.imgur.com/0auxGaZ.gif)
Here's the recently released source code of the Windows File Manager: https://github.com/Microsoft/winfile
I don't think real C compilers do that... The C standard has a number of "Translation Phases" or whatever they're called, a few of them are different parts of the preprocessor. You still need to do the homework though. :/
To clarify, in a real compiler, comments are replaced with spaces in [phase three](https://en.cppreference.com/w/c/language/translation_phases). Phase *two* involves turning `foo\&lt;newline&gt;bar` into `foobar`, meaning that // a single line comment\ that spans two lines is a valid comment. And phase *one* involves among other things, converting trigraphs to characters. The important one is the sequence `??/` which is turned into a backslash. So if you want your comment removal program to be industrial strength, it should account for those things.
I teach the 'single exit at the bottom' style. It makes the function easier to maintain because I can always add code at the bottom, prior to the return statement, that will always be executed regardless of the code path that was taken to get there. 
It's not always good programming practice, it's just misra programming practice. The hoops you have to jump through for a single return statement in a function can easily produce much less readable code, *especially* if you can't also use goto (Using it to jump to a common cleanup &amp; return section is a common, appropriate use of goto). Your first example is better than the second, personally.
One major benefit of single exit point subroutines is that your program's timing is more predictable, which is a major benefit when you're working with watchdog timers. In fact, writing code like above makes your code's execution a lot more predictable and easier to optimize. You may be sacrificing your best case and average case run time speeds, but an embedded, safety critical system should be judged on its best and worse case, and shouldn't give a large range between them to begin with since these are often used in real time scenarios where going either too fast or too slow is a no no. All the above being said, even the mandatory MISRA guidelines allow for formally outlined deviations in cases where following the MISRA guideline would make your code worse rather than better. An example would be using gotos to implement error handling along with a single exit point for functions which have a chance of failing and leaving data allocated in memory, causing a leak. The MISRA compliant method of handling such a thing produces code which is intractable spaghetti which is nearly impossible to optimize or cleanly refactor. MISRA allows for such deviations provided you formally explain why such a deviation is necessary.
&gt; "A function shall have a single point of exit at the end of the function." &gt; &gt; The rule is required and not advisory and I always knew that is was a good programming practice but still the 95% of the code that I've seen in my life simply ignores it, probably because those standards are made for critical systems and not for "everyday software". IMHO this rule is complete garbage. A single exit point just makes your code much harder to read and to understand under most circumstances. Instead, write your code such that it exists the function as soon as it can. This creates a style of code where with successive statements, more and more invariants are established over the data in the function, making it very easy to see what is going on. For example, consider this function which swaps the first two elements of a linked list: struct list { struct list *next; int datum; }; /* swap first two items, return new list head on success, NULL on failure */ struct list *swap(struct list *lst) { struct list *first, *second, *third; /* make sure we have at least one element */ if (lst == NULL) return (NULL); /* make sure we have at least two elements */ if (lst-&gt;next == NULL) return (NULL); first = lst-&gt;next; second = lst; third = lst-&gt;next-&gt;next; first-&gt;next = second; second-&gt;next = third; return (first); } Without leaving early, the invariance checks would make the code very hard to read. Try to avoid code that is hard to read.
I'm going to hit a middle road here. You've gotten a lot of good advice already, but I'm hoping to temper it a little bit. Both sides have pluses and minuses. A single exit point means you get more predictable timing typically, sometimes easier function modification. Multiple exit points can make code easier to read, and it allows you to potentially make the common case fast. I'd suggest you balance things. If you are on a project where things are not timing critical, set a best practice to for the team and follow it; this extends beyond how to exit functions too. This way code made by some one else doesn't feel too foriegn to anyone. However, timing critical things may require you to drive beyond preference. One thing I can think of is cryptography projects. Having a given algorithm or subroutine always take the same amount of time regardless of path is seriously desirable since timing differences can give away hints about what was done. Basically, know the ups and downs, present and balance them for the project at hand, make a decision, and finally stick to it.
Standards aren't rules written in stone, they're guidelines meant to guide you and there's always going to be scenarios where they're not applicable. It's good that you recognize this already, in the academic world it's very easy to get the idea that programming is a pure science and that the rules always ring true because the examples and tasks you are given are made to make the rules you are learning ring true. In the "real world" you might have to work with a shitty codebase, weird hardware or just code written by someone with another of rules and at that point religiously following a set of rules is only going to hurt you. 
I am gonna let [Kevlin Henney](https://youtu.be/mrY6xrWp3Gs?t=40m45s) answer this one for you.
There are ways around this rule. int err = 0; do { int err = somefunc(); if ( err ) { break; } err = someOtherFunc(); ......... } while(0); return err; It _technically_ follows the rule.
Thanks for the answers ( I'm sorry if I'm not replying to everyone but I deeply appreciate every answer I got), I was kinda tricked by the "This is required by IEC 61508, under good programming style" and I couldn't see why the rule make sense in the embedded world but in general it's not always the best thing to do.
I started early with an RS6000 machine at the college using punch cards, but bought my Commodore 64 for personal use. I did the BASIC thing just as you described but I was lucky enough to get a HES Mon cartridge for the C64 that allowed me to do straight assembly coding on the 6502.
As with most guidelines, I would say it depends. For your example, I prefer the upper implementation. If the function is a little more complex, and maybe involves allocating resources (memory, files,...) then you can free all these resources right before your single exit point. With multiple exit points, you will get code duplication and increase the risk of memory leaks and other unpleasant side effects of not freeing things.
Pascal was widely used as a bootstrapper in the early days because migration of the P-Code interpreter was fairly straight forward from processor to processor. First you'd write your compiler for the new hardware in Pascal, compile it to P-Code, hand craft a P-Code interpreter on your new processor then compile your compiler using the P-Code on the new machine.
&gt; The rule is required and not advisory This is the bug. It should be recommended but not required. It's good style, until it's not. There are many instances it makes more sense, is more efficient, and uses less code, to simply fail early.
I believe `ppL` is meant to be a pointer to pointers to `int`, but it is declared as a simple pointer to `int`. This might have gone unnoticed on a 32-bit machine, but on a 64-bit machine (I assume you are on a PC or similar), `int` is 32 bits wide while `int *` is 64 bits wide. So every time you store a new pointer in `ppL`, you overwrite half of the previous one. You could have avoided this by enabling compiler warnings.
I'm pretty sure MISRA doesn't allow multiple exit points from loops either, so `break` and `continue` are disallowed. You usually end up doing ret = do_something(); if (ret == SUCCESS) { ret = do_something_else(); if (ret == SUCCESS) { ret = do_third_thing(); if (ret == SUCCESS) { printf("success\n"); } else { printf("error\n"); } } else { printf("error\n"); } } else { printf("error\n"); } return ret; 
IEC 61508 does not require MISRA. It recommends adopting strict coding guidelines if using C (and discourages C as a general rule, IIRC) but does not mandate a specific standard or set of guidelines. (source: I have an IEC 61508 exam certificate lying around... somewhere...)
MISRA 15.4 and 15.5 are not mandatory, and can be "disapplied".
I feel like that was a good way to start. Nice that you had an assembler. I'm sure I did eventually, but I don't remember what it was.
unrelated as your question has already been answered but I suggest you refrain from using raw pointer arithmetic when it is meant semantically as array access: *pL == pL[0] *(pL + 1) == pL[1] *(ppL + i) == ppL[i] This will make code more readable.
It's the opposite, MISRA has that rule and it says that it's required by IEC, I directly quoted it from the MISRA C 2004
Ah, thanks, I didn't realize you were quoting MISRA.
I wish we kept this simplicity for bootstrapping. It feels that it's a much more involved affair now, with C/C++. Or am I wrong?
You're not wrong, Walter, you're just an asshole.
I wasn't sure if i had to declare it as an int**, thank you very much! I don't think theres an option to show compiler warnings in CodeWars, could've thrown it through gcc though. 
You're absolutely right! Thanks. 
Confused bot?
Your return value should always be of the type declared in the function signature.
You dont need the 'match all rule'. In lex/flex the default action is to print non matching lines to stdout. All that you need for what the op asks is a rule to match and strip comments (dont print). That may be simply done with a state (%x COMMENT), rather than with a complex and fragile pattern.
This subreddit is about the C programming language. Your post doesn't seem to be specifically about C, but rather about programming in general, so it is off topic. Please post elsewhere, e.g. in /r/learnprogramming.
I highly doubt you can’t see warnings in CodeWars (nerver used it), If you really can’t, then stop using CodeWars
The guideline I've set for my own coding style is that early returns are acceptable at the start of the function, before anything has been done that requires cleanup. That lets me get the basic validity checks and things out of the way without indenting the body of the function with a bunch of nested if's.
I prefer early return statements. It's easier to reason about: if a certain condition hits, return. You can just disregard everything after that, which reads better imo. 
For very short functions (under ~10 lines) I have no beef with functions that have multiple conditional exits. Fir moderately complex functions I think the second form is more extensible, since you can add processing save in the knowledge that you did not exit earlier (avoiding unreachable code).
Develop and test locally where you have control over your toolchain. That way you can use a debugger, valgrind, compiler warnings, `-fsanitize=address`, etc. to help track down problems.
If you want a simple text editor with code you can actually understand, try the source code of `ed`, the standard UNIX text editor. It's a line editor and thus a bit weird from a modern perspective, but the source code should give you some solid insights into what data structures you might use for an editor. See [here](https://github.com/freebsd/freebsd/tree/master/bin/ed) for the source of one version of `ed`.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [freebsd/freebsd/.../**ed** (master → e396020)](https://github.com/freebsd/freebsd/tree/e396020937ddfda91a487705bf76b977f4d23905/bin/ed) ---- 
Is [this](http://www.texteditors.org/cgi-bin/wiki.pl?action=browse&amp;id=RockEdit&amp;revision=3) what you want? The link mentions how to run the code. 
There is no correlation between predictability and single exit point. int foo(int arg1) { if (arg1 % 2) { do_a_long_operation(); } return 0; } How is the above function remotely predictable in time?
Interesting that he's teaching structured programming! Unfortunately, the toy examples don't do return-early style justice. When you have 4 or 5 different things you have to clean up, return-early with an error ladder is the cleanest path available in languages without exceptions or auto-cleanup mechanism. The alternative is alligator code, where you have so many levels of indentation the left margin looks like an open alligator mouth.
&gt;C Programming : A modern approach, 2nd edition, by K. N. King is my favorite. Do you have a second favorite? I've been working with Deitel's C How to program which I really like.
I have to be honest that I only used two books for C, which is the K&amp;R one, and King's. K&amp;R is so incredibly old, and hardly a good book for starters into C imho (especially for those without prior programming knowledge). King's is more accessible.
You're welcome, hope it works now!
Yes, that was all. I thought that, since ppL is a pointer that points to memory allocated as pointer memory, the ** would be imlicit or something. I need to work on my pointer skills.
Ok thanks 
That's interesting. I think it could work if functions are kept small enough. I had a guy working for me who wrote a function over 1000 lines long, it wouldn't fit into our standard editor at the time. I made him break it up, he was not happy. 
I got frustrated on something and played with preprocessor macros. This doesn't quite work. // preprocessor trick https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html // it doesn't work for us here because the x ## y operator occurs before __LINE__ expanded // // `./a.out knb eeeeeeeeee 8 poiuytreew 12345` triggers end of line bug #include &lt;stdio.h&gt; #define PUTS(str, n) do { \ for(int _i = 0; _i &lt; (n); _i++) { \ if((str)[_i] == '\0') { goto PUTS ## __LINE__; } \ else putc((str)[_i], stdout); \ } \ printf("\e[31m%c\e[0m", (str)[(n)]);; \ for(int _i = (n)+1; (str)[_i] != '\0'; _i++) putc((str)[_i], stdout); \ PUTS ## __LINE__: putc('\n', stdout); } while(0) int main(int argc, char *argv[]) { /* if the last arg get's clipped on '\0' output runs into next line */ for(int n = 0; n &lt; argc; n++) PUTS(argv[n], n); /* because __LINE__ did not expand this turns into redefined label error.. */ //PUTS("Hello, World!", 5); return 0; }
That looks like it's a 20+ year old unmaintained program. Practically anything would be a better choice. I'm honestly impressed you managed to dig up something that old though.
Run it with an existing file as command line argument. You should see the file content and be able to move around.
Nice! Most people look at [kilo](https://viewsourcecode.org/snaptoken/kilo/) but very nice. =) You might have needed to edit `#define OS_UNX 1` on Linux but it worked for me. There is a help screen if you press `ctrl-A`, messes the terminal up if closed without cleanup (i.e. `ctrl-C`, don't do that). Very nifty! If you want a **Public Domain** text editor there is [TDER](http://www.texteditors.org/cgi-bin/wiki.pl?TDE) but that one is much much more complicated... But for legal reasons might be useful, IANAL. Oh that, neither this editor nor kilo work without giving a filename, and it messes the terminal up too. On Linux use the command `reset` to fix that.
&gt; I always knew that is was a good programming practice It's not good programming practice. The first of the two codes you posted is simpler and easier to read. MISRA is not a "good practice" guide, it's more of a "try and prevent unskilled programmers from shooting themself in the foot" guide. 
If the code will never be touched by another person. Sure. If anyone will ever, ever touch it, for the love of God, do not use goto.
No. There are appropriate times to use `goto`. The Linux kernel uses *and recommends* doing literally what GP described in its code standard. `goto` is not evil, just prone to abuse. But that doesn't mean don't use it ever. Baby and bath water, my man.
Wow, someone should have told this author about autotools :)
&gt; Sorry for being imprecise. Prefer double to float. There is very little reason to use the latter in 2018. Use what you need, know your requirements.
&gt;should have told this author about autotools or CMake :) Indeed, should anyone expand Automake with these features would be great as they are ubiquitous! 
If what you need is a float (IEEE 754 32bit), you'd better not use an x86 processor, because you'll gonna get excess precision.
That looks great! I was wondering about this a while ago. It makes so much sense I was surprised it's not part of the language normally. It's just natural follow on to anomalous structures.
&gt; cross-platform, GNU Make-based yeah, so not cross-platform &gt; Make is a part of POSIX standard and many Unix-like systems adopt GNU Make as their Make implementations. s/many Unix-Like/Linux And if you're mentioning POSIX and GNU Make in one sentence, probably much is wrong. Don't get me wrong, I often enough also use GNU Make for ease of use but it's neither cross-platform nor close to POSIX make.
Since you already have a pointer, there is no need to use the `&amp;` operator to take the address. Just pass the pointer you have down to the next function.
Thank you! I did not realize that.
Inside Function2 you're passing the address of a pointer to Function3. It means you're gonna get a pointer to a pointer on Function3. Is this what you want? It seems to me you just want the original variables on Function3. If so, just call Function3(var1, var2) instead of using the address-of operator.
Thanks, I didn't realize that either. I'm still new to pointers so I still have a bit of trouble with them.
I think the Kanetkar book "Let Us C", which is still widely used in Indian colleges, could probably give this book some competition.
The syntax can be gnarly, but pointers are not as scary as people make them out to be. They are variables like any others, but just happens to hold the address of something in memory. Any analogy is bound to break down if you stress it enough, but in this case, you can think of houses. The original variable you have in `main` is a house. Passing a pointer to that house is like writing the address of that house on a piece of paper and passing this along. You are not passing the house itself (which might be a big struct or - as in this case - a small integer) but only a note saying where it is. Even better - you're actually making a copy of your paper and sending it on (so that if the function scribbles on the note (changes the address written on it), yours still has the same address on it). If the function receiving that note wants another function to use it, it would make a copy of that note and pass the copy along. (This happens for all variables passed to functions, not just pointers - pointers are not special.) However, by using the `&amp;` operator you are saying: "I wish to find out the address not of the original house *but of this note that I am holding*" (this is were the analogy creaks - paper notes are seldom large enough to command their own street addresses) and then *that* address is passed along. The receiving function knows nothing of the house, and receives the address to a note. It *thinks* it received the address to a house (int) so fun things are bound to happen, and the compiler will at the very least warn you.
Thanks, but I had no problem compiling the code. The problem I had was this editor was not able to edit an empty file, or enter a newline. 
Thanks for the info! While I was able to compile the code, I didn't realize why it wouldn't allow me to edit an empty file or enter a newline. I had tried TDE earlier, but as you said it is too complex for a beginner like me. I will have a look into the link you posted and try to dig into the code a bit.
I understand. But I haven't used this text editor. And this is the only documentation I could find. The best you can do is use gdb to step through the source code and see what is happening. Then figure out why you aren't able to edit an empty file or add a new line. 
Nice! Thanks for the link. I will have a look.
I hadn't realized that it didn't work with empty files. I thought that was some kind of bug.
The arguments that I've heard for goto claim that it has usefulness in situations that require quickly executing code. In these situations, I'd argue that if you're not using assembly, then you really don't need the gains you're going to get from using goto. Goto is a crutch to support bad coding habbits.
I use `plan9-extension` quite often, its one of those things i wished was in the standard. Though with C11 we are half-way there...
That's usually used by teachers and students who're not really preparing to be programmers. They're just looking to pass the C programming 101 course in colleges. Because of the huge IT boom in India 2 decades back, CS is considered a popular major but in essence only a very small percentage of students actually get to core CS or software dev roles. Most just end up at IT services roles. Nonetheless, I agree that's a pathetic book.
Have any situation as an example where you used it and it greatly helped you?
Polymorphic objects of multiple levels. Not having to use a name for each super-type saves me on typing, and it also makes things clearer. To me anyway. Greatly helping is pushing it a bit ;) But when you need it, its really nice!
It is! It really should work with empty programs.
Haha thanks for the compliment lol
I agree, but maybe I'm biased because I mostly done OOP in my life and I tend to do things this way. But in any case, an OOP approach helps to organize code if done correctly, or it can lead to nightmare if abused. 
Thank you, that was a very good explanation! I really like pointers, granted I was insanely confused by them at first, now I just make a few mistakes on occasion, and; as my question points out, get confused of some of the rules. I really appreciate you taking the time to write this out, it was very informative!
For the exercise I was doing something like that. It's used as a ring buffer made out of a chain list to contains bytes and it's literal representation. That's for a small crypto project where one could encrypt chain of characters with, so far, using xor, hence the ring buffer for the key. I certainly don't think it's all good practice, I'm more trying to play with the language and see what's possible. // file : ring_chain.h typedef _chain_item chain_item; struct _chain_item{ chain_item* next; chain_item* prev; } _chain_item_def = {NULL, NULL}; struct _ring_chain{ chain_item* edge; uint8_t* val_str; uint8_t* hex_str; } _ring_chain_def = {NULL,NULL, NULL}; typedef struct _ring_chain ring_chain; // file : byte.h #include "ring_chain.h" struct _byte{ uint8_t val; union { char hex[3]; struct{ char sixteenth; char unit; }; }; } byte_def = {0, {0,0,0}, NULL, NULL}; typedef struct _byte byte; struct _byte_it{ byte; chain; }; typedef _byte_it byte_it; 
Out of curiosity, can you give an example of what the book contains? One of my Indian friends, who works at a really good place in US, had recommended that book to me. I thought it would be good. But your comment suggests otherwise. 
@FUZxxl thanks for best laugh of the day (literally out loud) &gt; "calamitous s**tshow of textbook writing"
Mostly my impressions of this book are from answering questions from students on StackOverflow and elsewhere. The students are forced to use the book for their C course, but the book is based on 1980s technology (Turbo C, DOS and pre-ANSI C) and the author seems to be blissfully unaware of things like undefined behaviour and many of his examples seem to be completely wrong or misleading. The book has been updated a number of times, but even the most recent version seems to claim that integers are 16 bits, for example. Trying to answer the students’ questions can be quite challenging, because you first have to get them to accept that what they have read in the book may be wrong and also that the question they are looking at is based on a false premise or has no meaningful answer. As a result the Indian colleges are churning out C programmers who are going to have to unlearn much of what they think they know.
Makes sense why the book isn't good. Thanks for the reply! I think I will give the book a pass then. 
To be fair modern C has integers of *at least* 16-bit range (I'm not sure if BCD machines qualify, but if they did would need to cover 16-bit binary range).
Who is the employer? Unix, Linux, windows, embedded? What's the general nature of the work?
Hm, I thought *The Annotated C Standard* by Schildt was considered the worst C book. It has a page of the Standard on one side, and annotations to that page opposite. The price of the Standard from ISO was about 10x the price of this book; it was noted that the price difference reflects the value of the annotations. 
The article says: &gt;I don’t think he understands the call stack. but then goes on to describe misunderstanding of using a stack for automatic storage; this is a separate concept to the call stack. Nowadays it is common to use the same stack for calls and for automatic variables; in the past there were systems with two separate stacks here; as well as systems that only had a call stack and used static storage for automatic variables (which this author describes). 
in the "update" you should cast the pointer to `void *` first. There was nothing wrong with the original 
[This one](https://www.seebs.net/c/c_tcn4e.html) I think.
That would be us. This is a direct hire job. C programming using LabWindows, lots of embedded work as well. The work varies in scope and application.
&gt; Turbo C, DOS and pre-ANSI C &gt; blissfully unaware of things like undefined behaviour For some reason, the first things that popped into my head were: #include &lt;conio.h&gt; fflush(stdin);
Yea, you left some vital info out
Not to mention: void main() Or even just: main() 
Many, and most, of these criticisms are valid, but in some of the notes it felt like the author was being a bit too pedantic.
nit picking 
The latter one is fine though.
Really ? Implicit int is OK ?
Yes. What's the problem with that? Is it undefined behaviour? Or forbidden? Is it functionally broken? It's just a slightly outdated way of programming that is perfectly fine (in ANSI C).
So your company is called HiringSeattle and you have no web or otherwise presence you can link to? Sounds sketchy.
I think it's not permitted in C99 and later, but I am not a language lawyer.
You get bit a few too many times and you'll start to get pedantic too.
I think your post title has a significant typo.
This subreddit exists to discuss the C Programming Language. Please redirect your C++ content to r/cpp.
Please don't post these, especially not if they aren't in English.
Posts like this are way too common on this sub right now.
If you're looking for feedback please post your Go based project to r/golang. If you're attempting to inform the r/C_Programming community of a useful tool, you have a lot of work to do before I think anyone on this sub would consider using this. For starters you're already competing with CMake, which is *actually* cross-platform, and GNU Autotools, which is GNU Make based. I don't see any features you're providing that would convince me to use this over CMake.
What have you got so far? It's just relatively simple math
Yeah show an attempt and then if you're still stuck, it will be easier to show you where you got stuck
double income, tax1, tax2, tax3, total\_tax; const float X = .10, Y = .15, Z = .25; // The X, Y, and Z constants represent the tax rate to be charged cout &lt;&lt; "This program will calculate Taxes owed for the country Polobia \\n"; cout &lt;&lt; "Please enter total income "; cin &gt;&gt; income; tax1 = income \* X The math is the part I get but I am struggling with setting up the code so that whatever number I input it spits out the breakdown. Go ahead and roast me
This is C++ code, but you've posted in a C programming subreddit. However... You'll likely need a few conditional (`if`) statements. If you were calculating this by hand, how would you calculate the tax on $35,000? Explain all of the steps you take to arrive at the answer. At any point, do you multiply that 35000 by 0.1? That's what your code is currently trying to do.
Thank you. I do look for feedback. Though the project is implemented in Go (golang), it is currently designed for C (or C++) programmers. Therefore, I posted it here to gather feedback. If the idea is viable, I consider to extend it to other compilers or tools that lack of builtin project manager like LaTeX. I wrote it for C (or C++) first to see if it worked. I didn't think of posting it to r/golang; it sounds good.
No code. Only explanation. That's the tip ill give you. 70 grand. Now we receive this all at once, but we are not taxed on it all at once. Let's look at the limits. I don't feel like closing my post and reading the numbers so convert what I say to your assignment. First 15 grand taxed at 10%. I'm receiving at least 15 grand right (70 &gt; 15), so then I add 10% of 15 as tax. Write this as a condition in your code, you know what it is in concept so you can write it as code. Now, I took care of the first 15 grand, so I'm only worried about the remaining 55 grand. Let me update the remaining salary variable or whatever it is accordingly. Keep doing this until you reach the end. Let's say I calculate taxes for everything but the last 8 grand. My final tax percentage is 20. So I add in 20% of 8 grand (I don't want to do the actual math). Done. 
Here's a sneak peek of /r/golang using the [top posts](https://np.reddit.com/r/golang/top/?sort=top&amp;t=year) of the year! \#1: [It came to them with a message](https://pbs.twimg.com/media/DEjApdzXcAAlhH7.jpg) | [73 comments](https://np.reddit.com/r/golang/comments/6na5sy/it_came_to_them_with_a_message/) \#2: [Go 2, please don't make it happen](https://i.redd.it/7t1p88ct13ez.jpg) | [287 comments](https://np.reddit.com/r/golang/comments/6rxfjo/go_2_please_dont_make_it_happen/) \#3: [Self-aware robot](http://i.imgur.com/KZkCd7r.png) | [35 comments](https://np.reddit.com/r/golang/comments/6uihnj/selfaware_robot/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
Thank you for this! I understand much better what I need to do. So essentially what I need to do is first 15 taxed at the appropriate rate, next would be 30k taxed at the appropriate rate, and the remaining 25k taxed at the max rate?
Yes, "remaining" being the key word here. You have to remember that you are taxing ranges, not amounts. Even though you are taxing 30k, you are taxing the salary range of 15k-45k. There is no 30k separately, because you received your salary in one large chunk, not separate checks of 15,30,and 25.
Write out how you would explain the steps to a young teenager, using the terms 'if', 'then', 'else' (otherwise), and such. Like "If the income is less than $15,000, then the tax is 10% of the income. If the income is between $15,000 and $45,000, then the tax is $1,500 plus the part $15,00 and above". And so on. Once you've written it down in simple steps, then you should be able to translate that to code. 
You all have been very helpful Thank you!
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
That's fine, I'm not trying to be rude, it's just that the only feedback we can reasonably give you on this sub is whether or not we would use this particular tool, and IMHO it's not mature or full-featured enough to justify changing from my normal workflow. I actually think this is a cool project from the pedagogical perspective, but if you're looking to learn more, or ways to improve it you should consider your competition, and advice from other Go programmers.
Ok so lets the income is 150k 1. First 15000 is 10% so 1500 (remaining is 135k) 2. Next between 15 to 45k is 15% (45k)*.15( remaining is 90k 3. anything above 45k is 25% so 90k *.25 This will give me my total tax And then as far as coding this I should use an if statement like so double income, tax1, tax2, tax3, total_tax; const float X = .10, Y = .15, Z = .25; // The X, Y, and Z constants represent the tax rate to be charged cout &lt;&lt; "This program will calculate Taxes owed for the country Polobia \n"; cout &lt;&lt; "Please enter total income "; cin &gt;&gt; income; if (income &gt;= 15000) tax1 = 15000 * X; tax2 = (income - 30000) Thanks for your help 
From how I understand your question, only the 15-45 will be taxed 15%. So the end tax for that will be actually .15*30k = blah. Then subtract the 30k because that's what you analyzed. 
Makes perfect sense now thanks, maybe Im just retarded but the way this question was worded made no sense to me. Thanks for your help
The question was worded as per a mathematical and computer science related standard. For everything, there is an intuitive and correct definition. This problem is defined correctly, taking care of exceptional cases and arguments against ambiguity, but not intuitively so that you can understand it at first glance unless you've seen something like it before. You should talk to the professor and ask them to reward it for you, to whatever extent they are able to.
Also don't remove your question please. It might help others understand.
I appreciate your help, you should teach!
Thanks lol I plan to. Still in college tho
Need a bit more information I think.
Definitely not nit picking. The first code sample from the book is a total shitshow of badness.
On your system, a long is bigger than an int. The compiler is just warning you that the downsize can result in the loss of data if the value in the long is too large to be held in an int. It's harmless in this case but can be a big problem in others.
You can make your own random number program. Study algorithms.
Thanks man!! For some reason Xcode won't let me compile it because of the error. Do you have any advise as to why that might be happening too? I'm learning C in school. Im still a noob. haha thank you 
Since you’re using Xcode, use the “arc4random” variant of functions instead of “srand” and “rand”. It’s secure and you don’t have to seed it. 
Are you enabling an option to treat warnings as errors? Don't do that.
Thanks! So how would that look? haha Like this? int main (void) { int sampleSize; arc4random(time(NULL)); sampleSize = arc4random() &amp;#37; (UPPER\_LIMIT - LOWER\_LIMIT + 1) + LOWER\_LIMIT; if (sampleSize &amp;#37; 2 == 0) sampleSize++; { printf("\\n &amp;#37;d \\n", sampleSize); } return 0; }
I'm going to go out on a limb and say that this is an assignment for CS 50 and that OP's professor/TAs may not be compiling it under OS X.
I don't think I am. Not sure. 
[https://www.tutorialspoint.com/c\_standard\_library/c\_function\_srand.htm](https://www.tutorialspoint.com/c_standard_library/c_function_srand.htm) `void srand(unsigned int seed)` The `srand()` function expects seeds of type unsigned int and will convert the long you are passing to it by casting. A long is usually 64 bits and an int is usually 32 bits so that casting could result in a loss of data.
You can also cast the value to an int, or use a different RNG. srand48()/lrand48() works with longs, or arc4random like someone else suggested.
Even easier: nt main (void) { int sampleSize; // Not needed, arc4random is automatically “seeded” by the system // arc4random(time(NULL)); sampleSize = arc4random() % (UPPER_LIMIT - LOWER_LIMIT + 1) + LOWER_LIMIT; if (sampleSize % 2 == 0) sampleSize++; { printf("\n %d \n", sampleSize); } return 0; }
 The project is still in its early stage. I want to make a project generator for tools that own no builtin package manager like LaTeX by utilizing GNU Make. Currently, I wrote for C (or C++) first. Any comments and feedback are welcome. 
I thought that too, but I checked and GCC still allows it when using the c11 standard: ``` $ gcc -Wall -fsyntax-only -x c -std=c11 - &lt;&lt;EOF &gt; main(){} &gt; EOF &lt;stdin&gt;:1:1: warning: return type defaults to ‘int’ [-Wimplicit-int] ```
For the next time: Do not post images of code! You can't search for images, meaning that future readers with the same problem as you won't find your post and won't get the same help you got. Don't deny future readers this resource! Don't post pictures of code!
Use `-Wall` to display all warnings but not convert them all to errors. $ gcc -Wall -o &lt;output&gt; &lt;input&gt; Nonetheless, do not brush off warnings even if your program compiles.
the prob of a sample of size 21 is half what it is for 23 or 25 or any other size up to 41.
Oh well, useful for code golf I suppose.
Cast your seed aka the time, to uintptr_t This ensures its the right size across linux and windows
OP is likely to use Xcode defaults. In any case, in Xcode those options can be found in the project settings. There's a tab for build settings and a checkbox to show all instead of some.
This should initialize the first member of the union, i, to 300.
From the standard, §6.7.9 Initialization, ¶17: &gt; Each brace-enclosed initializer list has an associated _current object_. When no designations are present, subobjects of the current object are initialized in order according to the type of the current object: array elements in increasing subscript order, structure members in declaration order, and the first named member of a union. So this is valid code, and it initializes the `i` element of the union. That being said, if I were reading this code, I would appreciate it having an explicit designator: union Test a = { .i = 300 }; 
Nobody explained in in really simple terms so here it is: srand() expects an unsigned int, time(NULL) returns a time_t which is a long, so the value is implicitly converted by calling the function. The easiest 'fix' is to make the cast explicit, i.e.: `srand((unsigned int)time(NULL))`. Because time() returns a number of seconds and is unsigned, the loss of precision is unlikely to cause any issues. Or you can use a different RNG.
Initializes the first member of the union. 
Another simple one (from the same site) you might want to take a look at is [E-Mtv](http://texteditors.org/cgi-bin/wiki.pl?E-Mtv) It is also small, less than 700 lines of commented code, very easy to follow, and does not require a filename on the command line :-) It does however, require curses, but hopefully that won't be a problem. Rather than a linked list, it uses a big buffer - but not buffer gap. E-Mtv is somewhat portable also - I was able to get it to compile on Windows, ubuntu, and also Cygwin under Windows.
Speaking of Kilo, have you seen this? [Build Your Own Text Editor](https://viewsourcecode.org/snaptoken/kilo/) It is basically a very detailed code review/explanation of the Kilo text editor. I think the author did an excellent job. Very nice!
&gt;That looks like it's a 20+ year old unmaintained program. Ha! How about a 33 year old unmaintained program :-) [1985 Microemacs source](https://groups.google.com/d/topic/net.sources/qraqnOktgdI/discussion) On a trip down memory lane (Yes, I remember when the above came out), I spent an hour (or maybe 2 or 3) playing with this, and got it to compile on Ubuntu and Windows. And for the most part everything just seemed to work. Both 32-bit and 64-bit compiles. While it isn't small (5500 lines of well-commented code) it is very easy to follow. 
You have to cast time() to an int. So write: srand((int)time(NULL));
I noticed that you use `0x1l` to generate a `uint64_t` constant. This is wrong for two reasons: it would need to be `0x1ul` to generate an `unsigned long ` instead of a `signed long` and the type `uint64_t` is actually an `unsigned long long` on some systems (and at least in theory could even be an `unsigned int`). To avoid this problem the standard requires there to be a macro `UINT64_C` that would expand `UINT64_C(0x1)` to `0x1ul` or `0x1ull` as appropriate. Otherwise it looks quite good for somebody without much experience, I haven't checked the actual code logic though.
Awesome!!!! Just what I was looking for! Its cross platform too. Btw did you write this editor?
&gt;Btw did you write this editor? Nope, but I wish I had :-)
A few things: - You didn't fclose in `simulate_cache` - posix reserves the `_t` suffix for future usage, so if you want to be fully posix compliant you shouldn't use `_t` suffixes. Personally, I think this rule sucks, and I use `_t` all over my code since IMO it's incredibly clear that the symbol is a type name. Still, it's something to remember - You use `'%lx'` as the format code for sscanf for `uint64_t`. Format codes are hard to get right because of differences in platforms. There are defines like `PRId64` and similar in `inttypes.h` which you should prefer, as they're cross platform. - prefer `bool` to `int` for things that are only ever true or false, like `help` and `required` in `init` - `simulate_cache_access` will read garbage from `result` at #195 if `line-&gt;command` isn't `STORE` - if a function is only meant to be used in the file it's defined in, make it `static`
Minor thing: you could use getopt for parsing arguments, instead of parsing yourself
I disagree. I always compile with -Wall and -Werror, except during initial development. When I check in code, it compiles *cleanly*. Ignoring warnings is annoying at best, and hides serious errors at worst.
That sounds decidedly non-portable to me.
If uintptr_t is 64 bits, and srand() takes a 32-bit value, then this will generate the same error as before. Plus, stand() doesn't *take* a uintptr_t value. If you're going to cast a value, cast it to the right type.
You should indent your code 4 spaces so reddit knows how to format it correctly. int main (void) { int sampleSize; and so forth
Or mkmf or AutoConfig or who knows how many other "automated Makefile generators" there are out there. I hate those things. They add complexity without actually fixing any problems.
True didnt check the srand signature Point was, cast it to a stdint type
C++ is off topic in this subreddit. Please post C++ questions elsewhere, e.g. to /r/cpp_questions.
Sorry
No problem. Just make sure to pick the right subreddit next time.
Admittedly, I posted this before I looked at the code samples page. After checking that page, I'm much less likely to give the author benefit of the doubt.
It's somewhat hard to see what program is for without being familiar with book/homework. I think hexadecimal constants are automatically unsigned integers but less sure about default integer sizes. I've never seen TDD of C command line arguments quite like that even though it is exactly what should be done. :/ I don't even know what the matrix parts are for. Maybe include a README and mention name of any algorithm used to look up. To be fair you linked to a book but I haven't clicked on it yet. Those are first impressions, I don't know exactly what you're doing but the code itself looks okay.
Please fix the way your code is presented. For blocks of code, each lines must be indented with four spaces. Back quotes (`) are only used for code snippets inside a line of code. &gt; va_list ap = * app; Array initializer must be an initializer list On your platform, `va_list` is an array. You cannot assign to arrays which is why you get this error message. Use the `va_copy` function to copy `*app` into `ap` instead: va_list ap; va_copy(ap, *app); &gt; Clearly Xcode doesn't like generic function pointers. I have removed the typedef void (* voidf) (); line and replaced each voidf with void*. Losing a little type safety in a narrow scope isn't too bad? Should I just ignore the warning? Note that by changing the type to `void *`, you just turned what is a harmless warning into technically undefined behaviour as data pointers (such as of type `void *`) and function pointers (such as of type `void (*) ()`) are not guaranteed to be compatible. If you don't want to turn off the underlying bogus warning, I suggest to change the line to typedef void (* voidf) (void); so the type is declared as “pointer to function taking no arguments returning `void`” instead of “pointer to function taking arbitrary arguments returning `void`.” You can however just disable the warning and everything is fine. &gt; while ((selector = va_arg(ap, voidf))) I'm not sure what causes this error. Are you sure there is really this amount of parentheses?
Changing va\_list ap=\*app; to va\_copy(ap, \*app); got rid of both errors. Thank you! Yes there were three parentheses each side although I guess this isn't a problem since this error was preceded by an erroneous line of code.
You're not formatting your code correctly. For blocks of code don't use backticks (\`) for every line. Just indent the code with four spaces. Also the code you show has more errors than you show, presumably because there's code you're not including. For example it's missing headers and there's no definition of the `Class` struct, which is needed for code like `self-&gt;name`. These extra errors get in the way of diagnosing your issues. &gt; warning: This function declaration is not a prototype &gt; typedef void (* voidf) (); I don't see this warning from clang (the compiler used in Xcode). Could be the result of something else not shown. &gt; va_list ap = * app; Array initializer must be an initializer list The original author is making invalid assumptions about what a `va_list` is and how they can be used, presumably based on the implementation they were using at the time. With clang `va_list` is an array, and so it cannot be initialized like this. What the author apparently wants is to make a copy of the va_list object so that the copy can be manipulated without modifying the original va_list. This is not something that can be done portably. If modifying the original is okay then you can replace all the `va_arg(ap, voidf)` calls with `va_arg(*app, voidf)`. &gt; _Extraneous ')' after condition, expected a statement_ This is also not something clang produces for me. http://coliru.stacked-crooked.com/a/b08a0a217ce7ff41 
0x1ull is guaranteed to produce a constant at least wide enough for uint64_t
&gt; This function declaration is not a prototype The relevant warning is `-Wstrict-prototypes`. It might not be turned on by default.
I tried with `-Weverything` in that warning didn't trigger for me.
This wasn't my formatting! Reddit did a weird after I submitted!
LLVM is just a compiler backend, which is what clang uses. If you're building with Xcode 9 you're using clang.
One of your switch statements has a case with no break. Cmd+f `case LOAD:`
Since you said you're new to C. In C: •You can declare integers without giving them a value and they will default to 0. •You can use `x++;` instead of `x += 1;` •You can just say `if (!x)` instead of `if (x==0)` •You can just say `if(x)` instead of `if (x != NULL)` _____ You may already know that and chose to write the long-formats for readability purposes. Code is fine either way, just noting in-case you didn't know; C is a fun language!
Another editor no one seems to know about http://texteditors.org/cgi-bin/wiki.pl?OSPedit
&gt; You can declare integers without giving them a value and they will default to 0 Not true in general! (Only applies to statics/globals.) •You can just say if (!x) instead of if (x==0) •You can just say if (x) instead of if (x != NULL) It's debatable which of these forms is "better" (clarity vs brevity). 
I think it's an interesting move from CLion team as until now, they were focusing on developing their own engine and indicated many times that they didn't planned to us Clang as a code analysis. I am curious to see how long these two engines will stay together.
I think they want to ship something working for now. The current engine is massively buggy (in my experience).
That was intentional; I want `LOAD` and `STORE` to behave the same. Is there a better way to express that?
Thanks - I'm still learning what shorthand is correct. I got bitten by `if (strncmp(a, b)) {...}` recently. 
&gt; You are enrolled at CMU... Of course the education is good. :/ Actually, I'm just working through this on my own. 
Thanks - I had no idea about the macros. Keeping all the integer sizes straight is kind of a pain. I've definitely been spoiled by ruby
This is super-useful; thank you! 
I'll take a look at this; thanks
Very weird. Perhaps the warning was improved over time? Which LLVM version do you use?
I worked with the current engine mostly on C code and it was working pretty well. Except some strange includes and the unused include inspection being disabled, I never encountered anything that blocked me.
What has the C PreProcessor to do with it? :p
&gt; That sounds decidedly non-portable to me. Well, the original code was non-portable too. The type of `time_t` is implementation defined. It must be a real type (so a non-complex integer or floating type), but its range and precision are implementation defined. A particular perverse C implementation could do: #define time_t double /* Range of permitted values: [0.0, 1.0), plus (time_t)(-1) */ So if you _really_ care about portability, the OP's code wouldn't do either.
C !=C++!
The arc4random() family of functions is available on FreeBSD and it’s variants (all Apple platforms). Not portable to Windows or Linux, but for the environments it’s defined on it’s definitely better than srand/rand. 
That's because you overflow the range of a `long int`.
Technically it's undefined behavior when adding `1` to `LONG_MAX` (Which seems on your system is `9223372036854775807`), but basically you are just "overflowing" into the negatives. See [Tow's complement](https://en.wikipedia.org/wiki/Two%27s_complement) for the details. 
**Two's complement** Two's complement is a mathematical operation on binary numbers, best known for its role in computing as a method of signed number representation. For this reason, it is the most important example of a radix complement. The two's complement of an N-bit number is defined as its complement with respect to 2N. For instance, for the three-bit number 010, the two's complement is 110, because 010 + 110 = 1000. Two's complement is the most common method of representing signed integers on computers. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
(C == C++) evaluates to true, wtf are you talking about?
As the other commenters have mentioned, this is due to two's complement, the way signed integers are typically encoded. Unlike signed integers, doing this with a signed integer will wrap back around to 0, as there are not enough bits to encode it, so the carry doesn't fit. For instance, say you have an unsigned 8 bit integer, with the value `0b11111111`, what would happen? Assuming we weren't constrained by the 8 bits, it would become `0b100000000`, but all you'll see in that 8 bit slice is `0b00000000`. Have a play around with integer overflow and you'll soon understand it. Programming in C, it is something you will want to be able to spot without too much trouble.
1) `br` is a pointer, not a character. So it's value won't be `0`, it will be a memory address (non-zero). To verify this, print `br` in each loop. 2) No, `%d` scans for a decimal number. If you were to use `%i` it would be interpreted depending on the start of the number. Also, octal 07 is the same as decimal 07 so there's no difference here. If you want the leading zero printed out, you should use a `printf()` format specifier like `%02d` 
I’ve never even considered doing something like that in a switch statement. Had never even occurred to me that that could work like that. Thanks for teaching me!
1. ``br`` is a pointer on the character array. When pointing on ``'\0'``, its address is ``&amp;hex[4]``, which is certainly not ``NULL``. So the ``while`` will continue. You have to dereference it, just like you do for ``tolower``. 2. This is C++, not C :)
You need to compile the library statically within your binary. To do so, Allegro itself must be compiled with the proper option to support this. Search Allegro documentation on how to do this. Beyond that, I don't think you can cross-compile for Windows, so you will probably need to setup a machine to build natively on it.
There is MinGW for Linux, I've sucessfully compiled some binaries that work on Windows (and wine).
Yes, it looks like the warning was introduced in 4.0, whereas the example I linked hasn't updated in a while and still uses 3.8.
It seems like you're not *too* far away from a working Windows build. It's just a matter of tracking down all of the dependencies. I downloaded the Allegro sources, but, since it builds using CMake, cross-compiling via Mingw-w64 is non-trivial. (It's one of the things I personally dislike about CMake). Rather than hack their CMakeLists.txt to make that work, I instead grabbed [allegro-x86_64-w64-mingw32-gcc-7.2.0-posix-seh-static-5.2.4.1.zip](https://github.com/liballeg/allegro5/releases). I unzipped that inside your repository, deleted all the debug static libraries (`rm allegro/lib/*debug*`), then tried to build it like this: x86_64-w64-mingw32-gcc -Iallegro/include/ src/main.c \ allegro/lib/liballegro*-static.a \ -lopengl32 -lm -lgdi32 -lpsapi -lwinmm -ldsound -lshlwapi -lstdc++ The `-lstdc++` is necessary since Allegro is written in C++. The rest are system DLLs that come with Windows. However, this *still* has a bunch of linker issues. Allegro itself depends on these (despite your own program not actually needing any of them): * libdumb * libFLAC * libfreetype * libogg * libvorbis And then transiently on: * libvorbisfile * zlib So you'd have to build these yourself with Mingw-w64, or find pre-built binaries. That's easier to do with some more than others. Or example, I couldn't find any Mingw-w64 builds for Freetype. 
C not equal C++
Most C books teaches to assign a value.
Yeah my IDE gives me a warning every time. 
Clang can absolutely cross compile for wndows, it even support's MSVC's ABI. the hard part is getting the Windows SDK.
Ok. So, I just need to get the windows binaries for Allegro and then get the windows binaries for all those things you just listed and then compile it all together for Windows?
I think that would do it, yes.
&gt; **How do I statically link?** &gt; Sacrifice a virgin maiden to the gods of Mt Allegrohorn. https://wiki.allegro.cc/index.php?title=FAQ#How_do_I_statically_link.3F
This is actually not related to C. Anyway, what did you do? `miscperl.pl` seems to be shipped with the archive. I did this: # Compile library tar -xaf rhtvision_2.2.1-4.tar.gz cd tvision/ ./configure make -j5 # NOTE! You would want to do #make install # but since I don't want to install it on my system, # I didn't and changed some things later on that # you may not need to change. # The followig commands shouldn't be needed # when you've installed the library export PATH="$PWD":"$PATH" export TV="$PWD" # END cd .. # Compile OSPedit 7z x ospedit-2.1.1-src.zip cd ospedit-2.1.1/ # Archive was using CRLF instead of LF so convert it find . -type f -exec dos2unix '{}' \; sh configure linux # Since I didn't installed the library, # I need to hack the Makefile to add the # include and library paths # You probably don't need this sed -i -e "/^\(C\(PP\)\?\)FLAGS \+=/ s|$| -I'$TV/include'|" -e "/^LDFLAGS \+=/ s|$| -L'$TV/makes'|" Makefile # END make -j5 bin/linux/ospedit # Editor starts
Obligatory ‘whoosh’ 💨
My first thought: **"Oh shit, I don't have any virgin maidens."** My second thought, once I scrolled down: **"This is actually a really useful FAQ page."**
On Linux, it is expected that you distribute source code every user can compile himself.
Right, so I almost posted a comment telling OP to redirect this to r/cpp, but then I took 30 seconds to google `clangd` and realized it looks like a tool that can be equally beneficial to both languages, and this article just happens to focus on C++. Check out the [features](https://clang.llvm.org/extra/clangd.html), and how LLVM is marketing it as a tool for both languages. Maybe I'm wrong, but I'm pretty sure this post is C relevant.
Your loop doesn't loop - i starts at n, executes the loop blocks once and then quits because its reached its target of n. You might want to reconsider your loop and start with i=1.
Yes, and that's why I have not removed this post.
has there been any progress on makefile support? when i looked ages ago it only used cmake (i have intellij idea paid for, but use eclipse for c dev because of this...)
OP is using Lubuntu, aka Ubuntu, which has MinGW in their repositories. Crosscompiling using CMake is basically setting the toolchain file when generating (`-DCMAKE_TOOLCHAIN_FILE=/path/to/toolchain.cmake`) and there are pre-existing ones for e. g. the [MinGW chain for Ubuntu](https://github.com/zyga/cmake-toolchains/blob/master/Toolchain-Ubuntu-mingw64.cmake). Depending what the project does this might be enough, but I haven't tested it yet. This is basically the way I use to cross-compile to Windows.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [zyga/cmake-toolchains/.../**Toolchain-Ubuntu-mingw64.cmake** (master → b1c731f)](https://github.com/zyga/cmake-toolchains/blob/b1c731f92db5820b058453cb5407761ac4860818/Toolchain-Ubuntu-mingw64.cmake) ---- 
You can use the importer to convert to cmake, add a cmake [shim](https://stackoverflow.com/questions/26918459/using-local-makefile-for-clion-instead-of-cmake), or use the [plugin](https://plugins.jetbrains.com/plugin/9333-makefile-support). I've used the first two methods for some large projects just for the IDE's sake and it worked nicely. Debugging said large projects can get tricky however.
oh if there's a plugin that may be enough. thanks.
What was the exact error message? "miscperl.pl could not be found" as almost certainly not the *exact* error message. I ask because you might be getting an error about a missing *interpreter*, not a missing file. Do you have Perl istalled?
&gt; Testing my code is showing that only last assignment that is called is assigned to every location in both arrays. That would be because you're assigning `text` to every location, overwriting the pointer returned by `malloc`.
C++ is very different from python. Your best option in my opinion is either compiling and running in command prompt or using eclipse.
Copy the string into newly allocated line, don't replace it with memory leaks. Use `strcpy(array[i], txt);`.
 *C++ isn't C *There's no such thing as a C++ shell because C++ is compiled into executable files. In Python, your code is run by an already compiled executable that is the Python Shell. *A shell isn't an editor. An editor is for editing. A shell is a program that do anything on its own but can do things when you supply it instructions according to its syntax. *If you don't like VS Code because it has too much stuff, try notepad++, it's simple but still nice.
Thanks, this is really helpful! I tried using notepad++, and it’s good, but then how should I run the code? And again, I’m new to C++ so I’m sort of lacking on stuff like that. Also, I know C isn’t C++, but there’s no C++ sub.
There are literally three links to different C++ subs in the sidebar of this one. Not to mention the link in u/k_x90 's comment.
Oh sorry, I didn’t see those.
Literally the first line of what I wrote: &gt; /r/cplusplus is over [here](https://reddit.com/r/cpluscplus). Give me a sec to type it up, I'll give you a rundown on how compiled languages work.
`fgets` might not actually read anything if the input stream runs out of data; check its return value, and kvetch+`return` an error code if it’s `NULL`: if(!fgets(text, TEXT_LEN, stdin)) { fputs("error: unexpected EOF in input\n", stderr); return 1; } `malloc` can return `NULL` for various reasons (mostly-theoretically, but guard assiduously against it anyway); check its return value to make sure you actually allocated something. Also, you can do two different things to duplicate `text`. To copy it manually, capture the length of `text` in a variable, and use `memcpy` once you have the memory block: size_t len; char *p; len = strlen(text)+1; if(!(p = malloc(len))) { ... return 1; } memcpy(p, text, len); array[i] = p; There’s also a built-in function, `strdup`, which will do this for you: char *p; if(!(p = strdup(text)) {...; return 1;} array[i] = p; And you’re capturing probable-newlines in your text. (I.e., if an EOF ends the input line, the string ends with just NUL; if a newline ends the line, the string ends with LF NUL.) You probably don’t want this, because it’ll probably screw up whatever you intend to do with those words; to eliminate that newline before duplicating the string, do something like this: len = strlen(text); if(len &lt; 1 || text[0] == '\n') { /*maybe*/fputs("empty input line\n", stderr); continue;/* or return or otherwise break control flow */ } if(text[len - 1] == '\n') text[--len] = '\0'; and use the `malloc`+`memcpy` approach from above since you have the string length handy.
Yup that totally solved my 8 hour headache, I'm still figuring out the nuances of learning a new language. Thanks!
You could probably get Vim to look like that, and have something that is much more powerful and available on every *nix system.
&gt;tar -xaf rhtvision\_2.2.1-4.tar.gz I tried following your steps but when I ran `./configure` I get the following error: `hp@hp-HP-Notebook:~$ cd Downloads/` `hp@hp-HP-Notebook:~/Downloads$ tar -xaf rhtvision_2.2.1-4.tar.gz` `hp@hp-HP-Notebook:~/Downloads$ cd tvision/` `hp@hp-HP-Notebook:~/Downloads/tvision$ ./configure` `Can't locate` [`miscperl.pl`](https://miscperl.pl) `in @INC (@INC contains: /etc/perl /usr/local/lib/x86_64-linux-gnu/perl/5.26.1 /usr/local/share/perl/5.26.1 /usr/lib/x86_64-linux-gnu/perl5/5.26 /usr/share/perl5 /usr/lib/x86_64-linux-gnu/perl/5.26 /usr/share/perl/5.26 /usr/local/lib/site_perl /usr/lib/x86_64-linux-gnu/perl-base) at` [`config.pl`](https://config.pl) `line 8.` `hp@hp-HP-Notebook:~/Downloads/tvision$`
When I run ./configure in the turbo vision library, this is what I see: `hp@hp-HP-Notebook:~$ cd Downloads/` `hp@hp-HP-Notebook:~/Downloads$ tar -xaf rhtvision_2.2.1-4.tar.gz` `hp@hp-HP-Notebook:~/Downloads$ cd tvision/` `hp@hp-HP-Notebook:~/Downloads/tvision$ ./configure` `Can't locate` [`miscperl.pl`](https://miscperl.pl) `in @INC (@INC contains: /etc/perl /usr/local/lib/x86_64-linux-gnu/perl/5.26.1 /usr/local/share/perl/5.26.1 /usr/lib/x86_64-linux-gnu/perl5/5.26 /usr/share/perl5 /usr/lib/x86_64-linux-gnu/perl/5.26 /usr/share/perl/5.26 /usr/local/lib/site_perl /usr/lib/x86_64-linux-gnu/perl-base) at` [`config.pl`](https://config.pl) `line 8.` `hp@hp-HP-Notebook:~/Downloads/tvision$` When I run `perl -v`, I get: `hp@hp-HP-Notebook:~/Downloads/tvision$ perl -v` `This is perl 5, version 26, subversion 1 (v5.26.1) built for x86_64-linux-gnu-thread-multi` `(with 62 registered patches, see perl -V for more detail)` `Copyright 1987-2017, Larry Wall` `Perl may be copied only under the terms of either the Artistic License or the` `GNU General Public License, which may be found in the Perl 5 source kit.` `Complete documentation for Perl, including FAQ lists, should be found on` `this system using "man perl" or "perldoc perl". If you have access to the` `Internet, point your browser at` [`http://www.perl.org/`](http://www.perl.org/)`, the Perl Home Page.` `hp@hp-HP-Notebook:~/Downloads/tvision$` 
Ok, time to learn this. Every single computer in the world still runs on punchcards. Only instead of having a physical stack of cards with holes in them, we have digital ones. If you use a special program that knows that different segments of binary correspond to which CPU instructions, you can even pull apart a set of these digital cards and look at them. Disassembly of section .data: 00000000 &lt;.data&gt;: 0: 31 c0 xor eax,eax 2: 31 db xor ebx,ebx 4: 31 c9 xor ecx,ecx 6: 99 cdq 7: b0 a4 mov al,0xa4 9: cd 80 int 0x80 b: 6a 0b push 0xb d: 58 pop eax e: 50 push eax f: 68 2f 2f 73 68 push 0x68732f2f 14: 68 2f 62 69 6e push 0x6e69622f 19: 89 e3 mov ebx,esp 1b: 50 push eax 1c: 89 e2 mov edx,esp 1e: 53 push ebx 1f: 89 e1 mov ecx,esp 21: b0 0b mov al,0xb 23: cd 80 int 0x80 The hexadecimal bytes to the left are the real binary that make this program up. The words to the right are the human names of the different CPU instructions and registers being manipulated. I actually wrote the CPU instructions for this program by hand. That's how people used to have to write *everything.* It still works for tiny stuff like this, but in order to write modern programs, you need something faster. So, a long time ago, some people wrote a program that could take a file called full of text called sourcecode, and chew it up, and spit out a different file that contained a bunch of binary instructions based on what the sourcecode said. That's called a compiler. You write out code in C, or Rust, or C++, then you feed that code to gcc, or rustc, or whatever C++ uses, and the compiler spits out a new file full of binary instructions. This new file is commonly called 'a binary' or 'an executable', and it can be run by the computer in order to do stuff. Having a compiler isn't always convenient, so another method of turning sourcecode into CPU instructions was later created, called an an interpreter. An interpreter is a pre-compiled program that can eat sourcecode, but instead of spitting out an executable file, it turns the sourcecode into CPU instructions on the fly. Python is an interpreted programming language. A CPU is just a flat rock with lightning inside it. It's very very fast, but it's not very smart. It only knows how to do a couple dozen things, period. It doesn't understand Python code like it understands a compiled executable. Most programs you're probably familiar with have graphical environments with nice fancy buttons and things. But a ton of programs, probably the majority, do not. A lot of the programs your operating system depends on are just programs for stuff like writing bytes onto the disk, reading files, managing connections, etc with no graphics of any kind. But sometimes you, the user, need to be able to run a program that has no graphical frontend. Thus was born the command line. The command line is a program that allows you, the user, to execute other programs by typing them into a text-only prompt. You can change how a program runs by typing additional things in before hitting enter. I use the command line every day for various things. When I want to compile my C code, I type gcc my_program.c -o my_program Which runs gcc, the Gnu C Compiler, accepting my_program.c as the input file, and out comes a new file called my_program. When I want to run my program, I type ./my_program I used a command line program to get a nice, human readable view of that binary I showed you above by typing objdump -D -b binary -mi386 -M intel setresuid_shell Many editors have a few commands built-in that you can run by hitting keyboard shortcuts. If I recall correctly, in IDLE you can run your python script by hitting ctrl+r. This just runs the Python executable on your script internally. In Visual Studio Code, I have a keybinding set up to build my rust programs when I press ctrl+b, which internally runs the command 'cargo build'. Notepad++ doesn't have this, but you can still run your code using the command prompt. And honestly, you will have to get comfortable using the command prompt to do almost anything interesting development-wise, *especially* if you're writing Python and C++. Google around, there are tons of tutorials.
The problem *seems* to be that miscperl.pl is in the current directory but @INC (Perl's search path?) doesn't include the current directory. There's probably an easy fix to it, but I don't know enough about Perl. You might have better luck asking in a Perl subreddit, sorry.
Well, I want to study the editor's source code too, but Vim has hundreds of thousands of LoC, so this editor is much simpler.
One trick I see a lot of projects using, is adding in a "releases" folder in their Githb Repository. And then in the "Releases" tab on Github provide a list of download links for each platform. https://github.com/brave/browser-laptop/releases. That way it's easier to recognize a binary as belonging to a specific Github repo.
When I run `./configure` in the turbo vision library I get: `Succesful configuration!` `* No mouse support for console! please install the libgpm package needed` `for development. (i.e. libgpmg1-dev_1.13-5.deb).` `* No X11 support detected. If X11 is installed make sure you have the` `development packages installed (i.e. libxmu-dev). Also check the options` `to specify the paths for X11 libs and headers` When I run `make install` in the turbo vision library, I get: `librhtv.umk:1159: recipe for target 'obj/tdesktop.o' failed` `make[1]: *** [obj/tdesktop.o] Error 1` `make[1]: Leaving directory '/home/hp/tvision/makes'` `Makefile:27: recipe for target 'static-lib' failed` `make: *** [static-lib] Error 2` So, I am not able to compile the turbo vision library yet. Thanks for your help
From the link: &gt; As part of this goal, we now would like to give *clangd*, a popular Clang-based language engine, a try as an additional C++ language engine. From [the official LLVM documentation for Clangd](https://clang.llvm.org/extra/clangd.html): &gt; **Clangd** is an implementation of the [**Language Server Protocol**](https://github.com/Microsoft/language-server-protocol) leveraging Clang. Clangd’s goal is to provide language “smartness” features like code completion, find references, etc. for clients such as C/C++ Editors. 
&gt; Succesful configuration! &gt; * No mouse support for console! please install the libgpm package needed &gt; for development. (i.e. libgpmg1-dev_1.13-5.deb). &gt; * No X11 support detected. If X11 is installed make sure you have the &gt; development packages installed (i.e. libxmu-dev). Also check the options &gt; to specify the paths for X11 libs and headers Well it says it could configure it successfully, it just won't support mouse and X11 (GUI, but it shouldn't be needed for console). It also says the same on my end, however, there is still some mouse support in the final program for some reason. &gt; librhtv.umk:1159: recipe for target 'obj/tdesktop.o' failed &gt; make[1]: *** [obj/tdesktop.o] Error 1 &gt; make[1]: Leaving directory '/home/hp/tvision/makes' &gt; Makefile:27: recipe for target 'static-lib' failed &gt; make: *** [static-lib] Error 2 That just says that it failed to build `obj/tdesktop.o`. The actual error should be above it.
are you sure you are not running a previous built binary on your machine? (happens to me all the time)
I ran `make install` and scrolled up to see the error: `hp@hp-HP-Notebook:~/tvision$ make install` `make -C makes -f librhtv.mkf` `make[1]: Entering directory '/home/hp/tvision/makes'` `g++ -I../include -O2 -pipe -Wno-packed -c ../classes/tdesktop.cc -o obj/tdesktop.o` `../classes/tdesktop.cc: In function ‘unsigned int iSqr(unsigned int)’:` `../classes/tdesktop.cc:147:29: error: call of overloaded ‘abs(unsigned int)’ is ambiguous` `while( abs( res1 - res2 ) &gt; 1 )` `^`
There must be something wrong with your local environment. It crashes on my system. I'm not going to dig into it closely to work out why. You should be trying to find out why it's _not_ crashing on your system. I'm guessing you're compiling with optimizations enabled. Turn those off. 
Hmmm... The 2 in %2d says "take two digits at maximum and interpret it as a decimal number"?
I understandyour 1st point, but how come that printf prints a string and then stops at the '\0' sign? Is it because that is how it is implemented or?
Maybe the online tools run out of memory. You allocate a bunch of memory with malloc but you never call free. It's a good idea to always write the code calling free right after you write the one calling malloc. Also, I would try to figure out a way to solve this problem without calling malloc so many times. E.g. a two dimensional array can be converted into a 1d one fairly easily that you can create with a single allocation. 
Finally! I was able to compile It!!!! The error I mentioned above was about ambiguous `abs()` in the turbo vision code. I simply converted all `abs()` parameters to int by using `static_cast&lt;int&gt;` . Next when I ran `make install` It showed: &gt;make\[1\]: Leaving directory '/home/hp/tvision/makes' &gt; &gt;install -d -m 0755 /usr/lib &gt; &gt;install -m 0644 makes/librhtv.a /usr/lib &gt; &gt;install: cannot create regular file '/usr/lib/librhtv.a': Permission denied &gt; &gt;Makefile:62: recipe for target 'install-static' failed &gt; &gt;make: \*\*\* \[install-static\] Error 1 Next I ran the command `sudo make install` and it failed with the error:- &gt;install -d -m 0755 /usr/bin &gt; &gt;install -m 0755 rhtv-config /usr/bin &gt; &gt;install: cannot stat 'rhtv-config': No such file or directory &gt; &gt;Makefile:85: recipe for target 'install-config' failed &gt; &gt;make: \*\*\* \[install-config\] Error 1 Finally I gave up and just used `make -j5` and this time it again threw an error: &gt;make -C makes -f librhtv.mkf &gt; &gt;gcc -o rhtv-config -Iinclude rhtv-config.c &gt; &gt;make -C intl/dummy &gt; &gt;make -C intl &gt; &gt;make\[1\]: Entering directory '/home/hp/tvision/intl/dummy' &gt; &gt;make\[1\]: 'libtvfintl.a' is up to date. &gt; &gt;make\[1\]: Leaving directory '/home/hp/tvision/intl/dummy' &gt; &gt;cp intl/dummy/libtvfintl.a makes &gt; &gt;make\[1\]: Entering directory '/home/hp/tvision/intl' &gt; &gt;make\[1\]: Nothing to be done for 'all'. &gt; &gt;make\[1\]: Leaving directory '/home/hp/tvision/intl' &gt; &gt;cp: cannot create regular file 'makes/libtvfintl.a': Permission denied &gt; &gt;Makefile:39: recipe for target 'intl-dummy' failed &gt; &gt;make: \*\*\* \[intl-dummy\] Error 1 &gt; &gt;make: \*\*\* Waiting for unfinished jobs.... &gt; &gt;make\[1\]: Entering directory '/home/hp/tvision/makes' &gt; &gt;make\[1\]: 'librhtv.a' is up to date. &gt; &gt;make\[1\]: Leaving directory '/home/hp/tvision/makes' So, I used the command `sudo make -j5` and this time: &gt;make -C makes -f librhtv.mkf &gt; &gt;gcc -o rhtv-config -Iinclude rhtv-config.c &gt; &gt;make -C intl/dummy &gt; &gt;make -C intl &gt; &gt;make\[1\]: Entering directory '/home/hp/tvision/intl' &gt; &gt;make\[1\]: Nothing to be done for 'all'. &gt; &gt;make\[1\]: Leaving directory '/home/hp/tvision/intl' &gt; &gt;make\[1\]: Entering directory '/home/hp/tvision/intl/dummy' &gt; &gt;make\[1\]: 'libtvfintl.a' is up to date. &gt; &gt;make\[1\]: Leaving directory '/home/hp/tvision/intl/dummy' &gt; &gt;cp intl/dummy/libtvfintl.a makes &gt; &gt;make DYNAMIC\_LIB=1 -C makes -f librhtv.mkf &gt; &gt;make\[1\]: Entering directory '/home/hp/tvision/makes' &gt; &gt;make\[1\]: 'librhtv.a' is up to date. &gt; &gt;make\[1\]: Leaving directory '/home/hp/tvision/makes' &gt; &gt;make\[1\]: Entering directory '/home/hp/tvision/makes' &gt; &gt;make\[1\]: 'librhtv.so.2.2.1' is up to date. &gt; &gt;make\[1\]: Leaving directory '/home/hp/tvision/makes' &gt; &gt;cd makes; rm -f [librhtv.so](https://librhtv.so); ln -s librhtv.so.2.2.1 [librhtv.so](https://librhtv.so) &gt; &gt;cd makes; rm -f librhtv.so.2; ln -s librhtv.so.2.2.1 librhtv.so.2 Next I followed all the steps: &gt;hp@hp-HP-Notebook:\~/tvision$ export PATH="$PWD":"$PATH" &gt; &gt;hp@hp-HP-Notebook:\~/tvision$ export TV="$PWD" &gt; &gt;hp@hp-HP-Notebook:\~/cpp-programming/Editor\_source\_code/ospedit-2.1.1-src/ospedit-2.1.1$ find . -type f -exec dos2unix '{}' \\; &gt; &gt;hp@hp-HP-Notebook:\~/cpp-programming/Editor\_source\_code/ospedit-2.1.1-src/ospedit-2.1.1$ sh configure linux &gt; &gt;hp@hp-HP-Notebook:\~/cpp-programming/Editor\_source\_code/ospedit-2.1.1-src/ospedit-2.1.1$ sed -i -e "/\^\\(C\\(PP\\)\\?\\)FLAGS \\+=/ s|$| -I'$TV/include'|" -e "/\^LDFLAGS \\+=/ s|$| -L'$TV/makes'|" Makefile &gt; &gt;hp@hp-HP-Notebook:\~/cpp-programming/Editor\_source\_code/ospedit-2.1.1-src/ospedit-2.1.1$ make -j5 AND FINALLY: &gt;OSPlus Text Editor has been built. Wow, I am really grateful that you took the time to actually compile a library and another application to answer a question on reddit. Thank you very much!!!!
Running your program through valgrind shows a few errors. I'd be willing to bet that the one that's giving you trouble is the use of an uninitialized variable on line 117. It was created on line 20. Here's the full output if that's helpful to you: ==26464== Memcheck, a memory error detector ==26464== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al. ==26464== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info ==26464== Command: ./a.out ==26464== 2 5 12 13 -4 3 2 6 15 ==26464== Use of uninitialised value of size 8 ==26464== at 0x400C7E: main (main.c:117) ==26464== Uninitialised value was created by a stack allocation ==26464== at 0x4007A0: main (main.c:20) ==26464== No 11 No 13 Yes 2 Yes 3 Yes 12 Yes 6 12 3 -67 67 34 2 4 4 No 5 No 67 Yes 7 No ==26464== ==26464== HEAP SUMMARY: ==26464== in use at exit: 336 bytes in 8 blocks ==26464== total heap usage: 10 allocs, 2 frees, 2,384 bytes allocated ==26464== ==26464== 336 (48 direct, 288 indirect) bytes in 2 blocks are definitely lost in loss record 2 of 2 ==26464== at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==26464== by 0x400829: main (main.c:31) ==26464== ==26464== LEAK SUMMARY: ==26464== definitely lost: 48 bytes in 2 blocks ==26464== indirectly lost: 288 bytes in 6 blocks ==26464== possibly lost: 0 bytes in 0 blocks ==26464== still reachable: 0 bytes in 0 blocks ==26464== suppressed: 0 bytes in 0 blocks ==26464== ==26464== For counts of detected and suppressed errors, rerun with: -v ==26464== ERROR SUMMARY: 3 errors from 2 contexts (suppressed: 0 from 0) 
These kinds of errors always boil down to some nasty memory management errors, if you get an error like that always check: 1. Did you pass the boundaries of an array? 2. Did you allocate all the space you need? 3. Did you initialize all the variables before using them? You have some really shady hash table implementation (is it an open-closed hybrid?), it may be good but it is close to unreadable. An error might be on line 100, where the \`tpointer\` is probably Null and you try to access it's data member. Your \`while\` before it does not guarante that \`tpointer\` get's a value. 
You've compiled while being root, so any files and folders that are created will be owned by root and thus you needed to do `sudo` each time. The normal way would be to run simply `make` THEN `sudo make install`. Since it seems the library successfully got compiled, you still probably want to install it, so you don't need to patch the Makefile (the command with `sed`). Also, what is your Ubuntu and GCC version? I'm using Ubuntu 16.04 with 'gcc (Ubuntu 5.4.0-6ubuntu1~16.04.10) 5.4.0 20160609`.
Well, turns out that was exactly the problem. I used the "export PERL5LIB" command to add the directory of miscperl.pl to INC and that problem was solved. https://perlmaven.com/how-to-change-inc-to-find-perl-modules-in-non-standard-locations
Umm i tried running 'make' followed by 'sudo make install', in turbo vision but It again gave the "permission denied" error for the "make" command. Then I gave "sudo make" command followed by "sudo make install". Worked well this time. I am on a dual boot laptop running Ubuntu 18.04 LTS with gcc version 7.3.0 (ubuntu 7.3.0-16ubuntu3)
Why "wrong"? It can totally be a "correct" environment, the standard doesn't demand *wrong* code (specifically UD-triggering code) to execute the same way everywhere...
&gt; Why "wrong"? It can totally be a "correct" environment, the standard doesn't demand wrong code (specifically UD-triggering code) to execute the same way everywhere... You're right, I badly characterised the issue. In my defence, this was before I discovered that it was just due to undefined behaviour.
On why this happens in general: Your code isn't correct just because it runs locally. The standard only guarantees so and so much for the same behavior of programs on the different PCs (even worse: Same PC, but executed a different time) if your code is wrong. Likely you're triggering undefined behavior somewhere which can mean **execute correctly** (your PC), **crashes with segmentation violation** (online submission) or whatever the platform chose it to do...
Ok, I just tested it on a Docker Ubuntu 18.04 image and the same things happens as you described. I fixed the Perl-Error by using `PERLLIB=. ./configure` instead. To fix the things in the code: (basically replaces `abs(something)` with `abs((long)(something))`) sed -i -r 's/abs\(([^)]+)\)/abs((long)(\1))/g' classes/tdesktop.cc classes/tdisplay.cc Then everything went fine and I could compile and start the editor. Here is the full thing: tar -xaf rhtvision_2.2.1-4.tar.gz cd tvision/ PERLLIB=. ./configure # Patch for newer Ubuntu sed -i -r 's/abs\(([^)]+)\)/abs((long)(\1))/g' classes/tdesktop.cc classes/tdisplay.cc make -j5 sudo make install cd .. # Compile OSPedit 7z x ospedit-2.1.1-src.zip cd ospedit-2.1.1/ find . -type f -exec dos2unix '{}' \; sh configure linux make -j5 bin/linux/ospedit 
GPUs are typically optimized to use floats.
I don't know about the error but as a tip, you can replace line 12 (and 14) with: *x=*in/10;
Yep.
http://perldoc.perl.org/perl5260delta.html#Removal-of-the-current-directory-(%22.%22)-from-%40INC
Thank you so much, this is super helpful.
Nice! I had converted unsigned int parameters of `abs()` to signed int, which could have created problems I guess, so I recompiled the library after using `long` and recompiled the editor afterwards. These steps worked **perfectly** well. Thank you so much!
Okay, so the current directory is not added to INC anymore? I didn't realize that since I am a beginner and this is my first time running a configure script. Yes, this is an old editor that seems to have been first written in January 2000. This is the author's home page [https://www.owenrudge.net/osplus/](https://www.owenrudge.net/osplus/) . 
Wait, are you the guy who was trying to use a abandoned 20 year old editor a few days ago? And now this: &gt; Development has been officially stopped since August 2002, and there has been no real development of OSPlus for some time before then. Stop with the software archaeology and just use active, maintained programs. Your life will be much easier.
LOL I know what you are getting at, but I don't just want to use an editor, I want to read its source code and become a better programmer. That's why I have been looking at some old editors because they are simpler with lesser source code. If I use some modern editor, like Notepad++ or Vim, these have almost a million lines of code, too much for a beginner. 
Oh. That's cool. However, what I'm asking about is how do I compile my program into a "release"? As far as I know, everything I am compiling as is works only on my setup and only on my machine. I want users to click a link and get a version that just works without any setup.
Your code needs refactoring. You can extract at least five helper functions from `main`. A function should do one thing. I and J are fine for loop iteraters, but the rest of the single letter variable names need to go. This is especially important for longer functions. None of that will fix your errors, but they'll be easier to find. Also, pointers and ints are or are about the same size, depending on platform. No reason to have pointer to int args that you aren't modifying. Also, avoid "out" arguments, prefer return values. As for finding your errors, first make sure you compile with Wall and fix all warning. Then try valgrind.
It looked like there were a lot of replies for how to compile for different versions. My comment was focused on an example for distribution. To be honest I haven't played around with compiling for Windows or Mac.
I'm not sure I understand your question. How would you stop at the ``'\0'``, if you are not reading it? Reading the pointer only, without dereferencing its content, is not sufficient to react to this content. Put another way: yes, any function that would need to stop on ``'\0'`` needs to dereference the string and make sure that its content matches ``'\0'``, to stop.
&gt; Likely you're triggering undefined behavior somewhere which can mean This is almost certainly the correct answer. Since the behavior of undefined variables depends on the runtime state of the machine, and the compiler used, this would explain why it works on your machine and not some other one. As u/pink_echoes explained in his comment, your code almost certainly contains a bug that manifests on some machines but not others.
Yes you're right. If you're on the stack and accessing via a pointer, then it's just as slow as the heap. However, you can also access stack variables different. Okay wait, let's talk about assembly. I'm an ARM guy, so I only know ARM assembly: ldr str these ^^^ (2 cycle commands) are for accessing addresses (pointers) pop push these (1 cycle commands) are for just taking whatever is last off the stack or putting something new on so you can think of different ways to use both
&gt; If you're on the stack and accessing via a pointer, then it's just as slow as the heap. There's no "if... then" about it. Memory is always accessed with pointers. _That's what the CPU does_.
&gt; The use of pointers makes reading and writing to the heap slower than on the stack but don't we use pointers when we create arrays, even when they're created on the stack? Therefore, the performance for reading and writing to arrays on the stack and heap should be the same? Of course. The only way the CPU has to access memory is through memory addresses, and that's all that pointers are. The fact that a simple statement like: x = 42; may involve use of a memory address under the scenes is what makes C a high-level language: the programmer doesn't need to think about that. &gt; Couldn't variables created on the stack also be accessible by any function if we pass the address of that variable to the new function? A good example of this is the swap function. An object with automatic storage duration has a lifetime that extends until execution of the block with which it is associated ends in any way. A pointer to the object can be indirected by any function during this lifetime to access the object.
To answer question 2, if you can maintain a reference to a memory address on the stack you could pass it along to other functions. Stack memory isn't global in scope as most stacked variables and objects don't persist past the end of a called function to avoid issues with memory leaks and the like. For example, you could allocate memory on the stack in your main() loop and maintain references to those pointers for the duration of the programs run-time. That would be considered a stack variable with a global scope.
&gt;That would be considered a stack variable with a global scope I think the proper nomenclature is "duration" rather than "scope". A local variable of main (likely allocated on the stack), has a duration lasting for basically the whole execution of the program (until main exits). It is still local in scope, though, and has to be explicitly passed along to functions. "global scope" in C implies declaration \*outside\* of any function with the "extern" keyword.
&gt; The use of pointers makes reading and writing to the heap slower than on the stack This isn't true in of itself. The thing that is slow is reading from memory. We think of RAM is fast, and it is in comparison to disk. Whether the address of memory is on the stack or on the heap, reading from a memory address is equally expensive. The stack is normally less expensive to read from because of locality. &gt; Therefore, the performance for reading and writing to arrays on the stack and heap should be the same? Stack memory is typically faster because of locality and how CPU caches work. When you read from a memory address, an entire N bytes of memory is read into a cache: the bytes you are reading, and the surrounding ones (normally aligned to nearest so many bytes). Heap memory is more disperse, and has less locality, and therefore less of it will fit in a CPU cache. You get more cache misses, and therefore you'll actually have to read memory more, which is expensive (compared to registers or cache). The stack, however, just from its nature is all close together. So it will often already be cached. Also, many local variables may never actually be stored in memory, they might just exist in a register during a transient period.
&gt;Heap memory is slightly slower to be read from and written to, because one has to use pointers to access memory on the heap I think this statement is misleading. There is likely *some* overhead associated with indirection, but it probably isn't worth paying attention to. Especially considering that stack access is itself a form of indirection on most architectures. Any noticeable speed advantage for accessing local variables probably has nothing to do with stack vs heap, but is instead due to the variables being located in the cache or registers instead of main memory. In any case, this sort of optimization shouldn't be your focus until you have identified a specific performance bottleneck in your program. It is true that *allocation* on the heap is generally slower than growing the stack, but that only applies when `malloc` or `free` is called. Once something is allocated on the heap, it's not really any different than anything else accessed via pointer. Of course, there are individual differences based on things like the cache, but that's really outside the scope of C semantics. And of course the heap is not the only thing that is accessed with pointers. It's rather that C does not recognize such a thing as a "heap-allocated variable", C variables can only be on the stack, in registers, or in the static storage section (bss), so the only way to access something on the heap is via pointer. But it's equally possible to have pointers to stack or static variables, and this is quite commonly done (it's the only way to achieve pass-by-reference behavior, and is also useful to avoid unnecessary copying, such as when a function needs read-only access to a local variable declared by the caller).
\[Solved\] Thank you all for all suggestions and criticism(constructive), i accept the fact that my code was unreadable af. But in my defence i would say my primary goal was to implement what i imagined, but i'll make sure from next time i code ,i'll code it to as readable as possible. Regarding the problem as everyone said my code was trying to access a memory location which didn't exist for all the cases, and as i wrote the old code on my laptop which has Win10, the bug was not resulting in a segmentation fault. But when i tried to compile the same code on my desktop which has ubuntu i too got segmentation fault then. Now how i traced the bugged line of code is interesting and is something i would like to improve. As segmentation fault is run-time error, i placed some print statements in between lines i felt was faulty and last print statement that got executed bug was after that for sure. I had do it twice to bring down the number of lines i had analyse. I'm pretty sure this not an efficient way to trace this, i would like hear on that. Thanks! [check the difference](https://imgur.com/a/XuUsnuF)
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/Hy8Rj2r.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20e1l4efe) 
Very late to this thread, but I was thinking that encouraging users to put their shit through Valgrind or adding a quick tutorial on strace might also be a good addition to recommend? I know that I am a beginner to C and just recently learned how to use that stuff, and also know a lot of my peers who are at a similar or higher level and may not have even heard of it. This might save a lot of "halp" type questions, if they can track down leaks and shit. 
For point \#1 you should ask, How does the CPU access the stack? With the stack pointer, of course. You can't directly access it from C, but the CPU uses the stack pointer to generate addresses in much the same way as any other pointer. (Yes there are some differences between architectures, and some details are omitted, but a stack access is still a memory access.)
Local variables are usually accessed using ldr and str with indirection through the stack frame pointer.
When they're initialized, yeah
There are a number of different packages available - I recently found µnit (https://nemequ.github.io/munit) which has proven to be adequate for my purposes and without significant framework overhead.
 µnit looks nice. How would you rate it and compare it to previous frameworks you used (if any)?
I test everything I write pretty extensively. I generally use cmake's built in testing framework, and run the binaries with clan sanitizers. Then a separate pass through valgrind (without the sanitizers).
&gt; // d is a pointer to a d[2][B1] sized array Wouldn't it have made sense to declare it as such? void foo(uint32_t (*d)[B1]) { /* ... */ } Note that the fact that this is a 2-element array is always lost in C. Arrays are never passed to functions in C; they are always converted to pointers.
I've enjoyed using [CMocka](https://cmocka.org/), especially the mocking feature of it proved very helpful.
CTest very useful, but it isn't a test framework. It's a test driver, so you'd still need to find a good test framework.
Try out [libcheck](https://github.com/libcheck/check). I've enjoyed it for Linux and bare metal applications.
I've used [snow](https://github.com/mortie/snow) for a couple of my projects. 
I use Criterion : https://github.com/Snaipe/Criterion It's really easy to use, with minimal boilerplate code. Sometimes, I also use Catch : https://github.com/catchorg/Catch2 It's meant to be used in C++ but I really really like the nested test features.
+1 for criterion! I also use it and it's wonderful :)
It looks like this is the tutorial you're following: https://www.gribblelab.org/CBootCamp/ Giving it a quick glance, it's often misleading and is riddled with mistakes. Some of its examples have undefined behavior. Everyone else has already explained why just those two paragraphs are wrong. You should really find a better resource, otherwise you'll have to *unlearn* a lot of that stuff later on. I don't know any good online beginner resources, but K&amp;R is often recommended around here, and it's what I use when teaching beginners.
Test anywhere protocol, prove and https://github.com/jhunt/ctap
 void *myalloc(size_t s) { void *t = malloc(s); if(!t) { int e = errno; perror(e); perror(strerror(e)); exit(-1); } return t; } There. Now use myalloc() without fear.
I just built this editor on Ubuntu, but it can only access files in its own directory. If i want to edit files in another directory, how do I do that?
For the main program it's ok. For a library that's the worst idea.
Don't bother with local goto's, using goto for error handling like this is usually ok. If you think about it, it's a Poor's Man RAII and exception handling.
We use c-tap harness. https://github.com/rra/c-tap-harness
Nit: you can simplify your logic by using the return value of fork(): while (1) { if (fork() != 0) { exit(0); } }
Why? Errors in malloc() are always critically serious ones. If there is no memory left, or a hardware/kernel failure is preventing memory from being allocated, the correct thing to do is die as quickly as reasonably possible. Things are very wrong at this point. There is no logical way to continue.
How about static variables? Aren't their pointers still valid after the function returns?
*strerror* (and likely *perror* as well) use *malloc* internally [under the hood](https://github.com/bminor/glibc/blob/master/string/strerror.c#L38) on e.g. glibc. Just calling exit() is the only sane choice, really. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [bminor/glibc/.../**strerror.c#L38** (master → 2827ab9)](https://github.com/bminor/glibc/blob/2827ab990aefbb0e53374199b875d98f116d6390/string/strerror.c#L38) ---- 
I already seen this, like xmalloc of Torvalds in git's code source. But you do not consider freeing the previously allocated memory blocks when doing exit(-1). You will have memory leaks if there were some memory blocks you allocated before the malloc failure.
The fact that malloc couldn't allocate **the amount you asked** doesn't mean you have run out of memory. If the library user make a mistake and ask for more memory than the machine have, malloc could return NULL and you could still have plenty of free memory. As a rule of thumb, a library should never decide that a failure is critical, who decides that is the main program. A library should return the error condition as fast and as early as it can, and let the main program decide if it's critical or not. As another counter example to the malloc issue, the main program could decide that it can release some internal caches to free up some memory and try calling your library again.
No. Calling exit() will automatically free any malloc()'ed memory from anywhere.
Uh, no. When a program exits the OS cleans up all the memory it allocated. You don't *have* to free anything at exit, it's just good style and assists in stuff like hunting leaks with valgrind.
You are right, the other possibility is that we accidentally asked for an insane amount of memory, which is a bug I need to fix. In that case, I still need the program to crash. We don't even know if our code is the problem when malloc() fails. It could be some other poorly behaved code on the system and as soon as I free() some space it'll get gobbled up and my subsequent malloc() calls will _still_ fail. You seem to make some kind of arbitrary distinction between libraries and "the main program". No such distinction exists in reality. When malloc() fails, the only sane thing is to call exit(). I actually probably try too hard in my original comment with perror() and such, as another commenter pointed out those will fail anyway if malloc() is failing.
I tried a simple C script to check what you told me: int main() { printf("hello\\n"); int \\\*a = malloc(10\\\*sizeof (int)); int \\\*b = malloc(10\\\*sizeof (int)); exit(-1); return 0; } I have 80 bytes which are still reachable and listed in valgrind in Leak Summary, so I guess 80 bytes leaked.
A distinction does exist. A library doesn’t know if there are fallback methods. It doesn’t know if it’s a critical application. It doesn’t know if there are complex tear down code that must be preformed first. It doesn’t know if there is logging requirements. I’d be terrible a terrible library that is only useful for the most basic unimportant programs.
Yes there is a distinction. Suppose you're calling a graphics library function to read some image. If the library can't allocate enough memory to read the image file it should exit? Of course not. You would want to tell the user that image is too big, and perhaps allow the user to choose another file. When you are creating a library *you shouldn't assume anything*.
Yes it's technically a leak, and that's what valgrind is telling you, however it's an irrelevant leak because the OS is going to reclaim the memory when the process dies even if you don't explicitly free it. It's important to report it (and fix it!) because it probably means there is a *real* leak in the program if it doesn't exit.
How are you going to run complex tear down code with no available memory? How are you going to log anything with no available memory? You underestimate the severity of malloc() returning NULL. There is no sane way to continue. You must simply exit(). No practical distinction exists between the code in libraries and the code you write yourself. The compiler treats it all the same in the end.
The logger is already allocated. As well as the other memory needed to tear down. You seem to really not understand any non trivial application. If what you said was true, malloc would never fail, it’d just exit.
So check the file size against sysconf(PAGESIZE) * sysconf(_SC_AVPHYS_PAGES) before attempting to allocate memory for it. Don't rely on a memory allocator to do your bounds checking for you. It's the wrong place to do so.
non trivial applications don't use malloc() directly, they write their own allocator which would allocate memory in large chunks to be handed out as the application needs it, which makes this whole conversation moot. You seem to really not understand what I'm saying, and are trying to use your lack of understanding to belittle me. Knock it off.
Could you explain to me why malloc doesn’t just exit on failure?
We use cmock, unity and ceedling for our unit testing. Have also dabbled using Fake Function Framework instead of CMock. https://github.com/ThrowTheSwitch
You are still missing the point. A library shouldn't decide to arbitrarily kill the whole program **ever**. Also what you suggested is most probably a bad practice anyway for multiple reasons, one of then being that it's still not guaranteed that malloc would be able to allocate the memory for and you still wouldn't want the library to just kill the whole program because of it.
You might look at [obstacks](https://www.gnu.org/software/libc/manual/html_node/Obstacks.html) from glibc.
Why would it? It doesn't do anything else for you either. All it does is allocate memory.
Reachable memory is not leaked. Lost memory is.
You keep assuming that a failed malloc means **no memory at all** and that is **plain wrong**. A failed malloc means it couldn't allocate **the amount requested**, it doesn't mean **in any way**, that you are out of memory, and that a subsequent malloc with a different (smaller, probably) size will fail too.
Ideally libraries don’t allocate memory by themselves anyway. They allow you to allocate the memory using your own malloc. In some cases where this is not a viable option, the library should provide an option to plug in your own malloc function.
Why wouldn’t it if it’s the only sensible thing to do. Then we wouldn’t be discussing a library which uses the stdlib library to simply exit for us when it fails.
I agree that nobody should actually use my original comment, because it's terrible practice. The point I'm trying to make is that is you've run malloc() and gotten NULL back, you've already made a mistake. Once that happens, all bets are off. Code should always endeavor to be robust, and in the real world I'd do a bunch of checks against sysconf() or similar before actually calling malloc() and use that to determine my behaviour. If sysconf() reports that the number of available pages on the system is zero, or pagenum*pagesize is less than the number of bytes I need to allocate, then I should display an out of memory error and skip the call to malloc() entirely. I shouldn't try to call it, get null back, and then try to handle an error that _might_ mean I have actually no memory available.
Sorry but it's you who seems to lack understanding of how C, malloc, and the OS works. And software engineering. Non trivial applications use special allocators *as an optimization*, because they **know beforehand** the usage patterns of the application and can *optimize* the allocation for it. And still they just wrap malloc with a better suited function. No one in their right mind rewrites malloc instead of wrapping the compiler/libc provided malloc.
When I say "write their own allocator" I mean "wrap the libc provided malloc". Optimization is one possible reason to write your own allocator. It is not the only reason.
Valgrind is still checking inside the process space of the process, before OS cleanup. Memory allocations become irrelevant after the process terminates because the OS has a mapping of all memory use by all processes. There are occasional exceptions (shared memory, lock files, and similar) - but if you're using those, you *know* you're using those, it's not something 95% of programmers have to deal with.
You don't want to perror/strerror - it's safer to have a static buffer in the handler, use in-place string functions to write to it, and then manually write() and fflush() it before exiting or aborting (I usually abort in this circumstance, since it better indicates "things be absolutely screwed" rather than just "I tried to run and there was a problem")
People replace the libc malloc with a different one all the time. Ppl
WiseassWolfOfYoitsu, Do you mean that with semaphores, mutex locks, shared memory, sockets and multithreading I cannot rely on exit() (and therefore not rely on myalloc) to automatically deallocate memory blocks? (sorry I am not familiar yet with these exceptions, it is advanced C programming and I wish to study that later, because I feel that these C tools provide advanced possibilities) .
Yes, if something is locked when the locking process exits, there is *no* safe way to unlock it without completely deleting and recreating the lock. Note that how you use them makes a difference here. A simple mutex between threads in one process and it doesn't matter - all users of the mutex go away with the process. It's when you start getting into genuinely multi-process applications (not just threads) doing syscall-level or shared memory locks that it gets hairy, where one side can die with the lock acquired while the other side is still running. That said, you probably don't wan to be doing memory allocation inside a lock. since it's an expensive process and you'll hold up all the other lock users - you'd ideally do all of your preparation before locking, then spend as few lines (and preferably no extra syscalls) inside the lock before unlocking it. That minimizes overhead of the lock as well as risk in using it.
Of course, you can replace malloc with custom allocators for specific purposes, my point is you don't write an application-specific malloc from scratch. Even so, probably those allocators are still implemented in terms of the libc malloc.
 &gt;Even so, probably those allocators are still implemented in terms of the libc malloc. They aren't. They're implemented in terms of the same syscalls to request memory from the OS that the libc malloc (which is, in FreeBSD's case, jemalloc) is using, though - sbrk(), mmap(), etc. - but they completely replace the system malloc when used with a program. 
&gt;They aren't. I stand corrected. &gt;And you certainly can write your own application specific malloc that doesn't use the system one (or a third party one) if you really want to. It doesn't mean you should, except for learning purposes.
I write assert()’s into -t self-test flags, and run them with cmake’s ctest application.
https://www.amazon.com/s/ref=sr_st_review-rank?keywords=C%2B%2B+for+beginners&amp;rh=i%3Aaps%2Ck%3AC%2B%2B+for+beginners&amp;qid=1530469270&amp;sort=review-rank https://www.youtube.com/watch?v=R2_Mn-qRKjA
r/learnprogramming r/cpp r/cplusplus
procced to r/cpp C != C++
Probably not here. This sub is for C, which is different. If they want you to learn C++ then just Google and YouTube some tutorials.
Good luck. https://sites.google.com/site/cs101atjust/useful-links Zip through that and then do another book... Maybe while working on next C++ project itself. Oh, no programming experience at all? umm... I would still try to get through tutorial... And get help if stuck anhwhere! That includes installation.
Post was removed. Same posting as about 
Hmmm. Says I cannot access the file/link?
http://www.learncpp.com/ looks pretty complete as a tutorial. https://visualstudio.microsoft.com/downloads/ if you're using Windows I would suggest Visual Studio Community 2017.
Jeez.. very thorough. Thank you
Seems like alot of those wont let me post as a question..
I think you're way over-complicating things. I usually go with with your option 2, but split off two other functions, `initBoard` and `freeBoard`. You'll usually want a `freeBoard` anyway, and you can always make `initBoard` static if you don't need it elsewhere. This is much cleaner IMHO: static void initBoard(board *this) { this-&gt;name = NULL; this-&gt;tab = NULL; } void freeBoard(board *this) { if (this) { free(this-&gt;name); free(this-&gt;tab); } free(this); } board *allocBoard(void) { board *this; if (!(this = malloc(sizeof *this))) goto end; initBoard(this); if (!(this-&gt;tab = malloc(TABSIZE * sizeof *this-&gt;tab))) goto end; if (!(this-&gt;name = malloc(NAMESIZE))) goto end; return this; error: freeBoard(this) return NULL; } By the way, it seems yor code has the `board-&gt;name` and `board-&gt;tab` assignments switched (I fixed it in my example).
r/cpp_questions also https://www.reddit.com/r/learnprogramming/wiki/faq#wiki_getting_started
Posted on r/cpp_questions. Thank you. 
Yeah, I'm not even sure what the differences are. Like literally zero programming knowledge 
Comparing C to C++ is equal comparing Java and Python!
Weirdly enough. I do kinda understand that one. Makes sense. I figured if I tried to learn C, then C++ second would be beneficial. 
Other posts here are good for giving your feet wet with the basics. The best way to learn is to do your own projects. Once you get to that point, I recommend you start looking at Herb Sutter's [Guru of the week](https://herbsutter.com/gotw/) blog. This will help you navigate around some of the tricky CPP quirks and design considerations that you might run into as an intermediate student of CPP.
Do you know why? Is that what they use there, or just the engineer's favorite language? C and C++ are both general purpose programming languages. But you are training for a specific purpose. Knowing that purpose can help you achieve it sooner. If you're using QT, for example, you might start with their tutorials. And you need to learn a lot about gui programming that's not even specific to C++. If you're doing web development, that's a different thing to learn. If you're doing embedded, that's yet another different thing.
Yeah, the posters so far have been very helpful. I wish there was an app I can use on a daily basis to pick up. I work alot, so by the time I'm off, I dont have the energy to pick up a book. I'm going to check that blog right now. Thank you
Just ignore C++. Learn Java or Python after C! Rust will kill C++ soon! 
The engineers make the programming for the prototypes using that language to my knowledge. And I'm trying to move up in the company, so I want to be proactive before my review comes up 
It's what they use to program. I just have zero experience. I'm trying to feel the waters. So I'm not sure what will be easier to slide into 
If you have zero programming experience...learn python it wont take you more than a few months to get a good understanding. And you can always learn C and C++ late... Anyway, you can learn C first but it will require of you way more effort. C++ will require your hair, you will be bald by the time ya good at it! hahahahaha
Thank you for the tip. I downloaded SoloLearn. It seems to have all the programming languages. So it will be a good resource 
Nope its not a good source! Whatever the programming language you will learn do a research what are the most advised courses and books! I never heard about SoloLearn. Dont kid if your life, go safe, just follow get a proper course or books! 