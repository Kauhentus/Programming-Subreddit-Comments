?? sory for that .. but i am one how posted it in the first place..
The point is that your title is not how most people would write them. Take a look at other posts in this sub for a better idea on what titles should look like.
Yes ..true . i ll keep in mind ... It should be short ..
yo ... i did it .. thanx a lot 
Hey ... I am beginner too .. And people on reddit are really very helpful .. .. I am new to reddit too.... U can post ur programming problem or questions and u will get sure reply ... 
In ncurses, you first move everything you want and then refresh the screen, either the individual screens or all screens at the same time. See manpages for wrefresh/() and doupdate().
How beginner are we talking, what are you currnetly learning/doing
Sorry ...I am a student .. And Currently in love affair with C .. 
Aah i did it .. I move everthinv first and then used wrefresh and usleep ... Thanx ..
Did you read the error with the compilation? test.c: In function 'binary_search': test.c:60:18: error: expected expression before ';' token stop = --; //To break the loop if the number isn't in the range of the loop. ^ That is where the problem is. Did you mean stop--; or stop -= 1;
Right... okay
You have a completely nonsensical syntax in your code: `stop = --;`, which will not even compile. It is a simple error, probably a mere typo. Yet you are claiming that you tried "fixing" and "recreating" the code... How is that possible, considering that any compiler would instantly point out the error? A person who gets stuck at an obvious syntax error could not have possibly written the rest of this code. Did you just copy it from someone and then lied that this is "your" code?
There isn't much bloat—it's just not really possible to implement the functionality of `yes` in less code than that.
Ok so first of all, it is my code and The problem that I have expirienced is a run error, and before I sent the code here I made a change in the loop in order to break the loop better, after that I immediately sent the code here, sorry for having this compilation error and the problem that I'm trying to fix is that the binary search doesn't work as intended. So sorry for sending here a fuckedup code and please help me to fix the problem Sorry for my retarded English and formatting I'm from my phone.. 
To be honest, I have really hard time trying to connect your code to the concept of "binary search". I mean, *binary search* is based on the fundamental idea of repetitive splitting of the search range in half, which is usually easily recognizable in implementations. No matter how different these implementations are, this fundamental idea always stands out. But I don't see anything like that in your code. You calculate `mid` at the start, which does split the array, but that's it. Your code looks like a botched attempt to split the array in half and then do a *linear search* in each half. Which is not *binary search* at all. This is just a slightly obfuscated version of *linear search*. The reason I'm telling you this is that if you really want *binary search* then there's no way to "fix" your code. The algorithm is not there. There's nothing to fix there. I can "fix" it to make it find your number, but it won't be binary search at all. The whole thing has to be re-implemented to actually make it perform binary search. After that we can proceed to "fixing" it. This is what a regular binary search implementation might look like void binary_search(const int array[], int ind) { int min = 0; int max = ind; int mid = 0; /* At each iteration we'll work with range [min, max) */ while (min &lt; max) { mid = (min + max) / 2; if (g_num &lt; array[mid]) /* Continue search in [min, mid) */ max = mid; else if (g_num &gt; array[mid]) /* Continue search in [mid + 1, max) */ min = mid + 1; else /* Found it! */ break; } if (array[mid] == g_num) printf("\n\nYour favourite number is in the %d slot in your array.\n\n", mid); else printf("\n\nSorry mate, it appears that your favourite number does not exist in your array."); } There are things that can be improved there, but they are very minor.
For this let's use a set of statements: a; b(); c; If you break on a, 'step into' would advance to the next line as it is a straightforward statement and is not calling a function. Now the point is before b(). Using 'step into' steps into the execution of b() wherever it is defined and you walk through that function in the same way. If you break on a but now use 'next', you would first evaluate a and be before b(). If you use 'next' again you will evaluate ALL OF b to it's completion then advance the point to just before c and so on. Run to cursor in theory let's you click on a point in your code and automatically set a breakpoint. When the code runs and reaches that breakpoint you will be debugging from that state. For 'step out' I usually would consider this to be equivalent to gdb's 'finish' which means 'finish the rest of this function and break as soon as you return to the function that called it.' This may mean something different in the context of Code::Blocks. The two instruction level steps are probably there when you have moved into assembly land which would come up when debugging a binary without symbols or stepping into a library where you don't have symbols either.
yew lyk creme uv sum yung gai?
What he's trying to say is stop putting multiple periods and commas between everything 
I hate hate it when people do that. 
Me,,.,.,.,.,.,.,.,.,..,..,.,.,.,.,..,.,.,.,.,.,,..,..,..,.,.,.,.,.,..,..,.,.,.,.,..,.,.,.,.,.,,..,...,.,.,.,.,.,..,..,.,.,.,.,..,.,.,.,.,.,,..,...,.,.,.,.,.,..,..,.,.,.,.,..,.,.,.,.,.,,..,...,.,.,.,.,.,..,..,.,.,.,.,..,..,.,.,.,.,..,.,.,.,.,.,,..,..,..,.,.,.,.,.,..,..,.,.,.,.,..,.,.,.,.,.,,..,...,.,.,.,.,.,..,..,.,.,.,.,..,.,.,.,.,.,,..,...,.,.,.,.,..,.,..,.,.,..,..,.,.,.,.,..,.,.,.,.,.,,..,..,..,.,.,.,.,.,..,..,.,.,.,.,..,.,.,.,.,.,,..,...,.,.,.,.,.,..,..,.,.,.,.,..,.,.,.,.,.,,..,...,.,.,.,.,.,..,..,.,.,..,..,.,.,.,.,..,.,.,.,.,.,,..,..,..,.,.,.,.,.,..,..,.,.,.,.,..,.,.,.,.,.,,..,...,.,.,.,.,.,..,..,.,.,.,.,..,.,.,.,.,.,,..,...,.,.,.,.,.,..,..,.,.,.,.,..,.,.,.,.,.,,..,...,.,.,.,.,.,..,..,.,.,.,.,..,.,.,,.,.,.,..,.,.,.,.,.,,..,...,.,.,.,.,.,..,..,.,.,.,.,..,.,.,.,.,.,.,.,..,.,.,.,.,.,,..,..,..,.,.,.,.,.,..,..,.,.,.,.,..,.,.,.,.,.,,..,...,.,.,.,.,.,..,..,.,.,.,.,..,.,.,.,.,.,,..,...,.,.,.,.,.,..,..,.,.,.,.,..,.,.,.,.,.,,..,...,.,.,.,.,.,..,..,.,.,.,.,..,.,.,..,..,.,.,.,.,..,.,.,.,.,.,,..,...,.,.,.,.,.,..,..,.,.,.,.,..,.,.,,.,..,.,.,.,.,.,,..,.. Too. 
Aah I understand I will not do it again I am really sorry 
sorry i understand now its illigal to use commas and dot in reddit 
Lol don't worry, it's not a big deal, it will just help people understand your sentences better 
It's not. Just use punctuation in a manner similar to this. Run-on sentences can be worse than having too many periods, commas, or spacing them inappropriately like this: "So don't let these guys ruin your entire reddit experience . Even if they are trying to help ,, it can be a bit intimidating sometimes .."
&gt;Perhaps I'll just change the description to "an alternative set of coreutils." That may be a more apt description. I think that your complaint about bloat in the GNU coreutils isn't without merit, but you have to keep in mind that a lot of the 'bloat' is devoted to keeping consistent standards across all of the tools. I can't think of very many other libraries that have gone to such lengths to standardize the input and output to a vast range of tools. I don't think that coreutils are perfect, and I think that there is something great to be said for simplicity of design and structure (this is why I really like OpenBSD's stuff vs. Linux), but you really need to make a very convincing argument if you want adoption as to why your stuff is better (and would be completely transparent to replace).
you didnt upset me :)
THank you and i apologize again for my gory writting. i never meant to upset people.
It's alright. People are just *edgy* here
Glad to know that :)
Is English not your primary language? If not, don't worry about it. You don't need to apologize for anybody if you just aren't familiar with proper English grammar. There is absolutely nothing wrong with that, even though other people may be downvoting you.
Sorry, thanks for the reddit's!
happy cakeday !
You seem to be having a lot of ncurses questions. Have you read any tutorials, such as [this one](http://www.tldp.org/HOWTO/NCURSES-Programming-HOWTO/)? Also, remember to add any code you have so far so we can help you. In general, you select a color pair and use that color pair for drawing everything until a new color pair is chosen or colors are disabled. Use attron() to start using a color and attroff() to stop using it. 
Yes, sorry i forgot to put the code. i am going through this same tutorial. Have a close look into this code : https://pastee.org/r6aee firstly, it does not fill the box. secondly, it overflow the box drawn by the box( ) function.
aaah i am so stupid. If i remove the box( ) function then the over flow problem solve. sorry, for troubling for such a silly paper work. and color problem solve with this line : wbkgd(win,COLOR_PAIR(1));
I managed to pick up a couple of books for dirt cheap yesterday in a second hand book shop. I got Programming in C 3E, C Primer Plus and Beginning C for £1 each. And C in a Nutshell for £1.50. All in excellent condition. I know they are not the very latest editions but I checked the reviews and it appears not a whole lot changed from the most recent editions so I don't see it will be a huge issue. 
That is actually why I want to start with C. I want to start at the bottom (well close to the bottom, I could start with assembly...). And work my way up from a nice solid foundation from C to OOP and interpreted languages. I am hoping that learning in that direction will allow me to better understand and appreciate why we have the higher level languages and better understand how they are implemented at a lower level. 
Either, hide the form, get the values and then close the form OR call something from form1 to set the values and then close form2.
jaccoppi. Pls look at this code. I want the color white. But it gives me Grey. If You border the win with box( ) function and the bold it with attron(A_BOLD) it gives the correct color to the border. I want that color to be the BackGround color of the window. https://pastee.org/2ru6j
Color white will be gray on most terminals by default, you need to use the bright parameter as well.
Bright parameter ?how to use that ? And can u tell me how to use init_color( ) function
I want to use the rgb color but I am unable to use it 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**ANSI escape code**](https://en.wikipedia.org/wiki/ANSI%20escape%20code): [](#sfw) --- &gt;In [computing](https://en.wikipedia.org/wiki/Computing), __ANSI escape code__ (or __escape sequences__) is the method of [in-band signaling](https://en.wikipedia.org/wiki/In-band_signaling) to control [formatting, color, and other output options](https://en.wikipedia.org/wiki/Formatted_text) on video [text terminals](https://en.wikipedia.org/wiki/Text_terminal). To encode this formatting information, it embeds certain sequences of [bytes](https://en.wikipedia.org/wiki/Byte) into the text, which have to be interpreted specially, not as [codes of characters](https://en.wikipedia.org/wiki/Character_encoding). Although [hardware](https://en.wikipedia.org/wiki/Computer_hardware) text terminals have become increasingly rare in the 21st century, the relevance of this [standard](https://en.wikipedia.org/wiki/Technical_standard) persists because most [terminal emulators](https://en.wikipedia.org/wiki/Terminal_emulator) interpret at least some of the ANSI escape sequences in the [output text](https://en.wikipedia.org/wiki/Text-based_user_interface). One notable exception is the [win32 console](https://en.wikipedia.org/wiki/Win32_console) component of [Microsoft Windows](https://en.wikipedia.org/wiki/Microsoft_Windows). &gt; --- ^Interesting: [^Echo ^\(command)](https://en.wikipedia.org/wiki/Echo_\(command\)) ^| [^VT220](https://en.wikipedia.org/wiki/VT220) ^| [^ANSI ^art](https://en.wikipedia.org/wiki/ANSI_art) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cn28dj3) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cn28dj3)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Aah right. But color white is listed in it. I might be wrong but terminal support white color
Is "code blocks" a product? If so, why would it not be set off in the traditional way with capital letters to make that clear?
Does whatever debugger you're using have no documentation?
Yes it is, but the IDE I am using is irrelevant. I am simply wanting to know what these commands could specifically mean. Not sure why you are focusing on grammar. 
I don't know a lot about debuggers coming from Python. However, I am willing to learn. It seems your implying that I should first find out what debugger Code::blocks is using and then look at the documentation. 
Thanks! That definitely helps a bit! I am going to go to the Code::blocks forum for any further information. Not sure why I didn't think of that in the first place! Oh well, sometimes when your stuck in a problem, it is difficult to see other approaches. 
Awesome find! You should be well on your way with those books.
That's a different question and you should start a new topic for it. In any case, without compiling your code I'd say the problem is you're passing wbkgd() a color pair, not a single color. When in doubt, consult the manuals for the functions you're using. If you're on linux, just type "man wbkgd". If not, use an internet search engine or linux.die.net for example.
I said that because i wanted to know what those general terms meant with regard to stepping through code. I have seen the exact same terms in VBA and in a Python code debugging like program. And sorry I wasted your time and energy but then again your are on Reddit...so how are you not wasting time already? :) Jk
It does. But I couldn't find this in there. 
Yes. I am googling it. I am on Linux. I am aware of this fact. So I tried to use rgb color of my own with init_color. And still I cannot able to change the color.
Thanks God their rejected it. I would hate seeing C code around polluted with OOP concepts, especially inheritance and class hierarchy. If you want classes, methods, inheritance etc. go program in C++ or Java. Leave little beautiful language that C99 is alone. I really appreciate the work the committee done so far. Improvements in C99 over previous major versions are very useful (designated initializers, compound literals, float macros) but they follow spirit of the language. Above mentioned proposals don't. Let's keep it this way. 
man 3 isalpha #include &lt;ctype.h&gt; int isalnum(int c); int isalpha(int c); int iscntrl(int c); int isdigit(int c); ...
Firstly, you can use character classification functions from `&lt;ctype.h&gt;`. like `isalpha` and so on. Secondly, if for some reason the classification does not suit your purpose, you might take a look at the character table on your platform and discover that you can cover large contiguous groups of characters with a single range, like if ((c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= 'a' &amp;&amp; c &lt;= 'z')) to cover all latin letter characters. That will help you to avoid writing a dedicated comparison for each specific character. Thirdly, you can also implement a fully custom classification through string literals and `strchr` function const char *const DIGITS = "0123456789"; const char *const PUNCTUATION = "!\"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~"; if (strchr(DIGITS, c) != NULL) /* It's a digit */; else if (strchr(PUNCTUATION, c) != NULL) /* It's a punctuation character */; Fourthly (and finally), if you are working with 8-bit characters, you can simply declare a table (an array) of size 256 which will map each character to its type (e.g. "letter", "punctuation", "whitespace" etc.)
It sounds like you want to develop a code base on Windows, and also build that on code base on Linux. The usual way to achieve that is setup a build environment for Linux. Debian is a fine choice. Then kick off a build on each platform whenever you check something into your version control system. There CI type systems that has most of this canned. I have used Jenkins/Hudson, but there are other choices like buildbot. You may also want to check out lvm in addition to gcc. Also, you may want to look into Cygwin which gives you a Linux like environment on Windows. If you really mean cross-compile, using a given compiler, and generate binaries for different platforms, I am afraid, that I will not be of any help. Btw, Lua is sometimes used in a performance critical systems.
Thanks for the answer I appreciate it. I am looking at [Bakefile](http://bakefile.org) to help sort out the issues. I agree with you about having a "build box" that grabs the code from the main fork of the project and compiles it.
Wouldn't it make more sense to run a linux dist robin virtualbox and develop there? Cygwin is also my preference when it comes to shell use on windows. I've never mastered C on windows though. It always seemed like C++ had better windows support. 
Hey man. Try to simplify it. It's way too complicated. Generate the number randomly using a random library and use whatever function will keep it within your bounds. Then run the number through the tests for repeated digits. I'd make an array with length of four and then if array[0] != array[1] &amp;&amp; array[0] != array[2] {} And so on and so forth. Clunky but readable. I glazed over trying to read your code. 
Since your used to Visual studio and getting upto speed in a new IDE sucks, id checkout VisualGDB lets you do GCC/Makefile based project from the comfort of VS. All comes down to what your comfortable with. If you dont need the full IDE sublime text + GCC on your OS of choice works as well.
Turn on all warnings in your compiler, and pay attention to what they say. $ clang -std=c99 -Wall -Wextra -pedantic -O3 -o program program.c program.c:15:22: warning: implicitly declaring library function 'malloc' with type 'void *(unsigned long)' w-&gt;word = (char*)malloc(strlen(word)+1); ^ program.c:15:22: note: please include the header &lt;stdlib.h&gt; or explicitly provide a declaration for 'malloc' program.c:16:12: warning: passing 'const char *' to parameter of type 'char *' discards qualifiers [-Wincompatible-pointer-types-discards-qualifiers] strcpy(word, w-&gt;word); ^~~~ /usr/include/secure/_string.h:83:27: note: expanded from macro 'strcpy' __builtin___strcpy_chk (dest, src, __darwin_obsz (dest)) ^ program.c:15:5: warning: variable 'w' is uninitialized when used here [-Wuninitialized] w-&gt;word = (char*)malloc(strlen(word)+1); ^ program.c:13:14: note: initialize the variable 'w' to silence this warning word_t *w; ^ = NULL program.c:32:13: warning: implicit declaration of function 'free' is invalid in C99 [-Wimplicit-function-declaration] free(d2); ^ 4 warnings generated.
Sorry. I don't understand your question. What signal library do you mean? What is meant with “when to use ?”
Sorry. I mean signal.h library in c. What is the use of it
In AddWord(), you create a pointer named 'w' but you never allocate memory for it. You need something like: word_t *w = (word_t *)malloc(sizeof(word_t)); This allocates memory for the struct itself which holds the two pointers 'word' and 'next'. Only then can you move on to allocating memory for 'word'. Also, your arguments to strcpy are backwards. It's supposed to be strcpy(destination, source).
Actually I was thinking if I can use it in a ncurses program which can return something if the terminal is resized. Is it possible using signal.h methods and functions ??
You don't really need a windows build box. All you need is the MinGW cross-compiler for Windows. [See instructions here](http://www.blogcompiler.com/2010/07/11/compile-for-windows-on-linux/).
Yes, that is possible. On most systems, you get a `SIGWINCH` when the size of the terminal changes. You can query the size of the terminal using the `TIOCGWINSZ` IO control, or you can use curses for that, which is more portable. Here is a little example on how to print the new window size after it changes on Linux and many other Unices: https://gist.github.com/fuzxxl/722d03a71ca0ffcc0b48 
I think you're right, now that I read it again. [Fortunately, you can compile for Linux under Windows, too, using cygwin](http://metamod-p.sourceforge.net/cross-compiling.on.windows.for.linux.html).
Coming from MSVC on limited systems, I'm partial to codeblocks. Eclipse seems to be a favourite but being java based my machines couldn't handle the super bloat, and I still have a burnt taste in my mouth from how terrible java was in 199x on my 486 To make my stuff cross platform, I keep my function(s/ality) in separate source files, and restrict the GUI to its own (win.c or x.c) and/or maintain a types header for the nuances of types between gcc and VC or bcc, though as others have mentioned gcc will compile for windows just fine meaning you don't need to account for those differences
I agree with keeping separate source files for login and interface. Luckily enough once the classes are built the only thing it will need is a couple of console windows for the main interface will be sockets. The interface is being developed in Unity3D So I don't have to do the heavy lifting there. Good advice thanks. 
I like this MiniGW cross compiler. I am checking this out seriously. Do you use this yourself?
I agree with you for anything with a windows interface I used C+. I use c on windows when I wanted speed and little interface.
Ok this rocks! this is exactly what I need. I am going to give it a go with the demo version and see what I can see. $200 is not a lot of money if it saves as much time as I think it will. 
I'd take a look at Jetbrains CLion and MinGW. CLion is still in beta (free at the mo) but is really quite good, and is cross platform.
Kinda sorta. You can use MinGW under Windows (instead of Visual Studio, for example), and I've done that. I've also used other cross compilers before, but usually for an embedded system. But I've never needed to compile for Windows under Linux. MinGW is just a port of the GCC compiler, but with Windows as the target instead of the host system, along with all the libraries you might need to compile for Windows.
If you're starting a new project then consider using C++; you will spend less time on memory management code, and reinventing the wheel; and there's no down-side really. Your entire program could be reduced to: #include &lt;set&gt; #include &lt;fstream&gt; #include &lt;string&gt; int main() { std::set&lt;std::string&gt; dict = { "Hello", "There", "Orion" }; dict.insert("Friend"); dict.erase("Orion"); std::ofstream fp("words.txt"); // could use fopen,fprintf,fclose instead if you want for ( auto &amp;word : dict ) fp &lt;&lt; word &lt;&lt; "\n"; } 
An option not mentioned yet is [g++/Qt](http://qt-project.org/). I guess not an option if you don't want to use C++, but it attempts to provide cross-platform everything. (GUI, network, etc.) 
MinGW is dead; however there is a fork MinGW-w64 that is up to date. Bear in mind that this does NOT include a POSIX library - your code will have to stick to Standard C functions or platform-specific API. It is just a port of GCC to Windows, with minimal associated library to implement Standard C. The Cygwin project attempts to provide a POSIX library for Windows; the downside of this is that your binary will have to have cygwin1.dll available at runtime (as that contains the runtime library). 
VS has the problem of not following standards. It *still* doesn't support major things that were added to Standard C 15 years ago. It's making a belated effort now to support Standard C++ (but still no movement on Standard C) however it's still considerably behind g++ and clang++. 
You should also consider just running it on real hardware. You can always use Putty to ssh into it. (Or VNC, or CygwinX, if you need graphics.) Really, you should think about how it will run in production and duplicate that as well as is practical. If it's going to run in a VM in production, or on someone's cloud, then testing on real hardware might be counter productive.
The SONAME of libFLAC is likely "libFLAC.so.8". This is set when creating libFLAC and tells users where to look at runtime. If you change the soname on libFLAC to remove the .8, things should work. If sounds like you'd rather statically link libFLAC into your wrapper though. Do you get a libFLAC.a file when you build? You can just point to that in your wrappers's linker command. Or you may just be able to delete the .so files so it has to use the .a.
Yes, but it works well for C89/90 development. And it is not accurate to say that there's no movement on C side. VS2013 made major steps towards C99 support: it supports compound literals, tagged aggregate initializers, interleaved statements and declarations to name a few. 
2a) It depends on the context. If we're talking colors, I'd say 0xFFFFFF is white. All the bits are "on." But no, it doesn't mean anything to me in particular. 3) Not functions. Pointers to functions.
Scons can build in windows (using MSVC) and Linux. It is similar to your suggestion of [bakefile](http://bakefile.org/) without the makefile crap.
1) I have not read K&amp;R so I cannot say. But it is as I understand, still the definitive guide to C. 2) I don't use octal myself. So I can't explain that one. But hexidecimal translates more easily to base 2 then base 10 does, allowing simple bitmasking. Say you have 8 bits, and you want the most significant 4 bits of it, so in binary that would look like 11110000. Well in decimal, that's 240, but in hexidecimal it's F0. Which allows you to map every 4 bits (or half byte) into a single character. 8 bits (a full byte) in one character is too difficult to read. 2a) Well of course, after you do it for awhile, it's not much harder than decimal is. Of course you often convert it to decimal unless you are doing pure hex based math (like in a stream cipher). 3) Most certainly, well sort of. You need to use function pointers to do it. The easiest way is with a typedef, as this way makes it easy to assign it to variables like any other value. typedef void (*exec_f)(void) void passed_function_example(exec_f function) { ... } But you can do it in the normal way as well. void passed_function_example(void (*function)(void)) { ... } And to use either of these just have a function that fit's the pointer setup (not required, but highly recommended). void some_function( void ) { ... } and call it like so passed_function_example(some_function);
1) Don't think you'd be picking up any bad habits by learning from K&amp;R, just potentially some outdated ways of doing certain things. Shouldn't be too difficult to pick up once you have the hang of it though. 2) Writing numbers in hex is nice because the number of digits you need to represent a number is smaller. There are also easy conversions to go from/to Base 10 and hex, and octal and Base 10.There's nothing stopping you from using the base 10, but in certain cases it's easier to use the hex equivalent. 2a) As mentioned before after a while you'd be able to pick up certain meanings for hexadecimal numbers, so sometimes the conversion wouldn't be necessary. 
&gt; 3) Not functions. Pointers to functions. Which is sort of the same thing in C.
Octal and hexadecimal numbers are often useful in that they clearly show the bit-pattern of the numbers you operate on. For instance, given the following function which swaps the two bytes of a two-byte quantity (i.e. `unsigned short int`): unsigned short bswap(unsigned short a) { return (a &amp; 0xff00) &gt;&gt; 8 | (a &amp; 0x00ff) &lt;&lt; 8; } The hexadecimal numbers clearly show the bit-pattern we want to highlight. Now consider the same function written with decimal numbers: unsigned short bswap(unsigned short a) { return (a &amp; 65280) &gt;&gt; 8 | (a &amp; 255) &lt;&lt; 8; } The bit-pattern is now much less clear that before. The same thing applies when you try to build bit-masks: enum { O_RDONLY = 0; O_WRONLY = 01; O_RDWR = 02; O_APPEND = 04; O_CREAT = 010; O_CLOEXEC = 020; O_EXCL = 040; } The usage of octal numbers (or hexadecimal numbers) highlights the fact that in each value only one bit is turned on. Compare `01 02 04 010 020 040 0100 0200` with the same sequence in decimal: `1 2 4 8 16 32 64 128`. It is much less obvious that you are dealing with bits. The final example is UNIX permissions. These are usually provided in octal notation as a three or four digit number. The last three digits are the bitwise-or of `4` for reading, `2` for writing, and `1` for execution. The first digit (if there are four) has a special function which I won't explain here. For example, a permission of `0640` means that the owner is allowed to read and write, the group may only read and anybody else is not permitted to do anything. It is very easy to permissions when written in octal, but it's just not possible when they are provided in decimal or hexadecimal.
A little more info about 2) Octals. We live in an age of fancy bit-mapped computer screens that can display pretty much anything we throw at them... But cast your mind back, back into the dark ages of early computer history when [Nixie Tubes](http://en.wikipedia.org/wiki/Nixie_tube) was the common display device. * Binary, with its 0's and 1's, too much space. * Hex, with its extra digits, couldn't be displayed at the time * Decimal didn't translate into or out of binary easily. For a short, but crucial time in computer history, Octal was the stop-gap solution for dealing with binary numbers. Today, the only place that I'm aware of Octal still being used is in the Unix file permissions. 
&gt; 3) Can functions be passed as arguments in C? Function pointers can be passed, but, unlike Javascript, ANSI C doesn't have closures / lambdas / anonymous functions. So you can't pass a block of code to a function, you'd have to write a separate function and pass a pointer to it and any parameters separately. I think GCC and clang both have extensions that allow lamdaish stuff. 
1) Later prints of the second edition of K&amp;R are ANSI C (C89/90). You are not going to pick any outdated habits from the formal core language point of view (C89/90 is a largely subset of modern C), but you might pick some bad stylistic habits, mostly stemming from much older versions of the language, such as: casting the result of `malloc`, using `atoi` function, using `strncpy` function for "safe" string copying, pointing to string literals with `char *` pointers and so on. You can use the book as a "reference" but don't try to use it as a "tutorial": its examples are often riddled with bad coding habits. 2) Hex and octal format are immediately and easily convertible to binary format and vice versa. That's the primary "why" that explains the widespread use of hex format. A hex digit corresponds to exactly 4 binary digits. An octal digit corresponds to exactly 3 binary digits. Hex is much more popular since 4 divides the bit-width of the machine word. Oct was also fairly popular a couple of decades ago, but is not widely used anymore. With practice, understanding the relationship between hex/oct digits and the corresponding bit combinations becomes second nature. 2a) "Mean anything"? I'm not not sure what you are referring to. Does decimal `1526784` mean anything to you? Does it mean more than its hex equvalent `174C00`? These are just numbers. They don't mean anything without context. You might feel better using decimals to represent quantities, but when it comes to bitmasks, hex will immediately prove superior. I know that 0x5555 stands for alternating 0 and 1 bits and that 0x3333 stands for alternating 0 and 1 bit pairs. In decimal format it is not even remotely as obvious, to put it mildly. 3) *Pointers* to functions can be passed around as arguments. Treatment of functions in C is actually very similar to treatment of arrays. Both quickly decay to pointer types in most contexts (i.e. in *all* contexts except `sizeof` and unary `&amp;`) . And most operations applicable to these entities actually work through pointers.
Portable compilation toolchain ? Cmake.
&gt; I think GCC and clang both have extensions that allow lamdaish stuff. Which doesn't mean that you should use them. They don't work on all platforms, make your code unportable and might break in the future.
2/2a) Hexadecimal numbers are much more elegant than decimal numbers for binary computations. Yes, it is about aligning with memory. Take this example and you will understand: number with 5 digits in hex (example: F56D1) → needs 20 bits on memory (just multiply by 4, always) number with 5 digits in dec (example: 19504) → needs ?? bits on memory (I won't even try to do this without paper) And that is it. Yes, it is an additional thing to learn, but after getting used you are thankful for the convenience they bring to you. Yes, I personally can read hex almost as intuitively as dec. That is, I don't know their decimal conversion, but I can certainly tell you A00F is bigger than A005. I can add on my head. Etc.
Not to mention that they have special restrictions and behaviors that vary from how lambda's usually work.
I guess my main problem is with a lack of a knowledge of bits and bytes. "...would look like 11110000. Well in decimal, that's 240, but in hexidecimal it's F0. Which allows you to map every 4 bits (or half byte) into a single character. 8 bits (a full byte) in one character is too difficult to read." all this makes sense, it's this: "Say you have 8 bits, and you want the most significant 4 bits of it", what!? if I have 8bits, I have a char or an int, no? Why would I want half of the char of half the int?
As I've stated to some others who replied, I guess my lack of a need for binary computations puts a lot of this discussion into theory-land in my head. 
1) casting the result of malloc, using atoi function, using strncpy function for "safe" string copying, pointing to string literals with char * pointers and so on. Thanks, I'll look out for these! THat said char * has not been introduced into the book so far, yet when I look up exercises to compare my work, A LOT use char *. Is there a book you would better recommend? 2a) I guess here, hex's are less confusing since 3F is clearly code for something, but octals, being digit only, took be a bit to wrap my head around, oh 12 is 10? So decimal 1526784 does mean at least it's quantity to me, where as the octal does not at a glance. I "get" it, but it's still weird to me. I know that 0x5555 stands for alternating 0 and 1 bits and that 0x3333 stands for alternating 0 and 1 bit pairs. Yeah, I think I need more experience :)
Don't think of it purely as numbers, think of it as a part (chunk) of memory (bits and bytes!), as a place to store data. Say you want to store 32 light switches. You could make 32 variables or array of 32 elements, but if you know that switch can only be 0 and 1, then you could be "smart" and use only one integer to store those switches and use bit manipulation to change them. [Here](http://www.falloutsoftware.com/tutorials/ktm/ktm1.htm) you can learn a little bit more about memory.
That helps! Question, was 32 picked arbitrarily? 
Yeah that's exactly why I've avoided stuff like that in the past.
Nope. On most architectures, the type int is 32 bits, or 4 bytes. So if you were using an integer as a bit mask, you could "index" so-to-speak 32 items before you ran out of space in an int. If you used a separate int variable to hold the on/off condition of each switch, you'd be using 1024 bits, or 128 bytes of memory, which is just a waste. In your program, you could always use bit number 0 to hold the condition of switch 0, bit number 1 for switch 1, and so on. It doesn't matter what all the other bits are, if bit n is 1, then switch n is on. This is an example of a bit mask, and one of the places using hexadecimal is much more useful than decimal since each hex digit is a direct mapping to 4 bits. Example: int switch_array = 0; /* all switches initially "off" */ switch_array = 0xBEEF; /* in binary this is: 1011 1110 1110 1111, with switch 0 on the right. Switches 16-31 are all off. */ /* Test if switch 6 is on */ if (switch_array &amp; 0x40) printf("switch 6 is on\n); /* Test if any of switches 12-15 are on */ if (switch_array &amp; 0xF000) printf("a switch between 12 and 15 is on"\n); /* Turn on switches 30 and 31 without disturbing state of other switches */ switch_array |= 0xC0000000;
Just for reference, when writing code, octal numbers are preceded by a leading 0. Hex numbers are preceded by a 0x, and decimal numbers have no leading characters. e.g.: char oct = 077; char hex = 0x3F; char dec = 63; char huh = '?'; In reality, i.e. memory, all four values are exactly the same: 0011 1111.
you are very helpful thanks, but switch 6 is 0x40?
Thanks. I'm going to have to check out the process to get from hex -&gt; binary. Only really covered hex -&gt; decimal so far.
The problem with that echo is that you send your program only a '#' character (and a line-feed), followed by an end-of-file. What select is actually telling you when it returns 1 is not that there is data available, but that a subsequent read would not block. And it doesn't. Instead, getchar is giving you -1, which means end-of-file. I'd say you should test for the character that getchar returns and exit when it is EOF (which is defined in stdio.h and equal to -1).
Yup, sure enough, checking for -1 works just fine. Thanks for the info! 
Even though this is probably intended as just a sketch, it is still a rather poor quality code with a number of errors of different level of seriousness. Firstly, according to its manpage, `readlink` does not zero-terminate the buffer. It has to be done explicitly and manually. Virtually every manpage on `readlink` shows how to do that properly. The code at the link fails to terminate the string. This is a serious error. Secondly, `readlink` returns `ssize_t`, not `int`. There was a time when it returned `int`, but it is long gone. Thirdly, casting the result of memory allocation function (which returns `void *`) is a sign of gross incompetence. I'd understand if the code was intended to be cross-compilable with C++, but in this case there's no reason to even think about that.
Very informative. &gt; casting the result of memory allocation function (which returns void *) is a sign of gross incompetence. Could you elaborate on this point, please?
&gt; ... I don't have any kind of formal compsci background.... I've read through K&amp;R, and I don't recall it relying on many (any, really) Computer Science concepts. As I recall, hopefully my memory isn't failing me, it introduced all the concepts it was going to deal with just before or just after showing them off in code. It definitely didn't presuppose any data structures knowledge (it may mention a few, but introduced "the way C does it", if I remember correctly). Are you reading a physical copy or a PDF? I've seen a number of PDFs, and they all have one issue or another: with formatting being the most prevalent, and flat out errors being another. Layout is fairly important in a programming text, and the print copy doesn't suffer as such. &gt; It is because I want to understand the machine better. What better way to do so than learn assembly? It may seem a bit over kill, but there's a free ebook which teaches the concepts of CompSci via Assembly: [Programming from the Ground Up Book](http://savannah.nongnu.org/projects/pgubook/): &gt; This is an introductory book to programming and computer science using assembly language. It assumes the reader has never programmed before, and introduces the concepts of variables, functions, and flow control. The reason for using assembly language is to get the reader thinking in terms of how the computer actually works underneath. Knowing how the computer works from a "bare-metal" standpoint is often the difference between top-level programmers and programmers who can never quite master their art. I've only read the first three chapters (I don't think I did the exercises), and I recall it being decent. This book will definitely help in the area of "bit twiddling [and] things like bitmasks." I recall those topics being introduced later in K&amp;R, and not relied upon very heavily. I suppose if I'm not remembering that correctly, though, it could be a blockade if one adheres to the "don't progress until exercises are solved" approach. I suppose I should note I completely ignored that method, which is why I recommend it. After K&amp;R, I lamented not being able to do certain things with C that I later realized were full-on 'homework assignments' from the book (implementing printf, for example). &gt; Is there any books or online resources that can give me a crash course in the sort of things I am struggling with? I'm still not entirely clear where you're getting stuck. I don't recall a lot of CompSci theory in K&amp;R, but I very well could be mis-remembering. Maybe /r/C_Programming should start a K&amp;R reading group with a few seasoned coders available to help out when newbies get stuck. I would absolutely recommend starting with the first chapter of K&amp;R, and not moving forward until you've completed every exercise therein. I know I said that before, but I think it's sound advise. The exercises may seem trivial at first, but the later ones can be rather difficult: especially if you don't allow yourself a "well, that's good enough for now..." solution. &gt; The things others appear to have issue with such as getting a compiler installed and working. Etc. I am fine with. That was just an example, and not really at all what Chapter 1 deals with: I meant it to read more as an all encompassing example. That is, "Ask here whenever you get stuck, be it installation woes or advanced topics." Poor writing on my behalf, sorry. In the same vein of the article /u/Broinz [posted](http://www.reddit.com/r/C_Programming/comments/2pn0gz/interesting_article_on_why_to_study_c/cn39jua), I would recommend [C of Peril](http://www.pldaniels.com/c-of-peril/): it covers the same types of topics in a similar manner. If you want some data structures resources, check out [Open Source Interactive Data Structures and Algorithms](http://algoviz.org/OpenDSA/), but note it's not tailored to C. I don't think data structures and algorithms theory will really be applicable for learning C (at least not as introduced via K&amp;R). On the other hand, if you're struggling with K&amp;R because you find it boring, these topics may be exactly what you need.
Sorry this will be a short reply but I just wanted to say thank you very much for such a great reply, once Christmas is over I will sit down and have a proper read of all you wrote and the links you posted. I just wanted to say thank you and wish you a Merry Christmas! :)
I might not have a use for this, but implmentations of ls and similar commands are always interesting. Thanks.
Different from what to what? You function, ref, has a return type of "int". return 0; returns the value 0. return Px; returns the pointer to an integer in Px, casted to int.
Sorry should have explained more. If I change PX to 100 and print it. Its memory address different from if I returned it 
In C, a void * can be assigned to any pointer type (and vice versa) without casting. While I agree that unnecessary casts should be avoided, "gross incompetence" seems a bit hyperbolic. Failing to Nul terminate the returned string on the other hand...
Your function returns an int, you should not return a 'px', which is a pointer, The pointer will be converted to an int, which might not be a proper conversion if an int can't represent a pointer properly. (Which in some platforms it can, and on others it cannot). 
In most applications the compiler specifies memory offsets, not physical memory locations. When the program runs, the os assigns it a memory space to run its code. Edit: Make sure you read the other comments in this thread as this can be a complex subject.
 int var = 0; // pointer variable That's not a pointer, it's just an integer.
*the group may only read. User, group, and other each have read, write, and execute bits.
If you're in a unix-styel shell... `tee` to the rescue! ./mycmd | tee logfile.txt Or, if you don't care to see the output as well, just redirect the output: ./mycmd &gt; logfile.txt This last solution works for Windows as well.
Assuming you want to do this in a pure C approach, I think the simplest way to accomplish this is to create your own printf function that calls fprintf multiple times with all the files that you want to send your output too. For example, say I want to send all the output to a FILE *fileout, as well as stdout: int my_printf(const char *format, ...) { va_list args; FILE *files[] = { stdout, fileout, NULL }, **file; int ret; for (file = files; *file != NULL; file++) { va_start(args, format); ret = vfprintf(*file, format, args); va_end(args, format); } return ret; } The 'my_printf' function can be called directly in place of printf in the same fashion as printf, but it will write any output to both 'stdout' and 'fileout'. If you don't mind using some shell magic, you can always pipe to `tee` and give it a filename to write any input too (as well as writing any input to the console).
sorry. I believe I was a bit drunk when I wrote this answer.
&gt; In most applications the compiler specifies memory offsets, not physical memory locations. When the program runs, the os assigns it a memory space to run its code. This is somewhat, but not entirely right. In an ordinary environment, the compiler creates object files that indeed only specify offsets. But the linker links these together into a single program which has a fixed address it's supposed to be loaded to. This slowly changes with modern technologies like shared libraries and position independent executables, but most applications are still compiled to be loaded from a fixed address.
Not to mention which xrealloc is non-standard, and he fails to check the (possibly NULL) return value from it.
Convert the numbers to strings (perhaps using `sprintf` from `&lt;stdio.h&gt;`, but make sure you have enough space allocated for the string) and then use `strstr` from `&lt;string.h&gt;` to search for one string inside the other.
You could also convert the numbers to strings, loop through the long string, taking steps that are as long as the length of the substring and count how often the substring is encountered.
so to find the n'th number in an integer just do int arbitraryNum(int n, num) { int Temp=1; for(n;n&gt;0;n--) { Temp*=10; } return ((num/Temp)%10); } //edit:formatting //edit:do this up to the length of the integer and put the result into an array to do the rest of the computation
As OP want **everything** that is written to the terminal you should redirect stderr also: ./mycmd &gt; logfile.txt 2&gt;&amp;1
He wants to ignore overlaps so more like int targetLen = strlen(targetStr); while (*convertedNumber) { char *p = strstr(convertedNumber, targetStr); if (p != NULL) { cnt++; convertedNumber = convertedNumber + targetLen; } else { convertedNumber++; } } I also fixed a problem with your while loop.
This is a complex topic. The simple case is systems without virtual memory. A lot of embedded systems are like this: Gameboys, DVD players, etc. In that case, the program simply reads and writes to whatever memory address it wants. That memory address is a "physical" memory address. Of course if the processor is 32-bit, it can support a maximum of 4GB of memory, but usually not all of that is present. (Often it's a lot less.) In that case, there are simply gaps: addresses that if you write to, nothing will happen. Reading from them might do nothing, or might cause an error. There may also be "memory-mapped" peripherals, things that are wired up so that if you read or write a special memory address, instead of going to memory it goes to that peripheral. This is a simple and easy to implement way of communicating with peripherals. But most PCs (and that also includes smartphones, modern gaming consoles, and other "large" computing devices) use "virtual" memory. In that case, when the program refers to a memory address, it's a "virtual" address. The OS and hardware work together to maintain a mapping between virtual and physical memory addresses. This lets the OS assign chunks of physical memory as it sees fit, without having to keep them in any kind of order. When your program is loaded by the OS, its executable file tells it where it wants to put its data. So it says the code goes in one region of virtual memory, its data goes in another, and its working stack goes in another. Then it goes along its merry way. As with the physical memory case, there are gaps in the virtual memory, areas where there is no physical memory mapped to the virtual memory. In this case, there's almost always hardware support to catch accesses to those regions, and doing so is usually an error. But your program can use OS functions to change its mapping, so that it can add more physical memory to unused virtual addresses. This could be empty regions of memory, or it could ask the OS to make a region of memory contain exactly the contents of a file from disk. (This is called "memory mapping" a file, and it's a quick and easy way to manipulate files because the OS does the hard parts for you.) But to your specific question, you can certainly write a program that refers to any virtual address you want. The question is, what will be there? If you're on a system like Linux that puts things in known locations, you might know in advance. But if you just pick an address at random, chances are you'll wind up in one of the large undefined regions.
Well, it has three friends too. I've got an expansion chassis for one (really just a PDP-8/M without the programmer's front panel), and two PDP-8/Es, one in fully-working condition. I'm also too young to have ever used one, but I was fairly lucky in obtaining my PDP-8s. If you're on OS X, [Bernhard Baehr's simulator](http://www.bernhard-baehr.de/pdp8e/pdp8e.html) is awesome in every way. Right now I've been using SimH to test out my latest code (and it works!). Hope to have it up on my [GitHub](https://github.com/drovak/os8diskserver) soon. 
You only have to go to half the length of the string because of the overlap clause. 
I'm no expert, but I'd recomend something that mixes C with Assembly. This is because what really sets C apart is its assumption that you know what you are doing and the close mapping to the machine. When I did a GameBoy emulator in a mixture of C and Assembly I realized it was a very effective way to really understand C. Maybe you could try to implement a CPU interpreter (the Z80 or Intel 8080 are very easy to emulate).
You're right. Forgot about the no overlap.
Well, the whole point of `xmalloc` being used there is that it never returns null. It simply aborts the entire program when it cannot allocate memory. Where appropriate, this is probably the easiest way of handling such situations. As for it being non-standard... the trick itself is very platform-specific already, so seeing a non-standard function being used there is not a big deal.
I'm definitely not a Java expert, but it's the only language I've had formal training in. Pointers, to my understanding, are like variable arrays...they point to a location in memory, right? I like both your suggestion and the other about practicing with an Arduino and Assembly. Because I've taken a few Java classes, I feel like I've got a rounded learning experience with the language...my only real experience with C is modifying a few thousand lines of code (that seems poorly written) for a lab I volunteer at. So, you see, I feel like there's a good chance I'm missing some language fundamentals. 
Thanks for the suggestions, I'll look into it.
What you have is a basic problem of finding a substring in a string. Avoiding overlaps is just a minor modification. However, solving this through an actual conversion to string feels like a way to "generate more heat than light". (Unless the very topic you are studying is dedicated to finding unorthodox ways for solving new problems using only existing tools.) Anyway, the same thing can be easily implemented numerically int main() { unsigned long long number = 1232412232325678; unsigned long long sub_number = 232; unsigned long long divisor = 10; for (unsigned long long t = sub_number; t &gt;= 10; t /= 10, divisor *= 10); // `divisor` is the the next greater power of 10 for `sub_number` // You can calculate it some other way, if you don't like the above unsigned count = 0; while (number &gt;= sub_number) if (number % divisor == sub_number) { ++count; number /= divisor; } else number /= 10; printf("%u\n", count); } 
I don't know what platform(s) the author is targeting, as he doesn't say. readlink is available on pretty much all POSIX-ish systems, so I didn't presume initially that it was targeted to something non-obvious. Since I was not familiar with xrealloc, I looked at my C reference (which didn't have it), then at my man pages on both a Linux and a FreeBSD system (which didn't have it). The only reference for it I found via quick internet search was [this](http://www.keil.com/support/man/docs/c251/c251_xrealloc.htm). It states, under Return Value: &gt; The xrealloc function returns a pointer to the new block. *If there is not enough memory in the memory pool to satisfy the memory request, a null pointer is returned* and the original memory block is not affected. (Italics added.) If the OP is using a different implementation that you know has different semantics (e.g. blow up with ENOMEM or segfault, etc), my apologies, but that was not clear to me from his post. Otherwise, the failure to check for a NULL here is a valid concern. Also, since this article was posted in the vein of a "generally useful thing for sysadmins to grab and re-use", I feel portability concerns (within the general POSIX ecosystem) are a valid nit, but it's certainly minor in comparison. None of this is to take away from your previous points, especially the failure to use readlink properly, which I fully agree with. 
To be honest, I was also unfamiliar with `x...` family of memory allocation functions, but most doc pages I was able to find stated something like this http://www.delorie.com/djgpp/doc/libc/libc_872.html I was under impression that the entire `x...` family was introduced by some implementations specifically to implement the "victory or death" approach to memory allocation. And yes, I see that the page you linked gives a different description. In your page the `x` in the name apparently signifies the fact that these functions work with `xhuge` pointers in ARM C166 compiler. I don't know which version of `x...` family the original article had in mind. But I find it unlikely that it had anything to do with ARM C166.
Write an os from scratch. 
Coming from Java. I skipped half of the learning c books. And went straight into pointers, structures, and pitfalls
This is something I definitely want to attempt before taking my operating systems class... It seems this is a common university level text on the subject: http://www.amazon.com/gp/aw/d/0470128720/ref=redir_mdp_mobile?pc_redir=T1&amp;tag=stackoverfl08-20 Any other recommendations?
&gt; most applications are still compiled to be loaded from a fixed address I don't think this has been true for a very long time. It was certainly true on DOS and similar OS's, but any multi-tasking, multi-user system is going to have a hard time running multiple programs if each application specifies it's own addresses. The other comments that suggest offsets are correct. The application "sees" a contiguous region of memory that is zero-based, and a virtual memory manager helps translate the addresses to real (non-zero) addresses, treating the application addresses as offsets to real addresses.
Not OP, but I know on my system int is 4 bytes and int* is 8. I think this is actually true of all pointers, they will all be the same size on one system and 8 is pretty common. Don't quote me on that, though.
&gt; The other comments that suggest offsets are correct. The application "sees" a contiguous region of memory that is zero-based, and a virtual memory manager helps translate the addresses to real (non-zero) addresses, treating the application addresses as offsets to real addresses. This is not quite true. On DOS, that was the case: If you ran a COM-program, DOS assigned a segment to you. The segment register contained an offset into the physical memory for your program. Modern operating systems use a technology called *paging.* Each program can use the entire address range from 0 to 2^(32)-1 or 2^(64)-1 as it wishes. A component called a *memory management unit* intercepts addresses coming from the processor and translates them into actual addresses according to tables put there by the operating system which assign each 4096 byte region the program sees (called a *page*) into a 4096 byte region in the physical RAM. If the program attempts to access a page that is not present in the translation table, an exception is generated and the operating system can either correct the tables or perform other actions, like terminating the process. This is required (a) because the tables inside the MMU are limited in size, requiring the operating system to take care of the parts not fitting in and (b) because the operating system can have less physical memory than actually allocated to all the programs; a lot of memory allocated by programs isn't actually used. This makes it possible for the operating system to conserve space.
Buy K&amp;R and work your way through it for a good start. 
Thank you, this is exactly what I was looking for. 
You cannot change `return 0;` to `return Px;` in your code. Your function is declared as returning `int`, while `Px` is a pointer. It is illegal to return a pointer value from an `int` function. C language does support implicit conversions from pointer types to integral types. For this reason, a change like that will produce a *constraint violation* (i.e. an error) and a diagnostic message from your compiler. The program will become non-compilable from the point of view of C language.
Just as a hobby...
Hell, Linux started as a learning exercise. And then there's TempleOS -- though that's less of a hobby and more of a software crusade.
Write a game. A simple game, but a game. Write it to be as small and efficient as possible. Use something like SDL to get a simple flat 2D canvas on which you can draw, and write your own graphics primitives. Short of creating an OS (which I've not ever attempted to tackle yet), writing any non-trivial game from the bolts on up will teach you a *lot* about the language you're using.
Do you have permissions to create a directory in /var/log? You should be checking errno to see why it's not working.
That question requires that the project can be used to show off in their portfolio whereas I don't mind working on a trivial project. Edit: those responses are appreciated none-the-less
I think a game is probably the best project idea. For anyone else wanting to start out on this path, I found this: http://www.parallelrealities.co.uk/2011/09/basic-game-tutorial-1-opening-window.html?m=1 
&gt; Hell, Linux started as a learning exercise That's what I'm refering to. 
[Integer division](https://www.reddit.com/r/learnprogramming/wiki/qtsgfb#wiki_are_you_performing_integer_division_instead_of_floating-point_division.3F)
I am assuming that all of your .c files are part of the project? If so, you're almost there but not quite doing it properly. When you use #include, the C preprocessor basically inserts the contents of the file you specified straight into the "base" file (in your case, "chapter20ex1.c" directly into "main.c". During the linking phase, all of the files in the project are linked together, and the definition of your function chapter20ex1() exists in both the original file, *and* in main.c. Short term, what you need is a way to tell main.c about the functions in chapter20ex1.c, without including the actual definition. There are a couple ways to do this, but the one that is usually used is a "header" file. In your case, you would create "chapter20ex1.h", and put the following in it: #ifndef CHAPTER20EX1_H__ #define CHAPTER20EX1_H__ void chapter20ex1(void); #endif This provides the "declaration" of your function, which tells main how to call it. It also provides "include guards" (the #ifndef, #define, and #endif statements), which aren't strictly necessary here but it is a good habit to get into. Change your #include statement to include the header file instead of the .c file. I would also modify the definition of your function in chatper20ex1.c file to this: void chapter20ex1(void) { puts("Hello World!"); } You're not returning anything, so "void" is the appropriate return type, and you aren't using any function arguments, so you should specify that as well.
When you are posting a problem like this with a compiler error it is helpful to post the precise compiler output. Additionally I think it would be very helpful for you work at the command line to understand the difference between the preprocessor, compiling and linking. This error comes from the fact that you are compiling two object files- one for your main.c and one for your chapter20ex1.c. As part of the preprocessor phase of compilation of main.c the entire text of chapter20ex1.c is merged into main.c so main.c looks like: /* prior included output of the include directives */ /* end of included math.h file */ chapter20ex1() { puts("Hello World!"); } int main() { chapter20ex1(); return 0; } So now the compiler creates an object file for a definition of main() and chapter20ex1(). The other file generates one definition of chapter20ex1() and then you link the two together to try and form the final executable. This causes your error because the linker sees two of the same definitions in your two object files and reports an error. Recommendations: * Understand what [function prototypes](http://en.wikipedia.org/wiki/Function_prototype) are. This is easiest to understand when you work within one file and have to define prototypes at the top of your file so that later functions can use them. * Try working with one project per chapter or assignment. It's just more sensible and what the rest of the universe does. The ~20kb you save on disk is not worth it and learning your way around project management is always valuable. * Understand the concept of the [include guard](http://en.wikipedia.org/wiki/Include_guard) which helps understanding for the preprocessor/header/source file dynamic.
Yes but it's older standard. C99 has some nice things added but some abandoned compilers (like MSVC) won't support those.
Guys, thanks for both of your replies! After carefully reading both, it sounds like I don't understand enough about what is going on when I build (compile) two files in Code::blocks. I will do some research on how to compile a C file from the command line in windows and that should help to enlighten me a bit on exactly what is going on. I will also do some more research on the other items arkmark outlined. 
Just with that I really doubt it can be compiled... Don't you have the rest of the source code?
I'm not sure, but I think Visual Studio is for Basic, C#, C++, and others which must not be named. And I don't know if VS can be configured with MinGW or Cygwin in order to allow to compile C code, but if you want to program in C, you should't use VS but Code::Blocks, CodeLite and so on.
Oh sorry here you go. I believe all the key editing and timing is done in the above file. Full source code for reference: http://puu.sh/dMleJ/3ef084fff5.zip
However, as with everything C, intrinsics are king. The distinction is significant.
That's pretty much it. I think I'll be learning C in software design next year but for now I'd just like some help making this source code allow the keys to send Z, X and ESCAPE scancodes and function like a normal keyboard. I'm a little slow on the uptake so please be patient with me :)
(Sorry for delayed response, was traveling in relation to the holiday.) I hadn't seen the DJGPP docs when I searched; I would certainly agree that that is a more likely representation of what OP was intending. In that scenario, I retract my complaint over NULL-checking. The fact that it's so non-standard that it likely has no prototype... "it's probably in your libc, but you can't really know until link time since it's undeclared...": that kind of thing still really bugs me from a portability standpoint. That said, I suppose each of us is free (project/work requirements aside) to determine how portable we care about being.
Your comment is quite rude. I would take offense if I had, in fact been the author of the function. Your charge of "gross incompetence" should be directed toward the original source: https://www.gnu.org/software/libc/manual/html_node/Symbolic-Links.html
Alright, I'll check there. Thanks.
xrealloc is a convention of GNU kernel development; it is a subroutine of realloc with an error handler. It is also convention to write "xrealloc" when we wish to take for granted that error handling will be expressed in a sane way. You know, if you just want to tell people about a function. That you find helpful and interesting. Of course, don't take my word for it: https://www.gnu.org/software/libc/manual/html_node/Changing-Block-Size.html You are correct that C166 is too brand-spanking new to be relevant. However, the link you provided from delorie.com provides a pretty useful hint as to xrealloc()'s history in its description: "Note that, currently, the header `stdlib.h' does not declare a prototype for xrealloc, because many programs declare its prototype in different and conflicting ways. If you use xrealloc in your own code, you might need to provide your own prototype explicitly."
xmalloc is a conventional subroutine expression. It is assumed, by convention, that the subroutine will be handled in the application. xmalloc can and has been written to save state at the time of application exit.
&gt; "generally useful thing for sysadmins to grab and re-use" I agree this is valid. I clarified at the top of the post this is from GNU's libc. 
The type of a string literal is `char [n]` where `n` is the number of characters plus the null terminator. I.e., the type of the expression `"Frank"` is `char [6]`. This is why you can declare your variable these ways: * `char name[6]` - matches exactly * `char *name` - array types decay to pointers * `char name[]` - the size of the array is implicitly given by the value it's initialized to Now, when you have the line `name = "Terry Ted";`, all that's happening is that `name`, which used to be a pointer to the first character in "Frank", now takes as a value a pointer to the first character in "Terry Ted". That's it. It's not copying the strings around at all, it's just changing the pointer value. Note that this works exactly the same if you declare it as `char name[]` or `char name[6]`. Array variables are still just pointers to the first element.
Oh, I'm sorry, but I don't know how to do that :(. Maybe, like dmc_2930 said, you'll get more help at that subreddits :( I'm sorry :(
No worries, thanks anyways.
Follow up question. The size of the original *name variable Frank is 6 characters with the \0 character. When you assign "Terry Ted" the compiler will know how to "grow" the size of the array to 10 automagically? I know you said its changing the ptr address but im confused as to how it would handle the size difference. 
Your explanation is somewhat incorrect. Let me try to explain how string literals actually work. Everywhere but the exception listed below, a string literal `"Frank"` represents an anonymous object of type `char[n]` where `n` is the number of characters in the string including the trailing `\0` byte. Writing to such an object is undefined behaviour; you might pretend that the type of `"Frank"` is actually `const char[n]`, but it isn't for compatibility reasons. Notice that the C standard does not mandates that the addresses of different string literals are different; `"Frank" == "Frank"` may or may not evaluate to 1, depending on compiler and platform. An object of type `T[n]` for some type T and some integer `n` decays to a pointer to its first element in most contexts, such as when it is passed to a function (incidentally, the types `int(char[])` [function from char-array to int] and `int(char*)` [function from char-pointer to int] are equal) or an operand to most operators (a notable exception is the `sizeof()` operator). Because of this rule, the code int A[10], B[10]; A = B; will not work: `B` decays to `int*` when an operand of `=` (but `A` will not) and `int*` is not assignable to `int[10]`. The exception to the behaviour of string literals is when a string literal appears as an initializer to an object of type `char[]` or `char[n]` where n is not larger than the number of characters in the string literal plus the trailing `\0` byte. n is allowed to be smaller than the length of the string literal and this is useful in some cases. In this case, the content of the string literal initializes the variable. The string literal will not create an anonymous object in this case. If the length of the array has not been provided, it is derived from the length of the string including the trailing `\0` byte. If the length of the array is shorter than the initializer, the string literal is truncated to the length of the array. To put it simply, char a[] = "Frank"; is shorthand for char a[] = { 'F', 'r', 'a', 'n', 'k', '\0' }; As a final remark, adjacent string literals are concatenated (dropping the intermediate `\0` bytes) after macro expansion has taken place but before parsing begins. This makes it possible to use constructions like this: #define NAME "Frank" printf("Hello, my name is " NAME "! I am happy to meet you.\n");
This is how my code looks like now, awww yeah pointers http://imgur.com/jKiKMIJ
Well, just remember, like any superpower, pointers should be used with extreme care, since they're definitely the number one source for difficult to track down bugs in C code.
Thanks, fixed now. In the for loop can you shorten it a bit by doing for(; *str; ++str) Also is it necessary to use double pointer for pnext? It seems like it would be simpler to just do *pnext instead
Yes, you can shorten it that way, if you prefer implicit comparisons. I prefer explicit ones. You can also move some operations into the cycle header to make it appear even more compact node *parsell(char **str) { node *head, **pnext; for (pnext = &amp;head; *str; ++str, pnext = &amp;(*pnext)-&gt;next) { *pnext = malloc(sizeof **pnext); (*pnext)-&gt;str = *str; } *pnext = NULL; return head; } As for `pnext`, no, in this particular idiom it absolutely has to have pointer-to-pointer type. I don't see how you'd do it with a `node *pnext`.
Is that exactly what you have in your code? A #define macro only replaces with the text up to a newline. If you want your ERROR macro to work as expected, you need to end each partial line in the macro with a line continuation character #define ERROR(PHRASE) { fprintf(stderr, \ "Fatal Error %s occured in %s, line %d\n", \ PHRASE, __FILE__, __LINE__); exit(2); } EDIT: Also, make sure there are no spaces after the backslashes. They must be the last character on the line.
Preprocessor macros aren't functions; they don't need braces, and, more critically, they need to be written on a single line or else the breaks need to be escaped. The error you're getting is because what this macro does is defines ERROR() to be equal to the '{' character. Then, the compiler sees a bunch of code without any scope and an unmatched closing brace. To fix this, get rid of the braces -- while not strictly harmful, you don't need them -- and place backslashes \ on the ends of each macro line you wish to be continued. Also, while not absolutely necessary in this case, it is a good idea to get into the habit of wrapping your macro parameters in parentheses á la `fprintf (stderr, "%s", (PHRASE));`. The reason for this is because the preprocessor works by simple text substitution, which can lead to some unexpected, difficult to diagnose, and potentially fatal bugs if you "pass" into them expecting C call semantics. Example of the latter: #define PROD(a,b) a * b int x = PROD (5, 10); // int x = 5 * 10; // So far so good... int y = PROD (x + 2, 10); // int y = x + 2 * 10 // Oops! // Parentheses could have avoided this: // #define PROD(a,b) ((a) * (b))
Hi - Thank you so much for your detailed response. I will change my macro as per your recommendations, and the issue is solved! Now onwards with my assignment... :)
Now achieve transcendence with Understanding and using C Pointers by Richard Reese on Oreilly.
Just wait until your juggling a dozen different pointers to arrays of pointers. or arrays of pointers to pointers... all of different types that need to be cast between each other. Mmm, I fell like I should write a program that uses pointers needlessly now.
For arrays specifically it doesn't matter much. There's one argument for using pointers though: pointer-based iteration relies only on *sequential access*. Index-based iteration requires *random access*. Random access contract is a much stronger and restrictive contract than sequential access contract. In general case, from the design point of view, it is often a good idea to stick to weaker, less restrictive contracts. I.e. do more with less, don't require something you don't really need. If you can efficiently implement the algorithm using only sequential access, stick to sequential access. If you are sure that you are working with an array and will always be working with an array, then such considerations don't matter much. Arrays provide random access for free. But once you start developing more generic code (in C++ maybe) or run into a situation when you need to replace one data structure with another (e.g. array with list), you might appreciate the value of this "do more with less" design strategy.
Don't think I've seen linked lists implemented like that before, thanks for the tip!
I think so, if i follow what you are asking correctly. char a[6] = "12345"; creates an array that is 6 characters long. So does this: char b[] = "12345"; and so should this: char *c = "12345"; That last one might not have boundary checking in the compiler however. I'm not sure as this is easier to debug when I don't play "how will the compiler handle this", so I don't do it that way generally. So yes, in all three, if you copy a new string over "12345" that is longer (say "abcdefghijk") you will overflow that buffer. Whether this hurts something is a completely different issue and you might march on quite happily and never notice (one of the 'joys' of C). Now if you add a statement like this: //using above defines c = b; The data that c pointed too is off lost forever and ever. Sure, the string still appears in memory where it was allocated, but you can't get back to it unless you've saved that address. Also, read /u/FUZxxl's post below about the rest of the nuance of how that statement works (which goes back to, when you need to worry about how the compiler does something, don't do it that way) 
&gt; will not work: B decays to int* when an operand of = (but A will not) and int* is not assignable to int[10]. Why doesn't A decay in that case? Decaying wouldn't violate the rule and would behave as it would seem the code intends.
Thanks!
I did post it on /r/avr back when I finished it, but given the real deal is in C... why not share it here. It's not *that* trivial, and shows C on both the embedded 8bit MCU and big x64 sides. Edit: I believe this project is missing a video. You can actually control MPd, browse Twitter stream etc. with it.
You haven't understood this. These statements create an array that is 6 characters long: char a[6] = "12345"; char b[] = "12345"; this statement does not: char *c = "12345"; In fact, the last statement creates a pointer to the first element of an object of type `char[6]`. This is a subtle, yet important difference. Notably, you can't assign to `a` or `b` (but you can assign to the array members such as `a[0]`) but you can assign to `c`. You are not allowed to overwrite the array `c` points to, since it comes from a string literal, this is *undefined behaviour.*
Be careful, they can be a pain in the ass.
If you need a macro that stands for a compound statement, the better idea is to enclose the statement into `do { ... } while (0)` instead of a plain pair of `{ ... }` #define ERROR(PHRASE) do {\ fprintf(stderr, "Fatal Error %s occured in %s, line %d\n",\ PHRASE, __FILE__, __LINE__);\ exit(2);\ } while (0)
Casting is usually a sign that you're doing it wrong. 
So %[ ] reads in a string that is composed of whatever characters are between the opening and closing bracket. %[\^ ], on the other hand, (where the first character is a caret), does the opposite, and reads in a string that is composed of whatever characters are *not* between the opening and closing bracket. So %[\^\\n] reads in a string of characters until it sees a newline. The 50 just gives a maximum length on the number of characters that can be read. Personally I think whoever wrote that line of code should have just used fgets.
&gt; If the key we want to insert is NOT the same as the key from the map That isn't what `if(!strcasecmp(name,map-&gt;name))` means. [The `strcasecmp` function](http://linux.die.net/man/3/strcasecmp) returns&amp;nbsp;0 if the two strings are equal, so `!strcasecmp(name,map-&gt;name)` will be true if the two strings are *equal*, not if they are unequal. &gt; But if the key exists, the new data should simply be appended to the old data? No. If the key already exists in the map, then the new value should *replace* the old value. That's how assignment works. Lines 80–89 are what happens when the map already contains an entry with the given key. The value currently associated with that key is freed, an array is allocated for the new value, and the string is copied into that new array.
The code also frees the previous version of value and returns no error (lines 99-101), so map_get will now return NULL for such data (instead of the empty string). Not nice. Also, if the code goes out of memory when setting the name, it will set it to NULL too (line 95-97), and this will cause the code to crash at line 80 at the next search (code only epect map-&gt;name to be NULL in the first entry). 
Thank you very much.
Well, yes, this code doesn't handle `malloc` failures very elegantly. I suppose it should call `exit(EXIT_FAILURE)` or something instead.
Thanks! Not familiar with objects in C yet though, but everything else makes sense.
The word *object* is fairly general in the C language and not really related to the notion of object-oriented programming. Here is the definition of object (from ISO 9899:2011§3.15): &gt; **object** &gt; &gt; region of data storage in the execution environment, the contents of which can represent values &gt; &gt; NOTE &gt; When referenced, an object may be interpreted as having a particular type; see 6.3.2.1.
Thanks!
*The C Programming Language* from Brian W. Kernighan &amp; Dennis M. Ritchie is really good. It's known to be the 'The C bible'.
I found a pdf and it seems really good. Thanks!
I'm going to check it out, thanks a lot.
I currently have 900 lines Does someone know some good form of posting that?
`fgets` has that annoying habit of reading the newline and including it into the output string :)
Please don't post the whole thing. Post a small, self-contained, correct example. Read http://sscce.org/ to understand what that means. Also read [How to Ask Questions the Smart Way](http://www.catb.org/esr/faqs/smart-questions.html#code).
OK, I'll try to reduce to only the lines needed Thanks for reading :) I'll update soon with the result
The process of multi-file compilation is fairly simple. When building a project, you first compile each individual source file into a machine code *.o file. Once all the sources are compiled, you 'link' the sources together, along with any library dependencies, using a linker program (the compiler often doubles as a linker). For gcc (the compiler codeblocks uses), The process goes like this: # compile '-c' tells compiler to compile source, but not link '-o' represents the # compiled file that the compiler produces gcc -c main.c -o main.o gcc -c other_file.c -o other_file.o # link --the first file after the -o is the output program. # Files following are dependencies gcc -o main main.o other_file.o The big difference between languages like C/C++ and modular languages like Python is that the language itself has no concept of linking multiple source files--linking is implemented only through build software. When you write `#include "chapter20ex1.c"` in a source file, you do not compile the source file. `#include` is a dumb process which does nothing more than copies and pastes the given file into the source code *before compiling*. As others have mentioned, you write function and type prototypes in header files ,which you then `#include`, so the compiler knows they exist even before you link the actual sources together. In practice, you use a use a build tool, like [make](http://en.wikipedia.org/wiki/Make_%28software%29), [rake](http://en.wikipedia.org/wiki/Rake_\(software\)), or [cmake](http://en.wikipedia.org/wiki/CMake) to build projects, even when not using an IDE--manually compiling and linking projects are a huge pain regardless of how you write code.
You will have to do a lot of research while reading it, but It helped me a lot to understand C better. [Deep C](http://www.slideshare.net/olvemaudal/deep-c) Before that, those books that were mentioned earlier here.
More than 10000 words :S the rest it's in reply So here it is, sorry couldn't reduce more :S I'm using codeBlocks (don't know if it matters) If you compile/run and chose this options: * v * b * a/b/c * a/b/c (different from the last one) * number 1-25 - here it's when it stops working :c Thanks a lot (really) for helping :D You can just copy everything from here: #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;ctype.h&gt; #include &lt;stdlib.h&gt; #define MAX_CHARS 30 #define MAX_PASSAGEIROS 25 #define MIN_PASSAGEIROS 1 #define MAX_BALOES 10 #define MAX_ANOS 2014 #define MIN_ANOS 1783 #define MAX_MES 12 #define MIN_MES 1 #define PRECO 100 #define DESCONTO 0.9 typedef struct{ //data int dia, mes, ano; }tipoDataF; typedef struct{ //baloes int numero; char nome[MAX_CHARS]; tipoDataF dataFabrico; char posicao; int maxPassageiros; int quantPassageirosA; int quantPassageirosB; int quantPassageirosC; }tipoBaloes; typedef struct{ //viagem int numViagem; int numBalao; char origem, destino; int numPassageiros; }tipoViagem; typedef struct{ //lista de espera int numPessoas; char destino; }tipoListasDeEspera; tipoListasDeEspera *venderBilhetes(tipoListasDeEspera *lA, tipoListasDeEspera *lB, tipoListasDeEspera *lC, int *preco, int *contLA, int *contLB, int *contLC, int *totPreco, char *opcaoC); char funcaoMenu(int contBalao, int *contViagem, int totLE, int totPreco); void atualizarDados(tipoListasDeEspera *lA, tipoListasDeEspera *lB, tipoListasDeEspera *lC, int contLA, int contLB, int contLC, int *totLE); int qtdviagens(char origem, char destino); void funcaosubMenuViagens(tipoBaloes balao[], int *contBalao, int *contViagem, tipoListasDeEspera *lA, tipoListasDeEspera *lB, tipoListasDeEspera *lC, int *contLA, int *contLB, int *contLC, int *preco, int *totPreco, char *lAlterar); int lerInteiro(char str[], int minimo, int maximo); void limparBufferTeclado(void); int main(void){ tipoBaloes balao[MAX_BALOES]; tipoViagem *Viagem = NULL; tipoListasDeEspera *lA = NULL; tipoListasDeEspera *lB = NULL; tipoListasDeEspera *lC = NULL; tipoListasDeEspera *lAux = NULL; int contLA = 0, contLB = 0, contLC = 0; int contBalao = 0, contViagem = 0, totLE = 0, preco, totPreco = 0; char opcao, opcaoB, opcaoC; char lAlterar; do{ atualizarDados(lA, lB, lC, contLA, contLB, contLC, &amp;totLE); opcao=funcaoMenu(contBalao, &amp;contViagem, totLE, totPreco); switch(opcao){ case 'V': funcaosubMenuViagens(balao, &amp;contBalao, &amp;contViagem, lA, lB, lC, &amp;contLA, &amp;contLB, &amp;contLC, &amp;preco, &amp;totPreco, &amp;lAlterar); switch(lAlterar){ case 'A': lAux = lA; break; case 'B': lAux = lB; break; case 'C': lAux = lC; break; } break; default: printf("\n\tOpcao inexistente, escolha uma opcao da lista.\n"); break; } }while(opcao != 'S'); free(lA); free(lB); free(lC); free(lAux); free(Viagem); return 0; } char funcaoMenu(int contBalao, int *contViagem, int totLE, int totPreco){ char opcao; printf("\n\n\t\t Menu Principal\n"); printf("\nBaloes existentes:\t\t %d", contBalao); printf("\nViagens realizadas:\t\t %d", *contViagem); printf("\nPassageiros transportados:\t 0"); printf("\nPassageiros em lista de espera:\t %d", totLE); printf("\nReceita obtida:\t\t\t %d", totPreco); printf("\n\nEscolha uma das seguintes opcoes:\n"); printf("\n (V) Viagens "); scanf(" %c", &amp;opcao); opcao=toupper(opcao); return opcao; } 
 tipoListasDeEspera *venderBilhetes(tipoListasDeEspera *lA, tipoListasDeEspera *lB, tipoListasDeEspera *lC, int *preco, int *contLA, int *contLB, int *contLC, int *totPreco, char *opcaoC){ char origem; char destino; int noPessoas; int nviagens; tipoListasDeEspera *laux; do{ printf("\n Indique a posicao onde se encontra[A,B,C]:"); scanf(" %c", &amp;origem); origem = toupper(origem); if(origem != 'A' &amp;&amp; origem != 'B' &amp;&amp; origem != 'C'){ printf("\n Posicao invalida"); } *opcaoC = origem; }while(origem != 'A' &amp;&amp; origem != 'B' &amp;&amp; origem != 'C'); switch(origem){ case 'A':laux = lA; laux = realloc(laux, ((*contLA)+1)*sizeof(tipoListasDeEspera)); if(laux == NULL){ printf("\n Memoria insuficiente!"); lA = laux; } else{ do{ printf("\n Indique o seu destino [A,B,C]:"); scanf(" %c", &amp;laux[*contLA].destino); laux[*contLA].destino = toupper(laux[*contLA].destino); if(laux[*contLA].destino != 'A' &amp;&amp; laux[*contLA].destino != 'B' &amp;&amp; laux[*contLA].destino != 'C' || laux[*contLA].destino==origem){ if(laux[*contLA].destino==origem){ printf("\n Ja se encontra no Destino"); }else{ printf("\n Destino invalido"); } } }while(laux[*contLA].destino != 'A' &amp;&amp; laux[*contLA].destino != 'B' &amp;&amp; laux[*contLA].destino != 'C' || laux[*contLA].destino==origem); laux[*contLA].numPessoas = lerInteiro("\n Indique o numero de pessoas: ", MIN_PASSAGEIROS, MAX_PASSAGEIROS); noPessoas = laux[*contLA].numPessoas; destino = laux[*contLA].destino; (*contLA)++; } break; case 'B':laux = lB; laux = realloc(laux, ((*contLB)+1)*sizeof(tipoListasDeEspera)); if(laux == NULL){ printf("\n Memoria insuficiente!"); lB = laux; } else{ do{ printf("\n Indique o seu destino [A,B,C]:"); scanf(" %c", &amp;laux[*contLB].destino); laux[*contLB].destino = toupper(laux[*contLB].destino); if(laux[*contLB].destino != 'A' &amp;&amp; laux[*contLB].destino != 'B' &amp;&amp; laux[*contLB].destino != 'C' || laux[*contLB].destino==origem){ if(laux[*contLB].destino==origem){ printf("\n Ja se encontra no Destino"); }else{ printf("\n Destino invalido"); } } }while(laux[*contLB].destino != 'A' &amp;&amp; laux[*contLB].destino != 'B' &amp;&amp; laux[*contLB].destino != 'C' || laux[*contLB].destino==origem); laux[*contLB].numPessoas = lerInteiro("\n Indique o numero de pessoas: ", MIN_PASSAGEIROS, MAX_PASSAGEIROS); noPessoas = laux[*contLB].numPessoas; destino = laux[*contLB].destino; (*contLB)++; } break; case 'C':laux = lC; laux = realloc(laux, ((*contLC)+1)*sizeof(tipoListasDeEspera)); if(laux == NULL){ printf("\n Memoria insuficiente!"); lC = laux; } else{ do{ printf("\n Indique o seu destino [A,B,C]:"); scanf(" %c", &amp;laux[*contLC].destino); laux[*contLC].destino = toupper(laux[*contLC].destino); if(laux[*contLC].destino != 'A' &amp;&amp; laux[*contLC].destino != 'B' &amp;&amp; laux[*contLC].destino != 'C' || laux[*contLC].destino==origem){ if(laux[*contLC].destino==origem){ printf("\n Ja se encontra no Destino"); }else{ printf("\n Destino invalido"); } } }while(laux[*contLC].destino != 'A' &amp;&amp; laux[*contLC].destino != 'B' &amp;&amp; laux[*contLC].destino != 'C' || laux[*contLC].destino==origem); laux[*contLC].numPessoas = lerInteiro("\n Indique o numero de pessoas: ", MIN_PASSAGEIROS, MAX_PASSAGEIROS); noPessoas = laux[*contLC].numPessoas; destino = laux[*contLC].destino; (*contLC)++; } break; } nviagens = qtdviagens(origem, destino); if(noPessoas &gt; 1){ *preco = PRECO*noPessoas*DESCONTO*nviagens; } else{ *preco = PRECO*nviagens; } printf("O valor a pagar e: %d euros\n", *preco); *totPreco += *preco; return laux; } int qtdviagens(char origem, char destino){ int ori, des, noviagens; switch(origem){ case 'A': ori = 1; break; case 'B': ori = 2; break; case 'C': ori = 3; break; } switch(destino){ case 'A': des = 1; break; case 'B': des = 2; break; case 'C': des = 3; break; } noviagens = des - ori; if (noviagens&lt;0){ noviagens += 3; } return noviagens; } void funcaosubMenuViagens(tipoBaloes balao[], int *contBalao, int *contViagem, tipoListasDeEspera *lA, tipoListasDeEspera *lB, tipoListasDeEspera *lC, int *contLA, int *contLB, int *contLC, int *preco, int *totPreco, char *lAlterar){ char opcaoV; char opcaoC; char lista; tipoListasDeEspera *lAux = NULL; printf("\n\nEscolha uma das seguintes opcoes:"); printf("\n Comprar Bilhete: (B)"); do{ scanf(" %c", &amp;opcaoV); limparBufferTeclado(); opcaoV=toupper(opcaoV); }while(opcaoV != 'B' &amp;&amp; opcaoV != 'C' &amp;&amp; opcaoV != 'V'); switch(opcaoV){ case 'B': lAux = venderBilhetes(lA, lB, lC, preco, contLA, contLB, contLC, totPreco, &amp;opcaoC); switch(opcaoC){ case 'A': lA = lAux; break; case 'B': lB = lAux; break; case 'C': lC = lAux; break; } break; default: printf("\n\tOpcao inexistente, escolha uma opcao da lista.\n"); break; } } void atualizarDados(tipoListasDeEspera *lA, tipoListasDeEspera *lB, tipoListasDeEspera *lC, int contLA, int contLB, int contLC, int *totLE){ int i; for(i=0; i &lt; contLA; i++){ printf("%d ", lA[i].numPessoas); *totLE += lA[i].numPessoas; } for(i=0; i &lt; contLB; i++){ printf("%d ", lB[i].numPessoas); *totLE += lB[i].numPessoas; } for(i=0; i &lt; contLC; i++){ printf("%d ", lC[i].numPessoas); (*totLE) += lC[i].numPessoas; } } void limparBufferTeclado(void){ char chr; do{ chr = getchar(); }while(chr != '\n'); } int lerInteiro(char str[], int minimo, int maximo){ int numero, controlo; do{ printf("%s", str); controlo = scanf("%d", &amp;numero); limparBufferTeclado(); if(numero&lt;minimo || numero&gt;maximo){ printf("\n O numero nao e valido"); } }while(numero &lt;minimo || numero&gt;maximo || controlo !=1); return numero; } 
You need to work harder on narrowing down your error. Nobody is going to hunt through 330&amp;nbsp;lines of your code. You need to post a **small**, self-contained, correct example. But the first thing you should do is turn on all warnings in your compiler, and pay attention to what they say: $ clang -std=c99 -Wall -Wextra -pedantic -O3 -o program program.c program.c:63:25: warning: unused variable 'opcaoC' [-Wunused-variable] char opcao, opcaoB, opcaoC; ^ program.c:63:17: warning: unused variable 'opcaoB' [-Wunused-variable] char opcao, opcaoB, opcaoC; ^ program.c:146:89: warning: '&amp;&amp;' within '||' [-Wlogical-op-parentheses] ...laux[*contLA].destino != 'A' &amp;&amp; laux[*contLA].destino != 'B' &amp;&amp; laux[*contLA].destino != 'C' ||... ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~~ program.c:146:89: note: place parentheses around the '&amp;&amp;' expression to silence this warning ...laux[*contLA].destino != 'A' &amp;&amp; laux[*contLA].destino != 'B' &amp;&amp; laux[*contLA].destino != 'C' ... ^ ( ) program.c:153:89: warning: '&amp;&amp;' within '||' [-Wlogical-op-parentheses] ...laux[*contLA].destino != 'A' &amp;&amp; laux[*contLA].destino != 'B' &amp;&amp; laux[*contLA].destino != 'C' ||... ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~~ program.c:153:89: note: place parentheses around the '&amp;&amp;' expression to silence this warning ...laux[*contLA].destino != 'A' &amp;&amp; laux[*contLA].destino != 'B' &amp;&amp; laux[*contLA].destino != 'C' ... ^ ( ) program.c:171:89: warning: '&amp;&amp;' within '||' [-Wlogical-op-parentheses] ...laux[*contLB].destino != 'A' &amp;&amp; laux[*contLB].destino != 'B' &amp;&amp; laux[*contLB].destino != 'C' ||... ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~~ program.c:171:89: note: place parentheses around the '&amp;&amp;' expression to silence this warning ...laux[*contLB].destino != 'A' &amp;&amp; laux[*contLB].destino != 'B' &amp;&amp; laux[*contLB].destino != 'C' ... ^ ( ) program.c:178:89: warning: '&amp;&amp;' within '||' [-Wlogical-op-parentheses] ...laux[*contLB].destino != 'A' &amp;&amp; laux[*contLB].destino != 'B' &amp;&amp; laux[*contLB].destino != 'C' ||... ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~~ program.c:178:89: note: place parentheses around the '&amp;&amp;' expression to silence this warning ...laux[*contLB].destino != 'A' &amp;&amp; laux[*contLB].destino != 'B' &amp;&amp; laux[*contLB].destino != 'C' ... ^ ( ) program.c:196:89: warning: '&amp;&amp;' within '||' [-Wlogical-op-parentheses] ...laux[*contLC].destino != 'A' &amp;&amp; laux[*contLC].destino != 'B' &amp;&amp; laux[*contLC].destino != 'C' ||... ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~~ program.c:196:89: note: place parentheses around the '&amp;&amp;' expression to silence this warning ...laux[*contLC].destino != 'A' &amp;&amp; laux[*contLC].destino != 'B' &amp;&amp; laux[*contLC].destino != 'C' ... ^ ( ) program.c:203:89: warning: '&amp;&amp;' within '||' [-Wlogical-op-parentheses] ...laux[*contLC].destino != 'A' &amp;&amp; laux[*contLC].destino != 'B' &amp;&amp; laux[*contLC].destino != 'C' ||... ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~~ program.c:203:89: note: place parentheses around the '&amp;&amp;' expression to silence this warning ...laux[*contLC].destino != 'A' &amp;&amp; laux[*contLC].destino != 'B' &amp;&amp; laux[*contLC].destino != 'C' ... ^ ( ) program.c:187:20: warning: variable 'noPessoas' is used uninitialized whenever 'if' condition is true [-Wsometimes-uninitialized] if(laux == NULL){ ^~~~~~~~~~~~ program.c:212:8: note: uninitialized use occurs here if(noPessoas &gt; 1){ ^~~~~~~~~ program.c:187:17: note: remove the 'if' if its condition is always false if(laux == NULL){ ^~~~~~~~~~~~~~~~~ program.c:162:20: warning: variable 'noPessoas' is used uninitialized whenever 'if' condition is true [-Wsometimes-uninitialized] if(laux == NULL){ ^~~~~~~~~~~~ program.c:212:8: note: uninitialized use occurs here if(noPessoas &gt; 1){ ^~~~~~~~~ program.c:162:17: note: remove the 'if' if its condition is always false if(laux == NULL){ ^~~~~~~~~~~~~~~~~ program.c:137:20: warning: variable 'noPessoas' is used uninitialized whenever 'if' condition is true [-Wsometimes-uninitialized] if(laux == NULL){ ^~~~~~~~~~~~ program.c:212:8: note: uninitialized use occurs here if(noPessoas &gt; 1){ ^~~~~~~~~ program.c:137:17: note: remove the 'if' if its condition is always false if(laux == NULL){ ^~~~~~~~~~~~~~~~~ program.c:121:18: note: initialize the variable 'noPessoas' to silence this warning int noPessoas; ^ = 0 program.c:187:20: warning: variable 'destino' is used uninitialized whenever 'if' condition is true [-Wsometimes-uninitialized] if(laux == NULL){ ^~~~~~~~~~~~ program.c:211:35: note: uninitialized use occurs here nviagens = qtdviagens(origem, destino); ^~~~~~~ program.c:187:17: note: remove the 'if' if its condition is always false if(laux == NULL){ ^~~~~~~~~~~~~~~~~ program.c:162:20: warning: variable 'destino' is used uninitialized whenever 'if' condition is true [-Wsometimes-uninitialized] if(laux == NULL){ ^~~~~~~~~~~~ program.c:211:35: note: uninitialized use occurs here nviagens = qtdviagens(origem, destino); ^~~~~~~ program.c:162:17: note: remove the 'if' if its condition is always false if(laux == NULL){ ^~~~~~~~~~~~~~~~~ program.c:137:20: warning: variable 'destino' is used uninitialized whenever 'if' condition is true [-Wsometimes-uninitialized] if(laux == NULL){ ^~~~~~~~~~~~ program.c:211:35: note: uninitialized use occurs here nviagens = qtdviagens(origem, destino); ^~~~~~~ program.c:137:17: note: remove the 'if' if its condition is always false if(laux == NULL){ ^~~~~~~~~~~~~~~~~ program.c:120:17: note: initialize the variable 'destino' to silence this warning char destino; ^ = '\0' program.c:260:10: warning: unused variable 'lista' [-Wunused-variable] char lista; ^ program.c:257:38: warning: unused parameter 'balao' [-Wunused-parameter] void funcaosubMenuViagens(tipoBaloes balao[], int *contBalao, int *contV... ^ program.c:257:52: warning: unused parameter 'contBalao' [-Wunused-parameter] void funcaosubMenuViagens(tipoBaloes balao[], int *contBalao, int *contV... ^ program.c:257:68: warning: unused parameter 'contViagem' [-Wunused-parameter] void funcaosubMenuViagens(tipoBaloes balao[], int *contBalao, int *contViagem... ^ program.c:257:224: warning: unused parameter 'lAlterar' [-Wunused-parameter] ...int *contLB, int *contLC, int *preco, int *totPreco, char *lAlterar){ ^ 19 warnings generated.
Why? - Thanks for the input.
how do i turn that on? it showed me 0 warnings
That's a widely used idiom that allows you to "call" your function-like macro just like you'd call a normal function. Consider this piece of code if (/* condition */) ERROR("error"); else /* do something else */; It looks OK on the surface, but it won't compile with your version of the macro. Compiler will complain about "orphaned else". This happens because the trailing `;` after `ERROR("error")` is not regarded as part of `{ ... }` compound statement from your macro. The trailing `;` is treated as an independent empty statement. This means that `ERROR("error");` is actually *two* statements, not one. Presence of two statements in "true" branch of `if` forcefully terminates that `if` and makes the next `else` orphaned. The compiler sees it as if (/* condition */) { /* your macro body */ } /* empty statement */; else /* do something else */; Obviously, that `else` is orphaned. In order to make this code compile you have to remember to never put a `;` after your macro if (/* condition */) ERROR("error") else /* do something else */; or you have to remember to always enclose your macro into an extra pair of `{ ... }` if (/* condition */) { ERROR("error"); } else /* do something else */; This is inconsistent and inconvenient. But if you use the `do { ... } while (0)` version of the same macro, the original code will compile "as intended". The unique property of `do/while` cycle syntax in C is that it requires a `;` after the `while`. That trailing `;` is a part of the `do/while` statement. The `do/while` statement "swallows" that trailing `;`. This means that `ERROR("error");` still represents only one statement. The `if` remains intact and `else` does not become orphaned. This `do { ... } while (0)` trick allows you to write proper function-like macros, which you can "call" just like ordinary functions, without having to worry each time whether you have to put a `;` after the "call" or have to omit it. ===================== It should also be noted that in your particular case you can "pack" your entire macro body into a single expression by using "comma" operator. E.g. you can define it as #define ERROR(PHRASE)\ (\ fprintf(stderr, "Fatal Error %s occured in %s, line %d\n", PHRASE, __FILE__, __LINE__),\ exit(2)\ ) That will eliminate the need for any compound statements. The macro will behave nicely with regard to `;` without forcing you to resort to `do { ... } while (0)` trick.
That depends. What are you using to compile your code?
But why are we comparing ch to EOF if we are working backwards? Will EOF return -1 if it reads past the beginning of a file, also? Edit: Meant "will getchar (and similar) return -1 if reading past the beginning". 
Bollocks if I know. I feel like there would be a better way to print a file in reverse.
Can 64 - 107 be summarized into a general use case? The way the `map_set` function currently works is three separate cases: * Where the dictionary has no elements. * Where the dictionary has elements, traverse through each element and compare the insertion's key to the element's key. If they are the same then replace the value with the new insertion value. * Where the dictionary has elements and the insertion key doesn't exist, add a new key at the end. Can this logic be abstracted or condensed? Also, is the underlying structure of a linked list the best way to implement a dictionary? Or is there some better structure to use? One more question. Sort of a reddiquette question. If I have follow up questions should I post them in the comments? Or should I add them to the original question with a "UPDATED" or "ADDITIONAL" label? What's the best way to ask a followup?
Some text files in DOS end with the EOF character. This is not an EOF signal from the operating system, it's just a byte in the file. The code does not print this byte if it encounters it, since it would be meaningless to have such a byte at the beginning of its output.
http://pw1.netcom.com/~tjensen/ptr/pointers.htm
Read your compiler's documentation.
Well, there is a fundamental difference between creating a new key/value pair and inserting it into the map, and just changing the value in an already existing key/value pair. You could avoid the special case when the dictionary has no elements by using a [sentinel node](https://en.wikipedia.org/wiki/Sentinel_node) or a similar idea, if you think that's desirable to do. A linked list is not an efficient way to implement a dictionary. Better data structures include [hash tables](https://en.wikipedia.org/wiki/Hash_table) and [binary search trees](https://en.wikipedia.org/wiki/Binary_search_tree) (especially self-balancing binary search trees, such as a [red-black tree](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree)). Follow-up questions will get the most visibility if you post them as new questions. If you do this, it would be nice to link to your previous posts to help people catch up if they didn't read your earlier questions.
I think I've handed that problem with the code I've written [here](https://github.com/franklinchou/datstruct/blob/master/dict/dict.c). I think it solves the memory problem. **EDIT** I'm not sure that the `next` pointer is ever appropriately assigned. 
Fantastic. Thank you!
*C Programming: A Modern Approach, 2nd Edition* by K.N. King is comprehensive as fuck (over 800 pages), but is still easy to understand and has loads of examples, diagrams, etc. This is basically a college level text book on C. Everyone always recommends the classic K&amp;R book, but it's very short and starting to show its age with some of the syntax and ideas, imo. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Control-Z**](https://en.wikipedia.org/wiki/Control-Z): [](#sfw) --- &gt; &gt;Control+Z is a [control character](https://en.wikipedia.org/wiki/Control_character) in [ASCII code](https://en.wikipedia.org/wiki/ASCII_code). It is commonly used as a __[substitute](https://en.wikipedia.org/wiki/Substitute_character)__ (__SUB__) character. It is perhaps best known as the [keyboard shortcut](https://en.wikipedia.org/wiki/Keyboard_shortcut) in [Windows](https://en.wikipedia.org/wiki/Microsoft_Windows) applications for the [undo](https://en.wikipedia.org/wiki/Undo) command. It is also used to signal an [end-of-file](https://en.wikipedia.org/wiki/End-of-file) on some [operating systems](https://en.wikipedia.org/wiki/Operating_system). &gt;Strictly speaking, Control+Z is not a [printable character](https://en.wikipedia.org/wiki/Printable_character) but a code for control purposes, though it is sometimes rendered by two characters as ^Z. It is generated by pressing the Z key while holding down the Ctrl key on a [computer keyboard](https://en.wikipedia.org/wiki/Computer_keyboard). &gt;In many GUIs and applications Control+Z can be used to [undo](https://en.wikipedia.org/wiki/Undo) the last action. In many applications earlier actions than the last one can also be undone by pressing Control+Z multiple times. Control+Z was one of a handful of [keyboard](https://en.wikipedia.org/wiki/Computer_keyboard) sequences chosen by the program designers at [Xerox PARC](https://en.wikipedia.org/wiki/Xerox_PARC) to control [text editing](https://en.wikipedia.org/wiki/Text_editor). Presumably these particular [keystrokes](https://en.wikipedia.org/wiki/Keystroke) were chosen because of their location on a standard [QWERTY keyboard](https://en.wikipedia.org/wiki/QWERTY_keyboard), since the Z (undo), [X](https://en.wikipedia.org/wiki/Control-X) (cut), [C](https://en.wikipedia.org/wiki/Control-C) (copy), and [V](https://en.wikipedia.org/wiki/Control-V) (paste) keys are located together at the left end of the bottom row of the standard [QWERTY](https://en.wikipedia.org/wiki/QWERTY) keyboard. &gt; --- ^Interesting: [^Graz ^Entertainment](https://en.wikipedia.org/wiki/Graz_Entertainment) ^| [^End-of-file](https://en.wikipedia.org/wiki/End-of-file) ^| [^Metropolis: ^Suite ^I ^\(The ^Chase)](https://en.wikipedia.org/wiki/Metropolis:_Suite_I_\(The_Chase\)) ^| [^End-of-transmission ^character](https://en.wikipedia.org/wiki/End-of-transmission_character) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cna55bo) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cna55bo)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Returning a `struct void *` as an opaque pointer is strange to me; why not just return `struct threadpool_t *`? You already forward-declare `struct threadpool_t` in `thread_pool.h` without leaking information about its structure (and not using the declaration at all), so why not this function signature: int threadpool_shutdown(struct threadpool *, int flag); The `_t` suffix in type names is usually used for system typedefs and should be avoided in other code. (Posix and Linus have something to say about this.) Please either use `struct threadpool` or `typedef struct threadpool threadpool_t`, with a strong preference for the former. Your API naming is all over the place: void *init_threadpool(int num_threads); int submit_job(void *pool, void(*function)(void *), void *argument); int threadpool_shutdown(void *pool, int flag); That's not very compartmentalized. For consistency, I'd do something like this: struct threadpool *threadpool_create (int num_threads); int threadpool_submit (struct threadpool *, void (*routine)(void *), void *userdata); int threadpool_destroy (struct threadpool *, int flag); The same is true for your shutdown type defines. The global `q_name` variable strikes me as odd. Each time you create a new threadpool, its value will be clobbered. Why not store this inside your threadpool struct? You don't need to cast the result of `malloc` in C because a `void *` will promote to any type. In line 244, why not just `break`?
If performance is your biggest concern, then one of the standard CS answers applies here: "It depends." You have to investigate what the compiler is going to do with your code, and how the compiled code will run on your processor and memory. [This can be extremely sensitive to minor differences](http://www.reddit.com/r/programming/comments/2nqrsr/cc_tip_how_to_loop_through_multidimensional/). But that's if we're talking about squeezing every ounce of performance possible from your code. Unless you're doing scientific processing on gigabyte-sized or terabyte-sized datasets, or something equally large, I would not bother with this level of optimization. Instead, I would optimize for *whoever has to maintain your code in the future*. What that means is, write everything in the simplest, easiest-to-understand way possible. If it's *just* a simple loop that iterates over an array doing a simple operation on each element, then doing `pointer++` is fine. But I almost always write my loops using `pointer[i]`. For debugging, I don't really like modifying the pointer variable every time, and I like knowing how far in to an array I am; iterating with `pointer[i]` instead of `pointer++` gives me both of those. And in general, I prefer implicit pointer dereferencing to explicit. Sure, you can write `(*pointer).foo` instead of `pointer-&gt;foo`, and `*(pointer + i)` instead of `pointer[i]`, but I think these are clumsy and harder to understand, and I prefer not to treat loops any differently unless I absolutely have to.
Don't use IPC for communication within a single process. Also, your unique ID scheme will fail because all processes will see the same sequence from rand().
What you don't get? For each new tile, you have to: 1. Allocate space for the new tile (line 18)... 2. Point the new tile to the old head (line 24)... 3. Set the new tile as the current head (line 25)... It is inside the loop because it must be done for each new tile. You can't do what you proposed because you are never pointing the tile to the old head. You are pointing the new tile to itself, which doesn't make a lot of sense. If you insert 4 spaces before each line, Reddit will format your code better and more people will bother to help you: typedef struct _tile { int x; int y; struct _tile *next; }tile;
#1 - The two lines you propose end up making value and value-&gt;next point to the same object. You should look at some pictures that illustrate how linked list insertion works. This q indicates you don't understand, at a high level, what you're trying to accomplish. #2 - Is your point that head ends up being the last value - so why can't I just assign it once? If so, the reason is that when you create a new value, you have to set its next field to the previous value of head. Head has to be updated each pass through the loop so that the subsequent iteration will have access to the previous value. Again, I think you need to go back and understand linked lists at a high level before trying to taking on the details of implementing them. Look at lots of pictures/diagrams. As to why it's printing out the numbers backwards - that's because you're adding successive numbers to the _front_ of the list. You could add them to the end of the list, but without the details of your assignment, I can't say for sure what you need to do. The fact that your program produces any output at all is happenstance. Here are some issue to consider: - You don't explicitly initialize i, you're lucking out that it's being initialized to zero. - Your while loop at the end should start with head. Currently, value is the same as head after you get done building your loop. This might not continue to be the case as your program evolves. - Pick a better name for the value variable (e.g. newTile or newHead) - a more descriptive name would help clarify your code. - Don't cast the return value of malloc - unnecessary casts are a bad habit. - Eventually, you should refactor your program into helper functions. E.g. a function that adds tiles to the list, a function that prints the list, ... This won't be trivial, first get your program working. A function that adds a tile to the list will need to modify the head of the list. This means it will either have to return the new head as its result or you will have to pass it a tile** (pointer to a pointer) through which it can return the new head. 
This make sence. I understand now HiramAbiff. You explain the exact thing that i want. Thank you and i will surely go through the diagrams and accomplish this high level.
Thank you. I will surely keep it in mind to add 4 spaces. I know i might look stupid asking the question.
submit_job doesn't add a pointer to the message queue. It copies the structure itself into the message queue and it's a blocking call. If I had passed it as mq_send((const char star) &amp;&amp;j, sizeof(star j), 0), this would copy the pointer into the message queue and this would be wrong. Will definitely take your suggestions and modify the code. Also going to ditch mqueue soon. I just used it because I thought it would be different from other threadpool implementations. Looks like it's not worth it. 
Except on OpenBSD where `rand()` is an alias for `arc4random()`. Also, never use `rand()` when you need any assumptions about the random numbers it returns.
The first is legal and declares `stream` as a restricted pointer. The second is illegal and should cause a compiler error. The `restrict` keyword may *only* be applied to pointers, which is why the second form is illegal.
The command I used to compile: &gt;cl -Zi ..\src\cstore.cpp zdll\lib\zdll.lib user32.lib shlwapi.lib propsys.lib ole32.lib shell32.lib oleaut32.lib output: /out:cstore.exe /debug cstore.obj zdll\lib\zdll.lib user32.lib shlwapi.lib propsys.lib ole32.lib shell32.lib oleaut32.lib cstore.obj : error LNK2019: unresolved external symbol gzread referenced in function "int __cdecl decompress_one_file(char *,char *)" (?decompress_one_file@@YAHPEAD0@Z) cstore.obj : error LNK2019: unresolved external symbol gzclose referenced in function "int __cdecl decompress_one_file(char *,char *)" (?decompress_one_file@@YAHPEAD0@Z) cstore.obj : error LNK2019: unresolved external symbol gzopen referenced in function "int __cdecl decompress_one_file(char *,char *)" (?decompress_one_file@@YAHPEAD0@Z) cstore.exe : fatal error LNK1120: 3 unresolved externals
Why are you invoking `cl` directly? If you have that installed, presumably you have all of Visual Studio? Just set up the project there and let it deal with invoking the compiler. It's a very competent IDE and it's *free*, so it's not like anyone can complain about you using it.
I'm not a Visual Studio user, but your intuition seems to be mostly correct. I don't expect game developers to care particularly about the difference between C and C++, so treat what they do with a grain of salt. 
&gt; I'm making a windows program in mostly C with a little bit of C++ (so it's all compiled as c++) You are not making a program in C; you are making a program in C++. If you compile with a C++ compiler (or as C++), you are compiling C++ code, not C code. There is a large difference between these two. For instance, C++ mangles symbols which can lead to the kind of linking errors you experience. Please only compile code that is actually C++ as C++.
I'm pretty sure he addressed this in a Q&amp;A. He compiles the code as c++. He also uses some C++ isms that may not directly compile with a c compiler but you can pretty much figure them out and convert to C99.
You are confusing the EOF *signal* returned by getchar (typically -1) with the EOF *character* used by DOS, 0x1a. They are not the same thing.
"restrict" is a type qualifier, like "const". Each level of pointer level (including the 0th) can be separately qualified. The type qualifier acts to the left, for example: char * * const a; char const * * const b; char const * const * c; except in the case where there is nothing to the left in which case it acts to the right, so these are equivalent: const char * * const b; char const * * const c; However, "restrict" cannot act on the 0th level (as it's not *really* a pointer), so these are errors: restrict char * * const b; char restrict * * const c;
Given int a, b, c; So, this is a pointer to an int pointing to a: int *p = &amp;a; And this is a pointer to a const int also pointing to a: int *cp = &amp;a; So, setting a to 2 like this: *p = 2; works, and like this: *cp = 2; is an error. This is a constant pointer to an int: int * const pc = &amp;a; and p is as before. So, setting p to point to b like this: p = &amp;b; works, and, trying the same on pc: pc = &amp;b; is an error.
I have no idea how to do multiple code blocks. int *const pc = &amp;a; Can not be changed? It will always point to a? int const *pc = %b; Can be changed, but points to a constant int?
It was supposed to be &amp;. Thanks for explaining, I think it's a bit clearer. How do I inline code on here?
`I swear` I've `tried` that in the `past` and it didn't work. Maybe something changed recently? I do know that it works with other forms of markdown, say StackOverflow.
He's writing c++ code without most if the c++ features. The only thing that I noticed he uses is the ability to create an instance of stuct without typing stuct before the declaration and without typedef.
No I'm not. EOF is not a single byte value. If it were, you could NEVER write the values for 0 to 255 to a file. It's a simple concept. How on earth can you count to 1000 in a binary file, if one of the bit patterns in the range of 0 to 255 triggers EOF when your OS encounters it? It doesn't. It's not an actual *char*.
Again, the DOS EOF *character* (i.e. 0x1a) is not the same thing as getchar's EOF *signal* (i.e. -1.) They are completely unrelated. Reading the DOS EOF character *does not* trigger the EOF signal. When reading such a file, getchar() returns the data in the file, then 0x1a (the last byte in the file,) then the EOF signal (-1.) [This page](http://homepage.ntlworld.com/jonathan.deboynepollard/FGA/dos-character-26-is-not-special.html) goes into more detail on the matter. EDIT: If the code in that page is to be trusted, at least one DOS C library actually does return EOF when 0x1a is encountered. Make of that what you will.
You putting a specific byte value into your file at the end does not actually make it EOF. I mean, look at your link, it's right at the top: &gt; MS-DOS didn't have an End-Of-File character of any sort. Did you even read it?
EOF isn't a character you can actually read. It doesn't hold a valid byte value. It is defined by the standard as a negative number, and it cannot be represented by the other values of a *char*. That's a requirement of the C standard. It can be any negative value, but it cannot be a valid *char*. Why? Because it would break file streams when it was encountered, making your program bug out. That's why you have to use an int to store the value of anything you're comparing to EOF. Seriously, all you have to do is actually read the sources you're citing: &gt; In the C Standard Library, the character reading functions such as getchar return a value equal to the symbolic value (macro) EOF to indicate that an end-of-file condition has occurred. The actual value of EOF is system-dependent (but is commonly -1, such as in glibc[3]) and is unequal to any valid character code. Block-reading functions return the number of bytes read, and if this is fewer than asked for, then the end of file was reached. See that? *"unequal to any valid character code"* I'm not just making things up here. It's how the Standard defines it. Furthermore, a programmer could write his program to interpret a specific set of bytes to mean he has reached the end of file, and to stop trying, but that still isn't actually EOF. EOF is an OS marker/indicator, and your standard C IO functions aren't going to encounter it. The OS will pass on "EOF was reached" to your program when you try to read past the actual end of the file. It's not going to send this same signal along just because you happen to *getchar* a 0x1a.
Since you are clearly having reading comprehension issues, I will very generously explain it to you yet again. As I said in my very first comment, "This is **not an EOF signal from the operating system,** it's **just a byte in the file.**" So again: the 0x1a at the end of the file is *just a normal byte* in the file, which *by convention* designates the end of the file in DOS, and some DOS C libraries apparently even go so far as to enforce that convention by converting that character to -1 (see the code examples in my link.) Read very slowly and carefully: this has *absolutely nothing* to do with getchar() returning EOF, and by extension, *absolutely nothing* to do with the C standard.
His code opens in binary mode. Most implementations don't actually care about the differences between text and binary modes however. It's really a bad way to check for end of file; that's what *feof* is for, assuming they actually use it correctly. tl;dr - bad code is bad.
I did have Wall, didn't think to actually run it through gdb though. Normally keep that for some harder things.
&gt; A bunch of spots in my array are printing out as zero, and I can't quite figure out why... For integers `a` and `b`, one of `a=b`, `a&lt;b` or `a&gt;b` is true. Your code only accounts for one of the three (though it appears that equality isn't needed in this case) because `a&lt;b` is a logically equivalent expression to `b&gt;a`.
I wonder what made you to use `FILE *` pointer specifically in your example. Considering that standard `FILE` type is intended to be opaque to the user-level code, I don't immediately see a context in which it can be meaningfully declared as a restricted pointer.
It's the "else if" you have. If you take that out your code will work properly. #include &lt;stdio.h&gt; int main(void) { int num1, num2, sums[30], count, i; puts("data:"); scanf("%d", &amp;count); for (i = 0; i &lt; count; i++) { scanf("%d %d", &amp;num1, &amp;num2); if (num1 &lt; num2) { sums[i] = num1; } else{ sums[i] = num2; } } for (i = 0; i &lt; count; i++) { printf("%d ", sums[i]); } return 0; } 
Since you read the number of pairs on the first line you can declare your array to be the appropriate size instead of an arbitrary length of 30. So your program could start with something like: int lines; scanf(%d, &amp;lines); int results[lines]; ... But really it isn't necessary to use an array since you can print the results as you "compute" them. Here is how I would do it -- it may not be very elegant: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char *argv[]) { /* read first number. */ int lines; if (scanf("%d", &amp;lines) != 1) { fprintf(stderr,"error: could not read record count from first line of file.\n"); exit(0); } int c = 0; for (; c &lt; lines; c++) { /* read a pair of numbers to compare. it is an error for scanf() to return anything but 2. scanf() also nicely disregards any additional spaces between tokens. */ int n1, n2; if (scanf("%d %d", &amp;n1, &amp;n2) != 2) { fprintf(stderr, "error: invalid file format around line %d\n", c + 2); break; } /* print the lowest number. before that though, we print a space if this is NOT our first result. if it is our first result we DO NOT print a space. we determine if this is our first result by checking if c == 0. */ printf("%s%d", c == 0 ? "" : " ", n1 &lt; n2 ? n1 : n2); } /* if c != 0 then we've generated some output which should be terminated with a new line. */ if (c != 0) printf("\n"); exit(0); } 
It was for a specific challenge, it wanted it this way, or at least it works. Obviously, if it was up to me, the array would be of variable size and results printed on the fly.
Okay -- fair enough. Consider: if num1 &lt; num2, do you have to check if num2 &lt; num1? Probably not. As already pointed out, that is where your bug is. You could eliminate it all together by simplifying it to: if (num1 &lt; num2) { sum[s] = num1; } else /* (num2 &lt;= num1) */ { sum[s] = num2; } 
I don't want to deprive you of the satisfaction you'll get when you figure this out, so I'll start by giving you some small hints. What is sizeof(tail[0])? What is sizeof(tail[1])? What is sizeof(tail[2])? That should help you understand what the tail[lineno] = line; actually does. If the lightbulb still hasn't gone on, find a rubber duck and explain to it, in detail, what mygetline does. Once you figure out your current issue, for extra credit, you might want to think about how it's possible to do this _without_ shifting all the previous strings each time you get a new string.
Probably because he/she/it expects it to do something else. Good job being an ass hole from you part though.
A question of "why did they expect it to do something else" is answered with "probably because they expected it to do something else"? Hmm... This might be an A++ approach to C programming in some liberal arts college, but I doubt this is what the OP needs.
There are always different ways to help out a beginner, mocking them is never helpful.
Dammit beat me to it :-) I'll typed it already so I'll post it here: you could put the int and string in a [tagged union](http://en.wikipedia.org/wiki/Tagged_union) and pass it that way. Something like this: typedef union { int int_value; char* string_value; } value_union; struct tagged_union { char type; value_union value; } Then make a single create function that takes this tagged union.
Here's my preferred way to do it: [C Object Oriented Programming](http://nullprogram.com/blog/2014/10/21/). In short: put a function pointer in your struct to create a virtual function. 
The basic idea of run-time polymorphism is that at the moment of creation the object's type has to be specified explicitly. You have to know exactly what you are creating. One the object is created, you send it away it live on its own as an abstract object that exhibits polymorphic behavior. I.e. polymorphism begins *after* object's creation. (Yes, there's a concept of polymorphic creation, "virtual constructor" etc., but there's no reason to see it as relevant to your question. It is not related.) This is exactly why your desire to have one `create` function instead of two doesn't seem to make much sense. No, actually, you *have* to have two different dedicated creation methods for `int` and for strings. Why would it suddenly be "nicer" to have one is not exactly clear to me. Why do you want to have one function? What's wrong with two? Where exactly have you seen something like that being done with one function and how? Show us an example maybe? You can, of course, merge two functions into one, by passing the type as a `synType` parameter and using a `uintptr_t` parameter as a universal "data" value, but this is just syntactic sugar. And it has nothing to do with any polymorphism. 
You almost certainly want separate `create` functions, no matter how OOPy this gets. This isn’t C++; you can’t overload names easily and shouldn’t try too hard to. (Hell, even in C++ you’d still have to have a separate ctor per type in the end.) `_Generic` is fun until you realize how incredibly limited it is, and it’s C11 so you limit your compatibility quite a bit if you use it. Final note on this: The value `0` fucks up any chance you have of making a single ctor a good idea. If you have `makeCalcNode(0)`, then that could be the integer `0` or a `NULL` pointer `0`, and there’s no way to tell what the caller intended unless they give you an explicit cast, in which case you may as well just make different ctors. This quandry is exactly why C++ added the `nullptr` keyword, of which C hath none. Polymorphism is almost entirely about what happens *after* the object has been initialized, and in fact most languages/schemes are neurotically careful with pre-constructed or post-destructed memory because of the chaos that results otherwise. If you want to make *behaviors* polymorphic, that’s rull easy. (E.g., your `synType` field is probably the un-polymorphic sticking point of this whole exercise, and you could remove that and use a vtable instead to un-stick it.) If you want to make polymorphic factories that produce polymorphic objects with single or generated parameters, that’s also rull easy but probably not what you want. So in general in an OOP language, you’d have class calcNode { calcNode *prev; calcNode() : prev(0) {} virtual int /*?*/ doSomething() const; // VIRTUALS/BEHAVIORS }; class intCalcNode : public calcNode { int value; intCalcNode(int v) : calcNode(), value(v) {} // OVERRIDES/VIRTUALS }; class strCalcNode : public calcNode { const char *value; strCalcNode(const char *v) : calcNode(), value(v) {} // OVERRIDES/VIRTUALS }; —note that there are *different ctors* for the different sub-types of calcNode, but they call into calcNode’s ctor for common init. And then under-the-hood that gets rendered as struct intCalcNode; struct strCalcNode; struct calcNode_vtbl { void (*dtor)(struct calcNode *); int (*doSomething)(const struct calcNode *); // pointers to any other abstract methods/functions/fields }; inline void calcNode_dtor(struct calcNode *p) { (void)p; } struct intCalcNode_vtbl { struct calcNode_vtbl super; // any additional virtuals for intCalcNode }; struct strCalcNode_vtbl { struct calcNode_vtbl super; // any additional virtuals for strCalcNode }; struct calcNode { struct calcNode_vtbl *vtbl; struct calcNode *prev; synType type; }; struct intCalcNode { struct calcNode super; int value; }; struct strCalcNode { struct calcNode super; const char *op; // Or even char op[] }; in a header, and you’ll probably want to declare the ctors as struct intCalcNode *newIntCalcNode(int k); struct strCalcNode *newStrCalcNode(const char *str); (or `intCalcNode_new(int k)`, but come up with some normative nomenclature to keep yourself sane.) Example implementation: // in intCalcNode.c: int intCalcNode_doSomething(const struct intCalcNode *); /* ^ Replaces synType; make subclass overrides if you have more than one * thing with an int value. */ const struct intCalcNode_vtbl intCalcNode_VTBL = { // C99 syntax mostly for clarity .super = { .dtor = calcNode_dtor, // No need to override the dtor; nothing else to do .doSomething = intCalcNode_doSomething // Abstract methods get NULL or 0 for their value. // Overrides happen by using a different function pointer than the superclass. }, // etc. }; struct intCalcNode *newIntCalcNode(int k) { struct intCalcNode *const rv = (struct intCalcNode *)malloc(sizeof(*rv)); if(!rv) shit_yourself(); rv-&gt;super.vtbl = &amp;intCalcNode_VTBL.super; rv-&gt;value = k; return rv; } Once you have an `intCalcNode *`, you can make it into a `calcNode *` via `super`: struct calcNode *p = &amp;newIntCalcNode(k)-&gt;super; or just make automagic static cast macros which I can give you but they can get a bit complicated xor verbose. You can detect what kind of doojobber you have by looking at the `vtbl` member of `calcNode`: inline bool sameType(const struct calcNode *a, const struct calcNode *b) {return a == b || a-&gt;vtbl == b-&gt;vtbl;} inline bool isIntNode(const struct calcNode *a) { extern const struct intCalcNode_vtbl intCalcNode_VTBL; return a-&gt;vtbl == intCalcNode_VTBL; } inline struct intCalcNode *toIntNodePtr(const struct calcNode *a) {return isIntNode(a) ? (struct intCalcNode *)(void *)a : 0;} although full dynamic-casting takes a little more involvement. And of course, to invoke a virtual method: int v = node-&gt;vtbl-&gt;doSomething(node); which would be roughly equivalent to int v = node-&gt;doSomething(); in C++. So just paste in an intCalcNode- or strCalcNode-like group of structs and functions for each kind of operation/syntax?, and you can handle them in their own files, in their own ways, without needing to change the calling code except for creation (which needs to be different code anyway).
Initialize your variables before you use them. Use *and* instead of *or* for your *while* loop.
Why and instead of or?
OOOOOH. I get it now. Rofl. Wow. So every element in tail is pointing to the same line, which is dynamically changed each time I call getline. Lol. Spend a long time bashing my head on this.
Doesn't fgets need one more for the null? As for your second question, it appears to be working for me. I could go back and rewrite it, but it seems to work fine...
&gt; Doesn't fgets need one more for the null? `fgets` is aware of zero terminator character. `fgets` always reads at most `n-1` bytes to leave room for zero terminator character. Which means that if your buffer size is `200`, you should pass `200` to `fgets`. It will know internally that it can read no more than `199` characters. If your buffer is an immediate array, you should normally pass `sizeof buffer` to `fgets` instead of specifying "magic constants" in the argument list (see here http://en.cppreference.com/w/c/io/fgets, for example). &gt; As for your second question, it appears to be working for me. I don't know what you mean by "working". "Working"/"not working" is not a meaningful description of program's behavior. One more time: it the files have different number of lines in them, in the end the last line of the shorter file will be printed over and over. It does not seem to make any sense. If that's what you want, then fine. But your original post appears to indicate that this is *not* what you want. What kind of output are you supposed to produce in cases when one file has less lines that the other?
Fuck it. The program is trash, I'll start from scratch.
Yes, you are right, I stand corrected! Thanks! The solution you posted is definitely how I would tackle this.
It depends a little on the specifics of how you've implemented your linked list, but *usually* a linked list is a structure that contains a pointer to the first element (head) of the list. For an empty list, you would return a structure where that pointer is the null pointer.
Hate to say it, but C did not have this kind of thing in mind. This is the whole reason C++ was invented. I have to deal with similar stuff at work, and there's no good solution. We simply have multiple "create" functions. It's not such a big deal because processing out the data you'd need in order to call the create functions is different enough that it's no extra effort to call different functions along the way. If you still want to have a single "create" function, you could have it take in an enum indicating the type you want to create, and a union containing the data. (I don't think I've ever written or used a function that takes a union as a parameter, but it's certainly legal.) I think that's a better option than taking in a `void*` or using variadic arguments.
* Check argc before "to_find = *argv[2];" (Note that when argc == 2, to_find is going to be gibberish...) * Initialize files * I think you need to consider that argc/argv will have *all* of the arguments. Note: "fopen(argv[files]" is probably not exactly what you intend to do with that. ([see more here](http://crasseux.com/books/ctutorial/argc-and-argv.html)) I think you need to spend some more time on arrays.
 to_find = *argv[2]; Have you thought about what this line does if argc == 2? You might want *argv[1] instead. count++; You haven't initialized count, so it could be anything when this line first runs (but will probably be 0). count = 2; Why are you starting count at 2? Should this be files = 2 instead? while (files &lt;= argc) { files hasn't been initialized yet, but is probably 0 at this point. if ((file = fopen(argv[files], "r")) == NULL) { argv[0] is just the executable of your program. This is almost certainly not what you want. Try fixing these things and then give us an update
/u/dragon_wrangler has summarized it well. But to touch on this one point: When argc == 2, argv only has valid elements at indices 0 and 1 (index 2 points off to the land of wind and ghosts). So that's why I say check argc *before* you do anything at all with argv. &gt;Can you explain what I'm doing wrong with arrays? From above, trying to index an array beyond where it is valid can cause lots of problems... Later you start looping over files (at presumably 0) but you actually want to start wherever the input arguments expect to start listing files. &gt;I initialized files and am checking argc == 2 like you said, but still getting the same output. Don't concentrate so much on quickly changing a few things and expecting the whole program to work. Spend time on the small things that were wrong and find out why they were wrong -- even if that means taking a step back to write a simpler program to dig into that one point.
There is a difference between declaring a string in each way. Namely, usually when you refer to a string literal, it is not stored on the stack but another part of the processes memory which is read only. Therefore, `char *x = "Hello world\n";` declares a pointer pointing to this memory location. But, when you declare it like an array, as in `char x[] = "blah";` the character array is saved on the stack. Therefore, you return `x` in the form of a pointer to some stack space in the frame of that function. So when the function returns, the stack pointer moves back, and then reading it later is undefined behavior (it's probably the case the memory was reused in the `printf` call). 
Thank you for that explanation. I think i understand better now. One more question, when you pass a string array to a function. Does it make a difference if I pass it as? some_function( char *x) or some_function( char x[]) ? My guess is no, because arrays decay to pointers in functions, but just wanted to know whether there is a recommended syntax.
Valid statement about occasionally taking a step back. Thanks.
This doesn't make a difference, but it does if you pass a multidimensional array since only the "innermost" decays into a pointer. As for which is better stylistically, I don't have an opinion, perhaps others do.
There's no difference. However, keep in mind that this is not what is normally referred as "array decay" from the pedantic standpoint. "Array type decay" is implicit conversion of array *objects* to pointer type in expressions. "Array type decay", again, happens in *expressions*. It is not formally applicable to *declarations*. What you have in your case is an array parameter *declaration*. It is automatically replaced with a pointer declaration by the compiler. This replacement is not formally a part of "array type decay". ================ There's no "recommended" syntax here. Develop your own preferences and follow them. Being *consistent* is what's recommended. Everything else does not matter much. Now, having said that, keep in mind that these syntaxes behave differently once you start applying additional qualifiers to your pointers. In classic C89/90 you can write void foo(char *const x); There's no way to express the same constness in array variant in classic C89/90. In C99 it can be done as void foo(char x[const]); which might look a bit confusing to an unprepared reader. On the other hand, when you use array version in C99 you have an option to declare your parameter as void foo(char x[static 42]); which works as a hint to the compiler that your array has at least 42 elements in it (the idea is to facilitate generation of data prefetching code and such). There's no equivalent feature for pointer declaration. 
Is a linked list the same as a "binary tree?"
Nope. A linked list is a series of elements - you can think of it as a long row of things. They can be arbitrarily long, and generally must be searched one at a time. They're easy to insert elements into and remove elements from. A binary tree is arranged a little differently. The first element has two "branches", one pointing to values less than the middle, and the other branch points to values greater than the middle. Each sub-branch is arranged the same way. You would follow the branches until you reach your target value. Binary trees must be carefully "balanced" to be effective, but can guarantee that you'll find a match in a specific number of tries - and generally not very many, because every branch cuts your remaining elements by half. 
Thanks!
I don't understand. Do you mean you have the characters \ and t in the text file? Those will get read as \ and then t. You never check for those two character one after another. You are checking for the tab character (in ASCII this is 9). I'm not sure what your intended behavior is. Can you post the file you're piping in and tell me what you want the output to be?
Oh, I see. I thought I had been counting my \n but I wasn't, I had just hit enter after i typed \n in my text document so it appeared to count them but it wasn't. So, the only way to count new lines, tabs, blanks etc in a text document is to actually enter them by hitting tab or hitting enter to make a new line, and you can't ever type in \n or \t ? Makes sense, as the ASCII values would be whatever the value is for \ and n or t. 
As is, the code should count tabs. I'm assuming by "doesn't seem to recognize \t" you mean doesn't recognize tabs - _not_ the two character sequence - backslash followed by a 't'. Apart from that, you should ensure there actually are some tabs in your input file. As /u/wgunther already pointed out, your editor might be deceiving you. 
I thought what I wrote would increment if it saw \t in a text file. It doesn't, which is now clear to me. it DOES count an actual tab. My misunderstanding was that it would count \t as a tab, \n as a newline when they are typed as such in a text document. Thanks everyone. 
BigPete has a good answer. If C had 'until' like ruby (my other language), I would have written it `until (f1_done &amp;&amp; f2_done)` - I actually thought it that way. My C idiom translator just turned it from `until (x)` to `while (!x)` on the fly. :-)
I have an infinite amount of questions about C, but don't want to bug people with them.
I'm currently reading this one you can't go wrong with it. If you go over it you will have a great grasp over all the basic concepts and even more, the exercises at the end of each chapter will help you a lot.
Also compile with -Wall (with full warnings).
I often go "full retard" and use "-Wall -Wextra -pedantic". (Though I get pretty annoyed when it whines at me for not using argc and argv. :P)
So many things can go wrong with C, especially when you are a beginner. So my best advice is : be paranoid, patient and log everything ! You could simply use printf() to log your inputs, branches etc... and make sure it is safe and alright before writing any more code. Your first statement is "to_find = *argv[2];". log it: printf("to_find : %c\n", to_find); If it prints what you expect, move on, if not, there is one issue there that you need to understand and fix.
No reason you can't do the GUI in C with GTK. It isn't the prettiest GUI toolkit back it works cross platform (for the most part anyway). 
Pretty on Windows, or pretty in the API sense? 
I recommend you look at some other cross platform C projects for inspiration, e.g. the source for Lua comes to mind. If you are looking for a more modern C compiler, you might want a more modern build system too. The problem with Make is that it's just a dependency graph and rule matching. You still have to define all the rules. There are a lot that are implicit and it just works out of the box, but simple stuff like copying files during the build requires defining commands for those. Under unix, it's cp, but under windows it's xcopy. That's stuff you'll have to deal with in the Makefile and it's not ideal for cross platform. That's why tools like CMake were invented. I do use Make in some projects, but I try to look for something better when I can. 
There are different name spaces in&amp;nbsp;C. The name space for ordinary identifiers is separate from the name space for `struct` names (called "tags"), so you can use the same identifier to mean one thing when it is used as an ordinary identifier and a different thing when it is used as the name of a `struct`. The compiler can tell the difference because the name of a `struct` comes after the keyword "`struct`." Label names are in still another name space, and each `struct` or `union` defines its own name space for its members (which is why two different `struct`s can both have a member named&amp;nbsp;`x`, for example). &gt; **Follow up question:** How do the compiler know that the first instance of the node in main should be just *struct node* and not substitute *node* with *struct node*, resulting in *struct struct node*. A `typedef` is not a macro. It doesn't work by just blind replacement. A `typedef` defines a name for a type—it associates an ordinary identifier with a type rather than with a variable. The first declaration in the `main` function is not using the ordinary identifier `node`, because the identifier `node` there comes after the keyword `struct`, so the identifier `node` is a tag, not an ordinary identifier, and therefore the `typedef` is irrelevant.
It's confusing, don't do it. Stick with putting _t on either the tag or the type. Plus if you ever start doing C++ you'd be confused, as there the rules are different. Homework: Find out how they're different ;)
Thanks! The example in main was really stupid indeed, but the point was to try and clarify the things that confused me even further :)
Just one look at the author's usage of `strncpy` make one wonder if he knows what he's doing. Things like that always betray some people's incompetence with C language. (It is noted in the very first comment to the article as well.) K&amp;R C book is also guilty of abusing `strncpy` in its examples, but at least in K&amp;R the authors knew how to do it properly. They never forget to explicitly zero-terminate the buffer.
http://stackoverflow.com/questions/612328/difference-between-struct-and-typedef-struct-in-c In C++ you can do: struct my_first_struct{...}; and late use it as my_first_struct temp; struct my_first_struct temp2;
Oh, Cygwin is a good choice, but having to make it work is a little hard. I'm not be able to make GCC working, but I use it for ssh and other unix-like tools. Also, if you make GCC's Cygwin working on Windows, you have to add the cygwin.dll in order to be able to execute the program (I think it's so, I readed it not a long time ago).
It does. Per C99 "7.19.7.7 The gets function" &gt;`char *gets(char *s);` &gt; The `gets` function reads characters from the input stream pointed to by `stdin`, into the array pointed to by `s`, until end-of-file is encountered or a new-line character is read. Any new-line character is discarded, **and a null character is written immediately after the last character read into the array**. But keep in mind that `gets` is a useless broken function. It has been deprecated in C99. It has been completely removed in C11. Formally there's no `gets` anymore.
I have no idea how to do that, could you explain?
Just put four extra spaces in front of every code line. This turns &gt; int main() &gt; { &gt; foo(); &gt; bar(); &gt; } into &gt; int main() &gt; { &gt; foo(); &gt; bar(); &gt; }
Yeah, I've heard all about this before. `printf()` for debugging, use GDB. Just always forget to use them.
Have you tried compiling this code yet? It shows a bunch of errors that you'll need to fix. typedef struct userInputsAllegations }*userInputsAllegations; I would recommend you use a different name for the typedef of your struct. That will make it easier to understand. Most coding styles suggest using CamelCase notation for structures so they don't get confused with variables. Also, are you deliberately making userInputsAllegations as a pointer? If so, you'll need to update everywhere you use that type. counter &lt; statements Statements is a pointer. This should be counter &lt; *statements * (int)&amp;statements); This part of your malloc statement is wrong. You want to be multiplying by the number of statements, but this is casting the address of your statements pointer to an int. Try *statements instead. 
Agreed, shirking VS without a good reason seems unnecessary. * It's free * It's much easier to install than GCC/MinGW * It's a very competent IDE * It's a hell of a lot more fun than dealing with Makefiles * It will make things *drastically* simpler for other folks who may want to build your code or integrate it into their Windows-based apps * It's widely used in the business world I ship cross-platform software, and it's a pain in the ass on the *best* of days. If you want people to actually use this thing, don't make it harder than it needs to be.
Heed this advice, many times a file might not contain exactly what we think it contains and a binary dumper (like 'od') will clear that mystery right up. 
C++ is purposely designed not to conflict with C in this regard (to make it easier to write cross-compilable header files). This means that in C++ you can still do typedef struct Node { ... } Node; I don't see any compelling reason to add `_t` to struct tags in C. It achieves absolutely nothing. There's no conflict or confusion between struct tags and type names in C. 
No assumption is involved in this case. In standard C language constant `0` and `NULL` are always guaranteed to be equivalent in pointer contexts. While I personally prefer to use `NULL` in such contexts, it can always be replaced with plain `0`. The language guarantees that. The only reason I used `0` in the above code is to make it shorter - to avoid including an extra header file that defines `NULL`.
Alright, thank you everyone, we were asked to use gets in the current homework, I guess we'll learn later better input functions.
&gt; note: It's usual to put a _t on the stuct name to separate it from the typedef name to stop people being confused. Is your example an accurate illustration of the quoted sentiment (i.e., seen in the wild)? After reading your note, I was expecting the _t to appear on the typedef name, not the structure tag. I would expect the change to the structure tag to read _st or something, and would find _t on a structure tag counter intuitive. typedef struct node { int data; struct node* next; } node_t; or typedef struct node_st { int data; struct node_st* next; } node; And by "expect ... to read", I mean if I were skimming a source file. How prevalent is the form you've demonstrated (in your experience)?
Your go-to search for any library call should typically be for the man pages for that call. In this case, for instance, a search for "man 3 gets" yields: &gt; gets() reads a line from stdin into the buffer pointed to by s until either a terminating newline or EOF, which it replaces with a null byte (aq\0aq). No check for buffer overrun is performed (see BUGS below). http://linux.die.net/man/3/gets linux.die.net is actually a great source in general for C programming. 
On a mobile, please forgive crappy formatting. Install Visual Studio, and then the appropriate installation from [here](http://zeromq.org/distro:microsoft-windows). There are separate installers for 2012 and 2013. You should be good after that. Oh, and you can get the full install of Visual Studio Pro for free now, just download Community Edition and you should be good to go (there's a couple more steps if you want LightSwitch too).
VS understands makefiles? really? Do you have any documentation on this?
EDIT: I just figured it out. After doing what /u/NathanClayton said above, you have to include the header file into the project. To do that, just use [this] (http://stackoverflow.com/questions/15901285/visual-studio-2012-adding-new-header-file) StackOverflow link. After that it should work. Thanks a lot! ~~Okay, so I downloaded v4.0.4~~ ~~After installing it, and opening my project in Visual Studio, do I have to import anything into the project?~~ ~~I have to include "#include &lt;zmq.h&gt;" into the project, but where do I get zmq.h?~~ ~~Thanks for all your help so far!~~
thank you.
Learn C it's good for your character.
&gt; Alternatively, knowing the length of the source file can be helpful. I'm not sure how to go about getting the length. How would I do that? &gt; From there, if you want to follow your original idea, have a look at what fread and fwrite return : the number of bytes read/written. So then, I'd use how much bytes read/written and subtract it from the total bytes left in order to figure out how much to read/write again. &gt; Also, consider this : What happens when your source file is less than 10 bytes ? Well, according to the documentation for `fread()`, if a partial element is read, the file position indicator is indeterminate, but it will still return the number of objects read successfully, even if they're less than the count supplied. **edit:** &gt; Is C required ? using the shell's "cp src dest" seems great already :) This is actually a great point, and one I hadn't thought of. The only reason I'm trying to figure this out is that a similar exercise in Python was done, and I was wondering if I could replicate it in C.
 -&gt; http://msdn.microsoft.com/en-us/library/txcwa2xx.aspx
&gt; Is C required ? using the shell's "cp src dest" seems great already :) However, even though cp can do the trick, if I am writing a program that needs to copy files from one place to another, or duplicates them for backup purposes, then in such a case, something like this would be necessary. (Of course, I'd be opening these files in binary mode.)
Still, I am not sure to understand why this is necessary, "cp" copies and mv "moves". Anyway, if your purpose is to learn, this is still a good exercice.
domyhomeworkkthxbye
&gt; _t instead of _st is such a simple typo to make, I thought it prudent to ask. I think it was more of not thinking, rather than a typo ;)
Haha, alright. Happens to the best of us.
Consider what will happen if your input file is less than 10 bytes long. The very first read operation will successfully read these 5 bytes and then raise the `EOF` condition. The cycle will never iterate and your program will complete without writing anything to the output file. This is already wrong. If you want to continue using `feof`, a possible read-write scenario might look as follows char buffer[10]; fread(buffer, 1, sizeof buffer, src); fwrite(buffer, 1, sizeof buffer, dest); while (!feof(src)) { fread(buffer, 1, sizeof buffer, src); fwrite(buffer, 1, sizeof buffer, dest); } (Note that I swapped `fread` and `fwrite` calls inside the cycle.) This variant still suffers from a serious problem: if the source file size is not a multiple of 10, the last chunk of data read from the source file will be incomplete (less than 10 bytes). Yet the `fwrite` always writes exactly 10 bytes. In practice this will result in extra "garbage" bytes added at the end of destination file to pad it to the next multiple of 10. And that is exactly what happened in your original code as well (that extra "sta" that you see at the end of the output file). In order to avoid this you have to keep track of how many bytes were actually read by `fread`. And that's exactly how many bytes you should write with `fwrite` char buffer[10]; size_t n; n = fread(buffer, 1, sizeof buffer, src); fwrite(buffer, 1, n, dest); while (!feof(src)) { n = fread(buffer, 1, sizeof buffer, src); fwrite(buffer, 1, n, dest); } This version is already sufficient to properly copy your files. However, the program's structure is still dominated by the fact that it insists on using `feof` to detect the end of source file. In C language you should actually avoid using `feof`: use it only if you really really have to. You can almost always detect the `EOF` condition by simply analyzing the return values of the read functions. In your case you will know that the source file has ended when `fread` reads less than 10 bytes. This allows you to get rid of `feof` call and rewrite the code as char buffer[10]; size_t n; n = fread(buffer, 1, sizeof buffer, src); fwrite(buffer, 1, n, dest); while (n == sizeof buffer) { n = fread(buffer, 1, sizeof buffer, src); fwrite(buffer, 1, n, dest); } Or, you can put everything into the cycle body and do it with just a single pair of read-write operations do { char buffer[10]; size_t n; n = fread(buffer, 1, sizeof buffer, src); if (n == 0) break; fwrite(buffer, 1, n, dest); } while (1); (The code above does not check for other kinds of errors that might occur while reading or writing the files, but that's a different story.) 
 cat f1 &gt; f2
You have understood everything correctly. This code is broken. Even broken code will work sometimes. In this case, the code will *probably* work correctly even if the input is more than 100 characters long. Try it with longer and longer input and eventually it will crash (or worse). One of the unfortunate things about developing in C is that, when you screw up and write broken code like this, it usually doesn't immediately fail. Sometimes it will accidentally work anyway :(
"But don't want to bug people with them." Is anyone not laughing at the genius of this pun? int main(void) { static const int true = 1; while (true) { up_vote(); } return 0; }
I just wrote a bunch of data structures from scratch. You can check them out [here](https://github.com/franklinchou/personal/blob/master/datstruct/linkedlists/sll.c). But for some reason I've always liked an implementation where the List and the List's nodes are separate structures. For example. struct List { struct Node *head; }; struct Node { int value; struct Node *next; }; struct List* List_create() { struct List *list; list = (struct list*) malloc(sizeof(struct List)); list-&gt;head = NULL; return list; } int main(void) { struct List new_list; /* new_list will now hold a pointer to the head node which is instantiated as NULL */ new_list = List_create(); return 0; }
What's going on is that you're writing past the bounds of the char array, clobbering whatever happens to be in that memory location. No big deal; fscanf is happy to write lots of characters to that location, and whatever fscanf wrote is *probably* still there long enough for printf to dump it to the screen. The next instruction that tries to use whatever data used to be there is going to be in for a nasty surprise, however.
fscanf is overwriting the end of c. Welcome to the world of undefined behaviour and no bound checks :)
Seems pointless to have a return value after an infinite loop. Unless you expect an error to occur where the value of `true` gets flipped to false, which is as probable as me knowing the exact number of atoms in the universe.
Might want to format that function so it's treated like code. You can do this by starting the line with 4 spaces. This doesn't seem to be a problem with bitshift operators as your shift using the start variable works, but you want to mask your current number with the number of bits which is represented by your end variable. I.e. (using your example with src = 28) you want to mask your shifted number with 111 (3 times the number 1, 3 being the end variable). Just google on bit masking and using the bitwise AND operator in C and you'll find your answer. Also, I'm very curious on how your function will react to src being a negative number. Not sure how relevant that is to whatever you're trying to accomplish though.
You probably want to use bitwise-and and a bitmask.
I can't read French, so I'm just guessing possible guesses: * compile or compiler * link or linker * library object for sin() * library object for printf() 
Wow, i can read French but this doesnt make sense at all...
You got the basic functionality right. One thing that looks weird though is the inconsistency in base class access. For some reason you use `file-&gt;stream` to gain access to member function pointers, but use cast `(struct stream_s*) file` pass the base class pointer. A consistent approach would use either ((struct stream_s *) file)-&gt;read_func((struct stream_s *) file); or file-&gt;stream.read_func(&amp;file-&gt;stream); As for making it look more elegantly... All you can do is wrap some repetitive things in macros or inline functions. 
Why are you declaring `theAge` to be a `char`? It looks like you want it to be an `int`.
&gt; Not sure how that even compiled The only thing technically wrong with the code you had written was the line scanf(" %d", &amp;theAge); which yields undefined behavior because the `%d` specifier requires a pointer to `int` but you gave it a pointer to `char`. But that kind of argument type checking is not something that compilers are expected to do. So there is no reason that your code *shouldn't* have compiled. However, your code has undefined behavior, which means that you have absolutely no guarantees about the behavior of any part of the program. But you should turn on all warnings in your compiler, and pay attention to what they say: $ clang -std=c99 -Wall -Wextra -pedantic -O3 -o program program.c program.c:12:14: warning: format specifies type 'int *' but the argument has type 'char *' [-Wformat] scanf(" %d", &amp;theAge); ~~ ^~~~~~~ %s 1 warning generated.
&gt; What's stream_t? A typedef for struct stream_s? Yes, sorry, I fixed it in the main post.
This is correct. When you give scanf the pointer to theAge, scanf assumes that it can write 4 (usually) bytes to that location. When it reads in the age (e.g. 18 == 0x00000012), it will overwrite the data next to theAge on the stack. In this case, that data is theGender. If you check in your original example, you'll see that when it's doing the comparison, theGender is 0x00. To see this working, try your original code but with this in place of the variable declarations. char theGender; char unused1 = 0x01; char unused2 = 0x02; char unused3 = 0x03; char theAge; And then print out all the values at the end of your function.
FFR, you should *always* check the return value of `scanf` (or any other I/O function that matters). You might not always read everything properly, and if you don’t, you don’t want your program to go a-spinning off into bogus behavior. You may also want to clear out whitespace after the `scanf` call, because it could leave some in your input buffer. If you’re looking to shrink the code a bit, you can use `%s` to reduce the three `printf` calls in the `if` block to one: if(theAge &gt;= 18) { const char *genderStr; if(theGender == 'm') genderStr = "dude"; else genderStr = "m'lady"; //(shudder) printf("\nYou may enter this website, %s\n\n", genderStr); } else puts("\nNothing to see here!\n"); That inner `if` can also be dropped to a ternary: genderStr = (theGender == 'm' ? "dude" : "m'lady"); and using that, the `if` can be reduced to a single statement on either side: if(theAge &gt;= 18) printf("\nYou may enter this website, %s\n\n", theGender == 'm' ? "dude" : "m'lady"); else puts("\nNothing to see here!\n"); or, if you’re feeling insecure a single statement for the entire thing: printf(theAge &gt;= 18 \ ? "\nYou may enter this website, %s\n\n" \ : "\nNothing to see here!\n\n", theGender == 'm' ? "dude" : "m'lady"); …but I can’t wholeheartedly recommend doing that sort of thing with a `printf` format specifier.
You’re pretty much doing it right, although as people have noted most languages use a vtable to push the function pointers (which would otherwise be repeated in every object; lower access time, much higher memory overhead) out of the main object. However, I recommend making `inline` functions to dispatch the virtuals and keep the two uses of the object pointer parameter in line: #if defined(__GNUC__) __attribute__((__nonnull__((__extension__(1)))) #endif inline read_func_t stream_read, stream_file_read; inline write_func_t stream_write, stream_file_write; ... inline int /*I assume*/ stream_read(struct stream_s *stream) { return stream-&gt;read_func(stream); } inline int stream_file_read(struct stream_file_s *stream) { return stream_read(&amp;stream-&gt;stream); } inline bool /*?*/ stream_write(struct stream_s *stream, char/*?*/ data) { return stream-&gt;write_func(stream, data); } inline bool stream_file_write(struct stream_s *stream, char data) { return stream_write(&amp;stream-&gt;stream, data); } A couple notes: * You can do the dispatch functions as macros instead, but `stream_read` and `stream_write` would each require two uses of `stream` and that can have odd side-effects—e.g., `stream_read(stream_array + i++)` would increment `i` twice and pass the second stream to the first function, so I recommend against it. If it must be a macro and you have GNU extensions, you can use a statement expression instead. The `stream_file_*` functions can be macros, although you should generally also provide a function as well so that the name can be used alone as a function pointer: #ifdef __GNUC__ #define FN_MACRO(x) (__extension__((void)0,x)) #else #define FN_MACRO(x) ((void)0, x) #endif extern stream_read_t stream_file_read; #define stream_file_read(stream) FN_MACRO(stream_read((stream))) If you do this, you need to use a trick to prevent macro expansion when you implement `stream_file_read`: #define NIL int stream_file_read NIL (struct stream_s *stream) { return stream_file_read(stream); // Invokes the macro } * The GNUC things I did above can be omitted, but * `__extension__` showing up in something tells GCC not to kvetch about seeing GCC extensions in any non-`gnuXX` dialect mode. Normally it just disappears, but because of the syntax rules around it, it can be used to prevent a parenthesized expression from being used as the condition in an `if`, `while`, etc.—e.g., `if stream_file_read(foo) {...}`. The `(void)0,` in `FN_MACRO` prevents an expression from being seen as a compile-time constant to match function behavior, and also prevents the expression from being used as a function argument/parameter list (e.g., putchar stream_file_read). This kind of thing ensures that the caller sees little to no difference in behavior or possilibities for usage between a macro and function call, enabling you to change the underlying API &amp; implementation method at will without breaking source compatibility. * `__attribute__((__nonnull__(1)))` tells the compiler that the first argument to `stream_read` must be nonnull. (You can omit the argument to nonnull-ify all arguments, but if you add a parameter that can bite you in the ass.) This enables the compiler to warn if it sees you passing something that it can tell is `NULL`, and it enables the compiler to optimize the function’s implementation based on the assumption that `NULL` must not be passed to it. (In fact, you can’t even get from the inline dispatchers into their intended callees with a `NULL` `stream` parameter on most architectures/compilers. This is why it’s a good reason to use the dispatchers, rather than just call the function pointers directly—otherwise, the `nonnull` assumption isn’t necessarily true and using the attribute might make it a little harder to debug things.) IIRC there’s an equivalent `decltype` specifier for MSVC but I can’t remember it, and it’s a bad idea to use MSVC for C given its oddities/stupidities w.r.t. their implementation of it. You can automate a lot of this stuff with macros, too, if you’re doing very much OOP in one place. If you’re going to go that route, though, pick an easy-to-use nomenclature (e.g., use `_` or `__` where you’d use `::` in C++) and stick to it so your macros can get around in the type system you create. You can even do fairly complex type-related operations like static casts (e.g., those requiring pointer adjustments based on the particular kind of cast and super/subclass) with macros, though only up to a limited depth because the preprocessor is not quite Turing-complete.
&gt;But that kind of argument type checking is not something that compilers are expected to do. C compilers aren't. But other languages have mechanisms that prevent this from happening.
&gt; printf(theAge &gt;= 18 \ ? "\nYou may enter this website, %s\n\n" \ : "\nNothing to see here!\n\n", theGender == 'm' ? "dude" : "m'lady"); This doesn't really work the way you might think it does. It's equivalent to the following (with abbreviated strings): printf( (theAge &gt;= 18 ? "Enter, %s" : "Nothing"), (theGender == 'm' ? "sir" : "ma'am") ); You are *always* passing two arguments to `printf` here, even if `theAge &lt; 18`. Also, the backslashes at the ends of the lines are unnecessary and distracting.
C language specification explicitly states that possible manifestations of undefined behavior include compiler refusing to compile the program. Which means that compilers are *allowed* to check the validity of `scanf`'s arguments. And some compilers do. In fact, modern C compilers are actually *expected* to be able to perform this check, since GCC made this capability de-facto standard.
&gt; In C you need to use strcpy() or strncpy() (both in &lt;string.h&gt;) to do what you're trying to do with genderStr. You can't set a string (char array) equal to another string. But genderStr isn't a character array, it's a pointer to a (constant) character. That makes it perfectly legal (and, in this case, useful).
&gt;If yes, what is so unique in this book (beside the fact that it was written by language authors) It's about 1/5 the thickness of typical programming books yet still gets the job done?
If you ask any programmer for their opinion on the quality of the K&amp;R book, you will probably hear vastly differing responses. Some people hate it and others like it, however it is definitely very famous.
I guess you wanted to link to https://web.archive.org/web/20141205223016/http://c.learncodethehardway.org/book/krcritique.html
Because so many places (and even open source projects) still use C89, it is still a valid way to learn C. For projects using C11, your style will be a bit off but anything you do should still work excepting use of some seriously broken pieces you shouldn't have been using even in C89 like gets().
Many excellent recommendations! The former point, "complete lots of programs," is covered by the exercises in the book. I really enjoyed _Deep C secrets_. Van der Linden was in the Sun Compiler group, troubleshooting C issues, and his geeky sense of humor enlivened the whole book.
K.N. King's C Programming: A Modern Approach (2nd Ed) is also an excellent start (I honestly can't decide which I prefer between Harbison and Steele, and King). 
Harbison and Steele's "C: A Reference Manual" is a reference, though -- it's not intended to serve as a tutorial. As for King, I've not read either edition (just excerpts), so I'll refrain from commenting.
The OpenBSD source code is a wonderful place to learn about C. http://cvsweb.openbsd.org/cgi-bin/cvsweb/src/ Consider reading the simple tools. For example: /bin/cat or /bin/sleep or /bin/echo Once those make sense, try more complex tools. For example: /usr/bin/tmux http://cvsweb.openbsd.org/cgi-bin/cvsweb/src/usr.bin/tmux/
Make a brainfuck interpreter. It covers pointers, math, io, and so forth, and the finished product isn't very large.
Your arrays only have 4 elements, but the challenge states that 1 &lt;= T &lt;= 100. Change: unsigned int nums[4], flipped[4], count, inputs; to: unsigned int nums[100], flipped[100], count, inputs;
Here's from a file I made a whilst ago when teaching someone python. I don't know where abouts on the scale you are, but work your way down from the top. The most interesting stuff is all of those games at the end of the file done in ncurses or some other interactive system (e.g. SDL). https://gist.github.com/anonymous/001a249afa518df14d3c ps: Don't just look at the top couple of easy examples and think "pfft, I could easily make those, but they bore me". If you haven't actually done them or something almost exactly like them, then you probably can't. The only way to prove that you can is to do them, and doing that a) reinforces what you've already learnt and b) helps you learn more. 
How about an auto sudoku solver? Or a blackjack game? 
Write a program to rotate a TIF / BMP / GIF / PNG (pick one) image in increments of 90 degrees, then rewrite it back out again to a file. Don't use any image libraries to do it. 
Good grief, whoever titled that article on Dr Dobb's was more excited about using a pun than actually looking at the website for more than 2 minutes... Nearly the entire package listing is composed of forks of an original repo by one of biicode's creators forked specifically to add a biicode.conf file. I wouldn't call that "buzzing."
Make a bignum that you can add, subtract, multiply, and divide. Learn how to incorporate a 3rd party library. Statically link a library and dynamically load a shared object. Implement objects with inheritance and polymorphic functions. "If you want to write classes, use C++". Look, people do it, and it makes for a good exercise. Make a game. It can be in ASCII, who cares? Roguelikes are a good starting place. It can be your introduction to procedural content generation. Learn sockets and extend your roguelike into a MUD. Make a game on top of an existing renderer.
Basic pointer arithmetic. I would even take it one step further and do int p(int n) { char a[n][n]; return a[n] - a[0]; } or even better int p(int n) { return sizeof(char[n][n]); } All of them are based on the same principle as the original code, with my versions not even being hacks and making it more obvious how the whole thing works. Of course, none of these methods will work properly with a negative value of `n`.
&gt; But it doesn't print out 0's as it should. "Should"? Why? You declared a local variable without any initializer. It should contain unpredictable garbage, not zeros. In C language you initialize everything to `0` by doing double Matr6x4[6][4] = { 0 }; It is a well-known idiom. The `= { 0 }` can be used to initialize absolutely any object of absolutely any type to a zero value. If you want to set your object to all-zero values later, after the declaration, you can do it by using a *compound literal*. Unfortunately, since arrays are not assignable, you will have to use `memcpy` in order to copy the compound literal value into the array memcpy(Matr6x4, (double [6][4]) { 0 }, sizeof Matr6x4); Keep in mind that in C language uninitialized values not just contain garbage, they are not guaranteed to be *stable*. Which means that reading the same uninitialized value multiple times might give you a different value each time. For this reason there's no meaningful answer for why adding a loop changes the "value". You never had any determinate value there in the first place. There's nothing really to change.
&gt; memset(Matr6x4, 0, sizeof(Matr6x4)); I thought C automatically initialized everything to 0.. my bad. Thank you, the memset works. The "Matr6x4[6][4] = {0.0};" gave me an error. It did a similar thing when I used a double for loop to set each item = 0 http://imgur.com/T30NBsA can you tell me what's wrong there? 
Thanks, the memcpy works. Although it did a similar thing when I used a nested for loop to set each item = 0 http://imgur.com/T30NBsA can you tell me what's wrong there? 
C does not usually initialize anything to 0, however global variables will always be initialized to 0 (for security reasons) upon executable start-up, or upon memory allocation from the OS. So anything outside of your main function will always be 0 on any typical* OS. int a; char b; void main(void) { printf("a=%d, b=%c", a, b); // a=0, b=0 } *Embedded/tiny/single-user OS's may not initialize memory to 0, so don't really depend on it for serious code.
Could you please explain the first example that you've given? I can't quite comprehend it.
Very interesting, but you can only use typedef once, what if you need to work with multiple types in the same file?
Yes, that's what I meant when I said that these versions are not "hacks".
For example with ring buffer, you can instatiate different genericfunctions in different c files. and then export static functions trough non static functions using forwading. int point_push(const point_t * p){ return generic_curcular_buffer_push(&amp;circular_buffer,p); } now `point_t` and `int point_push(const point_t * p)` can be prototyped in `.h` file. Pattern is that you write this generic library and instatiate it in .c file, then wrap all static functions in non static functions so that can be exported trough h files. Some of boilerplate code can be still generated with macros if needed but it is not necessary. You can define same types in differrent c files. here it is one possible solution. https://github.com/ra1u/generic_c 
I feel like my post was unclear. [Here's the full challenge.](https://www.hackerrank.com/challenges/maximizing-xor)
So the largest value determines the maximum? Their test cases are not at all clear. I don't have any idea how to go about this.
Sure, but AutoHotkey is Windows-only. I needed something that will work on Linux without Xorg running.
Not really. `1` is less than `3`. `2` is less than `3`. But `1 ^ 2` is not less than `3`.
Nope. A string literal *is* a character array, basically; `genderStr` becomes a pointer to one or the other.
Well, let me take another wild guess. I noticed that `even ^ even` results in a smaller value while `even ^ odd` results in a larger one. I also noticed that in their example `(10,13) and (11,12)` both give the maximal value, and they both add to 23. I feel like writing out bit representations on paper might help, but don't really want to.
There’s nothing wrong with passing extra arguments to `printf`. It’s not a good idea, as I noted, but there’s nothing wrong with it. What the `printf` does is: - If `theAge &gt;= 18`, the first format string is used. That will pull the second argument. - If `theAge &lt; 18`, the second format string is used. That doesn’t pull the second argument; it remains unused, although it is (of course) evaluated before the call. And yes, the backslashes at the end of the line are unnecessary. So are whitespace and comments, for that matter. I use backslashes stylistically to indicate that there’s an operator dangling on the next line, so that when I’m looking for bugs or whatnot, I don’t think I forgot a comma or semicolon. And for what it’s worth, I find the extra parentheses in your `printf` call unnecessary and distracting, but I’m betting you used them stylistically.
Other than performing a couple of loops to xor the values together and tracking the maximal value; are there more elegant solutions?
I am pretty sure IAR Workbench C compiler did not zero memory for me. But it has been awhile (a year or so) since I programmed using that IDE so maybe I am remembering wrong. The compiler+linker should be putting uninitialized data (globals) into the .data? segment, which the OS binary loader should be zeroing (for security). I don't think the C library would re-zero that .data? segment again on startup. For a quick test I just compiled using Pelles C compiler (x86) and stepped through the C init code in Olly and at no point did it zero the .data? segment.
Actually, they go into the [.bss section](http://en.wikipedia.org/wiki/.bss), not the .data section. The .bss section is just stored as a size. When the program is loaded, the OS takes a block of memory that's the size specified and initializes it to all 0s. This all happens before any initialization code takes place. I can't speak for the behavior of IAR Workbench, but I can say that if it didn't initialize globals then it wasn't compliant with the C standard.
This is a fun little bit of obfuscation, but this isn't really a "hack" in the classical sense. It's not like the Quake square root magic, you're not replacing an expensive solution with a less expensive albeit nonintuitive one; you're just hiding the multiply that will *still be going on* under the hood to get at your pointer answer *and* introducing a memory overhead at the same time. Also, as everyone has pointed out, UB.
Malloc is allocating as much as you ask for for the dereferenced value. A pointer to int needs int size space in memory; not the size of the pointer's memory address. 
I find it overrated. But you might not. It's kind of like the Moby Dick of C books. A classic and everyone knows what it is. But does everyone who says it is awesome *really* believe what they say? Who knows. 
They were both screwed up. You just got lucky and one was screwed up with the initial value of 0. When you don't initialize a variable, it picks up a garbage value left behind by something else. But as you can imagine, the number 0 pops up quite frequently. So, one variable picked up some large number that maybe once had a meaning, and the other picked up a 0.
I mean a program to output that..
added example 
What have you tried so far? We can help you improve or debug something you've created, but no one here is going to do your work for you.
Firstly, you never showed how your variables were declared. If `squareSums` somehow got declared with static storage duration, then it is guaranteed to get implicitly initialized to zero, even if you didn't explicitly initialize it yourself. (This is probably unlikely though.) Secondly, you could simply get lucky. Uninitialized values are unpredictable. In your case that unpredictable value just happened to be a zero. Zero is one of those values that tend to pop up more often in raw memory. Try swapping the variable declarations. It might change the outcome (or it might not). Thirdly, things like that can easily depend on such factors as optimization. One variable might end up being represented by a CPU register and therefore behave differently with regard to such things as "unpredictable values". 
&gt; ((struct_type *)0)-&gt;field tries to access the field field of a struct_type at memory 0. "At memory 0"? If that were guaranteed to be the case, then we wouldn't have to subtract `(char *) 0` in the end. What you quoted is basically a popular implementation of the standard library macro `offsetof`. On platforms where null pointers are represented by zero address, this implementation can be shortened to a mere #define offsetof(struct_type, field) ((size_t) &amp;((struct_type *) 0)-&gt;field) That's actually what a "traditional" implementation of `offsetof` looks like (http://en.wikipedia.org/wiki/Offsetof), since popular platforms actually use address 0 to represent null pointers. However, the author of your `OFFSETOF` macro apparently wanted to be more pedantic. In order to cover potential "exotic" platforms, which might use *non-zero* addresses to represent null pointers, they remembered to subtract `(char *) 0` in the end. For example, on some exotic platform null pointers can be represented by `0xABCDEF01` address. In that case `((struct_type *) 0)-&gt;field` will actually refer to a field `field` of an "imaginary" object located at address `0xABCDEF01` in memory. In order to compensate for that they subtract `(char *) 0` in the end (which they expect to be `0xABCDEF01` as well in that case). Note that this is still not 100% pedantic. A pedantic language lawyer might note that the language does not guarantee that all types use the same representation of null pointer value. `(struct_type *) 0` might end up being `0xABCDEF01`, while `(char *) 0` might end up being `0xF00DBAAD`, which will screw up everything.
**TIL a new trick** :) ...thank you for providing an additional example. But is it ok to #include a .c file in another .c file?
Would you mind fixing the indentation of the code? There seems to be a level of indentation missing on the second if. So far your code already looks pretty good; to fix both problems you have, you could try this: * instead of iterating 10 times, iterate until you see the character `\0`, that is, the end of the string. * whenever you see a number, increment a counter. When you see a dash, don't increment. * after the string has been processed, check how many numbers you have seen. If you have seen 10 numbers, you got a complete SSN and your program should output *valid* or *invalid.* If you've seen only 9 numbers, try to compute the 10th number. How this is done is left as an exercise to the reader.
You're misusing arrays. `mapDim` starts initialized to 0, then you declare `mapArray` to be an array of size 0. Changing the value of `mapDim` after that does not change the size of `mapArray`. You're just getting lucky that it works at all. Move your array declaration to *after* reading the dimensions from the user. 
Ah ok I'll have to try that thank you, I see what you mean and it makes sense. I did locate the problem to the for()loop, if I used i&lt;x where x is greater than fourteen then the program crashed idk why, maybe this will fix it.
Your question is unfortunately very vague. So, you're just getting joke responses because nobody really knows what you're really asking. If I read between the lines, I'm guessing you want to create a loop that calculates that sequence and prints it out? If that's the case, the first step is to describe (in words instead of code) what the sequence actually is. Start there, and then go to code.
But that's exactly my point. Yes, constant `0` in C is overloaded to mean "whether the physical representation of null pointer is for the given type". Which is exactly why this implementation #define offsetof(struct_type, field) ((size_t) &amp;((struct_type *) 0)-&gt;field) is platform-specific and "incorrect" from the pedantic point of view. And which is why subtracting `(char *) 0` makes it better (albeit still not 100% perfect from pedantic point of view).
Yeah, I checked their solution and this looks like what they did. 
The input last line does not end with '\n', resulting in an infinite loop because of while ((ch = getchar()) != '\n'), I would fix that with: while ((ch = getchar()) != '\n' &amp;&amp; ch != EOF ); 
.data and .bss aren't the same thing. Depending on the context and who's talking, they're either separate sections, or .bss is one **part** of the .data section. For example, the output of `readelf` will list them as two separate sections. But when I compile some example code, the variables are in the .data section in the assembly. One thing that holds true regardless, however, is that globals with an initializer are *not* part of .bss. As for embedded systems, that really all depends on the system itself, and fortunately it's not something programmers need to care about. For most microcontrollers, I believe the values are initialized to 0 in the image itself, before the device is even programmed, or it's zero'd during programming. Having the run-time zero that data would also make sense for some embedded systems.
I know at least GCC will suppress warnings for system headers by default, you may be able to convince your cross-compiler to do that with the Android SDK. POSIX specifies that snprintf return -1 and set errno to EOVERFLOW if the value would have been larger than INT_MAX, however, some implementations truncate the return value to INT_MAX and leave errno alone. Unfortunately, ISO C99/C11 and POSIX often conflict with both each other and reality. The Unix world has some experience with 64-bit problems, they've been dealing it with for some time now.
Actually, if it's `fputs`, the `stdout` comes after the string, not before. I must've changed my mind about which function I was using halfway through writing it!
&gt; I have always found strict adherence to stdint.h and using (u)intXX_t variables helps ensure compatibility. For for loops and other variables you typically know the size of, you can use int_fast8_t or int_fast16_t so the compiler can both ensure the compatibility you need and also use (perhaps) larger registers to hold those values. Basically every variable you ever use ever ever ever should be in stdint.h or a typedef derivative. Our codebase actually predates C99 (well, parts of it do), and in any case we have to support too many proprietary compilers for embedded systems that don't have proper C99 support. But we already have an abstraction layer that defines i32/u32/i16/etc types, which we use almost everywhere.
&gt; It is a pleasure to hear that you understand the major issue behind using size_t for that purpose. Haha, thanks. :-) I'm too young to have programmed on the 8086 or 80286, but I do like learning about historic computing, and reading up on segmented memory has really helped me make sense of some of the distinctions involved in this process. &gt; you can relatively safely use `uintptr_t` for such purposes. Even though the immediate semantics of this type is not tied to any "sizes" or "counts", it is obvious that it should be sufficient for representing any address-space-related metrics. Ahh! That makes sense... since it can hold the value of any pointer, by definition that means it can hold the value of any amount of memory. (Actually, is that always true? If Physical Address Extension was enabled, I could have up to 36 bits worth of memory even though pointers are only 32 bits. But if I'm writing the kernel, I'd want a type that can hold the total amount of memory in the system, which would require a 64-bit type.) But yeah, it seems like I can `typedef intptr_t mem_amount_t` and that should be good for what I'm looking for right now. (And if it turns out to not work for a particularly weird platform, I can override the typedef for that platform.)
&gt; Similarly, there's no dedicated type to describe the number of nodes in linked list. A lot of people got damaged by reading too much into questionable-quality code and got duped into using size_t for everything (Linux community is hit especially hard by this confusion). There's also quite a few low-quality articles on the Net, which tout using size_t for that purpose in authoritative tone. Can you elaborate on what you mean? Even the C standard library uses `size_t` for counting things. 
&gt; Another thing to look out for are right shifts, which may yield different results on 64 bit Learn the portable rules about shifts: * Shifts of unsigned types do what you expect * Signed left shift causes undefined behaviour if a `1` is shifted into the sign bit * Signed right shift is implementation-defined. * Shifting by the width of the type causes undefined behaviour. * Bear in mind that integer literals have a type; `1 &lt;&lt; 31` is undefined but `1LL &lt;&lt; 62` is OK. (If 32-bit int). In lieu of learning the rules, only do unsigned shifts and always use suffixes. You can avoid much of this by explicitly using multiplication and division if that's what you intend. (Writing a shift when you mean multiply by 2 is a lame micro-optimization). 
This is really more of a math question. That said, I'll do my best and explain it without going into tons of detail about the math behind the Fibonacci test. An easy way to test if a number is a Fibonacci number is to test if `5 * n ^ 2 + 4` or `5 * n ^ 2 - 4` is a perfect square. This fact is being used in this code. double square = num * num; square *= 5; square += 4; double x = sqrt(square); That calculates `5 * n ^ 2 + 4`, our first test. To be a Fibonacci number, one of our tests has to be a perfect square. To test for a perfect square, it's easiest use sqrt, because the sqrt of a perfect square is always an integer value. square -= 8; double y = sqrt(square); This calculates the second piece of our test, `5 * n ^ 2 - 4`, by reusing the value we already calculated, `5 * n ^ 2 + 4` and subtracting 8. We then sqrt it like the first test. return (fmod(x, 1) == 0 || fmod(y, 1) == 0); This is a crucial part. To understand `fmod`, you first need to understand what the mod operator `%` does. Basically, in math terms, `x mod y` is equal to the value left over after dividing x by y, with all four numbers being integers (The numbers being `x`, `y`, the result of `x / y`, and the remainder of `x / y`). For example, `5 mod 2` is 1, because 2 divides into 5 two times, and then one is left over (Or IE. `5 / 2` is equal to 2 remainder 1, and the mod operator gives us the remainder, 1). In C, this operator is expressed with the symbol `%`. So in C code, you can write `5 % 2` and it will give you 1. `fmod` is the same concept, however `fmod` can work with floating point (`double`) variables. The basic way this works is that you divide one number by another, toss out any numbers after the decimal point, and then multiple the number you're left with by your divisor and subtract that from your initial value. I explained it in basic terms, but you might find it simpler to understand if you just see the equation that fmod uses to calculate the remainder: fmod(x, y) = x - (int)(x / y) * y; Even if you don't understand the math completely, the important part is how it's being used here. We do `fmod(x, 1)`, and `fmod(y, 1)`. Remember, we're testing for a perfect square, and for that to be true either `x` or `y` need to be integers. Since we know 1 is an integer, and interesting thing happens in the above equation either `x` or `y` are integers and our second number is 1 - The integer cast drops out, and the remainder is zero: fmod(x, y) = x - (int)(x / 1) * 1; fmod(x, y) = x - (int)(x); /* Get rid of divide and multiply by 1 */ fmod(x, y) = x - x; /* x is an integer, so x == (int)(x) */ fmod(x, y) = 0; Another important fact, `fmod(x, 1)` will *only* equal zero if `x` is an integer. If `x` isn't an integer, then `(int)(x) != (x)`, and thus the above equation will give some non-zero value. So with that in mind, we can use fmod to test whether or not a floating point number is an integer or not, and thus completing our Fibonacci test: return (fmod(x, 1) == 0 || fmod(y, 1) == 0); This tests if either `x` or `y` is an integer, and if either one of them is, it returns 'true' (1).
&gt; That sounds like the opposite of what I want. For one, I'm actually not guaranteed to have 64-bit values on some processors. My day-to-day embedded processor is a Blackfin, which can only do 64-bit ints by software emulation... not something I'd want it to use when implementing malloc(). The emulation of 64-bit math, especially just pointer math (add, sub) is exceptionally fast, usually taking only 1 additional clock cycle to execute, and supported in hardware even on systems that have less than 64-bit registers. So do not be afraid to use uint64_t on the Blackfin, for example. Even on a 32-bit memory addressed system, when dealing with memory allocated, a 32-bit value is still not enough to hold the total memory allocated. Remember that some systems will use paging, so even though the memory address is only 32-bits, the total amount of memory that can be allocated by the system can be much larger! Using uint64_t to support memory is completely fine, even on 128-bit systems. uint64_t without blocking can support 16 EB of system memory. That much memory will not be common for another 50+ years!
I never heard of hackerrank before. going through the warmup now, it seems like good practice so far. thanks! I'll pm you the stego program
Alright, cool. Note that hackerrank is not a good way to form overall projects. They're just quick challenges, like any other site, that are either good practice or may teach a new concept or two.
Yup I know, it's like codingbat. PM incoming....
They got added in c99. It's magic, I tells ya. 
I've heard that the Tcl/Tk source code is really well documented C. Also check out this question on HN: https://news.ycombinator.com/item?id=7602237
The Linux Kernel I'm going to say. Take a look at [this](http://luisbg.blogalia.com/historias/74062) listing of some algorithms and data structures implemented in it.
Linux!
Firstly, Visual Studio already supports *almost* everything in C99. But incidentally not VLA. Secondly, by the committee decision VLA support in C language has been declared *optional* (aka *conditional*) in C11. Compilers are now formally allowed to omit VLA support. Such compilers shall pre-define `__STDC_NO_VLA__` macro. To VLA or not to VLA is a big question, BTW. Back in the day people were criticizing `alloca` function use for not having meaningful use cases. The same criticism can be transferred over to VLA. I can come up with an example where this feature becomes truly useful, but it will rely on some quite specific data relationships. In general, dynamic allocation of stack memory remains something that is frowned upon. And for good reasons.
Off the top of my head SQLite for a fairly large codebase. DJB Simon G Tatham Sean J Barrett at Nothings
python source code is in C and it's nice
You could take a look at openbsd src/! http://cvsweb.openbsd.org/cgi-bin/cvsweb/src/
Not really a "look at this project ", but check out [OSDev](http://wiki.osdev.org/Main_Page). If you have decent knowledge of C and/or another suitable systems language and don't mind (or enjoy!) getting your hands dirty, you'll love it and learn a ton.
http://kotaku.com/5975610/the-exceptional-beauty-of-doom-3s-source-code
Postgresql
That code is beautiful! The API is also extremely well designed too.
Uhm, I think since C99. So awhile now.
I've been using DWM for my window manager for several years on both my laptop and desktop. Before they added multi monitor support I added it myself (I did offer a patch, but they already had a better implementation in the works). The code was a joy to read.
That must mean Microsoft's compiler never learned how to check the pressure &amp; inflate a tire when needed. 
Please put four spaces before each line to make your code appear in mono space (does nobody read the formatting guide?) 
Thank you. The code I copied straight from lecture notes. The 5 is really stupid I can't see how i didn't see it. Removing 5 and adding int doesn't allow me to compile it either. I am not sure what you mean by smart quotes. 
Small nitpick: you ninja-edited `i` to have initialization but not `j`; would suggest either leaving it as it was, or doing: int i = 5; int j = demo(i); (Of course, you avoided the mistake of `int i = 5, j = demo(i);`)
Might be a tad above my head for now, but certainly something to look at. Thanks!
The list is really nice, since I'm not quite ready to dive into Linux code in general - the list give a nice foothold. Thanks!
Hm... What exactly is the implied mistake here (aside from possible stylistic considerations)? Per 6.7.5/3 (C99) each *full declarator* in a declaration ends with a sequence point. I always assumed that the intent was to require that individual initializations are executed in order from first to last (and separated by sequence points). The sequence point is there, but I don't immediately see anything in C99 that would explicitly define the order... Quite possibly the presence of a sequence point is already sufficient to define the order in this case. Or not? GCC is known to detect such simple situations and issue warnings about unspecified or undefined results, but it is silent in this case.
There's no sequence points in the multiple initialization case, `j` may be initialized before `i`. In the code you suggested there is no error, I just thought it was stylistically inconsistent to change one assignment to initialization but not the other.
Um... Yes, there *are* sequence points in declarations with multiple declarators. This is explicitly stated in the standard and this is not disputable. What isn't immediately there, is the requirement to execute the initializations in declaration order (as opposed to executing them random order, for example). If there's no such requirement, then clearly `j` may be initialized before `i`. That issue is separate from sequence points. Amusingly, even C++ appears to be undecided on that subject http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1342 A footnote in C++ standard seems to clarify the intent, but footnotes are non-normative. Returning to C, it is not clear what the purpose of those sequence points would be, if the order is not defined. Sequence points can change *undefined* behavior into *unspecified* behavior, but I don't see any practical value in that.
&gt;What is the real-life purpose of sequence point after each declarator, if there's no ordering among declarators? So that in the code: int i = x++, j = x++; there is no undefined behaviour (only unspecified). For rationale, I'd guess that it is similar to any other situation: why impose an unnecessary constraint on optimization? For example if the compiler is free to re-order the initialization of variables then it can optimize how the stack is used if some of those initializers contain function calls. 
So true. Thanks for saying that.
Thanks! Looks like a good read. I understand what you mean about beautiful design - I was more interested in what exactly C can bring to the table to make things nice, but still a nice read.
SDL (Simple DirectMedia Layer) https://www.libsdl.org SDL manages to wrap low level native OS platform stuff needed for games (for a ton of platforms), into a nice, relatively simple, common C API for cross platform use. It's been around for well over a decade, used by tons of commercial games, tons of language bindings (nice property of being C), and is now adopted by Valve as a core component such as for SteamOS. 
Not sure about the relevance of this "pro-tip" here. Firstly, it is not about the code, it is about the language. Secondly, it might not be first priority for a beginner, but it matters for an expert. Thirdly, I see a discussion, I don't see an "argument". Fourthly, funny "wonderful impression" remark. It is like saying that if a freshman mathematics student accidentally opens a book on differential equations, he'll experience a trauma that will make them never touch math again. No there's no issues with impression on newbies here. Quite the opposite, most of the time such discussions draw rants from self-proclaimed "professional" C users who suddenly realize that they can't grasp the topic. They never learned the language when they had time. And now they are to busy or, more likely, to lazy to do anything about it. And that brings us to our real *pro-tip* for today: Want to program in C? Learn it thoroughly, every turn and corner, every nook and cranny. It is doable. C a very compact language. And "learn" means *understand*. Strive to understand the rationale behind every language feature. That is how you become proficient in C. If you'll spend your life running away from anything you don't know by "reformatting the code", you will never rise above the level of a typical "weekend coder". 
 &gt; No, you cannot define the enum in the table. I think that answers my question. Bummer. I figured there wasn't a way to do that.
He actually wrote `char * name`, but because he didn't use backticks (`) to format the code, reddit interpreted the asterisk as italics.
Oh, I see. The asterisk became italics. 
In the example table, and in my real situation, each row in the table will correspond with exactly one enum value. This will always be the case. There will always be a one-to-one relationship. There are two enum values so there are two table entrys. In order to add another command I have to add another enum value and then the corresponding table entry. It would be nice if all I had to do was update the table. It's really that simple.
Apologies it should be name not buffer, I was researching the problem at the same time and must have had buffer on my mind.
&gt; The emulation of 64-bit math, especially just pointer math (add, sub) is exceptionally fast, usually taking only 1 additional clock cycle to execute, and supported in hardware even on systems that have less than 64-bit registers. I'm not sure why you think this. I whipped up a quick function to test this theory. To add 2 32-bit ints, it generated: R0 = [P1]; R1 = [P1 + 4]; R0 = R0 + R1; To add 2 64-bit ints, it generated: R0 = [P1]; R1 = [P1 + 8]; R0 = R0 + R1; R2 = [P1 + 12]; R1 = [P1 + 4]; CC = AC0; R3 = CC; R1 = R1 + R3; R1 = R1 + R2; So with data loads, you're looking at 3 instructions versus 9; if you ignore data loads, it's 1 versus 5. Not a huge difference, but more than a single cycle. &gt; Even on a 32-bit memory addressed system, when dealing with memory allocated, a 32-bit value is still not enough to hold the total memory allocated. Remember that some systems will use paging, so even though the memory address is only 32-bits, the total amount of memory that can be allocated by the system can be much larger! Definitely true. Fortunately, since it targets embedded platforms, this implementation of `malloc` doesn't need to deal with swap files or address extension, so I can safely assume that the maximum amount of memory it needs to handle is however much is addressable in the system. &gt; Using uint64_t to support memory is completely fine, even on 128-bit systems. uint64_t without blocking can support 16 EB of system memory. That much memory will not be common for another 50+ years! Again, I disagree. Not only is it marginally less efficient, it's just trading one problem for another. Sure, it might take 50 years to show up, but that's what caused problems with 2-digit years and other such oversights. The *best* fix is to typedef it. There are multiple variables that will be holding values as large as "maximum amount of memory" (some in structs, some as temp variables), so a typedef should be used so that if I need to change it, I only need to change it once. Now that it's a typedef, I can put some preprocessor code in so that it can be overridden on a particular platform, if I find an instance where my default doesn't work. With that done, I can set the default typedef to something reasonable. You suggest just using `uint64_t`, but I think `uintptr_t` as suggested by /u/BoatMontmorency is a much better pick: this will give me the default I wanted where it's 32 bits on my 32-bit platforms, and 64 bits on my 64-bit platforms. If this code ever gets compiled on a 128-bit platform, it would be able to handle a malloc pool of all 128-bits worth of memory, without any modification needed.
&gt; I can quote the C spec on unimportant details like the rest of you losers and have been known to do it right here on reddit in the past. Sounds mildly familiar. Are you by any chance "a redditor with 198 IQ and the moderator of /r/PoliceCops"? &gt; Learn "that sequence points are stupid" Facepalm.jpg &gt; BECAUSE IT MAKES YOU LOOK SO ELITE AND YOUR PENIS SO HARD TO HAVE IT AS A SINGLE LINE ... And I give you /r/C_Programming on Reddit, ladies and gentlemen!!! Where C newbies get the most wonderful impressions that haunt them for the rest of their lives! 
The idea is that I want a value that will correspond to an entry in the table. If I'm checking for a system_on command somewhere in the code I don't have to know it's exact index in the table I just have to know the enumerated value to search for it. As BoatMontmorency pointed out, maybe I could use the enum value as a direct access index. However, then the process of adding or removing a command is more tedious because the enum and it's associated row in the table must always match up. I would like to avoid that if possible.
&gt; makes the process of updating the table and the enum a tedious task Depends on the size of the table and the frequency of such updates... But anyway, in any case there's no "automatic" solution at the pure core language level. A third-party preprocessor-level solution might exist. Believe it or not, we do almost the same thing in our code by using our own script that automatically generates "enums" from the "tables".
Oh a script! That's a cool idea. Yeah I figured there wasn't anything at the language level that could help. Thanks for your feedback.
Yes, you can accomplish what you want. You'll need to split your code into two files - an (untested) example is below. When adding a new command you only have to add a new line to CommandTypes.h. There's actually name for this "technique," x-macros. Now, whether or not this results in more readable/maintainable code is a judgement call. I suppose if there are a large number of commands, it could be a win. --- CommandTypes.h: COMMAND(system_on, 0, 1), COMMAND(system_off, 0, 0), --- Commands.c: #define COMMAND(command, value1, value2) command typedef enum CMD { #include "CommandTypes.h" } #undef COMMAND typedef struct { CMD command; int value1; int value2; }CommandTableEntry; #define COMMAND(command, value1, value2) {command, value1, value2} const CommandTableEntry CommandList[] = { #include "CommandTypes.h" } #undef COMMAND
What is an MWE, sorry I've just never heard of that before.
Does your code even compile? Which compiler are you using? On GCC: error: ‘o’ undeclared (first use in this function) while((o = getopt(argc, argv, "n:")) != -1) { ^ Secondly, your function `splitter` is inside the `main` function. You can do that, but you shouldn't. Here's a [re-formatted version of your code](http://pastebin.com/SjDwY8Ag). You can see that `main` is never closed, too.
Unfortunately, something somewhere has to keep these two entities aligned. The compiler can't do this (imagine if the enum were in a header and the table in a source file), so it's up to you. The most common solutions to this are: 1. Ensure there's a 1:1 relationship between the two. This is very easy, but I've fixed stupid bugs because someone added an enum without updating the table, or some other silly mistake (which is easy to make because they're often in different files, and there's nothing indicating how to associate them as it's implicit). 2. Put the enum in the table, as you've done. A bit of duplicate work, but forces you to update the table. Doesn't protect against all bugs (two entries with the same enum value, for example). 3. Have a tool generate the code for you. Not worthwhile for small projects, but very, very common for large ones that have very large tables. Honestly, this is something that has bugged me about C for a long time. It's an incredibly common problem, and no good, easy, robust solution.
Added the line `printf("%s\n", name);` into `case 'n':`, and it seems to work. I'm on Linux, using GCC 4.9.2 by the way.
Good idea. It can actually be done without using an extra file. One can just do #define TABLE_DATA\ COMMAND(system_on, 0, 1),\ COMMAND(system_off, 0, 0) #define COMMAND(command, value1, value2) command typedef enum CMD { TABLE_DATA } CMD; #undef COMMAND typedef struct { CMD command; int value1; int value2; } CommandTableEntry; #define COMMAND(command, value1, value2) { command, value1, value2 } const CommandTableEntry CommandList[] = { TABLE_DATA }; #undef COMMAND 
The code you posted in pastebin does not even call your `splitter` function! Where is the call?
 case 'n': if (argv[2]){ name = argv[2]; splitter(name, 5); } break; This also works. Am I misunderstanding your problem, or are you having problems inside `splitter` function?
Going to test now, I hope I wasn't an idiot lol. Edit: replied to BoatMontmorency, I remembered the problem was the pass through name was returning null.
Yeah sorry about that, forgot to include it in the code. I don't normally post on reddit regarding programming help so messed up quite a few times so far. Check out my reply to BoatMontmorency for my current problem (null printf'ing)
That means that your `buffer` pointer is null. This again raises the question of what `buffer` is. Are you sure this wasn't just a simple variable mix up? E.g. you wanted to print `name`, but instead printed some unrelated variable `buffer`, which just happened to be null at the time.
Sorry for the example to make sense I changed the word "buffer" to "name" - they are one.
For good portability, you might want to continue operating under that assumption.
Nope, it returns "null" when printing the name from the splitter method. Edit: New code update in original post with no mistakes now... I think!
Your problem is still not pointers. Your problem is that you don't know how to use getopt(). Here's the man page for getopt(): http://linux.die.net/man/3/getopt Look at the example. What's different between that and your code? I also still strongly suggest assigning NULL to 'char * name' by default, to catch errors. Hint: You should not reference argv[2] inside the switch statement if you're using getopt() properly. Or, as I said earlier, you could ditch getopt() entirely, and just use argc and argv directly. It's really easy to do what you want. int arg = 1; /* Skip name */ while( arg &lt; argc ) { if( argv[arg][0] == '-' &amp;&amp; argv[arg][1] == 'n' &amp;&amp; arg+1 &lt; argc ) { name = argv[arg+1]; arg++; /* Skip the used argument */ } arg++; } Or you could use a for loop: for( int arg=1;arg&lt;argc;arg++) { /* Same code as inside the while loop above */ } This may seem more complicated, but it really isn't. If you want to process more arguments, you can just check for '-', and do a switch on the next character, i.e.: if( argv[arg][0] == '-' ) { switch( argv[arg][1]) { .......... } } Don't use getopt() unless you have tons of options that are complex and you actually need to use it. EDIT: Forgot to increment arg in the while loop above.
You are apparently running into the fact that `getopt` *permutes* the content of `argv` array. If you want to use `getopt`, you should not access `argv` array directly. At least not under the original indices. In your example if `-n` is intended to the the option key and `NAME` is intended to the that option's value, then you should access the option value through the global `optarg` variable, not through `argv[2]`. Read some man pages on `getopt` - they contain good examples of proper `getopt` usage. In your case it should probably be something like case 'n': if (optarg) name = optarg; break; 
I tried out what you said it should be something like but still got (null). I will read up on optarg though, thanks.
Real world allocators have much more functionality than what you've written here. - Your code requires that on every request for a new allocation, the entire list of allocations is walked in order to find a suitable free block. That's far too much overhead to be workable. Actual allocators maintain free lists that can be used to find a suitable block without having to consider any in-use blocks. And they are often divided up into separate free lists based on size, such that for common sizes a free block can be found almost instantaneously by taking the block at the front of the line. - Your code doesn't pay any attention to avoiding fragmentation. In actual allocators, this is vitally important, otherwise you can end up with a heap that's terribly fragmented. This results in wasting a ton of memory, because a fragmented heap has tons of free blocks but they are all too small to satisfy anything but the smallest of requests, and so it has to constantly expand despite having numerous free blocks. (And to harp on the first point again, in a fragmented heap, you would have to walk over that entire giant list only to make it to the end without being able to find a suitable block.) - Your code doesn't ever return memory back to the operating system. Real allocators do try to relinquish memory, especially for large allocations. - In the scenario where a program makes a bunch of sequential allocations without any free()s, your code results in a `sbrk()` syscall for every allocation. That's very inefficient, because syscalls are relatively expensive. Real world allocators request memory from the kernel in larger chunks than what is necessary to satisfy the current request, so that there is available space to fulfill subsequent requests without requiring a syscall. - Your code always uses `sbrk()`. Real allocators only use that for small allocations. Large allocations are done through anonymous `mmap()` regions. This is done to make it possible to relinquish these regions back to the operating system when they are freed. `sbrk()` is very clumsy because you can only move the break forward or backward. But you can map and unmap regions at will. For example, with your allocator, if the code allocates 64 bytes, then allocates 10MB, then allocates 64 bytes, then frees the 10MB allocation, there's no way to relinquish that memory back to the operating system because that last 64 byte block is still in the way of being able to move the break point backwards. But if you'd used an anonymous mapping to service the request for 10MB, you can relinquish that region as soon as it's no longer needed, regardless of what other allocations might have happened in the mean time. - Your code never splits a large block into smaller blocks. For example, suppose someone allocates 10MB, then frees that allocation, then allocates 64 bytes. Your code will use that 10MB block to service the request for 64 bytes, which means the vast majority of it will be wasted as unusable slop. - Your code isn't thread safe. Real world allocators have to contend with multiple threads allocating and freeing concurrently. This is a considerable source of frustration, because putting everything behind a mutex adds a lot of overhead to the single-threaded case. Real world code tends to go to extremes like having per-thread free lists so that requests can be serviced without taking a lock. 
http://pastebin.com/EybzcTp5 Still getting the same null problem with updated code.
&gt; I'm not sure why you think this. I said *usually*, not always. &gt; The best fix is to typedef it. There are multiple variables that will be holding values as large as "maximum amount of memory" (some in structs, some as temp variables), so a typedef should be used so that if I need to change it, I only need to change it once. Now that it's a typedef, I can put some preprocessor code in so that it can be overridden on a particular platform, if I find an instance where my default doesn't work. I was under the assumption when you asked for "portability advice" you meant for methods that did **not** rely on using the Preprocessor or Macros. AKA I thought you wanted code that was portable without any user intervention. If you want user intervention, then yes continue using the Preprocessor &amp; some Macros. It is the best way to achieve portability. The downside to this is each new platform will likely need more research (datasheets) &amp; code added specific to it. If you want **code** that is portable between platforms (you specifically mention 32-bit and 64-bit) then my methods mentioned above are valid. I personally refrain from using the PP/Macros for any reason in my code, especially for portability, except for the obvious cases where I cannot skirt around them (embedded processors having different port numbers, memory address layouts, etc). You can still use my uint64_t trick, but turn it into a macro like uintmax_t, and in 50 years when you need it to be larger, change it to whatever the new max standard is, probably something huge like uint512_t lol.
You need to always specifiy the array sizes for everything but the first one (the compiler cannot read your mind to find out what sizes you want): int jagged[][3] = { {0,1}, {1,2,3} }; Example usage: int jagged[][3] = { {2,4}, {1,2,3} }; int size = sizeof(jagged); printf("size=%d\n", size); int* p = (void*)jagged; for (int i=0;i&lt;(size/(int)sizeof(int));i++) { printf("%d=%d\n", i, *p++); } Output: size=24 0=2 1=4 2=0 3=1 4=2 5=3
Thank you, I will definitely work on those. This was really just a first draft of this, so thank you for your feedback. Back to work :D
I tried replacing my new code with a backup of the old one and adding your code but got nothing but null again. I have no idea what's up with my code.
I still think you're not understanding how argc and argv work. argc is now many arguments your program received, including it's name. For example, if your program was run with no arguments, argc would be one, and argv[0] would be the name it was called as, such as "myprog". argv is an array of char pointers. So argv[0] is a pointer to char, which contains the programs name. argv[1] is a pointer to the first argument, etc, all the way up to argv[argc-1]. If you want to test if an argument exists, compare it to argc. Don't try using argv[something] != 0, or any variant of that, because it's incorrect. Each argv[i] for i &lt; argc will be a valid null terminated string. Why don't use use a debugger and step through your code. That might help you to figure out what's happening.
I like to use printfs for debugging sometimes. In the code where you expect name to get a value, add a printf like: printf("Hey! I got a name! That's pretty cool!"); Now run your program. Did it print that out? If not, you know where to look. Also, you can step through the code with a debugger. Set a breakpoint at the line you expect to get name a value, then run it. You can figure this out, you just have to take it one step at a time.
How do you run this code? What command line parameters?
So I changed it to `if (argc) name = argv[arg + 1];` But am still getting the null. I have no idea how to fix it as I not overly experienced with C. I am highly grateful for your help and don't blame you if I'm too nooby to understand.
I forgot to increment arg inside the while loop of my example. Check out the modified code above, or use a for loop instead of the while loop. It's two different ways of doing the same thing. In fact, the for loop is how I usually do that.
I forgot to increment arg inside the while loop of my example. Check out the modified code above, or use a for loop instead of the while loop. It's two different ways of doing the same thing. In fact, the for loop is how I usually do that.
I am running my program in Terminal in Ubuntu. All of my printf's are printing null other than printing the entered string.
Sorry, I'm not all that lazy it's just that I don't know of any Ubuntu C debugging methods/tools.
There's a program called gdb. Google it. "gdb tutorial" should give you all that you need.
What arguments are you passing?
Oh ok, then your method would work for him.
Using a Makefile (gcc)
No, the question is how do you run *your program* once it is compiled. How do you specify your `-n` parameter?
Minimum Working Example Meaning, the smallest bit of code that demonstrates your problem.
Sorry, I use ./ProgramName -n John
One more time: the code you pasted to pastebin *does not print anything* in response to `-n` option. In addition to that the code you posted contains an infinite cycle, because you never change the value of `arg` inside the cycle. But even if you fix the infinite cycle, your code still requires `-l` option to print something. Nothing is printed from inside the `-n` option branch. Yet you claim that your code prints `(null)`. This does not make any sense. Either you are posting inaccurate code or you are posting inaccurate description of the program's behavior. Or you are posting inaccurate command line parameters. Nobody can help you until you start providing real information. Post the *actual* code. Post the *actual* command line. Post the *actual* description of what you see. Here's your latest code from pastebin with infinite cycle problem fixed http://coliru.stacked-crooked.com/a/69c2cbac7a23278f It works as expected.
So they get a free list at runtime?
Do a google search for "Doug Lea malloc" to find a paper and source code that is quite instructive on how to write a decent malloc. Here, I did the search for you: http://g.oswego.edu/dl/html/malloc.html
Yep, saw your SO thread..:) It's hard to remember whether it's C or C++ that has some bizarre semantic, for each semantic. (For example C allows union aliasing and C++ doesn't). 
[May your bitwisdom flourish.](http://lmgtfy.com/?q=bitwise+programming+in+C)
That's a lot of criticism for what amounts to a simple coding exercise. I don't think all of it is warranted. OP wasn't trying to write a high-performance allocator, just any old implementation of `malloc`. Walking used allocations: very true, there's not much point in this. Keep one list for allocated memory, and one list for free memory. Multiple free lists based on size would be nice, but isn't required. Avoiding fragmentation: I don't think this is fair. First-fit is a trivial algorithm to implement, and while it does lead to memory fragmentation, it may not be enough to harm anything; it all depends on the workload. I've worked on an RTOS that used first-fit for years before it became fragmentation became enough of a problem to implement a more complex algorithm. Calling `sbrk` every time, and not using `mmap`: Again, I saw this as a trivial implementation. These are performance improvements that aren't required for proper functioning. Not splitting blocks: Very valid complaint. Actually, besides just splitting blocks, I'd also rather see it combine adjacent free blocks, so that two smaller blocks would be combined and could then be used to service a request for a larger block. Not being thread safe: Although I agree everyone should be aware that your single-threaded code might be used in a multi-threaded environment, that doesn't mean there's anything wrong with having this implementation be single-threaded. It could trivially be made thread-safe by just protecting the `malloc` and `free` functions with mutexes. Things like per-thread free lists sound like they require cooperation from the OS or thread library, which is way outside the scope of a coding exercise.
Thank you!
I could have googled it myself, but I wanted to have a little different understanding to bit level programming that is already there on the web. I always get lost in them, and never really got hold of understanding the use of masking the bits and unmasking the bits and 1's complement and 2's complement and so on. 
Not bad; it's simple but effective. I work on an RTOS that has a first-fit memory allocator that isn't much more complicated than this. I see you've already incorporated some suggestions that were given here. A large number of runtime errors are off-by-1 errors, where someone overflows or underflows a buffer, often by just a few bytes. Imagine what would happen if a buffer overflow overwrote the `size` variable in your `malloc_pointer` struct: very bad things would happen. To avoid this, you could add some fenceposting: a couple of extra bytes on either side of the metadata, so that if there's a buffer overflow, hopefully it will only overwrite the fencepost instead of your metadata. If you set the fenceposts to known values (like 0xCCCCCCCC), you can check whether they're still correct when the memory is freed. If you see a value other than 0xCCCCCCCC, you know it got overwritten. (There could be a false negative, if someone happens to write all C's, but there's not much you can do about that.)
Uses: isolating bits in numbers read from IO ports to control external devices ("bit 4 is the state of the button, bit 5 is output on the LED" type things). Also quick multiply/divide/modulus by powers of two.
I believe the exercises in K&amp;R are more to just demonstrate the way bitwise operations in C work, and are not intended to really go into "bitwise programming," which to me sounds more like assembly. C was developed to allow a programming without having to worry about individual bits, memory addresses, and the like all of the time, so if you want to really get into heavy bit-bashing, you may want to check out assembly programming. As for knowing enough about bits, bytes, and memory to complete the exercises in K&amp;R, here are a few pages I found that might help you: * [A gentle introduction](http://www.math.grin.edu/~rebelsky/Courses/152/97F/Readings/student-binary) to how binary mathematics work, and how numberes are represented and manipulated in binary. This page seems pretty good except I think it glosses over negative numbers a little too quickly. Maybe better to look at... * [This page](http://www.cs.cornell.edu/~tomf/notes/cps104/twoscomp.html) explains two's complement, which is how basically any modern computer represents negative numbers in binary. * [This first half or so of this page](http://www.falloutsoftware.com/tutorials/ktm/ktm1.htm) explains how binary is used in computer memory. To tl;dr the parts useful to a C programmer, every 8-bit byte in memory has a unique address, but a 32-bit word would take up up 4 bytes. On my system, an int is 4 bytes, and a long is 8 bytes, but I only need the address of the first byte of either of those to refer to the whole datum, sort of like how a pointer to the first item of an array is the same as a pointer to the array itself. * [This page](http://www.cprogramming.com/tutorial/bitwise_operators.html) discusses bitwise operations in C and C++; the text of K&amp;R chapter 2 section 9 does too! There is an [example of using bitwise operations](http://www.cprogramming.com/tutorial/xor.html) to perform a type of encryption on that site as well; although it is written in C++ the differences are minimal, so here it is in C: #include &lt;stdio.h&gt; int main() { char string[11]="A nice cat"; char key[11]="ABCDEFGHIJ"; for(int x=0; x&lt;10; x++) { string[x]=string[x]^key[x]; printf("%c",string[x]); } return 0; } Hope some of this is useful to you! Edit: having trouble getting the code to format nicely but I hope it gets the point across.
Thanks for this link, it has some really interesting things!
My bad. I'm having a crappy day and added salt to an innocent question making myself look like a jerk. Sorry about that. Good luck with your study. (I'm trying to be better about _not_ misguiding my snark) :)
The object created by a compound literal has static storage duration if used outside the body of a function, otherwise it has automatic storage duration. There is no way to directly create an object with dynamic storage duration, but you can assign to one: typedef struct { double x, y; } point; point *p = malloc(sizeof(point)); *p = (point){ 1.5, 3.7 }; This is equivalent to creating a named variable with automatic storage duration and then assigning: typedef struct { double x, y; } point; point *p = malloc(sizeof(point)); point tmp = { 1.5, 3.7 }; *p = tmp; The only difference is that in the first case, the object is unnamed and can't be referred to again, whereas it has the name `tmp` in the second example. In both cases (and assuming in the latter case that `tmp` is not accessed again) an optimizing compiler will optimize away the local variable completely and avoid having to do any copying, i.e. it will generate code as if you'd written: typedef struct { double x, y; } point; point *p = malloc(sizeof(point)); p-&gt;x = 1.5; p-&gt;y = 3.7; Note that this doesn't work with array types because they undergo pointer decay and can't be assigned: double (*p)[2] = malloc(sizeof(double[2])); *p = (double[2]) { 1.5, 3.7 }; // error The left hand side of the assignment is an lvalue of type `double[2]`, but the right hand side has decayed to a value of type `double *`, which is not a valid assignment statement. It's the same reason that you can't assign arrays: double foo[] = { 1, 2 }, bar[] = { 3, 4 }; foo = bar; // error 
Note that you can also look at the javascript code for the online CRC calculator.
Thank you. My mind was been embiggened.
If you haven't come across "A PAINLESS GUIDE TO CRC ERROR DETECTION ALGORITHMS" then you should read it (http://www.ross.net/crc/download/crc_v3.txt). Not only does it explain CRCs, but it contains code to create any type of CRC you want, with several different implementations (tradeoffs between space and speed). 
The AVR toolchain includes the crc16 header file that gives you access to standard 16 bit CRC algorithms - I suggest you use these instead. Specifically, take a look at this: http://www.nongnu.org/avr-libc/user-manual/group__util__crc.html Use the following include directive at the top of your code: #include &lt;util/crc16.h&gt; A CRC calculating function could look something like: uint16_t CRC(uint8_t *ptr, uint16_t len) { uint16_t crc = 0xFFFF; while(len--) crc = _crc16_update(crc, *ptr++); return(~crc); }
&gt; and blow up anyways? Why isn't that worth avoiding?
What I mean to say is maybe throw an exit with a message saying that the allocation failed? 
&gt; check for a null return from this function as well Do you mean perform the memory check again after line 42? 
Would you want a function you called to just exit if it encountered an error instead of telling you about it?
Not every failed allocation is reason for stopping the program.
Why don't more people simply return the result of calloc?
Since the allocation failed, *something* has to happen because the current function can't continue. There are all sorts of options of how to abort. We could simply blow up by calling `exit(1)` or something similar, as you suggest. It would certainly deal with the immediate problem. But that's really a nuclear option. This allocation might have been optional, and maybe we could have kept going. There might have been files to flush or connections to close before the program exits. The point is we don't know what the best thing to do is this deep in the program because we don't know the context of the allocation. So we return an error value. We hope that whoever called this function knows what the right thing to do is. And if they don't, they can return an error value until someone does know what to do. In more structured languages, this would be handled by an exception, which would take care all this unwinding for us. In C, we have to do it manually.
Accessing memory at address 0 does not cause a segfault everywhere and all the time. You don't want to rely on the compiler to catch that for you, you want to test for it, and explicitly code error handling. Trust me.
Performing a check for null on pointers is even more critical because this is a library. In general it is good practice to check all pointers before use, however if a malloc fails because of memory exhaustion you are probably in big trouble. This null check is also to some extent misleading because a programmer might think they are protected, but pointers can be non-null and invalid. Some of the worst bugs I have had to investigate are for duff pointers where memory has been over-written. In our coding standards we have an explicit rule to check for null before pointer use. 
No, he means that whomever calls the map_create() function have to check if it returned NULL. struct map_t *m ; m = map_create(); if (!m) { //deal with error } 
&gt;Accessing memory at address 0 does not cause a segfault everywhere and all the time. Do you have an example of an environment where it doesn't? With the exception of a few embedded things without MMUs and that also allow valid data/code in the first page, accessing things in the first page will almost always result in a OS exception or CPU trap. (e.g. certain ARMS have valid page 0s and no MMUs and I guess if you're writing in kernel mode you might be able to access it). However, if you have a hugeeeee structure then 0x0+offset could hit a valid page I guess. 
Utter nonsense. As you have discovered, it may well make sense to return allocated memory and expect the caller to free it. The trick is to document this fact clearly. For example, my man page for the standard library function strdup() says: DESCRIPTION The strdup() function returns a pointer to a new string which is a duplicate of the string s. Memory for the new string is obtained with malloc(3), and can be freed with free(3). 
That's fine, but if you provide an API like this, please also provide (as the C standard library does) an alternate facility to use a buffer that the caller provides. Otherwise you risk making your API unsuitable for use in tight loops where a malloc/free combination is far too expensive. 
Ah, I didn't think of this... I could solve this by asking for a allocate function as part of the parameters. They would be freeing it, so they should know how they want it allocated. 
Very good point. I couldn't think of an example that uses malloc(), but still worth mentioning is stuff like ctime() and ctime_r(), which respectively return a static buffer or take one as an argument.
* A natural integer type for generic array indexing is `size_t`. Your implementation for some reason insists on using `uint32_t`. Why? The same happens in your list, where `uint32_t` looks even more out of place. List is a container that is conceptually larger than even `size_t`. List calls for `uintptr_t` to store element count. * Your poymorphic `clone` and `dtor` functions accept elements to operate on, but provide no meaningful way to pass any additional user-provided data to these functions. This is often a major impediment. * Your array implementation does not notify anyone when array elements are moved to a different location in memory (inside `resize` function and others). In some cases it might be necessary. Might be a good idea to add a callback for that too. * You included `&lt;stdint.h&gt;`, but didn't include `&lt;stdbool.h&gt;`? * In code that uses C99 features, things like uint32_t i = 0; for (i = 0; i &lt; n; ++i) look strange. C99 gave us the reason and the opportunity to ditch that ugly habit of specifying dummy initializers in variable declarations for (uint32_t i = 0; i &lt; n; ++i) * Formally `%u` is not the correct format specifier for printing `uint32_t` values. The proper one is `%` concatenated with `PRIu32` macro. The latter is defined in `&lt;inttypes.h&gt;`.
&gt;&gt; Accessing memory at address 0 does not cause a segfault everywhere and all the time. &gt; Do you have an example of an environment where it doesn't? A quick search turned up [this FAQ answer](http://c-faq.com/null/machexamp.html). I remember reading that on PDP (probably PDP-11) address 0 was a synonym for the CPU's register 0, so it was readable, writable, and even executable. Edit: Also, I work on an embedded system where we can define the memory map to be anything we want. We place code starting just above address 0, and mark the code region as code (executable, not mapped for reading as data). But we could just as easily change this, and have address 0 as a valid data address. And we do have an MMU (well, Memory Protection Unit, there's no virtual addressing in it)
I think you're interpreting the rule a little differently than I am. In order to free malloced memory, you need to keep track of it. The `malloc`/`free` API doesn't give you any way of asking "What memory have I allocated so far?" So what I take away from this rule is, "Don't allocate memory unless you have a plan for how you'll free it." Someone should always be responsible for keeping a pointer to that memory, whether it's your library or the user. As much as possible, I try to write the allocation and the corresponding free at the same time. I put the allocation where it belongs (in a startup function, for example), and then go to the corresponding shutdown function and add a `free` for the same memory. If I pass ownership of it to the user, I add a comment around the point when I do so, as well as putting it in the documentation; this makes it clear that it's now the user's responsibility to free the memory. If you don't do this, you might get into a situation where you have no reference to the memory, or it's not clear who owns the memory, or there's no way to know when everyone is done using it and it's safe to free.
Well, why force the definition of a type before declaring your functions, when you could simply use (void*) pointers and declare once ? As it is, putting everything as static functions in your header files mean that you essentially compile twice and store twice the same functions. It is already borderline for a small project, and a big no-no on a big one, or as a library. Moreover, compiling against that and trying to debug will be a nightmare. Sorry, I'm not a specialist and have only used C for small projects, but I would never use that as it is.
Ah, a pointer that got stomped on or smashed... well in that case... If a pointer gets overwritten, the fault lies with whoever overwrote it. If it's a buffer overflow in your own thread, fix it. If it's some other thread who stomped on your memory, fix the other thread. You can't defensively code against someone else overwriting your own memory. (Okay, you *can*, but it's exceedingly difficult and almost never worth the effort.) I've had to debug those, too, and it sucks. Even if you're able to notice that something's wrong with your pointer, it's already been overwritten. Inevitably, the only solution is to catch it in the act somehow. Usually I'm able to reproduce the problem and set a hardware breakpoint to stop when someone writes to the pointer, at which point I can backtrack and find out why they're doing that. But it's tedious as fuck, if you're able to do it at all.
I wasn't suggesting exiting as a strategy for fault-tolerant systems any more than you were suggesting that your code was designed for satellites. In my experience in general-purpose computing environments, the only time alloc fails is when the computer is so badly screwed as to require reboot, and trying again, especially with no delay, is perhaps the worst thing to try. Shrug. I wouldn't say either strategy is a one-size-fits-all. 
I compile your code and get back from valgrind ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 15 from 15). I am also running on OSX. Perhaps this is unrelated, but when was the last time you did a `brew update`? Also, what version of the OS? 
fgets() is your friend. That's an extraordinarily verbose valgrind log full of chaff from your OS's libc. Wouldn't worry too much about it. 
The code doesn't have any buffer overflows so your valgrind report is finding things that aren't part of your code. (It could be bogus reports, or bugs in your compiler's runtime library or whatever). However it does have some bugs: * EOF or \n are actually stored in the output buffer and counted as a character. * `inputChar` should have type `int`. To understand why, read the documentation for `getchar`. 
You could try alloca()
*Might* segfault, not would. In the case where the malloc fails, the C compiler is free to compile the following code into anything it likes. Over time, compilers will probably be less and less likely to actually give you segfaults, especially at those locations, as the optimizers get 'better'. It is very much *your* responsibility to check for NULL and ensure the error is handled in an appropriate fashion.
I'm using version 10.10.1 of OSX and did a brew update and upgrade earlier today.
Thanks, i should say that i don't trust my tests :) The only thing i can see wrong with this approach is like you mentioned the use of macros that makes the compiler error report not so great (clang does a way better job than gcc btw) and the fact that as static functions these things will get included everywhere increasing the executable size, by how much i don't know. I have to admit the NIH mentality is something i tried to fight in the past but it's still here to some degree. Nevertheless i see this as a opportunity to learn how these data structures work and offer my own solution better or worse, i cannot learn just by using libraries made by others. Programming is just a hobby for me and i learned everything myself, not by reading books, not in school, just by looking at source code from others and by reading online blogs/tutorials.
Thank you i know about CCL but it's way too large for my needs, theres also many other great libraries out there like [cii](https://code.google.com/p/cii/), [klib](https://github.com/attractivechaos/klib) and others i can't remember right now.
I really dislike the *void** approach i think it's not optimal in both memory efficiency and speed, that is why i try to write something different, i do not know if it's better or worse. You are correct, debugging will be harder (some compilers like clang issue better error reports than gcc for example but it's still a problem) and executable size will increase but i didn't test by how much. Thank you for your opinion I'm not a expert either so i really value any feedback i can get :)
Is 10.10 even supported? The valgrind page doesn't say so. Apparently they got around to fix all the issues with 10.9 which also took quite some time.
Your open call is correct. You need to check after the call that the file pointer is non NULL. If NULL, you had an error of some sort. See perror example on cplusplus.com, http://www.cplusplus.com/reference/cstdio/perror/.
* Yes, creating a callback for relocated elements is a matter of your decision. It works either way. As you noted, it is always possible to detect the relocation from the outside. I just wanted to note that element relocation occurs not only when the entire array memory is reallocated, but also when the array memory remains in place, but some elements get moved during `insert` operation. If external code cares about element relocation, that external code will have to differentiate between these situations and figure out which elements moved in memory and which did not. Meanwhile, the array code already knows that anyway internally, which is why it is sort of "easier" to do it through a callback. But this is something that is needed very often, so it's OK without that extra callback. Again, is a matter of your design decision. * Regarding C99: your code seems to use it rather extensively already: variable declarations in the middle of the code, `inline`, flexible array at the end of the struct (not even mentioning library features). * Yes, it is `%zu` for `size_t`. The table you linked implies regular `unsigned` when it suggests `%u`, not `uint32_t`. Of course, on most platforms `unsigned` and `uint32_t` are the same (at least representation-wise) so the code is expected to work, but still from the pedantic point of view "we don't know" what's really hiding behind `uint32_t`. Which is why the library provides a format specifier macro for that.
&gt; I'd have to check for NULL's everywhere...care to suggest a better approach I don't think there is a "better approach". Since C doesn't have exceptions or any other mechanism for handling failure, it's pretty much standard that you have to check for NULLs and gracefully fail (or decline to do anything) when you get them. &gt; I don't know about abstracting everything, that was not my intention, if it seems to confuse users that i might have to do that. This is definitely a question of philosophy, coding style, and efficiency. Older C code would probably do what you did, and expect users to just access the struct member directly because that's the most efficient way. Newer code goes in the OO direction, where the struct should be treated like a black box, and you use functions to do everything, even if it's just reading a struct member. It can be a little less efficient (although if functions are inlined, it should end up being identical), but some people prefer the approach of providing a function for everything for consistency. &gt; Thanks for noticing my efficient code there :) i have to disagree with you on this one i don't think the slow way is better even if you have to modify the code (you can use a macro or something). Hmm, let's see. You have vlist_node(T__)* node = list-&gt;head.next; /* loop until the next node is the head node */ if (list-&gt;dtor != NULL) { while (node != &amp;list-&gt;head) { node = node-&gt;next; /* point to next node to avoid temporary */ /* call dtor and free previous node */ list-&gt;dtor(&amp;node-&gt;prev-&gt;value); free(node-&gt;prev); } } else { while (node != &amp;list-&gt;head) { node = node-&gt;next; /* point to next node to avoid temporary */ free(node-&gt;prev); /* free previous node */ } } Let's say I wanted to add some logging to it. I have to duplicate my changes, like this: vlist_node(T__)* node = list-&gt;head.next; /* loop until the next node is the head node */ if (list-&gt;dtor != NULL) { while (node != &amp;list-&gt;head) { LOG("node is %p, next node is %p", node, node-&gt;next); node = node-&gt;next; /* point to next node to avoid temporary */ LOG("now node is %p and prev is %p", node, node-&gt;prev); /* call dtor and free previous node */ LOG("calling dtor on %p", &amp;node-&gt;prev-&gt;value); list-&gt;dtor(&amp;node-&gt;prev-&gt;value); LOG("freeing %p", node-&gt;prev); free(node-&gt;prev); } } else { while (node != &amp;list-&gt;head) { LOG("node is %p, next node is %p", node, node-&gt;next); node = node-&gt;next; /* point to next node to avoid temporary */ LOG("now node is %p and prev is %p", node, node-&gt;prev); LOG("freeing %p", node-&gt;prev); free(node-&gt;prev); /* free previous node */ } } That's a fairly simple example, but even here I've had to duplicate 3 lines of code. If it had been written as a single loop, I wouldn't be duplicating code as much. In terms of performance, I doubt you'd notice a difference between the duplicated or non-duplicated versions even with lists of several million items. You could help the compiler by pulling out the function pointer as a `const`, like so: vlist_node(T__)* node = list-&gt;head.next; /* loop until the next node is the head node */ const void (*dtor)(T__* p) = list-&gt;dtor; while (node != &amp;list-&gt;head) { LOG("node is %p, next node is %p", node, node-&gt;next); node = node-&gt;next; /* point to next node to avoid temporary */ LOG("now node is %p and prev is %p", node, node-&gt;prev); if (dtor != NULL) { /* call dtor and free previous node */ LOG("calling dtor on %p", &amp;node-&gt;prev-&gt;value); dtor(&amp;node-&gt;prev-&gt;value); } LOG("freeing %p", node-&gt;prev); free(node-&gt;prev); } By making it `const`, the compiler may recognize that it can specialize the loop exactly the way you did, by pulling the `if` out and making two separate loops. But if so, it will be the compiler creating two loops, rather than you. &gt; I am using `__` after all my macro "variables" so users know they are macros and to minimize collision with external variables, no one would create something like `int t__=0;` right? Well, it's doing textual substitution before the compiler ever sees it. And the `t__` is only bound for the definition of the macro substitution. So I don't see how a global variable called `t__` could conflict with it. A macro definition of `#define t__ something` *might* cause problems, but even then I think the definition from the macro function argument takes precedence (although I'm not positive about that).
First, don't call `srand` in `get_new_word`. Only call it once ever, at the top of main(). As for your problem, `word_given` is basically a local variable within `get_new_word`. Assigning its value has no effect on `ctxp-&gt;word_given`. You need to pass in a pointer to this pointer: int get_new_word(const char** word_given) { (*word_given) = wordlist[rand() % WORDCOUNT]; return 1; } ... get_new_word(&amp;ctxp-&gt;word_given); Alternatively, since you're not really using the return from that function, you could have written it like: const char* get_new_word() { return wordlist[rand() % WORDCOUNT]; } ... ctxp-&gt;word_given = get_new_word();
Sounds good to me. Of course, there's other ways to implement hash tables besides having a linked list. But go with whatever you're comfortable with.
There's nothing wrong with that as long as you don't need a cryptographically sure random number....in which case you should not be using rand() anyway.
I'm an embedded programmer. I want all my data types "nailed to the floor" - so I know exactly how big they are and where they are. Abstraction is useful if and only if it INCREASES clarity. If it makes something needlessly more complicated, then it's best to avoid it.
It's funny you say that. If I take a step back and look at the bigger picture in abstract layers, then bigger projects seem less complicated. However, I'm only in my fourth term at school so my data structures programming is a little rough. I understand I will have to test thoroughly to make sure things are working on each layer. But that was another philosophy my professor was talking about: maturing as a programmer. I need to be comfortable with a vast majority of data structures in order for me to implement large scale projects from the ground up. Thanks for the insight!
Have you not heard of `fopen`, `fclose`, and `memset`
My enormous human-ant antennas indicate to me that he includes error handling to those basic functions.
I didn't. But that's a great set of ideas.
It's not officially supported.
You may be interested in the C Code Archive project: [CCAN](http://ccodearchive.net/).
What error handling though? Sometimes you want to do one thing and sometimes another. (And memset cannot fail). 
I'm assuming you mean the braces, [this](https://www.kernel.org/doc/Documentation/CodingStyle) should help you out
1 &lt;&lt; index will simply return a power of two which is being masked against whatever is in array[index]. The check here is to see if that single bit has been turned on in the number stored in that index. This can be used for things like maintaining a set of bitflags within index[] or just doing something like a decimal to binary conversion.
Example, handling partial writes correctly. I always have to write it and it's sort of a chore.
Awesome. Thanks everybody. The bitmasking is the piece that I was missing... 
If you're doing really small programs to start out, you could use [ideone.com](http://ideone.com/) through your browser. Personally, I downloaded Virtualbox and used a linux distro to learn C. 
Try [Cygwin](https://www.cygwin.com/) on for size.
I've been self-teaching myself C through various books/courses/series the last few months (I'm still not that great), and so I have some suggestions about good places to start learning. Books: * [The C Programming Language AKA "K&amp;R"](http://www.amazon.com/The-Programming-Language-2nd-Edition/dp/0131103628) by developers of C - It's short/concise and simple, but covers the whole language (because there's not that much syntax to cover), and *tons* of people swear by it like a bible. * [C Programming: A Modern Approach](http://www.amazon.com/Programming-Modern-Approach-2nd-Edition/dp/0393979504) by K. N. King - This book is much larger and more in depth than K&amp;R, with around 800 pages and lots of examples and exercises. It's essentially a college textbook and is actually used in colleges. * [Learn C the Hard Way](http://c.learncodethehardway.org/book/) by Zed Shaw - This one is free and online. I like it because it focuses more on you figuring out things on your own by breaking the code in various ways and having an absolute understanding of every line, rather than just having you copy everything and telling you how it works Courses/Videos: * [[Harvard CS50x](https://www.edx.org/course/introduction-computer-science-harvardx-cs50x)](http://c.learncodethehardway.org/book/) - An awesome, free online course with high production lectures, and helpful videos/tips if you get stuck. It mostly covers C, but it does go into other things (that are still worth knowing) at the very beginning and end. * [A Free Course for C Beginners](https://www.youtube.com/playlist?list=PL76809ED684A081F3) by Carl Herold - Not really a full course, just most of the videos. I found this very recently, and the original website doesn't exist anymore. It goes at a very relaxed pace and explains things incredibly well in a way that you will remember. These videos really solidified/helped my understanding of binary, hex, and pointers. I highly, *highly* recommend it over anything else if you're just starting out. * [Handmade Hero](http://handmadehero.org/) by Casey Muratori - You can watch and follow along with this guy as he programs a video game from scratch in C. He streams every weekday, usually has a Q&amp;A after, and [puts every video up on YouTube](https://www.youtube.com/channel/UCaTznQhurW5AaiYPbhEA-KA). The series starts off with a sort of rushed intro to C, and honestly the whole thing is always at a fast pace and can feel complicated. But that's what it takes to make a game from scratch, and he takes time to explain what everything means. Plus it's mostly all very interesting and useful. Resources: * Google - google everything, or Bing it, I don't care * [Stackoverflow](http://stackoverflow.com/) - someone probably asked your question before, especially with C * /r/dailyprogrammer - Great daily challenges. These are like working out your programming muscles. * /r/learnprogramming - Occasional posts about C, and you can ask/find your questions here as well * [Online C Compiler](http://www.tutorialspoint.com/compile_c_online.php) - A convenient compiler that you can use anywhere to play with simple programs using C standard library functions. Other than that, you should maybe look into trying out Linux, because it's more developer-friendly than Windows (such as having a C compiler out of the box). And the whole kernel and many core components of the OS are written in C, which are all usually open source, so you can learn from, and contribute to them. Good luck, friend.
Would you mind indenting your code with four spaces so it appears in a monospace font? This makes your code easier to read and others are more likely to answer your questions.
Today's Coffees has a [C](http://todayscoffees.com/quiz?lang=c) option, which is the only one of its kind I'm aware of. It's decent.
Would like to thank everyone for their help, I managed to understand the problem eventually so I think you for your persistent help.
&gt; What is the difference between (*p_ptr)-&gt;x_ptr and *(p_ptr)-&gt;x_ptr??? By the precedence of operators, the second means `*(p_ptr-&gt;x_ptr)`. So, in the first, you are dereferencing `p_ptr`, and then attempting to dereference that result *again* and access the `x_ptr` element. In the second, you are dereferencing `p_ptr` and accessing the `x_ptr` element, and then dereferencing that result.
(*p_ptr)-&gt;x_ptr performs the dereference first then applies -&gt;. This causes the compiler to try to dereference a struct rather than a pointer to a struct.
THANK YOU.
THANK YOU.
Like /u/BoatMontmorency says, most are pretty terrible. Youll find the answers are vague at best and incomplete at worst. That being said, I know Odesk has a test for C that you can look through. Can't speak for quality though.
Is this the first time you take a C test? I would suggest you just learn C, then these questions will become super simple. When I was in school I learnt C on my own, didn't even go to class and always got more than 100% on my tests.
My guess is that C isn't an easy or hip language to learn for it to be fun so there isn't a strong demand for one. . At least not for your average Internet student. Most people would bristle at the concept of pointers and having to consider memory management. I'm learning C on my own at the moment, just by book and reddit/stack exchange . It would be nice to have learn programming buddies but i don't see how this could be made fun to appeal to a larger audience. 
I assume it's somewhat easier to make interactive guides for interpreted languages as opposed to compiled languages?
[Ch](http://www.softintegration.com/products/), anyone?
Is even a ncurses based tutorial tough to make too?? There is an interactive tutorial to java, afaik java is compiled into bytecode(and I also know java is sponsored by sun oracle and all those MIT guys), Also who said you need to make a C tutorial in C, I know javascript and php(I'm never proud of it!), and I know both of these allow execution of commands on the server terminal, However I don't know how risky that would be, it should be a sanboxed sandbox tut!
I did surely do that! Thanks for the recommendation(quite close to what I had in my mind!)
I think [Learn C The Hard Way](http://c.learncodethehardway.org/) is the closed to an interactive tutorial you can get. C is a language of many pitfalls; programming in C requires concentration and structured work. It's not a language to learn in an afternoon, unless your background is assembly, Forth, Fortran, or something like that (but then you probably already know C). The best advise I can give to you when you try to learn C is to keep the following thing in mind: C always does the simplest thing you can imagine. There is no smoke and mirrors, no magic and nothing special about what the language does. C does not try to guess your intent and will try to make something out of the program you write, even if it doesn't make any sense at all. Most programs compile, many of which really shouldn't. Watch the warnings the compiler throws at you.
&gt; I'll be your buddies, buddy, buddy. (No joke I'm going through c books ATM as well.)
Pthreads. Learn it sooner rather than later
Learn assembly first and everything it teaches you about memory management so you have a good grasp of programming close to the metal.
look around this site: http://geeksquiz.com/c-language/pointers/
vut r pee-thrids?
The lottery numbers.
"You're doing great"
Go to book store. Buy K&amp;R -- your welcome. 
I don't really know. It's been a very smooth learning slope for me because I started with a low level programming language toy for the z80 processor in the TI-84 calcs. "Keep it up."? "Don't forget to keep those bitcoins"?
No, But it would be nice to have one! Rather than I need an interactive tut to learn C, The fact their doesn't exist one was the reason I did post on reddit, And of course about Zed's book it was highly introductory when I read it, much like half of the lessons were missing(there wasn't even a mention of standard libraries just a I/O lesson I guess), Anyways having an interactive tutorial would be fun! Thanks again! 
There is some ambiguity in your definition of the conditions. For example, is ActionOne() to be executed if and only if *all* of A() **and** B() **and** C() are true? Anyways, I have made reasonable assumptions that I think you can understand below -- so I offer this as a starting point for you. int conditionsForActionOne() { return a() &amp;&amp; b() &amp;&amp; c(); } int conditionsForActionTwo() { return !a() &amp;&amp; !b() &amp;&amp; !c() &amp;&amp; d() &amp;&amp; e(); } void mainLoop() { while (!exitSignal()) { if (conditionsForActionOne()) actionOne(); if (conditionsForActionTwo()) actionTwo(); } } 
Indent four spaces. Maybe two. Never eight. No tabs. Stick with Emacs. Use makefiles. Write a simple OS.
Not so sure about this one. Learn C first, poi terms arithmetic and all that, then pick up ASM and have fun with it. I think that if you can exploit heap/stack overflows you know most of the memory secrets of Unix, and C will be even more powerful in your hands.
Thank you. This helps a lot. The case could be either all or some for A() B() C(). I'm mostly just trying to understand the overarching structure as someone approaching C.
Use KNF for your indentation. Don't let yourself get fooled by 1TBS, it doesn't work.
I know it's just 1998 but stick with C99, man. You picked a winner on that one. For OOP, how do you not know about Python though? Yeah, but indentation matters already! Go ahead and dabble with C++ but just know that it doesn't get good until around 2014. Maybe learn some assembly in the meantime?
Don't waste years with C. Learn it and move on to Python. 
&gt; When I call want to free them, is calling free on the pointer to SudokuBoard (variable named board) enough? No. You have to free() what you malloc(). That's pretty much all it comes down to.
I see. So something like this? void DestroyVector(Vector3d* toDestroy) { free(toDestroy-&gt;_x); free(toDestroy-&gt;_y); free(toDestroy-&gt;_z); } void DestroyMatrix (Matrix3d* toDestroy) { DestroyVector(toDestroy-&gt;leftColumn); free(toDestroy-&gt;leftColumn); DestroyVector(toDestroy-&gt;middleColumn); free(toDestroy-&gt;middleColumn); DestroyVector(toDestroy-&gt;rightColumn); free(toDestroy-&gt;rightColumn); } void DestroyBoard (SudokuBoard* toDestroy) { DestroyMatrix(toDestroy-&gt;topLeft); free(toDestory-&gt;topLeft); DestroyMatrix(toDestroy-&gt;top middle); free(toDestroy-&gt;topMiddle); // etc }
Ah, right. So in my instance, I should only be passing the pointers to free? Do I leave the OS to remove the chars, or will they will destroyed when no longer pointed to?
I am kind of worried now :P I don't know assembly, forth, Fortran etc. I am from a commerce background. I know c# and ASP.NET technology, C++,C and broken knowledge of java programming. What would you prefer me? should i go for Fortran or assembly? And yes i find Learn C The Hard Way a kind of interactive tutorial. But i rather believe it would be good to have a real interactive tutorial for C. Although i am new to C but i found and enjoyed many interesting facts and works on C. (Currently in love affair with C)
&gt; I've now set board to NULL after calling free on it (can't print after this, obviously). Is this the best practise for what I'm trying to achieve? Setting a variable to `NULL` does exactly one thing: It sets the value of the variable to `NULL`. Nothing else changes. No memory is being deallocated. Notice that after you call `free()` on a region of memory, the content of that memory region is *undefined.* That means, it may contain what it contained before, it may have been returned to the operating system (causing a crash when you try to access it), it may contain garbage, it may habe been explicitly overwritten by `free()` to prevent programming errors, or it may be used for a different purpose. Setting a variable to `NULL` is something I wouldn't do unless it's what you want. Setting variables to values you never read again will cause the compiler to emit a spurious warning “variable set and never read.” Also, catch-all initializing or setting variables to some value may shadow bugs where you forget to set the variable to an actually meaningful value.
hi. Yes i understand now and i am really having a hard time Understanding Socket and XCB. Or might be because of my work load i am not able to concentrate on it. I am just waiting for a small 1 week holiday. Till then, I am preserving all the question for you. :P
Okay. Sockets are complex, you might want to look for “bee's guide to networking” for that.
aah. I was in search of a good tutorial. Thanks. it is really complex. 
You copied my résumé? What does it look like now? I don't really care if you copy my work, as long as you obey the licenses and give proper credit.
Yes. I do that. Don't think me of that much of nuisance.
Just out of interest; what does your résumé look like now?
The formate is 97% yours. 3% edited. And the information is mine. I think i should mail you.
Do that if you like.
You can think of a union as overlaying two or more things on top of each other. `c` and `s` are both sharing the same memory, so if you change one you change the other. As zifyop points out, by a strict reading of the C standard, the only legal way to use a union is by reading from the same member that was last written to, i.e. it's legal to write to `c` and then read from `c`, or write to `s` and then read from `s`, but not to write to `c` and then read from `s`. (An example of how this might work is a discriminated union where there's some other variable that indicates which type was last stored there.) However, all mainstream compilers allow this behavior as a non-standard language extension because it's so common. As to the second question, on most systems, an unsigned char can represent the values 0 through 255. What do you think happens when you try to assign 1000 to that type?
this is my resume.(copied version) and i am consistently poor in studies. http://www.tinyupload.org/4mjvnj3odme
Yes. Numbers will be helpful. 
The original résumé was made with LaTeX (see file `cv.tex`). It would look much better if you just edited the LaTeX file instead of remaking it in LibreOffice. Also, you should try to get a picture in the right aspect ratio so it doesn't look skewed.
See [here](https://www.daad.de/deutschland/nach-deutschland/bewerbung/en/9199-visa-application/) for how to get a student's visa for Germany.
It was my advice to me and no assumption that C was my first programming language. Just that it would have benefited me to learn assembly before C.
yes. This is helpful
yes. Thank you
1. If you ask a *specific* question about unions (e.g. with a code sample), it usually implies that you already know what unions are *in general*. The whole idea of unions is based on the fact that that they store all of their members in the same region of memory, i.e. all union members *overlap* each other in memory. For this reason, any changes in one member of a union will be generally seen as changes in all of its members. This is exactly what happens in this case. Member `u.s` gives you access to the same region of memory as `u.c`. So, when you change `u.c` you automatically change `u.s` at the same time. 2. Unsigned integer types implement *modulo arithmetic* in C. The modulo is 2^N, where `N` is the number of value-forming bits in the type. E.g. `unsigned char` implements arithmetic modulo 2^CHAR_BIT (`= UCHAR_MAX + 1`). In your case it is apparently `256`. And `1000 = 232 (mod 256)`. This is where `232` came from. P.S. C language itself does not guarantee support for bit-fields of type `unsigned char`. For bit-fields the language explicitly supports only `int`, `signed int`, `unsigned int` and `_Bool`. Anything else is formally a quirk of a specific compiler and is non-portable.
How many times is `malloc()` called when executing this: SudokuBoard* createGameBoard(){ Vector3d* myVector = NewVector(1, 2, 3); Matrix3d* myMatrix = NewMatrix(myVector, myVector, myVector); SudokuBoard* myBoard = NewSudokuBoard( myMatrix, myMatrix, myMatrix, myMatrix, myMatrix, myMatrix, myMatrix, myMatrix, myMatrix); return myBoard; } Each of `NewVector()`, `NewMatrix()`, and `NewSudokuBoard()` calls `malloc()` once, and you call each of those functions once, so you've made three allocations. To free this memory, there must be exactly three calls to `free()`. But you're calling `free()` many more times than that (27 to be exact) so this has no hope of ever working. Remember, it's illegal to call `free()` more than once on the same allocation. Moreover, this whole design stinks. You've only created a single vector, and then you're creating a matrix that holds three pointers to that same vector. I'm almost positive this is not what you want. This is a matrix whose three rows are always the same, because there's only one actual row. Similarly, you have created a single matrix, and then a Sudoku board that holds nine pointers to that same matrix. This seems like an extreme over-complication. Most of the time when people write a Sudoku solver, they start with: int board[9][9]; If you really want to get fancy and be able to refer to individual boxes, then perhaps you want: typedef int box[3][3]; typedef box board[3][3]; ... board myBoard; Now you can refer to e.g. `myBoard[1][1][0][2]` which is the top row, rightmost column of the middle box. But there's no need to go `malloc()` crazy or have any of these create/destroy functions. The above example uses automatic lifetime; the memory is automatically reclaimed when control leaves the scope in which `myBoard` was declared. 
Yeah, I should have made that clear at the outset: I'd decided, whilst developing to only use one instance of each struct because otherwise I'd have ended up writing more code just to create all the instances I needed. I can see now how this might have made the issue worse. &gt; How many times is malloc() called when executing this: &gt; SudokuBoard* createGameBoard(){ &gt; Vector3d* myVector = NewVector(1, 2, 3); &gt; Matrix3d* myMatrix = NewMatrix(myVector, myVector, myVector); &gt; SudokuBoard* myBoard = NewSudokuBoard( &gt; myMatrix, myMatrix, myMatrix, &gt; myMatrix, myMatrix, myMatrix, &gt; myMatrix, myMatrix, myMatrix); &gt; &gt; return myBoard; &gt; } &gt; Each of NewVector(), NewMatrix(), and NewSudokuBoard() calls malloc() once, and you call each of those functions once, so you've made three allocations. To free this memory, there must be exactly three calls to free(). But you're calling free() many more times than that (27 to be exact) so this has no hope of ever working. Remember, it's illegal to call free() more than once on the same allocation. This make so much sense now. I was under the impression that I had to call free on each member that was a pointer, for each struct. Complete rookie move. Thanks.
What's said elsewhere in this thread is true, however you shouldn't be using pointers for most of these things. Not only will what you've written will be very slow (because it uses malloc/free, which are slow, and because you're going to absolutely destroy the cache), but it's harder to manage because of all the allocation/freeing you're doing. (Not to mention, if you write the code the way you're doing you'll have to do waaaay more bookkeeping and you'll end up thinking C is an awful language, which it isn't). Here, I've taken the time to convert your example to something will be easier to maintain, perform better, and use less memory: http://pastebin.com/0DWTJcBi . At the end of this, you will be able to free(board) and have that be the *only* thing you free, since it's the only thing that you allocated with malloc. Essentially, not everything needs to be a pointer. The vectors are stored inline on the matrix, and the matrices are stored inline on the Board. If you're used to C#, it's sort of like the difference C# makes between struct and class, if that helps.
It's the removal of this line which is giving you the duplicated output: hints.ai_socktype = SOCK_STREAM; Since you're no longer specifying the type of socket, you're getting the resolved IPs for the various socket types: SOCK_STREAM, SOCK_DGRAM, and SOCK_RAW. You can see this by also printing out the `p-&gt;ai_socktype` variable for example.com. There are other SOCK_* types, but you normally don't see them. $ ./showip example.com IP addresses for example.com: IPv4: 93.184.216.34 (1) IPv4: 93.184.216.34 (2) IPv4: 93.184.216.34 (3) IPv6: 2606:2800:220:1:248:1893:25c8:1946 (1) IPv6: 2606:2800:220:1:248:1893:25c8:1946 (2) IPv6: 2606:2800:220:1:248:1893:25c8:1946 (3) `man socket` will give you more information about this.
Wow, that's super helpful. Thank you very much :) I was under the impression that passing by pointers (which is what I would have been doing, once I've gotten the data types down) was quicker than passing data types around. Then again with yours, once the board is instantiated, it's one pointer to the whole thing. Yours definitely makes more sense than mine. I'm going to put this down to being quite rusty at C, as I haven't done any full on C in 4-5 years (done a fair bit of C++, and picked up some bad habits, in that time thought). It looks like I've gonna have to go back and review some parts of my knowledge.
It's quicker for large-ish objects, but these are small. Also if the function you're passing to can be inlined, then it usually doesn't matter even for large-ish objects (I'd still pass anything bigger than say, 256 bytes as a pointer, and if the function isn't inline, then I'll probably just pass a pointer no matter what, for abi reasons). Passing a pointer doesn't require heap allocation though, you can just pass the address of something on the stack (e.g. something like `Vector3 foo; InitVector3(&amp;foo, 1, 2, 3);`). Don't store that address from the stack though (not only will it be slower, you'll frequently have dangling pointers this way), this is just for parameter passing. Store it in the object, or as a pointer to malloced memory if you need that, instead. BTW, For stuff like Vector3, I recommend using C99's syntax (assuming you're using a C99 compiler) for initializing structs: `Vector3 foo = (Vector3){.x=1, .y=2, .z=3};`. Nothing like that for initializing things on the heap though.
Here's a copy of Clean Code and Code Complete. The best way to get out of insert move in vi is ctrl-[. CMake get's released in 2001.
 typedef struct { char _x; char _y; char _z; } Vector3d; typedef struct { vector3d* _leftColumn; vector3d* _middleColumn; vector3d* _rightColumn; } Matrix3d; I know this isn't your question but shouldn't vector3d have the same capitalization in the definition and the member pointers in Matrix3d?
Ok, so you have no clue what youre doing. 1. The main function is of type 'int'(int main(), not main()) 2. You don't need to include stdio.h twice 3. You end statements with semicolons, not colons, which i assume is a typo. Now, after you've fixed these things, look at the error you get and tell me your thoughts on it.
You give away the show too quickly, comrade!
And what does the compilation error tell you?
Yes. This is useful. Thank you
I think I just figured it out :'D But I'll definitely do that next time I need help!
What makes you think there's a display? ;-) Seriously, the devices I code for are for Voice-over-IP. They end up inside a box that has some blinking lights on the front, and a web page for configuration (much like your router at home). We do have a logging system, so processes that want to can set up an ID and write to it. But that's custom work. Your library wouldn't know about that, unless it's a library written specifically to run in our environment. Library code that wants to be reusable should do only exactly as much as it needs to. Unless it's a library meant for manipulating the display, it shouldn't assume there *is* a display. Here are things that *do* work: * Just return an error code. This is standard C practice for most libraries. The documentation should indicate which API calls will allocate memory, and how those will indicate failure (usually by returning ENOMEM on POSIX, or one of your library-defined error codes if you want to be really portable). * Have a way to get an error string to the user. This might just be a single function that translates an error code into a string. Or you could somehow build up a string and pass it back to the user (kind of like an exception), but doing so would require either a fixed buffer, or allocating memory, neither of which are ideal. * Have a configurable logging facility. Set up some macros and functions so that you can put logging into your library, but it's configurable to how the user needs it for their system. If they can't use it or don't want it, they can `#define DEBUG_LOG` to nothing and the logging will go away. If they want `printf`, you'd likely have already done that yourself, so it would be easy to enable. If they want something more complex like my logging system, the macros and functions should be flexible enough to let me do that. Flexibility is the key, of course. The API for my logging system requires a log ID (so it knows which task the message is coming from) and a severity level. I expect I might have to edit the library's code a little bit (to get it to register a log ID), but otherwise I'd want it to be fairly simple to change some functions or macros to add these extra parameters, without having to edit every single place that logs something.
What you can do is this * If you know that your board will always have fixed compile-time size 3x3 then you can simply do typedef char TBoard[3][3]; TBoard *create_board(void) { TBoard *b = malloc(sizeof *b); for (unsigned i = 0; i &lt; 3; ++i) for (unsigned j = 0; j &lt; 3; ++j) (*b)[i][j] = '-'; return b; } int main() { TBoard *b = create_board(); /* work with (*b)[i][j] */ free(b); } * Alternatively you can do this (which is "using a pointer to arrays of 3 characters" actually) typedef char TBoardRow[3]; TBoardRow *create_board(void) { TBoardRow *b = malloc(3 * sizeof *b); for (unsigned i = 0; i &lt; 3; ++i) for (unsigned j = 0; j &lt; 3; ++j) b[i][j] = '-'; return b; } int main() { TBoardRow *b = create_board(); /* work with b[i][j] */ free(b); } * Finally, if you want to stick with your method (which potentially allows for boards of any run-time size), you can allocate secondary memory in one block char **create_board(void) { char **b = malloc(3 * sizeof *b); char *bm = malloc(3 * 3 * sizeof *bm); for (unsigned i = 0; i &lt; 3; ++i) { b[i] = bm; bm += 3; for (unsigned j = 0; j &lt; 3; ++j) b[i][j] = '-'; } return b; } int main() { char **b = create_board(); /* work with b[i][j] */ ... free(b[0]); free(b); } The first two methods will indeed offer reduced memory usage. The third might too. As you can see, feeing the memory is done in one shot in the first two methods.
&gt; My question here falls along the lines of this. Is C smart enough to know when it hits a null character to break out of the while loop? Yes, it is. Let's look at that loop: while ((c = *word++)) A lot is going on in this very simple statement. First, `word` is dereferenced to get the character it points to. This character is assigned to `c`. `word` is then advanced to the next character. Finally (and this is the part you care about), the value in c is checked against the null character, which is the test condition for the while loop. Think of the assignment operator as a function that returns the value assigned. The return value is implicitly checked to see if it's non-zero. So, the code could have been written (if there were an actual function called `assign`): while ( assign(&amp;c, *word++) != '\0' ) Notice the second set of parentheses. They're redundant, but the goal is to tell the compiler that you know what you're doing. Normally, a single `=` would suggest a bug (most people want to do a comparison, not assignment in a conditional statement). The extra parentheses silence the relevant compiler warning. &gt; Question- The use of lowercase is arbitrary, correct? I could have easily used toupper(), right? The original algorithm at the link in your code has no case conversion. I believe the idea here is a modification to make the hash the same regardless of the case of the text. So, yes, `toupper` would have been just as acceptable to achieve that goal. The final hash value will, of course, be different, but it's internally consistent. Just don't try to compare against a hash computed with `tolower`.
&gt; Is C smart enough to know when it hits a null character to break out of the while loop It is not about C being "smart enough", it is about what's explicitly written in the code. Expression `c = *word++` (used as the `while` condition) evaluates to the new value received by variable `c`. This means that the moment `c` receives zero value from `*word` (i.e. the moment the cycle condition becomes zero) the cycle will stop. &gt; The use of lowercase is arbitrary, correct? I could have easily used toupper(), right? Yes, technically you could. The idea is to make the hashing function case-insensitive. Most of the time I see the characters converted to *lower* case for such purposes. But upper case will work too, just remember to be consistent.
AF_UNSPEC is 0, so the second line doesn't do anything (although there's nothing wrong with being explicit about what you're doing). The first line is necessary to zero the structure, so you don't end up passing random gunk. If you don't provide a hints struct at all (i.e. if you pass NULL for the third argument of getaddrinfo()) then the manpage says it's equivalent to providing: memset(&amp;hints, 0, sizeof hints); hints.ai_family = AF_UNSPEC; hints.ai_socktype = 0; hints.ai_protocol = 0; hints.ai_flags = (AI_V4MAPPED | AI_ADDRCONFIG); which is basically the same as using the two lines you quoted, except you get the AI_ADDRCONFIG flag set (so it'll only return v4 addresses if you have a v4 address assigned, and likewise for v6). (You also get AI_V4MAPPED, but according to the manpage AI_V4MAPPED has no effect unless you also use AI_ALL or hints.ai_family = AF_INET6, neither of which are set in the default hints struct. So I have no idea what that flag is doing there.)
&gt; c int is initialized. `c` is declared, but not initialized. (Additionally, in this case the declaration is also a definition, but not all declarations are definitions.) Note that initialization is not the same as assignment, although they both use the equals sign. 
Thanks /u/Rhomboid &amp; /u/boredcircuits. Great explanations and gave me some more clarity.
Even with that limitation, pretty cool. The DEC 10 was much beloved at MIT, Stanford, and a few other universities, but its positives tended to be a two edge sword. It had interesting and unusual consistencies/orthogonalities in its instruction set that they liked, but that also meant there were on the order of a hundred different kinds of NOPs. While it was amusing that people argued about the fastest NOP for each CPU model, the real negative is that this implied instruction density less than it otherwise would have been. Olin Shivers taught one of your classes? Cool.
Your macro #define Parameter will essentially do a find and replace, and replace all instances of `Parameter` with nothing. Since `Parameter` is the name of a struct, your struct definition turns to struct { ... } This is the source of the unnamed struct error. You should make your header guards have more unique names.
It's typical convention to use all caps for macros used in an include guard, such as `PARAMETER_H`. This makes it hard to overlook these kinds of problems.
Visual Studio is a great IDE/compiler/debugger if you're on Windows. Other than that, Clang is a cool for beginners because it tries to be more clear with its error messages. I don't think there's really much of a difference in skill level between compilers, you just pick one that works for what you're doing, and learn to use it. It's probably better to learn compilers that are more ubiquitous than not.
Problem comes when both sizes of firstname and surname dont match. Ideal way would be to deal them separately. The solution would be: #include&lt;stdio.h&gt; void main() { char firstname[30], surname[30]; int len,i=0; printf("\nEnter your firstname in lowercase\n"); gets(firstname); printf("\nEnter your surname in lowercase\n"); gets(surname); while(firstname[i]!='\0') { if((firstname[i]&gt;96&amp;&amp;firstname[i]&lt;123)) firstname[i]=firstname[i]-32; i++; } i = 0; while(surname[i]!='\0') { if((surname[i]&gt;96&amp;&amp;surname[i]&lt;123)) surname[i]=surname[i]-32; i++; } printf("\n Hi %s %s\n",firstname, surname); } 
You should get in the habit of compiling your code on as many different compilers as you can, each with diagnostics turned up to the maximum. This will provide the best diagnostic coverage, as well as alerting you when you use non-standard language extensions or non-portable APIs. 
I agree on using the command line and Vim or Emacs, but clang is a little friendlier than gcc.
VS is a terrible C compiler though, and does not give error messages as easy to read as clang either. (Although I personally think the ease-of-reading for the error messages is more of a factor when it comes to C++.) I think clang is definitely the better choice for a beginner who wants to learn modern C, although I don't know how easy clang is to set up on windows nowadays.
Unless you want to run this through obscure compilers, you can also just use #pragma once at the top of the file (nothing at the bottom required). It's not standard, but the most common compilers support it. It's less typing, and more importantly, less error prone.
Use tolower() and toupper() instead of hardcoding a character set. Or use Unicode, but that might be too advanced... And for the love of all that is holy, **never ever** use gets().
Well it wouldn't be a very good learning assignment if he just called a function to do all the work for him. Rewriting a function on your own is one of the best ways to understand how it works, and is a great skill/habit to have. After this assignment, he can call `toupper()`/`tolower()` in confidence, because he'll know exactly what's happening behind the scenes. It gives you a more complete understanding of what you're doing, and it's just more good ol' coding practice. Also what's wrong with gets? (I'm new to programming by a few months)
Turbo C!
Clang is probably the best. The output on errors will tell you exactly whats wrong, with literally an arrow pointing to the error. To make it easy to use, add the following to either /etc/profile or ~/.bashrc: export CC=clang export CFLAGS="-g -Wall" That makes clang the default and turns on ~~all~~ a lot of compiler warnings without having to specify it each time. Assuming you meant a text editor and not a compiler (because the question doesn't make much sense) Caret is a nice choice. It's a chrome webstore app that has syntax highlighting and good punctuation helpers (if you make a " for example, it will automatically add a matching one). Due to being a part of the chrome webstore, it is cross platform. Windows, Mac, Linux, ChromeOS are all supported. EDIT: Corrected -Wall flag and fixed typo. TIL about Wall though. I always thought it made every warning. EDIT2: I forgot to mention, but for usability sake (incase you don't know) when you start a project in caret, save it as "name.c" and it will automatically turn on C syntax highlighting. Also, once you are done, compiling your simple projects can be done with: make name Note that there is no .c after the command.
Rather than installing a compiler right away, it's worth considering that there are many free online IDEs/compilers which are great for learning programming and for trying out small code examples etc. E.g. [codepad](http://codepad.org) [ideone](http://ideone.com) [coliru](http://coliru.stacked-crooked.com) and more recently, the very promising [Cloud 9](http://c9.io). 
Ever hear of buffer overruns? gets(), like most original string functions, allows user to enter any sized input without regard to character array size. I.e. you make a char array 80 chars large but user enters 90, and function will happily overwrite anything after the 80 chars in memory.
Since you're a n00b with C, please take the following advice to heart: ***USE SPACES!*** You should already be used to using the spacebar from typing English, or whatever your native language is. :-) Why would you stop doing it just because you're writing code? Which one is easier to read? This... if((firstname[i]&gt;96&amp;&amp;firstname[i]&lt;123)&amp;&amp;(surname[i]&gt;96&amp;&amp;surname[i]&lt;123)) or this...? if ((firstname[i] &gt; 96 &amp;&amp; firstname[i] &lt; 123) &amp;&amp; (surname[i] &gt; 96 &amp;&amp; surname[i] &lt; 123))
do NOT use visual studio, it is an all-around horrific piece of software
Internationalization and case conversion/folding is a hard problem. OP's example only works on ASCII and related character sets, for example. Run it on an IBM mainframe that still uses EBCDIC, for example, and it'll fail miserably. Using the standard functions means you don't have to worry about it (And, honestly, in this day and age you shouldn't be using them for anything non-trivial either because they don't deal well with unicode or multibyte character encodings). If you're going to reinvent the wheel to learn how it works, don't make a square one. 
-Wall saves me from mixing up assignment and comparison operators pretty much daily.
You need a better teacher if that's what he's saying. Edit: anybody teaching C and advocating the use of gets() is demonstrating that they don't have a good enough grasp of the language to be teaching it. What else are they going to get wrong?
This worked, thank you.
"-Wall" won't give you every warning, use "-Weverything" for that. It's not supported in GCC, though.
Okay, point taken. :-) Still, it's a point I can't emphasize enough. Code isn't there just to get the computer to do something. It's also for other people to read and maintain. Writing code that's hard on the eye is a bad habit. Also applicable here is [this post from /r/ProgrammerHumor](http://www.reddit.com/r/ProgrammerHumor/comments/2sy33y/just_inherited_a_project_that_was_developed_by/). What are `96` and `123`? Why are you subtracting `32`? This could be much more readable by using the character values: `'a'`, `'z'`, and `('a' - 'A')`.
They're not supposed to be... 
If you're talking about the overhead required for each function call, then **scanf** probably takes up more memory when called due to all that's involved in its formatting/conversion checks. **fgets** just needs a variable to count how much it needs to read, and that's about it.
sure! * laughable UI, like you mentioned. it is the mother of all over-featured UIs where you can't find anything and they've literally had to resort to uncommon tactics of organization like right-justifying pane text to fit everything * so involved and overly-complex to do the littlest of things. try writing a hello world in VC. you'll almost certainly get linker errors the first time you "build" (compile? preprocess?) and you'll be stuck navigating the horrible world of dynamic linking on windows. the toolchain is absolutely the biggest block standing in the way of getting any meaningful work done in VC. just as complicated as the UI, full of "features" you'll almost never use. * closed source, who the hell knows what is actually going internally? at least with gcc, when it does some dumb optimizations that break your code, you can at least take an attempt at figuring out why through looking at the source. on windows, you're boned. * windows-only nonportable software. you're using a tool that will only ever make windows-compatible programs. this is so they can lock you in to using only windows. no POSIX, no portability, no nothing * pay for a "subscription" to use it, like this was ever a good idea * even less helpful error messages than GCC 
I bet the assignment doesn't read that way. Your code uppercases letters if and only if the corresponding letter in both names is lowercase. That is, if character 3 of the first name is lower, that doesn't matter UNLESS character 3 of the last name is ALSO lower, and then and only then are they both made upper. JOHN galt would remain unchanged . Ask yourself if that fits the problem definition.
&gt; I bet the assignment doesn't read that way. "The user will be asked to enter their first name and second name in lower case. "
afaik the VS team's advice if you want to build C is 'compile with gcc', MSVC is a C++ compiler
I think you mean an IDE. Try [Code Blocks] (http://www.codeblocks.org). It's simple. 
Yes, but, that doesn't say that "if both character N of the first name and character N of the second name are lowercase, update them both to be uppercase; otherwise, leave them unchanged".
gets() is fine for toy programs.
nope!
There are several open source libc implementations. Try looking through uclibc source code and seeing why you think one might use more resources than the other - any function with scanf in the name has to do a LOT more work than just reading the stream.
You could use a linked list ? Then you'd be essentially mallocing every time a new contract is added. You wouldn't need to set a database size. 
Sorry for the late reply. I just wanted to clarify. I think it is a good thing that you created your own list library. I'm not saying you should use a library that someone else wrote (If you check my post history you will probably see some of my own stuff). What I was getting at was the fact that most problems can be solved by a simple c array. Even though a c array is not a very elegant or flexible, it is very easy to understand and to write code around. Don't fall into the trap of using your list for everything. You will find your self really gunking up your own code.
"I've tried using realloc with no succes" is not a meaningful description of any problem. What exactly happened? Anyway, your code is riddled with many errors. Virtually each and every one of them is quite severe. The compiler has informed you about most of these errors with diagnostic messages. Why did you ignore them? * An obvious error in your code: when you `malloc` memory for your strings, you allocate exactly `strlen` bytes of memory. Here, for example people[i] = (char *)malloc(strlen(name)); phones[i] = (char *)malloc(strlen(phone)); strcpy(people[i],name); strcpy(phones[i],phone); This is insufficient. A string of length `N` requires `N+1` bytes of memory. An extra byte is required for zero terminator character. The above `strcpy` calls will overflow the allocated buffer and damage the integrity of the heap. The behavior is undefined. A typical manifestation of this undefined behavior is program abort in later calls to dynamic memory allocation functions. Note that the above actions (caluclate the proper length, `malloc` memory and copy the string) are combined in a popular `strdup` function. The function is formally non-standard, but is typically available on most platforms people[i] = strdup(name); phones[i] = strdup(phone); Finally, don't cast the result of `malloc`. * Another obvious problem that has already been mentioned is this `realloc` call people = realloc(&amp;people,(storage)*sizeof(char *)); The `&amp;` before the first argument has no business being there. * Another huge error is that you pass `people` pointer to your `AddNewContact` function *by value*. Any changes made to this pointer inside `AddNewContact`will not affect the value of that pointer in the calling code. I.e. whatever changes your `realloc` makes to the pointer value will be lost forever once `AddNewContact` completes. * This char searchterm[100]; ... scanf("%s",&amp;searchterm); is another example if an erroneous use of `&amp;`. You should not use `&amp;` when you passing an *array* to `scanf`. It will work properly in practice even with that extra `&amp;` (why - is a different story), but it is still formally incorrect. This error is repeated several times in your code. * You have an obvious pointer type mismatch in your `Execute(key,people,phones)` call in `main`. In most of your functions you declare the parameters as `char * people[], char * phones[]`. Why does `Execute` suddenly declare its parameters differently? 
Would you please indent your code with four spaces so it appears in a mono-spaced font? This makes your code easier to read for others. Have a look at the [commenting wiki page](http://www.reddit.com/wiki/commenting) for more details.
Edited! Sorry about that.
In `Create_Param` you have: p-&gt;name = ""; but then in Destroy_Param you do: free(param-&gt;name); You can only `free` things which were created by `malloc` and family, and `""` is not such a thing. To fix this you could either change to `p-&gt;name = calloc(1,1);` (an empty string), or `p-&gt;name = NULL;`. Your code seems to check for `param-&gt;name == NULL` in many places, so I guess your intent was that `NULL` is a valid state, however `Print_Param` has the line `if(strcmp(param-&gt;name,"") == 0)` which will crash if the pointer is `NULL`; so `Print_Param` needs to be revised to handle this case. The same problem (dereferencing null pointer) occurs in: * `Print_Param` * `sameString` * `main()`, `printf("Name: %s\n", getName(sParam));` because `getName` can return `NULL` I'd suggest that even if you stick with using `NULL` for the pointer, you make `getName` return `""` for a blank string. The most important thing is to be consistent throughout your code, either `NULL` represents a blank string or it doesn't. 
You might want to check out /etc/bash_completion It provides list of possible arguments for different commands and then bash uses readline to fill as much char as it can. That's it, not hard to do, you try to match unique words; ie ls test.sh test.sql &lt;TAB&gt; test.s 
I've reused termbox's utf8 'library'[1] several times. It's about as lightweight as it gets and you could easily build a string lib on top of it. [1] https://github.com/nsf/termbox/blob/master/src/utf8.c
People are saying clang, but any software that you can see the source code of will use GCC. Clang is used behind closed doors with "special sauce" addons you will never find. So you might as well go with something that will actually let you program.
The shell has hooks for doing programmatic completion. For example, you can tell the shell that when it has seen `git checkout` and the user types &lt;Tab&gt;, to run a command to print the names of all branches and use that as the list of completions. Programs can install these customizations in system locations, e.g. by adding files to `/etc/bash_completion.d/`. It's not hard to implement. Someone just has to do it for whatever command or utility you care about. 
If fread fails in the first loop then filecount will be uninitialized. As for the file, have you hooked up your debugger and stepped through the code to see what's going on?
Well, this was honestly just an exercise from a book. Guess they screwed up, I'll have to check the errata and submit this if it isn't there. Works great now, thanks.
Thanks FUZxxl, will do.
The code says &gt;96 and &lt;123, which only includes lower case letters, if I understand correctly, so it would leave upper case alone, right?
If you're on *nix machine, open a shell with `M-x shell`, and execute `cc test.c -o out`. This will compile your `test.c` file into a binary named `out`. Now you can execute that `out` file to see the results (in the shell, just execute `./out`). I suggest you read more about what compilation is and take a look at [smart-compile](http://emacswiki.org/emacs/SmartCompile).
Then I don't understand your point.
Thanks so much for that - now I am starting to really get it! :D I actually have Notepad++ and will actually use that to get started. I'll just do the gcc test.c -0 text.exe and run the .exe from Command Prompt until I get a fuller understanding, then I'll take a crack at emacs. Thanks again mate!
Take a look at [GLib](https://developer.gnome.org/glib/2.42/). It's not everyone's cup of tea, and is a pretty heavy-duty library, but it is certainly one of the most robust object-oriented C libraries out there. It includes excellent safe string manipulation through an abstract [string datatype](https://developer.gnome.org/glib/2.42/glib-Strings.html). It does not have a python-style api, but that is not really practical in C anyhow. It also includes unicode conversion utilities. Another advantage of GLib is that it interfaces very well with high-level languages, including python.
You never check to see if they enter 0 or a negative number for **storage**. Instead of looping through and setting everything to null, you could use **calloc** instead of **malloc**. You're missing a **return 0;** at the end of **main**. In **Execute** you **return** followed by a **break** which is never reached and is unnecessary. It could be simplified to something like: &amp;nbsp; void Execute(int key, char people[], char phones[]) { switch(key) { case 1: AddNewContact(people, phones); break; case 2: DeleteContact(people, phones); break; case 3: SearchByNumber(people, phones); break; case 4: SearchByContact(people, phones); break; case 5: PrintAll(people, phones); break; case 6: SortContacts(people, phones); break; } } &amp;nbsp; You also never actually use the return value, so there's no reason not to just make it a void function. **people** and **phones** are char\*\*, but Execute is expecting a char* arguments. 
Emacs + Windows + C Development? Look at HandmadeHero. https://www.youtube.com/user/handmadeheroarchive/videos - The Pre-Stream is basically setting up ( here: https://www.youtube.com/watch?v=F3ntGDm6hOs) - During the Videos a lot of C stuff is explained - Along the road was a Basic Emacs tutorial: (https://www.youtube.com/watch?v=hbmV1bnQ-i0) Have fun!
Yeah, you have to actually both read and think carefully. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**LLVM**](https://en.wikipedia.org/wiki/LLVM): [](#sfw) --- &gt;The __LLVM__ compiler infrastructure project (formerly __Low Level Virtual Machine__) is a [compiler](https://en.wikipedia.org/wiki/Compiler) infrastructure designed as a set of reusable libraries with well-defined interfaces. It is written in [C++](https://en.wikipedia.org/wiki/C%2B%2B) and is designed for [compile-time](https://en.wikipedia.org/wiki/Compile-time), [link-time](https://en.wikipedia.org/wiki/Link-time), [run-time](https://en.wikipedia.org/wiki/Run_time_(program_lifecycle_phase\)), and "idle-time" optimization of programs written in arbitrary [programming languages](https://en.wikipedia.org/wiki/Programming_language). Originally implemented for [C](https://en.wikipedia.org/wiki/C_(programming_language\)) and C++, the [language-agnostic](https://en.wikipedia.org/wiki/Language-independent_specification) design (and the success) of LLVM has since spawned a wide variety of [front ends](https://en.wikipedia.org/wiki/Semantic_analysis_(compilers\)): languages with compilers that use LLVM include [Common Lisp](https://en.wikipedia.org/wiki/Common_Lisp), [ActionScript](https://en.wikipedia.org/wiki/ActionScript), [Ada](https://en.wikipedia.org/wiki/Ada_(programming_language\)), [D](https://en.wikipedia.org/wiki/D_(programming_language\)), [Fortran](https://en.wikipedia.org/wiki/Fortran), [Ocaml](https://en.wikipedia.org/wiki/Ocaml), [OpenGL Shading Language](https://en.wikipedia.org/wiki/OpenGL_Shading_Language), [Go](https://en.wikipedia.org/wiki/Go_(programming_language\)), [Haskell](https://en.wikipedia.org/wiki/Haskell_(programming_language\)), [Java bytecode](https://en.wikipedia.org/wiki/Java_bytecode), [Julia](https://en.wikipedia.org/wiki/Julia_(programming_language\)), [Objective-C](https://en.wikipedia.org/wiki/Objective-C), [Swift](https://en.wikipedia.org/wiki/Swift_(Apple_programming_language\)), [Python](https://en.wikipedia.org/wiki/Python_(programming_language\)), [Ruby](https://en.wikipedia.org/wiki/Ruby_(programming_language\)), [Rust](https://en.wikipedia.org/wiki/Rust_(programming_language\)), [Scala](https://en.wikipedia.org/wiki/Scala_(programming_language\)), [C#](https://en.wikipedia.org/wiki/C_Sharp_(programming_language\)) and [Lua](https://en.wikipedia.org/wiki/Lua_(programming_language\)). &gt;==== &gt;[**Image**](https://i.imgur.com/dG73ZQL.png) [^(i)](https://en.wikipedia.org/wiki/File:LLVM_Logo.svg) --- ^Interesting: [^Clang](https://en.wikipedia.org/wiki/Clang) ^| [^Xcode](https://en.wikipedia.org/wiki/Xcode) ^| [^Chris ^Lattner](https://en.wikipedia.org/wiki/Chris_Lattner) ^| [^C++ ^AMP](https://en.wikipedia.org/wiki/C%2B%2B_AMP) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cnvybdw) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cnvybdw)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
LLVM is a good idea.
You'll have to install xcode and the command line tools ( from a terminal, "xcode_select --install", but after that's done it's a very nice environment. You'll have the same tools you're used to on linux.
Don't forget about XCode as an IDE. (Although personally I just use emacs)
xcode-select --install
I compiled your code without error (using the definition of `s_gets()` from [Prata](https://books.google.com/books?id=MAAuAgAAQBAJ&amp;pg=PA461&amp;lpg=PA461&amp;dq=s_gets+c&amp;source=bl&amp;ots=Y-n8dj1uw6&amp;sig=ZXaejVePhMHC_04wHxquIDl4PdU&amp;hl=en&amp;sa=X&amp;ei=8bC_VMv1MdGMsQTO6YDYDw&amp;ved=0CDcQ6AEwBA#v=onepage&amp;q=s_gets%20c&amp;f=false)) and the resulting program reads and writes from the book.dat file without any problems. Maybe the issue is a typo in your `s_gets()`.
OS X Yosimite is 100% POSIX-compliant. There is no better environment.
Not a big OSX user but as recall XCode had a very sweet debugger front end. Nicer than anything (free) for linux so that might be a selling point for OP.
GLib uses Lesser GPL, so you should have no issues with copyleft unless you modify the source itself. considering the size of GLib, even if it were given a permissive license, you would have to contribute a large amount of code to give you practical copyright control over the project. Other similar options are [Apache Portable Runtime](https://apr.apache.org/), which does not have an abstract string type, but includes safe string manipulation functions, dynamic arrays, and a good memory management system that would make it easy to roll one yourself. A third option is [Core Foundation Lite](https://github.com/fjolnir/CoreFoundation-Lite-Linux), the open source version of OS-x's C utility library. It uses the non-copyleft Apple Public License. It runs on pretty much everything except windows, go figure...
&gt; The best way to get out of insert move in vi is ctrl-[. Thank you!!
Thanks for all the help! It's kind of surprising there are not more of these type of fundamental libraries out there for C. I will most probably use GLib. Thanks again.
The are some other GCC flags you should know right off the bat, too, like `-std=c99`, without which you're by default limited to C89 functionality where you can't e.g. declare an iterator variable in a for loop expression. There is also a more recent C11 standard, activated in the obvious way, but GCC doesn't have complete support for that yet as I recall. If you ever plan to dive into the wonderful world of Windows programming, `-mwindows` will be your friend; you're on your own for figuring out what it actually does, but all your GUI applications will break without it! Optimization options are fun! Use `-On` to control how badly GCC mangles your code; `n` can be 0-3 or s for size, though I've yet to actually see a significant reduction in code size with `-Os`... I believe the default is `-O1`, but if you're going to be crawling all over your code with a debugger, let me save you some pain right now and suggest `-O0`. It doesn't disable *all* optimizations, but the code it generates will be pretty much exactly what you'd expect. When you're ready to roll, try `-O2` -- it might surprise you just how good the compiler can be! In general, try to stay away from `-O3`; it is known to have mixed performance results and to output code that is a bit less stable, according to the last I read. You should always run GCC with `-Wall` and `-pedantic`; together, they output *almost* every warning you could ever reasonably want to fix. It will be annoying in the beginning, but as you learn your way around the language, what makes well-formed code and what causes undefined behavior, you'll find they catch a lot of bugs for you. I believe that's all a beginner should possibly need... If I remember anything else, I'll let you know, and if you have any questions, don't hesitate to ask me or any of the other much smarter people on this sub!
While OS X has a POSIX certification, it is unknown to me how they got it. For instance, they use `bash` for their shell, which is known to be not POSIX compliant. The only POSIX compliant shell I know of is a specially patched version of `ksh88`.
Just for the record, /bin/sh and /bin/bash behave differently on OSX.. I ran into an odd case where I was doing echo -n inside a script... The /bin/sh version doesn't understand -n, where as /bin/bash does.. To see this: #!/bin/sh echo -n "test" vs #!/bin/bash echo -n "test Produce different results. Oddly enough, if you do /bin/sh --help, it claims to be bash.
Hey whats your setup? I currently use Xcode which I quite like. 
Probably Linux
&gt;If the user enters "John doe", are they supposed to get "JOHN dOE", on the basis that since the J was capitalized but the D wasn't? Because that's what it's doing now. No. It's not. It's converting an equal amount of character, if the name or surname is not the same length, it stops when it's done with the shortest.
You can always use [brew](http://brew.sh/) to upgrade vim and emacs (and pretty much everything else) on OS X, that way you don't have to deal with Linux on the desktop.
Git
True but it wasn't like Apple kept it a secret. They were very open with the fact they were switching to clang as the default and that gcc, etc would be symlinked. 
I quite liked doing C on Windows with Pelles C. It isn't perfect but it is a damn sight better than MSVC.
I actually prefer Linux on the desktop, but yes, for most people this is probably true.
The interpreter for the J programming language. [Check it out!](https://github.com/openj/core) it doesn't even look like C. It's absolutely surreal.
You make some good points. &gt; That said, the OP didn't ask about Windows, and I think Linux is still a better environment for programming than OS X. I was about to disagree with you here, but then I remembered a few of my friends back when I took Systems Programming in school. They were happily compiling their C networking project on their Macs up until the day it was due. Then they all went over to the lab (full of Linux boxes) and found that sockets did not at all behave the same on Linux... I can't remember the exact issue, but it was traced to Apple fuckery. Anyway- late submissions all around! And your example is even better. &gt; Where OS X shines for me is in being a very good compromise. And I totally agree with this part. 
GCC is world's better at embedded development Saying this as someone who still prefers clang for everything else though
euhm, afaik the apple sockets.h is the one from bsd. The bsd networking stack is copied by almost every commercial os, including windows and apple. If you follow posix things should just work (tm). e: was copied, not is; internals differ of course. It is the reference network stack however since the mid 80's.
Sortof. Ubuntu is better, IMO, since its linux. OS X is FreeBSD and not Linux. You have brew, but its not the same. 
I have a question. As a beginner, I notice that a lot of "senior" developers do not use IDEs, but I can image coding without one. Can you expand on why you dislike the automation, and what the benefits are of using something like Vim?
Exactly, not being caught up to C11 through patches is scary in 2015. Not to mention not even having full C99 support fourteen years afterwards for MSVC 2013.
You're awesome - thanks so much! I'll take you up on asking a question actually. When you say to use `-wall` and `-pedantic`, and the `-O0`, where would I add that to the `gcc test.c -o text.exe` command? at the end? or next to the `-o`?
I must ask, what are you developing? I am mostly coding for microcontroller interfacing but havent done any of that in xcode. Mostly done some c/c++ in xcode. 
Windows NT is 100% POSIX-compliant as well.
Thank you. I get what you are saying now. I still don't understand the code, though. And I have a lot more to do besides just changing to upper case for this assignment, so I'll give toupper() a go, and see if I get along better with that.
you can turn it to pure POSIX mode though.
http://lmgtfy.com/?q=automake+cross+compile+windows 1st result
Well, it *is* primarily a C++ compiler, so just use a proper C compiler instead.
&gt; I strongly second the general sentiment here, but the versions of things like vim and emacs that are included with OS X are positively ancient. You should plan on installing your own versions of that sort of thing. &gt; Even worse is bash, which is the last version before bash moved to GPLv3. It’s ancient with plenty of nice bugs.
&gt; Well, it _is_ primarily a C++ compiler, so just use a proper C compiler instead. That's no excuse. It compiles both C++ and C, and supports both in the documentation. Even if it mattered, [C++11 support isn't much better](https://msdn.microsoft.com/library/vstudio/hh567368%28v=vs.120%29.aspx). [Hell, MSVC 2015 doesn't have full support yet](http://blogs.msdn.com/b/vcblog/archive/2014/11/17/c-11-14-17-features-in-vs-2015-preview.aspx).
Interesting. That looks like hell to read, but i'm not the best coder so that might be why. 
It's actually pretty ok once you get used to the various macros they use. The source code includes an overview over how it works, including an explanation of the pivotal `A` and `J` structures. It helps having some experience programming with J to understand how J itself works.
No, it's hell to read. It looks deliberately obtuse.
That's why I would've said "Depending on whether the std lib contains it, you want to write it, or you use other libs" and not "Depending on whether the std lib contains it". People might want to write things just for the hack of it...
 /* x is statically allocated: declared in file scope, outside of any function */ int x; /* initialized to 0 */ int main(void) { /* y is statically allocated: declared with static keyword */ static int y; /* initialized to 0 */ /* z is automatically allocated */ int z; /* not initialized */ }
Thank very much, we'll look into this!
thanks man, now i understand =)
First glance: "Freaky error occured" cannot occur, but the fact you're checking for it may cause performance problems without optimization because itmeans that `is_prime` will get called twice in the event it is true. Declaring variables at the beginning of the scope is not good style, despite people doiing it. Declare variables in as small as scope as possible. So `divisor` should be declared on line 32, in the for loop statement. Also, you don't ned to calculate `max_divisor` before the else statement. Your code will say 1 is prime. 
One **is** prime, isn't it? Isn't it a big argument type thing. Also, thanks for correcting me. I've never understood the problem with declaring variables at the beginning of a function. It just...every single book does it.
One is neither prime nor composite. Older versions of C required declaring variables at the beginning of block, not because it's good style, but because compilers weren't as sophisticated as they are now. 
I'm reading from modern books. Is it really such a big deal to declare at the beginning? Also, thanks for clarification. One is not prime, inserted a condition to handle that.
You should not declare the beginning of a scope, unless it makes sense to do that. Like I said, declare variables in as small of a scope as you can. The declaration gives a lot of information, namely the initialization and the type, and it makes code a lot easier to read if that information is close to use. In addition, it makes smaller blocks of code easier to reason about, the same way avoiding global variables makes code easier to reason about. 
Alright, will try to get into that habit. I have a question: If my for loop was `for (max_divisor = 3; max_divisor &lt; sqrt(n); max_divisor++` would it recalculate sqrt(n) on every iteration?
I'll leave it as is. Seems pretty optimized, for someone with my knowledge.
1. Your cycle does not check the root value itself when the original number is a square. Consequently, your function reports that `25` is a prime. `25` is not a prime. 2. Piling up all variable declarations at the beginning of the function is a questionable practice (to put it mildly). Even in C89/90 we did not have to do that. And one of the greatest features of C99 (and you are actively using C99 in your code) is its support for variable declarations in the middle of the code, which allows us to declare variables *as locally as possible* and, consequently, declare variables with meaningful initializers int max_divisor = sqrt(n); for (int divisor = 3; divisor &lt; max_divisor; divisor += 2) { 3. Using explicit comparisons with boolean constants strikes me as odd. Boolean contexts are exactly the one in which implicit comparisons look right at home if (!is_prime(num)) { printf("Not a prime.\n"); } else { printf("It's prime.\n"); } 4. Using signed integer types for representing what is probably intended to be an always-positive integer value... Some people do that, some people consider it unacceptable. BTW, when it comes to integer division, a signed type might theoretically have worse performance with division/remainder operator on 2's-complement platforms. Not in this case, probably, and not something detectable, but anyway... 5. Since you are using a signed type, a good idea might be to do something for negative values of `n` inside `is_prime` as well as for zero value. Either report an invalid argument (if you consider it invalid), or maybe simply return `false`. I.e. it might be a good idea to rewrite the first `if` as if (n &lt;= 1) { return false; }
Even if the first four are unique, you could convert to a u32 and use a switch statement, I think.
Theoretically, it would, meaning that the language specification requires the Abstract C Machine to call this function on every iteration of the cycle. Practically, some compilers allow you to label your functions with compiler-specific *attributes*, thus providing the compiler with extra information about the function. For example, in GCC you can attribute a function as *const* (or *pure*). For *const* functions the compiler will assume that the same argument values always produce the same result. This lets the compiler to optimize code, replacing repetitive calls with a single call if the arguments do not change. Of course, if the function is relative simple, a smart compiler might be able to recognize a *const* function without any additional attribution by the user. In case of standard functions, like `sqrt`, I'm pretty sure any modern compiler will be able to optimize the repetitive call.
It depends on what they're looking for/how you interview. If they just want raw knowledge, I figure you could cram K&amp;R pretty fast. What do you feel that you aren't good at as a programmer? What you're not going to want to hear: while studying is definitely good, there really isn't any substitute for experience as a developer. Most (good) interviewers will want to get a feel for that. And there really isn't a substitute for actually having worked in the field. What may help you: most positions with 'X' years of experience aren't really that, and you can often get in with less. It doesn't hurt to apply, and worst that happens is that you get your stripes in an interview. A lot of positions are overstated, and often the place is looking for some subset of the skills.
This thing is plenty fast. I'll deal.
Quite frankly, if your hearts not in it, your hearts not in it. You'll never get good unless you apply yourself. And you'll never apply yourself if you don't want it. I'm a noob at this also, but i really want to learn this and over time i like to think that i might be able to read the Linux source code or some part of it and figure out how it works. 
I've participated in the IEEE 24-hour competitions before, there is no magic solution to avoid getting tired, but you can delay it a bit by walking around (outside) for 5 mins every hour, stay hydrated with water/Gatorade, and if you're so tired you cannot program fast/good, then take a 2-4 hour nap, shower, and go at it again. Avoid fatty foods since they release the hormone that makes you feel tired too.
Unless you are smarter or train better than other advanced guys, it is going to take you as long as it took them. Someone recommended lots of writing and code review, that's one way to train better, most people don't have the benefit of expert guidance. Anyway, learning C is just the beginning, C is easy. Learning the right libs and data structures for whatever you're into, learning how to USE the C language in your problem domain, that can take a while. Learning to write *secure* C code is nearly impossible, unless you are DJB.
Avoid the temptation to down a lot of coffee right at the start. The more you drink at once the further you'll crash. Try to caffeinate at regular intervals. The goal is to maintain your buzz.
This was an excellent explanation of the way things are defined for the C language. As a supplement, I'd like to add a bit of explanation about *why* automatic variables are garbage-filled and some things that can happen due to how compilers typically implement them. Although the C specification doesn't mandate *how* function local variables are stored, what typically happens is that each thread of execution in the program will have a segment of memory set aside as the "stack", and each function call allocates a "stack frame" by bumping the value of a register that tracks the allocated region of the stack memory. When a function call returns, the register is set back by the amount that was allocated for the returning frame. This method also typically manages some of the parameters and return value, as well as the address that the function needs to return to. Because your program's execution consists of a tree-like pattern of nested function calls and returns, the stack grows bigger according to the depth and size of the nested function call frames. When a call returns, none of the data on the frame for the returning function is erased, it just remains as it was used by the returning function. Because functions can be called from different places in a program, the frames will show up at different locations on the call stack at different times as the program runs. This is why it's so important to properly obey the storage lifetime of automatic variables. If you hold pointers to them beyond the end of their extent, the values *will* change unpredictably, and *writing* to those pointers can scribble garbage over the local variables of some other arbitrary function that's currently got a frame on the stack! This is the source of many hard-to-track bugs. Failing to properly initialize an automatic variable before use can be almost as bad, as *some* invocations may seem to work fine while others happen to have a value in that location that causes your program to misbehave. It's not entirely random, as it depends on the history of your program's execution, so sometimes these problems can lie hidden for a long time before some value happens to trigger bad behavior. Tldr; take the storage duration of automatic variables seriously, or it *will* bite you hard when you're least expecting it. And when you get mysterious bugs with data changing when it shouldn't, look for violations of storage duration discipline.
Turn on all warnings in your compiler, and pay attention to what they say: $ clang -std=c99 -Wall -Wextra -pedantic -O3 -o program program.c program.c:13:7: warning: unused variable 'response' [-Wunused-variable] char response = int_continue(); ^ 1 warning generated. You have three completely different variables all named `response` in your program, and you are confusing yourself as a result. The variable `response` that you are assigning to on line&amp;nbsp;13 is not the same variable as the variable `response` that you are testing on line&amp;nbsp;16.
Yes, that's exactly the case. The system sits idle for most of the time, but when a certain event occurs it needs to handle a bunch of commands in a very short time. Then it goes idle again. I was trying to remove both the strncmp calls and all the string literals needed, together with the if/else structure because for a set of say 20 commands supposedly equally probably I expect to have on average 10 calls to strncmp for each command in. I might be totally off course here, that's why I asked to more experienced people :) 
Thank you, that helps me assessing the problem a little better. Just a couple of questions: if my commands set allows for a perfect hash, do I really need to store the key values in the table? For a given set of approximately 20 commands, can I use a bucket size of let's say 75-100? I guess it comes down to the specific hashing function? Lastly, I apologise for my ignorance, but what exactly is a nested conditional tree? I've never bumped into that name before.
This is interesting: knowing that unfortunately the choice of the board wasn't given to me (I had to do with what they had already), what would you suggest?
 Use constants and write the switch against the constants. #define TEST 0x74657374 #define EXEC 0x65786563 #define CLEA 0x636c6561
The only issue I have with this is that its not portable across endianness. Although, I guess its only going to be used on Arduino. Actually, you could make it cross platform: s[0]&lt;&lt;24 | s[1]&lt;&lt;16 | s[2]&lt;&lt;8 | s[3] Assuming all commands are at least 4 chars long. And definitely define the constant in hexadecimal. Its much easier to read that way.
 S to the P to the aghetti SPAGHETTI!
On my phone and can't edit, but I do love my some spaghetti.
Whoa Colobot, i remember playing this game when i was a kid (in 2000 i think) really loved it back then, if you have children i really recommend it. You start on earth and then go explore alien planets (including the moon), program your bots to fight aliens gather/carry resources, build new things really fun. Oh, and the original game from 2000 is open source you can find it on [github](https://github.com/colobot/colobot). Have fun!
I like the jump table option. I'm going to investigate it.
Function pointers on AVRs are extremely expensive. I would avoid them whenever possible unless there's a huge benefit.
You might want to post this in /r/avr/ or /r/Arduino/ for better, embedded specific advice.
Don't continue this level of procrastination into your work, it will be noticed. This is a problem with a lot of recently graduated programmers they don't have skills in time management. As an owner of a medium size coding company this is actually part of our hiring process to check this for newly graduated programmers and make sure they get the training needed. 
Here's my idea for a more readable "simple switch statement hash" implementation. This is one of those cases where macros can improve readability: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define MKINT(A,B,C,D) (((A)&lt;&lt;24)|((B)&lt;&lt;16)|((C)&lt;&lt;8)|(D)) int main (int argc, char* argv[]) { const char*s=argv[1]; /* test code -- should check that strlen(s) &gt;= 4 */ const int i=MKINT(s[0], s[1], s[2], s[3]); printf ("DEBUG: %x, %s\n", i, argv[1]); switch (i) { case MKINT('t','e','s','t'): puts ("matched 'test'"); break; case MKINT('e','x','e','c'): puts ("matched 'exec'"); break; case MKINT('c','l','e','a'): puts ("matched 'clea'"); break; default: puts ("no match"); break; } return 0; } $ ./foo test DEBUG: 74657374, test matched 'test' 
That is a great solution. I always forget to use macros in C.
Ah so simple!
&gt; The standard [C99 says that](http://port70.net/~nsz/c/c99/n1256.html#6.5.8p5) comparing pointers with &lt;, &lt;=, ==,... only works if both pointers point to somewhere inside the same object OR one element past the object. It says that about the relational operators `&lt;`,&amp;nbsp;`&lt;=`, `&gt;`, and&amp;nbsp;`&gt;=`. The equality operators `==`&amp;nbsp;and&amp;nbsp;`!=` are not included in that section. It is perfectly fine to test any two pointers of compatible types for equality. &gt; My implementation of strend goes to the end of both strings and work its way backward until it reaches one past the beginning of one of the string It is not guaranteed that there is such a position as "one before the beginning of the string." Attempting to decrement a pointer that points to the beginning of an array yields undefined behavior. You should not decrement `s` if `s == s_start`, and you should not decrement `t` if `t == t_start`. You need to rewrite your function to avoid those operations.
I'm not sure here. You can initialize your static variables (and really you should be in the habit of always initializing your varaiables), so would it split some of them out of the bss section simply because they're initialized, and leave others there? Seems like way too much work. I'm not saying you're wrong, because I honestly don't know. But, it seems like it's amiss for the reason above.
compiles cleanly using `gcc --pedantic` so at least gcc thinks it's fine.
So 0x10c and Trillek have similar game concept to Colobot
I'm exactly sure but would the range of memory be 0 through n? Sorry, I don't know how to answer the address question. Should I turn the int** pointer into a char** pointer? 
Too add on to what /u/zifyoip said, if you were to try something like this: #include &lt;stdio.h&gt; main() { int x; printf("%d\n",x); } There is really no way of knowing exactly what the output of printf() will be. Basically whatever was left in the memory location &amp;x. Try compiling and executing this program to see the results on your machine. 
It's not a data structure, it's just code that looks like this: if (s[0] == 'y') { if (s[1] == 'a') { } else if (s[1] == 'b') { } else { error(); } } else if (s[0] == 'x') { if (s[1] == 'a') { } else if (s[1] == 'b') { } else { error(); } } As you can see, having a behavior specific to "xb" only takes two tests here, compared to potentially 4 tests if you did a strcmp per 'command' (the commands here are 'ya', 'yb', 'xa', 'xb'). I don't know anything about arduino programming - you should pay attention to the other commenters that do. But this is how I would approach the problem as stated. (If possible, I would try to make the wire protocol smaller - if instead of commands, you passed the offset of the command in a list, this would be pretty trivial to implement in several ways). Edit: 'Perfect Hash' means that for all the possible inputs, it will evaluate to distinct hash values - that can't be the case here, unless you are separately checking that the input is one of your twenty commands. The space of all strings of length 4 is a significant portion of maxint, far larger than the size of table you can afford to hold in memory.
You should read the man page for malloc() to find out how many bytes it allocates when you call it. Hint the 1st: if you want to store 30 of something, and you know how big each of them is, how might you call malloc() to do that? If those things are pointers, what can you use to determine how big a pointer is? Hint the second: sizeof(int) != sizeof( int *)
Function pointers are typically passed to some other method to be called at a later point. They allow you to abstract an operation. For example, suppose you are building a math expression parser and currently you support the four common operations. You may want to parse your expression but evaluate it at a later point (maybe it is an expression in terms of some variable whose value you will learn later). You can parse the expression and store the operator along with a function pointer that applies its operation to the left and right hand values. Later, when you decide to support more operations you don't need to rewrite how your expression is stored after parsing, you just need to know how to parse your new operators and add a new function pointer for its operation.
This sounds incredibly complex. So, I would parse an expression `2 + 4 * 8` to `4 8 * 2 +` and then at a later date call `mult(4,8)` and `add(2)`. Still not sure where function pointers come into play here. Thanks for the answer, though. 
Because without them you'd have to put gotos everywhere? :) I joke. They are useful for things like abstraction. Let's suppose you're writing a library that needs to read some data, but that data could come from a socket, or a file, or memory, or some weird thing you've never heard of. You make your library such that it takes a function pointer which it will use to get the data it uses. Now the user of the library can use whatever function he wants to send you the data. For example, he could just pass you a pointer to read(), or it could be a function he's written specifically for you. Also think about how C++ is implemented. It started as just a preprocessor wrapped around a C compiler. You can see how function pointers in structs could become instances of classes. This is just one use of many. The other big use of them is callbacks. If you're writing multithreaded code, you can pass a callback in which the code will call once whatever it's working on is done. This is REALLY handy! You can google callbacks to learn more. 
Consider an example: void apply_to_all(const int arr[], const int count, void(*f)(int)) { int i; for (i = 0; i &lt; count; i++) { f(arr[i]); } } void print(int x) { printf("%d\n", x); } void print_double(int x) { printf("%d\n", x * 2); } int main(void) { int arr[5] = {1, 2, 3, 4, 5}; // Prints every element of the array apply_to_all(arr, sizeof(arr)/sizeof(arr[0]), print); // Prints double of every element in the array apply_to_all(arr, sizeof(arr)/sizeof(arr[0]), print_double); return 0; } I wrote a function, `apply_to_all`, that applies an arbitrary function (as long as the function takes an `int` and returns `void`) to every element of an array. I pass the function I want to apply by function pointer.
The function pointer got lost in the language speak ;) The real value of function pointers is that you can select at runtime which function you want to call, so long as their types match. In the spirit of the parent poster, you would not call mult() or add() yourself. you would call a function pointer that is just another member of the struct that stores parts of the expression. in stead of something like this: struct EXPR { int op; struct EXPR* left; struct EXPR* right; int value; }; int calc( struct EXPR* e) { switch( e-&gt;op) { case OP_ADD: return calc(e-&gt;left) + calc(e-&gt;right); case OP_SUB: return calc(e-&gt;left) - calc(e-&gt;right); case OP_VALUE: return e-&gt;value; } } you would have something like: struct EXPR { int (*calc)(struct EXPR*); struct EXPR* left; struct EXPR* right; int value; }; int calc_add( struct EXPR* e) { return calc(e-&gt;left) + calc(e-&gt;right); } int calc_sub( struct EXPR* e) { return calc(e-&gt;left) - calc(e-&gt;right); } int calc_value( struct EXPR* e) { return e-&gt;value; } int calc( struct EXPR* e) { return e-&gt;calc(e); } 
This looks like a good start on how to implement a calculator. Neat.
There's an example on the qsort manpage. Type "man qsort" on a Linux box. I don't have a BSD-alike to hand to check the manual there but I'd be surprised if there's not an example in that.
Ah, there is an example. Didn't scroll that far down.
I am pretty new. I believe I need to use dynamic memory because there could be any number of lines in the file, and the lines can be any length. I don't really understand the difference between those pointers, could you explain it?
I like this explanation. Very clear. But how do they increase speed? Calling `myFuncArry[1]` would be just as fast as `myFuncArray[2]`...and so on, wouldn't it?
The real question when should you use it. Im with you in the respect where i have never seen a situation where i needed it but i can imagine scenarios where it might be useful. Another question that we should ask is whether a function can return a pointer to another function. I can't imagine what the syntax would look like but it could be useful. 
It took me 15 years and tens of thousands of hours before I think others would have considered me "advanced". What helped out the most was also learning and writing Assembler code alongside the C. But it also depends on your definition of advanced. I know too many "advanced" C programmers that are completely helpless using other peoples code, libs, or non-standard compilers/environments. Most C programmers are completely clueless as to how the compile &amp; link stages work. At work the "programming test" we give candidates is hilarious because of how simple yet effective it is. We give them the Quake 3 source code and tell them to get it to compile. That is it. They un-zip a file and try to compile it. Oh how these experts with 20+ years experience fail so badly. If someone can't even get someone else's code to work, then we really do not care what kind of code they can write. They are useless to us. There is a tremendous amount of code out there that is free and ready to be used, and these people would not be able to use it, they would need to write their own code to solve every problem, and waste so much time in the process.
Here's an example using qsort. I create a person struct that stores the person's birth date in three separate fields, corresponding to day, month, and year. Obviously there are better ways of storing the birth date, but that's a different discussion. I created a method to determine which person was older, using those three pieces of information. Then I call qsort, passing to it a pointer to my comparator method. One reason function pointers are so helpful in situations like this is because they allow you to focus on implementing a general purpose function (sorting, in the case of qsort), rather than on how to handle particular data (the data to sort, again in the case of qsort). typedef struct { char first_name[10]; int birth_day; int birth_month; int birth_year; } PERSON_STR; int compare_people( const void* p1, const void* p2 ) { if( ((PERSON_STR *)p1)-&gt;birth_year &lt; ((PERSON_STR *)p2)-&gt;birth_year ) return -1; else if( ((PERSON_STR *)p1)-&gt;birth_year &gt; ((PERSON_STR *)p2)-&gt;birth_year ) return 1; else if( ((PERSON_STR *)p1)-&gt;birth_month &lt; ((PERSON_STR *)p2)-&gt;birth_month ) return -1; else if( ((PERSON_STR *)p1)-&gt;birth_month &gt; ((PERSON_STR *)p2)-&gt;birth_month ) return 1; else if( ((PERSON_STR *)p1)-&gt;birth_day &lt; ((PERSON_STR *)p2)-&gt;birth_day ) return -1; else if( ((PERSON_STR *)p1)-&gt;birth_day &gt; ((PERSON_STR *)p2)-&gt;birth_day ) return 1; else return 0; } int main(int argc, char **argv) { int i; PERSON_STR people[4] = { { "bob", 12, 3, 1953 }, { "joe", 4, 12, 1980 }, { "max", 6, 9, 1928 }, { "sam", 7, 1, 2003 } }; printf("Unsorted:\n"); for( i = 0; i &lt; 4; i++ ) { PERSON_STR person = people[i]; printf("%s: %d/%d/%d\n", person.first_name, person.birth_month, person.birth_day, person.birth_year); } printf("\n"); qsort( &amp;people, 4, sizeof(PERSON_STR), compare_people ); printf("Sorted oldest to youngest:\n"); for( i = 0; i &lt; 4; i++ ) { PERSON_STR person = people[i]; printf("%s: %d/%d/%d\n", person.first_name, person.birth_month, person.birth_day, person.birth_year); } return 0; } The output I get when I run the program is: Unsorted: bob: 3/12/1953 joe: 12/4/1980 max: 9/6/1928 sam: 1/7/2003 Sorted: max: 9/6/1928 bob: 3/12/1953 joe: 12/4/1980 sam: 1/7/2003 Another example of when function pointers might be helpful is when you want to handle errors when establishing a socket connection with another computer. If you encounter an error, you could call a function that prints out an error code and exits. That's usually fine when you plan on using that function in one context (when you know that you always want to do that and only that when an error is encountered). If you wanted to make that function more generic, though, you could allow the calling function to pass in a function pointer that does something different (maybe it sends an email to someone, or maybe it writes an error to a log file, or maybe it closes the app, or maybe it tries again. You don't have to worry about it, since it's up to the calling function to figure out what's best in that situation).
 int (*test1 (int)) (int); Function taking an int returning a pointer to a function taking an int returning an int. int (*(*test2 (int)) (int)) (int); Function taking an int returning a pointer to a function taking an int returning a pointer to a function taking an int returning an int. Yeah, the syntax gets ugly quick (read: immediately), but they are incredibly useful, and typedefs make the whole thing much more bearable: typedef int (*int_fn) (int); typedef int_fn (*int_int_fn) (int); int_fn test1 (int); int_int_fn test2 (int);
Not to *any* function. It can only point to a function with compatible parameter list and compatible return type. In C language there's a feature (not present in C++) where a function (or a function pointer) declared with `()` parameter list implies *an unspecified* set of parameters. If you declare your pointer as int (*ptr)(); you can make it point to *any function that returns `int`* (the return type still has to match). The language still requires that you specify the correct set of arguments when calling the function through such pointer: int foo(int, int); int bar(const char *); int baz(double); ptr = foo; // OK ptr(1, 2); // OK ptr = bar; // OK ptr("Hello"); // OK ptr = baz; ptr(3.14); // OK ptr("Hello"); // Bad! It compiles, but the behavior is undefined 
Oh, I think it's slowly coming to me. Instead of `if (i == 1) { func1(); }...all the way through i = 10` we just run `myFuncArray[i]` and skip all the calculations
Seems like one of the harder concepts of C that will take a lot of experience to understand when, why, and how to use them.
So a simplified understanding of function pointers is that they're just like normal pointers, except you give them the address of a function instead of a variable? That definitely seems to be the case considering that printf("The address of printf by itself is: %p", printf); Prints a memory address.
 char response = 0; do { printf("\ntest 123 123\n\n"); response = char_continue(); } while( response != 'N'); You'll also need to update the declaration of your char_continue function to return a char instead of an int
The function apply_to_all is a function that takes an array, and passes each element of the array to a function declared in the apply_to_all function call. This is really useful if you have a few different functions you might want to apply to your array, like some type of sorting.
in C it's the closest thing to supporting a styles of programming that C doesn't easily support, this includes both functional programming (e.g. qsort as mentioned). as well as being able to fake/emulate inheritance. using structs &amp; function pointers. 
The second answer to that stack overflow question has a few examples: http://stackoverflow.com/a/1791064/119271
Why is this being down-voted? Does it contain misinformation or something?
Productive but unreadable without proper commenting, meaning it will hell to maintain or for people to collaborate on
One thing I've noticed with programming especially with c, code is usually written in the least amount of space possible and with variables you'd have to run in some sort step mode to figure out what they do. Even though it's silly using descriptive names even for variables goes a long way instead of using a looping counter variable and calling it "i" what's to separate that from another variable labeled "a, b or c"? Readable code where someone with no knowledge can follow is the best kind because the amount of time needed to get to speed is reduced and more people can contribute if it's open sourced or that people after you can maintain if it's for a business
&gt; One thing I've noticed with programming especially with c, code is usually written in the least amount of space possible and with variables you'd have to run in some sort step mode to figure out what they do. I'm not sure if it's easier to read half a page of high-density code in “step mode” or ten pages of low-density code in “scan mode.” The understanding you gain from “step mode” is much higher, too. &gt; Even though it's silly using descriptive names even for variables goes a long way instead of using a looping counter variable and calling it "i" what's to separate that from another variable labeled "a, b or c"? Of course it's silly to call your variables a, b, or c, except when you have a naming convention where this makes sense. For instance, in the J interpreter the arguments and variables in almost all functions have fixed names. There is no deviation from that scheme: * `jt`, a pointer to the interpreter state, is an implicit first argument to all functions. * `a`, is the value of the left argument of a function that implements a binary operator (from APL α) * `w`, is the value of the right argument of a function that implements an operator (from APL ω) or the only argument in a function that implements a unary operator. * `i` is the index in a loop. There are other conventions for a few other variables. What I try to say is that when you see a variable named `w`, you always know what it represents. You don't have to look up its type, which is always the type `A` (for *array*). &gt; Readable code where someone with no knowledge can follow is the best kind because the amount of time needed to get to speed is reduced and more people can contribute if it's open sourced or that people after you can maintain if it's for a business If you want as many people as possible to contribute code, maybe. It can help to keep away people who haven't understood the conventions and rules imposed by the project yet. One of the things worse than terse code is code where each function follows different conventions so you have no chance to “get used” to the coding style at all.
Yes.
Sorry i'm in no way bashing how J is written but the conventions programmers take. I'd rather have the 10 pages that I can go through much quicker and grasp the first time. Time should be spent solving a problem not reading others code. Thank you you went in depth and touched on more points than I could lol
Ah, so f would be declared and outlined elsewhere? And f could then be any function I want that matches the type `void(*f)(int)`...`apply_to_all` is just there to iterate through the array and apply the function pointed to by `f` to everything in it.
Not gona fix your CS homework, learn to debug or use fprintf.
I got it, needed to make it `const void *` Just a simple syntax error, it seems. However, now it isn't sorting. It just...reprints the array.
I changed the first one and the second one. It now reads ` qsort(arrptr, count, sizeof(*arrptr), fp);` and is sorting properly (or so it seems) What's wrong with `fp` as the 4th argument? Is it supposed to be *fp?
Exactly! You could use it to sort, swap...whatever.
Why are you sorry for this? I've looked through the "Scheme 9 from Empty Space" book and it's damn cool. I'd love to read the source code of a full Scheme implementation one day.
Yes for my very simple example, a switch-statement would also be fast and most people would prefer to do it that way as well. But the point of my post is about Function Pointers and how they can be used. I do not want to give a very complex example because then OP may get confused.
Like I said, just stolen from SO. But instead declaring `*num` I'll just do `num1` now? Can I still do `*num1`? 
You've already fixed the first bug by using count instead of sizeof(arr)/sizeof(arr[0]) kind of thing, but it got me thinking... I think it's dangerous to teach people the sizeof trick for length of arrays before they fully understand the difference between arrays and pointers, including the difference between array type parameters and real arrays.
&gt; while( response != 'N'); You can also re-write his above solution as while( response != 'N' &amp;&amp; response != 'n' ); To support both upper and lowercase letters! \o/
This prints the same on mine. So, the size of an array is hardcoded at compilation. To do anything variable, I have to keep track of the size myself, like with the `count` variable.
&gt; You can't assume any of it.... And that's as good as misinformation in my book.
In his particular scenario this would never be possible. But of course, in production code, always check for valid input!
Absolutely! As a beginner, it trips me up all the time. Having to scan and discard whitespace characters is such a faff!
I understood that. You just didn't mention it, so I thought I would.
Well you probably still have to do the boring coding part at some point and that's typically where the music comes in since you don't have to think very hard at that point. You probably aren't cranking the music when you are developing the solution and design.
people will find *anything* to be angry about
I *love* being angry about virtually nothing. 
That makes me angry.
You are passing it correctly as it is, your logic is just broken. See [here](https://gist.github.com/anonymous/e8f1f47fe1d8b37e8965) using basically the same logic. A reference to an array in C is equivalent to a pointer to the 0th value of an array in memory, so 'array1' is equivalent to 'array2' when: int array1[] = {1}; int *array2 = array; As then printf("%d:%d", *array, *array2); will just print "1:1".
https://gist.github.com/d3f565c3b651567c619f Compiles without warning, but doesn't sort. Reordered some of the statements in insertion sort and it matches the pseudocode given by my algorithms book, but still isn't working. 
The problem with this is that you didn't use a function. I'm pretty sure my only error now is pointer and whatnot, but I [just can't figure it out](https://gist.github.com/f572ed94df5276472260) EDIT: Also, my state is obviously not changing at all.
[OK](https://gist.github.com/anonymous/8d4e7a4401428051b3eb). Your state is changing: iteration 0 : { 5 2 4 6 1 3 } iteration 1 : { 5 2 4 6 1 3 } iteration 2 : { 5 2 4 6 1 3 } Set {0: 4} Overwrite element 4 (1) with element 3 (6) Set {0: 4} Overwrite element 3 (6) with element 2 (4) Set {0: 4} Overwrite element 2 (4) with element 1 (2) iteration 0 : { 5 1 2 4 6 3 } Set {0: 5} Overwrite element 5 (3) with element 4 (6) Set {0: 5} Overwrite element 4 (6) with element 3 (4) iteration 2 : { 5 1 2 3 4 6 } array : { 5 1 2 3 4 6 } It is partially sorted in the middle (1, 2, 3, 4) with 6 on the end. Your algorithm is walking over the array improperly.
The `%c` specifier for `scanf` does not skip leading whitespace in the input stream as the other specifiers do. You probably want to use `" %c"` instead, with a space before the `%c`, in order to skip leading whitespace in the stream. Otherwise `scanf` is going to read the newline character following the last item input.
Thanks this was fixed :)
Do you understand *why* that is what you should get? Do you understand the meaning of that string of bits? If not, then that's the first thing you need to figure out. You can't write a program to do something if you don't understand yourself what it is you're trying to do.
What are the requirements of the program? What is it that you are supposed to do?
What do you mean by "Binary 52bit"? There is more than one way to represent fractional numbers in binary. Mathematically, the base-two system can be extended to fractions just as the base-ten system is: so the first digit after the "binary point" is the "halves place," and the next digit is the "fourths place," and the next digit is the "eighths place," and so on. But that is not the way that fractional numbers are typically stored in computers. Computers typically store fractional numbers in a format called IEEE floating point. Both of those are ways to represent fractional numbers in binary, and they are not the same. Which one of those representations are you trying to get?
Yes you can have nested `switch`. To help with debugging, you could have changed: printf("Thats not a +,-,*, or /... Try again ;)"); to: printf("Thats not a +,-,*, or /. It was %d. Try again ;)", oper); Then the value printed out would give you a clue as to what the problem was. 
Have you tried di.fm? 
number of elements is not correct. Try to use `count` insted of `sizeof(arrptr)/sizeof(*arrptr)-1`
You might also like to consider breaking your code up into separate functions, so then the top level switch statement could look like: case 1: calcVolumeCylinder(); break; case 2: calculator(); And those two functions would have the relevant code inside. It makes your code cleaner and easier to read, as it adds a layer of abstraction and reduces the noise. 
It would help if you supplied more information on what you are trying to do, but it sounds like, as /u/theseoafs eluded to, you want 1 mutex to control access to the data. Both delete, and search, (and anything else like insertions, updates), will need to lock the data and operate on it. There are [many other solutions](http://en.wikipedia.org/wiki/Concurrency_control), most are fairly complex, and this is by far the easiest. I am not sure why each thread would need to have a mutex? Mutual exclusion is to protect data, not protect threads.
Maybe SWIG? www.swig.org
I don't think I understand your problem, I tried it and it seems to work well.
It works excellent. But go to wolframalpha or any other site, search **how many primes less than X**, and find out. Then redirect my program to a file. `cat -n file` The line number will be which prime that is (counting up) and then the prime itself. My numbers and wolframalpha's do not match
Well, I don't know how you do it because as I said it *works* here. Wolfram says for example that pi(200000)=17984 and the 17984-th prime you find is 199999 which is the last prime before 200000. There's no error here.
Hm, I stand corrected.
Wouldn't #ifdef __USERSPACE #define printf printfuser #endif be simpler? Then OP could just keep their code using `printf` instead of `printfuser` or something like that.
Why even have printfuser at all? Have `printf` itself be a macro that does nothing: #ifndef __USERSPACE #define printf(...) #endif Then just use `printf` as usual in the code.
The C language itself has no graphics capabilities. So the first thing you're going to have to do is research third-party graphics libraries to find one that will work well for what you want to do on the system you want to run it on. *Then* you can learn how to use it.
Thank you. SDL seems nice!
Yes both do. 
there is almost nothing C++ only about them, i worked through almost all of them a few years ago using only C.
Yeah, he uses C++ But the SDL API itself is C. Personally I've learned SDL2 from the wiki at https://wiki.libsdl.org but when I was learning SDL1 I used LazyFoo. It shouldn't be too hard to mentally translate into C if it hasn't changed much since the SDL1 tutorial.
SFML have a C binding [CSFML](http://www.sfml-dev.org/download/csfml/)
Did you update your memory allocation (the sizeof()) when you tried with the longer path name?
I did but i have found the problem. I had no folder called wavedata and assumed it would be created along with the file but it was not.
Or, if you're on linux, you could draw directly to the framebuffer. Then your just essentially playing around with a big array of pixels. [Useful Link](http://stackoverflow.com/questions/1830836/how-to-draw-the-graph-in-framebuffer-using-c-language)
In Language C there is no Bits functions or what ever you call it so I have to use unsigned char. If I put char array[8]; that would mean 8 blocks of 8 bits so 64bits in total, while I only want 8bits in total. my teacher told me that. 
You need to OR your bits onto your destination or you will over-write the ones already there. Please post your source code as well, I can help you better if you do.
I dont really have a source code, I am trying to understand on how I can do it. If I do OR on my bits, do I need like 2 different Array?
Why do you need this in an array? Array's are not for bit manipulation, they are for a series of 2 or more variables of fixed-size. If you just want 8-bits to manipulate, then use unsigned char. You can set the bits on and off like so: unsigned char stuff = 0; // set to 0000000 stuff |= 1; // Set LSB to 1 stuff &amp;= ~1; // Clear LSB to 0 stuff |= (1 &lt;&lt; 7); // Set MSB to 1 stuff &amp;= ~(1 &lt;&lt; 7); // Clear MSB to 0 stuff ^= (1 &lt;&lt; 4); // Flip bit 4 stuff |= (1 &lt;&lt; 3) | (1 &lt;&lt; 5); // Set bits 3 and 5 to 1 (00101000b) stuff = -1; // Set all bits to 1 stuff &amp;= ~((1 &lt;&lt; 3) &amp; (1 &lt;&lt; 5)); // Clear bits 3 and 5 to 0 (11010111b)
Thanks for helping me man, its not only 8 bits, that's only for the first part but in overall I need an array of 64 bits. In that Array I will have to split that in 3 part in 1 bit/11/52 bits and store 0/1 in them. I will use Array[8]; so in total I have 8blockx8bits = 64bits I don't need the code for everything, because I understand how to do the calculation part etc, what I really don't understand is how I can use the first Block of 8 bits to store 1 or 0, than use the rest of the first block and a part of second block of 8 bits, total I would need 11 bits to store 1/0 again without deleting anything in my array.
If you want 64 bits, make a uint64_t. Single variable, 64 bits, done. Edit: include &lt;stdint.h&gt; to get access to [u]intN_t variable types.
You can try allegro here http://alleg.sourceforge.net/ I used it in a project when I was at uni to teach us C. I'm surprised to see its still being maintained. Not sure it supports 3d however
You rather want `unsigned char array[1]` or `uint8_t array[1]` for bit-fiddling.
You don't need curses for this, but curses might make this easier. The basic idea is to define an array of figure shapes. The 7-segment figure shapes could look like this: +-+ + +-+ +-+ + + +-+ +-+ +-+ +-+ +-+ | | | | | | | | | | | | | | + + + +-+ +-+ +-+ +-+ +-+ + +-+ +-+ | | | | | | | | | | | | | +-+ + +-+ +-+ + +-+ +-+ + +-+ +-+ You put these shapes into an array and then assemble the display from these shapes.
Okey I understand that. Now how am I suppose to extract a number like 1 or 5 from this array.
Aah. Okey I understand now. Let me give a try now ;)
You aren't performing any error checking. Is PsLookupProcessByProcessId succeeding? Why aren't you using KeStackAttachProcess instead of KeAttachProcess? What exception is actually being raised?
I cant do this because I never know what the user will input. I have to store his input in array
I had previously used KeStackAttachProcess but the same error happened, so I just changed to this one to see if that would fix it. I'm not entirely sure how I can check what exception is being raised, the debugger in VS doesn't exactly tell me, it just gives me the system errors in the OP. I'll get the NTSTATUS of PsLookupProcessByProcessId EDIT: calling NT_SUCCESS(status) causes an exception, but I can't fathom why the lookup isn't succeeding.
http://i.imgur.com/U6ULq40.png as you can see, its the correct filename and the correct directory. the problem has to be something else.
What is your question?
Rofl im facepalming so hard right now.
Yeah i mustve been blind on both eyes. Appreciate the advice though :P
i want to be able to store it all without deleting any thing that is already in the array. also since I need 11 bit to store an int number in the array i will have to use 7 bit from the first block of the array since the first bit is used but then I need to use half of the second block to store the rest as I need 11bit total for that part.
Okay, you still haven't asked a question. You're trying to manipulate bits of bytes in an array of 8 bytes. I showed you how to do this previously. 
If you want to create aligned bit fields, you can do it like this: struct{ unsigned long long sign : 1; unsigned long long exponent : 11; unsigned long long mantissa : 52; } mydoubletype;
Yes, this is typically true, as far as physical representation is concerned. However, from the abstract language point of view, data pointers and function pointers belong to two completely different, unrelated and isolated worlds. You are not allowed to convert pointers between these worlds. You are not allowed to use `%p` to print function pointers.
It doesn't make sense to have NT_SUCCESS throw an exception. That can't be the issue.
You can't directly convert it to bits, but here's what you can do: char a = 23; // binary is 00010111 char b = 8; // binary is 00001000 char c = a | b; //c = 31, binary is 00011111 Logical OR "|" of two numbers returns a number that has the bits active of both input numbers. 11001100 | 00110011 = 11111111 array[0] = 3; // bits of array[0]: 00000011 int usrinput = 5; // bits of usrinput: 00000101 array[0] = array[0] | usrinput; //bits of array[0] are now 00000111
Edit 2 : Okay great news, i fixed it for the driver, it reads perfectly fine now. But my usermode application gets an Access Violation error after i call DeviceIoControl Code : HANDLE hFile = CreateFile(L"\\\\.\\KMDFTest2", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL); KMEM_ACCESS kmem; PVOID buffer = 0; kmem.Operation = Read; std::cout &lt;&lt; "Submit PID: "; std::cin &gt;&gt; kmem.Pid; std::cout &lt;&lt; std::endl; std::cout &lt;&lt; "Submit Address: "; std::cin &gt;&gt; kmem.Address; std::cout &lt;&lt; std::endl; NTSTATUS result; try{ DeviceIoControl(hFile, IOCTL_READWRITE_KERNEL_MEMORY, &amp;kmem, sizeof(KMEM_ACCESS), buffer, sizeof(int), NULL, 0); char toBuf[100]; //sprintf_s(toBuf, "We got : [ %d ] and we read [ %d ] bytes", buffer, 4); //MessageBoxA(NULL, toBuf, "Whatever Buffer WE Got", MB_ICONINFORMATION); //std::cout &lt;&lt; "Press a button and we shall close the handle" &lt;&lt; std::endl; system("pause"); CloseHandle(hFile); //std::cout &lt;&lt; "Handle closed, press and we shall exit!" &lt;&lt; std::endl; system("pause"); } catch(char*e){ MessageBoxA(NULL, e, NULL, MB_ICONERROR); } return 0; 
I can only do it with an Array of 64bit total I cant do it any other way. 
 IOCTL_READWRITE_KERNEL_MEMORY is not a documented constant, what are you trying to do?
Oh, sorry about that, that's my own. Basically informing the driver that i'd like to read or write memory. and the KMEM_ACCESS struct contains the PID, the Address, and the Operation (reading or writing). This is my READWRITE define #define IOCTL_READWRITE_KERNEL_MEMORY CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS) 
Alright. This is something I'm going to point you into the right direction and then let you figure out the rest since this is probably the meat of the homework question. Since there's no simple way to output a decimal as binary in C you have to write code to do it manually. The easiest way to do this is to loop through all the possible bit positions in an integer. By shifting bits to a particular position, you want to see if the same bit is flipped on in the input string. If the bit is on, you would output 1, else you would output 0. To determine if bits are on in two different variables, you would use the logical AND '&amp;' operator. There are 32 positions in an int (32 bits) Here is an example: int num = 4, bit = 0; bit = num &gt;&gt; 2; if (bit &amp; 1) printf("1"); else printf("0");
Linked list is overkill for this. Just for loop it. 
If you have a template pattern of length `M` that you want to use to fill a target sequence of length `N` (by "circular looping"), all you have to do is repeat the template `N / M` times and then top it off with `N % M` first characters of the template. In your case the template has length `M=6` (ignoring spaces, per your request). The target length is `N=19`. So, repeat the template 3 times (`19 / 6 = 3`) and then add 1 leading character of the template (`19 % 6 = 1`). BTW, if you know the exact target length in bytes in advance (`25` in your case, if you count the spaces), you could use a rather simple trick that achieves exactly what you need in just a few lines of code size_t n_src = strlen(array); size_t n_dst = 25; char target_buffer[n_dst + 1] = { 0 }; strcpy(target_buffer, array); memcpy(array, array + n_src, n_dst - n_src); Note that the above is formally illegal, since it uses `memcpy` with overlapping source and destination buffers. It assumes that `memcpy` copies data in byte-wise fashion and from lower addresses to higher addresses. If `memcpy` is implemented differently, the code will fail to work properly (such use of `memcpy` was the reason for the infamous Flash bug in Firefox). But it illustrates the idea. If you implement your own byte-wise memory copying function that copies from lower addresses to higher addresses, you will be able to safely use it for such purposes as filling a memory region with an arbitrary repetitive pattern. 
Well, you asked for 19 characters. Whitespace is a character. But if you're going for letter characters, you'll have to maintain a separate counter that counts the number of letter characters encountered, and change the loop to end on that condition instead. Since you want the whitespace in the final output, you'll want to keep the i counter as-is.
Glad to hear it.
How about the case of an escaped quote inside a quoted string. "Use the \" symbol to mark quotes" 
My program prints everything within quotes, including the fragment you posted
&gt; "Use the \" symbol or use /* to mark a comment" that returns everything you see quoted above. am i misunderstanding? is it not handling that correctly? I thought it should print everything between quotes no matter what is contained. thanks, i'll fix up the braces once i have the logic correct. 
I would think it would enter the QUOTE state on the first " and then return to OUT after \". When it sees the /* it would think it would be starting a comment. "Use the \" symbol" /* I would think this would break too " */
You do need to insert a space (I think). Not sure removing multiple spaces is required. For example j = 4/* comment */5; will give you a syntax error from gcc. I can't think of a case where leaving multiple spaces would cause a problem. 
Am I actually storing char 0/1 values in my Array? ------------------------------------------------------------------- void convert_to_binary(unsigned char tab[], int exponent) { int i; tab[0] |= (exponent &lt;&lt; 6); int k; for(i=6; i&gt;=0; i--) { k = exponent &gt;&gt; i; if(k &amp; 1) printf("1"); else printf("0"); } tab[1] |= (exponent &lt;&lt; 6); for(i=3; i&gt;=0; i--) { k = exponent &gt;&gt; i; if(k &amp; 1) printf("1"); else printf("0"); } } ------------------------------------------------------------------- Can you guys help me with this please? Trying to store 1/0 char values in both of my array. Is this how you do it?
Sounds suspiciously like a flushing issue
Yup, I actually solved it by moving fflush just after command execution and it seems to work okay now.
&gt; is this possible? My recommendation whenever you want to ask this question [EDIT: about coding] is - Try it and see what happens. In this case, yes. If you include that .h file from your code and link the library you should be able to access that variable.
New to coding in C, why do we need to \#include a header _and_ link the library? With math functions like pow, for example.
There are a lot of details under the hood, but this article seems pretty good: http://www.cprogramming.com/compilingandlinking.html The .h file is used for compiling your code, so that the resulting object file knows, for example, the size and type of the variable you're accessing. You then link multiple .o and library files together into an executable.
Thanks, I was hoping to do this without having to include the libraries header files in my main project, but I came up with a good compromise: I added a new header file called "shared.h" and in that file I included all of the include files necessary for the end-user code. The library never actually includes this file, but it individually includes all of the files that shared.h includes (as well as others that I don't want shared) in its own "includes.h" file.
You're right, it doesn't work. $ ./program 2 49 29 91 32 35 29 42 17 9 Organized Array 2 49 29 91 32 35 29 42 17 9
i dont understand how my code actually convert exponant to binary lets say my exponant is 1028 how does my code put it in my array and knows where to put 1 and 0.
Sure, it works *sometimes*. But it doesn't work always. Run it again until the first element of the randomly generated array is the smallest element (because, as you observed, the algorithm will fail in that case). Or avoid the random generation and initialize the values of the array by hand (or read them from input). Here's another failed run, for example: $ ./program 32 60 31 21 15 23 68 98 99 64 Organized Array 15 21 23 31 32 60 68 98 99 64
Thanks for the explanation. I guess I was confused because I kept running the program again and it didn't fail yet. 
What book is this? That break does in fact make the algorithm fail, not to mention the variable names make a simple program way harder to understand than it should be lol.
Your code doesn't convert anything to anything. Remember how it is said computers use 1's and 0's to work? Everything in your program is actually 1's and 0's. When you write `char`, the computer reserves 8 bits for you, meaning 8 1's or 0's. Let's say you write char x = 12; Your computer can't store 12. However, it will store it as `00001100`. Now, onto arrays. An array is basically a bunch of variables. So basically, writing: char myArray[4]; is more or less same as: char x; char y; char z; char m; And your code. Your code basically changes tab[0] and tab[1], the first two chars in the array. If you are thinking that the 1's and 0's get spread out through the array, like tab[0] being 1 and tab[1] being 0 and so on, that is not happening. tab[0] is a char, containing 8 bits, and tab[1] is another char, containing another 8 bits.
It's C Programming Absolute Beginner by Perry, Greg
then how would I put the number 1025 into an array on 1/0? I dont understand. :-(
There are two perspectives from which to tackle this question. From the perspective of the C standard, it doesn't matter. The C standard just specifies that the function is available. It doesn't concern itself with how the compilation infrastructure is implemented. From the perspective of actual implementations of the C programming language, POSIX (the standard for operating systems) specifes for `c99`, the portable name for the C compiler (also called `cc`): &gt; In the absence of options that inhibit invocation of the link editor, such as `-c` or `-E`, the `c99` utility shall cause the equivalent of a `-l c` option to be passed to the link editor after the last pathname operand or `-l` option, causing it to be searched after all other object files and libraries are loaded. Thus, the `libc` (which contains most standard C functions, except for some extra POSIX functions [like the socket stuff] and except for math functions, which are in `-lm`) is implicitly searched for symbols after all other libraries have been searched.
In case you're wondering why, it's because you're mixing levels of abstraction - `dup` &amp; `open` are POSIX syscalls working with file descriptors, while `fflush`, `printf`, etc. are implemented in libc (ie. a layer above posix) and have their own caching, and can't detect the filedescriptor having changed meaning. If you consistently used `write`instead of `printf` there would be no problem.
I suggest you read these two tutorials: http://www.cprogramming.com/tutorial/bitwise_operators.html http://crasseux.com/books/ctutorial/Masks.html One idea that comes into my mind is creating a loop, where you get the leftmost bit of a number by using a mask, then shift it 1 bit left until you reach the end of the number.
ah, thanks!
&gt; Fork is a bad example because it is a system call, it is not part of the standard library, it is implemented by the operating system directly and requires no linking. Bullshit! Of course it requires linking to use `fork()`. The interface to the operating system is not directly usable by C programs. For each system call, the libc contains a little function that puts the arguments into the right positions and calls into the operating system.
In your original source params 5 &amp; 6 may be wrong: DeviceIoControl(hFile, IOCTL_READWRITE_KERNEL_MEMORY, &amp;kmem, sizeof(KMEM_ACCESS), buffer, sizeof(int), NULL, 0); buffer is set to 0 and sizeof(int) will return 4, so DIOC() may be writing 4 bytes to address 0 (access violation). The params should be &amp;buffer, and sizeof(PVOID). sizeof(int) may not necessarily be the same as sizeof(void*).
i dont understand why people dont start with dennic ritchie when they want to learn C programming.. It is the best book out there..
It depends on what platform you are on and whether the library is a shared library (so or dll) or a static library. Without having this information, your best bet is to just try, as other said. You don't even have to include the internal header, you can just copy out the external declaration.
A header file does not tell the compiler where the function is to be found. This information has to be provided elsewhere. Incidentally, the Plan 9 project wrote an extension to the C programming language so header files can declare that they require a certain library to be linked in, but it hasn't gained much adoption and is unavailable on other platforms.
Would you please indent your source code with four spaces so it appears in a mono-spaced font? This makes your code much more readable.
You are right, and it turns out the libc dose also other things for example this program: int main() { return (0); } will not run without the standard library. The real entry point is _start(), main() is called by the libc after doing some initialization. The libc is always linked unless you compile with the appropriate option. -nostdlib in gcc.
it seems like there's only two persons who know how to code C and both of them are wrong
how do you write an os if their is no standard way to do that?
By the C standard you mean K&amp;R?
The definition of C is an international (ISO) standard.
No, he means the [C standard](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf).
I think you've basically got it, but have a couple of bugs. The main one is to do with where you calculate the average - you want to be calculating it at the end of every row, but you're calculating it for every cell instead - have you just lost track of how many for loops that code is nested inside? You've also got some nan's (not a number) showing up - there's a hint in the instructions about why that might happen. Good luck!
Of course you can, just return the variable named `value` after the loop.
OpenBSD has lots of clean, well designed C libraries and applications... If you want to learn someething about cross-platform Unix programming, I'd look at OpenSSH and read the whitepaper.
I am pretty good at C, I have never read that standard.
C was developed as a portable assembly language. There's not much in the way of restriction for exactly that reason. Go look at the Linux kernel. I'm sure you'll find a goto statement or two. And a bunch of pointer manipulations.
None that I know of. Input handling is difficult, especially in C.
Oh man, thanks for that! That was the final error in the program and now it's able to properly query my driver for information and retrieve it, thanks ! I don't know if there's any sort of SOLVED thing i have to add to the OP so... yeah thanks haha
Care to elaborate on what you mean by *functional program framework*? Are you talking about doing functional programming in C? I think there is a book on that. I think it's this one: http://www.amazon.com/Functional-C-International-Computer-Science/dp/0201419505/ - I'm not so sure though. Are you talking about building framework/programs that are functional (as in robust, secure, ...)? If that is the case, then there is an interesting book named "C Interfaces and Implementations" going through several kinds of modules you might want to implement in C, and going through how you'd elaborate an interface and an implementation for them =&gt; http://www.amazon.com/Interfaces-Implementations-Techniques-Creating-Reusable/dp/0201498413/. This book covers the sort of thing that I believe you should be studying after learning the overall language syntax and semantics, how to combine features of C to solve not so trivial algorithmic problems, and so forth. In summary, it talks about modules design (both interfaces and implementations) in C. There are more books here, like those listed in here http://www.iso-9899.info/wiki/Books. You can also check some more learning resources here http://www.iso-9899.info/wiki/Usenet and here http://www.iso-9899.info/wiki/Web_resources. Still on my second interpretation of your *functional program framework* (because idk much about the first one besides that book "Functional C"), there are tons of very complicated systems built in C, like operating systems, server software, and so forth. And for many of them, there were books written. Here are some software for which you can find books on their design and implementation: - FreeBSD =&gt; http://www.amazon.com/Design-Implementation-FreeBSD-Operating-System/dp/0321968972/ - LCC =&gt; http://www.amazon.com/Retargetable-Compiler-Design-Implementation/dp/0805316701/ - The C Standard Library =&gt; http://www.amazon.com/The-Standard-Library-P-J-Plauger/dp/0131315099/ - Minix =&gt; http://www.amazon.com/Operating-Systems-Design-Implementation-3rd-ebook/dp/B009TELWBE/ - TCP/IP =&gt; http://www.amazon.com/TCP-IP-Illustrated-Implementation-Vol/dp/020163354X/ (This is actually the 2nd volume of a 3 volume set.) - Unix =&gt; http://www.amazon.com/Lions-Commentary-Unix-John/dp/1573980137/ There are probably more, but those are the one which came to mind.
What exactly do you want to learn? If you are new to programming and algorithm development, I'd recommend [Project Euler](http://projecteuler.net). You learn a language by using it, so start with those smaller problems and then work your way up to creating your own large programs, that is, if software development is what you're interested in. 
&gt; Thank you for your in depth reply. By functional I mean a computer program from A to Z. A complete program framework, which achieves a function of some sort. Ex. a word processor. You can then first learn about common techniques and programming ideas for C programming. My previous answer mentions some books (including those talking about implementation of *real systems* that were made in C) and it also mentions the books section of the ##c @ irc.freenode.com wiki (http://www.iso-9899.info/wiki/Books). You should look at those. There are lots of things to study here, so you should keep side projects while you study from those books. The other thing is that to write systems "from A to Z", you actually don't write from A to Z. You use libraries, you use OS functionality, you use other programs to help you, and so forth. So a lot of learning what you want to learn is about learning other libraries. For example, if you were interested in computer graphics and/or game development, you'd spend some time learning the OpenGL API for example. There is another post of mine answering another guy/girl who asked about C that might help you =&gt; http://www.reddit.com/r/learnprogramming/comments/2u4rtx/looking_for_a_mentor_for_c_programming/co5463w?context=3 &gt; Speaking of systems, how come we don't see more operating systems out in circulation? I realize the obvious like support for software... There are things to be considered here. As far as I've heard, the marked for special purposes OS is sort of active. I don't understand about it, but what we common citizens see is the market for general purpose OSes. And general purpose OSes, like linux, windows, mac os, ios and so forth, are *extremely* difficult to be created. The whole thing becomes way scarier when you realize you'd be competing with Apple's systems, Microsoft's systems, and GNU/Linux. There are also drivers. Can the company get hardware manufacturers to write drivers for its new OS. And drivers are just a small part of an overall problem: how to get people interested in developing for your OS? Be it drivers, games, office applications, and so forth. Consider how it goes today. If you think about desktop OSes, it's all windows. There are *some* mac os users in the world (in the US, it might be more than usual, but in other countries, afaik, windows dominates). It has been all windows for a while now. On other areas, like mobile or consoles, I only know superficially (I'm unaware of console OSes; I think a lot of them just don't [or didn't?] have one; I don't know though). But even on mobile, we have 2 major OSes: Android and iOS. Even Microsoft didn't do so well in here as far as I can tell. What about blackberry stuff? pff. For server side OSes, you'll have to do MUCH convincing to get people to abandon linux. It's just too difficult, I guess. Not that you can't make your own as a hobby for educational purposes. It won't be very good, but to learn the concepts behind an OS, it can be extremely valuable. I think xv6 (an educational-ish purpose OS) has less than 10kloc.
I don't know if I understand what you're asking about. It's surely possible to come up with a new OS. If you're doing for educational purposes, maybe you should even do it on your own so you learn more. If you want one to compete with linux or windows, then I can't help you. It's too complicated, I don't know what one would have to do in order to get there. It's not that I don't want to help you; I just don't know. Even if you give me 10 years of spare time to work on it. But if you had to do such a thing, it seems like hiring a good team is a good starting point. What you'd need in that team, though, I'd not know in detail. You'd need good programmers, good hardware people that understand about the target platforms you have in mind, good API designers, good drivers programmers, good program optimization experts, lots of grey haired people that have been exposed to all sorts of related subjects over the years. However, that's all of too general, it's all the technical side, and probably it's missing a bunch of stuff. Remember, you need to do convincing to get other people to adopt your "industry ready shiny new OS", which means a lot of interpersonal, business-ish, non-programming, non-technical stuff. Stuff that I can't begin to understand very well. &gt; I would assemble a team with the right funding to code an OS If you can determine what is "the right team" with "the right funding", and if you can *find* people to form the team and if you *have the money*, then if you have the time, and the lucky needed (who knows? people in the team might get hit by a bus, or maybe you might be robbed), then I imagine you'd have a chance of succeeding. Getting a new OS out there that can actually compete with something like linux, or windows, or ios, or mac os, or android, ... It's such a major undertaking... I can only image part of it, and a somewhat small one.
These are real difficulties you mention and I have considered the problems involved. Thanks for expanding on a thought process which is hard to get feedback for. How about an OS based on the Unix kernel? Lots of ifs of course but I can enter a market area with my vision for this OS which Apple and Windows cannot. And working with the right team under secrecy it would be difficult for them to catch up quickly and they have enough market share to not care about this potential area for an OS. 
I appreciate all of your opinions on this. Linux was built with minimal funding. I would like to think that with the right funding an OS could be built. So apart from that the idea is doable in practice but not considered accessible by the technocrats. Naturally I have considered the biggest problem of an "industry ready" OS, before even thinking of attempting something like this, and I have solved it. 
&gt; Linux was built with minimal funding. I don't know if "minimal" is the right word in there, but I get what you mean. The thing about linux is that it's not the rule for open source projects. It got lots of efforts by lots of people. It is probably the most successful open source project out there. If you're aiming at the level of success of linux, I'm sorry but it's almost certain that you're bound to fail. It's not about being an OS or not, it's just that linux was an off the tracks open source success. &gt; I would like to think that with the right funding an OS could be built. Well, a much better OS than windows (the dominant now on desktop) can be built. But right funding is just part of the issue. &gt; I have considered the "industry ready" biggest problem and I have solved it. Industry readiness isn't something that depend only on the OS developer company. Part of what made windows industry ready is the fact that people wrote drivers for it, is the fact that there was software for it, and so forth. It's not only *on you* to solve this problem. Will nvidia write a drivers for your OS, so people buying a computer to run your OS with a good graphics card will be able to benefit from it? That's *one* example. A lot of it depends on aspects that isn't in your control. For example, back when windows and linux were growing and becoming more and more popular, OSes were simpler. That's just a fact. The software was simpler. For a long period of time in linux's beginnings you could if you were driven enough read major chunks of code base and understand it (maybe even all of it). This was probably true for windows as well. Back in the day, windows didn't have decades of evolution; it had a few years, with very bad support for users feedback. Analogously for linux. Today, they have decades of evolution, massive code bases, tons of features, and so forth. Now, you have to beat a major competition that wasn't as strong 20 years ago. It existed, of course, but it wasn't like it was today. Check out, for example, how the idsoftware guys were considering having quake (or doom, I don't remember which) ported to several other OSes. Most of which we don't even know existed, anymore. Today, we don't even conceive of those things because of how much the OSes today dominated everything. At the same time, Android and SteamOS are based on Linux. So they didn't re-invent the wheel on the technical side. I think PS3 had something based on Linux as well. It's difficult to say what is the most difficult part of building an industry ready OS. There is the technical side. There is the political/business-ish side. And in the middle of that a bunch of other things I don't understand.
&gt;Industry readiness isn't something that depend only on the OS developer company. Part of what made windows industry ready is the fact that people wrote drivers for it, is the fact that there was software for it, and so forth. It's not only on you to solve this problem. Will nvidia write a drivers for your OS, so people buying a computer to run your OS with a good graphics card will be able to benefit from it? That's one example. This is not relevant because I have circumvented this problem. And further the element of time after an initial successful offering will let me compete with an eventual growing market share. But what is relevant to my solution right now is the bare bone chassis of an OS. A basic chassis of an OS machine should definitely be doable, don't you think? 
I don't think anyone but a few compiler implementers reads it like a book from top to bottom. It's most useful when you have a specific question that you want answered, because it is the ultimate source of authority. You can use the table of contents, the index, or just search for terms. It might not be something you turn to when you're a newbie, but as you get more experience I think it's a very good habit to turn to the standard whenever you have some question about how something works or whether something is legal. Here's an example that you might want to try using the standard to investigate. What happens when you add a value of type `long` to a value of type `unsigned`? What's the type of the result? Does the expression `LONG_MAX + 1u` invoke undefined behavior? (Note: you have to specify some details of the platform to be able to answer these questions, so try it for both ILP32 and LP64.) Try this without googling, using only the standard. 
Look, if you *really* want to get into developing an OS to compete with major players, I'm not the person for you to be talking to. I don't think I understand what you're talking about anymore.
Well, thanks for your very knowledgeable insight. I don't think there really is any "right" person I can ever talk to about a project of this scope. I just have to do the original thinking myself and not be swayed by a random person's opinion. But then again this is a project of gigantic scope so I have to take that into consideration. I am comfortable pursuing this as I can envision highways in jungle yet unexplored. The question is also whether I'm willing to dedicate a large chunk of my life to this. &gt;Well, a much better OS than windows (the dominant now on desktop) can be built. 
I would not recommend project euler. It's great if you want to learn more maths but not programming. I would suggest something that deals with algorithms one might use in real life. Maybe something like [hackerrank](https://www.hackerrank.com/domains)
First of all, while compiling I get [lots of well justified warnings](http://paste.devys.org/fouhihaujay), you should get rid of them. There is usually no reason for a program to work well if the compiler isn't sure of what it's doing.
You should fix the formatting of the post, and let us know what line the error is on.
This is the problem: area = compute_surface_area(int radius, int height); volume = compute_volume(int radius, int height); Instead, it should be: area = compute_surface_area(radius, height); volume = compute_volume(radius, height); You need the parameter types on a function when you declare it, not when you call it. On line 6, these are declared, but they do not have parameters or parameter types (only return types): double compute_surface_area(), compute_volume(); It should probably look more like: double compute_surface_area(int radius, int height), compute_volume(int radius, int height); Also, if you want to write code in a reddit post, prefix each line with four spaces and it will be formatted as code. 
Thanks for your help, appreciate it. Will adopt the right formatting in future posts. 
Don't try to tab. Instead, put 4 spaces at the beginning of each line.
`#define PI 3.14;` should be `#define PI 3.14` . The `#define` is a text replacement ; you want `PI` to be replaced by `3.14`, not by `3.14;` . 
eta: First follow cym13's advice. Get rid of warnings. Check out the following line: reverseString(*s++); There is a lot of wrong going on there. :\^). First, do want to add one to s or what s points to (*s)? I think you want to add one to s. But also do you want to actually increment s or are you merely interested in passing s + 1? Besides all of that, I'd probably change NULL to '\0' on line 4.
&gt; There is usually no reason for a program to work well if the compiler isn't sure of what it's doing. Well, there are a few programs doing weird trickery the compiler doesn't understand, but that's rather rare.
This is what `memcpy` is for (or `memmove` if the two blocks of memory may overlap).
&gt;My question is; is there an easy way to do this without using memcopy() or looping/hard coding? memcpy *is* the easy way, is there some reason you don't want to use it? There are many different ways you could loop over the array to copy it but fundamentally that's what memcpy will be doing anyway.
The simple answer to your question is no. I am guessing you are looking for an assignment operator that allows you to simultaneously assign all the values from one array into corresponding elements of another array. There is no such operator.
One context in C language that allows array copying as a core-language-level operation is this char str[] = "Hello World"; i.e. initialization of a char array with a string literal. Another exception is, of course, copying of "wrapped" arrays struct A { int a[10]; }; struct A x = { 0 }, y; y = x; In all other cases array copying would involve a library function at least. I.e. you have no other choice but to use `memcpy` or a hand-written cycle.
You don't "read" the standard like a book. What you need to do is to: 1) Familiarize yourself with the structure of the document 2) Learn the standard terminology Most of the time we search for the appropriate quotes in the document by simply doing a contextual search for the proper term (like "order", "sequenced", "declaration" etc.) in the PDF version of the document (curse you, ANSI/ISO 9899-1990!). If you do this with some dedication, you will eventually become so familiar with the way the document is organized that you will know right away where to look to find the answer to a specific question.
The whole `scanf("%lf"` approach is, unfortunately, flawed. In order to get this level of control you'd have to read user input as a *string* using `fgets` and then manually validate the input and convert it to a number by using `strtod` double read_double_number(void) { double user_number = 0; do { printf("Please enter a number\n"); char buffer[1024]; if (fgets(buffer, sizeof buffer, stdin) == NULL) /* Handle a non-correctable input error: EOF or something else */ return 0; char *end; user_number = strtod(buffer, &amp;end); if (end != buffer &amp;&amp; (*end == '\0' || *end == '\n') &amp;&amp; errno != ERANGE) /* Success */ break; /* Complain and try again */ } while (1); return user_number; } And remember that in C a function with no parameter should be declared with `(void)` parameter list. What you have now is a non-prototyping K&amp;R-style declaration which is probably going to get outlawed in the future.
&gt; My question is; is there an easy way to do this without using memcopy() or looping/hard coding? Nope.