Linked lists require either dynamic memory, or preallocation. You could have an array of nodes that you then assign to a list. node gNodes[MAX_NODES]; int gNodeCount = 0; int main( ...... I'm lazy....... ) { node *head = gNodes[gNodeCount++]; head-&gt;next = NULL; } Doing it this way does not require free() or malloc(), but it is not ideal. 
&gt; the code is running too fast to generate different names every time It sounds like you're seeding the RNG each time you call your function. You should only be seeding it once, at the start of your program.
I'm a bit confused. I thought that the rate at which rand would produce duplicates is independent of the seed or the frequency at which rand is called. Rand is implemented as a PRNG, right? Once you seed it, it doesn't need any external sources of randomness. Can you post the code that retrieves the random number and constructs a name from it?
Ah, that makes sense. 
My suggestion would be to use a state machine. One of my courses at school required we parse a text file of any length, and we had no knowledge of how compilers worked. Our professor suggested that the easiest and most effective way would be to create our own state machine. If you've never heard of a Finite State Machine, don't fear as they are an extremely simple, yet effective, concept. Here's a link: https://en.wikipedia.org/wiki/Finite-state_machine **Edit:** I should add that state machines ensure there are no 'special cases' which seems to cause a lot of non-sensical spaghetti code. An example special case would be white space. What would happen if one of the lines in your text file had multiple spaces between each element? Well, one state in your FSM could deal with whitespace, where it will just skip the space and read the next character. I hope this clears things up a bit! 
My script submits a web service call with a user's name in it. Works just fine when you run it once, but when you run it multiple times in a row, the code runs so fast that the time value hasn't changed. You end up with several iterations with the same seed. Code: srand((unsigned int)time(0)); //Seed number for rand() for (d = 0; d &lt; 15; d++) { if (d == 7) { p = 32; //ascii space k = (char)p; buff[d] = k; printf("%c", k); } else { // A-Z = 65-90 and a-z = 97-122 //r = rand() % 25 + 65; //uppercase p = rand() % 26 + 97; //lowercase k = (char)p; buff[d] = k; printf("%c", k); } }
I am. But if I run it twice in a row, within a second of each other, it's the same seed.
 DESCRIPTION The time() function returns the value of time in seconds since 0 hours, 0 minutes, 0 seconds, January 1, 1970, Coordinated Universal Time. If an error occurs, time() returns the value (time_t)-1. If your program takes less than a second to run, and you run it multiple times per second, you're going to get the same seed each time it runs in that time frame.
Yeah, you just need a better seed. You can get it from /dev/random, or have each run of your program print out the next random number and then use that as the seed for the next run. Or you could use the tv_usec returned by gettimeofday() instead of time(). Microsecond granularity should be sufficient. 
Small nit: Reading from /dev/random can block unpredictably once the kernel's entropy pool is exhausted from repeated calls. I'd suggest it is better to read from /dev/urandom in this case.
If you're okay being locked to a Windows platform, maybe just use rand_s() to get your random number. No need to call srand, the seeding is handled by the OS. I think it requires that you're building in Visual Studio, though? Not sure.. See the example usage at the bottom of the page for generating a number in the range of 1-10, for example: https://msdn.microsoft.com/en-us/library/sxtz2fa8.aspx
hhhh thanks !! 
`clock_gettime`’s a little iffy for things like this because there’s no telling *a priori* what its actual resolution is—could be 1/18.5th of a second, could be 1/100th of a second, could be whatever the native timestamp counter’s updated at. (Ditto most OS-sourced clocks, which are usually designed for accurate-ish differential timing.) It’s a useful contributing source for entropy, but shouldn’t be used alone if there’s any chance you’ll reseed within the same tenth-of-a-second or so.
And what error did it give? You have i = 0 &lt; i which isn't doing whatever you expect.
If you are on Windows there are some great places to get seeds from. Though for performance reasons you will likely want to switch to the following PRNG (it's really really fast and really really random): **xorshift64.h** #pragma once //------------------------------------------------------------------------------ #include &lt;stdint.h&gt; //------------------------------------------------------------------------------ void init_xorshift64(const uint64_t); uint64_t xorshift64(void); //------------------------------------------------------------------------------ **xorshift64.c** #include "xorshift64.h" //------------------------------------------------------------------------------ static uint64_t y; //------------------------------------------------------------------------------ void init_xorshift64(const uint64_t seed) { y = 0x139408DCBBF7A44; if (seed) y ^= seed; } //------------------------------------------------------------------------------ uint64_t xorshift64(void) { y ^= (y &lt;&lt; 3); y ^= (y &gt;&gt; 1); y ^= (y &lt;&lt; 11); return y; } //------------------------------------------------------------------------------ Now here are some ways to grab some nifty (ultra fast, ultra reliable) seeds on Windows (All versions W2K and later): LARGE_INTEGER li; QueryPerformanceCounter(&amp;li); uint32_t tc = GetTickCount(); uint32_t pid = GetCurrentProcessId(); uint64_t seed = li.QuadPart * tc * pid; printf("Seed: 0x%016llX\n", seed); init_xorshift64(seed); I hope this helps! **Edit** To get a random character simply: char my_random_letter = (xorshift64() % 26) + 'a';
Thanks, So i guess with any library (jansson, jsmn...) I would be able to get only the fields im interested (like facility, pid...) because in that case i dont even need to parse the log.
* [Pelles C](http://www.smorgasbordet.com/pellesc) * [Ollydbg](http://www.ollydbg.de) * [IDA Pro](http://www.hex-rays.com/products/ida/index.shtml) * [IAR Workbench](http://www.iar.com) * [Windbg](http://windbg.org) * [VMWare Workstation](http://www.vmware.com/products/workstation) (for serious debugging)
If you're on Linux, the ELF loader will provide 16 bytes of random data in the auxiliary vector, specifically intended for seeding a RNG. See https://lwn.net/Articles/631631/ and `getauxval(3)`.
You're not checking the return value of fopen_s(), which would indicate any error in opening your file. Is numbers.txt in the same location as your program? If it isn't, you need to specify the path to it e.g. "c:\\\windows\\\numbers.txt". Also, your counter for the sum is wrong, should be 9. #include &lt;string.h&gt; errno_t err = fopen_s( &amp;readfile, "c:\\windows\\numbers.txt", "r") if (err &gt; 0 ) { fprintf(stderr, strerror(err)) ; } You have some other errors you need to cleanup too. 
Then there's this usage: FILE* file = fopen("abc.txt", "r"); if ( !file ) return fprintf(stderr, "Could not open file\n"), EXIT_FAILURE; There's a certain elegance to this, though it looks weird to an untrained eye.
It's working! Thanks for your feedback. I didn't notice the incorrect %types on scanf but definitely the reference of d in the second function. Thanks again 
what's the advantage of this?
I'd guess the intent is to present the "print error and fail" result as a single line of code. In C++ it could fit in a single line as `throw std::runtime_error("Could not open file");`, so this kind of tries to shoehorn that thinking into C. But I think I agree with /u/Rhomboid in that all it really does is pointlessly compress vertical space while still violating the spirit of coding style rules.
It is doing something: causing undefined behaviour! `i = i++` causes UB because the side-effect of post-increment is not sequenced before the read of `i` on the left-hand-side. 
vim, gcc, valgrind, make, git. Nothing fancy.
1. Correcting me for not differentiating the kind of char in the first (conversational) line even though I elaborate with a quote in the next line is silly. My point still stands; (u)int8_ts are typedefs for (unsigned) chars. 2. No, citing the GCC header (not the standard) was right. OP was talking about GCC output. You argued that using `uint8_t` would avoid the "conversion to ‘char’ from ‘int’" warning because it's "well-defined to assign an out-of-range value... unlike char". I was pointing out that your assertion is wrong. (They're the same to GCC.) 3. *If you want to go to the actual standard,* here you go. It defines all `intN_t` and `uintN_t` specifiers as "typedef name[s]" for a system's preexisting 8, 16, 32, and 64 bit integer types *if the system has them implemented.* In other words, the header is following the spec. &gt; **7.18.1.1 Exact-width integer types** &gt; &gt; 1 The typedef name **intN_t** designates a signed integer type with width N, no padding bits, and a two’s complement representation. Thus, **int8_t** denotes a signed integer type with a width of exactly 8 bits. &gt; 2 The typedef name **uintN_t** designates an unsigned integer type with width N. Thus, **uint24_t** denotes an unsigned integer type with a width of exactly 24 bits. &gt; 3 These types are optional. However, if an implementation provides integer types with widths of 8, 16, 32, or 64 bits, no padding bits, and (for the signed types) that have a two’s complement representation, it shall define the corresponding typedef names
`char` and `unsigned char` (equivalent: `uint8_t`) are different types. This distinction is important. I suggested using `unsigned char` (aka. `uint8_t`) instead of `char` . You responded with the factually incorrect: &gt;You should read stdint.h. `uint8_t` is nothing more than a `typedef` for a `char`. which I can only assume is supposed to be disagreeing with something that I was saying. You now say that you were being "conversational" despite your use of code marking, and you actually meant "uint8_t is nothing more than a typedef for `unsigned char`". If so, you seem to be agreeing with me, because I was offering the suggestion of using `unsigned char` (aka. `uint8_t`) instead of `char`. &gt;You argued that using uint8_t would avoid the "conversion to ‘char’ from ‘int’" warning because it's "well-defined to assign an out-of-range value... unlike char" I never argued that using `uint8_t` would avoid the warning. I argued that it would make the code well-defined. 
Short answer: It would be a pain in the ass. You don't know where the memory is going to be allocated or pulled from. Your program would be horribly unportable if you had to figure that all out by hand. If you want to do that sort of work, learn Assembly.
&gt; Why cannot we just pass the address of the variable and alter the value at that address by doing some algebraic calculation and return it to function main() ? A pointer is the address of a variable. That's exactly what happens when you pass a pointer to a variable.
You can put while loops with gcc statement-expressions ;) I like the comma operator too, but I usually only use them for macros.
A good way to learn is to just read through K&amp;R2 and do the exercises. The strategy for learning is pretty simple, put in the effort to learn a bit each day, have one or more things to work on (exercises, challenges, projects), and have something you can use as a reference to learn from (other peoples source code, question/answer websites accessed through search engines, IRC channels, etc). For programs, all you really need is a text editor and a compiler, not much else. Which platform/operating system are you going to be using?
Many thanks for the great reply. Will be using this later. :)
Might be of interest: http://c.learncodethehardway.org/book/ (note, this is part of this guys stuff if you want to learn another language as well... http://programming-motherfucker.com/become.html )
K&amp;R is a great way to learn how to write C in the 1980s. But exclusively using it to learn C now will lead to tons of bad habits that need to be re-learned down the road. It is an important book to work through, but not a good introduction to the language. Here are some better suggestions: http://stackoverflow.com/questions/562303/the-definitive-c-book-guide-and-list
I have to concur with this post. Also, look online at the syllabi of introductory C courses at junior colleges or universities. Consider purchasing the course required textbook and going through the book and exercises. Most college texts have excellent examples and in my experience many of the exercises are based upon modifications to the supplied examples.
Blech, sleeping for 2 seconds for every test? Seems like that would make it take a lot longer to run. Why not use the millisecond-precision timestamps universally? Also, why not switch to a different API? You mentioned you're on Windows, so you have the handy [CryptGenRandom](https://msdn.microsoft.com/en-us/library/windows/desktop/aa379942\(v=vs.85\).aspx) function.
&gt;Blech, sleeping for 2 seconds for every test? Seems like that would make it take a lot longer to run. It did. But it could also run in the background while I worked on the more permanent solution. &gt;Why not use the millisecond-precision timestamps universally? That's the end game. &gt;Also, why not switch to a different API? I'm a tester, not a developer. I'm constrained by my tool. 
I will leave [this](http://www.iso-9899.info/wiki/Main_Page#Stuff_that_should_be_avoided) here, it talks about why you should avoid Zed Shaw's Lean C The Hard Way. My experience wasn't that bad when I tried that, but I don't think it's good to start with, some of the concepts are throw like nothing and there are errors that might get a beginner confused a lot, I don't remember which ones because it has been a while since I last tried it, but I doubt it was fixed until now.
 #include &lt;stdio.h&gt; #include &lt;jansson.h&gt; int main() { json_t *root = json_load_file("log.json", 0, NULL); puts(json_string_value(json_object_get(root, "name"))); puts(json_string_value(json_object_get(root, "address"))); } 
valgrind, gdb, gprof, perf, make, autoconf
I guess it's focused on batch text processing because it comes from a UNIX perspective
no gdb? I practically live in there
The nostalgia.
Yes, I should include that, but I use it sparingly. A lot of my work is embedded, so GDB isn't always practical. I build what I can on x86 and run valgrind/gdb there.
It probably wouldn't run, but according to wikipedia: &gt; In November 1987, Windows 1.0 was succeeded by Windows 2.0. Microsoft supported Windows 1.0 for 16 years, until 31 December 2001 – the longest out of all versions of Windows.
The problem is actually that modern Windows dropped support for Win16 software. Current 32-bit (could be wrong...) and all 64-bit versions of Windows cannot execute 16-bit software any longer. Hence, the binary couldn't run any longer. Ah, it appears that Win16 software should work up to Windows 7 32-bit: [http://www.classicdosgames.com/utilities/win16.html](http://www.classicdosgames.com/utilities/win16.html) The source code, on the other hand, should compile for Win32 relatively easily.
If you want an approach that's good for beginners, I would take the Harvard intro computer science class CS50. It's free on edX and the first few weeks of the class focus on C programming with great problem sets that will build your skills. 
Even better! Am I correct in assuming that stab[] is a constant instance of fspec? 
No, you need to json_object_get the nested object
Just out of curiosity, what kind of embedded stuff are you doing? I'm looking to get into microcontroller programming for fun
emacs, gcc, gdb, make, autotools, git, GNU global
I was more speaking to the flexibility of the SendMessage/PostMessage construct. There are, of course, weird and clunky bits to the Win32 API, of course, but what API doesn't have its messy parts? I would hardly consider the reserved MSDOS device names part of the Win32 API, though.
If you want to learn quickly, read K&amp;R 2nd ed. K&amp;R is pretty dated and concise, so you won't get tons of explanation or any ANSI C related stuff, but it was written by the creators of C themselves and many people swear by it and still recommend it to this day. If you want to learn more comprehensively, read *C Programming: A Modern Approach 2nd ed.* It's like a college text book that goes more in depth. There are good explanations, examples, exercises, and programming projects; plus it *does* cover all the modern nuances. When I started learning C at square 1, I tried K&amp;R at first, but the exercises were too difficult at the time. After finding *A Modern Approach*, it had a way lower barrier to entry, so I've been able to work through it and get much better. Now I can tackle K&amp;R exercises no problem.
No it doesn't. I changed myVar to "John", recompiled and I got back J. So getting J when myVar is John or C when myVar is Caren is correct. I am just unsure as to why it firstly printed out Z. It's obviously some error but I am trying to figure why it might have happened in the first place..
Well, the only 'mistake' I see is that I'd gues you intended the address *of the string* to be printed, but you are actually printing the address of the stack variable 'myVar'. Use `printf("myVar address is %p\n", myVar)` if you want the address of the string. But as far as getting 'Z' back, I think you just miscompiled or something. No way for that code to print out 'Z'.
&gt; I'm having trouble printing the values Do you get any output at all? &gt; if (c &gt;= 0 &amp;&amp; c &lt;= 9) Maybe try changing this to *if(c &gt;= '0' &amp;&amp; c &lt;= '9')*, since you're getting chars and not integers, if I understand correctly. *++ndigit[c]* should thus also change to *++ndigit[c - '0']* . 
Also, for your digit loops, you loop from 0 to 10 included (so 11 digits total), so you want to exclude 10. 
Thanks for your reply! I didn't really understand why where were apostrophes around the 0. But now I understand. What's the difference between ++ndigit[c - '0'] and ++ndigit[c]? Doesn't c = c - '0'? 
I think you're miss understanding. I'm not trying to write a good program, I'm simply trying to "hack" this one. 
I tried that several times, I'm not sure why it doesn't work... Here's the second half of my edited code (changed, as you suggested): while ((c = getchar()) != EOF) { if (c &gt;= '0' &amp;&amp; c &lt;= '9') { ++ndigit[c - '0']; } else if (c == ' '|| c == '\t' || c == '\n') { ++nwhite; } else { ++nother; } } printf ("digits = "); for (i = 0 ; i &lt; 10 ; ++i) { printf ("%d ", ndigit[i]); } printf("\t spaces = %d \t other = %d \n" , nwhite, nother); return 0; } 
why not do both at the same time?
Great! :D The return key sends the character '\n', so that's why it should be end condition of the while loop in your case. EOF is the same thing in Windows/Linux/Mac, it's what's at the end of a stream, it's just that the way of calling "manually" can be a little different. I was not familiar with the *c = getchar()) != EOF* condition, that's why I was asking.
It seems that you should corrupt the stack such that when gets returns, it jumps to the start of the bad function. My guess is the `save %sp, -128, %sp` instructions are generating a pretty large stack frame, so you might want to create a larger text file. Judging by the assembly, this doesn't appear to be x86 code, so I can't tell much beyond that. I don't know what the save and restore instructions do, so it might help if you could provide more details on that. EDIT: It's also possible that whatever machine you are running on saves the stack differently, so you might need to craft your data to overwrite the stack with the exact values that you need, and only change the return address.
So this looks like one of the [Exploit Exercises](https://exploit-exercises.com/)? If I remember correctly, compile it with debugging: gcc -ggdb -fno-stack-protector -z execstack -o &lt;output&gt; &lt;filename&gt;.c gdb -q ./&lt;output&gt; disass main Find the return address from goodFunctionUserInput(void) and over write that with the address of oopsIGotToTheBadFunction(void) in your input to the program. You can also step into goodFunctionUserInput(void) and do 'x/2x $ebp' (look at the value the base pointer points to and the next value). The next value returned will be the return address of the function. You can use 'info func' to get the address of all the functions. If you need to, work through a gdb tutorial or buy "The Art of Debugging" by Norm Matloff. There are also writeups on the web for Exploit Exercises, but try to figure it out yourself first, take notes, and you will learn more. Edit: added '-fno-stack-protector' and '-z execstack' to compiler command just in case.
Something similar, yes. For some reason, when I execute the 'info registers' command, I don't see ebp, esp, or any of the 'normal' identifiers. Because I knew what I was looking for, I was able to find that sp was my esp, but I don't know how to tell what my ebp is called. Any ideas? Here's what I see: http://imgur.com/xBThNbV
Not off the top of my head. The only thing I could say is this looks like something other than Intel x86 or x86_64. What type of system and OS are you working on? Also, if it is something similar to Exploit Exercises, what is it?
The book 21st Century C is pretty good for modern practices. 
 #include &lt;stdint.h&gt; uint8_t fixedWidth_what; uint_fast8_t atleast8bits_what; That's what you get with C99 and it's quite nice! Of course there's a lot more, but that's the biggest thing I miss if I have a non-C99 compiler. ( int8/16/32_t, int_fast8/16/32_t, uint_..... ) 
Because the whole point of the assignment is to study a famously insecure function and learn *why* that type of function is insecure and exactly *how* you can carefully craft your input to a function like that to trick a computer into running some other function of your choosing. To remove the gets() function would completely remove the meaning of the lesson. It's worrisome that in the weaponized landscape we find ourselves in today they still don't teach the basic concepts of secure programming right alongside the other fundamentals. It's not enough to know "don't use gets()", you need to know WHY and what can happen if you do because gets is just a symbol of this type of vulnerability. You could easily introduce the same vulnerability into your own code if you're not taught the risks. edit: I guess I shouldn't complain without trying to offer something constructive so here's a good book about securely programming in C from [Robert C. Seacord of CERT](http://www.cert.org/secure-coding/publications/books/secure-coding-c-c-second-edition.cfm?)
So looking at this again, my guess is 'fp' would be your base pointer. It is sometimes also called the frame pointer.
Looks interesting. What's your plans for it?
Hmm and what about if you dont know in which child is the info we are looking for?
Just to comment on the headers, you might like to move the includes from the header to the C file. This helps create a clear separation between interface and the implementation. For instance, as it currently stands, the ui module is implemented with ncurses. If this dependency changes later on and you'd like to use termbox, conio, or some other TUI library, all you have to change is ui.c (or write a different version of it, if you're supporting multiple platforms/libraries), and ui.h and the code that calls functions from ui.h can be left unchanged.
Nice!
I had some of those on mind, thanks for the feedback! EDIT: * [I unified the :plot and :implicit commands](https://github.com/gciruelos/termplot/commit/cdae31ce0b68329704067a0ff1cd801212f27e19)
http://ieng9.ucsd.edu/~cs30x/sparcstack.html
It would be nice if you listed the dependencies for building in either the README or another file that details what it takes to build. Looking at the screenshots I thought it would require ncurses and after looking at the source that became readily apparent, but not everyone who uses your program is going to know where to look to find these things. I haven't read through your code much. But it would be nice if you were consistent with indentation. Looking at ui.c I saw places where it was 1, 2 or 3 spaces. It makes it easier to read especially when matching braces or parens. If you use tabs for indention, then other people can have it display however many spaces they like in their editor.
it wasn't the most thought out idea I'm sure. I didn't even consider crossing lines.
I don't see any reason not to send all 3.
Why would you expect the call to `puts` to work if you have not executed the instructions that set up its arguments? The `call` operation will transfer control to the target address and perform some initialization of the stack frame for it, but it won't set up the arguments to the call for you. You need to jump to the function that calls `puts` rather than `puts` itself to get the proper context.
Thanks! I figured this would be more or less what they were looking for.
I'm sure I could implement one of those, but I have a limited amount of time right now. Thanks for the code suggestions!
Assuming you mean something like a MUD (Multi-User Dungeon), it's just a matter of writing the formatted data to the TCP connection in the same way you would write it to stdout. The basic idea behind programs like telnet and nc is to copy data from stdin to the connection, and data from the connection to stdout. So that's the interface for your program -- read data that's typed by the client into their terminal and write data that will be displayed on their terminal. You just need to handle many of those connections simultaneously along with modifications to the server's state and all of that. There's a few ways you can do that; non-blocking I/O, event loops with callbacks (uses non-blocking I/O), multiple processes with fork() and use pipes/files/shared memory for IPC, and there's also different multi-threading libraries/models that you can look into. 
The telnet protocol is pretty simple, you can pretty much fully understand the RFC (minus all the options/additions) within 30 minutes or so of reading it. Telnet can be used for text or binary data communication, most of the time its used for text. Check out libtelnet (linux repo or google the github repo), I used it quite recently for a work project and it handles the telnet protocol for you.
Do a google search for Beejs Guide to Network Sockets. That was a gem of an intro to socket programming back in my day. Then move up to Richard Stevens network programming books.
Looks like a lot of Linux/vim users on programming C. Or is vim also available on other platforms?
[Quick Google search.]( https://www.google.com/url?sa=t&amp;source=web&amp;rct=j&amp;url=http://faculty.mu.edu.sa/public/uploads/1410684114.9986OOP%2520C%2B%2B.pdf&amp;ved=0CCEQFjABahUKEwjJicbYxv_GAhVUNYgKHTqvB78&amp;usg=AFQjCNHO08rZV5IOzRyQAS5smUo-eJGiIA&amp;sig2=2NdjtdSuKnOIJ9me78A0_w) You're welcome. Sorry for not answering your question though. But if your professor recommends it, then I suggest you click on that link. 
They are the same thing, so you shouldn't need to buy the extra textbook unless you need something very specific from it, like practice questions (etc).
This is the output http://imgur.com/TBFLeNS
You never initialize the values of *pmatrix*, so they hold random values that you add to. pmatrix[10][10] = { { 0 } }; // Product of Matrix A and B
Since it's not clear to me what an RVA is here, I'm assuming you have a file like so: header record1 record2 ... recordN &amp;nbsp; Seek to the end of the header to find the first record, and then just seek forward and backward the size of the record each time. The only time you should be needing to remember use the header size is when you rewind to the start of the file. Otherwise, just keep track of what record you're on, and as long as you're at least &gt; 1, you can seek backwards one. If that's not what you're trying to do, then ignore this, and probably provide a bit more info for the next person replying. HTH
PERFECT! I thought of this but I wasn't sure how to initialize a 2D array. Thanks a lot for your time 
You can do it with a loop if you like, but you can also initialize arrays completely or partially at declaration, like I have here. If you want you can initialize the whole thing: int foo[ 2 ][ 2 ] = { { 0, 1 }, { 2, 3 }, }; Anything you don't supply will be set to zero, or the equivalent for the data type.
Nothing should be drawn on the server-side at all, and the client-side's just an ordinary telnet client. As I said in the previous post, the telnet client just dumps what it receives to stdout for the most part, so if stdout is a terminal, colours and all that fancy stuff can be done by sending escape sequences to the terminal. Here's the output I got when I connected to aardwolf.org:4000 and went through the account registration thing (reformatted by xxd): http://codepad.org/NxpWR3FO In this case, the 'clearing the screen' effect is accomplished by a bunch of "\n\r" sequences. There's really not much magic involved, it's just a matter of squeezing out whatever functionality you can get from your terminal without breaking compatibility with other terminals.
You need to read the sections directory first; from there you can map an RVA for a section by bounding the RVA using VirtualAddress &amp; VirtualSize to find the right section, then you can use PointerToRawData to get the file offset of the section, add that to the RVA and subtract the RVA of the start of the section (found in VirtualAddress). Always handy to read through this: https://msdn.microsoft.com/en-us/library/ms809762.aspx
For relatively small projects the suckless guys have a pretty clean way of organizing things: [git.suckless.org](http://git.suckless.org) [git.2f30.org](http://git.2f30.org) (specifically look at C projects like [dwm](http://git.suckless.org/dwm/tree/) and [quark](http://git.suckless.org/quark/tree/) and you'll notice a common structure)
Yup, vim is available on other platforms. Linux is nice for writing C because the environment is basically all ready to go for you.
For me, it depends on what my goal is and who my audience is. If it's supposed to be super portable, then I will use Autoconf/Automake. That's usually when I put stuff under src/ and test/. I do that so that the noisy, yet highly portable, scripts inside of the root dir don't get muddied with the source code files. It makes it easier for the reader to know to go right there to see the meat of the project and not the supporting files. If it's something small, then I probably have a simple Makefile in the root directory and keep the source files there too.
&gt; Try &gt; &gt; if (name == "Dodi") No, absolutely not. You can't compare strings with the `==`&amp;nbsp;operator in&amp;nbsp;C. You need to use `strcmp` from `&lt;string.h&gt;`. EDIT: Actually, I don't know what this `string` type is in this code, but certainly the `==`&amp;nbsp;operator will not work for comparing strings.
I use an include directory, and a modules directory, which contains all of the individual components. Each module has a local.h file that describes all of the internal structures and functions, and also an include file that describes the outward-facing api for the module (with substantial documenting comments). Then the rakefile (I know most of you are probably using make - rake is fairly equivalent, but much easier to work with) compiles each module independently into a module.o and module.so file (the .so files are for ruby ffi bindings - I use ruby's rspec for my module testing), and finally links all the modules together as needed (a dependencies.yml file describes the intermodule dependencies).
Please consider answering the questions other posters asked you. We cannot help you if you don't cooperate. Please also indent your code with four blanks so it comes out in a mono-space font. It's very hard to read otherwise.
You are doing if string == something, not name == something (but use strcmp). String is a type, name is the variable here
String is a type in cs50 yeah
[**@rob_pike**](https://twitter.com/rob_pike): &gt;[2015-07-29 23:42:30 UTC](https://twitter.com/rob_pike/status/626538319237681152) &gt;[#define](https://twitter.com/search?q=%23define) bitblt\(s, r, d, p, c\)\(\*\(\(void\(\*\)\(\)\)0x430d6\)\)\(s, r, d, p, c\) &gt;First\-ever C cast to function pointer? dmr wrote it for me in 1981. ---- [^[Mistake?]](/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/3f3i7w%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
??????????
I understood the code I just didn't see the point. And why is it a define? Just create the function pointer and then assign the hardcoded address to it.
so this is the error: "error: unexpected type name 'string': expected expression if (string = "Dodi")". "GetSting" is inside cs50.h. still doesn't work :(
C does not have a `string` type. Try `char *` instead.
a link to cs50.h https://mirror.cs50.net/library50/c/cs50-library-c-3.0/cs50.h
Ah, of course. I am a silly sausage. According to https://mirror.cs50.net/library50/c/cs50-library-c-3.0/cs50.h string is defined there, without the &lt;string.h&gt; include.
I think it all comes down to what makes sense (files and directories can be used to organize code and convey its high level structure to make it easier to read and browse) or what is convenient/easy. With auto-complete tools and symbol indicies it doesn't matter as much where exactly a function is defined because it's very easy to find, and vanilla `make` isn't very pretty when you use subdirectories. The tools you use and the size of the project matters a lot; some projects have no subdirectories and are still easy to understand and work with. My current approach, while it sometimes feels a little heavy, uses many directories, one for each high-level module, e.g. server or client code, text and string routines, file formats and parsing, test framework, etc. These in turn contain one or more source files, private and public headers and tests (mostly black box/functional tests). So the root directory has one sub-directory for each module, which contain the sources and headers. Maintaining a Makefile by hand for this is quite tedious, so I have a common GNU Makefile that I use in several projects, which understands this directory structure and all I need to specify is a small project specific configuration that lists which directories are modules. Most modules are just tiny libraries, but generally at least one module is a binary, and in a client/server project there can be several binary modules. To end my rambling, the main idea is that you should use the file-system to place boundaries between modules. Sometimes a single source file is a module, other times it is a set of files for a larger module. Don't worry about it too much until you feel it has become messy, and look at how others have solved it and try to figure out why they've done it the way they have. If you don't understand why, it's just cargo culting.
Pointers are everything. When you want a function to return more than just an int, you need a way to pass it. Pointers to the rescue! char *getString(void) { return "This is pretty big. Glad it's a pointer!"; }
There is a simple explanation. Imagine your variable would be a house. A huge complex struct for example. Now you need to get some woodwork done in your attic. So you go out and hire a Carpenter. And you tell him please fix the attic in my house. Would you rather take your house with you to the carpenter and show him the attic, and then go back home. Or just give him a card withthe address off your house , so he can find his way itself ? ;) 
So for function with complex return values, I should always use pointers or is that the only way to return complex function results?
Someone else will most definitely provide a better explanation, but there are many reasons why pointers are extremely useful. First of all, having direct access to memory is very powerful. However, with great power comes great responsibility. So don't start using your powers if you don't know what's really happening. There are many examples to use, but here's one I always found interesting. Let's say you are passing values to a function, and the same values are being passed through that function into another function; essentially the same data is being passed by value through various nesting functions. As we all know, data being passed by value has a temporary copy on the stack frame (a temporary work space for a function), and after each function is done, the stack frame collapses and all temporary variables are destroyed. So, your value that you passed through won't change, because the value was destroyed in all functions. Let's say we had a POINTER that pointed to a specific address in memory. You start passing that pointer (that will always point to that address) to another function. You can assign values to the pointer, access any values inside the pointer for further use (dereferencing), and other things but that's out of my scope. You no longer have that temporary variable problem because passing by pointer doesn't create a temporary variable; the function can easily lookup the address where the pointer is pointing to and access the data. So you can do many manipulations without creating any extra temporary variables or any nonsense. I hope this makes a little bit more sense! 
C is pass by value. When you pass arguments to functions, the program copies those arguments and operates on the copies. The original variables are not modified. When you pass a pointer, the program does the same thing. It copies the data, which happens to be an address. The function gets a copy of the address, but the address is the location of something outside the function. The function can access that outside data using indirection. Another thing you can do if you know the address of some data is represent it as something else by casting. You may have read 10 bytes from a file into a character array. Let's say that you know the data is stored as binary--not text-- and represents several fields in a struct. You can cast the array to a struct where the bits fill in to give you your data.
You've probably been mislead by shitty tutorials that give you examples like this: int i; int *pi = &amp;i; *pi = 42; printf("%d\n", i); If that's all you've seen, then of course pointers seem useless, because why wouldn't you just write: int i = 42; You wouldn't. The example is contrived. Let's look at another example: #include &lt;stdio.h&gt; int main(void) { printf("Hello, world.\n"); return 0; } This is probably the first example that you ever saw of C. And it uses pointers. How? What's the signature of `printf()`? int printf(const char * restrict format, ...); You can ignore the `restrict` if you aren't familiar with it. This is the signature of a function that takes a pointer to const char as its first argument, and an unspecified number of arguments after that, and which returns `int`. The string literal (`"Hello, world.\n"`) that was passed as the first argument actually represents an array of const char with static storage duration which is allocated somewhere in memory. That array decays into a pointer to the first character, and that pointer is what you're passing to `printf()`. So that's an example of a major use of pointers. You can't pass an array of something to a function, but you can pass a pointer to the first element of an array. The function can then determine via other means how large that array is, in this case because it's a null terminated string. Look at all the signatures of the string related functions of the standard library: size_t strlen(const char *s); int strcmp(const char *s1, const char *s2); char *strcat(char * restrict s, const char * restrict append); [...and so on](http://pubs.opengroup.org/onlinepubs/009695399/basedefs/string.h.html). They all work with pointers, because that's how you efficiently tell a function to read or write some contiguous block of memory. String handling is a very large part of many programs, but that's only one use of pointers. Other uses include: - Working with dynamically allocated memory - Building data structures (trees, linked lists, queues, etc.) - Abstractions built on function pointers, such as callbacks or vtables - Input and Output ... and more. Pointers are a core, fundamental part of the language. It's practically impossible to write a program that does something non-trivial in C without using pointers. (Edit: well, maybe you can avoid them if you do input and output a character at a time and only do very simple text formatting, like some of the exercises in K&amp;R, but I posit that that's not the style in which most real world programs operate.) Don't let shitty tutorials mislead you. If you don't see the value yet of pointers, just keep learning, because you will. 
Thanks, makes perfect sense. I am actually going through some code that has do to that exactly, it does not know a priori how many variables it will receive from a file, so now it makes a lot of sense.
Yep, myArray[1] is just a more readable format they gave us for doing that same operation, adding numbers to the first address to create it's neighbour's addresses.
A pointer can be easily summarized as *a variable that holds the address/location of another variable*. The address is just a number. A pointer is like a regular int, except you can dereference it to see the value of another variable. When you get values from functions, or pass arguments to them, the variables for those values are just copies that only exist as long as the function is running. (Look into the stack vs the heap on Google or a book or something). So this function: void add_nums(int a, int b) { a += b; } int x = 1; int y = 2; add_nums(x, y); printf("%d", x); would print `1`, because a and b are copies of x and y which are gone once the function is over. Now, using pointers, we can make it work correctly: void add_nums_v2(int *a, int *b) { *a = *a + *b; } int x = 1; int y = 2; add_nums_v2(&amp;x, &amp;y); printf("%d", x); This time, we correctly get `3` because copies of *pointers* were used, and we can get to the original variables by "pointing" to them. So now imagine a large/complex data structure, like a struct. It would be inefficient to pass copies of these huges variables everywhere, so we just pass a small pointer, which allows us to not pass huge copies and modify original values.
Yes, since you only have to pass the small sheet of paper with the address and not the whole house with all the floors/walls/windows/pipes/etc. 
Here is an oldie but goodie tutorial on pointers that helped me grok pointers - http://pweb.netcom.com/~tjensen/ptr/
hey /u/FUZxxl I'm short of time for a while now, but atleas got a few minutes to check this subreddit ;)
Don't point your pointer at me just to make a point about pointers
Great reply, hats off to you!
I just saw a triple pointer in the code I am trying to figure out, it gave me a mild headache, but THANKS everyone, it all makes much more sense now!
To pass huge chunks of data to functions with minimal overhead and declarations 
There's nothing covering that in the international standard that defines the language. (The international standard is intentionally quite abstract; it doesn't say anything about the details of an implementation, such as object files, library/executable file formats, command line options, etc.) There are numerous package managers in common use (e.g. APT, Yum/RPM, Nuget, yypkg, pkgsrc, pacman, pkgtool, portage, etc.) but each supports only its own limited domain/platform/environment. There is nothing universal.
Are those different than Linux package managers, like for example apt-get and dpkg? Full disclaimer, I just started with Linux 3 months ago.
CCAN, http://ccodearchive.net/list.html It's not that big, but its one of the only ones I have run across. *Just noticed this was not really what you were asking
Hey! You got code written by a [three star programmer](http://c2.com/cgi/wiki?ThreeStarProgrammer).
In those days it was cool to do things in one line
Maybe you initially wrote `Z` something, then changed it to `Caren` and didn't save... or something 
The code has obviously been written on Windows (nobody with a sane mind would use `fscanf_s` otherwise), so it's okay. But OP, remember: The effect of calling `fflush()` on an input stream is not specified by the standard, your program might not work on other platforms.
I code in Windows and fflush(stdin) doesn't do anything. Perhaps it is just a MSVC thing.
OP uses `fopen_s` which is a bit different.
The {0} is an initializer. It sets all the entires of the first[] and second[] arrays to zero. The 'a' is the literal value of the character 'a'. It's converting a value that is a lowercase 'a'-'z' to a number between 0 and 25. Maybe breaking it down will help. /* a[c] is the character value, between 'a' and 'z' */ int index = a[c] - 'a'; /* Make a=0, b=1, ..... */ /* Now index is between 0 and 25 */ first[index]++; EDIT: 'z' - 'a' is 25, not 26. Thanks /u/F54280 for paying attention! 
our answers crossed. 0 to 25, btw :-)
In addition to the other mistakes in how scanf is being used, you are not checking the return code. scanf returns a value that tells you whether the input operations succeeded or not and you should be checking that.
Can u elaborate on how I can check scanf? I thought I have printf commands to see what I put in scanf
http://en.cppreference.com/w/c/io/fscanf scanf functions return an int indicating: - if there was an error reading before assigning to the first receiving argument, and otherwise - the number of receiving arguments to which scanf successfully assigned. Example: char a, b; int result = scanf("--%c--%c--", &amp;a, &amp;b); if (result == EOF) { // There was an error before either 'a' or 'b' were assigned to. } else if (result == 0) { // a pattern mismatch occurred before either 'a' or 'b' could be assigned to } else if (result == 1) { // User input was successfully read and assigned to 'a', but an error or pattern mismatch occurred before 'b' could be assigned. } else if (result == 2) { // User input was successfully read and assigned to both 'a' and 'b'. } else { // this can never happen assert(false); } Typically you only need to care that all of the arguments are assigned to: float x, y int result = scanf("{%f,%f}", &amp;x, &amp;y); if (result != 2) { // some error occured } Here's a program that demonstrates scanf behavior with a few different inputs: http://coliru.stacked-crooked.com/a/9ecbdc66d99810e4
&gt; many platforms Can you name any other than MSVC? 
Not really, you generally use the system package manager or manage dependencies manually. Now I can appreciate a nice package manager, they can be convenient, but I do think that this way is better. Package managers like npm and bundler and pip/virtual_env encourage the proliferation of dependencies. You end up with a lot of small dependencies and, worse, dependencies that you only use a tiny part of. Having a complex dependency graph can be a real pain to manage, and you absolutely have to audit every dependency every time you update it to make sure it hasn't added any malicious code. Managing dependencies through the system package manager heavily favors mature libraries that are well supported and have strong communities and good documentation. And strong guarantees of api compatibility between versions since keeping multiple versions installed is very inconvenient. The biggest disadvantage is that during development, if your team members don't all use the same distribution you have to manage your dependencies differently across machines. But if you're releasing to user machines (as opposed to releasing to your own server) you'll have to make individual packages for different distributions anyway. Unless you're project is free software and significant enough to make it into official package repos, in which case the distribution's maintainers will build those packages. And note that even with npm-like package managers, you really should be using the system package manager when deploying to user machines, otherwise you have all the problems usually associated with static linking.
On UNIX platforms, this behaviour applies, too. To quite from the glibc manpage `fflush(3)`: &gt; For output streams, `fflush()` forces a write of all user-space buffered data for the given output or update stream via the stream's underlying write function. For input streams, `fflush()` discards any buffered data that has been fetched from the underlying file, but has not been consumed by the application.
Can you show me your updated code? It's hard to tell what the problem is without having a look at your code. Does the compiler give you an error or a warning?
the only thing i changed is what you have. The compiler did not give me an error or a warning. However when i selected to load from file. It said the program has stopped working. something like Access violation writing location 0x00FEA000.
Exactly.
Sorry for all the questions, but I trying to figure this code out. So it seems to me that he is using a triple pointer because he is calling a function, that calls a function and calls a third function, but each function acts on different parts of a data set that is stored in a struct. Does that sound like a situation where one would use triple pointers?
Giving general advice on interviews is hard for me. Interview questions differ from company to company and from interviewer to interviewer. I’ve interviewed many C programmers in the past. I won’t go into the specifics of the questions I ask but here is some general advice based on my experience: Be proficient in the C language - that means be able to solve programming problems using the language. Expect to write C code. When I conduct an interview I ask the candidate to solve small problems, problems that can be solved in 30-45 minutes, by writing code on a white board. I look for both problem solving skills and code quality. I look for comfort with the language. I look for clean, understandable code. I look for correct code. I do make allowances for the fact that whiteboards are terrible for writing code. Understand the code you write. I ask follow up questions about a candidate’s solution. For example, I may ask about tradeoffs or performance implications. (My job is performance sensitive). For me, its important that a candidate be able to understand what’s involved in the tradeoffs. The exact choice when making the tradeoff may not be as important in the context of the interview. Communicate. A big part of working in a team is communication. When I hire someone I want that person to become a part of my team. I will ask that person to do things and will want that person to be able to understand my request. A team member will need to be able to ask questions if they are facing a problem, I would prefer if they can do that clearly. A team member should participate in team discussion about problems the team needs to solve. Communication skills are critical here. Demonstrate your ability to communicate during the interview. Related to the above, if you don’t understand a question in the interview ask for clarification. If you think the problem description is vague or ambiguous ask for clarification. You want to communicate and you don’t want to waste time answering the wrong question. Hope that helps.
Sorry for not answering, I was away. Can you send me the complete code after your correction? Just put it on a paste service or something.
thanks, I am still trying to dig all the functions because they are spread over several include files! 
Here is the link: https://www.dropbox.com/s/50nrbzm4eabeydd/Source.c?dl=0
"Where do you see yourself in 5 years?" "I *C* myself in this company." Then you both laugh and you're hired.
For now, I know functions, strings, arrays and can write programs based on these concepts. Any other major concepts as in buffer overflow.... and other ? where can I study them?
:') Have an upvote sir. that is all i have to give.
https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence
Did you try consulting the documentation of MPI?
Thanks man!
Yes, but C is not really the best language for this because there. In the end a website is just a program which implements the HTTP standard and which has some data accessible from the URLs it defines.
It is specified at runtime.
It seems that /u/livid_taco copied /u/TheMG's comment from the other thread. I just replied to him, I never ever read the [other thread](https://www.reddit.com/r/programming/comments/3fjmi4). Quite funny that both you and me gave the same response.
Ah, I see. I just removed his comment. I don't need no phonies here.
You've just used a double negative! :P
Do these assignments yourself! It will help in the long run. ..But since you are asking a question: #include &lt;stdio.h&gt; #define EVAL(expr) do{\ printf("\"%s\" evaluates to: %d\n", #expr, (expr));\ }while(0) int main(int argc, char *argv[]) { EVAL(5*6+8-4%3); EVAL(9 * 2 + (8 - 5) / 2 &lt; 1 * (7 + 4) &amp;&amp; 6 + 7 * 4 / 5 &gt; 7 * 2 + 5 - 4); EVAL(65/(9-3) != (23+10)/4+1 || 8+25 &lt; 225 &amp;&amp; 6+29 %4 == 2*3-4); //etc.. } Output: "5*6+8-4%3" evaluates to: 37 "9 * 2 + (8 - 5) / 2 &lt; 1 * (7 + 4) &amp;&amp; 6 + 7 * 4 / 5 &gt; 7 * 2 + 5 - 4" evaluates to: 0 "65/(9-3) != (23+10)/4+1 || 8+25 &lt; 225 &amp;&amp; 6+29 %4 == 2*3-4" evaluates to: 1 In this example true/false also get printed as their numerical representation
This is why the GCC 'expression statement' extension is so cool.
Please understand that this is not a homework service. What is the concrete problem you are experiencing? Where are you stuck? Furtermore, please translate the assignment for us. Google Translate produces unreadable gibberish for me.
las_data reads the resistance values ​​from the measurement file and load vector series with a number of series of records , one per series . Each series -mail to keep track of the show's total number of resistors , the total number that deviates more than 5 % from the nominal value , and the average of all resistances in series. The function will return the number of series. visa_stat be in diagram form, draw a trend line that shows the mean values ​​deviations for each series of the nominal value and , finally, the total number of resistors and the total number beyond 5 % threshold , both absolutely and as a percentage . For the drawing of the curve , use gotoxy in MSViscon package
I guess I "anwsered" the wrong way again lol. "Okey thanks for the reminder! Yes I think I know how to compute it. I just need to get to the step where I can compute it!"
I think you still did it wrong. To answer to a comment, click on the “reply” link right below the comment you want to answer to. I don't think you want to answer to your own comment though... --- Have you ever written code that reads a file? Do you have any idea how to do that?
Ohh that's sad.. No I havn't. I've read about it a little and tried but I can't get it to work.
All the nodes have the ability to communicate with each other. Each process on each node has the ability to communicate with each other. Each node (machine) can have multiple cores. Depending on how many cores each node has, you may want to vary the "ppn" argument to control how many processes run on each node. Usually (and this can vary based on lots of things), I choose "ppn" to be half of the number of cores.
Hello! I tried these 4 functions seperatly to "scan" and print the values but none of them works. antal=amount, summa=sum. Am I on the right path or am I nowhere? int las_data(FILE *tsin, struct seriepost serier[]) { rewind(tsin); int i, antal; double summa, tal; i = 0; antal = 0; summa = 0; while (fgets(&amp;tal, sizeof(tal), tsin)){ antal++; summa = summa + tal; } while (fscanf(tsin, "%lf", &amp;tal) == 1) { antal++; summa = summa + tal; } while ((tal = fgetc(tsin)) != EOF) if (isdigit(tal)){ summa = summa + tal; antal++; } for (i = 0; i &lt; 8; i++) { fgets(&amp;tal, sizeof(tal), tsin); antal++; summa = summa + tal; } while (fscanf(tsin, "%d", &amp;i)==1){ antal++; summa = summa + i; } printf("%lf %lf", antal, summa); _getch(); }
Oh that sounds super sweet. I don't have much experience with MPI and all that I have is with a remote Cluster that I used to ssh. 8 Node cluster with hyperthreading. And I really enjoyed it. Have any tips on how to proceed in this field? How is MPI doing against Hadoop?
Of course you can. You can avoid a lot of grunt work by using something like civetweb or klone. As a C newb I've been writing some websocket stuff with civetweb, it has seen fine uptime last month (not yet a single crash!) but C is not a really suited language due to all the string handling that is required for any meaningful website.
~~Try flushing stdout. Adding a newline to the printf format string should do the trick.~~
Please add four blanks in front of each line so your code comes out in a mono-space font. It's absolutely unreadable right now.
For your information. We finally succeded with the assignment. We used fscanf to find the values and looped it until end of file. Thank you for you're help!! 
It was a pleasure to me!
What does "a[i] = b[i]" do?
done. Did not know that.
You don't seem to be declaring i anywhere. This should have given you a compiler error.
Is it a program to copy a string?
A website is a text document served by a http server
As others have stated above, you're assign `a` to `b`. When assigning value to something always read *right* to *left*, **not** *left* to *right*. So your code `a[i] = b[i]` actually assigns the values of `b` to `a` which isn't what you want. The other thing wrong here is that you use, or ***define*** as it's called, the variable `i` the `for` loop, but you don't ***declare*** it anywhere. To fix this insert `int i;` somewhere before the `for` loop and after the start of the `main()` function. Now, a more subtle, but **very** important problem with this code is that it has what's called a ***buffer overflow*** error. This is a **major** security flaw. What this means is that when you read input into the `a` array by using `scanf()`, you do not **check** the size of the input. So someone could input a string greater than or equal to 9 and suddenly they've overrun the buffer size resulting in undefined behavior and possible security exploits; trust me you **do not** want this in your code. If you fix all these things and it still doesn't print, then I'll have to assume (from the fact that you `#include &lt;conio.h&gt;`) that you are on a Windows platform and I have no idea how Windows console output works. I'd try using `fprintf(stdout, "The new string is %s\n", b);` to be sure that it gets printed to stdout as I'm unsure if the Windows implementation of the Standard Library has `printf()` default to `stdout`. Hope this helped! :)
 #include &lt;stdio.h&gt; int main() { char a[10], b[10]; printf("Enter the string\n"); scanf("%s", a); int i; for(i = 0; a[i] != '\0'; i++) { b[i] = a[i]; } b[i] = '\0'; printf("The new string is %s", b); return 0; } Like someone else said you have a buffer overflow as well, you only allocated 10 elements for a and b, what happens if the string is slightly larger than that? (including the \0 you add at the end) 
Generally speaking, if performance is needed you wont be able to use the C library. Instead, you will need to use the API your OS provides for you. So which OS is this for?
You'll need to read up on Mac OSX's File/Directory API, and also all of the API's for whatever flavours of linux you'll be developing for. I have no experience with either really, but Google is always helpful.
`printf()` is just fine for this task. The bottle neck is more often than not the time to write the data to disk, you can't really avoid that. If you need to write more data in less time, consider writing binary data to save space.
can you please expand on that?
Your hard disk is slow. It takes so long to write data to a file that the time needed to prepare / format the data in software is diminishing. Writing to the terminal is even slower than that. One of the best ways to speed this up is to reduce the amount of data you write into the file, for example by writing numbers in their binary representation (4 bytes for a `long` as opposed to 8 characters for the same number in base 10 with a trailing newline).
You can re-direct stdout to a file. That's significantly faster than letting it spill to the terminal. AFAIR POSIX gives some guarantee that messages concurrently printed to stdout below a certain size (which exactly?) will not be garbled up. If that's not fast enough (or safe enough?) for you, you might want to just add some thread-safe queue of some sort that threads can push into, together with a logger thread that flushes it to disk. The queue can be made to grow if the logger is lagging behind and/or block the producer threads when they try to push into a full queue.
First, please format your code properly. I'm getting a headache just looking at that. Now, think hard about what this line is supposed to be doing: for(i=0;i&lt;a[i]='\0';i++); I'll give you the fixed version of that line: for(i=0; a[i] != '\0'; i++);
strlen(). Also, checking that your buffer are big enough before doing anything. And scanf() isn't safe.
Please don't delete posts. Others may come along later and learn from them. As for your overflow question, consider what information you have. When is the size of the needed buffer known? How do arrays and memory allocations work in C?
Please do not remove your question once you received an answer. Doing so makes it impossible for others who have the same problem you have to use this post.
/r/algorithms is that way...
Your program description appears to be quite vague. Could you give some more details?
Sorry. I'll ask in /algorithms.
Hands down the best part of C99 is being able to do for(int counter = 0; blah blah), instead of having to declare every freakin variable up at the top of scope
Went to a presentation when they spoke about MPI, Spark and Hadoop last week. The message was that Hadoop is horribly slow and Google moved on from MapReduce years ago. Spark is up to 100x faster than Hadoop and MPI (written properly) is the fastest of them all but of course it's the more difficult.
d isnt even properly declared, curse anything that lets you get away with that. You need to make sure your code is solid before submitting it for help.
In 'check', the variable 'j' does not stay constant. After the if statement holds true, the function returns and the variable 'j' is deleted. Then when 'check' is run again, 'j' gets created again and is initialized to 0. As for how to correct your output, it depends on what exactly you want the program to do. If you want to print the position of a given character in a given string, 'main' should return after the print statement. To fix the error where the position '0' is printed for check("hello", 'h'), when you find a match, you need to return j+1.
Here is a quick overview on [static variables](http://stackoverflow.com/questions/572547/what-does-static-mean-in-a-c-program).
Let me guess, you're using a 30 year old version of Turbo C 
&gt; One last thing, on the topic of coding practices in general. Its usually a good idea to reserve single-letter variable names for things like loop counters. Other variables, that hold meaningful data, should be given self-descriptive names. Renaming 'a' to 'str' and 'f' to 'search_character' goes a long way in making your code more readable. I go one step further - never use single letter variable names. Why? Try searching your code for 'i' sometime. That's why you'll often see 'ii' and 'jj'. It makes it much easier to search for them when you need to.
Some people asked me to delete posts like this. I'd like to remind you that moderator intervention is only being done for posts that violate reddit's or this subreddit's rules or for posts that are off-topic. I'm not deleting posts just because the author is inexperienced or doesn't put effort into his post. You have vote buttons to decide what content you want to see.
Well, you really want to sort on the four-digit year, right? So convert it to a four-digit year before you sort.
This isn't homework, the head person for the league likes saving money where he can. 
Both Max OS X and Linux are UNIX-like operating systems and use the POSIX-API for stuff like opening files and reading / writing. The functions are named `open()`, `read()`, `write()`, `close()`, etc. This is a read herring though, you won't really improve IO performance by getting rid of `printf`, the problem is that IO is slow *per se,* not that OP is using the wrong API.
I have to wonder what language the project started in that made C such a huge improvement in development time and bug count
Assembly, perhaps?
Ha yeah I know how you feel. When people post that GNU song my god!
So are Pascal and Assembly.
[Joooin us now and shaare the soooftware. Youuu'll bee freee hackers youuu'll bee freeeee.](https://www.youtube.com/watch?v=9sJUDx7iEJw)
Except that Pascal was never intended to be used for actual programming. It was intended as a simple programming language to teach students how to write their own compilers.
This is a good time to learn gdb.
I think it may have something to do with this section: struct doublylist *creat_dll(struct doublylist *temp) { struct doublylist new_node,ptr; ... while(num!=-1) { ptr=temp; new_node=(struct doublylist)malloc(sizeof(struct doublylist)); new_node-&gt;data=num; ... `temp` is passed in as a pointer to a doublylist but `ptr` is a doublylist according to its declaration. Inside the`while` block `ptr` is being assigned `temp` which is an address and not a value. also, IIRC `malloc` should return the address of the newly allocated block of memory on the heap but here it's being assigned to a doublylist instead of a pointer to a doulbylist (doublylist *). Was this code copied correctly? **Edit: back to back asterisks make text italicized so they're not shown 
You only mentioned Ada.
See [this comment of me](https://www.reddit.com/r/C_Programming/comments/3g5ve2/write_in_c/ctvsuhn).
You can still put four spaces in front of each line on a mobile device. That's not an excuse.
I think the real code is struct doublylist *new_node, *ptr; so they are both pointers.
So let's say I do and some of my functions (say print functions) vary wildly from one type to the next, but I make a typo or forget to change something when changing from one kind of variable to the next; with void pointers I could see myself scratching my head for a few hours, but with proper types I should get an error thrown for passing an improper type. I appreciate your suggestion, but disagree with the approach as I understand it. Are there any benefits to using void pointers of which I'm unaware? Edit: clarification
I'll check the video out when I get a minute. I don't doubt that linked lists aren't the best option all the time, but my question pertains to any kind of container really; I just didn't use arrays in my situations because I had no way of knowing how many elements I would need. Thank you for the reply though!
I think a common way to do this is to wrap your linked list implementation in a bunch of preprocessor macros. Then at the very least you use a common set of accessors for all the functions by defining macros for the types, or you pass a common "type" parameter into a single set of macros. This will at least take care of the casting for you and throw warnings if the cast is wrong. There are a bunch of ways to skin this cat, but the preprocessor is your friend so you're not doing anything too wacky. Note: remember to inline (or be sure the compiler inlines) things like push/pop, at least in your hot loops. Otherwise you might as well flush the performance boost of C down the toilet.
The math is not wrong; it is just not simplified (to the point where I cringed when I read it). &gt;It looks sort of like you're trying to use the formula for the progression and not the sum I'm not sure what you're trying to say by this, the formula used is to calculate the sum of all whole numbers from 1 to n; the variable name, as well as the print statement are apt for what the code does.
I'm not talking about your math -- I'm talking about the OP.
I know, and like I said, the math in that code is not wrong, it's just not simplified. The code above, in all likelihood, will work as intended.
Take a look at the `container_of()` macro that's used in e.g. the Linux kernel if you want a *generic* linked list. Then just include the node struct with the data you want in the list, and the iteration and manipulation routines can work on just the node struct. But in many cases plain arrays work really well, especially if the order of the items doesn't matter much.
Your code has a little flaw: printf("limit:"); scanf("%d",&amp;ctr); for(ctr=1;ctr&lt;=limit;++ctr) You are capturing the user input via scanf in the **ctr** variable that you then use as your for loop counter. I think you meant scanf("%d",&amp;limit); 
The GNU Scientific Library provides examples of this: * https://github.com/ampl/gsl/blob/master/matrix/file.c * https://github.com/ampl/gsl/blob/master/matrix/file_source.c * https://github.com/ampl/gsl/blob/master/templates_on.h * https://github.com/ampl/gsl/blob/master/templates_off.h 
+1. In addition OP, you might find it easier to spot bugs like this by introducing some white space to your coding style. For example i prefer a space after any commas and around operators : for(int I = 0; I &lt; 10; i++){ ...
Apologies for formatting, iPad!
There are header files `sys/queue.h` and `sys/tree.h` doing a similar thing but BSD licensed on FreeBSD.
If you don't care about the order, you can just take the last element and move it to the now empty spot. Even if you have to move all the elements, moving memory around is extremely efficient on modern CPUs compared to iterating through a linked list.
dont use turbo c
Both are pointers, maybe the two asterisks made new_node italicised 
Well, you don't need doubly linked lists for many programs (nor linked lists). You can use them, sure, but the more you try to make these things a one-size fits all, you add more unused code to your program, more dependencies, and often as a result, a greater need for maintenance. When you do need them, however, they are simple to implement and you shouldn't find yourself rewriting a lot of old code. For these basic data structures, it is often easier to implement them specifically for your use case, than it is to tailor a generic implementation to your use case. --- Just to tell you a story about my earlier experiences with C, I once wrote a program that counted the frequency of each bigram in its input. I used a hash table to store each bigram and how many times it occurred, and the program ended up being 185 lines. But it handled large inputs well, it was well commented, it handled many files from its input (wasn't a constrant), and it handled n-grams at the change of a macro (also not a constraint). I found it a couple years after writing it, looked at it and I tried rewriting it, and I ended up with a program that was under 24 lines of code which used nothing but an array of `256*256*2` integers (which could have also been `26*26*2`, depending on constraints.) It ran in less time over large inputs (not that there was a significant difference), the code was easier to understand and with no need for comments, and it took only a few minutes to write. I guess the point is, when you're less experienced, it's easy to let fancy data structures drive the implementation of your program. As you become more experienced, though, you're going to find that you can do a whole lot more with less, and you won't really look to these data structures until you actually need them. I also had some desire to make everything as general-purpose as possible. I don't have that anymore. Maybe I've just gotten lazier, but I read somewhere that laziness is a virtue when programming. 
Agreed. I wonder why it's still in use in teaching institutions. I wonder if there's a good job teaching Python 1.5 :)
http://stackoverflow.com/questions/695982/passing-an-ellipsis-to-another-variadic-function I hope this will help you.
It does, thank you. It also seems what I intended to use this for is impossible though. Oh well. I was intending to create a function like the following: Task offload_to_thread( void (*f)(...), ... ); I guess it can still be done with a va_list, but would make it harder for any users (likely only me) to use. You could call it the same way Task t = offload_to_thread(some_computation, 1, 2, 3, 4); but your function would have to do parameter parsing from a va_list itself
The usual pattern is to make `offload_to_thread`'s type signature something like this: Task offload_to_thread(void (*f)(void*), void *f_arg); requiring the caller to wrap the function you want to offload in a suitable manner. This also creates a race condition because the caller needs to provide the storage for what `f_arg` points to but potentially does not know when the callee stops using it. Actually, this very function exists and is called `pthread_create` in the POSIX thread (pthread) API.
The pthread api is one of the backends I would have used for this (windows has another thread API). I was looking for a way to pass in more than one parameter without the caller needing to wrap it (pthread_create only takes a single pointer). I guess the solution would be for offload_to_thread to wrap all the parameters and pass in a pointer to va_list. The function on the other end would have to unwrap, which sucks, but I see no better options.
I recommend you to not use this approach as it has an inherent race condition: The argument list described by a `va_list` is undefined when the function invoked with that argument list (i.e. `offload_to_thread`) returns as the corresponding stack frame is destroyed. If you want another thread to evaluate the content of the `va_list`, `offload_to_thread` has to wait until the entire argument list has been read before it can return which again requires the callee (i.e. `f`) to be modified or a wrapper to be inserted and partially defeats the purpose of `offload_to_thread`.
I was thinking of having a task handle anyway to be able to querry if the task is completed or not. I was thinking of storing the parameters there while offload_to_thread returns, but I see how this may need some thought offload_to_thread -&gt; create_task_with_params -&gt; add_task_to_taks_pool &lt;- .. Thread_pool Process_task -&gt; Get task -&gt; Execute task with parameters from Task -&gt; Free parameters from task -&gt; Free task (? ) - Task could be removed from task_pool, and if something querries for a task that doesn't exist it can be assumed to be completed, safer with memory - Caller could be required to free / destroy the task, but people never use the api as you intended - Other options &lt;- &lt;-
This is a possibility but it violates the principle that the allocator of a resource is responsible for freeing it and complicated verification. What if the thread crashes before it has a chance to call `free()` on the resource?
apt-get install libmpfr-dev libmpfr-doc libmpfr4 libmpfr4-dbg What issue are you having? What do you need help with? I don't see a question here.
and if you add "-lmpfr -lgmp" to your compile parameters?
Here is the code with all implicit conversions and the types of literals made explicit, assuming the type of `somevar` is `int`: uint8 foo = (uint8)255; uint32 bar; bar = (uint32)((int)somevar/((int)foo + (int)1) If the type of `somevar` is larger than `int` or `unsigned int`, the last line would be like this with `sometype` being the type of `somevar`: bar = (uint32)(somevar/(sometype)((int)foo + (int)1)
`a.out` is the executable, that is what you run. 
Thanks, I ran it but nothing happend, is there anyway to see whats actually happening? Edit: well I saw it running at 100% cpu maybe it was just looping?
&gt; if int is too small, the smallest type that can hold the output value I assume the compiler determines this "smallest type" at compile time, based on the operands' types?
The description is not entirely correct. If you perform arithmetic on two objects, then the rules for the type of the result are like this: 1. If both operands have sizes smaller than `int` or type `int`, they are converted to `int` and the result has type `int`. 2. If one operand has type `unsigned int` and the other has type `unsigned int`, `signed int` or a type smaller than `int`, the result has type `unsigned int`. 3. If one or both operands has a type larger than `int`, the larger of the two types is determined (were an unsigned type is larger than a signed type of the same size) and both operands are converted to that type. The result has that type, too. 4. If either operand has floating point type, the largest of the floating point types involved is determined and both operands are converted to that type.
I work with a LOT of europeans (I'm a lifeguard). Some of them study Comp Sci or have studied it in Gymnasium (kind of like secondary school). The ukranians study Delphi, Turbo-[language] and apparently some russian programming language used in the financial sector there. They say it's because teaching positions are paid low there so anyone who has up to date information on CS/programming actually works in the field and not as a teacher. One told me he asked his professor "nobody uses delphi anymore. Why not teach python" and the professor replied "I don't know python". I also have done some online tutoring/help for people starting C. Some people, from the Philippines or india, also use Turbo C in dosbox. It's just the quality of education over there and old, outdated resources. They get our textbooks translated 20 years later into Russian/Tagalog/Hindi and by then we've moved on passed DOS
&gt; I don't know how subtracting an entire array from a pointer works. That's not what is happening. What is happening is that a pointer is being subtracted from another pointer. Both `cur_age` and `ages` are pointers. The result of subtracting two pointers that both point to elements of the same array is the number of elements in the array between the two pointers, counting one of the endpoints but not the other. So, for example, `&amp;(array[5]) - &amp;(array[2])` evaluates to&amp;nbsp;3, which is 5&amp;nbsp;−&amp;nbsp;2, because there are three elements in the array between `array[2]` and `array[5]`, counting `array[2]` but not `array[5]`.
I think of pointer subtraction as finding the distance between two pointers.
Cool. So, even though ages is set up as an array, just using the word ages is a pointer to the first element in the array? Then my second question(forgive me if i'm wrong i started learning c after java so all of the stuff about memory is a little new to me) is does that mean that the program when it's running is actually subtracting the addresses in memory from each other?
That's pretty much how it works. When necessary, an array will "decay" into a pointer whenever it's needed, like to do pointer arithmetic or when passing the array to a function. When doing the subtraction, you're right that the hardware is effectively subtracting the addresses. But it also has to account for the size of the variables in the array and divide by that number. So, if you have an array of 4-byte integers, it has to divide the result by 4. Or if you have a more complex structure that's 128 bytes, it has to divide by 128. This is all done under the hood, so you don't usually have to think about it, though.
I am teaching myself C and I am a total beginners. K&amp;R is the bible of course but maybe not the best learning tool. I tried a few and settled on "C Programming - a modern approach" I find it pretty good. I also have "learn C the hard way" which is pretty modern but really aimed at windows users, which I am not.
Yes, but you have to be careful—the distance is measured in elements of the array, not in bytes.
&gt; even though ages is set up as an array In C, an argument of a function cannot have array type. So even though it looks like `ages` is declared to have array type, it is actually a *pointer* to the first element of the array. That "decay" from an array to a pointer is done by the compiler automatically.
Yeah I sawed that too, thats why I had to post on reddit. I guess not alotta people are not familiar with it.
It appears to have been published in&amp;nbsp;1990, and it appears not to advertise that it teaches ANSI&amp;nbsp;C, so it probably doesn't. Standard&amp;nbsp;C first appeared in&amp;nbsp;1989 as "ANSI&amp;nbsp;C"; before that, the C&amp;nbsp;language was a variant commonly called "K&amp;amp;R&amp;nbsp;C" that is completely obsolete today. Don't waste your time with a book that teaches old K&amp;amp;R&amp;nbsp;C—that's useless knowledge. Now, to forestall confusion, I need to point out that I am not saying that the *book* called K&amp;amp;R (*The C Programming Language* by Kernighan and Ritchie) is useless. The first edition of K&amp;amp;R describes K&amp;amp;R&amp;nbsp;C, and that edition is indeed useless except for historical curiosity, but the much more widespread second edition teaches ANSI&amp;nbsp;C and is a well written, still useful book.
Despite what you might think, the computer/compiler is not a magical black box. When you declare a variable and assign a value to it, you are essentially asking the compiler to remember that value. It has to store that information somewhere. That somewhere is memory. Since memory (RAM) is essentially an 8GB array, it wouldn't make sense to just throw the number in there. You put it somewhere and note down the address. Thus every bit of information that you need stored, including the ones you declare on the stack as well as the specific lines of code you've written all have a memory addresses. Pointers are an abstraction for storing these memory addresses.
Just because it works sometimes doesn't mean it's correct. C doesn't stop you from writing to memory you are not supposed to write to. Suppose on your machine, a pointer takes up 8 bytes of memory and an int takes up 4. Your struct then requires 20 bytes of memory, but you're telling malloc to only allocate 8. In the environment this works in, it just so happens that the memory you are writing to that you shouldn't be is not being used by anything else, so it happens to work and you are none the wiser. Why don't you try removing the * from the sizeof(struct doublylist *) in the malloc and see if it works in the environment it was failing in before? 
&gt;C++ is an object oriented programming language. Mostly Wrong. &gt;[In C++] Objects are the fundamental building blocks. Wrong. &gt;C++ follows bottom up approach What? &gt;[In C] Variables must be defined at the beginning in the function. Not for 16 years now. &gt;[In C] Programs are divided into modules and functions. What is a "module"? A translation unit? C++ has those, too. C++ doesn't encapsulate the entire program in classes like Java or C#. This doesn't even touch on the minor grammatical differences between the languages, like the different associativities of the ternary operator, or the C features that never made their way into C++, like designated initializers, or all the high-level features of C++ that *aren't* object classes or function overloading, like generic programming or compile-time metaprogramming, or the fact that C++'s type system is actually a *stronger* version of C's, or that C and C++ don't always agree on whether a given construct or behavior is well-defined, undefined, or implementation-defined.
C has operator overloading: You use the same operator in the following: * Adding two chars * Adding two ints * Adding two floats C does not support user-defined operator overloading.
&gt; C++ is a superset of C and contains all the features of C language. No designated initializers in C++.
No variable-length arrays, either.
1983.. so can i link object code from one compiler with another in 2015 already? (maybe i can, i didn't look into it but it bothered me since the beginning, i mean, what's not private in providing a lib and h file?) Also, compilers where a mess from 1983 until a couple of years ago. Exceptions? Not in early compilers. Templates? Not in early compilers. Then when you think that's over you got stl. Honestly, i'm suprised c++ made it so far as it did.
I agree with you on all but the third. C++ allows, but doesn't force, you to work at a low level of abstraction (actually, some of the new features allow you to go *lower* than standard C). It also allows, but doesn't force, you to work at *much* higher levels of abstraction, close to Python even with the modern language features and the Concepts TS (lambdas, first-class functions, duck typing via inference). No introspection, yet, but there's a proposal for that as well...
How can I check that its not teaching this K&amp;R C? 
&gt; In C, an argument of a function cannot have array type. Does that mean that if you wanted to use a function on all the elements of an array, you'd have to set up some sort of for/while loop to call the function for each element instead of modifying the arguments of that function to accept arrays?
&gt;I don't understand how to dynamically change the struct as the amount of memory required by a variable increases. This doesn't make any sense. The amount of memory required by a variable is fixed and cannot change. Structs cannot dynamically change either. Reading between the lines I'm guessing that perhaps what you were actually asked to do was to generate an array of structs, and each value in the file corresponds to one member for one particular struct instance? (e.g. if your file contains 500 cup entries you're meant to make an array of 500 structs). To clarify this it'd help if you can post some example input and the expected output. 
So in your example the bin file would contain 4 bytes of cup, then 4 bytes of spoon, 2 bytes of mat, and so on? And multiple records of that? What does the fact that there are 4 bin files signify - are they just 4 separate data sets? Does your program actually have to read in the text file and make decisions based on that? That is a fairly complicated requirement for an introductory course. I'm hoping that actually you are just supposed to hardcode in your program what the variable types are, your program doesn't have to work unaltered with a different text file. 
No, what it means is that if you think you are passing an array as the argument to a function what you are really doing is passing a pointer to the first element of the array.
&gt; It can but not necessarily, Huh? What else could it contain and how would you tell the difference?
It depends on OS and ISA. Take a look at http://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64/ for an example.
This code is not going to compile. Please show us your actual code.
If you're really crazy, you can use the alloca() function to expand the stack frame at runtime. Please don't do that. It's an awful function that really needs to go away. It's even worse than using sbrk() instead of malloc().
That doesnt even compile, you can only assign strings to arrays at declaration time. And even then you need room for the zero terminator, otherwise you potentially overwrite other data and get garbage. The proper way to copy strings outside that is using `strcpy` and `strcat` or even `memcpy` / `memmove`. If you still are unsure why you need the right size even when assigning strings, try this example below. struct test { char string[3]; char x; }; int main() { struct test testing3 = { .x = '1' , .s = "hello" }; struct test testing2 = { .x = '2' , .s = "hello" }; struct test testing = { .x = '3' , .s = "hello" }; printf("%s %c\n", testing.s, testing.x); printf("%s %c\n", testing2.s, testing.x); printf("%s %c\n", testing3.s, testing.x); } In the example, each declaration overwrites the next (on machines with a downward stack, otherwise reorder them for the same effect). Notice how it only fill **3 chars** and thus leaving off the zero terminator, forming one long string in memory.
Ah that's exactly what I was looking for! Looking back at the exercise it actually recommends to use the strncpy method. Guess it was just an unlucky typo for me since strcpy() was also a valid method. And to clarify, when I'm trying to limit a string to a specific length do I need to account for the NULL terminator in its length?
&gt; And to clarify, when I'm trying to limit a string to a specific length do I need to account for the NULL terminator in its length? That depends on how you use it. In general, it is best to always leave room for the null terminator. You'll need to look at strlcpy's man page to see what it does when it hits the length you specified. HINT: It won't necessarily null terminate the string......
Wow, lots of people missing the question here. OP is asking about stack *frames*, not the stack as a whole. It's mostly determined at compile time. The compiler knows that a stack frame takes up some minimum amount of space (such as storage for old return address, old stack pointer, and old frame pointer); this depends on the CPU and calling convention/ABI in use. Some CPUs have instructions that set up the stack frame automatically, so if the compiler uses those, it's stuck with whatever format the CPU puts it in. Then it pushes onto the stack space for any local variables it needs. In unoptimized code, variables are pushed and popped as they become live or dead, but optimizing compilers usually just tally up how much they'll need, and reserve all of the space once at the beginning of the function. Either way, at any point, the compiler knows exactly how big the stack frame is. Unless you use `alloca()` (or variable-lengths arrays in C99, which have the same effect). Those behave like `malloc()`, allocating an amount of space known only at runtime, but it does it *on the stack*. At that point, the compiler no longer knows how big the stack frame is. Now it's obligated to keep a separate frame pointer and stack pointer, whereas on most architectures it's simpler and easier to use only the stack pointer, since the compiler always knows how big the stack frame is. However, `alloca()` and VLAs are extremely rare. Most of the time, if you assume that the compiler knows the size of a stack frame at compile time, you'd be correct. &gt; is there any way I can determine stack frame size myself like the sizeof operator to determine size of variables Not that I'm aware of. This usually requires deep knowledge of the platform in question. Even switching to a different compiler on the same platform, or changing optimization levels, could potentially change this. I think the general assumption is that if you need to know, you're probably dropping down to assembly anyway. C is a high-level language where you're not supposed to know or care about the size of stack frames.
Good to know. I'm stuck on C89 (because embedded compilers don't always have good C99 support), and I'm told VLAs are considered a misfeature and no longer recommended, so I don't know many details about them.
Read code. Especially the Linux kernel. 
&gt; Why is the plus one needed? Hard to say without context. Show the rest of the code.
I think it gets rid of the space before the city name. Not too robust.
Because the City starts 1 byte after the comma. Remove the +1 and see what happens in his code!
I tested what plus 1 does, and it gets rid of the first character like you suggested. But it seems to remove the first letter, not a blank space, which i dont think should be happening.. Edit: i think you are right. Strlen revealed that when i didnt have plus one, the len was one larger than the word. Now I'm just confused on why the extra whitespace is in the city token in the first place..
Your rule 2 is wrong. `unsigned int` is never demoted to `int`. The result in that case is `unsigned int`.
&gt; The result is an int because 1 is an int literal; foo is converted to an int before the addition. This statement is a bit misleading. `foo` is *promoted* to `int` by virtue of being used in arithmetic. It doesn't matter what the type is of the other operand for this promotion to happen. If the other operand is larger than `int` then the first operand is promoted again, from `int` to the other operand's type.
.
That is a legitimate point. I had literally never considered the matter that way.
There is [21st Century C](http://www.amazon.com/21st-Century-Tips-New-School/dp/1449327141). Seems to have mixed reviews though.
Sorry, that was a typo. You are of course correct.
Can we see the full code? Since strtok can be used multiple times on the same string, its actually quite important to see all the previous calls to it. 
You're right, i just editted my post to show it. Take a look and see if you can explain what I'm not understand right, thanks.
He could have just done something this: sscanf( buf, "[%*s] %f %f %*[^,],%s", &amp;lat, &amp;lon, city );
Yes, you're quite right but I never check my saved posts and I'll probably forget about it. I do however check my comment history sometimes so I'm more likely to see it again.
~~Thats in general bad form when you're accepting user input. You're implicitly expecting the data to be correctly formatted, which is a no-no when processing user input.~~
As far as I can tell everything is correct and you shouldn't need that +1. Are you sure there's only a single space between the lat/lon tuple and City,Town? This call to strtok: lon = atof(strtok(NULL, " ")); //set lon should overwrite the last space between 15.0 and City, but the fact that its seemingly not doing that makes me think that there are actually two spaces in that line and you copied/pasted wrong. If you check out how strtok works, after it has found the beginning of a token, it will search forward until it hits the first byte matching a delimiter, which is then replaces with a NULL. strtok then saves off a pointer to the byte immediately after the NULL that it just inserted. This is the pointer used by strtok to pick up where it left off when you pass in NULL for the first parameter. With that, this call to strtok: ptr = strtok(NULL, ",") + 1; should have strtok's internal saved pointer pointing at the C. In your case, it looks like it's pointing to the space before C, and since in that last call ',' is your only delimiter, the space gets treated as any other character and returned as part of the token. Go double check your input data, or just look at "line" in a debugger before you start plugging it into strtok.
If you're not wanting to keep the old data, call free then calloc. If realloc causes a relocation then it will copy (in linear time) all the old memory content across.
On linux realloc will just [remap pages](http://blog.httrack.com/blog/2014/04/05/a-story-of-realloc-and-laziness/), which is very fast.
Yes you're right, there is two spaces between lon and City. For future reference, how do i know if i should or shouldnt use + 1 for strtok? It seems that if the token i want is a number, then the spaces dont matter since i use atoi or atof. But when the token is a word, and there are two spaces, i should use + 1? 
Unless you're using very clever hash routines rehashing cannot be done in-situ, so you'd have to have a second block of memory. 
It's not really relevant but just because I feel like blabbering about this (spent all day doing it), the memory in question is an array of pointers to linked list elements. The linked list elements are separately allocated and contain the key/value pairs of the hash. The key/value pairs are like struct kv { char * key; void * value; }; and the table in question is something like struct kv ** table My query is about "table" only. It's a standard hash table with buckets for collisions implemented with singly-linked lists. The solution I chose was to use free followed by calloc, but I was wondering if there were any possible advantages to using realloc even if the memory is to be blanked out. 
This was brought up recently on the Austin Group bug tracker: http://austingroupbugs.net/view.php?id=940#c2696 &gt; POSIX additionally guarantees that any pointer object whose representation has all bits set to zero, perhaps by memset() to 0 or by calloc(), will be interpreted as a null pointer. There is a lot of existing Unix code where this has been assumed to be the case, so specifying something contrary would have been bad.
That just means that the integer constant&amp;nbsp;0 represents a null pointer *in source code*. That doesn't mean that a null pointer must be internally represented as all-bits-zero. http://c-faq.com/null/machnon0.html http://c-faq.com/null/macsochange.html http://c-faq.com/null/varieties.html http://c-faq.com/null/confusion4.html http://c-faq.com/null/machexamp.html http://c-faq.com/null/runtime0.html http://c-faq.com/null/accessloc0.html
Your typedef is wrong, it causes `func1` to be declared as *pointer to function* whereas you want `func1` be declared as *function.* This causes *undefined behaviour.* Most likely, the pointer value you observe is the numeric interpretation of the first few bytes of the machine code for `func1`. Change the type definition to typedef void a_function_t(int a, int b); to fix this. Notice: Do not use `_t` as a suffix for your own types. It's reserved by POSIX for system types.
I see. Which then also means that POSIX can't possibly define what NULL is in generated code, since it's defined by the architecture.
Thank you for that useful remark! I've obviously oversecured default mode.
I have a crazy thought on a way to figure the ~~stack~~ frame size. You could call a function recursively and then do some pointer subtraction between a local variable in each frame. The difference is the frame size. This probably triggers undefined behavior, but I think it should work. (Edit: yes, I meant frame size ... typed too fast.)
Firstly, you mean stack *frame* size, not stack size. It's an interesting thought, and it would certainly work in some cases. But no, it's definitely not universal or portable. Functions that call other functions might have a different stack frame size/layout than leaf functions (functions which don't call anyone). On some architectures, leaf functions need not even create a stack frame. Also, I'm pretty sure there are some architectures where the size of stack frames can change, such as if you're using register windows. When you call a function, if you've exceeded the register window, the CPU will automatically dump registers to the stack. Depending on how it does that, I think it's possible that the difference between stack frames would change depending on whether or not it dumped the register window. More to the point, even if your method works, it only tells you the stack frame size *of that particular function*. As soon as you do it on a different function, the result will be different. And the result would also be different if you didn't do the measurement in the first place, since on some architectures that will mean one fewer variable to save stack space for. Basically, the act of measuring it this way is changing the result that you get.
All good points.
Hey thanks and yes it's ok! Haha the internet is awesome
Hey those pieces look awesome! I didn't know UTF had chess characters! Also yeah I need to break down findPiece since I use a lot of its parts in other functions, and right now I'm just rewriting the same stuff over and over and it kinda sucks cause the code is getting bloated. Edit: I just added those chess pieces! Now if you type "pieces" you get those, and if you type "letters" it reverts back!
See ISO 9899:2011§6.2.7¶2: &gt; 2 All declarations that refer to the same object or function shall have compatible type; otherwise, the behavior is undefined. The types *function returning type* and *pointer to function returning type* are not compatible, thus declaring `func1` as type *pointer to function returning type* and declaring it (in the definition) as *function returning type* is undefined behaviour as both declarations refer to the same object but have incompatible types.
Thanks! That's exactly what I wanted to know.
I understood what you wanted my point was that hashtables usually map from hashes to buckets based on the size of the table. Now when you have, say, buckets 1 and 42 set in table and you resize it, you'd have to recalculate the bucket from the hash wrt the new size of `table`. What do you do if bucket 1 now hashes to 42?
If you don't just dive right at it but instead pour yourself some tea, muse about it, and then dive in it wouldn't be so bad. You'd probably be fine. The way you did this suggests to me you aren't afraid to make mistakes, so it probably would be a fun exercize for you.
One little style comment: &gt; if (chb[i+1][j-1].occ == true) Comparing an expression to true is not quite C-ism. If we're going to compare 'X' to true for readability, we might as well check if the comparison itself evaluates to true: &gt; if ((x == true) == true) This looks bad, doesn't it? Generally, &gt; if (x) is well understood and used in C.
That's how I did it initially, but sadly stdbool.h defines true as 0 and false as 1 so this if (x == true) becomes this if (!x) which doesn't look as good. I tried defining my own true and falses but thought, that other C programmers might get confused if my style clashed with a C header. edit: This is completely false don't read this 
Thank you! In the beginning I had problems because the loop reads the chess board array from the left so each time I did a move that both pieces could do, it only moved the left one. So I created a conflict situation, so if you tried Rd3 on the above example, the game would ask you which rook to move the left or right rook. Or if the rooks were above and below with each other, it would ask you which rook to move, the rook above or the rook below. This workaround created another problem too because if the rooks were in the same x axis or y axis but were seperated with other pieces it would still ask, even if the move was obvious. So in my main.c file I called the piecesOverlap function a couple of times to avoid using a conflict variable if such a situation occured. Try running the game if you're on Linux! Right now the check and checkmate situations are kinda incomplete though, so temporarily the game ends when you capture directly the King.
Wow I'm sorry, I was completely wrong. I don't know how I thought the definitions were reversed, when I started programming the game I had some problems so I thought to remove smart things like simple ifs, but now that I know that I'll edit the code to make it more compact.
I don't know POSIX forwards and backwards, but let me take a stab at this. &gt; For one thing, onto the "privileges" required to change a thread's priority, is this only for a main thread, or even for threads spawned? What kind of privileges, are needed? I'm assuming super user? It needs "sufficient" privileges. What this means depends on the system. Unix-derived systems generally have a superuser, and that is certainly sufficient, but maybe ordinary users also have sufficient permission. Other systems may be more fine-grained. &gt; Next, are there benefits to increasing the priority of some threads? IIRC, a thread with higher priority gets a longer time-slice from the scheduler, correct? Does this inherently yield greater performance from the higher priority thread, and is it worth it in the long run, even if it's only temporary? Increasing the priority of a thread means that thread is more "important". What the actual result is depends on the system's scheduler. Ideally, yes, higher-priority threads will get put on the CPU sooner, and/or more frequently, and/or for longer, than lower-priority threads. But that's only an average over time. If your threads do 1 microsecond of work and then exit, you'll never notice the difference because it doesn't have time to produce an effect. If your threads block on I/O, then a lower-priority thread might finish first because its I/O happened to complete first. &gt; The reasoning I'm asking is because, for the educational wealth experimenting can offer, I'm improving my thread pool to make better use of it's prioritized tasking. I was thinking of increasing the thread's priority depending on the priority of the task, then changing it back to normal once it finished it's task. So, again, this is all system dependent. Linux has an adaptive scheduler that tries to give a priority "boost" to I/O-bound threads. The assumption is that I/O-bound threads generally want to wait on some I/O, do a small amount of work, and then start another I/O request. So their throughput is best if they are higher-priority, because their I/O requests will happen more frequently, decreasing the total time. Whereas CPU-bound tasks want to stay on the CPU for long periods of time to keep their caches hot, but a few hundred milliseconds here and there won't make much difference to how long until the thread completes. The Unix/Linux "nice" values are simply a hint for the scheduler, but the priority boost/penalty for being I/O-bound or CPU-bound stacks on top of this. And tasks still have finite timeslices, so it's possible for a high-priority task to exhaust its timeslice and have to wait for lower-priority tasks to run for a while before it gets a new timeslice. (Note, the exact details of this may have changed. The last time I studied it closely was early Linux 2.6.) Now, if you have real-time priority support enabled, then those strictly follow priority order. The scheduler *will* choose the highest-priority realtime task that's runnable. You can use that to provide stronger guarantees of when tasks will be run, but note that a high-priority task could still block on I/O and cause a lower-priority task to run instead. If your goal is to make sure that certain "things to do" happen before others, or with higher priority, this has as much to do with how you assign jobs across your threads as it does with the threads priority. It's entirely possible that you just need proper locking and synchronization between threads, and that will guarantee results that you could only approximate using thread priorities. &gt; I was wondering if this was a good idea, because I can see some drawbacks, being a higher priority thread would be of a higher priority than the main thread (I.E, the main thread would get less of a time-slice. I'd imagine it'd be very bad since worker threads are meant to just run in the background, overshadow the main thread). Depends on what all of your threads are doing. Sometimes that's okay, other times it's not. &gt; Then again, I don't know much about how threads are scheduled, but I am interested in learning. Hence, brings my next question... &gt; There aren't many examples on how to change a pthread's priority, so can anyone give me a nice and detailed example of how to use them? http://man7.org/linux/man-pages/man3/pthread_setschedparam.3.html http://stackoverflow.com/questions/3649281/how-to-increase-thread-priority-in-pthreads
Question, if you use an explicit namespace in front of a data type, would it still be "allowable" to use the _t suffix? Honestly, NS_Data_t *type looks better than Data *type; Moreover, since adding a namespace helps with identifying which module it belongs to, it also nearly eliminates the chance of it being already used, either in POSIX (as it seems very much against how POSIX does things, seeing their data types are mainly lowercase without a namespace). In other words, data_t has a much higher chance to be taken than NS_Data_t. Would the extremely low (near impossible) chance of it being taken justify the use of the suffix?
The entire namespace with the `_t` suffix has been claimed by POSIX. Notice that for new APIs, POSIX has been using prefixes to denote the API a symbol belongs to while the `_t` suffix denotes types regardless of name space. I suggest you to avoid using typedefs if possible. Writing struct NS_Data is better than writing NS_Data_t in my opinion.
&gt; If that's the case, should I just test once to see if it has enough permission and if it does not, don't do it again? Should I just request root just to get the possibility of it not happening out of the way? Then again, requiring root for a simple thread pool sounds very excessive. \*shrug\* I dunno. If it's absolutely *essential* that you be able to control thread priorities, then yeah, maybe it makes sense to do a check once when the program starts, and complain and exit if it doesn't have sufficient permissions. But maybe it's not so essential, and it's okay to have degraded performance. (Or maybe it won't even be degraded, if someone's running on a sufficiently fast computer 10 years in the future.) In which case just have some error logging if/when the request to change thread priorities fails, and let the user decide if they care to fix it. &gt; From what I've read about "nice" values, it only applies to the process itself, not for each individual thread, at least for POSIX, yet for Linux threads, it's possible to change it for individual threads (?), although I'm probably mistaken. Definitions get kind of confusing here. Linux doesn't have "threads"; every thread in Linux is also a process. This is unlike Solaris and other Unices that do distinguish between processes and threads. But, threads in Linux do have a parent process, and of course they share the same virtual address space. Anyway, since each thread is a process, I believe you can set niceness values on a per-thread basis. And I know for sure that `pthread_setschedparam()` works on a per-thread basis on Linux, since the software I work on uses it. &gt; I'm using Cygwin Ah, well... good luck. Since you're running on Windows, it's actually the Windows scheduler and APIs that are controlling your threads and processes. So somewhere in Cygwin's implementation of `pthread_setschedparam()`, it's calling native Windows APIs to change thread priorities. You'll be using a mapping of Windows' thread priority capabilities onto something that matches what `pthread_setschedparam` allows.
This is usually solved by specifying the source rank/file whenever it is ambiguous. Rad3 or Rhd3 in this case (see [Algebraic notation (chess)#Disambiguating_moves](https://en.wikipedia.org/wiki/Algebraic_notation_%28chess%29#Disambiguating_moves)). Btw, I noticed that you seem to have your board layout/coordinates mixed up? The a1 square should always be lower left corner from white's perspective, h8 is lower left from black's perspective.
&gt;n Windows it doesn't look the same due to the bad support of cmd with Unicode characters. The default fonts do not include the chess piece glyphs. However if you install [DejaVu Sans Mono](http://dejavu-fonts.org/wiki/index.php?title=Download) then it works.
Hui... this is going to get hard. I recommend you to find a Unix greybeard (I can try to give you some names if you want) and squeeze that knowledge out of him. You could also try to install very old Unices and find out how they react to your code. In general, C compilers had quite large differences in feature sets, standard library and semantics. It's nearly impossible to understand some workarounds found in code written for such compilers today.
I was hoping that I wouldn't have to do that… Well, hopefully Mr. Kernighan's house doesn't have an alarm and he will trust me and my good intentions (I mean, he's Canadian, after all). Jokes aside, can I install old Unices natively in my computer? (With GRUB or something. I don't want to have only a pre-1990 Unix in my computer!) Won't they broke in a rather recent computer? I've tried emulators like VirtualBox, but only a half of the images I've tried worked at all, and I don't know how to send files to them.
&gt; I understood what you wanted my point was that hashtables usually map from hashes to buckets based on the size of the table. Since "table" is zeroed completely initially, it's obvious that the key-value pairs have to be rehashed into new buckets. &gt; Now when you have, say, buckets 1 and 42 set in table and you resize it, you'd have to recalculate the bucket from the hash wrt the new size of table. What do you do if bucket 1 now hashes to 42? I rehash them into new locations. I promise you I have not edited my question since I wrote it, so if you go back and look you'll see that I said from the get-go that I want "table" to contain all zeros. 
Thanks, but I'm afraid I already have it… I found it in “a local library” (*wink*).
Gcc has flags --traditional and --traditional-cpp, although I have never tried them. https://gcc.gnu.org/onlinedocs/gcc/C-Dialect-Options.html 
There's a PDP-7 emulator somewhere around, and you can install one of the old unices on it.
ANSI C includes the condition that the implementation may only use the first 6 characters of external identifiers. Most implementations exceed that limit but it's not compulsory. 
Actually I tried installing a different font that was supposed to work on cmd, but two things: If the player has to install a new font and go to environment variables to set it as default, and then restart the computer just to see it a bit better, then it kinda ruins the fun. And the characters I had difficulty printing weren't the chess piece characters, but the box drawing characters for the chess board. I know about the old IBM codes, but if you guys could tell me how to make https://en.wikipedia.org/wiki/Box-drawing_character work on Windows, it'll be awesome!
They are in Unicode as that page shows - have you checked to see if any of the console fonts include that? In command prompt you can set the font by using the Properties menu of that window, you don't have to go into Environment Variables. It might be difficult to programmatically set though, they really want you to use the GUI.
I'm a little late to the thread -- be aware that if City contains spaces (New York City) then using `strtok( NULL, ", " )` is going to chop the City off at the first space encountered. Probably why the code switched to using just the comma as a delimiter. 
Not an answer, but it might be interesting to know that VIM is entirely non-ANSI C.
I assumed they probably only work in C# or some other Windows specific (for the most part) language, because I looked online for a while and there are workarounds for C# but not C. Also I'm very limited by my knowledge and experience, since I can't really use Unicode; it's just really easy to just print the escape sequences with C in Linux terminals, without having to use stuff like locale.h or wchar_t that I don't understand. I tried using wchars in Windows but I always got the same results, even if I changed the font multiple times (Lucida from properties, or others I downloaded and used through environment variables). Also the MS-dos characters don't work which is very weird since MS-dos was developed by the same company that made windows.
No, it's still wrong. The coordinates are supposed to be absolute, ie. a1 represents the same square no matter whose perspective you view the board from. This means that when you view the board from the black perspective (like in this case), the leftmost file should be h and the rightmost should be a. They're reversed.
What do you mean by "MS-DOS characters" ? If you are talking about the box edging, then read up on "code pages". &gt;I tried using wchars in Windows but I always got the same results, [See here](http://stackoverflow.com/a/31999541/1505939) for code samples.
&gt; change the text of any window i click on? Do you mean "window" in the Win32 API sense, or "window" in the typical user sense? (aka top-level window) "[SetWindowText cannot change the text of a control in another application. [...] To set the text of a control in another process, send the WM_SETTEXT message directly instead of calling SetWindowText.](https://msdn.microsoft.com/en-us/library/windows/desktop/ms633546(v=vs.85\).aspx)" Because [it's complicated](http://blogs.msdn.com/b/oldnewthing/archive/2003/08/21/54675.aspx). &gt; WM_MOUSEMOVE: doesnt work as i expected it too. "[If the mouse is not captured, the message is posted to the window that contains the cursor.](https://msdn.microsoft.com/en-us/library/windows/desktop/ms645616(v=vs.85\).aspx)" &gt; i read that you need to SetCapture() outside the look and then call WM_MOUSEMOVE:. That will get you move events outside your window, but not clicks: "[Only the foreground window can capture the mouse. [...], even if the foreground window has captured the mouse, the user can still click another window, bringing it to the foreground.](https://msdn.microsoft.com/en-us/library/windows/desktop/ms646262(v=vs.85\).aspx)" Now, you *can* get clicks destined for other applications by using raw input or a mouse hook.
I would have gone with algebraic notation initially but it probably would have been a bit harder for chess beginners (such as me for example). Besides I think the only feature that really makes this game a bit different than the countless other chess games is the fact that it is able to find your chess piece for you. Even though it's still not much but what can you do lol :P Also the simple way of moving the pieces for a chess console game makes it easier and faster to debug.
I'm not doing it for a practical purpose (the fact that the program I'm working in is a C implementation of TECO proves that I don't really expect anyone else to need it anyway), but I'm interested in knowing what 70s and 80s programmers “felt” by working in a difficult environment.
Thanks! I read the GCC manual and I don't know how I missed that. I guess I'll have to try it. Hopefully it's pre-ANSI enough.
Wow... Thank you so much! There's even a LISP to run on PDP-1! I've found the jackpot! I'll try them as soon as I can.
It's interesting to know that such a big (*huge* if you compare it with anything I've ever worked on) codebase is written in pre-ANSI C. If I ever run into a problem, I can see how they solved it.
Not *strictly conforming* is the term, but it's basically impossible to write a strictly conforming program that does anything. 
The rest may be ignored for linking (causing linking to go wrong)
Maybe you can ask the [PCC](http://pcc.ludd.ltu.se/) people if they have an old version.
I told you I tried this solution already, changing the codepage and all both from the console and from the code, but the box characters still look like a mess (I don't know about the chess pieces haven't tried those yet), if you don't believe me try it for yourself. 
I did try for myself and it worked .
Might want to look into using a low level mouse hook: https://msdn.microsoft.com/en-us/library/windows/desktop/ms644986%28v=vs.85%29.aspx
&gt; most OS's change their threading algorithms frequently as better ones (and different types of hardware) get invented I was about to say "only for some definitions of 'frequently'," but actually, I guess you're right. Linux went through 4 schedulers in about 8 years: * 2.2 (roughly 1999) — First SMP scheduler, simple circular queue * 2.4 (roughly 2001) — [O(n) scheduler](https://en.wikipedia.org/wiki/O(n\)_scheduler) * 2.6 (roughly 2003) — [O(1) scheduler](https://en.wikipedia.org/wiki/O(1\)_scheduler) * 2.6.23 (2007) — [CFS](https://en.wikipedia.org/wiki/Completely_Fair_Scheduler) (still in use today) And that's just the broad scheduler algorithms. I'm sure along the way there was tuning for various systems, optimizations for HyperThreading, etc. &gt; If you want your threads to play nicely with each other, and play nicely with the main process, and play nicely with the OS, and play nicely with all other processes, you will **need** to add a `Sleep(0);` to every loop that is running. Use `Sleep(0);` and **not** thread-priorities to balance your threads out on Windows **first**. That *greatly* depends on what you're implementing. Maybe for some workloads that yields acceptable behavior, but there are other situations in which you will never get the desired performance that way. I would say step one when doing any kind of multi-threading or multi-processing is: get your synchronization working. If threads are sharing data or cooperating in any way, then you need to use proper threading primitives (mutexes, semaphores, barriers, conditions, etc.) and techniques (e.g., job queues). For some things, using threading primitives and techniques correctly is nearly the *only* thing you need to do to get satisfactory performance. If you're using a producer-consumer workflow, then the only real tuning to do is adjusting the number of producers and consumers (if either is adjustable). Thread priorities won't really affect anything, and neither will yielding. For other workloads, thread priorities are a requirement. I deal with audio/video stuff, so it's essential that audio threads be real-time and high priority so that they can transmit outgoing data to the network ASAP, and keep tiny hardware buffers full. That's a job best left to the scheduler; littering sleeps or yields in the rest of the code is not the right solution.
The later standards lengthened the limit, thankfully.
Well, for starters, you should use the [right function](http://www.mpfr.org/mpfr-current/mpfr.html#Comparison-Functions) for comparison instead of &lt;. Then realize that your while loop does the same subtraction of the same values over and over again always setting anglea to the same result.
Maybe you should look at what "mpfr_sub" returns. Hint: It can't modify the value passed in via 'anglea', unless that's a pointer, and you haven't provided any info as to what it is.
As an afterthought, is mpfr_sub defined somehwere else? I don't see it.
that's why they say C is for people who know what they're doing :) there's no hand-holding in C, you need to take care of your shit, nothing to do with you, just saying
Well, I'm still using C almost exclusively well over 30 years with zero regrets. At the time K&amp;R was king it was the best thing ever for working with small devices -- so nightmare only retrospectively. For us it basically took some of the tedium away from assembly while not getting in the way. Having to take care of your own is why I still love working with it actually. Very few dependencies. Every problem I have is one of my own creation. 
It's a function from the [MPFR](http://www.mpfr.org/) arbitrary-precision floating point library.
What you're doing is essentially the same as this: while (a &gt; 0) a = 2 - 1; And, again, `mpfr_t` values are compared with functions. They're not primitive types, `&lt;` and `&gt;` and `==` won't work the way you expect. I already gave you the link to the documentation for the proper comparison functions.
Thank you I am sorry for being rude, can you modify an mpfr pointer or do you have to clear the contents of the variable and then insert the new numbers. So like anglea needs to be redefined every time in the loop, used then cleared, then redefined. I figure I can change the value of a variable with mpfr_set (mpfr_t rop, mpfr_t op, mpfr_rnd_t rnd) but using a comparison will return a positive value but I have no way of accessing or using that positive value or can I?
Ancient C compilers had a cool feature that modern C compilers don't have: `goto` pointers, not unlike GCC's "labelled goto" but also support crossing function boundaries and pointer manipulation. [example](https://github.com/geocar/ed-v6/blob/master/ed.c.orig#L28). They also had some weird bits: * `+=` was spelled `=+` which means that `x =+ y` parsed different than `x= +y`. [example](https://github.com/mrquincle/ancient-c-compilers/blob/master/primeval-c/prestruct/c00.c#L81) * `int x = 69` was written `int x 69` and of course, types were optional (default to int). [example 1](https://github.com/mrquincle/ancient-c-compilers/blob/master/primeval-c/last1120c/c00.c) and [example 2](https://github.com/mrquincle/ancient-c-compilers/blob/master/unix_v1/src/cmd/goto.c#L1). You can find lots of examples if you consider specific programs and look for their source code. Have you tried using an ancient compiler?
Read the documentation.
Because youre just declaring a pointer, you have to allocate memory for it to point to (e.g. stack allocation when using [ ], or malloc())
&gt; I have been trying to convert arrays in my program to pointers This goal doesn't really make sense. Arrays and pointers are two different things, and they serve two different purposes. You can't "convert arrays to pointers." &gt; int *i; &gt; i = {1,2,3,4,5}; This doesn't make sense, because `i` is a pointer-to-`int`. Therefore, it must point to a single `int`. If you want it to point to the first element of an array-of-`int`, then you need to make the array-of-`int` first. &gt; or: &gt; &gt; i[0] = 1; This also doesn't make sense unless you have previously initialized `i` to point somewhere meaningful. The expression `i[0]` is equivalent to `*(i+0)`, which is equivalent to `*i`, and if you haven't initialized the pointer&amp;nbsp;`i` to point to somewhere meaningful then dereferencing it with the expression&amp;nbsp;`*i` is meaningless and yields undefined behavior.
A pointer holds data: namely, it holds an address of another piece of data. So, "initializing a pointer" would be storing an address in the pointer. You can initialize pointers. For example int* a = NULL; // a points to the null address, 0 int b = 10; int* c = &amp;b; // c points to b It wouldn't make sense to initialize a pointer to be some data, like `i = {1,2,3,4,5};` because points don't store that kind of data; the kind of data they store is an address to that kind of data.
&gt; You can't "convert arrays to pointers." Except by using them in an expression other than as operand of `&amp;` or `sizeof` ;) &gt; int *i; &gt; i = {1,2,3,4,5}; gcc has an extension to ignore excess initializers, and also an extension to not requre a cast for assigning integers to pointers, so this ends up creating a pointer to address 1. 
You could write: int *i; i = (int []){1, 2, 3, 4, 5}; which creates an unnamed mutable array literal and points `i` at it. However this is worse than just using an array in the first place. Can you explain why you are trying to get rid of your arrays? 
Make another thread about how to implement hash buckets. I responded with all the patience I could muster trying to clear up the above misunderstanding. Having to deal with another misunderstanding someone's made of the simplified explanation I've given is really where my patience ends. 
True, I was thinking of `int *i = {1,2,3,4,5};` . Since OP reported getting "lots of warnings" but still getting an executable, I assume he actually did do that (or something).
The problem you're going to run into is that at least some of these Events will need to be created by code you write. The kernel will let you know (wake your process up from sleep) when you get activity on an fd, or get a signal. But beyond that... *you* are going to have to write the code that watches for things happening and then creates this "Event" structure and delivers it off to the right place. Offhand, the most obvious way I can think of to do this is to use pipes. See http://stackoverflow.com/questions/2533284/are-posix-pipes-lightweight . Also, socketpair()s are POSIX. Also, "named pipes" or "fifo"s may be useful. There's a trillion little details in doing this kind of event-based programming. And most of them can kill you - for reasons both gross and subtle. It's probably worthwhile to look at how people have done it before. I googled for "event libraries posix" and pretty much everything on the first page of hits looked good. &gt; If I just have one thread processing said event, then events can't be processed in an asynchronous manner; I.E an event must be processed before it continues to process the next event. Making me think I may be going about this the wrong way. Back in the stone ages, I wrote a multi-threaded webserver in Java. I decided to use a multi-threading strategy I called "Fire and Forget". Basically, your main loops exists purely to grab the next event off the event queue, and hand of off to a thread. Then the thread does its own thing until it finishes, with no further input from the main thread. You fire the event off to the thread, and then you forget about it. You trust the thread to do whatever needs to be done, for however long it takes, and then go to sleep when it's done. Thus "Fire and Forget". When there are no events, both the main process and the threads are sleeping, and everything is cool. This approach worked well for a simple, "just send the HTML file" toy webserver. It completely avoided any possibility of threads interacting with each other, and thus any problems with mutual exclusion, concurrency, etc. But this approach might be too limiting in a more complicated application. I mention it only so that you can think it over, and decide if this kind of strategy might work for you. If so, it will save you a LOT of hassle and pain.
Since when did C get mutable array literals?
No, this is a mutable object (i.e. you are allowed to change it)
Think of pointers as an integer representing an address (not always the case, but 99.99999% of the time it is). Arrays are a collection of actual *objects* (in the C sense, not the Java sense) that have a static size. The reason you can initialize an array like that is because it's understood to be a collection of values, which can be put on the stack and cleaned up as usual. You *can't* initialize a pointer like that because a pointer is a different concept entirely. As a side note, you might be confused because of the array subscripting syntax (arr[index]). It works for both pointers and arrays because arrays are more or less accessed as if they are pointers to the first element of the underlying collection. For pointers, it's equivalent to `*(pointer + index)`- the value at an address plus an offset. If you want a dynamically sized array, what you can do is use a function called [`malloc`](http://man7.org/linux/man-pages/man3/malloc.3.html), which takes a size in bytes and returns a pointer to dynamically allocated memory. For an array of some type `T`, with size `s`, you would initialize a dynamic array like T* arr = (T*) malloc(sizeof(*arr) * s); From there, you can initialize it by initializing elements from `arr[0]` to `arr[s-1]`. Just be sure to call `free(arr);` once you're done with the array, or else you're wasting memory (which will slow everything down eventually, or even cause a crash). 
This is the correct answer. If you want to create a file with specific permissions, use the three argument version of open (check `man 2 open`). To change the mode of an existing file, there's no need for a `system` call. Check `man 2 chmod`.
I mean that files created by a setuid program will have the executable's user/group as the file's user/group, and so on. This is actually a problem in Windows where elevation can occur during the program run; a file created after elevation will have Administrator ownership, so if the program is run again later without elevation then that file can't be written.
it is actually, so I have to write everything by hand :/ but thank you for your reply!
Also Google Chrome and Gmail. Google calendar, Google Music. He previously used openSUSE. Ubuntu got kicked out really fast.
I think the main problem here is not C, but the HTTP specs :)
&gt; If so, how do I read a 'generic' data in C? I tried using fopen with "rb" but it seems that option "b" doesn't work on POSIX compliant machine. POSIX doesn't care about the "b" options, because it doesn't treat binary files differently from text files. (Unlike Windows, which does end-of-line conversion.) Although my man pages say the "b" option is simply ignored. &gt; would it be right to say that a web browser cannot access a file directly and the server must write the bytes of data through connected socket in order to make it available to the browser? Yes. Get your server working with text files first. (Either \*.txt files, or plain HTML files.) It's easy to see what's happening with those. Make sure you test large files (say, up to 500KB). Then try to get an image. Just put the URL of the image into your browser (like `http://127.0.0.1:8080/test_image1.jpg`). It should issue a single GET request, download the contents of the image, and display it. The server *shouldn't* have to do anything different. You shouldn't even have to open the file differently; the web server can happily open and serve all files in binary mode, including text files. If it's not working, debug it. Put in some extra logging on the server. Use Wireshark to capture the network traffic, and look at what the client and server are actually putting on the network.
I could listen to Brian talk about the time around when K&amp;R was written all day. Great stuff!
Your post got caught in our spam filter. I manually unblocked it just now. I'm sorry for the delay.
Do you mind posting a video of the talk (if one exists)? I find it interesting that Kernighan would write code that requires extra effort to read considering he wrote [two](http://amzn.com/0070342075) different [books](http://amzn.com/020161586X) focusing on writing code in a style which is easy to understand.
I've always viewed type-checking as a form of training-wheels for beginner software developers. C is a language designed for programming hardware and things that directly interact with hardware (like an OS, or bus driver). These are not things for beginners to do! People use void pointers because they are under the assumption you know what you are doing, why you are doing it, and you do not need your hand held when doing it. Sure type-checking *could* find an accidental error, but good coders do not make those accidents, ever, so it's just a pointless exercise that wastes time and causes code-bloat. Also remember, most C developers back in the day started out as assemblers and moved onto C (like myself), so we were already used to a type-less environment (though assembly can have type-checking if the assembler enforces it, like MASM!).
Thank you, this explains a lot. If you don't mind my asking what tripped the filter? I'd prefer to avoid any future mixups.
&gt; When a pointer is declared such as char *some_pointer does C set aside an address for the data even if you don't explicitly do an assignment such as some_pointer = &amp;variable? No. int main () { char * x; * x = '\0'; return 0; } $ cc bad.c $ ./a.out Segmentation fault (core dumped) 
&gt; In other words can in de reference a pointer to store a piece of data without explicitly assigning it an an address. If you don't initialize a pointer, it's said to be uninitialized. The value of an uninitialized pointer may not be used in any way except to assign to it, i.e. to make it point to something valid. It cannot be dereferenced (`*ptr`), read (`ptr + 1` or `if(ptr)`), incremented (`++ptr`), decremented (`--ptr`), etc. (This isn't specific to pointers. An uninitialized `int` may not be used either.) &gt; I have seem some code examples where a pointer is used but there seem to be no explicitly address assignment before some data is stored using the pointer. You should show us those examples then, and we can explain what's going on. 
No worries; thank you all the same.
The Message loop is for events that only occurs inside your window or are related to your window. You can: char buf[33]; POINT cp; GetCursorPos(&amp;cp); //To retrieve cursor position, related to the screen HWND hWnd = GetForegroundWindow(); //Get a handle to the top-most window ScreenToClient(hWnd, &amp;cp); //Converts the cursor position from screen to the specified window sprintf(buf, "X:%ld, Y:%ld", cp.x, cp.y); //Put the cursor coordinates into a char buffer SendMessage(hWnd, WM_SETTEXT, 0, (LPARAM)buf); //Send a message to the other window to change the title If you want to capture other cursor events in other window you can use low level mouse hook (SetWindowsHookEx(WH_MOUSE_LL)) to capture them. 
What do you suggest as a better alternative? If you're going to be a C programmer, you have to understand strings, and you have to understand memory and pointers.
I had suspicions after your first comment, but this one assured me; A+ troll, would read again.
I have programmed satellite operating systems that are orbiting Earth as we speak. When I was in my teens I was hacking South Korean corps and calling them up on the phone to discuss their security issues. By my early 20's the largest American/Korean corps were contracting me out security work. I wrote the world's first complete DX9 profiler &amp; debugger that was used by at least 1 high level game design studio that I know of. I was the democratically elected president of a popular hacking scene around the year 2000. And this is just the shit I can remember after many years of pwning as a coder.
That's great, I'm happy you've had an allegedly successful career programming, but my claim that you were trolling was less based on a doubt of your credentials and more based on the fact that you completely disregarded my question in favor of spouting hate for anyone who doesn't program in your particular style, to your particular ends. I'm sure that when writing operating systems for satellites you have fairly specific goals for specific users who are well trained and informed, who probably don't need to worry about implementing your unsafe code. Unfortunately, not everyone is white-hatting for Korean corporations or writing the world's first complete DX9 profiler/debugger; some of us are writing libraries, compilers, and interpreters for people who don't want to have to know all the gotchas of low level languages like C or assembly in order to efficiently crunch some data or make a game. Not everyone can be as amazing a programmer as you claim to be, so please don't go around acting like everyone should be. Unrelated word of advice: when someone calls you a troll, whipping out the measuring tape for dick comparison by way of listing all the impressive shit you've done usually doesn't make you look like any less of a troll, especially when your CV so extensive as to seem unreal.
https://github.com/kojiba/RayLanguage You can see RTCPHandler, and rebuilt it to your needs. It currently used for tcp handling. Lib fully uses threads from POSIX on mac/linux. 
You can use int *i = &amp;((int[]){1,2,3}); And it will be pointer for stack array.
I used to use it to read and process many gigabytes worth of seismic data.
Sounds like a lot of labor. Do they still use C? Would you recommend C for big data analysis?
 LRESULT CALLBACK LowLevelMouseProc(__in int nCode, __in WPARAM wParam, __in LPARAM lParam){ MSLLHOOKSTRUCT* p = (MSLLHOOKSTRUCT*)lParam; HWND hWnd = GetForegroundWindow(); //Get a handle to the top-most window ScreenToClient(WINHANDLE, &amp;p-&gt;pt); //Converts the cursor position from screen to the specified window char buf[33]; switch (wParam){ case WM_MOUSEMOVE: snprintf(buf, sizeof(buf) - 1, "X:%ld, Y:%ld", cp.x, cp.y); //Put the cursor coordinates into a char buffer SendMessage(hWnd, WM_SETTEXT, 0, (LPARAM)buf); //Send a message to the other window to change the title break; case WM_LBUTTONDOWN: break; case WM_LBUTTONUP: break; case WM_RBUTTONDOWN: break; case WM_RBUTTONUP: break; case WM_MBUTTONDOWN: break; case WM_MBUTTONUP: break; case WM_XBUTTONDOWN: switch(GET_XBUTTON_WPARAM (p-&gt;mouseData)){ case XBUTTON1: // X Button 1 Down break; case XBUTTON2: // X Button 2 Down break; } break; case WM_XBUTTONUP: switch(GET_XBUTTON_WPARAM (p-&gt;mouseData)){ case XBUTTON1: // X Button 1 Up break; case XBUTTON2: // X Button 2 Up break; } break; case WM_MOUSEWHEEL: if((short)HIWORD(p-&gt;mouseData) &gt; 0){ //Scroll Wheel Up }else{ //Scroll Wheel Down } break; } return CallNextHookEx(0,nCode,wParam,lParam); } ... HHOOK Mouse_Hook= SetWindowsHookEx(WH_MOUSE_LL, &amp;LowLevelMouseProc, GetModuleHandle(0), 0); //When you want to hook the mouse ... if(Mouse_Hook != NULL){ UnhookWindowsHookEx(Mouse_Hook); //When you no longer need to hook the mouse } 
We use C to process radar data and output roughly 512kbps. We have c/c++ applications to record and analyze data. We also have custom Linux drivers. A lot of the stuff is not ANSI C. The C++ code usually involves Qt.
Something *almost identical* was posted about [a week ago](https://www.reddit.com/r/C_Programming/comments/3gmeyn/difference_between_c_and_c_c_vs_c/). There's obviously some copying from one or the other ... but they're not identical. Very strange. (Oh, and the list itself ranges from absolutely incorrect to very misleading.)
 scanf("%i", baseTen); Should be: scanf("%i", &amp;baseTen); However ... I'm not sure what you're trying to do with `convertToBaseTwo`. You need to rethink what you're doing there.
Ya i might have to start over there..
If I could recommend one thing, it'd be better documentation for your code. Every line doesn't need a comment, but do explain why your code segment is doing what it's doing. Most people that know how to write in C should be able to see what the code is actually doing by reading it. Far more valuable are comments on why a piece of code is doing what it's doing. If you have a hacky or ugly segment of code, a bit of explanation on how is also nice. Bad example: /* Adding up variables X and Y and printing the result */ printf(x + y); Better example: /* Show the user how many total pieces of fruit are available - apples x and bananas y */ printf(x + y); Disclaimer - still learning C, above code in examples probably not correct. 
Yeah, I see lots wrong. To start, you're not initializing `i` or `num`. You never actually use `baseTen`. You never return anything from the function at all. But more importantly, there's a huge conceptual problem here. Variables don't have a base. They simply hold numbers. (Now, it happens that internally they use base 2, but just pretend they don't for a minute.) So, right off the bat, `int convertToBaseTwo(int baseTen)` doesn't make sense, regardless of the code you put inside. What you really want to do here is *print out the value in base two*, not convert the value. You need to be putting the 1 or 0 in a string or directly putting it out for the user. Trying to put it in an `int` variable just doesn't make sense.
Try compiling with -Werror -Wall
I think he's abusing void * and C shouldn't be written like that.
I do not understand how your program is supposed to work. Could you elaborate?
You still have a problem with the scanf line - you should not put a space between the ampersand and the variable name. I'm not sure of your logic in the convertToBaseTwo function. You have your integer variable i, which you initialise to zero. As the variable i will always start as zero because you have set it that way; I think your while loop will look at i, see it is zero and not bother with the rest of the commands in loop, ever. If you want the commands inside the loop to run at least once try a "do while" loop structure. Further, this function does not return a value - you have int convertToBaseTwo... The int before the function name means the function should return an integer. I assume this should be the computed value that you want to print. 
How would you recommend one use void pointers in C?
Thanks for your reply. I'm working under a NDA. I'm using the print function to debug. And when I print out Variable One I get "0." Variable One and Variable Two can be any two numbers. What I'm hoping to do is compare x and y in program A using variables from program B. I don't need d and c to be separate variables. I was only using them to define the function results in the program before exporting out. So the main goal is to simply have the if statement in program A check for (x &gt; y) and "if else" to check (x &lt; y). And also to get the x and y numbers from the start loop of program B. That's all. Struggling to do this simple thing! 
Add four spaces before each line. You're returning zero at the end of that start function. Why is it called start? Why don't you just put that function in program A and call it from the main function?
I looked at something like this fair recently too and came to the conclusion that it was easier to use the decimal number to build a string up of `1` and `0`s then use that as the 'binary' value. As /u/boredcircuits said, the variable holds stuff, and it's the way we display it which decides it's a base 10 or binary etc. On a different note however, your code is very readable and clean looking, with consistency in the formatting throughout - very well done indeed. Keep it up mate it's a really good habit to get into. A few points to take note of: Your `convertToBaseTwo` function has a return type of `int` however it never actually returns anything. Also, in the `if else` statements make sure you include all the curly brackets. if (r != 0) { num--; binvalue = 0; } else binvalue = 1; num = num/2; Should be if (r != 0) { num--; binvalue = 0; } else { binvalue = 1; num = num/2; } 
We use C to bring financial time series into shape, e.g. [rolling over futures contracts](http://github.com/hroptatyr/truffle) or [applying corporate actions](http://github.com/hroptatyr/cattle). I would argue it can't be done without C in a correct, portable and yet performant way. We're heavily relying on hardware IEEE 754/2008 decimals for both jobs.
Yeah, I researched and tried a variety of ways. Oh well, back to the drawing board. 
Is C still the industry standard for HFT?
I would say: sort of. *Real* HFT is done on ASICs and FPGAs (and hence VHDL) but in my experience development/prototyping and stuff in testing/early production mode is most definitely done in C. 
Please but for blanks in front of each line of code. This causes these lines to be formatted as source code which makes them much easier to read than they are right now. To call a function, use the `()` operator. `VariableOne` is a reference to `VariableOne`, `VariableOne()` is the function `VariableOne` called.
Thanks for your time.
&gt; you should not put a space between the ampersand and the variable name There's no problem at the C language level with that. 
I find Brian Kernighan to have struck a very good balance between the theory of computer science and the practice of software engineering. The books he has authored have been models of technical writing: crisp, somewhat dense, *never* incorrect, fluent English; it is impossible for the reader to not get what the books say. [Brian Kernighan uses this.](https://usesthis.com/interviews/brian.kernighan)
You're probably going to need a virtual machine that can run Windows 98. Most of those compilers are 16 bit executables. Windows 98 is the last version that ran 16 bit programs. Not sure about Unix, but Linux wasn't released until 1991. You might have trouble getting the source to compile on a newer system. If the compilers are as rare as Vax machines, you might pay a pretty penny for a copy. In industry, stuff that old is expensive because they know you need it, if you're looking.
&gt;0xFFFFFFFFu value will be placed into a 64-bit variable of signed type. In case of a 32-bit system it means that the variable will contain value -1. This doesn't make much sense. I guess he meant to say that assigning `0xFFFFFFFFu` to a 32-bit `ptrdiff_t` variable means the variable will contain `-1`. 
Poe's Law.
It can be used whenever you need a block of memory but you don't know the size at compile time.
Or if the space is too large. By default a thread's stack is 2MB on Windows I believe.
ok thank you. Ain't you suppose to free space after malloc is used?
ok thank you
No problem. By the way, if you ever decide to learn C++, you should keep in mind that while malloc is available, you should avoid it unless you're 100% certain that you need it. C++ has tonnes of methods to dynamically allocate memory in a safer foolproof manner with no tangible performance impact.
Thanks for the reply, but I think you misunderstood my question. Void pointers are undoubtedly useful for all the reasons you list, and probably more, but my interest is less in the general purpose of void pointers and more in the overwhelming support for their usage in object oriented C. Consider the following two vector implementations: struct vek { int n, m; void *a; } MyVek; Vs: #define vek(type) struct { int n, m; type *a; } ... vek(int) MyVek; After mallocing initial space for a, and setting n and m we'll probably want to store values in the elements of a. No big deal, and if I understand correctly one would be able to store lots of different types of values in the void pointer implementation, which is something I could see being useful. However, in order to use that stored data later it may be necessary to keep the type in mind (for instance in a printf()). With the void pointer implementation, one would need to check the type of each entry in a at runtime in order to have type safe code as I understand it. With the vek(type) implementation you'd only be able to store one type in a per vector but you could define a print function that is inherently type safe and shouldn't have to pull any runtime resources to check types. My question is really: why void pointer objects over type safe objects?
ok thank you
Getting into that habit can be dangerous though. The next thing that happens is you add a function at the end of your code that does something else.. and before you know it, that code is in a loop that creates two billions memory allocation it never frees.
Think [simh](http://simh.trailing-edge.com/). 
Dosbox on Linux may be useful...
maybe you have better way to find and use C library ? ccan just have a little c lib without good document.
What you are asking for is known as a [SYN cookie](https://en.wikipedia.org/wiki/SYN_cookies). If your operating system supports using SYN cookies, you can configure your operating system to use them. On Linux or FreeBSD, write `1` into the file `/proc/sys/net/ipv4/tcp_syncookies`. Please remember that using SYN cookies has a couple of drawbacks: they violate the TCP standard and using them makes it impossible to use any TCP extensions as these cannot be encoded in the `ACK` package. Theoretically, you could also implement SYN cookies using raw sockets and a custom implementation of TCP but I advise against this as that basically circumvents large parts of the network stack and requires elevated privileges.
You need to use raw sockets to do this kind of thing. Definitely doable but documentation is a bit scarce. If you want to use python there's something called scapy that makes this much easier. 
This is a better answer than mine, although I'm not sure they violate the TCP standard. 
A signed integer can go as high as 2 trillion and change.
Why are you using %d to print a long lont int? Try using %lli. Also try using long long unsigned in which case the modifier becomes %llu
Your program is doing a ridiculous amount of calculations, I think if you left it running for a day you would see results, but this really isn't efficient. On my computer I ran it with gn as 50000 and it took like 3 minutes to calculate (intel dual core 1.86ghz). I can't even imagine how many calculations it would have to do if you set it to billions. Maybe try thinking a faster way to solve this problem?
I tried to make it more efficient by changing a 'for' to a 'do' but it seems it wasn't enough, I'll try to think in a better solution. Thank you for your help!
You only use free() when you don't have an use for what's stored anymore. So for example, you might want to use that array throughout your program. So it wouldn't be wise to free() it. But as soon as you don't need it anymore, you should free() it.
You really didn't do anything different if you just changed the loop type. You should think of a smarter algorithm to solve your problem and that means to write the program again from scratch. Try thinking of other possible solutions that might help you reaching the final solution. Don't just focus on what you want as your end value, focus on the process that produces that value. Good luck!
No it can't (or you definitely shouldn't rely on it being able to). http://www.tutorialspoint.com/cprogramming/c_data_types.htm 
I solved it using [GNU's big number library GMP](https://gmplib.org/). You can also create custom data structures and functions to handle numbers larger than 64 bits but it will take quite a bit of work, especially if you're a beginner.
or simply watch computing theory lectures online then solve the problem again
ok thank you
which project euler question is it?
Does this also apply for one step back from that, i.e. Hash the initial SYN, check hash bundled with SYN-ACK?
 #include &lt;stdint.h&gt; in C99 compatible C compilers use int64_t and uint64_t instead of that silly long long crap all over your code. its more obvious and easier to understand. 
Basically your algorithm is shit :) Research prime generating functions. Implement something like the [Sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes). Also, once you find a prime factor you can divide "gn" by the prime factor. For example: for (p in primes) while (isFactorOf(p, gn)) gn = gn / p You shouldn't need any external libraries to complete Project Euler problems.
Use `scanf(" %c", &amp;mylettre);` (note the space before the `%c`), which will cause `scanf` to skip all whitespace characters.
Well, newline is a character too. If you call it a third time it should be the correct value. 
Please put four blanks in front of *every* line of code so the code comes out readable.
Suppose you input `a`, enter, `b`. The input stream will be `a\nb\n`. The first `scanf` call captures `a`, and what's left is `\nb\n`. What gets captured next?
I'm not a witch I'm your wife!
If you are only using Windows use fflush(stdin). if you are on Linux you have to write a little loop while(getch() != '/n'){} The little loop works with Windows to but is messy.
Do NOT EVER do fflush(stdin). It is undefined behavior. 
I'm a beginning programmer and I've been using fflush(stdin) a bit in some of my assignments. Can you go into more detail as to why it's not good to use? 
Undefined behavior is to be avoided because *anything* can happen. The behavior on windows happens to be what you expect, but anything is allowed to happen; usually crash your program, sometimes return something that makes no sense, sometimes do some stupid shit like remove the file you have open, anything goes.
It's only defined to be used with output buffers, so using it on input buffers might work. Or it might not! :)
why would putting the space there skip all whitespace? Would this capture one single character (that has no whitespace behind)?
I've always found a good way to go is to have a project in mind as I read technical books, and to think "how does this chapter help me build my project?" As I work through the changes I would make to incorporate the new knowledge, I evaluate what aspects of the knowledge is still fuzzy. That determines the exercises or experiments I take on.
Well, for that you probably want to move on to another language, like C++ or Java. While writing an emulator in C is doable, I don't think it would be the best language for it. Keep leaning C, though. [Topcoder](https://www.topcoder.com) is a great site to get daily programming prompts and solve them, so you can really sharpen up your skills with it. Once you think that you're comfortable enough with C, you can then move on to C++ (which I prefer as a jump from C rather than going to Java) OR you could see if there are any emulator that are coded on C and contribute to the project. Actually, I found a few links. Since you never specified the type of emulator you want to make, I'll give you an array of emulators for you to mess around with: * [Chip8](https://github.com/rascal999/chip8-emulator) * [NES](https://github.com/blanham/ChickeNES) * [Motorola](https://github.com/kstenerud/Musashi) * [Gameboy Color](https://github.com/RossMeikleham/PlutoBoy)
Best help I can give is link to [1024cores](http://www.1024cores.net/home/lock-free-algorithms) and [more links](http://www.1024cores.net/home/lock-free-algorithms/links). Best explanations for lockfree stuff I've seen.
Linux does not have the `getch()` function, but calling `fflush(stdin)` also works. You shouldn't program this way though.
* [C11 Lock-free Stack](http://nullprogram.com/blog/2014/09/02/) : Builds a lock-free stack, using DCAS to solve the ABA problem. * [Futexes Are Tricky](http://www.akkadia.org/drepper/futex.pdf) : Builds a futex (a fast binary semaphore) using CAS. It doesn't involve DCAS or ABA specifically, but still a very practical, complex, real-world example. * [Common Pitfalls in Writing Lock-Free Algorithms](http://blog.memsql.com/common-pitfalls-in-writing-lock-free-algorithms/) : Similar to the first link, but goes in a different direction. 
Thank you. I'm going to have a good read into this. Great answer.
If you are working under NDA, why not write a program of similar structure that has a completely different intention? Then get your answer, learn from that and attempt to apply it to your confidential work.
Interesting idea. I have a few issues though. if(ms-&gt;capacity *2 &lt; ms-&gt;capacity) { When will this ever be true? while(ms-&gt;length &gt;= ms-&gt;capacity) Why realloc within a while loop, instead of just calculating your required space up front. Also, your growth function is capacity * 2. While that is all good for say, 4 chars. What happens if I have a 1GB string, isn't another whole GB wasted as part of the buffer? That wastage only gets worse as the string size increases. Doesn't this also mean that you can't store a 4.5GB string in 8GB RAM because the malloc will fail?
Question, when do you solve the ABA problem? 
Thanks for this! I'd rather stick to C for as long as possible, but moving up to C++ is definitely the most logical step. I'd likely end up using C for emulation anyway, as the two projects I'm most interested in ([Cen64](http://cen64.com/) and [mGBA](http://mgba.io)) are both written in it. I'm interested in any project which aims for accuracy which is why they appeal to me.
My thought's exactly. It's practically the C bible.
There are many ways to version your program, but one of the more popular methods is [Semantic Versioning](http://semver.org/). You will probably want to keep your version number in a separate `.h` file somewhere that you can increment whenever you make a change.
I am writing a library! Also the macros sound like a good way to go, it kinda feels like the library I'm writing will be using the #ifdef _XOPEN_UNIX #ifdef _POSIX_VERSION style. If you could clarify one thing, the macros aren't the values that will be printed if someone calls the version argument, right? I'll just use a plain old string for that, and simply change it every time I upgrade?
I always wanted to create something like this, except reusable and easier to plugin to other things I'd want to use it for. However I'm having quite a bit of issues following implementations of them, as they are all done in C++, so while I can understand the gist of what's going on, I'm unsure as to how I can implement them in C. For example, if the Hazard Pointer keeps a void* that holds data, it must be freed. Hence I'd need a destructor callback, as it was taken for granted in the C++ implementations that delete handles calling the class's destructor, while I have to handle that myself. void (*destructor)(void *); Then there's creating new objects. I'm assuming that the hazard pointers must have a custom allocator as well, hence, I'd probably need a convenience constructor to allocate more data on-demand. void * (*constructor)(void); Would that be the best way to approach a generic and reusable way to implement hazard pointers? Then, another question, should the list I use to hold the list of hazard pointers, be without mutexes or any other kind of locks? I heard in another article you can use binary search trees or maps instead of lists for efficiency, which is better? Then even if I manage to implement my own hazard pointers on trial and error, how can I unit test and get enough coverage for my hazard pointers? I guess to reiterate, a concrete (and readable) example would help me out immensely.
Thanks for the detailed reply! This is exactly what I was looking for.
It's not always applicable, but I try to generate file containing the git hash of the branch. It makes it easy to identify exactly what the software actually is. 
You probably shouldn't do this. Types are good. We want types. We don't want to turn c into javascript.
Yah, read Maged, is how I learned to make my C hazard pointers. I did without any custom allocator, hazard pointer system only needs to learn about pointers when you make them hazards. A custom allocator that triggers a scan of deferred frees sounds good though, I just have them triggered on following frees. Then to get rid of something the hazard pointer system has a function instead of `free()`, call it "`retire()`", which defers the free. void retire(haz_ptr_sys* hp, void* toRetire); `retire()` checks the safety of the deferred frees and when safe calls the destructor function pointer or `free()` if `toRetire` was a simple allocation. In my implementation I init the `haz_ptr_sys` with the `void (*destructor)()` and provide a `void* ctx` to `retire()` that's stored alongside the deferred pointer, because my destructors need some context sometimes. Those details could be arranged variously as needed. I also ended up having to provide the thread-local `haz_ptr_record*` to `retire()` 'cause of some GCC stuff about thread-local variables across different object files. As for the double-width CAS - most x86\_64 should have cmpxchg16b. Apparently if you can use an int128 type the GCC \_\_atomic/\_\_sync intrinsics will use cmpxchg16b, or Microsoft has `InterlockedCompareExchange128`. Else you'll need to do a couple lines of inline assembly - [this example is C++ but you want the ASM anyway](http://blog.lse.epita.fr/articles/42-implementing-generic-double-word-compare-and-swap-.html). As for testing, yah you can unit test that each bit does it bit, but mostly you just gotta functionally bash the thing hard as you can and make sure it doesn't shit itself.
Use a union to store the value and an enum for type.
If you want to use macros, you can start with something like this: #define def_list(t) typedef struct {t value; t##_list_node_t *next; } t##_list_node_t \ typedef struct { int length; t##_list_node_t *next; } t##_list_t; So def_list(int) becomes typedef struct { int value; int_list_node_t * next; } int_list_node_t; typedef struct { int length; int_list_node_t * next; } int_list_t; And then you need a macro to instantiate a list, and then to add or remove elements, and then for this and that... long story short shoot your foot now and save the trouble
It's a fun project, though. I've never really messed with the preprocessor and macros before, so this sounds like a really good project to do it.
should even work with pointer types, just typedef them. however, you using malloc wrong. you always reserve space for a pointer which always result into 4 or 8 bytes (depends on your system). just say malloc(sizeof(node_myStruct)); // without *
... but have static char const rcs_id[] in every file so you can use ident or strings/grep on the binary.
I recall a chapter on it in "The Practice of Programming" by Kernighan and Pike.
Weird way of putting it, but I think I agree. :-p 
I don't know what RFC 4180 is. My CSV files contains 35 rows and thousands of columns. Each section between commas contains 1,2, or 3 characters (numbers or letters). I need to perform some analysis on the data so my plan is to load the file into memory but I'm having trouble trying to be efficient. I'm still fairly new to C so pardon my ignorance.
&gt; RFC 4180 (you could have just clicked the link) is the standard for CSV files. You're right, I should have done this. &gt; Your CSV file is a bit unusual in that it has few rows but many columns, I made a typo and switched my rows and columns up. It should be the other way around. Your recommendations for parsing the file are apt and that's close to what I've been doing. This is reassuring to me that I've been doing it in a way that isn't too cumbersome with respect to resource use. I guess I'm just nervous more than anything and don't want to screw this up. Do you recommend using strtok() when comparing if two strings are the same or is this only used to count characters in a string? Thanks again for your time.
`strtok()` is a function that separates a string into fields. To compare if two strings are equal, use `strcmp()`. For reading in the file, I would suggest you to use `fgets()` to read one line of the CSV and then separate that line into fields with `strtok()`. If you don't want to use `strtok()` (it has issues when multiple threads are using `strtok()` at the same time), you can also use `strchr` to find the next comma in the string and split rows into fields like this. Parsing CSV files, especially simple ones without quoted fields is no rocket science. Go for it!
Thanks for your excellent advice. I will definitely use it!
Lol what do you mean? All applications on Linux and BSD have version strings right? I've seen the source code of most core-utils and gcc and they all use that style. Am I missing something here? Was Unix against using versioning in their programs? Is that a feature used in its derivatives only (bsd, gnu/linux, minix etc)?
I have shared my opinion u idiot. Go get a life !! And Yeah fuck your bandwidth
Here's some different versions of cat (pretty cool to compare them): * [Unix v5](http://minnie.tuhs.org/cgi-bin/utree.pl?file=V5/usr/source/s1/cat.s) * [Unix v7](http://minnie.tuhs.org/cgi-bin/utree.pl?file=V7/usr/src/cmd/cat.c) * [Plan 9](http://plan9.bell-labs.com/sources/plan9/sys/src/cmd/cat.c) * [OpenBSD](http://cvsweb.openbsd.org/cgi-bin/cvsweb/src/bin/cat/cat.c?rev=1.21&amp;content-type=text/x-cvsweb-markup) * [GNU Coreutils](http://git.savannah.gnu.org/cgit/coreutils.git/tree/src/cat.c) `--version` seems common in GNU software, doesn't seem too popular among many others. I think long options are exclusively a GNU thing, BSDs seem to have only short options, and the original Unix versions don't seem to have getopt -- arguments are parsed in a unique way for each command. I'm not too sure how versioning worked in the original Unix. I think all the software was just bundled with the Unix distribution, so you probably had 'the version of the program that came with v7 of Unix', for example. You can read about the [Unix philosophy](https://en.wikipedia.org/wiki/Unix_philosophy) if you're interested, but I'd take it as a grain of salt unless it really appeals to you. My comment was intended slightly in jest, if you need versioning to distinguish between features among different revisions, there's been some good suggestions in the comments. But if you can possibly avoid the need for it, that's probably the way to go. I used to enjoy adding features like `--version` to my programs when I was learning, but now I don't really see the point. I guess my approach toward programming has become more cold and sterile over the years, haha. 
Actually, I found this advice on the web and started with this book but soon found that it is very out of date. It's too bad that people are still suggesting it.
You should look into Unions.
My favorite way to do this is to use the Linux-Kernel inspired `container_of` macro to create an intrusive linked-list setup. The basic idea is that you have a standard `struct node` that just contains the info for a node in the linked-list, but no data. IE: struct node { struct node *next; } node; Then, you embed this structure into other structures you plan on linking into linked-list (IE. The struct you place a `struct node` inside of becomes your data): struct data { int value, value2; struct node data_list; }; Then, you have a single node for the head of your list: struct node data_list_head; And then a bunch of functions that only act on `struct node` types: void list_add(struct node *list, struct node *new); void list_add_tail(struct node *list, struct node *new); void list_del(struct node *list, struct node *old); etc.. `container_of` allows you to take a `struct node *` from the linked list, and get a pointer to the containing `struct data`. I'd be happy to answer questions if you have them. You can see an implementation of a linked-list using `container_of` [here](https://github.com/DSMan195276/protura/blob/master/include/protura/list.h). You can see some usage of it [here](https://github.com/DSMan195276/protura/blob/57041493e7d4052cf2f5fa963a2507113d843cc7/arch/x86/kernel/scheduler.c).
Get a life idiot. CEO of google n microsoft both are indians. And yeah get your facts right no one uses turbo c++. The best part is u know from where I am. I don't even know from where d fuck u come, Which shitty country xD
Arguments passed to variadic functions undergo integer promotion, so char is converted to int. Using `%d` with a char is not an error.
But, if you use %s you will convert the otctet value into an ASCII character.
I was getting errors when freeing. Changed to char * and it worked.
Remember that you will need to `free()` the returned `const char *` once you have printed it out otherwise you will leak memory. ~~Also, you will need 17 chars to store "255.255.255.255\0" with a trailing NULL not newline as previously mentioned.~~ Edit: can't count.
I'm doing it this way, is this ok (all are char *, I modified function to return char *)? All works fine. start_ip_str = ntos(addr.s_addr); netmask_str = ntos(netmask); network_str = ntos(network); last_ip_str = ntos(ntohl(last_ip)); .... free(start_ip_str); free(network_str); free(netmask_str); free(last_ip_str); I free them up after printing them out as they are no longer needed. I also modified function to not include the newline character, so I've kept the size at 16.
Yes, that is correct. Another way to avoid the use of explicit memory management would be to allocate the strings in the calling function and pass pointers to `ntos` to fill with the IP address string as such: void ntos(uint32_t ip, char * str) { unsigned char ip_str[4]; ip_str[0] = ip &amp; 0xFF; ip_str[1] = (ip &gt;&gt; 8) &amp; 0xFF; ip_str[2] = (ip &gt;&gt; 16) &amp; 0xFF; ip_str[3] = (ip &gt;&gt; 24) &amp; 0xFF; snprintf(str, 16, "%d.%d.%d.%d\n", ip_str[0], ip_str[1], ip_str[2], ip_str[3]); } &amp;nbsp; char start_ip_str[16]; char netmask_str[16]; char network_str[16]; char last_ip_str[16]; ntos(addr.s_addr, start_ip_str); ntos(netmask, netmask_str); ntos(network, network_str); ntos(ntohl(last_ip), last_ip_str);
&gt;"Segmentation Fault. What's causing this?" &gt;- Every C programmer ever Great title, made me laugh.
Without the asterisk it is nonsense. Turn on all warnings in your compiler and pay attention to what they say. Your compiler will warn you about an implicit cast of a pointer to an integer, because you are taking an expression of pointer type (`"Zed"`) and attempting to store it in a variable of integer type (`char`). The declaration `char *another;` declares `another` to be a variable of type pointer-to-`char`. That means that the type of value that the variable `another` can hold is a *memory address* of a `char`. That is very different from the declaration `char another;`, which declares another to be a variable of type `char`. In this case, the type of value that the variable `another` can hold is a `char`, i.e., a single character. A `char` is very different from a pointer-to-`char`. The value of a `char` is a single character; the value of a pointer-to-`char` is the *address* of a `char` in memory. A string literal, like `"Zed"`, has type array-of-`char`. When you use an array *as a value*, the value that you get is the memory address of the first element of the array. In the case of a string literal, each element of the array has type `char`, so the memory address of the first element of the array has type pointer-to-`char`. So the declaration and initialization `char *another = "Zed";` declares `another` to be of type pointer-to-`char` and initializes its value to the address of the first character&amp;nbsp;(`'Z'`) of the string `"Zed"` in memory.
Ah ok, the errors definitely came up. Thank you. Your comment is so thorough and is explaining it well. I had to read it a few times, but I get it!
[This](https://github.com/DSMan195276/protura/blob/master/include/protura/stddef.h#L17) is how it is defined in the Linux-Kernel. It uses some GNU extensions to do some type-checking on the arguments. [This](https://github.com/DSMan195276/nclyr/blob/master/include/common.h#L13) is a completely compatible macro that does the same thing but doesn't use any GNU extensions (And consequently has less type checking).
stpo :v get some english classes dude. And I am not going to waste some more fucking time on reading ur bullshit comments. Piece
Your problem is with efficiency. Think about what can be the greates size of divisor compared to the given number, and what is a common propety of prime numbers. (with one exception)
Sorry for the delay. Long story short, I developed a very rough, yet functional, [example](https://github.com/Newt-Hoenikker/OOC-Test) which allows me to print a `vek` without having to pass the type as a parameter. One thing I've definitely learned is that void pointers are an appealing alternative to type safe code due to the vast amounts of development time one would save. If you're looking for comments check the README, but I feel the code is straightforward enough without them. I also cut a couple corners so that I'd have something that actually compiled before folks lost interest in this, but I don't see anything that couldn't be ironed out with a little elbow grease and free time. Please also keep in mind that I may have just created an abomination, too monstrous to speak of, and I may not know it since I'm still fairly new to C (only a few months of experience), so I would greatly appreciate any critiques or advice (like whether or not certain functions should be `inline`, or if certain loops summon demons). Thank you in advance for your patience! In the meantime I'll throw the above link up in an update on the OP so everyone can see it more easily.
Thanks for the advice.
I had a similar question after moving to C from some higher level languages like C++, Python, and Perl. I found an overwhelming support for the use of void pointers in the design of my objects as per AT Schreiner's [book](https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0CB4QFjAAahUKEwjZvaC46rDHAhVRF5IKHSg8DQ4&amp;url=http%3A%2F%2Fwww.cs.rit.edu%2F%7Eats%2Fbooks%2Fooc.pdf&amp;ei=SDPSVdn5KtGuyASo-LRw&amp;usg=AFQjCNF5sTtbWshc84hTEj8mBGNU_ILV-A&amp;sig2=5-8hQjvhrdw48LEtFP18hw), but I didn't like the idea of type checking at runtime in order to get type safe code. So, I set myself to trying an [implementation](https://github.com/Newt-Hoenikker/OOC-Test) of a typesafe vector in C using the preprocessor as you suggested. There were several snags and I spent easily more time in development than I would have had I just used void pointers, not to mention what I have is barely even a fragment/proof of concept and is still many hours away from being fully functional. I'm at a point now where I recognize the use for each methodology. They both work fine, it's just a matter of what you're trying to accomplish and how much time you have to get things right. I hope this helped.
This solution is off topic. I removed it for you.
Why return the pointer that was passed in, why not just make it an out parameter and return void or int for an error code?
You're asking others to take English classes and you cannot even spell “your.” Please do not insult other users in this subreddit. This is your first and final warning.
Thanks!
Ever heard of the RAS syndrome?
I think you see an example in the code above.
I'm sorry but this is not the right subreddit to ask this question. You might want to ask in /r/learnprogramming instead. This subreddit is about the C programming language only, everything else is off-topic. Your post has been removed for that reason.
Your comment has been caught in our spam filter. I just unmoderated it, it wasn't visible before. I'm sorry.
Because it can then be used directly in `printf()` like OP had originally attempted like so char start_ip_str[16]; printf("Network Address: %s\n", ntos(addr.s_addr, start_ip_str, 16)); 
Hey- I was in your position back when I was 16. I also worked with text-based RPGs in Python in my early years of programming. I self-taught myself C my last year of University and am now working independently in games. If you're able to teach yourself, most computer science courses will be a waste of time. This is purely from my own experiences- I stopped paying attention to my CS lectures after my first year, and instead spent time programming games during class. Of course, I wanted to go into games and a lot of the stuff being taught was focused on traditional software. Most colleges would probably take anyone for a CS degree. However, I had terrible grades in math during high school, mostly out of a lack of interest in the subject beyond what was needed in the games I was making at the time. For whatever reason, CS departments enforce crazy requirements for Math courses that in no way represents the actual skills needed in most programming jobs. I ended up taking Calculus courses which I've found to be completely useless, even in games. I struggled to understand so much because I thought there would be a huge payoff for having that working knowledge, but now I see the stress wasn't worth it. YMMV. People graduating with CS degrees are a dime a dozen. If you have a decent portfolio that shows you can code, you'll basically be on the same level as college grads. College CS courses have you building lots of small projects, but then you'll occasionally make a handful of large ones. Do stuff like that. If you aren't using Github, start using it right away. Build small to medium-sized projects and make them open source. When you apply for a job, link to your Github page. Mine is featured proudly on my CV/resume. Python is a great language to have on your resume, but as you probably know, you'll need a more prominent OOP-based language in order to get any job in software development. Look into Java and C++. Take note that some employers might hire you based on your talent in other languages, then pay to train you in another. I.e., employers are often just looking to see how well you're able to adapt and pick up new concepts. Not knowing a particular language might not be that big a deal if you can pick it up quickly.
1. No. 2. "Dont ask why about anythting. Just compile it." Your rude demands don't help. 3. What are you going to do, just run an executable that some stranger gives you? Here, let me send you a virus.
You naive fool. Here, I'll send you an executable that just overwrites all the data on your hard drive. I wrote it myself just now, so it isn't in your virus scanner's definitions file. Even if you "remove" the executable from your system, you can't get your data back.
Can you film yourself running it? I want proof its not a virus cuz /u/zifyoip says so.
BWAHAHAHAHAHAHAHAHAHAHAHAHAHA
Too destructive. Better to insert ASCII goatse into important looking word docs.
I can't run it myself. That's the point of cross-compilation. I compiled it natively and ran it and it seems like it's doing a lot of calculations because my cpu is up to 60%. I left it running for like 30 seconds and then shut it down cause I have a very slow PC.
And how is the recording proof of anything? You do know how easy it is to fake these things?
Apparently it is. Anyway, I'm not deleting this as it's neither off-topic nor asking the users to do anything dangerous or illegal. Use the vote buttons to decide if you'd like to see this kind of content.
Nah, make the pirate from that Archer episode. I'd pay money to see the reaction if that actually came up on someone's computer in real life.
This will give you a really good idea of how memory is stored and allocated when using C. In terms of the code, global, stack and heap memory. [I found it very helpful.](https://www.youtube.com/watch?v=_8-ht2AKyH4)
Doubling the capacity is a mediocre strategy. The optimal strategy is to multiply the capacity by the golden ratio which is approx. 1.61.
Yes, you need to allocate enough space for the final string. Otherwise you write beyond your allocated space when you do the concatenation. Make sure that you remember the terminating null character&amp;nbsp;`'\0'` when you calculate how much space you need. You need to allocate one more byte than the length of the final string, because you need space for the null character at the end. The string `"Hello, World!"` requires 14&amp;nbsp;bytes of space.
I had KNR on my bookshelf for years before I started actually using it. I wouldn't say I was a good C coder, I'm still learning, but I've had to learn and use numerous languages and the one thing that I have found to work is to jump right in. Every time I tried to learn C I'd read KNR page by page. And a lot of things made sense, but I wasn't really doing anything with the knowledge. I was reading and hoping I'd become a super C coder without writing much code. I knew lots of other languages, but C was a different beast. When I actually got down to learning C (and I'm still learning to this day) I decided to have a project in mind, and then use the book as a reference to get the project done. I still keep the book next to me, it's helpful at times. My first project took over a week of solid coding. I don't have a job, so I spend much of my time with my head in books. I could have done the project with Python in an hour tops, but I avoided using any libraries such as cURL, and went straight into sockets. I'd try to implement everything myself even though it was probably unnecessary. Numerous problems and bugs would catch me out - for hours sometimes. These problems are necessary to through, so you learn why they happen and don't repeat the same mistake. You won't read KNR cover to cover and become "excellent" with C. I find if you actively use C for everything you do in your spare time you will develop strong pathways in your brain and over time you will become a good C programmer over time. What would you love to create? What's that buzzing idea you have on your brain? Catch the idea and work on it :) Jump in head first. Right at the deep end. If you get stuck you've got your book, Reddit, StackOverflow and ##c (freenode). Over the 12 years I've been programming it's the only thing I've found effective for truly learning a language. I just wish I'd learnt C right from the start. I'd also recommend you get to grips with a debugger/disassembler as early as you can. I use gcc (linux) and VIM as my editor, but I'm sure there's IDE's that can do this too. Just my 2 cents bud. Wishing you all the success in your learning endeavors. It gets easier, and those light bulb moments are the best feeling ever :)
&gt; They’re obscure, can give rise to subtle bugs, are *highly platform-specific*, and, if abused, will probably lead to awfully confusing code; a footcannon if I ever saw one. Wha?? "highly platform-specific"? There's nothing about setjmp/longjmp that's more platform-specific than any other standard C function. I'm actually kind of glad exceptions never caught on in C. [libpng](http://linux.die.net/man/3/libpng) is the only major library I can think of off the top of my head that uses setjmp/longjmp as a way to handle errors (can anyone think of another?). I get the motivation behind it, that it frees the programmer from the burden (or possibility of errors) from having to check return values and possibly thread them through multiple functions. C programmers seem to have so much practice and discipline in doing that, though, that it hasn't turned out to be a big win in the real world. I do like setjmp/longjmp as a way of reporting errors over callbacks, though. Callbacks always seemed kind of cumbersome because they're never in the right stack frame/context that you want them to be in, so you have to have some extra `void *` as an extra parameter to your callback, which points to some `struct` that you created only for that purpose. setjmp/longjmp allow you to forget about all that, as whatever data you need to handle the error already exists in your stack frame.
Yeah. [Check it out.](https://doc.rust-lang.org/book/enums.html) They're like C enums, except that each variant can optionally have data associated with it. So they're a C enum and a union at the same time.
I've implemented the hazard pointers, but I'm having difficulty understand how there are no race conditions involved. During the scan, it creates a collection of hazard pointers, then searches to see if it is contained in any threads hazard pointers, which I understand the reason, but... The list has potential to be outdated and unsafe and is a race condition. Imagine if after collecting all hazard pointers, another thread actually ends up acquiring the retired node during the middle of the scan, and you've already double checked if the node is still valid. Then it's possible for it to be deleted even when valid. I.E Thread A scans the collection of hazard pointers in each thread. Contains a hazard pointer, say HP, that Thread B is about to acquire. Makes it past the scan, on to the search and gets stopped by scheduler... Thread B snags HP, however Thread A's collection is outdated and still considers HP retired. It checks if the node is valid, then CAS the node. Gets stopped by scheduler. Thread A now ready to delete HP since according to it's collection it's ready to be reaped. However the issue here is that it will delete the node leaving Thread B to get data from a corrupted node. SegFault. This is inherent in all implementations I've seen so far. How do you get around this?
Exceptions are only really useful with proper scoping, RAII in C++ is a good example. longjmp is basically just a shorter way to express multiple chained returns and hides what is actually happening.
If you have access to `asprintf`, or take it from [libiberty](https://en.wikipedia.org/wiki/Libiberty), you can just do char *str = NULL; char *a = "Hello"; char *b = "World"; asprintf(&amp;str, "%s %s", a, b); // ... free(str);
Your post got caught in our automatic spam filter. I just unblocked it.
For variable length arrays, the `sizeof` operator does not compute its result at compile time. Rather it evaluates its operand at runtime (this normally does not happen) and computes its size. It's perfectly fine and useful to use `sizeof` on variable length arrays, but you should understand this property.
Do you mean internally or libpq? I've worked with libpq and haven't seen/heard of this.
`sizeof()` _should_ be a compile-time operator but as others have already pointed out, for VLA's it's not. In C11 they somewhat stepped back from this mistake by making VLAs an optional feature.
In that situation you can add up the space you need, then allocate it; this may not apply to the real world case. You may want to look at the realloc() call. There are other, higher-level, approaches, such as: maintaining a list of strings, and then only concatenate them at the point where you need the string; or allocate a buffer with some tailroom (typically, the same amount again) to avoid having to reallocate in all cases (time vs space trade off). The rabbit hole goes deeper. YMMV.
&gt; game-&gt;moving_object[0]-&gt;rigid_body-&gt;current.direction[2] = -1.0f; That's not so much of a problem but it looks a bit like you are overengineering stuff. Try to simplify your code and remove unnecessary layers of abstraction. &gt; My really bad include hierarchy in paint if it helps anyone: Include Hierarchy There are different philosophies when it comes to the structuring of header files. I follow the Plan 9 philosophy which states that a header file should not include other header files. You don't need one header file for each source code for, you can put the prototypes into few thematically grouped header files. You should also consider making a single file `types.h` that contains all the types (e.g. structure declarations and type definitions) you use in your program. Then every source code form starts like this: /* system includes first */ #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt; ... #include "types.h" /* now include all the project header files you need */ Other people will tell you other concepts of structuring header files, all of them are equally valid and have their own advantages.
Certainly doesn't look dangerous, but can we prove it's not designed to trigger some type of compiler exploit?
types.h is so arbitrary. How about naming the file the name of struct? Imagine reading the code. What would you first instinct be when you start reading the usage of a `x__struct`? It would be to look in x__struct.h, not types.h
Implementing your own memory allocator is fun! I highly suggest you try that as an exercise and then throw away the result as you realize that your own memory allocator will neither be as portable as `malloc()`, nor is it as secure or as well-tuned. Really, people put a lot of time into implementing `malloc()` and the implementations generally perform quite well. In C, you also usually don't call `malloc()` too often so having a lockless memory allocator does not bring that much of an advantage when you realize that there are other things much more important for a memory allocator that are hard to implement in a lockless fashion.
But you do loose parts of the possible optimization, which is why you should split your program into files along semantic boundaries so functions that benefit greatly from inter procedural optimization are in one file.
I have no idea, but this post got caught, too. You might be shadow-banned.
&gt;That's not so much of a problem but it looks a bit like you are overengineering stuff. Try to simplify your code and remove unnecessary layers of abstraction. This exact thing lead me to post here. I would really like to do that, but I don't know how(?). In terms of code, what do I follow? Is there some style/design people go by? Because if you notice, I just copied the style of most c++ tutorials I have followed to make my project and replaced them with c-syntax rather that re-design their code. And that's where I really need help because I want to really take this further. Also I'm a student, hence I lack "design foresight" that experienced people have. &gt;There are different philosophies when it comes to the structuring of header files. I follow the Plan 9 philosophy which states that a header file should not include other header files. You don't need one header file for each source code for, you can put the prototypes into few thematically grouped header files. You should also consider making a single file types.h that contains all the types (e.g. structure declarations and type definitions) you use in your program. I've skimmed through plan 9 online and I will be reading about it more. However, I have initial question, wouldn't it be counter productive to have to include all struct types from a types.h file when I just need one of them for my current file. In my code i have a "InputHandler.h" and it needs only "Vector.h" and "WindowContext.h", including everything would be overkill right?
While that's right, many memory allocators (including the one used on Linux) use a facility like `mmap()` to get around this problem. Simple `sbrk()` based memory allocation is almost never used nowadays. 
Right, all of this points to the fact that writing a memory allocator can in fact be more than simply a fun, throw-away project that can't hope to be better for a particular use than the system `malloc()`. &gt; and then throw away the result as you realize that your own memory allocator will neither be as portable as malloc(), nor is it as secure or as well-tuned.
Didn't know, sorry. It's "Scalable Lock-Free Dynamic Memory Allocation" by Mages M. Michael
Yeah, that sounds about right. Achieving performance is an entirely different beast and is not something that can be explained in a comment. The single largest source for performance issues is bad algorithms. Try not to use bad algorithms. If your code performs too slow, use a tool like `gprof` to find the hot spots where the program spends most of its time and try to improve them.
http://issuu.com/anonymous61/docs/p35-michael 
Maybe I am missing something, but how does `malloc()`'s use of `mmap()` solve the problem, anonymous `mmap()` is still on the heap and visible to all the threads, isn't it? EDIT : phrasing
Just do both - Have functions that return the version values from the macros.
Of course it is! Every library you use is just someone else's code; there's no magic in programming. Naturally, the more you decide to reinvent, the more effort you will have to put in to make that piece of high-level functionality; no matter how simple it may seem, often times the complexity of a problem explodes as you climb down the layers of abstraction. Note that this isn't necessarily a bad thing -- building a piece of software from the ground up is an invaluable learning experience! If you try something like this, just be prepared to be stopped dead in your tracks by problems that you never knew existed in processes you hadn't even spared a thought about before. Networking is a classic example of this; graphics is another one. To build an OCR from scratch, you'd need to be able to start at the top and work your way down, rigorously defining problems as you go and coming up with solutions, from "Recognize this character" all the way down to "Recognize line boundaries based on contrast differentials"; you could even go deeper, and write all the code yourself to load and decompress an image file from disk. It would take some reverse-engineering, but you could eschew operating system and driver APIs and write all the code yourself to call the relevant systems. If you wanted to go seriously hardcore and blast the last of your library dependencies, you could write a fully freestanding implementation. This wouldn't be particularly useful, but it would certainly be possible! Everything is code; layers upon layers upon layers of abstraction, but ultimately all the processor sees is a stream of instructions. The first programmers wrote machine code directly, but soon there were assembly languages, a form of code that was human-readable and could be translated directly into machine instructions. From there, compilers and interpreters were built for all sorts of high-level languages, and these languages were used to build large, complex, and portable systems, like the one we're talking on right now.
Stringification is not needed here, token pasting is.
Ah, makes sense now. `##` concatenates, so `####` concatenates three things (where the second one is nothing). Thanks!
Exactly, you *could* write everything yourself, including an equivalent to the stdlib, but I'm not entirely sure *why* you would want to do so. What's wrong with opencv or tesseract that you want to not use them?
&gt;The strings will be in the data section of the executable. The string literals may be in the code section. Of course this varies between implementations. &gt; In case 1, the function will contain code to copy the strings from the data section. In many cases this could be optimized out.
What was the original motive for variable length arrays -- avoiding heap allocations on tiny embedded systems? There's a lot to love in C99: designated initializers, compound literals, flexible array members, stdint.h, raising the silly size limits from ANSI C. But VLAs feel like something the ISO C committee added to stick it to the C++ committee back when they were antagonizing one another.
Not measurably, no. They do *very* different things though the second form doesn't produce mutable character arrays, it just gets you an array of pointers to static strings. `str[1][0] = '\0'` ought to produce a memory access error on the second approach, and should work fine on the first approach. In practice, the choice between those two is irrelevant and *also* will never come up.
Oh. You mean Apple, right?
It's mostly a readability issue, also a side-effects issue can occur if you have something like `upto(y++)`. Somewhere or other there is a post by Joel Spolsky or someone like that about his friend who used things like #define BEGIN { so that C started to look like Pascal, and lots of arguments against doing that. Edit: Here is the thing I was thinking of, I think: http://stackoverflow.com/questions/652788/what-is-the-worst-real-world-macros-pre-processor-abuse-youve-ever-come-across
There are lots of problems with this. For example, preprocessor macros have no enforced type safety; `putchar("hello");` gives you a warning (int from pointer without a cast), but `upto((struct foo) { .bar = 5, .baz = 4})` will make the compiler complain illegibly. Your maintainers will want to murder you. All that, for what? So you don't have to write idiomatic code? I mean, sure, it's a little more typing, but typing is not very time-consuming. There's less mental overhead in deciphering the meaning of the `for` statement then there is understanding whatever the hell that `upto` thing is doing - so there are no points to be won for clarity. So, why? *Buuuut*, I get what you're saying. In some *very specific* cases, sometimes macros like these are useful (SO LONG AS THEY ARE WELL DOCUMENTED AND CLEARLY COMMENTED). Sometimes the clearest way to solve a problem is by writing awfully-mangled code - with the power of the preprocessor, you can tame C, and rewrite your terrible construct so that the logic of what you're doing is transparently clear. For that, [praise be to Simon Tathan's mp.h.](http://www.chiark.greenend.org.uk/~sgtatham/mp/) TL;DR Macros for examples like you gave? Absolutely not. Well-documented, well-commented macros to clarify otherwise-mangled blocks of code? [Absolutely.](http://www.chiark.greenend.org.uk/~sgtatham/mp/)
Sorry if I sounded too strident. 
No, no, I appreciate it! I mean, I made the error, so it's on me to accept the criticism and fix it.
Upvote for fixing the comment.
I have often seen this kind of macros in programming contests, where speed is more important than readability, however if you're writing something you will read more than once, I'd suggest you stay away from them ...
I totally agree with /u/acwaters's comment. But aside from that I wanted to mention that I've implemented a very simple OCR myself in C, it relied only on the standard C library with my own little PNM image loader (a nice and simple image format) I used it (with some other code that called this program) to read the text in an emulated pokemon game and outputting it on IRC, where the bot would accept commands for buttonpresses. Turning at least the battle parts into a text game over IRC.
&gt; In the real world this makes absolutely no measurable difference in performance and you can safely ignore the assistant. I don't know, but my guess would be that cache misses are a measurable performance hit in cases like that due to prefetching...
On ELF targets, strings go into a specially marked subsection of `.rodata` such that they can be tail-merged.
One way to find out for *sure* is to 1.) complete some code that uses the array, and... 2.) compile and ... 3.) dis-assemble the object files into assembly langauge (Turbo C and other compilers have tools for this) You don't even have to know much assembly language to see a difference. If one is generating substantially more assembly code than the other -- the larger code is going to be the slower set. Or -- you can create some code that uses each array for a million iterations, and time the two variations. That might be the easier/faster way to find out. Every poster has made decent arguments, and none are disagreeable to me. But sometimes, we just want to *know*. 
&gt; There is more space allocated to the {char str[4][10] } version (although data/info is intended to be the same). How do you figure? For that case, one contiguous block of memory 40 bytes in size should be allocated. For the char \*str[] case, space needs to be allocated for the strings themselves *and the pointers pointing to them*. The strings themselves are 6 bytes each, including the null terminator. The string pointers are probably going to be 4 or 8 bytes each, depending on the system, making the grand total either 40 bytes or 56 bytes. So, at best, they're the same, but str[4][10] is certainly not *more*.
As it has already been explained, such macros are considered bad. However, if you work with any decent editor (vim included!) you can use tools like [Snipmate](https://github.com/garbas/vim-snipmate) to save time when writing pieces of code that you use often. For example, if you are using snipmate in vim, typing `for` and then pressing &lt;Tab&gt; will expand in a for-loop block, where you can edit the upper and lower limits etc.
There was significant opposition to the inclusion of the _s functions by a lot of groups, including glibc. I think it was basically only Microsoft that was supporting them, but that was enough to get them into the standard. So it doesn't surprise me that glibc is slow on implementing them. Though I would have expected them to have support by now regardless. &gt; if I passed a large enough number to something like s`canf("%d", &amp;var)` I'd get undefined behavior because of integer overflow `scanf_s` doesn't change any behavior with `%d`, it only affects `%s`, `%c`, and `%[`. You still get UB on overflow (though you can check `errno` to detect the condition and handle it).
I've thought about the integer overflow problem before, and wouldn't it be easier to just capture the input as a string, instead of as an integer? That way you can just convert to an integer a safe amount of characters from the string without risking overflow. Do you guys have any thoughts on this? Is this a good practice? To just get all input from the user in the form of a string, regardless of what type it is, and convert it to the appropriate type later (using a macro or something probably to make it simpler)?
Most programs read the stuff as a string, and then parse that string. scanf/fscanf/scanf_s/etc. just makes things too hard to recover from unwanted situations, handle invalid input, report sensible errors and so on, and are best suited for convenience in throwaway programs.
I see. That's disappointing. I wish there were a saner set of functions in the standard library
Yes but that gives no warning if there is a truncation.
I suppose it can be worked with if necessary, char s[2]; int n; switch (scanf("%4d%1[0-9]", &amp;n, s)) { case EOF: end of file/error case 0: no value to convert case 1: success case 2: truncated value } 
Yup.
Point is, it doesn't work. If you use a variable before you assign to it, the compiler is going to notice and your teacher will deduct points for that.
As /u/FUZxxl said, the global constraint handler is extremely problematic. I think the concerns about practical usage are valid, too. (Patterns like `strncpy(a, b, strlen(b))` are not exactly uncommon.) The `scanf_s` family of functions might be reasonable to implement (without the constraint handler) because stock `scanf` only supports specifying the field width in the format string. A way to pass `sizeof(buffer)` to the implementation, telling it the size of the target buffer, looks like a nice feature and would avoid real bugs (like that `udisks2` stack overflow). It's also not something covered by `_FORTIFY_SOURCE` at present.
It rather depends on what you're trying to do with the contents of the file.
Right now I just want to open it. I let Notepad run for 5 minutes and it didn't work. Wordpad was able to open part of it but viewing it was extremely slow. I would be happy if I could just split the file into smaller pieces but I've never used a splitter and would like some advice.
You said you just wanted to open it in the last post. That's how you open a file for reading in C. 
I've heard something similar. What's specified in the standard differs a bit from what Microsoft originally implemented. But since it's really only Microsoft's implementation that matters, it's not a big deal in practice.
Why do you say that? Because no one else has an implementation right now?
You can also look into memory mapped files. The Windows documentation is [here](https://msdn.microsoft.com/en-us/library/windows/desktop/aa366556%28v=vs.85%29.aspx?f=255&amp;MSPPError=-2147217396). If you are new to C then I wouldn't recommend this approach because it begins to take you out of the language proper and into external libraries.
Thanks for the feedback. I'll look it over and see if it's over my head or not. As you guessed, I am new to C.
Exactly. I don't know of any other implementation of the C standard library that comes with the bounds checking functions.
system() invokes the system shell to run the given command, which adds extra overhead. I would rather recommend the exec family of functions (execl/execv)
if you're running a linux (maybe mac too? idk) system then theres good documentation for the exec family of functions in the manpages, eg 'man execve'
Thanks for the advice but I think I'll be able to split the file with /u/jedwardsol 's advice.
&gt; /u/TurquoiseTurkey[3] 's "help" was a waste of both our time Your question is part of the issue. You make it so we have to assume we know what your end goal is. So let's say I read this question "Will I have any problems if I try to read a text file that is about 1GB in size? What tools do you use to read large text files?". Now I am going to assume that you want to open this file is to count the number of lines in the the file. In that case the only issue you have with a large file is how you declare the variable that is going to hold your counter. But you will have no issues with the large file itself. So I could have answered, *No you will have no issues, don't worry about it.* So at this point I have answered your question with a correct answer (Only if your goal is to count lines in a file)
Mac OS X is a Unix OS, so it should work there, too.
Ask for the tax rate and say enter 0 if there is no tax. Your calculation will then just work
Got it. Thanks! I didn't know if there was a fancier way that I missed.
Ah yes, `clock` is really only relevant within a single process. I don't think you want to use `clock` anyway. It sounds like you want to determine how long (in wall clock time) it took for something to happen? In that case, don't use `clock` because `clock` doesn't give you that information. Try `clock_gettime`
This is for school. the assignment isn't specific enough, it just says something generic like measure the time. I'll have to ask if he means CPU time or wall time. Thanks. Edit: from a look at the note section in the man page for clock, it definitely sounds like I'm going to want to use System Time.
Annex K specifies that `memcpy_s` and similar functions call an application-supplied callback function on a detect constraint violation. This is extremely bad design because it does not compose well. Different libraries within the same application (which have no knowledge of each other) may want to use the handler in different ways. This kind of global state totally breaks encapsulation.
Using Windows (8.1 if it matters). I have gcc installed and can compile using cygwin currently.
Hmm, interesting. Pop open a standard CMD and see if you can run gcc. If not, it might not be in your %PATH%. 
Yep! Cygwin uses a different path ($PATH) than Cmd/Windows (%PATH%). Cygwin sets its path in your .bashrc file, which obviously includes its `bin` directory whereas Windows does not. All you should have to do is add your Cygwin `bin` directory to your Windows %PATH%, restart CLion/CMake, and you should be good to go.
I really wish there was some kind of obscure standard, that most people weren't using it just because they haven't heard of it. That would make it easier at least, to know that something like that existed. It's exhausting to have to adapt to a different style at every huge codebase, which doesn't use a specific IDE to make it easier at least.
So how does a "global constraint handler" differ? What's the exact mechanism?
You might also want to check the wait4() system call. It will return both the user time and system time the child process used (along with other statistics). 
It's important that you ask precise questions. I'm sure you know how to open a file with `fopen`, so why do ask about it? Have you actually tried to open a large file with `fopen`?
Mind explaining your rationale? 
CLOCK_MONOTONIC is a system-wide clock that isn't effected by jumps in time due to setting the system clock (as it's incrementing from some arbitrary point in time). In practice CLOCK_REALTIME would work 99.99% of the time, but you might as well handle the corner case if you can. EDIT: Depending on what you want to measure, you could also use CLOCK_PROCESS_CPUTIME_ID to measure how much CPU time a process has taken.
There is no standard, but if it is of any help, I have seen a lot of programs use this structure with slight variations. bin/ binaries data/ data files lib/ libraries (may be libs/ as well) log/ program logs obj/ build object files src/ source files tmp/ temporary files It is vaguely similar to the default unix file system directories. But at the same time many programs just pile everything into the same directory.
If all you want to do is open the file to view its contents, then simply use an editor that supports opening large files. Vim, for example, can handle a 1GB file easily. For really large files [here's](http://stackoverflow.com/q/908575/365496) some advice.
Why should you include a compiler with your program? What benefits do you expect from this? I don't really understand what you are trying to do.
Unless your program IS a compiler this sounds really dumb and also no other applications do this. If you're confused of, what a compiler is or what a compiler does that's another thing though.
Are you looking for something like Lua by any chance? It's not a compiled language, interpreted rather, but it is embeddable into a C program so that you can add extensibility to your application. 
I *suspect* he means including a compiler inside of text editors.
OP was not asking for advice on whether or not to use scanf. OP was asking how to do one thing or another based on user input without using an if statement. As OP stated that they were using scanf, my answer merely reflected that reality. Sorry I didn't warn OP not to use scanf ever! If you're curious why OP is choosing to use scanf over fgets, I'd suggest asking OP.
Sorry I didn't mean to come across like I was attacking you. My fault!
Apparently somebody downvoted my answer, care to clarify why so I can learn from it?
But then you pass a `struct`, not an array.
That depends on the operating system, but I don't think there is any operating system that can locklessly give your process more memory as this is a task that's very hard / impossible to get right without locking. What you can try is to allocate a block of memory and use that for your own lockless allocator until it's completely used up. This way you only have to lock very rarely. Strategies like this are used by many allocators, this block is typically called a “nursery area” and there is one for every thread.
You can achieve something like that but you need to pass a true array pointer and the array length. You define an array pointer like this int (*bar)[length]; // bar is of type pointer to int[length] from here, you can have a sizeof that evaluates in the dynamic environment. void foo (size_t length, int (*array)[length]) { printf("sizeof: %zu (length: %zu)\n", sizeof(*array), length); } How arrays are handled in C is odd. Let's say that we have the array int bar[100]; `bar` is a symbol/identifier that designate an array (of type int[100], in this case). When `bar` is used in an expression, it doesn't actually evaluate to itself nor to a pointer to itself but actually to a pointer to its first element (it's an implicit conversion, a casting is an explicit conversion). It was done like this for practical reasons with the `[]` operator; if `bar` was actually returning a pointer to itself, `bar[10]` would actually not return the tenth element but the tenth array. To get the pointer of an array and not a pointer to its first element, simply use the `&amp;` operator. the type of `&amp;bar` is of pointer to int[100] (an array) the type of `bar` is pointer to int (implicit conversion) from this, int bar[100]; int *pbar = bar; // valid, bar return to a pointer to int (implicit conversion) int *pbar = &amp;bar; // invalid, &amp;bar returns a pointer to int[100] int (*pbar)[100] = bar; // invalid int (*pbar)[100] = &amp;bar; // valid You access the elements of an array through an array pointer with (*pbar)[...] = ...; because *pbar returns an array, an array that when used in an expression is actually evaluated to a pointer to it's first element (remember) so the `[]` operator works as wanted. What i find odd is * an argument `T xx[]` doesn't declare an array pointer but a pointer of type T. * I have not found a way to return array pointer. Hope my English was not too crap, surely that others will explain this better. full example: http://ideone.com/fu4tnj
http://goog-perftools.sourceforge.net/doc/tcmalloc.html This is probably what you are looking for. It gives every thread it's own thread-local heap as you describe.
I created a [Lua module](https://github.com/spc476/lua-conmanorg/blob/master/src/tcc.c) that wraps [TCC](https://en.wikipedia.org/wiki/Tiny_C_Compiler). I then wrote another [Lua module](https://github.com/spc476/lua-conmanorg/blob/master/lua/cc.lua) that allows you to directly load Lua modules written in C from source code. Do I use this in production? No. It's more of a quick prototyping tool (TCC is a bit flaky to use in production---it's also limited in the platforms it supports). I've also embedded TCC in another application to give me what can only be described as closures in C (since each compilation of a function is independent of other each other). Again, nothing I would use in production, but it's fun to play around with. 
Why would you want to locklessly allocate memory? Why would your thread die in a malloc call? My gut says there's a higher level solution to your issue.
Ah! These `␣` characters are a visualization of whitespace. Put blanks instead.
What is the value of s? Is the problem that sleep doesn't work? Or that it does but the output doesn't appear until the end? If the latter, use fflush(stdout) after the printf to force its output
thanks fix it!
thanks it worked!
For a lock free data structure to be lock free, doesn't that mean every component be lock free as well? Even if I cache thread local storage, it'd still have to lock even if rarely
&gt; I have not found a way to return array pointer. Welcome to C declarator syntax hell: int (*foo())[100] { static int bar[100]; return &amp;bar; }
Where did you get the idea that locks are bad practice? What's your beef with them? Locks don't cause deadlock, poor planning causes deadlock.
This one has automatic storage duration, so it will last until the next `}` . Compound literals declared at file scope would have static storage duration. 
It's like a function returning a function pointer. There a explanation in k&amp;r for such syntax &gt; The declaration of the pointer ip, &gt; &gt; int *ip; &gt; is intended as a mnemonic; it says that the expression `*ip` is an int. **The syntax of the declaration for a variable mimics the syntax of expressions in which the variable might appear.** This reasoning applies to function declarations as well. For example, &gt; &gt; double *dp, atof(char *); &gt; says that in an expression `*dp` and `atof(s)` have values of double , and that the argument of atof is a pointer to char. 
You are on the right track, and this problem is exactly where you'd use multiple inputs (unless you are making some guesses on behalf of the user). In your code, you need to take in another 'integer' value to decide if it will be taxed or not (your {0,1}, lets call it 'isTaxable'). Since you will be basing your equation off this value, it makes sense to start your if-statement by checking if 'isTaxable' is equal to 1. And since you are only deciding between two options, you can just do: if (isTaxable == 1){ // your equation will include tax }else{ // your equation will NOT include tax } Later on when you learn about multiple if-else (and nested if's) you can branch off even more but make sure you are comfortable with this idea first. Here's a thinking exercise: you're at a supermarket and only have enough money to buy an apple or an orange. You take out a coin and decide that if the coin lands HEADS, you'll buy the apple. If it's TAILS, you'll buy the orange. Try writing the code for this!
I don't have any beef with locks, it's not like I avoid them like the plague, I try to synchronize my code as much as possible, it's just that, I suppose it's like the hammer and nail metaphor, I'm teaching myself how to write lockfree code and use atomic primitives, so I end up trying to see where I can replace locks with lockless implementations. Part of the reason is from [Common Pitfalls in Writing Lock-Free Algorithms](http://blog.memsql.com/common-pitfalls-in-writing-lock-free-algorithms/), in particular this [image](http://memsql.wpengine.com/wp-content/uploads/2013/03/failstack.jpeg). I solved the ABA problem and safe deletion of nodes via hazard pointers, but I didn't solve the "NOT LOCK FREE" problem, so that's where I'm a bit confused at. 
Thanks!! :D 
I can't read through it right now, but don't forget that fork() will create an *exact* copy of the process as it exists when you call it, and exec() will *completely replace* the process you had running. By calling exec(), you might as well be calling exit(), since you will never ever execute beyond that line. Instead, you are transferring control over to what you are exec()-ing. Therefore, you should free any memory *before* calling exec(), and do not expect to be able to return control afterwards.
Does that mean that you can't call exec() in both the parent and the child of fork()? basically, this is my program: main { clock_getttime //mark start time if (pid == 0) { //child process mark end time in child execl(C executable) } else { //parent process mark end time in parent execl(C executable) } } That works, but in the program that's being executed I can tell that it's basically calling the same memory, and is thus not working as intended. How does someone call two external identical applications without running into this problem? 
&gt; So if you want your timer to work after execl not exactly. I want to get the time from the call to fork the executable and the actual start of that program. I also want to start up a second copy of the executable and measure the startup time of the second program. I'm not sure if my code does that or not, but I think so. The issue is I am literally calling the same application, and my program does stuff like fread(), fwrite(), memcmp() a bunch of random digits to a file and back, so it appears that they both hit the same areas of memory and this causes unintentional errors. 
your code is // start timer //fork // child stops timer, calls exec // parent stops timer,calls exec both child and parent work simultaneously,so we can't say who calls exec first. If your exec'd app has lot file I/O operations I think they will try to open same filehandles and cause some issue. So I suggest you to change app code so that it takes filename as commandline arguments, so you can call app with different arguments in both parent and child 
Also your last two brackets are backwards.
That's not a complete program. Why do you think the problem is in that portion of it? Have you run the program in a debugger? If so, where does it say the crash is occuring? If not, that's the best way of finding the location of the problem. In Display, head can be NULL. In newNode, head is assumed to be non-NULL and head-&gt;next being NULL is the indicator that the list is empty. Which of these is the real precondition on `head`.
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct node { int info; struct node *next; }; void Display(struct node *head); struct node *InsertAtBeg(struct node *head, int val); void InsertAtEnd(struct node *head, int val); void newNode(struct node *head, int val); struct node* Insert(struct node *head, int val); int main (int argc, char* argv[]) { struct node *head = NULL; //empty list int choice; int val; while(1) { printf("\n1. Display\n"); printf("2. Add node to beggining of the list\n"); printf("3. Add node at the end\n"); printf("9. Exit\n\n"); scanf("%d", &amp;choice); switch(choice) { case 1: Display(head); break; case 2: printf("Enter number you want to store: \n"); scanf("%d", &amp;val); head = Insert(head, val); break; case 3: printf("Enter number you want to store: \n"); scanf("%d", &amp;val); InsertAtEnd(head, val); break; case 9: exit(1); default: printf("Invalid choice\n"); } } return 1; } void Display(struct node *head) { struct node *temp; if(head == NULL) { printf("List is empty"); return; } temp = head; printf("List: "); while(temp != NULL) { printf("%d ", temp-&gt;info); temp = temp-&gt;next; } } /* struct node *p; if(head==NULL) { printf("\nList is empty\n"); return; } p=head; printf("List is : \n"); while(p != NULL) { printf("%d ", p-&gt;info); p=p-&gt;next; } }*/ void newNode(struct node *head, int val) { struct node *temp = (struct node*)malloc(sizeof(struct node)); if(temp == NULL) { printf("Unable to allocate memory"); exit(-1); } temp-&gt;info = val; temp-&gt;next = NULL; if(head-&gt;next == NULL) { head-&gt;next = temp; printf("Added at beggining\n"); } else { struct node *current = head; while(1) { if (current-&gt;next == NULL) { current-&gt;next = temp; printf("added later\n"); break; } current = current-&gt;next; } } } struct node* Insert(struct node *head, int val) { struct node* temp = (struct node*)malloc(sizeof(struct node)); struct node *temp2; temp-&gt;info = val; if (head == NULL) { temp-&gt;next = head; head = temp; //printf("inserted: %d ", head-&gt;info); return head; } else { temp-&gt;info = val; temp2 = head; while(temp2-&gt;next != NULL) { temp2 = temp2-&gt;next; } temp2-&gt;next = temp; temp-&gt;next = NULL; return temp; } } struct node *InsertAtBeg(struct node *head, int val) { struct node *temp; temp = (struct node*)malloc(sizeof(struct node)); temp-&gt;info = val; temp-&gt;next = head; head = temp; //printf("inserted: %d ", head-&gt;info); return head; } void InsertAtEnd(struct node *head, int val) { struct node *temp; struct node *temp2; temp = (struct node*)malloc(sizeof(struct node)); temp-&gt;info = val; temp2 = head; while(temp2-&gt;next != NULL) { temp2 = temp2-&gt;next; } temp2-&gt;next = temp; temp-&gt;next = NULL; } /* struct node *temp; temp=(struct node *)malloc(sizeof(struct node)); temp-&gt;info=val; temp-&gt;next = head; head = temp; return head;*/ 
InsertAtBeg puts the new node at the beginning of the list whether or not the list is already empty. Your new 'newNode' only puts it at the beginning if the list is empty `head-&gt;next == NULL`. Which is the same as putting at the end, put your printf a different message.
And when is it crashing? When you enter 1, 2 or 3? When the list is empty, or when it already has items in it? This version doesn't call the newNode function
Providing your own, untested, version that doesn't even do what the original does isn't helping anyone.
Look at the strtok family of functions. http://man7.org/linux/man-pages/man3/strtok.3.html
This looks good! But I will need to edit the script to use the rules we have in our project.
I was thinking more like the output I get from the checkpatch.pl script [in the other comment](https://www.reddit.com/r/C_Programming/comments/3je8w3/do_you_know_of_any_good_coding_style_check_tool/cuoick5): WARNING: please, no spaces at the start of a line #7: FILE: ../Test/test.c:7: + int val;$ WARNING: please, no spaces at the start of a line #8: FILE: ../Test/test.c:8: + int* ptr = &amp;val;$ ERROR: "foo* bar" should be "foo *bar" #8: FILE: ../Test/test.c:8: + int* ptr = &amp;val; WARNING: please, no spaces at the start of a line #9: FILE: ../Test/test.c:9: + int i;$ But I guess to diff like you said might also work. I will give it a try as well.
Looks good, I will give it a try!
astyle --dry-run http://astyle.sourceforge.net/astyle.html
You can tokenize manually if you do not want to use the built in functions and want it customised for your data. I wanted to try this out myself as an exercise, and I hope the approach below is legal as I'm learning myself. I would read the file line-by-line into a buffer, which is separated out with the tokenizing code below. #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { char testinbuffer[] = "(SEX,DEW,JAM,MAN),(ABE,JKE,DIE,QUE),(YUM,ALS,RUN,CAT),(ROW,PUL,LAT,LOL,DOS,UNO),(TRE)"; int lc0, lc1=0, lc2=0, lc3, counter4words, counter4letters, wordlength, index; //for each char in buffer for (lc0=0; lc0&lt;=strlen(testinbuffer); lc0++) { //is it the start of a set if (testinbuffer[lc0]=='(') { //first count number of commas in set, thus words is commas + 1 counter4words=0;//init counter lc0++;//we want the next char index=lc0;//and we will want to get back to it later while (testinbuffer[lc0]!=')' &amp;&amp; testinbuffer[lc0]!='\0') { if (testinbuffer[lc0]==',') counter4words++; lc0++; } //edit - forgot to do the + 1 for correct number of words counter4words++; printf("counter4words= %i\n", counter4words); //next find longest word as I can't just assume it'll be 3 lc0=index;////reset counter to start of set counter4letters=0;//init counter wordlength=0;//init length while (testinbuffer[lc0]!=',' &amp;&amp; testinbuffer[lc0]!=')' &amp;&amp; testinbuffer[lc0]!='\0') { counter4letters++; if (counter4letters &gt; wordlength) wordlength=counter4letters; lc0++; } printf("counter4letters= %i\n", counter4letters); //** define new array [number of words+1] by [max wordlength+1] now we have gone and counted them** //** hope this is legal as it appears to work ** char testoutbuffer[counter4words+1][counter4letters+1];//define array number of words+1 by max wordlength+1 //thirdly populate new array with each word separated out lc0=index;//reset counter to start of set lc1=0;//init counter lc2=0;//init counter while (testinbuffer[lc0]!=')' &amp;&amp; testinbuffer[lc0]!='\0') { if (testinbuffer[lc0]!=',') { testoutbuffer[lc1][lc2]=testinbuffer[lc0]; lc2++; testoutbuffer[lc1][lc2]='\0';//ensure buffer is terminated } else if (testinbuffer[lc0]==',') { lc1++; lc2=0; } lc0++; } //last with them separated out print them out or send them where they need to be for (lc3=0; lc3&lt;=counter4words-1; lc3++) { printf("testoutbuffer[%i]= %s\n", lc3, testoutbuffer[lc3]); } } } return 0; } 
Literally what I've been searching for. Already looked over one or two of the articles, a ton of useful information! Thanks again.
`p = calloc(n, m);` is basically `if (p = malloc(n*m), p != NULL) { memset(p, 0, n*m); }` `malloc(n)` is basically `realloc(NULL, n)` Essentially, you only *need* realloc and memset, but malloc and calloc may be used for their convenience. It's tempting to throw functions into the 'do not use' category, but by doing so you avoid understanding the situations where those functions can be used well. There is a trade-off that is present in `calloc` vs `malloc`; `malloc` usually completes in less time, whereas `calloc` guarantees zero'd storage. By understanding this trade-off and using the right function for the right purpose, you can write more efficient code with fewer characters than you could by avoiding one of those functions. 
Right, which is why added a separate question for malloc and calloc. The other functions up there really are unsafe unless they are used very specifically (which I also noted)
&gt; Just out of curiosity, what do you use s(n)printf for? Converting integers to strings Writing strings guaranteeing no buffer overflow
Hmm...based on advice from here and some stuff I read via various sites, I measured time in my program using clock_gettime(CLOCK_MONOTONIC, &amp;foo); My TA told me today that's a bad idea as CLOCK_MONOTONIC pauses from certain system processes (he was vague) and recommended I use gettimeofday() instead as follows: gettimeofday(&amp;foo, NULL); My reading says clock_monotonic should be used, he says otherwise, what do you think?
&gt; Also, benchmarks that aren't at max optimization level have questionable value. With the sources I listed above you'd want to compile without any optimisations, otherwise the library calls are likely to be removed. (Shown below.) # cat x.c #include &lt;stdlib.h&gt; int main(void) { malloc(123456789); return 0; } # cc -O2 -S x.c &amp;&amp; grep malloc x.s # cc -S x.c &amp;&amp; grep malloc x.s call malloc 
Note that `calloc(n, m)` also checks if `n*m` overflows, if you use `malloc(n*m)` instead you may have to do this yourself. 
downvote for thinking github is the only way to publish sourcecode. I will not use github.
It depends what you want to do. UTF-8 and ASCII are somewhat compatible. All ASCII characters are the same in UTF-8. An '@' symbol is going to be a byte with the value 64 in both. UTF-8 has multibyte characters, but they only utilize the high part of the 8 bits – if you wanted to e.g. count the number of "x"-characters in a string, you can be sure that it won't accidentally count part of a multibyte character as one. There's no 0-bytes either, so null-terminated strings still work just fine. There's some caveats: naturally, the number of bytes don't correspond to the typed length of the string anymore, which might screw up text-based layouts in e.g. ncurses. There could also be different representations of the same character; for example, this: ; is not a semicolon, it's a greek question mark represented by the bytes 0xCD, 0xBE, which could be confusing. There's also a fair bit of headache-inducing characters, e.g. the "right-to-left mark" which causes the text afterwards to be reversed. The problem of actually rendering this isn't usually your problem though, as the problem is left to the terminal you dump the text to instead.
Thanks for the input. I emitted a sigh of anticipated frustration while reading your post. I was hoping it would be easier to deal with this format and not have to figure out so many caveats. For the moment I just need to convert a handful of words to English. I already know the translations so it shouldn't be too much of a headache. I do have a question for you: &gt; the "right-to-left mark" which causes the text afterwards to be reversed. The problem of actually rendering this isn't usually your problem though, as the problem is left to the terminal you dump the text to instead. Will my compiler have any trouble with this "right-to-left mark"? My compiler is MinGW. 
Thanks for your time.
The definition you linked says *variable* contains "some of SSID, ...". Is it possible the SSID isn't included in that packet? You could try dumping the first few bytes of *variable* to see if it does contain a name.
The comment in the code where it says "some of the SSID" is what's confusing me. The SSID should come after the `capab_info`, unless I'm mistaken (which is possible). I'm not sure why it says "some of". I will try dumping and see what it yields.
https://en.wikibooks.org/wiki/C_Programming/C_Reference/wchar.h
This looks very nice, thank you.
Thanks.
Wow... really? Ok how about bitbucket? Pastebin? Some place where other people can see the code.
Thanks for the informing post. I appreciate your time.
I am certain they are beacon frames, but I will modify the filter to `type mgt subtype beacon` to be 100%. I should have done this originally.
After modifying the filter, the same problem persists. I am using tcpdump which is showing the correct headers. Surely if this is a beacon frame then u.beacon.variable[0] would be the SSID? The SSID is there, but I have to jump 2 bytes in order to access it.
Is this the TLV? https://msdn.microsoft.com/en-us/library/cc234031.aspx ... I get it now. In all the books I've read non of them mention this. Nothing I found online did either.
Works. Thank you for your help.
It's natural that people are going to mention wchar, but it's not necessarily a compatible representation with Unicode. For example, a conforming implementation is allowed to define `wchar_t` as a single byte. If you know you're specifically dealing with Unicode, don't bother with C's wide character types and functions. They'll do the wrong thing on some platforms. Use a Unicode library instead. &gt; If wchar_t (see 7.17) is defined as a signed integer type, the value &gt; of WCHAR_MIN shall be no greater than −127 and the value of &gt; WCHAR_MAX shall be no less than 127; otherwise, wchar_t is defined &gt; as an unsigned integer type, and the value of WCHAR_MIN shall be 0 &gt; and the value of WCHAR_MAX shall be no less than 255. ISO 9899:2011§7.20.3¶4 
UTF-8 files don't have a BOM. You're thinking of UTF-16.
The stack is a small (1Mb on Windows) region of memory that the operating system gives to your process when it starts (actually each thread gets one, but your program has only 1 thread). The processor keeps track of how much of the stack you have used. The processor uses the stack for some things, the compiler can also carve out chunks of it and it does so to (a) pass variables to functions and (b) store local variables. So in the case of your program, at the beginning of main() the compiler has put in a instruction which tells the processor 'I am using 140 bytes of stack', and at the end of main there is an instruction saying 'I am giving back 140 bytes of stack' The compiler knows what it is going to use the memory for, which is your case is something like ---|-------------------|-------------------|-------------------|------|-------------| 40 bytes 40 bytes 40 bytes 4bytes 100 bytes dot_matrix_product array_2 array_1 tok line So when you write to array_2[11] you're actually writing to array_1[0] You're using array_1 so the compiler has set aside space for it. The compiler is free to layout things as it wishes. Locals don't have to be stored in memory at all if the compiler doesn't want to. Or it can use the same memory for 2 different variables if it wants to (e.g. you only use variable x in the 1st half of a function and variable y in the 2nd half, the compiler knows they'll never clash and can reuse x's memory for y). This is why you must not rely on the behaviour you're observing. It works today, it might not tomorrow. You method with strtok is as good as any.
Thanks for the in-depth write up. But if I increase the array size of array_2 to fit all the ints, why does it still flow to array_1? Is strtok the only way? Is there no other function that takes in multi digit numbers with out breaking apart the entire string into tokens? Very complicated to do when compared to single digit ints. 
Shouldn't that cause a compiler error? I'm a newb
You're overflowing because you're incrementing row. When you do array_2[1][0] the compiler knows a row is 20 ints long so it still writes right past the end of array_2, I.E. where array_1 starts. You could use fscanf. I don't understand why you think single digits are easier .. atoi reads all the number however many digits it is
Hmm... you're right. Thanks for showing me something about sizeof() i didn't know before. Your kind and informative response is uncommon, to say the least. 
The C standard doesn't require a compiler error, because those arguments correspond to a `...` part of the prototype. Good compilers will give a warning though. 
I don't know if this counts, rt? Because it is very specific -- but my compiler's isalnum() is flawed, returning inaccurate results/causing crashes, etc. So I built [my own replacement](http://codepad.org/bRfj1DA6) which by dumb luck, was actually faster than the compiler's stdlib when tested, as well. I've kind of got a growing list of such replacements. In example -- some compiler's stdlib's strlen() will crash if given a NULL pointer. Now, whether that's *flawed* or not is arguable. I reckon most competent programmers will say it's not a flaw, and you should check a ptr for NULL before feeding it to any function. Sure, I get that, but... 
You can use fscanf to read the numbers from the input file. For example fscanf(file, "%d %d", &amp;array_1[row][col], &amp;array_2[row][col]) You pass fscanf() the file descriptor, then a format string (like in printf) to match the input, and then pointers where to store the input. http://linux.die.net/man/3/scanf 
Here's what my version of GCC (4.8) has to say about that: &gt; gcc -o game game.c game.c: In function ‘main’: game.c:19:2: warning: format ‘%c’ expects argument of type ‘char *’, but argument 2 has type ‘int’ [-Wformat=] scanf("%c", ch); /*Bad form, but compiler will not complain*/ ^ Note that I haven't even used -Wall which you should always do. IME, 90% of the questions on this sub can be answered by using -Wall (at a minimum) and paying attention to the compiler's output.
Do you want to be right, or do you want a good grade? 
Debugging a bomb for CSSE2310 I see :) Write a program to print the weird characters and then pipe them into ./bomb. Best of luck
You got me...It's funny, I've worked out every phase I just don't know how to input this string.
I just made a program which spits out the passphrase and then a \n and then a Y. It will execute in one go so be careful.
Buy K&amp;R C. Get a copy of the standard for the rest.
There is really no reason to use `memcpy` instead of `memmove`. `memcpy` can cause nasty bugs if used incorrectly.
Its not strictly embedded, but still C: I recommend you to download and just study/analyze the [OpenCV](http://opencv.org/) code base. It is good C code with lots of examples that you can immediately try. You can learn a lot by understanding the code. If you want to impress your colleagues with your C knowledge however, then study [this](https://graphics.stanford.edu/~seander/bithacks.html). 
To be right :P 
Yup, that's if you need a complete solution. There's also iconv. If all you need to do is identify individual codepoints (you don't need to distinguish composing characters and such; you're not rendering; etc.), you could get away [with something smaller](https://github.com/skeeto/goblin-com/blob/master/src/utf.h).
Thanks.
When doing file IO in `text mode` a Control-Z is processed as an end-of-file character. Any file IO would have to be done in binary mode. Text mode also does different things with `\r` and `\n`, depending upon platform as well.
&gt; won't be able to consume any of those super detailed C books for embedded Dev wizards in two weeks Unless you're still working full time right up to your start date then two weeks ought to be plenty of time to get quite a lot out of a book. Furthermore, your employment agreement presumably does not prohibit you from reading books in your off hours, so you're not limited to those two weeks. Anyway, I'll second the recommendations to spend time on stackoverflow.com and to get a copy of the C spec. For anyone new to professional programming, I think [_Code Complete_][1] provides a handy reference. It's not going to talk about C at all as far as I can recall, but the info is useful for any professional programmer. For material more specific to C you might checkout [_21st Century C_][2] and [_Expert C Programming_][3]. [1]: http://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670 [2]: http://www.amazon.com/21st-Century-Tips-New-School/dp/1491903899 [3]: http://www.amazon.com/Expert-Programming-Peter-van-Linden/dp/0131774298
 **Code Complete: A Practical Handbook of Software Construction, Second E...** |||| --:|:--|:-- Current|$28.99|Amazon (New) High|$36.48|Amazon (New) Low|$27.61|Amazon (New) |Average|$28.36|30 Day [Price History Chart and Sales Rank](http://i.imgur.com/Jve4fiL.png) **Expert C Programming: Deep C Secrets** |||| --:|:--|:-- Current|$29.43|Amazon (New) High|$35.17|Amazon (New) Low|$27.78|Amazon (New) |Average|$29.65|30 Day [Price History Chart and Sales Rank](http://i.imgur.com/VIz5cvL.png) | [FAQ](http://www.reddit.com/r/PriceZombie/wiki/index) 
Well, if all you want is a little refresher, you might try reading through some existing code. I'm thinking of the Linux kernel. You could read through some of that and try to work out (at a low level) what it's doing. Anything you don't understand you can look up online or in a book. That way you can concentrate on practical stuff without having to work through an entire book. And maybe you can tell your new colleagues about some cool technique you found in the Linux kernel. Instant l33t haxx0r points!
Note that I'm not sure that the windows terminal support UTF-8 chars out of the box, you may need to configure it.
K&amp;R is honestly the single best programming language handbook I have ever used. It's clearly written, concise and has challenging exercises.
If the way I defined the static testoutbuffer array in the previous version is not correct (it very likely is not), I have worked out how to do a proper dynamic array instead. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main(void) { char testinbuffer[] = "(SEX,DEW,JAM,MAN),(ABE,JKE,DIE,QUE),(YUM,ALS,RUN,CAT),(ROW,PUL,LAT,LOL,DOS,UNO),(TRE)"; int lc0, lc1=0, lc2=0, lc3, counter4words, counter4letters, wordlength, index; //for each char in buffer for (lc0=0; lc0&lt;=strlen(testinbuffer); lc0++) { //is it the start of a set if (testinbuffer[lc0]=='(') { //first count number of commas in set, thus words is commas + 1 counter4words=0;//init counter lc0++;//we want the next char index=lc0;//and we will want to get back to it later while (testinbuffer[lc0]!=')' &amp;&amp; testinbuffer[lc0]!='\0') { if (testinbuffer[lc0]==',') counter4words++; lc0++; } counter4words++; printf("counter4words= %i\n", counter4words); //next find longest word as I can't just assume it'll be 3 lc0=index;//reset counter to start of set counter4letters=0;//init counter wordlength=0;//init length while (testinbuffer[lc0]!=',' &amp;&amp; testinbuffer[lc0]!=')' &amp;&amp; testinbuffer[lc0]!='\0') { counter4letters++; if (counter4letters &gt; wordlength) wordlength=counter4letters; lc0++; } printf("counter4letters= %i\n", counter4letters); //** define new array [number of words+1] by [max wordlength+1] now we have gone and counted them** //** hope this is legal as it appears to work ** //char testoutbuffer[counter4words+1][counter4letters+1];//define array number of words+1 by max wordlength+1 char **testoutbuffer; testoutbuffer=malloc( (counter4words+1) * sizeof(char *)); if(testoutbuffer==NULL) { fputs("Error: memory not allocated for array- dimension 1.\n", stderr); exit(0); } for (lc1=0; lc1&lt;counter4words+1; lc1++) { testoutbuffer[lc1] = malloc( (counter4letters+1) * sizeof(char *)); if(testoutbuffer[lc1]==NULL) { fputs("Error: memory not allocated for array- dimension 2.\n", stderr); exit(0); } } //thirdly populate new array with each word separated out lc0=index;//reset counter to start of set lc1=0;//init counter lc2=0;//init counter while (testinbuffer[lc0]!=')' &amp;&amp; testinbuffer[lc0]!='\0') { if (testinbuffer[lc0]!=',') { testoutbuffer[lc1][lc2]=testinbuffer[lc0]; lc2++; testoutbuffer[lc1][lc2]='\0';//ensure buffer is terminated } else if (testinbuffer[lc0]==',') { lc1++; lc2=0; } lc0++; } //last with them separated out print them out or send them where they need to be for (lc3=0; lc3&lt;=counter4words-1; lc3++) { printf("testoutbuffer[%i]= %s\n", lc3, testoutbuffer[lc3]); } for (lc1=0; lc1&lt;counter4words+1; lc1++) { free(testoutbuffer[lc1]); } free(testoutbuffer); } } return 0; } 
I'd be surprised if `isalnum()` were buggy. Are you sure you're using it correctly? The argument to `isalnum()` is of type `int`. Its value must be either within the range of `unsigned char` or equal to `EOF` (which is typically `-1`). If plain `char` is signed (as it very commonly is), passing an unchecked `char` value to any of the `is*()` or `to*()` functions has undefined behavior; a crash is likely. You need convert the argument to `unsigned char`. Given a `char` array `s`, this: isalnum(s[i]) has undefined behavior, but this: isalnum((unsigned char)s[i]) is safe.
The difference is that `memcpy` has undefined behavior if the source and target overlap. But if you don't *know* whether they overlap, it's likely you have worse problems. (And if they do, are you sure that `memmove()`'s behavior is what you want?
You don't get much from `calloc` or `malloc`, just small enhancements (drop one argument, one fewer function call, negligibly reduced time, readability, etc.) in different circumstances. `realloc` and `memset` handle all their cases well, but there are situations which are better suited for `malloc` or `calloc`.
Know structs and pointers !!! Know structs and pointers !!! Oh and understand pointers!!!
Then ask the TA to prove his assertion. gettimeofday(), since it returns "wall clock time" is at the mercy of real world concerns of time, such as leap seconds and daylight saving time and what not. I think CLOCK_MONOTONIC is just fine. 
K&amp;R is a great way to *start* learning C. It's getting dated, though; there have been two major revisions to the C language (C99 and C11) since it was last updated. C programming style and "best practices" have evolved a bit as well. I think one of the most valuable things you could do (after picking up the basics, anyway) is study up on the C abstract machine model in the specification (can be downloaded in final draft form from here: http://www.iso-9899.info/wiki/The_Standard) along with the list of portability concerns in the appendices, which lists all the things that are unspecified, undefined, and implementation-defined. Note that these are really long lists, and the undefined behavior list especially is full of things that you aren't allowed to do, but which the compiler is allowed to not warn you about. Many, many bugs are due to accidentally writing code with undefined behavior. Also, write programs; either work exercises or write programs that are interesting to you. And find some open source programs in the domain you're going to work in on github or something and read through the source code, looking things up that confuse you along the way. When you find an interesting bit of code or something you can't figure out, try writing a little sample program to reinforce your memory and leave behind some "executable notes" that you can refer back to.
Thanks, never occurred to me. I'll have to revisit this issue with a type cast as you suggested.
The FILE structure maintains a kind of pointer into the file which moves forward as you read data from the file. Functions like fseek can modify the location of this pointer.
It's part of the state of the file handle.
Every file has with it an associated 'current position', which is maintained by the operating system. Reading from a file increments that position by the length of the read, and similarly for writing. The position can also be directly adjusted by seeking. Resetting the pointer back to the beginning of the file is generally called rewinding. If you can think about it, you can see a little bit of computer history leaking through into the present here. Magnetic tape storage systems were the standard for mass storage in the early days of computing, and file APIs evolved from how they worked. Eventually the idea of a file turned out to be so useful that it became an abstraction that was used to represent other resources, such as pipes, sockets, FIFOs, and so on, leading to the idea of a file descriptor as a general handle for a resource, not necessarily a file on disk. Fortunately, the model of a file with a 'current position' worked very well to describe these other kinds of resources, with the added notion that not all things are going to be seekable. You can just keep reading from a socket, and it will continue to yield data until the connection is terminated, just as continually reading from a file yields its contents from beginning to end. So for example a socket acts like a long file, except that you can't use seeking to modify the 'current position', i.e. calls to `lseek()` or `fseek()` will just fail. This abstraction wouldn't have worked nearly as well if a different scheme had been used to describe file I/O originally (such as every request including an offset and length) so I suppose it's fortunate that it was modeled after magnetic tapes which inherently represent a stream of information rather than a device that is more oriented to random access, like a hard drive. (At the controller level, each request to read from the hard drive includes an address (LBA) and length (number of sectors).) 
Under the hood on *nix, `fseek()` is `llseek()`, and is a standard part of the fops package. In the Linux kernel, `struct file_operations` includes character device entry points like `read()`, `write()`, `ioctl()`, and seeking functions. [For reference.](http://www.tldp.org/LDP/lkmpg/2.4/html/c577.htm)
Ok, you got me!
This is actually not true, it's completely hidden from the program accessing it and managed by the operating system.
When you use the name of an array *as a value*, such as when you pass it to a function, the value you get is a pointer to the first element of the array.
So, passing an array to some function `f(&amp;a, ...)` will have me pass the adress of the array `a` to the function? When would it be beneficial to do this over passing `*a`?
Ah, I see what you are saying now. Thank you very much for the answer. 
Good to see the Kochan book. I learned hobby programming from that book almost 30 years ago. Solid book with some elementary data structures illustrating things like; why pointers. 
To further confuse things (:p), `a[i]` is syntactic sugar for `*(a + i)` (and therefore i[a] should work as well). 
What do you mean? Can't you use a format string like "%9s"?
&gt; However I can't figure out how to tell if the set has an even or an odd amount of numbers. You know the size of the set, right? Use the remainder operator&amp;nbsp;`%` to see whether the size leaves a remainder of&amp;nbsp;0 or of&amp;nbsp;1 when it is divided by&amp;nbsp;2.
OH SHIT it's called mod right? I competley forgot about it.
Well, it's called&amp;nbsp;`%`.
Yeah thanks though for some reason I couldn't figure it out all last night and it was driving me nuts.
Me neither, you need to ask the admins for the why.
The variable in your code should be typed as a pointer to your node type, ideally. When you assign to it, you’re assigning a pointer value that identifies the location of a node, not a node itself. As long as you don’t overwrite a newly allocated node’s pointer without saving it off into the hash table, you won’t leak memory (which is what I assume you mean by “lose information”). In practice this usually comes out as something like // input: value v; Node *p; unsigned h = hash(&amp;v); unsigned idx = h % table.capacity; for(p = table.buckets[idx]; p; p = p-&gt;next) { if(p-&gt;hash == h &amp;&amp; values_equal(&amp;v, &amp;p-&gt;value)) { /* already in the table; replace or bug out */ return; } } p = createNode(&amp;v); p-&gt;next = table.buckets[idx]; if(p-&gt;next) p-&gt;next-&gt;prev = p; table.buckets[idx] = p; 
Sorry if I wasn't clear with that, NodeP is a pointer that is malloc'd and initialized in the function createNode() outside of main(). I tried and tested my code which followed the pseudocode I posted above, it worked so I think I'm alright for now. Thanks for the example, it was very helpful! One other question, though. I compile and do everything through the terminal and I heard there is a debugger tool that helps you watch memory leaks, would you happen to know the name of it 
I thought this was going to literally make syscalls to the ABI of the platform. Looks like it still links to system libs. 
Computers can't read minds so the user will need to tell the program what base each of the six inputs is being entered in. (Assuming you're wanting to convert them. If you only want to print them as entered then it's irrelevant what base they think they're writing in) For the alignment you could just add the correct number of blank spaces before each number. If they enter a one digit number you'd add nine spaces. A two digit number, eight spaces etc
For `scanf`, you could look at using `%i` instead of, say, `%d`. `%i` will read the string as a hex value if it starts with `0x`, an octal value if it starts with `0`, or a decimal value otherwise. If you can't use `%i`, then you may just want to use `%s`, read the value as a string, and then parse the string yourself - `scanf` doesn't provide tons of flexibility. Aligning a number like that is easy if you make use of `printf` features. The `width` parameter allows you to specify the minimum number of characters to print - `%[width]d`, so for example `%20d` will specify that you're printing an integer, and it must take up a minimum of 20 characters. Right aligning the number is the default for printf, so if your number takes up less then 20 characters to print, it will be padded with spaces on the left side to make the number take up the required number of characters.
&gt; Is there anyone that could help me with understanding how to scanf when I don't know if it will be a hex, decimal, or octal That part is easy: `%i`. It's the same as `%d` that you've probably used in the past, but it detects the base (010 is octal, 0x10 is hex, 10 is decimal). &gt; and then print it as an int aligned in this manner. This requires the field width to be specified in the format. In essence: printf("12345\n"); printf("%5d\n", 23); Will print: 12345 23
Keep in mind that when you print something, you're not going to start directly from the start of the line - You start where you left off. If you want to align the numbers like in your post, then you'll want to use the same width for both numbers, for example the format: "%10d %10d", that way, the first number is aligned to 10 characters, then a space, then the next number is also aligned to the next 10 characters. Also, seeing your other comment, your `printf` call doesn't work because you don't provide pointers to `printf`. You provide addresses to `scanf` using the `&amp;` because `scanf` modifies the value at that address, but `printf` only displays values, it doesn't need to modify them. Because of this, you can just pass the int directly instead of getting the address first.
Remove the &amp; symbol
The error message tells you exactly what is wrong. The `%i` format specifier expects a value of type `int`, but you're passing a value of type `int *`, i.e. a pointer to an int. `scanf()` takes a pointer because it needs to write the new value into the variable, but `printf()` only needs to read the value and consequently does not take a pointer but just the value itself. 
The size of an int is compiler dependent, whereas a float is 4 bytes exactly. You're trying to pass a thing of two bytes (possibly, who knows? Maybe it's 3 or 4?) to a thing that's looking to interpret 4 bytes, so my best guess is that printf() is grabbing your int (2 bytes) + garbage (the next 2 bytes after, which you have no idea what the state is). Instead, try casting n as such: printf("%f\n", (float)n);
The bits set in a 32-bit int holding the value 10 are 00000000 00000000 00000000 00001010 The bits set in a 32-bit float holding the value 10.0 are 01000001 00100000 00000000 00000000 Note that they are very different. When you do `printf("%f",n);` it passes the int version of 10. If you pass 00000000 00000000 00000000 00001010 to something expecting a float (%f) it should print 0.000000 (the actual value is 1.4*10^(-44)) 
You're invoking undefined behavior. You can't expect the compiler to perform the cast for you automatically — how is it supposed to know that that's what you wanted? From the compiler's standpoint, this is all it knows about the function `printf()`: int printf(const char * restrict format, ...); That is, it's a function that takes a pointer to const char, and then an unspecified number of arguments of arbitrary type. Based only on the function signature, passing an int is syntactically valid and the compiler assumes you know what you're doing. It's semantically invalid to do that, but compilers only know syntax, not semantics.(*) It's completely up to you to make sure that the arguments match the format string; if you don't then you invoke undefined behavior and anything could happen, including seeing results that appear random. That behavior in this case is due to the default argument promotions, which means that the code inside `printf()` that sees `%f` is going to expect to read a double off the stack because all floats are promoted to doubles when passed as varargs arguments, but you only passed an `int`, which on your system is almost certainly narrower than a `double`, and so `printf()` is going to read out of bounds of the parameters on the stack, including whatever random uninitialized garbage happens to be there. But the specifics don't matter when invoking undefined behavior, because they are liable to change at any point. The main point is that all bets are off when undefined behavior is involved. (*) It is possible to add special case rules for semantics. Some compilers do implement such rules, but only for standard functions, and then only to provide warnings, not to add missing casts. You should have gotten a warning when you compiled this. If you didn't, you probably need to look into learning more about your compiler's options so that you can turn up the warning settings. The default compiler options are very rarely what you want.
The first one is all you need. Everything else is in the docs.
&gt; The size of an int is compiler dependent, whereas a float is 4 bytes exactly. The size of all types (except char types) is compiler-dependent.
&gt; more about memory management when reusing the same variable name even if the previous times you've used it you have malloc'd the memory for it and only use a pointer to it. Again, this is too vague a description to be able to give a meaningful answer. I need to see actual code to evaluate what you are doing.
You can't pass a float to a varargs function like printf. It automatically gets promoted to a double, which is usually 8 bytes. While it is implementation and platform dependent, int is probably going to be 4 bytes.
First, make sure you're using a variable of a type that supports digits after the decimal point. That means `float` or `double` (or `long double`). `int` stands for "Integer", which means it can only represent whole numbers. Second, make sure you print variables using the correct 'format specifier' to `printf`. `%d` is a format specifier that says you're passing `printf` an `int`. To print out a `float` or `double` you use `%f`, `%e`, or `%g`. [This](http://en.cppreference.com/w/c/io/fprintf) page contains a table that tells you what to use for each variable type, and what format the number will be printed in. #include &lt;stdio.h&gt; int main() { double val = 21.0 / 2.0; printf("This is a double precision floating point number: %f\n", val); }
ooohhhh ty. my problem was I was using int
Where can I learn how float and doubles are stored? I know how they're stored in integer types, but I never found anything about how they're stored in floating types. 
There are a couple ways to go about this, but the easiest algorithm is taking the largest bill (or coin) you possibly can out of the total every time until the value goes to zero. E.g. make 0.71 1. can't take out 20,10,5,1, but can take a quarter. 1q, new total 0.46 2. can still take out a quarter. 2q, new total 0.21 3. can't take out any quarters, take out a dime. 2q 1d, new total 0.11 4. can take out a dime, 2q 2d, new total 0.01 5. can't take out dimes or nickels, can take out a penny, 2q 2d 1p, new total 0.00 6. total is zero, so we exit. For US coin denominations I believe this also results in the smallest number of total objects (bills and coins). EDIT: I see you're wanting to use the modulo operation. The idea is the same except you divide instead of repeatedly subtract the largest amount out, and take the remainder using modulo as the total for the next smallest amount. I've taken the divide to be floating-point division, you can just use the floor function to get the integer part. E.g. make 0.71 1. try: 0.71 / 20 = 0.xx -&gt; skip 2. try: 0.71 / 10 = 0.xx -&gt; skip 3. try: 0.71 / 5 = 0.xx -&gt; skip 4. try: 0.71 / 1 = 0.xx -&gt; skip 5. try: 0.71 / 0.25 = 2.xx -&gt; 2q, new total = (0.71 % 0.25) = 0.21 6. try: 0.21 / 0.10 = 2.xx -&gt; 2d, new total = (0.21 % 0.10) = 0.01 7. try: 0.01 / 0.05 = 0.xx -&gt; skip 8. try: 0.01 / 0.01 = 1.00 -&gt; 1p, new total = (0.01 % 0.01) = 0.0 -&gt; done (we know we should be done at pennies anyways) I'd also highly recommend using integers and just counting cents instead (you can get into some weird representation issues with floating point -- for example 0.1 does not have a terminating representation in base 2). In fact I suspect if you actually try to code up the above example as written, you'll get some garbage when it tries to do the dimes and pennies. It might still work depending on rounding mode, but it will probably fail in some nasty way when you're not expecting it. Leave a comment or PM me if you need some help with converting this into actual C code.
Probably the best way to do this is to do the calculation using `int` to represent a whole number of cents. For example you'd represent $78.83 as 7883 cents. int amount_in_cents = 7883; int number_of_twenties = amount_in_cents / cents_per_twenty; int amount_minus_twenties = amount_in_cents % cents_per_twenty int number_of_tens = amount_minus_twenties / cents_per_ten; Then to print out an amount in terms of fractional dollars, convert to `float` just for the print operation; Don't do any of the money calculation in `float`. void print_dollar_amount(int cents) { float in_dollars = cents / 100.0f; printf("$%g", in_dollars); } printf("To make change for "); print_dollar_amount(amount_in_cents); printf(" use:\n"); printf("%d twenties\n", number_of_twenties); printf("%d tens\n", number_of_tens); printf("%d fives\n", number_of_fives); printf("%d ones\n", number_of_ones); printf("%d quarters\n", number_of_quaters); printf("%d dimes\n", number_of_dimes); printf("%d nickels\n", number_of_nickels); printf("%d pennies\n", number_of_pennies); 
Definitely agree with this, if you can't use a decimal type you should go with counting cents for dollar amounts. Floating point opens up some non-obvious headaches.
Wikipedia https://en.m.wikipedia.org/wiki/Single-precision_floating-point_format Calculator for experimentation http://www.h-schmidt.net/FloatConverter/IEEE754.html 
No problem, we've all done something similar!
In this case, yes. As long as the compiler can prove that the function has no side effects, it will hoist the call out of the loop. In the case of `strlen`, the compiler knows that it won't modify the string and has no side effects, so it optimizes the loop. However, this isn't always true! As a test, I wrote my own version of `strlen` (just a simple, basic implementation). Neither GCC nor Clang were unable to hoist this function with `-O3`. Providing `__attribute__((pure))` (so the compiler knows there's no side effects) re-enables the optimization. I'm a huge fan of writing code how you want and letting the compiler optimize it for you. But having good habits to make it more likely for the compiler to do a good job is just as important, and that's the lesson here.
As spc476 said, you'll need to decode the file format (assuming it's not a bitmap). You'll have an array of pixels (color values). Then you just get the dimensions and you'll be able to know what color is at what point in the picture by looping through the pixels.
Are you trying to have this be a GUI app, or just CLI? if CLI just take cordnates, and return the values from a bmp. Edit: Not sure why I was downvoted? is it the misspelling of coordinates?
Try the following adjustments, &gt; printf("\n%s", argv[0]); printf("%s\n", argv[0]); &gt; printf("\nCount: %d", count); printf("Count: %d\n", count);
Holy shit I'm an idiot... the extra 1 was from code further down... Let's pretend this never happened. THANK YOU!!!
I'm pretty inexperienced with programming and haven't done anything outside of classes. They definitely look useful, I'll look into them, thanks! 
The trouble is with comments and the maximum colour value. Comments offer very little and they make the format harder to parse (you don't need to think about lines tilll you get a file with comments in it), and maximum colour values greater than 255 introduce issues with byte order for binary formats, so for those files it's no longer as simple as one call to `fread` to read the entire raster. And if you need an alpha channel, the only PNM option is PAM, which is a lot harder to read than P1-P6. It isn't as simple as adding a fourth pixel value to PPM unless you break the specification. PPM is a nice compromise between compatibility and simplicity, but in my own experience plain RGB data has been much easier to work with. 
What's the problem with `getopt()`? It does the job and it does so quite well.
I guess so, I'm using it for media compression
`getopt` *is* a fancy commandline argument parser
Decode the image to an array in opencv, default will be bgr colourspace. Change to an hsv colourspace. Define your target colour as hue range (max min). Mask your image for the specific hue. Filter with a binary filter. Find largest circle region within the image (largest countour) Return the centroid of the largest region ??? OpenCV documentation is insanely good just look for the right keywords and you should be ok! Have at it! Edit: I guess I arrived too late at this party! sigh
This is the first time I've heard about \_\_attribute\_\_, I'm reading the docs now. Thanks for mentioning it! :)
I'm currently working on a large, non-trivial application in GTK+ written in straight C. The biggest advantage of GTK+ is that it can be programmed without C++. In contrast, Qt, for example, requires (to my knowledge) C++. There aren't many C toolkits still actively developed it seems. I don't mind GTK+. It can be simple, but some controls (TreeViews) can be difficult to get started with. I would suggest using it in combination with Glade until you feel comfortable manually writing your layouts. Personally, I mildly prefer the Win32 API, so bring on the downvotes!
I forgot to mention that I develop on OS X, so the Win32 API isn't available for me. :) Thanks a lot for the suggestion though!
Not really related but you should not use atoi for unsanitized input. See [this blog post](http://ramblings.implicit.net/posts/2014/4/27/c-functions-that-should-be-avoided) for why and the alternatives
It was [Subsurface](https://en.wikipedia.org/wiki/Subsurface_\(software\)), here is [a video talking about the switch](https://www.youtube.com/watch?v=ON0A1dsQOV0). I haven't watched the whole thing, but I don't think Linus is in it (still relevant though). Quote from wikipedia: &gt;"Until version 3.9.2, subsurface used GTK+ for its graphical user interface and with version 4.0, subsurface switched to Qt 4. At the LCA2014, Torvalds and Hohndel explained why they choose to re-write the GUI using Qt."
C++ is not C, pleb.
Glad I could help!
&gt; Personally, I mildly prefer the Win32 API, so bring on the downvotes! No downvotes from me, i also find the Win32 API much better. It doesn't feel like it has C++ envy (although one could say that it has a bit of smalltalk envy, but that is very contained). My biggest annoyance about GTK+ is that it is *too* verbose and if you want to do something outside of whatever GTK+ provides, it is a major PITA. I tried to make a custom text editor widget at some point and i had to mess with GTK+, Gdk, Pango and a bunch of other things in the most convoluted way possible. Having said that, what makes GTK+ annoying to use from C, allows it to be much easier to use from other languages. Lately i'm messing with Vala and using GTK+ from it feels *much* better than straight C. A project of mine right now has all the UI stuff written in Vala and the backend stuff in C. Personally i've also made [Little Forms](http://runtimelegend.com/rep/lforms/index), which is a small self-contained C toolkit. It is mostly meant for simple tools (like a game launcher - i hate those in Linux that just for showing a couple of buttons need to pull GTK+ or Qt) and i'm working on it very sporadically (as you can see from the timeline). [Here is an example of it](http://runtimelegend.com/rep/lforms/wiki?name=Examples).
Ok, I don't know what line the signal comes in on, but first you need to know what the packet looks like that your CGM sends out for your wixel to sense. If you can get your other wixel to generate a packet fitting that format that the CGM uses (it'll be a bitstream), your first wixel (provided it can already decode the packet) should just print out the packet, as in step 4.
I mean, I agree with you that bundling `strlcpy` is a good idea. But it is also now in almost every major C library, the only exceptions being glibc and msvcrt.
&gt; No downvotes from me, i also find the Win32 API much better. It doesn't feel like it has C++ envy (although one could say that it has a bit of smalltalk envy, but that is very contained). IIRC Win32 API was conceived long before MS had a decent C++ compiler. But once they had, the brought the MFC abomination.
&gt; I'm currently working on a large, non-trivial application in GTK+ written in straight C. The biggest advantage of GTK+ is that it can be programmed without C++. In contrast, Qt, for example, requires (to my knowledge) C++. There aren't many C toolkits still actively developed it seems. Have you looked at Vala language? It looks like C#, but the compiler translates it to plain C with GObject classes. Supposedly it should be really easy to write UI applications, that's what the new GNOME applications are expected to be written in. I come from embedded Linux background, and unless you work on a really stripped down firmware, there's a high chance that glib &amp; friends is already included in the image. With Vala I can easily use the lower GNOME stack (no matter what people say, glib &amp; gio is still lighter than QtCore &amp; QtNetwork combined) and still face no issues during cross compilation as the code gets translated to C and all your builds are really done with gcc. Also interfacing to C is also dead easy, as again Vala is translated to C, so all you have to write is a `vapi` file that describes the C API in Vala terms and that's not a hard thing to do. To give you an example, recently I worked on an app working on a device that's used at the film set during shots. The device is interfacing with RED Epic-X cameras via the RCP (REDLINK Command Protocol) library delivered as part of their SDK. The library is in plain C. Writing a custom `vapi` file for the library plus some test tools (to check if the bindings are correct) and glue code (ex. for conversion between obscure RCP lists to GList) to took roughly 1-2 days (that's including the time to figure out how the library works). Then the app that basically performs a camera discovery, syncs with the cameras and exposes a DBus API for controlling every camera it found took roughly 4-5 days. I strongly believe that it would not have been possible given the amount of hours spent if I attempted to write everything in C.
If you're on OSX, you're probably not going to be very happy with GTK+. GTK+ traditionally works really badly on any platform other than linux.
I agree with this. Making a good graphical user interface is hard and you generally need to iterate and change the UI many times before you get it right. Graphical user interfaces written in C tend to be very verbose (unless the toolkit is very limited) which means that making changes will be tedious and error prone. GUIs are also event driven, i.e. asynchronous, which is also not a natural programming model for C due to the lack of closures, garbage collection, actors, etc. It is possible to write GUIs in C, but you'll be happier with writing the "engine" in C and call it from tcl/tk, python, or whatever through foreign function interfaces or IPC.
Good point. The GUI event handling and rendering will not be the bottleneck of your application (unless you're doing something really weird, in which case C won't be faster anyway).
Yes. It should show up as /dev/ttyUSB0 or so. On the Windows machine, you could try the various magic file names `COM0`, `COM1`, etc. but I don't know enough Windows for that.
For example?
See our side bar.
Harvard edX CS50 class starts with C. And Zed Shaw's ["Learn C the Hard Way"](http://c.learncodethehardway.org/book/).
though old books, these are considered the "C bibles" http://www.amazon.com/The-Programming-Language-Brian-Kernighan/dp/0131103628/ http://www.amazon.com/The-Answer-Book-Solutions-Programming/dp/0131096532/ http://www.amazon.com/Standard-C-Library-P-J-Plauger/dp/0131315099/ if you look hard enough on the internet, you can find illegal PDF copies of these books
https://www.edx.org/course/introduction-computer-science-harvardx-cs50x 
&gt; The biggest advantage of GTK+ is that it can be programmed without C++. In contrast, Qt, for example, requires (to my knowledge) C++. There aren't many C toolkits still actively developed it seems. I didn't know this. How do C developers go about GUIs? Do they just use GTK or are there other options that are more common? 
The big win for me with Qt is the EGLFS backend for embedded linux devices. Being able to have nice OpenGL interfaces without X/Wayland is awesome.
Have a look at GRAPHAPP http://enchantia.com/graphapp/ open source, C, easy to use, easy to remember, try the pizza.c example.
Yep. Or even the other way round. Start with a book, and go with that till you feel the whole world caving in around you, and then take cs50. At first, it'll seem so easy, but then after a while it all gets inundating again. Go back to your books then, and heaps of stuff makes sense again. 
I guess. I remember the concepts being quite well explained in the CS50X videos, I just couldn't keep up with the psets very well until I'd had a look at some other materials. CTHW isn't great on it's own unless you're already a programmer as the concepts aren't thoroughly covered, but it's great for just looking at some code that works then working through the extra credit to figure out how to improve &amp; break it.
Can anybody recommend a compiler for mac 10.6.8? I can't upgrade at the moment, the old version of xcode I can use is horrible. Tried eclipse and it never works. Textmate allows me to compile really simple things but never really got far. It's so frustrating because I've tried learning C and C++ loads but then I try to use an IDE and they all break on 10.6.8 :(
I'm not sure what others use. On Windows, you'd use the Win32 API. On Linux or similar, you'd use GTK+. There are some lesser-known toolkits. I think these days most developers aren't strictly programming in C (they're actually using C++) or they're interfacing with a higher level language for the interface. 
If you have the snow leapord install disk, xcode is on there and should work fine.
The subsurface video is full of a lot of incorrect FUD. The summary of the project is they didn't understand Gtk and somebody extremely familiar with Qt volunteered to rewrite it. 
I have xcode (mentioned it in my post), but it's an old version that is missing a lot of stuff; v.3.2, the best version I can get with snow leopard. Also it's not a nice environment to work in for a beginner. I feel like there is a lot of unnecessary 'baggage', like it should just be a text editor.. but you actually have a huge load of crap going on instead, and the one thing you want it to do won't work properly. I'm sick of installing command lines, frameworks, libraries, using crazy macports bullshit, blah blah.... and still I can't compile hello bloody world! I've got *way* further into 'Principles and Practice Using C' with the Terminal than xcode (no joke). I'm sticking to other languages for now but I really want to learn C a lot. Guess I'll come back to it when I can upgrade my hardware.
Hmm I must be blind.... You can install gcc, a very good compiler from the command line using pre built binaries. Here is a GitHub page that can help you https://github.com/kennethreitz/osx-gcc-installer/ Under part one there is a portion for 10.6.x. If you google basic gcc usage, you should be able to compile easily. 
Do you have homebrew? Try brew install gcc5.
Find specific color where? In a single pixel, an area, a specific area? Also, what kind of image? What file type and which color range (8-bit, 10-bit, float..)?
I probably will carry on using Terminal when I have another attempt at learning C. It'll probably help in the long run being more familiar with Terminal too.
Somebody else mentioned about gcc installers. I've gone through the gcc process before, without really knowing what I was doing. I'm looking into homebrew now though, cheers for the tip.
This is so very wrong. Here are just a few of the problems. What about image headers? What about images that aren't rgb? Why the hell would you pass an image through stdin? Why are you assuming that the width and height are at the start of the file? Also, the width of a long varies from system to system but one thing is guaranteed, its going to be longer than 1 byte, so why are you reading an image byte by byte with a long? Each long is going to take way more than a byte (4 on my system). You're also reading the same data into different values of p over an over again for some reason? You're also assuming that the image has a 24-bit color depth.
Check out the `--wrap` command in [ld's man page](https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_3.html). There's an example specifically on how to interpose `malloc()`.
Yes, use the printf` family of functions. You can convert a number to a string like this: sprintf(buf, "%d", number); Make sure that `buf` is sufficiently large or better use `snprintf`: snprintf(buf, len, "%d", number); Read the manual of your implementation of the C programming language for how to use `sprintf` and friends. I'm not sure what you mean with “on PuTTY” though. PuTTY is a terminal emulator, not a platform.
~~Any reasons for the op to not also use atoi?~~ Oops just realised this function goes the other way to the ops request.
What value would I put for "buf" ?
A chunk of memory for `sprintf` to write the converted number to. `sprintf` does not allocate memory for you, you have to do that yourself. If you want a function that automatically allocates a buffer for you, use `asprintf`, but keep in mind that this is usually not very idiomatic C.
The chunk of memory /u/FUZxxl mentioned would be in the form of a `char *` [Here's a reference for functions like this](http://www.cplusplus.com/reference/cstdio/sprintf/)
&gt; I'm not sure what you mean with “on PuTTY” though. PuTTY is a terminal emulator, not a platform. Presumably they mean that they're using PuTTY to access a Linux platform from Windows, and also that they feel the need to include irrelevant details in the titles of their posts.
Go through the book "The C programming language" by Brian and Dennis. Do the exercises and don't move on until you can easily do the exercises.
It might be a violation, but it's a very common thing to do for using a custom allocator for debugging or whatever.
http://www.cplusplus.com/reference/cstdlib/itoa/ Itoa would be one possible solution. Works like atoi but the other way around.
The ``itoa`` function is not standard C and is not supported by gcc.
But yours arbitrarily creating an image format. OP makes no mention of what format he wants but none of them look like yours. A reasonable person would assume he wants to read a real image format (e.g. bmp, jpg etc.) not some arbitrary garbage.
Yes, this is how you do it. 
What part of the C standard are you referring to? Malloc is provided by the OS, not by the language. 
Section K.3.1.2, "Reserved identifiers," in the C11 standard. See also http://web.archive.org/web/20040209031039/http://oakroadsystems.com/tech/c-predef.htm. &gt; Malloc is provided by the OS, not by the language. The standard library is part of the C&amp;nbsp;language specification.
It can be done uniformly on a typical linux or unix system, which is all I care about (And what it looks like the OP is using too). And there's a compile time (Well, link time) way too if that suites your need. Yes, it's moving away from strict standard C into the host OS capabilities and features. Big deal. 
Paste the whole error message as well as the source code.
You shouldn't use atoi in general though. See [this blog post]( http://ramblings.implicit.net/posts/2014/4/27/c-functions-that-should-be-avoided) for why
From the [man pages](http://linux.die.net/man/3/fgetc): fgetc() reads the next character from stream and returns it as an unsigned char cast to an int, or EOF on end of file or error. So fgetc always returns you the next character, it doesn't care if it is a newline. You need to check for newline characters yourself.
Your friend is right, the use of signatures or magic numbers is as old as files. Put an integer at the beginning of the struct and pick a number. Some compilers support multi-character constants, so you can do header.magic = 'BHTA'; header.date = GetDate(); header.filesize = 42; write(file,&amp;header,...) When you read, look for 'BHTA' and reject files which don't start with it. 
Can you try taking all the accented characters out of your code, and creating a new standard ASCII source file? The compiler might be having issues parsing the extended character set.
I know it was common to write the struct directly in the days of DOS but is this still a good practice? I ask because the compiler may introduce padding/alignment bytes into the file as the memory representation is written. If you look at some of Microsoft's opened specifications you see this in a lot of places where there are "reserved" bytes after some members of the struct were written. Then compare this to the TDS documention which is the wire protocol used by SQL Server. Since SQL Server was largely written by Sybase and possibly used different compilers on different platforms there are less padding bytes written which would indicate that they more likely wrote the struct members out individually.
It's up to you really. Your 1^st option is to manage your struct's layout so that it is what you want - either free from padding if it is your data, or it matches whatever you need tor read if it is someone else's data. The 2^nd option is to do a set of individual reads or writes to process the header correctly. Personally I would set up my struct the right way and read/write it in 1 go, but I have no criticism of someone doing it the other way.
Here's a hint: fgets + strlen
Depends on the scope of the project. The way structs are organized varies from platform to platform so if you want stuff to work cross platform then you don't want to rely on it. Different compilers also might produce different results but if you're using the same compiler on the same platform then you might be ok just using structs. Just don't use it for some major project where you expect a lot of people to be using it and will be building from source.
"reserved" bytes are not necessarily just padding. Often when the layout needs to be compatible across versions of a format or API the original structures will be defined with space that can be used later for new features without changing the layout. Another example of this sort of thing is functions that take extra parameters that always just take NULL or 0. Later versions of the API can add new functionality to be controlled by passing new values to those parameters. 
Do something more like, while not at end of file, while not '/n', increment a counter, print result of counter. When i'm not on mobile I can give way more detail if you wish. 
You don't have a function called "main". You have to have one in C. That's the entry point to your program. int main( void ) { // do stuff here... return 0; } 
Holy shit, it works :D Thank you so much, I still have a long ways to go yet, but at least I have something that works!
% is not part of the allowed operators in the assignment. How could one go about finding out if it's odd? Otherwise it would indeed be simply: int bitCount(int c){ int counter = 0; while (c){ counter += c%2; c = c &gt;&gt; 1; } return counter; } 
Oh. right :) I guess I need some bitwise operator practise as well! Out of curiosity, is &amp;1 faster than %2?
Every compiler I've ever used turns the latter into the former. 
If you want to print the entire file just call fgetc(file_descriptor) inside a while loop with !feof(file_descriptor) inside the parentheses. Maybe you forgot to associate your file name argument to a file descriptor? For example if you called your program like this: ./a.out filename.txt you should then use FILE *fd = fopen(argv[1], "r"); Other than that I can't know your problem without seeing the code. Also irrelevant question: How do I format code inside the comment, so that I don't have to put newlines inbetween?
Are you sure you are getting the filename in argv[2]? Try printing the argument you get in it to see if it is correct, and also try your program by hardcoding the filename to see if the rest of the code works.
The [bit twiddling hacks](http://graphics.stanford.edu/~seander/bithacks.html) page lists seven different bit counting methods along with a dozen or so other bit manipulation patterns. I'll discourage you from looking until you are done with your assignment as what you see can not be unseen and most is so obscure it will be clear where it came from. It's also pretty light on any explanation of how they work.
I'm assuming you don't know about `while` yet? Try reading up on that, you normally create infinite loops, or rather loops that continue until some condition happens. Just search for "C while loop".
Without further specification / context it is hard to help you. A few questions: * Do you need to calculate the average, minimum and maximum of all numbers that have been entered so far or just some of them? * Shall this program be able to run forever? * Do you know anything about the range of the numbers you will get? * What do you need this calculation for? * Is an output required? * Why would you program this yourself when there are very likely usable libraries out there?
Sum things in the for() loop with sum += a + b + c 
How does the data come in? User input? File?
However now I need help on this one lol, it just hangs after asking the first printf question #include &lt;stdio.h&gt; #include &lt;math.h&gt; int main(void) { int a, b, c, d, e, f, g, h, i, j, k, l, m; int t; int sum; int checkSum; t = 0; while (t &lt; 20) t = t + 1; printf("Enter a 13-digit ISBN code: "); scanf_s("%d%d%d%d%d%d%d%d%d%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d, &amp;e, &amp;f, &amp;g, &amp;h, &amp;i, &amp;j, &amp;k, &amp;l, &amp;m); a = a * 1; b = b * 3; c = c * 1; d = d * 3; e = e * 1; f = f * 3; g = g * 1; h = h * 3; i = i * 1; j = j * 3; k = k * 1; l = l * 3; sum = a + b + c + d + e + f + g + h + i + j + k + l; checkSum = sum % 10; if (10 - (checkSum % 10) == checkSum) printf("10 - (%d%%10) = %d. This is a valid ISBN code.", sum, checkSum); if (10 - (checkSum % 10) != checkSum) printf("10 = (%d%%10) = %d. This is not a valid ISBN code.", sum, checkSum); return(0); } 
You can use Qt. It's a cross-platform framework with a lot of Gui objects. It's pretty mature and has widespread use. 
Just search for win API Maybe along with the word tutorial 
What you need is the Petzold book. http://www.amazon.com/Programming-Windows®-Edition-Developer-Reference/dp/157231995X This will teach you Windows GUI C.
Qt is C++. The C bindings haven't been maintained.
Oh, yeah. Wrong sub. 
Stackoverflow usually has incredibly helpful and complete answers for many of my programming issues.
Please put four blanks in front of every line so your code comes out readable.
Qt is not usable with C and if OP wants to do programming for Windows, then he should do so.
I would do it if I knew how to . And I cant run the code right now
Most of these are still true, except for 3, 4 (doesn't apply any more) and 9 (modern linkers are better than that). `lint` is replaced by compiler options like `-Wall` today but the point of using these is still valid.
I think those ones caught my eye when I took a skim through it, but apparently it was published in 1989, so I was only off by one year! [source](https://groups.google.com/forum/#!msg/comp.lang.c/Fd-1I277Sp0/3dVotG6_MV4J) I remember running splint years ago on my earlier work, and along with warning flags and memcheck, it helped me clean up my source code. It's definitely worth trying those.
`NULL` is defined to be either `0` or `(void*)0`. The standard does not specify if the representation of the NULL pointer has to be all bits zero, but an integer constant 0 converted into a pointer has to become a `NULL` pointer.
Excellent. Thank you!
Number 3 applies to functions without a prototype. If you call a prototyped function, all arguments are implicitly converted to the parameters types. This does not apply to unprototyped functions or for variable arguments. Until the mid 90s, many platforms did not prototype standard library functions and many didn't even provide or provided declarations for the functions where they could be left out (i.e. functions returning `int` whose arguments follow K&amp;R rules). Thus rule 4 advises you to declare these functions on your own and rule 3 advises you to convert arguments correctly for functions without prototypes. Modern C implementations supply prototypes for all standard library functions so following rule 3 is not necessary any more and might even hide warnings (if you cast an incompatible pointer type to be compatible, the compiler will usually take this as a hint not to emit any warning). Rule 4 is not necessary for the same reason.
We can't help you if you don't show us your code. This doesn't sound like a very complex system -- you just described it in three sentences; where's the boilerplate suddenly coming from? Either strip it down to just the relevant parts or throw the whole thing into pastebin and send us a link.
&gt; Number 3 applies to functions without a prototype. It applies to functions with them as well though, even if it's less of an issue there. &gt; Modern C implementations supply prototypes for all standard library functions so following rule 3 is not necessary any more and might even hide warnings (if you cast an incompatible pointer type to be compatible, the compiler will usually take this as a hint not to emit any warning). Rule 4 is not necessary for the same reason. And that only applies to functions in the standard library.
C# is more like java than C. I think you're in the wrong sub.
I use mingw on Windows and gcc on Linux. This will compile c and c++.
Windows **is** a standard library for making GUI's :) Everything you need to make rich and wonderful GUI's in Windows is built directly into the OS, which is why Windows programs all look and function very similar. Check out the MSDN for near-infinite tutorials and code examples for programming GUI programs in Windows (in C).
Your macro is on one line which effectively fixes the problem. You could also write #define IS_EMPTY(val) \ ((val.a == 0) &amp;&amp; (val.b == 0))
According to K&amp;amp;R, for OP's code, the lines #define IS_EMPTY(val) ((val.a == 0) &amp;&amp; (val.b == 0)) are a macro, that ends with a newline, then the boolean expression ```((val.a == 0) &amp;amp;&amp;amp; (val.b == 0))``` which the compiler will never hit as an error because the compile fails at preprocessing. Instead it should be #define IS_EMPTY(val) \ ((val.a == 0) &amp;&amp; (val.b == 0)) which is a spliced or multiline macro.
No, the code is not on the stack. The stack is used for the local variables, parameters to functions, and other housekeeping stuff. The text of your C source doesn't exist anywhere in your program. The compiler converts the text into your executable (the .exe file since you're on Windows).
No, the code isn't on the stack. Once compiled, the executable version of your code is placed elsewhere in the address space (I won't go into details here). Unless you're on an embedded system with very limited room for code, it's very rare for the number of lines of code to cause any headaches.
No, code does not live on the stack. In fact one common security measure is to mark the permissions of the stack so that the memory region is non-executable, which stops common vulnerabilities such as stack overflow exploits. But the link you posted to answers your question; the very first bullet point is labeled "Static code and data - this is all the compiled code plus all static data."
Thanks.
Thanks.
Thanks. Memory management is still a bit of a mystery for me and some of the language on the link I provided is beyond my ability to currently understand. I appreciate your time.
&gt; i cannot get it to work In what way is it not working? "It doesn't work" is not a helpful description of the problem. http://meta.stackexchange.com/questions/147616/what-do-you-mean-it-doesnt-work
You need to `#include &lt;stdio.h&gt;` if you are going to use the functions declared in that header, such as `printf` and `scanf`.
If you are using windows you can also get Visual Studio Express for free. I haven't programmed in Windows in a long time so I can't really comment on this, but last I used it, it was pretty good. Seemed better for the .NET languages though. On Linux I've used CLion from Jetbrains, it's free for students but costs money otherwise. However, most of the time I just use vim.
Thou shall ship the fucking product on time, because the CEO doesn't give a shit about your silly rules.
No it is not different for microcontrollers.
They may have a separate instruction memory, which can be either mapped on the data memory space (ARM) or a different memory space (AVR).
So, what is your approach ? Algorithm ?
Yeah pretty much both the strings are taken from the terminal. One is a longer text file that I store in a string and print out once it reaches a newline character in which case it prints it (I can use this string to I guess iterate over) then it is cleared and reused for the next line until EOF. The other is a word or a string of words that stays constant throughout.
And `s` is not a common substring? Please define “common substring.”
it is but because it is a part of a bigger substring I left it out. if there were no common letters left or right of the s it would be a substring. basically it is longest common substring. 
Why not just read the letters into an array and then compare if they are equal. I am newbie so if I am off base sorry.
Is this a homework assignment?
It's just kind of an obscure way to do it, imo. The only thing can you really do w/ a typedef is make it a custom type, but you still have to initialize it somewhere. typedef struct { int a; int b; } foobar; int main() { foobar myfoo; Don't get me wrong, if you looked at the headers &amp; disassembly of both versions they'd probably be identical. It's just that in cases where something like this is more likely to be useful (with larger software projects), those are also the cases where having more readable code is likely to be a good thing. Anyone who sees "struct foobar myfoo" knows right away what it is. I don't think typedefs are evil or anything, just a little overused.
yes however the question I posted is not the assignment, it is part of a much larger solution. Heck I don't even need to print out the substrings, but I'm being as vague as possible as I want ideas and ways to go about it rather than solutions to it
What I mean is, what is your idea/approach/algorithm that would solve what you are trying to achieve ? Simply think about it, no need to program it for now. Use a pencil and a piece of paper and try it out with two very short strings. Once you have found the solution, it is time to program it and test it. You can start with a naive/brute idea. Given two strings A &amp; B: 1. List all substrings of A 2. List all substrings of B 3. Compare every combination of substring A and substring B. 
You would benefit from familiarizing yourself with the concept of "virtual memory" and "address spaces". Here's a good link which begins to introduce virtual memory: http://pages.cs.wisc.edu/~remzi/OSTEP/vm-intro.pdf In particular, learning about virtual memory typically also means learning about "segmentation" (which is the different "types" of memory that process has). If you read the PDF that I linked and are interested in more reading material, see the virtual memory section here: https://www.student.cs.uwaterloo.ca/~cs350/F15/reading.html
But what about function pointers?
here's one approach you could take: #include &lt;stdio.h&gt; /* fancy version of strstr */ int main() { int i, j, k; size_t size_string1, size_string2; int limit = 0; int matched = 0; // current matched characters const char string1[] = "basdvdad"; const char string2[] = "bsdvdzd"; size_string1 = sizeof(string1) / sizeof(char) - 1; size_string2 = sizeof(string2) / sizeof(char) - 1; limit = size_string2; printf("string1 \"%s\" is %d chars.\n", string1, (int) size_string1); printf("string2 \"%s\" is %d chars.\n\n", string2, (int) size_string2); printf("matches\n=======\n"); char cstring[limit+1]; for (j=0; j&lt;size_string2; j++) { for (i=0; i&lt;size_string1; i++) { matched = 0; while (string2[j+matched] == string1[i+matched]) { cstring[matched] = string2[j+matched]; matched++; } if (matched&gt;0) { j+=(matched-1); i+=(matched-1); for (k=0; k&lt;matched; k++) putc(cstring[k], stdout); printf("\n"); break; } } } return 0; } 
Thanks.
You didn't specify a level of skill, but given that it's a beginning c class I'm going to assume you're relatively new to programming. Unfortunately, it's not trivial to handle user input for this purpose. To do that, you'd need a [parser](https://en.m.wikipedia.org/wiki/Parsing) - recursive descent would be quite a nice fit for this language. A parser will take the user input and turn it into a parse tree. Once you have a parser, you'd need an `eval(parse_tree tree, int at)` function to evaluate the function for an x. 
See one I have been working on: [calc](https://github.com/scoult3r/clc)
It's NOT the end of the world if a C compiler doesn't support C11, especially for newbies learning the basics of the C language. I work with many processor families, so I try to avoid newer features as much as possible until a higher percentage of embedded compilers are C11 compliant. 
Yea, I think most newbies wouldn't use the C11 features, but continued development and support is still something to keep in mind before settling down with an environment. I think part of learning how to be productive in a language is also learning the tools around it. It's not that hard to learn new tools, but your productivity suffers while you do so. The tools are constantly changing of course, but Visual Studio should at least be somewhat similar to previous versions. That said, it seems that the debugger is superior in your experience to the other stuff that's out there, so maybe it's worth learning even if you have to switch down the line. I've never used it so I couldn't compare, but I will say that gdb is pretty painful to learn as a newbie. Which other processors do you work with besides ARM? Outside of x86/x86_64 I've mostly used 8-bit PICs, which don't seem to have very compliant compilers (they usually generate decent enough binaries, but it's a crapshoot as to the features they support). They're also simple enough that it isn't horrible to code for them in assembly. Anyways, upvote from me for the recommendation for something different, feel free to PM me if you want to keep talking, I feel like we are polluting this thread with advice which may or may not be useful to the OP.
That's pretty neat. I have a hard enough time keeping track of the differences between the 8 bit and 16 bit PICs whenever I have to do anything substantial (I have to constantly look at the datasheets), I can't imagine working with so many different processors. I guess that's one of the reasons we have C though, it abstracts away a lot of minutiae.
Thanks for the reply. I've never used "r+" or "w+". Is there anything I need to be aware of when using them? For example, If i use putc() in a "w+" file until "EOF" and then use rewind() to go back to the beginning and use getc() in the same file, will I run into any problems like overwriting data?
The C programming language does not provide functionality to compile and evalute functions at runtime. You need to write such functionality yourself. You could also consider binding to lua for this task, it should fit your requirements but I haven't used lua enough to be sure.
Hey dude. Get the Wixels talking to each other?
Well, sort of. I modified the main() of the original wixel program like so: http://ideone.com/CG63su. It's down near the bottom. The documentation on the radio* functions is in the [Wixel SDK.](http://pololu.github.io/wixel-sdk/radio__queue_8h.html#a94f52371368a91104b3a22d8dafee7bf) They do talk, but I'd like to have more realistic data sent through. I raised an issue on the [dev's github](https://github.com/StephenBlackWasAlreadyTaken/wixel-xDrip/issues) asking what realistic values are, but no response yet. I'm most interested in what the values of raw are, but reversing dex_num_decoder() has proven difficult.
LV has support for this kind of stuff. See: RK4 VI's. They use parsers + reverse polish notation to turn a function (as a string) into a numerical solution for that function over a specified interval.
This is wrong. You can very much have a problem with them if you don't read up on what they do: ``w+'' Open for reading and writing. The file is created if it does not exist, otherwise it is truncated. The stream is positioned at the beginning of the file.
&gt; or use freopen() to have the old one closed as the new file is opened [A word of warning](http://www.cplusplus.com/reference/cstdio/freopen/): '*"w+" write/update: Create an* **empty file** *and open it for update (both for input and output).* **If a file with the same name already exists its contents are discarded and the file is treated as a new empty file**.' If its just a scratch file then this shouldn't be a problem, but this is *not* the same as an append.
I explicitly mentioned `freopen()` in my answer, and it is not changing the mode for a open file, it's closing the file and then opening it *again*.
`freopen()` was another alternative other than using the proper mode, not to use both at the same time.
&gt; swprintf_s(diskNumberName, (size_t)numOfDigits, L"ld", diskOne.DiskNumber); Shouldn't that`L"ld"` be `L"%ld"` ? Also, somewhere deep in the Windows headers is a macro `_countof()` which you can give an array and it tells you the length of the array rather than the size in bytes (like `sizeof` does).
On an additional note, when working with strings setting the first character to the null character is enough, since the purpose of it is to determine the end of the string. So you can do: array[0] = '\0'; or using the standard library functions strcpy(array, ""); Of course this only works for strings, these are special kinds of arrays in C. 
Wouldn't Strlen(array) not do what likely is desired, why end at end of c string and not entire array? If we were maintaining c strings, setting only the zeroth element to null would suffice anyways. Need to keep track of allocation size of array.
In addition to what others have said, void clear_array(char array[]) is exactly the same as void clear_array(char *array) Also, clear_array(some_array); is passing a pointer to the 1. element of some_array, so it's exactly the same as clear_array(&amp;some_array[0]); 
Thanks.
Do you need the clear function for a specific reason, or could you use memset or bzero instead? I'm going to go against the grain and say a magic number is best if you do, but I would use a #define for that so it propagates.
You can't get the size of an array passed to a function without providing it to them. A pointer to the first element is what is passed. It's just like any other pointer to that type, in that it maintains no knowledge of what it points to beyond what type it is and where it is. char foo( char *p ) { ... what size? } ... int main( void ) { char c, a[10]; foo( &amp;c ); for( a ); return 0; } foo sees no difference in what arrives to it between those two function calls. Either way, it points to a single character.
Yes, that is /u/j__h's point.
I think I replied to the wrong guy. Oh well.
When is the length of the string equal to the length of the containing array?
This looks cool! I suggest you to use a [github gist](http://gist.github.com) to share single source code files though, as Google drive doesn't have syntax highlighting.
I sometimes use (upper?) camel case for type names. It's more the long names and encoding the type into the identifier I find overwhelming. (19 characters for a local variable!) I'm planning on attending university next year and I'm not sure what to expect, heh. 
I agree that names should not be too long. However [naming is a process](http://arlobelshee.com/good-naming-is-a-process-not-a-single-step/) and mostly I prefer to know what a variable represents when I have to understand other peoples code.
It's totally fine! And your code looks good, too.
Camel case is harder to read for me than snake case. Snake case just reads like word_separated_by_underscores, whereas camel case requiesEffortToRead and has ambiguity issues when parts of the name are acronyms or when you write in languages where capitalization carries a semantic meaning (such as German).
Because the character&amp;nbsp;`'5'` is not the same as the integer&amp;nbsp;`5`. In the most commonly used character sets, the character&amp;nbsp;`'5'` has an integer value of&amp;nbsp;53. The `%d`&amp;nbsp;specifier for `printf` indicates that you want to print an `int`. If you want to print a `char`, then use&amp;nbsp;`%c`.
If I read it correctly, you have the following to read: M 1986/01/01 petem@xyz.net Pete Moss 123 Boggy Lane,New Orleans,LA,70112 H100.15005 2 H222.15005 2 H200.15010 2 H333.15010 2 So first char is customer.cGender customer.cGender=buffer[0] ; You know DOB starts from buffer[2] and length is 10 strncpy( temp , buffer+2 , 10); strcpy(customer.szBirthDt , temp ); Next problem , where is the space betweeen email and name i=12; while( buffer[i] !=' ') i++; strncpy( temp , buffer+12 , i ); strcpy(customer.szEmailAddr , temp); Copy the rest of buffer to get customer.szFullName. Second line, you find the position of each comma. Third line you can use sscanf or find the space to split. If the first part contains "END" you reset to read again.
Yeah it's kind of cool that it gives a hint of the intent. Just wondering how common it is. 
You have a valid point here. However this readability comes at the cost of lengthening the variable name itself. For rather short (and hopefully equally meaningful) variable names this is not an issue. But since the naming process usually undergoes the "honest and complete" stage the names can become very long. In this case I prefer camelCase.
Thank you for fixing your post.
Ah, if you use imperial units, multiply with 703.07, so the formula 703.07 × *weight* ÷ *height*². This differs from your formula in that it's *height*² instead of 2 × *height.* Where are you stuck with respect to turning this formula into C code?
Thanks, that seemed to work.
That's what compilers are for. The programmer writes code that produces the desired observable behaviour, and the compiler outputs assembly instructions based on the target platform , optimization level, and other switches. If a compiler generates assembly that "wastes cycles" then report a compiler bug. 
I appreciate the comment. The point of the ^ part was that I was trying to do the square root of a function, but I was told that the sqrt() option wasn't as effective as simply doing ^(1/2).
 ^ Is the XOR operator. Any time you use it in C, it computed the XOR of the values on either side and returns that as the result. To compute powers ( including square roots ), you have to use a function call. You can look at math.h, or google it. I've already told you the answer though - it's pow(). There may be specialized functions just for square roots. That's up to you to figure out. Also, ( 1/2 ) in C will most likely return 0. Both values are integers, and the result of any division of two integers is rounded down. 
You should look at the man page for 'abs'. Can you find another function that does the same thing but works with floating point numbers? Also, check your parentheses. One of your pow calls is messed up. 
`sprintf`
Your post is an unreadable mess. Indent every line of your code with four spaces so that Reddit formats it properly as code.
given we haven't covered that in our class... is there another way?
What's it doing wrong? You need to detail the problem exactly before we can help you. Nobody wants to crawl through a source code dump. Tell us what's going wrong - as much troubleshooting as you've managed.
Your declaration and definition of loadBookName are different. char** and char[55][128] are not equivalent.
if I specify the filename as books.txt it gives garbage. 
this is what I got once I changed that: http://imgur.com/vbNt1k4
Can you go over why you used `strtok()`? it seems unnecessary for parse logic this trivial.
it is required by the specification
I think I got it: change the format specifiers in your `printf()` calls from `"%c"` to `"%s"`. The former prints a single character - you're passing a pointer, which it interprets as a character (hence the weird output). The latter specifies a string, which you're actually passing as a parameter. Make the change and tell me what happens.
Writing `char msg[] = "foobar";` allows you to use `sizeof(msg)` to get the size of the string later. No need to count characters with `strlen()`.
I typically avoid using an array as a function parameter. In fact, when I'm teaching introductory C tips, I present it as an anti-pattern. It can lull you into thinking that you have "real" array inside the function, when you really don't. 99 times out of 100, this doesn't matter, and you can get away with using arrays and pointers interchangeably. But consider the following: void foo(int array[]) { printf("%d\n", (int)sizeof(array)); } int main(int argc, char** argv) { int array[10]; printf("%d\n", (int)sizeof(array)); foo(array); } In this example, main will most likely print 40, whereas foo will most likely print 4, as array is implicitly converted to a pointer.
So, your teacher gave you all of this code, and asked you to fill in the blanks, but you want us to do it for you instead? You'll go far, kid. You'll go far.
No idea. It's the Dexcom G4, I don't think they publish a data sheet. 
definitely there needs to be a rule about putting your explanation in the title, so people can see immediately if they can help, and to show that the poster has actually tried to solve the problem and isnt just lazy its pretty contemptuous to expect some random people to do your homework for you
i see, char** is an array of point to char*, so you have an address that point to a list of address. with char[][] you only need one address as "entry point" because the size of the array is know and the starting position of a row can be calculated at compile time as offset form the first cell. (btw the example compile without cast, it just give a warning to me, i use "gcc -std=c11 -Wall -Wextra test.c")
You should give the parameters meaningful names instead of `par1`, `par2` etc. The error enum should be defined in the header file, because someone using your API would need it to determine what error happened. It might be a better convention to return 0 instead of 1 on success from `stack_init`, `stack_push` etc.
If downvoted, I'd love some feedback as to why. Always good to learn and improve :)
Expanding on the `enum` point: use the type you've created. Currently you return your error codes via `int`, instead return a `stack_error_codes` value. Makes it more explicit what you're returning. C type system means it's treated like an `int`, but it provides something slightly more trustworthy than a comment. If you're going to be returning 1 for true and 0 for false, try importing `&lt;stdbool.h&gt;` and using `bool`, `true`, and `false` (if you're using a late enough version of C), if not, maybe stick to 0 for 'success' and non-zero for 'error'.
Hm... Can't really use stdbool.h because my school's compiler is kinda old, so I have to make is as backward compatible as possible. And my reason to return 1 when successful is so that I can write if (foo() ) bar(); Especially on boolean functions. Should I change it to return 0 instead and manually write the check? Because it would be really weird to write if (!foo()) bar(); To check if foo() is true (different than 0).
Fair enough. The `0 == success` idiom is rife in the C standard library. I personally am not a fan of it. My personal usage is along the lines of the following:- * If you're returning an error code, make it a typed enum and make the first entry (0) represent success. * If you're logically returning a true/false value (like `isEmpty()`) then return 1 for true and 0 for false. Since you can't pull in `stdbool.h`, and your program is probably pretty stand-alone, I'd suggest you follow [one of the suggestions in this StackOverflow post](http://stackoverflow.com/questions/1921539/using-boolean-values-in-c). I'd go for option 3, typedef enum { false, true } bool; but using `#define`s seems more common in code I've seen. If you were working on an existing project you'd obviously use whatever that project uses.
&gt; if (!foo()) &gt; bar(); I agree that's weird, personally I always write it like this: if (foo() == 0) bar(); Or better, check for errors instead of success: if (foo() != 0) { /* handle error */ } bar();
Careful - The ideas on that StackOverflow post are not equivalent, though they appear to be. &lt;stdbool.h&gt; is different then just defining 'true' and 'false' and typedef'ing the 'bool' type. If you can't use &lt;stdbool.h&gt;, then you're better off not using a 'bool' type and using 'int' along with zero and one to make your intentions clear.
Okay. I did some changes to the code. I altered the return types, moved the enum to the header and made it reflect the "0 is success" standard. I guess that my implementation is good, since the whole discussion of this post was about my return types. XD 
This is an incredibly common problem, and I'm shocked that the language hasn't developed *something* to help. Unfortunately, there really isn't anything yet. One option is to write a tool to generate the code for you. This is the most complex solution, of course, but it's absolutely robust. A simpler solution is to write test code (run during the compilation process if you don't already have a unit testing mechanism). Maybe a switch statement for each command that asserts that the right entry is in the right place in the table. It's yet another place to update when you change things, but the compiler can warn you if you don't include everything in an enum inside a switch, and you'll know if you have a mismatch somewhere. The last option I see is to ditch the enum altogether. Use the command string (i.e. "Run") everywhere instead, with a function that hashes and translates to the right entry for you. Basically, you'd be making this into a hash map. This introduces a whole other set of problems, though.
no, do { ... } while (0); is a common pattern for MACROS. look it up on google. Its very important that you know why this is so.
In **stack_push**. When you second allocation fails (the larger one), you will leak memory. Plus you return the same error code both times. Its not clear which call failed. Reference: stack_error_code stack_push(stack_t* par1, void* par2) { if (!par1) return STACK_IS_NULL; struct stack_node_t* temp = malloc(sizeof *temp); if (!temp) return STACK_FAILED_TO_ALLOCATE_MEMORY; temp-&gt;data = malloc(par1-&gt;elemSize); if (!temp-&gt;data) return STACK_FAILED_TO_ALLOCATE_MEMORY; Second, in **stack_init**. You allocate your stack ptr on the free store. But is this necessary? You could also let the user decide what he wants. Reference: stack_error_code stack_init(stack_t** par1, size_t par2) { stack_t* temp = malloc(sizeof *temp); if (!temp) return STACK_FAILED_TO_ALLOCATE_MEMORY; That can easily be done by just making the first argument a ptr and assuming that a valid stack is passed. That way I could do struct stack_t s; if (stack_init(&amp;s, 1000) == 0) { do_stuff_with_stack(&amp;s); } // no need for free Btw. You do struct stack_t { make that typedef struct { ... } stack_t; then you don't have to write struct all the time. Second, your argument names are terrible. par1, par2.. wtf?
How are you calling it? And that isn't calculating the power, it is squaring `x` `y` times.
It's working fine for me (well, it's giving the wrong answer, but it runs). Post the function you're calling this from, and your command-line input/output