It's not a good idea to rely on static initialization of pointers anyway, since using a pointer's value is UB unless it's NULL or it points to a valid address (the end of an object also being a valid address). Always initialize your pointers explicitly, at declaration time if possible - or as fast as possible after declaration. &amp;#x200B; That said, NULL isn't required to be 0 by the C standard, but it *is* required to be 0 by POSIX: see [the NULL spec in stddef.h](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stddef.h.html). So if you're writing C for Unix-like systems, you can use the `if (!p)` idiom to test that a pointer is not NULL, and it's guaranteed to work.
This is really more a Unix question than a C question. The concepts you need to grasp here are not specific to C; but they're part of how Unix works (and here, specifically, sockets). You need to find yourself a good primer on socket programming - which you should have done before starting to write your server ;-) Other comments have already linked online tutorials, but if you want the real meat and potatoes of how to do things, these are the books you need: **Advanced Programming in the UNIX Environment** and **UNIX Network Programming** by W. Richard Stevens. If you don't mind your code being Linux-specific, you can get away with **The Linux Programming Interface**, by M. Kerrisk, instead - but I still recommend to read the Stevens books as soon as you're able. &amp;#x200B; Happy hacking!
Memory management (which string management is just a common instance of) is, to be frank, one of the most difficult parts of C, and it's *very, very easy* to get wrong; this is usually what does beginners and students in, and even when you're an experienced C programmer, it's easily *the* major PITA of any C project. My advice is to always do *as little memory management as possible*, to minimize the pain. So, for instance: if you need to use a string to store information, and you have a good idea of what a reasonable maximum size for that information is and it's not millions of characters long, use static allocation with an array of char. You could probably use 256 or 512 bytes for the name, and 8 or 16 bytes for the grade, unless you are also using this field to store a comment, in which case 1024 to 4096 bytes sound more appropriate. Also, if you have to store pointers, don't use `strdup` unless you *know* it's necessary. And surprising as it may seem, it's very rarely necessary. For instance, instead of newcourse-&gt;letterGrade = strdup(grade) ; you should wonder whether, instead, you can't just write newcourse-&gt;letterGrade = grade ; You'll probably find that most of the time, you *can*. The important question is, what is the lifetime of the contents of *grade* ? And most of the time, you'll find that those contents are already stored in a safe place and they're not going to disappear under your feet. The only case where you need to `strdup` grade is when you know the pointer will (or has the possibility to) become invalid before your Course object will. For instance, if the contents of `grade` are stored on the stack in the function that calls your Course initializer (in which case they will disappear as soon as that function exits); or if they're stored in a temporary buffer that gets reused after the call to your Course initializer. etc. etc. This is exactly the kind of question you should ask yourself constantly when you're writing C. This is what makes C difficult at first. But don't worry, you can get the hang of it pretty quickly. To avoid most headaches and code nightmares, a good rule of thumb is: *the function that creates an object is responsible for its storage; other functions that use that object should not have to worry about storage.* &amp;#x200B; Good luck and happy hacking!
That depends on the program and the operating system. It's also not a C question.
Virtually every game you see advertised is written in C/C++ so yes.
u/mitsuhiko 's suggestions are quite nice: http://lucumr.pocoo.org/2013/8/18/beautiful-native-libraries/
Conforming implementations are required to set uninitialized pointers of static duration are guaranteed to be initialized to null, no matter how much that costs, and no matter whether is serves any useful purpose in any particular application.
Check out cppUTest, test cases are written in C++ but you really don't need to now C++, just C. The class system makes it easy to write test groups. 
Check out [Unity](https://github.com/ThrowTheSwitch/Unity). This is the library [Exercism](https://github.com/exercism/c) uses and, from my experience, it _just works_.
Unity isnt C though...
Yes. And with any compiler worth its salt, the cost will be zero.
The “if (!p)” construct works whether or not NULL is actually 0x0000, when if is used with a pointer argument it is compared against the constant 0, which represents NULL, not the literal 0x0000
The engine itself was written in C. The editing and design tool, Doom Ed, was written in Objective C. 
I'm using criterion and I really recommend it :) https://github.com/Snaipe/Criterion
Please explain what you think "the constant 0" means. :-)
[The literal 0 has a different meaning based on its context](https://stackoverflow.com/questions/1296843/what-is-the-difference-between-null-0-and-0)
You can use Google's gtest framework.
This is a great library. Like it's says, "just works"
for completeness, no one has mentioned [check](https://libcheck.github.io/check/) - it's old, simple, and works with autotools. gets the job done.
Cmoka is a pretty famous one. But I recommend Unity as the nice gentleman before me suggested.
I agree with all of that too. These kinds of games are historically significant and are very much worth study for those interested. I can definitely understand why you took: &gt; Is it possible to create a game with just c? at face value, but I hope you can understand why I took it to mean "I've only seen C++ tutorials floating around, does this mean C is a bad choice for modern game dev?"
For basic stuff I use the ones provided by cmake. Otherwise, unity
Can I suggest you [µnit](https://nemequ.github.io/munit/#)? It elegent, has nice debug output and measure the code performance.
Awesome dude! Thanks for the material. Will definitely go through some of those. 
Yeah, absolutely after I saw your reply.
I just looked briefly at the proposal. Adding a new concept is good, but I don't think he fixed the definition of "object" to make clear that every object has a definite type; I also didn't notice any clarification about storage containing many overlapping objects simultaneously, but I would regard that as also being very important. Further, I think "storage instance" sounds a bit too much like object and would perhaps favor "Disjoint Region of Storage" to make clearer that (1) the term is referring only to the storage, and (2) unlike the term "object", the storage identified thereby will not be shared with anything else. The choice of words, however, is not as important as clarity about what concepts are included or excluded. A few more concepts that could help avoid ambiguity: the verb *to resolve an expression*, and the noun *lref*, At present, given an expression like `somePtr *p = &amp;arrayOfAggregate[foo()].member;`, the Standard doesn't have a good term to describe what is done with lvalue `arrayOfAggregate[foo()]` nor to describe the thing acted upon by the `.member` operator, nor the result of such action. Although the *expression* is clearly an lvalue, operators don't act upon expressions. If the call to `foo` performed while the compiler was doing whatever it does with that lvalue yielded 3, then the `.member` operator should be invoked upon `arrayOfAggregate[3]`, but there's no term to describe that. I would thus suggest defining the term *lref* to refer to a compiler-internal value that holds enough whatever information a compiler needs to identify an object. For objects whose current value is stored in memory, an lref would encapsulate an address and a type, but for objects stored e.g. in statically-assigned registers, lrefs may contain other information which is tracked by the compiler. Pointers encapsulate lrefs. Evaluation of an expression will cause any lvalues within it that are not operands of `sizeof` to be *resolved*, yielding *lrefs*. Given something like `fetchThing(&amp;someUnion.member)`; the evaluation of `&amp;someUnion.member` should be recognized as doing something to actively associate the created pointer with the union object within the calling context. At present, however, the Standard has no terminology to describe such a thing.
The first loop starts at 32 and ends at 1, the second starts at 31 and ends at 0.
The cost would be dependent upon the execution platform. If an execution platform would require that floating-point zeroes have the bit pattern {128,0,0,0}, and does not provide any means by which allow compilation can include functions that will be run before `main`, it may be impossible for the compiler to process the execution unit: struct { float f; char zeroes[1000000]; } q; without forcing the linker to include within the executable a byte containing nthe value 128, followed by 1,000,003 zeroes. I would regard the extra 1,000,000+ bytes of executable as a non-zero cost, but if code wouldn't have cared whether `q.f` was initially zero I would blame the cost on the mandate that the compiler provide for the needless initialization. 
I second looking into this. I use it with my C++ projects (as do many companies, I've seen), though from what I've read it is just as effective for C.
I think most frameworks are overblown. For many projects, I just make my own tests.c file and use asserts to signal failure. 90% of the effort in unit testing is creating good test cases. Once you have done that, it's trivial to add them to a call list manually. 
Also, I hope `i` is a signed integer for the second, or it becomes an infinite loop.
If I have a set of code that goes like this on each loop: binary = 1&gt;&gt;i; if(binary &amp; 1) { printf("1"); } else { printf("0"); } The i that starts with 32 will print 1000000000000000000000000000000 and the i that starts with 31 will print the correct binary interpretation of 1 which is 000000000000000000000000000001 Why is it different?
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
This subreddit is about programming in C. How is your FAQ related to programming in C?
Well in your second case the 1 at the end is because you're comparing a 1 with a 1 that is right shifted by 0 (i.e. 1&gt;&gt;0) so of course they'll be the same. There's no 1 at the end of the first case because the loop stops before 1&gt;&gt;0 is computed. In the first case at a guess it is because you are right shifting by more than the width of the type of the variable, which is undefined behaviour.
Are you thinking of the Unity game framework? The Unity mentioned about is C, with some ruby scripts to generate test runners etc. Plus the same guys also make CMock for mocking. 
Thank you, I misunderstood.
Good point, I didn’t think of that. Anyway, always good to get assumptions out of the way. I’m wondering, what did you end up using?
It's the errata page for a whole signal processing textbook that is provided for free at the top. Sophocles J. Orfanidis, what a name.
ECS, like OOP is a programming paradigm that is not specific to one programming language. Since it seems to be gaining momentum (mostly in, but not limited to gaming) I thought it was relevant. Knowing about ECS helps you write code that is more performant and more reusable. I did not make this explicit in my post, but I think C is a good fit for ECS. It does not promote encapsulation, or coupling data and behavior (key tenets of ECS), while promoting a code structure that feels native to C (structs with functions). If you feel it's off-topic though, let me know.
Yeah I just use cmake + ctest and have it run with clangs sanitizers.
Allocating memory takes time.
I've used LCUT for a while... mostly out of inertia at this point, but it has worked well for all of my embedded code. https://github.com/bigwhite/lcut
Let me make sure I understand. You need some way to convert `'M'` to 3, `'G'` to 6, and `'T'` to 12, without using any logical operators (`&amp;&amp; || !`), relational operators (`&lt; &gt; ==` etc), or selection constructs (`if` and `switch`)? I can think of two ways to do this. The first is to use math, using ASCII and doing the fanciness so a "simple" computation so you get the right results. This sounds like what you're trying right now, so let's look into how this might work. One way to think about it is to look at the three pairs of numbers involved: (77,6), (71,9), and (84,12). Since we have three points, we could fit a quadratic equation to these three numbers. In essence, we're finding a, b, and c such that y=ax^(2)+bx+c. Plugging in our points: 6=77^(2)a+77b+c 9=71^(2)a+71b+c 12=84^(2)a+84b+c Solving this system of linear equations, we get ... nastiness. a = 0.104395604, b = -15.95054945, and c = 615.2307692. And, really, we should solve this using integers rather than floating point numbers so we get an exact solution. I'll let you figure out what that denominator should be. Instead, a better way is to make a table. Something like this is fine: int conversion[26]; conversion['M'-'A'] = 6; conversion['G'-'A'] = 9; conversion['T'-'A'] = 12; Then we can get the correct conversion using `conversion[letter - 'A']`. Yeah, that's probably better.
A table like that was what I was thinking too. You could have a smaller table with a little bit more work, someone else might be able to find a way to have an even smaller one too: int conversion[6]; conversion[3] = 3; conversion[1] = 6; conversion[5] = 12; You'd then use `conversion[(letter &gt;&gt; 2) &amp; 7]`.
Unity is what we use in my job. It's great. I would suggest looking at combining it with its cousins Ceedling (build tool that makes using unity and cmock super easy) and for mocking - CMock or Fake function framework.
I see. As per our rules, to be on topic, a post must be about the C programming language or must strongly refer to it. Merely trying to reach an audience of C programmers for something that is not specifically about C is insufficient to make your post on topic. However, this is an edge case since I do see a little relevance in your post. I have decided to keep your post. Please keep the rules in mind for future posts.
My piece may have come across a bit ranty, but the changes in hardware design over time are almost certainly motivated to a substantial extent by the fact that the extended-precision types which improved semantics in languages other than C were often slightly worse than useless for C implementations, whose domination led to the eventual elimination of hardware support. I find it interesting, BTW, that people think of 80-bit extended-precision type as an Intel-specific thing, but many platforms *without floating-point units*, the 80-bit extended-precision type can be processed more efficiently than a 64-bit double.
I just use 'autotools autotest' have never used anything else. Am i missing out ? 
Possibly answered in: https://stackoverflow.com/questions/27432973/why-is-this-nodejs-2x-faster-than-native-c The Node.js implementation is faster because by default the V8 engine enables JIT(Just-In-Time) compilation, which optimizes certain parts of the code at runtime. If you just used the command `gcc my_code.c -o my_code`, the optimizations are not enabled by default, generating a slower but more "faithful" program that is faster to compile and easier to debug. If you enable the optimizations(`-O2`), the generated program will easily outperform Node.js equivalents. Optimizations sometimes generate much faster code. For example, if the compiler knows a number will never be bigger than 2^32-1(4,294,967,295), the compiler will compute using 32-bit numbers, which are way faster than computing using 128-bit numbers (as in the Stack Overflow example).
`letter - 'G' / 6` would reduce it to exactly three elements. The division is unfortunate, though. `letter - 'G' &gt;&gt; 2` requires a four element table, with a much more efficient shift to get there. As long as OP only cares about these three prefixes, I doubt there's a more efficient option.
You read my fucking mind I've been thinking about a project involving FFT
Post this in /r/Unity3D
I did!
The best thing about ECS is that there's about 15 different definitions of it and wildly different implementations.
Can you refer me to the different definitions? I actually think ECS is pretty well-defined, as the concepts are encoded in the acronym. There's not much wiggle room there. It is true that there are different ways to implement an ECS. In the FAQ I try to highlight a few approaches in which an ECS \_can\_ be implemented, but I want to extend this with more examples.
The key warning for your question is warning: 'y' is used uninitialized in this function A *variable* called `y` has nothing to do with the character y that the user might type.
If you have an integer and treat it as a boolean (in an `if` or a `while` for example) then it is treated as false if it has a value of 0, and true if it has any non-zero value. so `while(test)` means "while test is a number that isn't zero" and `while(!test)` means "while test is zero"
&gt; Can you refer me to the different definitions? Not without a lot of effort on my part :) The main thing is that the only agreeable definition is very, very broad (literally: entities, components, systems). And the other definitions are defined by the implementations, wgucg are often so contrasting, e.g. Unity's vs artemis. How can those two things both be "ECS"? They're so very, very different!
Looking through the proposal in more detail: In 3.19, I'd suggest "a maximal region of data storage in the execution environment that is created when either *execution enters the scope of* an object definition or an allocation *is performed*." Given something like: int test(void) { int first = 1; int *p; loop: ; int magic; if (first) { p = &amp;magic; goto loop; } else *p = 1; return *p; } Execution would "encounter" the definition of `magic` twice, and the second time would be allowed [whether or not the authors of the Standard intended to allow it] to arbitrarily disrupt its contents, but since execution only enters the scope of `magic` once, only one storage instance should be created. In 6.2.6.1p1, the use of the passive voice for "shall" makes it unclear to whom the requirement applies. In 6.2.6p4, giving blanket permission to alias objects via character pointers will needlessly impair useful optimization. For example, given: unsigned char *p; void store_byte(int v) { *p=v; p++; } void test(int n, int q) { while(n--) store_byte(q); } the proposed text would require a compiler to reload `p` on every pass through the loop to allow for the (extremely dubious) possibility that e.g. `p` might hold its own address, the least-significant byte of `p` might be non-zero, and `q` might hold a value one less than the initial value of `*p`. There's no reason to mandate that all compilers allow for arbitrary aliasing using `unsigned char*`, nor is there any reason not to allow other pointer types with compatible alignments and representations (e.g. `uint32_t*` when accessing things that are 4-byte aligned) *in cases where usage of the converted pointer does not overlap any other use of the object*. I think it's also unclear how nested objects play into things. For example, given: struct foo {int x; unsigned y[16]; int z;} s[5]; what may be done with `(unsigned char*)(s[2].y+1)? The use of the term "Object" in 6.5p6 is inconsistent with its use elsewhere; the indicated edits do nothing to salvage it. The paragraph should simply be deleted. I haven't read into section 7 yet, but those are my comments about the changes prior to that. 
Because of your title, I'm only going to focus on two lines of code: while ( !test ) { //... test = 10; One thing you need to know about C: it didn't originally have any concept of a boolean type. Or really any type at all (if you include its predecessor languages): almost everything was an `int` and that was good enough for us. But the concept of boolean logic is very useful, so there had to be some way of expressing that. What C does is allow an integer (or other types, actually) to be used in a boolean context. It does this by a simple definition: 0 is false, and *anything else is true*. When it needs to "create" a true value (as the result of other boolean logic), it will use 1 to represent true, but that's not a required starting point. So, in this case, `test` is initialized to 0 (essentially meaning false). Taking `!test` inverts the logic, producing a 1 to mean true. Thus, as long as `test` doesn't change, this loop will continue. But then `test` changes to 10. This means true, and `!test` inverts the logic, producing a 0 to mean false. This terminates the loop.
Thanks a lot for your answers!!
In your if statement you need to make y a string as you are not checking if they said "y" but if their response matches the variable y
It is pretty much the same as [duck typing](https://en.wikipedia.org/wiki/Duck_typing) or [pattern matching](https://en.wikipedia.org/wiki/Pattern_matching) in functional programming.
Wrong sub. We only talk about C here, not C++. You want /r/cpp_questions.
I guess this is true. Though the same can be said for different OOP implementations, and a lot of things in general. ECS is not a standard, it's a paradigm, thus some variability should be expected.
Ok thanks. 
If I were going to define the word object it would be something like this: An object is a real or imaginary thing considered to be independent of its environment because of some set of characteristics or by its function by primates with relatively large brains. In programming languages, an object is defined by elements of a mathematical formula that when translated to instructions for a computing machine produces a predictable change in the state of the machine that is used to store and load information that large-brained primates call a value and only exists as an idea until an actual region of memory in a running program is used for this purpose. Objects in memory may overlap, may contain subobjects, or may be part of superobjects of great complexity. An object usually has an address which is found by addition of various offsets at different steps of the compilation process or allocated at runtime. If the object has subobjects or exceeds to range of the system word size, they usually are accessed using the object's address and pointer arithmetic. Objects may store the address of another object. Would I consider a chain of objects or a tree of chained objects an object? Yeah. My primate brain tells me this is a single thing with a single function so it is an object. Are you suggesting additional terms should be added to the specification differentiate between objects that are of continuous memory and superobjects that are built from objects allocated from the heap?
Use what ever but use gcov to guide.
&gt; Though the same can be said for different OOP implementations I was going to raise that point :) There's absolutely [no consensus](http://wiki.c2.com/?DefinitionsForOo) on what "object orientated" is, other than it has objects and the design-focus is on the objects. Anything more than that is murky. It's the same thing with ECS, but at least ECS is a bit more consistently defined. Though I suspect that's most to do with the fact that the number of ECS implementations is currently less than the number of OOP implementations. Given enough time the definition of ECS will be as equally nebulous. 
[liquidsdp](http://liquidsdr.org/)
What about CMSIS DSP? This is more for embedded stuff but you can get ideas from it. [http://www.keil.com/pack/doc/CMSIS/DSP/html/index.html](http://www.keil.com/pack/doc/CMSIS/DSP/html/index.html)
Parts of the Standard place restrictions on how "objects" may be accessed, and invite implementations to misbehave in arbitrary fashion if those restrictions are violated. The way the restrictions are written, 99.999% of programs would violate them if one applied the definition of "object" used in most parts of the Standard (one would have to work very hard to contrive a program that did anything meaningful without violating the rules). In fact, the definition of object used in most of the Standard isn't bad, and the restrictions would be fine if only applied *for the purpose they were written*, but they fail to say that the authors made no attempt to ensure that they would allow things that there would be no sensible reason to ban.
It may be helpful to note that for any type where one can say `objectOfType = 0;`, the expression `!(objectOfType)` will be equivalent to `((objectOfType) != 0)`. This applies not just to numeric types, but also to pointers.
I am not sure if I understand you, but have a look at this: https://stackoverflow.com/questions/3024197/what-does-int-argc-char-argv-mean
This sub is only for the C programming language; try asking instead in /r/csharp.
Yeaah, youre doing that already using scanf function. If you run your code, the code should expect three inputs and will overwrite you're specified value of num1, num2,num3.
Try- String name = console.readline(); Console.writeline(“Hello “ + name);
This is just E P I C !
MSVC has this exact thing: [```assume```](https://docs.microsoft.com/en-us/cpp/intrinsics/assume?view=vs-2017)
sounds like programmin gives ya an incentive to have a bit of a wank mate I'd have a look at some human females
Thank you man. This is really useful.
You have to learn the difference between C and C# first :)
I love how it's written in the obsolete 70s style.
C# is off topic in this subreddit. Please post C# questions elsewhere, e.g. on /r/csharp.
That's a great way to think about it!
What is there to love about it ?
That's very different. The __CHECKED_ASSUME(x) would never result in a program doing anything other than behaving the same way as it would in its absence, or terminating abnormally. The `__assume(x)` directive may cause arbitrary behavior if the condition is ever false on any reachable path. While `__assume(x)` isn't as stupidly reckless than the notion of UB-based "dead branch elimination", a `__CHECKED_ASSUME(x)` would be much more useful programs which are required to refrain from doing anything particularly bad when given invalid data. 
r/programming_horror
Holy moly perfect timing! My University coursework at the moment requires the creation of some of these, so they are going to be great inspiration! Thank you so much!
The unfortunate fact of the matter is that if you want to be a really good C developer, you're going to spend a lot of time writing a ton of code to figure things out yourself. So much of the code out on the Internet is hot garbage, you have to dig into man pages to realize error conditions the author is totally unaware of and learn about fun little edge cases that always seem to exist. Like last night, I was writing a method to get the length of a file in bytes. Lots of people have posted code for that, but none of the code I saw had considered how files &gt; 4 GB would be handled. Thirty minutes of intensive Googling later and I discovered that it is possible to get a 64-bit file length count if I use POSIX to do the file I/O and pass the right compiler flag.
I ended up using the Unity test framework and CMock mocking framework.
I'd say that rather than keeping a 2-D char array, you should break up what you're doing: * create a function that prints out the game screen every in-game tick, which will update the displayed position of the obstacles * keep track of the position of each obstacle individually in either a struct or int[2]. Then increment the y-coordinate every tick. Those two parts *should* be enough to display the map. I'm not quite sure what the best option is for iterating through the list of obstacles when generating the map, but keeping a 30x30 array of chars doesn't seem right.
When a file or stream is opened, it is created in text- or binary-mode. In text mode, all "newline" characters are converted behind the scenes to CRLF pairs (carriage return, line feed) and vice-versa. This lets people on DOS use code interchangeably without having to manage these details (most of the time). 
&gt; So basically how do i add suppose '\n' at the end of each line? You don't, if you're converting from dos to UNIX you need to remove the `\r`, not add a `\n`. You're already reading a character at a time, you could check if that character is `\r` and not print it out.
&gt; char ch; &gt; /* ... */ &gt; ch = fgetc(fptr); Never read the result of `fgetc()` into a `char`. Use an `int`. EOF is a special value that can't be stored in a `char`, so you won't get the results you expect. &gt; So basically how do i add suppose '\n' at the end of each line? Both formats already have LF (`\n`) at the end of each line. What you need to do is *insert* CR (`\r`) before LF if converting to DOS, or *remove* CR when followed by LF if converting to unix. (Or just strip every CR if you want to keep it simple.) This is the logic you need in your loop. &gt; printf ("%c", ch); Use `fputc()` (or `putchar()`) instead of `printf()`. &gt; fopen(filename, "r+"); You should open both input and output files in binary mode (`rb`). Otherwise the C library may interfere with, or even undo, what you're trying to do by performing its own text mode translations. You definitely don't want to open for both reading and writing (`r+`). One problem that remains is that standard output may be in text mode, and, unfortunately, C doesn't provide any way to change this. The only portable way to deal with this is to also open an output file in binary mode (`wb`) rather than use standard output. &gt; printf("Enter the filename to be opened \n"); Normally a filename is be passed as a command line argument (`argv`) rather than prompted for interactively. It's far less error prone, and it just makes for a better interface. ./convert filename.txt &gt;converted.txt Also, check for I/O errors. 
You may also wish to look at http://www.fftw.org/ 
Thanks for the feedback! I have a better understanding of it, but ever since i changed the ch to int I received this error (\[Error\] invalid conversion from 'const char\*' to 'int' \[-fpermissive\]) any reason why? #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { FILE *fptr; char filename[15]; int ch; char text[100]; printf("Enter the filename to be opened \n"); scanf("%s", filename); /* open the file for reading */ fptr = fopen(filename, "rb"); if (fptr == NULL) { printf("Cannot open file \n"); exit(0); } ch = fgetc(fptr); while (ch != EOF) { fputc ("%c", ch); //fopen(filename,"rb"); ch = fgetc(fptr); //printf ("%^\nn",text); } fclose(fptr); } &amp;#x200B; &amp;#x200B;
 #include &lt;stdio.h&gt; int main() { FILE *fp; char b; int loop=0; fp=fopen("test.txt","r"); for(loop=0;;loop++) { b=fgetc(fp); if(feof(fp)) {fclose(fp); break;} printf("%d) %d %c\n",loop,b,b); }/*for*/ return(0); }/*main*/ this is how i might read a file, in either dos or linux.. btw, if you dont know about it, there is a super cool old dos C compiler available for free.. get the "turbo c version 2.01" http://edn.embarcadero.com/museum/ i have been writing C since 1991, and i have been coding since 1983, my first computer was an atari 400.. fyi, i am happy to have a whatsapp or regular phone call, if you want to chat about coding... happy coding.
compiles and works just fine on my linux machine
Hmm maybe it’s because I’m compiling it on dev c++ lol
You shouldnt use a c++ compiler for C. Yes, it *should* work, but its not primarly meant for that
`fputc()` doesn't take a format string, just a single character — e.g. the integer you got from `fgetc()`. int fputc(int c, FILE *stream); 
I am a new programmer. Could someone explain why C excels at the kind of development that it does? 
The program you posted is correct. I'm not sure what you're trying to do with `*a = &amp;t;`.
My bad I just don't know what I was thinking I was so fucking frustrated and ended up posting it here 
Well let's break it down the first bit is "\*a", so we have two parts "\*" the dereference operator and "a" an integer pointer, so the first part represents the value at the memory address stored in "a". The next bit "&amp;" the address of operator and "t" an integer variable, which gets you the memory address that t is stored at. Thus \*a=&amp;t stores the memory address of the integer "t" in memory at the address in "a". I maybe wrong but I think you are confused with what paremeters you have, you have two integer pointers called "a" and "b", NOT "\*a" and "\*b".
While I don't use a mac I seem to recall that codeblocks uses the project directory as the current directory and not the directory that the source files are contained in. Also how about trying a file in your home directory such as "\~/test.txt"
Your code is correct. The compiler won't even compile with the `*a = &amp;t;` part because of incompatible types: int and an address. What you're telling the compiler is place that memory address value to the memory address `*a` is pointing. #include &lt;iostream&gt; int main(){ int t; int *a = NULL; int *b = NULL; int c = 5; int d = 10; a = &amp;c; b = &amp;d; std::cout &lt;&lt; "VALUE OF a: " &lt;&lt; a &lt;&lt; ", SIZE OF a: " &lt;&lt; sizeof(a) &lt;&lt; std::endl; std::cout &lt;&lt; "VALUE OF b: " &lt;&lt; b &lt;&lt; ", SIZE OF b: " &lt;&lt; sizeof(b) &lt;&lt; std::endl; } OUTPUT: VALUE OF a: 0x7ffeea5e15f4 ,SIZE OF a: 8 VALUE OF b: 0x7ffeea5e15f0 ,SIZE OF b: 8 You see that both pointers have a size of 8 bytes which is double the memory size of the int types which are only 4 bytes. 
This is c++?
Yeah, compiled it and everything on my laptop. Unless there's something wrong with it?
No worries, we have all been there.
It is worth mentioning that Dev C++ comes with a very old GCC version from 2005 and is unmaintained. Even the latest version fork by Orwell was last updated in 2015. I recommend Eclipse or Code::Blocks. Both should be fairly intuitive.
I'm going to try another IDE, not sure what the deal is here, among other code blocks problems I'm having 
You can use [getcwd()](https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/getcwd.3.html) to print out the current directory during your program's runtime. 
How big are your text files? Not very if human made them. Read the whole thing in and search\replace?
Instead of printing the whole screen to move an object, you could move just the object. You could accomplish this in a couple of different ways; 1) if it is available for your compiler, you can use gotoxy(), 2) or you can use PDCurses. To detect collision I would try to check when the falling block reaches the bottom row, then check to see if the falling block's X coordinates are within the player's X coordinates. 
`fopen()` doesn't do shell style path expansion.
There’s a NIX program called dos2unix (I believe it works both ways)
Use xcode
The '*' there is the dereference operator. As opposed to the '*' as a pointer type declaration. The dereference operator returns that which the pointer points to (an int) so the code is swaping the values of 2 variables and using 't' as a temp variable. The method is using pointers as parameters so you have access to the swapped variables after the function is called since you can not return more than one varuable from a function.
This. Literally all compilers use the file extension to tell which language is being used, and in a yer you will absolutely forget that you've enabled that setting, you'll create a *.cxx file, and spend hours debugging why it won't compile.
You are probably looking for sscanf combined with gets or something similar.
You are probably looking for sscanf combined with gets or something similar.
Yes, I am using scanf, the type of data that my program asks for, it is numeric and what I try to do, is that the input is within the parenthesis
Ok not sure what you're talking about. Post code and explain how the result is not what you want.
Some calling conventions pass parameters in registers; rdi or rcx say on 64-bit Intel . So if argc was in rdi for the call to main and nothing changed rdi's value, the count_args will accidentally see the 'correct' value even though it wasn't called correctly.
ok &amp;#x200B;
&gt; Yet the program compiles without any warning You must be using a particular old version of GCC, one that defaults to C89 or C90. For newer C standards, you should get a warning because you haven't provided a type for the `argc` parameter in `count_args`. Since you haven't provided a type for `argc`, this is _not_ actually a function prototype: it is in fact an old-style K&amp;R function declaration, with `argc` having a type of `int`. Function prototypes were not required to call functions in these older versions of C. At the point at which this function was called, the compiler would _assume_ a prototype-less function was declared as: extern int count_args(); To be clear here: no information about its parameters is known here. The number and type of parameters is only known in the function definition, through the old-style K&amp;R function declaration syntax. With a prototype, it was up to the programmer alone to get that right in each and every call site. Regardless, function prototype or not, you're calling the function with the wrong number of arguments, so the behaviour is always going to be undefined. It just so happens that the state of the stack and registers at the time of this call are right for the `argc` parameter in `count_args` to get the right value.
Yeah! So, that's a fun one. Here is the exact code I used to test: #include &lt;stdio.h&gt; static int system_wide; void usage() {} void count_args(argc) { printf("argc: %d\n", argc); if (argc == 5) { system_wide = 1; } else if (argc == 4) { system_wide = 0; } else { usage(); } } int main(int ac, char *av[]) { count_args(); return 0; } I compiled with gcc on x64, no options to keep it simple. Let's use radare2 to disassemble those functions. I won't explain every single instruction but we need to know what happens in main and how count_args is called. You should know that an x86_64 machine has what's called registers, little memory spaces big enough to hold a pointer and very quick to access. It also has access to the RAM, a wider space but slower. Some example of registers are: * rdi: generic purpose * rsi: generic, frequently used to hold the Source of a copy * rbp: stack base pointer, the bottom of the part of the stack dedicated to a specific function call to hold its local variables mostly which is called a stack frame * rsp: stack pointer, top of the stack, the other limit of the stack frame You may see "edi, esi"... those are the same registers, but used on 32 bits instead of 64. Let's start with main: ╭ (fcn) sym.main 32 │ sym.main (int argc, char** argv); │ ; A function needs a stack frame, a place on the stack where │ ; it will store its metadata (where it was called from for │ ; example) and its local variables. The next 3 instructions │ ; prepare that stack frame). │ 0x00000682 55 push rbp │ 0x00000683 4889e5 mov rbp, rsp │ ; rsp is the stack pointer, where the top of the stack is │ ; This substraction allocates 16 bytes of memory from the stack │ 0x00000686 4883ec10 sub rsp, 0x10 │ ; We then copy edi and rsi on the stack in those 16 bytes │ ; At that point edi is argc and rsi is argv. │ 0x0000068a 897dfc mov dword [local_4h], edi ; argc │ 0x0000068d 488975f0 mov qword [local_10h], rsi ; argv │ ; Set eax to 0 │ 0x00000691 b800000000 mov eax, 0 │ ; Call count_args │ 0x00000696 e895ffffff call sym.count_args │ ; Set eax to 0 (return code, no error) and leave the program │ 0x0000069b b800000000 mov eax, 0 │ 0x000006a0 c9 leave ╰ 0x000006a1 c3 ret This was relatively easy. Since main has arguments those were taken as local variables and filled with argc and argv. They presently are on the stack as well as in edi and rsi since those registers were not cleared. Now onto count_args. ╭ (fcn) sym.count_args 82 │ ; It's worth noting that argc was taken as an int by default │ sym.count_args (int argc); │ ; These 3 instructions create a new stack frame │ 0x00000630 55 push rbp │ 0x00000631 4889e5 mov rbp, rsp │ 0x00000634 4883ec10 sub rsp, 0x10 │ ; We then copy edi to a local variable in the stack frame │ 0x00000638 897dfc mov dword [local_4h], edi ; argc │ ; And copy that value back into eax │ 0x0000063b 8b45fc mov eax, dword [local_4h] │ ; Then into esi │ 0x0000063e 89c6 mov esi, eax │ ; We now change rdi to contain the format string │ 0x00000640 488d3df50000. lea rdi, str.argc:__d ; "argc: %d\n" │ ; And set eax to 0 │ 0x00000647 b800000000 mov eax, 0 │ ; We have the format string and the argument in registers, │ ; those are the arguments for printf. Call it. │ 0x0000064c e8cffeffff call sym.imp.printf ; int printf(const char *format) │ ; The function continues but that's beyond that analysis So as we can see edi is used to hold the first argument of a function (if it's not too big or there aren't that many arguments, otherwise it's passed on the stack) and here the first argument of main became the first argument of count_args through edi since this register never changed value between the two calls. I hope that explain this sheds some light on the situation. 
What you need is a "GUI library" - see this thread for examples: https://stackoverflow.com/questions/2018850/cross-platform-c-library-for-gui-apps
I think you're asking how to create windows and buttons etc, sometimes called forms. This sort of functionality isn't built in, you need an external library. Look up a tutorial for QT or GTK.
Look up VT100 terminal commands. You can use escape sequences from this to reposition the cursor each time they enter one of the numbers. 
Ah cool I got u fam. Well the bad news is that this sort of stuff can be quite annoying to do on the terminal. Essentially what you want is this, right: \[ : : \] &lt;- first output \[1: : \] &lt;- user has entered first number \[1:3: \] &lt;- user has entered second number \[1:3:0\] &lt;- user has entered third number, data input complete, program continues. So to make this work, your terminal needs to be instructed to first print out \[ : : \], then move the cursor BACK to the first number area and accept input, then move to the second number yadayadayada. This can be done using ANSI escape codes: [https://en.wikipedia.org/wiki/ANSI\_escape\_code](https://en.wikipedia.org/wiki/ANSI_escape_code). Now the problem is you don't necessarily know what sort of support you might have for ANSI escape codes on your output terminal. If you're on unix &amp; family, you're golden. If you're not, you might have some issues - Windows support for ANSI escape codes is patchy afaik. &amp;#x200B;
**ANSI escape code** ANSI escape sequences are a standard for in-band signaling to control the cursor location, color, and other options on video text terminals and terminal emulators. Certain sequences of bytes, most starting with Esc and '[', are embedded into the text, which the terminal looks for and interprets as commands, not as character codes. ANSI sequences were introduced in the 1970s to replace vendor-specific sequences and became widespread in the computer equipment market by the early 1980s. They were used in development, scientific and commercial applications and later by the nascent bulletin board systems to offer improved displays compared to earlier systems lacking cursor movement, a primary reason they became a standard adopted by all manufacturers. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
https://stackoverflow.com/questions/784417/reversing-a-string-in-c
Good to know this. Thanks for the clarification. I thought when count_args() gets called, it pushes its arguments to the stack/registers. Since no arguments are passed to the callee, count_args(argc) { ... } would throw an error because this function doesn't know what argc is. As /u/aioeu mentioned, the function uses old-style K&amp;R function definition since I'm using C89. It seems count_args is just reusing the values that are on the registers. Thanks for the clarification again!
I didn't know you could do that. Appreciate the help.
By using Google for about 10 seconds. https://stackoverflow.com/questions/26883698/accessing-the-elements-of-a-char
Yeah it's reusing the argc value from the register. I didn't know you could do int count_args(argc) { ... } I was assuming it throw an error because argc is of undefined data type. But it compiled just fine. 
&gt; I didn't know you could do that. You can, but you shouldn't. K&amp;R function definitions are _seriously_ deprecated nowadays. :-) Since your GCC isn't helping you out, I would recommend using `-std=` and specifying something newer.
Here is a quick example which may or may not be what you're looking for: #include &lt;stdio.h&gt; int main() { int h,m,s; printf("Enter some data\n"); while (1) { printf("[ : : ]%c[6D",0x1B); if (scanf("%d",&amp;h)!=1 || h&gt;9 || h&lt;0) goto reset; printf("%c[1F%c[3C",0x1B,0x1B); if (scanf("%d",&amp;m)!=1 || m&gt;9 || m&lt;0) goto reset; printf("%c[1F%c[5C",0x1B,0x1B); if (scanf("%d",&amp;s)==1 &amp;&amp; s&lt;10 &amp;&amp; s&gt;0) break; reset: printf("%c[2F%c[0K",0x1B,0x1B); printf("Error in data, try again\n"); } printf("\nRead: [%d:%d:%d]\n",h,m,s); return 0; }
https://blog.therocode.net/2018/08/simplest-entity-component-system
In my opinion the best way to start programming GUI software in C is straight Windows API (assuming you are in a Windows environment). The API is a little bit difficult to get started but once you get a sense of what/how is happening it's pretty easy to work with. The other advantage of being a low-level API is that it will allow you to learn how those things work internally so later when you move to something more productive you will have better judgement and solid understanding. https://docs.microsoft.com/en-us/windows/desktop/learnwin32/your-first-windows-program 
An easy approach would be to move the printf after the scanf: scanf("%d%d%d",&amp;h,&amp;m,&amp;n ); printf("[%d:%d:%d]", h, m, n);
thank you :) I will download it :)
thx
 #include &lt;string.h&gt; #include &lt;stdio.h&gt; char* reverse_str(char* str) { char tmp; int len = strlen(str); int front = 0; int back = len - 1; while (front &lt; back) { tmp = *(str+front); *(str + front++) = *(str + back); *(str + back--) = tmp; } return str; } int main(int argc, char** argv) { for (int i = 1; i &lt; argc; ++i) { printf("%s -&gt; ", argv[i]); printf("%s\n", reverse_str(argv[i])); } }
Qt is C++
It is usually a bad idea to use VT100 escape sequences directly. Instead, you want to use the termcap or terminfo library to send sequences in a platform-independent manner. That said, to move the cursor left, the character `BS` (Ctrl+H, `'\010'`) can be used on all terminals.
There is no reason to use `*(a+b)` instead of `a[b]`. The latter is defined to behave exactly like the former in all circumstances. You just look stupid if you write `*(a+b)`.
https://imgs.xkcd.com/comics/tasks.png As you get into programming you will rapidly learn that some things that look like they should be easy are actually fairly hard. What you ask is possible, several other comments have given you direction on how it can be done, but it is hard. If you have only been programming for a month or two I would suggest not doing this now, in six months you should be able to tackle it far more comfortably.
You welcome. There is plenty of info and tutorials online. As an advice in order to ease your beginning steps don't try to create windows from scratch; it would be painful and unnecessary in most cases, instead take advantage of the resource editor and use CreateDialog as it would be much easier. A nice book to keep you company is "Programming Windows, 5th Edition" from Charles Petzold. 
thanks for your advice :) . I will download that book right now .I am currently studying 'the C programming language ' by Dennis M.Ritchie. Is this a good book to start with? And I just want to ask is CreateDialog a program ? we can download it ?
Jeez can't believe I gave a working code example and got downvoted. Rough crowd.
I think DMR's book is still valid for the fundamentals of the language, after that you can always enhance your knowledge with best practices and techniques for C. I get the impression that you are a novice, I don't want to discourage you but it would be wiser first to get comfortable with the language and then start toying with WINAPI programming because both require their time to settle. Trying to learn both at once might get you confused with information overloading but then again some people are super intelligent. https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-createdialoga https://docs.microsoft.com/en-us/windows/desktop/controls/individual-control-info 
yes . thanks..I will learn and make plenty of codes first in C then when I will be comfortable then I will go for the WINAPI. thanks for your advice and time and for fulfilling my curiosity for C.
Works here, though letters make it go ballistic. Would be easier for eyes with #define CSI "\033[" printf(CSI "2F" CSI "0K"); &amp;#x200B;
Yeah totally, doesn't deal with the 20,000 edge cases for what the input might be - but hopefully sends OP in the right direction.
Try this test/experiment, save the above code in a .c file in a folder on your Desktop, say the file is named test.c. Copy the file to be read to the same folder. Open a Terminal and go to the folder where the .c file and the file to be read are. Compile the code and run it, see if it works. This is a possible workflow: cd ~/Desktop/test_folder clang -std=c99 -Wall -pedantic test.c -o test ./test On macOS many IDEs will build the executable in a temporary folder, separate from your source code. My guess is that Code::Blocks works similar. With the above experiment, you can check if your program works.
Hence you can also use `b[a]` because they're defined to be equivalent. i.e. you can do `4["Hello"]` to get the 'o'.
I'm now using xcode and moved the file in with the c program under the same xcode folder, but it's still not working. I just did your suggestion but it's still not working and under that procedure you gave above. it says back "no suck file or directory". Just to clarify: 1. Make a duplicate of the c file and the txt file under a new folder to be tested 2. go to terminal and type in the path of the new folder 3. run the program from the new c file in the new folder 4. type that text (clang.... ./text) to see if the file exists 5. run the program 
You might try doing something like [sprites](https://en.wikipedia.org/wiki/Sprite_(computer_graphics)). I would use a struct for each object that would be something like the following: typedef struct { // 2D char array to hold your object's shape/pic char pic[4][4] = {0}; // current position int x_pos = 0; int y_pos = 0; // current speed of object int x_speed = 0; int y_speed = 0; } sprite; I would then use and array or linked list to hold pointers to each struct. Then each time your main loop repeats you would iterate through the array/list of structs and: 1. erase the sprite at its current position by drawing the sprite with blank spaces 2. calculate the new position of the sprite by adding its speed to its current position 3. test for collisions or the sprite going off screen 4. draw the sprite in its new position I would still use a 2D array to hold the screen.
Linux
Sometimes Linux on a laptop. Sometimes Linux on a desktop. Sometimes Linux on a Raspberry Pi (3 or 3+). Sometimes Linux on a Pine64. Never on Windows.
 Last login: Sat Feb 2 10:39:18 on ttys001 user-macbook:~ user$ cd ~/Desktop/test_folder user-macbook:test_folder user$ clang -std=c99 -Wall -pedantic test.c -o test user-macbook:test_folder user$ ./test Enter name of file to be copied: Untitled1.txt (or test.c) Enter name of output file: \^I'm getting this, but I don't think this was what you were saying
i'm really not picky, i try to keep my tools multi platform. And a editor is usually all i need - they don't differ that much from system to system. if i have to i write code on my phone (but i try to avoid it).
great! thank you so much for recommendation. Will check out Raspberry Pi.
thanks mate , SorryI wasn't very clear , I was looking for a software like Android studio or xcode that has C as one of programming languages.Not very familiar with linux , My only understanding so far that linux being an OS, would mind elaborate as to how it can be use for Software development? Thanks again
Emacs with C mode, gcc, gdb, Make
so let's assume that,I'm using notepad++ as an editor , how can i create an app or any GUI project?
I use visual studios community. The msvc C support is pretty ass but I really like visual studios and more importantly win32 and directx are invaluable tools I use everyday.
I use FreeBSD, whatever C compiler there is and a text editor, typically nano. Especially as a beginner you should avoid using IDEs for C as they make it much harder to understand how the compilation process actually works and what happens with your code.
I write my C programs on Windows. Of course, it was such a terrible experience I started using Cygwin, vim for my editor and make and GCC to compile. I use the command line more than I ever did when I was running Linux because Windows is so unfriendly and you have to install big bloated apps to perform simple tasks and it is impossible to work on things side by side with the way Windows resizes apps.
&gt; Especially as a beginner you should avoid using IDEs for C as they make it much harder are you suggesting using terminal instead ? I only been using eclipse so far.
Open a terminal, `gcc myProgram.c -o myProgram`.
Yes! Work in a terminal, use a terminal text editor and write makefiles to compile your code. Once you understand how the entire process works you may proceed to use an IDE, but not before.
There is a saying: Unix is an IDE.
Or just type `cc -o myProgram myProgram.c`; not every UNIX system has gcc installed or even a binary named gcc. Also, passing the `-o` option after any operand is not strictly legal.
Nope, I guess you started the Console app, what you want to use is named Terminal.
you learn how to program and write the code for it. You're probably a pretty new programmer? Than the question for the right platform is useless, it's like asking a golf pro which Golf club is the best. It depends on what you want to do. Programming an App for Windows, Linux or Android? Let's say Linux, than you want to choose a library that helps with creating a GUI. In that case i'd recommend the platform Linux and installing the library you chose to use. After that you have to learn how to use the library. And than you just write the code and compile it, just like any other program on any other platform. 
thank you so much!
thanks alot
great advise , thanks!
You can check what files are in the folder with the *ls* command. You need to have the C program and the file you want to read in the same folder. You have the same problem with Xcode because Xcode, like Code::Blocks, will move the executable in a separate folder.
To elaborate, Unix and C were made at around the same time by the same people. You could say, quite literally, that they were made for each other.
thank you,yes I'm beginnar i've only been programming for a little over a year now, just trying to implement what i have learnt by creating projects. if you don't mind is there a GUI library that works on all OS (linux, window and macos)?
Thanks, I have almost a year, this is a project for my programming class and you are right, this is more complicated than all the algorithm I did for the program XD &amp;#x200B;
not sure but gtk might. But yeah you first have to figure out what you want to achieve and than ask for recommendations for a certain topic/project/library. Because otherwise you'll just get general (mostly useless) advice. 
Thank you all very much, I will be testing all the solutions that have recommended me. 
Yes, I'm using Linux ;) 
Great, thank you very much, but what I want is that the characters are not deleted when the user writes, I'm thinking of using ncurses, for the interface, do you think this helps something?
&gt;Does a library serve as ncurses? to allow the user to select where to enter the numbers with the cursor? &amp;#x200B;
+1 for using FreeBSD.
It says terminal on the overhead bar and when I scroll over the app. So I checked what files are in the folder with the ls command and this is what I'm getting 0%BB%9D%E6%FE? a.out test.c Untitled1.txt test test.h &amp;#x200B;
OK, so this is what I'd try in this folder: clang -std=c99 test.c -o test ./test When asked about what file to read I'd use *Untitled1.txt* and for file to write something else, e.g. *Untitledcopy.txt*. After this, use the *ls* command again to see if there is a new file in there ...
Ok I'll try that in a minute but I'm confused- why am I making a test folder, why not just do this from my original project folder
In principle you can do it from anywhere, but you'll need to pass the full path to the program if the file to be read is in a separate folder. It was simpler to tell you how to do it this way. Also, if you learn how to use the Terminal (the command line) you will better understand what an IDE actually does. For example both Xcode and Code::Blocks use *clang* under the hood. My suggestion is to do some reading about using the Terminal for various tasks. It will be very useful in the long run. Also, if you learn how to use the Terminal on macOS it will be very easy for you to use a Linux computer if necessary at some point in the future. (The Terminal on Linux works the same)
Fedora 25, using atom as my editor.
http://tuhdo.github.io/emacs-tutor.html
There are some situations where, despite what the Standard says, gcc processes `arrayLvalue[index]` differently from `*(arrayLvalue+index)`. Most notably, gcc will recognize that an operation on `someUnion.array1[index]` might interact with `*someUnion.array2[index]` but will not recognize that an operation on `*(someUnion.array1+index)` might interact with `*(someUnion.array2+index)`.
Why don't you give it a try and find out? But remember it's not like the authors of ncurses have access to any magic which you don't.
You mean how the : is overwritten if the user types multiple characters? Well you basically need to change the way your terminal behaves, eg to not echo keystrokes to terminal, or to not buffer input until enter is pressed. Usually that is super os dependent.
&gt; There are some situations where, despite what the Standard says, gcc processes arrayLvalue[index] differently from \*(arrayLvalue+index). I have never heard about that and such is in violation of the standard. Do you have a source for this?
I've been happy with [Geany](https://www.geany.org/). Once you understand how you get from source to a built program, you start to understand that you don't need anything other than a text editor and console. In short, first you write the code into one or more .c files. Then you use a program like `gcc` which compiles every .c file into object files. The result of that step are files containing "machine code" corresponding to each source file. But individual files don't necessarily make a program, so after you have all the "machine code" scattered around you have to use a linker to gather them all and precisely fit together to make the final executable. If you're using external libraries, the linker also "links" the executable to those external files which contain additional pre-built "machine code" your program will call.
Visual studio 
On a side note, I filed an issue on github for them to fix that formatting error a couple of months back and they still haven't taken care of it. Shame.
 tr -d '\r' &lt; dos.txt &gt; unix.txt
he's doin a big one :D
It is maybe one screen worth of code... Did i miss the big part of it?
Sorry, I've fixed the code. My bad sir!
It is still only 29 lines of code... This is your homework?
I've fixed it myself. Thanks for being one grumpy cunt. B y e.
I missed where you told what the problem was with the original original code, and now i dont see your solution.. Btw, i have been coding in C for 28 years, lol.. I am old enough that i appreciate that when a youngster like ypu attempts to toss insults,it says much much more about you and nothing about me.. I wish you well with your C programming efforts.. Btw, if you were to ask any of the old hands around here, they would confirm that code isnt even considered "big" at least until it is way way more than ten or twenty thousand lines.. Good luck with your homework.. Edward..
Alright, I'm a first year college student and to me this looked a bit bigger. And the title doesn't mean a lot - it means of how sarcastic you started replying. We get it old man, you're better than most of us here. Anyway I've asked a 3rd year programmer and he's helped me to do it.
I understand that you are a first year student, it is quite obvious.. Edward..
CLion by the JetBrains guys is pretty sweet for C/C++
macOS + Xcode
For now I ssh into a server with Linux and vim my way through everything. Sometimes I'll use VS code and ftp it over
Yesterday /u/md81544 linked to [this SO thread on cross-platform GUI libraries for C](https://stackoverflow.com/questions/2018850/cross-platform-c-library-for-gui-apps).
Does Visual Studio support C99 yet?
Plug the exact code below into `gcc.godbolt.org` or other gcc/clang test facility. union foo {int ints[10]; short shorts[20];} foo; int test1(int index1, int index2) { foo.ints[index1] = 1; foo.shorts[index2] = 2; return foo.ints[index1]; } int test2(int index1, int index2) { *(foo.ints+index1) = 1; *(foo.shorts+index2) = 2; return *(foo.ints+index1); } Both clang and gcc are capable of recognizing that `foo.ints[index1]` and `foo.shorts[index2]` are both derived from `foo`, but when the expressions are written in the equivalent forms in `test2`, both clang and gcc consider the facts that `(foo.ints+index1)` is an `int*` and `(foo.shorts+index2)` is a `short*` as being more important than the fact that all addresses are quite obviously freshly derived from the same object at the points of use. 
What did you expect from dumping your homework with a click-bait title without even explaining the problem? It's not like the rest of the world exists for your convenience.
Guy asked for pointer arithmetic, I gave him pointer arithmetic.
So, why?
Dev C++, although it says C++ but I use it for C only
I haven’t done File Input/Output very much but I’m pretty sure using the function fseek() is necessary for setting your position in the file. Hopefully someone will be able to provide you with more information than I can. 
You have a couple choices. For either one, you're not doing half of it in your original code, which is reading the original file. You could get the size of the file, allocate a block sufficiently large enough to hold it, and read the whole file in one go. Then loop over the buffer and replace every instance of the newline marker with the New text + newline you want to append to each line. You'll also need a special case for the end of file in the event your input file doesn't have a trailing newline at the end of the file. Option two is to open the original file as read, open another file for write, read the input line by line, again appending the New text to the read line when you write it to the output file. This method is easier as it lets the stdlib file routines work out the end of line for you. Finally, delete the original file and rename the new one. This would be the last bit of code to add when you're certain it works properly, otherwise you'd potentially be clobbering your input file every time you test your code.
Visual studio can build c programs you just have to change the extension of every file to .c and .h and visual studio will compile an executable out of them.
1. You are opening the file in append mode. This only means you will append to the end of the file. 2. The rest of the code does not function as you intend. 3. You will need to understand how to process the file linearly and understand that the only thing differentiating a line is a linefeed character. See [http://www.asciitable.com/](http://www.asciitable.com/) 4. You will probably also need to open one file to read and a new file to write to unless you will parse and store the file into program memory. 5. You will need to look at the stdio API. [http://www.cplusplus.com/reference/cstdio/](http://www.cplusplus.com/reference/cstdio/) &amp;#x200B;
I figured it out. I was building for 32 bit windows for some reason even though the criterion dll was for 64 bit. I wish there was a simpler way to do this, it all just seems so much cleaner on linux
When running camel, you can specify architecture with -Arch x64 or x32 I think.
Eclipse c/c++ édition with DevStyle add-on. Otherwise Geany because is lightweight. 
Install MSYS2, use that to install the MinGW-w64 port of gcc and any needed libraries and tools. Much closer to a familiar Linux environment, but you can still use native Win32 stuff if needed. gcc is a much better C compiler than Visual C.
[Why is “while ( !feof (file) )” always wrong?](https://stackoverflow.com/questions/5431941/why-is-while-feof-file-always-wrong)
you can add -m32 for 32 bits and -m64 for 64 bits building.
I have had a lot of success using clang
i am not sure why you have the line that says "fputc("%c",fPointer);"... that just aint right, lol... if you are trying to APPEND to the END of a file, and your current text file looks like this: how now and you want to APPEND "brown cow" to the END of the file: #include &lt;stdio.h&gt; int main() { FILE *fp; fp=fopen("textfile.txt","a"); fprintf(fp,"brown cow\n"); fclose(fp); return(0); }/*end of main*/ and now your text file will look like this: how now brown cow but if you wanted to take that result file and make it look like this: **how **now **brown cow this is different that APPENDING to the END of a file, lol.. you would need to INSERT characters into the file, which would probably require you to read the current file, writing the NEW stuff to a temporary file, and then rewrite it all back to the original file. there isnt any mechanism to INSERT characters into a flat file. check out tmpfile(), which creates a TEMPORARY FILE, which you can use to copy your file to, and then copy it back to the original file once it has been modified.. the cool thing about tmpfile() is that it simply disappears once you close it.. like this: #include &lt;stdio.h&gt; int main() { FILE *fp; FILE *fptmp; fp=fopen("textfile.txt","r"); fptmp=tmpfile(); return(0); }/*end of main*/ and so now you could read textfile.txt, write it to tmpfile, and then REWIND() the tmpfile, read the tmpfile and rewrite it back to textfile.txt.. try searching google for "tmpfile() c rewind" 
also, i think that you maybe dont understand the "feof" usage... feof is used to test for end of file, usually when reading thru a file, which is irrelevant if you are trying to append to the end of a file... if you wanted to read thru a flat text file, i would use feof like this: #include &lt;stdio.h&gt; int main() { FILE *fp; char b; fp=fopen("textfile.txt","r"); for(;;) { b=fgetc(fp); if(feof(fp)) {fclose(fp); break;} printf("%c",b); }/*for*/ }/*main*/ happy coding, zero/. 
I have Windows binaries and source code and project filesthat easily compiles anywhere GCC is available. I have Visual Studio because I use that for other things. I had a lot of problems getting Android Studio working on Linux a few years ago and I would rather use the Windows version now.
take a look at the tutorial at: http://www.winprog.org/tutorial/start.html and definitely take a look at devcpp from bloodshed software.. many will tell you that it is outdated, but it is omg way cool and it is old school.. https://www.bloodshed.net/devcpp.html 
Incidentally, the Standard doesn't make any effort to define the behavior of any code which accesses a struct or union object using an lvalue of non-character member type--even if that lvalue happens to be a member-access expression whose left operand is that struct or union in question--on the presumption that quality implementations intended for various purposes won't needlessly "prevent the programmer from doing what needs to be done"(*) to fulfill those purposes even if the Standard would allow them to do so. (*) The published charter and rationale documents for the C Standard describe the Spirit of C as including a number of principles, the second of which is "Don't prevent the programmer from doing what needs to be done". It would seem implausible that the authors of the Standard intended that it be interpreted as encouraging implementations to violate the spirit of C which the Standard was supposed to uphold. The authors of clang and gcc seem to have recognized that an inability to handle any struct or union member accesses would make the language pretty useless, but since the Standard imposes no requirements on the behavior of code that uses a non-character-type lvalue like `someUnion.arrayMember[i]` nor even `someUnion.anyMember` or to access a struct or union object, it likewise doesn't impose any requirements on code that uses an lvalue like `*(someUnion.arrayMember+i)`. An implementation would thus be free to treat the first implementation usefully at its leisure whether or not it treats the second one likewise. I fail to see any reason a quality implementation shouldn't reliably handle both forms, but the Standard doesn't require them to handle either.
Well, what happens? How'd you use the if statement, and what was the result? Does the program operate normally when in range of the array? Also make sure choice is what you think it is. If you're not using a debugger, just throw in some printfs and see what happens to choice as it goes through the program. Please, do tell the results.
What if I want it at the end of each line? 
Then you need to search for '\n' characters, because those are line break characters and where those are you can then insert your text.
your regular text files really dont understand "end of line"... as a programmer, you should think of a text file as a buffer in memory.... a line feed("\n") is an ascii ten and a carriage return("\r") is an ascii thirteen, obviously... so, if your file contains: how now brown cow as a file, this might look like this: how(13)(10)now(13)(10)brown cow(13)(10) so whether you want to "insert" at the beginning of the line or at the end of the line, you need to read it all in and rewrite it to the original file... how you go about doing this is entirely up to you, whether you read the original file into a tmpfile() and then rewrite it back to the original file, this is your call.. btw, have you tried the old borland turbo C for dos? i simply love this compiler ide, and it is available for nada.. http://edn.embarcadero.com/museum/ get the 2.01 version.. 
Processing arbitrary strings of the form [+/-]xxxxx.yyyyyE[+/-]zzz in such a way as to yield the closest representable `double` is surprisingly difficult. If one is willing to accept a slightly less accurate conversion, things can be simplified enormously. For example, if one only needs numbers of the form [+/-]xxxxx.yyyyy, with neither component exceeding 15 digits, one could compute the whole and fractional parts, along with a base-ten divisor, as type `double` and then compute `result = wholePart + fractionalPart/divisor`. Since all numbers prior to the final division will be precisely represented as `double`, the result will be precisely rounded in all cases. Handling larger values, especially if they must be read from a stream and accurately rounded but one cannot limit their size to fit a buffer, is a lot more difficult. For example, 9.444732965739290951680E+21 should be rounded down to 9.4447329657392904E+21, but 9.444732965739290951681E+21 should be rounded up to 9.4447329657392916E+21. If a program has received 94447329657392909516 with more digits to come, there are a finite number of cases where it the final value could be end up being just above or just below the threshold between two adjacent `double` values, but handling them all is sufficiently complicated that the effort required to ensure a function is reliable in all cases may exceed the effort required for everything else in a program combined.
For the future, always put the gist of your question in the title. Also, please don't number source lines so it's easy for others to compile and run them themselves.
There is no built in functionality to edit a file in-place. If you want to add something to each line, the easiest way is to read the file line by line, edit every line in memory, and then to write the corrected line into a new file.
That depends on what compiler you use and for most compilers on Windows, this advice is wrong.
This is not correct. The standard quite clearly specifies when access to a union member is well defined: * if the union member was last written to and an appropriately typed lvalue is used * if the union member was not last written to and the union member is accessed through the `.` operator (as opposed to a pointer).
It's a subset of some various C standard functionalities between C89 and C11, so good luck. And it has only Win32 API and nothing POSIX which sucks too.
Oh wow! Never thought of reading it first and then rewriting it i'm use to c++ I guess lol. And yes I've downloaded but all i get is 3 files :/.... You have definitely help a lot and really do appreciate the help my amigo! 
Yup.. Glad i could help..
The way the C11 draft (N1570) is written, 6.5p7 says that accessing any structure or union object using any lvalue that isn't an lvalue of the struct or union type, a *containing* construct or union type, or a character type, invokes Undefined Behavior *even if other parts of the Standard would clearly and unambiguously describe the behavior of the action*. The Standard does *not* define what it means for things to alias. Instead, the purpose of 6.5p7 is to say what things are *allowed* to alias. Given something like: int foo(int *p, int *q) { *p=1; *q=2; return *p; } N1570p6.5p7 doesn't say that `p` and `q` wouldn't alias if they access the same storage, but rather that they're *allowed* to alias, and thus a compiler must allow for that possibility. That section was never intended to encourage compilers to ignore situations were references of one type are freshly visibly derived from references to objects of other types. While gcc and clang are being more generous than required by the Standard, that's because the authors of the Standard thought compiler writers would seek to uphold the Spirit of C whether or not the Standard required them to do so. If `someUnion.member` is a non-character type, there's no circumstance where `&amp;someUnion.member` could be used without first being converted back to a union pointer or a character pointer, or passed to a library function like `memcpy` that behaves as though it converts its argument to a character pointer, but having the address-of expression yield a useless pointer-to-member type would make no sense unless the authors of the Standard expected such pointers to be useful in at least some circumstances despite the fact that *they didn't specify any*. 
Pelles C?
Clang has full C18 support and is [supported by VC++](https://blogs.msdn.microsoft.com/vcblog/2017/03/07/use-any-c-compiler-with-visual-studio/)
Sometimes, the reason there are no good answers is that you're asking the wrong questions. Coding C on anything less than Linux/BSD is going to be an uphill struggle from my experience. I would say your best bet is running a real OS in a VM for writing code if you absolutely can't live without Windows.
That's ignoring the main issue. The Windows SDK. I'm not going to ignore the windows market and tell them to get a "real OS" to run my apps, that's unreasonable. A little extra work is worth being able to share my apps to my layman friends.
I don't want to try and kill C or anything, but did you ever try to learn Python? I know it isn't low level, but maybe in newer versions of Python it may support multiprocessing as default.
I need the Windows SDK. I'm not trying to step on people who use high level languages (they can be pretty sweet from time to time) but I use C for graphics programming, python just wouldn't be a good fit ya' know.
That's interesting. I never learned graphics programming, but it sounds fun. I hope you get it sorted out. I tried doing the entire C on windows, but never really succeeded. All I know of graphics programming is that you get stuff like opengl.
Marketing, I was talking about code. I don't know much about marketing, I prefer solving problems to inventing them. Good luck!
&gt; stinky C support What issues are you running into? The project creation workflow doesn't list C but it lists C++. All you have to do is change the file extensions and it usually ends up working correctly for me, although I suppose I've really only used C in Windows for driver work which is slightly different.
it doesn't fully support the C99 feature set. it's been nearly twenty years and they refuse to budge on this matter.
As far as I know, [nobody's ever written a decent standard C library for Windows](https://nullprogram.com/blog/2016/06/13/) — except, perhaps, Cygwin's libc, but that has other issues. Each has nasty warts, like how non-ASCII arguments are mangled when passed through `argv`, text stream translation, that `fopen()` is unable to access most of the filesystem, broken stdio buffering, etc. That's a consequence of MSVCRT generally being "stinky" as you put it, and everyone either links against it (MSVC, Clang, MinGW, Mingw-w64) or they copy all the warts for the sake of compatibility (Pelles C). For some reason Mingw-w64's formatted output is broken by default (no support for `size_t`, `ptrdiff_t`, `long long`, etc). There *is* an undocumented option that fixes this, and I have no idea why it's still officially undocumented. #define __USE_MINGW_ANSI_STDIO 1 When I'm compiling with Mingw-64, I use that almost by reflex. Also by reflex I drop this into the top of `main()` to disable the stupid text stream translations: #ifdef _WIN32 int _setmode(int, int); _setmode(_fileno(stdout), 0x8000); _setmode(_fileno(stdin), 0x8000); #endif 
&gt; I'm sick of not having full C support This is why I uninstalled Visual Studio. The workarounds were there, but everything is a battle. \- Using &lt;windows.h&gt; is hard because all the documentation is getting old. \- Using anything else was a battle between Linux, Windows, and C++ preferences. \- Most graphics SDKs don't work with C &amp; Windows at the same time. \- Setting up everything to work in VS offered nothing better than any other environment or language, But that is not the point of using C! Microsoft excluding C for so long has done damage. 
Just so we're being clear, It implements it's own C standard library and doesn't link with the MSVCRT right? Are there any down sides other than a lack of portability (My question is about a Windows based C implementation so I don't really care about portability). While I said I tried Clang, it's more like I read up on clang and assumed that it also just linked up to the msvcrt like MinGW does.
Clang doesn't have its own C standard library, it's designed to work with multiple. I believe it uses msvcrt by default on Windows but been a while since I've used it.
&gt; - Using windows.h is hard because all the documentation is getting old. Whaaat? The stuff in windows.h is documented superbly in my experience. What did you find that was missing?
For use with C, not C++.
pdev1 is never changed from NULL before referencing it at line chck1 = cdev_add(&amp;ddev-&gt;chdev, So if cdev_add writes to the pointer it is passed, it'll crash.
Can you elaborate on why MinGW feels like Linux programming? MinGW is GNU build tools (make, etc.) ported over to Windows, but it doesn't contain any Linux-based libraries (not even libc or crt, as you mentioned). All the code you write in MinGW necessarily can only be Windows libraries. So, is the build environment you don't like about MinGW?
&gt; It still has terrible performance, and that's unlikely to get fixed as Microsoft doesn't yet understand how bad it is. Microsoft understands fully how bad it is, but they really can't change it without breaking a SHITLOAD of drivers, company workflows, and code.
&gt; stinky C support It sounds like you want something that doesn't even exist. Let us know when you're done making it.
Just a heads up: this is /r/c_programming Have a nice day!
&gt;it just uses the MSVCRT for C support, ergo C support still stinky Are you missing some functions from the standard library or what are you talking about? The "C support" (language constructs) is the business of the compiler.
Uh, what version of VS are you using?
MacOS + Xcode primarily, Windows 10 + Visual Studio secondarily.
.lib are libraries not headers, add the lib folder to "Additional Library Directories", not "Additional Include Directories"
I have a C99 project with a CMake build system that works just fine on macOS, Linux and Windows. Feel free to take a look at it: [C-ray](https://github.com/VKoskiv/c-ray)
Have you tried intel's compiler?
Yes, it uses Microsoft's msvcrt. While you get all the modern C syntax, you'll still be missing standard library functions like aligned_alloc.
I guess /u/scalablecory is talking about Win32, which is a set of C APIs. I have to agree, Win32 is generally documented very well.
&gt; * Clang &gt; *relies on VC++ Build tools, so it's just a glorified wrapper Eh, what? I've used Clang and I never found a depedency on Visual C++. A dependency on MinGW, yes, but not the Microsoft thing.
Hmm, I'm on the fence about that. In most of these scenarios C++ is privileged beyond any other usage. I would have to hunt down all the equivalent instructions to come up with something similar to this: https://docs.microsoft.com/en-us/windows/desktop/learnwin32/learn-to-program-for-windows Microsoft stopped updating C documentation AFAIK. I didn't say it's not possible to find documentation. You're welcome to point out anything you think is beyond complaint to me. How far in is enough to consider it wasn't doing any favors? There are just better SDKs that are written in C, ... IDEs, OSs ... 
I guess it depends on what we look at. I was thinking more of the API references of the core Win32 APIs like kernel32, user32, etc. which I recall were documented pretty well. C++ APIs like Direct3D will of course use C++ for their docs. It loks like you're right about those guide documents though, most of them appear to be tailored towards C++.
Thanks for catching that silly mistake.
macos+xcode =only use swfit and objective-c
[VS2017 doesn't fully support c99](https://docs.microsoft.com/en-us/cpp/visual-cpp-language-conformance?view=vs-2017) and seems to be unlikely C11 will be fully supported either.
Mingw-w64 has the latest gcc and windows.h . Maybe you were doing it wrong.
Lol, what's with the bad karma? You tell me it's not a good solution to learn a programming language that is very similar to C to solve your programming problems? I picked up Python directly and could reinplement all of my C programs. I guess some people just get butthurt.
Why not build it for linux and run WSL?
How exactly do you “include” the file `python36.lib`? Also, note that C++ is off topic in this subreddit. If this is a C++ project, please ask in /r/cpp_questions.
If you can find anything in N1570 6.5p7 which would indicate that there are any circumstances in which an object of a struct or union type can be accessed using an lvalue of type `int`, including even something as simple as `someUnion.intMember`, I'd genuinely like to know. So far as I can tell, the authors of the Standard didn't make any effort to forbid compilers from behaving in obtuse and useless fashion. Indeed, the Rationale expressly recognizes the possibility of contriving a "conforming" implementation that was incapable of meaningfully processing anything other than a single useless program. Viewed in that light, the fact that the Standard would allow an obtuse compiler to behave in arbitrary fashion given `someUnion.intMember = 1;` isn't really a defect, since there's no reason to expect any compiler to be so obtuse as to handle it in anything other than the fashion described elsewhere in the Standard. Likewise, the fact that the Standard would allow an obtuse compiler to behave in arbitrary fashion given a construct like [from the earlier example] `*(foo.intArray+i)=1;` *shouldn't* be a defect, since there *should* be no reason to expect any compiler to behave in such obtuse fashion. Except, of course, for the fact that nowadays some compilers *are* that obtuse, and claim the Standard's failure to forbid such behavior as an invitation. 
Because ANSII has integer value ranges. So, any char can be mapped into the ANSII space (0-128) You could do a bunch of neat tricks with rolling (&lt;&lt; , &gt;&gt;) in ASCII This, of course, was relevant back in the days before Kernighan and Thompson defined UTF-8
Since that's the case, could I also use char c; instead?
In memory everything is a number, and this is reflected in C. A `char` is really an 8 bit number, but for convenience we can assign representations of the characters to them in C. e.g. both of these lines do the same thing: char a = 'A'; char a = 65; How do we know that `A` is 65? Because that's what ASCII says it is. If you're on a *nix box have a look at `man ascii`.
`char` is an integer type just like `int` and `long`. Really, the only difference is that functions like `printf` will convert that number to some displayable character. A less-known detail, character literals like `'A'` and `'\n'` are of type `int`, not `char` (fun fact, C++ is different in this regard).
ya, but the sane (ie, not the fuckwit/Lennart Poettering) way is to keep your data types separate and only convert when needed via the appropriate functions.
Why not just use the same data type for both c and the array?
In your example, `'\0'` is a character literal - the '' make it a character literal. The \0 is an escaped zero - it means "use this actual value instead of the character value '0'". Also known as a null terminator. As others have already explained, chars are just 8-bit integers.
Not really, look at how getchar is defined (see `man getchar`): int getchar(void); The `getchar` function actually returns an `int`! If you read description of other similiar functions in the same man page: fgetc() reads the next character from stream and returns it as an unsigned char cast to an int, or EOF on end of file or error. getc() is equivalent to fgetc() except that it may be implemented as a macro which evaluates stream more than once. getchar() is equivalent to getc(stdin). You find something about the special `EOF` (End of file) value. This is #defined as -1 and indicates that there are no data left. If you defined `c` as `char` you would have no way to cover 256 values as a valid character and also a special value!
In this case because `getchar()` can return values that can't be stored as a `char`, so you need to use an `int`. These values are only returned in conditions where you wouldn't want to use `c` as a character (e.g. if the end of the file is reached then `getchar` returns the `EOF` character) so as long as you check for this it's safe to store the result as a `char`.
The reason that int is used here is that getchar() returns int. It does that so that it can return an error value that's outside the range of character values. From the Linux manpage: &gt; fgetc(), getc() and getchar() return the character read as an unsigned char cast to an int or EOF on end of file or error. So, valid characters returned by getchar() are in the range 0-255. EOF is typically defined as -1, which is outside that range. (It can have other definitions but they'll still be outside the range 0-255.) With a char data type, you'd only have 256 possible values so there wouldn't be an extra value available to indicate an error condition. Normally you would want to test for EOF after calling getchar(), you wouldn't want to just trust that it returned a usable character value.
it's because this is a c programming sub and you gave "use another language" advice. In the real world this is fine but as it pertains to this sub, it's counter intuitive.
It's a local variable to the `strtok` function, but unlike automatic local variables it's held in the same address every time the function is invoked.
how would I even go about making my own C lib? aren't all the window Native API calls hidden and susceptible to great change?
I think your fingers got a bit ahead of your brain here, since you seem to know what you're talking about. I'll clarify for those people out there who are reading and might have gotten confused. ASCII is a 7-bit character set that includes values 0-127 (not 128). There is no such thing as ANSII. There are various 8-bit character sets referred to informally as ["ANSI"](https://en.wikipedia.org/wiki/ANSI_character_set). They are supersets of ASCII that also define characters 128-255. You shouldn't really use these anymore as a data format, but they are sometimes useful for display purposes when you have a console/terminal that supports them. 
D-OH. sorry yeah, you are correct. ASCII is an ANSI standard.
[Use the source, Luke!](https://sourceware.org/git/?p=glibc.git;a=blob;f=string/strtok.c;h=2eebc0a0dc9e4ce3bf3728d6361b691093c9b913;hb=refs/heads/master) At least, that's how one implementation does it, but I wouldn't expect there to be much variation. Note: you should be using `strtok_r` instead, if you can use POSIX functions.
have I tried what now? Intel has a C compiler? I didn't know, and I mean if it does what asked for in the post that'd be pretty sweet!
MinGW links with the MSVCRT.DLL, ergo it is trash. They don't use their own c library, they get it straight from Microsoft. Microsoft Clib = BAD; MinGW Clib = Microsoft Clib;
I meant they way you use it as Windows recommends is to set the Visual Studio IDE to use the clang compiler. In the end it still just links to the MSVCRT.DLL no matter where you use it. * \+ you'll get modern C syntax support * \- still using shite msvcrt.dll
this seems to be the closest I'm going to get right now, but I've been having trouble with its includes and library paths. If I put a folder in the includes which points to another folder, Pelles C won't be able to find the headers! So I can't do "#include &lt;stuff/stuff.h&gt;", it just shits the bed. If I can figure that out then it seems like a really good fit (I don't know about code efficiency though)
So, How many bits will be presented in computer memory system 32 bit? Int or Char?
I'm talking about both the C lib implementation and the actual syntax support. so stuff like Clang which does provide modern syntax, links against a C lib that was made many moons ago.
technically Direct3D is a COM object which is a binary format separate from C++, they just look alike. I've done light Direct3D programming in C and it is a pretty big hassle. &amp;#x200B; *in C++ you could just call functions like...* DirectXPointerThing-&gt;Function(VAR); &amp;#x200B; *but in C you had to do this...* DirectXPointerThing-&gt;lpVtbl-&gt;Function(this, VAR) where every function's first parameter is a pointer to itself &amp;#x200B; I guess this is why documentation is exclusively in C++ (that and the games industry pretty much all moved to C++)
it feels excessive. It's like setting up my own little linux box within windows. Ultimately it still just links to the MSVCRT so while gcc gives me modern syntax, it ultimately uses the gross Microsoft c lib so I'm back to square one. That and if I just wanted modern syntax I could just use clang without having to setup a mini linux within windows.
§6.5 ¶7 is the wrong section. A union consists of a union object and for each member an overlapping subobject of appropriate type. If you write `foo.bar` where `foo` is an object of union type and `bar` is one of its members, this refers to the member's subobject which has the right type and thus the access is correct. I have discussed this in [great detail](https://stackoverflow.com/q/38798140/417501) before. 
Afaik the API itself isn't susceptible to change? (no more than any other API). The thing with the Win32 API (if I remember correctly) is that Microsoft's said that they don't want you to do direct syscalls for things like reading and writing to files (i.e. no assembly to do syscalls), as parameters might change there, but I think stuff like [ReadFile](https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-readfile), [WriteFile](https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-writefile), [VirtualAlloc](https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) has been stable for long?
I guess now I gotta make a c lib using Win32 huh? Who knows, maybe it'll blow up once I figure out the nitty gritty of it all.
*Example 1:* When input is : 10 100 0.5 -1 Output is : Error. Invalid parameters. *Example 2:* When input is : 8 15 0.65 3 Output is : Acceptable success rate: 0.65 Average attempted sales: 15.00 Average completed sales: 12.25 Observed success rate: 0.82 Observed success rate is acceptable.
Wrong sub. We only deal with C here, not C++. You want /r/cpp_questions. Also, please use the "code block" (not "inline code") button to properly format code.
A 'char' is just a block of memory, same as an int. With the former, you're asking to set aside 8 bits of memory; with the latter, you're asking to set aside 32-bits of memory. You can store any 8-bit value in a char, and any 32-bit value in an int (signed/unsigned change the range, of course). The name can be misleading, because you think of actual alphabetical characters in a 'char'. This is where ASCII comes in - if you look up the ASCII table, you can see that the letter 'a' is just the value 97. So if you declared "char temp = 'a'", the value 97 (or 0110 0001 in binary) would be stored there, taking up 1 whole byte. You can then pass that to some function like printf which understands how to translate that to its ASCII representation. But you could just as well pass it the value 97. getchar() returns an int because it can return the special value EOF, which is an integer constant expression. 
It's an implicit cast. `int` gets downgraded to `char`, and data loss could occur. The reason you have to use `int` is because `getchar()` can return stuff outside of what `char` can store (0-255). If `getchar()` returns `EOF` (value of which is -1), there's no room for it in `char` and -1 would likely be converted to 255. So how would your program know whether getchar originally returned 255, or it actually returned EOF? It wouldn't, the program could fail or result in undefined behavior. Be careful with these kinds of things, check what the function returns and then decide what type you need to accommodate that.
Since the syntax has nothing to do with the C library; what are the specific problems? Are there functions you are missing?
They're already planning on adding support for most C11 features at some point in VS 2019's release history according to their mnager. as for C99, it's really only VLAs that no one actually uses, so.
Oh ok my bad Thanks 
Great but supporting most of it is not the same thing as fully supporting it and if OP wants to use VLAs it's a valid complain.
not functions "you are" missing but rather functions in the modern C standard that Microsoft is missing. Are they 100% necessary? No not really (hell I've been programming C in windows for a while now and I wasn't too desperate) but I still want the ability to use them. For example if I wanted to do multithreading, I could just use the windows header and create threads that way but I would love to be able to write threading code using thread.h instead so that way my stuff can still be portable if need be (I never mentioned it on the post but I also use linux and macOS so having all the library functions be the same would be very nice) You're thinking far too literal in that, "this guy is missing a specific c library function, what can I recommend him?" I'm not missing anything really, I just want to use cool new C stuff in windows is all.
Locally, and -- as you basically already said in your question -- statically, ie. declared with the `static` storage-class.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
A char is an ascii representation of an int value.
`make myProgram` will also do what you want for something simple like this - where the program name has the same base name as the source with gnu make.
The declaration `union intfloat { int x; float y;} uif;`, will commence the lifetime of three objects, known as `uif`, `uif.x`, and `uif.y`. Any action which accesses the stored value of any of them will *also* access the stored value of the other two. Given the above union, the rules of 6.5p7 say "An object of type `union intfloat` shall not have its stored value accessed only by an lvalue of type `union intfloat`, a character type, or some other struct or union type that contains `union intfloat` as a member." Such wording implies a run-time constraint, and any violation of a run-time constraint *automatically* invokes Undefined Behavior, *even if behavior would be unambiguously defined in the absence of the constraint*. Do you disagree with any of that? To make 6.5p7 even remotely workable, an operation like `uif.x = 1;` must be recognized as using an lvalue of type `union intfloat`, since lvalues of that type are allowed to access the stored values of types `union intfloat`, `int` and `float`. I don't see anything in the Standard that defines the types of lvalues in such fashion, however. If one recognizes that a compiler that can see that an lvalue is freshly derived from another lvalue should, for purposes of 6.5p7, treat operations upon the former as also being operations upon the latter, and that an operation satisfies 6.5p7 if any of the lvalue types involved do so, then 6.5p7 will suddenly make sense. Since the lvalue `uif.x` is derived from `uif`, an operation upon an lvalue is an operation upon an object of type `union intfloat`, and 6.5p7 explicitly allows for objects of type `int` and `float` to be accessed via an lvalue of a `union` type which contains them as members. The one remaining question would be whether there's any good reason why anyone claiming to write a quality general-purpose implementation would want to only recognize the absolute minimum set of lvalue-derivation forms needed to avoid making the language completely useless, rather than making a bona fide effort to recognize any other access patterns? 
It's been a little while since I worked with the Win32 API directly, but most of it is pretty easy to work with, in my experience. I suspect the hard part about writing a C runtime are the abstractions above the Win32 API. 
GNU make is only standard on Linux. Do not assume that people use it by default. That said, this works on any POSIX make.
That's not thread safe!
Non-sequitur. Linking to msvcrt is PART of mingw-w64's C library implementation, not the entirety of it. Personally I'm concerned with standard compliance, not implementation details. Maybe you could consider taking a similar view... 
I have discussed this question [before](https://stackoverflow.com/questions/38784268/can-an-object-have-more-than-one-effective-type). The main problem with your interpretation is that changing one object does not constitute an access to another object residing at the same location and thus it's not undefined behaviour. The type of the lvalues does not magically change to make anything workable.
Nor can you tokenize two strings at the same time in a single thread.
What makes you a good programmer is a lot of practice, the wish to improve yourself, and a keen eye on code quality. C is a good tool to learn all the virtues and vices of programming, but other languages are fine, too.
I mean, this is the C subreddit so you'll get a biased answer. Many of use learned C as our first language because it was the standard at the time. Is your end goal learning programming to work on the Microsoft stack, either making Windows desktop apps or using C# on the web? If so, just learn C#.
I assumed you were missing some functions and could give examples, since I have not heard of functions missing. If you're not missing them, I don't understand what the point of this question even was. It's too vague. And of course I take what you write literally; am I to guess what you mean?
What does that print? And why do you use strcpy?
Why are you doing a \`strcpy\`?
The best language (actually family of dialects) to use for low-level embedded programming (writing code for the microcontrollers in things like toasters, blinkie-light controllers, etc.) is, by far, the family of dialects that the C Standard was written to describe. If you want to work with small embedded systems, starting with those dialects is likely to be better than trying to use anything else. If you want to do low-level operating systems programming, C may be better than just about anything else, but one should tackle other forms of programming first. The weaker language described by the C Standard may be useful for high-end numeric processing applications that never have to process untrustworthy inputs, but such things are outside my field of expertise. Those are basically the only purposes for which C is suitable. Unless you're interested in those things (embedded programming is *way cool*), there's no reason to learn either the dialects the Standard was written to describe, nor the weaker language that it actually does describe. 
Sorry, my bad. I edited but it doesn't work. What should I do? If I provide with "hello world" and "is the way", I want to print "hello worldis the way"
“it doesn't work” is not an error description. What do you expect to happen and what happens instead? Also, don't randomly edit the code in your question. Nobody is able to understand what you want if you keep editing the code. If you found out what the mistake was, add a comment under your code with the updated code. Do not change the original code though.
If the stored value of `uif` is not accessed by `uif.x = 2;` what if anything would be illegitimate about a compiler that "optimized" union intfloat { int x; float y;} uif; void temp(int index) { union intfloat temp; temp = uif; // 1 uif.x = 2; // 2 uif = temp; // 3 } by eliminating the third marked statement? The stored values of `temp` and `uif` would match each other after the first statement; if (as stipulated) they aren't accessed by the second, they would thus still match each other going into the third (implying that the third marked statement would be a no-op)? If one recognizes that an access to an lvalue which is visibly derived from `uif` involves both an lvalue of the derived type *and* an lvalue of type `union intfloat`, then `uif.x=2;` is an access of both an `int` lvalue and *also* a `union intval` lvalue. While 6.5p7 wouldn't authorize the use of an `int` to access a `union intval`, it would authorize the use of a `union intval` to access the union object and all the members. 
Because you can do anything in C. 
strcat(a, b); Printf ("%s", a); In mobile sorry for formatting. Try that.
char is always 8bit, int however is at least 16 bit, usually 32 bits, but could be bigger depending on your system.
I am guessing "it doesn't work" refers to the fact that *strcat* is copying the newlines that fgets tacks on to the end of the *a* and *b* arrays so his/her printout ends up being "hello world\ngoog morning\n". &amp;nbsp; Agreed with you about "not an error description" and "don't randomly edit the code". I know this isn't exactly stackoverflow, but it'd be nice if we could somehow communicate to beginners the value of forming good questions.
I am guessing "it doesn't work" refers to the fact that strcat is copying the newlines that fgets tacks on to the end of the a and b arrays so his/her printout ends up being "hello world\ngoog morning\n". Agreed with you about "not an error description" and "don't randomly edit the code". I know this isn't exactly stackoverflow, but it'd be nice if we could somehow communicate to beginners the value of forming good questions. 
Try this: strcat(a, b) printf("%s", a);
After being a c programmer, then going to java I HATE the move to lose typed scripting languages 
strcat concatenates string b on to a, keep this in mind, it does not make a new string, strcat just performs the concatination and then returns the memory address of the destination string. &amp;#x200B; What is wrong can you post a screen shot of the output?
Sorry for the inconvenience caused guys. I will not repeat this again. All it does is print hello world is the way rather than concatenating
Because age ain't nothing but a number.
If you really want to understand what is going on in compiler and how computer see your code then try few first lectures from this course: [https://see.stanford.edu/course/cs107](https://see.stanford.edu/course/cs107) By far the best C content I have encountered on the web. The lecturer is easily uderstandable and capable as hell. After this questions like this above wont bother you anymore.
Yes,it is. My output is hello world is the way What should I do if I want hello worldis the way
The reason this is happening is that when you do fgets(a, 100, stdin); and you type "hello world" and then hit enter/return, then the array *a* looks like this: ['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', '\n'] where \\n is the character representing a new line. If you're on windows it would be \\r\\n because it represents the end of lines like this differently. So, to solve this you need to remove the newline. One approach would be to work backwards from the null terminator and remove a newline char if it exists.
WHY DOESN'T ANYONE SAY THIS! Literally the whole time I've been saying "msvcrt incomplete, give me something good to eat" and now someone tells me that mingw-w64 has a complete C library.
So it's `static` then?
As a general rule, if you're using a C/C++ IDE that's not Visual Studio, deal with the reality that you will have to mess with CLIs. Reminder that you can still edit the code from within visual studio and take advantage of the little IntelliSense it will give you, and use the PellesC CLI to do compilation and execution, passing the include directories with the the `-I` switch, like `... -I "directory1" -I "directory2"` etc. You can also use a batch script as a way lesser version of a makefile. 
I actually like the Pelles C IDE and I did figure out how to get auto-completion to work in it. I'll probably just add the -I and -L paths to compiler commands option within the IDE. Thanks a ton as I had completely forgotten that was an option!
Really? The IDE looks like a slightly improved version of DevC++, which is a way of saying it sucks balls, but it could be worse. If it was my project, I definitely wouldn't have bothered with the IDE part, and focus 100% on the compiler. It's not like C developers aren't already used to just basic text editors since no IDE supports C properly.
i would say, not just C, python, maybe Java (used to be C lite) and even dare I say it PHP as many different languages as you can, even sql in conjunction with the above languages, as much broad exposure as you can manage different syntaxes and grammers the better... is this agile ? well it kinda could be, but C will give you a solid low level grounding, you will (hopefully) learn about memory management which is very useful if anything it should teach you how many apps cause the type of bugs that lead to easy hacks...
&gt;If you're on windows it would be \r\n because it represents the end of lines like this differently. I don't use C much on Windows, but afaik these standard functions do some line ending conversion under the hood, and you only ,,see" \n in your program, just like on a UNIX-like system. (Obviously for compatibility reasons)
yeah I don't know why I find it charming, maybe it's that WinXP flair. I also customized the font and generally looks already so now it kind of feels like home. I don't like how Visual studio code feels (it's kind of clunky) and setting up Visual Studios Community just for code editing feels excessive, like I might as well just use vim (I also really like Vim, I'm just a sucker for ye olde time feels).
printf("hello world" "good morning");
You’re risking a buffer overflow. Your first buffer should be big enough for the resulting concatenation. An easy way to ensure that is to set the size argument for fgets to half the size of a and b.
I'm assuming your goal is Unity development. &amp;#x200B; I'll tell you up front that you have no reason to learn C, unless you want to program robots or build operating systems like MacOS or Windows. Sure, it gives you a good understanding of a computer's internal working, but that is unnecessary to know unless you work in a niche field. &amp;#x200B; If you want to learn C#, just learn C#. &amp;#x200B; For novices, the most difficult part is becoming familiar with the technologies available. Most people give up before they become acclimated. To mitigate this, I'd recommend going with the language that has the weakest path of resistance. This is any language with a good tutorial. Most likely, you'll find the best tutorials for Python, but if you can find a cogent and engaging one for C#, go with that
They are options, and differs between different programs even though there are some conventions. 
Oh so they are arbitrary and depends on who wrote? 
OP if you’re still struggling, the short answer to your question is fgets() records when you press enter after entering the first string and adds it to the buffer. So it really is concatenating the two strings, but the two strings being concatenated are really “hello world\n” + “good morning\n”, so it is not obvious that the strings are concatenated. The way to fix this is to scan the buffers read in through fgets() for newline characters and replacing them with null terminators. There’s numerous other issues with the code you’ve written here, but they’re outside the scope of your question.
strcat() returns a pointer to the destination so his original use would work, though it’s not ideal from a readability standpoint.
Yes, exactly. For most programs you can use the manual to learn about its options: man mkdir You can also use man to learn about man: man man Functions in the C library are also covered by man: man freak You can also read manuals online, e.g. on http://man.openbsd.org.
strcat() returns a pointer to the destination, so his original use would work. His problem is reading in newline characters with fgets() and concatenating the strings without removing them.
Some current systems have char as 16, 32 or 64bit. In the past there have been 9-bit and 18-bit chars and others.
ASCII is one possible encoding system but there are others, e.g. EBCDIC
For #2, I think it's more about not limiting "dangerous" moves the programmer can do. e.g. Hardcoding a pointer
The calling convention and platform ABIs. 
&gt;How should I do it? [Learn how pointers work.](https://pdos.csail.mit.edu/6.828/2012/readings/pointers.pdf) You won't understand char arrays in C till you do. Without using any functions from string.h: #include &lt;stdio.h&gt; char src[] = "goog morning"; char dest[] = "hello world"; char* my_strcat(char *src_p, char *dest_p); int main(void) { char *src_p = src; char *dest_p = dest; char *val = my_strcat(src_p,dest_p); puts(val); return 0; } char* my_strcat(char *src_p,char *dest_p) { char *rdest = dest_p; //placeholder while(*dest_p) { dest_p++; // move dest pointer to null character } while(*src_p) { *dest_p++ = *src_p++; } return rdest; } You can replace my_strcat above with the standard strcat from &lt;string.h&gt;. In general it is a good habit to read the source of any functions you import.
Don't think of variables as 'types' but as 'space'. A char takes one byte(8 bit). an int takes 4 bytes(32bit). So any of the first 8 bits if an int can be stored in char. Technically you can store more but it would cause an overflow/underflow. The type conversion happens behind the scenes in the C compiler.
What makes you think it was intended to be interpreted so narrowly, as opposed to suggesting that it applies more broadly to any abilities that an implementation's customers should be expected to need? Compiler writers shouldn't be expected to be telepathic, nor should they be expected to go to great lengths to support things merely because some customers might conceivably need them. If, however, many customers have been complaining for decades about an implementation's inability to handle some common constructs without disabling many optimizations wholesale, that should be a sign that failure to support such constructs is needlessly impeding programmers from doing what needs to be done. 
Suit yourself. VSCode master race, tho.
This ```man fsck```s
Maybe for a more modern language, but C is nearly 50 years old and must obviously be backwards compatible, seeing as an enormous majority of "low-level" code depends on it. C is a simple and mature programming language. People know what to expect when using it. The point isn't either to add more features or security or ways to express them. C does its job well. Compare this to OpenGl, where people asked for HSL to RGB, physics, built-in contexts, ect. You can keep adding and adding features into your language if you want, but it's not going to make it intrinsically better. C comes from a time where there was no limitation on the stuff you could do with it, no memory or process protection, you could write to the framebuffer directly, ect. No wonder kernels and drivers are mostly written in C. &gt;It seems that perfection is attained not when there is nothing more to add, but when there is nothing more to remove. -- Antoine de Saint Exupéry
Try stackoverflow Also you need to describe you problem in detail, you can’t just say I need help with this program.
To be a well rounded programmer, you need to know a lot of language, I would start with python, after you are comfortable with it and able to do some fairly complicated project and and able to implement ADTs, move on to C, then C++, the Java. Python help you to get into programming C give you tons of knowledge about programming C++ is just a amped up version of C with some powerful features. Basically you can use them together. Java is very broadly used After java you can try JavaScript, note java script is nothing like Java Then Nodejs 
The people complaining have moved on to other languages that better fit what they want a language to do. C persists in spite of those complaints and it's because they don't break it that it continues. It was only 5 years ago that I was working in production code that was not ANSI C compliant (written for a compiler from 86 that did things differently). 
Link to the repository: [https://github.com/SanderMertens/vectorize\_test](https://github.com/SanderMertens/vectorize_test) I wanted to know how much faster using SIMD instructions would be vs. normal non-vectorized code, so I put together a small example that tests a couple of scenarios. See the repository for details.
I feel like a lot of your thoughts are forgetting the history of computers and C. To be fair, most of the history can be forgotten these days because we've settled on how things should be done and gotten enough spare processor/memory to throw hardware at problems. Consider this example... `ntohl()` vs `htonl()`. Why have 2? On little endian machines they are both `no-ops` and on big endian machines they both do the same thing. This isn't the C language proper here, but that would violate the spirit of #4 wouldn't it? Except there used to be a middle endian architecture as well and `ntohl()` and `htonl()` had to do different things by design. There is a lot of C that is based in the fact that it was the wild west when it came to computers back in the day. It's a bit more consistent these days, but there are still those edge cases and it's not supposed to be the compiler's concern to take care of them for the developer (A job i recently interviewed for was using an architecture that didn't allow unaligned memory access... which can make accessing memory slightly more complicated).
C is a great language to know definitely learn if you have time happy coding
You could start by telling us what you're having trouble with. What's it doing, compared to what you think it's supposed to be doing?
That's a standard disclaimer for strtok(), which is why strtok_r() and strtok_s() exist.
Some things I noticed: * You prototype two functions but don't actually call them in main(). * Some of the prompts for user input don't have corresponding variables to store that input. * If the user types in lower case your if statements won't recognize the answer properly. * When using scanf() with a char variable you need to include a space (" %c", ... ) or newline character ("\n%c", ... ). [Explanation](https://gsamaras.wordpress.com/code/caution-when-reading-char-with-scanf-c/)
Please edit your post to format your code correctly.
gdb is the main tool you’ll need. As for binary exploits, learn about buffer overflows.
There was [some interesting discussion](https://www.reddit.com/r/C_Programming/comments/9z76mk/why_arent_there_c_conferences/ea72wj2) about this recently.
You could use strcat. char str[128]; strcat(str, "hello world"); strcat(str, "good morning");
Out of curiosity I created a small benchmark program to test the effect of vectorized vs. non-vectorized code. When code can be vectorized, compilers can in some cases use SIMD instructions, which are optimized for doing operations on large amounts of data. Details are in the repository readme: [https://github.com/SanderMertens/vectorize\_test](https://github.com/SanderMertens/vectorize_test)
Sbrk and how the stack works. Fun with redzones. 
This is wrong on so many levels. Makes me shiver 
Learn about the stack, heap, calling conventions, pointers and Assembly
The descriptions in the README flip SoA and AoS.
Oops- nice catch. Fixed it.
I didn't write #4. Having functions which may differ in corner-case behavior on implementations where that would make sense would be is useful and cheap, and the Standard really should do that more often. While it should be possible for an implementation to implement a single `memmove` function and have many other functions chain to that, the Standard library should recognize that there are many situations where a programmer knows something about the operands to `memmove` or `memcpy` that the implementation might benefit from knowing at compile-time. Implementations that don't benefit from such information could simply treat the different functions identically. My big beef with "modern" compilers, though, is that the authors seem to view the Standard as passing judgment on what programmers should need to do, and thus feel they have no obligation to support anything not mandated by the Standard. On some obscure platforms (e.g. those that use ones'-complement arithmetic), code to make evaluate `unsigned mul(unsigned short x, unsigned short y) { return x*y; }` perform an unsigned multiplication that works for product values between `INT_MAX+1u` and `UINT_MAX` would cost significantly more than code which only needs to work for values up to `INT_MAX`, and it might make sense to require that programs targeting those platforms must cast the operands to `unsigned` if they want the function to be usable with such values. It makes no sense, however, for a "quality" compiler targeting a modern two's-complement platform to process such a function in ways that will almost always handle values up to `UINT_MAX`, but which may occasionally behave in arbitrary fashion for values between `INT_MAX+1u` and `UINT_MAX`. Most programs are subject to the following constraints: 1. When given correct data, produce correct results. 2. When given incorrect, invalid, or even malicious data, don't do anything particularly harmful. Implementations that can uphold even loose behavioral guarantees in cases where the Standard imposes no requirements may be able to accomplish #2 far more conveniently and efficiently than those that treat UB as an excuse to completely jump the rails. While "modern" compilers' treatment of UB might be reasonable in cases where programs will never be fed malicious data, it is dangerously unsuitable for other, far more common, purposes. 
SoA/AoS layouts yield expected results for the use case in this benchmark, but I'm wondering how different would it be if you were doing a binary search on a very large array, so the first few jumps were much larger than a cache line.
C became popular because, when processed by simple compilers, the range of semantics available to the programmer would very nicely follow the range of semantics provided by the execution environment. Unfortunately, today's compiler writers like to pretend that since the Standard didn't mandate such semantics, they were never "really" supported and any code that used them was always "broken". It seems that in their view, programmers should be happier with a compiler that can turn `(x&gt;&gt;y)|(x&lt;&lt;((32-y) &amp; 31))` into a rotate-right instruction and turn `(x&gt;&gt;y)|(x&lt;&lt;(32-y))` into code that only works when `x!=0`, than one which would turn that into an inefficient mess of machine code for the former construct but would yield a rotate right instruction (that works even when `x==0`) given the latter. Perhaps the dialect processed by gcc/clang with optimizations enabled might serve some useful purpose in some fields, but it's far removed from the language the Standard was written to describe. What I'd like to see added as features would be the ability to start a program with some macros and/or directives identifying various semantic guarantees it requires, and other guarantees it's willing to waive, so that if a program started with a directive requiring that the "strict aliasing rule" only be used to identify things may alias (as opposed to restricting type punning of clearly-derived references), as well as one waiving aliasing of character types, then an implementation given: char could_assume_no_aliasing(int *ip, char *cp) { *ip = 1; *cp = 2; return *ip; } int must_recognize_type_punning(int *ip, int j) { *ip = 1; ((short*)ip)[j] = 2; return *ip; } would not be required to accommodate the possibility that `cp` might alias `ip` in the first function, since there is no visible relationship between `cp` and anything of type `int*`, but would be required to recognize that `((short*)ip)[j]` might identify the same storage as`*ip` since it is visibly freshly derived from the address of `*ip`. Maybe there are some purposes for which having the compilers allow for type punning in the first but not the second would be useful, but many more programs would need a compiler to recognize the second pattern than would need it to recognize the first. 
If the array doesn't fit in any of the caches, and access to the array elements is more or less random, I suppose the performance would degrade to having randomly allocated blocks on the heap. Still, you could use SoA to decrease the chance of a cache miss. Even if you hit the cache in 30% of the cases, it would still improve performance noticeably. Thinking about this a bit longer.. I wonder if anyone has ever tried to use some kind of heuristics to determine which paths in a tree are most visited, and store those nodes close together in memory.
I see, thanks.
I don't get it, why shouldn't it work. You have two buffers (a and b). strcat puts b after a in a and returns a char \* on a. &amp;#x200B; You printf the value of a. &amp;#x200B; To fill a and b you have to press return, that "return" gets into both (a and b) and get printed as '\\n'
If you want to learn C# or Python, don't begin with C. Beginn with a language you want to learn and learn C if you get real usage out of it, because the time you lose isn't worth the knowledge you get. &amp;#x200B; I would learn C# if the only platform I work is windows. If you work on other platforms too, learn python.
Thanks guys...I am learning C as my second programming language specifically for this binary exploitation purpose.
Let me be more specific with that one time I had to experiment with AoS/SoA layouts. I was doing a binary search on `char[132624][5]` (representing one unicode codepoint), looking for a `char[5]`. In theory, have no idea which one of those 132624 strings is the one I'm looking for, in practice, multibyte unicode codepoints are not nearly as common as single byte ASCII compatible codepoints, so most of the time only the first 127 were relevant. I wonder how the heuristic you mentioned could be implemented.
If you frequently do binary searches, consider using [B heaps](https://queue.acm.org/detail.cfm?id=1814327) instead.
&gt; To be a well rounded programmer, you need to know a lot of languages I cannot stress the importance of this enough. Make sure that the languages you learn are diverse in their paradigms. Little is gained from learning 20 different class based, statically typed, single dispatch, object oriented languages with single implementation inheritance and multiple interface inheritance.
Thanks for that link. It's an interesting read, though the piece of code I was talking about would usually do a bunch of searches at the start of the program's life time and rarely be run later, so it's not that big of a deal if it doesn't run super fast.
Ha, that was a good bad typo. Wonder if my Mac has autocorrect left on.
How do I install bake? Instructions on those repositories error out.
 #include &lt;stdio.h&gt; int main() { int p[] = { 1633903938, 543519605, 1633886281, 1701978222, 1830839393, 1701650553, 2037542765, 1869094956, 1752440951, 1969627237, 1226861411, 1851881248, 8564 }; (void) printf("%s\n", (char *) p); return 0; } &amp;#x200B;
&gt; I didn't write #4. No, but you interpreted 4 and said the language/compilers didn't follow it. I was providing a historic context.
This is where the error is , I have more code.
Would you be able to show us the rest of the code? The context would be valuable.
This is the class.cs &amp;#x200B; **public** class BankAccount { **private** **double** *balance*=0; //a private member field **private** **double** *interestRate*; // a private member field **private** **double** *InterestEarned*; // a private member field **private** **int** *accountNo*; // a private member field **private** **double** *Deposits2*; // a private member field **private** **double** *Withdrawals2*; // a private member field **public** **double** **GetBalance**() //a getter method { return *balance*; } **public** void **Deposit**(**double** n) // a deposit method, a setter method { *balance* = *balance* \+ n; //same as balance += n; } **public** void **Withdraw**(**double** n) // a withdraw method { **if**(n &gt; *balance*){ Console.**WriteLine**("Not enough funds to match withdrawel"); }**else**{ *balance* = *balance* \- n; //same as balance -= n; } } **public** void **Interestearned**() { *InterestEarned* = *balance* \* *interestRate*; } **public** void **setInterest**(**double** interest) { *interestRate* = interest; } **public** void **printInfo**(){ Console.**WriteLine**("AccountNo: " + *accountNo* \+ "\\tBalance: " + *balance* \+ "\\tInterestEarned: " + *InterestEarned* ); // Console.WriteLine("Account number " + accountNo); // Console.WriteLine("Balance "+balance); // Console.WriteLine("Interest Earned "+InterestEarned); } **public** BankAccount(**int** acc , **double** bal) { *accountNo* = acc; *balance* = bal \* 1.1; } 
You don’t seem to be closing your brackets after the for loop. 
This is the program(The main) string username, password; //username and password variables **int** loginAttempts = 0; //Login Attempts counter //Simple iteration up to three times **for** (**int** i = 0; i &lt; 3; i++) { Console.**WriteLine**("Enter username"); username = Console.**ReadLine**(); Console.**WriteLine**("Enter password"); password = Console.**ReadLine**(); **if** (username != "blessing" || password != "ccp3") loginAttempts++;//increment counter **else** break; } //Display the result **if** (loginAttempts &gt; 1){ Console.**WriteLine**("Login failure"); }**else**{ Console.**WriteLine**("Login successful"); } Console.**ReadKey**(); // if statement to check if the user wishes to continue //Console.WriteLine("Would you like to continue press Y for yes or Key N for No"); //string temp = Console.ReadLine(); //if (temp == "Y"){ //} //} //else if (temp == "N") { //} **int**\[\] accountNo = { 80045001, 80045002, 80045003, 80045004 }; **double**\[\] initBalance = { 100, 200, 300, 400 }; **double**\[\] deposit1 = { 100, 200, 300, 400 }; **double**\[\] withdraw1 = { 50, 50, 50, 50 }; **double**\[\] interestRate = { 0.01, 0.02, 0.03, 0.04 }; **double**\[\] deposit2 = { 10, 200, 300, 400 }; **double**\[\] withdraw2 = { 155, 50, 50, 50 }; BankAccount\[\] gobshites = **new** BankAccount\[4\]; **for** (**int** i = 0; i &lt; gobshites.Length; i++) { // start at 0 , check if your less than 4 if so execute statement gobshites\[i\] = **new** BankAccount(accountNo\[i\], initBalance\[i\]); } **for** (**int** i = 0; i &lt; gobshites.Length; i++) {// start at 0 , check if your less than 4 if so execute statement gobshites\[i\].**Deposit**(deposit1\[i\]); gobshites\[i\].**Withdraw**(withdraw1\[i\]); gobshites\[i\].**Interestearned**(); } // if statement to check if the user wishes to continue Console.**WriteLine**("Would you like to continue press Y for yes or Key N for No"); string temp = Console.**ReadLine**(); **if** (temp == "Y") { gobshites\[i\].**printInfo**(); Console.**WriteLine**("PRESS"); Console.**ReadKey**(**true**); Environment.**Exit**(1); **else** **if** (temp == "N"){ } **for** (**int** i = 0; i &lt; gobshites.Length; i++) {// start at 0 , check if your less than 4 if so execute statement // gobshites\[i\].printInfo(); // Console.WriteLine("PRESS"); //Console.ReadKey(true); //Environment.Exit(1); // } //} **else** **if** (temp == "Y"){ **for** (**int** i = 0; i &lt; gobshites.Length; i++) { gobshites\[i\].**Deposit**(deposit2\[i\]); gobshites\[i\].**Withdraw**(withdraw2\[i\]); gobshites\[i\].**setInterest**(interestRate\[i\]); gobshites\[i\].**Interestearned**(); gobshites\[i\].**printInfo**(); } } } Console.**Write**("Press any key to continue . . . "); Console.**ReadKey**(**true**); } } } } 
This doesn't look at all like C, I think you're in the wrong subreddit.
Should be C#
K &amp; R in the sidebar
I can't tell you whether it's a good idea for you, but for me C was the first language that "clicked" with me, after trying java and lua and thinking that I was just too stupid for programming, so don't assume that the "easy" languages are necessarily better for you.
Example?
&gt; I wonder if anyone has ever tried to use some kind of heuristics to determine which paths in a tree are most visited, and store those nodes close together in memory. This has more to do with understanding the environment where your code is running (for example, you either might have a whole CPU to yourself, or just a single core, or none of that, and depending on those alone, how often you run into cache misses is not only completely out of your hands, but also not benchmarkable outside of the business environment, which is why in business world, stress tests are usually done in the clients environment, not on the desktop of some random developer) and how the code is usually called, as a heuristic program like that would most likely produce different results for monday morning and friday evening in real world business environment and would not be a very feasible way of "brute forcing" the answer to the question of "how to do this efficiently?". It is a worthy analysis to do though, but I'd say you won't get a general answer, but rather lots of different scenario-based answers, where the closer to actual business environments those scenarios are, the more accurate the results are (and vice versa). 
It's nice, but how did you perform the test? Even Stroustrup was using a benchmark when he was talking about the performance difference of array based vs linked list based data because of cache misses. He was right of course, but that's despite his benchmark code error, not because of it. The error he made was using code that had to traverse the whole linked list despite always adding to one side of the previous insertion. The code thus was a performance test for random accessible arrays vs linked list insertion speed, not the effect of cache misses. It's easy to say "My benchmark proves X and Y", but making a benchmark that actually proves that is much harder. The best way to do it would be to implement some real-world software in a real-world business environment with a real-world business scenario, one optimized to work with vectorized data, one with non-vectorized data and see what the actual difference is. ---- I've read your code and unfortunately it just resembles any other desktop based microbenchmark that doesn't really look like it's properly simulating a system running in a business environment of any kind, and as such, I would treat the results as only applicable to very specific scenarios - basically one-program cpus crunching massive amounts of data, which is not a scenario that resembles typical business environments (more that of a desktop user with very little else running on the machine while running the benchmarked code) and as I see no analysis on what kind of business code would fall under the scenario this particular test is benchmarking, it's hard to see how the result could be used for anything substantial. The things your benchmark 'proves' are things we already know, we just don't know their actual effect in an actual business environment - preferably the one we have to work with - which is what we want to know.
Also, if there is no documentation in man, try -h or --help which are commonly used to show program usage
I mean, it won't actually concatenate the strings, but if the goal is just to display 2 strings side-by-side, it'll work. I learned about this method from second edition of "The C Programming Language," by Brian Kernighan and Dennis Ritchie. Why is this method considered so blasphemous?
C# is off topic in this subreddit. Please post C# questions to /r/csharp instead.
I directly quoted the list of principles in its entirety, verbatim. I think that #2, with the implication from #1 that the programmer should be trusted to know what needs to be done, are by far the most important principles, but in the interest of honest discussion I quoted the principles exactly as the authors of the Standard wrote them, even though I don't 100% agree with all of them as worded. If the authors of the gcc/clang wanted to make a principled argument that one or more of the principles should no longer be considered relevant today, I'd be interested in hearing that. I myself would be willing to argue that the design trade-offs implied with #3-#4 should be weighed differently today than in 1989. Among other things, instead of splitting the language into diverging dialects--a general-purpose dialect which is suitable for a wide range of purposes including systems programming but only allows very limited optimization, and an aggressively-optimized dialect that is only suitable for a few specialized purposes, I'd much rather see a standard language that can reliably do most of the things that the general-purpose dialect can but still allows most of the optimizations performed by the latter dialect. The kinds of optimizations that are easiest to perform often yield the biggest payout while imposing minimal semantic restrictions, and I fail to see any good reason why a quality compiler shouldn't be able to enable those without having to also enable far more aggressive optimizations that aren't suitable for most purposes. Which of the following is the most broadly useful meaning for `int1*int2 &gt; int3;`? 1. Perform the multiplication, truncating the result to the range of `int` and then do the comparison. 2. Perform the multiplication, truncating or not at the compiler's leisure, and then do the comparison. 3. Perform the multiplication and comparison if the product is within range of `int`, and behave in uselessly unpredictable fashion otherwise. There are many situations where #2 would enable useful optimizations that would be blocked by #1. There are far fewer situations where #3 would enable optimizations that would not be possible with #2. Relatively few programs would care about the distinction between #2 and #1, provided that casting a value to a type would force truncation (so a programmer needing the semantics of #1 could write `(int)(int1*int2) &gt; int3`). If the product would never overflow when a program receives valid data, and the result of the comparison wouldn't matter if the program receives invalid data, the second form of semantics would allow a program to eliminate overflow checks that would be required under the third, and thus achieve better performance despite the fact that the third form supposedly makes things more "efficient". 
Which platform did try to run it on?
&gt; is there reserved memory for structure, which aren initialised yet? No. &gt; What is meant with - struct test2 *p1, p2; ? That line declares two variables. `p1` is a pointer to a `struct test2` object (though it's currently not pointing anywhere). `p2` is a `struct test2` object. &gt; and the p2 ist a structure initialised of datatyp struct test2? Neither `p1` or `p2` are initialized. You'll need to point `p1` at a `struct test2` somewhere, either one declared in the program like `p2` or one you create with `malloc` or similar. You can use `p2` straight away but you can't assume anything about the value of any of the elements in it. As for the size of `struct test2` - it can be difficult to tell. The compiler will add padding where necessary so the elements fall on word boundaries. The easiest way would be to do something like this: printf("%zu\n", sizeof(struct test2)); 
Linux.
Thanks for your reply! I totally agree you should be careful when extrapolating benchmarks, which is why I put the disclaimer in my post: "these measurements shouldn't be taken at face value" Regarding this statement however: \&gt; The things your benchmark 'proves' are things we already know Based on the kinds of questions I see being asked in this subreddit I wouldn't want to assume all 44k subscribers do. I think there's likely to be a fair number of people that see this for the first time. \&gt; doesn't really look like it's properly simulating a system running in a business environment of any kind, and as such, I would treat the results as only applicable to very specific scenarios - basically one-program cpus crunching massive amounts of data, which is not a scenario that resembles typical business environments (more that of a desktop user with very little else running on the machine while running the benchmarked code) You mean like computer games? SoA is often associated with [ECS](https://github.com/SanderMertens/ecs-faq)\-style programming, in which case the code is structured in a way that makes it much more likely to consistently achieve the performance improvements measured by this benchmark. Also, I would like to point out that your description of a "business environment" is IMO a bit limited (something that runs on a "business server"). The business apps you are describing sound like software running some companies' IT infrastructure (probably not written in C). There is a vast number of other kinds of (OT) applications, like machine learning, image processing, data mining, sensor fusion, simulation, and so on- that could (and probably does) benefit from this. 
Oh, that should definitely work (just tried it on my Ubuntu machine and it works). Could you create an issue with the error you're getting in the repository? Thanks!
I really liked LiveOverflow’s series on binary exploitation, and he goes over how C is compiled on older systems. Maybe you would find that interesting!
I changed the command for the application to this: ``` bake clone SanderMertens/vectorize_test --cfg release bake run vectorize_test --cfg release ``` Can you try it again? Looks like an issue in bake (it can't find the project if it is not in the release environment).
No. While `const` prevents some misuse, `restrict` basically just tells the caller to be very careful. It has the "opposite" effect on memory safety.
The `restrict` qualifier does propagates like the `const` qualifier. However, it's typically the pointer itself that's `restrict` and the thing pointed to that's `const`, so you generally don't see it come up with restrict. void foo(const int *p) { int *x = p; /* warning: discards 'const' qualifier */ } void bar(const *restrict p) { int **x = &amp;p; /* warning: discards 'restrict' qualifier */ } &gt; &gt; always use restrict if the pointers in a function aren't aliasing That's not an unreasonable rule so long as those pointers truly never alias. Unlike `const`, it's a hard and fast part of the contract. In practice using `restrict` can make your C slightly less portable since a certain major compiler (*ahem* Visual Studio) is still stuck in the 1980s and doesn't yet support `restrict`. 
It’s a good rule to follow, but as opposed to not using const correctness, which invalidates programs, not doing restrict correctness will never hurt you. Also restrict is only useful when a function takes two arguments of the same pointer type. This is pretty limited so you don’t see people advocate strongly for it. Finally restrict is a C99-ism, so any pure ANSI program won’t want to use it. 
I recommend against this rule. It’s not stupid per se, but `restrict` functions fairly differently from `const` and only applies to specific situations. There’s also very little checking of whether things might *actually* alias, since that might not be resolvable until run time, and it’s easy to accidentally coerce away the `restrict` in an assignment or function call. With `const`, and to a lesser extent, `volatile`, the compiler can much more easily check that you’re not violating the language rules, and you have to cast explicitly if you want to de-`const` or de-`volatile` something. `const` and `volatile` also apply much more widely than the exactly-one situation that `restrict` is meaningful (i.e., applied directly to types of function definitions’ arguments). `restrict` is also C99, so if you’re aiming for portability to C89 or C++, you need to `#define` yourself a pseudo-keyword for something compiler-specific like GNU `__restrict__`, and even then `__restrict__` is mostly ignored when it comes to the C++ type system. (E.g., a `template` would see no difference between a `char *` and `char *__restrict__`. OTOH in C++ you can apply `__restrict__` to references, which may be helpful on occasion.) If you want to use `restrict` more liberally in function *prototypes*, that’s fine, and it won’t break anything one way or another. It’s mostly ignored on that side of things, like `const` and `volatile` as applied to the parameter type, but it’s useful for documenting that you don’t want aliases. (At least in theory; I guess an overly clever compiler could use it to “prove” that two callee args don’t alias, but that’d be iffy vs. the standard.) You can add or remove `restrict` to/from the prototype as you please while setting up your API, and then when &amp; if you need to you can officially cinch down the implementation without breaking anything.
I mean, I guess? It's kind of dangerous, though. as far as I'm aware, the restrict keyword is more or less telling the compiler that, as a programmer, you know what you're doing. This means the compiler might do some aggressive optimizations which emit code machine code that assumes the pointers never, ever alias. If they do alias while restricted, the compiler won't help you. If this goes wrong it's kind of a pain to debug (undefined behavior and all that). So the question is: can you, as the programmer, absolutely, without a shadow of doubt, ensure the pointers don't alias? Good luck!
You'll need a build of GTK+ that's linked against musl, including all of its own dependencies. Unless you're on a musl-based Linux distribution, you'll have to do this yourself. You'll also need to direct `pkg-config` to use your build (via `PKG_CONFIG_PATH`) instead of the one installed on the system.
Language is just a tool. Pick something you want to do and then pick a tool that works best for it. If you just want to start coding, most modern languages are ok to do so. Overtime, you will figuire out if programming paradigm provided by chosen language is the right one.
Thanks for posting that, as it's very relevant to our production workloads. Also, I agree about the models being outdated. Things like cache-friendliness are becoming ever more dominant in the real-world performance equation. For example, [this paper](https://onlinelibrary.wiley.com/doi/full/10.1002/spe.2511) shows that naive string searching algorithms can outperform clever ones due to SIMD instructions on modern CPUs. 
Actually this wouldn’t work with any compiler i know. First argument is one string in double quotes, then a colon followed by the arguments which occurred as placeholders in the first argument: printf( "%s %s\n", "one", "two"); Usually one would use variables. So there is a type check when trying to output. Two double quotes as one argument have no meaning in terms of syntax in C. Two static pointers where only one is expected.
You must provide to `free` exactly the pointer that was given to you by `malloc`. Your code allocates an extra spot for the size and then adjust the pointer to be after this spot, and then apparently passes this adjusted pointer to `free`. This entire scheme is a bit odd. I would recommend making a structure to hold the size and array together using a "flexible array member."
How are you calling `freeArray()`? My guess is that you're passing in the value returned by `createArray()`, but you need to undo the `array++` somehow.
 free(*array); In your function, "array" is of type double *. When you write " *array " you are dereferencing a pointer to double and then you are trying to free it.
Your functions want to be called like this: double* array = createArray(...); ... freeArray(&amp;array); But my guess is you're not doing that. My guess is that you're calling it like this — freeArray(array); — and ignoring the helpful warning your compiler is giving you that that code is wrong.
but i heard some programming language like PHP make you get bad habits, and some programming language like C# make you learn good habits. i don't know about C, and i don't want to learn the whole C language, there's two famous introduction to computer science course available, Harvard CS50 which is based on C, or MIT introduction to computer science and programming using python. i don't know take which course, the C one ore the python, that's why i asked this question. Thanks :D &amp;#x200B;
Calling it in main as `freeArray(&amp;array);`
First: Are you calling `freeArray()` like this — double* array = createArray(...); ... freeArray(array); — or like this — freeArray(&amp;array); — ? Second: It looks like `freeArray()` should be readjusting the pointer it gets before it passes it to `free()`, shouldn't it? Since you adjust the pointer before you return it from `createArray()`?
you are right but there's two famous introduction to computer science course available, Harvard CS50 which is based on C, and MIT introduction to computer science and programming using python. i don't know take which course, the C one ore the python? which is better for me? that's why i asked this question. Thanks :D &amp;#x200B;
but i heard some programming language like PHP make you get bad habits, and some programming language like C# make you learn good habits. i don't know about C, and i don't want to learn the whole C language, there's two famous introduction to computer science course available, Harvard CS50 which is based on C, or MIT introduction to computer science and programming using python. i don't know take which course, the C one or the python, that's why i asked this question. Thanks :D &amp;#x200B; &amp;#x200B;
 i don't want to learn the whole C language, there's two famous introduction to computer science course available, Harvard CS50 which is based on C, and MIT introduction to computer science and programming using python. i don't know take which course, the C one ore the python? which is better for me? that's why i asked this question. Thanks :D &amp;#x200B;
but i heard some programming language like PHP make you get bad habits, and some programming language like C# make you learn good habits. i don't know about C, and i don't want to learn the whole C language, there's two famous introduction to computer science course available, Harvard CS50 which is based on C, and MIT introduction to computer science and programming using python. i don't know take which course, the C one or the python? which is better for me? that's why i asked this question. Thanks :D
Okay, then you need to backtrack the pointer before freeing it. free( (*(array))-1 );
I would recommend Python. It has the least path of resistance
&gt;void free(void \*ptr); free the same thing that was malloced, free doesnt care about types, like like malloc doesnt generate types. You arent mallocing an array, your mallocing a void that you are choosing to use as an array, so dont try freeing an array, instead of calling your freeArray function just call &gt;free(array); &amp;#x200B;
Got it figured out. Seems obvious now, but thanks everyone for the help!
Overlooked that. Thanks!
&gt; In practice using restrict can make your C slightly less portable since a certain major compiler (ahem Visual Studio) is still stuck in the 1980s and doesn't yet support restrict. Sounds like a them problem.
Thanks for posting this. If others had trouble getting bake to work, here is a standalone version: Let me know if I'm horribly wrong regarding build flags. https://pastebin.com/L5dQrRm7
The behavior of `restrict` is totally different from `const`. The act of storing a value into a restrict-qualified pointer R essentially says that within the lifetime of that pointer, one of the following will be true of every byte accessed via any pointer derived from it: 1. The value of the byte will not change during the lifetime of R, 2. All accesses made to the byte will be made with pointers that are derived from R. If a function receives a `restrict`-qualified parameter and copies it into two non-restrict-qualified pointers, those pointers would be allowed to freely alias each other and the original pointer, but forbidden from aliasing anything that wasn't derived from the original pointer. If the pointer had been copied into `restrict` qualified pointers, then neither of those pointers would not be allowed to alias anything that wasn't derived from it--not even the original parameter. Note that while aliasing may seem confusing, most functions will either be designed in a way which meaningfully supports aliasing or they won't, and if the design of a function would not meaningfully support aliasing, it may as well use `restrict`-qualified arguments.
Using `restrict` when appropriate will allow nearly all of the performance advantages associated with `-fstrict-aliasing`, while reaping the semantic advantages of `-fno-strict-aliasing`.
&gt; So the question is: can you, as the programmer, absolutely, without a shadow of doubt, ensure the pointers don't alias? Functions will often be unusable in cases where pointers alias, for reasons that have nothing to do with `restrict`. If a function reads data from memory addressed by one pointer and writes results to memory addressed by another, then unless the sequence of reads and writes is known to be safe in various aliasing scenarios [e.g. the last read of element N will precede the first write of any element M &gt;= N] the function would be unsafe to use in aliasing scenarios with or without `restrict`. Incidentally, if there were a qualifier which would invite a compiler to perform reads eagerly or defer writes, but without inviting the arbitrary reordering allowed by `restrict`. that could allow many of the optimizations facilitated by `restrict` but be usable in many more situations. I don't know of any plans for such a directive, however. 
I don't know any of them, but the python one sounds more "fun" .
why not just use printf, sizeof(StructName)
https://en.cppreference.com/w/c/language/main_function
You get command line arguments by changing the signature for `main`: int main(int argc, char *argv[]) // Note: char **argv is also acceptable When your program is run, the OS sticks all the command line arguments into an array, which your program can access with `argv`. By definition, `argv[0]` is the name of the program itself, and those that follow are the actual arguments. `argc` is the size of this array (and so includes the program name). IIRC, the array is actually one larger than is claimed, and `argv[argc]` is `NULL`. Putting it all together, the pattern to use a command line argument is as follows: int main(int argc, char *argv[]) { if ( argc != 2 ) { fprintf(stderr, "Usage: %s file_name\n", argv[0]); return EXIT_FAILURE; } printf("Opening file: %s\n", argv[1]); } Running it in a bash shell: $ ./test Usage: ./test file_name $ ./test hello_world.txt Opening file: hello_world.txt 
The only thing I noticed was that you're using \`-O2\` instead of \`-O3\`. Other than that, looks good!
&gt; can you, as the programmer, absolutely, without a shadow of doubt, ensure the pointers don't alias? It's like asking car manufacturers if they can ensure drivers won't violate traffic laws. If you're designing something for other people, design it to prevent Murphy, not Machiavelli.
&gt; takes *two* arguments Interesting...
&gt; In practice using restrict can make your C slightly less portable since a certain major compiler (ahem Visual Studio) is still stuck in the 1980s and doesn't yet support restrict Compile with `-Drestrict=` (or whatever VS's equivalent is). The standard specificalls says that you can remove all instances of `restrict` from a program without changing its semantics. 
&gt; Also restrict is only useful when a function takes two arguments of the same pointer type. Not true. 
If they are different types, then the pointers are already assumed to not alias due to strict aliasing.
It can also be used when the function takes one argument, or for things that aren't function parameters. (And the strict aliasing rule has some cases where pointers of different types are allowed to alias, I guess you omitted mentioning that from brevity)
I guess it can be useful if the function uses a statically-allocated variable, and you know the argument doesn’t alias with it. 
Another worthy distinction is that `const` is mostly useful for the programmer, whilst `restrict` is mostly useful for the compiler.
If the compiler supports `restrict`, and then violates the `restrict` contract through "aggressive optimization", then it's a compiler bug and should be reported to the developers. AFAIK `restrict` is the only safe way to use vector mathematics instructions inside of a function whose inputs are pointers to the arrays.
Necro, but they were! With a demand for a portable os comes a demand for a portable language
Why call another function to \`free\` your custom allocated container? Not that it's not an array. Keep your \`malloc\`s and \`free\`s symmetric and in the same scope. Arrays are containers that hold at most one type of element. So if you need a double array, but want to take its size on runtime, you can read the number \`n\` and create the array with double \`dArray\[n\]\`. 
This sub is for the C programming language, not C#; try asking in /r/csharp. Before you do so, though, please read [https://idownvotedbecau.se/imageofcode](https://idownvotedbecau.se/imageofcode), and make sure your question describes the specific problem you're having (cf. [https://idownvotedbecau.se/itsnotworking/](https://idownvotedbecau.se/itsnotworking/)).
Don't use `__USE_MISC`. That's an implementation detail of glibc and not an interface. Instead define `_DEFAULT_SOURCE` (or, for older glibc, `_BSD_SOURCE`) before including any header files, including `stdio.h`. These are called *feature test macros*. Or, even better, just define it yourself since `M_PI` is non-standard. #define PI 3.14159265358979323846 &gt; It's not very accurate at all. Are you sure you're not mixing up radians and degrees? Your function is very accurate around zero — where this taylor series is centered. Between -1 and 1 radians you're basically just running into the limitations of `float`. &gt; What I'm confused about on this part is how linear interpolation would &gt; find a more accurate result I suspect the purpose is to find a less accurate result *faster*. On some much older or less capable computers, computing a Taylor series is slower than linear interpolation. This technique is unusual these days. 
I might indeed be mixing up radians and degrees. Input must be in degrees, and I tried to convert the degrees to radians via x = input_angle * (M_PI/180); which is now x = input_angle * (PI/180); per your suggestion. Can you elaborate a bit more on how I could be mixing up degrees and radians and how it could be affecting my code? Furthermore, do you mean -1 and 1 radians, or -1 and 1 pi? Where could I center the taylor series so that it is accurate throughout 0 degrees to 359/360 degrees? How do I recenter a taylor series? I apologize for the flood of questions, I'm just lost in trying to implement a Calculus II concept when I'm just getting started on Calculus I.
&gt; Can you elaborate a bit more on how I could be mixing up degrees and &gt; radians and how it could be affecting my code? The `sin()` function in C takes radians while your function accepts degrees. It's unusual for math functions to work in degrees. So when you're comparing your results to `sin()`, make sure you're not making a mistake like this: float err = sinf(x) - maclaurin_sine(x); &gt; Furthermore, do you mean -1 and 1 radians, or -1 and 1 pi? Radians. I just picked an [arbitrary, thin slice](https://www.wolframalpha.com/input/?i=plot+sin(x\),+x,+-1,+1) to look at. You can see how the accuracy really starts to drops off after 1.5 radians: * [plot](https://www.wolframalpha.com/input/?i=plot+sin(x\)+-+(x+-+x%5E3%2F3!+%2B+x%5E5%2F5!+-+x%5E7%2F7!+%2B+x%5E9%2F9!\),+x,+-pi,+pi) &gt; Where could I center the taylor series so that it is accurate &gt; throughout 0 degrees to 359/360 degrees? It's a polynomial, so you can't. Instead you do it piecewise. You'll have a Taylor polynomial around zero, then another, say, around pi / 2. It's a periodic function, so you map the input to whichever Taylor polynomial is closest to the input. Note how the shape of the curve around 0 is the opposite (negative) of the shape of the curve around pi and -pi. That means you can reuse the same Taylor polynomial to compute inputs around these regions. &gt; How do I recenter a taylor series? I always look this up when I need it, so I don't know offhand. You can find resources online for computing the Taylor series at different places along sine. You really just need another around pi/2. 
From the caller's side, a function signature like `void copyBytes(unsigned char *restrict dest, unsigned char const *restrict src, size_t n);` does imply that the act of calling the function won't change anything addressed by `src` *whose address wasn't exposed to the outside world via other means*, but each `restrict` qualifier is only applicable to bytes which are accessed with a pointer derived from the corresponding argument. Since a compiler can't assume any bytes would be addressed in that fashion, it can't assume anything about the arguments except in some rare cases where the address in question has never been exposed to the outside world.
The `restrict` qualifier is useful in many more situations than those where functions take two arguments, since `restrict` not only says that an argument won't alias other pointer arguments, but it also indicates that it won't alias objects accessed via other means, such as symbols with file or external scope. 
The "Strict Aliasing Rule" does indeed require that compilers to allow for the possibility that non-`restrict`-qualified pointers of character types might alias anything, despite the fact that almost no code in fact aliases things using character-type pointers, and allows implementations to break many useful constructs, including almost all situations where the Common Initial Sequence rule would be meaningful, in cases that don't involve aliasing. Note that use of a derived pointer as the exclusive means of accessing an object within the context of its derivation is *not* aliasing, but since the footnote to the Strict Aliasing Rule (which says the purpose of the rule is to specify circumstances where compilers must allow for the possibility of things aliasing) isn't normative, gcc and clang use it as an excuse to be willfully blind as to how pointers are formed, even within the immediate context of such formation. 
&gt; AFAIK restrict is the only safe way to use vector mathematics instructions inside of a function whose inputs are pointers to the arrays. In some cases, clang will use pointer arithmetic to check whether pointers overlap and select an approach for performing the operation based upon whether they do. BTW, the same principle could be applied by programmers to write a function that behaved like `memmove` in strictly conforming C even if all the arguments were `restrict`-qualified. Before doing anything else, iterate up to `size-1` checking whether `src+i==dest` or `src==dest+i`. If no address match is found, copy bytes from `source` to `dest` in any convenient sequence. Otherwise copy bytes to `dest` from either `dest+i` or `dest-i`, in appropriate sequence. In the overlap case, `dest` would be the root of all pointers actually accessed during the execution of the function, satisfying the requirements for its `restrict` qualifier. 
I commented some out, but they should all work: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; double *createArray(int n, int size) { double *array; array = malloc((n + 1) * size); //mallocs 1 extra for the size array[0] = (int) n; array++; for(int i = 0; i &lt; n; i++) { array[i] = i; //sets all elements to 0 } return array; } void freecall(void *ptr) { free(ptr); // free(ptr - sizeof(double)); } int main() { int n = 5; void *ptr = createArray(n, sizeof(double)); // freezero(ptr - sizeof(double), (n + 1) * sizeof(double)); // free(ptr - sizeof(double)); freecall(ptr - sizeof(double)); // freecall(ptr); return 0; } freezero() isn't available on most systems (I think), but I used it to check if the space behind the malloc gets overwritten. freezero() sets the memory to all zero before releasing it
The semantics of `restrict` qualifiers are straightforward when applied used to initialize pointer objects which have a well-defined lifetime during which they are not modified. They essentially invite a compiler to treat any accesses performed using the pointers or others derived from them as unsequenced with regard to anything else that might happen anywhere in the universe between the formation of the pointer and the end of its lifetime. The rules for `restrict` in other cases are much more complicated, and I have no idea how many compilers handle them perfectly.
Example with more filenames: #include &lt;stdio.h&gt; int main(int argc, char **argv) { if (argc &lt; 2) return -1; for (int i = 1; i != argc; i++) printf("[ %02i ]\t%s\n", i, argv[i]); return 0; } Input: (ls of root directory) ./test2 `ls /` Output: [ 01 ] altroot [ 02 ] bin [ 03 ] boot [ 04 ] bsd [ 05 ] bsd.booted [ 06 ] bsd.rd [ 07 ] dev [ 08 ] etc [ 09 ] home [ 10 ] lost+found [ 11 ] mnt [ 12 ] root [ 13 ] sbin [ 14 ] sys [ 15 ] tmp [ 16 ] usr [ 17 ] var
Unless it's against assignment rules, consider doing the Taylor series computation only for 0 to 90. The remaining sin values can be computed from those. E.g, using degrees, sin 1 == sin 179 (convert to radians before calling the sin functions though). This should give a more accurate result since the Taylor series gets more inaccurate at higher values
What is your solution so far?
Actually, I have drawn a flowchart but I'm not sure about the accuracy of that. I'll add the photo of that flowchart to my post. Only if you in position please have a look at that. Thanks
The man pages for the c standard library functions are gorgeous by any standard. Clearly a labor of care. 
Link?
On mobile so can't go in to detail but try adding `CFLAGS += -Iinclude` to your Makefile. You'll also need to set LDFLAGS when you get to linking your .so.
We're not going to do your homework for you, but if you have specific questions about C we can help you with that. First write down in plain English what you think the program needs to do, then think about how you would do that in C. Once you have some code, and assuming that code doesn't work or you aren't sure how it works then come back here and paste in the code. Either put four spaces in front of every line so reddit will format it nicely or use a pastebin service - whatever you do don't post a picture of your code, see https://idownvotedbecau.se/imageofcode Also how old is this question? Ceylon hasn't been Ceylon since 1972...
&gt; In some cases, clang will use pointer arithmetic to check whether pointers overlap and select an approach for performing the operation based upon whether they do. How does this work? Is it in the runtime library? I don't see how the compiler could know this unless it's somehow baked into the function, which could be a performance loss. Would especially appreciate if you can find it documented somewhere.
did you verify the meaning of "hardcoding a path"? i'd assume this means don't write #include "c:/users/user1/desktop/assignment/include/file.h", but #include "include/file.h" should be fine as it is a relative path.
The dead insect bothers me more than it should
Lots of good advice in other comments. Your lookup table will provide values of `sin(x)` for integer `x`. The interpolation function takes `float` parameters. Hence, you can use interpolation to approximate the sine of non-integer-degree angles: ```C #include &lt;assert.h&gt; #include &lt;math.h&gt; /* ... */ /* return an approximation to sin(x) */ const double sign = copysign(1.0, x); /* can't lookup negative x, so make use of symmetry... */ const double xlookup = fmod(fabs(x)), 360.0); /* ... and periodicity of sin(x). */ const int below = (int)floor(xlookup); /* largest integer &lt;= xlookup */ const int above = below + 1; /* smallest integer &gt; xlookup */ if (above == LUT_LEN) { /* prevent out-of-bounds access to lookup_table[] */ above = 0; /* make use of the fact that sine(360) == sine(0) */ } assert(xlookup &gt;= 0); assert(xlookup &gt;= below); assert(xlookup &lt;= above); assert(below &gt;= 0); assert(above &lt; LUT_LEN); return sign * interpolate(xlookup, below, below + 1, lookup_table[below], lookup_table[above]); ``` Please make sure you understand this code before using it. (And if I made a mistake above, sorry!) 
Maybe post your makefile?
In addition to what /u/henry_kr has said, you should probably read up on [how the include directive works](https://en.wikipedia.org/wiki/Include_directive#C/C++) (Wikipedia).
When you invoke the compiler, you tell it which directories to look for include files in. The form with `"` is correct (not the `&lt;` form)
[How\_to](http://lmgtfy.com/?q=Help+-+A+Complete+Tutorial+to+install+latest+glibc+beside+system+one+%26+write+a+simple+program+%26+compile+it%3F%3F%3F%3F) &amp;#x200B;
I’ve wondered how lucrative it could be to offer to do these kids’ homework for a fee. $50 here, $75 there... buys a lot of Starbucks. 
Do not delete your posts once you get your answer. I didn't write my comments just for you, but now nobody gets to see them because you've deleted your post. You've robbed an opportunity for others to learn.
How to act like an ass hat: 1. Link to lmgtfy
You are off-topic
Start by opening a browser and doing some research. 
1. Post a zero effort question expecting others to do the legwork
Correct way to handle this would be explaining why asking a question like this is bad and what OP could do to make it better. Instead of puttting an effort to make the lmgtfy link, he could've show OP the correct way.
He did show him how thoough. You're just the special snowflake getting upset about how he showed him. Especially given the nature of the question. 
JavaScript is easy to learn but slightly harder to implement. C based languages/Java can be overwhelming to new programmers, Python is easier to learn and implement but can confuse people when they switch to a language with more complex syntax. So it really depends upon what you want to do. I personally learned with JavaScript, branched off into C based but simpler languages such as those used for many game engines, this all gave me the skills to learn whatever language I want pretty quickly.
JavaScript is not something you have to learn last, it is no more complex than Python can be
and i don't want to learn the whole C language, there's two famous introduction to computer science course available, Harvard CS50 which is based on C, and MIT introduction to computer science and programming using python. i don't know take which course, the C one or the python? which is better for me? that's why i asked this question. and my future goal is learning C# Thanks :D 
I disagree C is used vastly in server-side/non-customer facing software. It is used widely in audio, video, and image encoding and decoding. C/C++ are also widely used in the development of desktop software and physical interactions such as a display showing information in a museum.
OP, since nobody else seems to be giving you any useful information, I might as well explain *why* rather than not answering your question and being a jackass at the same time. This question essentially expects us to do all the work for you; it's far too broad. Instead, do some searching on your own and read up about the glibc installation process, try to follow it yourself. If you run into specific errors, search those and see if you can find a solution that way. If nothing helpful pops up, then post here with a more specific question about the errors you're having. It's bad practice to post questions like this that demonstrate little effort in the way of research on the topic or understanding of what you're doing.
First, it depends on the sizes of ints, pointers and doubles on your machine. Second, it depends on the alignment requirements for doubles on your machine. Third, ignore `p1` and `p2`, they are not relevant to the matter of the size of `struct test2`. Off the top of my head, likely values are 48 (ILP32) and 56 (IL32P64), but I haven't checked.
wow this is too many :D i don't have too much time :/ my goal is to learning C#, and want to be C# full-stack web developer. Thanks &amp;#x200B;
That depends upon what you want to learn, Python is used largely for data science and machine learning/AI and the MIT course will likely focus on that and be more conceptual than actually focusing just on Python. The Harvard class is likely going to be a lot lower level and just learning C in general will teach a lot more about how computers work, it will likely will be more practical for learning C#. If I were learning to program with the goal of C# from one of those courses I would likely take the Harvard course. But I personally think you should learn to program before University, and it looks better than on your application.
Which is why I don't get the `two` in your comment. It makes even less sense when you consider concurrency.
 void freeArray(double *array[]) IMHO, this is misleading. It's not an array of double pointers. Matter of taste, I suppose.
Thanks very much bro, i will do that :D 
Examine the generated code for void test(unsigned short *a, unsigned short *b) { for (int i=0; i&lt;10000; i++) a[i] += b[i]; } when using the `-O3` option. As generated by clang, it starts with: test: # @test lea rax, [rsi + 20000] cmp rax, rdi jbe .LBB0_2 lea rax, [rdi + 20000] cmp rax, rsi jbe .LBB0_2 which means, essentially: if (a &gt;= b+10000 || b &gt;= a+10000) goto FAST_VECTORIZED_VERSION; This will add two failed conditional branches into the execution path if `a &lt; b+10000 &amp;&amp; b &lt; a+10000`, but if code can use the fast vectorized version even 1% of the time the performance improvement in those cases would likely outweigh the cost of the comparison in other cases. Note that the `-O3` flag essentially means "make loop optimizations that are likely to improve average-case performance even if they might hurt worst-case performance", and this sort of thing is a perfect example of that. Adding `restrict` qualifiers would eliminate the need for that extra branch. Incidentally, neither the code generated by clang 7.0.0 nor the design of any standard qualifier allows automatic vectorization in the most common case where `a` and `b` would alias: the scenario where they identify the same object. The fast vectorized version of the machine code clang generates for the non-aliasing case would be usable in that case, but clang won't try to use it. Adding a `restrict` qualifier would result in clang 7.0.0 generating efficient code that would work just fine in the `a==b` scenario, and is the only obvious way of making clang generate optimal code, but there's no directive that would allow a programmer to invite such an optimization except by writing the code as: void test(unsigned short * restrict a, unsigned short * restrict b) { if (a==b) for (int i=0; i&lt;10000; i++) a[i] += a[i]; else for (int i=0; i&lt;10000; i++) a[i] += b[i]; } which would yield code that's slightly more efficient in every case, and much more efficient in the `a==b` case, than the code without `restrict`, but it would cause clang to needlessly generate two separate loops even though the code generated for the `a!=b` case would work just fine even if `a==b`.
No problem, good luck
OpenSUSE + any text editor
The "takes two arguments" quote came from a comment to which I was expressing disagreement. I'm not quite sure how `restrict` would be relevant to concurrency unless additional attributes were added for that purpose. 
&gt; IIRC, the array is actually one larger than is claimed, and argv[argc] is NULL. It certainly is that way in a POSIX environment, from [exec](http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html): &gt; The argv and environ arrays are each terminated by a null pointer. The null pointer terminating the argv array is not counted in argc.
Unless you have reason to believe you'll get an error, assume `fork()` succeeds. So you won't get `-1`. Since every fork is going to be successful, you can walk the code for each process and see what it does.
Only if one is using a compiler that can use types to for purposes of assuming that seemingly-unrelated objects won't alias without breaking other aspects of the language one would happen to need need, such as the ability to use the address of a union member in ways that do not involve such aliasing of seemingly-unrelated objects. 
-1 would mean that the fork had failed. No new process would have been created. Based on how that was written, I don’t think the possibility of fork failing was considered. Start with the assumption that all of the forks succeeded and work out those results.
I'm sorry I tried to correct my question but It was late. I already searched for almost three days until now. I found some resources to install glibc from [stackoverflow.com](https://stackoverflow.com). I think, I installed glibc correctly, and I tried to compile a simple example with it but it did not compile. So I think I am doing somthing wrong, but I don't know, because I am new programmer and I trying to learn. &amp;#x200B; **Useful links that I found until now:** [https://stackoverflow.com/questions/35616650/how-to-upgrade-glibc-from-version-2-12-to-2-14-on-centos](https://stackoverflow.com/questions/35616650/how-to-upgrade-glibc-from-version-2-12-to-2-14-on-centos) [https://stackoverflow.com/questions/847179/multiple-glibc-libraries-on-a-single-host](https://stackoverflow.com/questions/847179/multiple-glibc-libraries-on-a-single-host)
Damn, so no points from that task. Thanks!
What do you mean it "didn't compile" ? There are many reasons a program wouldn't compile, so an error message would be helpful
IMHO, the Standard should have gone further and expressly allowed for the possibility of a conforming implementation treating `restrict` as a predefined macro with empty expansion. If the Standard had done that, and made some of the seldom-used features optional with feature-test macros, many slightly-extended C89 implementations could have been made conforming without having had to add new compiler logic. As it is, a compiler that makes a good faith effort to conform with the Standard(*) would be required to include logic to recognize `restrict` and enforce the associated constraints even if there are no circumstances where its code-generation logic would benefit. (*) Under the One Program Rule, an implementation may impose any translation limits it likes (e.g. number of different identifiers which contain the letter `q`), and may behave in arbitrary fashion when such limits are exceeded, with only one exception: for every translation limit listed in the Standard, the implementation must be able to process at least one source text (possibly a contrived and useless one) that nominally exercises that limit, in the manner prescribed by the Standard. Since the authors of the Standard acknowledge in the Rationale that *conforming implementations are not required to be capable of processing any non-contrived programs in the manner described by the Standard*, almost nothing a compiler could do when it sees a `restrict` qualifier (including ignoring it) would render it non-conforming. The stated intention of the authors of the Standard, however, is that improper use of `restrict` be a constraint violation. 
All hope is not necessarily lost. If you documented it well that the first fork failed and returned -1, it is a hypothetically valid sequence of events. And if you can (respectfully) argue that with your instructor, they may be willing to give you partial marks (possibly even full marks if your answer is correct given the case of the first fork failing). Though it would be useful to know what the right answer was if all of the forks succeeded. I would anticipate that if you did go to discuss your answer, the instructor might easily turn around and say: “OK, assume that they all succeeded. What would your answer be?”
I know the answer to that question so maybe je goes easy on me, guess I'll be researching all the possible reasons a fork could fail hahaha. Thank you!
Is `function` and `arg` defined? If not, would it even compile?
I tried to run the example from this website [Example](https://riptutorial.com/c/example/31557/c11-threads-simple-example) : **First I tried the following command to compile but I got this error:** **gcc -Wall -g -o main main.c -Wl,--rpath=/usr/local/glibc/lib -Wl,--dynamic-linker=/usr/local/glibc/lib/ld-linux-x86-64.so.2** `hello.c:1:10: fatal error: stdio: No such file or directory` `#include &lt;threads.h&gt;` `^~~~~~~` `compilation terminated.` Then I thought that, it could not find header files so I ran this command this time: **gcc -Wall -g -I/usr/local/glibc/include -o main main.c -Wl,--rpath=/usr/local/glibc/lib -Wl,--dynamic-linker=/usr/local/glibc/lib/ld-linux-x86-64.so.2** But I got this error: `/home/.../main.c:16: undefined reference to \`thrd_create'` `/home/.../main.c:18: undefined reference to \`thrd_join'` `collect2: error: ld returned 1 exit status` &amp;#x200B;
Why not just print them from your editor? If you really need a pdf, use the print feature, and have it print to a pdf file instead of an actual printer.
it was, but it wasn't relevant to the task
Maybe with pandoc
Gotcha, if it wasn't I'd argue it wouldn't compile. But my uneducated guess would be 4, 8 and 16 but it's probably wrong and I haven't touched c threading/forking in a long time.
This works if you're using a visual editor, but some people work on vim/emacs in the terminal and can't do this
well if al three forks work, every time fork is called, it would return a child and a parent within that parent so if the fork()!=0 goes into the parent only, it's 2 then the other fork creates a process in the parent so three, and the third fork another one in the child, so yeah, if i'm not mistaken 3 new and an old one, making it 4 processes &amp;#x200B; I'm not sure about the threads and the A's
Transient issues such as the system may have a maximum number or processes it may have. Or the user may have a number of processes quota that would be exceeded. Or any other reason that your system may decide that you’re not allowed to spawn another process.
Thank you. And what would you say are the answers to the three questions? 
Actually I think I may change my answer. I started writing it out on paper since my C knowledge is a bit rusty. Still don't think it's right though. So parent process, p1, starts and forks. If it fails it returns -1 and if it succeeds it creates a child process, we'll call it c2. If it succeeds then process c2 is created and it kicks off a thread. Regardless if it fails or succeeds it goes into the if, IIRC failure is -1, succeeds returns pid of the child process, and 0 denotes it's a child process. Both -1 and the pid can't be 0 for p1. Here p1 creates another process, we'll call it c3. The child process c2 doesn't enter this if since its fork would be 0 denoting it's a child process IIRC. At this point you have P1 and C3 sitting at the second if. Here is where it gets a bit trick. We've assumed the second fork succeeded. If it didn't then we only have P1 going through this. But for now we'll assume it succeeded. So P1 and C3 create another process C4 and C5, assuming also they are created. C4 and C5 would then enter the if block and print A and create two threads, so now we are at best case scenario we have three threads. Now P1, C3, C4, and C5 finish up and create four threads. Which gives us 7 threads, 5 processes, and 2 A's being printed. Assuming everything worked. Assuming none of the forks work then 1 process, 1 thread, and 0 A's. Based on how many forks work your answer would be between those two options I think.
That would be giving away the answers :) There’s a lot of value to you figuring out the answer, and then feeding the code to the compiler to see if it matches what you figured the answer would be. Printf will be your friend, as well as getpid() and getppid() (for the number of processes question, for threads there’s pthead_self() ). The number of As question will answer itself.
In vim you can save the file as html with highlighting. Then you could just print that html document using a browser
The classic unix way to do it is with the `enscript` program. Modern versions can do color syntax highlighting: $ enscript --color --highlight=c -o source.ps source.c $ ps2pdf source.ps The output is pretty nice.
vim can print to a printer (it's the `:hardcopy` command). This command can also print to a file, though it's postscript so you'd have to convert that to PDF.
Cool. Thanks 
I use windows mainly because I play videogames on my computer as well and unfortunately not enough games have Linux ports. Atleast with msys2 it's really not that bad. I still have my Linux VM though just in case.
two A's, seven threads, four new processes. All 5 processes great threads ad the second pthread_create, plus two processes create threads immediately after the A's get printed. Processes run the printf's because there is only one bare fork above there, the other two forks are in if's which only allows one of the pair to get in to the body of the if. the fork() != 0 is virtually identical to the fork() == 0 because there is little practical difference between parent and child in this context. The first fork creates one new process (2) One of runs the if block wherein the second fork creates a new process (3). Then there are two processes that run the next fork creating two new processes (5). 
Find answer here https://youtu.be/xgid7y1snke
Python has a [documentation page](https://docs.python.org/3/extending/) about this. That would probably be a good place to start. IT sounds like you want to extend your python program with some C (as opposed to embed some python into your C program).
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/cpp_questions] [Wrapper Events (Crosspost from C; If I can't do it in C, is there a way in C++?)](https://www.reddit.com/r/cpp_questions/comments/anunoo/wrapper_events_crosspost_from_c_if_i_cant_do_it/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I checked there, but I couldn't find anything about sending events; are you sure it's there? I'd also prefer for it to be easily usable with any wrapper I decide to write so I don't necessarily want it to be Python-specific (although adding support for it certainly isn't a bad thing)
You typically do not want to install your own libc. This just creates a bunch of problems without really giving you anything. Use the libc shipped with the system.
One thing I can think of is: Have a queue in the C code that any wrapper class can access, and have that queue hold something representing the events it is currently waiting to execute.
I don't think the glibc implements C11 threads.
I know this is not particularly helpful, but why do you want to do that? What is the point of this exercise?
Wow. This is amazing and I never knew it existed.
C# is off topic in this subreddit. Please ask in /r/csharp instead. Also, if it's due tonight you should have started earlier. Your lack of foresight is not other people's emergency.
It is in standard C, too (cf. ISO/IEC 9899:2011 §5.1.2.2.14 ¶2).
Your lack of planning is not our emergency. If your assignment is overdue, you probably started too late. That said, do not post pictures of code or error messages. Always post them as text. Read http://idownvotedbecau.se/imagesofcode for why. That said, it seems that a bunch of functions like `printEvent` are defined both in `CalenderParser.c` and `calParser.o`. That might be the problem but without seeing your code and build scripts (as text) it is very hard to say. If you lose -2% per hour, you should wait about two days to get 100% without having to do any work :-P
How can I check in a binary file? Is there a way? This is my github by the way. I can't leave it on public for too long since its a school assignment and I can get academic misconduct for sharing it. [https://github.com/iruchal/calendarParser](https://github.com/iruchal/calendarParser)
I'm going to be that guy and suggest you may want to pick another name for your project my man... "Pintos" means "dicks" in portuguese lol
Is it possible to be in a bin file? How would I fix this? I have attached my github with the code but I can't leave it on public for too long since Its a school project and I can get academic misconduct but thanks. &amp;#x200B; [https://github.com/iruchal/calendarParser](https://github.com/iruchal/calendarParser)
Probably an error in your makefile. Most likely your recipe is trying to build against calParser.o and CalendarParser.c at the same time.
 I think I’m going to try to use loops now. 
If you cannot share your code I cannot help you. I do not even look at code that isn't being made public.
What is the command you are using to compile?
Hehe, thanks for letting me know :-) I just used the existing name on the Stanford website.
GCC = gccCF = -Wall -std=c11 -g -Iinclude/ all: list parser list: $(GCC) $(CF) -fpic -c ./src/LinkedListAPI.c -o ./bin/list.o $(GCC) $(CF) -shared ./bin/list.o -o ./bin/liblist.so parser: $(GCC) $(CF) -fpic -c ./src/parser.c -o ./bin/calParser.o $(GCC) $(CF) -fpic -c ./src/CalendarParser.c -o ./bin/calParser.o $(GCC) $(CF) -shared ./bin/calParser.o ./bin/calParser.o -o ./bin/libcal.so clean:rm -rf ./bin/\*.o ./bin/\*.so
Please put four blanks in front of every line so the commands are formatted in a legible manner.
&gt;GCC = gccCF = -Wall -std=c11 -g -Iinclude/ all: list parser list: $(GCC) $(CF) -fpic -c ./src/LinkedListAPI.c -o ./bin/list.o $(GCC) $(CF) -shared ./bin/list.o -o ./bin/liblist.so parser: $(GCC) $(CF) -fpic -c ./src/parser.c -o ./bin/calParser.o $(GCC) $(CF) -fpic -c ./src/CalendarParser.c -o ./bin/calParser.o $(GCC) $(CF) -shared ./bin/calParser.o ./bin/calParser.o -o ./bin/libcal.so clean:rm -rf ./bin/\*.o ./bin/\*.so &amp;#x200B; it's a makefile? why is it not in with the rest of you code?
I made it public
Section 1.6 -- calling python functions from C? You'd implement whatever event handler dispatch you needed in your python, pass the single dispatch from your python to your C along with whatever else you're doing. Then, your C performs your action as-called and has access to itself "reach back into the python" to the event dispatch and the argument(s) specific to whatever action you just performed. I have only gone the other direction embedding Python in C, so at this point I am simply reading the documentation and interpreting it along with your example. That seems like one possible route though. 
I think the problem with your recipe is on the following line: `$(GCC) $(CF) -shared ./bin/calParser.o ./bin/calParser.o -o ./bin/libcal.so` Why do you link against the object file twice?
It should print 'A' twice.
`parser.c` and `CalendarParser.c` are both being compiled to `calParser.o`, which you then try to link in twice (giving you linking errors). It's standard practice to use the same name for an object file and a source file, just with different extensions. So a file named `%.c` produces an object file named `%.o`.
Can you help me add the main to the makefile please? I don't understand makefiles at all. I;ve attached the source files in the github link on the post
Well it looks like \\u\\cml\_iii has you answer for all the errors, where do you actually build the executable you just seem to make two shared libraries &amp;#x200B; `$(GCC) $(CF) -fpic -c ./src/parser.c -o ./bin/calParser.o` `$(GCC) $(CF) -fpic -c ./src/CalendarParser.c -o ./bin/calParser.o` &amp;#x200B; and overwrite the same object file calParser.o you need to change one of these.
Forget programming for a minute: how would you do this calculation by hand?
Actually, upon rereading your makefile, your problem is the whole parser rule: parser: $(GCC) $(CF) -fpic -c ./src/parser.c -o ./bin/calParser.o $(GCC) $(CF) -fpic -c ./src/CalendarParser.c -o ./bin/calParser.o $(GCC) $(CF) -shared ./bin/calParser.o ./bin/calParser.o -o ./bin/libcal.so You need to compile parser.c into its own object file (i.e. parser.o), and CalendarParser.c into its own object file (i.e. CalendarParser.o), and then compile the two object files into the shared library. Or you could compile the two source files into one object file, but it has to be done in one line.
A good first step is including the header files in main.c
Have you built the project at all using command line gcc or anything? I see your makefile and it doesn't really look like you've even tried to build main. My guess would be that you just want to compile your main against your shared object libraries (something like `$(GCC) bin/liblist.so bin/libcal.so main.c -o main`).
It would be total points/# classes, half year count as .5 towards #classes, and the grade in the class is divided by 2 before it is added to total points for 4.0 it’d be if 93&lt;grade&lt;100 it counts as 4.0, 90&gt;grade&gt;93 as 3.6,etc and then avg them together just like the 100 pt scale above. some classes are weighted with a 1.1 multiplier and 1.05 multiplier, I’d treat those the same as half years I can easily make this program with any set number of classes but I can’t figure out how to account for different variables such as # of classes, #of half years,etc. There is obviously an impossible number of combinations when the total number of classes can be as high as 28. 
&gt; Or you could compile the two source files into one object file, but it has to be done in one line. Not in any toolchain that I know of. I mean, you could use `ld -r` to link the two objects together, but that's just preposterous.
But you plan to make it private again. What I care about is that my answers benefit future participants. If you make your code private in the future, nobody is going to be helped by my answers. So I am not interested in providing any.
Whoops, was thinking of compiling the two source files into the shared library in one line. Ex. `$(GCC) -shared ./src/parser.c ./src/CalendarParser.c -o ./bin/libcal.so`
It sounds like you have a good idea for how to calculate things, now we just need to turn that into code. &gt; I can easily make this program with any set number of classes but I can’t figure out how to account for different variables such as # of classes, #of half years,etc. There is obviously an impossible number of combinations when the total number of classes can be as high as 28. You're over thinking this. Go back to your original calculation: "total points/# classes." All you need to keep track of is the cumulative total number of points and the cumulative number of classes. Two variables, regardless of the actual number of classes taken and the type. Then, you use a loop that handles each class: look at the grade, figure out how many points its worth, add that to the total, and add the class into the count of classes. This is also where you'd account for the weighting. After the loop is done, then you can do the division to calculate the final GPA.
Ok thanks, I definitely was overthinking. If I can just ask one more question, how would I code the loop to know how much each class is worth(if the class is half year, full year, 1.05 weighted, or 1.1 weighted?) I know it would have to rely on user inputted info, so I guess my question is how should I ask the user how much the class is worth, and then how to I convey their response into the loop. Hope that is not asking too much. Again, thank you so much for taking the time to help me with this. 
I would put the prompt inside the loop. Something like: for ( int i = 0; i &lt; num_classes; i++ ) { int grade; printf("Class grade: "); scanf("%d", &amp;grade); // Etc. for other parameters } So you can ask for a read in each thing you need to know about the class inside the loop. Like one value for the number of credits (this is how some schools manage the full vs. half year class: 1 for a full year, 0.5 for half, though sometimes classes can be up to 3 or 4 credits). Or another for the weight of the class. Or you can get fancy and ask yes/no questions ("Is this a full day class (y/n)? "). It's really up to you.
Thank you a ton, I feel like I have a little better grasp of how to code C++ now! 
FWIW this is C code, not C++ code. They are similar in syntax but beyond the surface they're very different languages
Whoops, I didn’t realize that. Thank you so much, you guys are awesome. 
Thanks for the example, that is interesting, I did not know that clang was doing this much loop analysis and inserting things like this into its loops. I should have been more clear, I was more thinking of a case where the size of the allocated memory is unknown, e.g. void test(float *a, float *b, float *c, int n) { for (int i=0; i&lt;n; i++) c[i] = a[i] + b[i]; } Does clang still insert a check in this case?
No, you're totally right; I missed that. Thank you so much!
visual studios actually has two ways to use restrict. \_\_restrict or \_\_declspec(restrict)
You should always start by googling your questions, as chances are someone has asked your question on SO before. The likely problem is you're defining the variable (initializing it to a value) and extern is intended for variable declarations. [https://stackoverflow.com/questions/4268589/warning-in-extern-declaration](https://stackoverflow.com/questions/4268589/warning-in-extern-declaration)
That means you have code like this: extern int sizeArray = 10; You can't (the compiler is letting you as an extension, but with a warning) initialize a variable at the declaration, only at the definition (there should be a `int sizeArray` in some .c file). Remove this initialization and do it at the definition instead. I wonder if this variable is actually supposed to be a constant, in which case `const int sizeArray = 10;` might be an acceptable solution as well.
That's pretty neat. In my OS class we used MITs [xv6](https://pdos.csail.mit.edu/6.828/2018/xv6.html) and had to do things like write a new scheduler and add new syscalls.
You're assuming function !=main. Which is reasonable though since they have incompatible types.
When I do that, it says this: ./bin/libcal.so: undefined reference to \`sizeArray' I have three files in the makefile and it makes libcal and I use sizeArray in two of them. Could that be why? How would i fix this?
Many programmers would expect something like `{ int *p = &amp;unionArray[i].intMember; *p = 12; }` to behave equivalent to `unionArray[i].intMember = 12;`. It's rather unclear what purpose would be served by having `&amp;unionArray[i].intMember` yield an `int*` if it couldn't be used even in such simple patterns as that. The authors of clang and gcc have said, however, that because the Standard does not mandate any circumstances where implementations must allow union members to be accessible via pointers, they do not intend to support any. Many interconnected devices are programmed in C. How can anyone reasonably expect them to be free of bugs and security vulnerabilities if compiler writers make no effort to support constructs which their customers expect to work in the fashion described by the Standard [whether or not the behavior is *mandated*, it is unambiguously *described*]? The vast majority of the problems caused by `-fstrict-aliasing` result from gcc and clang interpreting it as an invitation to ignore situations where a pointer of one type is derived from another and used in contexts where the derivation is visible and fresh, where the storage is not modified, or where the pointer is the root of all accesses to the storage. In other words, in situations that **don't involve aliasing**. Implementations intended for different tasks should support different sets of "popular extensions" [using the Rationale's term for the way many implementations usefully process constructs for which the Standard imposes no requirements] appropriate to such constructs. Unless the language adds some new directives or intrinsics, it would be impossible for a single language to define all the behaviors needed for some tasks without blocking optimizations that would be useful in others. Perhaps there are some kinds of programming for which the maximum-optimizations dialect of clang and gcc is suitable, and I wouldn't be bothered by the existence of such dialects if the authors recognized that they are highly specialized, and also recognized the legitimacy of programs written for other dialects that are more broadly useful. 
That error tells me you don't have a definition of `sizeArray` anywhere. One of your .c files should have that definition I mentioned. Or its in there but not being linked in, it's hard to say without seeing the code. It's hard to give help blind.
[https://github.com/iruchal/calendarParser](https://github.com/iruchal/calendarParser) &amp;#x200B; The header files are in include and the c files are in src
Hi, thanks for replying. Unfortunately I stupidly deleted my post in a 4 AM, post-10-hour-coding-marathon panic about plagiarism policies. To make it up, I'll create a report on my project from start to finish and post it here for the community's benefit. I'm completely certain your code is awesome and far better than my own, but the formatting is wack. Try inserting 4 spaces at the start of each line.
Well, it was for work but I did the entire project myself. I programmed a controller for an electric pellet smoker with PID control and used a really simple task scheduler behind the scenes. Here in the coming months I'll get to make a WiFi/Bluetooth module that will communicate with it via serial and a companion app to control it.
Fire up gcc.godbolt.org and look for yourself. Recognize that "lea" evaluates the expression in brackets and stores the result to the left operand, "cmp" is a comparison, and most things that start with "j" are conditional branches that act upon the results of a preceding "cmp", and you may be able to tell how many different versions of a loop clang is generating to handle different circumstances. 
Yup, `parser.h` declares `sizeArray`, but I don't see any definition for it. I would expect to see an `int sizeArray` in `parser.c`. Though I also see a local variable in `createCalendar` by the same name and a function parameter to `InitializeArray`, which has me thinking that this variable shouldn't be a global at all, but passed along with the array as a function parameter.
Nice!
The point of the extern keyword is to tell the compiler that, when looking at a file, "this variable exists, but its memory hasn't been allocated (defined) yet.", then when you get to the linking step it fills in the definition as-needed. Your original warning came up because you were using the keyword, but then providing the definition in the same line. You basically gave the compiler contradictory, but functional, instructions in the same line. When you modify your line to just be 'extern int sizeArray'. All the compiler knows is that the variable exists. When you then use it in your source code, if no definition comes along for it when you link you get your error because the variable simply isn't there. As the other commenter said, you have to have the definition. That could be as simple as picking a source file and including code to the effect of: #include "myexternalvars.h" //extern int sizeArray lives here int sizeArray = 5; //defined. now variable has memory int main(){ //do things with sizeArray here or in other linked source files }
I don't work in C professionally but the last thing I did that was fun and out of my comfort zone was a depth first, brute force, backtracking sudoku solver. Now I'm working on a dancing links implementation of the backtracking algorithm. This will rest my knowledge of circular doubly linked lists (toroidal actually!), malloc, callbacks (via function pointers!), some preprocessor macros, and ADTs. Way outside my comfort zone. Pretty excited.
Compiler and Assembler from the book "Elements of Computing Systems". Probably learned more about computer science doing that than getting a Masters and working 10+ years as a programmer.
Variables removed. Anything else you would suggest?
The original process, *p1*, goes fork1 =&gt; nonzero (p2 created) fork2 =&gt; nonzero (p3 created) fork3 =&gt; nonzero (p4 created) pcreate2 exit The first child, *p2* goes fork1 =&gt; zero pcreate2 exit The second child, *p3*, goes fork2 =&gt; zero fork3 =&gt; nonzero (p3.1 created) pcreate2 exit The third child, *p4*, goes fork3 =&gt; zero printf pcreate1 pcreate2 exit The first grandchild, *p3.1*, goes fork3 =&gt; zero printf pcreate1 pcreate2 exit So four processes, with 2, 2, 3, and 3 threads, 10 total. And two calls to printf. Others have already mentioned how fork can fail. printf can fail too, if stdout is directed to a full filesystem or write-protected filesystem or is closed. $ ./myprog &gt;&amp;- $ ./myprog &gt;/mnt/readonly-volume/somefile $ ./myprog &gt;/mnt/full-volume/somefile Actually, printf probably will not fail; flushing the output buffer at program exit could silently fail. Also, the C standard does not guarantee that standard I/O buffers correctly in the presence of threads or forks. This *should* be okay in your example because the first printf is after all the forks, and the child threads do not write anything. But it is not guaranteed. If `function` also does I/O or forks, all bets are off.
WOAH! now that sounds like it's something up my ally! I'll check it out!
Unfortunatly my GPA is far too low for me to help you. I didn't study hard enough, and now I'm punished by everlasting idiocy. Study hard everyone!
In emacs, you can ‘M-x print-buffer’ or ‘M-x ps-print-buffer’ to send the current file to the printer. Prefix with ‘C-u’ to get a prompt to write a PostScript file instead. Also, take a look at similar commands for regions!
Some implementations usefully extend the language by allowing an initializer on an `extern` to be ignored *except* for purposes of determining an array size, if needed. For example: extern_if_header int my_array[] = {1,2,3,4,5}; Where `extern_if_header` is defined as `extern` except when compiling one particular file. Defining things in that fashion means that files using the header can use `sizeof` on the array. Omitting the initializer would allow the declaration to create a symbol for the array, but client code would not be allowed to use `sizeof` because the compiler would have no idea of the size of the array. 
I don't have it at hand but if you search handmade hero you'll find it.
Hi, Good question. 1. It's a new project &amp; It's used as first class tool in some successful projects such as Alpine linux ... 2. It has almost same api as glibc. 3. It has less binary size relative to glibc especially in static linking. 4. It's much more memory efficient than glibc, especially in multithreaded applications. As documented in musl documentation in musl minimal stack size for a thread is 128K in latest version but for glibc minimal stack size is more than 2M. 5. ... please refer to main website for additional information. 
I don't think I've ever worked on any C programming project, personal or professional, that *wasn't* a solo project. Coolest according to popular opinion would [these](https://www.youtube.com/watch?v=wBRI8CS2Fpk) [hoops](https://www.youtube.com/watch?v=XCOotmKoXx0) and [poi](https://vimeo.com/245409339), which have WiFi support (web interface with pattern editor and visualizer), telnet server, Basic interpreter, command shell, Art-Net support, and a bunch of other fun stuff thrown in. Maybe the best geek cred is having written all of the firmware (and built the hardware) for a secondary communications payload on a small satellite.
Based on This [Stackoverflow](https://stackoverflow.com/questions/35616650/how-to-upgrade-glibc-from-version-2-12-to-2-14-on-centos) link I downloaded &amp; installed glibc myself in "/usr/local/glibc" path of my Linux OS. Then based on this [Stackoverflow](https://stackoverflow.com/questions/847179/multiple-glibc-libraries-on-a-single-host) link I tried to compile This [Example](https://riptutorial.com/c/example/31557/c11-threads-simple-example), But I got those errors that I mentioned before. I even tried to compile with "-I/usr/local/glibc/include" &amp; "-L/usr/local/glibc/lib" GCC flags, but I got those same errors. So As I said, I do not use precompiled binaries, so I do not think that there is problem with glibc compiled binraries.
This fixed it! Thanks everyone for the great feedback really appreciate it
You're correct, I was making that assumption.
Separate the declaration and the initialization. Declare it in a header file: extern int sizeArray; and define it in a source file: int sizeArray = 0;
I'd be careful about sharing your source code for the project, I know the OS class at my university is going through project 1 right now and I know other universities use it. You may end up getting an issue pulled asking for you to hide it.
Try posting this on r/codereview
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; // For exit() int main() { FILE *fptr1, *fptr2; char filename[100], c; char input = '$'; // the char I put at the end of each line printf("Enter the filename to open for reading \n"); scanf("%s", filename); // Open one file for reading fptr1 = fopen(filename, "r"); if (fptr1 == NULL) { printf("Cannot open file %s \n", filename); exit(0); } printf("Enter the filename to open for writing \n"); scanf("%s", filename); // Open another file for writing fptr2 = fopen(filename, "w"); if (fptr2 == NULL) { printf("Cannot open file %s \n", filename); exit(0); } // Read contents from file while ((c = fgetc(fptr1)) != EOF) { /* * I check the char and if it's a newline * I'll just add another char before */ switch(c) { case '\n': fputc(input, fptr2); fputc(c, fptr2); break; default: fputc(c, fptr2); break; } } printf("\nContents copied to %s", filename); fclose(fptr1); fclose(fptr2); return 0; } I didn't change a lot: \- I added a new char with the changes I want (char input = '$') \- the loop is doing the same as before, but I added a switch(c) {}, see comments &amp;#x200B; I am not really sure if that's what you wanted, but if it is, just ask if there are questions to it.
Just rename them from .c to .pdf That's my joke for the day.
Ah okay. Can these characters be treated like arrays? For Example I want to take away every "\\r" from the file.. &gt;I am\\r\\n &gt; &gt;testing this\\r\\n &gt; &gt;\\r\\n &gt; &gt;program\\r\\n &amp;#x200B;
Code review is on topic in this subreddit, too. As long as the code is C code.
Just remove the `extern` keyword. If you declare a variable as `extern` that means “do not define this variable right here, instead this is a variable defined somewhere else.” Given that you actually want to define a variable, this is not what you want.
So the main issue here is that using more than one libc on a system is a major pain in the ass, especially if you use shared libraries. All shared libraries you use must have been linked with the same libc for this to work. &gt; It's much more memory efficient than glibc, especially in multithreaded applications. As documented in musl website in musl minimal stack size for a thread is 128K in latest version but for glibc minimal stack size is more than 2M. These 2 MB aren't actually used. That's just the amount of address space reserved for the stack, so actually there isn't really a point here. &gt; It has less binary size relative to glibc especially in static linking. Given that text size is almost certainly much smaller than data size in all modern applications, I don't quite see the point why saving one or two MB helps here. Also consider that with dynamic linking, the libc is loaded to memory only once, so it does matter even less. But i do see your point for extremely constrained systems where you link statically.
Absolutely. I was just thinking they might have better luck cross posting it between the two subs. 
 case '\r': break; If you want to add something instead of '\\r' for example '&lt;': case '\r': fputc('&lt;', fptr2); break; If you want to add a string instead of '\\r': case '\r': fprintf(fptr2, "THIS IS NO \\r"); break; &amp;#x200B; &amp;#x200B;
I'm new to C, but not with C++ so here! #include &lt;iostream&gt; using namespace std; int main () { for(int i=1; i&gt;0;i++){ //infinite loop lol cout&lt;&lt;"Thank you!"&lt;&lt;endl; } return 0; } Thanks again!
&gt;//infinite loop lol It's not: int i will overflow and count from -2147483648, so it'll break the loop :)
Thanks for confirming, I don't have access to the standard.
&gt;So the main issue here is that using more than one libc on a system is a major pain in the ass, especially if you use shared libraries. All shared libraries you use must have been linked with the same libc for this to work. Yes you are absolutely right. I did not know this issue in the first place. I think to use musl, I should reach out to linux distros that adabt musl-libc as a first class development tool such as Alpine or Void linux. &amp;#x200B;
On Linux, the following should get you started on the performance issues once the code is compiled with debug info (-g): valgrind --tool=callgrind ./prog Which will create a file in the current dir that may be visualized using: kcachegrind
for(;;) { }// infinite loop lol
That is a good idea! If you want to test code with other libc implementations, also consider one of the BSD systems. They all have their own libc implementations.
See, and it's already no longer public. That's why I did not write an answer.
Which glibc version did you download and install? Is there a file `threads.h` in `/usr/local/glibc/include`?
For me the issue is clear. If you have further questions, consider making a Stack Overflow post. Please link it as I am interested in the resulting discussion.
Your code looks very clean. Here are some suggestions. 1. Always use brackets to enclose scopes to minimize possibility of making errors further down the line. 2. Assert and validate your function inputs. 3. Use a safe malloc that kills the process on failure; or handle the failure case.
Two projects: * I thought endgame tablebases were cool, so I took a Japanese chess variant and [solved it](http://github.com/fuzxxl/dobutsu). * I developed a [scanf-like tool but for serialising and deserialising binary data](http://github.com/fuzxxl/memf). It's just a proof of concept but it's pretty cool nonetheless. Right now I work on a high-performance bittorrent client. No code yet, but some fancy ideas.
Look for a document named N1570 on the internet.
glibc v2.29, latest version. Yes I checked that too. 
So the file does exist? Hm... let me check what to do when I get home.
Was the hit after changing compiler versions on Linux?
 #define exp 2.71828182845904 /* Euler's Number */ m(
Likely, I didn’t change anything significant in my code, and reverting to a version of my code from a year ago yields the same, absurdly slow performance now.
Someone actually made a profiling tutorial using my project as an example! [introtoprofiling](https://github.com/Erdk/introtoprofiling)
I considered it, but this sub is way more active.
I'd avoid using lowercase letters for these constants. Including this header means you can no longer use any of those names for local variables: struct element *e = get_element(obj); // e replaced by constant That's exactly why we have the convention for `UPPERCASE_MACROS`. 
Note that &lt;math.h&gt; already defines some of these constants: `#define M_E 2.71828182845904523536028747135266250 /* e */` `#define M_LOG2E 1.44269504088896340735992468100189214 /* log2(e) */` `#define M_LOG10E 0.434294481903251827651128918916605082 /* log10(e) */` `#define M_LN2 0.693147180559945309417232121458176568 /* loge(2) */` `#define M_LN10 2.30258509299404568401799145468436421 /* loge(10) */` `#define M_PI 3.14159265358979323846264338327950288 /* pi */` `#define M_PI_2 1.57079632679489661923132169163975144 /* pi/2 */` `#define M_PI_4 0.785398163397448309615660845819875721 /* pi/4 */` `#define M_1_PI 0.318309886183790671537767526745028724 /* 1/pi */` `#define M_2_PI 0.636619772367581343075535053490057448 /* 2/pi */` `#define M_2_SQRTPI 1.12837916709551257389615890312154517 /* 2/sqrt(pi) */` `#define M_SQRT2 1.41421356237309504880168872420969808 /* sqrt(2) */` `#define M_SQRT1_2 0.707106781186547524400844362104849039 /* 1/sqrt(2) */` &amp;#x200B; You might want to adopt a simlar M\_xxx convention, remove any duplication, and also note that constants should ideally be specified at double precisiion (at least) where approopriate, i.e. &gt;17 significant digits. &amp;#x200B; Also note that \`exp\` is already taken - it's a function, so redefining it as a literal constant is probably not a great idea. &amp;#x200B; &amp;#x200B;
Those `M_` constants are all non-standard extensions, so they won't necessarily be defined by the implementation. Even on systems that offer them, they won't be defined when you ask the compiler to be strict (`-std=c99`, etc.). The further problem is that if you define these yourself, you may run afoul if the implementation defines them — either because it's not well-behaved or because the program wasn't compiled in a stricter mode. So at minimum you'll need to defined them conditionally: #ifndef M_PI # define M_PI ... #endif But at that point you might as well just use your own definition every time and ignore `M_PI`. 
Most definitions of floating-point constants I've seen use 21 or 36 most significant digits, which I believe guarantees the binary number is preserved exactly in a roudtrip to decimal representation and back for extended precision (binary 80-bit) and quadruple precision (binary 128-bit) floating-point numbers. In general it probably doesn't matter all that much, but when we're talking about scientific applications, I'd find those definitions lacking.
I was thinking of this, I will definitely make changes! 
I never took that into account. I really just used the values I found in Wikipedia, but I will definitely go back and find the less erroneous definitions! Thank you
In logr(), why not format %02d for minutes and seconds, to get zeropadded 00 ... 59 ? &amp;#x200B; All right, 00 .. 61 :)
This is exactly the sort of feedback I’m looking for! Thanks! When I wrote that, I tried to find the neatest way, but obviously I didn’t find the way you just suggested.
what's an example of a safe malloc?
Thanks a bunch! 1. It’s so tempting to do one-liners for small checks sometimes! I think I’ll implement this too, just makes it easier to read. 2. This is certainly a good idea. I’ve only done this where I’ve had problems pop up, but it’s good practice to do it everywhere. 3. I’ve had a lot of accidents with runaway memory allocation, I’ll definitely implement stricter checks on those soon.
&gt; `#define c 299792458 /* Speed of Light in Vaccum [m*s^-1] */` this is a very bad idea, especially as `char c = '...'` is pretty idiomatic.
Wow, this is really clean and well written. I like it. Like you, I've written programs that can interface either with pthreads or Win32 threads. However, I dislike the conditional approach you've taken in `renderer.c` where it's littered all through your code. /* simplified illustration */ #ifdef WINDOWS handle = CreateThread(...); #else pthread_create(&amp;handle, ...); #endif This is fragile and difficult to follow. It's fragile in that it's tightly coupled to that function and you could easily break the code for the other platform and not realize it. You wouldn't know until you compiled and/or tested on the other platform. The approach I like to take is define an abstracted interface that's just powerful enough for my application, then implement it in terms of each supported platform. /* API */ struct thread; typedef void (*thread_proc)(void *arg); thread_create(struct thread *, thread_proc, void *); thread_join(struct thread *); #ifdef WINDOWS struct thread { HANDLE thread; }; static DWORD WINAPI stub(LPVOID arg) { /* Note: The stub_info object can't just be a local variable * inside thread_create() since that would lead to a race * condition. That object must alive long enough for the thread * to use it. Here I've chosen to headp allocate it. */ struct stub_info *info = arg; thread_proc proc = info-&gt;proc; void *proc_arg = info-&gt;arg; free(info); proc(proc_arg); } /* ... */ #else struct thread { pthread_t thread; }; static void * stub(void *arg) { struct stub_info *info = arg; thread_proc proc = info-&gt;proc; void *proc_arg = info-&gt;arg; free(info); proc(proc_arg); } /* ... */ #endif Once sticky point is that the thread routine prototype isn't compatible between pthreads and Win32 threads, which is something you've already had to address (`WINAPI`, etc.). So you have to go with the least common denominator in your abstraction and in each implementation use an awkward stub routine to "translate" the prototype. Once you have this working on both platforms, you don't really need to worry about accidentally breaking it because you changed the name of a variable in the code that calls it. 
The issue has already been addressed from many angles there, but SO isn't really intended for discussion. The problem fundamentally is that the authors of the Standard never seem to reached a consensus as to whether it is intended to be a full and complete specification for a useful language, or whether it was intended to form a "core" language which implementations would augment as necessary to make it useful for various purpose, and which would need not be very useful without such augmentation. What's unfortunate is that there have been long and bitter arguments between people who say that because certain semantics are useful, implementations should always be required to support them, and those who say that because it may be impractical for some implementations to support such semantics, programmers should never be entitled to rely upon them. Both sides of such arguments are wrong, because they're forcing a needless choice between inferior approaches. The right approach, which both sides should be able to agree upon, is that there are many things that implementations should do *when practical* [when the cost is less than the benefit], and that programmers should be entitled to rely on *except when targeting implementations where they would be impractical* [the cost would exceed the benefit]. If one wants the Standard to be more concrete, the solution would be to provide more means via which programs can indicate their requirements, e.g. after #ifdef __STDC_REQUIRE #__STDC_REQUIRE(INT_OVERFLOW(GENERAL), CHOICE(KILL(LOOSE), RING_VALUE(LOOSE)) #endif [I'm assuming that `__STDC_REQUIRE` would be a macro that token-pastes its arguments so as to minimize the need to stick `__STDC` before everything; the design intention is that many C99, or maybe even C89, implementation could be upgraded to reject programs that don't meet requirements merely by including a header file]. a programmer would be expected that an implementation to either reject the program entirely, or else guarantee that by default (in the absence of other directives, installed signal handlers, flag tests, etc.) observable side-effects from integer overflow will be limited to yielding a value which will wrap *if cast to a smaller type*, or forcing an abnormal program termination at any time the compiler's finds convenient (which may be before or after the time when overflow would occur in execution order). That's a huge range of freedom given to a compiler--enough that there would seldom be any real benefit to allowing compilers to do something else--but limiting behaviors to those would greatly reduce the cost of ensuring that a program upholds the following two requirements: 1. When given correct data, produce correct results. 2. Do not behave in particularly harmful fashion, even when given maliciously-constructed data. Implementations that would benefit from doing something else would be allowed to do so, but only if they handle a requirements spec like the above by either adjusting their behavior as appropriate to satisfy it, or refusing to process the program altogether. 
Thanks a bunch! [commit](https://github.com/VKoskiv/c-ray/commit/93b2ce4b58e038e81fb8374ffe7c9be212a6914c) OH7FZB
Even more PVS Studio spam. Nobody cares about your fucking software!
&gt; I dislike the conditional approach you've taken in renderer.c I absolutely agree! I hate conditional #ifdefs throughout program logic, both for the reasons you mentioned and it just looks... Ugly! So far my only saving grace has been that I haven't had to touch the threading stuff in a long while. I have had incidents where I unknowingly broke the Windows build while working on something! I'll definitely look into abstracting it with the way you presented. Thanks a ton for taking a look and the kind words!
R
There's also already a pthread implementation on top of the Windows API, https://sourceforge.net/p/mingw-w64/mingw-w64/ci/master/tree/mingw-w64-libraries/winpthreads/
Looks pretty good. One small thing is that you sometimes manually zero memory you allocated with calloc ([e.g. here for example](https://github.com/VKoskiv/c-ray/blob/be86f96962b74fd24eeeb00471b1623fb8cdfc07/src/acceleration/kdtree.c#L58)) someThing *ptr = calloc(1, sizeof(someThing)); ptr-&gt;field = NULL; ptr-&gt;otherField = 0; [calloc](https://en.cppreference.com/w/c/memory/calloc) will always return N bytes, all zeroed.
I did think of that and I did a few searches and came up multiple implementations shared on github so I wondered would one more really make a difference? Maybe since I posted on Reddit though... &amp;#x200B;
I was lucky enough to take the [class](https://pdos.csail.mit.edu/6.828/2018/) that was the basis for creating xv6. Unfortunately when I took it xv6 had not yet been developed. I did play around with xv6 earlier this year and I implemented B-tree directory entries for the file system. If you are interested, my source is [here](https://github.com/dillstead/xv6-public/tree/btree_dir).
I know for a fact that there was one that I glanced at once or twice, he had a design document written up (as is required for most classes) that talked about the implementation method without giving away code. The professor was okay with that as long as we didn't actually look at the code itself, so maybe do a quick write-up for students to look at?
You would want to check if that book uses C. I'm guessing not. If you choose to use C for your project, check out Raylib. Everything pertinent to creating an RPG can be found on the internet for free
Since you're on the C programming language, I assume you want to make a video game RPG, not a pen and paper one. For video games, it is immensely easier to pick a game engine and learn from their. Unreal Engine 4 and Unity are the best ones, they're free unless you are really profitable, and Godot is another one that is available that's completely free. Using the resources that come with those engines would be better than any general purpose book. 
You don’t need to buy a thing. Just google free tutorials and start coding.
It doesn't use C but i posted in this subreddit because the community is huge and i thought that theres a bigger chance that somebody would be able to have some good information and suggestions about this and game development in general, than in other subreddits. Thank you for the input tho, appreciate every bit of information.
&gt; Those M_ constants are all non-standard extensions, so they won't necessarily be defined by the implementation. Even on systems that offer them, they won't be defined when you ask the compiler to be strict (-std=c99, etc.). Wrong. They are specified by [POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/math.h.html) so they are standard extensions and will be defined even with `-std=c99`. And appropriate feature test macro may be required.
You should declare functions and globals only used in a single file as static. This changes them to have file scope and allows the compiler to give warnings about unused functions/globals and potentially allows more aggressive optimization.
Funny thing is. Some compilers will actually emit a literal infinite loop for such code. There are optimizers that we'll look at that code, notice that it only terminates during a signed integer overflow, which is undefined behavior... so it will conclude that it can only terminate if undefined behavior occurs. So... The optimizer will emit code with the assumption that undefined behavior will never happen, and emit an actual infinite loop!
On Debian 9 (glibc 2.24): $ cat test.c #include &lt;math.h&gt; double pi = M_PI; $ cc -std=c99 -c test.c test.c:2:13: error: 'M_PI' undeclared here (not in a function) Trying again with `_POSIX_C_SOURCE`, this still doesn't work because they're not in POSIX either: #define _POSIX_C_SOURCE 200809L #include &lt;math.h&gt; double pi = M_PI; These are X/Open System Interface (XSI) extensions. So this is what is necessary: #define _XOPEN_SOURCE #include &lt;math.h&gt; double pi = M_PI; I'd rather just define `PI` myself than rely on this. 
@sufferedcoin, It is generally slow to use `std::endl` when you just want a newline since it forces a flush. Just writting `cout &lt;&lt; "Thank you!\n";` is better. Also, `main` in C++ doesn't return a return at all! if you fall off the end, the standard says that it is equivalent to a `return 0;` being there.
Didn’t know that! Thanks!
Perhaps the Linux slow down is due to Spectre patches.
That was my hunch, but I really don’t want to blame a system engineered by experts, I’d wager my code does something wonky instead that doesn’t work as well on newer kernels. It should be noted however, that the performance degradation is drastic - about 10-fold.
Use r/gamedev then, it has everything you seem to be looking for. 
Updating soon (:
Many of the universal constants are measurements which we simply don't or cannot have that many significant figures. However, if you know which can be defined to such degree please lead me there.
More info on the satellite thing please!
Really don’t need to buy anything at all. A good portion of software devs are self educated. Technically all are. Plenty of stuff on YouTube. Good luck. 
I don't understand your reasoning. The fact is that '0' = 48.
Sorry if I'm not answering your question exactly, but my best tip is to not bite off more than you can chew. Large and ambitious projects will wear on your motivation. I would still stick to games if that is what motivated you in the first place, but try to set yourself small goals to begin with.
Good idea. I'll try and get to that and add it to my repository. 
The APRS payload for [LAPAN A2/ORARI](https://id.wikipedia.org/wiki/LAPAN-A2) was mine. I don't think I wrote any code specifically for the satellite, it was just one of hundreds of similar boards that were made.
You should check out handmade hero on YouTube. He technically uses c++ but there’s nothing he does you cannot do in C. It’s an amazing resource for making games (he’s making an RPG).
Looks very good, but replace scanf("%s") function with scanf(" %s") , because it can be source of error on some machines. ;)
If you want to use Unity search for Brackeys. They have some good videos.
Which kernel version specifically are we talking? Because if it's &gt;=4.19.2 then it is more than like the Spectre mitigation slowing it down. It's pretty unanimous that it's the cause of major performance regression. Spectre patches were introduced in 4.14 so an easy test would be to compile on a system with a kernel older than that. *buntu 16.04 ships with a kernel old enough. https://www.theregister.co.uk/AMP/2018/11/20/linux_kernel_spectre_v2_patch_slowdown_intel/ https://www.phoronix.com/scan.php?page=news_item&amp;px=Linux-PR_SPEC_DISABLE_NOEXEC 
I was commenting mainly on mathematical constants for which we can find decimal expansion of an arbitrary precision, but you have since then removed them, so it's a non-issue. Obviously for physical constants we can only provide the value to the precision of the experiments that measured them. I'd probably be hard pressed to find anything more than what's on wikipedia.
Thank you very much :D
Thank you, i've actually just started watching it. Appears to be a great suggestion!
pretty cool, how long have you been working on that one?
look up for something called "arrays"
The code is good, but if you are wondering where to go next I would suggest doing something with the code duplication, which is where you find yourself writing loads of code just to repeat something. This may be a bit advanced. My suggestion is to create a [graph](https://en.wikibooks.org/wiki/A-level_Computing/AQA/Paper_1/Fundamentals_of_data_structures/Graphs), where you have nodes that represents rooms and vertices that represents paths that you can take and the subsequent action by taking this path. If you design it like this you can also squash all your input parsing into a single function that asks for user input and chooses the vertex based on the input.
"Creating variables" at runtime doesn't make much sense. There's no way you'd be able to write code to refer to them. Instead, as has been posted, it's something you'd use an array for. It's worth learning about malloc, realloc, free, and pointers and arrays. C99 also introduced "variable length arrays," but they aren't very popular compared to normal dynamic allocation.
Unless your printer setup is foobar'd, you shouldn't need to convert anything. $ lpr source.c should be all you need.
You will need scanf(), for(), and atoi()
I may be way off base but shouldn't you be able to use an array to store your variable values and then point to each individual variable when you need to altar/recall them?
A brainfuck VM
 void *xmalloc(size_t n) { void *p = malloc(n); assert(p); return p; }
There are tons of it that are... not useful if you’re experienced. So don’t be afraid to fast forward or skip episodes. There are so many priceless gems in the series tho.
Thank you!
I am running the latest 16.04 with spectre patches. I assume you mean non-upgraded?
I'm newish to C. I dabbled a bit last summer, then took a college course in C and liked it. Switched schools over winter break, and the programming class I have to take is C. Thought it would be a breeze. Hoooooo boy it is not. The coolest (and therefore most difficult) thing I've ever done in C is each successive assignment. The most recent one involved Taylor series, interpolation, sine functions, etc. 130 lines and it took me 22 hours of labor to finish. I learned a lot about resource intensivity, optimization, and design philosophy. Can't wait for my next assignment. 
Worth mentioning is that the reason for that is to have the `scanf` call eat any leading whitespace.
Try writing a roguelike. Search for how to write a roguelike in C. The thing about RPGs that is tricky is figuring out stats and game mechanics. It helps to have a clear vision of what types of obstacles will be in between the player and their goals and what sorts of traits or abilities they may have to overcome them in a balanced way before writing the code for it. You will probably come up with something simpler with a better feel to it than you would using rules from a tabletop RPG.
&gt; I know this is not a question subreddit i'm not a mod, but i don't think i'd say that; it's just that questions about programming languages *other than* C are off-topic, and [badly-asked questions](https://idownvotedbecau.se/) tend to result in people being disinclined to answer. :-) 
Calling it 'safe' is probably somewhat of a misnomer - malloc on Linux rarely* fails in practice. It returns a pointer to virtual memory that isn't backed by physical storage until you actually try to write to it, which might crash your program at a later time. \* Unless you've disabled overcommit, are allocating some silly amount of data that trips the heuristic, or have allocated more than your address space can contain (something that's not exactly unthinkable on a 32-bit platform).
If you want to be extremely pedantic the standard says that a NULL pointer doesn't have to be represented by all bits zero – the address 0x00000000 could (theoretically) be a totally legitimate place to store data and "NULL" some not-zero-bits trap pattern.
Yeah non-upgraded so it would be the 4.4 kernel. You might still have some other bootable kernels in your grub menu too.
I would consider crash-on-write to be as safe as you could possibly make it, I’m not sure how you could reliably test for that.
^ this
Dope!
This looks very nice! By the way, just a small detail. In order to compile using MSVC and from a batch file (and for cl.exe to be recognized) you need to call one of the vcvars bat files, like vcvarsall.bat. In my build.win.cl.bat I can add first like: call "C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\VC\Auxiliary\Build\vcvarsall.bat" x86 to run, but the problem is it's a different path if you have lower version (2015 etc), or even professional version of 2017 which is C:\Program Files (x86)\Microsoft Visual Studio\2017\Professional\VC\Auxiliary\Build 
If you are asking what printf does it just prints out what ever you put inside of it If that's not your question please explain what your q is 
What you are looking for is dynamic memory allocation. Read about `malloc()` and `calloc()`. Warning! You are entering "the dangerous area of memory management".
I can't help but notice that there aren't any BSTs and friends in there. They're pretty fun to do and the code is very straightforward for the most part.
This is what a [side effect](https://en.wikipedia.org/wiki/Side_effect_\(computer_science)) is in computer science. There are some examples there.
I'm not sure what you mean by "barely useful". The [GTK docs](file:///usr/share/gtk-doc/html/gtk3/index.html) are pretty good. 
You don't say whether or not you need it to be cross-platform, so maybe [IUP](https://en.wikipedia.org/wiki/IUP_(software\)) might be an option?
**IUP (software)** The IUP Portable User Interface is a computer software development kit that provides a portable, scriptable toolkit to build graphical user interfaces (GUIs) using the programming languages C, Perl, Lua and Nim, among others. This allows rapid, zero-compile prototyping and refinement of deployable GUI applications. IUP's purpose is to allow programs user interface to run in different systems in unmodified form.It provides this ability by binding Lua with its C/C++ code, or simply writing C to the application programming interface (API). It handles user interface elements by using native controls provided by native APIs, such as Windows API in Windows, GTK+ in Linux, and Motif-LessTif in older Unices. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
It means “avoid using `printf()` or any other function that has side effects”. A function has side effects if it modifies the state of the program outside of the context it runs in. For instance, `printf()` will cause data to be transmitted to the standard output. The opposite is a “pure function”, which does nothing but return a value derived from the parameters that were passed by the caller. C does not have a notion of pure functions. C++ does (add `const` between the parameter list and the opening brace).
I am very happy with IUP : http://webserver2.tecgraf.puc-rio.br/iup/ 
+1 IUP has a nice api as well. 
The part reads "Return data describing IO which can be executed" example of such part?
You're right, I'll follow you suggestion and start looking into it. Thanks! 
Good catch, I'm using the Native Tools Command Prompt to compile with MSVC so I didn't notice it while writing the steps, but it would be great to have in place something like what you're saying. Thanks! 
There are active [mailing lists](https://www.gtk.org/mailing-lists.php). And looks like they plan a self hosted discourse forum. 
What kind of GUI project? Is it a tool? How big? Depending on your requirements you can use [raygui](https://github.com/raysan5/raygui), it's a very simple immediate-mode gui, I use it for tools creation and it is in very active development. I used it to create [rfxgen](https://github.com/raysan5/rfxgen) and multiple other tools.
This is a subreddit for C programming not C++ Post in /r/cpp/
There is also [Nuklear](https://github.com/vurtun/nuklear)
Use QT and QML? This separates the logic (any language) from the GUI functionality (QML) rather nicely.
"no C++ plz"
Try "FLTK".
"QML"
That’s where they are!!! Thank you!!
There is motif (now LGPL), and xforms (originally used by XFCE).
Yep, sorry. &amp;#x200B; They are technically accurate, but I feel pretty helpless when I read them. 
All the docs are hosted on GNOME's site as well. I have used the examples from gtk3-demo in the past. You also will need to look at the GObject docs
Isn't that still C++? I haven't looked at it in a while. 
I'm sorry I can't help with that but maybe Google can
A structure, that contains pointers to your data and functions that can handle the data and release all held resources.
I’ve used Andlab’s Libui for a project and it’s great! Although there is almost no documentation unfortunately :/
[imgui](https://github.com/ocornut/imgui) has [c bindings](https://github.com/cimgui/cimgui)
Honestly, I would bite the bullet and use C++ and Qt. You can do the UI in C++ and the rest of your stuff in C. I get it, but you're going against the grain here. You either go with GTK+3 or a far less used toolkit to stay with C.
Given this program: void test(float *restrict fp, int *restrict ip, int mode) { *fp = 1.0f; *ip = 1; if (mode) *fp = 1.0f; } a compiler need not allow for the possibility that the writes to `*fp` and `*ip` could alias, and could consequently move the write to `*ip` to the beginning or end of the function at its leisure, thus allowing the two writes to `*fp` to be consolidated and the conditional test eliminated. In the absence of the `restrict` qualifier, the Effective Type Rule would require that compilers allow for the possibility that the writes could alias, thus blocking that optimization. 
Tk? (Don't laugh, it's still pretty great and actively developed)
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
I have removed this question as you have [already asked it](https://www.reddit.com/r/C_Programming/comments/ao90pi/help_to_create_variables/). If you want to change your question, click edit.
This is not possible in C.
If all else fails, you can always use Motif.
An iterative function is one that does its work in a loop. As you said, a recursive function is one that calls himself. Think of the factorial function. It’s generally defined as such: fact(0) = 1 fact(n) = n * fact(n-1) This function calls itself and has a base case and a recursive call, making it incredibly easy and natural to implement recursively. int fact(int n) { if (n == 0) return 1; return n * fact(n-1); } However, there is an iterative solution as well using a loop. The functional difference will be that the iterative solution doesn’t have the overhead of excessive function calls. int fact(int n) { for (int i = n-1; i &gt; 0; i--) { n *= i; } return n; } The two functions give the same results for positive integers, but the way that they do it is different. Recursion becomes important in various data structures, such as trees, and is all but required in languages such as Haskell.
Iterative loops through to repeat some part of the code, like while loops, for loops, foreach loops. These are inside of a method. for(int i :vars){ print vars\[i\];} //this would be in some method. Recursive functions call themselves to repeat the code, they are the method, so in the recursive method there is a call to the itself. String recursive(int x){return 5+recursive(x):}
Ncurses
[Here's my breakdown of available C gui libraries.](https://orangehattech.com/c/)
I used to use GTK, and I was learning Qt. Those were the standards back in the day. However, each version breaks backwards-compatibility, and I got tired of having to port my apps every time a new version came out. I'll definitely be checking out some of the other suggestions here.
There's this little-known C wrapper for Qt: https://github.com/filcuc/DOtherSide
Ive been thinking about doing something like a taylor series calculator in C. Care to elaborate on what you did with taylor series,interpolatikn and sine functions? Much appreciated!
I don't understand. Are you saying you're looking for guides on setting up a development environment in the Linux terminal? 
Here's an outline of a Vim-based workflow: 1. Fire up a terminal and maximize it. 2. Go through the Vim tutorial, `vimtutor`. 3. Start `tmux`, the terminal multiplexer. 4. Split off a second pane within tmux with `C-b %` (that's `CTRL+b`, then `%`). Use `C-b o` to switch focus between panes. 5. In one terminal run this command: vim hello.c Makefile 6. In `hello.c` put this: #include &lt;stdio.h&gt; int main(void) { puts("hello world"); } 7. Still in Vim type `:w` to save, then `:bn` to switch to the next buffer (`Makefile`). Put this in your `Makefile` (note: that must be a tab character before `$(CC)`, not spaces): CFLAGS = -Wall -Wextra -O3 -ggdb3 hello: hello.c $(CC) $(LDFLAGS) $(CFLAGS) -o $@ hello.c $(LDLIBS) 8. Save that file with `:w`. Then, still in Vim, compile with `:mak`. 9. Type `C-b o` to switch to the shell in the other pane and type `./hello`. 10. `C-b o` to switch back to Vim. Use `C-^`, or `:bp`, to switch back to `hello.c`. 11. Edit as you wish. Use `:w` then `:mak` to recompile. 12. If there are errors, Vim will take you to the first one automatically. Use `:cn` and `:cp` to move back and forth between errors. Use `:cc` to redisplay the current error message. 13. Rinse and repeat. Some Vim's default here aren't the best. Suggestions: set hidden " so you can switch buffers without saving set autowrite " automatically save when using :make Suggested tmux config (`~/.tmux.conf`): # Use C-b C-b to switch panes. You do it a lot an this is more # comfortable than C-b o. bind C-b select-pane -t :.+ # Use vi keybindings in selection mode setw -g mode-keys vi 
What exactly is a “Linux distro terminal?”
Of course! I have everything in a github repository. It's private for now until my assignment gets graded - don't wanna cause a false positive on plagiarism tests. PM me your github username and I'll add you as a contributor to take a look.
This is so much better that what the other guy put.
This sub only has two rules, and the first one is to format your code. See the sidebar. Besides that, it's crazy to post a request for help without saying what the problem is. What are the requirements? What errors are you getting? What have you tried to fix it? What did you expect the output to be, and what output are you getting? Help us help you.
Always did like IUP.
Thank you.
Thanks!
Yep, unless this is an intentional copy paste combining two other header files. For example, if you want to use BSD string functions but your glibc doesn't provide them, this is a way to make sure you always get those functions
Depends on what is happening in and outside those guards. &amp;#x200B; Are you sure it is a macro guard for a header file and not just a ifndef-define-endif type of directives to define something? 
Different memory allocation libraries require different kinds of wrappers to detect corruption caused by errant programs. The only thing that would distinguish the Standard Library allocator from most kinds of custom allocators is the availability of ready-made wrappers for it. Custom allocators can in fact be designed to offer better protection than would be possible with the Standard Library (e.g. if an allocator function is only intended to be suitable in cases where allocations will be released in LIFO order unless something goes wrong, it could squawk immediately if a memory leak prevents an object from being released before one that had been constructed earlier, as opposed to merely indicating at the end of program execution that certain chunks of memory never got released.) 
Yeah, I guess it's just segmenting more *#define*'s
I don't understand. English is not my native language. Can you please explain what you mean by "segmenting more #defines"?
Thanks.
`M_PI` is standard. You are full of shit if you believe otherwise. It is part of POSIX.
Thank you for this apology. Please do not delete your posts in the future after receiving answers.
a="\u0391"; What do you think `a` is here? and what do you think the result of `a++` will be?
I'm not totally sure, but I think that \`a\` should be the unicode character 0391, and then \`a++\` should increment the unicode character to 0392, etc.
Note that this is a more advanced way of using Vim than an absolute beginner will be comfortable with, even after going through the Vim tutor. For most people, using a single window without tmux, opening a single file at a time, and compiling on the command line with `make` (or even just `gcc -o` and no Makefile) will be enough to get started.
This does not work the way you think it does. First of all, recall that strings and characters are not the same thing. Assigning a string literal to a character is certainly wrong. Locale is mostly a red herring, too. You might need to set the locale to the users locale for correct encoding, but setting it to anything else doesn't work. Just because you want to print greek characters, you don't need to set the locale to greek. If at all, this makes the behaviour worse because it selects some weird character encoding (likely ISO 8859-7). There are two ways out of your misery. Either use wide characters (yuck!) or use a Unicode library (yuck!). Both suck. One way to use wide characters looks like this, but only works in Unicode locales: #include &lt;stdio.h&gt; #include &lt;locale.h&gt; #include &lt;wchar.h&gt; int main() { printf("Locale is: %s\n", setlocale(LC_ALL, "")); wchar_t c; for (c = L'\u0391'; c &lt;= L'\u03A9'; c++) printf("%lc", c); puts(""); for (c = L'\u03B1'; c &lt;= L'\u03C9'; c++) printf("%lc", c); puts(""); return (0); } 
Can you explain more about what wide characters do? I'm assuming they're kind of like characters, but can store more, which might be necessary for the 4 digit unicode hex codes? 
No. Characters go in \`' '\`. Like 'A' is 65. But characters are limited to one byte, so two-byte Unicode won't work. This is why you need \`" "\`, which means an array of characters. &amp;#x200B; But what's an array, than? An array is actually a place in memory, from which pieces of data lie one after another. So \`a\` stores a number that is equal to the address of the first byte of the character sequence's position in memory. Imagine that you have 100 bytes of RAM dedicated to your program, and there's \`'\\u'\` in the 50-th byte, then 51-st byte is \`'0'\` (not 0), then the next byte is \`'3'\` and so on. \`a\` equals 50 in this case; \`a++\` will be 51. 
It's not part of any C standard, so if you're targeting C there's no reason to use it. Not everyone is using POSIX. Unfortunately *BSD libc is generally sloppy about feature test macros and will expose these macros anyway, which is non-conforming. This doesn't make them standard. As [I showed you here](https://old.reddit.com/r/C_Programming/comments/ao1n9l/hope_this_header_file_helps_all_the_science_coders/efyjnid/), it's not part of POSIX either. That's why glibc, which has by far the best feature test macro compliance, *still* doesn't expose them when you ask for POSIX. They *are* part of X/Open System Interface (XSI), which is why in the SUS documentation [they're labled XSI](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/math.h.html). This is not POSIX, which is why it has its own feature test macro `_XOPEN_SOURCE`.
A wide character is like a character, but it can potentially store characters with higher codepoints than a character. Wide characters are a tricky and complicated subject and the concept is a bit obsolete these days, given that they were implemented under broken assumptions on some platforms (I am looking at you, Microsoft) and that nobody really had thought this whole thing through.
POSIX is a standard. Thus, `M_PI` is a standard constant. &gt; As I showed you here, it's not part of POSIX either. It's not part of the subset of POSIX operating systems that do not chose to implement the XSI interface have to provide. Which operating systems do you know this applies to? Are they relevant? Clearly, POSIX includes the XSI interface. There is merely the option not to implement it. This is similarly to how an implementation of C can decide to be a freestanding implementation and may thus omit a bunch of functionality. Very few POSIX implementations do so. Most are irrelevant.
This sort of thing is why I don't like IDEs. It's frustrating and hard to debug these issues.
My philosophy is that you should avoid any dependencies you don't need. `M_PI` is not standard C (hence "non-standard" in a discussion about C), so by using it you're creating a dependency on a full-blown operating system standard. Avoiding that dependency is utterly trivial, so that's nearly always the right course of action.
I think you're leaving a lot of performance on the table in your render loop. You're using an Array of Structures style that won't be very cache friendly or SIMD friendly. For performance sensitive code like this you're generally going to want to use a Structure of Arrays approach. &amp;#x200B; Instead of one big loop that iterates over each pixel and does all the computations for that pixel in order, you want many smaller loops. Each step in the overall computation should potentially have it's own loop. For example you have some code where you calculate the direction, then you normalize the direction and then to apply camera transforms. For performance you would be better off to calculate all directions at once in one loop storing all directions in an array. Then loop over all those directions and normalize those. Then loop over all those normalized vectors and apply the camera transforms, etc. You can break down the entire computation into these 'stages' where you do a small piece of the computation for the entire dataset. This will generally perform much better.
The `restrict` makes no difference in that code . The strict aliasing rule means the compiler can assume the writes don't overlap. This is the primary use case for the strict aliasing rule. You made this same bogus claim in another thread last week. I think you have been parroting your ideas for changes to the strict aliasing rule so long that you've forgotten what the rule actually says 
Probably just meant `bash`.
That makes so much sense! Thanks a ton! I always stayed away from SIMD optimizations thinking they were way over my head, but your explanation there makes it much clearer. I’ll definitely start experimenting with a SIMD-optimized render loop. My only concern is that it makes the code harder to read for that portion, but I suppose I could have both SIMD and non-SIMD since that render loop is only a small, self-contained portion of the whole thing.
https://www.fltk.org/ https://www.tcl.tk/ https://www.qt.io/ https://www.wxwidgets.org/ Even if a toolkit is C++, you can use it with pure C; worst case you'd have to write a few wrappers.
Maybe? The window where you do things like gcc, -lm, -O0, etc
I used to refer ‘Numerical recipe’ in grad school. The book had not only mathematical arguments but also working program code. We had two copies, one written in Fortran and the other in C. The C version was probably translated from the Fortran version. 
You are talking about arrays of that variable type. If the variable type is only know in compile time, you can use array of unions. As suggested, there are VLA(variable lenght arrays) but IIRC linux wants to erradicate it. I need someone to back it up. But if I stand correct, use malloc instead of VLA for your arrays. Oh, a linked list is probably something you are trying to refer to.
Heck, I didn't even know or consider tmux. I just crack open multiple terminals, 1 for vim, one for compile/run, and a 3rd for multipurpose/general fetching.
yea. I really feel you. You do everything by hand on the terminal? Got a tutorial to recommend by any chance? 
I loved the challenge, will give you feedback soon. Are you looking for runtime optimizations or compile time too?
Compile time, code optimization, algorithmic improvements...
What’s the purpose of a Makefile?
What I use for stuff like that, is a makefile, terminal and then an editor of your choice. You can keep writing your code in C::B, but for compilation, I would setup a makefile to make sure its compiled properly. To compile using the makefile you need make (mingw32-make.exe). I for myself like to have different versions, one with debugging options and one without it. So my commands are: `make debug` or `make release` so I can easily switch between them if I need to. That way you can easily compile from a different editor without the built in tools the IDE provides. Makefiles will make it a lot easier. Also if your compile command gets longer, because of more includes, you only have to define them once in the makefile, which flags etc. and you never have to run anything else than make to compile.
In a lot of situations, tmux is unnecessary but cool. If you're working on a remote system though, tmux is absolutely required if you want to multitask on that machine. There's also a few neat tricks you can do with it, and it's a good alternative to screen in a few situations.
To make compiling projects easier. Instead of running gcc -O3 -Wall- Wextra -Wpedantic -AddMoreCompilerWarnings -AddSanitizer -I/&lt;path to custom includes&gt; &lt;custom libraries&gt; &lt;source files&gt; -o &lt;output file&gt; Stuff like that all the time from the terminal you can configure it all in a makefile and run just `make` or `make debug` if you want all the debugging stuff while developing. A makefile can also be used to compile different projects from just one file in which all the configuration is set. [Here](https://www.gnu.org/software/make/manual/html_node/Simple-Makefile.html) you can read some more in detail.
I don't have time to really dig into the code. My usual approach would be to profile with perf and lock for bottlenecks. I do have a question though: It looks like an 8-bit CRC is used as some kind selection marker. Wouldn't that be prone to hash collisions? Also, dat code style /o\
&gt; It looks like an 8-bit CRC is used as some kind selection marker Haven't seen so far... so was wondering if I should get 7-bit in. &gt; dat code style Kindly explain. Coding style varies very widely so I would like to know what you are indicating here.
Introductory Methods of Numerical Analysis by S.S. Sastry is a good read. It covers most of the introductory part covering up from Computational errors to Regression topics. Well detailed, easy to understand but with a limited no. Of 3-4 Exampler problems per topic and exercise at the end of chapters. Note:- it's a textbook and not a programming book written with algorithms. It's around 250rs at Amazon and worth the money. 
Hi, thanks for writing `nnn` it's awesome! It's obvious that the code is already quite optimized, but have you tested using a macro-based `qsort` implementation? One drawback to the library function is that the compare function can't be inlined.
Thank you 
I'd use a 32 bit hash with better properties than crc. See here for a good overview: https://github.com/rurban/smhasher &gt; Kindly elaborate. For the most part it just looks kind of alien, like it was written in the early 90's. It's not wrong, just ... odd. Two things that bug me are all those #ifdefs in the middle of a functions, and the inconsistent braces.
&gt; See here for a good overview Checking it &gt; For the most part it just looks kind of alien OK. At some point I ran it through checkpatch though not very recently. I can understand the readability stuff with #ifdef but it's a valid usage and is present in less that 10% of the functions. &gt; inconsistent braces What's wrong with the braces?
&gt; Hi, thanks for writing nnn it's awesome! Thank's for the compliment! :) &gt; macro-based qsort implementation I'll take a look.
Under the "Effective Type" rule, using any type of pointer to write to a region received from `malloc` will set the Effective Type of that storage until the next time it is written. Most practical programs that need to reinterpret storage don't need to alias simultaneously-active-but-unrelated references of different types, but the Effective Type rule assumes that objects' "Effective Types" change when written, as opposed to when references are created, and last until the objects are rewritten, rather than when the references cease to be active. 
Are you suggesting something like this: https://github.com/svpv/qsort Very promising!
Sometimes header files will need to use types that are defined in other header files. For example, `&lt;stdio.h&gt;` has some functions that accept a `va_list`, but if user code doesn't actually make use of such functions and doesn't include `&lt;stdarg.h&gt;`, the names associated with the latter header file should be available for user code. A solution for this is for an implementation to define a type `__va_list` (which is an identifier a reserved name, and may thus be defined by an implementation for any reason it sees fit), and then have `stdio.h` define the type if it hasn't been already, and have `&lt;stdarg.h&gt;` refrain from defining the type if `&lt;stdio.h&gt;` has already done so.
Are you suggesting something like this: https://github.com/svpv/qsort Very promising!
`stderr` does not belong to the library. It does not and cannot know its state, what it's connected to, or whether even exists. Have the library return an error code instead. I am fond of standard C's "return -1 and set `errno` on error" idiom, or the somewhat-similar "return negative error code on error".
I've been considering adding some code to make it more BSD friendly, might take time though as I am a noob.
It is not my library, I am merely contributing, and unfortunately the library returns both status_enums and fprintf
I hope I never have the displeasure of using it.
You are welcome! Please raise the PR.
I'll do what I can :)
I am not going to name it, but I am sure you have used it, maybe not programmed for it though
Yeah, that's the sort of thing I'm talking about. Being macro based means the comparison function can be inlined which may make a difference. This is something C++ programmers like to troll us about (e.g. `std::sort` is 3x as fast as `qsort` in part because of inlining.) 🤣
The notion of a major API printing out errors using fprintf() to a stream it does not own and cannot reason about is the most offensive and repugnant thing I've seen on this subreddit. It's something I would expect from someone with minimal to zero programming experience. How exactly am I supposed to use this in any project that isn't tiny? A random print doesn't help me any. How do I even know where it was even called from? How can I be sure that it was even the last call that I made that caused the error? How is the case handled where the fprintf() to stderr fails? Now, if you wanted to offer me the option to give the API a stream to print errors out to, I might consider that. Could be useful for debugging, but feels like the sort of thing a beginner programmer uses and a competent one just doesn't use. You also could do something like perror(), which takes in a value and gives you a useful string. That one is really useful.
how to you format a single word to be like that rather than as a code block?
See I agree with you, but now I have a question seeing as this is a project run by a major company and my code reviewer is an employee of the company, as well as the fact that this is my first commit. What would your course of action be?
&gt; I am not going to name it Please do. No project, open-source or not, should be above scrutiny, especially one that does silly things like this and is as prevalent as you allude.
I will likely delete this later but libvpx which is the video codec for webm
I just took a quick look at the library in question, and also checked the built libraries and executables. All the references I could find to `fprintf(stderr,...)` are in the source code for _command-line utilities_; as far as I can tell, none of the library code emits _anything_ to stderr, much less errors. CLI programs are of course welcome to use stderr, so unless yours is the first-ever commit to do this in library-only code, or I missed something, there's nothing to object to in this instance.
Mine does not do this but the reviewer is requesting I do. Here I'll PM you the change.
This is what I ended up doing after struggling with gtk. Honestly the QT documentation and examples are so in depth that you can easily just copy c++ boilerplate for the general UI portion and then write the app specific logic in pure C. Also QT looks great. 
Hundreds of hours were spent on this in a semester, definitely wished I had more help from my partners. I still have nightmarish flashbacks. Anyway, if you want to learn C, pointers, and how the hell your computer works this is this is it. Best learning experience I've had in college.
But doesn't errno belong to the standard library? If something that the library function called created an errno error, then one could raise it to the application.
&gt; But doesn't errno belong to the standard library? I don't see much need to distinguish the standard library from other libraries. If I pass an invalid value to a library function, setting `errno` to `EINVAL` (or `ERANGE` or some other more specific value, if appropriate) makes sense no matter what library it is. There are a few suboptimal aspects to `errno` though: it requires thread-local storage and it prevents functions from being marked pure, or being automatically determined so by the compiler. So overall I do tend to prefer using the "return negative error code" approach. But even then, I tend to stick to standard `errno`-compatible error numbers for as long as I can.
True! Please consider raising a PR.
There are a few tutorials for using the GTKGLArea widget: https://gtk.dashgl.com/ I made a quick test of a texture preview for Megaman legends using the GTK library and in general I found the experience somewhat enjoyable: https://github.com/kion-dgl/Dash-Texture-Viewer So what kind of project are you looking to get into with GTK3, and what kind of tutorials would you want to have to get started?
you call calloc to allocate 1024 \* the size of a "char *pointer*" bytes, which i presume is not what you intended. that would allocate 4096 bytes or 8192 bytes depending on whether you on a 32/64 bit system regardless, that's not your big bug the big bug is that you memcpy your message, not into the memory returned by the call to calloc, but to the address on the stack where your "char \*msg" pointer is allocated. so when you later call free, you're calling free with a garbage address. should be memcpy(msg, ... or memcpy(&amp;msg\[0\], ...
So there's a lot of weird stuff in this function. Notably, at: memcpy(&amp;msg, ...) you're passing the address of the `msg` pointer, not the value of the `msg` pointer (i.e. the address of the memory allocated by `calloc`), so `memcpy` is then overwriting the pointer and bunch of other stuff after it. Why are you going to all this trouble just to `write` a constant string with constant length? You could just have: static const char number_taken_msg[] = "Bad Player! That number is taken "; write(sockfd, number_taken_msg, sizeof number_taken_msg);
I do most of my programming in terminal emulators and rarely real terminals. No tutorial, but do read intro(1).
That window is called "terminal emulator." Terminal emulators exist for all sorts of platforms and are not very interesting for now, so talking about terminals is a red herring. What is interesting is the program that responds to what you type into the terminal. This program is called a "shell." The most common shell you are going to see is called "bash." The shell is a program that responds to what you type, interpretes it as commands and executes the corresponding programs, such as "cc," the C compiler. One popular C compiler is gcc, the GNU C compiler. You can always invoke a systems standard C compiler through the cc command.
Thanks! I dod not know these GTK related tutorials existed!
your first problem is that calls such as getc() don't return a char, they return an int. They return an int so that they can return every possible character AND also a unique value (EOF) to mark the end of the stream. 2nd problem is that you call 3 functions to iterate over a stream, but your first function advances to the end of the stream (not correctly, see 1st point), so the 2nd and 3rd functions thus have nothing to read. you would either need to close and reopen the file, call something like frewind or better... calculate chars, words and lines altogether so you only parse the file once
ty! what function should i use if not getc? And why isn't the input functions counting properly they don't use that function
`getchar()` needs to be able to return EOF as well as all the possible values for a char. If it just returned a char then you couldn’t have a separate distinct value for EOF.
&gt; I have a programming background(Java, C# etc.) and I initially thought getchar() will return a char type - turned out it returns an int . Isn't this kind of an unintuitive function name? Perhaps, but there's a few things weird things with characters in C. For instance, did you know that the type of a character literal (e.g. `'A'`) is actually `int`, not `char`? One of the reasons `getchar` returns an `int`, not a `char`, is because `EOF` may not be within the range of valid `char` values. &gt; Also, is there an official c documentation where I can look up libraries? The _official_ documentation for the standard C library is the C standard, the latest version of which is [ISO/IEC 9899:2018](https://www.iso.org/standard/74528.html) (aka, C18). You have to pay money to get this, so most people end up using one of the "drafts" instead. The link I had to the last C18 draft seems to be currently broken, so here's [the C11 draft](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf) instead. But while that's authoritative it's certainly not the easiest documentation to use. I tend to use [my system's C library documentation](https://www.gnu.org/software/libc/manual/html_node/index.html) for day-to-day use, and I only refer to the C standard (or, sometimes, the [POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/) specification) when I need to confirm something or think about portability.
On Unix and Linux, opening a file will use the lowest available file descriptor. If stderr is closed at the time the program starts and the application opens a data file (using stdio or direct Unix system calls), then any writes to stderr (e.g. from a library) will go into the data file, presumably corrupting it. In the late 90s, this gave rise to a local privilege escalation attack on Solaris. You close stderr, invoke a setuid binary which opens a security related config file for writing). Also a similar but less severe security hole in the base OpenBSD install; make link to the ping binary with a chosen name, invoke it with a usage error, and the name of the symlink is emitted out of a raw socket. Creating a raw socket is reserved for root, so this is a security hole, but it can't be used for local privilege escalation.
Thank you! I didn't know char is of type int in C (this is the opposite of Java or C# for example). Although it will take some time getting used to, it makes sense now. To my understanding, everything which can be expressed as a char, can be expressed as an int as well(the int allows me to allocate more memory and therefore use bigger/larger representations) - right? &amp;#x200B;
&gt; I didn't know char is of type int in C It's something you get away with not knowing for a very long time. It really only matters in very specific and unusual circumstances. &gt; To my understanding, everything which can be expressed as a `char`, can be expressed as an `int` as well(the int allows me to allocate more memory and therefore use bigger/larger representations) - right? Yes, any `char` value can be converted to an `int` and yield a value equal in value. It's not guaranteed that `char` is "smaller" than `int`, though.
Thank you. So the recommended way is to store the returned value from `getchar()` as an `int`?
&gt; Thank you. So the recommended way is to store the returned value from getchar() as an int? Yes, definitely. If you do not you may not have any easy way to test it against `EOF`. Consider, for instance, a system where: * `char` is the same as `unsigned char` (whether `char` is signed or not is actually implementation-defined), and can represent values from 0 to 2[^8^]-1; * `int` can represent values from -2[^31^] to 2[^31^]-1; * EOF is the `int` with value `-1`. If `getchar` were to return `EOF` and you were to assign it directly to a `char`, it would result in the value 255. (This conversion is defined by the standard since the new type is unsigned; if it were unsigned this conversion would be implementation-defined.) So you've got a `char` containing 255. How would you see whether this was `EOF` or not? This wouldn't work: if (c == EOF) { /* ... */ } since `c` would be promoted to an `int` and keep its value... and 255 is not -1. You'd have to do something crazy like: if (c == (char)EOF) { /* ... */ } This problem is entirely avoided if you just use `int` to store the return value.
getc is okay to use, but you need to store the value it returns in an int. &amp;#x200B; it doesn't work when taking input from the terminal as your scanf says just to extract a single character (%c) and then your countChar, countWords and countLines also then only take a single character (char c) as input. you need to investigate looping, reading one character at a time OR reading in a complete line and iterating over the string OR read about stdin which is a FILE\* that could be used to call your existing functions for counting from a stream (control-d at the terminal would send EOF). That way you count from a file or from input typed in using the same functions. &amp;#x200B; &amp;#x200B;
C# is a nice language. To me it looks like a streamlined C++, which is a good thing. I still prefer C and Go, but I see why people like C#. BTW, wrong subreddit. 
okay, let's say getchar was to return a char (a byte). seems fine, it can return all possible char values &amp;#x200B; but... getchar ALSO needs a return code to indicate end of the stream. what can it return? you might say it can return 0 to indicate this, but then you can't read any file containing the byte 0. same with any value you might pick. hence, getchar returns a larger type (an int) and it additionally returns EOF (-1) to mark end of stream
Similar q&amp;a was posted recently, fyi: https://www.reddit.com/r/C_Programming/comments/an3if9/why_can_i_store_an_int_in_a_char_array/efqmxwc/?context=3 for documentation, I like https://en.cppreference.com/w/c
&gt; I didn't know char is of type int in C `char` **literals** (such as 'x') are of type `int` in C.
&gt; The reason getchar returns an int, not a char, is because EOF may not be within the range of valid char values. It may be the case that every possible value of type char is assigned to a character, so there needs to be something extra to allow EOF to be represented. Except when sizeof(char) == sizeof(int). Then you need to call feof(stdin) to distinguish between a 'char' and an EOF.
Are you on windows? If so, you have to account for the ‘\r’. You also have several errors like the comparison to “.txt”, it wouldn’t work. First you need to use something like strcmp. Also C doesn’t know wild cards or extensions so you jave to define them. For counting words you’re checking against a ‘’, empty character not a space, so that would gove wrong results. 
&gt; streamlined C++ How so?
Less bloat, cleaner languange.
I c. Never really did any C#, but when I looked at it (many moons back), I thought “ugh looks like Java”! I guess I should look again. 
It does look like Java. Is it good or bad, depends on personal preference. I recommend Go, which in my opinion is like a real update to C, but without taking its spot.
So, yes, you have a lot of problems. One of the reasons this isn't working is that you are trying to read the same file multiple times. You would do better if you read a character, and then handled just that character, and then moved on to the next character. You'll end up with many fewer functions. Also, are you sure you aren't supposed to use the command line arguments, like wc would use?
They're both just as much C as the other, I think raylib just advertise that fact more because there's lots of game libraries that aren't in C. I've never used raylib, but SDL2 is a time tested library that is sort of an industry standard. 
thanks, so I guess i will just stick to SDL. Just another question: Can I also work through C++ Tutorials and "adapt" them to C language? Or is C++ SDL completely different? I found also two pure C Tutorials for SDL, but the best SDL Tutorials is probably that from lazyfoo but it's in C++.
I've never used Raylib, but personally, I've been pretty happy with SDL2 besides its built in rendering functions. I haven't had too much exposure to it besides the games I've been working on between school semesters though, so others may have conflicting thoughts.
SDL is written in C itself, so it is quite unlikely that you are gonna run into problems when developing for it using C(although most guides/tutorials about working with SDL2 you will find online will propably assume you're programming in C++). While I have never used raylib myself(only just now looked at the documentation), I did experiment around with SDL2 a bit in the past. It is a fairly low-level(compared to other libraries of its kind, I know that SDL2 is ofc a high-level library) library for handling your program's windows, drawing stuff in them, input handling and managing threads. As you talked about OpenGL, SDL isn't a 3D library. SDL can create a window with an OpenGL context, but that is about it, for the logic there you will have to use the good old-fashioned gl calls yourself and SDL doesn't help you in any way with that. Should you only care about 3D stuff, you might want to give GLFW a look then. The raylib you mentioned on the other hand seems to be a fairly high-level library that seems to do lots of things for you, it also is a true 3D library and provides lots of structures and functions to make creating your 3D application much easier. On the downside, this may limit what you can do with it, the performance may not be as good and (most importantly) you are unlikely to find ever find any kind of help outside of their site as it simply isn't used widely. (unlike SDL which is widely used) 
SDL in C++ is just using the C API last I looked. You shouldn't have any issue with doing that.
Oh God. Thank you... Don't know how I didn't see that. And no idea why I didn't just write a string to write, I've done that elsewhere lol 
Thank you, no idea how I missed that! 
I actually prefer to just start vim on its own, then to build I hit ctrl+z to background it. Run make, then run "fg" to resume vim. No tmux needed. Just vim and make, with an easy key combination
As long as you know the differences between c and c++ you can definitely do that, using structs and functions in place of classes and methods. A lot of cpp focused tutorials will also overload the math operators for things like vectors and matrices, where in c you have to live with "ugly" function names like vec2_add() and such.
If you want to make games, I'd suggest getting a game engine. The problem here is that if you set out to make a game in C, what you'll really end up doing is making a game *engine* in C and that's a rabbit hole. If the end goal is to make a game, don't make a game engine. It's 2019 and there are many free or cheap engines that will do all that work for you, take advantage of that. It will take you much less time to make the game, the game will be higher quality and your users won't care whether you coded it from hand or used an engine. This is also something I wouldn't recommend for a beginner. A game engine is a complicated thing that touches on many subjects and most beginners who set out to make an engine or a game usually fail. I would only recommend this for the most persistent and self-reliant beginner. It's not like it's a herculean task, it's just not something you'd want to attempt with no experience, especially with no experience in gamedev. A common sentiment is that using a game engine is "cheating" or "the easy way." Making games is hard enough, game design is hard enough, you don't need to be making it any harder on yourself. There are plenty of challenges to be met even when using an engine. Also, this book uses C++, not C. If you only know C++ then trying to learn C++ at the same time as following this book, you're probably going to have a bad time. C is simple, C++ is not. It's not something you pick up on the way to something else.
Hey! I'm probably biased on my opinion but raylib was specifically created to teach videogames programming in an easy and enjoyable way. It's been used with around 1000 students to date and everybody that tries it, likes it. My recommendation, you're the teacher, try both and evaluate which one better fits your intended syllabus and teaching methodology. Actually that's what I did when I started teaching videogames programming and so I created raylib.
RayLib is nice, as it gives you more pre-built game related stuffs to work with. SDL provides bare bones multimedia access.
Never used raylib, been writing an [Archon](https://en.wikipedia.org/wiki/Archon_(computer_game)) clone in C using SDL2 and have found it easy to use.
For graphical development with C, it depends on what kiond of API you want to you. Specifically there is OpenGL or Vulkan. OpenGL is a 'higher' level GPU language where you define programs that tell your GPU how to draw a screen, where as Vulkan offers more low level assembly access to the GPU's hardware. For C there are a few Window libraries that allow you to make a window with OpenGL context/ They are: - Glfw - Freeglut - SDL2 - GTK3 *GLFW* is the library used in the offical Redbook OpenGL book uses for explanations. It offers bindings for OpenGL and Vulkan. One downside about it is the Redbook uses C++ for linear math, when libraries like [this](https://github.com/felselva/mathc) exists, where the matrices needed for 2d/3d math have already been implemented in C. *Freeglut* is one of the easiest libraries to get into. They have a great [wikibook](https://en.wikibooks.org/wiki/OpenGL_Programming) that describes some of the basics for OpenGL specifically, and while the tutorials use C++ for the matrix libary, translating the tutorials back to normal C is good programming practice. A translation can be found here: https://github.com/kion-dgl/3D-Cube *SDL2* is the libary I see everyone recomending most often, and while it is a standard, the number of resources for specifically C are far and inbetween. Generally most of the documentation seems to be on [Lazyfoo](http://lazyfoo.net/SDL_tutorials/) and mostly uses C++. Specifically for C there is a Shoot-em-up tutorial [here](https://www.parallelrealities.co.uk/tutorials/). *GTK3* is a more general window application. So if you're interested in making UI beyond just games, it has a selection of widgets you can use to create different applications. One of those widgets is the GTKGLArea, which allows you to create an OpenGL 3(or higher) context in your application. And there are a few practical examples [here](https://gtk.dashgl.com/).
In die(), fputs+fputc might foul errno before perror sees it. Not likely, maybe impossible even, but... You don't need to pass .Xauthority to the server ? Is the signalpipe necessary, why not just do cleanup and \_exit in the handler ? You could block some of the signals until you are all set. You are not launching xinitrc too soon, before Xserver has initialized, does the -displayfd thing take care of that ?
Put backticks around it. Read the formatting guide for details.
The maintainers of Microsoft's compilers have traditionally been much more interested in avoiding breaking changes than have the maintainers of gcc and clang, and I would not want to see them adopt a more "modern" attitude. Given a choice between a C89 compiler with some C99 features that can reliably process: int *p = arrayOfUnion[i].intMember; *p = 23; in a fashion equivalent to: arrayOfUnion[i].intMember; and process unsigned mul(unsigned short x, unsigned short y) { return x*y; } in a fashion equivalent to unsigned mul(unsigned short x, unsigned short y) { return 1u*x*y; } and a C11 compiler that cannot, I'd much rather have the former. Of course, clang and gcc can be forced into a mode that can recognize such constructs, but only by disabling useful optimizations that some of the better 1990s compilers could accomplish safely. 
&gt; In die(), fputs+fputc might foul errno before perror sees it. Not likely, maybe impossible even, but... [Fixed](https://github.com/sineemore/sxinit/commit/a91443c5e3851a2688816d779b0111eec664ddd4), thanks a lot! &gt; You don't need to pass .Xauthority to the server? IDK, at least not in my setup. I'll read more about this anyway, thanks for suggestion. &gt; Is the signalpipe necessary, why not just do cleanup and _exit in the handler ? You could block some of the signals until you are all set. I don't think it is safe to run `cleanup` from signal handler. Am I wrong? &gt; You are not launching xinitrc too soon, before Xserver has initialized, does the -displayfd thing take care of that? It does. Well, it probably should, but sometimes parts of my `.xinitrc` are not handled properly. Actually it is the main issue with `sxinit` in my setup. Dunno why this happens. The issue is `setxkbmap -layout us,ru -option grp:rctrl_toggle` from `.xinitrc` doesn't *always* work and `stderr` is silent about this. Any thoughts?
You're not wrong, Walter, you're just an asshole.
I am not really aware of any breaking changes, and as far as I can see the C committee is pretty careful about backwards compatibility. However, if you prefer older implementations nothing would stop you from using the current one? I am actually pretty sure that Microsoft doesnt care as much about breaking changes as you might think, but rather focuses on C++ because in their eyes it has everything a C programmer needs - which is not true in my personal opinion.
I could give it a go (a little while ago I made a post about modern c support on windows) but forgive me for not being optimistic. Before when this was brought up, the vs dev team were actually quite rude about it. When asked why they couldn't implement a few extra libraries and small C syntax changes they essentially said "we don't want to that's why" (paraphrase) then they hid behind the, "just use c++, trust us it's better" cloak. 
I disagree. returning variables isn't always possible, setting a global variable is just disgusting. I'm writing errors to stderr, get over it.
Well that's really fucking dumb.
Design a proper interface and you can return error enums every time dingus.
There is only ONE true book! The Second Edition K&amp;R big blue "C"! As well as ten thousand others.
[the manager for MSVC has already said they're planning on supporting C11...](https://twitter.com/UlziiLuvsanbat/status/1052976061431013377)
I some of my personal stuff, I've played with using constant strings, the first word of which is a number. NULL typically means no error. If I care about the actual error, then I can call `itoa`, but I usually just print the string in my client code and move on. Saves from having to implement a version of `strerror`
I'm Pedro in that thread. Another thing worth posting is this: https://www.reddit.com/r/programming/comments/8hqc3l/announcing_msvc_conforms_to_the_c_standard/dyo85sd/?context=4 Personally, I think it's a waste of time to wait for Microsoft to give a fuck about C. I'm not even sure if I care anymore, of if I'm insisting on it just out of hope and habit. As a long time follower of the VC++ team on the web, over the years I've noticed with their articles and interviews how much the VC++ compiler is broken and old. It's basically the reason why MS has managed to never be competitive on C++ support until last year when they even went as far as implementing hacks as workaround in order to claim the title of the first full featured C++17/20 compiler (yet range-v3 is yet to compile successfully on it). As dealing with that much broken shit (I suspect Windows 10 came about when the Windows team accepted they would have to dive into the shit pool that is the ~30y/o Windows/NT codebase), there's also the fact that an update to the C side of the Microsoft ecosystem is counterproductive in terms of their push for the higher level platforms and frameworks such as WPF, UWP, etc. This directly influences the next factor, which is the lack of demand together with lack of any ROI for them, making the effort far from worthwhile. Though a great deal of the C++ standard is backported to C through the members of both committees, supporting the language part of the standard would require dedicated effort into it, to make both the compiler and IntelliSense aware of the changes. But virtually no one wants or has to deal with C code bases on Windows unless you develop/support old driver stacks or support a product that's been around ever since before the half of the past decade, like the Office suite, Photoshop, the VC++ compiler, or develop anti virus products, etc. Even Intel has announced they will be dropping the Windows API driver stack and migrate it to the UWP, which is basically the biggest nail in the coffin of both the Windows API and with it, C development in Windows. So yeah, I wouldn't get to hopeful. IMO there are more than enough reasons for Microsoft to just kick the bucket and call it fuck it.
typedef enum ... LibName_RetCode; does it every time.
Ever heard about indentation ?
I have to read enough shit C code at work, and you come asking for help hoping for people to read something that is objectively harder to read than assembly? Hint: use gist.github.com
When C89 was written, the first code snippet in each pair above would have been non-controversial when targeting any remotely-commonplace implementations. Neither clang nor gcc handles the first equivalence above reliably, and gcc will not handle the second reliably.
Yup, I messaged /u/Spongo2 from that thread a while back, and he told me to contact the manager dude on twitter. C11 is happening in the near future for sure, the only question is when.
I didn't read the entirety of it, but why in push are you setting the parameter val to 0, then to the top of the stack and don't do anything with it? Then you decrement topA, index the array at topA+1 i.e. stack[MAX] which is out of bounds. 
I already indented all of the lines with a tab space thereby resulting in a source mode. What's wrong?
Paste it into pastebin or replace the tabs with 4 SPACES
If so, might as well go for C17 since the last std was just a bunch of defect reports, nothing new, so that means saving a bit of effort. But we'll see.
A tab space is already equal to 4 spaces!
Why do you have separate `push` functions for each stack when they all have the same type? Also, why do you `#include &lt;malloc.h&gt;` when you don't use anything it provides? Try something like this for your stacks: typedef struct Stack { int * stack; int top; } Stack; Initialize them (using `malloc` for `Stack.stack`\--be sure to `free` this when you're done), and pass pointers to your fancy new stacks into push and pop functions to avoid duplicate code. This won't *directly* solve your problem, but it'll make debugging a lot less painful.
It's always possible if you make an API that doesn't suck. People like you, who write crappy code that works until it doesn't and tell everyone else to deal with it are wonderful job security for red team though, so maybe I should thank you 👌👌👌
https://stackoverflow.com/questions/54610637/multiple-stack-program-in-c-language-shows-incorrect-element-after-a-certain-amo
&gt;edit : i meant run, not compile. Does that mean it does actually compile, just not run? Can you paste the full terminal output, including the compiler output etc. You've not given much to go on.
It’s not. Don’t use tabs outside of a make file.
The indentation needs to be different for different lines. Four spaces before everything tells reddit that it's code, then the actual indentation begins: int popA() { int val; if (topA == -1) { printf("\n Underflow"); } else { val = stack[topA]; topA--; } return val; } 
 Your problem is your overflowing the arrays. Your limit check is checking the top index against the size of the array. So your check is off by one.
People are downvoting you because you just pasted a wall of a few hundred lines of badly written code with no formatting. Now there's nothing wrong with writing bad code with bad formatting, but if you want people to actually read it you should post it somewhere in a nice format and give a link. As an example of what you should do, I took your code and popped it into GDB online Debugger and made a link, here you go:[https://onlinegdb.com/ryqdWphVV](https://onlinegdb.com/ryqdWphVV) I don't mean to be all negative, I think it's a great effort and you wrote a lot of code. The problem with your program is you are repeating yourself way too much. You should have one function for pop, one function for push, one function for display, one function for top, and each function should take the int array as it's parameters. That would cut down the code you've written by like 80%. As an example, instead of having: &amp;#x200B; `int` `popC ()` `{` `int val;` `if (topC == -1)` `{` `printf ("\n Underflow");` `}` `else` `{` `val = stackc[topC];` `topC--;` `}` `}` And then another function `popA()`, etc. You should just have a function `pop(int* stack, int size)` where you pass the int array of the stack and it's size (the more efficient way to do it would be to to use a `struct Stack` as others have recommended) Because the problem is, in your `popA()` you return val at the end, but in some of the other pop functions you never return value. That's because instead of just making one function and making it work for multiple situations, you are copying the same code into 5 different functions, and some of the are wrong and some of them are right, but you can't really tell because you have so much code written. It's import to learn DRY; Don't Repeat Yourself. So, because you re-wrote every function for every variable you declare, you introduced a lot of extra code and a lot of it is buggy. You should re-write your program so you have one function for each procedure, and just pass each stack to the function with the relative info that you are modifying. I'm guessing most of your errors are because you are not returning the value inside of every pop function, only some of them. But there are probably more bugs around.
The dialect processed by the Borland and Microsoft C compilers for the 80386 and successors has remained stable, and it was only quite recently that Microsoft announced that it would no longer maintain the equivalent of `-fwrapv` as default behavior--something they deliberately announced as a change. It would have been helpful if they had clarified whether it retained the more useful but inexpensive guarantees that had been associated with `-fwrapv` [such as the fact that integer computations other than division/remainder will have no side-effects even in case of overflow, even if the result might behave as though promoted to a longer type]. When the C Standard was written, the authors did not think it necessary to mandate support for constructs that compilers were already supporting in cases where it made sense. In discussing the question of whether `unsigned short` should promote to `int` or `unsigned int`, the authors explicitly noted that constructs like `uint1=ushort1*ushort2;` were treated as as equivalent to `uint1=1u*ushort1*ushort2;` on implementations where doing so was sensible. There was thus no need to mandate that behavior, since the only implementations that wouldn't behave in that fashion would be those where some other behavior would make more sense. Unfortunately, the language has gotten caught in a Catch-22. with the authors of the Standard saying that there's no need to mandate that implementations where a particular behaviors would be cheap and useful support them, since such implementations would presumably do so whether or not it was mandated, and compiler writers saying that any code which relies upon behaviors not mandated by the Standard is "broken". As a consequence, the Standard has driven a wedge between between "unoptimized" dialects of C that allow a wide range of tasks to be accomplished easily, and aggressively optimized dialects that make it difficult or impossible to do things which had been easy in the unoptimized versions, rather than facilitating the standardization of a dialect which can easily support all of the semantics of the unoptimized version, often without any code changes, but still supports *most* of the useful optimizations that would be possible in the aggressively optimized dialects. 
I was about to make this exact point. Data types in C are not a fixed size and vary depending on the platform. 
I'm not sure what the 1974 C Compiler would have done with a `sizeof` expression whose operand was not an lvalue, but in general the language Ritchie invented, expressions that weren't lvalues or had to be of type `int`, `double`, pointer-to-lvalue, or pointer-to-function returning some type of expression. I think that continued through the K&amp;R1 era, except for the addition of two new types--`unsigned` and `long`--which seriously broke some nice aspects of the language until prototypes were added (and still break them in contexts like `printf` argument lists). Viewed in that light, what type could ``X`` sensibly have other than `int`? 
The behavior of assigning -1 to any integer type is defined by the Standard. If the destination type is unsigned, the value will be the one which, with one added to it, would yield zero. If the destination is signed, it will store the value -1 regardless of whether the destination type is larger or smaller than the source, with the possible contrived exception of a single-bit signed bitfield on a non-two's-complement platform.
Java is designed around the Java Virtual Machine. C# is designed around the .NET Framework, although some early parts of the design may have been intended to be platform-agnostic, and C# uses some abstractions which don't match the way things actually work. In C#, for example, given a loop like `for (int i=0; i&lt;10; i++) { someStruct x = new someStruct(i); ... }`, if e.g. the constructor of `myStruct` invokes an implementation of `IDictionary&lt;int, myStruct&gt;` which was written in another language, it's possible that the value of `someStruct` may leak from one iteration of the loop to the next despite the fact that the constructor call looks like a simple assignment. 
If you close 'stderr' you should modify it's value to something else or something invalid.
&gt; The behavior of assigning -1 to any integer type is defined by the Standard. Ah yeah, you're right. I got confused about conversions where the new type was signed and could not represent the value being converted.
&gt; Viewed in that light, what type could X sensibly have other than int? Sure, from a historical perspective it makes perfect sense. But it _does_ surprise a lot of programmers. Especially since in C++ the type of a character literal is `char`.
Good point. I was thinking about going into some of the details of oddball architectures, but I thought it might confuse the issue, at least for the OP. For most programmers on most systems, I think relying on `EOF` to indicate end-of-file or error is sufficient, with `ferror` being used to distinguish the latter. In my experience, `feof` tends to be a bit of a code smell: it's often used erroneously _before_ an IO operation has taken place, whereas it can only indicate that an EOF was encountered on the _last_ IO operation.
In the examples I gave it's the attacker who closes stderr. In any case, the ISO C standard does not allow C programs to assign to stderr. The best option is to reopen it onto /dev/null or /. Same for the other standard streams.
No, `fopen()` cannot do this. As you already learned, this is exactly what `popen()` is all about. If you really insist on doing it yourself, you could implement your own `popen()` using `pipe()`, `dup()`, `fork()`, `exec()`, and `fdopen()`. There's little benefit to doing it yourself, though. 
Eh, they wanna do C11 at least and integrate Clang. No idea how this will go. But there's still the use-case of supporting cross-platform programs which are still there and the newer WSL-Stuff. I'm not sure what MS is up to, honestly.
I can relate to your thoughts, I think this has been brought up quite a few times in the past. But I still wish Microsoft implements it, and a few comments today gave me a lot of hope! Having to talk to rude devs sucks, although I think we should have some sympathy for them - they probably get a lot of requests and saying "no" at first might be common practice to protect yourself from an overwhelming amount of work. In the end they might also just have had a bad day.
I'm kinda wondering about that too tbh. also, I wonder how quickly they'll support C2x? I'm excited for the new (C++ compatible) attributes.
You can’t declare the same variable more than once in the same scope. Make the second one tmp2 or declare double tmp one time before you use it 
That's actually awesome! Thanks for sharing this. Now let's hope he stays manager long enough until it is implemented. I still hope to see some more votes on the feature suggestion though, just to show we would like to see it actually happening. In the end we just need a couple more votes to make it the [most popular VC++ feature request](https://developercommunity.visualstudio.com/spaces/62/c.html?sort=votes&amp;type=idea&amp;openOnly=true) on their platform as far as I can see. 
k fixed it, whats the error with the printf?
Besides that: things just get lost in the noise if every library decides to dump their output into the debug cacophony. Always disable your helpful debug log output when you are done with it, otherwise it compounds over time and there is just noise. 
Try a debugger, they are very useful when debugging crashes. BTW you should format your code.
Deprecate breaking extensions. Upgrade to proper C99. Upgrade to C11. Boom.
&gt;\#include &lt;stdio.h&gt; \#include &lt;stdlib.h&gt; \#include &lt;ctype.h&gt; int lines = 0; int words = 0; int characters = 0; int choice; char filename\[256\]; char input; FILE \*files; FILE \*stdin; int c; int i; //pointers needed &amp; take in input int countLinesF(FILE \*files,FILE \*stdin) { while ((c = getc(files)), c = getc(stdin) != EOF){ if(c =='\\n'|| c == '\\0') { \++lines; } } return lines; } int countLines(char input) { if(input =='\\n' || input =='\\0') { \++lines; } return lines; } int countWordsF(FILE \*files, FILE \*stdin){ while ((c = getc(files) != EOF) || (c = getc(stdin) != EOF)){ if(c == isspace(c) || c == '\\n'){ \++words; } } return words; } int countWords(char input){ if(c == ' ' || c == '\\n' ){ \++words; } return words; } int countCharF(FILE \*files,FILE \*stdin){ while ((c = getc(files) != EOF) || (c = getc(stdin) != EOF)){ // if(c != ' ' &amp;&amp; c != '\\n' ){ // characters = (char)c; characters++; } //} return characters; } int countChar(char input){ if( c != ' ' &amp;&amp; c != '\\n'){ \++characters; } return characters; } hey i tried the debugger it just says program exited with exit code 0
Missing semicolon at the end of line 53.
Why are all of your variables global? and how do you know it crashes does it leave an error message?
In my experience, signal handlers can do anything when care is taken. But that's no proof at all. It used to be, that Xserver made a reset, whenever client count dropped to 0. I don't know if it still is so. It would explain intermittent stickiness of setxkbmap.
That's not a debugger?
i used gbd that's what it said
Did you add any breakpoints? What do you think a debugger does? The point of the debugger is to stop the code while the program is running and check what each variable is. Just running the debugger won't do anything.
it was to use the variables in the functions and main. it supposed to be counting the characters from the file or multiple files and the standard input. i commented out a lot of things and finally realized it was my argv and argc and stdin that was making it crash. works without them. still not sure how to implement it. ty for the help &amp;#x200B;
A key aspect of the early design of C is that a value of any integer type would always behave as a value of the largest integer type, and likewise the value of any floating-point type would behave as the largest floating-point type. This principle can greatly simplify a language and eliminate many weird corner cases; if one doesn't mind casting the left-operands of division, remainder, right-shift, and comparison operators in cases where performance is important, treating integer expressions as though they were evaluated as the longest integer type need not cost anything in other cases, and will default to a "safe" behavior in cases where performance isn't important. I think adding `unsigned` and `long` types without having `int` promote to them was worth the hassle in many cases, but it would have been helpful to have a variadic-function prototype syntax that would specify that all integer operands should be promoted to the longest (specified) type the function can handle, eliminating the need for callers to care what exact kind of integer or floating-point value they're dealing with. 
[https://en.wikipedia.org/wiki/Embrace,\_extend,\_and\_extinguish](https://en.wikipedia.org/wiki/Embrace,_extend,_and_extinguish)
**Embrace, extend, and extinguish** "Embrace, extend, and extinguish", also known as "Embrace, extend, and exterminate", is a phrase that the U.S. Department of Justice found was used internally by Microsoft to describe its strategy for entering product categories involving widely used standards, extending those standards with proprietary capabilities, and then using those differences to strongly disadvantage its competitors. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I changed -1 to 0 and it instantly solved!
So you have two executables right? One generated by your unity project, one generated by your C++ project? And you start them both up, and expect them to communicate, right? Well first up I would say that this sounds like a pretty bad design, provided that there isn't something else going on which we aren't aware of. If you need 1% of OpenCV, you would be better off linking what you need from openCV into your Unity executable and moving everything into the unity framework. Now I'm assuming that your openCV code needs to do something else in addition to provide data to Unity, so you can't do that, and it needs to be a stand alone executable for some reason. The solution is you need to use some form of IPC. I would probably use a library like zeroMQ ([http://zeromq.org/](http://zeromq.org/)), which I've found to be pretty good and has good cross platform support. Link it in from both sides and off you go. Now if you don't want to use a library for some reason, it is possible that a suitably elevated program can map arbitrary memory in the address space of some other process into its own address space (e.g. by using mmap on POSIX systems [https://en.wikipedia.org/wiki/Mmap](https://en.wikipedia.org/wiki/Mmap)). But this isn't going to be portable. Honestly since you're asking this question I reckon you'd fuck up this kind of design anyway, just use a library. Disclaimer - I've never used unity or C#. No idea how hard it is to link in arbitrary code.
There is are a few fun ways I thought of before I just looked up a real solution(here is the real solution https://docs.microsoft.com/en-us/windows/desktop/ipc/interprocess-communications ) Fun Way 1. It is to write a very specific order of numbers to what we will call your data stream(which will just be a variable) in your C++ script. This will allow the C# script to "initialize" by checking memory address for one sending out that order of numbers, then it will set that order to another number completing the pairing process. Then you can just transfer the data between the two by setting the memory address to something. Fun Way 2. Write the data to the users clipboard without their permission. Fun Way 3. Use the windows.h library to press usually unused key representing numbers to transfer the data. Fun Way 4. Host a TCP/UDP server locally that broadcasts the data. 
For 1: The processes have different virtual memory spaces. This will require elevated permissions and some wonky stuff to map to a foreign address space. No idea how to do something like that on Windows or if its possible. If you get over that and you just need to share the physical address between the processes, just sync this by writing to disk somewhere agreed on in advance. 2 and 3 sound not so much fun as infuriating when I want to use my clipboard/keyboard at the same time as running this thing. 4 is totally viable and in fact the link you give mentions using windows sockets.
I am not sure about in C# but memory addresses can decently easily be directly written to in C, after all that is how the cheat engine works. And I am pretty sure(I may be wrong as I am not an expert on data architecture) pointers point to a global memory address.
Not to be rude, but you are definitely on of those people on SO who tells people that they shouldn't have asked the question in the first place. But you are better than most of them in that you did answer the question.
I believe you have some reading to do. Here are a few wikipedia pages to get you started: [https://en.wikipedia.org/wiki/Virtual\_address\_space](https://en.wikipedia.org/wiki/Virtual_address_space) [https://en.wikipedia.org/wiki/Process\_isolation](https://en.wikipedia.org/wiki/Process_isolation) [https://en.wikipedia.org/wiki/Virtual\_memory](https://en.wikipedia.org/wiki/Virtual_memory)
Yeah with pointers I thought I was likely wrong about higher level. But I remembered there was a way to write/read memory addresses fairly easily from when I was playing around with the Windows.h library and I found it. https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-readprocessmemory
Now you say 'fairly easily' but note from your linked article: "The handle must have PROCESS\_VM\_READ access to the process." Now how do you get that access? I've got no idea myself, since I rarely use Windows. But I'm assuming that two random processes don't have that access to each other, otherwise security would be non-existent on Windows. Possibly you might get it by running one process as administrator. But you don't want to start elevating every damn time you require something like this. I am guessing that the main way to use the call you've linked 'in the wild' is actually to spawn one of the processes as a child of the other. That is the wonky stuff I'm talking about.
Thank you for your contribution.
It definitely is fairly easy to gain this access, you can for example write to the Windows calculator in under 20 reasonably sized lines. Here is a guide I found online that shows how easy it is https://null-byte.wonderhowto.com/how-to/write-into-another-processes-memory-with-c-0169224/
For more info on the handle read here https://docs.microsoft.com/en-us/windows/desktop/procthread/process-handles-and-identifiers but it is created by the process, it sometimes may require admin permissions but I don't think it does to read memory as I have seen nothing to indicate it does anywhere and I don't remember requiring it when I used this function. Admin is likely required for handles that edit registries for example though.
I would be shocked if that program runs as you expect it without selecting 'run as administrator' or whatever. So yeah, it is fairly easy to gain that access if you explicitly grant the program access to do whatever it damn pleases. Not so simple if you want to distribute your software to an average user, including the large class of users who don't have administrator access to the machines they are using (to say nothing of it being a bad design principle anyway to always require elevated privileges for software).
Vote for Pedro?
I thought this was implied to be a non-user facing product. Why would you ever run multiple processes as a non-user. Unless the Unity project would be a child of the C project which in that case it would have the permissions.
Definitely! Right after voting for the feature request.
"Why would you ever design software this way?" was the gist of my comment which you had a go at in the other thread. I think it is reasonable to assume as a starting point that software is being developed for use by people other than just the developer. Even if that's not true, it should be written as if it is. Also I wrote this in response to your comment where you seem to think that reading another processes memory is NBD and doesn't require admin rights: Dude just think about the security implications here for a second. Lets say an exploit emerges which allows malicious javascript to execute arbitrary code on a machine using some web browser. That shit does happen from time to time. If you are right, then all that has to happen is a user navigates to a website hosting that exploit, and boom the hacker has access to everything in your RAM. That probably includes unencrypted passwords, browsing history, what music you're listening to, if you have kids, your wifes name, your credit card details ETC ETC ETC. HOWEVER if you need admin access to do that, all the hacker has access to is the address space of the javascript engine used to run the malicious code. He probably already has a pretty good idea of what that looks like. Have a read of things like spectre and meltdown etc. The whole fucking world went nuts over these exploits and they literally just allow an unelevated user to do what you seem to think is par for the course. Anyway I don't see this getting any more constructive. I hope you have learned some things about operating systems and security.
I did not go at your comment I made a minor joke, but yes it does require admin permissions I didn't consider that a major issue as most uniformed users will give admin permissions to anything
It doesn't sound like a crash which should have caused segmentation fault or similar. Which means it may be easier to debug using printf statements in the code to print out variable values. 
What was deleted?
Also thanks for the response but I found a solution, I ended up exporting the C++ project as a DLL and using functions linked to my class containing an api I made(i don't know if I said that right) I was able to call the main function of the DLL and call 2 more for positional data. I really appreciate the response, thank you. Bear with me I am still New to C++
What the hell is an object?
Im referring to a sphere thats in the scene already. The host can shoot the sphere and it bounces away. But not when client does it. I think its due to ownership 
&gt; the shit pool that is the ~30y/o Windows/NT codebase NT was spec'd on '88 while Linux is from 1991. Even OS X goes back to NeXTSTEP 0.8 from '88. None of this stuff is all that new. Next pushed for their objective C in the driver kit, Microsoft kept C++ out of the kernel, as does Linux. They will go clang long before they kick it. But they are on the DEC fast track as they keep withdrawing from markets. 