&gt; C is a language that forces you to understand how you are using memory, and forces you to be responsible for what you do with that memory. Java, Python, JavaScript (and other higher-level object-oriented languages) hide those details away from the programmer, and then they take care of everything for you behind the scenes. This is the main reason why I'm considering C, to be honest. 
Yeah, just like stack overflow is SEO friendly and I thus have to scroll through halfa apage of useless SO posts until I find the actual documemtation. Which is getting actually annoying.
Latter half of the inner loop makes no sense. sizeof(line) in particular, size of a pointer knows nothing about what it points to. Do you need to use the temporary out\[\] at all ? Shouldn't it go something like this: while match in line print line upto match print substitute line += match length print line
Client has no new\_s
This true, but I have a very short attention span. I'm not complaining, I actually got tested on this recently and found among other things that I was in the 0th percentile of the attention scale. I'm working on overcoming it but videos are helpful to me since they can hold my attention better.
&gt;I have been trying to read some, but stuff like K&amp;R just confuses me and doesn't teach me anything. I'll admit, it's terse yet dense. You have it take it slow, do the exercizes, and don't move on until you're good on the section you're on. You can't learn a programming language through osmosis. Sure, videos can help explain a bit, but nothing beats sitting down, writing code, and evaluating the results. Ultimately, *doing* is what is going to get you there. &gt; It just makes me confused and feel stupid. Don't let it get to you. It's pretty abstract stuff, and it takes practice.
I don't think you've truly grasped the material that came before the exercise. Go back and go over it again. You need to understand it before you can complete the exercises. You can (and should) refer to previous chapters as you work through the problems. Each time you ask yourself a question, go back and find that answer. It's in there, I promise.
I understand. I wish you all the best and great success.
What errors are you getting? The only syntactical problems I see is you need `#include &lt;string.h&gt;` for `strcmp`, and `gets` is deprecated (and removed in newer versions of C) so you should be using `fgets` instead.
What compiler errors are you receiving? They're usually decent at telling you where the mistake is. void remplir(char**T,int N) remplir(org,nb); It looks like your function call types don't match your function declaration.
Don't let the initial difficulty get to you. Ultimately it's the *same* paradigm as Python in the respect that your code is a sequence of instructions, controlled by decision statements, loops, etc. Good code is broken down into reusable functions. Python my have spoiled you a bit. It handles quite a bit of low level ugliness you're not used to, and gives you powerful types that include numerous functions and transformations. Just keep in mind that at the beginning of learning C, you're going to be responsible for *lots* of low level housekeeping and management tasks, and building the complexity you're used to yourself. 
hi thanks for the reply but it just stopped working error pops out 
**What** error?
i dont get any error with my compiler i get to enter the number of words and then the original sentence then the sentence to verify and then it just stopped working while normally it has to compare the new sentence to the original one if you know what i mean 
[Found a PDF of C Primer 5th edition](http://faculty.euc.ac.cy/scharalambous/csc131/books/C%20book%201.pdf) Pages:800 Filename:C book 1.pdf Nice. cc u/FOSSilized_Daemon [I struggle with books as well](https://www.reddit.com/r/C_Programming/comments/aukzit/c_youtubers/eh9e431), just thought I'd share. For a channel someone recommended [Handmade Hero](https://www.youtube.com/user/handmadeheroarchive) here a few days ago to me.
hey well first thanks for your answer considering the compiler error i get no error with my compiler but once i run the program i have the choice to choose the number of words then enter the original sentence then enter the new sentence so i can compare it with the original one that should be in the stack &amp;#x200B;
That's about as unhelpful as can be. What is the actual error? Programs don't "just stop working" -- you make a change, and then it stops working. What did you change? Your program should compile, especially if you fix those two problems I pointed out. There's a few other things you should fix: `i` and `j` are never initialized, and you never `free` anything. `fflush(stdin);` is undefined behavior (but that's why you're able to mix `scanf` with `fgets` at all, so oh well).
&gt;code does not compil You can maybe see the source of our confusion? Are you saying now that the program hangs?
If you are looking for a course/youtube to explain to you every function in the C library, you aren't going to find it. That is what the man pages are for. You are going to have to further research the tools used in C to understand how they work.
oops sorry i meant code does not work 
I did try and compiled it and worked but it stops after filling the second sentence or so And the program gets closed I also don’t know why 
&gt; it doesn't spend any time actually explaining them or teaching me how they work. Actually, paragraphs two and three of section 1.5 say everything that's needed up to that point. &gt;"The model of input and output supported by the standard library is very simple. Text input or output, regardless of where it originates or where it goes to, is dealt with as streams of characters, A *text stream* is a sequence of characters divided into lines; each line consists of zero or more characters followed by a newline character." &gt;"It is the responsibility of the library to make each input or output stream conform to this model; the C programmer using the library need not worry about how lines are represented outside the program." &gt;"The standard library provides several functions for reading or writing one character at a time, of which getchar and putchar are the simplest. Each time it is called, getchar reads the next input character from a text stream and returns that as its value. That is, after:" c = getchar() &gt;"the variable c contains the next character of input. The characters normally come from the keyboard; input from files is discussed in Chapter 7." That's it. That's *ALL* you need to know at this point to use `getchar()`. There's literally nothing more to it that you're not being told. Calling `getchar()` returns the next character coming from STDIN. `putchar()` sends whatever character you choose to STDOUT. Don't over think it.
Regarding the memory usage, please see [TROUBLESHOOTING.md#running-out-of-memory](https://github.com/NASA-SW-VnV/ikos/blob/master/TROUBLESHOOTING.md#running-out-of-memory)
hello thanks i actually did what you said i also added i++ and j++ but as you said i guess im in an infinite loop since im trying to compare the sentence that i've just read to the one that is already in the stack so just to translate pile = stack affich = print vrf=verify remplir = fill the table printf("entrez les mots de la phrase originale\\n"); = enter the original sentence words printf("entrez les mots de la phrase a verifier\\n"); = enter the new sentence words &amp;#x200B;
&gt; but crap like getchar and putchar and stuff makes no sense Why not? I gets a *single* character or sends a *single* character. What's so hard about that? &gt;I'm at the point where I can't even open K&amp;R cause I don't know what the hell it's talking about It sounds like you need to rewind and start back at the beginning. There's something you've missed or skipped over.
I don't really know how this can be broken down any easier. You're calling a function `getchar()`, and it returns a single character. Period. That's it. There's nothing hidden, and nothing else to know. That's *all* it does. What you do with that character is your business. You can throw it away, or store it in a variable or an array, or test it for some value. That's all *ANY* programming language offers.
Why turn to a video when you can see the same thing in real time on your computer in the same amount of time it takes to type a URL?
You're probably going through it too quickly. LIke I said before, it's a very terse and very dense book. You have to stop and *think* about everything that written. If you don't, you're going to get lost.
&gt;}while(i&lt;=nb||pile\[top\]!=vrf\[i\]); I think you might want to start with this. That should probably be &amp;&amp;, though it's hard to work out what you're trying to do. I'm not clear why you're using pointers to pointers. Maybe you could start by writing some pseudo-code to show us what you're trying to accomplish?
I really don't understand what you're trying to do in that loop. Why is a stack involved here? Can you provide (a translation of) the assignment? One thing that might help both of us is if you write out that loop again, but with a quick description of what you think each line should do and why you need it to do that.
well technically this is an exercice using stack .. and I tried to do it but since it's Char it got complicated and my friend told me like i can't put a whole sentence in an array so i should do pointer to pointer which is the reason why i used malloc to create the 3 arrays i needed so the assignment is about receiving a sentence or phrase and another sentence or phrase and do a verification which is about checking if it if it's possible to get the second array using a stack
&gt; if it's possible to get the second array using a stack Everything made sense until this line. I have no idea what this means.
I kind of understood Like you put the first thing in original array in the stack ( push ) then you compare with the vrf - the second array and if it’s the same you (pop) and that is by putting what in stack in the last array affich” 
Exactly 
he perfectly explained it right there what is there not to get
Ok, we're having some sort of communication issue here, because I'm still completely lost as to what your goal is. I'm sure some of it stems from language barriers (don't get me wrong -- your English is a thousand times better than my French). But there's a more fundamental problem: I still have no idea what your code is trying to do. All I can tell is that you're trying to compare two sentences in some way. My best guess is that you're trying to see if two sentences are the same. As in, using some naive code: for ( int i = 0; i &lt; NB; i++ ) { if ( strcmp(org[i], vrf[i]) != 0 ) { printf("They're different\n"); return 0; } } printf("They're the same\n"); But ... somehow you're supposed to use a stack to do this comparison? The algorithm you're describing will (if I understand it right) push to the stack all the words that are different. Is that what you're going for?
**The problem:** You're getting stuck in what would end up being an infinite loop after entering both inputs. &amp;#x200B; **The reason:** This is a multi layered problem, I recommend you add some print statements so you can see what you are actually reading and comparing. Your real issues are revolving around `gets(T[k]);`. The first input seems to be skipped which is due to stdin containing a `'\n'` line break from the previous `scanf()` call. I'd recommend replacing both `gets()` and `scanf()` with `fgets()` and parse the number using `strtol()`. &amp;#x200B; **Additional issues:** After you fix your input issues, you still have the seg fault. There are several problems here alone. * Variables `i` and `j` are uninitialized, almost guaranteeing a crash when trying to use them as an array index. * I have no idea why you want to use a third buffer of char pointers, `pile`, but it's added complexity that you really don't need, and is adding a host of uninitialized value errors that cause crashes even after the above fixes. &amp;#x200B; &amp;#x200B; **Recommendations:** * Fix the above issues mentioned, and consider redesigning to remove `pile`. It's useless and you can compare the two buffers without it. * Add print statements for some added debugging * Use valgrind or gdb to step through these issues, otherwise there is no way for them to be reported.
well technically if it's not the same you push again until the same as the second array otherwise you print that it's not possible try another sentence o verify another sentence .. well i guess what you said is legit because here we push the words that are different until it's the same and then you pop and if it's same no need to push because maybe it's the end of the array and you already have words in the stack that if you pop them it will give you the sentence you want to verify 
Get rid of the entire else clause.
&gt; I get no actual output from my project code but it prints out the Hello World from the main.c file generated when you create a new project, *even though there is no reference to that file in my makelists file.* Yes there is, it's right here: set(SOURCE_FILES main.c memory.c cache.c) You can run the debugger by clicking the 'Debug' button on the top right, or Run &gt; Debug
Hey thank you for the full answer i really appreciate all the recommendations and explanation the last problem is im forced to use stack or what im calling « pile » in the program because the exercice requests it 
Here are the best C youtube channels which owners is a true masters of his craft: 1. Sean Barrett - [https://www.youtube.com/user/silverspaceship/featured](https://www.youtube.com/user/silverspaceship/featured) \- 30+ years of experience 2. Bitwise - [https://www.youtube.com/user/pervognsen/featured](https://www.youtube.com/user/pervognsen/featured) \- 20+ years of experience 3. Casey Muratori - [https://www.youtube.com/channel/UCaTznQhurW5AaiYPbhEA-KA](https://www.youtube.com/channel/UCaTznQhurW5AaiYPbhEA-KA) \- 10+ years of experince 4. Jonathan Blow - [https://www.youtube.com/channel/UCCuoqzrsHlwv1YyPKLuMDUQ](https://www.youtube.com/channel/UCCuoqzrsHlwv1YyPKLuMDUQ)
Jerry Cain Stanford University https://youtu.be/Ps8jOj7diA0 Doesn’t get better than this.
I just found this [one](https://the-eye.eu/public/Books/IT%20Various/ADDISON.WESLEY.C.PRIMER.PLUS.6TH.EDITION.2014.pdf) 
I am so glad I turned off automatic downloads in my browser. btw I use Brave
why? does my link contain virus?
No, I'm on my phone and I don't want to download a lot of files to it. I don't have a lot of storage left. I did get an SD card a while back which helps though. The Eye is actually a great archival site. I found them when Nintendo started cracking down on ROM hosting sites again. They DMCA'd 2 sites, and I thought I should start my own personal archive of ROMs I wanted. I didn't act on it until Emuparadise stopped hosting ROMs. They didn't even get a DMCA, they were just tired of the legal battles and wanted to avoid the next one. That's when I decided I needed to act quickly, but that was several months ago, and most ROM hosting sites are still up.
oh sorry I will put a notice 
My link is also a direct download I should do that too.
Emacs with the various modes to make it a full fleged C IDE. 
I've used several toolkits/frameworks for GUI programming across several languages, and Gtk was noticeably more difficult as far a modern full-featured GUI toolkits go. Even setting up the build environment (on Windows) can be a pain in the ass. &amp;#x200B; Sample code is seldom found, even less for videos, although gnome does have a fair amount of [demos](https://developer.gnome.org/gtk3/stable/index.html) to pick through, I often was unable to find examples for specific problems. You could also look at the github pages for Gtk applications like gedit, although that may be a lot to take in. &amp;#x200B; Personally I'd recommend starting off small. Get the demos compiled and running, then start modifying them and learn as you go. Unfortunately you won't find a community as robust as the one Qt has where every question you could possibly ask has been answered 10 times over, but it's certainly doable, and some of the best quality software I have used with unparalleled performance uses Gtk (sublime text).
&gt;Unfortunately you won't find a community as robust as the one Qt has I've noticed. If only based in the oustanding amount of documentation in comparison, Qt seems better. Let alone GTK has some **very strange** design decisions like dropping the system tray icon in Gtk+4 early releases because "notifications do the same". It makes you wonder if the core team behind it knows the difference between a tray icon and a notification. &amp;#x200B;
thenewboston also derek banas
He's the unknown treasure of YouTube.
Im a beginner in C and he is a great resource, wish i found him when i first started. His explanation of pointers and dynamically allocated arrays are perfect for newbies like me
Yeah, that was a bit of a mess. I met with some people and was able to work it out. ``` char bfr[MAXBFR]; char* match; while(fgets(bfr, MAXBFR, stdin) != NULL) { if (strlen(bfr)&gt;MAXBFR) {return -1;} char* line = bfr; char out[MAXBFR]; out[0] = 0; while ((match = strstr(line, regex)) != NULL) { int length = (int) strlen(line) - (int) strlen(match); strncat(out, line, length); strncat(out, string, strlen(string)); line += (length + strlen(regex)); } strncat(out, line, (strlen(line) - (match==NULL ? 0 : strlen(match)))); fputs(out, stdout); } ``` One more question - I'm also supposed to have bounds checking for the input, but because I'm already limiting it with `fgets`, is it possible that `bfr` could be too long?
What's with the weird indentation and also try to keep your code style consistant. Where are the incudes? In you client you have new\_s defined but you don't actaully set it, and I don't see why you need it for the client. Just use: do { memset(buf, '\0', sizeof(buf)); bytesread = recv(s, buf, sizeof(buf)-1, 0); printf("%s", buf); } while (bytesread &gt; 0); 
It was not initialized properly, but that was the least of my problems. Here's the corrected version ``` char out[MAXBFR]; out[0] = 0; ```
Yeah I watched the whole course and did all the exercises as well, you can find my comments under everyone of his videos LoL :P
I guess im just going to have to find them now 😎
&gt; what is the best way to order the turns? It depends. Google "sorting algorithms" to find out why. &gt; Is it customary to sort an array of structs by a struct's property? Yes. &gt; Or is some other design recommended? Not in this case. Other designs are for specific applications. Try using `qsort` first, and then write your own preferred sorting algorithm later if you want.
Definitely use `qsort`, and write a comparitor function that compares the applicable members of the struct. From a game design perspective, be sure to have a consistent way of handling cases in which two structs have the same speed value.
A simple approach would be to build an array of struct pointers which initially point to all your structs in order, and then write a comparison function that will compare the speeds of two objects identified by two pointers. Doing things this way will ensure make it easy to have references to game entities that remain valid between turns. If one were to physically sort the structs within an array, then pointers that identify one game entity on one turn might identify a different entity on a different turn. Not very useful. 
*Oh you sweet summer child*
Another thing to note about `volatile` is that the authors of the Standard trusted compiler writers to recognize what semantic guarantees their customers would need, but some compiler writers take the view that programmers have no right to expect any semantics beyond what the Standard requires. Some programs require the ability to perform memory accesses with mutex-release and/or mutex-acquire semantics (forbidding operations that precede a particular operation from being reordered after it, or forbidding operations that follow a particular operation from being reordered before it, respectively), and when such semantics are needed they may be very conveniently mapped to `volatile` writes and reads, respectively. For example, a common pattern would be something like: // These variables, and the storage identified by output_data may be accessed by // the main-line code only when output_count is zero, and by the ISR only when // output_count is non-zero, except that the main-line or ISR may always test // whether output_count has been set to a zero or non-zero value. extern unsigned char volatile * volatile output_data; extern unsigned volatile output_count; void await_output_completion(void) { while(output_count) idle_spin(); // Spin } void start_output(unsigned char *dat, unsigned count) { await_output_completion(); output_data = dat; output_count = count; } Unfortunately, so far as I can tell, the only way to make such code work reliably in gcc is to disable function inlining. Otherwise, given a function like: void test(void) { unsigned char buff[1]; for (int i=0; i&lt;100; i++) { buff[0] = i; start_output(buff); await_output_completion(); } } I know of now way (other than disabling function inlining) to prevent gcc from "optimizing" it to void test(void) { unsigned char buff[1]; for (int i=0; i&lt;100; i++) { start_output(buff); await_output_completion(); } buff[0] = 99; } since the authors of the Standard expected that people writing implementations for platforms and application fields where such semantics might be needed would be interested in their customers' requirements rather than just those imposed by the Standard.
Bad things happen if "x" is substituted by "overrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrflow". That still looks crazy. length is just match - line, I think. After the loop, match can only be NULL.
What do you mean by "real time use"?
Real life applications !
&gt;Linux kernel object oriented This is very good, thanks!
Thanks for that!
So you want free labor and you posted on the wrong sub. Are you stupid or just plain dumb? 
I really didn't understand the concept of permutation and combination in class so I thought an example might help. 
Ooh a third option appeared! Socially inept! First, the way you worded it made it sound like some creep trying to make a quick buck off of someone else's code. Second, this is the C sub not the C++ sub ergo look elsewhere for C++ advice. Third, if you want programming advice, ask for advice. No one will you give you code that you can copy and paste and possibly steal
Hi there, This is a C subreddit; you might find some useful C++ links in our sidebar, though.
It's going to depend on on whether or not the combat system is wholly separate from any other systems where you are going to need the structs in a different order. If that's the case, you can keep a local array of speed ordered pointers in the combat system, and update that whenever new players and creatures are created or destroyed. (If players and creatures have different structures, you'll probably need to figure out a way to store which kind of pointer it is you are dealing with somewhere, so you make the proper deference when you are looping over the combat list.)
The is amazing. I mean, you're a little insane to do all this, but I like it anyway. XD
My computer did all the work! It was just a couple shell scripts.
 while (1) { struct sockaddr_storage addr; socklen_t addrlen; int new_s; addrlen = sizeof(addr); if ((new_s = accept(s, (struct sockaddr *)&amp;addr, &amp;addrlen)) == -1) errx(4, "Accept failed"); char buf[MAX_LINE]; // here memset(buf, '\0', sizeof(buf)); // here memcpy(buf,ctime(&amp;curtime),sizeof(buf)); // here send(new_s,buf,sizeof(buf),0); // here close(new_s); } That indentation under your if() is very missleading!
This is the best subreddit thanks for sharing the url.
For loops let you control the exact amount of times it will loop no matter what. Do-while loops make sure that your loop executes at least once no matter what. You can do everything with a while loop that the other loops can do if you want but it's good practice to use the the right loop for the circumstance. 
The Buddy Allocator comes to mind. tcmalloc() as well.
Thank you !
Yup, enjoy!
I'm curious if replacing tabs with spaces has significant impact on compilation time.
This paper is more specific to memory fragmentation, but also give you a good overview on algorithms etc.: [https://www.cs.tufts.edu/\~nr/cs257/archive/paul-wilson/fragmentation.pdf](https://www.cs.tufts.edu/~nr/cs257/archive/paul-wilson/fragmentation.pdf) Avery good (academic) starting point.
Because it's often easier to read if you choose the loop accordingly. :)
Well, on the first look I don't see anything wrong. I would start using wireshark to see if the TCP connection is established and if the server sends the data afterwards.
Thank you a lot ! 
Note that `do ... while` is not the same as the others. It always executes at least once, since it checks the condition after each loop instead of before.
Hey oh5nxo, &amp;#x200B; Here is a sample output from the rtl\_433 library when the arduino sends a message: &amp;#x200B; rtl_433 version unknown inputs file rtl_tcp RTL-SDR Trying conf file at "rtl_433.conf"... Trying conf file at "/home/bongo/.rtl_433/rtl_433.conf"... Trying conf file at "/usr/local/etc/rtl_433/rtl_433.conf"... Trying conf file at "/etc/rtl_433/rtl_433.conf"... Registered 96 out of 120 device decoding protocols [ 1-4 8 11-12 15-21 23 25-26 29-36 38-60 62-64 67-71 73-100 102-103 108-116 119 ] Detached kernel driver Found Rafael Micro R820T tuner Exact sample rate is: 250000.000414 Hz [R82XX] PLL not locked! Sample rate set to 250000 S/s. Tuner gain set to Auto. Tuned to 433.720MHz. _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ time : 2019-02-26 09:07:57 model : RadioHead ASK Data len : 33 To : 255 From : 255 Id : 0 Flags : 0 Payload : 123, 94, 43, 152, 82, 103, 117, 85, 235, 91, 255, 162, 13, 70, 133, 22, 198, 198, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 76 Integrity : CRC _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ time : 2019-02-26 09:08:07 model : RadioHead ASK Data len : 33 To : 255 From : 255 Id : 0 Flags : 0 Payload : 25, 156, 137, 187, 103, 139, 36, 213, 31, 191, 40, 240, 58, 249, 44, 136, 198, 198, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 76 Integrity : CRC &amp;#x200B;
It should negligibly speed it up modern hardware using tabs - fewer characters to iterate over
On a compiler who won't optimize it: \- speed &amp;#x200B; On a compiler who'll optimize it: \- readability (- speed in some rare cases) &amp;#x200B; Speed: goto &gt; while() &gt; do ... while() &gt; for()
[https://pastebin.com/6hg4Yz5i](https://pastebin.com/6hg4Yz5i) Just sh it to compile. Read before sh'ing. I intended to stay away from the crypto stuff, but added it anyway as it was available by default, on FreeBSD. I suspect you have it too, raspbian? but probably not set up identically to mine. Test run, I only see garbage. Bug somewhere or I've misunderstood something in the format. $ ./a.out {^+\98RguU\EB[\FF\A2\0DF\85\16\C6 # 1st, before decryption \BD6*\AD\83\082\AE\9C\F5\8B\C4p\8D\F4v # after \19\9C\89\BBg\8B$\D5\1F\BF(\F0:\F9,\88\C6 # 2nd message \94m\14\04\9B\89\DF:\1A\E7Z\0D\F1i\AC\C8 &amp;#x200B;
A lot has moved since then. Check out the jemalloc design documents and the papers on slab allocators. I think I recently saw a paper on reducing internal fragmentation flying around, but I forgot its title.
A `while` and a `do ... while` loop are not actually the same; a `while` loop tests its condition before executing the loop (and thus may not execute the loop at all) and a `do ... while` loop tests its condition after executing the loop (and thus executes the loop at least once). A `for` loop is indeed just for convenience. You can reach the same effect with a `while` loop, but it's just much easier to understand what is meant for counting loops. Incidentally, the spiritual successor of C, Go, does away with all but the `for` loop, using the `for` keyword for four kinds of loops: * infinite loops of the form `for { ... }` * while-loops of the form `for cond { ... }` * proper for-loops of the form `for ...; ...; ... { ... }` and * iterator loops of the form `for ... = range ... { ... }` Pretty nice design if you ask me. There is no equivalent to `do ... while` loops as these are rarely used anyway. 
You might want to avoid the terms `STDIN` and `STDOUT` as they have not been introduced at this point.
calling go the spiritual successor to C is a massive insult to C.
Go was literally designed by the same team that designed C. Ken Thompson, who wrote the original C compiler also wrote the first Go compiler. Go is their vision of what a systems programming language (which is the original purpose of C) should look like in this day and age.
Thanks I will check it ! 
are you tryin to say that while has the highest speed,then comes do...while,then for loop
can you explain me with any sample program.... i would be greatful to you
If your compiler won't optimize anything, then "goto" will be faster than while() &gt; do ... while() &gt; for() (in most cases) &amp;#x200B; If your compiler optimizes well: for (int i = 5; i; i--); should be the same as int i = 5; while (i--) { // nothing } &amp;#x200B;
No. But there are countless sample programs on the internet, so perhaps check out one of those.
No! This is a very wrong misconception. There used to be a difference way back in the 70s, but today's compilers are so smart, they generate optimal code regardless of what loop you use. Do not choose a loop based on thinking one of them is faster than the other.
Actually, `do ... while` loops used to be faster than `while` loops due to them saving one jump each iteration. That said, please don't teach this outdated nonsense to beginners.
No. However, there are many well-written sample programs on this subject on the internet. Check out one of them if you need examples.
Glad to help. 
Oh, well that's even dumber than I thought. Thanks for the info tho.
"how to program in C LIKE it's OOP" Dynamic dispatch is literally OOP, I wouldn't go that far.
Replacing any amount of consecutive whitespace with a single 'whitespace' token (or even treating it as the delimiter of two other tokens, not making a toke for it at all) is the first and most basic thing any tokenizer does. The optimization and rewriting steps are what take most of the time during compilation. Tokenization time is neglegible. 
That's what I wrote... 
No. You only distinguished between optimizing compilers and non-optimizing compilers without giving any differentiated explanation as to what the normal case is. Your comment reads as if there is an actual performance difference and as if it would matter when that's complete bullshit advise for a novice programmer. Also, your “speed hierarchy” is wrong.
Even that is wrong. An optimising compiler throws away the entire loop because it does nothing. A goto typically generates worse code than a loop these days because the compiler is worse at reasoning about it.
Calling the language which is fully defined by the C Standard the spiritual successor to the language the Committee was formed to describe seems like an even bigger insult to the former.
The functions: void fillMem(void *ptr, int size) { while(size--) *ptr++ = 123; } and void fillMem(void *ptr, int size) { do { *ptr++ = 123; } while(--size); } have different semantics. The second will generally be faster in the cases where its semantics would meet requirements, but a compiler would generally have no way of knowing which cases those might be. Some compilers may be much more likely to optimize code with `for` or `while` loops than code using `goto`. It's very easy for a compiler to recognize loop patterns like `for (int i=0; i&lt;len; i++)`, where neither `i` nor `len` ever has its address taken or is disturbed within the loop; from there, it's easy for a compiler to replace an expression of the form `a+b*i` [where `a` may be an integer or a pointer] with a temporary `t1` that is initialized to `a` and increased by `b` with each iteration. If there is another expression `c+b*i` with the same `b`, a compiler can replace that with `t1+(c-a)`. These kinds of optimizations predate the invention of C by more than a decade. The only situation where I can think of where a `goto`-based looping construct might be likely to outperform a `for` would be when the `goto` is used to skip parts of the first iteration that are unnecessary but harmless. On a non-optimizing compiler, skipping the needless parts of the code may improve performance, but on an optimizing compiler, the increased complexity may reduce performance more than the skipped steps improve it.
Good point. 
&gt;fully defined by the C Standard It would need to be a subset of the C standard in order to be fully defined by it, which Go is not. &amp;#x200B; Go was meant to be syntactically similar to C, and an alternative to those that didn't enjoy C++. It has object oriented characteristics and garbage collection. The language is primarily found in the web domain, and it's strong points are in line with that. From a design perspective it really couldn't be a more different tool than C, the leading language for embedded development.
I don't come from a programming background but, one advantage I can see that tabs have over spaces is that a tab character is user defined. If you use 8 space tabs or 4 space tabs, ultimately the character is just the tab escape sequence, interpreted by your editor. If you want 3 space tabs, you just change the tab space and automagically the whole thing changes. Now the real argument is curly brace placement.
Ya, as long as you use tabs for *indentation only* (never for alignment), and use spaces for *alignment only* (never for indentation), then TISA is super-flexible!
1. Because a is already a pointer. If you `printf(%p,a);`, you'd get an address. 2. Because the `[]` dereferences it, you need to use the `&amp;` to get the address. You could replace it all with `a+i` to get the same result.
You don't need a `&amp;` in the first case as it expects a memory address in the scanf and that is exactly what a pointer is. In the second example you are treating `a` as an array, in `&amp;a[i]` you get the i th element in `a` however this returns the value and not the address, thus you need `&amp;` to get the address of the element in the array. You can look at the differences with `printf("%x %x\n", &amp;a[i], a[i]);`
A number of the issues identified by posters on your [last thread](https://www.reddit.com/r/C_Programming/comments/auovvq/code_does_not_compil_trying_to_compare_a_sentence/) are still here.
OOP without dynamic dispatch has no difference with a regular C code.
The issues identified were fixed and the thing about not using stack is out of question because im forced to do that as required in the exercice thanks 
Brackleys
This is a general CS/data structure question, not a C question... If you have a question about a specific C implementation, post the code and ask a specific question, but otherwise, Google is your friend...
Your code doesn't compile. There are mismatched `}` and an undeclared variable `pile`. 
what i mean by 'pile' is stack i changed it
Ok it’s been 30 days, thoughts on the book?
Does your compiler warn you about `i` and `j`? If so, fix the warning. If not, turn the warning level up. Don't mix formatted input (scanf) with unformatted input (gets). If fact, never, ever, use `gets`.
actually it does not warn me about that and thanks for the tip
Alignment is one issue, as mentioend by u/xeow. Another is that multiple users are now seeing different depictions of the code, depending on their tab settings. This makes other spacing rules, like 80-column limits, difficult to detect. Using spaces ensures that everyone is looking at the same identical code, regardless of editor or settings.
Alas, I ordered the book, received a shipping confirmation and delivery date from Amazon, and *then* received another email from the seller saying “sorry, but the book went to somebody else.” 
there is a special place in hell for people who use tabs **and** spaces for indentation. 
Good point! That's part of why I eventually switched to SISA for all my personal code.
This is a great reason to learn and use C, but it's not a great reason to write programs in C. the best way to get good at programming is to want to get better and write as much code as you can. 
Everyone makes mistakes sometimes /s
[Kernel Normal Form](https://man.openbsd.org/style) wishes to have words with you.
FYI, I updated my comment to included Part 2 of the series. 
I'm actually interning for this great new startup called GroverScore. Their goal is to help students across the country achieve their academic and professional goals. Their platform (find it at [https://www.groverscore.com/](https://www.groverscore.com/)) uses analytical tools to analyze your GPA, rank you amongst your peers by class, graduation date, and majors, and help you identify areas to focus on in order to improve your GPA. Ultimately, the founders hope to use GroverScore as a job-recruiting tool as well! Please sign up using the link, and definitely reach out to me with any questions, feedback, and if you'd be interested in joining the team! Good luck! Gabe Greenbaum [gag371@nyu.edu](mailto:gag371@nyu.edu)
For more info about why, `a[i]` is actually defined to be identical to `(*((a)+(i)))`. This actually allows [stupid tricks](https://stackoverflow.com/questions/5073350/accessing-arrays-by-indexarray-in-c-and-c) like `2["abcde"]` evaluating to `'c'` So you've already dereferenced to an int in the second line with the array indexing operator (with the implied `*` in `[]`), and to get back to a pointer-to-int, you need to take the address of that int with `&amp;`
Yeah I think everyone snatched them up, now the price is super high and not worth it at the new price
The authors of the C Standard were called upon to describe a language that was designed for low-level programming, and where many implementations were expected to process many constructs in ways characteristic of the target environment, and whose "spirit"--according to the published charter--included principles like "Don't prevent the programmer from doing what needs to be done". The published Standard itself, however, omits any mention of the Spirit of C described in the Charter, and says nothing about how quality implementations for various kinds of machines should process actions which had been processed 100% consistently by implementations for such machines. If one takes the language described in e.g. K&amp;R 1st and 2nd Editions and strips out everything not mandated by the C Standard, referring to the latter language as C is a major insult to the language which the authors of the Standard were supposed to have described.
In C++, all member functions work by passing the class to the function as a parameter. In essence, if you write this code: class C { void foo() const; }; Under the hood, the compiler is actually making a function that looks roughly like this: void __C__foo(const C* this); And when you call that function: C c; c.foo(); The compiler does this under the hood: C c; __C__foo(&amp;c); Assuming your C code looks like the under-the-hood C++ version, you're probably on the right track. Where function pointers come in is when you implement virtual functions. And yes, that means calling the function in the structure and passing it the contents of the structure itself. Alternatively, you might look into vtables so the function pointers aren't duplicated in every instance, but the effect is the same. Either way, this is necessary so you know *which* function to call. But that function needs access to the specific instance of the "class" -- which might be a polymorphic call, so this is exactly how you're supposed to do things.
Thank you, that makes things much clearer!
So which approach is generally suggested? I know this isn't python but conventions are nice. 
Even though the Standard defines the behavior of `arrayTypeLValue[i]` as equivalent to `*(arrayTypeLValue+i)`, there are some situations where gcc and clang will treat the former as having defined behavior but the latter not. For example, from what I can tell, both will recognize the possibility that `someUnion.array1[i]` might identify the same storage as `someUnion.array2[j]`, but neither will recognize that the equivalent lvalues `*(someUnion.array1+i)` and `*(someUnion.array2+j)` might do likewise.
it's the same as "this" in java or "self" in python.
What are SISA, TITA, and TISA?
Maybe [this](https://lwn.net/Articles/444910/) article also helps
See bullet items in post. They're acronyms I made up. S=Spaces, T=Tabs, I=Indentation, A=Alignment.
I did see the bullet points, I missed the numbering though. That's what confused me.
&gt; I myself use SISA2 for C code LoL what's next? no new line for curly brackets? You wanna become a web dev? Because you're more than half way there already.
I used to use 3, but now I find 2 to be more readable for myself. I don't nest excessively or write long functions, but I do use a font with minimal leading (meaning the lines of text are close together while maintaining readability). I typically view code in an editor window that's 80x100 or 120x100 character cells. I like seeing lots of lines at once.
I would like that too... on a low pixel density screen.
Please indent each line of code by 4 spaces for proper formatting (if you want people to take the time to help you).
 if (pFileStu == NULL) exitError("Error opening file"); return(-1); You're missing something here... if(fgets(str, 6, pFileStu) != NULL) Note: the size passed to `fgets` includes the null terminator. &gt; I don't know how to start reading from the file, then store that particular info into a variable, then continue from where it stopped reading and then store the next bit of information, and etc. I also don't know how to stop reading the record when it reaches "END" and then start the process over again for the next student record in the same file. Make a function that can just read one record from the file. Read each thing one by one. When you get to the class names (I think that's what those are), you'll want to do that part in a loop, which you exit when the input is END. From there, you can call this function in a loop as well.
This subreddit is about programming in C, not about programming in general or theoretical computer science. Please post such questions elsewhere.
Function pointers in structs is a very common pattern in C. You can use this to define a “virtual interface”. This is especially common when working in a big system with lots of “pluggable” components. eg the Linux kernel does this all the time for device drivers. If you want to make your code cleaner so that you don’t call mystruct-&gt;foo(mystruct, ...) all the time, you can always wrap them up in calling functions/macros. eg \#define dofoo(obj,...) obj-&gt;foo(obj,...) For an example of this in action, see: https://github.com/exablaze-oss/exact-capture/blob/master/src/exactio/exactio_stream.h And https://github.com/exablaze-oss/exact-capture/blob/master/src/exactio/exactio.h exactio_stream.h defines exactio_stream_interface_t which has a bunch of function pointers in it. It also has some handy macros for storing private data for each implementation. exactio.h defines some wrapper functions for dealing with structs in a cleaner way. 
Thank you so much for your answer, but how do I only read, for example, the student names "Pop Corn" and "Penny Loafer" or even their emails because the length changes for each one.
Alrighty -- there's a tonne of confusion going on here, mostly due to your use of the term "stack", along with your code being structured in a really confusing (and unintuitive) way -- not to mention your variable names make it nearly impossible to understand immediately what you're trying to do. FYI, most of the time in the context of C, when we talk about "the stack" we're referring to the part of memory that is used for static memory allocation within a function. (as opposed to the heap, which is used for dynamic memory allocation that persists across function calls). Correct me if I'm wrong, but it sound like by "stack" you're talking about the last-in-first-out data structure to hold your words, and that part of the assignment is to implement functionality that adds a word to the stack (aka `push`) and removes a word from the stack (aka `pop`). Is that what you mean? If so, the assignment is a little silly. Anyways... if that's not what you mean, then stop using the term stack. Now, I'm trying to wrap my head around this assignment... From my understanding, the requirements of this assignment is to: 1. Query a user for a sentence, and save the words in the sentence in structure A. 2. Query a user for a second sentence, and the words in the sentence in structure B. 3. Compare each word in structure A to the respective word in structure B. 4. If the word is identical, add the word to structure C 5. Print structure C. Is that the idea? If so, then start the assignment over at the beginning rather than trying to fix what you have here.
You should still use `fgets`. It reads from the file until one of three things happens: the end of the file (doesn't apply here), it reads the specified number of characters (accounting for the terminator), or until the end of the line. So when you need to read the student name, pass in a buffer that's larger than the largest string you expect to read and read through the end of the line. The email is a bit trickier. That line appears to be a comma-separated list of values, one of which is the email. What I would do there is read in the entire line at once (again, using `fgets`) and then parse this string for what you need (possibly using `strtok` or `strtok_r`, but if all you need is the email then just searching for the first and second commas might be enough).
Alright thanks again, this helped me so much!
It's worth pointing out that if you do this in C to write object oriented familiar code, the CPU will predict that the function is always the same and call it nearly as efficiently as a normal C function. When you point to a new function, most CPUs will miss the prediction just for the first time you call the new function. But if you want to program like this, you're better off programming in a subset of C++. In C code, it is confusing to see a bunch of function pointers in a struct that are never assigned a new value. However, you can use glibc to use a form of OO programming in C that is familiar to C programmers.
Nobody has mentioned glibc yet which is the most common library to use objects in C.
same for virtual functions?
The standard way to do this is a [https://en.wikipedia.org/wiki/Virtual_method_table](virtual method table). Typically implemented as a vtable struct inside the class struct. It enables solid inheritance implementations at the expense of two pointer lookups per function call. There are two approaches commonly used to C OOP. The vtable path you are going down and simply prefixing function names with the name of the class. I tend to use the later, falling back on parent function calls can be simulated using a define. This is because I tend not to use many of the more complex OOP features. And yes, you will always end up passing the struct in anyway as a parameter, I suggest standardising on it always being the first parameter. This is the price of not having language level OOP support.
And, don’t cast malloc(). malloc() returns a void *, and you should include the proper header file. Get in the habit of using the standard library functions correctly. Casting malloc() can lead to difficult-to-debug problems. http://www.c-faq.com/malloc/mallocnocast.html
What you're doing is re-inventing object-oriented C. This is how we all used to do it before C++ was invented. I'll give you a concrete example. Many many years ago, I wrote a primitive drawing program called [xdraft](http://xdraft.sourceforge.net/). It used an object-oriented approach. My "base class" was called DrObject, and every DrObject structure had a pointer to a DrObjectClass structure, and the Class structure had pointers to about a dozen functions: redraw(), pickTest(), pickPoint(), snap(), rescale(), delete(), transform(), copy(), write(), and so forth. DrObject structure; note that it contains a pointer to a DrObjectClass structure: struct _DrObject { DrObject *next, *prev ; DrObjectClass *objclass ; char *name ; char *comment ; ObjectType type ; Point bounds[2] ; /* bounding box */ int color; }; DrObjectClass structure; it consists entirely of pointers to functions: struct _DrObjectClass { char *name ; void (*redraw)(DrContext *, DrObject *, GdkDrawable *, DrawCommand, VisMask mask) ; long (*pickTest)(DrContext *, DrObject *, PickCommand, int,int, PickInfo *) ; long (*pickPoint)(DrContext *, DrObject *, int x, int y, Point *out, Point *p0) ; void (*snap)(DrContext *, DrObject *, SnapCommand) ; void (*rescale)(DrContext *, DrObject *, int wid, int hgt, Boolean) ; void (*showpoints)(DrContext *, DrObject *, Boolean) ; void (*objdelete)(DrContext *, DrObject *) ; void (*transform)(DrContext *, DrObject *, Matrix) ; DrObject * (*copy)(DrContext *, DrObject *) ; void (*write)(DrContext *, DrObject *, FILE *, FileFormat, Matrix) ; void (*colors)(DrContext *, DrObject *, Boolean *) ; void (*bounds)(DrContext *, DrObject *, int *, int *, int *, int *) ; }; Every primitive type — points, lines, arcs, compound object, etc. — has a structure of its own, that includes a DrObject DrPoint; the simplest of them all: struct _DrPoint { DrObject o ; PointType type ; /* type: dot, cross, etc. */ }; So, tying it all together, the Point module contains a single static instance of DrObjectClass containing pointers to all of the point-related functions. When a new Point object is created, a DrPoint structure is allocated, filled in with all the information relevant to that object type, and the objclass element is set to a pointer to the Point module's DrObjectClass struct. Then, for instance when the program wants to redraw a primitive, it does exactly what you said above: it calls object-&gt;objclass-&gt;redraw(object, context, canvas, ....);
Yes.
Implement the game using something that *behaves* like an array. E.g. gridSet(0,0,'X'); if(gridGet(1,1)=='O') { blah ... *Implement* those 2 functions using something that isn't an array (9 independent variables, for example, or a bitfield)
Any way i could do this using basic cout and loop statements? 
Thanks for that in depth explanation! It's nice to know the way I was going about it was on the right track xD
How dare you bring *facts* to a *religious* argument.
This is very nearly exactly what the original C++ "compilers" did. In Design and Evolution of C++, Bjarne talks about how the earliest versions of the compilers did the implementation. Unfortunately I can't find a reference to the page in the book and I don't have my copy handy. &amp;#x200B; If you have never read the book, it's really interesting, IMHO!
This is a C subreddit. ask in a C++ subreddit if you have to use C++
That gets a bit more complicated. There will be a name mangled function, but it's not actually your function that gets called at first - instead, it calls a generated intermediate function which then calls a function pointer embedded in the class' data. This function pointer allows deeper layers of class abstraction to get called even from the shallower layers name mangled functions. This is also all possible in C and even used as such in production environments (something like it is done in some parts of the Linux kernel) but takes a ton of annoying boilerplate.
The bottom turtle's name is always C.
An array name is a pointer to the first element in the array. Specifically: `a = &amp;a[0]`when a is an array. You can write either one; they refer to the same location in memory.
I think **a** means the address of the array and **&amp;a** is the pointer of the array, so their value maybe the same but they mean different things. **\*a** is equal to 11 is understandable and **\*(&amp;a)** should be equal to a which is **0x123456**. That's my personal thought and I don't know if it's true, welcome anyone who knows the truth.
If you're looking for a real-world example of a use-case for function pointers in a struct, you can find one in the [Redis source code](https://github.com/antirez/redis/blob/a7780f716ea34899050d3b2b2b9241c09624c0d0/src/dict.h#L58). In this case he's using a struct to define different operations on a hash table (hashing algorithm, value duplication, deletion, etc) typedef struct dictType { uint64_t (*hashFunction)(const void *key); void *(*keyDup)(void *privdata, const void *key); void *(*valDup)(void *privdata, const void *obj); int (*keyCompare)(void *privdata, const void *key1, const void *key2); void (*keyDestructor)(void *privdata, void *key); void (*valDestructor)(void *privdata, void *obj); } dictType; A design like this makes it simple to create a new hash table with any arbitrary data for keys and values and the hash table "plumbing" can be used for both. There are several different hash table types [defined here](https://github.com/antirez/redis/blob/a7780f716ea34899050d3b2b2b9241c09624c0d0/src/server.c#L1243) 
I tried to explain it with comments: &amp;#x200B; Code: #include &lt;stdio.h&gt; #define NEWLINE printf("\n\n\n"); int main(void) { int a[] = {11,12,13}; /* a[0] equals *a */ printf( " a[0] = %i\n*a = %i\n", a[0], *a); NEWLINE; /* the address of a[0] equals the value of a */ printf( "&amp;a[0] = %p\n a = %p\n", &amp;a[0], a); NEWLINE; /* if I point on the address of a, I get the value of a */ printf( " a = %p\n*(&amp;a) = %p\n", a, *(&amp;a)); NEWLINE; /* if I want to have the value of a[0] I can set a pointer * on the value of the address a ( **(&amp;a)) */ printf(" a[0] = %i\n**(&amp;a)= %i\n", a[0], **(&amp;a)); NEWLINE; /* addresses of a[0], a[1], a[2] */ for (int i = 0; i != 3; i++) printf("&amp;a[%i] = %p\n", i, &amp;a[i]); NEWLINE; /* values: a[x] equals *(a + x) */ for (int i = 0; i != 3; i++) printf(" a[%i] = %i\n*(a + %i)= %i\n", i, a[i], i, *(a + i)); NEWLINE; /* now with a void * , because here the compiler won't use the real size * if I just add 1 to it * This is a bit tricky because the compiler knows on a int * that + 1 means * I want to add sizeof(int) to the address, he won't do that if I use a void * */ void *ptr = a; for (int i = 0; i != 3; i++, ptr += sizeof(int)) { printf(" a[%i] = %i\n*((int *) ptr) = %i\n", i, a[i], *((int *) ptr)); NEWLINE; } return 0; } &amp;#x200B; Output: a[0] = 11 *a = 11 &amp;a[0] = 0x7f7ffffbc130 a = 0x7f7ffffbc130 a = 0x7f7ffffbc130 *(&amp;a) = 0x7f7ffffbc130 a[0] = 11 **(&amp;a)= 11 &amp;a[0] = 0x7f7ffffbc130 &amp;a[1] = 0x7f7ffffbc134 &amp;a[2] = 0x7f7ffffbc138 a[0] = 11 *(a + 0)= 11 a[1] = 12 *(a + 1)= 12 a[2] = 13 *(a + 2)= 13 a[0] = 11 *((int *) ptr) = 11 a[1] = 12 *((int *) ptr) = 12 a[2] = 13 *((int *) ptr) = 13 &amp;#x200B;
so bsd FINALLY got something wrong... Everything else they produce is pretty spot on
It's a pointer to the stack. Multi dimensional arrays are stored as 1d arrays with multiple pointers
If you put your base classes in a union then you can have a unified way of getting a pointer to a base class from an object pointer. I do something quite similar to what you describe, see: [http://www.deleveld.dds.nl/inherit.htm](http://www.deleveld.dds.nl/inherit.htm) Your mentioning of offsetof makeines me think that maybe using containerof might be useful in this context. Something to think about...
&amp;a == a just means that the pointer shows on itself, which is the first element in the array at the same time.
Thats exactly what im trying to do 
I put this here because it involves some c code 
Two things: 1. This subreddit is C, not C++ 2. Post your code as formatted text, nobody will debug pictures
1. Wrong subreddit. C != C++ 2. Translate the error message to English. The whole world does not speak your language (French?) 3. Try googling first. You will get your answer much quicker 4. Paste code and error messages as text, not images. You can use Markdown mode and fenced block to retain the source code format
a is an integer array, so &amp;a is a pointer to integer array. Same memory address but different type. &amp; and \* back to back cancel out. You should have gotten a warning from compiler with \*(&amp;a)=%i and \*(&amp;a).
People have to stop using "using namespace std". 
Okay ! Thank you ! 
Okay thanks, so what should I use now ? "std::cout"? 
Array is a sequence of bytes in the memory. a[] stores on stack, it means that variable 'a' contain adress of first byte of this sequence (in your example array is 12 bytes length). 
It's not related to your problem. It's a bad practice. Just think what will happen if you use two libraries which both share a function with the same name. 
The variable a is name of array and means an addres of first array element. But when you using array as operand of &amp;, variable a evaluates to whole array, thats why it returns same value as just a variable. The same behaviour you can see with sizeof, that returns you size of whole array, not size of pointer. It works only with arrays implemented on stack.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
[Ralf Brown's Interrupt List](http://www.ctyme.com/rbrown.htm) might be useful to you.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
did you delete this from the start of your .cpp file #include "stdafx.h"
An array is nothing more than a sequence of objects in memory allocated right after each other. The first object of an array (at offset zero) is located right at the beginning of the array, so indeed `&amp;a == a`.
Oh alright I understand 
Okay thanks ! 
Well I have learned that this is an old form but thanks ! 
i didn't get you
So in main, it is generating a set of 3 contiguous memory locations and, at the time of allocation, because you have the {} syntax, initializing the values from whatever junk data existed there from previous use of the memory to those values. It is best practice to initialize with instantiation wherever possible so good job. As to whether values are contiguous, yes, in this case they would be and generally they are contiguous, especially for small sets of data, but there are exceptions. If you're working with very large sets of data that exceed available resources (often when you have multiple simultaneous programs the OS is toggling between like background processes and your program or just really big data), the OS will use [paging](https://en.wikipedia.org/wiki/Paging) to contain all the data that can't fit in main memory to quickly restore it, and so excess memory will be loaded in and out between storage/RAM and so what is in smaller data sets contiguous becomes non-contiguous at the stitch points. Other ways you can end up with non-contiguous memory (sort of) are through data structures like std::vector. The std::vector object itself exists on the stack, which is a section of main memory/RAM, however, the *data* sis contiguous on the heap, which is a much larger separate area of RAM ([difference stack and heap](http://net-informations.com/faq/net/stack-heap.htm) if you haven't encountered that). The stack is de-allocated with scope, the heap must be explicitly de-allocated, std::vector just also calls the necessary de-allocation via it's destructor. You can end up with unusual fusions of memory with something like std::vector&lt;std::array&lt;params&gt;&gt;, as std::array is allocated statically at compile time and is basically a wrapper for a C style array and all its data still exists on the stack. I don't actually know how std::vector&lt;std::array&gt;&gt; is allocated, the std::array must be known at compile time, but std::vector data, which in this case is std::array, is definitely heap allocated to allow variable/dynamic array sizes. Additional info: [memory addresses are in hexadecimal](https://www.i-programmer.info/babbages-bag/478-hexadecimal.html?start=1), so when you see 0x(numbers) you could convert that into the familiar base 10 which exclusively uses arabic numerals and see a more familiar understanding to show that the memory is truly contiguous. [Reasons why hex is used](https://www.bbc.com/bitesize/guides/zp73wmn/revision/1) (hint: it's because our notation of the internal state of transistors as charge difference/charge equivalent as "1/0" is intrinsically binary, hex is factorable as a power of 2 easily while base 10 isn't. While there are other designs like [ternary](https://en.wikipedia.org/wiki/Ternary_computer) that were explored early on, transistors are so good it's a case of reduction to the simplest available solution. Remember that everything you're seeing on the screen, *everything*, is something that a programmer or even deeper an EE did to help a human understand the inner state of the computer. One of the hardest changes in the mental model I made when learning to program to understanding what's happening was going from "I write this program and it is something that a computer understands" to "this is not a strong representation of what's actually happening". [A computer is the most impossibly complicated flashlight ever built](https://xkcd.com/722/), everything you read on that screen is an abstraction. For example, if you're exploring references and addressing, you're soon to encounter pointer arithmetic if you haven't already. This int a[10]; std::cout &lt;&lt; a[5]; is identical to int *ptr; *ptr = a; std::cout &lt;&lt; *(ptr+5) They're so identical that I can also use these ptr[5]; *(&amp;a[5]); This will become clearer and clearer as you learn more. For me, the 2 examples that really "broke" my mental model of the abstraction of programming languages to "where do things exist on memory, how does the compiler differentiate variables vs pointers, how is the compiler re-interpreting my instructions" was [learning about inlining](https://www.learncpp.com/cpp-tutorial/75-inline-functions/) . It is generally described as something like 'taking code and copy pasting it wherever you invoke the inline function" and this makes it faster because you don't need to allocate on the stack or push/pop (terms that will make sense later if they don't already). However, I can create a local variable x in my inline function when there is already an x in the scope of the calling function, and some how there is no conflict, even though if I copy pasted the exact same code creating a duplicate variable it would fail compilation. Clearly the compiler was reinterpreting x as something, what else was it doing that just doesn't resemble my instructions?
This is bizarre. I always thought pointers and arrays were handled identically but I might be wrong. If `a` were declared with malloc would `&amp;a` still be equal to `a`?
TLDR; you can use C to do just about anything, but it might not be the best tool for everything you can create android apps with C indeed I created a c lib to do some (faster) intersection work in a 3d java application, and there is also the android native interface (basically androids version of java's JNI) for just this, but as to whether you'd want to well that's debatable C like many other languages isn't the one fits all hammer for every problem... I often use C (or sometimes D) if for example I'm doing stuff with 3d and physics (dynamics) as you really need to squeeze every bit of performance out of it that you can, for example using liquid approximation using particles that said if I wanted to have a nice GUI for simple tasks, or experiment with AI on my GPU, I'd more likely throw something together with python... equally if I wanted to add scripting to a C application I'd likely use LUA as the scripting language or possibly javascript If you want a language that's semi portable (with care) and lowish level but you're aware its all too easy to shoot yourself in the foot, and you want a language that doesn't include the kitchen sink in its feature set, then C might just be for you... &amp;#x200B;
Array of 3 ints is 3 ints adjacent to each other in memory. Maybe the rule you are overlooking is that there is implicit conversion from an array to a pointer to its first element in most (but not all) contexts. If you replace the last `a` in the first `printf` line with `&amp;a[0]` maybe it will make more sense. 
No, they are arrays of arrays. Not arrays of pointers.
`&amp;a == a` is a constraint violation (incompatible types for `==` operator)
I do understand the concept of one language does not fit for all, but thank you for then nice answer ! 
There is a difference between type and representation. The question regarding the output of `printf("%p", a)` and `printf("%p", &amp;a)` becomes a little more clear when we look at multi-dimensional arrays. char arr[10][8]; printf("%zd, %zd, %zd\n", sizeof(arr), sizeof(arr[0]), sizeof(arr[0][0])); /* 80, 8, 1 */ Here, `arr` is an array of 10 arrays of 8 chars. The total size is 80. The types of the expressions `arr`, `arr[0]` and `arr[0][0]` are all different. One difference is the meaning of the `+` when you add a constant. However, there are 80 chars in total in the multidimensional array `arr` and even though it consists of different objects they overlap and have a partly shared representation: printf("%p, %p, %p\n", &amp;arr, &amp;arr[0], &amp;arr[0][0]); /* 0x12345, 0x12345, 0x12345 */
C is a systems language, so it's used to create the back bone of systems like Linux and Windows. It's principally used in places where an operating system doesn't exist, so Arduino, and many other kinds of embedded systems operate on C or C++. Apps, for Android are written in Java and iOS uses Swift, but if you want to create a server, a database, or something that runs incredibly fast and reliably like a renderer for animation, or a cruise missile, you'll probably use C. I've been working in C for a long time, and I don't recommend it as a first or even as a second language.
Wow, TIL. I thought array and pointers were practically the same but check this out: ``` #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void main(void) { int * a; a = malloc(3 * sizeof(int)); int b[] = {11, 12, 13}; printf("&amp;a=%p, a=%p\n", &amp;a, a); printf("*a=%i, *(&amp;a)=%i\n", *a, *(&amp;a)); printf("&amp;b=%p, b=%p\n", &amp;b, b); printf("*b=%i, *(&amp;b)=%i\n", *b, *(&amp;b)); } ``` ``` &amp;a=0x7ed6c264, a=0x1a74008 *a=0, *(&amp;a)=27738120 &amp;b=0x7ed6c258, b=0x7ed6c258 *b=11, *(&amp;b)=2128003672 ``` I thought I knew but I had no idea Coding on mobile, sorry for formatting.
Nobody cares about constraint violations.
thnak you, my university teaches it as a first language therefore I nees to learn it
I'm trying to migrate our embedded systems over to c++ as well. LTO, constexpr, and templates blow C out of the water. Unfortunately, the tooling and unit testing isn't 💯 so I end up needing C to temporarily bridge the gap.
No, malloc returns an address and your pointer gets a new value: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int *a; a = malloc(sizeof(int) * 3); for (int i = 0; i != 3; i++) { a[i] = rand(); printf("%i\n", a[i]); } printf("a: %p\t&amp;a: %p\n", a, &amp;a); free(a); return 0; } Output: 848211141 1875439804 1789916543 a: 0x1c24b45b6a70 &amp;a: 0x7f7ffffd74a8
IMHO, understanding the unique nature of arrays and the circumstances of array decay are one of the major topics that separates beginner C programmers from intermediate C programmers. 
“It does not work” is not an error description. If you want help, you need to tell us what you exactly tried and what exactly went wrong, resp. what exact error messages you got.
You might want to take a look at SeaBIOS it not from an actual machine but it is open source. [https://www.seabios.org/Download](https://www.seabios.org/Download)
i was pointing out how &amp;a and &amp;b were handled differently for malloc and array, respectively. i thought it was as easy as heap/stack but all other operations were the same; i was wrong.
Array values decay to pointers (i.e. you can use them like pointers with the value of the start of the array) but they behave differently for a few things (sizeof, the address-of operator). I’m actually not entirely sure why they aren’t just the equivalent of a `T* const` variable — it lets you write a `sizeof` macro to get the length of the array, but the original C spec only has constant size arrays.
Have you tried printing the address of \`0\[a\]\` ? &amp;#x200B; Think about what it might mean, and then print its address... You'll be surprised :)
Array name (identifier) is not a pointer. Address is not a pointer. There are no pointers in this expression. A pointer is a variable that can store an address. On the left side you take an address of object `a`, which is an array, and it's address is the address of the first element. On the right side you have identifier `a`, which is a name of an array, and when used in expression evaluates to the address of the array/address of the first element.
Newbie question: What's the difference? I learned in class that an array[3][3] would take up 9(?) memory addresses in the form of [a0][a1][a2][b0][b1][b2][c0][c1][c2]..., etc. What makes it an array of arrays instead of just one long array with a pointer for each dimension?
&gt; make a copy of your pointer you pass and manipulate it with arithmetic to avoid a dreaded data abort Can you expand on this? It sounds like a bad idea.
I pass a pointer into a function that is a char array. Inside that function I muck around with the pointer to obtain an interesting part of the string I want to compare maybe. Or I chop off the first N number of bytes for some reason. Then when I return if I run into a free() using that same pointer I manipulated there is no tag associated with that character array I was pointing to, the application gets confused because application doesn’t know what to free because the pointer doesn’t have any knowledge of tag data describing what the pointer was pointing to. I could avoid this by never mucking with the pointer in the first place and instead make a copy of the pointer to do the arithmetic I need inside the function so that it goes away when I return. 
It seems VS is correct. You should enable more warnings/errors in Code.Blocks if possible since it apparently didn't detect the problem in the code.
Because although arrays may _decay_ to pointers under certain conditions, they are disparate types. Just like an `int` is different to a `float`.
There are at least two problems with that code. Both are detected by `gcc -Wall`. You should enable more warnings/error in Code.Blocks.
contradiction
It helps if you understand assembly and look at the disassembly. typically what it's doing is a[0] would be doing &amp;a + (0 * sizeof(int)) where int is the data type known to the compiler. a will just be a memory address in an array. if a[] = 0x1000 a[1] is the same as doing: *(0x1000 + (1 * sizeof(*a)))
Actually the code is from a book named 'Programing in ANSI' by E Balagurusamy. So, I am confused if the book is wrong or not.
Incomplete introduction. Not even something you would get in a preface to a book on learning C. Full of side bar ads. 
Your initial description is correct, it takes up 9 adjacent int-sized memory locations. There are no pointers involved 
Two changes are needed to compile it: &gt;char \*name; char \*\*ptr; ptr = \&amp;name; name = "DHAKA"; printf("%s\\n", \*ptr); &amp;#x200B;
Yeah I it this way too. I need to use a pointer to pointer. But I somehow was reding the book and got confused. Tried to compile it and this happened. Thanks for the reply. 
If you declare a function `function (type a[])` everything acts like a pointer. This is hideous and I would never do this...but it works.
 char get_letter(char *s) { s += 3; return *s; } like this? If so, the pointer in the function is separate from the pointer that was passed in - this example only modifies the local copy and the calling function is not affected. Also, what do you mean by "tag data"? I don't believe that's a standard term in C. 
You could check out PVS-Studio, they are one of the best for C code IMO. Also Fortify is not bad. There are plenty of bad things that can happen that these tools won't catch though. Code review and test-driven development are very powerful tools to add to that arsenal.
I think that to better understand the output you can follow these steps: `int a[] = {11,12,13};` `int *b = a; // Just to explicit that 'a' is a 'int *' pointer` `int **c = &amp;a // &amp;a = address of a pointer of type int * -&gt; so it's a int**` &amp;#x200B; int \*\*c int \*b int a\[\] addr: x addr: y addr: 0x123456 value: addr(\*b) value: addr(a) value: 11 &amp;#x200B; so: `*(&amp;a) =&gt; *(c) =&gt; goes to addr(*b) (y to simplify) and get the content =&gt; addr(a) = 0x123456`
That's because `function(type a[])` is exactly equivalent to `function(type *a)`, [according to the language spec](http://port70.net/~nsz/c/c89/c89-draft.html#3.7.1): &gt; A declaration of a parameter as "array of type" shall be adjusted to "pointer to type," A misunderstanding about this language "feature" inspired [one of Linus Torvalds' most well-known rants.](https://lkml.org/lkml/2015/9/3/428. Some programmers even consider it [C's biggest mistake.](https://www.digitalmars.com/articles/b44.html)
If you have any confusion about arrays and pointers in C—which is perfectly normal; most people do, at first—I *highly* recommend reading the C FAQ's [section on arrays and pointers.](http://c-faq.com/aryptr/index.html)
That's how K&amp;R declares functions that take arrays as arguments, and it's how I learned to write C. Regardless of how you do it, arrays in C are second class citizens that are not passed by value at all. It's true that you could just as easily write your function prototype as *function(type *a);* but that's even less intuitive because you can't explicitly see that a is an array, only that it is a pointer to a single value of type *type*. *function(type a[]);* is exactly equivalent to *function(type *a);*. In both cases you would pass [the array name itself](https://old.reddit.com/r/C_Programming/comments/avaa64/what_do_c_arrays_actually_do_under_the_hood/ehdoyc8/) as an argument to *function*.
Not OP, but `free` only knows what memory to release if you give it the exact same pointer value it that `malloc` or one of its friends gave you. In many implementations, `malloc` reserves a little extra space for a "tag" before the region (some metadata that it can read to know how big the region is). Alternately it could keep a global data structure, or possibly both, but they're all keyed off that pointer value. So OPs suggestion seems to be, never manipulate the variable where you store the pointer value from `malloc`, and if you have to manipulate it, do so in a separate variable. Your example would be fine, as long as you don't store the return value into the original variable.
&gt; As most people know, C in ... If the article is an *introduction* to C then the very first sentence shouldn't assume that I know anything about it.
&gt; `int **c = &amp;a;` This is incorrect, and a common misconception. The correct type of pointer is int (*c)[3] = &amp;a;
&gt; always write free() immediately on the next line as malloc() which sometimes is useful. This is ridiculous advice. 
[IKOS](https://www.reddit.com/r/C_Programming/comments/a5a5nc/ikos_21_an_open_source_static_analyzer_for_c_and_c)
There are no extra pointers; C just scales the first index by the row length to index into the 1-D array. In your example, `array[2][1]` would give the item at index `2*3 + 1`. I believe C also lets you say things like `array[0][7]`(at least in some cases), which would give the same result.
Oh great, thanks for the precisation :D but except this misconception, is my explaination correct?
I tried to illustrate freeing a pointer no longer pointing to its original location here. https://pastebin.com/ELn9rwGc And here is what I mean about tag data and keeping track of attributes for pointers “under the hood” that C does for us. https://en.m.wikipedia.org/wiki/Tagged_pointer
a is == to &amp;a\[0\]
Maybe it was interpreted as that’s where free() always lives? I mean to say write down now it before you forget about it later.
This sub is for C programming. Try r/cpp and other cpp subs. 
My bad
I love Linus
Sounds like you could use a good foundation in data structures and algorithms. I'd find a book on the subject and dive in. My recommendation: The Algorithm Design Manual by Skiena. Link: https://www.amazon.com/Algorithm-Design-Manual-Steven-Skiena/dp/1849967202
If you're a beginner, I would focus more on creating correctly functioning code than I would on niche efficiency tweaks. Also, bear in mind that algorithm efficiency comes in multiple forms. There is time efficiency and space/memory efficiency. It is not uncommon for gains in one to come at a cost in the other. General example, to avoid brute force in the past I have had to allocate additional memory to hold tracking information. &amp;nbsp; If you want feedback about this specific problem, post your code and we can have a look. Be sure to use reddit's code formatting (four spaces in front of every line of code typed in a comment or post). If it's really long, use pastebin.
When considering algorithms, start with a naive approach that gets the job done. That'll help you internalize the problem and start to recognize patterns, edge cases, etc. After you've gotten that up-and-running, analyze the big-O cost. (google/youtube it -- it's a really important concept. This will lead you to some type of statement like "well, my outer loop runs n times, and my inner loop runs `n` times, so my big-O is `n^2`. Now let's see if I can apply some type of divide and conquer strategy to either the inner or outer loop to turn one of those `n`'s int a `log(n)`to turn my algorithm into `nlog(n)`" That part likely sounds like gibberish, but I promise it'll make sense once you start to study data structures and algorithms (a.k.a. the subject of nearly every first-round technical interview)
Yes, but what’s interesting is that when declared in the way I’ve done above, `a` is also == to `&amp;a` (assuming you cast them both to void*) But as this post has taught me, that’s because a decays to a pointer that points to the first element of the array, aka `&amp;a[0]` 
This is exactly what I was looking for. Thank you!
From the book, "C Traps and Pitfalls", section 3.6 Counting and asymmetric bounds. "Use _inclusive_ lower bounds and _exclusive_ upper bounds." I.e. When accessing an array, `a`, with `count` elements, and therefore the last element having the index, `maxIndex`, which is one less than `count` . prefer for (size_t i = 0; i &lt; count; ++i) ... over for (size_t i = 0; i &lt;= maxIndex; ++i) ... The book has several pages going into detail on the advantages of (and errors avoided by) consistently indexing this way. The arguments apply to any language using zero-based indexing for arrays. Sadly, this section is _not_ part of the freely available AT&amp;T paper, of the same name, on which the book is based. 
The best advice I received is **Read the Fucking Manual.** I found that the main factor distinguishing bad programmers from good ones is that the good programmers, when faced with a problem, start by reading all available documentation before asking for help. Bad programmers ignore documentation and always complain that they don't understand anything. Don't be a bad programmer. Read the manual!
It's blog spam season again! Please don't post these.
We used Frama C for the formal verification of C programs. It's open source, but not really ready for production use.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
I did, thank you.
If a problem seems insurmountable, solve a concrete sub-problem first. For example, if you can't implement a function that reverses a string, assume that every string has exactly 5 characters. Can you implement that? Now what would you have to change if every string had 7 characters instead of 5? Can you see a pattern emerge and abstract it into a loop that works with strings of arbitrary length?
You could try [scan-build](https://clang-analyzer.llvm.org/scan-build.html).
This example doesn't have the problem you think it does. The \` ++p\_my\_ptr \` in \`trim\_first\_two\_bytes(char\*)\` is only incrementing the local copy of the pointer, NOT the value in \`p\_my\_ptr\` out in the scope of \`my\_func()\`. To actually change the value of \`p\_my\_ptr\` inside \`my\_func()\` you'd have to write a function that takes a \`char\*\*\` and pass it \`&amp;p\_my\_ptr\`.
1 -- this looks like C sharp, so you're in the wrong subreddit &amp;#x200B; 2 -- please take the time to learn how to get a screencap
OK, this post is amazing. You appear to have taken a cell-phone picture of your monitor, containing a C# program that you need help with. * This subreddit is for the C programming language. Try /r/csharp, or /r/CSharpHomework. * If/when you post there, upload the text of your program to something like [GitHub Gists](http://gist.github.com), or [Pastebin](http://www.pastebin.com) instead of posting a picture. With a picture you force people to retype your whole program. Good luck!
Okay thanks dude first time asking for help online I thought its too easy so some could just tell add so something and thats it Thank bro
\#include &lt;stdio.h&gt; int main() { int iFFNum = 5; int fSalary = 0; int fTotalSalary = 0; printf("Give me input: \\n"); for(int i=0; i &lt; iFFNum; ++i) { scanf("%d", &amp;fSalary); fTotalSalary = fTotalSalary + fSalary; } printf("fTotalSalary is equal to %d", fTotalSalary); }
Sorry for being snarky, but you'll have better luck in the C# forums if you upload the text of your program. Another site that's useful for this is [Ideone](https://ideone.com/fSollj) where you can actually execute C# code.
First of all, the parameters of your prototype for evaluate and its definition do not match. Second, you're trying to pass argv, which is of type `char *[]` to a function that is expecting type `char[]` which are different. Make your prototype match the definition and then change evaluate to expect `char *[]`
Make sure to use formatting when posting snippets by making sure each line starts with at least 4 spaces, or using a github gist or pastebin as someone mentioned above. 
I just looked into the book, and now fully intend on reading it - thank you! 
"6 + 2" is not a valid RPN expression. Try "6 2 +".
my bad, meant 6 2 +
Your argv is incorrect in its type. It should be an array of elements having type char /*. With argv I believe that can equivalently be char /*/*argv or char /*argv[]. Also, argv may contain the file path as its 0th element. Your loop tries to evaluate this and could catch a leading '/' and treat it like a division operator. Also, your evaluate function can lead to errors with such input as it has no case to handle things like this and doesn't return a value even though it's expected to. Additionally, isdigit() does not necessarily return 1. Errors even if you get a number. Fixing these I got an output of 8. 
C# is off topic in this subreddit. Please post C# questions to /r/learncsharp instead.
Of all photographs of screens posted here, this is undoubtedly the worst. Post text, not crappy pictures.
C# is off topic in this subreddit. Please post C# questions to /r/learncsharp instead.
This is a even lower point for this sub than any before. This is the crap that has been encouraged by the shitty mod team.
But my evaluate function doesn't really return anything since it's just looping, pushing and popping. 
It's because you're declaring outside the namespace I believe, someone correct me if I'm wrong. Hard to tell what you're doing, but that's the start of the problem. Post the code itself and we could help more.
Sorry typo, I meant eval. 
I mean im returning some form of operation involving left and right. Do you mean when i use exit(1)? 
 for(counter=3;counter&lt;=nthfibonacci;counter++){ . . } 
Honestly I considered that, but in his instructions he requested the use of specifically a while loop.
This is probably the best way. Another way would be to put braces around the code in the `else` block so that it can span multiple lines. if (...) { ... } else if (...) { ... } else { int counter = 3; while (...) { ... } }
since "while" ist specifically requested as it seems, this would be the best approach
Thank you! That did the trick. My Instructor told me that it's incorrect to declare variable statements with just else statements. So I didn't try it. Only else if. Is that normal?
For me, it's often easier (and better helps my comprehension of C) to look at the disassembly (like with gcc [-S](https://gcc.gnu.org/onlinedocs/gcc/Overall-Options.html#Overall-Options)), make a small sample, or step through the sample than to google my question and sift through the possible (possibly out-of-date xor too new xor contradicting/confused) answers or looking through "documentation" for the exact bits I'm wondering about.
No. Look at the flow of possibilities for a given input if something besides 0...9, +, -, /, x is fed to the program. I can run it, with the other corrections, with an input like 6 2 = and there is no error. Evaluate() would determine that it is not a digit and thus call the function eval (2, 6, '='). Eval in turn only checks if a char is in the set { +, -, x, / }. If it does not belong to that set, no alternative action is taken and the function reaches its end without returning a value, despite being a non-void function. I am not 100% sure, but I suspect this is undefined behavior. My machine still assigns a meaningless number that can be pushed onto your stack, and as such the program will complete and spit out a number as if it correctly executed, even though it didn't accurately perform its intended function.
You mean whether it's normal to declare variables inside an else block? It's nothing special at all. It's all about the scope of the variable. Do you only need it inside an else block? Then you can declare it inside. 
No reason why you can’t declare stack variables within else blocks. They’re just like any other block of code. Just don’t expect them to be available after the block ends.
[Mesh](https://github.com/plasma-umass/Mesh) is a new compacting memory allocator for C/C++. It's cool because it avoids relocating data by using pages in a clever way.
What about `T a[]` actually being `T *const a`?
Whixh existing compilers would fit that bill? ComCert? tcc?
 "Adding to this, you can't use else with a condition. Else should be used without condition or else if should be used with condition." &amp;#x200B; Were his words, and I don't quite get what they mean. Doesn't that contradict what we just did?
You can’t have an else with out an if before it. A lonely else doesn’t make any sense. The condition is inside the parentheses after “if”.
What your instructor means is first you can't do this ... else (counter == 3) { ... it's not valid syntax, and additionally don't do this ... } else if (counter = 3) { ... although it's valid C, it's usually not what you meant, is unclear, and can make your program hard to understand. Recognize the difference between `=` and `==`. 
What are you typing? Is that the entire code?
So the object of the program is to take an equation in as a string and then output the results. So for example "1+2" would be something I would like to take in as a string. There is a lot more code, but the snippet is the part that I know if causing the error. There is no code that precedes this in the call.
There's more to it than not being able to assign to the name: char a[64]; char *const b; assert(a == &amp;a); /* pass */ assert(b == &amp;b); /* fail, and a compiler warning */ The `sizeof` operator also has a very different view of `a` and `b`. 
What exactly are you typing? More than 19 characters? Snippets are insufficient to debug. Are you including any header files? Is that literally the 1st few lines of main?
Literally the 1st 3 lines in main. The string I'm testing is 3 characters (not including \n). Full Code here: https://pastebin.com/PGhtbqS7
Alright, what makes those examples you linked in correct is the fact that (counter == 3) and (counter = 3) are not in the curly braces. Correct? 
Forgot your pointer my dude. Need to put &amp; in front of equation on the scanf line, like this ", &amp;equation) 
It's probably crashing at line 33.
I thought the &amp; was not necessary when using Char Array's 
You are correct, no `&amp;` is needed there.
 int main(){ char buffer[20]; printf("Enter a string: "); if(scanf("%s\n", buffer)){ printf("%s\n", buffer); } return 0; } Seems to work just fine for taking a string and printing it if it's valid input. So your problem is likely somewhere else. To do what you want to do is going to require parsing the string to solve the equation which can be trickier than it looks. Good luck!
&gt; What I have so far, I'm mainly confused about how I should temps_tens and temps_hundreds to index masks to get value A common way is to perform modulo-10, then divide by 10 and repeat. This works for an indefinite number of digits. In your case it's fixed, but it's good practice to act like it's not - then it's easily extendable to more digits if required. int tenths = 839; // this represents 83.9 int value = tenths; // make a working copy do { int digit = value % 10; // 'digit' will be 0-9 // ... do something with digit value = value / 10; // shift 'value' by one decimal digit } while (value &gt;= 10); So if you start with value = 839, then first time around the loop 'digit' shall be 9 (being 839 % 10). Then value is divided 839/10 =&gt; 83 (integer division truncates, i.e. rounds down). Then you take that one digit, lookup into the bits array, and write it into your *display* variable. **However,** you've been told to use specific variables for the tens, hundreds, etc. (and it's clear from the instructions that each of these vars is intended to be just a digit, i.e. in the range 0-9 only.) This isn't compatible with this loop strategy. So you've got a couple of options: 1. Unroll the loop. Basically, copy-and-paste its contents three times, and each time replace 'digit' with the appropriate variable: int temp_tenths = value % 10; value = value / 10; // shift int temp_ones = value % 10; value = value / 10; // shift int temp_tens = value % 10; value = value / 10; // shift int temp_hundreds = value % 10; // and the below is purely for thoroughness... if (value &gt; 0) // .. raise an error! temperature is too high for display 2. Or, pick out the individual digits with a one-liner: perform a division to *shift and truncate* the original value, then a *modulo* to get the single digit: // each var here must be within the range 0-9! int temp_tenths = (tenths) % 10; // 839 div-by-1 gives =&gt; 839 modulo-10 gives =&gt; '9' int temp_ones = (tenths / 10) % 10; // 839 div-by-10 gives =&gt; 83 modulo-10 gives =&gt; '3' int temp_tens = (tenths / 100) % 10; // 839 div-by-100 gives =&gt; 8 modulo-10 gives =&gt; '8' int temp_hundreds = (tenths / 1000) % 10; // 839 div-by-1000 gives =&gt; 0 modulo-10 gives =&gt; '0' Or the other way to do this is modulo, *then* divide, although I think this is less clear: // each var here must be within the range 0-9! int temp_tenths = (tenths % 10); // 839 modulo-10 gives =&gt; '9' (no further div required) int temp_ones = (tenths % 100) / 10; // 839 modulo-100 gives =&gt; '39' div-by-10 gives =&gt; '3' int temp_tens = (tenths % 1000) / 100; // 839 modulo-1000 gives =&gt; '839' div-by-100 gives =&gt; '8' int temp_hundreds = (tenths % 10000) / 1000; // 839 modulo-10000 gives =&gt; '839' div-by-1000 gives =&gt; '0' So note that modulo is **not a mask**, i.e. if you want the lowest digit: // module gives us the "remainder" after dividing by the given number: int temp_tenths = (tenths) % 10; // NOT % 9 And any division by 10 (or 100, or 1000) acts like a decimal 'shift'. Hope that clarifies how modulo works. A couple of other points: * I don't follow why "6400" ( = 640.0 degrees) is a special value that you can't exceed. Surely this should be "9999" (being 999.9 degrees). * This is dangerous: *set_display_from_temp(my_temp,00000000000000000000000000000000); * since you inadvertently used an *octal* constant: * "100" is decimal 100 (exactly as you'd expected) * "000100" is octal 100 because of the leading zero, which is actually decimal 64, so very much not what you'd expect. * You've used a 32-index array *display[32]* for your final bits variable: The instructions imply that you should be using a 32-bit *display* variable instead, using masks to set it
Did you gdb it?
Learn to use gdb my man
never heard of it! Thanks, i'll look into it.
Yup!
Np. Its the most quintessential C programmers tool
Why is this username allowed?
Its segfaulting at strcat() &amp;#x200B; Are you trying to copy 1 char at a time from equation to str1 or str2 because strcat doesn't work like that. It copies the entire string until the terminating null byte and overwrites the terminating null byte in the destination with the new string. Also you shouldn't use an array as the source in strcpy &amp;#x200B; I noticed a couple things I want to mention 1. Always initialize your variables before testing them for their value. ex. you test op=='**\\0**' on line but you never set it to '\\0' in the first place so it will contain garbage data at some address where op will store a char for you 2. Don't initialize an array parameter size like (char equation\[20\]), as far as C is concerned your passing the address to the beginning of the array, you need to know how far into that array (location in memory) you can iterate. 3. Line 41 says else if(equation\[i\]=="\_") so your comparing a char at the index i in equation with the string "\_" using == I think you just meant to say '\_' if you want to compare strings make sure the array is null terminated and use strcmp() 4. Line 79 your doing the opposite of number 3 else if(equation == '0') I think you just wanted to check equation\[0\] == '0' ? 5. If you initialize your arrays with null terminating bytes then you don't have to worry about some functions segfaulting &amp;#x200B; &amp;#x200B;
The name of an array is essentially equivalent to &amp;arr\[0\]. The &amp; isnt necessary
I think this is the answer I am looking for. I wasnt sure if you could initialize values with the null value, I just assumed it was default that way. And yes, I am try to add 1 char at a time for the strcat thing. Is there a way to append char to a string? As for the initializing the array parameter size, I thoughts that is what C required you to do. Like it was reserving the amount of space that is required to store the array.
Nope, not really sure what that means.
It's an online debugger that will show you the stack / most likely were youre segfaulting 
Instead of using strcpy, use strncpy. It's pretty much the same thing except you can specify how many characters you want to write. You segfault is most likely being cause by trying to write too big a string into another string. Lines 29 &amp; 33, you're concatenating a string x on to another string y, if you go over the allowed number of chars in x, it'll seg fault. Also since nobody has pointed it out yet, don't use names like str1 or int2. It makes it more tedious for other people to try and figure out what's going on.
I don't know of any implementations for modern microcontrollers like the ARM Cortex-M0 and Cortex-M3 that have really pushed that philosophy, and I am genuinely puzzled as to why. While icc seems to have decent semantics, it also seems rather complicated. While tcc is simple, the quality of code generation leaves much to be desired. Using graph coloring for register allocation of automatic objects whose address is not taken and cached values of common sub-expressions, while invalidating any cached subexpressions whenever anything happens that would have any possibility of disturbing them (e.g. any `volatile`-qualified access) would be low-hanging fruit, as would basic loop induction for loops of the form `for (autoVariable = v1; autoVariable &lt; v2; v1+=v3)` where there's no possibility of `v1`, `v2`, or `v3` changing except via the `v1+=v3`. C as accumulated almost three decades of technical debt since the authors of C89 decided there was no need to officially recognize that implementations intended for purposes like low-level programming should offer stronger behavioral guarantees than would be needed for those intended for high-end number crunching of non-malicious data. They saw no reason that implementations intended for low-level programming shouldn't be perfectly capable of supporting the behavioral guarantees appropriate to such tasks with or without a mandate from the Committee. They also saw no reason to worry about rules that failed to consider whether various corner cases should be defined on some or all implementations, since such things would only matter if an implementation had reason *not* to behave in commonplace fashion, and in such cases people involved with writing programs and compilers for some tasks that might benefit from an unusual behavior would know more than the Committee about the costs and benefits of the common behavior versus alternatives. The authors of the Standard have said that they recognized the usefulness of non-portable programs, and did not wish to preclude use of C as a form of "high-level assembler". Many compilers can offer such semantics when all optimizations are disabled. Unfortunately, even though the Committee has described the Spirit of C as including the principles "Trust the programmer" and "Don't prevent the programmer from doing what needs to be done", the designers of many optimizers fail to recognize that optimizations predictated on the assumption that programmers won't do X are going to be--at best--counter-productive in cases where it's necessary to do X. 
GDB isn't online
I’m not sure if this is directly related but you should add an &amp; to equation as this “&amp;equation”. Refer to the section on pointers for further explanation. Hope this helps!
I addressed it below. Char arrays do not require a pointer to the variable. equation is the same as saying &amp;equation[0] I believe. So that is not my problem, thanks though!
I don't think someone who has just started learning C is ready for a complicated debugger. 
All the stuff around clang is very much worth to consider, scan-build was already mentioned, clang-tidy is also a good on. If you doing an open source project and host it on github, you also get a coverity scan for free. &amp;#x200B; In addition, I strongly recommend writing unit test. Running these unit test under the control of a sanitizer or valgrind will point you to quite something.
Well thé pdf in my book is the paper upon which mesh is built, however, as a new system i did not knew how mesh compared with the older ones.
In my experience there is no shortcut, you start small and you keep at it. When I started programming it was difficult to keep track of a few hundred lines of code. I'm writing a project with hundred of thousands loc nowadays and keeping track of things is a non issue. Over time you'll develop a higher level understanding of concepts like objects and know how they work at the lowest level. After what pretty much everything becomes a simple variation on concepts you understand very well. Looking at the code you referenced I searched for the 'vtable' structure and didn't need to read anything else. So it all comes down to the grind I guess, keep at it and you'll get better. Write, fail and repeat until you succeed. Good luck! 
Check out isdigit().
Thank you for cheering me up! Do you mean I should Google "vtable in C" and then when I learn that it'll suffice for learning how I should to go through that kind of program? Maybe an article like [this](http://cecilsunkure.blogspot.com/2012/08/object-oriented-c-virtual-table-vtable.html) you mean?
Thank you for the through explanation it explained a lot, when it comes to combining the values I did this *display = ((arr[temps_tenths]) |(arr[temps_ones])); *display = *display | (arr[temps_hundreds]) &lt;&lt; 14; *display = *display | (arr[temps_tens]) &lt;&lt; 7; Am I going about it correctly? 
You don't need to use bit twiddling. For each digit, just copy one item from arr\[10\] (should you call it font\[\] instead ?) into display, into successive positions.
Very close to it now. Just pay attention to the details and you should get there. *display = ((arr[temps_tenths]) |(arr[temps_ones])); This will basically overlay both the tenths and the ones into the same position. "839" would end up with 3 and 9 both occupying the lowest position in your display. The "3" (i.e. temp_ones) should be shifted up by 7. The tens ("8") should be shifted up by 14, and the hundreds ("0") needs to be shifted up by 21. Still to do: * For *temp_tens* and *temp_hundreds* you'll need to explicitly test for "0" before *ORing* these digits on: your instructions say to ignore leading zeros. * You'll need to test *is_fahrenheit* to determine whether to set bit 28 or 29
Another thing to think about: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(void) { int buf[arc4random() % 100]; printf("sizeof(buf) = %lu\n", sizeof(buf)); printf("buf is able to contain %lu elements of type int\n", sizeof(buf) / sizeof(int)); char string[arc4random() % 30]; char example[] = "This string is too long for the buffer"; snprintf(string, sizeof(string), "%s", example); printf("%s\n", string); return 0; } 3x Output: sizeof(buf) = 332 buf is able to contain 83 elements of type int Thi sizeof(buf) = 84 buf is able to contain 21 elements of type int This string is to sizeof(buf) = 160 buf is able to contain 40 elements of type int Th I've put arc4random() in there to proof that the compiler doesn't precalculate the value of sizeof(). I thought that could be an interesting sidenote for you :). A simpler pointer would always return 8 on my machine
The syntax of an if/else expression is if (&lt;expr&gt;) &lt;expr&gt; [else &lt;expr&gt;] where `&lt;expr&gt;` is any expression, and `[else &lt;expr&gt;]` is optional. The expression that follows the `else` could very well be another `if` expression. That is where the syntax `else if (...)` comes from.
You could study [GObject](https://developer.gnome.org/gobject/stable/) it is open source and well documented. There is also a [free book](https://www.cs.rit.edu/~ats/books/ooc.pdf) on writing object oriented C.
Ir can be used online or offline
There are two (well, two *sane* ones) general approaches I can think of, provided I understood the problem correctly. The fast one involves either clobbering the argument array, or making another array of the same size (possibly smaller, but worst case is equal size). This would involve making a copy of the array, sorting it (using qsort for example), and then traverising it and every time the number changes, you count how many you've seen, add that amount divided by two to the total, and reset the counter. The less memory-hungry one would be slower, since it requires you to traverse the array multiple times. It gets worse the larger the array is, but no extra memory is needed. Like a lot of algorithms, it's a trade-off between memory and speed. [Examples of the two approaches.](https://tio.run/##jVPbbtswDH22voLtMMAXdWkCrHtws0/Yyx67oHBkuVNqS5nsFNgCf3tGUk5jB8kwwBdKPDykeCh196LU4fDBWFXvSg2PbVca9@nnVzHZqs36fM8b@0J7Qsxm@MA3B63zHe7Cm/atcZYcwtgOlNvZ7nlbGN/GtE5r03YSyGzNH52IvYho4XUHS7jPRSSiynlgsOEt/D0yGK0sS0SEIRxTIXdJEBnSDATIcKLYBIoNUhj8cTwTRKaCmIp52qxguQQ2zYrcwR8d6ec5L9deF69s9iK8IpDcMPCd91LqUP2Q/Z@po4iPkmUhKX2oNdlyOOIMFnlI31Or0LfzlrqXi/4ox/crWuCrmm2snG07eHOmhLSg1p2Wa9ZjIE2DYAkUcHdarDnRmbSL/9FWQl20nd01g1x58KY0Orp8pmCENUVdOxUTAaTM4ypiTxLEN7pR29/xKEJC@F7G/yLkFE4IOcbJoS8Jz95QIhYyinq6X6FzPGNnQzq/MqSk80B4M2UMcu@v6TtJdhy2y7UZqm00NTwXldd6fG463NmsUO1NYWz8rhPT4UTCfi5hIWHODxqfJTz0fOotXv2uim8/lj/srZzc7tDeL9z367DFGNcfDn8B "C (gcc) – Try It Online")
Best advice I received was use whitespace in your code. Early in my career I was doing some C development and my compiler was spewing out a series of errors that I had a hell of a time trying to figure out. I eventually tracked down the error to a line of code like something like this: void foo(int* inval) { int x = 25/*inval; I was horrible about not spacing out my lines of code and the /* was parsed as opening a comment block not a divide by value of inval. The compiler though was generating errors at line numbers way further down the source file after it finally reached a closing comment marker. I kept trying to figure out what the errors were but the line numbers being reported were not where I screwed up. I've since learned to love whitespace.
Thank you so much. Especially that free book sounds amazing. 
BTW, I'm not familiar with ComCert, but I'm curious how its authors handle the fact that the Standard often defines terms in ways that create nonsensical corner cases. For example, given: int arr[10]; void foo(int *p1, int *p2); void test(int *restrict p, int *restrict q) { *p = 1; if (p==arr) foo(p,q); } Function `foo` would be allowed to access the same storage as `*p` if and only if such access is done with a pointer "based upon" `p`. Under the definition given in the Standard, a pointer value `E` is based upon `P` if replacing `P` with a pointer to a copy of the array identified thereby would change `E`. Given the above code, would replacing `p` with a pointer to a copy affect the value of `p1`, `p2`, both, or neither? It would seem absurd to suggest that `p1` isn't based on `p`, but equally absurd to suggest that `p2` is. Does ComCert include a meaningful definition of "based on", or does it ignore `restrict` (something implementations are allowed to do), or what? 
From the [manual](http://compcert.inria.fr/man/manual005.html): &gt; The `restrict` qualifier is accepted but ignored.
On my phone so can't get in to much detail but you need to loop over where you ask for input and check it's one of the values you're expecting. If all is well then break out of the loop, otherwise go round again.
I don't think you need more than one loop. Looking at your code it seems you understand if-else, do-while constructs. Have you learned about the [break keyword](https://en.cppreference.com/w/c/language/break) yet? 
Why not 3 loops? An outer loop that controls the entire game, and an inner loop for each input. If you get the signal to quit, use `return` to end the program.
C# is off topic in this subreddit. Please post C# questions to /r/csharp instead.
Curious, why don't you just use getchar for user input? I would also mention that scanf is dangerous. I get why a beginner needs to learn it but at some point you'll need to use something more safe.
I have definitely had difficulty with placement of curly braces, the syntax has been challenging for me in C. We have learned about the break keyword. We have not covered the continue keyword, but I was messing around with it earlier trying to get it to function in the code. That's actually what I was experimenting with in the section that is commented out in between responses: if (response1 == 'r' || response1 == 's' || response1 == 'p') continue; just terminated the loop. 
what do you mean use return? 
So I actually am using getchar() beneath the scanf's because it wouldn't let me accept both characters (would accept one and terminate the loop assuming the second was the enter key I believe?) 
`return` is a keyword that ends whatever function you are in, (and passes a "return value" back to whatever called the function) Notice on line #2, you have a line that says: int main(void) This is the beginning of your `main` function. The`main` function is what gets called (ie. it's the function that runs) when your program runs. In this case, `main` is a function that returns an `int` (as denoted by the first keyword on that line). Notice on line 51, you have the line: return 0; That is the line of code that causes the function to stop running. It "returns" the value `0`. A main function returning `0` happens to be the convention that indicates that the program exited successfully without any errors. The neat thing is that you can return at any point in your function (ie. it doesn't have to be on the last line of the program) So... you can do something like this: (note: this is pseudo-code, and might not be applicable to your project -- it's just an example to show how `return` works) int main(void) { while(something){ // execute some code if ( the value is a 'q' ) { return 0; } // execute some other code } // finish the game logic return 0; } Notice there are two `return` keywords -- one is inside an if statement in the while loop, and one is at the end of the main function. If the code execution gets to *either* of them, the `main` function will return and your program will end. Does that make sense?
That's true. The scanf gets that char and getchar gets the \n. Nice work there. I could never find an equivalent solution to getch from Windows. Sorry for wasting your time but if you do try Windows you have a solution that gets one keystroke without printing to the screen.
I saw that you had commented that out. Didn't see the `continue`. Hence, I asked. &amp;#x200B; &gt; difficulty with placement of curly braces I would highly recommend putting braces always with any statement. Irrespective of whether there is one statement or multiple. It will help you in the beginning to write readable and understandable code. &amp;#x200B; I will also recommend indentation. Helps with readability. &amp;#x200B; For example, if-elseif-else: if(cond1){ //Statement 1 //Statement 2 } else if(cond2) { //Statement 3 } else { //Statement 4 } //Statement 5 for: for(init; cond; update) { //Statements } //Statements outside for
It might make your code easier to follow if you extract the user input part into its own function. You could do something like this: char getInput(const char *msg, const char *valid) { char resp; do { printf("msg (valid: '%s'): ", valid); scanf(" %c", &amp;resp); } while(!strchr(valid, resp)); return resp; } Then you can call it with the message you want displayed and a string with valid input characters, like this: char input = getInput("Enter move: ", "rpsq"); /* Now handle whichever valid input was entered */ You could modify the function to immediately exit if 'q' is entered, if that's always something you wish to do.
Stack overflow to the rescue! Try this custom conio.h. I added this to your original code (with some other adjustments I'm sure others pointed out 😉) and it works great! https://stackoverflow.com/questions/3276546/how-to-implement-getch-function-of-c-in-linux
A few improvements that I might suggest. Instead of using both `scanf` and `getchar`, just do `scanf(" %c", &amp;variable)`. The space in the format string causes it to consume any whitespace leading up to the character. When you test for a tie, you could simply do `response1 == response2` (as long as you test for invalid input first). For the while loop, I would just do a `while (1)` so that it loops forever, and do the following before testing the win condition to leave the game. if (response1 == 'q' || response2 == 'q') { break; } The way I would do the code overall is infinite loop begin get input 1 test for invalid characters or 'q', break if 'q' get input 2 test for invalid character or 'q', break if 'q' test for tie (if player 1 and player 2 same input) test for player 1 win (your test seems fine) else player 2 win (no test needed since this is the only possibility left) infinite loop end
Hard to see on the phone, i only see one loop. But why not add &amp;&amp; response1 != q &amp;&amp; response2 != q to the while loop?
This subreddit is about programming in C, not programming in general. Please post general programming content to /r/programming instead.
I was looking for ComCert, rather than CompCert. No wonder I couldn't find it. I find it curious that CompCert fully specifies that pointers are inter-convertible with integers of the same size, and specifies the behavior of accessing integers via pointers to objects of smaller types, but does not define the behavior of subdividing pointers nor--so far as I can tell--of using `memcpy` or `memmove` on objects of pointer type or structures containing such objects. It also seems weird to specify that pointers may be arbitrarily indexed to point anywhere, but then specify that relational comparisons between pointers that aren't associated with the same object invoke UB. I could understand that guaranteeing transitive behavior from comparisons between pointers to unrelated objects could be expensive, but there's a huge difference between "yield 0 or 1 in arbitrary fashion" and "jump the rails". It also seems a shame that CompCert doesn't do anything at all useful with "restrict", since the optimizations it allows are among the safest but most valuable low-hanging fruit. If an implementation ignores `restrict` qualifiers on pointers whose value is exposed to the outside world or converted to an integer, whose address is taken, or which are compared to other pointers are not visibly derived from the same root object, the remaining situations should still provide lots of opportunities for provably-safe optimizations that would not otherwise be possible. 
 scanf("%[^'\n ']", &amp;response); This should work perfectly anywhere for scanning a character. For scanning a string you just need to write the same thing but without a space after the '\\n'. &amp;#x200B;
Online is the pre-internet term for interactive software. 
&gt; [~~ComCert~~](https://www.google.com/search?q=comcert+c+compiler) [CompCert](https://www.google.com/search?q=compcert+c+compiler) They formally prove all of their optimizations. Maybe there's some issue with `restrict`. They don't support VLAs either, so maybe they felt that it was similarly unnecessary or potentially subversive. I really don't know.
can i ask how you fixed isdigit()? &amp;#x200B;
This subreddit is about programming in C and is explicitly not about C derivates like Objective C, C++, or even RobotC. Please post this question elsewhere, e.g. on Stack Overflow.
C# is off topic in this subreddit. Please post C# questions to /r/learncsharp instead.
ok, my apologies, thank you
Ah I see what you mean, I tried this and didn't work quite as I wanted, as it would end the entire function, and not print the totals, I think I would have to break it up into two bodies of code each with their own main function? Ended up doing a if(ans == q) break; as a user suggested. 
I had formatted it as player1 == player2 but it got a bit messy getting the second character to evaluate (before using getchar() I had forgot the space before %c. This overall has been super helpful. I modified the code to clean it up and implemented some of your suggestions. How do you recommend testing for input? I tried a few things and my best solution so far is using another while loop inside of it I tried using while (response1 &gt; 's' || response1 &lt; 'o') since the ascii values are all so close this seems to work, but im not sure if there's a better way to validate the input? One issue im having is if multiple things are entered, say pppppppp it will read each of those characters as input from either user. So if player one enters pp, it's a tie, if pppp, two ties etc. Don't think a %1c would fix the issue as it would ignore an invalid response if someone types in 'paper'? Updated here: https://pastebin.com/VGWNAcM0 
Okay bro. Thanks for ur fast answer!
There are certain situations where formally proving correctness of `restrict`-based optimizations would be difficult, but the situations where proving correctness would be easiest are, quite conveniently, also those where the optimizations would offer the most marginal gain. If there is no means by which value of a `restrict`-qualified pointer can "escape" a function, then it will be possible (and quite easy) to identify all of the pointer-type lvalues in that function whose value might ever be based that pointer. BTW, another thing I thought seemed to be missing: any means of forcing an access to an "ordinary" object to be sequenced with regard to an access performed on some `volatile`-qualified object. The Standard would allow the Implementation-Defined semantics of `volatile` to guarantee such behavior, but no way for code to test whether any particular implementation will behave in that fashion. 
Sorry, no idea. Perhaps try whatever community forums there are for RobotC?
\&gt; handle errors too using setjmp / longjmp I worked professionally doing embedded systems C programming for almost 10 years and literally never had to use a setjmp or longjmp. Whatever you think you should be doing with them -- you should probably not be doing that. If you're writing a program that needs to do significant amounts of text processing you should almost certainly NOT be writing it in C. At least not the user input side of it. I wouldn't spend a ton of time on low-level string parsing (unless you're interested in it).
I would recommend not blasting ahead and going straight for larger programs. Take your time and learn it all right the first time around. When I learned C, at first I was impatient and began writing larger scale programs after skipping over a lot of the basics figuring I will just learn them on the fly, but all that gave me was a ton of frustrations as simple things seemed to not work for me. Looking back at some of my early attempts at programming in C is a nightmare, and I'm almost positive that taking my time with the basics (especially with regards to pointers and memory management) would have made learning the language a more painless.
I didn't find an active forum about robotc that's why I thought about posting here as a my last hope 😋 Anyway, thanks for ur help!
just do whatever is most fun. the hard part of learning is staying involved. as long as you stick at it, you eventually cover the ground.
&gt;I worked professionally doing embedded systems C programming for almost 10 years and literally never had to use a setjmp or longjmp. Whatever you think you should be doing with them -- you should probably not be doing that. A few sources online suggest using it an alternative to exceptions - but it feels very goto-y. How do you handle errors as return values in your programs? &gt; If you're writing a program that needs to do significant amounts of text processing you should almost certainly NOT be writing it in C. At least not the user input side of it. I wouldn't spend a ton of time on low-level string parsing (unless you're interested in it). My interest is mostly academic; I have a bit of an inferiority complex for not knowing how these things *really* work. I can't see myself writing much production C code any time soon. &amp;#x200B;
You want `fopen(args[i+1], "w")`. Your compiler should have warned you about this. If it hasn't, make sure to turn on warnings.
Changed it, but it's still the same old story. It defiantly runs in stdout but it just does not save it in r.txt or any other text file that I passes it 
Doing exception style error handling in C is asking for trouble. That type of flow works in languages that manage resources for you or have defined destructors (c++). In C any resources you create, then jump away are leaked, and there’s not really a way to recover from that. In general, error handling in C is done via return error codes. You return errors up the stack until you hit the point that it makes sense to handle it. Another pattern you see a lot (I personally am not a fan, but it’s common) is using goto *at a function level* to make cleaning up resources this method owns easier. Example: error_code foo() { // code that allocates things... error_code e = error_success; if (error case) { e = error_code_oom; goto cleanup; } if (other error case) { e = error_code_no_network; goto cleanup; } cleanup: // code that releases resources return e; } It’s not pretty, but it does mean that whatever is allocated in this function will be de-allocated when it returns.
So why was there no warnings? Do you get any warnings now?
Actually yeah, I get 2 warnings: 1. warning: passing argument 2 of ‘fopen’ makes pointer from integer without a cast [enabled by default] bar = fopen(args[i+1], 'w'); 2. warning: passing argument 2 of ‘dup2’ makes integer from pointer without a cast [enabled by default] dup2(fileno(bar),stdout); I just don't know what they mean
TIL! Thanks for informing me!
The first one means that you passed an integer constant (i.e. `'w'`) instead of a pointer to something (e.g. `"w"` which is a pointer to characters). The wrongly typed argument is implicitly converted and a warning is given. The second warning says that `dup2` expects an integer (i.e. a file descriptor) but you pass a pointer (i.e. `stdout`). What do you need to do to fix this?
isdigit() is not guaranteed to return just 1 or 0. [Documentation](https://linux.die.net/man/3/isdigit)
I got hired at my first "real" development job after 6 months of teaching myself HTML/JS/CSS and PHP. When I started at the job, our first project was supposed to be crossplafform in C. Knowing that I knew nothing of C, he gave me a subscription to Safari and a link to "Learn C the Hard Way" and instructions to teach myself as much as I could in 2 weeks. I got well ahead of the book, researching how to do random things just beyond the scope of what I was reading. Everytime that I gave up in frustration and returned to the text, I learned some key detail that hours of Googling never turned up. Eventually, after about a week of this, I quit racing ahead and just followed the book. That worked out much better. And then a week later he said that the C project was moving to Java so he handed me the Java version in the same series... I never finished either book, ended up writing the Project in Python 3 and R, which I learned on the fly. YMMV, but stick to the text. Its usually presented in a sequence that only makes sense once you have the knowledge to write a simpler version of the same book.
Have you learned the “switch” statement yet? Maybe instead of so many if’s a switch would work.
Hey I just fixed all of these warnings. But still stdout does not create that file! It must be something wrong with the structure of code
They might already be doing some analysis where they infer where a `restrict` could be safely applied. If that's the case, then an explicit `restrict` would be redundant. Either way, they might not want to honor every explicit `restrict` because maybe it would make it too easy to subvert an otherwise very safe compiler. But I'm just guessing.
Please show the corrected code.
C is not an object oriented program and you should not try to shoehorn into it because it will make things worse. Trust me. 
The reason why getting keyboard input in C is the way it is is because your C program doesn't get input from the keyboard, it calls the operating system to do it. The operating system doesn't know what your intentions are for the keyboard input so it takes scancodes from your keyboard, maps them to characters based on your keyboard layout and stores them in a buffer. Then it's up to you with the help of the standard libraries, to take these characters, see if they match what you are expecting, and store them in C variables as you need them. I've found that it is helpful to take things one step at a time. Try matching one thing and print out what you get with different input before moving in to the next step. As for handling errors, you can look at the documentation for the functions in the standard library when you get more comfortable with things. Many functions that perform actions have return values that can be checked. Many functions return special values such as NULL or EOF or a negative number.
What does the output look like? If there's 3 weird characters then it's probably the UTF8 [BOM](https://en.wikipedia.org/wiki/Byte_order_mark)
I think that gdb uses setjmp and longjmp for its back traces, and I only know this because I have had to make sense of them from a backtrace one time (i.e. I was seeing a backtrace of a backtrace), but you really should not be thinking or worrying about this sort of thing. Those are much more advanced concepts for people that are thinking much more about, say, where the program itself is sitting in memory. Mere mortals don't need to worry about that. Probably the best thing that I can think of is to try and emulate in C some of the tasks and features that you have come to expect in JavaScript, e.g. the various JavaScript data structures (Object, Map, etc), working with pointers in a similar way to vars, implement basic string manipulation functions, etc. Of course, none of this will be productive, but might be helpful to understand C better. It might also help you to understand the JavaScript engine.
You might be interested in [*Computer Systems: A Programmer's Perspective*](https://www.pearson.com/us/higher-education/product/Bryant-Computer-Systems-A-Programmer-s-Perspective-3rd-Edition/9780134092669.html?tab=features) by Bryant. It talks about all of those things and will give you a really solid foundation.
Arrays aren't pointers. They decay to pointer when used in expressions except as operand to &amp; operator, sizeof, alignof, etc.. 
Technically undefined behavior so ur code can even spawn satan
There is no `**` operator in C. If you want to take a square root, use `sqrt()` from `math.h`. Make sure to link with `-lm` to gain access to the math library.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
if (pid == 0){ //If zero, then it's the child process for(i =0; i &lt; numTokens; i++){ if (strcmp(args[i],"&gt;") == 0){ bar = fopen(args[i+1], (const char *)'w'); dup2(fileno(bar),1); fclose(bar); } } //Original starts exec_result = execvp(args[0], &amp;args[0]); if(exec_result == -1){ //Error checking printf("Cannot execute %s. An error occured.\n", args[0]); exit(EXIT_FAILURE); } //fclose(stdout); //Original ends fclose(stdout);
Jeez, a single project shifting from C to Java to Python / R, what kinda shop was this???
This subreddit is for C, rather than C++. You should read up on how to format code on reddit. Also your code is a bit long to just include in a post; You should put the code somewhere else, such as pastebin.com, and link to it.
Please put four blanks (spaces) in front of every line of code so the code is formatted correctly. Also, your code is still wrong. You silenced the warning about the wrong argument to `fopen` with a cast but did not understand why it occured. `fopen` expects a pointer to char (i.e. a string) as an argument, but you gave it an int (i.e. a character constant) instead. To fix this, do what I said in my first comment.
I'm teaching myself C by building a larger project. I've found it very helpful to approach each piece as a separate module. I learn new things with each module, each is a bit better than the one before, and because they're isolated components I can go back and rewrite / improve the early ones without the whole project getting infected with my earlier bad ideas. This might not be the best approach for you, but it's working well for me, I find it easier to stay interested with a larger goal, and integrating the different parts helps shake out problems with my designs that I would have missed with a smaller scoped tutorial.
Hello, what you said did the trick. I just wanted to say thank you so much. You were more helpful than my university CS teacher that I pay thousands of dollar and her useless, minion TAs.
As a piece of advice: you should read the documentation of every single function you use before using it in your programs. All of your errors are caused by you having wrong assumptions about what library functions do.
if I have a negative value in the temp and a binary value associated with it -&gt; 0b10000000 which is the last value in the array, how do I access it to input it into my display? All the other are numerical values so I can easily access them but the negative isn't.
Rob Pike has more influence in Go. 
In my quick test, this worked in the sense that msg contained the information from the file I passed to it from the command line. How are you determining that msg is empty -- stepping through code with debugger or do you have additional code that you've omitted here? Are you sure that the contents of both will fit into the array sizes you've defined?
They aren't even equivalent. So comparing their performance is nonsensical. 
Modulo of a negative input gives a negative result, which your array doesn't support. Easiest way is test if the input is negative at the beginning of your program, and if so set a flag, then invert the temperature and treat it as positive. bool isNeg = false; if (temp &lt; 0) { temp = -temp; isNeg = true; } Then at the end of your program, test temp_hundreds, temp_tens (etc.) to find the lowest of these is zero, and that determines how far you shift the "negative sign" array value. Put the negative sign at the last of the array positions: arr[0] = 0bxxxxxxxx; // whatever gives a '0' digit ... arr[9] = 0bxxxxxxxx; // whatever gives a '9' digit arr[10] = 0b10000000; // the negative sign if (isNeg) { if (temp_hundreds == 0 &amp;&amp; temp_tens != 0) display |= (arr[10] &lt;&lt; 21); // shift how far? else if ...etc. }
later in the code I’m calling printf(“%s”, msg); but nothing is printing. Also strlen(msg) is being returned as 0
Then show all the code, not the bit you think is wrong.
On the 2nd time through the outer loop, what does the inner for loop do?
I don’t know, thats the thing. I originally set the inner forloop as “ct” =0, but then I realized that it would print the same thing 20 times since after the first time it completed, “ct” becomes 0 again
ct2 starts as 7, the value it had to end the previous loop. 7 isn't less than 7, so the 2nd loop does nothing. Start ct2 at 0. Use ct and ct2 together to calculate the index to print.
For error handling: return codes, or passing a variable or struct by reference that results and/or errors can be placed into. Not a big fan of `errno`-like solutions or stuffing errors into thread-local storage, but that can potentially work as well. For error handling within functions I’ve occasionally done the `goto` thing the other commenter mentioned — I wouldn’t tend to write new code like that, but occasionally it was either that or refactoring/rewriting a huge amount of existing ugly code. You can implement exception/continuation-like things with setjmp/longjmp, but it gets very ugly very quickly IMO. If you need that and aren’t completely forced to use C, then C++ does that a lot better. I’d be hard pressed to want to do any kind of string processing in C. Again, unless you have really extreme needs things are a lot easier with std::string in C++. And if you don’t need extremely high performance it’s much much easier in a language like Python IMO.
If say fopen("x", "r") == NULL then perror and exit(EXIT_FAILURE)
First off, please don't post images of text. Second, build yourself a quick-and-dirty "hello world" program just to make sure you know how to make the most basic barebones program, compile it, and run it. Next, go through each of the requirements, and build them out one at a time, then test them one at a time. These requirements are super-super-super descriptive and they're basically listed in the order that you need to implement them. The biggest piece of advice I can give you is don't get overwhelmed by the project. Every requirement is laid out very explicitly -- you just need to start breaking it down piece by piece. Here's an example: Requirement #1: "Ask the user for the initial height of a ball in feet." Substeps involved: 1. Printing out the prompt (ie. "please enter height in feet"), 2. Getting input from the user and storing that input 3. Then checking that the input is valid 4. Looping back up to #1 if it isn't valid. Then move onto the next requirement... Part of the assignment is figuring out how to do each of those sub-steps -- whatever course or class you're doing probably has taught you a few basic functions you can use to accomplish these goals.
Break the task down into its constituent parts and attempt to solve them as individual units before assembling them into the whole program. As you run into problems, then come back with what you've attempted (i.e. your code) and the specific issue that you are encountering (e.g. compiler errors, runtime errors, or unexpected output). This is really just re-stating your assignment sheet, but from a programming perspective you have about 5 tasks: * user input functionality. Prompt the user and validate their input according to your assignment. * calculation functionality. function(s) to figure out the values as requested in the assignment. If you wanted, you could make a separate function for each calculation you have to perform, depending on how your choose to mathematically address the questions. * Output/display functionality -- assuming your variables have values, print them (presumably to the standard output) in the form you've been asked to do so. There, you have a 3 to 5 function program that solves your assignment. Work on one at a time. Test it independently to make sure it works, then move to the next one.
freopen() could be useful in the redirection part. exec() et al return only if there was an error, so the latter if is not needed.
One that decided on a language before identifying functional requirements.
 int nums\[\]={68, 62, 51, 73, 12, 18, 65, 33, 68, 84, 81, 34, 30, 18, 60, 66, 36, 29, 75, 53}; int arr\_size; int cols = 7; arr\_size = sizeof(nums) / sizeof(nums\[0\]); printf("size of array is: %d\\n",arr\_size ); for (int i = 1; i &lt;= arr\_size; i++){ printf("%d\\t",nums\[i-1\]); if (i % cols == 0) printf("\\n"); } &amp;#x200B;
&gt; I'm really curious to understand exactly what is going on, and how to do things in a safe, reliable, UB-free fashion, but it's proving quite hard to make headway. It's impossible to write UB-free code even for the experts, so don't bother. Just plough ahead, making a note of what *could*bite you, but don't try to actively work around it at this stage otherwise you'll just get bogged down in the weeds.
What is `cout`?
You're not checking the return value of `contains`, instead you're checking the constant int `1`. You want to do something more like: if (contains(arr, size, l)) { printf("%d is in the given array\n", k); } else { printf("%d is not in the given array\n", k); }
you throw away the return code from the contains()-function. this should be fed to the current if(1){ } 
There was one dude who posted an ascii masturbation animation here once and I feel like that is pretty much the peak of software development. It can only be down hill from here.
This sub is for C, not C++, and `cout` is a C++ thing. So either change this to C (which wouln't take a lot in this instance) or head over to /r/Cplusplus. Also why are you using a `double` for `rows`? You can have half a row, so it makes more sense to use an `int`. As for the problem with the loop, /u/jedwardsol has already pointed you in the right direction for that one.
ohhh got it! thanks !! &amp;#x200B;
Can i also check, "if (contains(arr, size, i))" will check if value is 1 right?
It'll check if the value returned by the function call to `contains` is different from 0. That's because any value different from 0 represents logical true. I'll also point out you have unreachable code inside the function `contains` namely after the `return 1;` statement.
Almost. It'll check if the value is *not* 0. Also looking at your code you have a potential buffer overrun, you need to make sure `size` is always small enough to fit in your array.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
&gt; freopen() could be useful in the redirection part. No it couldn't.
How so? Not changing fd 1 on all systems?
`freopen()` closes the file backing the `FILE` and then opens a new file for it. It is not defined which file descriptor this new file gets. It is not guaranteed to be the same. On UNIX, `open` uses the least unused file descriptor. This could be 0 or 1 in this case depending on whether `stdin` was closed before. However, if some other thread asynchonously opened a file, then this could screw up everything. There's a reason AT&amp;T introduced `dup` and `dup2`.
You are right. 
For an analysis of your code you can use Extrae. Link: https://tools.bsc.es/extrae This will trace your code and generate .prv files which then can be visualized using paraver. Link: https://tools.bsc.es/paraver Using this setup you have toons of configuration files that will helo you to understand better the parallel behaivour of your codes. 
Thanks ! That is exactly what I was looking for !
if(1) is always true. 
This is where malloc would come in handy, right?
Using `restrict` on a function's pointer-type argument gives a compiler explicit permission to make certain transformations on the sequence of operations performed. The fact that a compiler transforms the sequence of operations in the indicated fashion would hardly be "subverting" it. Further, the cases where `restrict` offers the most benefit are those where it is safest. If, for example, a stream library for a free-standing implementation were implementing something similar to `fgetc` as a static inline function: static inline int stream_get(STREAM *stream) { if (stream-&gt;seqPtr &lt; stream-&gt;seqEnd) return *stream-&gt;seqPtr++; else return stream_getMore(stream); } and that were used in an fread-style function: void stream_read_block(STREAM *restrict stream, void *restrict dat, unsigned n) { unsigned char *dt2 = dat; while(n--) *dt2++ = stream_get(); } in the absence of "restrict" a compiler would have to generate code for `stream_read_block` that would allow for the possibility of creative invocations like: unsigned char buff[128]; void evil(void) { STREAM stream; stream.seqPtr = buff; stream.seqEnd = buff+127; buff[0] = '?'; stream_read_block(&amp;stream, buff+1, 100); } which--if processed as defined by the C Standard--would cause the first byte at `buff` to be copied to the second, then the second to the third, etc. Adding `restrict` would allow a compiler to--if so inclined--generate code for `stream_read_block` that optimizes for the common case with something equivalent to: if (stream-&gt;seqEnd &gt; stream-&gt;seqPtr &amp;&amp; (stream-&gt;seqEnd - stream-&gt;seqPtr) &gt;= n) { memcpy(dat, stream-&gt;streamStart, n); stream-&gt;seqPtr += n; } Without `restrict`, a compiler would have to either generate code that re-examines `stream-&gt;seqPtr` and `stream-&gt;seqEnd` on every pass through the loop, or else check whether the range of addresses written by the function overlap with `stream` or the data that would be accessed via `stream-&gt;seqPtr`. The first such choice would be much slower than optimal code (by an order of magnitude or close to it), while the second would require a lot of work to perform in provably-correct fashion. Given `restrict`, however, a compiler examining `stream_read_block` could notice that it can see every pointer that can possibly based on `dat` (there's one other--`dt2`), and that the only access made via either pointer is the `*dt2++`, which it can see is going to happen exactly `n` times, writing `n` bytes starting at the address given in `dat`. When used as intended, `restrict` is an easy way of inviting compilers to perform safe and effective optimizations. A programmer who writes a function like `stream_read_block()` is going to know whether it is intended to support weird ways of using it like those in `evil()`, but a compiler would have no way of knowing that. The things that worry me would be the lack of defined behavior when using `memcpy` or `memmove` on data structures that contain pointers, and the failure to specify that given something like: extern volatile char const * volatile output_ptr; extern volatile int output_len; void start_operation(char const *dat, int len) { output_ptr = dat; output_len = len; } ... char buff[100]; ... memcpy(buff, "Hello", 5); start_operation(buff, 5); the writes to `buff` will not get reordered across the accesses to `output_ptr` and `output_len`. The C Standard for whatever reason has yet to specify a generally-practical means of ensuring such a thing (making `buff` volatile would require replacing `memcpy` or any other function that might be used to write it with a version that accepts a volatile pointer to the destination--not practical as a general approach) even though many kinds of systems programming would be impossible without it. 
Yes it would, and it's slightly newer friend `calloc`.
When you state p=&amp;i you assign the address of the value i to p with the &amp; operator
goto is your friend when it comes to C error handling. For example: https://github.com/tavianator/bfs/blob/4b60aafc1185164cf48a0627bc3b092c6a79b3bc/mtab.c#L99 Make labels that destroy things in the reverse order they're created, and goto the right one when something fails. Return status codes from functions if they can fail, e.g. 0 for success and -1 for failure, and set errno to an error code that describes what happened. This is all you need much of the time, and it's compatible with how the C standard library works. Alternatively, some people these days just return error codes to avoid messing with errno. That's fine too, just be consistent.
Does clang have any option to make it limit the use of the "strict aliasing rule" to determining what types of objects are allowed to *alias*, but recognizes that: 1. An lvalue which is not used in any way within a particular execution of a function, loop, or other such context does not alias anything in that context (but might alias something in a parent context). 2. In contexts where an lvalue or pointer D is freshly and visibly based upon some other lvalue or pointer L, operations on D (or its target) do not "alias" L, but *are* operations on L (or its target). I think the authors of the C89 would have thought such principles sufficiently obvious that they could safely go without saying, though handling of corner cases of what constitutes "freshly and visibly based" would be Quality-of-Implementation issue. Is there any option to make clang apply principle #2 in the obvious cases? Its default behavior is unable to even recognize that given: struct s1 { int x; }; struct s2 { int x; }; union { struct s1 arr1[100]; struct s2 arr2[100]; } u; int i,j; accesses to `(u.arr1+i)-&gt;x` and `(u.arr2+j)-&gt;x` would both be accesses to `u`, and could thus interact with each other when `i` and `j` are equal. 
Ehh, I'm definitely not the right one to ask. I have no idea. You should probably make a new thread.
This is an excellent approach and good advice.
If you edit your code so every line is indended by at least four spaces, it will be formatted much better. 
&gt; I'm a JavaScript programmer who doesn't feel complete not knowing a low-level, unmanaged language C is not a low level language. Of course, its lower level than javascript. [Read this](https://queue.acm.org/detail.cfm?id=3212479). Also you can easily turn it into a managed language with a garbage collection library which provides its own implementation of malloc. &gt; One thing I'm finding quite challenging is balancing my interest in understanding the low-level details with just plowing ahead with the basics. The "basics" of the C language says a lot more than you think. Something as simple as passing an array to a function will teach you a lot about how C treats function parameters. &gt; I'm eager to start actually building some nontrivial programs Go right ahead and build them. When you inevitably encounter "undefined reference to symbol" error and segmentation fault and stack-smashing, you'll learn a lot. Progress quickly but always go back to scrutinize the "details" because the details define the language. [Read the list of undefined behaviors](https://gist.github.com/Earnestly/7c903f481ff9d29a3dd1) when you're pooping. &amp;#x200B;
IIRC, the implementation of stdargs is not part of the standard so what you are doing is not portable.
Looks like it is spesific for the 64 bit calling convention. What are you aiming at?
A common purpose of `setjmp`/`longjmp` is to handle situations where one needs semantics similar to having one process launch another and continue execution afterward whether the latter process terminates normally or abnormally, but where one cannot in fact use multiple processes (e.g. one may be using a freestanding implementation without an OS). Before executing a function that should behave as a sub-process, the main process calls `setjmp`. If something happens that would prevent the secondary process from continuing, that process should call an "early-exit" function which should set some flags to indicate what happened and then call `longjmp`. If code following the `setjmp` gets invoked as a consequence of the `longjmp`, it should do whatever may be necessary to clean up from the partially-executed "second task", after which it may proceed to the next task. An important difference between common `setjmp`/`longjmp` patterns and exceptions is that exceptions are designed to allow for "clean" rollback in case of failure, while `setjmp`/`longjmp` are more often used in situations where it's possibly to blindly blow away all state associated with the second task. For example, if the secondary task will needs to allocate storage but will continue using it until it's finished execution, it could use a heap manager like: union { uint8_t dat[TASK2_HEAP_SIZE]; uint64_t alignment_force; } task2_heap; uint8_t *task2_heap_next; void task2_memory_setup(void) { task2_heap_next = task2_heap.dat; } void *task2_alloc(uint32_t size) { uint8_t *ret = task2_heap_next; size = ((size-1) | 7)+1; // Pad to next multiple of heap size if (size &gt; task2_heap.dat+TASK2_HEAP_SIZE - ret) TASK2_OUT_OF_MEMORY(); // Will call `longjmp` task2_heap_next += size; return ret; } If code calls `task2_memory_setup` before starting each secondary task, and if the second task uses `task2_alloc` for all its allocations, any storage which is allocated by one secondary task will get released when another secondary task starts, *without the system having to know or care about what particular objects had been allocated*. If one were to use exceptions rather than `longjmp`, the system would track allocations in sufficient detail to allow them to be individually released, but if one is simply going to start up a new task using a fresh memory pool, all that extra effort would be wasted. 
I hear what you're saying. I'm just offering possible reasons why `restrict` is not supported. From their [site](http://compcert.inria.fr/compcert-C.html): &gt; CompCert C is a compiler for the C programming language. Its intended use is the compilation of life-critical and mission-critical software written in C and meeting high levels of assurance. It accepts most of the ISO C 99 language, with some exceptions and a few extensions. Here's an [overview] (https://wiki.sei.cmu.edu/confluence/plugins/servlet/mobile?contentId=87152376#content/view/87151927) of the position that various standards and tools for safety critical software take on it. It tends to be unsupported, discouraged, or forbidden. If your intended audience isn't going to use it anyway, then why bother?
I know of no good reason why there shouldn't be a standard function for "get a line of input from the console and put up to N-1 characters into buff followed by a zero byte; reject any input beyond the first N-1 characters". On many non-Unix operating systems, such a function could provide a better UI than using `fgets(buff, N, stdin)` because the keyboard-processing code would know how many characters of input will be processed and could indicate when characters are rejected. For example, it is common for MS-DOS or Windows command-line programs to use an input-line function which won't echo back more characters than are expected. If such a program is expecting to read 8 characters and the user types "hello there", only the "hello th" part will echo, thus indicating that the remaining characters are going to be ignored. Unfortunately, the behavior of `fgets(buff, N, stdin)` is defined in such a way that the keyboard logic would have no way of knowing how much data the program would read from the input line, and thus no way to provide user feedback. 
The authors of the Standard intended UB to be an invitation for compiler writers who wanted to serve their customers to process things in whatever fashion would best accomplish that. Although it also allows compiler writers who are indifferent or hostile to their customers' needs to violate the Spirit of C(*) by preventing programmers from doing what needs to be done, the authors of the Standard didn't think it practical to try to forbid capricious implementations that are "conforming" but useless, and thus make no effort to do so. (*) The Spirit of C is described in the Charter and Rationale documents associated with the Standard. 
The Standard imposes no requirements on the design of a \`va\_list\`, nor does it have any concept of such a thing containing an "offset". A "conforming" C program is allowed to do anything that is acceptable to at least one conforming implementation, so the above would be conforming if there's any implementation where it does what you want. I would not, however, regard any approach that examines the contents of a \`va\_list\` object as "portable". &amp;#x200B;
but I read that even Java is object oriented, so do you mean object systems as a WHOLE are bad or just in C?
I mean... Just start small and work your way up, like anything else. I highly recommend installing OpenBSD in a VM and going through the source. You can start just reading basic command line utilities, modifying and building them, and go deeper from there.
The semantics of `restrict`-qualified pointers that are stored in anything other than automatic objects whose address is not taken are sufficiently nebulous that they're probably not very useful. Restrict-qualified parameters whose address is not taken nor exposed to the outside world, however, have clear and useful semantics. In general, functions that accept multiple pointers to objects cannot be expected to *usefully* handle cases where the same storage is accessed via different pointers unless the author has taken such cases into consideration and documented them. For example, given the following function prototype and description: // If n&gt;0, copy a sequence of n consecutive int values from from *src to *dest. // Else do nothing. void intCopy(int *dest, int *src, int n); If the author of the function isn't deliberately having it behave in a particular fashion when the source and destination overlap, but a caller expects that it will, that would suggest that the calling code is broken *whether or not the parameters are `restrict` qualified*. In cases where it would be useful to have a function guarantee behavior in some cases of overlap but not others, it would be useful to have a `__semi_restrict` qualifier which would allow an implementation to perform reads eagerly and defer writes, but not vice versa. That would allow for situations where an implementation would promise to behave as a "move" if the destination is less than the source, but not promise to behave as a "smear" if the destination is greater. If course, an implementation would be free to process `restrict` in this fashion whether or not the Standard requires it, although reliance upon such behavior should not be considered acceptable in a code review. Some of the MISRA rules are designed to guard against compilers that process code in non-conforming fashion, and the prohibition against `restrict` may be a consequence of some implementations not bothering to recognize that pointers which are derived from `restrict`-qualified parameters are allowed to alias the pointers upon which they are based, or of programmers' failure to understand the behavior of `restrict`-qualified objects other than parameters. 
You make a good point. It makes C a harder programming language for beginners and it has resulted in vulnerabilities like the buffer overflow logging into old versions of UNIX.
For C specifically I'd say it's fairly easy to read. Ususally what you see is what you get. To understand lagre godebases, I like to put printf in strategic locations to trace code and data flow. There are also tools like callgrind that can visualize how code works. If you're hunting strange bugs, the clang sanitizers are your best friends. I'm not sure how familiar you are with C, but the typical beginner pitfalls are pointer arithmetic and array decaying.
See, you have it set to M for mini, when it should be W, for wumbo
Whether you use `&gt;=` or `&gt;` the loop will still print the last number if it is negative - unless the previous number happens to be exactly 0. If you don't want to print negative numbers then you need a check around the printf if(timeUntilGround &gt;= 0) { printf...
gee thanks for that!
&gt; it instead outputs nothing This is incorrect. There is output. [https://onlinegdb.com/By9OGSP8V](https://onlinegdb.com/By9OGSP8V) Try to run and see. However, changing &gt;= to &gt; will not help you remove the negative number. &gt; I need it loop and output up until the last positive number. You try adding an if and break statements. There might be other ways to achieve this as well. But I do not know how much you can change your code.
The math is not correct. You have: time = distance + velocity * time - time squared or time = distance + distance - time squared which makes no sense. What would make sense would be if `timeUntilGround` was actually `currentHeight` and `16` was `(double)gravity / 2` with `gravity` initialized to 32. Even better, declare everything as `double` so you don't need the casts. As for your loop problem, did you remember to initialize `time`?
Good languages should make it easier to do things the right way than the wrong way. I find it sad while it's easy for a programmer to do: #include &lt;stdio.h&gt; int main(void) { char name[256]; printf("What's your name? "); gets(foo); printf("Hello %s!\n", name); } C makes it much more difficult to perform the task safely.
You assume that op remembered to initialize `time`.
I agree. OP hasn't actually given us sufficient information about initializations. 
Yeah, that formula seems completely wrong in terms of the units. 
To understand your questions and thinking better, I had a few questions and suggestions. &amp;#x200B; **generateArrival()** What is the function supposed to do? Why not insert the values into the linked list as you scan them? &amp;#x200B; **Copy from the file into a linkedlist** I can see a mistake here in the way you read. You are reading in a fixed number of characters that may not conform to your format specifier. For example, if your MAX\_LINE\_SIZE is 10 and your actual file says `A,A 1 1 B,B 2 2` then szInputBuffer will contain ***A,A 1 1 B,*** (10 characters) and then parsing with the `"%s %d %d\n"` format specifier may make you miss certain inputs. &amp;#x200B; **EVT\_ARRIVE and EVT\_DEPART** I do not understand what the question here is. Can you please explain what you need help with in this part?
Thank You! To answer your first question and third, it is a function that reads the input from stdin. Another question I have is, this void function, it can be named whatever, but it should get the data from the file. what should I pass it, should it be void generateArrival(Simulation sim) void generateArirval(Event event) void generateArrival() or something else entirely. Basically, get the data from the file, but the kicker here is this, You asked the EVT_ARIVE... and what it does. So in this in program, EVT_ARRIVE &amp; EVT_DEPART are two events, that signify if a individual is arriving or departing. I have to then input that information from the data file into the Simulations eventList (you can find the structure for it above) Now, on to the second question. I have been continuing to try and fix the function, I have gotten this so far while(fgets(szInputBuffer, MAX_LINE_SIZE, pFilePerson) != NULL) { iLineCount++; i++; // if the line is just a line feed, skip it. if (szInputBuffer[0] == '\n') continue; // print the input buffer as is (it also has a linefeed) //printf("Person # %d: %s\n", iLineCount, szInputBuffer); sscanf(szInputBuffer,"%7s %d\n", event.person.szName, &amp;event.person.iDepartTmUnits); printf("%-6s %d\n", event.person.szName, event.person.iDepartTmUnits); } Like you said I think i'm missing certain inputs because it prints the name correctly, but when I try to print the next thing in the file, a number, it just prints 0.
1. Don’t shout 2. There is no pic. (-ture, presumably?) 3. Your code is both unformatted and overformatted at the same time. Indent by four spaces to keep Markdown from having at it, and don’t escape things like asterisks. 4. `do`-`while` is probably not the right loop construct for this. You might not be able to beat a `for(;;)` or `while(1)` loop with a `break` in it. (Or a `goto`. It’s not the best of ideas and you’ll get kvetched at regardless, but if you’ve already seen the label before you `goto` it, it’s no more or less cognitive load than reading from a variable.) 5. If `time` isn’t a `double`, `time = time + 0.1` (and this is C, so it can just be `time += 0.1`) will do exactly nothing. If `time` is a `double` (most stuff in this probably should be), `ballVelocity * time` is already at least a `double`. (There’s basically no reason to cast `ballHeight` either, because the remaining `double` subexpressions will coerce it to `double` if it’s not already.) And it’s probably not a good idea to name something `time`, given the preexisting `time` function. 6. Not an error, but `printf` won’t take any arguments as `float` (any `float` post-format-string will be promoted to `double` automatically), so `%lf` is identical to `%f`. A `scanf` call *would* need the `l` in `%lf` because it takes pointers to things, which don’t auto-promote the same way. 7. If this is related to the prior post that was basically “Here homework, what do?” you shouldn’t need to actually step time in order to solve it. You’re looking for the intersection of a *y* = *f*(*x*)-type equation with *y* = 0 without having to worry about bounces or other sweeps past the *x* axis, so just solve 0 = *f*(*x*) for *x*. No loop required.
Are you sure you end up with 2 nodes at the end? I mean, the code for `free`ing a binary tree is canonical, and your `freeSubtree` looks right to me.
My count method returns 2 nodes left after freeing the subtree.. I should check with valgrind 
Just a guess: you aren't setting your free'd pointers to NULL after freeing the memory. The pointers still have the (now freed) memory addresses in them, and you are likely invoking a count on these pointers, which is undefined behavior. &amp;#x200B; This is a common error for linked data structures, you need to indicate (after freeing) that the pointers you are holding are now invalid.
Ok so I added this and I get what you mean. However the problem is that the signature of the method is void freeSubtree(Node *N); and the method should be called as freeSubtree(root); without any &amp;. This means it will not save my root. What can I do now? 
You are assuming free'd memory is NULL when it isn't.
Datasheets and user manuals are your friends. &gt;This Geiger counter serial communication baud rate is selectable from following value: 1200,2400,4800,9600,14400,19200,28800, 38400,57600,115200. Press S4 key changes baud rate. http://www.gqelectronicsllc.com/GMC-320PlusV5UserGuide.pdf
That is fantastic, thank you so much.
I see.. makes sense but I don't get how to put N on NULL. Because it doesn't save the root outside the scope of the method freeSubtree..
**Part 1** From whatever I understood, I think it is best if you can think of generateArrival() as a function that takes in a list of departure events and adds the arrivals events to the same list. So, when you are scanning departure times from the file, add them into the linked list in the simulation variable's list. Then, you can pass pointer to the Simulation to the generateArrival function. void generateArrival(Simulation *sim); // OR void generateArrival(SimulationImp s); **Part 2** If it was up to me, I would not be scanning everything using sscanf or fgets, I would be scanning character by character if a single line contains multiple names. If one line contains only one event/person, then fgets would be a good way to go about it. Also, using `\n` in the format specifier string may not be a good idea. Run this program [https://onlinegdb.com/BJEExdv8N](https://onlinegdb.com/BJEExdv8N) And then remove the `\n` from scanf and then run the program.
&gt;What can I do now? &amp;#x200B; Manually set root to NULL after calling freeSubtree() on it.
I think is better to parse the file looking for the spaces in a while loop, when get the first space you can copy the string to szName, second space to iDepartTmUnits, and the third space to iTime; 
you have a missed { in your code, before if count &gt;= 3
I'm aware of all formatting problems. I literally have 0 prior experience in coding of any capacity and this is for an introductory course. This being my first and only exposure to the C language so far, I don't have all the knowledge at my disposal. This is the reason I've reached out to forums like this - the guidance of people with much more experience than I tends to be a valuable learning tool. That being said, time was initialized and the formula was correct. It was specified by my instructor and I'm using it in its intended context. But I've now set everything to a double; I rewrote the loop to be a for loop, and included a nested if statement as a check (as suggested by the first comment.) Time = time + 1 is now time += 1. The code is now functioning as intended and looks much cleaner. I appreciate some people's patience. Thank you for the advice. (also, sorry for there being no pic. I attached one but it didn't post with it for some reason.) 
Assuming I wouldn't want all of the prior loops to be printed, just the last attempt; would I just include this if statement after a the loop, keeping the math within the loop? If that makes sense? 
All variables are variables are initialized at 0.
So I showed you how it works in the link. Can you change it and share the link to show me how it doesn't work for you? Thanks! 
I checked all of my brackets and parentheses and they all have a pair.
That brace has its closing match after the next two if statements. They can exist by themselves to establish a scope (e.g. for automatic variables inside the local scope of a function).
Your final if condition isn't being met. I am guessing that strcmp(line, "END ") is not evaluating to 0 because the line actually contains "END \n"). When this happens count is never reset to 0 and then each line is read and subsequently printed by the block at line 191 in your numbering.
You'll need to keep track of the current value and the previous value. So when the value goes negative, the previous value is still around to print. Something like double nextTime = height * velocity ...; if(nextTime &gt; 0) { timeUntilGround = nextTime; time += 0.1; } else { break; }
C is a procedural language, java is an object oriented language. They are just different ways to solve problems, different kinds of them. Like, you don't wanna use java style OOP for realtime high performance stuff. 
Part 1 Thank You, it is a list of events of departure and arrival. I was wondering if it was a pointer or a something competently different. But that does clear things up. Part 2 Well, in this case the input is like this Ant,Adam 10 5 Mander,Sally 4 3 King,May 6 6 King,Joe 9 6 Graph,Otto 2 5 Carr,Redd 1 3 So sscanf and fgets are appropriate and were told to use those functions. And yeah the "\n" I removed it from the line of code. It was junk. Okay So this is where I am at now, I am able to print out the Name using this iScanfCnt = sscanf(szInputBuffer,"%[] %d", person.szName, person.iDepartTmUnits); the only problem is that now i get the full string to be printed and the iDepartTmUnits outputs 0. I attached a counter and the counter is only reading that it went through 1 conversion. How do I get around this? and /u/Medww may be on to something, do you think that is a good way to go about it? 
&gt; parse the file looking for the spaces in a while loop I really hate to ask this, but I understand what you mean, but via code, i haven't the slightest idea how to code that
something else I would like to ask, am i using the correct paramaters in sscanf? like, should it be iScanfCnt = sscanf(szInputBuffer,"%[] %d", person.szName, person.iDepartTmUnits); or something like iScanfCnt = sscanf(szInputBuffer,"%[] %d", event.person.szName, event.person.iDepartTmUnits); and how does this incorporate the use of a linked list? 
You've been super helpful dude, thank you. But what if I were to want the loop to process ballHeight if it were equal to 0. So far the loop only accounts for variables above 0. When testing it with ballHeight = 0, it always displays 0. If 0 were plugged into the equation, it shouldn't, right? 
You've been super helpful dude, thank you. But what if I were to want the loop to process ballHeight if it were equal to 0. So far the loop only accounts for variables above 0. When testing it with ballHeight = 0, it always displays 0. If 0 were plugged into the equation, it shouldn't, right? 
You've been super helpful dude, thank you. But what if I were to want the loop to process ballHeight if it were equal to 0. So far the loop only accounts for variables above 0. When testing it with ballHeight = 0, it always displays 0. If 0 were plugged into the equation, it shouldn't, right? 
When calculating when the ball will hit the ground, if the ball starts at an initial height of 0, I'd start with the ball’s height after 0.1 second, right? Would I just write an if statement before the given code to check? 
Boutique Software for Clients with more money than God. I'm still bound by NDA, but basically, the project was to do real time network analysis, including IDS and deep packet sniffing. My boss was a PhD Candidate in CompSci and Data Analytics, who rented his brain out at a ridiculous price. He literally hired me because he was lonely and wanted to have the opportunity to befriend me, not because he needed me. I spent 6 months working for him, and literally never wrote any production code. The shit he was doing was so far above my head that even 2 years later, I still can't understand the code he wrote. I was his rubber duck, and needed to know just enough to ask dumb questions. It was great fun and a great learning opportunity, but when I got to my next job, I was sorely disappointed in what real development looks like.
It wasn't the shop. It was the Client.
&gt;%\[\] Try %15s
scanf %s cGender ring an alarm bell, c for char ?
Use a **tree then set *tree=null. 
Really not appropriate here, as Arduino, and much of the features that are trying to be used are from C++ not C
You are on a Linux system, it takes care of most of that for you. The /dev/ttyXX device is a serial port, the conversion has been done for you. The tty device presents as a file, you can open and read it like any other. For initial debugging I suggest just using `cat` and `echo &gt;`. The baud rate is set by the device. If you don't know what it is there are a handful of standard values you can try. `stty` is the easiest way to set the baud rate. $ stty -F /dev/ttyUSB0 9600 $ stty -F /dev/ttyUSB0 -a
So far I really like it, but I have got one comment, on line 57, `if(res != BFI_OK){` I may be just stupid, but I can't seem to find where the variable res is assigned to or declared, you might have ment to type ret in there? And also I think the switch-case that is in that if clause could have had a default case, or just a case where res == BFI\_OK, that would make the if clause obselete and make slightly better looking code imo, but that is just my style of writing. overall, I really like it. you could try making a basic python interpreter next!
It isn’t a rite of passage! The defines BFI_OK etc 0,1,2,3 would fit better in an enum. Typo « res ». 
The formula is not correct if the variables are named correctly.
thank you! I must've forgotten to save the file before committing. As for the switch case statement I do see where you I come from. For me I just started writing it like that and just kinda stuck to it. Thank you for the kind words and feed back! a python interpreter does sound interesting, I'll have to take a crack at it at some point!
thanks for the typo notice, it is fixed now :D I always did errors as defines instead of enums and I thought that's how things are usually done. am I wrong on that?
It really depends on who writes the code and for what purpose, but in general if you have more than 2 constant values who serve the same role in the code, whom are in ascending order I would recommend making an enum.
smart! I'll start thinking about doing that instead!
Looks nice! I like overall code structure and clarity :)
Which of C and C++ are you programming in?
\&gt; **I feel like making a Brainfuck interpreter is a rite of passage** Only if you live in the gutter. The only place I ever hear about Brainfuck is reddit. Proves my statement.
I don't think it handles nested loops correctly, i.e. (`[[]]`). You could implement proper loop handling using a stack. Then you would also not have to scan forwards for every loop.
After fFileLoad(, is it necessary to hold on to the FILE? Skipping program\[\] altogether and loading it on the go with getc() and occasional fseek() feels tempting. You could change yourself by writing back to the program file :) Test for memory\[\] index being negative ? Stretching memory\[\] as needed ?
comments are a bit of a controversial subject, but imho you should be commenting where you can't write better code. so if you're writing something and have to stop and think before deciding exactly how the code will be, and are not sure if you'll remember the logic, and can't refactor to make it clearer, add a comment. the flip side of that is don't put comments like "load a file" just before a function called "loadFile" or whatever. it's pointless and you're effectively treating your future self as an idiot. also wtf does "no touchy" mean? if you want to make a distinction between public and private API use a header file (public) v local static inline declarations (private) or, if you need private but shared, some specially named header (private_foo.h or whatever).
Your struct definition is not legal C, so there's no "correct" answer here. That may be why you're seeing inconsistencies. Prior to C11 it's not legal because you're missing a declarator (the field name). Both GCC and Clang still accept it with a warning despite being invalid. struct A { struct B {int b;}; struct C {int c;}; }; C11 introduced anonymous structs and unions which allow you to omit the declarator. However, you're not allowed to supply a tag when you do so. GCC and Clang still accept it as before, but they're not anonymous members since they have a tag name. Anonymous structs/unions were initially a feature of MSVC. In GCC and Clang you can access it prior to C11 with `-fms-extensions`. Mingw-w64 has this feature enabled by default, which is what you're seeing. It seems when you use it, you get MSVC's version of anonymous structs/unions with slightly different behavior than C11. 
Looks nice. Question: Wouldn't it be clearer to separate progIndex and index in 2 different structure ? 
Have you preset the value in \*max beforehand ? ar\[size\] reaches one past the end of array, it's also compared against a pointer, not the value.
they preset the value " max=ar\[0\];" in the main function
I tried what you said in description about "END \\n" and that made it work thanks! Do you know how to Delete the last "END" when the output looks like: pte357 M 1986/01/01 Pete Moss CS pte357@my.uni.edu 3.20 N HIS1043.002 GEO1013.005 MAT1214.003 CS1713.002 agt352 M 1957/02/02 Pop Corn MAT agt352@my.uni.edu 2.8 N MAT3013.001 MAT3233.002 HIS1053.004 geh582 F 1958/03/03 Penny Loafer CS pennyl@xyz.net 3.5 N MAT1214.003 CS1713.002 GEO1013.005 sen233 M 1979/04/04 Adam Sandler ENG hgilmore@xyz.net 2.93 Y ENG1023.002 fse234 F 1989/05/05 Melba Toast BIO butter@xyz.net 2.03 N HIS1043.002 GEO1013.005 MAT1214.003 END &amp;#x200B;
ah okay, i used size-1 instead and it worked. Thank you!
Mostly C++, but I think I’ll need the C posix library.
&gt; The Standard imposes no requirements on the design of a \`va\_list\`, nor does it have any concept of such a thing containing an "offset". Thank you this is exactly what I wanted to know.
I was just taking a quick look at the CS50 videos and I really liked it. It does exactly what I want! Thanks for the recommendation. As someone who also likes to know the whys, CS50 just suits me so well. :)
I see! Thanks! Now it's clearly why the "nested" `struct`s are treated as anonymous ones. &gt; Your struct definition is not legal C In other words: I must not declare "nested" `struct`s in C? Even when compiling with `-std=c11` -- because my declaration is not a correct declaration of an anonymous `struct` (moreover, \`\`anonymous struct'' is not what I need there).
This is legal at least all the way back to the original ANSI C standard: struct A { struct B {int b;} b; struct C {int c;} c; }; /* ... */ { struct A a; struct B b; struct C c; a.b.b = 0; a.c.c = 0; b.b = 0; c.c = 0; } You're simultaneously embedding `struct B` and `struct C` inside `struct A` while also defining these structures. That's all fine. As of C11, you could do this, placing two anonymous structures inside `struct A` *without tags*: struct A { struct {int b;}; struct {int c;}; }; /* ... */ { struct A a; a.b = 0; a.c = 0; } The structures themselves don't have member names, which is what makes them anonymous. I can access `b` and `c` as if there were directly on the top-level struct. This is more useful with unions than structures: /* C11 and later */ struct value { enum {TYPE_INT, TYPE_FLOAT} type; union { int i; float f; }; }; /* ... */ { struct value value; value.type = TYPE_INT; value.i = 0; value.type = TYPE_FLOAT; value.f = 0.0f; } Prior to C11 you had to give the union a name and access had to go through that name, which isn't as elegant: /* Any C standard */ struct value { enum {TYPE_INT, TYPE_FLOAT} type; union { int i; float f; } data; }; /* ... */ { struct value value; value.type = TYPE_INT; value.data.i = 0; value.type = TYPE_FLOAT; value.data.f = 0.0f; } But notice I didn't use a tag name for the anonymous member. When you do, GCC and Clang treat it as a definition that just so happens to be defined inside another structure, and the effect is actually this: struct B {int b;}; struct C {int c;}; struct A {}; And so `struct A` is empty. 
sorry I'm confused as to what you mean, could you elaborate?
The semantics associated with anonymous structs/unions were available in the language described by the 1974 C Reference Manual, which lacked union types but essentially treated every structure type as an anonymous union of all structs that were the same size or smaller. The division of struct members into separate namespaces was a mostly-useful feature, but the inability to have overlapping members without adding an extra layer to the access syntax was a misstep. Personally, what I would have liked to have seen would have been to say that if the word `extern` follows the keyword `struct`, then all members of the struct would be exported to the enclosing context, so that given something like: struct POINT { int x,y,z; }; struct S1 { struct extern POINT position; int q,r,s; } foo; the compiler would behave as though `foo` had members `foo.x`, `foo.y`, and `foo.z`, but code could pass the address of `foo.position` to a function expecting a `struct POINT` and have it operate on all of them. Note that if one were to attempt to use: struct POINT { int x,y,z; }; struct S1 { union { struct POINT position; struct { struct {int x,y,z;}; struct q,r,s; }; }; } foo; the first struct within the second union item would not be compatible with `position` because it lacks a tag. BTW, exporting struct members to file scope would be a useful means of forcing layout for objects that client code will expect to use as file-scope objects. Many ARM processors will be able to process something like: extern struct FOO { int x, int y; } foo; void test(void) { foo.x += foo.y; } more efficiently than they would be able to process: extern int x,y; void test(void) { x += y; } because the former would be processed into: void test(void) { register struct FOO *__p_foo = &amp;foo; __p_foo-&gt;x += __p_foo-&gt;y; } while the latter would need to be processed into: void test(void) { register struct FOO *__p_x = &amp;x; register struct FOO *__p_y = &amp;y; *__p_x += *__p-&gt;y; } but if there's no *semantic* reason for `x` and `y` to be in the same structure, such grouping shouldn't be baked into client code. Being able to declare a structure type and then export the symbols to the enclosing scope would allow the performance benefits without adding semantic burden. 
Thanks a lot, once again! You've completely clarified behavior of compilers now :-) Thanks!
In addition to what’s been said, the GCC docs state that G++ will treat an empty struct as having a single anonymous `char` member—presumably as long as the struct isn’t inside some other struct—which could be what you’re seeing. Microsoft stuff *might* treat the `struct`s as ~superclasses, since in GNU you can do struct A {…}; struct B {struct A; char b;}; which causes `B` to ~inherit everything from `A`. Not sure if that would vary per-compiler/-mode as well. And more fundamentally, Windows has a different ABI than Linux (especially for x64/x86_64) so the rules constraining what it can do would be different there.
You could just have an variable representing the angle and use something like floats or doubles for their position so you could have an ball "between the pixels" (subpixels), that you then round when rendering. (so if x=5.8, then you could render the ball at x=6)
If you want to step up your game, compile it to a byte code rather than interpret the raw text. Brainfuck was originally designed the way it was because it could be compiled so trivially. Compiling has some interesting benefits: * You can resolve all your loops ahead of time into actual jumps. The program will run faster, and you validate all the loops for correctness before you execute the code. * Your bytecode can be richer than Brainfuck instructions. For example, instead of move left/right by one (`&lt;`, `&gt;`), your instruction can have operands that allow moving multiple steps at at time. You compiler would condense a series of Brainfuck instructions into a single bytecode: `++++++++++` becomes, say, `incr 10`. The bytecode you actually execute will be both smaller and faster. You can take this even further, adding more complex instructions to your bytecode and implementing a peephole optimizer to convert common groups of Brainfuck instructions into a single higher-level bytecode. For example: `[-]` could become `clear`. 
Good idea, but I think this would make the ball look bumpy while traveling.
Yes. Also you can but an extra line between your assignments and the for loop to distinguish the functional 'blocks' of code. 
Most books and style guides I have read would encourage (or in the case of some style guides, mandate) the latter style. "One assignment per line" in particular is a common guideline. This is particularly the case for declarations, e.g.: int x = 5; int y = 3; int z = 0; not: int x = 5, y = 3, z = 0; The most frequently given rationale I have seen for this is that if you're scanning the code visually, looking for the declaration for e.g. 'z', it's too easy to miss it when it's so far from the left, and the variable type. int x = y = z = 0; // set all to 0 seems to get marginally less hate however. 
Interactive input should generally be processed by reading in a line of input at a time, discarding any characters beyond what there's room for, and then parsing that line as needed. For whatever reason, the Standard includes a function (`gets`) would be convenient to use if the operator can be trusted not to type too much input, but which is impossible to use safely, but nothing that's anywhere near as convenient that can be used safely. Probably the simplest way around this limitation is to write your own function. I think something like: int get_string(char *dest, int buffsize) { int length = 0; if (buffsize &lt;= 0) return -1; do { int ch = getchar(); if (ch &lt; 0 || ch == '\n' return length; if (length &lt; buffsize-1) { dest[length++] = ch; dest[length] = 0; } } while(1); // Until return } should work nicely (untested). You could then invoke it like: char name[32]; int length; length = get_string(name, 32); // Read up to 31 characters printf("Hello %s! Your name has length %d.", name, length); Note that while it would be possible to read a line of input via `fgets(name, length, 32);`, that would require doing additional work to find the length of the input, and either strip out an unwanted newline character if the user typed 30 characters or fewer, or skip any characters past the 31st if the user typed more. 
The design of `strncat` seems rather silly. It generally either presupposes that you don't know the length of the string to which you're appending, but you nonetheless know how exactly many characters will fit after it, or else that your're using a fixed-size zero-padded source buffer but a zero-terminated destination. While there might be some usage cases for it, they would generally seem even more obscure than those for `strncpy`.
You're probably better off using something like SDL.
Without seeing exactly how you implemented the changes, I can only guess. What is possible is that your conditional doesn't exactly match the end case for the text at the very end of the file and so an additional loop through the while block is executed. This should be very easy to debug using your debugger. Just step through and examine the values at the end of the final loop and see what happens after what you expect to be the last pass through. IF this is happening in your while loop, somewhere the value of a variable does not match with the literal chars you expect it to.
C++ is off topic in this subreddit. Using the POSIX API is not enough to make this on topic sadly.
If you're using a typical 80x24 terminal, I'd suggest using both `,` and `'` to draw the ball, based on a half-line position, or maybe using either `;;` on one line sometimes and `..` on one line and `''` on the line below, again based on half-line position. If you can manage decent timing accuracy, you can smooth out the diagonals by making the timing of when the ball moves vertically independent of the timing of when it moves horizontally. This won't yield perfectly smooth motion, but you may be able to do things as well as would be possible on an 80x25 terminal. I'd guess that modern flavors of Unix would allow a program to operate with timing that's much smoother than the one-second-based `sleep` of older flavors, but I don't know how to achieve such timings nicely. 
Thanks for the pooping reading suggestion. I got a chuckle out of your phrasing. Now if you'll excuse me, I'm off to read about undefined behaviors.
What are you expecting from text?
You could look into using [block-drawing characters](https://en.wikipedia.org/wiki/Box-drawing_character), like ▖▗ ▘▝
It´s not very clear if the registers on the txt file come up all in the same line or line by line, please clarify this
Rip, sorry bout it. 
Actually, I got it to work. while(fgets(szInputBuffer, sizeof szInputBuffer, pFilePerson) != NULL) { iScanfCnt = sscanf(szInputBuffer, "%15s %d %d", event.person.szName, //Name &amp;event.person.iDepartTmUnits, //Delta Depart &amp;event.iTime); //Delta Arival // Check for bad input. scanf returns the number of valid conversions if (iScanfCnt &lt; 2) { printf("\tWarning: Expected ID and name, received %d successful values\n" , iScanfCnt); continue; } } iScanfCnt now returns 3 scans!
But I am now presented with a new problem. It is now asking that I insert EVT_ARRIVE and EVT_DEPART events into the simulation's eventList.
 that does sound pretty cool, I think I'll try it. thank you for the suggestion
great, but remember that if name,lastname are more than 15 chars is possible that this code fails to parse.
thank you! thankfully, the names are only 12 chars long is there any help you can give for the other question?
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
This is a good idea! But personally I'd recommend the half-height block characters ▀ and ▄ instead.
Glad I was able to help! That inquisitive spirit early on, I think, often separates the great programmers from the "I can kinda hack something together with enough trial and error, but not sure how it works" that's much too common nowadays, don't lose it! :) 
you're taking a joke a bit too seriously man
ah the loop comment was actually meant for another function, it's just a comment I forgot to remove. other than that yeah good points, my comments aren't the best
so as I understand with this info you have to create a Linked List, maybe a NodeLL list? you already have all the info for struct Event. But i don´t know how you must handle this part, and what does SimulationImp and LinekedListImp
I'm it migth be a preference thing, but I would separated the program memory from the program instructions. In other words, having 1. a stuct for the `FILE`, `program` and `progIndex` and `programSize` 2. a struct for the `memory` and `index` That said, take my comment with a grain of salt, I'm new to C. &amp;#x200B; &amp;#x200B;
First off, a request: make use of reddit's code formatting. 4 spaces of indent before every line of code, which will help everyone read it more easily. Your levels of indirection are incorrect inside your write_adjacent function. You were correct that you need to pass in test_pointer by its address and not its value. Once inside the function though, problems begin. pointer = (char) malloc(sizeof(char) * 3); Type mismatch. 'pointer' is of type char *** ; which is to say, it points to a memory location intended to hold a "char **". You are allocating the space for 3 elements of type char. Beyond that, you are casting the result of your malloc to type char. None of these match. &amp;nbsp; Assuming you are trying to allocate a 2D array with 3 rows and 50 columns, what you would want is this (with comments explaining why). First off, a request: make use of reddit's code formatting. 4 spaces of indent before every line of code, which will help everyone read it more easily. Your levels of indirection are incorrect inside your write_adjacent function. You were correct that you need to pass in test_pointer by its address and not its value. Once inside the function though, problems begin. pointer = (char) malloc(sizeof(char) * 3); Type mismatch. 'pointer' is of type char *** ; which is to say, it points to a memory location intended to hold a "char **". You are allocating the space for 3 elements of type char. Beyond that, you are casting the result of your malloc to type char. None of these match. &amp;nbsp; Assuming you are trying to allocate a 2D array with 3 rows and 50 columns, what you would want is this: *pointer = malloc(sizeof(char *) * 3); (*pointer)[0] = malloc(sizeof(char) * 50); You were trying (incorrectly) to assign memory to the pointer variable "pointer" used as a parameter in your function. Keep in mind that there is an additional level of indirection. You passed in &amp;test_pointer. This is the address of a pointer-to-pointer variable. Your goal is to assign memory to the pointer-to-pointer variable, so you'll have to dereference to get back to that, which is what I did in my example. Additional note, you are casting the return of your allocation to the wrong type, but honestly you do not need to cast the return from malloc. That is a c++ thing, not required or often used in C. 
Thank you for the quick response. I'm not sure what's wrong with formatting, I used 4 spaces and looks fine from mobile and desktop _to me_. I'm not sure if I understand your answer. I changed the code to what you mentioned right before you answered, even taking out the casts. My code looks exactly like yours but still segfaults when I add the second `strcpy` call. 
Has to be the 80x24, or could you use some ridiculously small font for 500x200 cols and rows ? :)
Make life easier, use a local variable inside the function, and assign it just once before returning: char **v; v = malloc(sizeof (char *) * 3); v[0] = malloc(50); ... *pointer = v; 2nd line of main() is bad, random value in test\_pointer can just happen to point outside your legal memory.
Because you haven't allocated that memory. Your code only had (with corrections): (*pointer)[0] = malloc(sizeof(char) * 50); That allocates what we can call the 0th row of your 2D array. If you want to access rows 1 and 2 you will need to allocate them similarly. In general, pointer variables do one thing: they point to a location in memory. C does not provide you with a safety net, which means when you define a pointer, it is up to you to ensure that the location it points to is valid memory for you to access before you attempt to read or write to it. Malloc is making those locations "open" for you to read/write. When you define char **test_pointer, the only thing that exists in memory is a single number representing space that is expected to hold values of type char *. Then when you call *pointer = malloc..., you are telling the machine, okay set aside a block of size x to hold entries of type char *. Then, since this location is in turn holding different types of pointer variables you need to repeat the process with the appropriate types and locations (as we did for the 0th element). Let's use a real-world analogy. Forget about doing this in a function for now, let's focus on everything happening in the same scope. Let's say there's an empty street in town that has a bunch of open land around it ready to be used. You want to build a house, so you go to the town and say so, then they give you the rights to a single plot of land to use for a home an an address. Done. Now let's imagine instead you are a developer who wants to build 10 homes. So you go to the town and make the request and they assign you 10 plots of land along that road for you to use for homes. Perfect. Now think bigger, you're like mega wealthy and want to build a housing development. So you you go to the town with a set of streets to build. Once you have that space, you decide how you want to use each street and go back to the town and say how many houses you want on each street. Great, they give you the individual plots for each house. Now imagine the situation where you try to build your housing development but you stop after you get the rights to build streets. So you have a network of empty streets, but then you decide to skip ahead and just build a house without permission. Problem! The city never gave you permission for that, so they come by and prohibit you from doing work because it's an error in the process they allow. Maybe they had other plans for some of that land on your street. Maybe its already in use and they just didn't tell you. That is what is happening with your segfault.
They're just implementations of their structures, that's how my professor created them Yeah, I have to create a link list with this info
I don't want to return anything. Passing by reference is a pre-requisite for me. That's because I have to extrapolate this to another function which actually does stuff that I have to actually return. Since I can't return more than one thing, I'm trying to accomplish *and* understand how to do this manipulation from inside a function and have it persistent outside of said function.
Thank you for the analogy... I think I got what you meant. But I'm still having trouble making sense of how adding parenthesis to the piece of code worked and the previous version didn't.
I didn't mean returning the data, just that you use 'pointer' just once at the end. char** test_pointer; printf("*test_pointer=%p\n", *test_pointer); That one? How come? If test\_pointer is bad, \*test\_pointer is crash, no?
&gt; First off, a request: make use of reddit's code formatting. 4 spaces of indent before every line of code, which will help everyone read it more easily. Note: OP used a code fence which *does* display correctly on the redesign. However, since the admins want to discourage us from using the "old" interface, they've decided to make code fences display improperly outside of the redesign. The situations sucks.
I'm not sure where the *&amp;() sytnax is coming in. I don't see that in your code. If you mean the parentheses I added in my corrections, that's just to make explicit the order of precedence in the operations. Without those, the computer will interpret *pointer[5] as "give me the value at the 5th location in "pointer"", when what I want is (*pointer)[5], which says "give me the value contained at "pointer", then because that is itself a pointer/array, give me the 5th element in that memory block/array.
Ah thanks, didn't know that. I never use the new version.
This is **the** answer. Thank you. I think I understand it now. Is there any way I can *not use* parentheses to do the accomplish same thing? Using parenthesis doesn't seem very readable.
Parentheses and brackets have different levels of precedence, so if you want to avoid them you will have to re-write your code. As another commenter suggested elsewhere, you can use variables to "disguise" levels of indirection. Meaning, you define a new variable with its type the level of indirection you want and then use it instead of the parentheses. If you define char **p = *pointer, then you can just do p[0] = malloc. ... This is probably fine for this small example, but just keep in the back of your mind for the future that "[three star programmer](http://wiki.c2.com/?ThreeStarProgrammer)" is a thing. Basically, complicated programming in C may very well require many layers of indirection; however, if it's getting deeper than one or two (e.g. char * or char **), then it's probably time to refactor your functions or structures to handle that abstraction more nicely.
That's exactly what I want! I want it more readable. I'll post the better-looking solution asap. Ouch. That article hurt.
Works on my machine
That was working before. I'm not sure why it's not working anymore.
Post is edited. I think it's more readable right now. Would I be able to say "indirection was removed" now? Can it improve?
* Since looping is recursive, you can have lots of `[` (generate with `yes [ &gt; file.bf`, mine was ~600MB big, so ~300MB of `[`) and it'll exhaust your stack and segmentation fault. * You also don't limit the `index` variable, so you can read and write stuff out of bounds. So for example, `&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; -` creates an infinite loop because it decreases the `progIndex` by one (so it then points to the space), and later again and so on. (I am on a Linux AMD64 system) * You could've used [`strerror`](https://linux.die.net/man/3/strerror) or [`perror`](https://linux.die.net/man/3/perror) to get an more accurate error message. * Reading the entire file might not be the best idea, since it might be very big. * Since you read the entire file, you actually don't need the `res-&gt;file` (file pointer) any more, since you never use it again (except when destroying it). * The interpreting is called "parsing" here, which is not fitting. * You may wanna check the program for any syntax errors, e. g. `][` wouldn't be allowed. * Errors are usually printed to `stderr`, not `stdout`. * Some inconsistency: `program`, `programSize`, `progIndex`
this is actually super nice and helpful thank you so much for taking the time to write this! I'll be sure to work on that stuff
Anonymous structs cannot have a struct tag. OPs code is a struct with no members and two struct definitions (not member definitions). Not allowed in C11 either.
Yeah that'll work as far as pointer behavior is concerned. Once you get comfortable with pointers, another options for 2D arrays is to have one as your "index" (the pointers to pointers) and one as your "content". Then instead of a bunch of allocations you make only 2 malloc calls. For example: void alternative_func(char ***pointer) { char **pp; char *all_rows; int numrows = 3; int numcols = 50; int i; *pointer = malloc(sizeof(char *) * numrows); //memory for 3 pointers to char pp = *pointer; all_rows = malloc(numrows*numcols*sizeof(char)); //memory for 3*50 chars for(i = 0; i &lt; numrows; ++i) pp[i] = all_rows + (i * numcols); } Imagine you have a 1000xn array. You can allocate it with 2 calls and a bunch of assignment operations or 1000 malloc calls. Also, then you only have two things to free, your "index" and your "content" block.
 if ( a = printf("hello world")) { 
Wait does that actually function? What would it do? Return true?
This sub is about C, not C#
These are two hyper-specific restrictions... I'm curious -- what's the purpose of the lab? (ie. what's the overall assignment?)
You're *very* lost. You're *so* lost that you're on the wrong subreddit. /r/csharp/
a is assigned the value that printf returns (which will be 11 if "hello world" is successfully printed or a negative number if printf fails) Then, if a isn't 0, the expression is true and the body will be executed.
printf returns number the total number of characters written 
Yeah it does. `printf` returns the number of characters printed. If the number of characters printed is nonzero the block after the if would be run.
 Write a C program order3\_challenge2.c that reads 3 integers and prints them from smallest to largest. You are only permitted to have 3 variables in your program and they must be of type **int**. The restrictions of the previous challenge exercise also apply. You are not permitted to use **if** statements. You are not permitted to use loops (e.g. **while**). You are not permitted to call functions other than printf and scanf. For example, you are not permitted to use functions from the math library. You are not permitted to use **printf** inside expressions - you can only use **printf** as a statement (the way it has been used in lectures). You are not permitted to assign variables inside expressions - you can only assign variables as a statement (the way it has been done in lectures). For example, both of these are **invalid**: (a &lt; b) &amp;&amp; printf("a"); // invalid (a &lt; b) &amp;&amp; (a = b); // invalid You can use **printf** to print the value of an expression, in other words you can have an expression inside **printf**. You are only permitted to use parts of C covered in the weeks 1 and 2 lectures. For example, you are not permitted to use the ternary ?: operator. You are not permitted to define functions.
I relate to the Three Star Programmer and that is a bad habit. How do I stop being one?
but don't tell me the answer coz its not allowed
It's hard and it's (frankly) a really, really dumb assignment for a programming class. This problem does not teach *anything* about programming -- it's basically just a convoluted math riddle masquerading as a lab assignment, which forces you to use lines of thinking that a programmer would *never* actually use. If this is a class on computer science or programming in C, your professor should be ashamed of themselves. If this is a math class -- maybe it's okay.... but really, this assignment is just a math riddle.
C# is off topic in this subreddit. Please post C# questions to /r/learncsharp instead.
Technically speaking, these restrictions are bullshit because the only way to use `printf` is in an expression. Similarly, there are only two ways to assign variables: during initialisation and using an assignment operator in an expression. 
Interesting. So by some degree, printf can be treated as strlen? 
This is a fun challenge and there are multiple ways to solve it. It's easy if you know the general idea, kinda hard otherwise. As a hint: this boils down to sorting the three numbers from smallest to largest. To do so, you need an expression which yields the smaller or larger one of two numbers. How can you build such an expression?
I do frequently use this kind of programming technique when writing branch-free code. This is useful for cryptographic applications (constant time algorithms) and high-performance code (it is hard to vectorise data-dependent branches).
The point of the assignment is basically trying to force you to spit out the three integers in order without using any if statements or anything that behaves like an if statement. The purpose of restricting assignments within expressions is to stop someone from doing a conditional assignment (ie. using a short circuit or similar as an if statement) I haven't worked out the answer, but I know what specific property of C they're forcing the student to rely on..... (and it's really stupid)
&gt; I haven't worked out the answer, but I know what specific property of C they're forcing the student to rely on..... (and it's really stupid) You do? That's weird because I can think of a number of different solutions that all boil down to different basic ideas.
I'll PM you.
Start with it anyway - if you properly encapsulate the drawing it will be an easy way to get started while you work out all the other game play. Once you're done you can see if it really hinders game play and switch it out for something better at that point (or possibly you'll find it's good enough).
Sure. Let's not spoil this for OP.
I don't know how much input you want on this, so I put my reply behind a link so it's not immediately visible. It does not contain an answer but it does point out some parts of the language you could explore to try to get to a solution. I haven't used C in a long time so I don't know which of these are implementation/platform dependent and which of these are guaranteed to be portable. I doubt you need to care about portability for an exercise like this though. Either way, I think you can combine the following two features of the language with all the binary and unary operators you have seen to get to a solution: https://pastebin.com/T6H3fWuZ https://pastebin.com/zq2Lnxz7
Stupid exercise, I'd just use switch case out of spite. It is not forbidden by the rules you posted, but still not what the person had in mind. 
From a pedantic standpoint, the Standard's requirement that objects' stored values only be accessed *by* lvalues of particular types is similarly problematic. Within the execution of the expresion `x=1;`, an lvalue of `x`'s type will be used to identify the object to be written by the full expression, but the lvalue `x` itself doesn't write the object, and the full expression isn't an lvalue of any type because it isn't an lvalue at all.
Practice really. When you're just starting out with the language, I would prioritize just creating correctly functioning code over anything else. Once you get something functioning correctly, then go back and worry about improving its readability and/or efficiency (space efficiency and time efficiency). As you program more, you will run into situations where it just seems like there's got to be a better way to do whatever it is you're doing. Usually if you search around online, there will be a stackoverflow thread that addresses the same kind of issue, or if not sometimes someone has written an article or blog post on the topic. If there's not, post there and see what kind of answers you get. As you do this more and more it will become less common for you to need to do so. Once you get comfortable with the language core concepts, sometimes it's just fun to search for things like "creative uses of _________" (some random C feature) and see what people can do with random situations and needs they might have or just want to explore.
I believe render clear just fills the window with the clear colour. You'd need special window system calls to make the window itself have transparency. SDL is cross platform, some platforms lack compositors, so I doubt it supports window-level transparency. I love to be proven wrong though :)
I don't think SDL2 is capable of what you want. If you are using Windows, maybe you could take a look at UpdateLayeredWindow or SetWindowRgn. It should be possible with X11 too but I'm not sure...
You could probably still use sdl and those functions
printf returns an int. `int x = printf("hi\n");` is apparently not allowed since it uses print as a value/expression. also, `int a = x = 6;` would not be allowed although it is valid c, both a &amp; x become 6.
Take some time to think about what the differences are between what you are telling the two programs to do. Can you state what each one does? 
Yes, of course. I meant one could obtain the window handle from SDL2 and pass it to these functions.
Basically: * when you use fprintf you are just waiting for the kernel to write the data to that file. * when you're using system, you're actually: * asking the kernel to make a copy of the current process * in the process copy, ask the kernel to switch the current process executable code to be your default shell's one * your default shell takes over, does its own initialization, loads its own config (`~/.bashrc` or whatever), then parses the command, and only then executes it. * i am fairly sure that the `system` function will wait for all this to be done before returning, that literally means there's a `waitpid` call somewhere &amp;#x200B; Needless to say, spawning a whole new process takes a lot of time.
With znpy answer I get it. In one version I am creating multiple processes, and in the other it is just a single process. Right? 
I think you'd have to, to match the resolution. I think the 2600 would do 160 x 192, so a standard 80-column screen with 1/4 block characters should do it for width.
&gt; With znpy answer I get it. In one version I am creating multiple processes, and in the other it is just a single process. Right? The issue isn't so much the "the number of processes", though that certainly contributes -- it's the fact that using `system` involves a huge number of additional steps. Heck, just compare these: $ sudo perf stat --repeat=1000 sh -c '' Performance counter stats for 'sh -c ' (1000 runs): 0.516612 task-clock (msec) # 0.794 CPUs utilized ( +- 0.22% ) 0 context-switches # 0.008 K/sec ( +- 61.19% ) 0 cpu-migrations # 0.000 K/sec 118 page-faults # 0.228 M/sec ( +- 0.05% ) 1,906,604 cycles # 3.691 GHz ( +- 0.22% ) 2,154,657 instructions # 1.13 insn per cycle ( +- 0.04% ) 430,041 branches # 832.425 M/sec ( +- 0.04% ) 15,406 branch-misses # 3.58% of all branches ( +- 0.05% ) 0.00065030 +- 0.00000180 seconds time elapsed ( +- 0.28% ) $ sudo perf stat --repeat=1000 sh -c 'echo 1 &gt;file' Performance counter stats for 'sh -c echo 1 &gt;file' (1000 runs): 0.544653 task-clock (msec) # 0.805 CPUs utilized ( +- 0.11% ) 0 context-switches # 0.024 K/sec ( +- 39.87% ) 0 cpu-migrations # 0.000 K/sec 121 page-faults # 0.222 M/sec ( +- 0.04% ) 2,010,023 cycles # 3.690 GHz ( +- 0.11% ) 2,220,945 instructions # 1.10 insn per cycle ( +- 0.05% ) 443,864 branches # 814.949 M/sec ( +- 0.04% ) 16,666 branch-misses # 3.75% of all branches ( +- 0.05% ) 0.000676792 +- 0.000000939 seconds time elapsed ( +- 0.14% ) Take a look at the `cycles` count (or the `instructions` count... the instruction throughput is much the same in both cases so it doesn't matter). The only difference between these two runs is that in the second case I am doing the `echo` command. What this tells us is that the 97% of the time in running `echo 1 &gt;file` is spent _starting_ the shell, let alone getting it do any useful work.
I don't see why it should disallow ][, I mean, it is useless, but still valid. 
Seems unnecessarily complicated to me to be honest. 
If you want to dable in gates and pure logic... There's PALs, CPLDs and FPGAs for you too. Or implementing specific algorithms in DSPs and such, taking advantage of specific math instructions. Many times what you need cannot be done in a linear, step-by-step execution logic. Reminds me a MRI scanner-like project at my university where they had to be able to account for each and every photon. Not just count them, but record their direction of travel too. There's no CPU on earth that could ever do that! I particularly love taking advantage of powerful hardware features provided by microcontrollers. These days they offer so many peripherals out-of-the-box. Having to code ECC routines using crypto-acceleration engines for example, can be quite the challenge sometimes. Specialized hardware definitely has it's place, even if it seems that less and less companies are creating their own ASICs these days with all the off-the-shelf component available these days. But the common factor to it all, is cost per unit. There are microcontrollers nowadays that cost less than 3 cents. It can be cheaper to put a microcontroller than a bunch of discrete gates sometimes. It's the modern version of buck-charging circuits that have replaced big transformers in today's power supply circuits.
&gt; SDL_SetWindowOpacity This is a global per-window transparency setting. You're wanting per-pixel alpha or chroma keying. It's possible but I'm not convinced SDL supports it.
Yes, `system` does have a wait call in it
it does, i tested it. Also im not sure what you mean by scanning forwards for every loop.
Sort of. `printf` returns `int`, which probably can’t handle the 0-to-`SIZE_MAX-1` range that `strlen` can return. (The stdio `printf`/`scanf` functions all have stupid problems like this, where they use `int` for lengths and sizes.)
&gt;your default shell system() uses /bin/sh, nitpicking here.
Well `printf("hi\n");` without the assignment is still an expression. More precisely, it's an expression used to form an expression statement. That's why the requirements are bullshit.
Not just that. Given that `fprintf` is asked to write `"1"` to a fully buffered file, it should only actually call `write` about 1 in every `BUFSIZ` calls. 
Ah, thank you, didn't know that! Is that supposed to be the standard behavior os is it implementation-dependent ?
&gt;What this tells us is that about 95% of the time in running echo 1 &gt;file is spent &gt; &gt;starting the shell &amp;#x200B; Indeed. I was oversimplifying it, but to be more precise what i wanted to say is that forking a new process and switching context takes a lot of time (multiple syscalls + context switch + shell loading its own conf) compared to a "simple" syscall to the kernel.
POSIX, hazarding a guess.
The file is being opened and closed each time, so the `write` will occur as the buffer is flushed during `fclose`.
I see. Totally missed that. So there is actually an open, a write, and a close. Plus I think an fstat. And do not forget the malloc.
I think it's easiest to think of it in terms of: what must always be true? pHead is *always* the first node in the list, it can have nothing before it; pFoot *always* points to the last node in a double linked list, nothing maybe behind it; and an empty list is represented by a head node (whose prev points to the tail, and a tail node whose pNext points to the head)
Instead of 2 links, keep one actual NodeLL in LinkedListImp.
`pNext` and `pPrecedes` mean the same thing. If you want a doubly-linked list, use `pNext` and `pPrev`.
Do you need to implement fast append (instead of just prepend)? If not, you don't need the foot pointer. Do you need to implement fast removal? If not, you don't need a doubly-linked list, you can just use a singly-linked list. In any case if you're having trouble implemting a doubly-linked list with head and tail pointers, it would be a good idea to implement _and test_ something simpler first: a singly-linked list with head pointer but not tail pointer.
This OP should get a Singly linked list, test all the features and then implement a DLL. 
Yes, that's what the middle paragraph of my post said too.
Huh? Doesn't precedes mean to come before?
I don't need speed or anything like that, it's for a school project. I figured I'd try doing a doubly linked list, but it seems I am in way over my head and am struggling to understand it. I think I'll take your advice and just do a singly linked list for this project. 
[Wikipedia says:](https://en.wikipedia.org/wiki/Brainfuck#Commands) &gt; `[` and `]` match as parentheses usually do: each `[` matches exactly one `]` and vice versa, the `[` comes first, and there can be no unmatched `[` or `]` between the two. Also looking at [esolang](https://esolangs.org/wiki/brainfuck), it says that for `]`, it should go back to the matched `[`, which it isn't there, so it's an error. (It doesn't say to explicitly ignore). On the same page, there's an link to "[Original distribution by Urban Müller](http://main.aminet.net/dev/lang/brainfuck-2.lha)", which contains an C implementation, which also errors on unbalanced `[]`.
In ISO C it's implementation dependent, but POSIX requires it to use a POSIX compliant shell. So it doesn't have to be /bin/sh, but on most distributions, that's where the POSIX shell is.
Took me a whole day but it works &amp;#x200B; \#include &lt;stdio.h&gt; int main(void) { double a, b, c, d, e, f, g, h, i, j, k ,l, m, n, o, p, q, r, s; double smallest\_value, middle\_value, largest\_value; int smallest\_integer, middle\_integer, largest\_integer; printf("Enter integer: "); scanf("%lf\\n", &amp;a); printf("Enter integer: "); scanf("%lf\\n", &amp;b); printf("Enter integer: "); scanf("%lf\\n", &amp;c); &amp;#x200B; &amp;#x200B; d = (a + b)/2 + (((b \* (a &lt;= b) + a \* (b &lt; a)) - (a \* (a &lt;= b) + b \* (b &lt; a)))/2); //bigger value e = (a + b)/2 - (((b \* (a &lt;= b) + a \* (b &lt; a)) - (a \* (a &lt;= b) + b \* (b &lt; a)))/2); //smaller value //printf("%lf\\n", d); &amp;#x200B; f = (a + c)/2 + (((c \* (a &lt;= c) + a \* (c &lt; a)) - (a \* (a &lt;= c) + c \* (c &lt; a)))/2); g = (a + c)/2 - (((c \* (a &lt;= c) + a \* (c &lt; a)) - (a \* (a &lt;= c) + c \* (c &lt; a)))/2); //printf("%lf\\n", f); &amp;#x200B; h = (b + c)/2 + (((c \* (b &lt;= c) + b \* (c &lt; b)) - (b \* (b &lt;= c) + c \* (c &lt; b)))/2); i = (b + c)/2 - (((c \* (b &lt;= c) + b \* (c &lt; b)) - (b \* (b &lt;= c) + c \* (c &lt; b)))/2); //printf("%lf\\n", h); &amp;#x200B; // e, g (smallest value) j is lowest j = (e + g)/2 + (((g \* (e &lt;= g) + e \* (g &lt; e)) - (e \* (e &lt;= g) + g \* (g &lt; e)))/2); smallest\_value = (e + g)/2 - (((g \* (e &lt;= g) + e \* (g &lt; e)) - (e \* (e &lt;= g) + g \* (g &lt; e)))/2); &amp;#x200B; //d, f (largest value) h is highest largest\_value = (d + f)/2 + (((f \* (d &lt;= f) + d \* (f &lt; d)) - (d \* (d &lt;= f) + f \* (f &lt; d)))/2); l = (d + f)/2 - (((f \* (d &lt;= f) + d \* (f &lt; d)) - (d \* (d &lt;= f) + f \* (f &lt; d)))/2); &amp;#x200B; &amp;#x200B; &amp;#x200B; //n p Lowest to middle value &amp;#x200B; n = (e + g)/2 + (((g \* (e &lt;= g) + e \* (g &lt; e)) - (e \* (e &lt;= g) + g \* (g &lt; e)))/2); o = (e + g)/2 - (((g \* (e &lt;= g) + e \* (g &lt; e)) - (e \* (e &lt;= g) + g \* (g &lt; e)))/2); &amp;#x200B; p = (e + i)/2 + (((i \* (e &lt;= i) + e \* (i &lt; e)) - (e \* (e &lt;= i) + i \* (i &lt; e)))/2); q = (e + i)/2 - (((i \* (e &lt;= i) + e \* (i &lt; e)) - (e \* (e &lt;= i) + i \* (i &lt; e)))/2); &amp;#x200B; r = (g + i)/2 + (((i \* (g &lt;= i) + g \* (i &lt; g)) - (g \* (g &lt;= i) + i \* (i &lt; g)))/2); s = (g + i)/2 - (((i \* (g &lt;= i) + g \* (i &lt; g)) - (g \* (g &lt;= i) + i \* (i &lt; g)))/2); //printf("%d", n); &amp;#x200B; middle\_value = (n + p)/2 + (((p \* (n &lt;= p) + n \* (p &lt; n)) - (n \* (n &lt;= p) + p \* (p &lt; n)))/2); &amp;#x200B; &amp;#x200B; smallest\_integer = smallest\_value; middle\_integer = middle\_value; largest\_integer = largest\_value; &amp;#x200B; printf("The integers in order are: %d %d %d\\n", smallest\_integer, middle\_integer, largest\_integer); &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; return 0; } &amp;#x200B; &amp;#x200B; &amp;#x200B;
\&gt; pHead points to the first node in the list, that I understand, however - should the first nodes pPrecedes point to pHead, or to NULL? Same with the pFoot, should the last node in the list point to pFoot, or to NULL? &amp;#x200B; It sounds like you are writing a doubly-linked \_circular\_ list. This means when you are on the last node your "next" pointer should point to the first node and when you are on the first node your "previous" pointer should point to the last node. &amp;#x200B; You \_shouldn't\_ point to the head and tail pointers in your list struct from the nodes because you will introduce an additional layer of indirection (pointing to a pointer to a node - instead of just pointing to a node) that you don't really intend. The head and tail pointers in your list struct are just entry points into the list.
&gt;... should the first nodes pPrecedes point to pHead, or to NULL? The first node in the linked list should be pHead no? So you're asking whether the head's "prev" pointer should point to itself? I think it makes more sense for it to be set to NULL.
If I understand correctly you have a design with two levels. The "top" level has a linked list struct that identifies the end nodes. The "bottom" level is the nodes themselves, in a doubly linked chain. And you're asking where the "end" pointers in the chain should point ( or if they should be null). They should be null for two reasons: First, when iterating along the chain, testing for null is an easy, standard way of checking if you have reached the end. Second, the pointer s should always point to the and type of object. In this case, to a node. The top level linked list struct is not a node. Also "precedes" is fine, but "previous" is more normal. And some of the other answers here are crap 
This link here might help you if u are using Windows operating system. Though this link is for making OpenGL window transparent but SDL uses OpenGL after all. So this should work in your case too. Right ??? https://stackoverflow.com/questions/4052940/how-to-make-an-opengl-rendering-context-with-transparent-background Please let me know if it worked.😀😀😀
Yes, that's fine. Do note that pointers to that array will become invalid.
From the current standard &gt; The contents of the new object shall be the same as that of &gt; the old object prior to deallocation, up to the lesser of the new and old sizes. So yes, realloc ensures that the data in the previously allocated memory is retained when you grow the size. This could be because the old memory is reused, it could be because the data is moved. Your application shouldn't care. I think you are overthinking things, trying to second guess how the allocation is performed.
Please submit code that compiles (and preferably without warnings).
Maybe you should start by figuring out what that error means?
1. The way you malloc is wrong in many ways, first of all sizeof(length) is will always be 4 so i assume you wanted to so malloc(length) but malloc takes size in bytes and you want to store 32bit ints. malloc(length * sizeof(int)) would be more suitable 2. Either im blind or you dont do anyting with your vals in command_to_in_array, make use of that destination pointer 
Tanks for the insightful answer. This was just a random thought, i wasnt even doing anything related to that rn just curious
Yes. So one could make the argument that 'A-&gt;pPrecedes = B' means “A precedes B”. Either way, the common idiom is “prev” or (less frequently “previous”), and using “precedes” instead will make your code harder to read.
Destination is undeclared I get that. But I am not sure how I can send it to my next function.
I am still trying to figure out how I can use the pointer for my next function.
Diagram the problem out. Draw boxes to represent each strut, and label members within the boxes. Draw arrows to represent where the pointers point to. Start with whatever condition you use for your initialization. Now, draw out adding a new node, and see which arrows you need to re-draw. Now think about how you would refer to those arrows (and their targets) using code. Repeat the process a couple of times. Was adding a second node different than adding the first node? If so, how did it differ, and how can you detect which case you have? Now remove a node. Note which arrows you need to re-draw, and how you reference those arrows. Think about how you're going to free the node after you've removed it. Do this for every function you need to implement. It will help you determine edge cases and conditions. This entire process really helps with pointer assignment &amp; manipulation. Practicing drawing simple structures, like linked lists will be a tremendous help down the line.
Take your answer to 23.a., and count them. Anywhere there's a loop, multiply the stuff in the loop by the number of times the loop runs.
I know, but I'm just trying to say what they probably meant.
Maybe a VB GUI after that.
The restrictions you posted say &gt;You are only permitted to have 3 variables in your program and they must be of type **int**. You have broken both restrictions but I think that can be salvaged. You seem to have an approach that works and avoids conditional statements. If you have seen macros before you can probably use those to make your code look more readable. You could replace all of the following parts of your code: a * (a &lt;= b) with a macro: #define VALUE_OR_ZERO(CONDITION, VALUE) ((VALUE) * (CONDITION)) /* In the body of your code you can then write the previous expression using the macro */ VALUE_OR_ZERO(a, a &lt;= b) And you can use that macro to implement another macro that returns the greatest of two integers or the smallest of two integers. They could look like this (but the implementation is up to you): #define GREATEST(A, B) (/* Some implementation here using the VALUE_OR_ZERO macro */) #define SMALLEST(A, B) (/* Some implementation here using the VALUE_OR_ZERO macro */) With those two macros available you'll be able to reason about the code more easily while still fulfilling all the requirements of the exercise. 
Stay calm and vi on. 
You probably want to look into using [`sprintf`](http://www.cplusplus.com/reference/cstdio/sprintf/), which is like `printf`, excepts it outputs to an buffer as an string. So you might have this: char old[50]; char new[50]; sprintf(old, "oldname_%d.txt", issue); sprintf(new, "oldname_%d.txt", issue); Of couse this uses fixed-sized buffers. If you like to future proof, you could use [`snprintf`](http://www.cplusplus.com/reference/cstdio/snprintf/) with `n` (amount of characters to write) to `0` and using the return value as the number of bytes (+1) to allocate using `malloc`.
So what is actually the problem is that your code always enters the loop. Eg. `[+.]` should not print anything, but in your program it does. The stack thing is probably not relevant. I implemented BF iteratively, so I needed a stack. If your loops are implemented recursively then its not be necessary anyway.
I don't think second guessing any c operations is the best way to utilize the language. Segmentation faults are fine for personal tools but should be far removed from production 
Don't recommend sprintf as it's dangerous (can overflow buffers). Instead you should always use snprintf: char old[50]; sprintf(old, sizeof old, "oldname_%d.txt", issue); Yes, in this example you're never going to overflow because even with 64 bit numbers, the buffer is large enough but it's still good to get in the habit since the next example may not have this property. 
Thank you very much! I've tried with `sprint` although the compiler is throwing some errors I'm not really sure what to do with. **CODE** #include &lt;stdio.h&gt; int main() { int issue; int total = 13; for (issue = 1; issue &lt;= total; issue++) { char old[50]; char new[50]; sprint(old, "OldFile_%d.txt", issue); sprint(new, "NewFile_%d.txt", issue); rename(old, new); if (rename(old, new) == 0) { printf("%d:Done\n", issue); } else { printf("%d:Error\n", issue); } } return(0); } &amp;#x200B; **CMD** rename.c: In function 'main': rename.c:15:3: warning: implicit declaration of function 'sprint' [-Wimplicit-function-declaration] sprint(old, "OldFile_%d.txt", issue); ^~~~~~ C:\Users\***\AppData\Local\Temp\ccsLg9lM.o:rename.c:(.text+0x3b): undefined reference to `sprint' C:\Users\***\AppData\Local\Temp\ccsLg9lM.o:rename.c:(.text+0x57): undefined reference to `sprint' collect2.exe: error: ld returned 1 exit status This does not compile. From what I've found, it seems it does not find the `sprint` function or similar? If it matters, I'm using gcc on Windows.
Thanks a lot, this did the trick! :) An extra question: If I want to make it so the user has to insert the old and new filename manually (rather than inserting them in the program itself), do I use `scanf` ?
You could, you can also use [`fgets`](http://www.cplusplus.com/reference/cstdio/fgets/).
The potential error is that realloc can return null if there isn't enough space in which case the old pointer is still valid, so remember to realloc to a temp variable and then reassign the original after the realloc call has been verified as working to avoid a potential memory leak.
you mean s**n**printf()?
why should it not print anything? I feel like I'm missing something stupidly obviously
How can you “send” something that does not exist?
&gt; `sizeof(length)` is will always be 4 You can't assume that. In principle, it can be any positive integer. In practice, it can easily be 2 or, less commonly, 8.
Not strictly about your C code but a bit more generally: - You're running rename twice. I don't think you want to do that. - You're not checking if the new file exists before calling rename. If it did exist, it won't after your program has run.
The array is not initialized.
From wiki: &gt; `[`: if the byte at the data pointer is zero, then instead of moving the instruction pointer forward to the next command, jump it forward to the command after the matching ] command. I.e. it's like a `while loop`. You implemented it like a `do while` loop.
As someone who uses command line programs a lot I really don't like it when they ask for things like this interactively. If I was writing this program I'd read the file names from `argv`, or even use something like `getopt`.
Aren't they initialised automatically?
No, pretty much nothing is done automatically in C.
Because when you do int a[12] = {0} You are actually initializing the array with zeros.
Using a temp variable is only necessary if an application would have any hope of continuing usefully in case the allocation fails.
oh dang ok you're right. I didn't notice that part. that means I have to find that matching closing tag first. I might have to rethink how I do loops
Also, when I declare an char array: char a[4] = {'n','o','p','e'} printf("%s\n",a); I was told that if you are declaring a character array make sure to create an extra space for '\\0' because when you are printing the printf() will keep on printing until '\\0' is encountered or something but this doesnot happen. Really confused about character arrays in C.
Strings are char arrays with the extra "\0". When you make a char array you need to do it yourself
int GarbageCollecotr(Node N) { if(N==NULL) return 0; else if(N-&gt;left!=NULL) GarbageCollector(N-&gt;left); else if(N-&gt;right!=NULL) GarbageCollector(N-&gt;right); &amp;#x200B; free(N); return 0; }
This code invokes undefined behavior because `a` is not a proper string. However, it *just so happens* that when you ran this code, the next byte in memory was a zero, so it appeared to work.
It's also next to impossible to happen on a modern platform anyway - OS generally massively overallocate memory and will practically always return a valid pointer, and just kill your program when it uses it if there is actually a problem bad enough it can't fix it with swap. 
There isn't a string type in C so we use null terminated arrays of char instead. One of the few things C can do for you is make it easy for you to initialize these strings, e.g. char a[] = "nope"; That will do the same as your example, except it will also leave space for and set the null terminator.
I don't think this is true on Windows since it doesn't do overcommit.
IIRC, they *can* become invalid but don't always. Either way you should always assign it a variable like `foo = realloc(foo, size)`
Yes, they can stay the same but there is no guarantee, so you should always assume they aren't.
@xxc3ncoredxx , You really shouldn't write that code... When using `realloc`, the returned pointer might be `NULL`, indicating that the (re)allocation failed... however, **in case of failure, the original pointer remains valid**... which means that you might end up with a memory leak. The correct approach is: void * tmp = realloc(foo, size); if(tmp) { /* okay */ foo = tmp; } else { /* handle error */ free(foo); perror("(re)allocation failed); exit(-1); /* or not */ } 
Hence the second part of my comment. 
I suppose you are correct there. 
The loop does resume, it simply doesn't issue another prompt because that code occurred before the loop. I get the expected blank terminal line awaiting input. If you want another prompt you can either change your logical progression such that the prompt is part of the loop (perhaps a do-while loop instead of a while loop) or simply add a new line of prompt code along with the error message. Your variables and types are kind of all over the place. * tot_points -- Defined as an int and then cast to an int in the avg calculation. Also, not ever initialized. * total -- defined as a float, used like an int (assuming only integer point values are valid. Used to accumulate a total input, but not used after that. * avg -- defined as a float, but assigned an integer value (in the line where it is calculated. Not used after that, but the line where your output says you're displaying the average uses an integer format specifier. Also, that format specifier says to display an integer to 2 decimal places. Either you want %2d or %.2f
Assigning a single variable might not be enough. What if you have a pointer to the third element somewhere in your program? After the realloc you can't use it anymore.
I may be wrong because I have always declared arrays as pointers, but wouldn't this array be unmodifiable, since it's a pointer to read only memory where "nope" is defined?
Thank you! 
Oh you mean mismatched '[' and ']', I just thought you meant '][' by itself.
It's undefined behaviour to use the old pointers in any circumstance , the optimizer can assume they're invalid pointers even if the allocation didn't "move"
Although on a modern operating system if memory is so short that your realloc fails then the OS is likely to kill your process anyway. 
If they are static, they are initialized to zero. if local on the stack, no they are not.
Yes, that is correct.
No it’s not.
Which is it then ? :P
I just tested it, I am in fact correct
 char a[] = "nope"; declares a local character array (with a size filled in by the compiler), whose contents are the same as the string literal “nope". This character array is modifiable as normal. const char *b = "yep”; will declare a pointer to the constant character array of yep, which will be in read only memory. For historical reasons, you are allowed to exclude the const part of the declaration.
Wait no I'm an idiot
Interesting, does this only apply to variable declerations or would this work? ```C char a[5]; a = "nope"; ```
&gt;\#define VALUE\_OR\_ZERO(CONDITION, VALUE) ((VALUE) \* (CONDITION)) ty man, the question I posted was the second challenge question. The first one allowed me to use as many variables. tbh when it said that it had to use the 3 variables only on the second part, i was prepared to copy and paste everything into one line without variables. It would've work but it would have been aids.
Idk if It's a formatting error or not but it’s really easy to read a code that is well indented and has goos separation between blocks. As someone has already gave a nice well explained answer, I'm not gonna say anymore. I just wanna request you and all to post a well indented and clean code so that we can understand easily or even learn something from that. Please, don't get me wrong. I'm just trying to help me, you and the community. #happy_coding 
Will do in the future. Sorry!
Don't be sorry. Everyone starts at somewhere. I'm a newbie too. Just learning. 
That is why you should be keeping track of an offset from the original pointer and not building up a list of pointers directly to the data. 
Cleaned it up a bit - Now the output just ends after I input the points for the game #1. &amp;#x200B; #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; // // Declare Variables // int main(){ int i,num_points; float points_arr[0]; float total,avg=0; //total and average variable int tot_points; //total number of points // Greet the user // printf("Welcome to the Jets' Game points analyzer "); printf("\n"); printf("\n"); printf("This program calculates the average of as many game points you wish to enter."); printf("\n"); printf("\n"); printf("First, enter the number of game points to process:"); while(1){ //loop until points no &gt;=2,if &gt;=2 break,else loop scanf("%d",&amp;num_points); if(num_points&gt;=2) break; printf("Number of games must be greater or equals to 2\n"); } // clear buffer // fflush(stdin); // float points_arr[num_points]; //allocate float type array for num_points value if(points_arr==NULL){ //check for memory allocation fail printf("Couldn't allocate memory"); exit(-1); } printf("Now enter the %d points to be processed.",num_points); //prompt for user input num_points times printf("\n"); printf("\n"); for(i=0;i&lt;num_points;i++){ printf("Enter points amount #%d: ",i+1); while(1){ //check for &gt;0 input.if &gt;0 break,else,loop scanf("%f",(points_arr[i])); if(points_arr[i]&gt;0) break; printf("*** Entry error! The game points must be positive. ***\n"); } // printf("The value of the array is : %d and to be added to tot_points ",points_arr[i]); // display value in the array points_arr for subscript i // printf("I'm here befor the calculation of the sum"); tot_points = tot_points + points_arr[i]; //calculate sum } avg=(int) tot_points/(int)num_points; printf("\n"); // // Print the sum printf("The Total points of the %d game points entered is %.2d\n",num_points); // // // Print the average // printf("The Average points of the %d game points entered is %.2d\n",num_points,tot_points); // //Final Statements // if(avg&lt;10) printf("Your game points average needs improvement.\n"); else if(avg&lt;20) printf("Your game points average is adequate.\n"); else if(avg&lt;30) printf("Congratulations your team made the Silver Status.\n"); else printf("Congratulations your team made Hall of Fame status.\n"); free(points_arr); return 0; } &amp;#x200B;
it would be more natural to increment a pointer along expr and test for when it's pointing to the null byte at the end of the string. that would avoid the ugly `&amp;exp[i]`. the k&amp;r book (although i am not a fan) has some good examples of this kind of code.
If there's enough memory after the original allocation then it will return the same pointer and internally track that the size has been increased for that chunk of memory - specifically to know how much memory will be available again when that memory is free()'d. Otherwise it will allocate the contiguous chunk from elsewhere and copy the contents of the original block to there, but all your original pointers to the contents of the original block will then no longer be pointer to what they are supposed to. In these kinds of situations it can be handy to use array indices and do a simple pool allocator that just returns an index as a handle to an instance of a data structure. This simply obscures the underlying memory locations and makes it a lot simpler and smoother to deal with - without slowing everything down in any way that is significant.
Thank you for replying :) Agh, of course, I should just move a pointer along the string! That's the type of thing I really need to get committed to the front of my mind, so I reach for it right away instead of having to be reminded of it. Regarding using strstr and strchr in the default case, would that be to achieve what the: if (ch != '(' &amp;&amp; ch != ')' &amp;&amp; ch != ' ') does? By slurp up, do you mean having a nested while loop in the default case instead of going round the loop once per character to read a full identifier? I've seen that method used before, I wanted to check if that's what you were referring to. Thanks again, very much appreciated.
First, strlen returns size_t not int. I would adjust the type of length and i to size_t to avoid problems when you have larger strings. I would suggest returning a single token from lex at a time, you'd need to make use of some static variables and wrap the call to lex in loop. &gt; Having to repeat the same code for the left and right parentheses doesn't sit well with me at all, but I couldn't work out how to manipulate the fall through so that only the type was different. I wouldn't loose sleep over a couple repeated lines. If you really wanted to you could do something like this: case ')': case '(': tokens[tok_slot].start = &amp;exp[i]; tokens[tok_slot].length = 1; tokens[tok_slot].type = (ch == ')' ? R_PAREN : L_PAREN); &gt; I often feel naked writing in C, like there's very little means of abstraction to turn to. I'm not entirely sure what you mean here. You use the same mechanisms of abstraction you would in any other language, including python; you define functions to abstract complicated manipulation into simple function calls. 
Yes, you are correct. I misread the example as: const char* a = "nope"; Which does create a string with 5 read-only characters in memory. 
yes + yes.
Thanks for the advice :) Regarding the abstraction comment, what I really should have said was that I lack familiarity with C's common abstraction methods. Getting used to doing things without closures, for example. Do you mean using a static variable so that lex can retain some kind of counter (say, retain the value of i) between calls, to pick up where it left off? Thanks again.
see how strtok works - i am pretty sure that's what the poster is thinking of. this kind of thing is common in older(?) c functions, but is not thread safe. it's generally possible to make a thread-safe version that returns intermediate state to the caller without making the signature much more complex. for example, take a pointer to a token that you modify and return a char* that is used on the next call.
Regarding the lexer itself, you should look into creating a different interface in which you have a function \`next\_token()\` that returns the next token instead of generating a list of the tokens and then manipulating it. Subsuqently your parser would need to keep a certain number of tokens so that you could parse the program (usually 2: \*current\_token\* and \*peek\_token\* which is the token ahead of current\_token). This makes your lexer \*\*much\*\* more efficient because you'll have to tokenize programs of tens or even hundreds of thousands of characters, maybe even millions. &amp;#x200B; I've been following a great book: "\*Writing an Interpreter in Go\*", in which he explains and writes a lexer, parser, and interpreter. I hope my \[code\]([https://github.com/reposefulGrass/monkey-interpreter/blob/master/lexer.c](https://github.com/reposefulGrass/monkey-interpreter/blob/master/lexer.c)) helps explain the previous paragraph. &amp;#x200B; One issue I see that may be significant is that you create a token which has a pointer to a string (the source code). What happens if this string changes? That token would change. That is bad. What you would want to do is get the string and duplicate it (or create a string from it). Say you have the program string "(defn function (x) (+ 2 x))", and you're trying to tokenize "function". In C you would do so: // AN INSTANCE OF MY CODE ON GITHUB typedef struct { char *input; int length; int pos; int read_pos; // ... } lexer_t; // ... void lexer_read_char (lexer_t *l) { if (l-&gt;read_pos &gt;= l-&gt;length) { l-&gt;ch = '\0'; } else { l-&gt;ch = l-&gt;input[l-&gt;read_pos]; } // ... l-&gt;pos = l-&gt;read_pos; l-&gt;read_pos++; } char * lexer_read_identifier (lexer_t *l) { int start = l-&gt;pos; // find the end of the identifier while (is_letter(l-&gt;ch)) { lexer_read_char(l); // implicitly increments l-&gt;pos to end of identifier } int length = l-&gt;pos - start; char *ident = strndup(l-&gt;input + start, length); // DUPLICATION return ident; } Duplication is so that you can create a string of that section and use it. In C a string MUST end with a NULL character which is represented numerically as 0 or in ASCII as '\\0'. Your code does not create strings, it partitions the original source code. In this case it would be hard to print or use said literal of token. &amp;#x200B; NOTE: Later on I'll try to look more in-depth at your code and see what else I can help you with. 
This isn’t relevant here.
I haven't thoroughly looked through your code or attempted to compile but a few things jump out. First, `fflush(stdin)` is an undefined behavior in the C standard, and should be avoided. Second, your first `while` loop doesn't do what you think it does. (and your `printf` statement has 2 `%d` yet only 1 int argument. Third, you've already posted your code. Rather than ask "why isn't x working" -- tell us what you've done to try to debug it... Does it compile? In what way doesn't it work? In the programming world we like to look at troubleshooting through the lens of "When I do X, I expect Y to happen. Instead Z happens." 1. Here's the initial state and the steps to reproduce the issue. 2. Here's the expected result 3. Here's what actually happens instead That way, we don't have to pick through your code to try to figure out what you were trying to do... Finally, comments, indentation, and spacing could be cleaned up a bit for readability. (both on reddit, as well as for your personal use) From a personal development perspective, stop saving old code snippets in comments. It's messy, confusing, and prevents you from building the muscle-memory to type code correctly. Just delete them, and type what you *actually* mean later. It feels wasteful to delete old snippets, but I promise you it's better in the long-run. (note -- if there are entire blocks that you want to comment out *temporarily* that's fine, but it's really crap practice to leave tons of random incorrect one-off lines around)
Great to know that you are aware of that, now im pretty sure a person that cant even properly allocate space for an int wont be using a platform that doesnt have an int of size 4 so no need to complicate it trying to flex.
You need strcpy or other explicit copy for that.
The answer is 6
Not sure what you trying to here -- I think you messed your sample code. # include &lt;stdio.h&gt; int\* f(int size, int \*ptr); int main(void) { int i = 5; int \*p = f(i, &amp;i); i = p\[0\]; printf("The value of i is %d.\\n", i); return 0; } int\* f(int size, int\*ptr) { printf("%d\\n", \*ptr); return ptr; }
Opcacity != transparency. AFAIK SDL can't create transparent windows. If you're using raw OpenGL, check out GLFW. It can do that.
The code you posted does not compile. The code below compiles and runs. &amp;#x200B; #include &lt;stdio.h&gt; int* f(int size, int *ptr); int main(void) { int i = 5; int *p = f(i, &amp;i); i = p[0]; printf("The value of i is %d.\n", i); return 0; } int* f(int size, int*ptr) { printf("%d\n", *ptr); return ptr; } function f returns the value held by variable ptr before the variable ptr is destroyed. &amp;#x200B;
1) If someone asks, help I need to build a program that plays tic-tac-toe, what should I do? &amp;#x200B; 2) Versus, this for loop (or whatever) is giving me wonky values. &amp;#x200B; 2) is a reasonable newbie question. 1) looks like someone skipped class/lab and has a homework project due tomorrow. 1's won't get much love, deservedly so. &amp;#x200B;
Ok, I see. I added the declaration "int j = 6" and "ptr = &amp;j" in f and now the return is "the value of i is 6". I'm still confused because I was under the impression that everything declared in f ceases to exist in memory once it's popped from the stack, so then the pointer in main can't be pointing to any valid spot in memory, yet the declaration i = p[0] in main is still valid, and so it must be pointing to space in memory that still exists, right? What am I missing here?
C isn't that hard to get started. Start slow. Buy a learning C book or find similar tuts on the web. &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B;
Honestly, check out K&amp;R. Obviously all books are going to cover everything from beginner to etc. Otherwise, KN King’s is pretty good across the board. You could try this: http://www.buildyourownlisp.com/contents, given your background in LISP.
“Expert C Programming - Deep C Secrets” Peter Van Der Linden Don’t ever loan it out, you’ll never get it back.
It works because ptr in function f holds a value that exists in main (the address to i or j) int i = 5; /* storing 5 in variable i */ int *p = f(i, &amp;i); /* passing the address to i into f */ /* the address of i gets returned from f */ /* the memory that holds i remains intact */ &amp;#x200B;
You were lucky, and your compiler did not punish from naughtiness. It should have warned you. The 6 is still there, somewhere, but in an outlaw state. Any following activity can change it in hard to predict ways.
Huh? This doesn't compile because j is not in scope for f. What compiler are you using? #include &lt;stdio.h&gt; int* f(int size, int *ptr); int main(void) { int i = 5; int j = 6; int *p = f(i, &amp;i); i = p[0]; printf("The value of i is %d.\n", i); return 0; } int* f(int size, int*ptr) { ptr = &amp;j; printf("%d\n", *ptr); return ptr; } &amp;#x200B;
Have a peek at the assembly, gcc changes return \&amp;x; into return NULL; and smiles menacingly.
There is a great book about building data structures in C. Besides learning you a lot about the language without going through the beginner shtick, it might also be really interesting/revealing to learn how e. g. linked lists, trees, hashmaps, atoms/symbols (I forgot what Lisp calls them) etc. can be implemented. 
That is a nice feature that forces the segfault in this example. So even if you ignore the warning screaming at you, you will still get a nice segfault.
"Don't say I didn't warn you".
 Sorry, to be precise, this is what I did exactly: #include &lt;stdio.h&gt; int *f(int size, int *ptr) { int j = 6; ptr = &amp;j; return ptr; } int main() { int i = 5; int *p = f(i, &amp;i); i = p[0]; printf("The value of i is %d.\n", i); return 0; } I think understand your explanation for the original piece of code, i is declared in main and so the memory for i exists throughout the function call, there is no new memory being created only within the scope of f. If this is the case, then I find the above code to be curious because my compiler (gcc) is saying this too is valid, however shouldn't this be an issue given that j is declared only in f this time? 
So.... How do you *feel* about the assignment? Have you learned anything valuable about effectively programming in C? Do you feel this was worth your time? (Not trying to be snarky -- looking for honest feedback)
I use this old book called C in 21 days, it includes exercises and do’s and don’ts , I think it’s pretty good 
The value goes via ptr, not directly as return \&amp;j; Try with gcc -O2. At lower optimization it doesn't keep track of things enough, and doesn't notice the naughtiness. Old local variables don't disappear when you return. They are still there, same RAM as everything else, but it's beyond current stack top, or whatever mechanism the system uses. Next time you make a function call, that RAM is used for something else. Or sooner, it depends.
You can solve the first line with a normal CRC8 (poly = 0x07) but you need a final XOR step of 0xD2, this is probably just luck. It would only take some minimal effort in python to try every combination of starting and final values to get an answer if one exists.
1. K&amp;R 2 (start here and do all the exercises) 2. 21st Century C (good info on the ecosyem surrounding C) 3. Expert C (a nice deep dive into the nuances of the language) 4. Ted Jensen's tutorial on Pointers and Arrays in C (free pdf, a great tutorial if you are stuck on understanding pointers)
this is book is absolutely awesome
Sure is. And I've lost it 4 or 5 times by loaning it out to people and never getting it back. Its that good.
This subreddit is about programming in C only. Please post general computer science questions elsewhere.
`][` is also mismatched since when you read the `]`, you don't know any `[` yet.
&gt; char a[5]; a = "nope"; No, this would not work. `gcc` spits out the following error if you try to do that: error: assignment to expression with array type This would work: char *a; a = "nope"; However `a` would be read-only. You could print it out: printf("%s\n", a); But this would segfault: strcpy(a, "foo");
I've always thought that "warning" should be an error, but then I do use -Werror .... oh and -Wall and a bunch of other stuff that has at one time caught me out but isn't actually included in -Wall !
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Not exactly answers your question but recently I found out Linux Kernel documentation website which looks pretty neat [https://www.kernel.org/doc/html/v4.16/](https://www.kernel.org/doc/html/v4.16/)
What is the name of the book? 
That strikes me as a dubious design. An errant non-privileged application shouldn't be able to bring down a whole system. Further, it would seem like quite a few programs could have been simplified or made more efficient if there had been a standard combination multi-purpose allocate/free/resize function which, based on a "mode" parameter, could have offered the following configurable behaviors: 1. Request that the OS promise that the memory will be usable (recognizing that the implementation may not be able to control whether the OS upholds that promise), and fail if it cannot do so. 2. In case of failure, trap via implementation-defined means whose default behavior will force an abnormal thread (if applicable) or program termination (so as to avoid the need for client code to include error-handling logic that's simply going to force an abnormal termination anyway). 3. Zero any new storage added to the allocation will be zeroed (if thus configured). 4. Adjust the size of an existing allocation if that can be done without invalidating any existing pointers, but otherwise do nothing. [Most typically used for shrinking allocations, but also usable in cases where client code could skip some unnecessary work if the pointer isn't going to change]. 5. Either expect that the allocation will be further resized, or that it won't, and that it will be long-lived or short-lived. 6. Given a request to allocate zero bytes, return a non-null, "non-leaky" pointer that need not be freed, but will be treated as equivalent to NULL if passed to realloc/free or this new function, which may have zero added to it yielding itself, may be compared to itself with relational operators (reporting itself equal), and may be safely passed to `memcpy`, `memcmp`, etc. when the size argument is zero. As it is, user code is required to test memory allocations for `NULL` whether or not the program could do anything useful in case of allocation failure, but on some implementations could still fail unpredictably in case of allocation failure, yielding worst-of-both-worlds behavior, allocations have no good way of knowing which objects should be packed tightly and which ones loosely for best storage efficiency and minimal fragmentation, and user code that is supposed to be portable needs to include special logic to handle size-zero cases. 
*Hey just noticed..* It's your **2nd Cakeday** RussianHacker1011101! ^(hug)
r/osdev is nice, but the post are somewhat infrequent.
There is no special meaning for a target named "default". The target that make builds by default is always the first one listed in the file.
As far as the Standard is concerned, calling `realloc` in any circumstance where it returns a non-null result will set the original pointer and any pointers derived from it to Indeterminate Value. Even if code were to use `memcmp` to compare the bit pattern of the original pointer to that of the new one and find that they are equal, that would not imply that the original pointer or others derived from it would actually be usable for any purpose. IMHO, the Standard should have included a means of requesting that storage be resized, if possible, without invalidating the pointer to it. This would be especially useful in cases where code would have an upper bound for the amount of storage something will take, but not an exact figure, and would then want to shrink the allocation to fit the actual requirement without invalidating existing pointers that identify the object or (especially) portions thereof. Unfortunately, the only way to achieve such functionality is to replace the library's crude set of memory-allocation functions with better ones. 
Using `size_t` rather than length would cause all arithmetic involving lengths to be done with unsigned rather than signed integer semantics. In the practical cases where they would behave differently, signed integer semantics are generally more intuitive. If code may be processing untrustworthy input, it might be useful to replace strlen with a call to strnlen which forces an abnormal program termination if the length exceeds INT_MAX/2, since practical strings shouldn't be that long, and imposing such a limit would make integer overflows unlikely.
/r/osdev as /u/8bitslime has mentioned. I'd encourage you to just post in this sub though. It's in no way only for beginner C questions and the regulars who post and respond here have a deep understanding of the language. It's pretty clear that most here make a living utilizing C. I don't want to speak for anyone, but pretty sure most here would love to discuss issues beyond the how to get scanf working variety. Give it a shot! 
I really chuckled about the `scanf` comment. I believe I used it once in one lab, and then never again...
&gt; calling realloc in any circumstance where it returns a non-null result will set the original pointer and any pointers derived from it to Indeterminate Value. OP and myself were talking about program pointers to the contents of the first block - not the original pointer that refers to the beginning of the block itself as a whole. I.e. if I allocated a block for 10 structs and then had some part of a program pointing to the structs that comprise the allocation, those pointers wouldn't change to an "Indeterminate Value" if the block was realloc'd because realloc is oblivious to the fact that any part of my program is pointing to the contents of the original block. My program's pointers to the structs within the original block would then be pointing to no-longer allocated memory, instead of their fresh new place in memory in the new block of memory returned by the realloc. In this case the program would only continue working properly if the returned realloc block was just the original block but extended in size - but not if the contents had to be copied to a new larger block. &gt; the Standard should have included a means of requesting that storage be resized, if possible, without invalidating the pointer to it The Standard cannot possibly enforce keeping the original pointer every time because it cannot guarantee that there will be infinite free space immediately following the original allocation. What if you had a hundred allocations, where would you put them all so that any one of them could also be extended in size without overlapping one of the other 99? What if a realloc grows to a gigabyte in size? How would you ensure that doesn't overlap any of your other allocations? It can't be done. &gt; Unfortunately, the only way to achieve such functionality is to replace the library's crude set of memory-allocation functions with better ones. ...AKA managed languages, which have their purpose and place, that is: when the programmer can afford to be lazy and careless because their application isn't performance-sensitive and they can be totally ignorant toward the underlying machine that's actually doing the work.
...and is usually (but not necessarily) named “all”.
There actually is a relevant target named `.DEFAULT` in GNU Make (possibly others) that overrides the first target rule.
According to the C11 Draft N1570 6.2.4p2 "The value of a pointer becomes indeterminate when the object it points to (or just past) reaches the end of its lifetime." A successful call to `realloc` will end the lifetime of an allocated block whose address is passed in, even if the call happens to return a pointer that is bitwise identical to the original. &gt; The Standard cannot possibly enforce keeping the original pointer every time because it cannot guarantee that there will be infinite free space immediately following the original allocation. What if you had a hundred allocations, where would you put them all so that any one of them could also be extended in size without overlapping one of the other 99? I think you missed my point. Any call to a `realloc`-style function should do one of two things: 1. Provide a pointer to a block of requested size, 2. Report that it cannot satisfy the request (either via indicating to the caller that it failed, or by trapping). If a request specifies that the block is not allowed to move, that would increase the likelihood of the request failing. On the other hand, in some cases it may be useful for a program to do something like: Acquire enough storage to handle a function's worst-case needs Build within that storage an object that contains pointers to portions thereof Shrink the allocation to match what the function actually needed Using this approach may greatly reduce the number of individual allocations required, but if `realloc` were to invalidate the original pointer that would break things. &gt; ...AKA managed languages, which have their purpose and place, that is: when the programmer can afford to be lazy and careless because their application isn't performance-sensitive and they can be totally ignorant toward the underlying machine that's actually doing the work. Or the programmer needs better performance and semantics than can be achieved using the Standard library. Many programs use short-term allocated storage while building long-lived data structures, but using the standard library functions would result in the long-term allocations getting separated by holes where the short-term ones used to be. Having a means of indicating which allocations should be placed consecutively when practical because they'll be around for awhile and won't get resized, and which ones should be kept away from the long-term allocations, would alleviate such issues.
Ah I see, thanks a lot for the help 
&gt; I don't want to speak for anyone, but pretty sure most here would love to discuss issues beyond the how to get scanf working variety. Give it a shot! YES. I've been writing C for a long time now and I think that I've used scanf maybe a handful of times. Most of my work is embedded, though.
No blog spam please.
Please put four blanks in front of every line of code for your code to be formatted correctly.
Now, it's fine ?
Nope. Four blanks in front of every line of code. That's what you need to do.
Sorry I am new. I thought sharing basic resources would not be counted as spam. This post only contained links to C codes. Is it still a spam? just asking not arguing though
From my side, it's look perfect. I give lots of spaces for better experience.
but we can't easily read it...
The point is, your post is not useful as a resource. This is an uncommented, incorrectly implemented version of a very common introductory programming exercise. It's not useful for anybody to learn from (if at all, it teaches people how to make the same mistakes you made). Your title suggests that you want other people to copy your code. This is not something beginners should do, especially not if the code is wrong. That said, it is fine if you just want to post your solutions to programming exercises or your own software project. But then you should make sure not to claim that they are meant to be resources for other beginners. If you want to post a resource, it must be correct and good enough for others to actually learn something from it.
Reddit has a formatting option to format code as code. That is, the code is formatted in a monospaced font and all whitespace is preserved as typed. This is achieved by putting four blanks in front of every line of code. If you use the new reddit site with its visual editor, you might want to highlight your code and then press the `&lt;/&gt;` button to apply this formatting instead.
On which device, you are seeing it. I don't know about PC / laptop but in mobiles, it good. And guys, I post this code from my mobile. So, I can't tell about PC, how it is looking on PC. Don't know guys 
21st century C https://www.amazon.com/21st-Century-Tips-New-School/dp/1449327141
thanks, I should have properly thought about the points. In future, will not "spam" unwantedly. Also, just wanted to ask, I have only uploaded successful codes after getting checked by my instructor, not sure about wrong code thing. Still, I will remember all the points. Thanks.
Actually, I m new at reddit. Can you help me, how to post my code in code format in Reddit. 
The main mistake is that you use `int` instead of `size_t` for indices. This causes your code to fail if the arrays are sufficiently large. Also, you might want to format your code as code for easier reading. Right now, the code is very hard to read as it's not in a mono spaced font and as there is no syntax highlighting at all.
Two options: The preferred option is to select “switch to markdown.” Then take each line of code and put four blanks in front of it. This causes your code to be formatted as code. You also need to put a blank line between code and surrounding text. Alternatively, you can use the fancypants editor. Select the code, then click “...” and click “code block” (the T in a square symbol) to format your code as code. You can edit your original post to correct its formatting. &amp;#x200B;
But if he ask to put a “default: “ in my makefile where i have to add it? because I do have all: in my makefile but not default: 🤔
I love this sub so much pure joy doing embedded systems
Sounds like Algorithms and Data Structures by Sedgwick, my favorite C book so far
you make it sound so simple, I'm using the "new" design and I find code formatting very hit and miss using the fancypants editor, just plain don't work, I'll have to try without sometime... void main() { print("hello"); }
Yeah you pressed “format inline code,” not “format code block.” The second one is hidden in the “...” menu. Very poor UI design if you ask me.
Dang - got it correct in the text description but not the code example. Thanks for catching that.
As a result of decades worth of accumulated technical debt, the C language has diverged into a number of dialects, some of which cannot support all of the things that programs may be called upon to do, and some of which cannot be processed particularly efficiently. Any useful resolution of this problem will require recognition of such divergence. There is no way a single set of rules could simultaneously allow all of the optimizations that may be useful in programs that don't require low-level memory semantics, while allowing existing programs that require low-level memory semantics to do what needs to be done. The needs of future programs and implementations could be handled by defining intrinsics with semantics that would use release/acquire semantics to limit reordering. Few programs need to access storage with multiple *simultaneously-active* references that have no visible relationship between them. It's far more common for programs to produce a reference D using some other reference, access the object exclusively for the new reference, and then abandon that new reference before the next time code accessed or addressed the storage via any reference not based on D, or enters a function or bona fide loop wherein that occurs. If such intrinsics existed, code which relied upon ordering of actions on different lvalues *without marking such reliance* could be deprecated in favor of code which either marks such reliance precisely, or indicates e.g. "future actions involving some particular pointer must occur after any preceding actions involving any object, whether or not the compiler can see any relationship". Such a directive wasn't included in C89 because implementations whose customers would need such semantics provided them whether or not they were explicitly compelled to do so, and those whose customers wouldn't need such semantics would never be asked to do so even if such intrinsics were available. Consequently, any approach based upon adding such intrinsics would also need to deal with how implementations should handle code that doesn't yet contain them. If the Standard were to recognize three sets of rules, and a means by which programs could indicate which set of rules they needed, their *combined* complexity could be far less than would be required for any single set of rules that could satisfy everyone's needs. Rule #1: Maximum optimization -- No byte of storage which has ever been accessed using any type may be accessed by any other within its lifetime, except that struct and union members may be accessed using member-access lvalues, and in cases where intrinsics are used to demand the necessary semantic guarantees. For programs that don't need anything beyond these semantics, this would allow maximum optimization while eliminating the need for compilers to worry about the possibility of actions changing the Effective Type associated with regions of storage. Rule #2: Precise memory semantics -- All accesses made to all objects will be performed using loads and stores in execution order. Rule #3: Evidence-based semantics -- A compiler may assume that if a region of storage is accessed twice via some lvalue, and there is no evidence of any action between those accesses would suggest that the storage might be observed or affected via other means, it may consolidate those accesses. For purposes of this rule, a compiler may also, at its leisure, insert dummy accesses at the beginning and/or end of each function or bona fide loop, and consolidate other accesses with those if there are no intervening operations that could conflict. If programs indicate what kinds of constructs they would need to have treated as evidence (e.g. whether if a `void*` is converted to `char*` and write-dereferenced, should that be considered evidence of access to objects which have been accessed between the formation of the `void*` and its conversion to the `char*`). implementations that can't recognize some particular kind of evidence could handle the program by behaving as though the programmer had specified rule #2. Rule #3 wouldn't allow as many optimizations as #1, but would generally allow many more than #2. Designing new code for compatibility with either compilers that use #1 and support the new intrinsics, or those which use #2 and could simply ignore the new intrinsics, may be preferable to designing new code around #3. Approach #3, however, would allow a lot of existing code to be processed more efficiently than would be possible if approach #2 were the only option. 
Look at this line again: if ( (strcmp(input, terminate) != 0) ) // exits loop if input is equal to "-1" 
At a glance, you've got the condition with the strcmp backwards. There may also be whitespace (particularly a newline, maybe, it's been a while) trailing the input. 
Many implementations, at least historically, would provide useful pointer semantics beyond those required by the Standard, by performing pointer arithmetic in such a fashion that if `p` and `q` identified pointers to different parts of an object or region of storage within its lifetime, evaluation of `p-q`, `p&gt;q`, etc. would yield values that would be unaffected by the lifetime of the storage identified thereby. Such a guarantee would allow code that knew the whereabouts of every pointer `p` that had been in block `oldLoc` but whose content was now at `newLoc`, to compute the new address as `((char*)p-(char*)oldLoc) + (char*)newLoc`. Note that this would work even on platforms (like 8086 large model) where `(char*)newLoc - (char*)oldLoc` might not be computable. Unfortunately, the Standard has never provided a means by which a program can test whether an implementation supports that "popular extension". 
I see! I changed it to: `if ( (strcmp(input, terminate) != 0) ) // exits loop if input is equal to "-1"` but now I have the opposite behavior - it keeps taking input even if I enter -1.
I think the hint you need is: "what value does strcmp return when its' arguments are equal?"
A previous commenter told me to take a look at those lines again, and I believe I fixed them. The logic now is: `if ( (strcmp(input, terminate) == 0) ) // exits loop if input is equal to "-1"` but now I have the opposite behavior - it keeps taking input even if I enter -1.
Thank you for taking the time to reply, it is very much appreciated :) I've starred your code on github. It'll help a lot to have something to keep referring to, especially as your code is nicely laid out. I'm going to get that book too, it seems very approachable compare to, say, the ol' dragon book. Thanks again!
input == "-1\n\0" terminate == "-1\0"
Oh snap. Great point. Tbh, not even sure what a debugger is/how to use one.
If you take a look at the first paragraph of how fgets works at cppreference.com, you'll see that Florida_Owl is totally correct.
In short a debugger will preserve references to the original human readable source code in the machine-readable binary. That means you can step through the execution of your program and stop it at any point for which those references exist (meaning, if you compile with this option enabled your code will have that ability; however, if you are calling functions from an external library they may or may not. As for which one, it depends. If you are using an IDE (e.g. something like codeblocks or visual basic), then the debugging is something that would be handled through that program, just like compilation. Check your documentation. If you are using the command line to compile (e.g. gcc), then you will need to set the flag that indicates you want to compile with the debugging symbols (the "references" I mentioned). and then use an external debugging program. For people that compile on the command line, gdb is a common debugging command line utility. Using things like these is a skill in and of itself, so there's no time like the present to start practicing. I'm sure there are a ton of tutorials out there with a little googling.
There were times when I felt annoyed and just blank of thoughts. However giving it a long try, I realised that there is always way somehow. It was a long process. Trying to figure the math bit, then trying to overcome different problems such as an alternative version of absolute values. It was worth my time because it kept me thinking how I could use c simpler. And it allowed me to use c that I would have never thought of. I also learned there was an easier way. Basically coding challenge questions helped me expand my way of thinking.
unsure if resolved, but check your fgets. your -1 input might have extra stuff on it.
Echoing what others have said: Read K&amp;R, of course, but then immediately read *[21st Century C](https://smile.amazon.com/21st-Century-Tips-New-School/dp/1491903899/)* by Ben Klemens. Unsolicited advice for new C developers (who, like yourself, are not new to software development in general): To really get going, you're going to want to do some further reading on whatever toolchain you're using. This generally won't be a book (they exist but are often out of date the day they're released) but the documentation that the toolchain provides. You can skip at least some of this with an IDE if that's your thing, [CLion](https://www.jetbrains.com/clion) and [Code:Blocks](http://www.codeblocks.org) are both nice, the former is kind of spendy, the latter is open source. I don't super love working in IDEs. I don't trust anything without a command line interface. That's a personal preference, though, and don't let anyone tell you modern IDEs (like CLion or Code::Blocks) are crap, because they're actually great. If you're using Linux, you get pretty much all the standard stuff with your distro, including the compiler, build tools, a debugger, etc. If you're using Windows, it's a bit hairier. You _can_ use MSVC, but the C compiler is not even fully C99 compliant. They really only implemented the parts of the C99 standard required to support the C++ compiler, which is the part they care about. I use MinGW under Cygwin, which is pretty nice once you get it set up. Setting it up is a bit of a pain if you've never done it before. You've also got a ton of options for build tools, all of which come with trade-offs. Make works great for smaller projects, but can get unwieldy pretty quickly. For this reason there are tools that _generate_ makefiles that you then call make on, the most widely used of which is Autotools. If you want to contribute to open source, this one is important. CMake has a lot of adoption in the C++ community, and works well for C projects once you get it going, but I thought it was a bit of a bear to set up. Like I said, though, there are lots and lots of options, but you'll need to roughly understand some build tool before you can really work on a C project of any size, your own or someone else's. Personally I like [Scons](https://scons.org), which I use for my own projects, but I haven't seen too many major open source efforts using it, the main exception being [Godot](https://godotengine.org/) Hope that helps get you started! Good luck and be sure to ask questions in here, people are really very helpful!
The loop condition is redundant since you perform the same test earlier and `break` out if the test passes. Also you make a mistake by not checking the return value of `fgets` and not checking for overflowing your array. A better loop structure would be: for (k = 0; k &lt; MAX_WORDS; ++k) { if ( ! fgets(input, MAX_CHARACTERS, stdin) ) break; if ( strcmp.... ) break; strcpy(input_words[k], input); } 
From the point of view of the Standard, a function like: int *test(int mode) { if (mode) return 0; return &amp;mode; } would have well-defined behavior if invoked with `mode!=0`. Given that the One Program Rule would allow an implementation to behave in essentially arbitrary fashion in response to almost any source text if some possibly-contrived "translation limit" is violated, I think the Standard should give implementations broad latitude to reject conforming programs based on any criterion the designer things would identify programs that would not be processed usefully. An implementation that rejected most programs for no reason might not be very useful, but that should be a Quality of Implementation issue rather than a conformance one. As it is, however, I think the clear intention of the Standard is that a quality implementation should process `test` above so it returns a null pointer without side effects if `mode` is non-zero.
Only fprintf(stderr, ...) if a compile time flag is given (or runtime, depending on how much you care about the extra binary size from the constant strings or whatever). But in either case, one of the other approaches is required in addition. Either returning a code, `struct { code, message }`, or a `mylibGetLastError()` function which returns one of those is fine, although in the `mylibGetLastError` case, you need to be sure to use thread local storage to store what the last error is, in order to avoid data races. 
This depends on how complicated the error could be and how many varieties of error I need to deal with. If there are multiple ways that the function could fail, but they're all standard errors that `errno` can deal with, I'll return a success or failure case and on failure, the caller can check `errno`. If there are multiple ways that the function could fail, but I can't rely on `errno`, I'll return either an int corresponding to different error codes, or, if my needs are especially complex, write a struct to the caller's stack (I don't like returning structs because I don't want anything copied unless it actually needs to be) that contains information about the results.
 void main() { print("hello"); } oh the penny drops...
It really depends on the nature of the error and the nature of how you expect the function to be used -- there's no universal answer. Is the error due to user input? Then messaging and re-prompt is good. Is the error due to a system call failing? Check `errno` and handle appropriately. Can your application recover from the error? Then log to `stderr`, handle it gracefully and move on. Its the error unrecoverable? Log the error, and exit with a non-zero status. If you provide some examples (either code or use-cases), we can elaborate further.
Thanks for the response! I'm not so much looking for a specific answer, I just wanted to spark a discussion about the relative merits of each approach.
Thanks for this! 
Another more extensive option is to take an error handler callback somehow (often via struct) that lets the caller specify how to deal with things. This works well for recoverable errors, and it’s usually fairly easy to come up with a few predefined “constant” callbacks for common cases (e.g., just `fprintf` to `stderr` and terminate abnnormally). It also works well when you have warnings or notices that *could* be treated as errors but needn’t necessarily, or that might need to be logged specially somehow.
One of the early projects I worked had an environment variable "env" for every function. So function calling would look like: int ret = do\_something(env, &lt;-inputs-&gt;, &lt;-outputs-&gt;) There were macros like env\_func\_in(env) and env\_func\_out(env) to be put when you enter and leave a function. Even malloc would look like env\_malloc(env, size). env-&gt;status (same as ret) and env-&gt;msg carried info on errors. All in all, it worked well for communicating errors, with optional stack trace.
Logging.
In the largest project I've developed, every function returns 0 on success, error code on error, and takes a logger as first argument. Almost all calls are checked with a `goto exit` on error where the exit block does memory clean-up before returning the error code.
Doesn't the code get very bloated if you have to pass the logger around like this in *every* function?
It's no worse than the "this" that you have in many OO approaches. You get used to it.
The first thing I think about is that the function needs to report some information about the error, or only if it worked or not, or if it can actually fail. We use custom return codes, nicely encoded to differentiate between success/informational values and errors. We also have a logging mechanism that provides a pseudo stack-trace, with file and line number information saved in the logs, so we can nicely track the error to where it first appeared. &amp;#x200B; Most people just go and use this system for every function. But a lot of the time I see functions that never fail (always return success). In this case why not make it a \`void\`? If the function returns a pointer, \`NULL\` is almost always a good choice, unless you care about why it was not able to return a valid pointer. And if the fail reason is not important I feel like a \`bool\` return value is better and easier to reason about. &amp;#x200B; I don't like to return structs. It always feel like it is not the optimal choice. 
Yes, I am well aware.
I suppose I have four favorite/preferred ways: * Operate on data passed either by value or by reference and return a `bool` value `true` or `false` indicating success or failure, respectively. (I use `&lt;stdbool.h&gt;` to define `bool`.) If I need to return data to the caller, I do it via a pointer that must be passed in. * Operate on a structure passed by value and return a structure with no error information. (Sometimes, by nature, a function simply cannot fail — for example, a function that adds two vectors and returns the vector sum, or interpolates between two RGB colors.) * Operate on data passed by value or reference and return a pointer to new, dynamically allocated data, with `NULL` indicating failure. This isn't my favorite method and I don't do it often. But sometimes it fits the need best. * On rare occasions, when returning a value that is inherently an unsigned integer, but the function can fail, I'll return 0 or –1 to indicate failure (the latter requring a signed return value). An example would be a string formatting function similar to `printf()` where I want to return the number of characters written, but where a syntax error in the formatting string results in an error.
write(stderr, "Shit's Fucked, Yo!\n"); abort(); Clean, simple, direct :D (Note to any CS students: Don't actually do this except in cases like memory management has failed where you have no reasonable hope of recovering).
&gt; If code may be processing untrustworthy input, it might be useful to replace strlen with a call to strnlen which forces an abnormal program termination if the length exceeds INT_MAX/2, since practical strings shouldn't be that long, and imposing such a limit would make integer overflows unlikely. Or you know...you could just use the appropriate integer type instead of coming up with weird workarounds in order to "safely" implicitly down cast an integer variable. Yes, it would be weird to find a string size_t characters long, but doing weird shit like what you described is how you end up with unreadable crap code. The man page for strnlen() has this to say: &gt; The strnlen() function returns strlen(s), if that is less than maxlen, or maxlen if there is no null terminating ('\0') among the first maxlen characters pointed to by s. Which to me says there is no way to detect whether the string is strlen() &gt; maxlen or put another way, no way to detect a string that is too long and exit unsuccessfully with a friendly error message. That coupled with the fact that strnlen() is not part of the C standard library but is POSIX only would suggest one would be better off writing their own implementation which is able to hold a string maxlen + 1 code points long and return a negative value (perhaps as int64_t) if str + maxlen + 1 != '\0' assuming '\0' has not been found yet.
&gt; Do you mean using a static variable so that lex can retain some kind of counter (say, retain the value of i) between calls, to pick up where it left off? Exactly. 
&gt; but is not thread safe /u/dys_bigwig this is definitely something to be aware of. However, unless you are a very very special snowflake, implementing a multithreaded LL or LR parser is just way more complexity than you really need. IIRC, gcc (and all other compilers as far as I'm aware) uses multiprocessing via fork() to parallelize builds. This means each compilation unit is handled by what is effectively an isolated instance of the parser.
I'd be hard-pressed to imagine circumstances where it would be appropriate for code to work with strings that are even a million characters long without knowing how long they are. I don't think any program that's designed to work efficiently with billion-character strings would ever try to call `strlen` on them; if strnlen can't find a zero byte within the first billion characters, that would be a pretty strong indication that the program isn't likely to behave very usefully. As for detecting the "zero-byte-not-found" scenario, given `int len = strnlen(s, n);`, the value of `s[len]` will be zero if the length of the string is in fact `len`, and non-zero if the source string was longer. That's an easy scenario to handle unlike the badly-designed fgets which provides no indication of how much data was actually read. 
I think the authors miss the most important source of contention: not only does the C Standard lack the precision necessary to construct a "test oracle", but it's not *designed* to fully describe all of the semantics that should be provided by implementations claiming to be suitable for any particular purpose. According to the published Rationale, the Committee wanted to encourage variety among implementations, with different implementations supporting different features and guarantees--presumably chosen according to their customers' needs. Rather than worrying about nitty gritty details about things like bitwise manipulations on integer-cast pointers, it would seem more useful to focus on a couple of key questions: 1. What semantics do programmers need in order to "do what needs to be done". 2. What freedoms to implementations require in order to generate efficient code. If one assumes a basic execution model where the state of each object `O` is encapsulated in `CHAR_BIT * sizeof O` consecutive bits of storage, stored in ascending addresses starting at `&amp;O`, the primary freedom implementations need is the ability to reorder and consolidate accesses to unrelated regions of storage in cases where such reordering would not affect behavior in ways that would matter. The primary semantic feature programmers need is the a means of ensuring that certain operations *not* get reordered in cases where such reordering *would* affect behavior in ways that would matter. There is no reason these needs should conflict, save for the lack of standard ways of indicating happens-before relationships beyond those a compiler might infer for itself. There are many programs that use integer-to-pointer casts, but not for anything "weird". There are many programs whose performance would be relatively unaffected by having compilers make pessimistic assumptions about what may be aliased by any pointer that is freshly formed from an integer-to-pointer cast. There are even many programs that have both properties. There are, by comparison, relatively few programs where some integer to pointer casts are used to do "weird" things, but pessimistically assuming that they all might be used in such fashion would materially degrade performance. Trying to formulate rules for which kinds of weird pointer manipulation a compiler should recognize would seem less more complicated but less useful than simply having a means of indicating whether or not a program would require a compiler treat integer-to-pointer casts pessimistically, and/or indicating places when certain operations must not be reordered with respect to certain others. 
&gt; that would be a pretty strong indication that the program isn't likely to behave very usefully Its not about runtime behavior per se but about the combination of runtime behavior _and_ maintainability of the code.
Just add this to your Makefile: ``` default: all ``` Teachers are rarely infallible.
More information at [https://en.wikipedia.org/wiki/Call\_stack](https://en.wikipedia.org/wiki/Call_stack)
Learning to use a debugger can turn a 4 hour "add printfs, then make a theory about whats broken up, and try something to fix it" into a 2 minute "step, step, step (holds mouse over variable) 'OH duh. That's wrong. I'm a fucking moron."
welcome! programs may have minor discrepancies, so check out for that
Re the 2nd question, instead of preallocating each input\_words member, consider allocating them as needed. strdup is nice, though not in standard. Easy to roll your own, strlen malloc strcpy. For the array itself, just shrink it to size afterwards, with realloc. Or, grow it as needed as k gets bigger, realloc again.
I just use assert
I checked on my pc, it's looking good. 
Think about using a while loop so you can keep sorting/swapping until you are certain that the numbers are in the correct order while( not\_in\_order ) { ....do sorting... }
Largest number gets moved into position by two first comparisons, so the last comparison never does anything.
Assuming 'a' is an array/pointer and 'i' is an index, use `i[a]` for all array indexing to really piss off your professor.
you madman
Damn, that is pretty nice, thanks! I will give it a try!
syslog() or similar can be appropriate for some types of programs. If there is an automatic alert, the person sitting on a phone can answer "working on it" or even "fixed it already".
Did some quick coding, there can be a faster method + maybe need to add some error handling &amp;#x200B; #include &lt;stdio.h&gt; #define SIZE 5 int main(void) { int array[SIZE]; int ret = 0; int biggestValue = 0; for (int i = 0; i &lt; SIZE; i++) { printf("Insert number:\n\t"); scanf("%d", &amp;array[i]); } printf("Inserted numbers: \n\t"); for (int i = 0; i &lt; SIZE; i++) { printf("%d ", array[i]); } printf("\n"); for (int i = 0; i &lt; SIZE-1; i++) { for (int j = 1; j &lt; SIZE; j++) { if (array[j] &lt; array[j-1]) { int temp = array[j]; array[j] = array[j-1]; array[j-1] = temp; } } } printf("Ordered numbers: \n\t"); for (int i = 0; i &lt; SIZE; i++) { printf("%d ", array[i]); } printf("\n"); return 0; } &amp;#x200B;
Maybe try to add a theme to every program you write. When I was in university learning to program PLC's, we always try to implement a police signal/siren (in our case white and blue leds flickering). Also if it is completely irrelevant, just keep doing it. 
Wouldn't making the logger global also help? Seems like a good reason to do so, or what prevented you from doing so?
Are you in the [same class](https://www.reddit.com/r/C_Programming/comments/awnwmi/i_dont_100_understand_this_lab_exercise_can/) as /u/meteorah? 
You could have a signature pattern of spaces and tabs at the ends of the first few lines of each of your source files.
Rofl. Probs in same uni and year
One second, looking it up... &amp;#x200B; Ah, here we are: David R. Hanson - C Interfaces and Implementations.
Stick your name at the top.
Yeah, I try to have a uniform way of writing my code, I am also trying to find completely useless stuff for the programm to do as you said! Thanks! &amp;#x200B;
I might give it a shot, thanks!
If I read the rules correctly you are allowed to use the ternary operator, so making a `MAX()` that way is easy, although I doubt they have that in mind...
Nope, no ternary operator AFAIK.
Consistently submit the best-written and implemented solutions to exercises posed by your professor/instructor. Might be hard to do, but you **will** get noticed.
I've noticed that K&amp;R are teaching C89 (?) In programs they present there is main() instead of int main() Isn't that outdated? 
woops, I missed the last paragraph.
Good luck with your homework!
I don't think anyone has done this yet.
What's the point in this answer? The OP even asks how you do your logging. Given that you've written a UTF-8 library before, could you give us an example of how you output and configured the log messages in that?
// We're going to be sneaky and exploit a for loop as an if int i0=scanf(); int i1=scanf(); int i2=scanf(); for(i0=i0; i0&lt;i1;){ // Now we know i0 is &lt; i1 for(i1=i1; i1&lt;i2;){ // Now we know i1 is &lt; i2 printf("i1="+i1); printf("i2="+i2); printf("i3="+i3); } } // You do the rest ;)
You can't use loops.
No cannot use any kind of loops and not even for loops. &amp;#x200B;
Can i see the code you wrote please? i'm still struggling.
Thankfully, being noticed is not an issue, I am one of the best students in the class and actually the professor reviews my work individually most of the times and asks me if I have any questions during class. I am just looking for a way to add random gimmicks in my code to mess with her and make the class a bit more fun! Thank you very much for the answer!
No.
Guess I'll die...
if you want homework help you'll need to show your work first. 
Yes and I should have made a caveat that the standard has evolved with some major enhancements in C99 and again in C11. I usually do not advise beginners to use this book to learn from. The OP was an experienced programmer and K&amp;R is an excellent introduction to the language for experienced programmers. I should have pointed OP to the C standard or even the wikipages for [C99](https://en.wikipedia.org/wiki/C99) and [C11](https://en.wikipedia.org/wiki/C11_(C_standard_revision)) Thank you.
int i0=scanf(); int i1=scanf(); int i2=scanf(); printf("smallest=%i", ( (i0&gt;i1&amp;&amp;i0&gt;i2)*i0) + ( (i1&gt;i2&amp;&amp;i1&gt;i0)*i1) + ( (i2&gt;i1&amp;&amp;i2&gt;i0)*i2) ); etc...
Try using ++i instead of i++, not only more cache efficient, but for some reason everyone uses i++.
Two other people from your class asked the same question yesterday. Perhaps look at their threads?
Go-to statements allow you to make your own flow control. So you could do you own subtractions and jump to different labels based on the result. 
Please don't [repost your questions](https://www.reddit.com/r/C_Programming/comments/axkql9/how_can_i_output_3_integers_in_ascending_order/). If you made an error in your post, click “edit” to fix it. Do not make another post.
I think i got what you wrote but can you like elaborate more. &amp;#x200B;
I've never seen this exercise in a class on C. 
Wow
This assignment is not a programming question, it is a mathematical puzzle and not meant for dumb people like me.
You test each variable to see if it's the 1) lowest, which will evaluate to 1 in C. So you multiply that by the number. You'll get 0+0+number Then do for Middle, then for highest.
Why would anyone get pissed off by this? It's just pointer arithmetic.
Now that you've solved this, here is my solution: #define INT_BIT (sizeof (int) * CHAR_BIT) #define MAX(x, y) ((x) - (y) - 1 &gt;&gt; INT_BIT &amp; y | (y) - (x) - 1 &gt;&gt; INT_BIT &amp; x) #define MIN(x, y) ((x) - (y) - 1 &gt;&gt; INT_BIT &amp; x | (x) - (y) - 1 &gt;&gt; INT_BIT &amp; y) #define MAX3(x, y, z) MAX(MAX((x), (y)), (z)) #define MIN3(x, y, z) MIN(MIN((x), (y)), (z)) extern int main(void) { int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); printf("%d\n%d\n%d\n", MIN3(a, b, c), a + b + c - MIN3(a, b, c) - MAX3(a, b, c), MAX3(a, b, c)); }
Would really like if you added some more comments on how you are doing your math.
So you can copy the solution [for your own submission](https://www.reddit.com/r/C_Programming/comments/axkql9/how_can_i_output_3_integers_in_ascending_order/)?
What is this exercise even supposed to teach? Finding loopholes? My first thought was a nested switch.
as seattlefunk points out, the last printf misses the variables, it should be `printf("%d,%d and %d",first,second,third);` But its better to write one swap function and then input first,second once and then second, third after that. That will create a neat code. Also, you can want to check that taking integers you limit your code to taking integers up to 10^(6) . &amp;#x200B;
They didn't say it had to be portable, right? Linux x86_64: #include &lt;stdio.h&gt; int main( void ) { int a=0, b=0, c=0; scanf( "%d %d %d", &amp;a, &amp;b, &amp;c ); __asm( "movl %%edi, %%eax\n\t" "cmpl %%esi, %%edi\n\t" "movl %%esi, %%edi\n\t" "cmovgel %%eax, %%edi\n\t" "cmovgl %%esi, %%eax\n\t" "cmpl %%edx, %%eax\n\t" "movl %%edx, %%r8d\n\t" "cmovgel %%eax, %%r8d\n\t" "cmovgl %%edx, %%eax\n\t" "cmpl %%r8d, %%edi\n\t" "movl %%r8d, %%ecx\n\t" "cmovgel %%edi, %%ecx\n\t" "cmovlel %%edi, %%r8d\n\t" "movl $.scanf_format, %%edi\n\t" "movl %%eax, %%esi\n\t" "movl %%r8d, %%edx\n\t" "xorl %%eax, %%eax\n\t" "callq printf\n\t" "mov $60, %%eax\n\t" "syscall\n\t" ".scanf_format:\n\t" ".asciz \"%%d %%d %%d\\n\"" : : "D"(a), "S"(b), "d"(c) ); } 
Hahahaha holy shit, that cracked me up :x
&gt; not only more cache efficient This is a myth. If it doesn't matter whether it's pre-increment or post-increment, under optimization a compiler will produce the same code regardless. It it does matter, the result is already in a register ready for use. You could potentially make an argument about register pressure, but even that's unlikely to be the case.
This is tangentially related, but I figured I'd toss it here. I'm one of the weirdos who bounces between hardware and software work, and a lot of my stuff is in FPGA land. When in the midst of developing stuff, things in FPGAs can get hairy fast (I was bricking a softcore just last week). When I hit really annoying states like this, I'll often do the very ugly thing of tying a signal related to the bricking (like a trap or exception signal) to an LED so I can sort of infer the state a bit better. Then messing around with the code a bit can get that one signal to alter a bit, and bugs can normally be worked out pretty easily. NB: I would never ship something like this! This is development style feedback for systems where extracting info can be really really painful
I like you, this is a special kind of loophole
It would throw me for a loop because the syntax is super underused. Probably wouldn't piss me off though. I'd just adjust it to a more typical syntax and recommit it cause weird but correct will probably cause issues down the road.
For the usual reasons (modularity, threads, testing, clarity etc) I avoid global station in my code wherever possible. In this case it may have been OK - I can't find a good reason not to - and I have been considering making it global in a new project I am working on. But as I said in another reply it's the return code testing and associated error handling ( memory management) that had a larger impact. A log argument (almost) everywhere soon becomes easy to ignore.
When working with numeric quantities, rather than bags of bits or algebraic rings, the semantics of signed values are generally more useful than those of unsigned types (though the behavior of promotion rules with `sizeof` may cause unwanted "unsigned" behaviors regardless). Unsigned quantities can represent values that are twice as big, but that advantage is only meaningful in cases where values may get too large to fit in signed type but would never get too big to fit in an unsigned type. Historically, making `sizeof` unsigned allowed it to efficiently accommodate systems like "large model 8086" where it would be common for objects to exceed 32767 bytes, but none could exceed 65,535 bytes. Outside of that narrow *but important* use case, `sizeof` could and probably would have been kept signed as it had been in many pre-Standard dialects.
Nice that you got the solution. But can you please explain the math you have done, its confusing how you calculate highest number. Well done for your solution though.
Usually I have two different types of functions: 1) as you said if the function returns data a NULL return means error 2) Otherwise, I create an enum type for all of the different possible errors, and us that as the return type. This way I can get more detailed error information on return.
 printf("%d", (a&gt;b &amp;&amp; a&gt;c)\*a + (b&gt;a &amp;&amp; b&gt;c)\*b + (c&gt;b &amp;&amp; c&gt;a)\*c);
It's a big subject, but errno.h is a pretty standard way to handle errors. To exchange data based on the error one can always return the error/success code and store the data in an out param.
I don't have it anymore, but it was literally just the code you posted, just correcting the isdigit() comparison and correcting the argv type. What problem are you currently having? Are you getting a compilation error? A compiler warning? An error at runtime? My general advice would be rather than try to solve your entire program at once, work separately on each individual unit until it is correct, then combine them at the end. Stepping line by line through your code with a debugger will help immensely in identifying problem spots (and often the reasons for those problems).
Start having some fun with the processor. On of my friends had to do essentially what was an "intro to C" class, even though he knew a good amount about the language already. For the first assignment he did things like this: ``` #define BEGIN { #define END } #define MSG(x) printf(x) void MyFunction() BEGIN MSG("Hi Mom!); END ``` I'm sure your graders and professors will have a lot of fun.
&gt;This gives output 0.
Btw can you make the algorithm to print the middle number?
I got smallest and the biggest numbers, but can you make the algorithm to print the middle number?
You're using `i` to index both arrays. What happens when you increment `i` to jump over a space in the source array?
We need more information. What types and sizes are these arrays? How are they defined? Where does the "sentence" array come from? Is 'i' initialized? What is your error or errors you are experiencing. Right away I can see you are using 'i' wrong by incrementing for navigating two different arrays in different patterns (assuming "has the sentence" contains spaces. 
you have to initialize a, b, c :) #include &lt;stdio.h&gt; int main() { int a = 3, b=1, c=2; printf("%d", (a&gt;b &amp;&amp; a&gt;c)*a + (b&gt;a &amp;&amp; b&gt;c)*b + (c&gt;b &amp;&amp; c&gt;a)*c); return 0; } prints 3
nope, you figure it out, the principle is the same, use the result of bool operation to either multiply something with 0 or 1.
When I was in uni, the majority of the professors used scripts to check your solution programs, and did not even look at your code. Besides, most likely, the only person you’re gonna piss off by your i[a] will be the professor’s TAs, coz these are the guys who grade homeworks :)
 The issue is that it removes the spaces but inserts another character: i is initialised. Here is the program: int main() { char arr[30]; fgets(arr,30,stdin); char copy[30]; int i=0; do { copy[i] = arr[i]; i++; if(arr[i] == ' ') { i++; continue;} } while (arr[i] != '\0'); printf("%s",copy); } &amp;#x200B;
Those definitions for `BEGIN` and `END` are boring and don't yield proper syntax anyway. More interesting would be #define BEGIN do{ #define END ;}while(0) #define IF if( #define THEN ) #define ELSE ;else #define PROCEDURE void #define BEGINPROC { #define ENDPROC ;} Then you can write code which is a bit more like it's supposed to be (though variable declarations still end up wrong, and it's necessary to use different words to mark procedure boundaries versus those used for statements. int MAGIC; PROCEDURE FOO(int I, int J) BEGINPROC IF I&gt;J THEN I=I+1 ELSE IF I&gt;J+2 THEN BEGIN J=J+1; I=I+3 END ELSE J=3; MAGIC = I+J ENDPROC Incidentally, while I think modern dialects of Pascal made it in many ways a better language than C [its variable declarations are way better, for example], and was sad to see it lose out, I prefer grammars that use terminators rather than separators. But if one's going to write Pascal in C, one should use Pascal-style statement-separator rules. 
It's not inserting anything. You are skipping elements in your copy array by double incrementing 'i' when you find a space in your arr array. When you define copy[30], all your machine is doing is setting aside a block of memory of that size for you to use. It has undefined values at each element until you put values there. Because you are using the same index ('i') to iterate over arr and copy you are skipping positions in copy and seeing the "garbage" values that the machine put there.
Thanks i figured out the smallest and largest, i just need algorithm for the middle one.
Along the same lines, name the variables annoying and hard to read things like r, rr, n, nn, m, foo, foobar, foofoo, foofooba, ...
To stand out you could try adding command line options to all your programs. \--help could actually be useful. \--version could print a quick synopsis of the lab/project and date of work. \--about that prints something about yourself.
I like to sign my comments, whoever looks at my stuff in the future should know exactly who wrote it.
Well, it'll just be a bit more complicated because you have to cover more cases, i.e. `a` can be middle when either a&lt;b and a&gt;c, or a&lt;c and a&gt;b... so total 6 cases, 2 for each variable. I believe you can do it.
When I find space if I don't increment the i then won't the program loop over the space only and not move on to the next character?
Recall that the sum of the three numbers is the same as the sum of the largest, middle, and smallest number. Now use that to find the middle number.
you can define the linked list as a type (see typedef syntax) and then in the struct definition of the library element, you can take student name as a character and the linked list as a type also. For understanding this type of approach, see how graph is defined in geeksforgeeks.
&gt; My first idea was to, within the structure for student, have a linked list along the lines of 'books_owned' I'd probably not do this, and instead have an array of pointers to each of the books owned, with a NULL pointer at the end so you can iterate over it without having to know how long it is.
Yes
Yes, but I think you misunderstood Florida_Owl : What he meant is that you are incrementing 'i', which is the counter for both arrays. But if you increment it for both, that means that while you skip this character in arr, you also skip this part in copy(where there are garbage values at this index position, because it was never initialized). What you should do, is use two different counters, so that when you skip an element in arr, the index for copy is not incremented. Btw did you try the code with spaces occuring consecutively?
That's funny, I was reading Expert C programming yesterday and he mentions a professor who did something similar to make it similar to Algol-68: #define STRING char * #define IF if( #define THEN ){ #define ELSE } else { #define FI ;} #define WHILE while ( #define DO ){ #define OD ;} #define INT int #define BEGIN { #define END } to write code like: INT compare(s1, s2) STRING s1; STRING s2; BEGIN WHILE *s1++ == *s2 DO IF *s2++ == 0 THEN return(0); FI OD return(*--s1 - *s2); END 
Hi, Another way to accomplish something like this in C is to walk through the string using pointers, instead of array indexes. Personally, I think using pointers is less confusing but I've been using C forever, so YYMV. I've created an annotated function to strip spaces from an input string in place, that will hopefully make sense to you. Disclaimer: I have not had any coffee yet 🙃 #include &lt;stdio.h&gt; #include &lt;string.h&gt; size_t removeSpaces(char *src) { /* I'm going to keep the do ... while since that's how * you set it up, but this means I need to make sure * the string has at least one byte in it */ if (*src == '\0') { return 0; } /* Set up a pointer to the beginning of our input string * this is going to be our 'read' position */ char *read = src; /* Set another pointer to the start of our input string * this is going to be our 'write' position */ char *write = src; /* Now the loop. We have two "position" variables. One * points to the next character to check for a space, * and the other is where we're going to write. */ do { /* If our read position does not contain a space, * write it to our current 'write' position, and * increment that write position. * * Note, that if it is a space, our write position * stays the same, and then the while(*read++) will * move the read position forward * */ if (*read != ' ') *write++ = *read; /* Loop until we're at the end of the string */ } while (*read++); /* This will just return the length of the return string * which can be useful in real programs */ return read - src; }
I am definitely trying this, even today, just to see what my professor says, I hope that the programme responsible for the correction of the code accepts this kind of answers. We write our code on an online platform that checks for syntax errors and assesses whether our code is functioning properly. I am going to draw inspiration from the people below for funny names and other stuff. Thanks!
I had a talk with my professor about the reasons we use C instead of programming languages like Python, Pascal or Java, and she explained that C is a very solid base to start on our field (Physics) because it makes the interpretation of problems with math very straightforward. A few years earlier they used to teach Fortran for the same reason, but nowadays Fortran is kind of obsolete.
I am familiar with styles of coding like this because of my own research (currently the class is in a very early stage, thus we stick to basic) and I will try to adapt my code in order to get a more advanced look.
I tried that too, but it seems a little too generic for my liking, I prefer to add useless lines of code just to make it irritating for others to read and make it a little more distinguishable. Thanks for the answer though! 
&gt; o I've managed to get all of it working. Thanks for the help tho. really appreciate it!
That sounds very interesting, and offers a lot of potential for planting gimmicks and other funny meaningless stuff, thank you very much for the answer!
If you really want to be evil, it might be worth taking a look at some of the entries from the international obfuscated C contests - https://www.ioccc.org/ 
Thanks, I am definitely checking this out, the goal is to make my code make my professor hit her head against the wall. Damn, she is going to murder me
I'm not sure if I understand your advice correctly, because wouldn't that require a maximum number of books you can own/rent? I get that you would not need to know how many books a student has and could just iterate over the array until you reach NULL, but what is the advantage? Being able to index directly instead of having to iterate through a list? Because my first thought was that depending on the size of the array this approach could need a bit more memory. 
A compiler that is making *any* reasonable effort at generating efficient code will observe if and how the result of an expression will be used before generating code for it, and will generate identical code for "pre-increment lvalue [result ignored]" and "post-increment lvalue [result ignored]". The logic here is essentially the same as the logic needed to make `if (x==y)` branch based on the equality, rather than having the `==` operator produce a 0 or 1 and then branching on that, and wouldn't generally be referred to as an "optimization". 
If you can freely choose your way, an option could be a directory tree for books and students, and temporary links back and forth when a book is on loan. books/978-0131103627/constant_info books/978-0131103627/loan -&gt; students/Zadorrak students/Zadorrak/books/978-0131103627 -&gt; books/978-0131103627
I know that speed can be important in automated trading, but you're competing against people who literally buy real estate as close to the market as possible (so the actual packets have a shorter round trip). I would not do something like this in C. A better choice is probably something like Python.
Where's your linked list going to be stored? That's going to need memory too. Also a real library is going to have a maximum number of books you can take out, so why don't you set one? You also wouldn't have to assign the memory to it all in one go, you could assign more each time a book is added. Each entry only needs to be as big as a pointer, with a linked list each one would be at least twice as big as you'd need a pointer to the book and a pointer to the next item in the list.
Indentation based on Fibonacci numbers looks really good compared to just using four spaces. Digraphs are two character sequences to represent symbols that may not be available on keyboards or some older character sets. Most C and C++ compilers from the last twenty years support them. %:include &lt;stdio.h&gt; int main() &lt;% printf("Hello World!"); return 0; %&gt; C compilers don't support things like unicode math symbols, but some may support accented letters in identifiers. They may be read as unaccented characters during compilation. Underscores can be used as a separator in identifiers. 
Plug for /r/algotrading. Anyway, this is something you can do in C, from your backtesting framework to your execution engine, risk management, etc. Though, it's only worth it if you need much lower latency than doing it with, say, python or some other high level language (and judging by the fact that you're asking this question, you don't). If your goal is to improve your C and do something neat in C, then you certainly can do algo trading in C. If your goal is to do algorithmic and automatic trading, then python is a great choice since it has numpy, pandas, scipy, and a bunch of already written back testing and execution engines, which is cut down the amount of work greatly.
Thank you very much, I am going to incorporate such characters in my code for sure! Except for that, I think it is a pretty nice fact to know!
There is no language called C/C++. Which of C and C++ do you want to program in?
You can try with tree rather than linked list. &amp;#x200B; Tree is struct with two Node pointers, one is next brother, second is first child.
Modern Fortran is a better fit for many tasks, including high-end number crunching, than C, despite the fact that some compiler vendors try to twist C into something very different from the language the C Standard was written to describe. What made C successful was that in the days before the first Standard, and about 1-2 decades afterward, it was recognized not so much as a single language but rather a recipe for producing dialects which used a common syntax, but had semantics that were tailored for different platforms and purposes. The C Standard was, at the time, recognized not as fully specifying everything a programmer should expect from an implementation, but rather as a "common core" which quality implementations should augment in a fashion appropriate to their target platforms and purposes. Since people writing compilers would know more about their customer's needs than the Committee could hope to have, the Committee gave compiler writers the discretion to augment the basic language as much or as little as they saw fit. Sometime around 2005, however, some compiler writers got the silly idea that the only programs they should be interested in are those whose behavior is fully mandated by the Standard, and this idea seems to have become very fashionable. This leads to compilers making rather brilliant "optimizations". For example, a 32-bit gcc, if given a function like: unsigned mul(unsigned short x, unsigned short y) { return x*y; } invoked as `mul(i, 65535);`, may infer that `i` can't possibly be greater than 32768 because that would cause `x*y` to overflow. This may cause weird side-effects on the calling code. The language the C Standard was written to describe was very useful. The language the authors of gcc and clang want to process, not so much. Unfortunately, I don't know any retronym to describe the former. 
yes you can, you will have several modules... a.- to get the data, save to disk and fill the gaps b.- read data from disk and apply algos c.- algos d.- backtesting e.- real work f.- portfolio management
&gt;Where's your linked list going to be stored? That's going to need memory too. That is of course correct. I guess what i meant is, that if used in a real environment (or at least with data close to that) my prediction based on observation would be that this approach would use more memory than a linked list. Please let me explain my train of thought. *The libraries i used in my life (public and university) had a rather high amount of users (or at least cardholders) that did not rent a lot of books (except during finals and even then always only the same books). *Both had a rather large number of books you were allowed to rent. *If one uses a system where every structure for a student is initialized with an array of that size, then most of that memory would never be needed. With this in mind i thought it to be smarter to use a linked list, because even if you need twice as much memory for a single entry compared to an array: This advantage of an array would only be useful if every student at the same time rented at least half the amount of allowed books. The chances of this occuring are rather small. &gt;Also a real library is going to have a maximum number of books you can take out, so why don't you set one? A valid argument, but you can set a maximum number with a linked list, too. One could use a variable in the student struct, to keep track of this (and increment it every time a book is rented and decrement it when it is given back), or when one tries to rent a book, that the number of books is counted while iterating over the list. &gt;You also wouldn't have to assign the memory to it all in one go, you could assign more each time a book is added. Each entry only needs to be as big as a pointer, with a linked list each one would be at least twice as big as you'd need a pointer to the book and a pointer to the next item in the list. Ok, with a dynamic array i could see if you chose the initial size of the array small enough, that this would indeed need less memory. I did not think of that, thanks.
That is extremely interesting, a lot of useful information, I will research the topic myself too!
The easiest way I think is to declare a List type for each element of the book list. When you declare a typedef'd struct (structed typedef?) to point to itself, it's often common to declare the struct and typedef in two different expressions. C refers to these as "incomplete types." Then add a, say, void* to point to whatever data you want the list to contain, that shoud be all that's needed for the books list.
I have my own Log function, the log function's parameters are of an error level (only test and error are supported currently but there's no reason it couldn't be expanded), `__func__` which is a macro expanded to the function's name at compile time, and a format string to describe what went down. Unlike everything else in FoundationIO, there's only the UTF-8 variant because we're not gonna generate new error strings at runtime, so UTF-16 is unnecessary, even on Windows. (I do convert from UTF-8 to UTF-16 on output in Windows tho) Internally the logging function simply calls my UTF8_FormatString function from StringIO (which is a wrapper around UTF32_FormatString which simply reencodes to UTF-32 output to UTF-8) then the formatted string is returned, it's caught by a variable, and then I use StringIO's UTF(8|16)_WriteFile function to write it to either stderr if the user didn't specify a log file to be opened separately, or to the user specified file if they did. All of the real work happens in StringIO
// l337 d00d
Honestly, I'm not really sure how your code there works. I understand that it loops through the array.
Not quite. You are incrementing past the null terminator and then running another loop. Also, you are returning the length of the original input +1, not the length of the string after modification. 
Fixed the off-by-one. I don't get any complaining from Valgrind on the increment though.
Thank you! I understand now :)
You could create a dynamically sized array using malloc. Just need to keep up with its size and a reference to the array. 
If your input string is char test[3] = "ab\0", let's assume it uses addresses 0x01, 0x02, and 0x03. First two loops the 'if' condition will essentially re-write positions 0x01 and 0x02 to themselves ('a' stays where 'a' was, same for 'b'). Then we get to the while condition. *read requests the value at 0x02, which is valid, so read becomes 0x03 ('\0'). Fine, now we loop through with the null character. Because you are assigning anything that isn't a space to the position held by the write pointer, that line executes. After the assignment, write will increment to 0x04. When we get to the while loop end, the termination condition is met, but read is also incremented to 0x04. This is why your calculation was off by one (0x04 - 0x01 == 3).
Many ways to complete the task. But don't get bogged down looking for the correct way. As per the requirement each student needs a collection of books they own. There's many to choose from linked list, tree, set, array etc. What you need is to understand the trade off's for the various functions. If you chose the linked list; what's the runtime cost if I were to return the book. What would be the cost if I used a tree? etc.. Storage costs as well come under the same consideration. Although remember memory is cheap and plentiful. Since you're learning, remember that everything in programming is a trade off and you need to be aware of which ones you are making. &amp;#x200B;
uhhh possibly this uni is quite reputable for its cs course in australia ...
Whilst many algorithms will be written in C, or C++. A higher level language would suit you just fine. As referenced by others e.g. Python. Since you won't be doing any sort of HFT, the algorithm will be producing trades at quite low rates (i assume you've got per trade costs to take into account.) So really you'll be focusing on the logic, rather than any low level speed concerns. Also if you go ahead, make sure you put a kill switch if your losses start to increase.
If you type `Bernard` and press the enter key then fgets will put `Bernard\n` into name The length of that string is 8 name[8-1] is the `\n` 
There is a clue in the section of the manual page. &gt; fgets() reads in at most one less than size characters from stream and stores them into the buffer pointed to by s. Reading stops after an EOF or a newline. If a newline is read, it is stored into the buffer. A terminating null byte (aq\0aq) is stored after the last character in the buffer. https://linux.die.net/man/3/fgets
This subreddit is about programming in C only. I have removed this post until you clarify which of C and C++ you want to use.
&gt; BTW can't strlen be zero? It would cause write outside the array. Yes, if there are no characters before EOF. And it should check if the final character is `\n`, it may not be. len = strlen(name); if (len &amp;&amp; name[len-1] == '\n') name[len-1] = '\0'; (Untested)
Also I have a quich question about file handling: How do I move file pointer in C: I am trying to compare an character array provided by the user with the list of names I have in a file and I did this: int usernamechecker (FILE *fp, char arr[50]) { int i=0,counter=0; char c; while (c != EOF) { fseek(fp,1,i); //my logic is to use fseek to move the pointer by 1 byte and i=0 means the beginning of the file c = getc(fp); printf("%c",c); if (arr[i] == '\0') {break;} else if (arr[i] == getc(fp)) { counter++; i++; } } if (strlen(arr) == counter) return 1; else return 0; } &amp;#x200B;
Just to add on here, at it's replacing that '\n' with '/0' making the char array a C string. 
Functions like getc, fread, fgets etc advance the file pointer for you. You generally don't need to do it yourself, though there are cases where you might want to, e.g. to resume reading from a previous position.
Put this piece of ascii art in a multi line comment at the start of all your programs. I guarantee it will distinguish your work. / \ \ / \ | | \ | | | `. | | : ` | | \| | \ | / / \\\ --__ \\ : \ \/ _--~~ ~--__| \ | \ \_-~ ~-_\ | \_ \ _.--------.______\| | \ \______// _ ___ _ (_(__&gt; \ | \ . C ___) ______ (_(____&gt; | / /\ | C ____)/ \ (_____&gt; |_/ / /\| C_____) | (___&gt; / \ | ( _C_____)\______/ // _/ / \ | \ |__ \\_________// (__/ | | \ \____) `---- --' | | \_ ___\ /_ _/ | | / | | \ | | | / \ \ | | / / | | \ | | / / \__/\___/ | | | / | | | | | | | | | | 
It's already a C string if fgets() succeeds; strlen() wouldn't make sense otherwise. It really is just stripping the last character.
thanks man i just did that and everyting is working as normal ! :D
Right. My bad misunderstanding if fgets. Thank you. 
I prefer char *x = strchr(line, '\n'); if (x) { *x = '\0'; }
The button mappings are located in *syscall.h* located in the INC folder.
This is a slightly different question. The difference is for this question you can use as many variables as you can. &amp;#x200B;
It's not stated explicitly, but if you read enough documentation you'll start to notice that many string functions in C deal with strings that end with '\\0'. It's something of an informal definition that is used to decisively mark the end of a string, and is the fastest way to do so (try to come up with a way that uses less memory or runs faster; you can't!). When working with strings, you will need to frequently make sure that they are properly null-terminated otherwise they will not work with the standard library functions that deal with strings. Moreover, the code above is not the best way to do what it does, and does have the potential to produce unintended results. For strlen() to work, it needs to have a terminating character in place already. All that the third line does, is replace a terminating character with a terminating character, essentially doing nothing. In the case where the array "name" is allocated to non-zeroed memory, it is possible to get an array like \[i, n, p, u, t, (etc.), (etc.), (etc.)...\] and have a bunch of junk trail the string because fgets() does not stop at or appends terminating characters on it's own. To fix this, you need to set all values of the array to 0 first before trying to put a string in it (malloc() does this). In general, due to the lightweight manner in which C is implemented, there are no "quality of life" functionalities that you would get in a higher level language, such as having access to a variable that contains the length of the string. A language that provides this will probably have calculated the length of the string using a similar method (which you can do yourself by creating a class/struct with an int and a pointer to the string). &amp;#x200B;
When you enter a series of characters with fgets typically the input is terminated by a newline or a Ctrl-D character. fgets retains the terminating character in the string it returns as the final character. The purpose of your code example is to remove the terminating control character by placing a NUL ('\0') in that position. The fgets manual page mentions that the returned string includes the trailing newline. At least it should mention that. 
I prefer: line[strcspn(line, "\n")] = '\0'; If there's a `'\n'` it's replaced by `'\0'`, otherwise it overwrites the `'\0'`. No extra variables needed and you are sure you don't write in sensible data as OP code.
&gt; It's not stated explicitly, but if you read enough documentation you'll start to notice that many string functions in C deal with strings that end with '\0'. It is explicitly stated. From C18 7.1.1 &gt; A string is a contiguous sequence of characters terminated by and including the first null character. The term multibyte string is sometimes used instead to emphasize special processing given to multibyte characters contained in the string or to avoid confusion with a wide string. A pointer to a string is a pointer to its initial (lowest addressed) character. The length of a string is the number of bytes preceding the null character and the value of a string is the sequence of the values of the contained characters, in order. This extract also explains why your second paragraph is incorrect. `strlen()` returns the number of bytes preceeding the null. so strlen("hello") will return 5. `hello[5-1] = '\0'` will replace the 4th character, starting from zero, which is the "o". As an aside, it would be faster to store the length of the string rather than use a null terminating character because extracting the length is such a common and expensive operation. It would cost up to 7 bytes of memory on a 64bit system, which is trivial. It is widely regarded that the C string implementation was a mistake and has led to a huge number of security issues. However it can't be changed now.
Thanks, I appreciate your corrections. I'll update my comment to fix my basic math error.
What advantage would an array have in this situation over a linked list? As long as you’ve got a pointer to the tail of the list insertion will be faster. You can iterate over a linked list and stop when next == NULL