Great article, thanks for sharing!
A few of these "puzzles" are just weird syntax errors and typos. I only really "enjoy" syntax checking my own "puzzles". 
For the life of me, I can't figure out the error in the 2nd puzzle. [EDIT]: Finally found out what the problem was.
Yeah, makes me want to automate putting my typo and syntax errors online in the form of a "puzzle" so other people can find and fix them for me.
It's a good preview of PHP-6
http://code.google.com/p/cmockery/
although this article looks interesting, and although I haven't done plain C for years - since 1995, probably, and although I use languages now that provide garbage collection (even objective-c 2) - I'd like to read this article. I guess it goes on the to-read pile. There are way too many things like this to read. Edit: upon consideration, I probably would have more time to read all these sorts of things if I didn't read reddit. But then I might not have heard of it. So lengthens my "things I know I don't know" list.
Wow, he's just re-invented the standard arena-style malloc() logic that the compiler uses under the covers when you call malloc() and free(). And mixed in some [Memory Pool](http://en.wikipedia.org/wiki/Memory_pool) logic. And none of it free()'d us from having to (remember to) manually allocate and de-allocate memory. This is like MFC's brain-dead IUnknown interface, but somehow even worse!
I only see 0xf questions.
Count again. 
you fail the test
For completeness....
Does anyone use ActiveX for anything? I can't remember the last website I had a problem with not being able to install something (I only use Firefox).
i know windows update site uses that (or used)
My "Significant Other" works for a company whose core service is delivered via ActiveX.
lol why the quotes? IE only shit confuses me. Maybe it's because from the beginning I've always thought internet based applications and sites should be multi browser and platform enabled. I primarily support firefox with my apps but they work fine in IE, Safari, Opera, etc. Haven't tried Chrome but I'm not concerned at this point.
&gt; lol why the quotes? It's a funny phrase. Sometimes, I feel a need to use scare quotes because of the weirdly pretentious feel of the term. &gt; IE only shit confuses me. Maybe it's because from the beginning I've always thought internet based applications and sites should be multi browser and platform enabled. Well . . . that's a reasonable expectation.
Some of that stuff was actually C++, not C. That bit about storage class and linkage left me confused.
What was C++?
You know what? I was going to say increment/decrement and lvalue/rvalue, but I looked them up, and I see I was wrong on both counts.
&gt; Exceptions are generally a bad idea. O rly? Having made the switch from functions with return values to exceptions in C++, I think that's quite debatable. With the tools available today, such as Boost, and techniques like RAII, the control flow issues are easily handled. The additional power of exceptions is amazing. Handle errors when you can -- let the rest pass through automatically. It's a beautiful thing when you use exceptions correctly. If you are having problems reasoning about the flow of your code, *you're doing it wrong*. It's not the fault of exceptions, or any other code construct for that matter. Don't let things get so complex that you don't understand them, but don't throw the baby out with the bathwater, either.
I think C is a great language, but I doubt it's the best option available for web applications (neither PHP)... PHP has a big user base, I think this page reflects the large user base of PHP, but, of course, if you come here to reddit, to ask the very same question, I'm pretty sure the asnwers will vary through Ruby, Python, Java, .NET, PHP, Haskell, Erlag, whatever, and maybe you could get some great advice for C libraries for web development... My advice is that if you have a little project (as I'm pretty sure is the case), use Python-&gt;Django, if you need to write a dirty crap in a very short time, use PHP (PHP is like a bitch, you can abuse it in a lot of different ways, but you wont marry her), and if you have a very big, interesting project, use Java or C#, those languages have the advantage that you can find far more programmers having nice "Java Programming Style", than for example Python programmers, having a nice "Python programming style" (most Python programmers use to think "in java")... 
The mailreader I'm using is written in C. [Mutt](http://www.mutt.org/) Newsreader [TIN](http://www.tin.org/) is written in C. The Linux Kernel is in C, as are all the GNU tools installed. Projects in C on freshmeat.net: http://freshmeat.net/browse/164/ (8788 atm) 
Lets review the original question: &gt; Are there any good and free libraries to develop web applications in C? Sir, we are talking about using C for web applications. Does the linux kernel looks somewhat like a web application?
Web applications are even less complex than the applications (and OS) I mentioned. You don't have to deal with (n)curses for text output. Everything is text. And most of the GNU tools work with text. The Unix world is very fond of text files and text streams. 
What are you talking about? I am the OP. I've used Ruby even before Rails and you can find my name in a few files under /usr/lib/ruby/1.8/ Before that it was mainly Perl. Today I like Python. I do web development in PHP, if needed. There's some C# at work, too. Etc., etc., etc., incl. a template engine in Common Lisp. 
Well, I don't know who you are; I made an assumption and I was wrong. When I see questions about web programming in C I usually think of my friends who had a semester or two of C.S. along with their anthro degree or whatever and don't see why you'd want all these silly new languages. &gt; There's some C# at work, too. Etc., etc., etc., incl. a template engine in Common Lisp. My hat's off to you for your flexibility. I think "one language to rule them all" is a far more common sensibility, though. &gt; Before that it was mainly Perl. Today I like Python. Python is a cancer. It's a decent language; but anyone who respects the "language renaissance" and wants to see it continue ought to boycott it on principle. We're seeing "just use Python" morph into an injunction to sit on your duff. 
Go back to your Pascal, you fuckin' whiners. C is a portable assembler with (slightly) prettier syntax. That's it. So if you don't want an assembly language - DON'T USE C! C is not a high-level language. If a high level language is what you want - DON'T USE C! C embodies the unix philosophy: it gives you "enough rope to hang yourself." If you want your compiler to babysit you and make sure you don't use an uninitialized variable (you sad, sorry sack who doesn't even deserve to call yourself a "programmer") - DON'T USE C! The kind of person who comes up with lists like this doesn't understand what C is (and is not). As such, THEY SHOULDN'T USE C. SRSLY you choke-tards, whining about the comma operator?? The operator that I never once saw in any code anywhere, that I didn't even know existed, for the first 5 years I programmed in C? Shit man, 90% of what's on this list is an example of "UR DOIN' IT RONG". What kind of moron depends on the order of operations in the arguments to a function call? What idiot makes their program depend on the order of side effects? Whining about A LIBRARY? You people make me sick. I can think of no better smack-down to lay upon you than the one from [this Onion article](http://www.theonion.com/content/node/34156): *"Even a Lamborghini isn't fast enough if you don't know how to shift, brainiac."*
Every item on that list had me screaming "Who the fuck writes code like that??", except for the first one, which had me screaming "Who the fuck codes without syntax highlighting??".
LOL @ the Microsoft code: &gt; __inline BOOL &gt; SearchOneDirectory( &gt; &gt; IN LPSTR Directory, &gt; &gt; IN LPSTR FileToFind, &gt; &gt; IN LPSTR SourceFullName, &gt; &gt; IN LPSTR SourceFilePart, &gt; &gt; OUT PBOOL FoundInTree &gt; &gt; ) &gt; &gt;{ &gt; &gt; // &gt; &gt; // This was way too slow. Just say we didn't find the file. &gt; &gt; // &gt; &gt; *FoundInTree = FALSE; &gt; &gt; return(TRUE); &gt; &gt;}
UML is really more aimed at OOP. You probably just want to use traditional flowcharting if anything.
I was hoping someone would know of a good place to find information on pre-built embedded systems. I'm not a particularly hardware-oriented guy, but I'd like to try my hand coding with something embedded. It'd be small, low-power, low-performance, but with a flexible amount of IO options and the like. For instance, a 50mhz MIPS CPU w/built-in or optional ethernet/usb/etc. Preferably it would have a version of linux or the like available for it (busybox is fine). I think Linksys makes NAS devices running busybox with usb/ethernet for pretty cheap, and I might settle for that. However, I'd really prefer something more hobby-community-based and not quite so commercial. Thanks for any input.
Try checking out the [gp32x platform](http://www.gp32x.com/).
Atmel ATMega chips.
Arduino is *fantastic* for small physical-computing projects: http://arduino.cc/ This is built around the ATMega chipset. There's also the new computer-in-a-power-brick that's flexible and seems awesome (although whether it's really an embedded system is another debate.
MSP430!!! There are a lot of boards you can buy that are cheap, and depending on what I/O support you want. And free compilers too. It's also the single most used 16 bit mcu in the world. 
14/16 without cheating (all from memory, without looking to any references). For the first one I gave no answer, as I don't know what this jmp functions do. And I gave the wrong answer on question 9, as I didn't know that the sizeof argument is not evaluated.
I have been programming Python, Java, VB, Fortran, ML, etc etc.. for ages, but my study requires me to dig in to the big old world of C and C++. What I have found is that I try to work like if it was Python, and every time I hit some place where it differs (which is pretty much everywhere) I try to reimplement what's missing. You don't have to tell me that its wrong, since thousands of programmers must be getting along with C just fine without it :) So please give some hints to best practices, and places where I can find comparative tutorials between C/C++ and other languages it they exists. 
At the more basic level, there are a few in the STL that I found useful when I was converting a Python program to C++. I made particular use of the ones at this link: http://cplusplus.com/reference/stl/ Of course, I'm probably doing things wrong too. :)
If you're new to C, you're not an experienced programmer.
glibc, hands down.
now, seriously: * SDL * pcre
OpenGL
 * [zlib](http://www.zlib.net/) * [lua](http://www.lua.org/) * [libpng](http://www.libpng.org/pub/png/libpng.html) * [jpeglib](http://www.ijg.org/) * [µstr](http://www.and.org/ustr/) - though I haven't used it much yet - found it here on reddit. [edit: forgot µstr!] 
bstring
bgilib //obscure? EDIT: I forget the file extension
µstr is great, although it mallocs more than I'd like. vstr is by the same guy, and uses memory much better.
Yeah, I mean to have a look at vstr, as well. I mostly don't mind just using char * for simple stuff, but when a program does significant string handling, it's time to either pull in another language (when possible and worth it), or use a decent string library.
* [libutf / libfmt / libio / libregexp9](http://swtch.com/plan9port/unix/) * [libtask](http://swtch.com/libtask/) * [libthread](http://swtch.com/~rsc/thread/) * [The rest of the p9p libraries](http://man.cat-v.org/p9p/3/)
PCRE!?!?! *[yuck](http://swtch.com/~rsc/regexp/regexp1.html)* And their performance issues are the least of their problem, perl regexps are **ugly**.
* libcurses * berkeleydb * libpng * Xlib * cairo
Yes. Anytime I need to store a file that doesn't need to be in binary, that's what I use. Very rarely do you get something that's fast, easy to use, and is great code. But you get that with SQLite.
Do you indeed need a UML generation?
Hope everything is clear. I even posted the C code I used to run that project. Honestly its one of my first attempts at coding and a friend helped me through some of the tougher spots. So no guarantee the code isn't chocked full of things you shouldn't do.
Great project. I just got myself something similar (the [Ardunio board](http://arduino.cc/) with the ATMEGA328 chip) I'm just waiting for some free time between projects to play with it. On a side note: .doc wouldn't have been my first choice in formats to release your code in. Plaintext is fine (as in the .txt extension on windows) or preferably use a paste-bin service with C syntax highlighting like [pastebin.com](http://pastebin.com/) (or [paste.pocoo.org](http://paste.pocoo.org/)). Whatever works for you. Edit: For example, here is your code (formatted with uniform code indentation and 80 character line limits (some people do some people don't)) uploaded to a paste-bin service http://pastebin.com/f3ee3d957
Thank you! I was pretty happy when it actually worked lol. I am having problems coming up with small projects to try out. The next thing I am trying though is a simple obstacle avoidance bot using the ATMEGA328 as its brain. Good point with the code, I was limited by what extensions it would let me upload. it wouldn't let me do a plain .txt unfortunately. I didn't even think to host it at another location and just link it.
Whatever project you come up with will be well received on reddit, can't wait. `:)`
Thank you again. The robot I am planning on making I will try to post more info on how I assembled the hardware in case any one wants to try. The code will likely take me longer though... I still haven't been able to use two of the ADC channels at a time, only one. I know that its just my lack of C knowledge though.
GLib.
&gt; Russ Cox Ah, and I thought the API looked familiar; Yay! (of course, you could just use Limbo for the task.)
do {...} while(false); - it's the error prone version of goto! Just use goto, and save your self the pain. Here is just one problem: do { ... ... for(int i = 0;i&lt;bar;i++) { if(foo) break; //only breaks the for loop, not the do while false loop } } while(false); 
Couldn't you test before the while? Also, TFA is talking about using it inside a macro: #define SetSize(x,h,w) do { SetHeight(x,h); SetWidth(x,w); } while (FALSE)
I've never seen it used this way. Anyway, the article is about macros with multiple statements, and making them behave intuitively. But I thought everyone knew that trick by now.
If you read it, he was actually using it in the context of making macros act like regular statements. In any case I'm quite fond of the trick you describe. :) Never run into issues with accidently breaking an inner loop.
I don't mean to sound like an anal prick. Sorry. Still, those macros could be re-written using goto instead of do ... while(false). Use of goto has been discouraged so much that people are inventing even less appealing yet equivalent solutions, IMO. Just use goto. This is one of the cases where it applies. Edit - Ok, as a macro, the one thing I do like about this is that it automagically handles the name of the goto label without the macro having to deal with it. In that sense it's superior to goto, but only in this macro case! ;) 
I like the C++ version.
Don't use macros.
When I was always at school, we used to use a tool called rhapsody. (I never used this IDE again) I don't know exactly if it was a plugin / modification or anything else, but there was the possibility to create UML diagrams, flow charts,... and the generated result was in C . (We have used it for embedded developpement on ARM system). 
Cute, but where are your threads? Looks more like a asynchronous (using select on socket descriptors) proxy server, which makes more sense anyway. *Edit: handles/descriptors
I haven't touched threads much at this point, do you know a good resource for them?
For windows? Not really, haven't touched that API in ages. I'd hit up MSDN and start with CreateThread.
What about Linux, I hope to port this.
I'm sorry if I led you in the wrong direction, as you have it, with select, is better than threading. I was just nitpicking your title. That said, if you're still interested in threads on linux, you'll want to look at the pthread (posix thread) documentation. [First hit](https://computing.llnl.gov/tutorials/pthreads/) on google looks pretty useful, plus the standard man pages (manpages-dev on ubuntu, I think) should be enough to get you moving in the right direction. If you have a general idea of what you need, but don't know exactly what man page it'll be in, try "apropos &lt;subject&gt;". If you have any more questions, send that orange-red envelope my way.
At my uni they teach pthreads. Check out the API and look up mutex's and get them synced. Have fun, remember not to accidentally pass a pointer to a pointer (did that and it took me quite a while to realise).
ah, when I said threading I meant the socket server itself could thread (handle more than one connection at a time) not that it was written with threads. Thanks for all your input. :)
Excuse me, but this is C Programming reddit.
As often as you want to write a C program and not a C++ program, but you obviously skipped that class.
Don't forget that a lot of warning options are only useful when the optimizer is turned on. As to how popular it is, you might like to hit up google code and death for some splint annotations. Also, splint can warn you of many things that a compiler cannot. In the case of splint, you can also add extra checks to it, such as ensuring byte-sex safety and whether inpu has been used without being sanitized (rather like Perl's taint mode) 
My biggest problem with the current state of splint is that it's seems to be stuck in c89. I.E. the variables all need to be declared at the start of the methods or else splint exceptions out. It also doesn't seem to know about j and z print format specifiers. It also has at least one bug regarding a networking library in posix mode. For all that I do use splint as the zen master suggests. often and early but recently I've found I get about the same amount of warnings if I enable gcc warnings like -Wshadow, -Wcast-qual -Wwrite-strings as I do if I run splint. I guest the question behind the question is "has the use of warnings options in gcc decreased the need for a lint like tool?" I don't get how how turning on the optimizer will affect the usefulness of warning options. Surely code optimisation would decrease the usefulness as the more optimised the code, the less it looks like the original source?
Try http://vijay.techi.googlepages.com/interview Not quite in the format you are looking for, but should give you enough to work through as well as the solutions. 
First time I used SQLite memory DB I came in my pants over the speed.
I didn't realize how fail PCRE was, thanks for that.
UPX 3.04 - Best eXecutable Packer! Changes in 3.04 (27 Sep 2009): * new format Mach/AMD64 supports 64-bit programs on Apple Macintosh. * new formats Dylib/i386 and Dylib/ppc32 support shared libraries [such as browser plugins] on Darwin (Apple Macintosh). An existing -init function (LC_ROUTINES command) is required. * new format vmlinuz/armel for Debian NSLU2 (etc.) linux kernel * bvmlinuz boot protocol 2.08 for 386 Linux kernel * Extended ABI version 4 for armel-eabi ARM Linux ELF * bug fixes
The average programmer is a web programmer and web programmers aren't C programmers, they've never learnt C because someone told them it was scary and dangerous.
huh? why can't it be done the same way in C?
also, why use do{} while(FALSE); when you can just use {}? curly braces are for scoping, you can put them anywhere you like.
First tip, avoid C++ Second tip, don't program C like you would python, in the same way that python programmers program in a 'pythonic' way, C programmers program in a C way. Third tip, C programming is about thinking about the problem, since C doesn't have a lot of batteries included the brute force approach will usually lead to lots of code and you'll get the case where your C program contains a buggy subset of lisp. 
Thanks a bundle! Doing the last year I have come to exactly the same conclusions :) 
You're a big disappoint to your mother and I. Go back to programming in Java.
libstdc++ (RUN FOR YOUR LIFE...)
Because before c99 there was no inlining in C.
Dude gets pretty wanky about comparing his 6-byte overhead to a pessimal 32-byte dickweed overhead. And who the hell uses length-prefix strings anyway?
This defies my preconceptions, and thus I automatically dismiss it without serious consideration.
Hmm.... seems like C++ programs are written to increase speed at the cost of memory. What surprises me is that C programs are actually shorter, I always thought C++ would be shorter since it has all the structures already written.
The kind of programs in those contests are too small. They don't need all the crap C++ has that would need to be written in C for a large scale project.
It's unfortunate that this seems to be down for me now.
Keep in mind that, atleast with the k-nucleotide test (didn't check the others), the C++ version uses threads and openmp, while the C version appears to be single threaded. The test runs on a quad-core machine so it isn't much of a surprise that the C++ version showed almost exactly a 4 times shorter run time.
For this very reason I posted the single-core test results. On the other hand everybody can improve the codes. So you can provide a multithreaded implementation for C.
Most of what's handled by old lint is handled by GCC now. splint is what goes above + beyond GCC.
Well, I meant do people use (splint or lint) or (nothing), not (splint) or (lint). 
splint, but I don't get much benefit from it since I don't annotate my code.
anyone has a valid link? 
libcurl
The backstory behind splint and lint is that, back in the days when compilers took forever to run, people decided to remove a lot of the really time-consuming error checking -- Hence you get splint and lint. GCC has added most of this back in, although splint does do some things that GCC does not. The really cool thing that you should be looking at, though, is static code analysis. I would recommend using Clang (the C-language front for LLVM) and its static code analysis features before using splint / lint. And for runtime checking, use Valgrind. 
I would suggest Nerdkits from http://www.nerdkits.com/ .The kit comes with a Atmel AVR ATmega168 microcontroller, LCD screen, solderless breadboard, loads of sample code, temperature senser, switches, and leds. There is more stuff included and it costs around $80 but you dont have to worry about soldering any thing since its a breadboard.
I've found splint has issues with c99 variable declarations, so I stopped using it. The projects aren't maintained from what I can tell
Was the embedding of LUA for you ? or for end users to run code ?
Yet people still code in php..
What' wrong with: #define SetSize(x,h,w)\ SetHeight(x,h),\ SetWidth(x,w) ? No one likes commas?
gumstix? http://www.gumstix.com/
For me. 
I code all my web applications in AWK. How's that for text processing.
That's not called threading. You socket server can handle more than one open connections but it will only respond to one at a time.
This is why you have no friends. &gt; Obsessing over correctness and completeness http://www.stanford.edu/~pgbovine/geek-behaviors.htm I had already admitted my mistake yet you point out how its wrong. 
Oh god. I do all of those.
Seems up now.
Thanks, I'm making a PDF of this.
Great, you made him delete his account.
that would mean (if your macro expanded to multiple statements) writing if(condition) SetSize(x,h,w) else SomeThingElse(); *Note the lack of semi-colon after SetSize*
[Effective C++](http://www.amazon.com/gp/product/0321334876?ie=UTF8&amp;tag=aristeia.com-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321334876) [More Effective C++](http://www.amazon.com/gp/product/020163371X?ie=UTF8tag=aristeia.com-20linkCode=as2camp=1789creative=9325creativeASIN=020163371X) and [Effective STL](http://www.amazon.com/gp/product/0201749629?ie=UTF8tag=aristeia.com-20linkCode=as2camp=1789creative=9325creativeASIN=0201749629)
Try products by Rabbit (www.rabbit.com). They've got cool core modules, dev kits and even single-board computers. Hardware includes Ethernet and Wi-Fi interfaces, TCP/IP, HTTP/FTP server and client code, lots of cool stuff. Uses a C compiler and provides source code for almost all of their libraries (except for the Wi-Fi driver). Comes with lots of sample programs.
splint, but I don't really use it that often
I got my start in embedded programming on a GameBoy Advance emulator and the homebrew stuff for it. It was a 16MHz ARM with 256KB of RAM and a custom 2D accelerated graphics chip. It was a great introduction to using the GNU tool chain for embedded work and all the software, including a fantastic bug-free emulator, was free. The hardware was dirt cheap and easy to find. Although getting flash ROMs has been made grey market in the North America since then. Nowadays, I think you could get the same results with a used Nintendo DS, I'm sure it has an active community. Most of the handheld world seems to revolve around ARM these days so even though the DS may seem like a toy, it is comparable to many PDAs and phones in terms of architecture. For this reason, I would pick the DS over a hacked PSP and its MIPS CPU.
Use [Lua](http://www.lua.org/). Expose your base C API to Lua, then do your generic stuff using Lua script.
Won't glib help you, at least a bit?
&gt; we'd like to use some good, open source libraries * [Judy Arrays](http://judy.sf.net/) have almost completely replaced my use of hash tables and sparse arrays. It's comparable to Google's sparsehash, and has an excellent (dense) API. * [Vstr](http://www.and.org/vstr/) is an excellent, high-quality string library. I'm not aware of a similar C++ project. &gt; I want generated, type-safe, generic algorithms. I want a pony. If you want C++, use C++. C programmers do not write code like C++ programmers. We do not generally use object-oriented models, and we do not rely on type-safety for correctness. &gt; I'm seriously considering writing my own code generator Dude, if you want C++, use C++. In the hands of most programmers, C++ isn't any slower or more bloated or buggier than C, and that means you. Writing your own code generator means that rather than take advantage of all the smart people working on improving C++ compilers, *you* are going to tackle the problem and do it yourself. These reasons you don't want to go into- they might be highly relevant.
Here are some pointers: 0xbf86d530 0xbf86d534 0xbf86d538
And then, when I want to expose the code I write as a C library, I'll have to wrap that Lua code in a C API again and make it a shared library. It sounds like more trouble than it is worth. I'd rather generate C code.
Me: Can't use C++ You: Use C++ That's not helpful. I can't go into all the reasons I can't use C++, but here are some of them: 1) The code I'm writing uses a C-only linker (think embedded, but not quite) 2) The redistributable I'm creating can't ship with a specific version of the C++ runtime, nor can I rely on a specific version being installed. There are legal issues among other things here. If you have any more C-only suggestions, I'd love to here them. I do use C++ for other projects, which is why I'd like some sort of macro-free type-safe way of writing some generic C libraries. I know I can do it via code generation; if it hasn't been done before, I'll do it myself. If it has, I'd love to hear about it so I don't duplicate some work.
glib isn't type-safe. Everything in a glib container is cast to gpointer. For example, if I want to store 'uint64_t' on a 32-bit system, I have to dynamically allocate space for it and put a pointer to it in the glib hash table. Not ideal. This is the problem I'm trying to solve.
&gt; That's not helpful. I can't go into all the reasons I can't use C++, but here are some of them: 1. Fixing the linker would probably be easier than writing your own high-quality code generator. [Cibyl](http://code.google.com/p/cibyl/wiki/Cibyl) took a novel approach to doing that, getting C to run under Java. 2. Then use a different runtime. GNU libstdc++ [can be redistributed](http://www.cs.huji.ac.il/~etsman/Docs/gcc-3.4-base/libstdc++/html/17_intro/license.html). Taking options off the table without justification isn't helpful either. You ultimately want some problem solved, and yet you're here masturbating about code generation, lifting libraries, and weak promises to "give something back". &gt; I know I can do it via code generation; if it hasn't been done before, I'll do it myself. Lots of people have done it. cfront and [lwc](http://directory.fsf.org/project/lwc/) immediately spring to mind. 
I don't think you understand... C is not a type safe language. C has no notion of polymorphism beyond unsafe casts. C cannot do the things you want it to do, and that is why it is called C and not C++. If you truly have no choice but to use C, then you are better off learning how to write idiomatic C code and not trying to force C to be a different language.
1) The linker is closed source. 2) My legal team disagrees, and no matter how much I don't like it, I can't change their mind. Are you just going to keep giving me the runaround because you don't have anything else to share? It's fine to keep quiet if you don't have anything to contribute. However, I don't appreciate you trying to find some loophole in the requirements I outlined. You can't just throw out some reasons why my requirements may or may not be valid - you don't know the whole picture, and no, I'm not going to write it all out here. It's definitely complicated. Either help by suggesting ideas or resources that you may have heard of (I do appreciate the links you've given me so far - thanks for those), or don't bother replying. This "but your requirements must be wrong" stance isn't helpful to anyone.
1. Writing a new linker isn't that difficult. Writing an intelligent code translator is much harder. 2. Fire your legal team. The Free Software Foundation [cannot make this more clear](http://gcc.gnu.org/onlinedocs/libstdc++/faq.html#faq.license.any_program): &gt; Q: So any program which uses libstdc++ falls under the GPL? &gt; A: No. The special exception permits use of the library in proprietary applications. &gt; Q: I see. So, what restrictions are there on programs that use the library? &gt; None. We encourage such programs to be released as open source, but we won't punish you or sue you if you choose otherwise. Really. If you have a lawyer telling you that libstdc++ makes your program GPL, they should be disbarred. They are obviously incompetent and not to be trusted with regards to copyright law. If he said "I don't think so", and you're just paraphrasing, give him that link and ask for a yes/no. &gt; However, I don't appreciate you trying to find some loophole in the requirements I outlined &gt; ... you don't know the whole picture, and no, I'm not going to write it all out here. &gt; ... This "but your requirements must be wrong" stance isn't helpful to anyone Listen: When someone asks me, how do I use a chainsaw to open my beer, I tell them that's not a good idea. Here are all sorts of other tools for opening a beer. I can appreciate you don't have a bottle opener, but here's how you can make one out of all sorts of other things. *I* can open my beer with a chainsaw. I realize it looks pretty cool. If you want to learn how to open beers with chainsaws, I'd be happy to help with that. If you just want to get your beer open, I'm not going to suggest you use a chainsaw.
Convert it to use Judy arrays. It outperforms STL, and performs favorably to Google's sparsehash.
*sigh* First, nowhere did I say that my legal team thinks the libstdc++ license makes my code GPL. There are different issues. They have been hashed out over a few years, and the final answer is no. They have reasonable arguments that I am not qualified, nor paid, to refute. I'd appreciate it if you didn't assume my legal team was a bunch of idiots. It makes you sound like one. This is what I'm talking about: don't try to make it seem like you know best. You can't possibly have all the information about my situation, so unless you can answer the technical question (of which I've described plenty, I think, about what I want to do), your opinion isn't very useful. Trust me: if I could just switch to C++, I would have. Don't assume I'm an idiot, too. Second, I'm not going to get paid to write an entire linker (for C++ nonetheless - quite an ordeal), especially when macro-based libraries are "good enough" for management. I'm simply looking to spend a little bit of my own time writing up some generic libraries in C using a code generator. I think it would be cleaner and more typesafe, and no slower than using the pointer-based nightmare. And no, I don't think that writing a linker is easier than writing a C template language, especially one that only allows the most basic of type substitutions. In fact, I think a C code generator for this purpose would be quite easy; that's why I'd like to do it in my free time. 
I don't think you understand. Just because you can do unsafe things in C doesn't mean you have to. I prefer C code that uses the C type system to its fullest. That's what it is there for. I only know of two useful techniques for general container libraries - the kernel uses one (embedded structures and macros) - which adds the type-safety - and glib uses the other (pointer-based) - which doesn't have type-safety (but also doesn't have macros). I'd like a type-safe, macro-free one. Generating code will do it; if others have done this and succeeded, I'd love to hear about it. If they've tried and failed, I'd also love to hear about it. What I don't want to hear is how dumb of an idea it is. If it is truly dumb, I'll figure that out on my own. Have you tried it? Have you heard of anyone who tried it? If not, then how do you know how dumb it is? It sounds pretty good to me: instead of writing "int\_hash" and "double\_hash" out by hand, I can generate the ones I need. All the "hash\_insert" routines will take in a properly-typed argument, and all the "hash\_lookup" routines will return a properly-typed argument. What's the downside to this? You think just because C lets you abuse the type system that everyone should do it, even if there is a better way? That's lame.
Certainly don't abuse the type system. Write out specialized functions for each data type you require. "Code generation" is a poor man's compiler. You are hoping to write your code in a new, inevitably crappy, pseudo-language of your own design, instead of writing C code like millions of C-coders write it. If you are dead-set on not writing C, then just save yourself the trouble and link in an interpreter for a real language like others have suggested. You're making this way too hard and it doesn't have to be P.S. the subset of C that is "type-safe" is not a language you want to program in. Type safety means avoiding dynamic allocation (no malloc), it means avoiding arrays because their bounds are not checked. It means avoiding pointers because they do not contain range information. If you'd like to see what it takes to make C type-safe, take a look at [cyclone](http://cyclone.thelanguage.org/). If you are purporting to do better than they have good luck. 
&gt; I'm simply looking to spend a little bit of my own time writing up some generic libraries in C using a code generator Go ahead and post that then. Reddit would be happy to teach you how to do stupid wastes of time, but so long as you're arguing that writing a bunch of code in the hopes that it might be useful isn't a stupid waste of time, someone is going to try and convince you to re-think your problem. Lots of programmers have been where you're at. We're trying to be helpful by trying to get you past it as quickly as possible. &gt; I'd appreciate it if you didn't assume my legal team was a bunch of idiots. Unless your legal team is your wife, I stand by my statement, and then it'll only be a courtesy. &gt; I don't think that writing a linker is easier than writing a C template language You're wrong. Writing a new language- no matter how simple you make it sound by putting adjectives like templates, and "only substitutions", is going to eat increasingly more time. Days will become weeks. If you don't give up, you'll be tweaking it for years. Every feature you add will simply introduce new questions. It simply recurses endlessly- you'll be asking and answering questions with no end in site. Meanwhile, I've written a linker for a previously unknown (to me) system in an afternoon. It is extremely straightforward, has a beginning a middle and an end. Some vague "C template language" that doesn't mean anything concrete just introduces new questions. &gt; Trust me: if I could just switch to C++, I would have. Don't assume I'm an idiot, too. This isn't about being an idiot. It's about doing something stupid. Everyone does stupid things sometimes, and it doesn't make you a stupid person; it doesn't make you an idiot.
 0x3A28213A 0x6339392C 0x7363682E
I'd like to avoid writing out specialized functions for each data type I require. That's the whole point. That task is completely mechanical, takes no thought, is boring, and can be done by a computer. That's what I want the computer to do for me. Surely you aren't suggesting that type-safety is all or nothing. It's a gradual scale, and the more you work against it, the worse your code is. One can be better off with malloc, arrays, pointers, and hash routines that return double when they store double than one can be with malloc, arrays, pointers, and hash routines that require everything to be cast to void*. Your argument isn't valid.
How can you claim to know where I'm at when you don't know anything about me? It's a simple technical question and you are extrapolating all sorts of crazy things from it - things like my lawyers are idiots, my idea is a waste of time, and I don't know what I'm talking about. I've written plenty of toy languages. They don't take very long. If you can't write a simple code generator that takes this: int TYPE_hash_lookup(TYPE key, TYPE_hash_node *node); and turn it into all of these: int double_hash_lookup(double key, double_hash_node *node); int float_hash_lookup(float key, float_hash_node *node); then you are doing it wrong. In fact, I could probably do it with macros and just pre-process the files on the side for each type I want up front, so that the clients of this hash util include a concrete .h file and call the generated routines directly. Bam, done in less than an hour. However, I think that resulting few-hundred-line-macro would be a nightmare. Why not generate that code with some simple DSL instead? Sounds ideal to me. Why is it somehow "wrong" to ask if anyone else has done this before? Perhaps they have ideas that would be useful to me. Ideas other than "your premise is flawed", which is completely useless to me.
0xdeadcafebeefbabe (64-bit machine here)
Ok, so it appears no one can convince you not to go down this path of "code-generation". In that case, let me give you some advice: Use a lexer generator and a parser generator(flex and bison) when writing your new language. Macro expansion might seem like an attractive idea, but without an explicit AST as in lisp, you will rapidly run into situations you wish you could do something, but can't. Better to start out on the right foot. Once you do have an AST built up with your parser, writing the type-checker can be a very time-intensive task. I would advise you keep the number of checks minimal if you want this project to be tractable. You might want to go ahead and compile in the Boehm-Demers-Weiser garbage collector, it is pretty portable and widely used, and will keep most of that nasty malloc stuff away from you. I hope you are getting paid a mint. 
If I'm going to be generating simple code like I'm thinking of, I'm going to write a DSL in something nice like OCaml so that I don't have to roll my own. I've written language parsers in flex and bison - that's way overkill for what I'm talking about. I appreciate the ideas though. It's more than others have been suggesting. I still wonder why code generation has such a stigma associated with it. Especially on the simple level I'm talking about. It's really not a big deal.
&gt; It's a simple technical question You'd rather be unable to solve a simple technical question, than accept that it isn't a simple question? I parse the question as asked is a multiquestion. It begets many new questions, and there is no clear bottom. That hints to me that I should estimate its complexity very high. &gt; then you are doing it wrong. In fact, I could probably do it with macros ... Bam, done in less than an hour This is a bad idea. You should not write code like that. You are boxing values for no reason beyond symmetry. With [Judy arrays](http://judy.sf.net/) I'd simply write `JHSG(result,table,&amp;key,sizeof(key));`. That code is simple, it is short, and most importantly: it is correct. The program that you suggest writing- it is a waste of time. If you can in fact do it and test it in an hour, it is still a waste of time. "But it's not type safe", I hear you whine. However true, that kind of type-safety doesn't turn out to be very useful because these kinds of bugs cause your program to barf out immediately, whereas the kinds of bugs in your DSL could remain hidden for months- or even years. Bringing a new language into the world is not something to be taken lightly. If you are trying to solve a real problem for work, don't do it this way. If you're just playing around, then restate the question so that nobody gets the wrong idea here. (You may have read that Lispers create new little DSLs all the time. If you would like to write your compiler-generator in Lisp, I can point you to a number of projects that do *exactly that*. I would not recommend it as a one-off solution in any other language.) &gt; Why is it somehow "wrong" to ask if anyone else has done this before? I didn't say that was wrong. You can ask to do silly things. You started this by asking how to solve a problem using X. I said using X doesn't solve that problem. I can help you solve the problem (fix the linker; use GNU) or I can help you do X, but I simply cannot help you do both because they are mutually exclusive. Getting wrapped up in right and wrong is just going to frustrate you further. &gt; Ideas other than "your premise is flawed", which is completely useless to me. Well, what would you expect people to say *if* your premise was flawed, except, your premise is flawed? I mean, if you understood *why* it was flawed, you wouldn't have had the premise in the first place, would you?
Your posts are becoming more incoherent and you are deteriorating into babbling. This will be my last response to you unless you come back onto the original topic. &gt; You'd rather be unable to solve a simple technical question, than accept that it isn't a simple question? The simple technical question is solvable - in fact, I outlined a solution. Since the solution is simple, it follows that the question is simple, and since there is a solution, it follows that the question is solvable. I'd like to find a better solution, but that has nothing to do with the solvability in general. The main question is whether anyone has done this more cleanly than just a ton of macros (which I see in many, many C-based generic container libraries). I found one answer already - see my edit in the main topic. Maybe there are more. Maybe they do exactly what I want. Maybe not. &gt; I parse the question as asked is a multiquestion. It begets many new questions, and there is no clear bottom. That hints to me that I should estimate its complexity very high. Perhaps your parsing skills need work. I see a very clear bottom, a simple and clear problem, and having a computer generate the code for me that I would otherwise have to write out, mechanically, line by line, with only minor type differences, seems to be a logical solution with low complexity. I'm not sure where you are dreaming up all of this complication. &gt; The program that you suggest writing- it is a waste of time. If you can in fact do it and test it in an hour, it is still a waste of time. If it saves time by avoiding the use of very long and complicated macros and makes debugging easier, I don't see it as a waste of time. If it saves time by making it easy to create a new generic container in C in the future, I don't see it as a waste of time. If someone else wants to use a generic C container library without diving into a macro abyss and they end up finding mine, I don't see it as a waste of time. I'm not sure where you are dreaming up all of this time-wasting, and even if I was wasting my time, it's both irrelevant to the question I asked and outside the set of things you should consider yourself qualified to comment on. &gt; You are boxing values for no reason beyond symmetry. I'm not boxing values at all. They would be unboxed the whole time. I'd have to box my values using glib; that's the whole reason I want to avoid the generic pointer approach. &gt; that kind of type-safety doesn't turn out to be very useful because these kinds of bugs cause your program to barf out immediately Absolutely not. Are you serious? Mis-cast a double as an integer and watch your program fail in subtle ways, not loud and obvious ones. This kind of type safety is exactly what I want. Otherwise I'd just create a hash table that holds very large scalar keys and values and cast everything to that and back. Type safety out the window, but hey, only one implementation! Sounds great, sign me up... If this is what you "C programmers" do, no wonder you think I'm out of my mind. (By the way, I'm also a "C programmer", so all that "we C programmers do it this way..." garbage is also meaningless). &gt; Bringing a new language into the world is not something to be taken lightly. What a bunch of crap. This isn't some major programming language I'm trying to invent. It's no more complicated than some of the template libraries that web developers use to generate HTML. Big f'n deal. Writing a little language in OCaml, with type checking, is a trivial affair nowadays. Using caml4p or caml5p it gets even easier. That would be overkill for what I'm talking about. The sky is not falling. Get over it. &gt; You can ask to do silly things. The only silly thing here is your answers. You are telling me to solve my problem by doing anything except what seems to be the easiest and most logical thing to do. Write a new linker? Ignore my legal team? Forget about type safety? What kinds of answers are those? &gt; Well, what would you expect people to say if your premise was flawed, except, your premise is flawed? I mean, if you understood why it was flawed, you wouldn't have had the premise in the first place, would you? You can assert anything you would like, but that doesn't make it true. My premise isn't flawed. Just because you don't understand it or wish to make it sound like some ridiculously complicated impossible task doesn't make it any more difficult than I find it to be, which isn't difficult at all. The only thing I was hoping to get out of this post was some pointers to other projects doing similar things. Even you mention that you know of some in Lisp, but you didn't share them. Don't worry, though, I've written plenty of DSLs in Lisp (don't worry, I won't share them so I don't scare you into thinking there are even more languages in the world), but I find OCaml easier to write these sorts of things in.
&gt; don't worry, I won't share them so I don't scare you into thinking there are even more languages in the world Why are you trying to hurt my feelings? Did *I* hurt your feelings? Wow. I'm sorry. I'll try and be more sensitive of your feelings. &gt; Perhaps your parsing skills need work Perhaps they do, however the [only other person](http://www.reddit.com/r/C_Programming/comments/bn9ki/looking_for_pointers_to_generic_c_libraries_stl/c0nm1xg) to try to talk to you about this parsed it the same way: You're trying to get C++ features into a place where you have C but not C++. You seem to think creating a new language (even a toy) is easier than writing a linker for an existing language. Once you have this toy language, you then have to solve the original problem (of implementing your C++ features). You will also have to debug them. &gt; Even you mention that you know of some in Lisp, but you didn't share them I'm sorry you think I'm keeping secrets from you; your post didn't indicate that Lisp was on-the-table. ECL is a Common-Lisp that uses a regular C compiler as it's compiler/linker. I keep the ECL-SLIME backend working, so I'm rather familiar with it's compiler and can answer questions about it. Getting it working for an unknown architecture is probably more work than writing/fixing a linker. [scexp](http://www.unmutual.info/software/scexp/) is an S-expression syntax for C. I am aware of this but I have not used it. CLiCC can actually translate Common Lisp into C. I haven't used this one in over a decade. Thinlisp is one designed for simplified runtimes and easy deployment. I am aware of this but I have not used it. [Scheme in 90 minutes](http://lambda-the-ultimate.org/node/349) compiles scheme to C. It is mostly a toy, but it's the only scheme-based one I'm aware of. &gt; My premise isn't flawed You can assert anything you would like, but that doesn't make it true. If it makes you feel better, you can stomp your feet while you say that too. Anyway, I hope your employer knows what you're getting him into, although if his legal team thinks there's some reason you can't use libstdc++, I'd very much doubt that he's well-informed about that as well.
No one said Lisp was off the table; I even suggested I would use OCaml if the language was bigger. That's the point of generating C - you can generate it anywhere you want (like on a nice Linux development machine) and compile the resulting code using whatever embedded compiler and whatever lousy linker you have access to later. In fact, that's another argument against the "write your own linker" approach - I'd have to write one for every system I build on now (and in the future) which contains a non-redistributable C++ library, or non-existent C++ compiler. That's a waste of time. &gt; Once you have this toy language, you then have to solve the original problem (of implementing your C++ features). You will also have to debug them. I'm not sure which C++ features you think I'm trying to add in here - again, with the assumptions - but I can assure you that mechanically generating the implementations of a generic container library that I would have written out by hand isn't a reimplementation of any part of C++. It's just not that hard. I think it would be easier to debug one script that spit out some implementations than it would be to ensure all the hand-written "hash\_double\_insert()" and "hash\_int\_insert()" routines were bug-free. I'm sure you've heard of DRY. How is this harder to debug? More baseless assertions. I'm glad you see you've thrown in some character attacks as well. At least you shared a couple of links. Thanks for that. &gt; I hope your employer knows what you're getting him into Still making baseless assertions about my employer and my legal team? No surprises there. Apparently (based on the project I linked to in the summary) Google seems to think similar projects aren't a bad idea (but what do they know). You must be a troll to suggest yet again that writing a linker would be easier, especially since you don't know anything about my target machines and, based on your comments, you don't even understand the problem I'm solving. Next time you have trouble "getting it", ask for some help. It might be better than wandering down a complicated imaginary path where the other guy is trying to do the impossible. It's certainly better than guessing at the situation and making up answers to questions no one asked. Unless you like that sort of mental masturbation. 
&gt; Still making baseless assertions about my employer and my legal team? No surprises there. When the Free Software Foundation (the copyright holder of libstdc++) says there isn't any reason you can't use libstdc++, and your "legal team" says otherwise, your "legal team" is wrong. Baseless isn't a synonym for "things that I disagree with". &gt; I'm glad you see you've thrown in some character attacks as well. &gt; You must be a troll to suggest yet again that writing a linker would be easier &gt; Next time you have trouble "getting it", ask for some help. Stop acting like a child. When you're ready to act like a grownup, you can apologize for this namecalling, and generally being a jackass. I was trying to help you by pointing out how you're wrong. Other people tried to do the same thing, and when you were mercilessly vitriolic, you got downvoted by people who stopped by and decided you weren't worth replying to. ---- &gt; I think it would be easier to debug one script that spit out some implementations than it would be to ensure all the hand-written "hash_double_insert()" and "hash_int_insert()" routines were bug-free. Straw man. I wouldn't bother having a `hash_double_insert()` in the first place. I don't believe that kind of type-harness is valuable. &gt; No one said Lisp was off the table; I even suggested I would use OCaml if the language was bigger Stop being disingenuous. You first mentioned OCaml [at this point](http://www.reddit.com/r/C_Programming/comments/bn9ki/looking_for_pointers_to_generic_c_libraries_stl/c0nmk51) *after* I had mentioned lisp. You didn't mention it in your original post. &gt; I'd have to write one for every system I build on now Wrong. Only for systems that have a broken C++ linker, and those are unusual. &gt; which contains a non-redistributable C++ library Moot. libstdc++ is redistributable. &gt; You must be a troll to suggest yet again that writing a linker would be easier You're overestimating how hard it is to write a linker and underestimating how hard it is to write your DSL, and ignoring the fact that you'd then have to reimplement the desired algorithms in your templating language, and then train your programming staff how to use it, and document it, and so on. &gt; since you don't know anything about my target machines Apparently neither do you. You make good company with your "legal team" who knows nothing about copyright law. The difference is when I ask questions about your target machines, you act like a total asshole, and handwave the question away. &gt; Google seems to think similar projects aren't a bad idea They aren't a bad idea. Google has also made a linker, several compilers, and so I think it's okay for them to implement another template-based language. It's a bad idea for *you* to implement, for your job, when you have other stuff to do.
`#include &lt;`[`sys/queue.h`](http://fxr.watson.org/fxr/source/sys/queue.h)`&gt;`
&gt; Stop acting like a child. Looks like I've touched a nerve. If you stop acting like a troll, I'll stop calling you one. You repeatedly suggest things that I've either explained can't be done (but you seem to know enough about me, my employer, and my lawyers to continue to disagree with) or you claim things that aren't true (like writing linkers for systems you don't even know I'm using must be easier than a few lines of script). My posts started out with a neutral tone and only got more aggressive as you continued on your quest to convince me that my employer and lawyers were idiots and my idea is a waste of time, all of which require you to know much more about my situation than you could possibly know, and none of which is true. If you are going to keep spitting out the same talking points, I'm going to keep getting more aggressive until you understand, or until I feel like it won't be possible for you to understand. The downvotes? I don't care about those. My initial civil replies got a lot of downvotes. It's typical reddit. Perhaps people don't agree with me, but that's no reason to downvote. It's too bad no one else joined the conversation. If I'm so far off base, perhaps more people could convince me by using good arguments (not "you are doing it wrong and your lawyers are dumb. QED."). &gt; Stop being disingenuous. You first mentioned OCaml at this point after I had mentioned lisp. You didn't mention it in your original post. Actually, if you look below, I mentioned OCaml in this topic (in reply to someone else) before you mentioned Lisp. &gt; I wouldn't bother having a hash\_double\_insert() in the first place. So you'd either use a macro API or cast things to void*? Great - the two things I'm trying to get around with my idea end up being your answer? Either that or you could explain yourself more and, you know, have the technical conversation that should have been going on from the beginning. It's pretty simple, really. Instead of writing out all the hash routines for the types I want to use, I want to generate them. This is the perfect mechanical problem for a script to handle and I just want to see who else has done things this way. If the answer is "no one", great, I'll create something new. If it is "these people over here have tried it and it worked", then great - I'll check it out. If it is "these people have tried it and it failed" then I'd be surprised, and I'd want to know what exactly failed for them. I'm still sort of shocked that you managed to take this simple technical discussion and derail it so gracefully into an argument about my lawyers. &gt; Only for systems that have a broken C++ linker, and those are unusual. I build my code on three such systems (either a broken C++ linker or no C++ compiler). Since you have no idea what my situation is, you can't keep repeating the same answers over and over. Writing my own linker is not a viable solution! &gt; libstdc++ is redistributable Has this been tested in court? My lawyers (and I also know the lawyers of other, larger companies have agreed with this position - Fortune 500 is all I can say) believe that one of the issues is that, while the application is easily distributable, libstdc++ itself is not so clear. There are other legal issues, but this is one of them. I'm not going to explain it in any more detail. I'm not sure how you think that you know more about what's best, legally, for my company (and others) than that company's lawyers, but that's not a good position to take. I can't distribute libstdc++. End of story. Repeating yourself isn't going to change that. This isn't just copyright law, by the way - this is contract law. If you don't even understand that much, then I'm not sure how you think you can advise my lawyers on what they should be doing. &gt; You're overestimating how hard it is to write a linker and underestimating how hard it is to write your DSL, and ignoring the fact that you'd then have to reimplement the desired algorithms in your templating language, and then train your programming staff how to use it, and document it, and so on. My "programming staff" is me. It'll be about as hard to use as: # Some config file hash_gen "id_hash" int double /* Some C file */ #include &lt;id_hash.h&gt; void foo(int i, double d) { id_hash_insert(h, i, d); } The hash algorithm is already written; there is no "reimplementation" that is needed other than taking out the concrete opaque types (like void*) and replacing them with whatever the config file says the types should be. This isn't rocket science here. We're talking about a few lines of script. I think it is you who overestimates my problem. &gt; They aren't a bad idea. Then why are you telling me it's a waste of time? Now you are contradicting yourself. &gt; Google has also made a linker, several compilers, Irrelevant, especially since it has nothing to do with my problem, and even more especially since I bet the people who wrote that project aren't working on linkers, compilers, interpreters, assemblers, or any other technology that you think is somehow a prerequisite for a template language. Do you think the other useful template languages out there were all either bad ideas or implemented by someone who wrote a linker? What kind of stance is that to take? And who says I have to write out the template language myself? I could easily use an existing template language (there are a lot out there) and simply code up my solution in that. Not a lot of work, and no where do I see this mystical new language that's going to make a mess of my job, my employer, or the world. &gt; It's a bad idea for you to implement, for your job, when you have other stuff to do. Again, since you know nothing about me or my job or what else I have to do, this is a bunch of useless speculation. Since you can't seem to focus on the actual technical question, I'm done talking with you. If you decide you'd like to actually discuss something someone else finds interesting, join the conversation again, but leave the things you know nothing about (my lawyers, my employer, my job, my time, and my TODO list) out of it. 
Thanks for the pointer. I'm not fond of the macros that are used to make the API tenable though - that's one of the things I'd like to avoid. It adds bloat (since everything is inlined, any two translation units that use the same type of list are going to contain duplicate copies of the list manipulation code for example). I also think it's hard to debug. I'd like to improve things, at least for my needs, by eliminating the macros and making the implementations external functions in a separate translation unit, like any other library.
&gt; Actually, if you look below, I mentioned OCaml in this topic (in reply to someone else) before you mentioned Lisp Right. Since you were replying to someone else, I should obviously think it was directed at me. Grow up. &gt; It's too bad no one else joined the conversation. If I'm so far off base, perhaps more people could convince me by using good arguments The onus isn't on us to convince you, sorry if you thought the world worked that way. You ask for help, and this is what you get. If you want something else, change your behavior. &gt; So you'd either use a macro API or cast things to void*? Great - the two things I'm trying to get around with my idea end up being your answer? Unfortunately, you have no justification for getting "around" those things. Professional C programmers don't bother with such silliness. That's why you're having such a hard time finding libraries and code that do what you want. &gt; Has this been tested in court? My lawyers (and I also know the lawyers of other, larger companies have agreed with this position - Fortune 500 is all I can say) believe that one of the issues is that, while the application is easily distributable, libstdc++ itself is not so clear. There are other legal issues, but this is one of them. Has what been tested in court? The Free Software Foundation- the copyright holder said you can redistribute it. It doesn't affect the copyright of your application. I linked to the page. [libstdc++](http://gcc.gnu.org/ml/gcc/2004-06/msg01124.html) is very clear. You need to comply with the GPL of it, and you need to make it's source code available. Why would you think this is complicated? How could that possibly be a problem? &gt; This isn't just copyright law, by the way - this is contract law. If Your lawyer is an idiot. [The GPL isn't a contract](http://www.groklaw.net/article.php?story=20031214210634851). If you do not comply with its terms, you do not have the right to redistribute it. Anyone who tells you otherwise is ignorant to basic copyright law. &gt; The hash algorithm is already written That's stupid. The hash function should depend on the inputs. A general hash function cannot possibly be any better than simply not hashing the double and using a n-ary trie. If your inputs aren't random, then why is the hash algorithm already written? Judy Arrays (a 256-trie) is comparable to the fastest hashtable I know (Google's sparsehash), and specialized n-ary tries can go faster. A C++ compiler can get smart enough to eliminate stupid stl access and ignore type coercion when it isn't useful. &gt; It's pretty simple, really. Instead of writing out all the hash routines for the types I want to use, I want to generate them. Go right ahead. It's more complicated than you think. If your "hour" was accurate, you've already wasted it arguing with me. If six months from now, you're still tweaking your macros or your code generator, you'll know I and everyone else who tried to lead you away from this was right. Any function F(A,B)-&gt;C has A*B*C combinations which is A*B*C implementations to test and check. If you *just* use C basic types, and you assume the simpler case of F(A,B)-&gt;{A|B} then you're dealing with (char+int+short+long+int64*signed/unsigned+float+double+longdouble=13*13) 169 functions to test. Why would you possibly bother testing 169 different combinations when you can simply test the code that you actually *have* to write? &gt; Then why are you telling me it's a waste of time? I said it's a waste of *your* time, if you're trying to get C++ working on an architecture, reimplementing the features of C++ you want with macros is harder than writing a linker. If you're goofing around, then say so. You'll get a lot more help if you frame this has a thought puzzle instead of actually trying to solicit help solving a problem with your job. &gt; Irrelevant, especially since it has nothing to do with my problem You brought up Google, and said: Look, *they* write a template language, why can't *I*. The answer is because you're not Google. &gt; Looks like I've touched a nerve I asked why you were trying to hurt my feelings, and you're happy that you got the result you wanted? Stop being a child. &gt; You repeatedly suggest things that I've either explained can't be done You've asserted without justification. You haven't given a reason why they can't be done except some hand waving by some "legal team" which obviously doesn't practice copyright law.
You seem to have a certain irrational fear of the C preprocessor. The macros in queue.h expand to a few instructions, often a single one. This really does not add any bloat. Think of it like short C++ functions which are being inlined by the compiler.
[Pointers by xkcd](http://xkcd.com/138/).
I'm not afraid of the C preprocessor -I just think it should be used sparingly and minimally. That linked list may be a few small-ish macros that expand to a few instructions but in general, that's not a decent way to write generic algorithms in C in my opinion. I've seen hash algorithms written like that where the table management and resize routines were entirely macros. I don't think that's "good C". It may be idiomatic, but I think it can be improved. I'm basically looking for common techniques for writing generic C algorithms. All-in-macros is one way and void\* opaque typing is a second way. I think I'm going to investigate a third way (generating routines for specific types) and see how it works out. It beats the other alternative (writing the routines by hand, one by one, for each type) if I want to avoid void* and macros.
&gt; Right. Since you were replying to someone else, I should obviously think it was directed at me. Grow up. What a joke. Nowhere did I say you should have thought it was directed at you. I'm simply saying I mentioned OCaml before you mentioned Lisp. The only reason I had to point that out was because you said I was being disingenuous, when in fact, I wasn't - my original statement, that no one said Lisp was off the table, and that I had mentioned OCaml before you mentioned Lisp, is still accurate. Do you enjoy taking thing out of context to support your position? It's rude. Perhaps you should grow up. &gt; The onus isn't on us to convince you No, but what does that have to do with anything? I only said that I would have appreciated people that disagreed with me to discuss it, rather than downvote, as per reddiquette. I suppose that's too much to ask. I'm sorry my suggestion offended you enough to warrant a defensive reply. &gt; Unfortunately, you have no justification for getting "around" those things. Professional C programmers don't bother with such silliness. First, I don't need justification beyond the fact that I think it would make my code better and save me time. Second, I'm a professional C programmer, so your generalization is obviously meaningless. It's statements like this that reassure me that you are a troll. No one could make such claims and be serious about it. Rest assured, unless you bring up some other assumptions that I have to correct, I won't be feeding you any more. &gt; Why would you possibly bother testing 169 different combinations when you can simply test the code that you actually have to write? What makes you think I'd have to test every combination? It's no harder than testing the C++ template version. First you test a few different classes of types, then you test your application with concrete instantiations. No big deal. It's not rocket science; stop making a mountain out of a mole hill. &gt; I said it's a waste of _your_ time You are not qualified to speak about my time. As I said before, this will save me time. Therefore, it is not a waste. The only waste here is this conversation, except that I hope someone else doesn't come along and see your baseless accusations and think they have meaning, so I have to keep putting you in your place. &gt; If you're trying to get C++ working on an architecture, reimplementing the features of C++ you want with macros is harder than writing a linker. I don't know how you made the jump from 'generic C libraries' to 'all of C++'. This has nothing to do with C++. Generic algorithms exist in many languages, and I'm looking to see if there's a better way in C above macros and void*. Get your head out of C++ and think for a few minutes before you speak. When someone asks "what is the best way to write a generic library in C" or "what other ways besides macros and void* are there", the answer is NOT "C++" or any other language. It might be a valid answer if the question was "what is the best way to write a generic library" but I would argue that a language with dynamic typing or abstract data types is a better answer than C++ if that was my question. Since it wasn't, though, this point is moot. &gt; If you're goofing around, then say so. You'll get a lot more help if you frame this has a thought puzzle instead of actually trying to solicit help solving a problem with your job. Whether this is for my job or not is irrelevant. This is a question about what people think about different ways of writing generic algorithms in C. This is a general question not tied to any job, program, or operating system. You are the one who brought jobs into it by making accusations against my employer and my legal team. I'm still not sure what they have to do with a technical question though. &gt; You've asserted without justification. I don't have to justify my legal team - they justify themselves to whomever it is important. Since the discussion isn't about them anyway, I don't have to justify their decision to you at all. In fact, I don't know enough about law to carry over that justification, even if I knew all of it. Stop talking about my lawyers as if they somehow affect this discussion in the slightest. Here's another hint: Even if I could distribute libstdc++, I have no C++ compiler on my target systems. And even if I got one, the linker wouldn't work. And even if I reimplemented the linker, guess what? I *still* wouldn't use C++! Want to know why? The C++ ABI would get in the way. I'm shipping pre-built libraries that others link to. Suppose I use C++ and I ship my own libstdc++. Now they have to use the same version of the C++ compiler that I used, with the same options, or else they either won't be able to link to my code, or things will start failing silently at runtime because two versions of the C++ standard library will be in use at the same time. What a nightmare. Go back to your cave, troll.
&gt; Even if I could distribute libstdc++, I have no C++ compiler on my target systems. For such a smart guy, you could've said this back on [question one](http://www.reddit.com/r/C_Programming/comments/bn9ki/looking_for_pointers_to_generic_c_libraries_stl/c0nm017) and saved yourself a lot of frustration. Instead you felt like wasting my time, and everyone else's time. &gt; Whether this is for my job or not is irrelevant It's highly relevant. If you're looking at solving a problem, the solution that costs the least is the most valuable. If it's for personal growth, then the solution that yields the greatest personal growth is the most valuable. &gt; This is a general question not tied to any job ... You are the one who brought jobs into it Actually, you brought it up when you said certain options were off the table [because of your legal team](http://www.reddit.com/r/C_Programming/comments/bn9ki/looking_for_pointers_to_generic_c_libraries_stl/c0nm237). &gt; I don't know how you made the jump from 'generic C libraries' to 'all of C++' I don't know why you inserted "all" there. I certainly didn't use it. Please work on your reading comprehension. &gt; It's statements like this that reassure me that you are a troll. You should go meet some other C programmers. Linus is one of the more high profile people to come out against [type safety](http://lkml.indiana.edu/hypermail/linux/kernel/0708.0/0807.html) when it comes to affecting readability. This fantasy world you live in where everyone who disagrees with you is a troll isn't helpful. &gt; I hope someone else doesn't come along and see your baseless accusations and think they have meaning You're doing a great job of being convincing so far. By the way: baseless doesn't mean "things that I disagree with". &gt; When someone asks "what is the best way to write a generic library in C" Ah, but you didn't do that. You wanted one that offers some measure of type safety, despite the fact that C programmers don't usually do that. You've handwaved and unilaterally dismissed any of the suggestions to do something else. You're not getting what you want so you're name-calling. Grow up.
&gt; For such a smart guy, you could've said this back on question one and saved yourself a lot of frustration. I mentioned it once before in this thread in reply to you; it's not my fault you didn't notice. Also, don't blame me because your non-answer of "switch to C++" isn't getting you anywhere. If you listened to me in the first place when I told you I'm using C, and only C, on the target system, then you would have wasted your time trying to convince me that C++ was The Way To Go. Will you suggest I switch to D now? Let me save you the trouble: I don't have a D compiler on the target machine either, and I'm not porting it. I don't have OCaml, Haskell, or any other language that would make my life easier. I have C. Even though all of this is irrelevant, since you should have read my C question and either given a C answer or kept quiet, I figure I better mention this just in case you get some more bright ideas. &gt; If you're looking at solving a problem, the solution that costs the least is the most valuable. If it's for personal growth, then the solution that yields the greatest personal growth is the most valuable. The world is not so black and white. Perhaps it's a little of both, but seriously, it DOESN'T MATTER at ALL. It's a question: If you were using C, what techniques or libraries do you know of that let you write type-safe, generic utilities. It's not so hard, once you take off your C++ glasses, to either have something useful to contribute or not. Making this about motivation, jobs, lawyers, or any other topic under the sun is a weak cop out to try to cover up the fact that you didn't know. &gt; Actually, you brought it up when you said certain options were off the table because of your legal team. And you brought that up when you continued pushing for reasons I should switch to your favorite language. What's your point? The question was about C and you veered way off topic. Congratulations. Now I have to keep cleaning up your mess. &gt; You should go meet some other C programmers. Linus is one of the more high profile people to come out against type safety when it comes to affecting readability. I know plenty of "C programmers" - in fact, I work with many of them. I'm also familiar with Linus's style and theories. I'm surprise you quoted him since he hates C++ (at least, C++ programmers). However, that's all moot, since it has nothing to do with my question! Besides, my idea would end up with code that is more readable in my opinion, so your point is moot because of this even if it was valid otherwise. Which it wasn't. &gt; This fantasy world you live in where everyone who disagrees with you is a troll isn't helpful. You must be in a fantasy world. I haven't called anyone else in this topic a troll because they haven't acted like one. If the shoe fits, wear it. To continue to push C++ when you've been repeatedly told it's not an option, especially in a question about C, is being a troll. Suggesting that my employer or my legal team are idiots and don't know what they are doing makes you a troll. Live with it, or stop acting like one. &gt; You wanted one that offers some measure of type safety, despite the fact that C programmers don't usually do that. C programmers use type safety all the time, and if a good C programmer is given a choice, all other things being mostly equal, of a utility that is type safe and one that is not, the C programmer that chooses the type-unsafe one is the idiot here. &gt; You've handwaved and unilaterally dismissed any of the suggestions to do something else. The question is, what ways do you know of to do X. If the answer is "do Y instead", or "your lawyers are idiots", or "I know more than you and you don't want to do X", then yes, those answers will get dismissed. That's how it works because that's not what the question is asking. I'm not sure what world you live in where your answers, even though they don't address the question posed, are good answers, but I wish I lived there too. Ignorance is bliss. 
&gt; I mentioned it once before in this thread in reply to you ... it's not my fault you didn't notice. You mean [here](http://www.reddit.com/r/C_Programming/comments/bn9ki/looking_for_pointers_to_generic_c_libraries_stl/c0nnlt9?context=3) I presume. You'll note that this wasn't when the question was originally asked. Look, you fucked up. Perhaps you meant to say it. Perhaps you thought you did say it. You didn't. You wasted mine, and everyone else's time, and somehow you think that's *my* fault. Grow up, kiddo: It's your fault that you're not being understood. 
I'm not sure how you come to your conclusions. There's nothing fucked up about my question, about my interest in the topic, or about my dismissal of your non-answers. I'm also not sure how you can blame me because you don't understand the simple phrase "C-only", but whatever helps you sleep at night. There's one more thing - I'm surprised you brought up Linus and the kernel when talking about your hypothetical "C programmers" that do things your way and that somehow prove I'm mistaken. The kernel utilities are actually pretty nice - they are type safe too! Imagine that. C programmers who want to use type-safe code. Even type-safe generic utilities. In fact, those are probably state-of-the-art as far as I've seen. They even use macros minimally (instead of putting the entire implementation in macros). So they almost fit the bill for what I am looking for. However, I don't like the non-standard pointer casts they use to get the job done. That's another reason I'm looking for a better answer. I think code generation might be it, and I want some discussion on the topic. Thanks for contributing a bunch of false ideas about unrelated topics though. Helpful. You can take your "real C programmers don't care about type safety" bullshit and go spout it off somewhere else. Maybe you and your band of perfect C programmers who eschew type safety wherever possible can keep contributing to all the security problems the computing industry is currently having. I'd rather write some type safe utilities. I know it can be done (it has been done!) - I'm just going to do it better.
I feel your pain. I asked a question about the state-of-the-art in generic C utilities just a few days ago and the biggest response I got was "Go use C++". Sometimes the hive mind is closed for business.
eMule 0.50a Tombstone 2.1 by WiZaRd. one of the fisr emule 0.50a based mod. TombStone 2.1 comes with the latest ClientAnalyzer 
gcc can actually figure out when you're doing the ifdef trick for header files and just skips it entirely. I don't know if other compilers do this however
eMule v0.50a beba v2.60 [the better edition] ** released April 27 2010 - merged: eMule 0.50a * including some lib updates - improved: add and remove sources only from downloading list if they are visible [dolphinX] - improved: added even more file types [Tuxman] - improved: analyzed mod thieves are not added to Mod Stats anymore [Tuxman] - improved: applied some smaller code changes and improvements [Tuxman, WiZaRd, Xman, Spike2, JvA] - improved: clients on upload queue are also informed of an ID change now [Spike2/Stulle, modified by Tuxman] - improved: don't create a beta test file (for ASFU) [Stulle] - improved: increased width of the Queue number display label (may fix the truncation on some systems) [Tuxman] - improved: layout of the Files options dialog (has been out of alignment since the .49c codebase update) [Tuxman] - improved: readded the "don't draw hidden rect" improvement in several places [SiRoB] - improved: reduced CPU usage of some UInt128 functions [NetFinity] - improved: skip not needed requeuing on NNS [SLUGFILLER/WiZaRd] - fix (o): disappearing tray icon fix [dolphinX] - fix (o): friend detection fix [WiZaRd] - fix (b): IntelliFlush was (partially) broken [Tuxman] - fix (o): memleak fix in ArchiveRecovery.cpp [gureedo] - fix (b): several memleaks in modeless dialogs [WiZaRd] - fix (o): SortProc issue in SharedFilesCtrl [moloko+] - fix (b): toolbar skins work now ;-) [thanks to jerryBG] - changed: beba's classical FutureMule icon is back :-) [Tuxman] - updated: Automatic Shared Files Updater [Stulle] * includes a crash fix by WiZaRd - updated: Client Analyzer v1.5 [WiZaRd/zz_fly] * includes Anti-Corruption and stats fixes - updated: Enhanced Client Recognition v2 [Spike2] * includes CompatClientStats [Stulle] * also added easyMule 2 detection [Sundawner] HomePage: http://beba.emulefuture.de
I would recommend [The Practice of Programming](http://www.amazon.com/dp/020161586X), [Expert C](http://www.amazon.com/Expert-Programming-Peter-van-Linden/dp/0131774298) and [Operating Systems Design and Implementation](http://www.amazon.com/Operating-Systems-Design-Implementation-3rd/dp/0131429388). Also Jon Bentley's "Programming Pearls" are great, though not always about C.
I suggest reading "The GNU C Library Reference Manual". I regard it as the best C reference that I've ever read.
First thing you need to do is to get a copy of "C FAQ by Steve Summit", read it end to end, then get a copy of "Expert C programming, Deep C secrets" and read that end to end. You would already be a better programmer by the end of these two books.
Or you can buy a Linksys WRT160NL for less than 100$ and put http://openwrt.org on it
* Clearsilver http://www.clearsilver.net * MessagePack http://msgpack.sourceforge.net
strtoul() does not have incorrect error signalling. On an error, the return value is set to ULONG\_MAX AND errno is set to something. Before using strtoul(), you must set errno to 0 and, afterwards, check it if ULONG\_MAX is returned.
 Bah. I hate 'considered harmful'. If you aren't [Edsger Dijkstra](http://en.wikipedia.org/wiki/Edsger_Dijkstra) it just makes you sound like a douche.
One of the best examples of Coroutines is protothreads in the [Contiki embedded OS](http://www.sics.se/contiki/).
Thanks for the link!
So?
This one is nice! Thanks :)
"New" as in "ten years old".
I've always liked how this is valid C code: char foo[5]; 4[foo] = '\0'; 4[foo] is equivalent to foo[4] since \*(foo + 4) is the same as \*(4 + foo).
After doing some embedded work where the compilers didn't have much beyond C89, I've tried avoiding some newer features like this. VLAs seem like they could be useful though, at least for modest allocations for the sake of convenience. Has anyone here had much experience with them to comment on their best uses?
AFAIK: It has the same advantages as alloca except it is standard instead of machine/compiler dependent. A difference is that alloca remains allocated until the function returns. VLA's are deallocated at the end of their enclosing block. So... VLA's are standard (unlike alloca), they are more efficient than malloc/free, and the programmer has more control over their lifetime. &gt; The alloca() function is machine- and compiler-dependent. For certain applications, its use can improve efficiency compared to the use of malloc(3) plus free(3). In certain cases, it can also simplify memory deallocation in applications that use longjmp(3) or siglongjmp(3). Otherwise, its use is discouraged. With a prototype like... void do_something(int xdim, int ydim, int zdim, double array[xdim][ydim][zdim]); "array" is still a pointer inside the function but this syntax allows "array[x][y][z]" to compute the correct offset. This makes some math work more concise. One gotcha is that "sizeof array" is the size of a pointer when "array" is a function argument and "sizeof array" is the actual size of the array if the declaration is visible in scope. "sizeof" is evaluated at runtime for the latter case.
Thanks!
This looks awesome, but also evil! :)
This is only a little bit of abuse, it's pretty clever.
Note for future reference, to block the incredibly annoying scrolling twitter nonsense: [adblock filter](https://adblockplus.org/forum/viewtopic.php?f=2&amp;t=5104) (Good article, once that rule was applied.)
Actually, wouldn't you check if errno is set? I know it makes no difference as long as both are checked, but to maintain consistency with other errno functions, you would check errno, and then deal with the error. If you are checking for ULONG_MAX, someone reading your code might be confused at first.
"Sorry, Splint does not yet support variadic macros. We hope to fix this in a future release." I found this about splint and sort of looked away. But I found a Microsoft tool called PREfast static code analysis, it comes with the new version of the Windows (Platform) SDK v6.1. It's easy to use, you just use the compiler (cl.exe) that is distributed with the SDK, so you can use it in visual studio and add /analyze to the command line. http://poisonforthemind.blogspot.com/2010/06/prefast-code-analyze.html Benefits of using it -- find many warnings of array out-of-bounds indexing, null and invalid pointers, and local scope masking outer scope. Works on C++ too
I got a question: Can you explain to a guy like me who knows computers but is not an IT guy, not a programmer, what this mod does? Thanks in advance for your time.
What do you want to change? Strings (text) or functionality (code) ? 
This subreddit is about the C language, not C++.
Declare a static char array with enough space to contain all possible settings, assign something unique to the beginning of it. static char szMySettings[100]="***Myoptions!£$"; When running, open executable as a file in binary mode, search for your unique string (this time you have to build the unique string as you do not want 2 occurences of the string in your binary). Write your settings into the space after your unique string, close file. Assumes %your OS% doesnt checksum executables.
I don't feel like these libraries provide the full benefit of sum types or RAII. Libex appears to deal with the exception handling part without any guarantees that certain code will be executed (e.g. to release resources) in the event of an exception being thrown. Also, the sum types implementation appears to be more of syntactic sugar than anything else; its not clear from the code that the compiler or runtime will actually catch any misuses of the type, which is one of the main benefits of such a type. Otherwise, this seems nice, but I think it should be understood that these macros don't actually make code safer in any sort of automatic sense.
&gt; Libex appears to deal with the exception handling part without any guarantees that certain code will be executed (e.g. to release resources) in the event of an exception being thrown. I suppose it depends on what you mean by "exception" and "thrown". If you mean the exception types and THROW provided by libex, then it does provide that guarantee. There are conditions however, all of which are documented on the [Google code page](http://code.google.com/p/libex/). The most egregious is that you have to make sure that all your uses of control-flow operators are in proper scopes, else you interfere with libex, ie. you can't return in the middle of a function, and you have to make sure that you don't use goto/break/continue to escape an exception handling block. However, only using return, goto or a global program exit/abort function, can prevent the FINALLY block from running. Edit: I'm also contemplating providing macros that redefine return, break, and goto, so that the developer would get compile-time errors if they try to use them. That's pretty invasive though, and requires adopting libex pervasively, at least in any source file in which it's included. &gt; Also, the sum types implementation appears to be more of syntactic sugar than anything else; its not clear from the code that the compiler or runtime will actually catch any misuses of the type, which is one of the main benefits of such a type. To be fair, [the Haskell compiler has to be told to perform exhaustiveness checking](http://ocaml.janestreet.com/?q=node/64), so exhaustiveness checking is not a given even with languages that natively support sums. Just gotta live with it. The benefits to libsum that I see, is that it provides disjoint sums by default, and the pattern matching construct opens a new scope for each matched case; contrast with the C defaults of unions/non-disjoint sums and unscoped case matching for the switch statement. Further, libex provides more structured error handling, instead of requiring gotos and intermixing program logic with error handling logic. I think anyone would admit that both of these changes provide safer defaults.
Thanks for the clarifications. It seems like there's a bit of overlap in terms of matching which exceptions have been thrown and matching what type is stored in a sum type. Do you think that following the practice of making the return value of a function be the sum of the exception types that can be "thrown" and the actual desired type that one would want to return upon success be less restrictive (in terms of allowing support for more control-flow changing operations) than simply using libex? In terms of "automatic", I was referring to how C++ guarantees that destructors will be called and so resource release can naturally be put into destructors, whereas in C, one needs to explicitly release resources where they are used.
&gt; Do you think that following the practice of making the return value of a function be the sum of the exception types that can be "thrown" and the actual desired type that one would want to return upon success be less restrictive (in terms of allowing support for more control-flow changing operations) than simply using libex? This is the way it should be done for a real language with effect types that propagates exceptions, but it's difficult to achieve in C for a couple reasons: 1. libsum, and sum types in general, often require dynamic memory allocation. The express purposes behind libex was not to perform any allocations, and just use local control flow so the unstructured local goto form could simply be replaced by a more structured exception handling form. 2. A further complication is that you'd have to create a sum per function, which would be rather cumbersome to do in C. To make this convenient, you'd have to basically hide all of C's function declaration syntax behind some macros that declare all the enums and unions required. I've played around with stuff like this, and it's doable, but I think it would be a hard pill to swallow for most C devs. Finally, the control-flow restrictions would still exist. See the other C exception libraries based on setjmp/longjmp that I linked on the libex page if you're interested in more flexible exception handling albeit with a slightly higher overhead. &gt; In terms of "automatic", I was referring to how C++ guarantees that destructors will be called and so resource release can naturally be put into destructors, whereas in C, one needs to explicitly release resources where they are used. Unfortunately we have to live with some restrictions due to C's inherent limitations. But, I do have another unreleased C macro project which provides type-based overloaded functions. We could then introduce a scoped declaration, like C#'s "using", that requires each object implement a "destroy/dispose" operation. However, this project is significantly more invasive than the relatively simple libex and libsum, and I'm not yet satisfied with it. So even more flexible and safer C is future work. Stay tuned! :-)
You should look into the "safe" string functions, such as strlcpy and snprintf, which take a maximum length. The unbounded manipulations you do with fixed-size buffers in extractLink() look scary. Otherwise, it looks very interesting. Will try!
why use C to download youtube videos? should have used something like python or php....
What problems might this pose?
If you want quick solution... aptitude install youtube-dl ... but I think he wanted to learn C.
Compiled and ran in Cygwin. gcc `curl-config --cflags` -c yayd.c gcc -o yayd.exe yayd.o `curl-config --libs` ./yayd.exe http://www.youtube.com/watch?v=FGdcHRYo8CI A bunch of output... [S1][P20] Ghouls 'n Ghosts [HTSF] | 100.00 % | 61575508.00 bytes of 61575508.00 bytes Completed downloading 61575508.00 bytes of [S1][P20] Ghouls 'n Ghosts [HTSF] Each update to the progress bar was on a new line. [The first example of compiling with curl I found](http://curl.haxx.se/mail/lib-2002-01/0132.html) was done in two steps, and so I did it that way.
I think it poses security risks. Potential shellscript attacks and whatnot.
In best case it can crash the application for longer strings. In worst case can be used to compromise the machine. The `extractLink()` for example is dangerous, since it parses input of an user which calls it. For example you can pass an arbitrary string that could make your computer execute harmful code as user running it. It's not a big deal when you call it from command line yourself. The program has your permissions, and can't do more than you're allowed on your system. Also why would you want to go such lengths to execute something, if you have access to the shell you run it in. So the only visible issue is that with longer strings it'll just crash. But as soon as someone for example creates a website that uses this program to fetch the videos, this becomes a huge issue. Now anyone can make the server run arbitrary code with the permissions of user that runs the program (typically it would be the webserver). 
For a newbie, this is pretty well done (consistent formatting, consistent structure), although, here's a few observations: * The character escape sequence `\e` is not standardised, so it may not compile on some compilers, replacing it with `\x1B` may be better. The standard says that non-standard character escapes require a diagnostic message (i.e. a compiler warning), for GCC and clang, you can see it with the `-pedantic` flag. * In your `writeF3` function, you allocated memory for your local `text` variable, but you do not free it anywhere. Similarly in your `writeF2` function, you have allocated memory for your local `str` variable, but you do not free it anywhere. `writeF3` is called quite a large number of times. * The `strstr` in your `writeF2` function operates on input that is not guaranteed to be null-terminated. Allocate `str` with `str = calloc(nmemb + 1, size);` and all bytes will be initialised (or alternatively, continue to use `malloc`, but ensure you allocate room for [and provide] the null character). * In `readPage()`, you allocate enough space to hold the entire page contents (including room for a null character) but you do not null-terminate it, this means that in `extractTitle()`, `strcpy()` operates on input that is not guaranteed to be null terminated. * You call `curl_easy_cleanup()` in `getPage()`, but later in `readPage()` you try and access `CURLINFO_SIZE_DOWNLOAD`, which is not permitted according to this excerpt of the `curl_easy_cleanup()` man page: &gt; Any uses of the handle after this function has been called are illegal. This kills the handle and all memory associated with it!
You might be interested in [clive](http://clive.sf.net/). 
Please use const pointers wherever possible. For example, usage() should be declared as int usage ( const char *argv ) http://en.wikipedia.org/wiki/Const-correctness 
Master Foo once said to a visiting programmer: “There is more Unix-nature in one line of shell script than there is in ten thousand lines of C.” The programmer, who was very proud of his mastery of C, said: “How can this be? C is the language in which the very kernel of Unix is implemented!” Master Foo replied: “That is so. Nevertheless, there is more Unix-nature in one line of shell script than there is in ten thousand lines of C.” The programmer grew distressed. “But through the C language we experience the enlightenment of the Patriarch Ritchie! We become as one with the operating system and the machine, reaping matchless performance!” Master Foo replied: “All that you say is true. But there is still more Unix-nature in one line of shell script than there is in ten thousand lines of C.” The programmer scoffed at Master Foo and rose to depart. But Master Foo nodded to his student Nubi, who wrote a line of shell script on a nearby whiteboard, and said: “Master programmer, consider this pipeline. Implemented in pure C, would it not span ten thousand lines?” The programmer muttered through his beard, contemplating what Nubi had written. Finally he agreed that it was so. “And how many hours would you require to implement and debug that C program?” asked Nubi. “Many,” admitted the visiting programmer. “But only a fool would spend the time to do that when so many more worthy tasks await him.” “And who better understands the Unix-nature?” Master Foo asked. “Is it he who writes the ten thousand lines, or he who, perceiving the emptiness of the task, gains merit by not coding?” Upon hearing this, the programmer was enlightened. 
lol, yes I was not sure what to do with the input link. It does look scary. Hopefully strncpy, strncat, some pointer manipulations and an if statement to keep it's length in check will make it more secure. 
 Yes, re-inventing the wheel isn't a good idea, re-inventing it the hard way is bad too. But writing it in bash wouldn't help me learn more C. I wrote it to learn, not to download videos. It helped learn more about string manipulation, pointers, and libcurl. Like others pointed out, there are better and safer tools to do it. Hehe thank you for the Master Foo story. Wish there were more of it.
It's a shame I can't up-vote you more than once, lol. You pointed out a lot of things I missed. Don't know why failed to notice the curl_easy_cleanup part. I like pedantic already, points out things -Wall doesn't. Nice to meet calloc too. Taught me something I'll be using a lot. The modified version yayd-1.c all of it fixed. Thank you.
Avoid using [`strncpy`](http://opengroup.org/onlinepubs/007908775/xsh/strncpy.html) if you can, it's name is somewhat deceptive and the function itself is mostly useless. It does not guarantee that the destination is null terminated, whereas most (or all?) of the other `n`-string functions do. To safely concatenate strings, you can use the non-standard `strlcpy` (BSD-based Unices and Solaris) or `strcpy_s` (Windows). Alternatively you can roll your own, it's not too hard. If you do use `strncpy`, ensure your buffer is at least 1 bigger than the size you provide, and that that extra byte is the null terminator.
&gt; Hehe thank you for the Master Foo story. Wish there were more of it. [There is more.](http://catb.org/esr/writings/unix-koans/) It's not original to me. 
I'd recommend to just start hacking. Seriously. Strive to succeed but be prepared to fail, and if you do, learn from your mistakes. Good idiom is often best learned by simply trying things out. Feel for yourself what works and what doesn't. Programming is like that, it's not an exact science, and for most good programmers I know not something that they learned out of books.
What C books have you thus far read so that one might be able to give recommendations based on your current level of knowledge.
Anyone who claims C++ is a superset obviously does not know both languages. Other differences: 1. `long long int` is a standardised type in C, but not in C++, although many compilers permit it. 1. `_Complex [float|double|long double]` types (a.k.a. `complex [float|double|long double]` if `&lt;complex.h&gt;` is included). 1. Variable-length arrays. C allows an array's length to be determined at runtime (the `sizeof` operator must also return its dynamic size). A few C++ compilers also implement this but it's not in the C++ standard. 1. The keywords `static` and/or `const` may appear within the `[]` of a function's array parameter declaration, like this: void function(int array[static const 5]) { // do something } 1. The `restrict` keyword. 1. `__func__` is implicitly declared at the beginning of every function and has an array-of-char type containing the name of the function. 1. A function-like preprocessor macro in C is allowed to have a variable number of arguments (the variable arguments are referenced with `__VA_ARGS__`). Yes, these are C99-specific, but C99 was standardised around 1 year after C++ was standardised in 1998, so I don't think it's unfair to compare standards issued around the same time. 
All of those points are new features added to C99, and there is no reason they couldn't be added to a future version of C++. Most C++ compilers for example support _restrict_. On the other hand, type namespace pollution — which is what this code illustrates — is an area where C++ is fundamentally incompatible with C. 
That's why I cry when a recruiter asks what experience do I have in the language C/C++.
I understand your point (and it is a good one), but just because some/most C++ compilers support some of these C additions, it does not make it part of the standardised C++ language. The lack of these standard C features within standard C++ means that standard C++ is not a superset of standard C. C++0x includes/implements some of the above, but C1X introduces even more, such as `_Generic`, thread-local storage specifier, etc.
&gt; Not many people know this, but the C language (with the help of gcc extensions) ... That's a bit like saying: &gt; Not many people know this, but a car (with the help of a rocket booster) ... It's only useful to the people that have those tools available, and do not care about making sure that their code works with all compilers. The article demonstrates something pretty cool, I'll admit, but the title is a bit misleading.
...and what is easier to debug than massive macros with returns in them?
This is the same as [blocks](http://thirdcog.eu/pwcblocks/), right? Apple's version looks a lot cleaner, though they may not work exactly the same.
If I caught anyone using this in my workplace, I would ridicule them biblically. (I was going to say publicly, but biblically popped up on the dictionary, and I liked that word better.) Fuck this shit and everything about it. Just because you can do something with macros in C doesn't mean you should. If you want Containers, Templates and fucking Lambda Expressions, USE A DIFFERENT FUCKING LANGUAGE. &lt;/rant&gt;
To counteract the usual response, I'll just say I find this stuff neat. I wouldn't use it in real code, but it's cool to see someone figuring this kind of stuff out. It also shows people that there isn't any magic going on behind the scenes in higher level languages
I guess they're lambdas, but they are not closures. Therefore not nearly as useful as first class functions in other languages.
get off my lawn.
The test results are a bit sad (GCC 4.3.3) Running all the tests... Running test suite Beginning... Test a01: FAILED! Test a02: FAILED! Test a03: FAILED! Test a04: FAILED! Test a05: FAILED! Test a06: FAILED! Running test suite Consistency... Test b01: FAILED! Test b02: FAILED! Test b03: FAILED! Test b04: FAILED! Test b05: FAILED! Test b06: FAILED! Test b07: FAILED! Test b08: FAILED! Test b09: FAILED! Test b10: FAILED! Test b11: passed Test b12: FAILED! Test b13: FAILED! Test b14: FAILED! Running test suite Ending... Test c01: FAILED! Test c02: FAILED! Running test suite Uncaught... Test d01: FAILED! Test d02: FAILED! Test d03: FAILED! Test d04: FAILED! Test d05: FAILED! Running test suite Finally... Test e01: FAILED! Test e02: FAILED! Test e03: FAILED! Running test suite Caught... Test f01: passed Test f02: passed Test f03: FAILED! Test f04: FAILED! Test f05: passed Test f06: passed Test f07: passed Running test suite Signals... Test g01: passed Test g02: passed Test g03: FAILED! Test g04: FAILED! Test g05: passed Test g06: passed Running test suite Integration... Test h01: passed Test h02: passed Test h03: passed Test h04: passed Test h05: passed Test h06: FAILED! Test h07: passed Test h08: passed Test h09: passed Test h10: passed Test h11: FAILED! Generating report.... Done. This was clang 1.0: Running all the tests... Running test suite Beginning... Test a01: FAILED! Test a02: FAILED! Test a03: FAILED! Test a04: FAILED! Test a05: FAILED! Test a06: FAILED! Running test suite Consistency... Test b01: FAILED! Test b02: FAILED! Test b03: FAILED! Test b04: FAILED! Test b05: FAILED! Test b06: FAILED! Test b07: FAILED! Test b08: FAILED! Test b09: FAILED! Test b10: FAILED! Test b11: passed Test b12: FAILED! Test b13: FAILED! Test b14: FAILED! Running test suite Ending... Test c01: FAILED! Test c02: FAILED! Running test suite Uncaught... Test d01: FAILED! Test d02: FAILED! Test d03: FAILED! Test d04: FAILED! Test d05: FAILED! Running test suite Finally... Test e01: FAILED! Test e02: FAILED! Test e03: FAILED! Running test suite Caught... Test f01: passed Test f02: passed Test f03: FAILED! Test f04: FAILED! Test f05: passed Test f06: passed Test f07: passed Running test suite Signals... Test g01: passed Test g02: passed Test g03: FAILED! Test g04: FAILED! Test g05: passed Test g06: passed Running test suite Integration... Test h01: FAILED! Test h02: passed Test h03: FAILED! Test h04: passed Test h05: passed Test h06: FAILED! Test h07: passed Test h08: FAILED! Test h09: passed Test h10: passed Test h11: FAILED! Generating report.... Done. The GCC test had one segmentation fault and one FPU fault, but the clang test run had several segfaulters. Clang also complained that the format specifier `%.*s` requires the field width of type `int` but it has been given `unsigned int` (e4c.c line 994). This project still deserves applause I think, it looks like a lot of effort has been put forth here.
The seg/fpu faults are there *on purpose*, because the library can handle system signals (such as division by zero); some of the tests check the behavior of the system in the absence of the library, so they are supossed to crash. By the way, thank you very much for taking the time to test it. I will fix the unsigned int bug and try to find out why some of the tests are failing (I know it's lame but "they work on my machine").
Yeah I looked at the code to see what the story was and saw that some were meant to seg/fpu fault, I was mainly just mentioning that both GCC and Clang had different segfault results. I'll test on more implementations (I have a vast array to choose from!) and let you know about the results.
That would be just great. Thanks a lot.
writing perfectly correct c is hard
OK, I've just done some tests. Microsoft's VS2005 C compiler did not produce very good results. All of the tests in the "Beginning" suite failed from a stack overflow. Here are the results: Running all the tests... Running test suite Beginning... Test a01: FAILED! Test a02: FAILED! Test a03: FAILED! Test a04: FAILED! Test a05: FAILED! Test a06: FAILED! Running test suite Consistency... Test b01: FAILED! Test b02: FAILED! Test b03: FAILED! Test b04: FAILED! Test b05: FAILED! Test b06: FAILED! Test b07: FAILED! Test b08: FAILED! Test b09: FAILED! Test b10: FAILED! Test b11: passed Test b12: FAILED! Test b13: FAILED! Test b14: FAILED! Running test suite Ending... Test c01: FAILED! Test c02: FAILED! Running test suite Uncaught... Test d01: passed Test d02: passed Test d03: passed Test d04: passed Test d05: passed Running test suite Finally... Test e01: passed Test e02: passed Test e03: passed Running test suite Caught... Test f01: passed Test f02: passed Test f03: passed Test f04: passed Test f05: passed Test f06: passed Test f07: passed Running test suite Signals... Test g01: passed Test g02: passed Test g03: passed Test g04: FAILED! Test g05: passed Test g06: FAILED! Running test suite Integration... Test h01: passed Test h02: passed Test h03: passed Test h04: passed Test h05: passed Test h06: passed Test h07: passed Test h08: passed Test h09: passed Test h10: passed Test h11: passed Generating report.... Done. Microsoft VS2010 C compiler was much better though: Running all the tests... Running test suite Beginning... Test a01: passed Test a02: passed Test a03: passed Test a04: passed Test a05: passed Test a06: passed Running test suite Consistency... Test b01: passed Test b02: passed Test b03: passed Test b04: passed Test b05: passed Test b06: passed Test b07: passed Test b08: passed Test b09: passed Test b10: passed Test b11: passed Test b12: passed Test b13: passed Test b14: passed Running test suite Ending... Test c01: passed Test c02: passed Running test suite Uncaught... Test d01: passed Test d02: passed Test d03: passed Test d04: passed Test d05: passed Running test suite Finally... Test e01: passed Test e02: passed Test e03: passed Running test suite Caught... Test f01: passed Test f02: passed Test f03: passed Test f04: passed Test f05: passed Test f06: passed Test f07: passed Running test suite Signals... Test g01: passed Test g02: passed Test g03: passed Test g04: FAILED! Test g05: passed Test g06: FAILED! Running test suite Integration... Test h01: passed Test h02: passed Test h03: passed Test h04: passed Test h05: passed Test h06: passed Test h07: passed Test h08: passed Test h09: passed Test h10: passed Test h11: passed Generating report.... Done. I'll let you know the test results of other compilers once I have the time (sorry it took me almost a week just to get these).
I'm glad that many tests worked out this time! I'm surprised about the *stack overflow*, though. I'm looking forward the test results of other compilers, whenever you have the time. I really appreciate your help. I've been doing some research myself and noticed that some of the compilers just don't play nice with signals. For example, on Windows: * GCC 4.4.1 (TDM-2 mingw32) * GCC 3.4.2 (mingw-special) * Open Watcom 1.9 * Tiny C Compiler 0.9.25 Both GCC versions worked as expected (100% tests passed), but when compiled with Open Watcom or Tiny C Compiler, only the tests not related to signals passed. What I'm thinking now is that I need to create a test suite for the compiler itself, so at least I get to know when the library can rely on some specific platform behavior, or even play with the compiler's options to find out how to tweak it so the library works. What do you think about it? 
I have considered this aspect before, and I found myself going to C++ to use namespaces to make the identifier names shorter, but I still ended up preferring to specify the namespaces explicitly, defeating the the original point. In my own C++ code, I tend to specify all namespaces explicitly, never using the 'using' keyword, for fear of clashes and ambiguity on my part. I know there might be rules for namespace scoping precedence or the compiler will not let you form clashes, but I sure don't remember any of this, and when I'm reading my own code, I don't want to have to worry about it. Now I've gone back to C style naming, dumping all the namespaces explicitly in identifier names. I'm probably exceptional in this habit, though.
I finally have found out what was wrong with most of the tests! My *ad hoc* test framework was checking **the return value** of the function "system" in order to retrieve **the exit code** of each and every unit test. It turns out that in **POSIX** systems, one is supposed to use the **WEXITSTATUS** macro in order to retrieve the actual exit code. So, most of the tests were actually succeeding, but the test framework could not check their exit codes properly and therefore they seemed to be failing. Now I am fixing my test framework up and I will let you know when the repository is updated. 
Hi again, dreamlax. I have re-written most of the test framework and now it works 100% on my Ubuntu box. Could you please verify it on some of your implementations? Thanks a lot in advance. By the way, I've simplified the testing process. Now you can simply download a [Makefile](http://exceptions4c.googlecode.com/svn/trunk/test/Makefile); it will fetch the rest of the source files (through wget) and then compile everything. 
Sure thing, just on my way into work now (I only just now saw your previous comment about fixing up your test cases, I didn't get an orangered).
If you make BEGIN/END_SCOPE expand to a couple of braces, you can automatically detect if they fail to match up.
Hmmm. It's a good idea, but I think that it will break some things. END_SCOPE_AND_BREAK, which is not used in the example, defers to END_SCOPE for running the destructors. If I'm not mistaken, END_SCOPE_AND_BREAK currently supports "fall through", but wouldn't if BEGIN_SCOPE and END_SCOPE expanded to a couple of braces. Another thing is that one does not always have to use BEGIN_SCOPE, which can be convenient because I imagine that it can be easy to forget. In the example, for instance, I have: if (! APR_STATUS_IS_SUCCESS(apr_status)) { fprintf(stderr, "`apr_app_initialize` failed: %s\n", apr_strerror(apr_status, s_1KiB_buf, sizeof s_1KiB_buf/sizeof s_1KiB_buf[0])); END_SCOPE_AND_RETURN(EXIT_FAILURE); } 
I like it, though generally I am opposed to "clever" macro code used to implement features from another language when you could just use that language. But cleanup code is I think one place where it can't hurt. The other obvious option is to use goto, and thats been popular in some circles, but obviously a lot of people just avoid goto no matter what and get irked when they see it. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main(int argc, char *argv[]) { char *a, *b, *c, *d = NULL; a = strdup("This is the first string."); if (a == NULL) { fprintf(stderr, "Could not allocate string for 'a'.\n"); goto main_end; } b = strdup("This is the second string."); if (b == NULL) { fprintf(stderr, "Could not allocate string for 'b'.\n"); goto main_end_b; } c = strdup("This is the third string."); if (c == NULL) { fprintf(stderr, "Could not allocate string for 'c'.\n"); goto main_end_c; } d = strdup("This is the fourth string."); if (d == NULL) { fprintf(stderr, "Could not allocate string for 'd'.\n"); goto main_end_d; } fprintf(stdout, "The strings are:\n %s\n %s\n %s\n %s\n", a, b, c, d); /* Cleanup */ free(d); main_end_d: free(c); main_end_c: free(b); main_end_b: free(a); main_end: return 0; } Is this all that bad? I don't know. Obviously if you have a very large amount of allocation and cleanup, you would have a lot of different labels, and it could get messy very quickly, such as ODBC code for example where you are binding 20 or so columns and managing resources for that, and each cleanup step is laborious. Also, reordering is still an issue. If you move things around, you need to move them around in the cleanup code, so its possible to introduce errors. I like the macro solution, its not too hard to understand what the macro is doing, and its clear that it's a macro being used there - most importantly anyone else jumping into the code for the first time might look at the code and they won't go "wtf" as the macro have clear definitions. I've been handed code to maintain that I've had to throw out wholesale, because they've used loads of macro tricks and other tricks, and the density of the tricks reached a point where it was cheaper for me to just rewrite it in a readable maintainable way instead of trying to learn how the previous developer thought.
Sorry for the 2-week delay on this. I had to punch holes in my work's HTTP proxy to allow wget to download properly (the HTTP proxy we have is unnecessarily strict). After I got through that, I finally found some time to collate the test results (again, I am *very* sorry for the delay). The following tests were performed on different flavours of Ubuntu: * GCC 2.95 on Dapper: Did not compile * GCC 3.4.6 on Dapper and Jaunty: All tests OK! * GCC 4.0.3 on Dapper and Jaunty: All tests OK! * GCC 4.1.3 on Jaunty: All tests OK! * GCC 4.3.3 on Jaunty: All tests OK! * Clang 1.0 on Dapper and Jaunty: Failed tests: * `unit_test_h01` [X03] * `unit_test_h03` [X03] * `unit_test_h08` [X03] * tcc 0.9.25 on Dapper and Jaunty: Did not compile. The following tests were performed on Mac OS X 10.6: * GCC 4.0: Failed tests: * All `unit_test_a` [X23] * All `unit_test_b` [X23] **except `unit_test_b11` (passed)** * All `unit_test_c` [X23] * All `unit_test_d` [X23] * All `unit_test_e` [X23] * `unit_test_f03` [X23] * `unit_test_f04` [X23] * `unit_test_g04` [X2E] * `unit_test_g05` [X23] * `unit_test_g06` [X23] * `unit_test_g07` [X0E] * `unit_test_h06` [X23] * `unit_test_h11` [X23] * `requirement_z02` [X23] * `requirement_z03` [X23] * `requirement_z07` [X03] * `requirement_z08` [X23] * `requirement_z09` [X23] * GCC 4.2 * All `unit_test_a` [X23] * All `unit_test_b` [X23] **except `unit_test_b11` (passed)** * All `unit_test_c` [X23] * All `unit_test_d` [X23] * All `unit_test_e` [X23] * `unit_test_f03` [X23] * `unit_test_f04` [X23] * `unit_test_g04` [X23] * `unit_test_g05` [X23] * `unit_test_g06` [X23] * `unit_test_g07` [X23] * `unit_test_h06` [X23] * `unit_test_h11` [X23] * `requirement_z02` [X23] * `requirement_z03` [X23] * `requirement_z07` [X23] * `requirement_z08` [X23] * `requirement_z09` [X23] * Clang 1.0 * All `unit_test_a` [X23] * All `unit_test_b` [X23] **except `unit_test_b11` (passed)** * All `unit_test_c` [X23] * All `unit_test_d` [X23] * All `unit_test_e` [X23] * `unit_test_f03` [X23] * `unit_test_f04` [X23] * `unit_test_g04` [X23] * `unit_test_g05` [X23] * `unit_test_h01` [X03] * `unit_test_h03` [X03] * `unit_test_h06` [X23] * `unit_test_h08` [X03] * `unit_test_h11` [X23] * `requirement_z02` [X23] * `requirement_z03` [X23] * `requirement_z07` [X23] * `requirement_z08` [X23] * `requirement_z09` [X23] If you would like specific log files just let me know and I can email them to you or post them here.
Hey, no worries at all about the timing... on the contrary, I am deeply grateful. These test results are of great value to me. And yes, it would be even more helpful if I could read the log files. Please send them to 1234@gmail.com (guillermocalvo instead of 1234), or post them here, whatever is more convenient for you. I will analyze all this information and try to figure out how to solve the failed tests (and, specially, the compilation errors) on those platforms. I'd like to know your opinion on the Makefile: apart from the HTTP proxy issue... do you think that it's handy, or should I remove the `wget` stuff?
Hey mate, I've finally allocated some time to collate the previous results and mail them to you! Busy at work being the end of the year and all that (sorry again).
Yeah, I so understand you. I'm busy these days too and I just haven't been able to check it out yet. Next week I hope to get the time to analyze it and write you back. Thank you for being so kind and helping me out with my library.
int class; There are also some scoping differences if I remember right, Bjarne has some examples in his book.
&gt;Never think to write malloc-fail-proof code without testing it thoroughly, otherwise you haven’t written malloc-fail-proof code. Coding around malloc failing is like coding around the processor failing. 
1. Install Linux 2. Install Eclipse CDT 3. ? 4. Profit
use vim
First time I heard about G-WAN was in an [answer on Stack Overflow](http://stackoverflow.com/questions/388602/are-there-any-good-and-free-libraries-to-develop-web-applications-in-c/4901032#4901032). Yesterday. 
I used Mingw and it is pretty nifty.
That's a terrible answer. Stop trolling.
Thanks! I always fail at the makefile part though; I'd neither seen nor heard of one until I tried to set up eclipse. What belongs in a makefile, and how to do I find out how to create one properly? I'll try following your steps again; right now we're just happy that it sort of works; the console window won't output until we finish debugging though... I don't really buy into the linux vs windows or 'use vim' hype. I know people that can't get Eclipse set up on linux either, so I agree with you there! I also can't imagine that people who solely debug with command line and printfs are very good programmers...
Looks interesting but since its linux only and there is no source I'll probably never try it. I would like to see speed tests between this and node.js 
&gt; since its linux only ??? &gt; speed tests between this and node.js ??????
Do you have a question? From the website: &gt; G-WAN/Windows is frozen to v1.0.5, missing features like SSL/TLS, Service mode, virtual hosts, HTTP compression, Handler and Maintenance scripts, ability to run any C source code file (not G-WAN related), linking with static or dynamic libraries (lib/dll) and C source files, GIF I/O, Area/Bar/Dot/Line/Pie/Ring Charts, frame-buffer primitives, JSON (de)serialization, on-the-fly CSS/JS/HTML reduction, CSS Data URIs, compression, crypto, HW and SW random numbers, hashing, checksums, and many exported functions made available to C scripts. Those are pretty important features for a web server. http://nodejs.org/ is a webserver written in Javascript and it is incredibly fast. Since G-WAN is also claiming incredible speeds, it would be nice to see how the two compare. 
&gt; Those are pretty important features for a web server. OK, that's fair. &gt; http://nodejs.org/ is a webserver written in Javascript Shit, I thought it was just a framework. (does more research)
What would reddit suggest as the way to test malloc() fails without too much hassle?
An interesting program by an intelligent person who is good at recognizing patterns. I would say that he's too good at it by reading the manual. The program itself seems to be a fun project but its closed sourceness is somewhat problematic for me.
 One of the most common reasons why malloc fails is not because it is out of memory, but because of a buffer overflow somewhere else that thrashed the memory struct malloc uses to manage each allocated buffer. If that's what's happened (program memory corrupted), how should you handle that? Do you really want to try logging something to disc? Or print to screen? Are you sure it will work with your corrupted memory? If you are going to test for malloc failing, The best you can do is exit(). 
I finally got this setup to work; I had to add some paths within eclipse as well (http://dev.eclipse.org/newslists/news.eclipse.tools.cdt/msg11853.html) Does your console output work while debugging? My console doesn't output until I'm done.
Holy shit! Thank you for posting this.
Gut feeling is it's a bad idea, no idea why I feel that way though. Just not something you want to ship with your actual code, I guess. I recommend you take a look at the [google test framework](http://code.google.com/p/googletest/). Don't let the webpage fool you; it'll work just as well for C as it will for C++. 
agreed.
It will increase your executable size. However you can get around this by not building the test code in the final 'release configuration', using preprocessor conditions.
Don't ruin your pristine application code with a bunch testing crap. It's important to test and get the bugs out of your code, but long term what's even more important is the code itself. 
If you can end up with a clear separation of actual code and testing code then that sounds fine. Not sure what you would gain though. Would it not be easier to add a "tests" target to your makefile, so that `make tests` would simply invoke the unittesting framework and run the tests?
 int* a[3], b[42]; /* ;-) */
Let's say I have: int b[3] = {1, 2, 3}; And then declare one of the following: int (*a)[3]; /* or */ int *a; And then set: a = &amp;b; Are both 'a' declarations identical? Is the first only useful for getting compiler warnings/errors if I try to go past a[2]?
They're only identical in that they're both pointers and ints are involved. :) // in the definition: // // a is type "pointer to array of 3 ints" // b is type "array of 3 ints" // c is type "pointer to int" int b[3] = {1, 2, 3}; int (*a)[3]; int *c; // in an expression: // // b is type "pointer to int" // &amp;b is type "pointer to array of 3 ints" a = b; // TYPE MISMATCH a = &amp;b; // ok c = b; // ok c = &amp;b; // TYPE MISMATCH 
cdecl is an indispensable tool. http://www.cdecl.org/
Are you beej as in Beej's Guide to Network Programming? So I wrote a simple program to understand what I thought (*a)[3] meant: 1 2 #include &lt;stdio.h&gt; 3 4 int 5 main(void){ 6 int b[3] = {1,2,3}; 7 int (*a)[3]; 8 int *c; 9 int i; 10 11 a = &amp;b; 12 c = b; 13 14 for(i = 0; i &lt; 3; i++){ 15 printf("%i, %i\n", *a[i], c[i]); 16 } 17 18 return 0; 19 } 20 And then: ryan@papabear:~/intarrays$ gcc -o a a.c -Wall -Wextra -pedantic ryan@papabear:~/intarrays$ ./a 1, 1 0, 2 -1093151712, 3 I was expecting this to output 1,1; 2,2; 3,3. So how does (*a)[3] work? Edit: Right after I posted I got it: Change line 15 to: printf("%p, %p\n", a[i], &amp;b[i]); Output becomes: 0x7fff11184ac0, 0x7fff11184ac0 0x7fff11184acc, 0x7fff11184ac4 0x7fff11184ad8, 0x7fff11184ac8 So then I changed line 15 to: printf("%i, %i\n", a[0][i], c[i]); And the output becomes: 1, 1 2, 2 3, 3 Edit 2: Wait something doesn't seem right about that... Actually line 15 should be (I think): printf("%i, %i\n", (*a)[i], c[i]); But then what about the output from 'printf("%p, %p\n", a[i], &amp;b[i]);'...that doesn't quite make sense
Note that it's a command-line tool. There's a link to the source on the web page. The web app is just a front end to it.
This is the best explanation of how to read complex function pointer declarations I've ever encountered. Thank you! 
Here's [another](http://ieng9.ucsd.edu/~cs30x/rt_lt.rule.html) to compare it against.
Actually I got curious and looked up my K&amp;R and I believe the author meant K&amp;R when he mentions some book in the 80's. Because in chapter 5.2 they cover the golden rule, but in their own words. So the golden rule itself could have been something he thought up based on that chapter. 
Sure it's in K&amp;R, and that's the original source for a rule retold in many forms. There were several very good books from the 80's that might have mentioned it - if could have been [Harbison &amp; Steele](http://www.amazon.com/Reference-Manual-Samuel-P-Harbison/dp/013089592X) that he recalled. If you're actively coding in C and like books, H&amp;S is the best reference outside of the actual ANSI standard.
Wouldn't #pragma pack solve the problem?
Why does the C implementation look so much less verbose?
I believe this is because when C was designed they figured it would be used in a Unix environment and thus made certain assumptions about the kind of behavior users wanted that Go doesn't.
While reading this, I discovered the [duffgrams](http://iq0.com/duffgram/index.html) on the same site. Very useful!
Any one has a mirror? 
Heh, what is going on here? curl -Is slashdot.org | egrep '^X-(F|B|L)' | cut -d \- -f 2 
As I [have benchmarked](http://attractivechaos.wordpress.com/2008/10/07/another-look-at-my-old-benchmark/) a few years ago, my single-header [khash library](https://github.com/attractivechaos/klib/blob/master/khash.h) is faster and much more lightweight than uthash. Even if you do not like my library, there are more decent C hash table libraries (e.g. glib and stb.h) than uthash, which I believe chose a wrong way. Generic programming should not come at the cost of speed or memory.
For now, Go is way behind C on efficiency. Go is actually slower than Java and in some cases even luajit.
Too complicated. Sometimes when I don't want to write makefile for simple project I simply add: #if 0 gcc $0 -o ${0%.*} $* &amp;&amp; ./${0%.*} exit 0 #endif 
 curl -Is slashdot.org Download headers from slashdot, skip error message. egrep '^X-(F|B|L)' Show only lines starting with X-F, X-B or X-L. cut -d \- -f 2t Treat input as columns separated by -. Return second column. It transforms HTTP/1.1 200 OK Server: Apache/1.3.42 (Unix) mod_perl/1.31 SLASH_LOG_DATA: shtml X-Powered-By: Slash 2.00500120110610 X-Bender: Gimme your biggest, strongest, cheapest drink. X-XRDS-Location: http://slashdot.org/slashdot.xrds Cache-Control: no-cache Pragma: no-cache Content-Type: text/html; charset=utf-8 Content-Length: 89087 Date: Tue, 14 Jun 2011 09:46:26 GMT X-Varnish: 1343580823 1343580215 Age: 57 Connection: keep-alive to Bender: Gimme your biggest, strongest, cheapest drink.
for short, one-file C programming I absolutely love [tcc](http://bellard.org/tcc). It lets you do this: #!tcc -run #include&lt;stdio.h&gt; int main() { printf("Well, that's convenient!"); return 0; }
A few more I can think of: - C++ doesn't allow recursive calls to main - size('A') is 4 in C, 1 in C++ - char foo[3] = "foo" is illegal in C++ - C++ is far stricter with casting. C doesn't require casting void* to other types
No source = no download.
This makes me wonder what kind of hacks and nasty "phone home" code lies in there. I'd shoot myself in the head before I touch it. edit: I read a few posts on the forum. The author seems very cocky. Anyone who risks investing time into an web app for this G-WAN is mentally insane. If that guy gets hit by a bus, gets bored or otherwise stops maintaining "the masterpiece", all the time, effort and money which went into developing for G-WAN goes to waste.
C++0x helps with a lot of this verbosity. The author probably never seen Java code, otherwise he wouldn't say "the extreme verbosity of C++". And readability is a matter of taste. Personally I find .begin() and .end() more readable than pointer arithmetic.
This is, of course, complete nonsense. The correct way is std::for_each&lt;&gt;, and is a one-liner. Like usual, the moaning about C++ is being done by someone who barely speaks the language and has comments turned off on their blog.
Java is all the time overly verbose, but C++ does have its moments. `vector&lt;somenamespace::someothernamespace::sometype&gt;::iterator someiterator = somecollection.begin();` isn't the sort of thing I'd call concise. But then, that's where C++0x saves the day with type inference.
That's exactly what I was referring to. `auto` is one of the best new features.
Dup of post in [r/coding](http://www.reddit.com/r/coding/comments/i8048/weakness_of_stl_over_plain_c_types/)
auto and typedefs fix a lot of that.
I agree. I can provide verbosity fixes and allocation pattern fixes for every single example in that article. 
`auto` and `decltype` fix probably all of that. I'm not sure why you'd use `typedef` instead of either of those, though there is probably a case.
&gt;Like usual, the moaning about C++ is being done by someone who barely speaks the language and has comments turned off on their blog. As expected of Obj-C programmer. /trolling
&gt;if 0 == flag.NArg() { ಠ_ಠ
You're having issues with file I/O. You need to open the file with append to append lines. Also don't forget to close the file after you're done. I recommend Googling for tutorials on the topic. Also consider writing a separate smaller program to get used to file I/O.
[K&amp;R](http://en.wikipedia.org/wiki/The_C_Programming_Language) That's all you need.
K&amp;R is really the best place to start, but one thing that's invaluable just for learning good practices and idioms is actually the [GNU C Library Manual](http://www.gnu.org/software/libc/manual) -- just stay away from the GNU extensions if you want your code to be portable.
K&amp;R is good, but I also felt [Programming in C](http://www.amazon.com/Programming-3rd-Stephen-G-Kochan/dp/0672326663/) was a very well written book and at a reasonable price.
If you're near the northwest suburbs of Chicago, I'll be giving a talk called "Just Enough C for Open Source Projects" in two weeks. :-) http://petdance.com/2011/07/ill-be-presenting-just-enough-c-for-open-source-projects-july-19th-at-software-craftsmanship-mchenry/
^^ The GNU C library documentation made all the difference for me.
Unfortunately I'm in the northwest suburbs of Philadelphia. Otherwise I'd be there in a heartbeat.
Here are my slides, if that's any help. http://www.slideshare.net/petdance/just-enough-c-for-open-source-programmers
You'd do yourself a favor if you get a copy of The New Testament ("The C Programming Language, 2nd. Ed.", a.k.a "K&amp;R"). Very seriously - K&amp;R is one of the two or three best technical books I've ever laid eyes on. I learned C form the Old Testament (K&amp;R 1st. Ed.) back in the day. If that's not an option, do it anyway eventually unless you're opposed to actual books. Web resources that might help until you obtain and work through K&amp;R: * [C FAQ](http://c-faq.com/) - read it. know it. live it. (except the bits I disagree with, of course ;) * [The C Book](http://publications.gbdirect.co.uk/c_book/) - online book on C. I've only skimmed it (I have a couple copies of K&amp;R, &amp; have been coding C since the early 80s, so I'm not the target audience), but it doesn't look bad on the surface, anyway. * [EDU tutorial](http://einstein.drexel.edu/courses/Comp_Phys/General/C_basics/#first)- not sure it's that good, but it's the top link in gooooooooogle, so hey, it has that going for it. It's also shorter than the online book, if you're the tl;dr type Two other things: * "strings" in C are typically "char arrays" and "pointers to char" or "char *" or "char pointers". That will make it easier for you to search for info. * for basic I/O, you'll mostly want to use the functions in the &lt;stdio.h&gt; header (printf, fprintf, fgetc, etc.). Again, that'll probably make it easier for you to search.
[C in 21 days](http://www.phy.hr/~matko/C21/) is really good for readability, just double check what you learn with more formal books like K&amp;R.
Oh my god this is perfect. Thank you so much. I've set a time limit of 2 months to learn C as best I can.
make is just a build environment, it has fine performance, especially when dealing with multiprocessors or grid agents. (learn make -j) it's parser is basic because it doesn't need to be more. if you wanted more functionality you can use an actual language, or scripts to do whatever you want it to do... make is a build tool, not a development language. php, phython, java, javascript none of these PROFESSIONAL DEVELOPMENT languages throw errors when a variable is undeclared. why should make? again, not a development language, but a build tool. as far as conditional syntax, make doesn't require this, it's a build tool, if you need your build to make some sort of decision there is SOME compatibility for that, but if you want it to make complex decisions, use a scripting language (i like m4) use the right tool for the job. again, := vs =, make isn't a programming language, and most times you WANT the = (as like #define) it's a build tool, with "search and replace" functionality, not a development language. i think whoever wrote this article doesn't really understand make or how to use it, maybe they'd be more comfortable programming perl build.pl files.
Maybe something about the size of a data type in bits? :/
It's there to keep it from being confused with 22.
i bet you it's jsut because some company policy to never use magic numbers and someone took it too far or chose a bad name
Someone probably set a standard to always use a define for values that can possibly change in the future, so instead of putting #MAX_ITEM_SIZE they failed miserably. :P
I'm constantly seeing things like #define MAX_COUNT_STR "max-count". It makes me homicidal. 
out of context. this might actually be not so stupid - but to know that you should provide context.
why? at least MAX_COUNT_STR is a symbol that can be checked during build time for correct spelling. if you write somewhere "nax-count" instead of "max-count" the compiler won't catch it.
because it obscures the code for almost no benefit. Yes, finding the undefined is the one benefit...but code clarity for the maintainer is *so* much more important, and I'm sorry, if you're not careful enough to spell a string key correctly, you're not careful enough to program. 
&gt; if you're not careful enough to spell a string key correctly, you're not careful enough to program stop trolling
Whilst i do not deny c++ is verbose, i also believe that 0x sorts out almost all of the mentions problems stl alg (note i aren't quite sure wht your try to achieve here (because you right it is ugly) but something like list&lt;int&gt; l{4,5,6}; find_if(l.begin(), l.end(), [](int a)-&gt;bool{ return a&gt;=0; }); iterate int a[size] = {1, 2}; for (int *p = a; p != a + size; ++i) printf("%d\n", *p); or vector&lt;int&gt; a{1,2}; for(int &amp;b: a) cout&lt;&lt;b&lt;&lt;end; Also with the getBuffer problem, whilst it's definition is verbose, the input iterator type could easy also be template argument allowing you to pass in any valid iterator
I'm fairly sure that's the reason too. I mean, it certainly could have been named better; but if it cuts down on the magic numbers then that's a Good Thing. Even though it's named "SIXTEEN", searching for that rather than the constant 16 is much easier, so a search-and-replace should be fairly easy (assuming the word doesn't crop up as part of other identifiers/macros).
Totally serious
It's still preety funny.
I think it would help if you would share the kind of things you are looking for, as often you can pick and choose the things you are trying to use that day rather than including all of glib for instance.
For all binaries on your system, run ldd and keep the first term for the libraries used. Judicious use of find, xargs ldd, sort, uniq -c and sort again should yield a useful answer. You'll see libm libdl libc libpthread, libpcre, etc. 
http://apr.apache.org/ http://www.nongnu.org/confuse/
I cannot recommend libconfuse enough. I've tried many config file libraries, and short of embedding a scripting language (like Lua, which is also great), libconfuse remains the best in my opinion.
glib2 is fairly popular even outside of gnome programming. I personally don't like it that much but it doesn't really have an alternative in terms of coverage.
Well, I was thinking about memory management, data structures and string handling mostly.
If you want to embrace the madness and use macro-based generics (they're typesafe, just hope you never have to debug the macro), I really like the [klib](https://github.com/attractivechaos/klib) stuff from Attractive Chaos. What I'm really starting to get into is Lua (extending it with C modules rather than embedding Lua into C programs). It really is one of the most elegant and simple languages/APIs ever, and it feels like such a perfect match for C.
I'm the mod for [/r/msp430](http://www.reddit.com/r/msp430). I don't have any problems with you cross-posting Launchpad, Chronos, or *any* MSP430 powered devices in /r/msp430. In fact I would encourage it since we're not exactly swamped with submissions. Personally have two launchpads, and a chronos, amongst other dev kits. I updated /r/msp430's side bar to show my support for the other MSP430 subreddits.
Great, I would like that. I hope I'm not fragmenting the community in any way, I didn't realize there was so much launchpad posts going on there. Thanks for your support!
Oh this is grand, I had purchased a couple of launchpads and never got around to using them; however, I was cleaning my desk yesterday and upon finding them thought that I should check if there existed sub-reddit dedicated to them.
This last one is what got me. I know my knowledge of c++ hits a wall in a fast and painful way but even with that I was wondering why that last one wasn't a template based function.
If you want to debug macro-based code, you may use: gcc -E test.c|grep -v ^# &gt; test-inc.c; indent test-inc.c 
At a cursory glance, its conf file format looks very similar to Boost.PropertyTree's INFO format. I'm curious if it can write to the config file similarly to Boost.PropertyTree?
* Lua - http://www.lua.org/ * SQLite - http://www.sqlite.org/ * libmd - http://martin.hinner.info/libmd/ * JSONCpp (C++) - http://jsoncpp.sourceforge.net/ * TinyXML (C++) - http://www.grinninglizard.com/tinyxml/
I hate windoze and Cygwin, so my first thought is to say dual boot with Linux if you want to be a programmer, it will make your life easier. But if you don't want to, why not try downloading the [windoze version](http://www.eclipse.org/downloads/?osType=win32) of eclipse?
Well as I said, its the first course ever in Programming. (Programming A - don't know if this apply outside of Sweden) I rather not dualboot just of this course. I've never used Linux aswell so. Thanks anwyay - maybe in the future if I stick with programming. And I have the windowz version of Ecplise and I have Cygwin. Its just that it doesn't work. Cheers.
It sounds like Eclipse expects you to explicitly build the file with ctrl + b before you try to run it when coding C or C++. [This guy](http://codingrecipes.com/eclipse-launch-failed-binary-not-found-and-netbeans) ran into the same issue, it looks like he solved it by using netbeans, but the comments on the blog have workarounds for Eclipse. 
hmm I guess you need to code in a sort of Linux environment? This this a requirement for the course? If not I recommend: http://www.microsoft.com/visualstudio/en-us/products/2010-editions/visual-cpp-express Maybe this could be a solution: http://www.vmware.com/products/player/ Install Ubuntu on it and either run Eclipse or just use make and some editor I've used both of these methods myself. Hello from another Programming Swede.
You probably need to [tell Eclipse where the tools are](http://help.eclipse.org/indigo/index.jsp?topic=%2Forg.eclipse.cdt.doc.user%2Freference%2Fcdt_u_prop_build_settings_tool.htm), or just [add c:\cygwin\bin](http://www.astro.umd.edu/~harris/cygwin/) to your [PATH.](http://geekswithblogs.net/renso/archive/2009/10/21/how-to-set-the-windows-path-in-windows-7.aspx)
This is not a IDE specific subreddit.
http://max.berger.name/howto/cdt/ar01s05.jsp#nomake
Lectures: 4 - 7
This guy is a fucking idiot. He's teaching all kinds of things that are wrong. He's spewing garbage like "You can't dereference a void pointer." Of course you can -- you get a byte. You just have to be careful to cast the result properly. Modern C is built on void pointer dereferencing. Second, teaching folks to pass around signed ints instead of size_t or at least unsigned ints as a parameter indicating the size of a segment of memory is sloppy at best and just plain bad teaching. Also, integers are not four bytes. He states repeatedly as a matter of fact that integers are four bytes and always will be four bytes. I remember when integers were two bytes. Now they're eight. You cannot make statements like "an integer is four bytes" -- you must explain to the students that integers are sizeof int bytes, and sizeof int may be one number on one architecture and a different number on another architecture. And when swapping ints, you shouldn't need an intermediary value to begin with. Also -- perhaps most annoyingly -- (int *) is pronounced "int pointer". Not "int star".
Might I humbly suggest you try mingw instead of cygwin? I've found it to be much easier to work with for simple things like you're doing. Tomorrow evening I'll have time to put together a step by step if you like. I just got finished with my own CS homework and I must sleep for 5 hours before getting up for work tomorrow.
Get VMware, install linux, mint, ubuntu or crunchbang, use linux, no need to dual boot, still get the benefits of linux.
Well, as much as I agree on some parts you write here, I'm not going to argue about quality of teacher, because point was in examples and how to write generic stuff. Only one question. Can you give me more info about "dereferencing void pointer get a byte"? I really don't remember anyone said it anywhere, so i would appreciate it. It was always: don't do it, or cast it to original type first. Hmmm, well in freeradius i've seen using void ** and dereferencing, but i'd really like to see what,where and how. Thank you. 
Or using clang. It gives much much better errors and warning in dealing with macro issues than gcc.
Thanks for the good suggestion. I will try.
libevent -- awesome.
According to author Dan Saks, "The simplest way to read and write const declarations correctly is to use an unconventional style."
Great article, thanks. It pisses me off that every time such concepts are implemented, there's people in the comment section saying that C isn't good because you can do this concept natively in language X.
Haha, so true. 
Depends - if you have other good reasons to use C, then these tricks are useful. Otherwise using language that supports it natively can be cleaner. Choose a right tool for a job. I quite often use two or more languages per application, depending on what is easier to do in some language. ;)
This unfeature of C is *so* annoying. Have to say I begrudge the missing carry information so much that in the past I've resorted to assembler when necessary. For example, here's some code I have to accumulate 64-bit numbers into a 128-bit accumulator: #ifdef __i386__ static void accum128_64(uint128_t *acc, uint64_t val) { __asm__( "addl %[vall], 0(%[acc])" "\n\t" "adcl %[valh], 4(%[acc])" "\n\t" "adcl $0, 8(%[acc])" "\n\t" "adcl $0, 12(%[acc])" : : [acc] "r" (acc), "m" (*acc), [vall] "r" ((uint32_t) val), [valh] "r" ((uint32_t) (val &gt;&gt; 32)) : "cc" ); } #else static void accum128_64(uint128_t *acc, uint64_t val) { *acc += val; } #endif Sigh. Portability flies straight out the window. Fortunately doesn't matter here, I'm happy with gcc on x86[_64]. I know I can use the change of sign tricks documented in the linked posting to recover the carry ... but the generated code is horrid.
pcre for regular expressions - http://pcre.org/
Nice and tasteful just like the man.
Aww. That just made me tear up a bit. It took me far too long to recognise his name.
I don't know, so here's an ugly perl one liner: perl -MFile::Find -MFile::Slurp -e'my%w;find(sub{return unless-f&amp;&amp;/\.txt$/;$w{$_}++for map{split/\W/}read_file$_},q{.});print map{qq{$w{$_} $_\n}}sort keys%w' 
Thank you for this ugly pearl one liner.
&gt; How do we know that we are looking at a directory vs. a file Look at an existing implementation. Here's [FreeBSD](http://svnweb.freebsd.org/base/head/contrib/file/)'s implementation of `file`. &gt; How do we get to other directories within a directory? man 3 directory 
nothing like making your source files longer by needlessly putting the open brace on a line all by itself..
I'll do what I feel like doing.
That's right, that's why it says "control structure."
I always put my opening bracket on it's own line because then it's symetrical with the closing bracket. :)
W hy ?
Like I'm taking formatting advice from someone who can't spell symmetrical? Or its?
Ok, I made a typo on symmetrical, but "it's" is a contraction of "it is". As in "because then it is symmetrical". :) 
While I mourn his passing, I will have to find an alternative way of remembering him. My braces will be placed firmly on the following line, where they can be easily visually matched to one another. This incurs no counter-acting loss of comprehension, since I can have more than twenty-five lines on my screen in one go these days.
Not necessarily - I like putting a useful comment describing the purpose of contained block in same line as opening brace. Looks neat (ok, the example is too trivial for adding a comment). if (i % 2 == 0) { // output even numbers printf("%d", i); }
Just because two different domains use the same term, it does not follow that the conceptual meaning of the term as used by the distinct domains are equivalent. (Natural) language != (programming) language. It's hard to write a BNF for a natural language grammar. It's messy, and not just because terms are reused either. I don't think it's valid to assert that his grasp of any natural language (especially when used in an informal context, like in this case) implies an inability to formulate himself in a programming language. It also seems flatly contradicted by my personal experience with programmers, who can often act sloppy and impatient with non-formally defined 'spaghetti' natural languages. Or Perl.
I don't think the parallel you guys are making here is valid: The block following a statement is not a part of a sequence in the sense a letter is part of a word, or even the way a word is part of a sentence. If we are to stick with the analogy, it's more akin to a paragraph. And we use line breaks to separate those to enhance the readability of what we write too.
Not wanting to be too critical (to each his own...) but I find this very cluttered.
...and doesn't notice that there are two "it's" in his own post, even when already clued that one is wrong.... 
It's been my experience that care in language correlates very well, both positively and negatively, with care in engineering. 
Quite, and I've experienced that as well. Especially former chemists having converted to programming (happens surprisingly often, apparently - I've had the pleasure of working with several) tends to exercise great formal care and tend to strive for complete understanding of what they're doing. Could have something to do with coming from a field where minor errors in allowing for ambient temperature can lead to being spread rather thin over the walls of the lab. But lack of attention when writing software can have (and has had) terrible consequences too, and so we programmers would do well to display more professionalism -- like (less abstract) engineers, and for the same reasons.
You should pass it to each function. If you make a global variable, it is passed to each function implicitly (any function can access it). If you make the array in main(), and pass it to each function that needs it, you can control access to the array. You can see clearly which function can access it, and if you pass it as a const pointer you know which functions can read it, and which can read or write to it. Edit: spelling
My Data Structures professor calls 'putting the opening block braces on the same line' as the new school way to do it. She says braces on a new line is old school.
shit. you win. :)
What's wrong with if (i % 2 == 0) { // Output even numbers printf("%d", i); } ?
#included &lt;stdio.h&gt; main() { [printf ("Dennis Ritchie has died, requiescat in pace.\n"); return 0; }
But... But.... the coding standards at my company MAKES me put them on a separate line. :(
**No.** I will remember Dennis Ritchie for designing a free-form language which allows the programmer to control the placement of braces.
Like [this](http://code.google.com/p/unix-jun72/source/browse/trunk/src/c/cc.c)
\#define DOZEN 64 Because, apparently, a few years after it was made, the program had to process more than a dozen files.
And a lot lot [more](http://david.tribble.com/text/cdiffs.htm)
It's pretty straightforward, the same as you do any dynamic memory allocation: ... struct node { int value; struct node *next; } *node_array; size_t node_array_len; ... int main(void) { node_array_len = ... node_array = malloc(sizeof(struct node) * node_array_len); ... } void traverse_one(int n) { struct node *ptr; assert(n &lt; node_array_len); for(ptr = &amp;node_array[n]; ptr; ptr = ptr-&gt;next) { do_something_with(ptr-&gt;value); } } You don't have to store the size as a global variable but otherwise you'll have a pretty hard time staying in bounds. 
For something like a memory allocator, that's not very realistic. You would end up passing it along to every function, because it might be required in a leaf function somewhere down in the call stack. Also, const pointers to the heads of linked lists aren't going to help at all from a const correctness standpoint, because they don't prevent adding or deleting elements at the end of the chain, or modifying elements in the middle of the chain. They would only protect the head element. 
I thought you couldn't declare an array from an unknown size. int grades[arraysize]; should give you problems. You would have to use some malloc/free stuff to handle an array if you don't know the size beforehand.
The main function should be returning an integer, namely 0. int main( void ) { ... return ( 0 ); } You did not initialise the variables min and max and are using them incorrectly. It should be: max = grades[0]; // etc You have a syntax error starting on the for loop line. Remove the semi-colon at the end and it should work correctly. for(i = 2; i &lt; arraysize; i++); &lt;- Remove this! It may be the copy/paste but you should really improve your indentation to improve readability. I hope this helps! 
I remember having this homework assignment too! What are the odds?
Please do yourself and future colleagues a favor and use [K&amp;R](http://en.wikipedia.org/wiki/Indent_style#K.26R_style) or [Allman](http://en.wikipedia.org/wiki/Indent_style#Allman_style).
This looks like homework so I'm only going to give you a hint. Look at the first if statement. Look closely at the assignment statements (grades[0] = max, etc). What could be wrong there (perhaps compare them with the assignments in the second if...
Variable-length Arrays are available in C99.
Passing a parameter down through the call-stack is certainly realistic - take a look at how Lua manages it. Secondly, if you pass a const point to the head of the linked list to a function, you are only passing a const reference to the first element. If you want to modify the linked list head itself you must pass a pointer to the pointer to the head element. If you make this const, then client code cannot modify the pointer.
I ended up using a shorter way to solve the problem but thanks for the help.
ya my indentation sucks I'm a very unorginized person in life and my main language is python which i use a different orginization. I was also doing this at about 3, but i guess that normal for programmers. Now I also feel dumb for switching the max= grades function. 
wat?
I use Allman/ANSI style as it's easy to match the braces. I'm under some pressure at work to use K&amp;R style as I'm writing Linux device drivers and that's the style used in the kernel, even though my code will never end up there. The worst style I've seen is GNU. 
Allman because I think it's more readable. I can't stand this: if (foo) { dosomething(); } or this: if (foo) { dosomething(); }
Lol those render exactly the same on my phone. Is there an android app that can understand formatting? I've been using "Reddit is Fun"
Don't hurt me; I'm a lisper, and I code on a netbook. void k (void) { if (foo) f(),g(); if (bar) { h(); j(); }}
Can't you use a browser?
Love Allman style! K&amp;R is too hard to read later and harder to debug or see what's going on.
well, never thought of that, but "my" style is kind of a mixture. i always place the opening brace ({) on the same line as the control statement of function header. if there's one thing that i hate it's this: function(int x) { (...) } or: while () { (...) } anyway, after reading some stuff [here](http://en.wikipedia.org/wiki/Indent_style), "my" style is probably the banner one.
The first C code I ever saw in my entire life was FreeBSD device drivers, so I've picked up the BSD KNF style: static void do_stuff(const char *foo, void *bar) { if (stuff != NULL) { do_foo(); } else { do_bar(); } }
I also prefer something similar to the BSD KNF style, but with one small variation... static void do_stuff(const char *foo, void *bar) { if (stuff != NULL) { do_foo(); } else { do_bar(); } }
I guess I'm Allman also, hadn't heard the term used before, had to go [google](http://en.wikipedia.org/wiki/Indent_style#Allman_style). More specifically, I'd also add four space indents and **absolutely** **no** **tab** characters (except in that one annoying place where `make` mandates them). To that end I have set list listchars=tab:»¯,trail:° set in my `.vimrc`.
1TBS int main(){ if (foo){ doStuff(); } return 0; }
Allman style, partially because it's how I learned it, but also because, like others have said, for the balanced structure. However, if I'm working on a shared project and others are using KNF or K&amp;R, I'll adapt.
The specific style is way less important than having a consistent style. After working with a style, you get used to how it shows structure and it becomes second nature. 
You use what the project requires you to use. If you're working at a company, they (should) have a standard. If you're working on open source, they'll have an existing style that you have to follow. So, I try not to get too married to any particular format because you have to cope with living with someone else's decision. 
I do the same but always put a space before the brace int main() { if (foo) { doStuff(); } return 0; }
let &lt;TAB&gt; equal four spaces if (foo) &lt;TAB&gt;{ &lt;TAB&gt;&lt;TAB&gt;dosomething(); &lt;TAB&gt;} ***or this:*** if (foo) &lt;TAB&gt;{ &lt;TAB&gt;dosomething(); &lt;TAB&gt;} Hope that helps
Ah yes thank you. I prefer: if (someThing) { doStuff(); } :)
I prefer K&amp;R, too.
Obviously, the best style is the style of whatever project you're working on at the moment. That said, in my mind, there is only one right style for C .. you know .. the authors' style .. K&amp;R .. one tab per indent level; opening braces on the same line, except for functions; closing brace at the level of the opening statement, on a separate line (except for "} else {"); space after if/for/while/.. but not after function names... all that. Except for one thing .. I never break long lines .. why do that, that's your editor's job .. and noone should limit me to 72 (or 80) characters when I can see 200 .. also, what's 72 characters when you add tabs? Outside of C, I prefer to ignore the "except for functions" part, otherwise, I tend to use much the same style. Also, I'm very passionate about tabs vs. spaces .. for me, it's a difference like between &lt;code&gt; and &lt;monospace&gt; (or however these are written) .. tab is a logical delimiter, spaces are a visual one. I do realize many people prefer spaces and have their reasons to but .. any sane text editor can understand tabs and can let you set the indent level for yourself .. and as long as you use tabs, the level you see is independent of how anyone else reading the same code sees it. Also, when coding in python, the difference can kill you. I dislike Allman (and the GNU abomination) mostly because of those wasted lines. Just my 2c :).
I started out using Allman but then switched to K&amp;R as I started to write Linux drivers and low level programs. Honestly, I don't really see any difference, readability wise, between the two.
Whitespace for humans, punctuation for compilers.
Out of curiosity (and low funds) how is that netbook working out for you? Do you only write the code on it then compile on a different machine or do you compile on the netbook itself? Also what are the specs?
a 4space indenter here as well (for personal projects)
Heh, I have no idea what your .vimrc line does, but I have the same hate for tabs, and believe all indentation should be four spaces! I have typed 'set ts=8 sw=4 sts=4 et' at least 10,000 times the past decade.
As someone who routinely codes on a netbook, I can say it's quite reasonable. However, I only edit a few files at a time; I don't try to run an IDE. I have an asus 1005ha, with a 92%-of-full-size keyboard and a properly placed Ctrl key. These aspects were critical in my purchasing decision and are what enable me to write code effectively. The specs were (are?) pretty much identical across comparable models. I use the default WinXP with MinGW to do compiling.
Good to know. I don't run an IDE myself anyway (well... I've added a few helpful plugins to Vim so it's enough of an IDE for me). As I say, not exactly rich and this old laptop only has one *maybe* two more years of useful life left. (already 4 years old and heats up to 85 celsius *very* quickly whenever the processor is being pushed above average daily use)
It makes tab characters and trailing whitespace visible. I also have highlight NonText ctermfg=DarkRed set so that the they show up nicely.
If you don't break lines because &gt; 80, why do you dislike wasted lines because your terminal is also &gt; 24 rows? It's not big deal then.
Unfortunately, it's always a big deal .. I tend to not have much code in ifs and whiles, usually just some call and maybe checking for error values or something .. so let's say you have 2 lines body, that means 4 lines for K&amp;R and 5 lines for Allman ... I usually have either 29 rows per term or 52 .. for 52, that's 3 whole ifs that can fit the screen! :) Seriously though, every little bit helps, as long as it's not really ugly. You know, out of sight, out of mind :).
(Assuming you're looking for a C solution) man 2 stat (S_IFDIR) man 3 fts The rest is open(2) or fopen(3) and then read/fread and split on isspace(). Or you can popen("find . -name *.txt -exec wc -l {} /dev/null", "r")
It's interesting to note that the Go language effectively "solves" its style war issue through specification: http://golang.org/doc/effective_go.html#formatting
To tabs and spaces again - http://www.viva64.com/en/a/0076/#ID0ER6AK
i got this far http://pastebin.com/zC3jPnVD
Ken Thompson isn't the author of C, that was Dennis Ritchie: http://en.wikipedia.org/wiki/C_\(programming_language\)
&gt; I gota do a program that would count together all the numbers in 1130778, which is 27, and then factorial all uneven numbers till 27. when i run the program it should look like this You mean, sum the digits. But factorial uneven numbers? What does that even mean? You want to print the factorial for all odd numbers until 27? Why the scientific notation?
Can you post the exact question, word for word?
To add the digits of said number you should divide the number into incremental powers of ten and take the rest. Something like: int num = 1130778; int digit = 0, total = 0; int divisor = 10; while(digit &gt; 0) { digit = (num % divisor); num -= digit; digit /= divisor / 10; total += digit; divisor *= 10; }
[Whitesmiths style](http://en.wikipedia.org/wiki/Indent_style#Whitesmiths_style) with the added quirk that the opening brace follows 1TBS: static void do_stuff(const char *foo, void *bar) { if (stuff != NULL) { do_foo(); do_bar(); } else { do_bar(); do_foo(); } } 
" Volatile seems to have no meaning, so it is hard to tell if ignoring it is a departure from the standard" What if you have a memory mapped device on your microcontroller and you don't want the compiler to think that the "variable" cannot change by itself... volatile may be useless in many programming fields, but in embedded system we still need it. Although i may have missed something here, english is not my primary language.
&gt;I was looking and people recommend The C Programming language by Ritchie and Kernighan. This is the Bible as far as C programming is concerned.
http://c.learncodethehardway.org/ (still being written, download the alpha and build it yourself for a more complete version) or you can go the more traditional route and get the highly regarded [K&amp;R](http://en.wikipedia.org/wiki/The_C_Programming_Language) book
I heard this book is good: http://www.amazon.com/Programming-Language-2nd-Brian-Kernighan/dp/0131103628
K&amp;R K&amp;R K&amp;R Everyone that has told you this already is right.
K&amp;R is good. Also, [Programming in C by Stephen Kochan](http://www.amazon.com/Programming-3rd-Stephen-G-Kochan/dp/0672326663/ref=sr_1_1?ie=UTF8&amp;qid=1319072699&amp;sr=8-1) is pretty good and might come across better depending on your learning style.
should i get the first or second edition
Wait--why is that $58?!?! I couldn't have spent more than $25 on that a few years back. Edit: 21 hours later and it is up to $64.
... second. Unless you'll be maintaining original PDP11 Unix code.
I&amp;R is not only the Bible, it's also a damn fine book. It will teach you C. Get the second edition.
after you read K&amp;R, you should move onto "Programming Pearls" &amp; (my personal favorite) "Advanced C Programming" by Peter van der Linden 
Van der linden 's book is great. Aka deep c secrets.
Linden's book is *amazing*, but not for beginners obviously. 
I never said it was. that's why i said it should be AFTER k&amp;r. possibly after the pearls book, even
After at least a year of serious C coding I'd say
It does seem strange. I paid much less, perhaps about £20 or so.
The van der Linden book's title is actually "Expert C Programming - Deep C Secrets" for anyone searching.
Another decent online intro is Beej's Guide to C Programming: http://beej.us/guide/bgc/output/html/multipage/index.html I tried K&amp;R once before and bounced off it, read Beej's guide for a friendlier overview, and then went back to K&amp;R with more patience and found I got much more out of it.
No point in getting the first edition, nobody uses the original C now, everyone uses C89 (ANSI C) or later. And the second edition covers changes since the first too.
I'm not sure about K&amp;R, but I have seen some books increase in price somewhere around august/september, because that's when kids go to school and have to buy books for their classes.
You basically need three books: K &amp; R, Expert C programming Peter Van Der Linden, The C FAQ (this is indispensable)
Programming in C is what his class uses right now, or didn't you read the OP? I haven't read it, so I can't judge it, but it sounds like OP doesn't like it (or maybe just the class).
It's been north of $40 US for years now. And worth every damn penny.
You only *need* one book: [The C Programming Language, 2nd Edition](http://cm.bell-labs.com/cm/cs/cbook/). However, I would also recommend you own [C: A Reference Manual, Fifth Edition](http://careferencemanual.com/), especially for the C99 coverage. Not needed immediately, by any means, but well worth having - the reference section of K&amp;R will serve you well for quite a while for any C89/C90 coding. A fine supplemental book is [C Programming FAQs](http://www.informit.com/store/product.aspx?isbn=0201845199). Much of it is available online as the [comp.lang.c Frequently Asked Questions](http://c-faq.com/), but the book adds material and polish. Once you're ready for advanced C knowledge (I'd guess after at least a year of substantial C programming, but only you know when you're ready and interested enough), you really want to read [Expert C Programming: Deep C Secrets](http://www.amazon.com/Expert-Programming-Peter-van-Linden/dp/0131774298), by [Peter van der Linden](http://afu.com/). There are some other very good books that have more or less direct applicability to C programming. The two I would call out are [The Practice of Programming](http://cm.bell-labs.com/cm/cs/tpop/) and [Programming Pearls](http://cm.bell-labs.com/cm/cs/pearls/). Both worth far in excess of the asking price. Good luck, and welcome to the deep end of the pool. The water's fine.
It's not a book, but allow me to share something I have learned that I do regardless of which language I'm using. Make your compiler settings as strict as reasonably possible. If I'm starting a C project from scratch, I like to have it fully conform to the ANSI C spec, treat warnings as errors, and so on. The basic idea here is that even though it seems like more of a pain up front, the resulting code will be more correct and work better. It's better to catch a potential bug or portability problem when your code is 20 lines long than 10,000 lines long!
woops, my bad. i was naming it from memory. I generally remember it as the "ugly fish" book :) it's the name under which it's saved in the bot in efnet#c++(and is fairly accurate given the cover :) ) 
I agree with everyone about K&amp;R, it really is about the best reference for the language itself. I also recommend "The GNU C Library Reference Manual" - which can be as simple as "info libc" if you're on Linux - as it does an excellent job of covering the basics (memory management, I/O, etc.) with the C library.
The O'Reilly book Practical C Programming is very good.
As a first C book for beginners I'd better recommend "C Primer Plus" by Stephen Prata. No K&amp;R tricks and cool hacks, just clean structured programming style.
My mind somehow skipped from "I was trying to find something like Learn Python the Hard way for C." to "I was looking and people recommend The C Programming language by Ritchie and Kernighan."
I think the sudden price increase is due to Dennis Ritchie's death. Very bad of the publisher to do this when his work should be celebrated and widely available to the masses.
Can you please re-state your question? I don't understand. Are you asking if it's possible for a function to return multiple values? No. A function can only return one thing. But that thing can be a struct that contains multiple fields, or more commonly, a pointer to a struct. 
Or you can pass pointers to values you want to change
So i have a function that takes a few user inputs and does cross multiplication on them because the input is are vectors. That fist function gives me 4 variables which are named ABD , ABC ect. ect as shown above. Those outputs are in the function B. In function A I will be comparing the 4 values from the function B but I cannot put the comparison within function B. In a different part of the program I was able to use int compare = functionA() were function A did the same thing as what i described the function B doing but instead of having 4 variables that are being calculated I had 1 and I was able to run my program.
A function can only return one thing. You can either have it return a struct that contains your four values, or return a pointer to a struct, or you can pass it pointers to each of the four variables instead of declaring them locally, and have it modify them through the pointers and return nothing. 
Yeah, you'd be best off defining a struct to hold your values and returning that struct (rather pointer to it) from function B, like was previously mentioned. You could do an array, linked list, etc, but as long as the computation only returns 4 variables, a struct is probably the cleanest route. If your computation size was dynamic, a different data structure would probably work better.
It's funny how easily you can tell a programer by the need for specific descriptions. :P I was thinking the same thing when I first read the OP.
 struct result { int ABD, ABC, CDB, CDA; }; int A() { struct result res = B(a, b, c, d); } If the data values will always be used together, I'd also define a type for them, and pass it in to the function instead of the separate arguments. Another alternative which might be applicable would be to let the user pass in a pointer to a results structure, which you could then populate with the results. There are *many* ways you could accomplish what (I think) you're asking. C gives you a bunch of tools, you can use them in many different ways. Of course, like any set of sharp tools, there is plenty of opportunity for you to use them wrong, but, in return, you get more control than you would have in a higher level language. Like anything else, it's a matter of trade-offs. 
Simplest solution: int B(int *abd, int *abc, int *cdb, int *cda); int A(void) { int abd, abc, cdb, cda; B(&amp;abd, &amp;abc, &amp;cdb, &amp;cda); ... do something with the results ... }
Thanks everyone fr the help I was able to figure out how to do it with the help.
* glib * tinyscheme - http://tinyscheme.sourceforge.net * mhash - http://mhash.sourceforge.net
I've enjoyed C Programming: A Moddern Approach
The problem is for my class I cannot use structures and pointers because my teacher hasn't taught us them. And he might get mad if I'm using stuff we haven't been taught.
Thanks for all the help I'll take a look at some of the books. I also noticed that there is an alpha for learning c the hard way. Has anyone tried it and if you have what is out opinion on it.
1TBS. I find it almost impossible to read anything else. As soon as I see Allman the code literally melts into unreadable gibberish. Then again, I also have difficulties reading code that makes extensive use of camelCase...
I'm learning from it right now. I'm pretty happy with it. I was going off of the website, but I ran out of pages. I had to make a git clone of the repository and build the more up to date version myself. Oddly enough, I felt very well prepared with everything I had to deal with in making the up-to-date version due to the sections I had previously read in the book.. go figure :) 
I generally use [Compact Control Readability Style](http://en.wikipedia.org/wiki/Indent_style#Compact_Control_Readability_style), which I actually started using before I learned there were names for different styles.
I was in Borders right before one closed, and the sticker price was $49.95.
[sglib](http://sglib.sourceforge.net/) looks pretty good as far as generic macro go.
[CCAN](http://ccodearchive.net/). From the website: &gt; **The Idea** That nice snippets of C code should be moved out of junkcode directories and exposed to a wider world, where they can become something useful. &gt; [CCAN](http://ccodearchive.net/) is loosely modelled after the successful CPAN project for Perl code development and sharing. 
You're right. The function should be getting a pointer in both cases. While I'm not sure what is causing the error (you need to post more code as well as exactly what is wrong), I still recommend using calloc(3) and probably memcpy(3) depending on what "function" is doing.
Have you checked that malloc does not return Null? 
Problem solved, thank you - using calloc sorted it, does that mean there is a difference between how explicitly defining an array initialises the bytes versus how malloc does? As I'm aware, calloc sets all bits to 0 - does this mean double array[10]; initialises the bits but double *array; array = malloc(10*sizeof(double)); doesn't?
Yes. malloc() does not modify the contents of the memory it's giving you.
Not exactly. Only global variables are initialized to zero. Your array is zeroed because it's global, not because it's a literal array. If you declared it in a function, it would not be zeroed beforehand. (Or if you were already declaring it in another function, then it was only zero by chance; it's allocated from the stack, whereas malloc() would allocate it from the heap.) You're right about malloc() and calloc(). malloc() just gives you the memory as-is, with whatever garbage was in there beforehand. calloc() is basically just a wrapper to malloc() which zeroes the memory after allocating it. If using calloc() instead of malloc() fixes it then your function is reading from the array before it writes to it. You should either fix this behavior or at least add a comment that documents that your function requires a zeroed array. It might help if you post more of your code.
Hmm... but am I right in thinking that explicitly declaring an array doesn't zero it out either? Which means having to use calloc() makes no sense, because technically the two code examples (explicit and with malloc()) are identical in terms of preparing the array?
Declaring a global array does zero it out. Declaring a local/auto array does not. 
If the array is defined as a global variable, then it is zeroed. If it's defined in a function, then it is not. The OP hasn't specified whether he's declaring it globally or in the calling function. If he is declaring it in the calling function, then yes they are semantically identical in terms of preparing the array, in that the array contents are uninitialized. So reading from it is undefined in either case. Just because the code works as expected in one scenario or the other doesn't mean it's correct. Most likely his function is just broken because it's reading from the array before writing to it, and this entire thread is just focusing on entirely the wrong place. Using calloc() has simply masked the bug, and it is likely to re-appear later. (I am not a fan of calloc().)
They're really quite different. For example, one allocates on the stack and the other on the heap; the static allocates constantly at compile time and the dynamic at runtime; the static can pack structures under quite a few more circumstances than the dynamic; the static invokes the compiler-provided allocation hooks and the dynamic the CRT hooks that come from the operating system; the static allocation can be done safely across TU boundaries and calling conventions but the dynamic cannot; et cetera. They don't even go into the same segment. On some machines, like Nintendo's GBA and DS under the commercial lnkscript, this means the data isn't going into the same kind of memory (the static stuff when const goes into .GLOBAL_CONST, which is in ROM on the cart, whereas the dynamic stuff goes into RAM.) &gt; As far as I am aware, the two are entirely equivalent. Am I wrong here? Rule 1: "as far as I am aware" is not a good way to work. Read the manual or the spec.
&gt; am I right in thinking that explicitly declaring an array doesn't zero it out either? In c99, the short constructor syntax on a global implies zeroing on packed primitive arrays. The guys advising you to rely on this should not be: most compilers do not default to c99, and it's much more clear to actually write `={0}`, so that people know that you have done this intentionally, rather than in error. This is especially important because people will attempt to use your C as C++, which affords no such guarantee. Using implicit initialization is basically getting on your knees and begging chaos for difficult to find problems. Whether it's technically correct in carefully defined circumstances is beside the point: in reality it's going to bite you in the ass, often, and it's a negligable work savings. Better safe than learning repeatedly the hard way. When you've had enough bad coworkers, you'll understand.
Global variables are *not* *necessarily* initialized to zero. This requires c99 behavior, which is not actually the common behavior among today's compilers. This allows subtle bugs to creep in when someone compiles your C with a compiler set up the way most compilers are by default. C++ also does not afford this guarantee, so your C will show unnecessary defects when used as C++, too. Above and beyond that, it's good form to show initializers so that people can tell it's set up that way purposefully, rather than by oversight, and it's not as if it's hard to write out. If your compiler or OS is doing that, fine, but it is not guaranteed. If you are relying on pre-initialization anywhere without enforcing c99-or-above compilation, you are writing defective code. Relying on language-version-specific behavior is a serious red flag. Advocating it is ill advised. &gt; calloc() is basically just a wrapper to malloc() which zeroes the memory after allocating it. It's also member aligned, which is potentially wasteful and expensive.
&gt;This requires c99 behavior, which is not actually the common behavior among today's compilers. *citation needed If your C compiler isn't up to standards set over a decade ago, you have more problems than uninitialized globals. I challenge you to name one compiler with a release in the last five years that does not adhere to C99 standards. 
&gt; *citation needed Yeah, do your own research, Jack. &gt; If your C compiler isn't up to standards set over a decade ago Try reading less between the lines, and spending less time reading one sentence taken away from the rest of the comment. If you run GCC stock, or ICC stock, they both compile as c89, not c99, unless you tell them otherwise. This is the other part that should have helped you catch on to what was actually said, instead of the thing you decided to argue with: "with a compiler set up the way most compilers are by default." Put those together with MSVS, which doesn't do c99 at all, and probably never will, and you've got the vast bulk - more than 95% according to UNSD - of compilers in their default configurations. And no, I'm not going to cite that, either. I'm not wrong simply because you don't know what I'm talking about, can't be bothered to read the entire comment, and don't want to learn to do simple Google verification. There is more to life than using your own ignorance to try to tell other people how to present information. You want a citation? Go find one. Writing fragile code is bad, whether you understand it or not. &gt; I challenge you to name one compiler with a release in the last five years that does not adhere to C99 standards. MSVS, by far and away the dominant c compiler on Earth by usage, doesn't do c99 at all. Notice the complete lack of, among other things, `stdint.h`. Of course, I didn't say anything about not adhering to standards; I just said that most compilers aren't in c99 mode by default, which basically none of them are. Stop pretending to know things.
Here are some citations for you. C89 6.5.7: &gt; If an object that has automatic storage duration is not initialized explicitely, its value is indeterminate. If an object that has static storage duration is not initialized explicitely, it is initialized implicitely as if every member that has arithmetic type were assigned 0 and every member that has pointer type were assigned a null pointer constant. C99 6.7.8: &gt; If an object that has automatic storage duration is not initialized explicitly, its value is indeterminate. If an object that has static storage duration is not initialized explicitly, then: &gt; &gt; \* if it has pointer type, it is initialized to a null pointer; &gt; \* if it has arithmetic type, it is initialized to (positive or unsigned) zero; &gt; \* if it is an aggregate, every member is initialized (recursively) according to these rules; &gt; \* if it is a union, the first named member is initialized (recursively) according to these rules. C++98 8.5.6: &gt; "Every object of static storage duration shall be zero-initialized at program startup"
Microsoft still has not implemented a proper C99 compiler. The default behavior of almost all C compilers is still to compile in C89 mode. He's correct about that part, but it's just about the only thing he's correct on. As far as I know C99 did not change the initialization of global variables (see citations below.)
&gt; \[calloc() is\] also member aligned, which is potentially wasteful and expensive. Can you explain what you mean here? I'm pretty sure malloc() and calloc() both align exactly the same way. The standard simply says they must allow alignment for "any type of object", which is basically just a requirement for word alignment. In practice malloc() implementations align to 16 byte boundaries (in the smallest allocation pool), regardless of whether you call malloc() or calloc(). The actual glibc implementation of calloc() is [here](http://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=8608083adbe65c530a0d8ac3bbf547d85586b678;hb=HEAD). Note that `public_cALLOc()` does not actually use the element size or number of elements independently at all. It just goes `bytes = n * elem_size`, checks it for overflow, and uses that from then on.
As others noted, I believe the code in your function is either not accounting for uninitialized data, or has a bug in it. May I also recommend something for you: Whenever you pass a pointer to a function and need to copy data in iteration/length from that pointer to another location, always pass the size. In this case, your function would look like: function(double* x, double* y, int size); In your example, you can call this function with: double y[100]; function(someArray, y, sizeof(y)); Good luck!
&gt; Here are some citations for you. Maybe you should have read them? &gt; If an object that has automatic storage duration is not initialized explicitely, its value is indeterminate. Agrees with what I said. &gt; If an object that has *****static storage duration***** is not initialized explicitely, it is initialized implicitely Virtually nothing has static storage duration, and by definition the code being discussed does not, before you protest. This is amusing because, given your C++ quote, you appear to believe that the code in question has this. This is especially amusing because I already explained this in another comment, expecting someone to make this mistake, but didn't remember to get both comments. From another comment which mysteriously got downvoted within 60 seconds of me telling you you were wrong ( http://www.reddit.com/r/C_Programming/comments/lun3l/mallocing_an_array_not_equivalent_to_explicit/c2vu1zu ) : &gt; &gt; They don't even go into the same segment. On some machines, like Nintendo's GBA and DS under the commercial lnkscript, this means the data isn't going into the same kind of memory (the static stuff when const goes into .GLOBAL_CONST, which is in ROM on the cart, whereas the dynamic stuff goes into RAM.) So you can quote the standard. That's great. Let me know when you start reading what you quote. *****Your quote from the standard says I'm right*****. &gt; C99 6.7.8: Yes, this is what I said too. C99 does this, but nobody's compiler is by default set up for C99. So, quoting C99 at me, when I said "this requires C99 rules," is just you trying to look like you have a bigger point than you actually do. Notice that the part that's different between c89 and c99 does not apply in this context in any way. &gt; C++98 8.5.6: "Every object of static storage duration shall be zero-initialized at program startup" Do you know what static storage duration means? The code above does not have static storage duration. The only part of the standard you quoted by definition has no bearing here. Unfortunately, people see citations and assume I'm wrong, without actually checking to see whether the citations disagree with me, which in this case they clearly do not. If you would read more carefully before arguing with people, you might find out that *****you haven't actually discovered any mistakes*****.
&gt; Do you know what static storage duration means? Do you? You seem to be arguing that global variables don't have static storage duration, which is rather bizarre. Let's clarify all this here. Variables defined at file scope (i.e. global variables) always have static storage duration. If at file scope I put: double y[100]; That is a definition of a variable with external linkage and static storage duration. If I put instead: static double y[100]; That is a definition of a variable with static linkage and static storage duration. If I put instead: extern double y[100]; That is a declaration of a variable with external linkage and static storage duration. The `static` modifier on file scope variable definitions affects linkage, not storage duration; they always have static storage duration. If however, within a function, I say: void foo(void) { double y[100]; } This is a definition of a variable with static linkage and automatic storage duration. If instead I define it like so: void foo(void) { static double y[100]; } This is a definition of a variable with static linkage and static storage duration. The `static` modifier here affects storage duration, not linkage; variables defined inside functions always have static linkage. With these clarifications, nothing else in your post makes any sense. The reason I gave you both C89 and C99 rules is to show you that they are exactly the same. You keep trying to argue that something requires C99, but absolutely nothing changed in C99 regarding default initialization of variables.
This is good advice, except you typically want to pass in the number of elements rather than the byte size of the array. double y[100]; function(someArray, y, sizeof(y) / sizeof(y[0])); Judging from the OP's answers, it certainly seems like there is a bug in the function. The allocation strategy used should not affect its behavior.
You're correct. That's what I meant but apparently I can't write even a single line of code without a bug :)
&gt; You seem to be arguing that global variables don't have static storage duration I certainly am not. Not only have these words not come from me, but grandparent's code cannot be about global variables, because one of the two contexts he's in is mallocing, and mallocing cannot happen outside a function's context. You are now making things up to look right, then trying to change the topic. &gt; Let's clarify all this here. Let's not. Every criticism you've made has either been about things that aren't the original poster's code, or things that you imagine I'm saying when I haven't actually said them. None of your clarifications have to do with the situation at hand. &gt; Variables defined at file scope Not the OP's code. &gt; `double y[100];` &gt; That is a definition of a variable with external linkage and static storage duration You can't actually say that for sure. It is *not* external by default, which is why keyword `extern` exists, and it is *not* static unless it's global. You seem to be assuming that things are global when in fact they are provably not global. Your last set of criticisms relies on this false assumption. &gt; If I put instead: `static double y[100];` That is a definition of a variable with static linkage and static storage duration. You also don't know this. Your whole schtick seems to be based on assuming context. If for example that's within a class or a struct, it is neither statically linked nor has it static duration. I would like to remind you that you've now assumed two different contexts for original poster's code, both of which are provably impossible. First you wanted it to have static duration, which it does not actually show anywhere in the code, and when that was pointed out, then you wanted it to have global scope, which it cannot because it's being initialized with a malloc, whose return value of course by definition is not available at compile time, which is why by definition it cannot be statically initialized. &gt; If I put instead: `extern double y[100];` That is a declaration of a variable with external linkage and static storage duration. That's nice. That isn't the code we were discussing; this act, where you pretend to teach so that you do not have to admit error, is pretty boring. Next show me some FORTRAN. (rolls eyes) &gt; With these clarifications, nothing else in your post makes any sense. Just because it doesn't make sense to you, etc etc. &gt; The reason I gave you both C89 and C99 rules No, dear, I actually brought that up, you just missed it. And when that was pointed out to you, you missed it again, so that you could continue to feel correct. &gt; You keep trying to argue that something requires C99, but absolutely nothing changed in C99 regarding default initialization of variables. Ok. :) When you're done telling the person who said "you aren't reading me correctly" what they meant, don't be surprised when they don't take very seriously your insistant criticisms of things that they haven't actually said. I get that the person saying the things you're imagining would be wrong, but they're not my words.
Please read [my post here](http://www.reddit.com/r/C_Programming/comments/lun3l/mallocing_an_array_not_equivalent_to_explicit/c2vtjj4). This is the relevant bit: &gt; If the array is defined as a global variable, then it is zeroed. If it's defined in a function, then it is not. The OP hasn't specified whether he's declaring it globally or in the calling function. I never actually said it's a global variable. I said we don't know. Just because the OP put the lines close to each other in his post doesn't mean they're in the same scope; he just hasn't shown us what the original code looks like. It is likely that it is a global variable since changing malloc() to calloc() gave him the same behavior, but we don't know. The reason we kept talking about global variables is because [you said this:](http://www.reddit.com/r/C_Programming/comments/lun3l/mallocing_an_array_not_equivalent_to_explicit/c2vu31w) &gt; Global variables are not necessarily initialized to zero. This requires c99 behavior That is completely and utterly false. Global variables without an explicit value are always initialized to zero, in C89 and C99 and C++. I quoted the standards of all of them to show you that the rules are the same, and that C89 or C99 or C++ makes no difference at all. You are now trying to change the subject and make it look like I'm the one arguing that the OP's code is using global variables. This is dishonest. It's also incredibly frustrating, because: &gt; You also don't know this. Your whole schtick seems to be based on assuming context. If for example that's within a class or a struct, it is neither statically linked nor has it static duration. Every example in [my post](http://www.reddit.com/r/C_Programming/comments/lun3l/mallocing_an_array_not_equivalent_to_explicit/c2vxtqq) is in *file scope*. I said it twice right before the first example. Did I really have to repeat the words *file scope* in every single chunk of code? Whether the OP is using file scope or not is not what we're talking about here: you said global (file scope) variables were not necessarily initialized to zero, and I was proving you wrong. ----------- EDIT: Oh, I also need to correct yet another thing you have wrong here. &gt; It is not external by default, which is why keyword extern exists, and it is not static unless it's global. It most definitely has external linkage by default, whether or not you use the `extern` keyword. The `extern` keyword makes it a *declaration*, not a *definition*; by using extern, you are declaring the variable, and telling the compiler that it is defined elsewhere, so the compiler should not allocate storage to it. By not using `extern`, you are telling the compiler that it is defined here, and that it should allocate storage, but *it still has external linkage*; the compiler will make the variable available to the linker so that other translation units can access it (via `extern` declarations.) Notice I used the terms "declaration" and "definition" correctly in [my post](http://www.reddit.com/r/C_Programming/comments/lun3l/mallocing_an_array_not_equivalent_to_explicit/c2vxtqq). The one with `extern` is a declaration, the one without is a definition.
&gt; You are now trying to change the subject and make it look like I'm the one arguing that the OP's code is using global variables. This is dishonest. Okay, guy. Clearly, I must have brought it up, since I didn't say it at all. I'm long since bored of this. Your last several posts have been putting words into my mouth so you could call them wrong, or cutting away the context of things I said so that it looks like I've said something I haven't. Even when you get up on a post about a specific challenge and get shown to be wrong - like defying me to show you that the world's most common C compiler is a case example of what you insist must never be the case - you just skate on past your mistake like it isn't there. Why? Well. Anyway. You haven't added any new information in quite a while, and when I point out specific criticisms, you just talk about other things, then accuse me of changing the topic. Very effective. Believe what you like. I'm tired of the downvote anger circus. One or both of us is wrong. If it's me, then either I'm not listening or you're not communicating. If it's you, then either you're not listening or I'm not communicating. It could also be any overlap of those. No amount of continuing this will solve any of those. Feel free to insist that I'm just refusing to admit I'm wrong, even though it's plain as day that I simply don't believe that you're correct. But you wouldn't be so transparently ego driven, would you? `:)` Have a good night, Jack. Take solace in that it must surely just be that I wasn't listening. Enjoy editing out the errors.
It was global. Yeah, you're correct about me masking the bug however the function I call isn't my part of the assignment so it's not me losing marks; meaning i'm more than happy to just mask it.
I did actually also pass the size, I just only used the two arrays as parameters in my example because the rest wasn't really relevant. Problem completely solved now though!
I second the recommendation for C: A Refernece Manual, Fifth Edition. It's by far my favourite C book. The descriptions in it are particularly detailed and it fully and precisely explains every detail of the language.
I'm using this book for one of my CS classes, unfortunately I discovered [this](http://www.inf.unideb.hu/grafika/eng/rtornai/Kernighan_Ritchie_Language_C.pdf) way after I bought it, should help you out.
I bought mine back in February for about $14 from Amazon and then a week or so later the price went to $25 or so, ofcourse this is for used, because I'm a cheap skate.
&gt; Global variables are not necessarily initialized to zero. This requires c99 behavior, which is not actually the common behavior among today's compilers. LOL. Global variables are *definitely* initialized to zero, and that is part of C89 and C99. Has been from the start.
Don't use "int" for size. Use something both unsigned and large enough to cover all of memory. A common idiom is to use "size_t" for size, from "stddef.h".
also gcc -save-temps then it always leaves those .i and .s files behind.
Whichever style this is: int main() { if (foo) { doStuff(); } return 0; }
C Programming Language (K&amp;R). I found the recommendations on [this page](http://fabiensanglard.net/c/) useful.
Thanks, Ill check it out.
[Decent](http://www.thenewboston.com/?cat=20&amp;pOpen=tutorial)
K&amp;R and the [GNU C library reference](http://www.gnu.org/s/hello/manual/libc/index.html) for learning good practice.
In all the places where you are creating new nodes, you arn't nulling the links, so they will end up with garbage values (non-null)
that is why you need a new_node(void) function that returns a pointer to a new and properly initialized node (having its left and right pointers set to null). Also you would probably benefit in the long run by creating getter and setter functions for nodes (perhaps enforcing it by utilizing [abstract datatypes](http://mimog.wordpress.com/2011/09/02/abstract-data-types-in-c-or-information-hiding-2/))
To post code to reddit, prefix each line with 4 spaces to prevent it from being mangled. 
[This](http://en.wikibooks.org/wiki/C_Programming) and [this](http://publications.gbdirect.co.uk/c_book/)
Came to suggest "The C Programming Language" (K&amp;R), but I see it has already been well represented!
When someone made a similar request (looking for good C books), I posted [this](http://www.reddit.com/r/C_Programming/comments/lhzdc/looking_for_a_good_c_book/c2t19ny) advice. I'd say it applies to you, as well. Yes, there are online sources that are cheap or free, but none that I've seen are as good as the books I cite. Some don't entirely suck, though, so if spending the money on even a used copy of K&amp;R is out of the question, I'm sure folks will point them out here.
[RosettaCode](http://rosettacode.org/wiki/Main_Page) is a great reference site (wiki). Someone already posted [this one](http://en.wikibooks.org/wiki/C_Programming) but I'm re-posting because it's great. [CodePad.org](http://codepad.org/) is a quick and easy way to practice and compile your code... although it's not good for programs that require user input after execution (i.e. scanf - "Please enter your name" and stuff like that).
You are overanalyzing, and your problem is not malloc. It's pointers. First of all, readNumbers is a function that takes a pointer to a size_t (which is an unsigned integer) as an argument. The call to scanf (note that this passes count, which is the _memory adress_ of the size_t value). After this, count is still the address and *count is the value at this address, i.e. the number that the user entered. The call to malloc has the size of the memory area to be reserved as its argument. The size is *count (i.e. the value) times (*) the size of an int. The star in the middle is only a multiplication, not more. I hope this helps a bit.
Perhaps a few comments on the readNumbers() function will help. &gt; The function takes a single variable, 'count', which is a pointer to a size_t (unsigned int). The pointer is used since readNumbers will be responsible for populating 'count' so that the calling function will know how many numbers were read. The 'count' variable does not need to be initialized prior to calling readNumbers and will likely be replaced anyways. int* readNumbers(size_t* count) { &gt; The user is prompted to enter the 'count' of numbers to be read. Note that since 'count' is already a pointer, it does not need to be dereferenced for scanf(). printf("How many numbers do you want? "); scanf("%zu", count); &gt; Now, from the above scanf() call we presumably have a valid 'count' of numbers to read. Let's assume the user entered 10, so we know that *count = 10 (remember, count is a pointer to the address, so *count is the actual value). Let's also assume sizeof(int)=4 for this example. The following malloc call now says to create a new dynamic array of type int by mallocing a size of (10 * 4) or 40 bytes. &gt; int *numbers = malloc (40); int* numbers = malloc(*count * sizeof(int)); &gt; If the malloc was successful (non-NULL), iterate *count (10) times and read them in, filling the 40 byte array (10 reads of 4 bytes). if (numbers) { int i; printf("Enter your numbers: "); for (i = 0; i &lt; *count; i++) { scanf("%d", &amp;numbers[i]); } } return numbers; }
Thanks, that's incredibly helpful! This is probably a dumb question but (in this particular scenario) when I specify "sizeof(int)" in the malloc statement, I am referring to "int* numbers", correct? In other words: *This* int numbers = malloc(count * sizeof(**int**)); *is referring to this* **int** numbers = malloc(*count * sizeof(int));
Yes. A somewhat common bug can come from this in the event of numbers being changed from int to long at a later date (assuming int and long are different sizes). It is easy for people, especially beginners, to make the following change: long* numbers = malloc(*count * sizeof(int)); Now we are in trouble, because we expect twice as much storage than we ask for. The easiest way to avoid this type of bug is to use sizeof() on the variable itself: long* numbers; numbers = malloc(*count * sizeof *numbers); This way, numbers will be properly allocated if long is switched to int or vice versa.
Might I recommend that you use calloc when allocating arrays? Use it like so: int *numbers = calloc(NUM_COUNT, sizeof(int)); It will take care of allocating enough space (count * size in bytes) and it's more idiomatic. Use malloc for single object allocation: object_t *obj = malloc(sizeof(object_t)); 
Superb! Thank you!
Ah... that makes sense.
To make this even more confusing that code also has an integer overflow ;p
&gt;In the malloc statement, where is the value of "count" defined? In the line above it: scanf("%zu", count); &gt;Is "count" defined by the "sizeof(int)"? No. &gt;In other words, is it saying that "count equals the size of the integer"? If this is the case, is the "*" between these two some sort of linking character? No. The * at the front is dereferencing (count itself is a pointer) so you get an integer, and the star in between is just multiplication. If the number is 5, and each integer takes up 4 bytes, the result will be 20 bytes. That's how much room you need for 5 integers. And you ask `malloc` "please give me enough memory for 20 bytes". And `malloc` reserves them for you, and tells you where it is.
&gt; You are overanalyzing, and your problem is not malloc. It's pointers. If that's the case, this might help the OP: http://www.highercomputingforeveryone.com/ Units 8-15 will cover pointers, malloc, and should provide enough info to understand what is going on. If you are having trouble with pointers and using malloc, then this might be enough to clear it all up.
It's best to start with an understanding of how malloc() works. A call to malloc() returns a pointer to memory that can hold *at least* the number of bytes you ask for: char* some_bytes = malloc(12); 'some_bytes' will now point to an array of 12 characters. Lets say you want 12 integers. If you don't want to assume the byte-count of a single integer, the following will work: int* my_integers = malloc(12 * sizeof(int)); 'sizeof(int)' will return the size in bytes that a single integer will use. We then multiply that by 12 to allocate enough memory to hold 12 integers. Lets say that we're handed a pointer to the number of integers we're to allocate space for: size_t* pointer_to_int_count; Later in the code, we point that variable to a location in memory that holds an actual value: pointer_to_int_count = &amp;some_other_integer; In the case of your example code, a pointer to the number of integers is passed in. Either way, dereferencing that pointer gives you a number that you can then use with malloc: int* my_integers = malloc( (*pointer_to_int_count) * sizeof(int) );
I'm going to blow my own horn here, assuredly in the most G-rated sense, and say that I started writing a Guide to C a while ago: http://beej.us/guide/bgc/ After a while, I decided it wasn't quite what I was after (maybe it needed to be two books...? I'm still not quite sure why I don't like it), and it fell by the wayside. However, there is quite a substantial amount of information there. You might find it too beginner, but there it is, FWIW.
 scanf("%zu", count); int* numbers = malloc(*count * sizeof(int)); This reads a number from the user, and allocates 'count' times sizeof(int) bytes. '*count * sizeof(int)' means the value of count times sizeof(int). The * in *count is the dereference operator, count itself is a pointer, so you need to use * to get at the int it points to. The * in between count * sizeof(int) is multiplication. If you input '10' , malloc allocates storage for 10 ints. 
Still need help
First thing I see: x[2] does not refer to a valid entry in the array. Your only two elements are x[0] and x[1]. I also don't understand the point of the x[] array since it only exists during the execution of the get_room_size() function, and all you do with it is set x[0] and x[1] and then never use those again. Did you mean to multiply them together? return x[0] * x[1] If so, there's no reason to use an array since you already have those values in the length and width variables. Also, in main() you refer to value[2] which does also not exist. You only have value[0] and value[1].
I think you want to do something like this instead (pass a pointer to the array to the function): #include &lt;stdio.h&gt; void get_room_size(int *x) { int length = 0; int width = 0; do { printf("Enter length and width of room in feet:\n"); scanf("%d", &amp;length); scanf("%d", &amp;width); if (length &lt; 1 || width &lt; 1){ fprintf(stderr, "Error! length and width must be positive values:\n"); fprintf(stderr, "length: %d\n", length); fprintf(stderr, "width: %d\n", width); } } while (length &lt; 1 || width &lt; 1); x[0]= length; x[1]= width; } int main(int argc, char *argv[]) { int rooms, i; int value1[2] = {0}; char room_id[]= {'A', 'B', 'C', 'D', 'E'}; do { printf("How many rooms are there in the house? "); scanf("%d", &amp;rooms); if (rooms &lt; 1 || rooms &gt; sizeof(room_id)) fprintf(stderr, "Error! rooms must be between 1 and %d!\n", (int)sizeof(room_id)); } while (rooms &lt; 1 || rooms &gt; sizeof(room_id)); printf("You want to paint room(s): "); for (i = 0 ; i &lt; rooms; i++) printf("%c ", room_id[i]); printf("\n"); get_room_size(value1); for (i = 0; i &lt; 2; i++) printf("%d\n", value1[i]); }
Combining Artcfox and jrandom's answers, pass pointers to length and width to the function. There is no reason for the array: void get_room_size(int *length, int *width) {...}
Maybe something like this? // Note: Assumes c99 standard so we can declare // variables wherever we need them. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; // ===================================================== Forward Declarations // Forward Declarations // ----------------------------------------------------- void get_room_size( char room_id, int* out_length, int* out_width ); // ===================================================== Main Program // Main Program // ----------------------------------------------------- main() int main() { // Retrieve number of rooms int room_count; printf( "How many rooms are there in the house?\n" ); scanf ( "%d", &amp;room_count ); // Enforce minimum/maximum rooms if ( room_count &lt; 1 ) room_count = 1; if ( room_count &gt; 26 ) room_count = 26; // Allocate space for rooms and initialize char *room_ids = malloc( room_count ); for ( int i = 0; i &lt; room_count; i++ ) room_ids[ i ] = 'A' + i; // Paint rooms for( int current_room = 0; current_room &lt; room_count; current_room++ ) { int length, width; get_room_size( room_ids[ current_room ], &amp;length, &amp;width ); // Room-painting code goes here. } // Free up room id memory free( room_ids ); } // ----------------------------------------------------- get_room_size() void get_room_size( char room_id, int* out_length, int* out_width ) { int length, width; do { printf( "Enter length and width for room %c\n", room_id ); scanf ( "%d", &amp;length ); scanf ( "%d", &amp;width ); if ( length &lt; 1 || width &lt; 1 ) printf( "Length and width must be greater than 0.\n\n" ); } while ( length &lt; 1 || width &lt; 1 ); *out_length = length; *out_width = width; }
You can lead yourself into undefined behaviour very easily by forgetting to check the return value of `scanf`. Although this is just a trivial application, it is never a good idea to assume that user input will be sane. 
To add to the previous answers, there are multiple instances of you referencing array elements that do not exist, which will screw up your stack and lead to undefined results. Specifically, valuel[2] and x[2] do not exist. In C (unlike VB), when you define "int my_int_array[2];", you get storage for two ints, my_int_array[0] and my_int_array[1]. You are seeing unexpected numbers because you never set valuel[0] or valuel[1] to anything. There is no relationship between x[] and valuel[], but your code implies that you think there is. The other posters in this thread have provided better alternatives.
Damnit man, indent your code properly.
Yes, obviously. This example is just a rough demonstration, not a robust program. I don't even remember the last time I used scanf() in one of my own programs. The return value from malloc() also needs to be checked, and I've been using C++ long enough now that I don't remember if you have to manually cast its returned pointer to the correct type or not in C99. Oh, and it looks like main() needs to have a return statement at the end since main() needs to return an int.
In C, functions can return one thing. This one is returning one int. You take that one int, and you store it in value1[2]. (Note that value1[2] is out of range. You should have declared it as int value1[3]; so that the indexes are 0, 1, and 2.) You have stored nothing in value1[0] and value1[1], so they're just garbage. It looks like you're trying to have get_room_size() initialize the value1[] array. The C way of doing this would be to pass a pointer to the first element in the value1 array to get_room_size(). Then get_room_size() would modify the array that the pointer points to (which is value1). Put another way, get_room_size() would modify the value1 array indirectly via the pointer. C provides all kinds of sugary help to make this seamless with arrays. #include &lt;stdio.h&gt; void get_room_size(int a[]); int main(void) { int value[3]; // with arrays, you can get a pointer to the first element // just by using the plain array name: get_room_size(value); // pass pointer to first element in array printf("%d\n", value[0]); // prints 10 printf("%d\n", value[1]); // prints 20 printf("%d\n", value[2]); // prints 30 return 0; } void get_room_size(int a[]) { a[0] = 10; a[1] = 20; a[2] = 30; } In that code, C is allowing you to use array notation in the function definition instead of pointer notation, but there is most definitely a pointer to the value array getting passed to get_room_size(). get_room_size() gets a local parameter "a", which is initialized as a pointer to the first element in the value array. By operating on the values that "a" points to, we are actually modifying the "value" array, since "a" points to value[0], "a+1" points to value[1], and so on. This is TMI, but this code, below, works the same as the code, above; it's just using pointer notation, instead: void get_room_size(int *a) { *a = 10; *(a+1) = 20; *(a+2) = 30; } 
Nice benchmark suite, and khash is really cool. No surprises that it's possible to beat uthash, uthash has a lot of features (list order and sorting) and because of that it uses more memory and more code. For fun I created a hybrid solution using a in-structure handle like uthash, but relying on `containter_of` for the generic interface and using a macro-expanded suite of specific wrappers for specialization. It was faster than uthash and used a lot less memory in your benchmark. (And almost as fast as khash in the strings test)
About the award video: http://www.youtube.com/watch?v=LXZ1OL2U3lY Why does reality fade so fast? They're trying to make the 90's seem like the stone age!
You just throw that, and expect us to tell you something about it ? Good luck.
I'm just looking for something that I'm missing. The program is supposed to use semaphores to acquire the items then release the lock. This is the first time I've done something like this which is why I'm confused
What is the problem ? Does it work ? What are you expecting ? Why isn't it in /r/Java ?
[Learn C The Hard Way](http://c.learncodethehardway.org/book/)
If this is a Java class then there are issues with the fact that you have object instance level variables (chef, lock, homer_sprinkles, homer_filling) but all your methods are static so they can't access them. If this is C code then you don't use **import** or need the class declaration. Which is this supposed to be?
I put an edited version of my latest code in there. I think I got the jist of it but I have no idea how to code if the random number is 1 then it should notify homer_shell or if its 2 to notify homer_sprinkles, ect. 
It's a conditional operator. It's equivalent to saying "if m is between 0 and 60 then set r.minuto to m, otherwise set it to 0.
See [here](http://en.wikipedia.org/wiki/%3F:). I personally love this operator.
[Ternary Operator (wikipedia)](http://en.wikipedia.org/wiki/%3F:)
yeap got it, thought it would be something like this, but it was the first time i saw it so, confusion hit me. thanks guys!
This code can't be complete, I see no activation of threads. I believe I understand the concept you are trying to implement but the model is more C like not Java. Let's start with your methods. First, it appears you want basically three threads running: **homer_sprinkles**, **homer_filling**, and **homer_shell**. Then it appears you want to control the activity with the **table** *scheduler*. In Java to do what you want, you would construct Thread objects and pass them Runnable objects that contain your three methods. Below is some code that shows the concepts. It is not intended to show the best way to do this, just to show how threads work in Java. import java.util.Random; //util classes not imported by default public class Donut { //All java objects can be used as semaphores. We make //this static so it is accessible to other classes without needing //an instance of the Donut object static Object chef = new Object(); //this is used to control child threads. Thread loops should be //terminated programmatically, Thread.stop is unsafe. This is //also static to make it accessible to external classes static boolean done = false; //we need three threads, these are object instance variables Thread homerSprinklesThread; Thread homerShellThread; Thread homerFillThread; //to handle the three functions we create 3 anonymous //inner classes that implement the Runnable interface. Each //one does a different job. You could also create 3 separate //classes that directly implement Runnable or you could have subclassed Thread Runnable homerSprinkles = new Runnable() { //Runnable interface requires a single run() method public void run() { //this is why 'done' was made static, so I could do this while( !Donut.done ) { //now we grab the monitor on ourself. I didn't use 'this' //here, but instead the Donut variable that holds the //object so I can use it elsewhere as well. Because this //is an inner class of Donut it has access to all of Donut's //variables. synchronized(homerSprinkles) { try { //ok, let's wait for a notice wait(); } //if this happens, our thread was ended. exit the while loop catch(InterruptedException ex) { break; } } //By grabbing chef, we prevent the main table //thread from send the next command until //we are done. We don't do this inside the homerSprinkles synchronized //block so we don't end up with a deadlock condition. synchronized(chef) { ////do whatever here System.out.println("Notified Homer with sprinkles"); } } //let the user know we aren't doing any more sprinkles System.out.println("Done with sprinkles"); } }; //works exactly same as homerSprinkles Runnable homerShell = new Runnable() { public void run() { while( !Donut.done ) { synchronized(homerShell) { try { wait(); } catch(InterruptedException ex) { break; } } synchronized(chef) { System.out.println("Notified Homer with shells"); } } System.out.println("Done with shells"); } }; //works exactly the same as homerSprinkles Runnable homerFill = new Runnable() { public void run() { while( !Donut.done ) { synchronized(homerFill) { try { wait(); } catch(InterruptedException ex) { break; } } synchronized(chef) { System.out.println("Notified Homer with filling"); } } System.out.println("Done with filling"); } }; //create our Donut object and create, but don't start, the // homer threads public Donut() { homerSprinklesThread = new Thread(homerSprinkles); homerShellThread = new Thread(homerShell); homerFillThread = new Thread(homerFill); } //this is the 'worker' method run from the main thread public void table() { //start the child threads System.out.println("Starting threads"); homerSprinklesThread.start(); homerShellThread.start(); homerFillThread.start(); //worker threads are now running and stopped on their //own monitors Random r = new Random(); //since you didn't have any controls for exiting your table's 'while' //loop I added this just so the program wouldn't run for ever int donutsToMake = 12; //some support variables to determine when donuts are made boolean filled = false; int filledCount = 0; boolean shell = false; int shellCount = 0; boolean sprinkles = false; int sprinklesCount = 0; System.out.println("Starting donut line"); int x; while( donutsToMake &gt; 0 ) { //this is the global monitor, used by the main thread and all //child threads. Only one thread has it at a time synchronized(chef) { //you actually have 3 states (shell, fill, sprinkle), but r.nextInt(2) only //generates 0 or 1 and r.nextInt() generates 0 to 2^32, //probably not want unless you want sprinkles to happen way more times //than the other tasks x = r.nextInt(3); //generates number 0, 1 or 2 System.out.println("Issuing next command to workers: " + x); } if( x == 0 ) { //the main thread needs to now own a worker thread's monitor //before it can issue the notify command synchronized(homerShell) { homerShell.notify(); } //we have at least one usable shell now shell = true; shellCount++; //do we have a complete donut? if( filled &amp;&amp; shell &amp;&amp; sprinkles ) { System.out.println("Donut made....\n"); donutsToMake--; //reset for the next one, could be wasting parts though filled = shell = sprinkles = false; } } else if( x == 1) { //works same as the shell option just uses homerFill worker synchronized(homerFill) { homerFill.notify(); } filled = true; filledCount++; if( filled &amp;&amp; shell &amp;&amp; sprinkles ) { System.out.println("Donut made....\n"); donutsToMake--; filled = shell = sprinkles = false; } } //x == 2, same as the other two else { synchronized(homerSprinkles) { homerSprinkles.notify(); } sprinkles = true; sprinklesCount++; if( filled &amp;&amp; shell &amp;&amp; sprinkles ) { System.out.println("Donut made....\n"); donutsToMake--; filled = shell = sprinkles = false; } } } //ok, all 12 donuts are made, we need to shut down //the workers. First we set our global run flag 'done' to false done = true; //then we notify each worker one more time. their while loops //will now exit. synchronized(homerShell) { homerShell.notify(); } //we choose to wait for each child thread to exit before //moving on, but this isn't necessary. once notified, they //will exit try { homerShellThread.join(); } catch(InterruptedException e) { } synchronized(homerFill) { homerFill.notify(); } try { homerFillThread.join(); } catch(InterruptedException e) { } synchronized(homerSprinkles) { homerSprinkles.notify(); } try { homerSprinklesThread.join(); } catch(InterruptedException e) { } //and now tell the user how much we wasted making 12 full donuts System.out.printf("Created %d shells, %d filling and %d sprinkles for 12 donuts\n", shellCount, filledCount, sprinklesCount); } //all Java applications must have a main, just like C. static public void main(String args[]) throws Exception { //so we create an instance of our main object Donut donut = new Donut(); //now we start the loop. This runs in the main thread and //will exit when 12 donuts are made. donut.table(); } } Hopefully this helps you understand Java threading. Basically you have to fire off your thread workers with your processing methods. In C each of your static methods would have been given to a thread as well, so the concept is the same, just in Java you use a Runnable object (or subclass Thread directly and provide the run method). Semaphores are very much the same in both languages, just that in Jave every object can act as a semaphore and be grabbed by any thread that can see it. 
There's no reason for length and width to exist outside the loop. It is *far* cleaner to have them inside the loop, and today's compilers are smart enough to not make this a performance issue.
I think it's fair to say that it's going to be impossible to debug this without seeing some actual code. You've given us what you think is the relevant code, but you clearly don't understand what's going on - if you did you wouldn't need to ask the question - so your understanding of what's relevant in the code is necessarily incomplete. 
What? Are you insane? Local variables are located on the stack. Stack offsets are created by the compiler and used directly by the compiled code so there's *zero* overhead. Nothing gets "allocated". As for code sanity, in this example length and width have a useful lifetime of one loop iteration. Declaring them outside the loop is incredibly bad code hygiene -- variables should only last as long as the scope they are used in. Never mind that you're engaging in the worst sort of premature optimization. This is not a time-critical loop. Well-structured code is *far* more important than a few zillionths of a second saved in a loop that *pauses while it waits for the user to type input on the keyboard*. Please don't teach newbies, *period*. You *are* a newbie.
I currently happily use MinGW, Notepad++, and I type up little python scripts as I need them to sort projects (automatically make header files from the C files, and such). It works well for me, though it may not be the standard approach.
Vim, MinGW, terminal. I have quite a few Vim plugins to help me work faster, though.
1. [vim](http://www.vim.org) 2. [ctags](http://ctags.sourceforge.net/) 3. msys with [MinGW](http://mingw.org) and/or [MinGW-w64](http://mingw-w64.sourceforge.net/) 4. gdb 
A Linux VM. No joke. MinGW is the stuff of nightmares. Visual Studio Express is a reasonable answer as well, if you're already conversant with IDEs and won't be confused by the Microsoft-only nonsense like stdafx and .vcproj.
I use Visual Studio (Express), CMake and Vim. VS is ... bearable. Luckily, you only have to use it for compiling and debugging.
Eclipse-CDT isn't so bad if you can withstand the initial self-flagellation.
I don't do it all that much, but I use Emacs, MinGW, and msys. It's a lot like programming C in Linux, except for the lack of POSIXness and trivial-to-install libraries. A useful way to get MinGW + msys on your machine is to install the development version of Git. It comes with all the essentials. 
Pelles C
Never had any trouble with and always enjoyed developing in MinGW.
Code::Blocks and MinGW.
I have fun with cygwin &amp; vim. I even got clang on there.
[TDM-GCC](http://tdm-gcc.tdragon.net/) [Code::Blocks](http://www.codeblocks.org/)
Send more of your code. How c.setBackgroundColor works?
I use Emacs as my text editor, gdb for debugging, Valgrind to check for memory leaks, Make for compilation and linking and gcc as my compiler.
Thanks, for your input! What kind of version control do you use? What about subversion and git integration with Emacs?
Vim, gdb, valgrind, make, gcc and sometimes clang. Edit: git for version control
Git for version control. There is an excellent [Magit](http://philjackson.github.com/magit/) mode for emacs.
I use icpc (for MKL math kernal libraries) and gcc when I don't need mkl. Either way, I use makefiles for everything. Unless I'm using Qt libraries, then I use qmake. The VIm editor is great, I love it to death. Don't care for emacs tho. For version control I use svn, just because I'm use to it. You should ask the lab what they use? 
There's nothing wrong with using gedit if vim is hard for anyone in your group.
I agree with most of what's been said. Your basic tools are `vim`, `make`, `gcc` and `man` and `grep`, and in my practice, lots of open consoles in an unobtrusive window manager. I couldn't live without these lines in my `.vimrc`: set list listchars=tab:»¯,trail:°,extends:»,precedes:« set showbreak=··· highlight SpecialKey ctermfg=Red but then I regard tab characters as an abomination.
The suggestions on here are pretty spot on. You seem to be a little unfamiliar with version control, so I would recommend reading up on that. Git, as everyone else mentioned, would be my recommendation, but mercurial and svn are also options, depending on what kind of setup your lab has. For example, I use git with a personal Github account for all my personal projects. But I work in a physics lab as well and our group has a private svn server, so all lab work goes on that. In terms of how often to commit, this also depends on what version control system you are using. For git, the [git book](http://book.git-scm.com/) is a great place to start, and [this sheet](http://www.ndpsoftware.com/git-cheatsheet.html) is great for quick reference. I'm less familiar with svn, but I know there are similar reference materials out there. Out of curiosity, what is the lab working on?
its to change the collor. void Consola::setBackgroundColor(WORD color) { CONSOLE_SCREEN_BUFFER_INFO csbi; GetConsoleScreenBufferInfo(hconsola,&amp;csbi); WORD cor = csbi.wAttributes; cor &amp;= 0xFF0F; cor |= (color &lt;&lt; 4); // duvidas acerca destas duas linhas -&gt; TI ou TAC SetConsoleTextAttribute(hconsola,cor); } 
Make also sure you configure your compiler to be as strict as possible and activate as many warnings as you can tolerate (-std=c99 or -ansi, -pedantic, -pedantic-warnings -Wall -Wextra and so on for gcc, for instance). I also like to have my makefile compile the code with at least two different compilers, because sometimes one of them catches something the other doesn't, but is genuinely a problem in my code; at present I use gcc, clang and icc.
You want to set the width when printing the row number: cout &lt;&lt; setw(2) &lt;&lt; i &lt;&lt; " ";
I tend to use clang over gcc because clang has nicer error messages and I haven't really encountered any issues with it. I also use valgrind and gdb when I can because it real helps you out. splint/lint can also be handy for finding potential problems too.
Echoing everyone here. Just got a masters in high performance computing and a phd in mat sci. One thing, knowing MPI, OpenMP and/or pthreads may be helpful if you get into supercomputer or parallel codes. Vim and git are my favorites. icc almost always makes the fastest auto vectorized code. Clang is amazingly helpful especially when some stupid syntax error is killing you. 
May I ask why? (I'm talking about the tab characters)
I have two problems with tab characters. 1. I have no idea how wide they're supposed to be (four or eight characters?). Lots of people claim "oh, only use them for indentation, then tab width just doesn't matter." Unfortunately, tab width *does* matter if you care about column width. For readability reasons I absolutely limit all code to 80 characters (I'm writing on punched cards ;^) 2. Secondly, people frequently have no idea that they're inserting tab characters (I'm looking at `gedit` users here), and the result frequently is completely messed up code -- where of course I have to figure out whether they were writing with 4 or 8 character tabs, or maybe some nasty mixture, before fixing the problem. The best example I saw of this was once many years ago when the editor I was using at the time (some early version of Visual Studio, I seem to remember) decided to replace *all* the tabs with spaces in the file I was editing (because, I think, I'd selected "tabs as spaces") resulting in a complete catastrophe to the indentation. So, either use tabs absolutely everywhere and to hell with column widths, or use tabs everywhere, state the tab width and try and enforce a column width (that's what the kernel development style does), or throw tabs away. Fundamentally my problem with tabs is they are invisible, have unpredictable effects, and people don't get them right.
error C3861: 'setw': identifier not found do i need a library for that? th thing is,eatch square must have "4 characterer" spaces.
 #include &lt;iomanip&gt; It's part of of the standard iostream library.
thanks but nope its the same : (
guys i have a gotoxy function given by the teacher, maybe i can use it to change the bg collor. going to try that later. well if anyone wants to know this is the function. void Consola::gotoxy(int x, int y) { COORD coord; coord.X = x; coord.Y = y; SetConsoleCursorPosition(hconsola,coord); } 
Depending on the complexity of the project, I might choose use a better build tool than make. cmake and scons are good alternatives.
Basically because it begs the question, if not 80 characters then what? If I have to horizontally scroll to read your code, or just as bad, try and follow over a wrapped line, then at the first opportunity I'll reformat. I know some people regard 80 characters as old school, but it's a comfortable size. With 80 character columns I can have three windows side by side on one screen, one in an enlarged font for more comfortable editing. Whenever I encounter a file with overlong lines it's an interruption to my flow, generally I have to resize the window it's in to see it properly and then put it back again afterwards. So I like my punched cards (wish I hadn't thrown them all away, actually).
Please for all that is good, don't use additional make tools whenever possible stick with good old make. Everyone has make, and most people know how to deal with make, cmake is just lazy in all but the most extreme cases. Further more this is so many alternative make tools, qmake, cmake, bjam... I would much rather have to do this ./configure make make install then I would have to learn your favorite build chain.
What you're proposing is *not* just `make`. To do what you are proposing, he would need to learn the nightmare that is autoconf/automake, instead of a single, properly designed build tool. It looks like you're assuming that you are going to build his code at some point. Why would you think that?
no, the configure, make, make install, (the first being optional) is the standard way to build and install programs in a UNIX environment, the one that affects me. And yes I build a lot of software from source, and TBH if I can't do it with build essentials then I rapidly loose interest in it.
Did you try adding the std:: namespace: cout &lt;&lt; std::setw(i) &lt;&lt; i &lt;&lt; " "; 
Checkout the [git community book](http://book.git-scm.com/). It is a great reference for learning git and is free.
Boehm's GC is nice, if that's what you meant by memory management.
It is interesting that redditors downvoted autoconf. While I really dislike autoconf as a developer, I dislike cmake/scons more as a user. Autoconf is largely a standard, though a bad one.
What's the performance of this? Is it useful for lock-free datastructures?
You will have to use opendir(3), and readdir(3) for walking the directory tree. The opendir syscall will return NULL if the thing isn't actually a directory. If you want to check explicitly, call stat(2) and do a bitwise or of the mode_t field and the S_ISDIR constant. The header files you will need are sys/types.h and dirent.h for opendir/readdir, with the addition of sys/stat.h if you want to use stat. You can read in the file using the functions in stdio.h and tokenize the input using strtok(3), which is in string.h. Keeping track of words and their occurences is trickier. You will need to implement your own hashtable. I have an implementation of it at https://github.com/zhemao/libds.
New keywords: _Alignas _Alignof _Atomic _Bool _Complex _Generic _Imaginary _Noreturn _Static_assert _Thread_local \_Why \_Wouldyou \_Do \_This!? It just seems like a bolted on addition that to make fit with the rest of the language people are going to end up #define-ing things to what they *should* have been. *Ninja-edit*: Poul-Henning says it better than I can. [[link]](https://www.varnish-cache.org/docs/trunk/phk/thetoolsweworkwith.html)
It's for backward compatibility. Now can we please stop whining and talk about __cool new things__ in our favourite language? Like UTF-8, aligning, generics, static asserts and, of course, multithreading? 
If only GCC had full C99 Support, [http://gcc.gnu.org/c99status.html](http://gcc.gnu.org/c99status.html)
Those keywords were made using the rule in the older C standard that says "identifiers starting with an underscore and an uppercase letter are reserved for future use". That way, if anyone had violated that rule then it's their own fault that their code won't be C99/C11-compliant. This way, people can modify their own code to either utilise the standard definition of `bool` in `stdbool.h`, or, they can use their existing [or new] identifier instead (`BOOL`, `boolean`, etc.)
P.S. this is C not C++ 
Could you post your code in [codepad](http://codepad.org/)? It's much easier to read. (and test) You might also find [this man(ual) page on printf](http://linux.die.net/man/3/printf) useful.
http://codepad.org/g9mUmOis here is a better example
Ok ill try that, thanks! 
i just posted the link, check it out :P
You could use `getchar()` to read one character and then check what has been entered. Here's a slightly more extensive version of your program: http://codepad.org/XMOK475V Some notes: * Do not use `gets()`, for this reason (from its [manpage](http://linux.die.net/man/3/fgets)): &gt; Never use gets(). Because it is impossible to tell without knowing the data in advance how many characters gets() will read, and because gets() will continue to store characters past the end of the buffer, it is extremely dangerous to use. It has been used to break computer security. Use fgets() instead. * You will notice that I used `sizeof`. This operator returns the size of a variable, i. e. how many bytes it can store. It comes in handy when using function like `fgets()` that need to know how large a buffer is. * The `strrchr()` bits in my code kill the trailing newline that `fgets()` adds to the input it reads. In C, strings are terminated with a null byte, so we just put one where the newline is (`sttrrchr()` returns a pointer to the last occurrence of a character in a string or NULL if it isn't found). * Never do something like `printf(my_data)`! `my_data` can contain conversion specifiers (like %s) and an attacker could use them to gain access to sensitive data that your program keeps in memory. Not important for a small test program like this one, but important for other projects. Use `printf("%s", my_data)` instead.
i see.. thank you! but it is a little overwhelming to me. But i think i can figure it out :P
`_Bool, _Complex, _Imaginary` were added already in C99, not C11. (And it's a good and stringent thing -- if the standard has reserved a namespace, use it)
Perfection isn't always necessary.
In no way do I mean to be a downer, and no I will not downvote this post but I cannot stress enough how important it is to learn things like this on your own. Yes, there are hundreds of forums that will give you code snippets if you ask or fix your code if you post it like this, but this doesn't TEACH you anything. Everyone has been in your position but you can only learn and get better if you **DO NOT** copy and paste but rather open one of the many intimidating looking books/pdfs/whitepapers and say "hmmm how can I do this?" and figure it out even if it takes you 100 wrong attempts. **It may not be simple or efficient, but you'll discover a lot of "wrong" answers that are the right answers for a problem later on.** Again, I wish you luck and I don't want to diminish your interest in learning ANY language, but regardless of the language you're learning self discovery is half of the process and you'll be glad you did in the end. I'm workin on a CompSci degree and during that time I have interacted with many engineering, business, and biology majors who have to learn how to program at some point and I have frequently been told this is the most effective piece of advice they've been given on the subject and I only hope it helps you as well.
Believe me I totally 100% agree with you! I have been trying all day with no luck :/. But tomorrow my brother is going to help me with it, but I found it to be a very rewarding experience. I had one error tried to fix it and ended up with 6 errors lol. 
And what would you have the standard use? If they had decided to name them as `bool`, `atomic`, etc. then it would be a virtual certainty that it would clash with existing code that tries to define its own type by that name, making that code no longer compile if C11 mode is enabled. The result would be that nobody would ever use C11 mode because it would break too much code, and so compiler vendors wouldn't spend much time implementing C11 features, and the standard would be a failure. The original ANSI standard reserved all keywords named like that for just this reason, and so it's only right to follow up on that and use it as intended. 
Good, and again I don't mean to offend as I understand you have no programming knowledge to this point but that is a basic function that is taught in the first 3 chapters of any good C/C++ book so if this is giving you issues, I suggest reading more and reviewing all the associated theory. What do you plan to do with these strings? I would assume put them into a struct, but before you do that you need to look at pointers and their associated theory... It gets much more complex really quick. I guess what I'm trying to say is "learn" the language by reading at least half a book or no less than 4 hours of youtube videos before writing a single line **especially** if it's your first language. Programming isn't a linear "paint by numbers" but rather a 1000 piece puzzle with hundreds of different ways to put it together but only a handfull of those combinations will work as expected and/or efficiently. I'm not trying to disuade you from learning a language, I encourage it especially C as it's my absolute favorite, but I also don't want you to quit out of frustration because you haven't acquired the "overcoming error adversity" skill set which only time and banging your face against a keyboard can teach.
Well I plan on doing nothing with it.. I am only a freshman in high school lol I just want to start early because I have the resources to do so :P thanks for the tips!
Probably the most confusing part that Tblue did is the assignment's to tmp. tmp is actually a pointer to a character inside of the name buffer. If statements regarding tmp will then only be taken if the result was not 0. (Personally, I dislike assignment statements inside of conditional statements.) The *tmp = 0; will null terminate the string sooner, basically overwriting a character where the '/n' is located making the string "shorter".
I just don't understand how GCC plans to fully support Unicode based on ISO/IEC TR 19769:2004, when it doesn't even have a fully C99 compliant wide character implementation. http://en.wikipedia.org/wiki/Wide_character
Is there any realistic use for wide characters? They're terribly platform and implementation dependent.
[http://msdn.microsoft.com/en-us/library/dtxesf6k%28v=vs.80%29.aspx](http://msdn.microsoft.com/en-us/library/dtxesf6k%28v=vs.80%29.aspx)
And which use cases remain now that we have `char16_t` and `char32_t` ?
&gt; In addition, only one locale can be represented at a time in multibyte encoding, whereas all character sets in the world are represented simultaneously by the Unicode representation. UTF-8 is multibyte and it works fine, also locale is the wrong word..
I really do like your enthusiasm. Why did you settle on C for your first language, if I may ask? (I learned 6502 assembly first, then later 8086 assembly, then C, and looking back I wouldn't have it any other way.)
Don't forget [cscope](http://cscope.sourceforge.net/cscope_vim_tutorial.html) and [ctags](http://ctags.sourceforge.net/) for vim.
Holy f... it's *the* beej. Are you really he? I think I've downloaded all of your guides, but I must confess to having read none — someday, though, someday. As to the OP, mark another down for [K&amp;R's 2nd edition](http://www.amazon.com/Programming-Language-2nd-Brian-Kernighan/dp/0131103628/). Be careful if you're looking online for a PDF, there's one floating around that doesn't match the physical copy. I found, and sent, a PDF to a friend who discovered an error, which didn't exist in my physical copy. All the more reason to shell-out money for the real thing! I only went searching since the binding on my copy is starting to go, and I don't want to add further wear. 
yes i had that, thanks
i was able to do it lie moocat told me, with setw thanks mate! well now i have another problem totaly different, i would create another topic but its not needed. well in the constructor of a game engine, i'm alocating the map, and now i have to alocate memory for a number of factions given by the user, thats easy, i just use a default constuctor for the class "factions" and do it with no problem, howver after that i need to fill the array of "factions" with the other elements. For that i was thinking in creating an auxiliar object of Faction and then do the atribution by copy, how do i do that? tl:dr: how do i copy an object by atribution?
http://www.cplusplus.com/reference/clibrary/cstdio/scanf/ See 'Return Value' section.
well originally i was going to choose java, but then i looked more into c and c++ and realized C is the language i was looking for. In the bigger picture i want to be a game coder, so C seemed like a good choice for my needs and wants. and thank you for liking my enthusiasm ;D!
True, but gcc should limit itself to -std=gnu99.
Thanks for the reply. This reference library is AMAZING! Thanks again I will be making good use of this. Regarding my previous question you are referring to the *EOF*? I could then utilize the *feof()* with a flag to indicate incorrect input? I'm still working through this online course and have yet to encounter *EOF* in the lessons/readings so I'm curious as to how they expected me to validate without *EOF*...? 
Since git isn't available as a library (libgit2 doesn't count...yet), the only way to interact with real git is by calling commands with like execl() or system() which may not be as flexible as you need. This was the case with Gerrit (a code review tool written by Google), so the Gerrit guys decided to reimplement Git in Java (since Gerrit is written in Java). Sadly, this is not the first time this has happened. I believe GitHub uses a reimplementation of Git written in Ruby.
It lags behind main GCC? I didn't know that.
This is a perfect example of why people from C/C++ backgrounds are *very* skeptical of writing calculation-intensive algorithms in Java (and other languages that require boxing of number values — I believe CLR languages don't, but at the cost of some limitations with generics?). 
oh, I thought you meant MinGW :/
I don't like this blog. The most recent note of tip #13 doesn't even say which model chips were used during the tests, just giving the bit size of the registers for AVR, MP430 and an ARM Cortex gives you basically no information to go off of, and no assembly output is given for comparison. Since the assembly is basically all that matters in this case omitting it is really dumb, and it wasn't even mentioned that you should find a better way to pack time on an 8-bit or 16-bit micro than just using a uint32. The next tip #12 isn't as bad but still has some just issues with how it is presenting the data. Again, assembly dump anywhere for comparison? How would you want the assembly to look? Which compilers are to blame? The tip #11 is pretty silly as well, but makes more sense in the EE space where 'procedural programming' means put everything in one function that is ten pages long. Tip #3 is stupid as well. If you want to tell people not to use printf because vargs has a long startup time why is there not one single word about write()? In the embedded space you shouldn't be using things with hidden costs anyway if it actually matters, and there is no mention of alternatives. **tl;dr**: take this blog with a considerable grain of salt.
I will agree that he does miss out some useful information like the assembly and compilers he tested on. However I don't think tip #11 is too silly, maybe just a poor choice of example.In one of TI's programming guides they state to try and avoid functions in general as they seem to think they come with unnecessary over head. As for your comments about tip #3, I had not heard of write() before. After a Google it looks to me like its a linux fd function? So it wouldn't be feasible for the products he mentions, PIC and MSP430 which don't have the resources to need/run an operating system. Also I think the reason he only mentions printf functions is because that placeholders are useful. Using a write like function will still probably involve that you use all the something-to-string functions that printf uses also. 
&gt; However I don't think tip #11 is too silly, maybe just a poor choice of example.In one of TI's programming guides they state to try and avoid functions in general as they seem to think they come with unnecessary over head. Tip #11 basically says the opposite of what you are saying here, that you should use functions instead of giant switch statements that are parameterized. Again without really knowing beyond an AVR processor or the assembly output you can't really tell if the results are because the switch blocks were really long, the act of putting parameters on the stack or the fact that if you write a series of small functions any half decent compiler could inline the statements, especially in embedded land where lots of pins are used as global variables and any global var with a var++ assignment can be pretty much be put anywhere optimization wise without penalty. &gt; After a Google it looks to me like its a linux fd function? write() is standard in C99 I think, you should expect it if C is supported, just like read(). You can get really far without having to use printf, and from what his example was lambasting was the vargs implementation (where you can have a function signature int foo(int a, int b, ...); ), and if you were trying to do "hello world\n" you would want to be using a function without vargs. And if I am mistaken about write() being standard, there are still other options without vargs like puts() (C89) and fwrite() (C89)using the stdout descriptor, and neither of these functions mechanically require an underlying OS. Again this goes back to my previous point that the author doesn't say what compilers he uses, or really what chips he is using or the assembly output. There are ways to do static strings much more efficiently than printf. The cost in tip #3 is vargs, not the actual string wrangling, in fact doing the string wrangling on your own without vargs or doing a static number of args like printfi("%d", int i); might be a viable alternative without using printf and incurring the vargs penalty. Again I like the points he proposes, I just don't like the solutions because there are easily ten better ways to handle it (oh and the lack of code/assembly listings which are what matter 110% in embedded).
I think the intended point is that if you're building a string out of O(n) concatenations then this will have a complexity of O(n^2 ) where it need only have a complexity of O(n). 
Concatenating O(n) zeros still takes only O(n) time. It's not like strncpy needs to strcat each of them separately.
Concatenating O(n) bytes once takes O(n) time. Concatenating 1 byte O(n) times takes O(n^2) if you're using strncpy because it has to take the length of the buffer you're appending to each time.
That's more of a [Banner style](http://en.wikipedia.org/wiki/Indent_style#Banner_style) with an added quirk.
Oh, ok, now I got what you are saying, and the author seems to have fixed his description too.
Why is it misuse to want to safely take a substring from a string? It's a fairly common operation in any kind of parser.
Whoa that looks absolutely awful in markup language. Thanks for setting me straight though.
What tools did you use on linux? Maybe they work well on windows. Or we could figure out how you like to roll dev wise (eclipse cdt? vim? emacs?) and suggest windows solutions.
Your d4 array has no size! Arrays in C are not magically resizing (like e.g. a C++ or Java vector), they are static. I am surprised whatever compiler you are using didn't warn about this. Gcc says: dice.c:4:5: warning: array ‘d4’ assumed to have one element That "variable length array" syntax (d[]) is only really appropriate in a struct. P.S. Global variables are bad, mmkay?
I did get that warning, but assumed since it still compiled that it would just work since it kind of sort of did. I gave this a shot to initialize the array, and it seems to be working right. int main( int argc, char *argv[] ) { int d4[argc];
as drobilla says. also you should be surprised it works at all, and doesn't segfault. 
That is using a C99 feature called variable length arrays (VLA). It's roughly equivalent to: int *d4 = alloca(argc * sizeof(int)); ...except that `sizeof(d4)` will actually evaluate to `argc * sizeof(int)` instead of `sizeof(int *)` as with the above. Note that this means the data is allocated on the stack, which means it's not suitable for large or unconstrained allocations. Also, there is a portability price to pay for using this. In their infinite wisdom Microsoft has chosen to not support the majority of C99 in their C compiler, which means you can't use VLAs with MSVC. 
I seem to remember that `alloca()` or maybe some Windows specific equivalent works with MSVC, but it's been more than a decade since I've had to use Windows tools (good grief, has it really been that long?) `mingw32` seems to work ok when targeting Windows, and of course it does C99 + the very handy gcc extensions.
&gt; I did get that warning, but assumed since it still compiled that it would just work since it kind of sort of did. If you want to continue writing C, you need to disabuse yourself of this notion immediately. C is a powerful tool, but it doesn't hold your hand. There's absolutely nothing stopping you from, say, taking a random memory address from the stack and overwriting it with whatever you want to. When you write to a stray pointer, the damage might not be immediately apparent, it might just cause your program to crash (or worse, just return wrong results) sometime in the future. Example of a real bug: I had a 32-bit application, which filled an array of values by doing long* target; long* source; int len; for (i=0;i&lt;len;i++){ *source++ = *target++; } (not originally my code) I converted this application to 64-bit. It ran perfectly well. Some time later, a patch was added that added a memory allocation after this point in execution. The program would sometimes randomly crash from an assertion in malloc after that. The reason is that in gnu 64-bit, longs are 8 bytes. So, that array copy was clobbering it's length worth of random stuff on the heap when it was done. This often didn't hurt -- the heap was sparse enough that perhaps there just wasn't anything important there. But sometimes it ran over the structures malloc uses internally to keep track of it's state. Making some completely unrelated code to crash way in the future. In C, you really need to *understand* what each and every line of your code does. Luckily, this isn't so bad, because the C language is small enough that it's possible to hold it all in your head. But it is not a repl language, where you toss something together, and if it works, great. Things you don't understand can have serious consequences very far from where they were written.
The operation is common, but your assumption of using strcat() in O(n*n) time is certainly not common at least among good C programmers.
You simply use calloc. int *d4 = calloc(argc, sizeof(int));
&gt;The program would sometimes randomly crash from an assertion in malloc after that. &gt;The reason is that in gnu 64-bit, longs are 8 bytes. So, that array copy was clobbering it's length worth of random stuff on the heap when it was done. There's no inherent reason that a change in `sizeof(long)` would cause that loop to result in a crash -- unless for some reason your buffers aren't actually large enough to hold `len` values of type `long`. (In the code fragment you posted, none of the variables are initialized, so it's hard to tell exactly what's going on.)
&gt; I did get that warning, but assumed In C, this will be the death of you. This is why most C and C++ programmers throw whatever set of flags (in gcc, -wall -werror -strict -pedantic) makes the compiler be as strict as possible, and treat all warnings as errors. &gt; I gave this a shot to initialize the array That's one larger than you need. The first "argument" is the path from which the application was run. What you're thinking is the first argument is actually the second. It's C. No guessing.
The desired effect was to copy over a single 4kB page. (long) pointer++ increments by 8, and (int) pointer++ increments by 4. So, with a len of 1024 and 32-bit longs, that code copies over a buffer of 4kB. With a len of 1024 and 64-bit longs, that code copies over a buffer of 8kB. It honestly took me a week of debugging to find that one, from when I realized that something was actually wrong. Fixed by replacing with a call to memcpy.
Hey this is about a month too late, but a really good reference to learn C is the [GNU C library reference](http://www.gnu.org/software/libc/manual/html_mono/libc.html). For example, here is [the scanf and related input functions](http://www.gnu.org/software/libc/manual/html_mono/libc.html#Formatted-Input) section. Once you are more comfortable with C, a very good "best practices guide" is [CERT C Secure Coding Standard](https://www.securecoding.cert.org/confluence/display/seccode/CERT+C+Secure+Coding+Standard). Again, as an example, see [what they say about the exact code you posted](https://www.securecoding.cert.org/confluence/display/seccode/INT05-C.+Do+not+use+input+functions+to+convert+character+data+if+they+cannot+handle+all+possible+inputs).
Whenever you see yourself doing anything where variables start to be named var1, var2, var3, var4, ... you should look into doing an array. Perhaps a max_row[3]/max_col[4] would be more sensible. Whenever you see yourself doing suspiciously similar code you should see why it is similar and see if it could be compacted. You make this programatically hard by having bad variable names, and the first suggestion could help you quite a bit.
http://pastebin.com/0a2q5ysL This might help you. Also your code indentation makes me cry.
I changed it up a bit and made it in terms that I understand. Thanks a lot, it really helped me understand the structure of some of the things in C. Here is what I changed it to if you are curious: http://codepad.org/5UiSxLAY
Nice. I forgot that I could use %3d instead of my ugly hacks. Thanks for fixing it and good luck learning C!
/* Output even numbers */ if ( i % 2 == 0) printf("%d",i); No brackets needed for one line, come on!
[emacs+autocomplete](http://www.emacswiki.org/emacs/AutoComplete)
 struct Node { char *data; struct Node *next; } *head; char * nextItem() { struct Node cur_ptr = cur_ptr-&gt;next; return cur_ptr-&gt;data; } In Struct node, **next** is a pointer. In nextItem, **cur_ptr** is not a pointer at all, it is a struct. Also, you're creating a variable called "cur_ptr" and when variables are first created, they're full of random bits. You've just created a Node struct full of random garbage and then tried to use "-&gt;" on it as if it were a valid... anything. But it isn't. You should watch [Pointer Fun With Binky.](http://www.youtube.com/watch?v=f-pJlnpkLp0)
 struct Node cur_ptr = cur_ptr-&gt;next; It may make things mentally clearer for you if you adopt a coding style more like this: struct Node cur_ptr; /* Create a var called "cur_ptr", which is a Node struct. */ cur_ptr = cur_ptr-&gt;next; /* Move to next node. */ Neither line is really what you want. If you separate them out, you might have a better chance of seeing how (and why) that's the case.
alloca is not VLAs.
MSVC does not implement C99, so it's certainly as close as you're going to get.
I came here to say basically the same - It's pretty amusing to see a cycle comparison of the same code throwing around 32 bit integers. It happens to be a lot faster on a 32 bit processor (wow!)
The first argument of `printf()` should always be a format string, not an arbitrary string. If you have some string `s` that you want to print, this is incorrect and dangerous: printf(s); /* WRONG AND VERY BAD */ The problem with this is that if `s` happens to contain text that `printf()` thinks are format characters, things will go off the rails into undefined behavior land. Believe it or not, this can lead to a remote exploit. If you want to print a string, say so: printf("%s", s); /* safe */ If you can tolerate a newline being added, then use `puts()` instead: puts(s); /* safe */ The compiler is warning you that you're doing something that's probably wrong. It's a warning, not an error, by the way.
Greatly appreciate your help. Thank you.
Whatever floats your boat.
It must be an interesting class that hasn't yet covered printf.
It was covered, but it was very general. He mentioned that it wasn't the best choice for printing, but that he would go into that later in the semester. If you like I can pm you a copy of my notes.
Game programming is a major venue for C and C++ programmers. Then there's embedded programming, and of course, the derivate Objective-C is heavily used on all Apple platforms. Raw C is not necessarily a very productive language for every use case, but if you're writing a library, and you want to stay 1) cross-platform and 2) usable by every other language, it's the lowest common denominator, API and ABI wise. For end user products, I would personally prefer C++, because things like RAII and smart pointers allow you to be a little less careful with your memory management, template classes allow you to cleanly reuse more code, and strong type checking catches a higher number of "stupid" bugs (yes, C compilers can catch those too with the proper compiler flags). That said, some C programmers can be very productive with things like GLib and GTK+.
Get a tiny microcontroller like an arduino, a nintendo DS or whatever and start hacking away on it. It's super fun, you can build cool stuff with it, and if you want to, it's easy to build a little operating system on top of it.
While Python and Java are perfectly fine programming languages (while Python is more of a scripting language, but whatever) but with C you actually learn what's happening **inside** the machine (without using non cross-platform assembly). I think it's a huge advantage if you know what's happening when your code runs since it makes you more efficient when debugging and when writing code. Besides that, it's used in a lot of devices you use at home (using a thermostat? 90% chance it's written in C. You car? A big part of it runs C code!).
C is used for mostly embedded and kernel stuff these days. It is good to know C because it gives you knowledge of how the computer actually works in terms of the stack, heap, registers, kernel etc. Although I am personally fairly well versed in C I tend to forego it for personal projects because I prefer working with higher level abstractions. If you know the very basics of C I would recommend that you either get a copy of Expert C programming or that you get the source of a small [program](http://code.google.com/p/femtobot/) written in C and read that.
 float boat; whatever(boat); 
mainframe programming
What is the "best choice for printing", then, and why weren't you using it? And back to the original point: why would you attempt to guess at how printf works when you decided to use it rather than look at a single reference, of which there are thousands, probably at least one without even using your network interface? Getting someone on the net to do your work for you won't work when you're in a job. 
Yeah, embedded is a hell of a lot of fun. Something about being that close to the hardware and using minimal resources to do something is great. 
I really don't think C gets someone to know what is happening inside of the machine. As you mention it's Assembly language does that. Yes in C you're not as removed from the hardware, you'll have to deal with memory management, but it's a far cry from say understanding much about circuits like flip flops, half adders etc etc. For one to learn about assembly I think it's almost necessary for them to learn about things like the ALU, the bus, registers, how memory physically works and is addressed, von nuemann versus harvard architectures. In C not so much. 
Certainly not just the kernel. The overwhelming majority of all software on a typical GNU/Linux machine is written in C.
Well, Im not sure as "he said he would go into that later in the semester". I hate when people try to get people to do their work for them on the net too. As you see, I did not ask to have my hand held and have the code written for me. I asked for an explanation of what was happening based on the code I had already written and the message I was getting from the compiler. People always say there is such a rich community for beginner programmers. Yet every time Ive even HINTED at needing help with something that the average programmer considers simple on any forum (Here, r/programming, stack overflow, etc.) I get blasted for trying to find an easy way out. As I stated in the original post, my homework is done. I just wanted to do something a little extra. I again apologize for being such a waste of human life to you, I will change my major to liberal arts now if you like.
Do... do you really not know C99 initializer syntax in for loops? Nothing is being redeclared or redefined; the variable is defined exactly where it is used and is therefore more clear.
 float aFloat = whatever(your.boat); // whatever() returns the value of your.boat cast as a float // so that whatever() literally floats your.boat. fuck you who downvoted.
I'm with you dude! I've coded a bit in C for mainframe... Thought I don't like z/OS, but it's a huge and solid system.
Isn't game programming with structured programming a pipe dream?
Systems programming
I'm not sure what you mean. Can you elaborate?
I agree if someone is using C as a general purpose language in their BSD/Linux shell. If that same person was to pick up an AVR or other "toy" embedded controller, that person would only then come to realize how a uint8_t is literally only 8 bits wide, and every single one of those damned bits matters (and pretty much directly maps to a physical pin on a physical chip on a physical breadboard attached to a physical LED/fan/motor). There a thousands upon thousands of libraries available that abstract your hardware away from your code, your OS being the most prominent. The closer to the hardware one gets, the more magical things might become, and that's when one can finally start to understand what exactly is going on.
No offense to OP, but curl and ncurses programming aren't necessarily the easiest things to get into. Curl isn't extraordinarily difficult, and I use it regularly, but I wouldn't recommend it so quickly.
There are a lot of games written in C. in fact, SDL is written in C. I'm not sure what you mean here.
I should have been more specific: modern games. Of course writing in C is viable, but now the complexity of games require the level of abstraction that OOP provides.
Look, you used printf() without a clue how it works. You can't do that. When I said that, you said he hadn't covered "getting a time stamp from the system clock". That's not relevant to printf. Printf doesn't get the time stamp. It prints it, or anything. Then when I said I couldn't really believe he hadn't covered printf, you said he had called it "not the best choice for printing", and would go into it later. So I asked what is the "best choice for printing", implying "according to your prof". There's zero chance that you're any distance into a C course with no discussion of how to generate output. Programs that don't generate output are useless, and the very first toy program *always* generates output. So how are you supposed to do it? And if you have a way to do it, why did you choose to ignore that and use printf()? And if you choose to ignore it and strike out on your own, why on earth would you not look up the *documentation for how to use printf*? Your story doesn't hang together, and I think you're not being honest, and it's not harming me, but it's certainly harming you. You should actually tell the truth, particularly when you want help.
This is a little bit disingenious. The reason C is used for operating systems and driver is not that it is somehow superior when a programmer has to deal with huge projects — it's because C gives the programmer full and complete control over the code, with minimal pitfalls. In an operating system, the costs of a virtual method call or larger code size due to template generation are readily visible, because it's something the programmer explicitly has to decide to do, and so that's why most operating system designers and programmers for embedded systems prefer C. I would not think to use C for a video game, where you can afford to do targeted optimization.
Of course it is. $ cat schlecht.c #include &lt;unistd.h&gt; int main() { for (size_t x = 0;;); for (size_t x = 0;;); for (size_t x = 0;;); return 0; } $ gcc -std=c99 -o schlecht schlecht.c $
so you never printed the result of a calculation. Again, that's some class, to be midway through February (must be at least 3 weeks in, right? 4?) and not ever have written a program that does any calculation...
You got me. I knew how to use time() all along. It was all an elaborate ruse. +10 Detective
Are you serious? You still don't even know that the problem was printf(), not time()?
It also will not slow down already-compiled code.
One of numerous reasons: if(...) { &lt;-- either o or O are valid vi commands here ... &lt;-- either o or O are valid vi commands here } if(...) &lt;-- o is not a valid vi command here { &lt;-- O is not a valid vi command here ... }
Lots. My browser, and status monitor, I wrote for example in C. You can make very short, efficient code in C and still produce a featureful product, especially if minimalism is an aim. It's also extremely portable. I'm writing a small general purpose text game engine for *nix systems in C, and while the platform isn't exactly a demanding one to write for, It's a lot of fun to put together.
C may not be the best for numerical analysis. I'm not saying you can't do it, but unless it needs to be done routinely on production code you might want to consider learning Matlab. What do you mean by float being implemented? In hardware or software? Modern desktop processors have it implemented in hardware. Many ancient desktops (486 SX) and micro-controllers can emulate it in software.
I'm familiar with Matlab, however I will likely be using R for my undergrad thesis, since its a statistics problem, however I will be using a regression method that is very similar math-wise to Finite Elements, hence it involves a lot of matrices etc. To get to the point, C/C++ is used where R is slow and/or imprecise, so it would be handy to know. The floating point thing was just curiosity to be honest.
I recommend reading the GNU C library manual, which I found really useful: http://www.gnu.org/software/libc/manual/
You might want to learn Fortran, as it is still used for a lot of numerical analysis programs. Fortran is not as flexible as C, which allows the compiler to make some assumptions which can compile to faster code. I wrote my last Fortran program 20 years ago.
&gt;Does anyone know of an example of a float being implemented? IEEE 754? It's already there in the type "float". There's also "double".
C is a great language for implementing numerical algorithms (such a mat mul) however it is not so good for encapsulating these and being able to talk about them in higher level terms. C++ is a much more complex language with a steep learning curve, and you will find yourself having to 'unlearn' various thing but thanks to libraries like ublas maths can be done with the speed of C but with a more mathical syntax.
have you checked out gearman?
No I haven't. I must say [gearman](http://gearman.org/) looks really cool. Thanks for pointing that out.
Your point was that structured programming becomes difficult to manage. Threesan's point was that things like the Linux kernel are extremely clear - as clear or more clear than they would be had they been the victim of OOP.
Latest free committee draft, as close as you can get without paying for the final version. http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf
Next week: How to staple jelly to the ceiling.
I'm thinking that's going to be an easier task.
Or you could just use GLib's [GObject](http://developer.gnome.org/gobject/stable/chapter-gobject.html) [(wikipedia)] (http://en.wikipedia.org/wiki/GObject)
That's because atoi is looking strings rather than characters. Maybe you should use a function which works on chars (or ints) like isdigit or something like that.
To convert a char that represents a digit into the integer it represents, just subtract the ascii value of 0 from it. This works because the digits are represented by consecutive small integers. if (isdigit(c)) { n = c - '0'; }
I will give it a try and get back to you. Thanks.
There are probably several things that need to be done when validating a specified format: Is the length of the string correct? Just chopping it at the 14th (say) character won't check that. Is the general format correct? Are the separators (dashes here) in the correct spots? Does it matter if the separators aren't the correct separator characters? Could you separate the various fields more easily, say by using strtok or similar? How do you validate each separate field? All digits? Then how about an isdigit loop? All alphabetic? maybe use an isalpha loop. Etc. 
14 is the length i've been working with as the ISBN is 10 digits with 3 dashes and the newline that fgets places. The input doesn't have to be separated but the program should be able to deal with dashes if it is separated. Other characters or letters are incorrect input, would then prompt again for correct input. I am unfamiliar with strtok and after a quick lookup it seems it would be ideal for this situation I would prefer to use a more straightforward approach.
I thought I was getting some success but I've managed to muck it up. My isdigit isn't getting digits from what i'm feeding it anymore. I'm getting a lot of arghs for(num = 0; num &lt; 14; num++) { if (isdigit(*ptr)) { convert = (*ptr - '0'); *ptr2 = convert; *ptr++; *ptr2++; } else puts("argh"); } 
Ok. This is ridiculous. Rather than this, I recommend reading Steve Dekorte's [Objects in C](http://dekorte.com/about/papers/2002-OOC/), which is about using OOP as a way to structure your C programs, and establishes certain conventions, rather than trying to emulate C++ features in C.
Yeah, you're right to use the "++". I was asking about the star. That's only useful for retrieving or modifying the value stored at the address being pointed to. What I mean is that, if all you're doing is incrementing the pointer (but not interested in the value at the location it points to) there's no need for the star.
OK, well I just hope I was helpful.
Doom was written in C, and has many of the features of "modern" games (in this case modern FPSs like later id engines): * Creature AIs * Multiple monsters * External map and texture formats * Interactive map elements * Multiple weapons It's not a mess of spaghetti code or grossly unabstracted peephole optimisations. There may be a certain syntax overhead for having to manage object methods as separate functions, but that's about it. 
Doom isn't even a 3d game...
It's is less 3D than any of its successors; some have called it "2.5D". But it does math to figure out how to map polygons in 3D space onto a 2D screen. Sure it has limitations on the angle of view you can look at or the alignment of those polygons, but for all intents and purposes the player is running around in a 3D world. Are you saying because floors have to be level and cant overlap, that it's completely unlike any modern game?
The problem is not object oriented programming in C, which in many cases is easier than in C++, but trying to reimplement C++ in C. OTOH, avoiding C++ should always be your number one priority.
&gt; The problem is not object oriented programming in C, which in many cases is easier than in C++, but trying to reimplement C++ in C. That's true, but a lot of the specific OOP features in C++ are pretty much exactly the implementations of OOP features that people expect when you say "OOP". :-) There are other, simpler, ways to do it, and when you're working in C, I would definitely recommend a more straight-forward approach (I like the way the Linux kernel implements pseudo-polymorphism in its handling of IO objects, for example). &gt; OTOH, avoiding C++ should always be your number one priority. You know, people say things like this all the time, most of the time half-joking, and that's fine, but it's not a very informed statement. C++ has a lot of features, and to a young programmer, many of them seem dangerously attractive. But in the hands of an experienced programmer (which most C programmers worth their salt will be anyway), it is *immensely* powerful.
&gt;&gt; OTOH, avoiding C++ should always be your number one priority. &gt; You know, people say things like this all the time, most of the time half-joking, and that's fine, but it's not a very informed statement. C++ has a lot of features, and to a young programmer, many of them seem dangerously attractive. But in the hands of an experienced programmer (which most C programmers worth their salt will be anyway), it is immensely powerful. To use a stupid analogy... Yes, a bomb can be extremely powerful in the hands of an experienced person, but that doesn't mean you should use it as a foundation for a house. At 15 years years of experience and going, I consider myself fairly knowledgeable in C. I pretty much only use C++ when I have to, mostly professionally, and the amount of shit you run into when working with C++ makes it unreasonable for anything bigger than 'Hello World'. In particular I remember one time I (professionally) ported a Windows C++ application to Linux. I decided to run Valgrind on the beast and found so many hidden bugs you would never have been able to find just from looking at the source code. The rest of the company, comprised of experienced C++ programmers, were very impressed about the bugs I found. The sheer insanity of the C++ language and syntax should drive away anyone with a reasonable amount of software development experience.
&gt; To use a stupid analogy... Yes, a bomb can be extremely powerful in the hands of an experienced person, but that doesn't mean you should use it as a foundation for a house. Yes, that is a very bad analogy. :) You know, the strength of C++ is the ways in which it allows you to structure your code to be *less* bug prone. It doesn't force you to do so, but being knowledgeable about the common best practices (use raw pointers with extreme discrimination, use RAII where applicable, depend on the strong type system, etc.) is the primary way to create software containing *less* bugs than you would ordinarily find. Unfortunately, many people write C++ without knowing the first thing about these very common idioms, but that's not the fault of the language. The same people will create the same amount of bugs in C, if not more.
I would highly recommend this: http://www.amazon.com/Linux-Programming-Interface-System-Handbook/dp/1593272200/ref=sr_1_1?ie=UTF8&amp;qid=1330527521&amp;sr=8-1 It gives you a good place to go and use all that C you just learned to write programs to do REAL THINGS 
I know :( I started learning a couple weeks ago, and I'm bad. The pointers are there mostly because I started putting them wrong, realized what I was doing, and was too lazy to go back and fix them. The professor wanted us to have individual integer variables for each assignment grade, but that would require 7 more arguments per function and I was like nooooo, I'll just use an array. ~~I still don't understand what's wrong. I understand you not wanting to tell me exactly what is wrong, but could you at least tell me what line the first error is on so I can work from there?~~ Edit: LOL I feel like an idiot. - Thanks :)
I know you're learning...and man it shows. So I just thought I'd give a little bit of advice on getLetter(). You're trying to set up ranges for a letter grade, and a switch statement is a horrible way to convey ranges. I'd recommend rewriting void getLetter(int percentOfTotal) to use just if and else if statements. You should end up fewer lines of code that is easier to understand, debug and change. Also, use a for loop for calculatePoints() instead of all those if statements. Set temp to the ass[0] and just loop through the rest of the indexes (i = 1; i &lt;= 6; i++), when you find an index less than temp, set temp to it. It'll be about 3 lines of code, and much easier to understand, debug and change.
I didn't entirely understand what you meant by doing a % to get the lowest digit, so I did this. Acceptable? It looks way better than it used to. The prompt says that it must contain a switch function, it doesn't say that it can't contain anything else. void getLetter(int percentOfTotal) { int temp; char letter; switch (percentOfTotal/10) { case 10: case 9: letter='A'; break; case 8: letter='B'; break; case 7: letter='C'; break; case 6: letter='D'; break; case 5: case 4: case 3: case 2: case 1: case 0: letter='F'; break; default: printf("Invalid percentage"); } if (percentOfTotal==100 || percentOfTotal==99 || percentOfTotal==89 || percentOfTotal==79 || percentOfTotal==69) printf("%c+",letter); else if (percentOfTotal==90 || percentOfTotal==80 || percentOfTotal==70 || percentOfTotal==60) printf("%c-",letter); else printf("%c",letter); }
Very close to what I was thinking and a huge improvement. The modulus function or % will give you the remainder after a division, so if you want the lowest digit, you'd divide by 10. if (percentOfTotal &lt;= 100) &amp;&amp; (percenOfTotal &gt;= 60) { lowestDigit = percentOfTotal % 10; if ((percentOfTotal == 100) || (lowestDigit == 9)) { // Plus } else if (lowestDigit == 0) { // Minus } } else { // No plus or minus } See how there is a slightly less complex conditional (5 comparisons instead of 9)? Often conditionals are where bugs are introduced. As a programmer you'll want to reduce the number of places bugs can be introduced. (As a side note, depending on the CPU architecture your solution might still be faster. Some CPUs do a division for the modulus function which can be really slow.)
I think this is what you meant, and I do agree that it is much nicer than what I was doing. Thanks! :) Upboats for everyone! lowestDigit=percentOfTotal%10; if (percentOfTotal==100 || percentOfTotal&gt;60 &amp;&amp; lowestDigit==9) printf("%c+",letter); else if (percentOfTotal&gt;60 &amp;&amp; lowestDigit==0) printf("%c-",letter); else printf("%c",letter);
I've updated the OP with what I need to fix now ( in bold )
Very nice, that part of my function now looks like if (percentOfTotal&lt;=100 &amp;&amp; percentOfTotal&gt;=60) { lowestDigit=percentOfTotal%10; if (percentOfTotal==100 || lowestDigit==9) printf("%c+",letter); else if (lowestDigit==0) printf("%c-",letter); } else printf("%c",letter); 
That's fine as long as you don't get an illegal value earlier on. You'll hit the printf("Invalid percentage"), then the printf("%c",letter); At that point the letter will be uninitialized and you'll print garbage. You could add a return after the Invalid Percentage, but I dislike functions with multiple returns. Unfortunately C doesn't have exceptions. Another common thing to do in that scenario is to have a goto to the end where it returns. Gotos are considered harmful. What I would do wrap the entire function with a if percentOfTotal &lt;= 100 and percentOfTotal &gt;= 0) and move the error statement from the switch statement to the else statement.
You seem to be very knowledgeable, do you have any thoughts as to why I am not getting valid totalPoints/percentOfTotal in calculatePoints()? (line 197) 
Like this? for (i=0;i&lt;6;i++;) { *assTotal+=ass[i]; if (ass[i]&lt;=ass[0] &amp;&amp; ass[i]&lt;=ass[1] &amp;&amp; ass[i]&lt;=ass[2] &amp;&amp; ass[i]&lt;=ass[3] &amp;&amp; ass[i]&lt;=ass[4] &amp;&amp; ass[i]&lt;=ass[5] &amp;&amp; ass[i]&lt;=ass[6]) { temp=ass[i]; } } *assTotal-=temp;
Closer! The summation and subtraction is correct. The if statement is wrong. Set up the temp value outside the loop (you can initialize it to ass[0]). Then compare temp to ass[i] and assign temp to ass[i] when it is ass[i] is less than temp. Renaming temp to lowestValue and it might make a bit more sense. Once you see how simple it is you'll give yourself a dope slap.
I'm a professional software engineer and review a lot of code. Pretty sure your if statement in the loop is broken. Debugging tip, sprinkle printf() statements throughout your code to figure out what the variable values are and whether they make logical sense at that point in the code.
I see what you mean... int lowestValue=ass[0],i; for (i=0;i&lt;6;i++) { if (ass[i]&lt;=lowestValue) { lowestValue=ass[i]; } } *assTotal-=lowestValue; right? lol iambadandshouldfeelbad.jpg
Yes! Doesn't that feel so much better than your original code? For a minor performance improvement you can change the &lt;= to &lt; in ass[i] &lt; lowestValue as there is no need to assign it when they are the same value. 
Really, your excuse is your professor broke your program? So you blame someone who tried to help? Really, the only thought going through my head is Fuck You.
Yes, I should have worded it differently. The professor does provide some time in which we can ask questions and he can review our code, and I am thankful for that. I will quote the bolded text I've added at the top &gt; Let me make it very clear that it is my fault that this program doesn't work. I wrote a BAD program and when my professor attempted to help me, it became even less functional. We ran out of time and I had to leave. Because he was unable to help me, I came here.
Working on it right now.
Okay -- it is at: http://pastebin.com/kr2p980p If you are using gcc, compile with: $ cc -std=c99 main.c -o assn7 -lm I tried to duplicate the exact output in the examples. Frankly, I hated this assignment. :^) It was more tedious than challenging and it didn't require very robust error handling. eta: I forgot to toss out the lowest but not the last assignment score. Fixed here: http://pastebin.com/FXv6cwhA 
I've attempted to fix a few linux kernel bugs for the guests, but usually its something trivial and simple (timeouts, etc). I was wondering exactly what the Z/OS native environment was. Thanks.
I've never programmed at the kernel level in z/os but even programming at user level is completely different. There are some similar concepts but mostly it's a whole different world, physical and logical organization of "stuff" (shared memory, storage, processes, users, etc). I find mainframes really interesting from a design perspective and from backwards compatibility. 
Good luck being contrary to anything on this reddit. 
 struct closure { int state_variables; void (*function)(struct closure *, int arguments); } struct closure *c = make_closure(1, add); c.function(c, 2); // returns 3 old school, but it works. GCC and clang (i think) also support [blocks](http://en.wikipedia.org/wiki/Blocks_\(C_language_extension\)). 
Thanks. I figured it would be something similar based on how the first arg in python methods is \_\_SELF\_\_. Now forgive me if I'm confused, but my complication is that I want to implement many closure structs with different state but still refer to them generically by some base type. struct closure { void (*function)(struct closure *, int arguments); } struct closure1 { void (*function)(struct closure *, int arguments); int state; } struct closure2 { void (*function)(struct closure *, int arguments); string state; } Should I cast them all to closure* if the function ptr is always the first field? Is there a better way to do this?
&gt; I like the way the Linux kernel implements pseudo-polymorphism... I'm new to C and just posted a [question](http://www.reddit.com/r/C_Programming/comments/qqxgm/how_do_you_implement_a_function_object_function/) asking how to implement Java interfaces in C. If this is similar to what you were referring to, could you share some info?
I read that in C you can refer to the struct by the type of its first element? I did a test and &amp;closure == &amp;(closure.function). Is that in the spec / every compiler? So would it be safe to use it as a typedef'd function pointer (the first field) instead of by the struct name?
Agreed. When talking about "C-like" languages, missing D seems a mistake. Both D and Go are C the right way and they are compared favorably to each other.
What surprises me is that GNU and therefore you would assume GCC are very pro C and fairly anti C++ (in terms of what most GNU tool are written in -- I think the GNU hand book also recommends C over C++ because it is easier to learn). Yet the C11 features whilst probably easier to implement are no were near as complete as the C++11 features. As a C++ guy I aren't complaining but it is curious.
I am happily using C++11 with most of the feature set intact, on GCC at least almost everything I have needed has been there except regex and delegating constructors. Clang is still away off although they make a lot of noise about how well their doing but they don't touch gcc yet. MSVC is pretty lacking TBH, there are mssing really basic stuff like variadic templates and range based for loops. I have never used s sun compiler ;)
But Doom was a rich and fun game. Isn't smaller code a good thing?
When was the last time that you played Doom?
Go needs an artist to help the engineers developing it. As a set of features Go appeals to me so I've experimented with it on a couple projects but nobody I know likes the syntax especially the StudlyCaps for public method names. Regardless of your preferences towards camelCaps vs underscores public methods should take the least amount of effort to write since that's what you are going to write the most of. As Matz (Ruby) puts it, "optimize for programmer happiness".
The Linux kernel is very "object oriented", if you spend any time looking at the code. It's sad that most higher-level programmers don't realize that. I find lots of apps. these days with far worse OO design despite being in OOP languages than some of the very old school C programs that exist. 
Not to a call to "whatever": void whatever(float /\*foo\*/) { return; }
All the web servers with the highest performance are in C, FYI. 
Eh, no. If you spend any reasonable amount of time doing C development, sooner or later you're looking at disassembled binaries side-by-side with source. That's really when you start to gain an understanding of how 'C becomes assembly'. That's just not true of most other languages. Python programmers (who haven't spent much time in C), in particular, often have very bad gut instincts about performance hotspots. And I'm not talking about O notation here and algorithm choice. I'm talking about the core things that sometimes 'escape the math', things like locality, etc. when it comes to processing large volumes of data with tight loops. Good C programmers will run circles around everyone else, in my experience, because they have a good idea of how their C turns into machine instructions. 
"Won't compile" is too vague. What are the exact compiler errors? What compiler and linker options do you have enabled? Are you trying to do anything you shouldn't, like putting large objects on the stack or in static/global variables? You're going to need to use the heap. 
I'm getting an error from the x64 cl.exe of : LINK : fatal error LNK1248: image size (BEBD8000) exceeds maximum allowable size (80000000) for this program #include &lt;iostream&gt;//all the normal includes #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #include &lt;conio.h&gt; #include &lt;string.h&gt; #include &lt;math.h&gt; float vala[4000][100000]; float valb[4000][100000]; int x,y; int main() {//int main for(x=0;x&lt;4000;x++) { for(y=0;y&lt;10000;y++) { vala[x][y]=0; valb[x][y]=0; } } printf("mark");getch(); return 0; }//int main 
That's what I thought. You're trying to allocate enormous static arrays, which isn't going to work. Static/global data has to fall within the lower 2GB of address space. You need to use the heap for large amounts of data.
There are two approaches. You can allocate a flat block, and access it by computing the index manually: int rows = 4000, cols = 100000; float *foo = malloc(rows * cols * sizeof(float)); ... foo[r * cols + c] = ...; Or you can create separate blocks for each row, which means the memory is no longer contiguous (which is a performance drawback) but you can retain the familiar array syntax: float **foo = malloc(rows * sizeof(float *)); for(int r = 0; r &lt; rows; r++) foo[r] = malloc(cols * sizeof(float)); ... foo[r][c] = ...; If you're curious why your version doesn't work, it's because symbols that are known at compile time are addressed using RIP-relative address mode. This is more efficient, because it results in a relocation that encodes the address of the symbol in the opcode as a 32 bit offset relative to the current instruction. However, this means that symbols can only be addressed if they're within +- 2GB of the current instruction. The alternative would be to use a full 64 bit absolute reloc, but that is a different opcode encoding and it is only available in a few forms, so this results in an extra instruction required, so it's generally avoided. This decision to choose a more efficient addressing mode is sometimes called the memory model, and they are given names like small, medium, large. On linux at least you can choose which model you want to use, trading off that performance loss for the ability to have large statics. I don't think this choice is possible on Windows. I don't know if it's because the required reloc types are not supported, or whether the tools just don't support it. It should be possible in theory, but most of the time you're better off just using dynamic allocation instead. 
It is, but there are severe limitations to the way that objectorientedness works in the Linux kernel. That's because there isn't a demand for the full feature set of classical OOP. I totally agree with you that OOP is by no means some kind of guarantee that your app will be well-designed. Often, OOP lures people into thinking that OOP is *the* only good way to design an application, when it really only applies well in a handful of common use cases.
I'm guessing this is outside of a function. When you assign a value to a variable outside of a function, that value needs to be known at compile time because it's actually written to a section of the executable. The time function returns the system time, which is only known at runtime. Try moving the assignment into a function.
Programmer happiness goes up when everyone is forced to adopt the same style :) More seriously, what's so laborious about using StudlyCaps?
Bad article. The useful aspects of OOP in C are not this difficult or verbose.
StudlyCaps have their place. Personally I find the use in Go-lang causes me grief because it's not so easy to scan for types mixed in amongst method calls. I'm talking strictly about StudlyCaps here for method names __and__ types. I was not intending to debate the use of camelCaps (lower case first letter) versus underscores for method names. I do wish I knew of a published study on (Studly|camel)Caps but I don't so here is my subjective list of complaints just for fun :) * They are hard to read for native English. English readers comprehend a lot of word shapes, when words don't have clear separation it forces you to re-read slowing down comprehension. * They are even harder to read for non-native or strong English readers I'm told. * Capitalization changes the meaning of some words (March, march) and flat out cannot be written in others like German (I think) where the sharp S already looks capitalized, 'FußPfund'. * You run into issues with multiple abbreviations and acronyms where you have to fall back to underscores or only capitalizing the first letter. SSHURI, SSH_URI, SshUri... each language seems to have multiple 'solutions' none elegant and often conflict with other conventions (constants). * Applications cannot always correctly generate mixed case names (e.g. meta programming) as some case conversion does not map one to one (German), round trip (German) or rely on locale settings (Turkish). edit: I follow language conventions even ones I don't like just so we are clear :)
Surprise the crap out of your teacher and use mmap()
That is amazingly helpful. Thanks a lot! 
Thanks! I've forwarded the link to the kids and have asked them to read it over. They will comment and probably ask for more information, but their questions will be much more informed.
If you're going for lex/yacc, you could look at [Writing Your Own Toy Compiler Using Flex, Bison and LLVM](http://gnuu.org/2009/09/18/writing-your-own-toy-compiler/). I used this for reference a while back, though my target was not LLVM but a custom virtual machine made by my professor (and generating the code was very easy). There may be some fairly advanced stuff in there, but the tutorial quite complete, and I found its sections on flex and bison very useful on their own. However, I think lex/yacc may add a bit too much overhead, while not providing that much insight without the theoretical stuff (like in the Dragon book). And since it sounds like the kids are already quite familiar with programming in C, I would simply suggest giving them a series of projects like: * A [recursive descent parser](http://en.wikipedia.org/wiki/Recursive_descent_parser) and evaluator for simple arithmetic expressions with infix/prefix/postfix notation (basically, a calculator). * Extend the calculator with variables and functions. * Write a very simple lisp interpreter * Write a regular expression matcher (for some simple notion of a regular expression). I.e., have them implement `grep`. These exercises are all quite easy and fun in just plain C, and should give them very good insight into the basic problems that arise in practice.
Just FYI: The Dragon Book is partially superceded by the Tiger Book: "Modern Compiler Implementation in C". http://www.cs.princeton.edu/~appel/modern/c/ Still fairly advanced.
learn about floats and equality tests, also printf formatting. and your for-loop doesn't do any testing of results. 
True, and that would be the way I would do it, but I doubt he knows about that sort of thing yet. It's neat though. 
you are over thinking this. remember that c always rounds down ;) http://pastebin.com/LCrBZfFN
the answer is 7744 btw
Only in C99 (it may also do it in C++, I'm not sure). Previous versions of C would invoke undefined behaviour.
thank you so much! one question: where did you get int base=31 from?
Thanks! It was very helpful
i just tried to figure out what the lowest number that gives a four digit square is. 30^2=900, so 31 is close. i'm pretty sure that it is actually 32 though. try running it from zero, it still works
thanks for explaining. zero works too but i get 0 &amp;7744 when i compile it
You're never returning anything from `memo()` in the n &gt; 1 case. You calculate the value, and store it in `saved[]`, and then just drop off the end of the function. This shouldn't even compile. You need to return something in every case: the n &lt;= 1 case, the case where the answer hasn't been computed yet, and the case where a previously computed answer for this n already exists. 
Firstly, ITYM **s**scanf to parse a string. Secondly, there is overhead in sscanf which is pointless. Each time you call it, it will scan the format string, parse it and determine what you want. If, as you point out, you know ahead of time you want an int, why make the computer discover that at runtime when you can tell it at compile time? Finally, depending on your architecture and ABI, it may be slower to return a value by writing to a pointer passed as an argument than simply returning an int from a function. The former involves a write/read to/from memory while the latter can be done via a register.
Just a few days ago I announced [my latest compiler textbook](http://www.t3x.org/reload/), Practical Compiler Construction, [over there](http://www.reddit.com/r/programming/comments/qxk00/my_latest_book_practical_compiler_construction_by/) in the programming reddit. It is basically a tour through a simple C compiler that is written in C and compiles to 386 assembly. No prior knowledge in the field of compilers is necessary to read (and understand) the book. Recursive descent parsing is discussed thoroughly and then converted into a more efficient approach that avoids implicit recursion. Of course, lexical analysis, semantic analysis, code generation, optimization, runtime support, etc. are also covered. See the homepage (link above) for details.
I played Doom yesterday. And yes, the game logic (in the original code) it's 2D, but the game render a 3D view of it. A proof of it, is that you can't stay below of a cacodemon or a lost soul, plus that you can't have rooms in the same x-y place and different z coordinates. And the map editor is 2D. I remember when FPS games was called "Doom type games". And like Scotty said one time. "How many times do I have to tell you? The right tool for the right job."
Why need use ProperEnglish() function
Cool, just ordered the book!
It's the one. Great introduction to the language and to middle to low level programming in general.
Does it ever go over creation of applets/windows? Or is it all computational via CLI?
Cool, I actually bought the second revision with I think was written in the late 1990s. I actually pirated a copy since I had already ordered the physical book, it's very interesting! Also [related](http://xkcd.com/806/) to the word "shibbeoleths" (I couldn't help myself :)&lt;- And [again](http://xkcd.com/541/). 
I was just amazed I spelled it right.
I actually didn't know that shibboleet had a meaning until you said shibboleth and I looked it up! Also, with Google Chrome it's impossible to spell something wrong, saved me from the grammar/spelling police on Reddit more times than I could count.
I personally waded through [the GNU C Programming tutorial](http://crasseux.com/books/ctutorial/) after being on and off with C over the years. It has helped tremendously. Then I picked up K&amp;R, and it has helped, too.
 void main() { void *ptr = 0x41414141; void (*func)() = (void (*)())ptr; func(); } You can cast a void* to a function pointer like that. This type of thing is actually very common in WIN32 but the assumption is that you know the prototype. I'm not completely sure that I understand your goal here. Can you guarantee calling convention on these functions?
Casting the address to a desired function pointer type would pretty much be the way to do this, although typedefs make function pointers much easier to deal with. Instead of void (*func)() = (void (*)())ptr; you can do something like: typedef void (*fptrVoidNoArgs)(); fptrVoidNoArgs func = (fptrVoidNoArgs)ptr; It really helps especially when casting, as it eliminates the tons of extra parens, and it's useful if you have plenty of pointers of that same type. On a side note, a fun way to call a Windows-styled "thiscall" (non-static member, passes "this" in ECX register) function that you may have the address of is to declare the function pointer type as "fastcall" (passes first 2 parameters in ECX and EDX). Imagine a member function that takes an int and returns an int: typedef int (__fastcall *funcMFPIntInt)(void* thisptr, int dummy, int arg0); funcMFPIntInt func = (funcMFPIntInt)ptr; int x = func(someObjectPtr, 0, 1); The "dummy" parameter (the 0 in the call) can really be anything since it's passed in EDX and the function doesn't care about what is in EDX, it's only looking for the "this" pointer passed in ECX. There are better ways to handle this in C++ (converting the function pointer into a MFP of some generic class, casting the known object pointer to a pointer of that generic class, and calling the function pointer as one would normally do in C++), but this works in C without the need for inline asm. On a final note, GCC and its ilk handle "this" pointers as a hidden first parameter, but that is also how large return types (usually larger than 2 registers) are handled (in pretty much all compilers), and I forget the order used when there is a large return type for a thiscall function, so you really need to check the disasm of the target function to figure out how to write your function pointer type.
Hey. The issue is that a cast has to happen at compile time. I only have the information about the type of the function at run-time - so I literally can't write the cast signature. Basically I have a struct like this: typedef struct { void* func; int ret_size; int arg_sizes[10]; int num_args; } func_info; And I also have a way to get the actual data for each of the arguments. But from this (and not knowing the exact type the function pointer points to) can I still call the function some how with those arguments.
Awesome. I just wanted to make sure that my code wasn't breaking at an assignment with different types. I am not printing the numbers out, but rather am assigning chars in order to use my memory better. I don't want to have a ton of zeros taking up space and instruction cycles as I'm running on an 8-bit platform.
So if the 16-bit number is over 0xFF I may in fact just get 0x00 in the 8-bit value or junk even?
Simple answer: Yes, you will get junk
You should also use either signed/unsigned char or (better) uint8_t/int8_t from stdint.h.
And [the solution](https://gist.github.com/2365372).
I think the "bonus" solution is impossible. A Computer Scientist can provide the formal answer. I'm not there yet. Nonetheless... Fundamentally, cpp would have to define a valid C token as false (or '0' as it may be) when that token is /CONFIG_[A-Z0-9_]+/ iff it was not #defined in the first place. Yet, cpp syntax is deliberately at odds with C statement syntax. One can't write `if (#ifdef CONFIG_PROC)' because cpp won't bother rewritting CONFIG_PROC into a boolean expression. It merely passes the text on to cc which barfs on the "#". It's like sed without backreferences, but also like C without statements. Note that there are suprising things cpp can do. I've found a macro that can evaluate to its airity which seems counter-intuitive, but I don't think this one is possible.
Well shut my mouth. That looks like the real deal. Once I've slept and sobered up I'll give you a standing ovation because I really thought this one was impossible. Wait, no. That's too far away. Comma operator. Awesome!
I see it. It's great!
Reported ಠ_ಠ
Since you said that you keep those structs in an array, this line &gt; func_entry new_fe; looks suspicious to me. You're allocating the new data on the stack, which will be free'd once it goes out of scope. Edit: Just in case you don't know how to allocate a struct on the heap (I didn't until a few days ago): char *space = malloc(sizeof(func_entry) + length + 1); func_entry* entry = (func_entry*) space; assert(space != 0); /* Initialize ... */
Because the returned fe is the same I think it is probably okay but I've posted anyway. The suspicion that something deeper is wrong comes to me from the fact that fe-&gt;name is different sizes when printed between the functions.
My guess is new_fe is in the initializer function's stack when you add it to the func_entries[] array. So it gets reclaimed when that function exits. The second function accesses the same stack address, but its contents are now completely different. Try to allocate new_fe on the heap using a func_entry pointer. See if that preserves things better. Your small example might work because the stack was not overwritten.
If I had to guess, I would say that you are overflowing a buffer somewhere and overwriting the value of the name pointer -- notice that the new pointer value is all ASCII (the hex translates to "noteleks"). Perhaps the arg_types buffer in the structure; although, I can't be sure without seeing the context. EDIT - After having re-looked at your example and the other comments, it is likely that the problem is you are allocating the structure on the stack, and then this stack structure is getting overwritten when you return and then call another function. You're better-off allocating the data on the heap with malloc or similar.
Perhaps. Though this overflow would have to have happened between when I put it into the hashtable and after I take it out... I'll take a deeper look at this. Perhaps I can dump the hex of the struct and see what else of it - if any - is different.
Try it yourself: #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; typedef struct { int x; int y; } pair; static pair* pairs; void setup() { pair p1 = {1,2}; pair p2 = {3,4}; pair p3 = {5,6}; pairs[0] = p1; pairs[1] = p2; pairs[2] = p3; } int main() { pairs = calloc(sizeof(pair), 3); setup(); for(int i = 0; i &lt; 3; i++) { pair p = pairs[i]; printf("(%i, %i)\n", p.x, p.y); } free(pairs); }
Thanks, this helps. I'll see what happens if I run it through valgrind etc.
The `%p` specifier always prints out the pointer value in an implementation-defined manner, so two compilers can produce a program that prints pointers in two entirely different ways and still be valid, conforming C compilers.
That is one option but then it limits the number of function entries. See the code I posted to jazzyb for the basic layout I have.
Theoretically speaking... what happens if realloc() moves your func_entries because it grew too large? Doesn't that invalidate all your data in your hash? I think you need to check the return code of realloc and compare it to what it used to be. If there's a mismatch, you need to rehash. Or just do what I did [512] ;)
Yeah, this is what I believe it happening. Changed it to an array of ** so that the reallocation wouldn't invalidate the hash. Getting another cryptic memory error now but I'll have to investigate more.
I don't quite know how the ** will prevent from invalidating the hash but I would store the base_address somewhere and store the rest of the pointers as relative addresses to the base. Then you can update the base as it changes. edit: assuming the struct is aligned properly... proceed with caution!
Ah I see what you mean now. Yes, I actually was going to ask you if you needed that array for anything (like indexed access for whatever reason). Since you have the hash, there's really no need for the array. Good luck!
Thanks for the help everyone. It really is appreciated. Turns out the reallocation was causing troubles. I also had a *really* horrible memory bug somewhere else in the code which was writing to memory left right and center. Which didn't help the issue. But managed to spot that too :)
No, they've got nothing to do with stdin, because you aren't redirecting anything here. (Redirection requires using shell tokens like &lt;, &gt;, |, etc.) They are simply strings that will appear in the argv[] array that's passed to your main(). 
the integers will also show up in argv[]? can I do something along the lines of "int value = (int)argv[1];" to use it as an int?
The other way of reading complex declarations is using a spiral drawing, starting from the inside of the deepest part of the declaration (\*p)(int), start at 'p', draw a spiral in anti-clockwise fashion, until you hit '\*', p is pointer, continue on from there until you hit 'int', notice its wrapped in parenthesis so its a function pointer to 'int', then continue on, until you hit '\*', p is a function pointer to 'int', returning a function pointer with a parameter...continue on until you hit the parameters, which makes it p a function pointer to 'int', returning a function pointer with parameter types of double pointer and char type, continue on until you hit another '\*' and that's a pointer, continue again in anti-clockwise fashion until you hit double, and there you have it, p is a function pointer to int, returning a function pointer with parameters(double and char) returning back a pointer to double. And there you have it, **phew**
Glad you recognize it, its quite a old technique that has drifted beyond the mist of time - BTW, I think, you should do it in real life, eff 'em who thinks you're drawing doodles, its for **your** understanding, and maybe, if you showed them, you'll get instant respect. I'd be quiet horrified at the attitude of 'find the author and punch them in the face' ([linky](http://c-faq.com/decl/spiral.anderson.html)) if you want to dig deeper - I recommend the book 'Expert C Programming by Peter Van der Linden' in which he comes up with an exercise in recognizing this sort of complex declarations plus you will come out with a more deeper understanding of C :) **Edit:** BTW it sounds like you're co-worker/instructor is trolling you guys and getting a kick out of it when he saw your faces going 'WTF is that declaration' cue brain-farts... well you can put this back on him, this expression **3[a] = 'c';** and ask him if that's legitimate or not :D
A deeper understanding of C is always useful. I still come across things that are like voodoo. I may have to try and locate this book.
No, sorry. It's not the 'doodling' that I would never do, or punch someone in the face for. Rather it's the act of writing such a declaration in real code that I would never do, and would be unhappy with the author of IRL. I think the 'doodling' idea is superb and will be bringing it up to my lab next week. It could be a troll, but not by my co-worker. It was in the slides that he was given as course material to teach so it could be a troll by the previous instructor of the class. I will bring up the above expression and see if he can figure it out. BTW, he's not **my** instructor, just happens to sit beside me in our lab so we were discussing this declaration when he found it in the slides he was supposed to use for the class.
This is pretty useful, thanks!
Linux kernel style is slightly different from BSD-KNF. Most notably, the return types of functions are on the same line as the rest of the function declaration: static io_context *get_task_io_context(struct task_struct *task, gfp_t gfp_flags, int node) { ... BSD-KNF: static void aml_store_to_fieldname(struct aml_environ *env, union aml_object *obj, struct aml_name *name) { ...
Your submissions *[website title is interesting](http://i.imgur.com/NizgL.jpg)*
If it does turn out to be a problem of multiple definition, a common way of fixing it is doing something like #ifdef GLOBALS_HERE #define GLOBAL #else #define GLOBAL extern #endif GLOBAL int x; That way the globals are declared in every file except for the one source file in which you define GLOBALS_HERE or whatever other identifier you care to use.
How do you know that this is the cause of christofjw's problems?
&gt; Most likely They don't. But they are stating this as a prior.
I don't know for certain, but in my experience it is the most likely reason. 
The -L and -l options relate only to the .a static library. The search path for header files is controlled via the -I option. It looks like libEngiFunc.a, EngiFunc.h and Driver.c all live in the same directory which makes me think you've used #include &lt;EngiFunc.h&gt; in Driver.c as opposed to #include "EngiFunc.h" but you know that already having carefully read the fine gcc manual [1,2]. [1] http://gcc.gnu.org/onlinedocs/gcc-4.4.2/gcc/Preprocessor-Options.html#Preprocessor-Options [2] http://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html As stated, a difference between #include &lt;...&gt; and #include "..." is that the latter by default has the directory containing the .c file in the search path whereas the former doesn't.
You need to either copy the header file to where you are compiling, or add the path to the header file to the compilation command line. Compiled libraries are ( generally ) only object/ binary files and do not include the headers. 
Ok, I think you've helped me. I did not create a header file. My professor's instructions lead me to believe that the "header file" you need to include in the driver was just the name of the library without the "lib" and with a .h extension. Do I actually need to create a header file to allow the driver to link to the library?
That's always it. The one little thing I forgot to do.
your strtoupper() function is broken, as noted. some c library implementations have strcasecmp() which is effectively the same as what you've implemented with strequ(). I don't think your use of scanf() and *buffer is safe. I think you need to set a field width for the string, so %31s. you earn extra points for using gdb.
What the heck is this? If you want challange, why don't you build a full-functional calculator with graphing and advanced trigonometry funcionalities on Python instead of a simple one in C?
If you have "some knowledge" of C++, then you're part-way there anyway. Just keep writing. That's the only tip I can give.
I think you might want to review how scope works. I'm passing the location of the buffer as the argument, not the location of the pointer.
Actually, it would return false. I know you can't modify string literals; that's why I wrote strequ as (!strcmp(touppercase(x), y)). y (the string literal) is never changed.
What is this that you think can't be done in Python?
using scanf is a nice way of getting buffer overflow and is not the recomended approach. I was not talking about scope, what happens if you enter 50 characters? Had to downvote you for not reading between the lines in my reply to your post!
No worries there mate, there's [gnu bc](http://www.gnu.org/software/bc/) which might be of use to you. Have phun :)
I think he's referring to this: &gt;[…] but what I really want to do eventually can't be done in Python.
Thank you!!
You should always read the man page of the library functions you're using. There's lots of useful information in there. For example, the manpage for strcmp(3) has; SEE ALSO bcmp(3), memcmp(3), strcasecmp(3), strcoll(3), strxfrm(3), wcscmp(3) useful stuff :)
I don't see why K&amp;R, or their estates, shouldn't get paid for K&amp;R's work. Disney has nothing to do with this.
They've already been paid for it for over the last 34 years. If you personally think it hasn't been enough, feel free to mail them a check, of course. I'll unremorsefully stick with the free copy myself. Do you also get upset at the Gutenberg Project for giving out free copies of Sherlock Holmes without paying the Doyle estate? Also, [Mickey Mouse Protection Act](http://en.wikipedia.org/wiki/Copyright_Term_Extension_Act). 
Is this even all that relevant anymore? Isn't K&amp;R riddled with examples that don't even compile, poor style, and pedegogical worship? Don't we have *standards* now? As a historic footnote, sure, it might be interesting, but C is a living, breathing, evolving language, and there are decades of accumulated knowledge about using it that won't be represented in studying a 24 year outmodded manual as though it were some sort of infalliable *bible*. Am I wrong? No, really, I'm not trolling, I'm asking.
Uhhh, no. I mean *authors*. Plural. Both Kerninghan *and* Ritchie.
Ok, ok, I'll say what at least a few other people are thinking, too: TIL how `const` works. I've never really made use of it, so I never knew. 
I'm kinda busy now, but % may help you set up turns. If (turn%2==1) it is p1's turn; Else it is p2's turn; If (turn==9 &amp;&amp; nobody won) printf("Tie"); As far as code for winning, you will probably need a lot of if statements for each possible win combination.
For checking if complete it might be simpler to break it down into a couple of functions: checkRow, checkColumn, checkDiagonals. For instance, an implementation of the checkRow function, which checks a given row, might look like this: bool checkRow(int row, int* board) { int rowOffset = row*3; return (board[rowOffset] != 0 &amp;&amp; board[rowOffset] == board[rowOffset+1] &amp;&amp; board[rowOffset] == board[rowOffset+2]); } Calling checkRow(0, gameBoard); returns true if someone has won on the first row. However, it doesn't tell who did win =P Note that usage of bool requires #include &lt;stdbool.h&gt;
Unless you do it the fun way const int winning_combinations[8][3] = { { 0, 1, 2, }, { 3, 4, 5, }, { 6, 7, 8, }, { 0, 3, 6, }, { 1, 4, 7, }, { 2, 5, 8, }, { 0, 4, 8, }, { 2, 4, 6, }, }; for( int combo = 0; combo &lt; 8; combo++ ) { things with board[ winning_combinations[combo][0 thru 2] ]; }
Direct link: http://cconf.org
It *is* your place to decide. Don't just go with whatever Disney And Ilk says. I don't want to turn this into this discussion, but definitely take time to ask yourself, "What is the optimum length of time for copyright protection?" If you come up with exactly what we have today, I'll be mighty surprised.
I am writing an AI for a card game, Magic: The Gathering. I am focusing on writing a [Game Tree](http://en.wikipedia.org/wiki/Game_tree). A directed graph where nodes are game states (the memory) and edges are moves. Using a memory model with snapshot control, I can create a temporary node by creating a snapshot, explore the consequences of one or more moves, and go back to the original node (state). I explored the possibility of using mmap with MAP_PRIVATE and fork but I did not want to be dependent on *nix extensions. Can transactional memory do this? start a transaction, do a bunch of things (even starting new transactions) and end it. EDIT: Happy cake day!
Of course! I forgot that in older C versions you can only declare variables at the start of a block. That seems to be precisely why it's done in the GEGL hello world, to keep it ANSI C. Solved, thanks!
&gt; (I have heard that the value of a block is the value of the last statement in it, but I've never seen or written any code which uses that peculiarity) There's no such thing in standard C as the "value of a block". Blocks are in standard jargon "compound statements" and statements have no value per se. What you say is true, however, of statement-expressions in GNU C. 
I also use the blocks even without local variables, just to separate part of the code. For example, when I have a portion of a function that calculates a variable, I write: int myVar; { foo(); ... if (bar()) myVar = something; else myVar = somethingElse; }
Some additions to the standard library would be nice. A regex.h, for example, would be good to have.
[Relevant](http://stackoverflow.com/questions/3259761/why-isnt-regular-expressions-part-of-iso-c99)
Ahh, thank you, i've never used used the code formatting on reddit before.
Consider: multComplex = multwoComplexNumbers( numberchoice_first, numberchoice_second); printf("\n Multiplication of the two complex numers is: %f %f \n", c.real, c.imag ); You're assigning the result to the variable 'multComplex' but trying to print the value of the variable 'c' (which, AFAICT, is never initialised to anything, hence the garbage output). Either a) assign to c or b) print out the value of multComplex. Also, is it by design that you only have two chances to input a correct choice on the menu or is it because you've not covered do { } while loops in your classes yet? **Edit:** Corrected version: https://gist.github.com/2719411/faa0c21f2a3cc17fb702ac54574c61782049bd58 . I've also corrected the missing '.real' at line 39. There are still a few stylistic issues which will only come with experience, but now it works as advertised. **Edit 2:** Also, exit(3) requires stdlib.h to be #include-ed as well...
 c = /* whatever */; is the usual way of assigning a value. My corrected version went down the other path of just removing the redundant *c* variable. E.g. my lines 48-51: diffComplex = subTwoComplexNumbers (numberchoice_first, numberchoice_second); printf ("\n Difference of the two complex numbers is: %f %f \n", diffComplex.real, diffComplex.imag); become c = subTwoComplexNumbers (numberchoice_first, numberchoice_second); printf ("\n Difference of the two complex numbers is: %f %f \n", c.real, c.imag); Similarly for 37-39 and 59-62. Then replace line 24 with simply: complex c; Except don't do that because single letter variable names are considered harmful. **Edit:** I accidentally a semi-colon. Isn't it always the way?
Hey, no problem :) and good luck. Well, ```-std=c99``` enables the new C standard instead of the default C89, ```-Wall``` enables all recommended compiler warnings and ```-pedantic``` adds some more (even missing end-of-lines actually :)). You should usually fix all the warnings for your programs, unless you really know better (no, no you don't ;)). Also, if you have trouble understanding some of the warnings, you could give ```clang``` a try (another C compiler, works as a drop-in replacement for gcc), their errors and warnings are usually much simpler to understand.
Real men use -Werror ;&gt;.
Some more flags I strongly recommend: -Werror Use this one. Don't stop to think, just add it to your build and always use it. You *want* warnings, and you want them to go away. -Wextra This one may make you cry at first (particularly in combination with `-Werror`), but keep with it. By the way, when writing C, it's not great style to use `typedef`. The alternative is *slightly* more verbose, but once you're used to it it's clear: struct complex { float real; float imag; }; struct complex inputComplexNumbers_first(void); and so on. Your code gets peppered with `struct` keywords, which is a little irritating, but in the end it makes things clearer. Oh, and one last point. If your function doesn't take any arguments, declare it as `result_type function_name(void)` not `result_type function_name()`. Due to unfortunate archaism the latter means "don't type check me"!
Alright here's your problem. You can only have **1** return value. Therefore: return p, n, d, q; Is invalid. Your function is returning 1 int. 
Also, the problem OP is getting with compiling (the conflicting types) is due to the name of his function, "remove()". [Remove() is a part of stdio](http://www.codecogs.com/reference/computing/c/stdio.h/remove.php). Rename the function to solve that conflict.
There really should be if statements to take care of that, but I heard the prof is sort of nitpicky about the code. And I fear adding in more than what he wanted would lower my grade.
If you indent your code by about five spaces from the left when you put it into reddit, you will retain your layout; #include &lt;stdio.h&gt; int insert(int p, int n, int d, int q); float dollars(); int remove(int p, int n, int d, int q); int display(); int pennies = 0; int nickels = 0; int dimes = 0; int quarters = 0; int p, n, d, q; float x; int main() { insert(p, n, d, q); x = dollars(); display(); remove(p, n, d, q); x = dollars(); display(); return 0; } 
The comments are pretty comprehensive. This is an efficiency optimization, since it reads and processes 32 bits at a time, and the memory architecture this targets will work in 32 bit words... Your method will actually load 32 bits every iteration and give you only 8 bits from it to check...
I made a little pair of C programs to test the speed difference: https://gist.github.com/2791520 Looks like about a 12% speedup using the glibc implementation: spectre256@north ~/repos/gist-2791520 $ time ./strlen &gt; /dev/null real 0m1.387s user 0m0.988s sys 0m0.397s spectre256@north ~/repos/gist-2791520 $ time ./mystrlen &gt; /dev/null real 0m1.566s user 0m1.160s sys 0m0.401s
Google "bit twiddling hacks", or SWAR. Rob Pike has a short article too about 2's complement arithmetic and C's bitwise operators that is illuminating.
Doing things one at a time is slow; especially on modern processors whose speed is largely due to doing as many things in parellel as possible. (I.e., in this implementation there is a branch every byte. Although, I'm not entirely sure that can't be executed speculatively.)
FYI, the original DEC Alpha had byte level addressing but the load and store instructions only worked on 32-bit and 64-bit words. They hedged their bets by using byte level addressing so when it did prove to be a bad idea they were able to extend the instruction set without changing the addressing architecture. Also, many architectures targeted to the scientific community are/were entirely word oriented, leaving the packing and unpacking of characters within words entirely to software.
It's not immediately relevant but you should prefer to avoid function-like #defines, favoring inline functions. The dumb text substitution will eventually fuck you.
C const is still useful but does kind of suck.
I tried to do this in VS2005, but I've had trouble outsmarting the optimizing compiler. Thought for sure it couldn't reduce my simple strlen if I changed the terminating character to, say, 'X' -- but the time results indicate that it has managed to, anyway. Adding an extra side effect variable incremented alongside len has no effect, though adding two does have effect, so I'm not inclined to trust that, either -- in particular, I'm not sure if I'm just running out of working registers, or somesuch. (If I disable inlining, one side effect is enough to bloat the time the same as two with inlining enabled.) It's clearly not being reduced to a constant return, as looping summing a returned static var++ is just about instant. My time results (Again, what they mean? Not entirely sure): **643ms** for strlen and versions I believe to have somehow been reduced to strlen. **1863ms** for versions which I believe to have NOT been reduced to strlen, but may be suffering some other ill effects from the additional variable operations inside the loop. **1940ms** for a version with extra side effect variables incremented in the loop (5 total). **0ms** for a version which I believe to have been effectively reduced to const.
I don't really have a preference, basically something that I could work on. This is basically the stuff I know how to do in C (plus knowledge of algorithm design [greedy, dynamic, divide &amp; conquer...]): http://pine.cs.yale.edu/pinewiki/CS223/Schedule
&gt; Figured it out. I was going to delete this post but maybe it'll help some other people. &gt; In the IDE I'm using (Keil uVision) I had both my main.c and st9720lcd.c in the same project. I removed st9720lcd.c from the project and it compiles fine now. Doh Great, but that's the wrong solution. Remove the ``#include &lt;st9720lcd.c&gt;`` from ``main.c`` and put ``st9720lcd.c`` back in the project. Then Google some resources on the difference between compilation and linking. Also check that you know what ``#include`` actually does. If you understand http://en.wikipedia.org/wiki/Include_guard, you understand enough. A rule of thumb is that if you're ``#include``-ing anything other then a ``.h`` you're doing it wrong.
You can use either Pthreads or OpenMPI. I personally like pthreads the best. Fairly straightforward, although I'm not sure if the ms compilers support it. 
you can use forks and the various exec() functions, if you're familiar with system-level code
Not quite; I don't think that the overhead is worth it. I would just go with pthreads.
I presume the inner loop is computational? Have you tried psycho or PyPy? Also, I'd try re-writing the inner loop in Cython first before re-writing the whole thing in C. Getting the multiprocess functionality for free is a huge bonus. Personally, I'd profile aggressively and take small, calculated steps in order to improve performance. Why spend weeks/months re-writing the whole thing in C if you can get 80% of the speed by re-writing the inner loop in Cython in a few days.
I found this [pthread win32 port](http://sourceware.org/pthreads-win32/) and it seems to be somewhere to start. Is there any other Windows specific equivalent of pthreads?