I will check out the SSL library. I did implement the Fisher-Yates shuffle when creating a new deck, in function create_shoe. With that in mind, if any distribution biases are being integrated within my software, then that could be an issue, assuming the distribution does not even out after n-trials.
What platform is this running on?
The standard defines three valid values for main to return - 0, EXIT_SUCCESS, and EXIT_FAILURE (Which is often 1 but doesn't need to be). Anything else is implementation defined. Since you didn't mention what OS or how you're looking at the return value, it's hard to say anything about what you're seeing. I would make sure argv[1] exists and that sscanf() succeeded before trying to use x, though.
its on a Linux server being run at our college. 
Ahh I'm quite new to programming and was not aware that the OS could affect it. Its for a school project where the professor wants us to return a -1 if its not a 1 2 or 3. Before implementing the current code, i went through and made sure the sscanf was working.
Things don't even out. And people don't notice. There was an incident a while ago where a "random" number generator in a standard library in some language or system never generated odd (or even) numbers and it took people decades to spot that. Many, especially older, implementations of rand in C libraries could never generate a 0 because if the internal state of the generator became 0 (and the "random" number was just the internal state), it would permanently get stuck and keep generating zeroes forever, same thing would happen if you called srand with 0. Even CSPRNGs are not safe like when some linux distribution decided to "improve" OpenSSL and ended up with all of their users generating one out of 65536 possible keys. Gambling isn't better, like when one of the early online poker sites only had 64k different shuffles which could be predicted by the player by just seeing his cards. Or when some gang broke the algorithm for some model of slot machines and sucked millions out of Las Vegas casinos, which is apparently still happening today. When it comes to random numbers our profession suffers from massive collective stupidity. Pretty much everyone gets it wrong and good solutions are dismissed with false arguments and "everyone else does it wrong, we can't be different".
It doesn't matter what you did before; it matters what you do now. Suppose your program is run without any arguments. Or the first argument is "narf" and not a number. Now you're using x without initializing it to a value first, which is undefined behavior and potential bad things can happen.
Printf the result you are about to return and see what it gives you. Also, the person above is telling you that you should check, in runtime, that the scan successfully converted an int (what will happen to your program if I type in "dhdjfidjfk" instead of a number?)
I see. I will try to find a way to make sue argv[1] exists before using it. Thanks for the help :)
Is there a reason why a standard TRNG (True-RNG) is not implemented? I can see ISO or even the IEEE recommending a combo of hardware/software to improve randomness? But, what do I know? I could see a quantum semiconductor being made and having the next-gen C standard reference the state of each bit from said SC.
what would i use to printf? printf("the value of x is %d\n", x); was giving me the command line argument i entered, not the return value i was hoping for. Sorry, im very new to this.
The relevant information for Unix and Linux systems is buried in the documentation for the [wait()](http://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html) system call, which is what a program that runs another program uses to get its exit status. In particular, the `WEXITSTATUS` macro: &gt; WEXITSTATUS(stat_val) &gt; &gt; If the value of WIFEXITED(stat_val) is non-zero, this macro evaluates to the low-order 8 bits of the status argument that the child process passed to _exit() or exit(), or the value the child process returned from main(). -1 is represented as all bits being 1 on normal 2's complement CPUs. The low-order 8 bits all being 1in a type larger than 8 bits is 255. Whatever is testing your program is probably doing an int status = WEXITSTATUS(value); tl;dr: Returning a negative value from main() won't work with most tools that run programs and do stuff with the return value, and thus shouldn't be done. Stick to 0 to 255 for Linux and Unix.
I've been doing embedded and web backend work for many years and have never had to build or work on a linked list. It's only a teaching concept anymore.
I see. For our assignment, it asks specifically to return -1. "The function accepts a string; scans it with sscanf to try to convert it to an integer; and returns a value as follows: if the integer=1, return 1 if the integer=2, return 2 if the integer=3, return 3 in all other cases, return -1 "
Pretty sure we're in the same class and I'm in the same boat as you dude. I've tried everything I know of to get the numbers in range and the program won't take any of it. Good luck man, and throw some advice over here if you figure it out
Well, it can't be done unless it's being tested with a custom tool that is expecting a negative -1 and does something with the exit status to account for that case.
Sure, just replace the `i++` (or similar) with `i += 2`
Oh cool, didn't realise it was that simple 
Make a new variable that will hold your return value and then print that.
Okay. Let me play around with that for a bit and see if i can get it to work.
This is another function being tested via a main we cant see. Would running this function under a new main with test cases work better? Im very new to C. Thank you for all of your help by the way.
He's being taught so it seems like even in your context it is relevant. And linked lists are still provided as classes in major languages.
Post the full text of the assignment.
I made a variable Y that holds my return value, and printed that. That one is working as intended. Here is the code as well as a few test cases: ~$ test411 1 the value of Y is 1 ~$ test411 2 the value of Y is 2 ~$ test411 3 the value of Y is 3 ~$ test411 -1 the value of Y is -1 ~$ test411 haha the value of Y is -1 ~$ test411 00002 the value of Y is 2 ~$ test411 5 the value of Y is -1 ~$ cat testparse.c #include &lt;stdio.h&gt; int main(int argc,char*argv[]) { int x; int y; sscanf(argv[1],"%d",&amp;x); if (x == 1){ y=1; } if (x == 2){ y=2; } if (x == 3){ y=3; } if (x != 1 &amp;&amp; x != 2 &amp;&amp; x != 3){ y=-1; } printf("the value of Y is %d\n",y); } 
Here is the assignment text. For ODP411, you need to write a C function named parse. The prototype is: int parse(char *); The function accepts a string; scans it with sscanf to try to convert it to an integer; and returns a value as follows: if the integer=1, return 1 if the integer=2, return 2 if the integer=3, return 3 in all other cases, return -1 This means if the string is empty, if it starts with a non-digit, if it's an integer bigger than 3 or less than 1, if it has non-printabe characters, etc. then your function should return -1. Use sscanf to do the conversion. If sscanf can convert it to an integer, use that integer value and make sure it's between 1 and 3. If sscanf can't convert it to an integer, return -1. Test your program thoroughly. Then, once you are convinced that it works, assess it as follows: put your function in a file named parse.c There should not be a main function in parse.c: it should only contain your function. Note that you'll need to include stdio.h in order to use sscanf compile it with the following line: gcc -o parse parse.c /tmp/odp411main.o assess parse 
Yeah, you're not reading it right. You're supposed to write a function named parse() that takes a string as an argument and returns one of those values, not make main() do it. That makes a lot more sense.
Hmm alright. how would I go about testing it to make sure it works if i make it a function parse() instead of main()? 
Er. Terminal or compiler?
Write a test framework and then don't include that when you compile it with the provided one the assignment wants you to use when it's ready to be turned in.
You are trying to Declare an 'int' type variable where you are not allowed for any declaration. You are missing either ';' or '{}' it may be a reason of the above error... or something very similar. 
Okay. One more question if you dont mind. How would i call the return value i get from the parse function? for example, in the test framework, say i want to see if what parse returned, i run 1, 2, 3, 5 ,-5, "test", " 5" , and 0005 through it. How would i call on the return value parse gives me?
Erm I use codio so I think it's the compiler 
What statement is required? I use the variables later on within the function but I also get the error message that they're undefined when I try to compile too. 
Can you please put four blanks in front of every line of code so the code is readable?
For one thing, your 3rd and last for loop has &lt; 6 as guard. This might cause your second error.
Have done
In C, writing `0 &lt; coldtemp &lt; 80` is the same thing as `(0 &lt; coldtemp) &lt; 80`, which isn't what you want; you have to write it as `0 &lt; coldtemp &amp;&amp; coldtemp &lt; 80`. I'm assuming that the `else if (coldtemp &lt; 0, coldtemp &gt; 80)` means that you want to check if `coldtemp &lt; 0` or `coldtemp &gt; 80`. If so, then you need to write `else if (coldtemp &lt; 0 || coldtemp &gt; 80)` (also, you probably want to just replace the whole thing with `else`, assuming that 0 and 80 are invalid temperatures as well). The same thing applies to the other two `if` statements; any time you want to check for X AND Y you should write `X &amp;&amp; Y`, and any time you want to check for X OR Y you should write `X || Y`.
Nope, it will just partially fills the buffer. Try a file composed of exactly 5000 \n, you code will find 8192 of them (or 8184, if you didn’t correct your code)
Where is the brace that ends the function? Is this the only code in your file? It might be useful to post all the code in your file because I believe that the error is caused by something before this code snippet.
Take a look at the variables you're using in the second and third `for` loops of `victory`. In particular, you're using `row` as the index variable of the second loop, but you're not using it anywhere inside the loop itself.
It's quite a long code but ok
There's a bit more than that but they're mostly tests that was put in by my course teachers 
Did you have a specific question?
I get the following errors when compiling your code: * The line `return Right` misses a semicolon * You write `if (a + b = c || a + c = b || b + c = a)`; that's wrong. In C, you compare values with `==`, a single `=` is used for assignment only. * in the function `triangle`, you call `valid(n, sa)` but there is no variable `n` defined in this function. * In all your calls `digit(sa)` etc. you call `digit` with a string as an argument but `digit` wants a character. Perhaps you want `digit(sa[0])` to call `digit` on the first character of `sa`. I think the first error causes the compiler error you have, try to fix it and see if the other errors pop up. You should fix these, too.
Just for completeness, there are actually 3, with the 3rd being: int main(int argc, char** argv, char** envp)
Ya how to build the rest of the program. I tried using arrays but that didn’t work I don’t know what else to do
Thank you very much for the detailed reply! I only get an error message now for the function valid that 'control reaches end of non-void function'. I didn't change anything in digit if that's the problem? Digit is meant to look through the input given and check if all of the characters are digits, so if they typed 3a4, wouldn't digit(sa[0]) return as true?
In `triangle`, what do you think is returned if none of the conditionals apply? That's what the compiler is warning about. `digit` is defined to check a single character. If you want to check all characters, you need to write a loop and manually check each character. You could simply change `digit` to do that instead.
Wouldn't embedded naturally avoid heap allocation?
Well those are the only options of triangles so there isn't really another option I could give it, I could use an else statement to return illegal if all other ifs don't apply?
Yeah, that's possible. Note that in the way you ordered your conditionals, `Flat`, `Impossible`, and `Illegal` cannot possibly be returned because `Scalene` must be taken if `Isosceles` wasn't taken.
I'm in your class and I'm lost too at the exact same part. I have no idea what to do past opening the file and I've been struggling to find a solution all weekend. The module examples on the site don't go over how to play with file data like this
Is it just me or is our professor the worst at explaining things? Ya I’m at the same place as you I don’t know what to do after opening the file.
Yeah this seems to be the next hurdle, I'll give it a bit of a think.
I'll try and put it in a different order, but that'll mean I'll need to look over the valid function
I'm 90 percent sure we are supposed to use a for loop to determine which numbers from the txt file will be calculated and displayed as the final percent of days in range. I just can't figure out how to exactly put that into code. If you figure it out please message me or something. I'll do the same if I get it
&gt; return Right Missing a semicolon on your return statement.
Ya I’m pretty sure you use a for loop. I know how to calculate it in my head. You just count how many of the temperature is in the range of the coldest and hottest temperature and divide it by the header. I just don’t know how to put that in code. 
Ya I’m pretty sure you use a for loop. I know how to calculate it in my head. You just count how many of the temperature is in the range of the coldest and hottest temperature and divide it by the header. I just don’t know how to put that in code. 
Do you know if we have to use arrays?
No. Arrays are for the next project. This project can be done without them
Okay I guess that narrows it down a bit lol
I'm sure there are a lot of different ways you could do this, and I'm sure someone with more C experience could point you towards a better one. But one thing you might look at it using `fgetc` on your file pointer to get individual characters from your file and then parse them. This seems like a pretty naive approach but would probably work; you could use an outer while loop, `while ((ch = fgetc(ifp)))` to iterate over the entire input file, and inside that you would need to first get the header number for the number of days of weather data per month, then use that number to determine how many days of temperature you need to parse. You can use an `if` statement to check if the `ch` you get from the file is a space, in which case you know you're moving on to the next day's temperature. For each month you'll have to compare every day's temperature to the range the user inputs, and count it towards the total number of days of data you have. Then use that to determine the percentage. As I said, this is an off-the-cuff naive solution and I'm in no way a C expert, but that's at least how I would start out trying to solve the problem.
What does "\n" do in printf?
Inside the FS function, change the printf to print first the 'i' and then the 'y'. Something like this: printf("%d %d", i, y);
New line character.
https://m.imgur.com/t/reaction_gif/CHn6z8T
nothing i removed it
That sounds super confusing lol is there any way you can write it out like how you would in code?
thank you man this helped out :)
And what would happen if he removed some of them?
use something like: fscanf( filepointer, "%d", &amp;numberOfElemsInMonth ); and loops 
Hey, please don't delete your post after receiving an answer. That's really shitty! How are future readers supposed to get help from this post, too, if you deleted it? You are doing this community a disservice with this sort of behaviour.
you can use: fscanf (ofp, "%d", &amp;SomeNumber); like you use scanf just with different files as input.
You have your main function definition: `int main(into argc, char **argv)` argc is the argument count and argv is a array of pointers, which point to strings. To pass those parameters to your function you would do it as with any other parameter. `yourfunction(argc, argv);`
Ah sorry, I wasn't really sure what I was meant to do when it was answered, I won't do it again. 
I mean, no, I'm not going to do your assignment for you. Look up how `fgetc` works, or try `fscanf`like u/staticrain2 suggests. Write a really small test case to figure out how you'd do it in a larger case like your assignment. Ask your teacher for help too! That's what they're there for.
 &gt; `int convert(int n, char c[])` &gt; `int collatz(int n , char number[])` Why did you declare your functions to take two arguments? You don't seem to use the first argument, `n`. 
Well, you're returning something when your main function is a void. Usually IDEs do not expect void functions to return anything. I would delete "return (0);". Check if it works.
I'm not really sure to be honest, I took some stuff from a program written for us by my course teachers and it had int n in it. 
I still get similar error messages after removing them though.
Thank you for your cooperation. Just don't delete your post next time. It's fine to delete before you got a comprehensive answer, but please don't do so afterwards.
Can you post them?
You have to check that the number of arguments in the function calls matches the number of arguments in the declarations.
This should do it if I understood the assignment correctly. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int is_temp_in_range(double temp, int min, int max); int is_temp_in_range(double temp, int min, int max) { if(temp &lt; min){ return 0; } if(temp &gt; max){ return 0; } return 1; } int main() { int cold; int hot; char filename[30]; int temps_available; int temps_in_range; int month; int best_month; double percent_in_range; double max_percent_in_range; double temp; temps_available = 0; temp = 0.0; month = 1; best_month = 1; printf("Tell me about your crew's preferred temperature for sailing:\n"); printf("What is the coldest temperature they can sail in?\n"); scanf("%d", &amp;cold); printf("What is the hottest temperature they can sail in?\n"); scanf("%d", &amp;hot); printf("Please enter the name of the weather data file:\n"); scanf("%s", filename); FILE *fp; fp = fopen(filename, "r"); if (fp == NULL){ fprintf(stderr, "Failed to open file!\n"); exit(EXIT_FAILURE); } /* First read the number of avaiable data points into temps_available */ while(fscanf(fp, "%d", &amp;temps_available) != EOF){ temps_in_range = 0; /* Now read each temperature into a float, check if it is in range, if it is increment counter */ for (int i=0; i&lt;temps_available; i++){ fscanf(fp, "%lf", &amp;temp); if(is_temp_in_range(temp, cold, hot)){ temps_in_range++; } } /* Calculate the percent of days in the current month where the temperature is in range */ percent_in_range = ((float)temps_in_range/temps_available * 100); if(percent_in_range &gt; max_percent_in_range){ max_percent_in_range = percent_in_range; best_month = month; } printf("Month %d: %.1lf percent of days in range.\n", month, percent_in_range); month++; } printf("\nYou should leave for the Caribbean in month %d!", best_month); exit(EXIT_SUCCESS); } Compiled with gcc. Output: ❯ ./temp Tell me about your crew's preferred temperature for sailing: What is the coldest temperature they can sail in? 60 What is the hottest temperature they can sail in? 80 Please enter the name of the weather data file: input.txt Month 1: 93.3 percent of days in range. Month 2: 20.0 percent of days in range. Month 3: 58.1 percent of days in range. Month 4: 100.0 percent of days in range. Month 5: 100.0 percent of days in range. Month 6: 50.0 percent of days in range. Month 7: 64.5 percent of days in range. Month 8: 9.7 percent of days in range. Month 9: 60.0 percent of days in range. Month 10: 100.0 percent of days in range. Month 11: 93.3 percent of days in range. Month 12: 83.9 percent of days in range. You should leave for the Caribbean in month 4! 
I removed all int n so each function has only one argument in it, which makes more sense to me but it tells me that the first argument in my main statement should be int, how would that work with input from the user?
Yes, the first argument to main is an integer, often called argc.
where would you use that in the program?
so int main(int **argc)?
`int main(int argc, int **argv)` (or `int *argv[] ` The first is *arg*ument *c*ount, second is the *arg*ument *v*ector (i could be wrong calling it vectoe) 
Ideally 
Then why would your embedded experience relate to the real world applications of a data structure that is inherently heap based strongly enough that you could definitively call it 'only a teaching concept'?
using: int main(int argc, char **argv) seemed to work for that particular error, thank you! 
Ahh yeah, char not int... Writing on phone, hehe
thank you immensely for this post you don't have any idea how much you probably saved my life but the code still won't open the .txt file and responds with the failed to open message every time. both the .c and .txt files are in the same folder and I type in the name of the file verbatim and no dice. Sorry to bother you anymore but any clue on this?
The only problem now is that printf(result) seems to be bringing up some problems
No, one of the following: int main(void); int main(); int main(int argc, char **argv); int main(int argc, char *argv[]); int main(int argc, char **argv, char **env); https://en.wikipedia.org/wiki/Entry_point#C_and_C.2B.2B
Do you have read access to the file? That is strange. Try changing fp = fopen(filename, "r"); to fp = fopen("myfile.txt", "r"); where "myfile.txt" is your files name. I've tested it on Fedora linux, what OS are you trying to run this on?
`printf("%d\n", result) ;` Look up printf for the format codes 
Wait no I solved that, just something about an expected declaration after result 0
Seriously? The linked list is one of the most fundamental data structures. *Many* important data structures are more-or-less linked lists and then some (any kind of tree involves linking nodes, for instance). Your comment makes it sound like linked lists are somehow antiquated, when in reality they are the best way of solving several extremely common problems. As an embedded systems programmer, I encounter them all the time and I would be curious to see a multitasking kernel that managed to avoid them entirely.
Yeah instantly realised that's what I missed, ignore me, all problems solved thank you very much :)
Beyond that, you can have a linked list without heap allocation. Consider the following: struct thread { 
It does! Thanks!
It does! Thanks!
Beyond that, you can have a linked list without heap allocation. Consider the following: typedef struct { thread_t* next_to_run; // ... other important fields } thread_t; thread_t threads[16]; There are sixteen threads statically allocated, but the order they run/wake-up/whatevre can be determined dynamically based upon priority or any other criteria. I have never seen an operating system that doesn't use linked lists (although I'm not saying they don't exist or that it's impossible), dynamic memory or not.
It's just a common variable name, nothing special. I would suggest you use more descriptive names than 'ptr' in your own programs, though.
Changing that instance just gives an error without the quotations that temperature(name of the .txt file) is undeclared with the quotations the program runs but it still displays that it has failed to open the file. do all filename instances need to be changed or something? Opening this .txt like this has been my nightmare for the weekend. i'm running it on windows 10
Thank you! I thought so, I wasn't sure.
wait, okay I got it to work. changing that one instance and then removing both files from the folder to my desktop somehow made everything work.....ok thanks a ton , this has been driving me crazy
thank you so much! this helped a lot!
Please run the code in my edit, it should give a more helpful error message. Also, are you putting in "temperature" or "temperature.txt"? You must put the full filename. 
I tried both and both failed until I stuck both files on the desktop. then the change you suggested worked fine
You should print `number_converted` at the start and end of the loop, then comparing that to the expected behaviour. You're missing an `else`.
Were you in the same directory as the the txt file and executable when you ran it? It looks in your current directory for the temperature file, not the directory the executable is in.
This subreddit is for C only, not c#. Your post has been removed.
One does not simply say a linked list is theoretical while using a linked list. You should check how many times linked lists are used in the Linux kernel. In fact, in multithreaded fifo queues you can get very powerful and high performing linked list data structures using compare and swap atomics that you can't always use in other structures. As others have said, static allocation allows you to use them without using heap memory allocation at all.
Since you already noticed it, strictly speaking you should call it array since its size is fixed. Vectors are dynamical structures with varying sizes.
Like `p`
Even worse, `var`
This problem is actually fairly challenging, I'm surprised it's an assignment for entry level C. Consider the original riddle: jugs hold 3 and 5 gallons and you need exactly 4 gallons. The solution: fill 3 gallon (3, 0) pour 3 into 5 (0, 3) fill 3 gallon (3, 3) pour 3 gallon into 5, note only 2 gal fit (1, 5) empty 5 gallon (1, 0) pour 3 gallon into 5 gallon, note only 1 gal to pour (0, 1) fill 3 gallon (3, 1) pour 3 gallon into 5 (0, 4) The "pour X into Y" step is slightly complicated, because you may transfer only part of the water from one jug to the other, you can only move the minimum of what will fit (jugMax - jugValue) and what is in the other jug. Once you get that far, then finding the (shortest) path to the solution is also a fairly complicated problem, at least for entry level. You've got a good representation of the "state" of the world at any time, a pair of numbers representing the volume in each jug, e.g. (x, y) has x gal in one jug and y gal in the other. I won't give a spoiler so you can think about how to best find the series of steps that will get to any given desired volume, 
Its for a computer programming theory class. You need to semesters of programming prior to take it but when i took them at a cc, one semester was in c and the other in java so i don't have the upper hand like everyone else here at the university im at who had two semesters of c++. Im limited to what i can do but i think this makes a bit more sense. 
Signal 11 is a segfault, which means your program is trying to read or write memory it doesn't have permission to. I see at least one place where that happens because you're writing past the end of a string, plus you're trying to free an address that wasn't returned by malloc().
For my own curiosity, what editor is he making you use?
Hhm... what do you mean that it wasnt returned by malloc? char * back = (char*)malloc(strlen(buff)+1); what else do i have to do besides that?
Dude if you came to think "ptr" to be an operation, your classes are really bad.
The address returned by malloc is not the one you pass to free. You modify back to point to the end of the space you just allocated, and just keep on writing past that.
Just a misconception from seeing the same name in examples over and over again. Doesn't necessarily mean the class is bad. 
Do expand on u/hydratedcabbage's point, while we used to do things like list_ptr, that isn't much of a convention anymore. In fact, the word ptr is hardly used. 
&gt; your **classes** are really bad. This is C, dude.
Eh, newbies come up with some really bizarre things. That's not even a top 10 misconception.
What would you say are the top 10?
You’re only checking 2 conditions, =0 and !=0, anything else doesn’t get accounted for and never increments your counter that would terminate your loop. You need an else
The program you have been asked to write takes some user input then processes a file. Typically, most programs of this type have the following outline: START PROGRAM HOUSE-KEEPING - declare variables PROMPT USER GET USER INPUT OPEN FILE /* MAIN LOOP* / WHILE NOT EOF READ line from file IF HEADER GET HEADER VALUE /* INNER LOOP */ FOR I = 0 TO HEADER VALUE - 1 READ line in group PROCESS LINE UPDATE GROUP TOTALS NEXT END IF END WHILE PRINT INFORMATION FROM FILE CLOSE FILE CLEAN UP END PROGRAM The way I usually approach writing a program like this is I start from the main loop, then add the features I need one at a time. So for this program, you could have: _First Iteration_: 1. print prompt 2. get user input To test that it is working correctly, use printf() to print out the user input variables _Second Iteration_: 1. open file 2. close file Test the return value of fopen() then use printf() to make sure opening the file works _Third Iteration_: 1. write the main loop Test that it is working by Using printf() to print out each line of the data file _Fourth Iteration_: 1. write the code to detect the header 2. write the code to get the header value Test that this is working by using printf() to print the header value _Fifth Iteration_: 1. write the inner loop Test that this working by using printf() to print each line in the group _Sixth Iteration_: 1. write the logic to process each line in the group And so on. This seems like a lot, but in each step you are only writing and debugging a small amount of code. And, each step builds on the previous steps that have been tested. Furthermore, you only have to solve on small problem at a time. If necessary, you can also break up each of the steps. 
In the last few days I saw a post by somebody who thought that you compared strings with something like if (foo[4] = 'f', 'o', 'o') ... That was up there.
You could also use the following if you need to keep a running total If (i%2 = 0){ }else { }
What else is there? Either something equals 0 or it doesn't.
Fairly common in short functions with a descriptive name that act directly on a structure or variable as given by the function name. void do_something_to_int32(int32_t* ptr); I avoid it as a general rule, but it’s a nice shorthand when not ambiguous. I used to see it a lot with pthread functions because the tutorials give the argument as (void* ptr) and people don’t change it to a meaningful name (which they should). 
Also it's a check of `%2` so the only options are 0 and 1.
PuTty (Vim)
A pointer points at *something*. int i = 42; int *p; p = &amp;i; `i` is an integer. `p` is a pointer to an integer. In this case p is pointing at the integer `i`. If *something* is a pointer then you have a pointer to a pointer int **q; `q` is a pointer to a pointer to an integer; q = &amp;p; `q` is pointing at `p`. `p` is pointing at `i`. A pointer to a pointer is no more advanced than a pointer to an integer. A pointer points at something. That something might be a pointer, it might not.
Your stnode variable is not a node itself, but a node pointer. It is only big enough to hold a memory address, and the type of the variable says that the address it holds is the address of where a node is stored in memory. When you call malloc, a node-sized chunk of memory is allocated *somewhere*, and the function returns the address of that chunk; i.e. a pointer to it. Which, it turns out is the same type of value as stnode and nextptr. So, the main thing your program is doing is writing and re-writing these address fields; the nodes themselves never move. The stnode variable actually starts out as NULL (file-scope variables are initialized to 0 automatically), which represents an empty list. Whenever you allocate a new node, you put the address of the current list head node in it's nextptr, then write the address of the new node into stnode. So your variables never hold nodes at all; the nodes are off somewhere else and your variables just hold address values. 
A pointer is a value that is interpreted as an address in memory. A pointer points to a defined another value and a type. // there is a location in memory storing the value 1 int i = 1; // this will hold the value that is that memory address int *ptr1 = &amp;i; // ptr1 is a location in memory storing the value of a // memory location that is storing the value 1 // ptr2 stores the value that is that location (pointing to ptr1 address) int **ptr2 = &amp;ptr1; 
They're like nested dolls. A pointer to a pointer holds the memory address of another pointer that holds the memory address of some value. You should try writing some test code that printfs the values and the addresses of the pointers. It may be easier to visualize. 
debugging with no optimisation, would show (again depending on architecture and optimization ), that (on linux X86_64, with little no specified optimization ) the program would crash on the `fgets` line because `fp` is null. However, the program had already run through one loop iteration, meaning that before the loop, `fp` is not null. A debugger would help figure that out, and surely the backtrace. but not point to hwat is wrong with the program
If number_converted is even, it will repeatedly enter the first if statement and divide by 2 until number_converted is equal to 1. At which point, you want the while loop to end. But it still does the next if check, which is now true, and it enters there and sets number_converted to 4. The next time through the while loop you go back into the first if statement and your loop is infinite. So you may want to change if (number_converted % 2 != 0){ to just else{
Relevantly, if you have a pointer to a pointer it is often very useful to change which pointer it is pointing to. This is used quite often in functions which allocate something for you: you pass in a pointer to a pointer and the function changes that pointer to point to a newly allicated thing.
They probably want it to expand to nothing.
So would you say this is correct? &amp;p = The address of the variable stored at p *p = The value stored at the address pointed to by p **p = (I'm not sure how to say this in words)
Detailed analysis for the `while` loop in `split_line` (assuming we are handling a line containing data ). first iteration ( `i=0, fields=[?,?,?,?,?], line="views,user,id,title,duration"` ) 1. the result of `strtok` is "view" ( not NULL ) 2. `++i` ( i: `0` =&gt; `1`) 3. store first token in fields[1] ( c index a **zero-based**, meaning that the first result should have been stored in `fields[0]` ) second iteration ( `i=1, fields=[?,"views",?,?,?], line="views,user,id,title,duration"` ) 1. the result of `strtok` is "user" ( not NULL ) 2. `++i` ( i: `1` =&gt; `2`) 3. store first token in fields[2] third iteration ( `i=2, fields=[?,"views","user",?,?], line="views,user,id,title,duration"` ) 1. the result of `strtok` is "id" ( not NULL ) 2. `++i` ( i: `2` =&gt; `3`) 3. store first token in fields[3] fourth iteration ( `i=3, fields=[?,"views","user","id",?], line="views,user,id,title,duration"` ) 1. the result of `strtok` is "title" ( not NULL ) 2. `++i` ( i: `3` =&gt; `4`) 3. store first token in fields[4] fourth iteration ( `i=4, fields=[?,"views","user","id","title"], line="views,user,id,title,duration"` ) 1. the result of `strtok` is "duration" ( not NULL ) 2. `++i` ( i: `4` =&gt; `5`) 3. store first token in fields[5] **we are writing outside of the `fields` array boundaries** fifth iteration ( `i=5, fields=[?,"views","user","id","title",**"duration"**] , line="views,user,id,title,duration"` ) 1. the result of `strtok` is NULL 2. `++i` ( i: `5` =&gt; `6`) 3. store first token in fields[6] **we are writing outside of the `fields` array boundaries** 4. NULL is returned ( end of loop ) After the while loop i == 6 fields=[ ?, // 0 undefined value "views", // 1 "user", // 2 "id", // 3 "title", // 4 "duration", // 5 outside of array bounds NULL // 6 outside of array bounds ] writing outside of the array bound is **Dangerous** as you are writing data in either other variables, or values that are very important for the control flows of your program ( things like return instruction address, or register content after your program has returned ). 
The macro is used to guard against including the same header file (ae.h) multiple times.
Thanks. I've updated the question. Just noticed that the formatting screwed up stuff. Sorry about that :(
You never reach 1 at the loop check. Assume ```number_converted == 2```. We enter the while loop and the first if passes. so we divide and it's now equal to 1. Now we enter the second if and it is true, so we triple it and add 1. Now it's equal to 4. The loop will never reach 1.
If you define something without a value it just exists and you can do ifdef on it. For include guards there is no reason in giving it a value, it just has to exist.
Reformatted for legibility: #include &lt;stdio.h&gt; int main(int argc,char*argv[]) { int x; sscanf(argv[1],"%d",&amp;x); if (x == 1) { return(1); } if (x == 2) { return(2); } if (x == 3) { return(3); } else { return(-1); } } Minor comments: The value returned by main() will be the exit code for the program. The meaning and valid values for exit codes depend on the operating system, but in general, -1 is not a good idea. Probably it will be converted to 255 under Unix. Dunno what Windows would be doing. But bear in mind, that any value other than 0 is considered an error, and *all* your return values are error values. So what your program does is accept an argument on the command line and then return an error without generating any output.
Reformatted for readability. Remember to indent your code by 4 spaces. #include &lt;stdio.h&gt; #define MAX_SIZE 5 int main() { int count, values = 5, arr[values], range, freq[range], currentv, num = 0; FILE *fp; fp = fopen("sequence.txt", "r"); /* I read in a text file of * integers: 1, 1, 2, 3, 1 */ for (count = 0; count &lt; values; count++) { fscanf(fp, "%d", &amp;arr[values]); } fclose(fp); /* * Start counting from 0, putting each number into a * frequency array. */ for (count = 0; count &lt; range; count++) { freq[count] = 0; } for (count = 0; count &lt; values; count++) { currentv = arr[count] - 1; freq[currentv] += 1; } for (count = 0; count &lt; range; count++) { /* * If my frequency of counted values is greater than * my total number of values, I add one to the * counted numbers. i.e if my total number of ones is * greater that my total number of integers, I add * one. */ if (freq[count] &gt; values / 2) { num = count + 1; } } /* * If my founded number is not 0 then I print which number in * my list comes most. If it is 0, no number appears the most * is printed. */ if (num != 0) { printf("The number %d occurs the most\n", num); } else { printf("No number appears the most\n"); } return 0; }
**p = The value stored at the address pointed to by some pointer that is pointed to by p.
&amp;p would be the address of the pointer p itself. 
Thanks :)
I second this. Swap the second if for an else. That way, if the first condition evaluates to true, number_converted won't be further altered till the next while iteration.
eh.. ```number_converted == 3``` it's not 1 so we enter the loop. is it divisible by 2? No, so we do the else you suggest multiply it by 3 (now it's 9) and add 1. Now it's 10. Repeat loop It's not 1, so we drop in.. It's divisible by 2, so now it's 5 and we don't do the else Repeat loop It's not 1, so drop in It's not divisible by 2, hit the else Multiply by 3 (now 15), and add 1 (now 16. Else won't fix his problem.
unless I'm misreading, I'm not sure his problem is that simple (see my other comment)
This isn't really C related, but I personally find LISP an amazing language that makes working with lists extremely easy. 
POSIX extended regex does not support `\d`. That's a feature of other flavors, like PCRE or ECMAScript. If you want to match a digit in ERE you have to use `[0-9]` or `[[:digit:]]`, depending on whether you want locale-aware matching. 
Oh, I see. Thank you so much! It was driving me crazy.
The function you're looking for might be `strstr`: "The C library function `char *strstr(const char *haystack, const char *needle)` function finds the first occurrence of the substring needle in the string haystack." You should be able to copy everything up to first delimiter (the `needle`) to one string, copy the substring from the end of that to the next occurrence of the delimiter to a second string, and then concat the remainder to the first string. No idea if there's a better way to do it, but I think that would work.
Let's not be too abstract here. A pointer is a 32-bit or 64-bit (depending on your target architecture) variable which contains a memory address. It's as simple as that. Now the C language adds abstractions to make it easier to program with variables containing addresses. Imagine an array of integers, which represents memory (each number is a cell): Address: 0 1 2 3 4 5 6 7 8 9 ... Value: 1 8 9 3 4 2 8 1 5 0 ... Let's assign the name `var` to the second cell (which contains the value 8). Whenever I read `var`, I read the content of cell #1 (counting from 0). What if I want to call a function which needs to modify the second cell? I can't pass `var`, since this would pass the value 8, and it doesn't help. I need to pass the location of the cell, which is #1. Therefore I pass `&amp;var`, which means exactly this: cell #1. Now the function has its own parameter variable, let's call it `param`, which contains the value 1 (address of `var`). If the function sets `param` to 3, then it's just replacing the address 1 with 3. The memory array above remains unchanged. By setting `*param`, though, we're setting the value at address `param` (1) to 3, so our first 8 above becomes 3. What would be `**param`, then? It is the equivalent of `*(*param)`, which is: the value at address (the value at address `param` (1)). The value at address 1 is 8, and the value at address 8 is 9. A common use case of a double pointer is for a function to return a C string by parameter. A C string variable (`char *`) is the address of the first character of a string in memory. If you want to return a C string by parameter, this parameter needs to have the type `char **`, that is, the address of the address of the first character of a C string.
No new lines, so all the output in the same line.
Ah yeah, I should have picked up on that. Thank you!
That's poorly worded and only sort of correct. Modern CPU cores can and do execute multiple instructions simultaneously, but only from a single thread. More cores means more simultaneous threads, assuming the operating system supports them. A multi-threaded process (or a multi-process workload) may or may not benefit from multiple cores; this is a very complex issue that depends on things like the ratio of I/O to computation, memory access patterns, cache effects, resource contention... Sometimes, it can make sense to use multiple threads even if there is no performance benefit, and sometimes a task that seems trivially parallelizable may be more efficient if implemented as a single thread with a work queue, due to resource contention. Note that in this context, “thread” means “schedulable entity” and does not necessarily map one-to-one to what an application programmer thinks of as threads. Some schedulers map multiple userland threads to a single schedulable entity (M:N threading in older Solaris and FreeBSD versions). Some language runtimes implement threading partly or entirely within the application, with no operating system support (green threads in Java). Some languages use other parallelization paradigms than threads (coroutines in Simula). The bottom line is that concurrency is one of the most difficult problems in computer science and software engineering, it can't be explained in a few short sentences, and you can't rely on your intuition to understand it.
Also: with the current code, setting aside the incorrect syntax for conjunction and disjunction, what happens if `coldtemp` is exactly 0 or 80?
You got it backwards. Some languages use the word “vector” to denote dynamic, variable-length arrays. That does not mean a fixed-length one-dimensional array is not a vector.
Please write `int32_t *ptr`, not `int32_t* ptr`.
&gt; A pointer is a 32-bit or 64-bit (depending on your target architecture) variable which contains a memory address. In some languages on some computers. The C standard makes no such guarantee. Even within the x86 family, pointers can (effectively) have 16, 20 or 36 bits and be represented as either one or two different numbers, or they can be indices into a table which contains the real memory address and some metadata. Outside the x86 family, things get even weirder.
This pattern is commonly used in C and C++ and is called a header guard. #ifndef _FILENAME_H #define _FILENAME_H /* insert file content here*/ #endif What it does is make sure that a header file is only included once during the compilation in order to avoid multiple definition errors. Here, #define without a value is used because you don't need something associated with that macro, just to know whether or not it exists.
Thanks :)
 #include &lt;stdio.h&gt; void main() { // an array of integers int i[]={4,3,2,1}; for (int n=0;n&lt;4;n++) { printf("n=%i, i val=%i\n",n,i[n]); } // an array of pointers to items in the array int* p[] = { &amp;i[3], &amp;i[2], &amp;i[1], &amp;i[0] }; for (int n=0;n&lt;4;n++) { // by dereferencing the pointer we can access the interger printf("p[%i] val=%i\n",n,*p[n]); } } as you can see we can have an array of pointers, the pointers could point to anything, you could even have a pointer to an item in this pointer array (but that could get confusing!) suppose you had an array of struct's that you want to be able to change the order of, rather than copying the actual structs, you can instead swap the order of pointers in and array... 
I assume this is for a programming course assignment so I won't give the full solution, just the general idea of how I would tackle this problem. You'll need to iterate over the file and read parts of it using fread and store it in a buffer. Then, you'll need a way to seperate each word from the next. There's a library function called strtok that can help you do this. char *strtok(char *str, const char *delim); strtok will iterate over str and stop at the first occurence of one of the characters in delim and return this 'token' as a string. After that you need to get that string's length and save it in an array.
Imagine a real world example with addresses. Let's say I have 2 postal delivery addresses (i.e. a pointer) "123 Dennis Street" and "ABC Brian Avenue". If I want to deliver a letter. I go to the address and put it in the letterbox. That's accessing the contents of a location using a pointer. Now, imagine that the location I should deliver to could depend on information from a 3rd party dispatcher (like some function in C). I could get a P.O. Box number (a pointer) and the 3rd party dispatcher would put the delivery address in the PO box. So the PO Box number is an address to an address, i.e. a pointer to a pointer. Before delivery, I would check the contents of the PO Box, read today's delivery address from inside and then deliver my letter to that address. You can extend the analogy. Imagine that a broker company uses different dispatchers to spread the load. The 3rd Party dispatcher could get a PO Box (an address to and address to an address), the broker company would put (say) my PO Box number into the dispatcher's PO Box. The dispatcher would read the contents of his PO Box, it contains my PO Box number, so he puts the final delivery address into my PO Box, I open my PO Box, get the final address and deliver the letter. 
it is infact an assignment and I appreciate the help without giving the full answer!!! I will try it! Thank you 
&gt; I've re read the syntax of #define macro and I can't seem to find anything which says about one parameter. **#** **define** *identifier* *replacement-list* *new-line* *replacement-list:* *pp-tokens_opt* The pp tokens for a replacement list are optional, which makes the replacement list optional. Note that the identifier __AE_H__ encroaches on the implementation's namespace: "All identifiers that begin with an underscore and either an uppercase letter or another underscore are always reserved for any use."
I hate to be that guy, but if you understand the c syntax and what malloc and free do, then it's down to practice. I would suggest you try to implement a linked list of ints, it might help you bridge the gap. The nice and terrible thing about c is that it has just enuf power to get the job done, but nothing more. You will see things like structures of function pointers to make inheritance like behavior, something you get for free in other languages. 
This might help: You need to open a file for reading (look at fopen) Iterate through the file line by line and store into in a buffer (fgets?) When you have a line one strategy might be to declare two pointers where the first one points to the first letter in the line and then the 2nd pointer points to the end of that word. So keep incrementing pointer1 until you get to a letter and then set pointer2 to pointer1 and increment pointer2 until you encounter a non-letter or space. You can then get the length by subtracting pointer2 from pointer1 (might not be as simple as this, can't remember fully) then you would store the information you want somewhere. Keep doing this until you reach end of file. This is probably not the best way and certainly isn't the only way. Good luck and don't give up. If it helps on paper draw the string as boxes with only one character in them and think about how you would separate the words out and how you would count how long a word is once you've separated it. Good luck!
They do different things. One takes an already existing struct and populates it. The other both allocates and populates the struct. The first one is far more flexible, because it separates those two things and doesn't make any assumptions about what the user needs. You can use it with an existing struct, or a struct with automatic or static storage duration (i.e. it does not have to be on the heap.) The second example forces the hand of the user and requires that the struct is dynamically allocated, which may not be what the user wants. Or perhaps the allocation of the struct is not really under the user's control, for example if it's a library that's going to manage its own resources as an internal implementation detail. You can't really just say as a blanket statement which one is better; context is important. 
I prefer the former because lets the caller decider how the struct is allocated: struct bleh bleh; bleh_init(&amp;bleh); // ... Or even: struct foo { int n; struct bleh bleh; }; void foo_init(struct foo *f) { f-&gt;n = 1; bleh_init(&amp;f-&gt;bleh); } An exception is when `struct bleh` contains a flexible array member and the caller and its actual size is dynamic: struct bleh { int x; int y; int values[]; } 
If I declare multiple variables on the same line, which I never do, then I will. 
When working in C it helps to have in mind some form of abstraction for memory. Thinking of a pointer simply as an address to another value along with some information on how to interpret the indexed value. A char pointer for example points to a single byte while an int pointer points to the least significant byte of a 4 byte integer. This is at least how I have come to understand pointers.
I don't understand why you think it is poorly worded an only partial correct? A single CPU can process only one instruction at a time, period. It may do this so quickly that you think it is doing multiple things but it is really only doing one instruction incredibly fast. Multi threading on a single core cpu is still just managing the instructions one at a time, on a multi core it is managing instructions at a rate of n. Modern CPU's have more than one core, so they can process core # = n at a rate of n instructions simultaneously. No intuition need, facts will suffice.
Thanks for your response. Will try the linked list soon. I've been practicing daily for about 3 weeks. Yes I think I've had too much for free so I find C difficult and unusual :(
Will keep this mind, thanks.
Thanks :)
&gt; The first one is far more flexible, because it separates those two things and doesn't make any assumptions about what the user needs. Yeah, I figured something like this. I'll take this argument into account next time. Thanks!
Alright, good explanation, thanks!
Just to be clear I am not bashing those other languages or the people that use them. I don't see anything wrong with getting anything for free. That being said though you will have a strong understanding of how those languages work if you understand C.
The first version is generally more flexible, as other people have said, because it allows callers to make decisions about where the struct is stored The only benefit (in my opinion) of the second option is it gives you true encapsulation and lets you hide the struct's members. You can define the struct and the alloc/init function in the C file and only provide a forward declaration/typedef in the header, so the only way to creat that struct is through that init function It's not necessary, but in some ways I think it can be nice to have that "true" encapsulation.
And what happens if he removes half of them?
I tried and it happened exactly like you said and it makes sense. Thank you, I fixed it like so and the 5000 \n file works fine now: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt; int main(int argc, char **argv) { int fd; char buf[4096]; int i; int linecount; int errsv; int len; linecount = 0; if (argc &lt; 2) { printf("Path to filename required\n"); return (1); } fd = open(argv[1], O_RDONLY); errsv = errno; if (fd &lt; 0) { printf("%s\n", strerror(errsv)); return (1); } memset(buf, 0, 4092); while ((len = read(fd, buf, 4096)) &amp;&amp; errno != EISDIR) for (i = 0; i &lt; len; i++) if (buf[i] == '\n') linecount++; errsv = errno; if (errsv == EISDIR) printf("%s\n", strerror(errsv)); else printf("File contains %d lines\n", linecount); close(fd); return (0); } 
I thought a structs size had to be known at compile time, thus disallowing dynamically sized structs. How do arrays of structs work, when each struct has a different size?
The first one is better. You can have an alloc and init method, or have a helper "new" method that do both
Not all structs must have a known compile time size. In fact there's a whole class of types called *incomplete types* with unknown sizes. Declaring a struct without defining it is one example. These types can be used in certain ways (i.e. pointers to them) despite their unknown size. However, you can't have an array of unknown types, nor can you use automatic or static storage for them. These types may be complete in another translation unit, though. [Flexible array members](https://en.wikipedia.org/wiki/Flexible_array_member) are an example of a useful incomplete type. The last member of a struct can be an array with an unspecified size (i.e. an *incomplete array type*). Its contents will immediate follow the end of the rest of the struct and that struct will have an incomplete type. This member isn't included in the result of `sizeof`, except when padding is necessary.
There are a couple of issues with your code. If you like we can discuss them all, but the error is probably due to: strcat(listagem, "\n "); strcat(listagem, aluno); which writes to the memory location pointed to by listagem which is not a buffer you are allowed to modify, but even if the system let's you modify it, it's not large enough to hold your concatenations. What you should do instead is to define char listagem[256] = {0}; Which will give you a buffer of 255 chars plus a mandatory 1 char for the terminator to work with. Please note that using strcat is not safe, because it doesn't take the size of the destination buffer into account. Use strncat instead.
Thanks for the explanation, the first time I tried to do that my compiler was screaming at me for how bad I am. Thus I assumed, that it didn't work generally. Definitely going to try that now.
 strcat(listagem, aluno, sizeof(listagem) - 1); If you meant `strncat` then is the wrong way to use it. The last parameter is *not* the total size of the target string buffer - it is the remaining size.
&gt; How do arrays of structs work, when each struct has a different size? You're not allowed to make an array of structs with a flexible array member. The C11 standard says: &gt; the last member of a structure with more than one named member may have incomplete array type; such a structure (and any union containing, possibly recursively, a member that is such a structure) shall not be a member of a structure or an element of an array.
Very good point, thank you! I have used the Win32 API's equivalents for so long I've lost touch with reality. Let me correct that.
I've done all the recommendations you've posted guys, but the code is still kind of problematic. I think I'll re-think my approach to the problem instead... I just need to print on the screen a list, there's no further use for the concatenated list. Maybe I'll have a better solution looking from another way... Thanks guys!
How do you declare a const pointer? I thought we had already agreed that the position of the asterisk it's a matter of preference. There are pros and cons for both options, being the neutral `int * foo;` the option with less cons in my opinion. But you do you, just don't try to impose your own conventions on others
C does little to encourage/force good practice the way other languages do. There is a lot of crappy code out there and even fairly skilled programmers write the mode obscure code, I am convinced that half the time it is because they can rather than because they need to. You need to find good, well structured clear code to learn from, not just something that was uploaded to github. 
The second is better if you want to hide what `struct bleh` is or have a special purpose memory allocator or some sort of singleton pattern. There is also the advantage that the size of `struct bleh` needs not be known to the caller which makes a difference when your library is linked at runtime.
snprintf would be far clearer than the strncat series.
Hello, the simple problem is one the line sum = m + n; m and n aren't initialized and have random values so sum get a random value which is probably always greater than t. Another minor problem is the prototype of your function steps(); the m and n value are inverted and doesn't correspond to the function declaration. To avoid these future errors, try compiling with the gcc flag -Wall, and -Werror (if you want to takes warnings as errors).
Right, just be aware that snprintf(listagem, n, "%s%s", listagem, aluno); is undefined.
But note that this is optional. In the C99 standard, for example, it's listed in the Annex J (which is only informative) under section "J.5 Common extensions", which lists extensions that are common but not portable.
 int x = parse(...whatever...); printf("parse result was: %d\n", x); 
&gt;an int pointer points to the least significant byte of a 4 byte integer. The int pointer points to the entire int. If you dereference it (apply `*` operator) you get the whole int, not just one byte of the int. If you convert the int pointer to `char *` then you get a pointer to the *first byte* of the int, which is not necessarily the least significant byte. It's the first one in memory order. (Bytes within a variable are all ordered, this is why you can increment a pointer to result in a pointer to the next byte of the variable). Maybe you are used to systems where the first byte of an int is the least significant one, but there are many systems (perhaps even more) where the first byte is the most significant; and there are other possibilities. 
&gt; Therefore I pass &amp;var, which means exactly this: cell #1. No, `var` means cell 1. `&amp;var` means the address of that cell, or `1` in your model. 
&gt; So does that mean (*FunctionPointer)(void *) is an alias for double? Not really. The syntax for `typedef` works like this: In a declaration, `typedef` just says that instead of declaring a variable, you want to declare a type alias. The identifier you declare is declared to be a type equal to the type it is declared as. So double (*FunctionPointer)(void *); declares `FunctionPointer` as a pointer to a function taking `void*` returning `double`. The parentheses around `*FunctionPointer` are needed so this isn't parsed as double *FunctionPointer(void *); which would declare `FunctionPointer` to be a function taking `void *` returning `double`. If you stick a `typedef` in front, typedef double (*FunctionPointer)(void *); we instead declare `FunctionPointer` to be the type “function taking `void*` returning `double`.” I hope this explains everything.
&gt;&amp;p = The address of the variable stored at p `p` is the name of a variable. We don't really say that a variable is stored at its name. Instead, a variable is stored at a storage location, and the name `p` labels that storage location. So `&amp;p` is the address of the location where `p` is stored. 
&gt; double *FunctionPointer(void *); &gt; which would declare FunctionPointer to be a function taking void * returning double. If you stick a typedef in front Do you mean a function returning a double* ? 
Correct! Very good.
http://cdecl.org can help you break down type declarations. [Example](https://cdecl.org/?q=double+%28*+FunctionPounter%29%28void+*%29)
Behold the [spiral rule](http://c-faq.com/decl/spiral.anderson.html). This is the magical secret to understanding this mess. Then use [this site](https://cdecl.org/) to see if you're doing it right. Your intuition about how `typedef int hello;` works is the core of the problem. It's so easy to say that the type on the left is aliased to the name on the right, because that's how 99% of type aliases like this seem to work. But that's not right. Instead you use that spiral rule: start at the name and move out in the spiral: "`hello` is an `int`." Likewise, `FunctionPointer` should be interpreted as: "`FunctionPointer` is a pointer to a function taking a pointer to `void` returning a `double`." &gt; Furthermore "*FunctionPointer" portion of the first line looks like it is dereferencing an existing pointer, not declaring a new one. One reason for the complexity here is C decided that all declarations should follow how they're used. So when you declare a pointer, it should like like you're dereferencing an existing one. That's exactly what you noticed.
Thanks for the help
Edited to be more clear, thanks.
Oh wow, thanks.
441 Emerson St., Palo Alto, CA 94301
`var` means content of cell #1, `&amp;var` means address of cell #1, indeed, or just the short version _cell #1_. I see this as: if I'm calling you on the phone (calling the function), I can ask you to put some data in _cell #1_ (`&amp;var`), as opposed to telling you just 8 (the cell's content, or `var`).
&gt; `&amp;var` means address of cell #1 &gt; I can ask you to put some data in cell #1 (`&amp;var`), Even in a single post you are still switching meanings - you start off saying `&amp;var` is "address of cell #1`" (which clearly implies `var` is "cell #1"), but then in the second paragraph you say that "cell #1" is `&amp;var`. `var` is the cell, not its content. 
No, they are not equivalent. Let's ignore the increment for a moment, so the code is: w[char_index] = cur_char; cur_char = w[char_index]; After either of these lines, we know that `w[char_index]` and `cur_char` contain the same thing ... but in the first case, they both have what `cur_char` started with, while in the second they both have what `w[char_index]` started with. These could be different values! Remember, `=` in programming is not the same as `=` in math. It's an assignment operation, not a definition of equality. As for the increment, part, though, that does the same thing.
Ah right. I really only wondering about the increment part. Sorry, I should've made the question more clear. But they are the same, as in: cur_char = w[char_index]; char_index++; and cur_char = w[++char_index]; are the same? 
No, in the first case cur_char = w[char_index]; char_index++; You are setting the value of cur_char before the increment. In the second, cur_char = w[++char_index]; You are setting cur_char after the increment. Placement of the '++' matters. Putting it before the variable says to increment after evaluating the variable. Putting it after says to increment after the evaluation. An equivalent expression would be: cur_char = w[char_index]; char_index++; and cur_char = w[char_index++];
They're still not quite the same thing, no. Since you use a pre-increment, it would be equivalent to: char_index++; cur_char = w[char_index];
 int const *pic; Declares pic to be a pointer (the pointer can change) to a constant int (the int cannot change). int *const pci; Declares pci to be a constant pointer (the pointer can't change) to an int (which can be changed). int const *const pcic; Declares pcic to be a constant pointer (which can't change) to a constant int (which can't be changed). The code: int const a; const int a; Do the same thing (declare a to be a constant integer), but I prefer the first way (where const modifies the item to the right) as it's more consistent with making the pointers themselves constant. 
Oh right I get it now! Thanks!
&gt;It's a trick question. The correct answer is that it won't compile without a semicolon. The question was about an expression, not a program. "What is the result of the expression `2 + 2`?" "It won't compile."
Excellent rebuttal 
I agree with const being to the rigth of the type `int const * const foo;` it reads more naturally: foo is a constant pointer to constant int. Instead of `const int * const foo;` being: foo is a constant pointer to an int that's constant. Many people says `const int foo;` reads more naturally. For basic declarations I can understand it, but with more complex declarations I always start reading the variable name first and then go left. So I always use the right side option for the reason you mentioned. My question was to assert the point that you can't use the asterisk together with the name when you use the const qualifier, so for the sake of consistency I think the double spaced asterisk option superior.
You keep referencing char_index and charindex as if they are the same. They are not, I assume that’s just a typo?
The second version is for initializing a struct when the values could be anything, the other is for more specific uses. If you're writing a library, always use #2.
No, you're setting W[index] to cur_char. in the second, you're setting cur_char to W[Index], then incrementing the index on the next line because only 1 expression is allowed per line.
![&amp;pizza](https://ixquick-proxy.com/do/spg/show_picture.pl?l=english&amp;rais=1&amp;oiu=https%3A%2F%2Fpreviews.123rf.com%2Fimages%2Fpiksel%2Fpiksel1311%2Fpiksel131100111%2F24238655-Woman-pointing-at-pizza-Stock-Photo-pizza.jpg&amp;sp=e3989a5472a3c046d2b04f27975d6f39)
[&amp;pizza](https://ixquick-proxy.com/do/spg/show_picture.pl?l=english&amp;rais=1&amp;oiu=https%3A%2F%2Fpreviews.123rf.com%2Fimages%2Fpiksel%2Fpiksel1311%2Fpiksel131100111%2F24238655-Woman-pointing-at-pizza-Stock-Photo-pizza.jpg&amp;sp=e3989a5472a3c046d2b04f27975d6f39)
You can use either WinExec() or system()
I'm not on Windows at the moment, but i don't see why passing the appropriate command to `system()` wouldn't work, as long as your account has permission to change those settings. That said, calling `system()` is a bit of a kluge... and is totally not a good habit to get in to. A more "official" way of changing network adaptor setings on Windows in C/C++ appears to be Microsoft's [IP Helper Functions](https://msdn.microsoft.com/en-us/library/windows/desktop/aa366073(v=vs.85\).aspx). 
Interesting! This would likely a good fit for reversi (the game the OP is actually working on) since you'd only need two words: one for the black pieces, one for the white ones.
I generally avoid `strncat` because it has a nasty trap: if the input is exactly the same length as the buffer, the result is not zero-terminated!
C++ is off topic in this subreddit. Please post C++ content elsewhere.
&gt; How do you declare a const pointer? int *const foo; &gt; I thought we had already agreed that the position of the asterisk it's a matter of preference. From the compiler's and the standard's point of view, sure, but from a human point of view, no. The asterisk applies the variable, not the type. Compare int32_t* a, b; and int32_t *a, b; These two lines mean the exact same thing to the compiler but convey different messages to a human reader, especially an inexperienced one.
&gt; I don't understand why you think it is poorly worded an only partial correct? I just spent three paragraphs explaining just that.
From what I can gather, both methods (that is, using envp or getenv() family functions) are covered by POSIX, which in combination with standard C should result in pretty portable code?
And the original tweeter was apparently waiting for that answer. That was definitely his plan, to catch people out on a compilation error when posting the name of a restaurant without any other context.
&gt;Wrong. Modern CPUs can process multiple instructions in parallel if they do not interfere with each other. Single Instruction stream, Multiple Data streams- still only one instruction. A *multi-core superscalar processor* -multiple instructions, multiple data streams, so still to processes more than one instruction at a time, you need multiple cores. As I mentioned before if the processor allows hyperthreading a two core processor could execute 4 instructions at the same time. Pipelining will only increase the number of instructions per clock cycle, not perform 2 instructions simultaneously. Your also overlooking the fact that superscalar processors have not yet accounted for the situation in which the second instruction will need information from the first instruction. What OP is talking about is having either a single core cpu or a multi-core cpu. So instead of trying to earn you place on /r/iamverysmart , you should try to focus on what OP is asking and if you have something constructive to offer OP, great, if not, you really need to settle down. 
Really it is useful.
This subreddit is about C, not C++. See the following subreddits for C++ stuff: r/Cplusplus /cpp r/cpp_questions
What the hell is this crap?
This is the C subreddit. /r/cpp is for C++
Actually, that's Rust, and this expression evaluates to a [slice](https://doc.rust-lang.org/std/slice/) of pizza.
I am not talking about SIMD or multi-core processors or hyperthreading. I am talking about superscalar single-core processors with multiple ALUs, capable of performing multiple operations simultaneously providing they are independent (i.e. none of them depend on the result of another). The latest Intel CPUs can perform up to 6 or 8 instructions simultaneously under the right circumstances. The bottom line is that you are wrong. Stop insisting that your ignorance trumps my experience. Try to learn something from our conversation, and move on.
The link you sent me https://en.wikipedia.org/wiki/Superscalar_processor was specifically talking about SIMD and MIMD, did you not read your own link?? I think you are missing the point of OP's question and are behaving like a child. If you want to be right that badly, then "oh, absolutely you are right. I am sorry for my ignorance and will bow out to your superior knowledge". Have a great day.
Looking to make a pizza for the first time, I could use a few pointers. 
Documentation for `/dev/input/eventX`: https://www.kernel.org/doc/Documentation/input/input.txt 
&gt; The link you sent me was specifically talking about SIMD and MIMD No. Reading comprehension much? It only mentions SIMD as an example of what superscalar processors are *not*. Here let me quote the entire lede: &gt; A superscalar processor is a CPU that implements a form of parallelism called instruction-level parallelism within a single processor. In contrast to a scalar processor that can execute at most one single instruction per clock cycle, a superscalar processor can execute more than one instruction during a clock cycle by simultaneously dispatching multiple instructions to different execution units on the processor. It therefore allows for more throughput (the number of instructions that can be executed in a unit of time) than would otherwise be possible at a given clock rate. Each execution unit is not a separate processor (or a core if the processor is a multi-core processor), but an execution resource within a single CPU such as an arithmetic logic unit. &gt; In Flynn's taxonomy, a single-core superscalar processor is classified as an SISD processor (Single Instruction stream, Single Data stream), though many superscalar processors support short vector operations and so could be classified as SIMD (Single Instruction stream, Multiple Data streams). A multi-core superscalar processor is classified as an MIMD processor (Multiple Instruction streams, Multiple Data streams). &gt; While a superscalar CPU is typically also pipelined, pipelining and superscalar execution are considered different performance enhancement techniques. The former executes multiple instructions in the same execution unit in parallel by dividing the execution unit into different phases, whereas the latter executes multiple instructions in parallel by using multiple execution units. &gt; The superscalar technique is traditionally associated with several identifying characteristics (within a given CPU): &gt; * Instructions are issued from a sequential instruction stream &gt; * The CPU dynamically checks for data dependencies between instructions at run time (versus software checking at compile time) &gt; * The CPU can execute multiple instructions per clock cycle
Another way to do this is to use fgetc() to read the file one character at time. As you read a character, if it is not a space you set a flag. Then when you encouter another space you increment your word count and clear the flag.
Are you done yet?
That's a weird way to write an address, can I still dereference it using `*`?
Keep in mind, all mainstream compilers support `#pragma once` now, so Pop that in front of the header guards, and just use actual header guards as a fallback.
I feel sorry for you.
That's nice, go spread your massive intellect around. I am positive you are needed desperately somewhere right now, so don't let me take any time away from others who are in need of you. You have put me in my place, I have already bowed to your wealth of knowledge, no need to continue to berate me for being a mere pleb.
You could interpose yourself between terminal and user like the ttyrec program. 
It amuses me that you continue to respond in spite of your repeated assurances that you are not interested in anything I have to say.
I don't really want to use another program I was hoping to make it myself. would this program even work if I was logged into gnome or i3 or the like and wanted to use it without a terminal emulator?
Never said I wasn't interested, repeatedly said your intellect is far superior to mine (funny since you don't know who I am). I think you have an issue with not having the last word. Feel free to no longer respond to me.
What exactly is it that you try to achieve? The right interface to use strongly depends on the spot were you want to capture input.
I'm using i3 and I want to make a program that runs in tbe background as a daemon of sorts and whenever I press a certain key I want it to write to a system file to change brightness. I know that there already are things to do this but I'm just trying to do it on my own for fun.
You cannot do this for the whole.system as far as I am concerned. However, you can hook into X for this purpose.
This subreddit is about C only. please ask elsewhere.
C# is off topic in this subreddit. Please post elsewhere.
that seems unreasonable, there is no standard way to get a key state in linux?
I wanted to do this before, I think it could be done. Maybe a kernel module would work better than a daemon though.
I'm assuming that by "after the comma" you mean the fractional part of a number (like it would handled in French), and not the thousands separator (English). You may need to swap periods and commas in some places below. &gt; Basically I have to print out "intdiv" again but with 2 digits Which two digits? Do you mean you want 5/2 to show 2,00 or 2,50? &gt; without using float or double variables. Does this mean that you're not allowed to use variables declared with those types, or that you're not even allowed to use float or double values in a calculation? A couple of things that may help you out: You can *cast* a variable in C to have it treated as a different type. For example you could print `intdiv` as a float by calling `printf("%f", (float)intdiv);` You can specify the precision of a decimal number output within your `printf` format. To print a number with 2 digits after the comma, try `printf("%.2f", 2.5);`
There are multiple ways but AFAIK keyboard devices are locked when in use.
There are 29832 readers in this sub. Posting such badly formatted code, with no example of what the problem is and no human understandable description of the issue is a waste of everuone’s time.
Thanks, this should help me out!
You're probably running into the "problem" of floating points not being precise. ([Way more information if you like reading](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html)) Use an epsilon. This means you check if the guessed value is very near the expected value. (Basically, in math `(expected - epsilon) &lt;= guessed &lt;= (expected + epsilon)`). An solution in C would be `fabs(user_guess - correct_answer) &lt; 0.000001f`. The `0.000001f` is the epsilon that I just arbitrarily used.
To add to this answer, if you cannot use any ‘float’ or ‘double’ or float literals (like 1.0), you may think about doing the operation on the numbers multiplied by 100, and use modulus to extract the digits to print (like if you were calculating in cents instead of dollars).
This is … oddly structured, but it’s difficult to tell what’s happening without enough code; e.g., declarations for `correct_result`, `user_guess`, and `clean_stdin`. My guess is that you’re doing it wrong: Floating-point numbers do not generally mix well with `==`, especially when you’re limiting precision on input and output; you’ll need to come up with some tolerance `EPSILON` sth a correct answer is within `EPSILON` of `correct_answer`, making the “correct” condition something like fabs(correct_answer - user_guess) &lt;= EPSILON A floating-point value describes a range of numbers centered around something ∈ℝ, *not* any single member of ℝ. Also, that `while` loop’s condition seems kinda wonky. (This seems like a better idea for a `while(counter--)` or `for(…counter…)` nested inside a `do`/`while` loop, since you won’t know what a meaningful `choice` actually is until after one iteration of the loop has completed. You’re also coming up with new guesses before you even know that you’ll need them, which is weird, and you’re duplicating that code several times as well/as a result.)
If you go the `WinExec` route, you’ll probably need to use `cmd /C`. `system` should use that under the hood unless you’re under Cygwin or something similar. In any case, be aware that Windows doesn’t have the same clean-ish separation between arguments that UNIX has, so if you’re dealing with trying to run an `argv`-like array you’ll need to do a bunch of not-at-all-well-thought-out escaping tricks any time an argument needs to include spaces or quotes, or sometimes backslashes if they’re near quotes. (’s not like you ever need backslashes on Windows, of course.:) IIRC `cmd` itself also handles `^` strangely.
C++ is off topic here. Please post C++ elsewhere.
I'm not familiar with i3, but in awesome-wm you can setup any program to run on any combination of hotkeys, thanks to the config file. Maybe there are similar options in i3?
Is it because you cast the value of x/y to a float after doing the integer division instead of doing floating point division? I’m more familiar with java and I’m just starting to learn C but that might be something to look at. I could, of course, be wrong 
&gt; `(++product - sum++) * sum` This expression, which you use a couple of times, invokes undefined behavior, which is bad in C. It's not entirely easy to explain to a newcomer what the problem is. (From an earlier standard: "Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression. Furthermore, **the prior value shall be accessed only to determine the value to be stored**.")
[This question also appeared on StackOverflow recently](https://stackoverflow.com/questions/46780715/)
like the user 4e4f... did
Cool tool but these editor “features” are extremely annoying. I am not used to the editor automagically inserting quotes and parentheses and to be honest I find that's extremely irritating because you can no longer type blind: You have to look at the screen to see when the editor randomly inserts something.
&gt; Is it because you cast the value of x/y to a float after doing the integer division instead of doing floating point division? I’m more familiar with java and I’m just starting to learn C A cast has higher precedence than division in both C and Java. `(float) x / y` should work pretty much the same in both languages, except for the irrelevancy in this case that Java defines an order of evaluation, whereas C leaves it unspecified.
I think every IDE / text editor made for programmers I've used has done that... At least visual studio, vs code and sublime text.
Still extremely annoying to use an editor like that. Keeps jarring me out of the flow when things I didn't type show up. At least we'll always have emacs.
Good to know, thank you! 
None of the editors I have ever used do that.
there is, I'm just trying to do it through a background process because I want it to run on more than just i3
bookmarked. Can't way to take a compiler course to figure out how this is all handled under the hood
I just listed 3 of the most popular ones and they all do it, so I guess you're in the minority.
If you think that the average C programmer programs in an IDE you have some misconceptions. Where do you have these “most popular” numbers from?
This subreddit is for C, not C++. Perhaps you'll find a kind soul, but I'd look for a C++ subreddit. 
Never said anything about C... [Here you go](https://www.infoworld.com/article/3217008/development-tools/the-most-popular-ides-visual-studio-and-eclipse.html), plus it's kinda common knowledge that visual studio is one of the most popular ones, even without a source.
Oops. Sorry about that! Thank you.
A segfault is a sign you're writing to or sometimes reading from memory you don't have permission too. In a sort, that usually means you have some out of bounds array access. Use a debugger and valgrind to help narrow down where.
You should check waitpid()'s return value before using status... Anyways, you'd want to use a signal handler and SIGCHLD to reap a dead subprocess that was running in the background because it's more efficient than using a nonblocking waitpid() call at random spots in hopes the process has exited since the last time. You shouldn't be bothering to check until the OS tells you that a child has terminated.
So.... As the man page for signal explains, there are a long list of signal values your program can receive or send. Some you can send in your code with the kill() system call. Some are automatically generated for you by the OS like when your program ends, it aborts over a bad memory access or somesuch. For your shell program it sounds like you're mostly concerned with the SIGCHLD one. This one is delivered by the system to your shell process when a process you've exec-ed and placed into the background terminates. What you probably want to do from here is write some code which handles the "disposition of the signal" (the program steps you need to do when you get that signal). You need to write a handler function, point to it in a filled-out sigaction struct and hand that struct to a sigaction system call. This sets up the handler values in your process' ublock so that when the referenced (in the struct) signal is delivered, your program is interrupted and execution passes to the handler. Once your handler completes your process execution resumes if you haven't called any termination syscalls like exit(). Obviously this is a VERY low-detail overview of the whole setup; search for "linux process handling" to find out the gory details on what you want to do and why. 
&gt;Never said anything about C... This is the C programming subreddit...
On mobile but from a quick glance it may have to do with the nested while statements. They are going to execute all the way to satisfy first. 
Visual Studio is historically a horrible environment for C development. Does it even have support for the parts of C99 that weren't adopted by C++ yet?
Some things to make this easier. * `left` and `right` should be of type `size_t`. * Since quick sort is recursive, check if it should be run at the beginning of the function. if (right - left == 1) return; * Make partitioning a separate function, that returns some `size_t` that is the index of the partition. Use this for the two recursive calls. * Because you have moved the function invariant to the top of the function, you can safely run both left and right quick sort calls unconditionally at the end. Also, compile your code with `-g` in GCC, and have the compiler leave behind debug information. Now run the program through `valgrind`. It should tell you on what line of your program an illegal memory access occurs.
If it's just to make things easier (not required for assignment) why not use qsort?
Delete the code and start from scratch. That piece of code is just horrible. Nothing personal.
He is unpacking an RGB pixel into its 3 components (into 3 separate variables). In computer graphics, it's common to store a pixel as a single 24-bit integer (or 32-bit integer if you're including an alpha channel), where 8 bits represent the red value, 8 bits represent the green value, and 8 bits represent the blue value. Imagine a 32-bit value being like so: 00000000RRRRRRRRGGGGGGGGBBBBBBBB Where the first 8 bits (the 0s) are not interesting, the next 8 bits are the red value of the pixels, and so on. What if you want to know what the value of red is in that pixel? Well you need to isolate the R bits and get rid of all the rest. The &gt;&gt; shifts all of the bits over the right by the specified number of bits. So `color &gt;&gt; 16` looks like: 000000000000000000000000RRRRRRRR Note the G and B bits have been shifted off the end (they're no longer there). Some extra 0s have been added to the left. To understand the point of the `&amp;` operator, consider we want to isolate the G bits. First we do a `color &gt;&gt; 8`: 0000000000000000RRRRRRRRGGGGGGGG We've got the G bits in the right place, and have got rid of the B bits. But we still have R bits hanging around that we want to get rid of. The `&amp; 0xff` says to do a bitwise AND operation with 8 1-bits like so: 0000000000000000RRRRRRRRGGGGGGGG 00000000000000000000000011111111 If we do a bitwise AND operation between those two values, the R bits get masked away and we're left with only the G bits.
In the main loop when you check that the elements[i] is not a number you call insertinico which is fine for the first or the second node but you when you insert more than 2 nodes using this you cause memory leak use the insertfinal function instead.
It's a rough copy of the code from here: http://www.algolist.net/Algorithms/Sorting/Quicksort
What is Qsort?
Thank you so much. This is incredibly helpful
It's a function provided by stdlib.h that implements the quicksort algorithm for you. There will be plenty of resources online for how to use it if you search online.
thanks
I was literally just thinking about how useful the exclusive or operator is. I wanted to perform an operation only when one thing is out of sync with one another. It cuts out a bit of logic from my program and does it in a concise way. You can use binary operations for lots of things - my one caveat is that when you do use them write a comment to explain your logic as we know from De Morgan's law that many logical expressions are equivalent, but not all of them will be immediately apparent to someone glancing over your code. 
In the future, either link you code in [PasteBin](https://pastebin.com/) or place in in your comment, and use something like Reddit-Enhancement-Suite to indent it for you and have it formatted like code. Example: #include &lt;stdio.h&gt; int main(void) { printf("Hello world!\n"); } 
As long as you can turn it off, as you can in VS, I don't care. 
That is your best bet, and a good start. C is intimidating, you can tame it with practice. Don't feel weird about reading the same tutorials or books over, and over again. Play with code, make things crash and understand why. A linked list is a surprisingly good start because there's a million ways to implement it. I would say though, have a use case. Have a pretend purpose for the list, whatever that is, so you have a guideline as far as the interfaces go. Trying to write a generic "super linked list to superceed them all" is just going to be frustrating.
Avoid signals until/unless there’s something you actually need them for—it’s difficult to use them correctly, portably, or efficiently and there are usually better mechanisms available. In this case, you’ll probably want `SIGINT`, `SIGQUIT`, and `SIGTSTP` handlers for the shell’s own use if `isatty(0)` (e.g., if you press Ctrl+C, +\, or +Z at the prompt, respectively), and you might need to set some others like `SIGPIPE` to `SIG_IGN`. Use `WIFSIGNALED` (/`WIFSTOPPED`) to find out about child programs being killed—even if you handle `SIGCLD`/`SIGCHLD` you’ll need to call `wait`\* to de-zombie the child anyway, as it’s just triggered to let you know that there are events available. (Also, IIRC there’s a mix of support on older OSes for names `SIGCLD` vs. `SIGCHLD`, so you might need to `#ifdef` your way through that sort of code to be portable.) A process receives a signal in a variety of circumstances for a variety of reasons. (Typically on UNIX “process” and “program” are almost identical terms due to the frequency with which `fork` is used as a precursor to `exec`; only if there’s some overarching framework like MPI do you refer to a single process “within” a program.) If you’re on Linux, see `man 7 signal` for an only-slightly-cryptic list of signals; the main reasons and causes for signal use are: - The process has crapped itself fatally. These signals arise internally to the thread in question, and include the venerable `SIGSEGV`, `SIGBUS`, `SIGILL`, and `SIGFPE`. Rarely `SIGEMT` and `SIGSTKFLT` when they’re actually used, and sometimes `SIGSYS` is counted in this category. - The process is running for too long or hogging resources it shouldn’t be; typically the signal would be delivered from the TTY driver (e.g., after Ctrl+C, +\, +Z) or from another process’s call to `kill`(1,2, or 3), typically with signal `SIGTERM` for a first attempt (lets the program try to clean up) or `SIGKILL` after that (can’t be caught, no cleanup possible). - You need stop/continue/background/foreground semantics like Bash supports, in which case `SIGTSTP` (from Ctrl+Z), `SIGSTOP` (uncatchable like `SIGKILL`), and `SIGCONT` would be used. `SIGTTIN` and `SIGTTOU` are used when background processes need the TTY. - The process needs to be notified about some unusual interaction with the OS. E.g., for when alarms or timers go off (`SIGALRM`, `SIGVTALRM` or `SIGPROF`, but don’t ever touch `SIGPROF`), asynchronous IO events happen (`SIGIO`/`SIGPOLL`), power failure (`SIGPWR`), terminal window size/characteristic change (`SIGWINCH`), file lock lost (`SIGLOST`), bad syscall (`SIGSYS`), debugging breakpoint/watchpoint reached (`SIGTRAP`), and urgent data available (`SIGURG`). `SIGXCPU` and `SIGXFSZ` can be triggered by `ulimit` IIRC, if you use too much CPU or disk space. More esoteric non-POSIX signals include things like `SIGSAK` (AIX, “secure attention key” pressed), `SIGFREEZE` and `SIGTHAW` (SunOS/Solaris IIRC, state save to/restore from disk), or `SIGTHREAD` (switch context). IIRC SunOS/Solaris even has a couple of `SIGJVM`s too for spooky Java purposes. - The process may raise a signal itself, either to test how it goes or to prematurely terminate; e.g., `abort()` is usually implemented with `raise(SIGABRT)`. You could also `raise(SIGKILL)` to effect a hasty and unavoidable exit from the process, not that you should. - The process may want to implement some special behavior out-of-band with the TTY; e.g., `dd` reports how things are going if you send it `SIGINFO` and some things will handle `SIGUSR1` for similar purposes. - The process may need to coordinate asynchronously with others, for which `SIGUSR1`, `SIGUSR2`, and the real-time signals are typically used. (Though communicating with signals is rarely the headache.) Also, signal 0 can’t be handled, but can be used to ping a process from afar—`kill(pid, 0)` with sufficient caller privilege will return 0 if the process exists.
Extending on this answer: You said “ Why would I need to interrupt a process in my program? ” Because, when a process does, it has an exit code. The exit code will be passed to the parent via the waitpid() syscall. Until then, the kernel needs to keep track that this process has exited with that code, and that it is a child of a specific parent. In the meantime, the parent, which would be your shell, is probably waiting for user input, and this can last for hours. So the shell can register a handler for signals, and when a child exits, it can waitpid() on it.
Besides interacting directly with `/dev/input/eventX`, you can use libevdev to capture raw keyboard inputs or you can use the `XRecord*` functions to capture the inputs from X. For libevdev you might want to look at [caps2esc](https://github.com/oblitum/caps2esc) and [interception](https://gitlab.com/interception/linux/tools) to get an idea on how to make it work. There's also [xcape](https://github.com/alols/xcape) in case you prefer the X approach. 
Lists are one way to implement stacks and queues (as opposed to arrays or some combo technique)—the stackness or queueness of the structure dictates the behavioral characteristics, whereas the listness or arrayness of the structure makes certain behavioral characteristics possible (e.g. array for O(1) random access). For this it’s probably easiest to maintain a queue (head+tail ptrs, single link) for the letters and a stack (top ptr, single link) for the digits. You may want to make a `struct` for each kind of structure and manage things with separate functions, or you can roll it all into a single function and use separate variables. Enqueueing: node-&gt;prox = NULL; // If doubly-linking for no good reason: // node-&gt;antr = tail; if(tail) tail-&gt;next = node; else head = node; tail = node; Pushing onto the stack: node-&gt;prox = top; // If doubly-linking: // node-&gt;antr = NULL; // if(top) top-&gt;antr = node; top = node; Once you have the queue and stack constructed separately, you can lace them together ass-to-mouth by doing if(queue_tail) queue_tail-&gt;next = stack_top; else queue_head = stack_top; This will effectively invalidate `queue_tail` and leave intermediary backlinks broken, but it puts eveything in the right order to be iterated over with for(p = queue_head; p; p = p-&gt;prox) putchar(p-&gt;data); or iteratively emptied with for(p = queue_head; p; p = q) { q = p-&gt;prox; putchar(p-&gt;data); free(p); } Couple other things: This code— if(elementos[i] &gt;= 0 &amp;&amp; elementos[i] &lt;= 9) —does not compare with digits 0 through 9, it compares with ASCII codes 0 through 9, which correspond to C0 control characters NUL through HT. You want to compare with `'0'` and `'9'` instead, or more portably `#include &lt;ctype.h&gt;` and use `isdigit` because theoretically digits are not guaranteed to be packed into a neat little contiguous block in the code-space. (In practice, most things support ASCII at the very least so the latter consideration doesn’t much matter.) For future reference and it doesn’t matter in this case specifically, but generally it’s best to put the largest, most alignment-sensitive things up at the head of the `struct` so that the compiler can pack them first and waste the least space. In this case pointer(s) first because they probably have a 4- or 8-byte alignment, and character(s) go last because they probably have a 1-byte alignment.
while its still crashing! recompile with -g (assuming gcc) and have a play with gdb gdb nameofapp from there you can press r to run once the app has crashed execute bt to get a backtrace on the call stack, this will often lead to the exact source (code) line of the crash... from there a bit of head scratching is all you usually need! obviously gdb is capable of much more but that should be enough to get you started with very basic diagnostics...
in a LOT of application (socket programming for example) you get your data basically in a big blob of binary. at that point you use binary operations to parse the incoming packets. it's also heavily used in error detection and correction.
I reckon this should work, OP. Also, take a look [here](https://github.com/kernc/logkeys). 
You’ve gotten a couple good answers already, but I’ll spew forth about what bitwise ops are used for. `&lt;&lt;` and `&gt;&gt;` are used to shift bits towards the more- or less-significant ends of the value, respectively, and are basically an implementation of integer multiplication and division by a power of two. (`a&lt;&lt;b` = `a`·2^(`b`), and unsigned `a&gt;&gt;b` = `a`/2^(`b`), and any worthwhile compiler knows about these optimizations.) Commonly, `&gt;&gt;` on a negative number will fill in with ones on the left side to maintain negativity, although what happens when right-shifting a negative is not defined by the C standard so try to avoid it unless you’re aiming at a specific family of compilers where you’re sure about the behavior. IIRC `&lt;&lt;` exhibits the usual undefined-behavior overflow characteristics for signed values when a bit comes off the left, but normal cutoff characteristics for unsigned values, so stick to unsigned shifts whenever possible. Some old MS compilers exhibit the wrong behavior when the signedness of the operands differs, and compilers are allowed to treat shifts of &lt;0 or ≥the number of bits in the value however they like. Most architectures do shifts mod 32 or 64 bits under the hood. `&amp;` is used to mask off or test bits; anywhere there’s a 1 in the mask is left alone in the result, and anywhere there’s a 0 is forced to 0 in the output. `a&amp;(n-1)` can be used to calculate a very fast `a` mod 2^(`n`), so `a&amp;0xFF` is equivalent to `a` mod 256. Assuming two’s-complement representation, you quickly round down (towards −∞) to the nearest multiple of `b`=2^*n* by doing `(unsigned)a &amp; (unsigned)-b`. You can do a quick is-a-power-of-two check with `x &amp;&amp; !(x &amp; (x - 1))` for nonnegative `x`, though that won’t tell you *which* power of two `x` is; that requires a proper logarithm, which you can do with `&amp;` using O(lg *n*) steps for *n* bits. You can also use `&amp;` to do SIMD operations without SIMD instructions, but most of the time this takes more effort than it’s worth unless you’re very clever and don’t care about portability/legibility. `|` is used to mask on bits (0 in mask→left alone, 1 in mask→1 in output), and can be used to piece together fields in a larger value. E.g., to reconstruct a color per your component breakdown from trusted-valid `r`, `g`, and `b`: uint_least32_t color; color = ((uint_fast32_t)r &lt;&lt; 16) | ((uint_fast16_t)g &lt;&lt; 8) | b; (You’d want to saturate components into [0,255] first if they’re not guaranteed to be 8-bit already.) If there’s no possible overlap between fields (i.e., only 0s where there might be a 1 in any other field), `+` can be substituted for `|` to lend a possible, very slight speed boost since there tend to be spare adder slots in instructions that do address calculation. `^` is a close relative of both `|` and `+` (essentially carryless `+`), and toggles bits from off to on or on to off where there’s a 1 in the mask; 0 in the mask leaves things alone as usual. `^` can be used for parity or bit difference, but it’s mostly used for dirty tricks otherwise. However, on two’s-complement architectures it’s very useful for sign-toggling; e.g., you can do a nifty branchless absolute value on most architectures using it: signed value = INPUT; unsigned sign_mask = -(value &lt; 0); return ((unsigned)value ^ sign_mask) - sign_mask; This takes advantage of the fact that `-x` = `~x+1` under two’s complement; XORing with −1=all 1s is the same as `~`ing, and subtracting −1 is adding 1, so it negates if the input is negative. A fun party trick is to swap using only XORs: a ^= b; b ^= a; a ^= b; Perhaps there was some architecture or compiler where this was more optimal than using a temporary variable, but that’s not the case on anything remotely modern or common, so this technique is mostly avoided in its pure form. A similar technique can be used to branchlessly select from among choices, however. `~` toggles all 1 bits to 0 and 0 bits to 1. It’s typically either used as a surrogate for negation (it *is* negation per ones’-complement), or to invert the effects of `&amp;` and `|`. With `&amp;`, it’s used to leave bits on instead of turning them off (e.g., `a &amp; ~3U` will turn off the bottom two bits whereas `a &amp; 3` would turn off everything else and leave the bottom two alone); with `|` and `^`, it’s used to leave bits alone instead of turning them on or toggling them. Internally, the compiler may convert `&amp;&amp;`, `||`, and `!` to `&amp;`, `|`, and `~` if there’s no causal/temporal dependence between the operands, which tends to eliminate conditional branch instructions. This is especially useful with sign tests; e.g., a &lt; 0 &amp;&amp; b &lt; 0 → (a &amp; b) &lt; 0 a &lt; 0 || b &lt; 0 → (a | b) &lt; 0 but per the C standards you can’t use the right-hand forms portably/reliably so let the compiler do that kind of optimization. For future reference, in general it’s best not to mix bitwise math and `int`s if there’s any chance the `int` might be negative, because how negative things get mixed into bitwise math depends on the compiler and target architecture. The standards leave the correspondence between a number’s value and its architectural representation wide open so that C can target sign-magnitude and ones’-complement machines, so make no assumptions unless you’re sure of what you’re targeting and how it behaves. (Note that on some older platforms, the preprocessor and compiler may even behave differently in their evaluation of `&amp;`, `|`, `^`, `~`, `&lt;&lt;`, and `&gt;&gt;` expressions involving negative numbers, or the compiler may evaluate constant expressions differently from how compiled code would evaluate a non-constant one.) Also, the code you posted requires ≥25-bit `int` to exhibit well-defined behavior (fine for most systems nowadays), but it should probably use `unsigned long` or `uint_least32_t` to cinch things down properly because the standard mandates only ~16-bit `int` minimum. If there were an alpha field things could get weird.
Well, you can by now use a different compiler!! And IDE that can be used with different compilers, ain't that awesome?! Yeah, MS, welcome to the stone age :)
Oh haha, I thought I was in /r/programming
I get the correct result, but it's not guaranteed. What happens if you replace all instances of `%lld` with `%llu`?
What value were you expecting? What is the value of INT_MAX (from &lt;limits.h&gt;) on your system?
The first assigns `NULL` to `tree`. The second assigns `NULL` to the pointee of `tree` which is a semantic error in this case as `tree` doesn't have scalar type.
i don't understand .
What part of this explanation don't you understand?
i get that semantic error part , it should be tree==NULL but I am not able to understand what this checks and what exactly does *tree=NULL does ? Thanks for the help
Nothing is checked at runtime. `NULL` is a pointer (or integer, depending on the implementation) and `*tree` is a structure, so these two cannot be assigned to each other.
Doesn't the starting values have to be fibonacci numbers? 10 and 6 are not fibonacci numbers
int v; int * p; foo(void) { p = &amp;v; // p now points to v *p = NULL; // v is now null p = NULL; // p is now null } 
fuck formatting :(
&gt; plus it's kinda common knowledge that visual studio is one of the most popular ones, even without a source. this just doesn't make sense 
I think this will work. ( *((char*)(ptr_to_s-&gt;ptr_to_data)) )++;
I tried something similar (if not identical) and it just doesn't like the post increment outside of brackets. Might just be my compiler, I agree that you code should work...
And 4 spaces to the beginning of each line. main() { //Like this }
vim is more popular than sublime, 4th on the list. Faith in 8% of humanity restored :P
[removed]
&gt; So &gt; &gt; double (*FunctionPointer)(void *); &gt; declares `FunctionPointer` as a pointer to a function taking `void*` returning `double*`. Im actually pretty sure it's returning a `double`. This'd be returning a `double *`: double *(*FunctionPointer)(void *); Now we also need the parenthesis because double **FunctionPointer(void *); would return a `double **`. In your example, the parenthesis are actually not mandatory. The "spiral rule" gives: /------------------- \ / /--------------\ | double (*FunctionPointer)(void *); ||------------/^ ^ |-----------------| 
My advice would be to not try to do this all in one statement. If it's complicated enough that you're having trouble formulating it, it's going to be hard to read and understand as well. I stick to a fairly conservative coding standard and I'll take clarity (and safety) over compactness.
There's little confusing because there's a difference between `*tree = NULL` in a definition and `*tree = NULL` as a statement. When you do struct bst { /*...*/ } *tree = NULL; you're defining `tree` as a pointer to a struct and then setting that pointer to `NULL`. If you do, by itself, tree = NULL; you're setting the same pointer to `NULL` again. Those things above are different from doing *tree = NULL; by itself. Here you're trying to set what's pointed to by `tree` (a struct) to `NULL`, which doesn't make sense. 
Yes it does return double. I must have been a bit drunk.
Something that I don't think has been mentioned yet is that it's really handy for a function that might have a lot of options, e.g. `open` on *nix systems: int open(const char *pathname, int flags); `flags` can set many different things, e.g. `O_APPEND` opens the file in append mode, `O_CREAT` will create it if it doesn't exist, and `O_RDWR` will open the file in readonly mode. As flags is a bitmask we can easily combine these options (with `|`) and the implementation of the function can easily check if they are set (with '&amp;'). It's also trivial to add new options. If `open` didn't use a bitmask for the flags field you'd have to add more and more arguments, and you'd end up with something like: int open(const char *pathname, int append, int create, int readonly, int exclusive); If we need to add another option in future then the function signature will change and *all* code that uses it will need to be adapted. With a bitmask only the parts that need to use the new option need to be changed.
Vim and Emacs do so too! 
I changed it to %llu and it did work. So thanks!
Yeah but i had to do it for a fibonacci-like sequence. So basically, F(n) = F(n - 1) + F(n - 2) but for any two initial values.
haha...too bad I use Emacs
#C #Pointer #Interview #Questions and #Answers - #Java2Python
Casting function pointers is okay, but calling them with a wrong signature is definitely not. Use approach one.
What is this obsession with indians and interview questions? These questions are trivial to answer if you have actually learned how to program (and are thus rather useless), but if you don't know how to program, you won't land a job by memorizing interview questions. Just learn how to program, it's not that hard.
#C #Interview #Questions on #Strings - #Java2Python
I agree with you for the writing part, particularly wrt maintenance. The implementation is totally different and clear to the reader. However, I think it can be useful to practice these sorts of things; they help one understand the compiler and the language better.
I see, however what happens under the hood, and what could go wrong?
You shouldn't get compiler warnings for unused arguments unless your settings are EXTREMELY high. Maybe some lint checkers will report on that.
Undefined behaviour is undefine behaviour. The compile is allowed to make nasal dæmons fly out of your nose in this case. In practice, this “just works” but don't expect this to work in the future and just don't do it.
I think -Wall will include that (-Wunused-variable) warning, and I actually find that useful most of the time.
Okay, thanks!
This is my interpretation of your code... should compile and achieve what you want to do. #include&lt;stdio.h&gt; char data = 5; typedef struct { void * ptr_to_data; } s; s c; s * ptr_to_s = &amp;c; int main() { ptr_to_s-&gt;ptr_to_data = &amp;data; printf("data value = %i\n",data); (*((char *)ptr_to_s-&gt;ptr_to_data))++; // solution? printf("data value = %i\n",data); } 
Shouldn't work, if I've understood you correctly. I'm pretty confident you'd be trying to assign to an rvalue (which is probably why you can't get it to compile), and you're definitely not assigning to the struct member you want to edit. Just do: char * tmp = (char *)(ptr_to_s-&gt;ptr_to_data); *(tmp++) = c; ptr_to_s-&gt;ptr_to_data = (void *)tmp;
This doesn't help you right now, but it's possible the next version of C (currently called C2x) will add the [C++ attributes feature](http://en.cppreference.com/w/cpp/language/attributes), along with the `[[maybe_unused]]` attribute. If they use the C++ syntax, your code would then look like: static void load([[maybe_unused]] char *arg1, [[maybe_unused]] void *arg2) { // } This feature was presented to the committee last year and were received favorably, so I would expect them to appear in the language eventually. In the meantime, however, your should use your first option you proposed.
&gt; Can we use loops to read strings? &gt; No. The hell? This is awful. Also, does this look like Twitter to you?
C++ is off topic in this subreddit. Do not post C++ content. This is your final warning.
I prefer strict warnings as it does help catch things from time to time - and encourages better practice, I habitually use a macro like this #define UNUSED(x) (void)(x) just because it aids readability - its clear as I use these first, what's used and what's not...
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; struct data_container { void *data; } int main(void) { struct data_container data_container; data_container.data = malloc(6); strcpy(data_container.data, "hello"); struct data_container *ptr_to_data_container = &amp; data_container; *((char*)(ptr_to_data_container-&gt;data)++) = 'c'; printf("%s\n", ptr_to_data_container-&gt;data); printf("%s\n", ptr_to_data_container-&gt;data - 1); }
Actually, no, see this comment: https://reddit.com/r/C_Programming/comments/76tdwl/help_understanding_this_pointer_to_functions/dojgstf?context=3 
Hexadecimal number. 0x tells it's a hex number
That it's in hex. It's a single quote. Char is a byte in c so any character is also a number. See http://www.bluesock.org/~willg/dev/ascii.html
If you're using gcc or clang, you can suppress warnings about intentionally unused variables with: int cb(void *arg1 __attribute__((unused))) { return 0; } 
`0x` in front of a number denotes a number that is written in [hexadecimal](https://en.wikipedia.org/wiki/Hexadecimal). In this case, 0x27 = 39. Potentially relevant, this is also the [ASCII code](https://en.wikipedia.org/wiki/ASCII) for a single quote (`'`).
&gt; Char is a byte It is an integer type, but its width is implementation-defined.
The existing code is correct. The `++` and `+=` operators may only be used on an lvalue. And it would be undefined behaviour to use an lvalue of type `char *` to access an object that is actually of different type (in this case `void *`).
All of the casts and parentheses in your code are unnecessary.
More succintly: *(char *)ptr_to_s-&gt;ptr_to_data++ = c; 
Implementation-defined, as in it may not consist of 8 bits. However, `sizeof(char) == 1` by definition.
It's called a Lucas sequence. The Fibonacci sequence is simply the Lucas sequence that starts with 1 1.
That doesn't make it a byte.
What's emacs? :P :P
MSVS 2015 and 2017 have almost full C99 support.
God forbid I ever prefer clarity over assuming everyone who reads my code has instant knowledge of operator precedence in any situation... 
I disagree. http://c0x.coding-guidelines.com/6.5.3.4.html &gt; The sizeof operator yields the size (in bytes) of its operand [...] https://docs.microsoft.com/en-us/cpp/c-language/sizeof-operator-c &gt; The sizeof operator gives the amount of storage, in bytes [...] https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#The-sizeof-Operator &gt; You can use the sizeof operator to obtain the size (in bytes) [...]
The result of a cast is an rvalue to which you can't assign using the ++ operator, so that doesn't work. 
spacemacs, haha
I run into things it doesn't support all the time on those occasions when I'm forced to use it with C. A recent example: The proper way to display a size_t variable with printf is with %zu. On Windows? %I64u. Granted, that might be more a runtime than a compiler issue, but it's still not in accord with C99 or C11. 
/r/cprog but it's not very active.
I can understand the frustration. People has those questions, and I lot of people are happy to help them. It would be best (in my mind at least) if both groups met up with their posts/answers on a seperate subreddit. Unfortunately, this subreddit doesn't rules doesn't have any formal rules (as far as I know and can find looking), nevertheless any forbidding homework. There is a specific subreddit for homework questions (/r/C_Homework) and a few more that specifically cater to questions (listed in the sidebar). I wish we'd have some tighter rules that basically forbid homework (and questions close enough to look like homework) and then some strict enforcement pointing those users to a place with people that want to see those questions (and would be more likely to help). Not sure how to start a subreddit-rule-convention, but that's pretty what it would take. There's no other subreddits which are big and C-specific unfortunately to switch to.
Try a C++ subreddit, preferrably one for homework questions. /r/cpp_questions or at least /r/C_Homework . Please read their rules and posting guidelines first of course. Also you should probably have your code posted on pastebin or something and link to in your question, no one is going to be able help. Your code may make it more clear, but giving your questions a brief read, they really aren't very clear. 
Thanks. I appreciate the input! 
/r/cpp does a pretty good job with this. Posts with homework questions are pretty quickly redirected to /r/cpp_questions.
**Here's a sneak peek of /r/cpp using the [top posts](https://np.reddit.com/r/cpp/top/?sort=top&amp;t=year) of the year!** \#1: [I just found a use for the poop emoji in C++](https://np.reddit.com/r/cpp/comments/75gohf/i_just_found_a_use_for_the_poop_emoji_in_c/) \#2: [C++17 is formally approved](https://herbsutter.com/2017/09/06/c17-is-formally-approved/) | [97 comments](https://np.reddit.com/r/cpp/comments/6yjerb/c17_is_formally_approved/) \#3: [Bjarne Stroustrup awarded 2017 Faraday Medal](https://www.cs.columbia.edu/2017/bjarne-stroustrup-awarded-2017-faraday-medal/) | [23 comments](https://np.reddit.com/r/cpp/comments/72gxkw/bjarne_stroustrup_awarded_2017_faraday_medal/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
If you look at the comments you can usually find/debate some techniques.
I polled this community a while ago. The majority actually liked homework questions so I did not consider further policy action.
C++ is off topic in this subreddit. Please ask in the subreddits /u/dnabre indicated.
Sorry about that. This is my first time looking for help and didn’t mean to post in the wrong subreddit. 
No problem.
Thank you! Been looking for a place that I could get help. 
Thx! The fabs() function solved it! That clear_input() is so nothing happens when i input a character, like "f" or "s". Was just a tip i found somewhere. Btw, here's the beginning of the main function: int main() { /* Generate random number every time */ srand(time(NULL)); int x, y; int user_guess; int correct_result; int counter = 0; char choice; int clean_stdin() { while (getchar()!='\n'); return 1; } begin: printf("What do you want to practice? (A)ddition/(S)ubtraction/(M)ultiplication/(D)ivision/(N)othing \n"); scanf(" %c", &amp;choice); And after that, we have all those "if/else if" statements, to check if you've chosen Addition, Subtraction and so on. If not, the program prints that you've chosen to quit.
You could use a queue for your output. This would allow you to completely send each message before starting the next. Also, you could design a simple protocol that will give structure to the messages.
Get rid of the trailing space in the format.
That did it! Thanks my dude really appreciate ya help.
I think others have largely answered your other questions, so... &gt; And more generally what is the point of using bitwise operators like OR,XOR etc.. ? Why would I ever want to compare binary numbers and shit? The applications are limitless. Usually you are doing something low(ish) level. One simple example is bit-fields, in a 32 bit unsigned integer you have 32 booleans. Using AND you can check the status of any individual bit in that integer; and using OR you can set any individual bit. My personal favorite is swapping two values in place without wasting a third register/memory address: a ^= b; b ^= a; a ^= b; Now `a` holds what was originally in `b` and vice-versa. In college one of my assignments was to write my own `malloc()` and `free()`. I kept bookkeeping information in a chunk of memory in the front of a large page that I carved up as users called `malloc()`. Whenever someone called `free()`, rather than do an expensive lookup on my internal data structures to find the page the pointer being freed was allocated from - I just made sure my pages were allocated on word boundaries and created a second pointer by doing a bitwise AND on the freed pointer to clear the low order bits and thus make my second pointer a pointer to the front of the page where I could get access to the bookkeeping data. Then of course there are mathematical computation that can be vastly sped up by using bitwise arithmetic instead of the naive methods. It used to be (and probably still is) much faster to do multiplication and division using a series of bitwise shifts and addition along with an XOR to flip the bits when you needed to deal with negative numbers (two's complement). The sky is the limit as they say. Take the time to learn all the bitwise stuff. It gives you a better appreciation for what the machine is doing, if nothing else.
&gt; A fun party trick is to swap using only XORs This is always one of my favorites.
In case you care, you misspelled minimum in your function.
If you find one, please let us know. I wouldn't be so bothered by the homework questions if they weren't almost universally the most basic Chapter 1 C problems, and SO frequently posted.
Is it that hard to just not open posts you don't like? 
Just use wikipedia for the increment and decrement operator.
PHP has similar syntax of C
I can easily find out specific operators and what they do; but I just want to know if there are any projects i could do that would help me learn how to use them comprehensively so that when I need to make more complicated expressions I will know how they work together.
When I was a kid, I programmed Pr1me computers for a living. Arguments and the return address were passed on the stack, and if you called a function with the wrong number of arguments, your program would crash. Your style #2 would definitely cause programs to crash.
OK, you should indent your code 4 spaces so that it doesn't get reformatted. The two asterisks in `*right` and `*tree` turned the code into italics and confused me. struct bst { int data; bst *right, *left; } *tree=NULL; Now that I can read it, I see that **tree** is a *pointer* to a **struct bst**. Your code is combining a declaration and an assignment. You could also have written: struct bst { int data; bst *right, *left; } *tree; tree=NULL; and now we see that **tree** is a pointer to **struct bst** and its value is NULL. Had you written *tree = NULL; it would have been an error because you're trying to set whatever tree is pointing to to NULL, but tree isn't pointing to something that can be set to NULL.
Come join us at /r/c_language or stick with /r/cprog
I mean they're pretty specific operators, you're not really gonna see them outside of loops. I don't think I've EVER seen them outside of the loop condition variables, that's just bad practice to me.
Except we all know what it does, you're just making it more confusing by casting such a basic ass operation.
I do, however I find it a bit cumbersome.
You will most likely only come across the increment and decrement operators in loops. They increase or decrease a variable's value by one. You could also do something like `i+=2` or `i+=4` to increment i by 2, 4, or whatever you want. Essentially, you're changing the value of i, then putting that value back into i. Does that make sense? 
I'm not surprised, they are getting their homework done for them. 
**"Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live. Code for readability."** - John Woods, 1991. 
I've normally preferred to make such conversions explicit - if that's not your preference, fair enough, but it's not a problem with my code, and I won't apologise for it. (In fact, in my job I write (mostly) C++ with warnings enabled and treated as errors, so in practice I normally *have* to use explicit casts.) If you'd like to point out an actual problem with my answer, rather than attacking me for not writing in your style, go right ahead. 
&gt; (In fact, in my job I write (mostly) C++ with warnings enabled and treated as errors, so in practice I normally have to use explicit casts. C is not C++. They have different type systems. C++ requires explicit casts, C does not. Furthermore, if you need casts in C++, you're probably using the wrong idiom, while in C, unnecessary casts are frowned upon as they can hide bugs.
The unnecessary casts and parentheses make your code *less* readable, not more, because the reader has to visually match the parentheses and decide whether they change the evaluation order.
... I'm well aware that they're different languages, thank you. I'm aware, as I have already said, that the casts are not technically necessary. I prefer to make the casts explicit. That's not wrong, it's preference. Kindly either a) point out something that's actually wrong with my example, or b) stop attacking me for not writing it exactly the way you would. Because I've already seen the way you wrote it elsewhere in the thread, and it was broken, for reasons I have explained to you. 
&gt; Furthermore, if you need casts in C++, you're probably using the wrong idiom, while in C, unnecessary casts are frowned upon as they can hide bugs. If you think using casts in C++ is "probably wrong", you clearly haven't written very much C++. If the cast is unnecessary in C, any potential bug with it is better hidden if you don't write out the conversion than if you do, in that it's less immediately obvious that the conversion is happening (in many cases, though possibly not the one above). 
Thanks for the explanation of why it shouldn't be doable. 
I don't agree, even in the case where everyone does know the operator precedence. In the case where anyone at all might not it's very obvious why it's clearer to make it all explicit. I would agree that there's an extreme to which I don't think this philosophy should be taken, but in most cases I believe it's a readability improvement. If you disagree, that's fine, but if that's all you've got to say then please just stop spamming me about it. 
Warnings about unused function arguments are stupid. Disable them. It's very common to implement an interface where a function must have a specific declaration but where you don't need to use all the arguments. To warn about that warns about too much perfectly valid code. Avoid alert fatigue. Casting function pointers is pretty much always wrong. You are allowed to cast a function pointer to another function pointer as long as you cast it back to the original type before calling it, but this means that your program needs to know which type the function pointer had and that means that there's nothing preventing you from storing it correctly in the first place.
Huhuhu.
&gt;&gt; /r/cpp does a pretty good job with this. &gt; Here's a sneak peek of /r/cpp using the top posts of the year! &gt; #1: I just found a use for the poop emoji in C++ OK. Well, then maybe it is better to keep homework questions. :-D
&gt; A fun party trick is to swap using only XORs: Please never show this to beginners without at least a warning that this should never be done in real code. This might have been a useful trick in the 80s, but with superscalar processors this just causes pipeline stalls because each instruction depends on the result of previous instruction. Also, in most practical cases it requires a branch to check if &amp;a == &amp;b (it's rare to see swaps of normal values, but very common to swap values through pointers to them).
Yes, that's the problem. The homework threads are not intrinsically uninteresting, so it is a good a idea not to avoid them. *But* it's been a little while (either since /u/FUZxxl tweaked the spam filter which was previously making too many false positives, or since the start of the new school year) that the sub is flooded with homework threads. The consequence for me is that I do not open them any more. The only way to find those which may embed interesting things is to read them all, and that's too much, especially considering that half of them don't make much sense, because of a too bad English, because they were posted in a rush, because the poster is totally lost and has no idea of what is important or not, and so on (because of the bloody Z generation too :-&gt; ). The following consequence is that I almost do not come to the sub any more. *But* if we ban the homework questions, we will also lose the ones that triggered interesting matters. There is almost no way to know in advance in which of the threads it will happen. That's not easy to decide. Once the volume grows, there is no more perfect choice to make. 
There are many ways to do this, but you're probably expected to just have a loop that checks all 8 bits in turn and increments your counter variable for each one that's set. Or check the low order bit, right shift by 1, repeat until the number is 0. That's another common basic approach. Hints: &lt;&lt;, &gt;&gt; and &amp; will be useful. 
I'm in favor of keeping the homework questions, but I think we all benefit we if the bar gets raised a bit. Virtually every single time I come here I see multiple downvoted questions where the author don't even put in the minor effort to format the code properly. Not to mention all the trivial questions that could be answered by googling it (there's one right now asking what `0x27` means). 
Here's my favorite bit counter, cribbed from the Bit Fiddling Hacks site: unsigned int charBitCount(unsigned char v) { unsigned char c; static const int S[]={1,2,4}; static const int B[]={0x55,0x33,0x0f}; //01010101, 00110011,0001111 c=v-((v&gt;&gt;1)&amp;B[0]); c=((c&gt;&gt;S[1])&amp;B[1])+(c&amp;B[1]); c=((c&gt;&gt;S[2])+c)&amp;B[2]; return c; } It can be easily expanded to handle integers as well. I find the way this clears it down really elegant.
Would it not be a good idea to move homework questions to the more appropriate subreddit (/r/C_homework), instead of deleting them? That way you don't waste the effort, however small, of the poster, and of the people who bothered to reply. I doubt that Reddit can already do this, though technically it should be quite easy. 
I for one like all the questions.
A byte is not equivalent to 8 bits, it is the smallest unit, and it could be something else than 8 bits. Why Anglos persist on using *byte* instead of *octet*, which is the accurate term, is beyond me. Especially when they add insult to injury, by allowing the confusion between **b**ytes and **b**its. But Anglos have got a never-ending love for shitty units :-D 
But then the drawback is that this means more work for the moderator(s), and the need for him/them to draw arbitrary lines that will probably move depending on the mood of the day, opening the possibility for more fights about the decisions made.
&gt; If you think using casts in C++ is "probably wrong", you clearly haven't written very much C++. I have. Typical example: casting the return value from `malloc()`. The problem is not the need for a cast, but the incorrect use of `malloc()` instead of `new`. &gt; If the cast is unnecessary in C, any potential bug with it is better hidden if you don't write out the conversion than if you do, in that it's less immediately obvious that the conversion is happening (in many cases, though possibly not the one above). I'm not worried about the reader, I'm worried about the compiler. An unnecessary cast can cause the compiler to suppress a warning which would have alerted you to a bug. It will also make your life unnecesasrily difficult if you need to change the type of a pointer.
C does not support templates like C++ will. I'm not familiar with MSVS, but I'm sure someone on here can help fix your other problems shortly.
Could you not use variadic arguments here?
[removed]
Sorry, I’m totally oblivious to the previous discussion on this topic so forgive me if someone already answered this question. Why don’t we have a weekly thread dedicated to homework questions? I see that in plenty of other subs. All other homework threads get closed and told to post in the homework thread. Just a thought, I know it would be more work for the mods.
I feel you. It’s either suffer through all the low level uninteresting homework questions, or have no activity on this sub. I wish there was more talk about general c tricks and techniques but no one seems to care enough to post. GitHub has some interesting solutions and examples, but lacks discussion. I wish there was a happy medium.
The cast isn't unnecessary if the compiler would complain about the conversion. If you're letting a tonne of warnings you'll ignore into your build output then you're potentially obscuring the ones that matter. If your conversions give you warnings either cast to say "I know what I'm doing" or change the code. (I work with warnings as errors, so again this is non-optional for me) Giving one example of someone writing unidiomatic C++ using a cast is not sufficient to show that use of casts in general is indicative of bad C++. Yes, casts can be used badly. So can a lot of language features. That doesn't mean anytime you cast it's bad. 
/u/newt_hoenikker I don't know how to make a template, but I have something just as good. Step One Make a source file filed out as a general template. [Here's one I use for myself. You can modify it to include whatever you'd like.](https://www.dropbox.com/s/bblzga0ry438vg8/MainFunctionTemplate.c?dl=0) Step Two To open this for use in any project, just open it by CTRL-O or going to FILE-&gt;OPEN-&gt;OPENFILE in the top taskbar, and navigating to wherever you saved it. Step Three At this point, you should see the MainFunctionTemplate.c (or whatever you've called it) in Visual Studio. It has *not* been included in your project yet/ Step Four In FILE in upper taskbar, click "Save As" and rename the new source file into whatever you want. It's simple, but I hope this saves you just a little bit of effort. :))
Thanks! This helped out a lot.
You're going to need to write code to parse the user's input into a tree, and then you will need to evaluate it.
You could, but then you lose type checks and have additional code to get to the possibly used arguments. 
The MSVC compiler is available as a standalone executable which you can just run from the console to compile a single file.
Since I'm lazy, I'd use a CAS like Maxima to do it, not C.
If you always know that the user will be giving you a polynomial, then your best bet is still to store just the coefficients in an array. It's easy and effective. You just have to get a bit more fancy with how you parse user input: read the coefficient (including sign, and it might be implicitly a 1 if it's nonexistent), read the x, read the exponent to see where the coefficient belongs, and then store in the array. Alternatively, you could turn this into a more general-purpose expression evaluator. Tokenize the input and store in a tree structure, which you can then evaluate directly. This is a common assignment for beginners, actually, mostly to teach how to make and use a stack (look up infix vs postfix conversion and you'll probably find something).
You can't increment aDest if it is constant. There's not a good reason for it to be constant, so you can remove the const. If you're stuck with the signature, make a copy uint8_t *dest = aDest; and use that instead of aDest.
Is there any reason you're not just using `memcpy` for this? `memcpy(aDest, bAddr + OffsetAmt, nBytes);` &gt; The problem I'm having is im not even getting the first byte copied into the array correctly, I think the issue is with the line. &gt; "*aDest = point1;" Your compiler should be giving you a warning on this line. The left side is of type `uint8_t` while the right is `uint8_t*`. This mismatch won't work. You need to dereference the right side as well. &gt; I understand that I need to increase adest and point1 as i go through the array &gt; but what I Don't understand how I can increment aDest if it's declared as a constant. This is a common confusion. The pointer isn't `const`, the thing it points to is. So you can change what the pointer points to, but you can't use it to change the value of what it points to. Which is also a problem in your current code: you want to be able to both change `aDest` and change the array itself, so you don't want any `const` at all in that function parameter. As opposed to `bAddr`, which you never reseat and only read the contents of what it points to. If it makes things easier, you can treat both of those pointers as arrays, so your loop just becomes: aDest[k] = bAddr[OffsetAmt + k];
But you guys have to take decisions even if the majority don't like them. I believe /r/cpp guys got it right: refer people with questions to r/cpp_questions/ and keep /r/cpp a place to talk about C++.
&gt; But you guys have to take decisions even if the majority don't like them. No.
I don't think your example is a polynomial. Variables in a polynomial can be raised only to the power of non-negative integers.^[[ref]](https://en.wikipedia.org/wiki/Polynomial#Definition) e.g. a^2 - 2ab^3 - bc + 1 is a polynomial but your example is not because of those exponents
1. this is C subreddit. 2. Why can't you write this your self? 3. No offense, but this post alone demonstrates how much lack of knowledge you have in this industry. You should be learning this yourself. The first step would be learning the difference between C/C++. Otherwise, you aren't going to learn anything at all. Sorry, but I'm just plain sick of "free homework" from people and companies.
Sorry I'm 12 my mom is making me do this for homeschooling please forgive me
All good, I can understand. -- I would be lying if I didn't do the same thing when I was 12. My demands were a little too high level. heh Here is a very good resource that got me on a good track: https://www.tutorialspoint.com/cplusplus/. Just read through all the topics on the left. I know it looks scary long, but it really doesn't take that long to learn C++ when you get the basics down. EDIT: Don't hesitate to post already written code if you need help in the cpp reddit. -- Not a lot of people are fans of doing all the work. ;)
C++ is off topic in this subreddit. Please ask elsewhere, e.g. in /r/cpp_questions. Best of luck with your education!
You are right. You don't have to. But until you make that decision this sub is pretty much irrelevant if you have a decent knowledge of C.
/r/C_programming is the largest C programming subreddit and has grown by about 200% since I started moderating it, so I seem to be doing something right.
Reddit doesn't allow you to move posts.
How is it irrelevant? People other than you come here with a more than decent knowledge of C and you are free to bring up topics to discuss with them.
Nobody questioned the decent level of popularity of the sub.
Then what is this “irrelevancy” comment about? By all standards I can think of, this is the only non-irrelevant subreddit about C and there is nothing stopping you from posting all the content in the world.
So, at this point I feel like I've ended up in a way more extreme position on the casts than I intended to be in or really believe. A more realistic position would be: In the example I gave above, sure, it's probably OK to ditch the casts (I'm keeping the second line parentheses though). If you're converting and you get a warning, either change the code or add a cast. If the type to which you're converting isn't easily visible on the page, probably add a cast. I think that third part is a reasonable compromise between not accidentally silencing warnings where you are doing something wrong - which is a legitimate concern, of course - and maintaining easy readability for others who touch your code.
That's just bad formatting. OP meant to write `3x^3+2x^2+5x+1`, or 3x^(3)+2x^(2)+5x+1, but Reddit rendered it as 3x^3+2x^2+5x+1 To avoid formatting, escape formatting characters like \^ with a backslash (\\\^ is rendered as \^) or use backticks around the text (\`a\^b\` is rendered as `a^b`). If you don't want to avoid formatting but want to write polynomials like x^(2)+1, just put spaces between the terms (x^2 + 1) or put the exponent in parentheses (x\^(2)+1 is rendered as x^(2)+1)
It is irrelevant for that kind of people because you have to swim in a sea of beginner questions. Why do you think the guy is asking for a different sub? Yeah, theoretically you can bring up topics and you and other people can search for them to engage in a discussion but because it is annoying for the people involved that are interested on that they just go somewhere else (doesn't have to be on Reddit).
I thought I was clear: it is irrelevant **if you have a decent knowledge of C**. It's great for people learning the language or trying to get help for their homework.
If you want a forum for “advanced” C programmers (whatever that means), the only thing I can really recommend is comp.lang.c in the Usenet.
This guy markups.
&gt; If you're letting a tonne of warnings you'll ignore into your build output then you're potentially obscuring the ones that matter. I never ignore warnings.
Thanks!
Maybe there could be some filters with tagged posts like many subreddits out there to filter questions/homework/other discussions?
... Spectacularly failing to answer the point in any meaningful way. We're done here. 
But that is a part of the problem, not a part of the solution. It is a growth issue, that any kind of forum (Usenet, web, Reddit, any other form) experiences sooner or later (and generally sooner *and* later) when its popularity reaches a critical number...
And you want me to maintain some sort of elitism?
I don't know. To be fair many of those filters either they do not work or they are slow. In fact I just found out that there are filters here in this subreddit and I tried one of them and it didn't work. But let's face it: most people don't even know there are filters. Once you see the frontpage of this subreddit you come to the conclusion that this place is for questions and that it is way different from /r/cpp, /r/java, /r/dotnet, /r/php, etc. Just to be clear I'm not against beginners or people getting help. I just think that kind of stuff should be separated into specific subreddits so the "main" subreddit for the programming language can have more, let's say, "interesting" content.
In my case, what I like the most is when someone submits a (very) small program or project for review. I say small or very small, because I find it impossible to dive in bigger ones (even not so big). But even for small ones, it takes some time to review, it takes some time to check things, it takes some time to formulate the remarks in a clean way, and then it takes time to discuss and exchange with the poster. So if the thread is quickly buried by too many beginners threads, that is not very cool :-/
I understand and it makes sense, I'm just afraid we would have too many subreddits with less visibility and less people browsing.
Following this point, the sub would be an absolute ghost town if we did not allow homework questions. Unlike C++ there simply isn't much changing in C to garner much discussion on it. That weeds out at least half the content you see on subs like /r/cpp
We already have these, check the side bar.
For starters, turn on your compiler warnings. You should see something about using uninitialized variables. You don't want to do that.
If it's non-existent it might also be zero (the whole term doesn't exist).
Just as I said. ^^^(Here for show.)
There is one post a day, if you remove questions then there are no posts a day.
In this case I'm running Ubuntu Linux and the terminal is just called "terminal".
This is a very compact and fast way to count the number of set bits. It only loops as many times as there are set bits! https://pastebin.com/wzVUVdaJ
Datagram or stream socket? Large packets on datagram sockets need to be fragmented which may be the problem.
It is a TCP socket so a stream socket... I was taught TCP would take care of fragmentation and correct transport. That's why I am a bit confused right now.
Show your code.
Sounds an awful lot like your using UDP and MTUs are screwing you. Are you using ::send or ::sendTo? 
https://pastebin.com/sVgCULe9 The socket is set up similar to here: http://beej.us/guide/bgnet/output/html/multipage/clientserver.html#simpleserver with socket type set to STREAM
https://pastebin.com/sVgCULe9 The socket is set up similar to here: http://beej.us/guide/bgnet/output/html/multipage/clientserver.html#simpleserver with socket type set to STREAM
 recv_status = recv(sock_desc,buf,len,0); You don't update buf and len here for cases where recv() doesn't read len bytes all in one go.
Oh right... I didn't spot that. I will fix that and try it out again when I get to work on the code again today or tomorrow morning.
Thank you! Simply initializing the char arrays to empty arrays fixed the terminating issue
There are 5 loops. Which one is only counting to 6?
I just bought my TV. How the fuck is it older than C?
Thank you!!! that explanation kind of lit a switch. that does make a lot of sense. i appreciate it
Pointers are necessary to emulate higher level constructs at a very low cost 
How would you make a binary tree without pointers?
Lets say you would like to make a grid based game, for this you would need an array of tiles of course. You would want to get a tile at x, y without looping trough the entire array to find the right tile. So you would wanna say "Hey give me the tile at x and y". This could be done in either of 2 ways. - translating the x and y to a single integer. For example (x + y * width) this would give a single integer that can be passed on the array as normal. - Or you would fill the array with pointers that point to another array. This makes an 2D array. Each x points to the array containing the y. Now you could just call the array as shown here (array[x][y]). Another reason for pointers is because in C an struct's size ALWAYS has to be known before compiling. This is because the memory management system has to reserver the bytes needed by the struct. So if you would want an array inside the struct but you don't know the size of the array before the program starts, (for example you ask the user how many elements need to be created). this means the array needs to be stored outside of the struct. So we create a pointer inside the struct (a pointer is always 4 bytes on a x32 system) that points to the array. Now we can just get the pointer adress with a malloc(elements * sizeof(elementinarray)). And voilah we have a dynamic size array (not really, we need to create a new array every time we want to increase of decrease the size). Side note: EVERY and EVERY malloc has corresponding free() call
Thanks, this is the type of clarification I'm looking for.
Take the idea of a list (sometimes referred to as a linked list) where each element in the list and refer to the element before and after (a double linked list). Each link would be a pointer.
How could you do anything without pointers?
Another reason why they're useful is avoiding expensive copies when passing a large data structure to a function: just pass a pointer to it.
One thing I've thought about doing to teach pointers (and more) to beginners is to implement trees and linked lists via arrays. Basically, you allocate a large array of nodes. Nodes carry references to each other via an index into this array. I think this could also teach how memory allocation works as a more advanced topic.
&gt; EVERY and EVERY malloc has corresponding free() call I think you mean EVERY and EVERY malloc has *to have a* corresponding free() call. Your original sentence implies that it already has one somehow.
Well if you're a decent programmer it already has. No JK i indeed ment to say that. Thanks :D
Uh, no. OS X uses the Mach kernel...
I just got in my office and worked on the code and sure now it works fine. Yeah I was always overwriting what I already had, because I didn't update the pointer. Thanks
I'll give another example. Suppose you have a small image (100x100 pixels, and is grayscale). You create an array: int image[100][100]; /* filled with the image contents */ You have some functions that operate on the image, for example: int get_max_pixel_value(int image[100][100]); Every time you call that function, you *copy* the image, and the function works with the copy, and not the original. I'm sure you can see where this is going... if the image were RGB and much larger, say 4K (or 3840x2160), you'd end up copying 21MB of data **each time you called the function**. If you do this a lot, then it's *very* slow. On the other hand, when you use pointers: int** image; /* appropriate malloc calls to setup the image along with the data */ int get_max_pixel_value(int** image); The function gets a *copy* of the pointer -- a memory address -- which is 64bits (depending on platform). I know I'd rather copy the 8 bytes of the pointer vs 21M bytes of the image contents when I call this function. Now, on a practical note, there's all sorts of metadata associated with an image, such as width and height that I've not used here. The above is to focus on the pointer aspect -- I'd not actually implement it in this manner in the real world. HTH. 
Practical: [Arrays of pointers](https://embeddedgurus.com/stack-overflow/2014/03/replacing-nested-switches-with-multi-dimensional-arrays-of-pointers-to-functions/) [Jump table](https://embeddedgurus.com/stack-overflow/2009/12/jump-tables-via-function-pointer-arrays-in-cc/) Theory: I would suggest reading about addressing modes. 
If you were to buy something on the internet, would you rather send your whole house over so that they put the package in and send it back to you or would you rather give them your address so that they put it directly in your mailbox without any additional work? That's what pointers are for in situation where you use big structures.
Value of pointers pretty clear here, thanks.
[With an array.](http://opendatastructures.org/versions/edition-0.1d/ods-java/node52.html)
The reasonning is good but the example is not. The argument of the first function will not pass a copy of the content of the array, but a reference to it. (Sorry, I don't have time at the moment to check my assertion and develop it, I hope someone else can dot it.) 
Why bother tokenising the input? You can do the whole job with getchar, two ints (one to maintain state, the second to count the length of the current word) and a data structure for the frequency histogram (e.g. an array, supposing you know the upper limit on the length of words in the input).
Very true, and this must be the optimal solution as well. You did well to point it out since I didn't think of it.
Suppose you want to sort an array of large objects. One alternative is to actually put them in order. But every element swap is expensive if the objects are large. Another option is to make an array of pointers, and then sort that. This technique also helps if you need to use the same data, but sorted in two different ways. But my general advice is if you want to see how data structures, and the facilities of the language, are useful, then use the language to solve actual problems.
Your programm has its instructions in the text segment. If the programm now gets executed, you need to keep track of the current instruction executed. This keeping track is done by a pointer (instuctionpointer). The Linux file system works by references. Pointers are an essential element to computing in general, I don't know if a computer without pointers is even possible. https://en.wikipedia.org/wiki/Program_counter or just read some of the standard wikipedia article about pointers: https://en.wikipedia.org/wiki/Pointer_(computer_programming) I hope you can see how essential they are to computing
&gt; OS X uses the Mach kernel... OS X / macOS runs a BSD clone as part of its Mach/Darwin clusterfuck: https://en.wikipedia.org/wiki/Darwin_(operating_system)
Ignoring computer architecture, lets say you were selling 2000 lbs of sand, and someone arranged to meet you to pick up the goods. Would you bring the sand to the point of transaction, or would you be more inclined to tell your buyer where (what address) to pick up the sand? Similarly you could share a file attached to your email, or share a link to a google document. Well, it's that way with pointers. If you have a *lot* of data to share, like a binary image or a video, you can simply agree to share the location of the data in memory rather than actually transfer everything when the hand-off is made.
Literally the next thing I said: &gt; Perhaps there was some architecture or compiler where this was more optimal than using a temporary variable, but that’s not the case on anything remotely modern or common, so this technique is mostly avoided in its pure form.
With that `clean_stdin()`, `fgets` and `fgetc` are probably a better idea than `scanf`. You can `sscanf` and `strtod` and `strto`(`u`)`l` and so forth, and it gives you a little more direct control over the input than `scanf` gives you. Also forces you to check inputs a little more carefully, since EOF and errors can happen at any point.
No blog spam please.
The example (at ~35:25) where the division is moved ahead of the `foo()` looks like it's definitely a compiler bug, not a valid optimization of undefined behaviour, since `foo()` could call `exit()` and result in a perfectly well-defined program. Unless the compiler also knows something about the behaviour of `foo()`.
Thank you! Could you possibly explain what it means to "parse into a tree?"
&gt; Every time you call that function, you copy the image This is wrong. The function receives a pointer to the array, with type `int(*)[100]`. Structs are copied when passed to functions, arrays are not. So this program: #include &lt;stdio.h&gt; void change(int image[100][100]) { image[0][0] = 1; } int main(void) { int image[100][100]; image[0][0] = 0; change(image); printf("%d\n", image[0][0]); return 0; } prints `1`, showing that the array in `main` is changed by the function.
Let's say yo have a watch, this watch can display any date inside a month, from 00:00 on day 1 to 23:59 on day 31 how you will tell the time?. ofc with the hands of the watch. the hands of the watch will rotate around pointing to stuff, this way you can tell the time &amp; date The hands of the watch does not move, they are fixed in a place rotating around itself, and then point to stuff, where you can extract useful information. The watch hands are the exact equivalents of pointers in C, and that shows how important and useful pointers are.
I accidentally left some information out of my question. I should have said that for the scenario I was running, the integer "size" should be equal to 5. However, for some reason the program just started working when I ran it again. I think I may have forgotten to recompile it. Thanks anyway. And sorry for not including enough information in my question.
First take a look at https://en.wikipedia.org/wiki/Abstract_syntax_tree, so you can get an idea of what I'm talking about. Basically, what you want to do is define a `struct node`, that has two members of type `struct node*`, an enum to define the possible types of nodes, and a union of possible contents of the struct (number, operator, etc). Then you will need to write a parser, or use a tool like bison to generate one, to convert your polynomial into a tree. For instance: x^2+6x+3 -&gt; (x^2)+((6*x)+3) gives something like ``` + / \ ^ + / \ / \ x 2 * 3 / \ 6 x ``` Then to evaluate it, you recurse into the tree, evaluating each node's children before evaluating the node. This is exactly what your c compiler does when it parses your source code, and if you get lost, I highly recommend reading a little about parsing with regards to compilers.
You are correct
Pointers allow a function to modify variables outside of its scope. Here's a simple example that should be pretty clear: void swap_ints(int* x, int* y) { int tmp = *x; *x = *y; *y = tmp; }
And what have you tried so far? You'll get better responses if you show your working.
Can you post the complete output of the program as well as the input you provide so I can debug this? What operating system are you programming on?
programming on terminal for mac and yes this is the output it gives (it gives the same whether i use I D L or R): http://prntscr.com/gzyumx this is the file i use: http://prntscr.com/gzyv1i
 for (int a = 0; a &lt; len - 1; a++) userWord[a] = userWord[a-1]; In the 1^st iteration of the loop, a-1 is -1. So you're reading off the beginning of the array
Copying a string to itself is undefined behaviour. Don't do that. Note that this happens when you run `strcpy` on `userWord` and a function which returns a pointer into `userWord`. Instead, use `memmove` to move the data savely. This requires you to know about the length of the string but you already seem to know that.
I just changed it to a = 1 instead and I'm still having the same problem... what else do you think it could be?
my purpose by doing that was to copy the string that was altered by one of the functions on to the original one so that if I had more than one input (i.e. user types "DL"), it wouldn't just print out the string through the L function.
That is correct. However, you cannot copy a string to a part of it. That's undefined behaviour and likely causes your crash.
Is there any way I can do that without using memmove? I haven't learned that yet
Then learn it! Type `man memmove` and study the documentation. It's a fairly simple function to use.
/u/FUZxxl has good advice. If it isn't `strcpy` then run it under a debugger, or add more printfs to narrow down the problem. I don't spot anything else wrong except char tempVal[len - 1]; userWord[len-1] = tempVal[0]; which is wrong is wrong when len is 1 (But the input should be `Alabama` so this isn't the crash this time)
a gets the value of something1 and something3 is compared against 0 for the condition of the while loop. Technically all three expressions are "evaluated" but that doesn't really matter unless the expression is doing something such as how a is assigned the value of something1.
Another Q: is C turing complete without arrays and pointers? I'm having trouble seeing how someone could write an arbitrary algorithm without them
so i read that its something like this: a=something2 something2 while (something3 &gt;0) { do this a=something1 something2 }
Correct.
Ok, i should have just posted the code in the first place i guess, im working with pipes and here is some sample code that im trying to understand. ffd=file descriptor,pfd=pipe file descriptor while ((c = read(ffd[READ_END], rb, 1)) &gt; 0) { write(pfd[WRITE_END],rb, c); } This is just reading from input file and writing to a pipe, but it looks like it would never end?
It's a form of optimization really. Suppose you have the following structure: struct foo { char filename[FILENAME_MAX]; size_t size; time_t create_time; }; And a function to print out the contents of that structure: extern print_foo(struct foo f); The contents of the function is immaterial to this discussion. So that function exists. Without pointers, when you call `print_foo()`, the compiler will have to generate code to create a copy of the structure so the function will be able to use the data. For a small structure, this might not be that bad, but as the structure size increases, so too does the time to create the copy. With a pointer: extern print_foo(struct foo *f); only the address of the structure need be passed. This is one basic use of pointers. Now, to your question of an array of pointers. Again, that's useful. Suppose you have a list of such structures: struct foo *list; Yes, it's a pointer, but you can allocate space for it: list = calloc(1000,sizeof(struct foo)); and then treat it as an array (of 1000 items per the call above). You fill up the array with information on a bunch of files (say, 1000) and you want to sort the array by size. That's easy enough: static int compare_foo(void const *left,void const *right) { struct foo const *l = left; struct foo const *r = right; if (l-&gt;size &lt; r-&gt;size) return -1; else if (l-&gt;size == r-&gt;size) return 0; else return -1; } ... qsort(list,1000,sizeof(struct foo),compare_foo); And this will work, but qsort() will have to copy the physical contents of each element around, taking time. Instead, if you had a list of pointers to pointers, yes the code will get slightly more complex, but it will execute faster as only pointers have to be copied, not the actual contents of the items: struct foo *list; struct foo **plist; list = calloc(1000,sizeof(struct foo)); plist = calloc(1000,sizeof(struct foo *)); /* point to each element of list in plist. */ for (size_t i = 0 ; i &lt; 1000 ; i++) plist[i] = &amp;list[i]; list = function_to_fill_in_list(); static int compare_foo_p(void *const left,void *const right) { struct foo *const *pl = left; struct foo *const *pr = right; if ((*pl)-&gt;size &lt; (*pr)-&gt;size) return -1; else if ((*p)-&gt;size == (*pr)-&gt;size) return 0; else return 1; } qsort(plist,1000,sizeof(struct foo *),compare_foo_p); The data in `list` is still in the original order, but looping through `plist` will show the data sorted by filesize. 
That is very different from the code in your original post. This one will loop until read() returns 0 or a negative number.
Yes! but how? With what i currently know about comma separated conditions for while loops, it seems like it would run forever,
Oh, I think I see. You're confusing the [comma operator](http://en.cppreference.com/w/c/language/operator_other) with commas used to separate function arguments. Two very different things.
That's very cool!
OH i think im confusing the read function with comma operator for while loops. that whole while function is basically saying while end of line hasnt been reached or there wasnt an error, read 1 char from the file and put it in the read buffer. And then the write in the while loop basically writes to the pipe whatever is in the read buffer which should be 1 byte.
As someone who understands pointers... this analogy was confusing and... pointless.
After scouring my brain thinking about the code bases I work on the most common and simple reason for using pointers is quite simple. If you want the function to modify the variable or return a result pointers are necessary because the return value is already used by an error/success code normally. 
Pretty much, yeah.
No, not quite correct. `a=something1` is done in every iteration of the loop.
No. while ( a=something1, something2, something3) &gt; 0 ) the a-something1, something2 and something3 are evaluated before every iteration of the loop. Not just the 1st.
A number is a number. Binary, decimal, hex, etc. refer to representations of a number. So int index = (((*(src+i))&gt;&gt;(GROUP*(idx/8)))&amp;mask); Gives you your number and you can represent it in different bases with printf("%x\d", (((*(src+i))&gt;&gt;(GROUP*(idx/8)))&amp;mask)); // hex printf("%d\d", (((*(src+i))&gt;&gt;(GROUP*(idx/8)))&amp;mask)) // decimal 
Have you tried adding a fflush(stdout); statement after the printf statements?
Thanks for this pretty extensive reply. I've skimmed it and will be going over it in more detail.
This should help you with what your trying to do: https://stackoverflow.com/a/997959/5476495
Put 4 spaces in front of every line to format it as code. And that looks like C++. This sub is for C. You want /r/cpp_questions.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
Thank you! And to think that I managed to complete this radix sort assignment, but not figure this out.
Dude, just call `printf` and family with `0x%X` boom, hex.
Amen to this.
Thanks for the example. Previously, I assumed that, unless a pointer type is passed as an argument explicitly, the values were always copied over. It's an interesting caveat to note that arrays are passed by reference, not value, as opposed to most other types.
As a computer architect, this is the correct answer. It’s not just syntactic sugar some others are suggesting. They’re useful for passing large amounts of data around without memory copies
Arrays aren't “passed by reference.” Rather, whenever you use an identifier that refers to an array, the array is implicitly converted to a pointer to its first element. There are three exceptions to this rule: If the array is an operand to `sizeof`, `&amp;`, or `_Alignof`, this decay doesn't happen so you can (a) point to the array or (b) retrieve its size and alignment.
&gt; Or you would fill the array with pointers that point to another array. This makes an 2D array. No, that's not a 2D array. An array is by definition a contiguous zone of memory, so that the position of each element can be computed by a simple mathematical formula. In an array of pointers, on the other hand, it's impossible to tell where the j-th element of the i-th row is without dereferencing the row pointer. So unlike regular 2D arrays for 2D arrays made of pointers you have an extra memory dereference on each access, that's quite a big deal considering how slow the memory is compared to the CPU and that the cache can't help you much in this case since it has no way to predict where that pointer is pointing. Another problem is that you have a mem overhead of `height * sizeof(int *)`, for small 2D arrays this overhead dominates and considering that we're most likely compiling for 64 bit systems it adds to the problem. E.g.: a small 3x3 matrix of ints has an overhead of `3 * 8 = 24` bytes, that's 6 ints added to what you're storing, so `66.6%` more mem (also: i haven't taken into consideration the bookkeeping overhead of `malloc`, since we're probably allocating each row dynamically). The right way of declaring and allocating a dynamic nxm 2D array since C99 is: int (*arr)[m] = calloc(n, sizeof(int [m])); This requires at least C99 support from the compiler because `arr` is technically a pointer to a VLA. If the compiler doesn't support C99 i'd still recommend a 1D array and manually computing indices over an array of pointers. &gt; Another reason for pointers is because in C an struct's size ALWAYS has to be known before compiling. This is false considering flexible array members, the struct is allowed to have variable size but only if the variable member comes last in the struct, which makes sense when you think about it. Again this requires C99 support. It's possible to do this without C99 too, just allocate the struct header for the array plus memory for the array, however with this method you must make sure that the start of the array which comes after the struct is properly aligned to whatever alignment the type of the array elements require. Either way saves us from a memory dereference: the array is packed together with the struct. &gt; (not really, we need to create a new array every time we want to increase of decrease the size). Though it's possible to do it like this, that's what `realloc` is for.
I would probably use strftime: http://man7.org/linux/man-pages/man3/strftime.3.html
No blog spam please.
I mean, almost all languages are pass by reference
higher level languages like java or c# implement references with pointers under the hood 
&gt; You've got a point there ...walks away petting his dog Arrow. 
That's my point. although I incorrectly assumed OP's question was why C has the asterisk/ampersand mechanics rather than the more general why languages have references.
You weren't incorrect in your assumption. I'm only concerned with C here.
Ah, well in that case, you're right. Access to memory addresses does have a use for low-level stuff (kernel stuff mostly), but 99% of the time, there's no need for it and just adds cruft. Look at a modern systems language like Rust -- there's no need for manual pointer control 99% of the time, so they did away with it. But when you do need it, they provide the same asterisk/ampersand mechanics as C.
This is the correct answer. I would like to add: I spend half my day, every day, looking at frigging log files. Please do people like me two favors: * Use the same format for timestamps everywhere. Mentally shifting gears between different log files is a hassle, and writing scripts to analyze logs gets messy if the format is inconsistent. * Use this format: `yyyy-mm-dd hh:mm:ss` (strftime format `%F %H:%M:%S`). Representing dates in Y,M,D order means you can simply sort the file. You'll find that useful someday.
Yes. Is it feasible? No.
Thanks for your answer. Why isn't it feasible?
Possible, yes. Likely, no. The market is flooded with teenagers and amateurs attempting to make everything from games to apps. Some are even really good. The game Stardew Valley for instance was made by one guy. However, the likelihood that you're able to create a viable product alone, support it, market it, keep developing it, alone, is close to zero. Veeeeeeeeery few people have the drive, skill, and luck needed to make it in a market tougher than ever before. Now, learning to program by taking online classes and reading is certainly possible, but unlikely to put you at the top of the applicant list for jobs or even joining startups. I've made a fair bit of systems for various clients and made decent buck for it But I don't have the drive or skill to singlehandedly create the next Facebook ;)
If you had a niche application that required specialized software, then yes. It's very common to have have specialized software for specialized applications. Could you go from 0 to viable business model? Sure, how good is your idea vs what's out there. But if its just a close copy of what's available, no, not likely.
See other answers to your question in this thread, they sum up the immense difficulty pretty well. My response was a little tongue-in-cheek.
Very unlikely in short term. Would take a very long time. Here are the problems you will face in a realistic world. Which will easily be problematic for a entry level programmer. - Assembly for the boot loader. - having to manually write driver support for devices. - having to learn to load programs libraries and multi threading. - don’t get me started if you plan on having a GUI. LOTS of things really get involved. - having to handle RAM memory for the programs and hopefully won’t bork your OS or other programs. Microsoft couldn’t even nail this right until Windows XP. As you can tell this is extremely involved. Plus you have to worry about marketing, setting your self apart and finding a problem that needs to get solved. IMHO I would love a VM centered OS. But something like that would take a lot of time and resources.
An OS is a wide-ranging and complex piece of software, and doing it right would mean many years of studying computer science. People have been figuring out the best ways to do that stuff for half a century. Even a small system like FreeRTOS is a team effort. But you can certainly make a living as a programmer without formal education. I did technically take a couple of years of community college classes, but I learned little if any programming there, and in fact I'd been programming in C for a year or two and my instructor had only learned over the summer. For a solo developer, the money is really in specialized applications for a particular niche. For example, I've got an application I wrote for in-house use that ties into my e-commerce system and to UPS and USPS label printing systems and automates a lot of tasks for packing and shipping orders. If I wanted to spend a lot of time expanding it, making it more configurable, and documenting it, I could probably make a viable product out of it. It'd mean finding and marketing to a specific market segment (say, companies of a particular size range using one of a few popular e-commerce systems) and there's no guarantee I'd sell enough to make a living on it, but it's certainly something that can be done by one person.
On Linux or MacOS: int main(int argc, char *argv[]) { for (int i = 0; i &lt; argc; i++) printf("argv %d is \"%s\"\n", i, argv[i]); return 0; } `argv` is an array of pointers to the program's arguments.
&gt; Could one learn how to program on their own time without any college Absolutely. You'll find that the vast majority of colleges don't even teach C and other languages well. &gt;than develope something (for example develope an OS) An OS by yourself? No. The OSes that people write by themselves (e.g., MINIX, TempleOS) aren't real-world viable (and generally aren't meant to be). 
Thanks! For what it's worth I fully agree with you on date formats too.
well first of all someone wrote some shitty, hard to read code. but to be more helpful, the `,` operator in C has the lowest precedence of any operator. that means it is evaluated last by the compiler. as far as what it does, is that it evaluates the thing on its left, then evaluates the thing on its right, and returns the value of the thing on its right. So in other words, that condition statement here is assigning the value of something1 to a, and the loop will continue if something3 &gt;0 the presence of something2 in this situation is completely pointless, also.
First off, that's C++, and this is the C subreddit. Secondly, this looks like a homework problem. Odds are your college has people who are literally paid to teach you things.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
What arguments do you want to pass? What are their types? If you can answer this question, I can help you with the syntax.
The producer.c is given an int argument for the size of the buffer which is how many char array "strings" the buffer can hold. I can read this in this int fine, I just am having issues with how to initialize this buffer afterwards and then how to make it so the consumer.c can actually access this buffer afterwards if that makes sense.
So the buffer is supposed to be an array of strings? Or is it just an array of characters?
it is supposed to be an array of strings of size x that is initialized in producer.c and accessible by consumer.c if both programs are running concurrently.
Wait... these two are separate programs? Are you supposed to use some sort of shared memory? I'm a bit confused. It would definitely help if you could paste the relevant parts of your problem description. Though, I'm off to sleep now, it's late in CEST land.
I completely agree with you that the superior date format is `yyyy-mm-dd` (ISO 8601) but since OP didn't tell us what the timestamp would be used for (or who will interpret it -- a person or a system) then I would split the answer: 1. For log files, use `%F` (ISO 8601 = `yyyy-mm-dd`) -- it's the format of least surprise in dev/IT and, as you say, it sorts nicely. 2. For user consumption, I think the best general-purpose answer for OP is to respect locale settings and use format specifiers `%x` and `%X` for date and time formatted according to the user's current locale. 
The gist: Declare you char array, once, in one file. Then refer to it in other file(s). e.g. in `file1.c`, you have: char *a; Obviously, you can read and write to `a` in `file1.c`. Maybe you will allocate and initialize a value in `file1.c`. Then in `file2.c`, you can declare the existence of an external variable like this: extern char *a; And now anywhere in `file2.c` you can refer to `a` just as you would in `file1.c`. You can actually allocate or free the array from `file2.c` if you like, or just read or write to its contents. The `extern` reference will be resolved during compilation/linking.
If you can keep the entire linked list in memory (just in case there is some stupid rule against that) — for each transaction remove the corresponding item from the list, update amount, and re-insert in the right location to keep sorted. Then just write out the binary file. You’ll need to implement three fairly simple functions on the linked list: traverse in order, insert item keeping the list sorted, remove item from list. Should be simple enough.
wtf?
C, not C++ or C#... fcking retards can even read properly...that's what one gets by learning crap programming languages
This is what we call an over reaction.
Well I'm right there with you if you want to talk about fuckery you foul mouthed cunt. Let's see how fucked up your tit-encumbered pussy code is and explain it back-ass to your bitchin ears in a way that won't fuck you up in your asshole head fucker.
what?
Ignore the troll.
I think what he's trying to say is that your choice of words in your title is uncalled for and lacks civility 
Interesting way to express that, but fair point. 
You _can_ write a function to do this. It isn't pretty: int (*qsortcmp_fn(int (*fn)(const char *, const char *)))(const void *, const void *) { return (int (*)(const void *, const void *))fn; } Note, the the function has to do the cast. Might as well just do the cast directly on strcmp. qsort(a, 10, sizeof(*a), (int (*)(const void *, const void *))strcmp); Or, if you really don't want to cast, write a wrapper around strcmp that takes void*'s. int void_strcmp(const void *s1, const void *s2) { return strcmp(s1, s2); } 
Worth noting that casting a function pointer and then using it to call a function, as in the first example above, is [undefined behavior](https://stackoverflow.com/questions/559581/casting-a-function-pointer-to-another-type). So writing the wrapper function is your only real option.
The reason you can't pass `strcmp` to `qsort` is that `qsort` calls the comparison function with pointers to the elements, which are in your case pointers to char. So it passes effectively `char**` and the comparison function has to dereference that to pass `char*` to `strcmp`. [qsort(3)](https://linux.die.net/man/3/qsort) is very clear on that that.
Well, this sub recommends not giving answers directly, but you did a fair deal by yourself, this is not particularly difficult and I'm kinda bored, so I'd do something like this: (I'm assuming a `final_grid` that is a 4x4x100x150 array, and an `original_grid` that is a 400x600 array) for (y = 0; y &lt; 400; y++) for (x = 0; x &lt; 600; x++) final_grid[y % 4][x % 4][y / 4][x / 4] = original_grid[y][x]; That is, you go through every pixel in the image, and you split them in any of the 16 groups depending on their modulo value (so that the group each pixel goes to loops between the four). Then, you select the position in that group by dividing the index by 4, to compensate the 3 pixels that were moved to other groups. (I'm not too good at explaining things, so if you have any doubt please ask.)
I think that makes sense. I never thought about it becoming a 2 dimensional array with technically another 2 dimensional array being inside it, so that may have been my mental block. I'm calling it a night now, but I'll shoot you a PM in the next couple of days, if that's ok, just to bounce ideas off you in case I can't get it to work. 
Yeah, OK, when you have time a PM or a response to this is fine.
C# is off topic in this subreddit. Please post C# content elsewhere, e.g. to /r/csharp.
Please be civil.
Did you mean me or the guy who first warned of "fuckery" in his question and title?
There is no list of vulgar words. You may swear if you think it is appropriate to do so. I trust your own judgement in this regard. “pointer fuckery” is definitely an appropriate use of words and I don't see “fuckery” as a swear word at all. However, your comment is insulting to OP and does not contribute to the discussion at all which is why I removed it.
Shared between what? Translation units, processes, threads?
To be clear, your choice of words is absolutely acceptable. However, I am a bit sad that you deleted your thread. Please don't delete questions after receiving an answer. This is because you can't find deleted posts in the search. How are future readers supposed to find these answers if your post has been deleted?
Well that's fuckery in itself. Reddit fuckery. Is there a fuckery line in the sand? Can I use the word fuckery at church or in front of my grandma or on TV? Personally, I think that's fuckery in and of itself but I guess my upbringing is was one where respect was based on how one talked to others and words with fuck in them were disdained and fuckery unto themselves .
&gt; Can I use the word fuckery at church or in front of my grandma or on TV? I don't see why not. &gt; Personally, I think that's fuckery in and of itself but I guess my upbringing was one where respect was based on how one talked to others and words with fuck in them were disdained and fuckery unto themselves . I think it's weird how some people are grossed out more by a choice of words than by insults to their intelligence, like participating in this discussion.
Well, though I regard this sub to be on a higher plane than the rest of reddit, look around this place. I mean, how low is one willing to go?
I don't see how the word “fuckery” makes you go “low” (whatever that means). The important thing is the discussion about the subreddit topic and being helpful to beginners. As far as I can see, this subreddit scores very high on these categories. But perhaps I just won't be able to understand the nuances of a weird foreign culture where some words are censored on TV to protect the precious ears of children and easily offended people.
As you called it, it's being "civil". Polite society. Do you walk down the street yelling out to anyone you know in public, "Hey, motherfucker!".
I don't shout at random people in general, but if I did, “Hey motherfucker” wouldn't quite be off the cards.
And that exemplifies why I consider reddit, overall, a low-class gutter dwelling collective.
So what stiff-upper-lip high society do you recommend to peruse instead?
We call it being normal, decent and moral. I've never known it to be stiff-upper-lip. I have no acquaintances or relatives who talk like this and we would avoid anyone who does. 
Perhaps this stems from my different cultural perspective, but I don't consider “fuckery” to be an abnormal, indecent, or amoral word. I don't even consider the word “fuckery” to be a swear word. I am happy for you that you manage to live a life with all these pesky harmful swear words shut out. That's one huge box ticket off on the list of life goals.
As I said, I was brought up as a better person than that.
I'm happy that you found a way to feel superior to me. 
You'd be better off selling support of an already existing OS. But yes you can definitely learn without college, if you're driven.
Post some code. for morse-&gt;alphabet the binary tree is a good solution because you have [multiple char (., _)] to [single char], but the other way around [single char] to [multiple char] doesn't really fit a binary tree since you have just 1 argument, which is the letter. So I would recommend a dictionary as linked ring such as struct letterToMorse{ char[1] letter; char* morseCode; struct letterToMorse* next; } that you will explore sequentially.
No. I already knew that.
C++ is off topic in this subreddit. Please post C++ content elsewhere.
fck me! 
you can declare and initialize char* a; in one file.c and declare: extern char* a; in other .c files. You can dynamically allocate a linked list for a and terminate it by NULL. You could also make different data structures than a linked list by also sharing other different variables ( file1.c: int number; file2.c: extern int number; This makes number a shared variable ) and so on. 
I'd just use an array of structs. A binary tree for 26 elements is overkill.
That is a good idea indeed. I should have used this as well in the first case instead of using a binary tree at all hehe.
You need a newline after each internal loop. 
thanks.
For alphabet to morse, true. But for murder to alphabet, an array is clunky (yes, the array could be easily iterated, comparing strings). This is actually a decently basic example to learn binary trees. 
Such a binary tree is called a [trie](https://en.wikipedia.org/wiki/Trie), the problem with tries is that they take a lot of mem per node, though it's possible to compress tries by various means. Anyway in this case it helps to consider the trie a perfectly balanced tree and store it in an array where the '.' child of the i-th node is the `2*i`-th node and the '_' child is the `2*i+1`-th node. For encoding simply keep a LUT. Proof of concept [here](https://pastebin.com/raw/7Zrd74QU).
You should take a look into spritesheets. Because how you're explaining it looks or at least acts like one. You could use some external libraries like sfml which is a c++ framework. Or sdl which is for c. They usually contain some kind off subimage function where you can create an image out of a part of an image. 
If you want a more interesting and practical application of a tree for coding, check out [Huffman coding](https://www.youtube.com/watch?v=dM6us854Jk0). It's one of the earliest compression algorithms and works a lot like Morse, assigning short codes to common symbols. I've actually written a couple of Morse generators for real products, and they just used lookup tables. The first was very constrained for code space so it used 8 bits to pack the Morse representation of each character, with 2 bits for length and 6 bits for the pattern.
lmao! haha
I would look into finding a library to do this for you. Look into the "pam" or "pnm" libraries; they're free software. There might be more modern choices available.
Your terminology is confusing. C doesn't have "import" When you \#include a file, it literally gets copied into the file that does the include. Header files usually have function declarations, type definitions, declarations of extern variables, etc. Declarations just tell the compiler that something exists; it still had to be defined somewhere.
I changed it. Include sounded a little clunky to me, so my mistake. So does the compiler know to look in the .c file when functions are defined in the .h file? That's really my question. I'm not too familiar with how the linker works. Still new to C. 
Got some sample input matrixes and what the output should be?
640x480 or 600x400?
Or, you know, an array of pointers to strings: const char *l2m[] = { ['e'] = ".", ['t'] = "_", ['i'] = "..", ['a'] = "._", ['n'] = "_.", ['m'] = "__", /* ... */ }; The encoding algorithm is left as an exercise to the reader. BTW, /u/_bush, when you say right for `.` and left for `_`: not that it really matters as long as the output is the same, but it's traditionally the other way around—left for `.` and right for `_`. BTW2: a Morse decoder can also be implemented as a finite state machine. The transition table is simple enough that you can write it out by hand.
you might find this useful... https://en.wikipedia.org/wiki/Include_guard
The linker links object files together, not C source files. They don't even have to have been generated by a C compiler. It doesn't know or care about the source language. Back to C, it's bad practice to define functions in a header file (ignoring inline functions), because it leads to multiple object files defining the same function, which the linker doesn't like.
600 x 400
Added a sample to my post. 
&gt; I think you mean EVERY and EVERY malloc has to have a corresponding free() call. Not really, why?
&gt; Side note: EVERY and EVERY malloc has to have corresponding free() call Not really, why?
Something we can actually use as arguments to that function would be nice.
Ok, I have 3 separate files to run my program so I will put them all in one file so that readers here can copy and paste. 
I have added it to the top of my post now.
Use semaphores. https://linux.die.net/man/7/sem_overview https://stackoverflow.com/a/16400833 etc.
Hi all, Long story short, I have created 4 if statements and just want them to execute only when the user enters that particular letter at the beginning. At the moment it's running them all after each statement is finished 
Do not post pictures of code. Always post code as text and don't forget to put four blanks in front of every line of code so the code comes out readable.
Any comments on whether this is worth sitting through or not?
So what's the error?
The connection fails. It compiles and runs fine, but the client won't establish a connection with the server. The client never gets passed `connect` and the server never gets passed `accept`.
The reason I replied the way I did was that to the OP it seemed there's binary trees or a if() else() jungle. I wanted to highlight a saner alternative. For a learning exercise, there's certainly nothing wrong with the idea.
There are several warnings (with -Wall) you should fix. And your send and recv aren't guaranteed to work well. Since it's a TCP socket, the stream doesn't have any message boundaries you can rely on, instead you need to loop and call recv until you have received all data you expect.
Yes, but what's the error? You pass errno to your frprintf(), but don't actually display it because there's no format codes in the error message... (Use strerror() for a human readable version, or perror() like in your server code.)
&gt; -Wall Completely forgot to compile with that. Solved my problem. Thanks!
Yeah, just noticed that when I compiled with -Wall. The issue got fixed though.
Header files typically contain declarations. A function declaration tells the compiler that the function exists and what its return type and parameters are. The compiler needs to know this to generate machine code that calls the function. When you include the header file in your source file, it copies the contents so that the compiler knows about the things you declared. It would be equally valid, although far more inconvenient, to manually put declarations for the things you use in every source file that uses them instead of including a header. When you compile a source file, an object file is created. The object file maps function and variable names to code and data, but it has no information about the types because the compiler already checked that the types were right. The places where you call a function will have a placeholder that basically tells the linker to put the address of the function there. The linker then looks at all the object files and combines them into one. Once it's a single file, now the addresses of everything are known, and the linker can fill in the placeholders to make the final executable file. Languages like Java and C# do not compile code into native object files. They use their own format which is processed by a VM at runtime. This enables them to store metadata about functions in the compiled file. So, they only need the compiled file for the compiler to know about the functions in it. However, these files can't be linked into a native executable; so, the program will depend on the VM being installed and be slower because everything has to go through the VM instead of being executed directly. (There are other advantages and disadvantages to this way of doing things.) Back to C, since the compiler has no way to store metadata in the object files, it needs declarations to get the full information about the functions. We put these in header files because it's convenient to be able to include them rather than providing them manually every time they're needed. As an analogy, say you need a cake. The bakery has a form that says you need to list the shape, size, and flavor of the cake you want. This is like the header file; it doesn't tell you what steps are involved in baking the cake, but it gives you the information you need to get a cake baked. The recipe at the bakery is like the source file. It has the instructions for baking the cake. You have a to-do list that says you need to get a cake, this is like another source file that calls the cake-baking function. You don't need to know how the cake is baked, but you need their form (the header). The object files are the neurons in your brain that give your body the instructions to follow your to-do list and in the baker's brain that tells him to follow the recipe. The linker tells you the address of the bakery so you can send the form there. The combination of everything forms the executable file. 
What is the difference between "tree" and "trie"?
I love the thumbnail of Patrick playing the drums
Definitely worth it if you're into game dev.
To be honest, your question is still a little confusing. But let's say we have: -- f1.h -- int foo(void); -- f1.c -- #include "f1.h" int foo(void) { return 3; } -- f2.c -- #include "f1.h" // ... printf("%d\n", foo()); So in f2.c, we call the foo() function, which is defined in f1.c. However, f1.c is never included in f2.c. Is that your question? If that's your question, the answer is that, when the compiler compiles f2.c, it has knowledge about the existence of the *symbol* `foo`, but it does not know anything about the implementation of it. The compiler will emit machine code that makes a call to the *symbol* `foo`. Then, separately, when the compiler compiles f1.c, it will emit machine code which is bound to the symbol `foo`. Those two processes will give you `f1.o` and `f2.o`, which are files containing the generated machine code. `f1.o` contains a reference to the `foo` symbol without an implementation. `f2.o` contains the definition of the `foo` symbol. During linking, the linker will match up references and definitions of symbols, regardless of which .o files they're in. (I'm describing a typical compiler setup here. Different compilers may have different naming conventions, etc.)
That helps. Thanks!
Thanks for that. I've seen it implemented in some example code and figured it was something like that. Makes it easier to avoid multiply defined errors. I see that's why header files are recommended way of including files. 
Someone in the thread mentioned include guards, which solves that problem, right? What's the convention for including functions from another c file then?
I haven't checked your code in depth, so I can't claim this is the only mistake, but it is a pretty important one: arrays are 0-indexed, so if you declare an array with size n, only the elements 0 to n-1 will exist. However, you're accessing the elements 1 to n, which exceeds the limits.
 for (i=0; i &lt; row; i++) { for (j=0; j &lt; column; j++) { matrix[i][j] = 88; printf("%c\t", matrix[i][j]); } printf("\n"); } I believe I adjusted it correctly to what you said. It does in fact work with 5 now, but if column=6 it prints the same error as before. I assume it should now work as it is within the array's range, did I miss something? And thanks for the quick reply.
You need to declare (and dimension) the array *after* the size is known. &gt; int i, j, row, column, value, matrix[row][column]; At this point, `row` and `column` are uninitialized variables, so your array `matrix` has an unknown number of rows and an unknown number of columns. Well actually, your problem is a bit more serious than that: using an uninitialized variable at all is undefined behaviour and *anything* could happen. Move your declaration of `matrix` until after you have values in `row` and `column`.
Ah you're totally right, I did not think about that. That fixed the issue. Thanks!
%c is for char, but matrix is an array of ints. Try using %d in the printf. 
For future reference, ensure that sensible compiler warnings are enabled (on gcc or clang, this will be the `-Wall` flag). Your mistake is one that pretty well every modern compiler will be able to warn you about.
I see, ill look into that. That's really useful. Thanks for mentioning.
Just in case, ray tracing is not what you do to render video games. It's too expensive. Modern games use a render pipeline, which transforms a 3D polygon scene into a flat image using successive matrix operations, for which GPUs are optimized.
Okay, so running your program through valgrind gives bunch of errors like this: ==21063== Invalid read of size 8 ==21063== at 0x108925: blocked_ijk_matmul (matrix.c:41) ==21063== by 0x108D3C: main (matrix.c:19) ==21063== Address 0x5201118 is 0 bytes after a block of size 72 alloc'd ==21063== at 0x4C2DB2F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==21063== by 0x108AF3: generate_matrix (matrix.c:72) ==21063== by 0x108D22: main (matrix.c:18) Line 41 is C[(i * n) + j] += A[(i * n) + k] * B[(k * n) + j]; At least some if not all of those array accesses are out of bounds. If you're reading memory that doesn't belong to you, it's not surprising that the results aren't what you expect. There's also a huge number of similar errors in print_matrix().
It's obvious why you're getting the out of bounds array accesses, so I searched a bit for blocked matrix multiplication, and found [this](http://www.netlib.org/utk/papers/autoblock/node2.html). Pay close attention to what that algorithm does that yours doesn't. (And remember it's in fortran or something else with 1 based arrays; a trivial adapation is needed for C).
If you allocate memory and don't free it then your program will have memory leaks. Arguably if it's just a short lived process then this doesn't really matter as the OS will clean up after you when the process exists but you should still use free here or risk getting in to bad habits.
I enjoyed it at 2x speed. (Then again, I watch every video Casey uploads.) Unless you could already knock out a very basic raytracer, without libraries, in about 4 hours entirely from memory, then there's something to learn from this video.
One clarification though. Casey doesn't program in plain C. He's using C++ but limiting himself to a mostly C subset of the language. As an example, he's using function polymorphism. Even though I watched the video, I don't recall if he's using any C++ stuff in this specific case, but since some of the code is copied from his HandMade Hero project, he might have (the matrix operations at least).
Thank you! I'm having a little trouble understanding how to approach this from a code perspective. Cold you explain a bit more what a parser is?
True, but it is trivial to convert his code to pure C if you use a C compiler. His programming style is closer to C than to modern C++.
I don't disagree with you as I'm not a very experienced C developer, but how would you "trivially convert" function polymorphism to a C version earlier than C11 (a version which is missing `_Generic`)?
Rename each variant and manually choose the correct function at each call site. That's what's ultimately happening underneath the C++ version.
Duuh. :D I was thinking too hard on the problem.
I was speaking about his coding style in general not about function polymorphism. There are ways to implement polymorphism in C, if you really needed it, e.g. https://stackoverflow.com/questions/8194250/polymorphism-in-c. However, I think a more C like approach is to use a slightly different function name.
&gt; If you allocate memory and don't free it then your program will have memory leaks. It's only a leak if it's no longer in use... &gt; Arguably if it's just a short lived process then this doesn't really matter It does not matter how long the process lives. If the memory you allocated is in use right up to the end, there is no need to free it. Same thing for closing files and sockets. &gt; risk getting in to bad habits. I'm all for good habits, but I'm not a big fan of [lies-to-children](https://en.wikipedia.org/wiki/Lie-to-children).
I still think you should free every malloc (and close sockets/files fwiw), if only to remove false positives from valgrind etc. It's better to learn to tidy up after yourself too. I really don't think this counts as lying to children.
Did you fix recv as well?
No blog spam please.
you're best bet would be to speak with some recruitment agents specialising in C about the market. it will depend on application because c has many fields but i dont think you will struggle. 
For one, you lack a loop to actually append the string and two, how do you know you have enough space in the destination string?
Why the hell you want go back to c? I went from python to c and really regret it. But to your question, I guess you have enough experience to get a c job. The question is who is offering such jobs: 1. CPU intensive 2. Embedded world 3. GPU programming 4. Lagacy systems (in combination with 1-2) In my company they are always looking for c devs or even cobol, since no one wants to mange the old systems. 
you are searching for the \0 terminator in t and incrementing i until it is at the index in t of \0. You cannot use i as an index into s[] because you need to use another index that starts at the first char in s[]. You also need a second conditional loop to copy all of the chars in s[] into t[]. the condition should again look for the \0 terminator in s[]. int i = 0, k = 0; while(t[i] != 0) { i++ }; while(s[i] != 0) { t[i++] = s[k++]; } t[i] = 0;
Thank you, that is very helpful advice!
That's a fair question. It's partly personal preference - I like to know how systems really work under the hood, and C seems to encourage and reward that kind of knowledge. Secondly its partly economic. I have a theory (unproven) that maybe skills learned as a C programmer have a longer half life than those in higher level languages due to the constantly changing landscape of APIs and packages in those languages. It may be that I am experiencing feelings of "the grass is greener on the other side" however, so I could be wrong about all of this.
Ok sure. It depends on what you do. If you are doing something that really needs c then go for it. I would advice you to be a bit careful with lagacy systems. Since that kind of jobs are more about maintenance and not really development and you lear more if you create new things. 
Thank you!!
there is a mistake in my code... while(s[k] != 0) { .... and no worries
Not yet, I get what you're saying though. This was just a test to make sure messages can be sent.
I've seen that example too but thought that it was doing the same thing as my algorithm, just written slightly differently. Is it the fact that it's using `min(i0 + b - 1, n)` or is my indexing in `C[(i * n) + j] += A[(i * n) + k] * B[(k * n) + j];` off as well?
No
This subreddit is about the C programming language. For existentialist questions, please go to /r/philosophy.
Yep, you got it.
Depending on what sort of work you want to do there is quite a demand for good C/C++ programmers. Especially in finance and IoT at the moment.
A parser is a part of a program that examines tokens and assembles them into some sort of data structure describing the source code. If you think of it in terms of the english language, the parser would take the words in a sentence, and assemble them into something like a sentence diagram. So lets take a look at your example. You're going to want to have a piece called a *lexer* before your parser that identifies *tokens* of the input text. Tokens would be numbers, variables, and operators in your case. The lexer then fills in the fields of a struct for each token, and passes them onto the parser. The parser will read the stream of tokens, and in the case of a parser like bison, will match a number of tokens to a rule/pattern, and run a little piece of code. It might look something like this: add_expr: number ADD_OP add_expr { make_binop(make_number($2), $1, $3);} | number {make_number($1) ; So this rule matches something like `6+2`, because it has a number followed by a plus, followed by another number (which gets matched by add_expr on the second line). Then it feeds those operands to some function that assembles them into a tree, here `make_binop`. 
Would you do embedded systems work? I work in off highway industry. C is being pushed out by matlab simulink, so if you could pick that up, you would be a good fit.
What was your c/c++ experience doing? If it was embedded, you can likely jump right back in. 
Note that LLVM is written in C++ so this is kinda off topic. I think you are going to get better answers in an LLVM specific subreddit. Compiling LLVM is notoriously fickle, I have spend countless times trying to compile it unsuccessfully.
Because C is awesome? I’ve been doing both C and Python for a long time now and I much prefer C. I like being close to the metal and knowing exactly what’s going on under the hood. Python’s great for many things, but at the end of the day I’m a systems hacker. It’s so much more fun to me than high level application development.
LLVM supports plugins! [See here](https://releases.llvm.org/3.6.0/docs/CommandGuide/opt.html) for how to load one into `opt`.
I work at Microsoft, and there's a large amount of C (and C++) code we have to maintain in the OS. Most new development will be done in C++, but C still has a lot of value.
Ok. I didn't want to start a discussion about which language is better. I'm doing c too and I like it. My point was more the WHY, since it's often not about the language. It depends on what kind of system or architecture you are working on. New software is rarely done in pure C you can end up with old, boring systems - that was my point.
did not know there was an LLVM specific sub, thanks
Really? I've compiled it dozens of times (via CMake) and the only problem I've ever had was running out of memory during linking. It's way simpler than building GCC.
Frankly I've been finding that C jobs are getting harder and harder to find unless you work for an open source company like RedHat or Canonical and get paid to work on upstream projects. If I were you, I'd learn Go. It will be easy for you since you know C and the market is really good for Go programmers. That is the transition I made and it is working *really* well for me.
Go? haha
I bet there are more Go jobs than C right now.
Can you post your code and explain what happened that it didn’t work out?
https://i.imgur.com/mHM3DMk.gif
I bet that there are more Rust jobs than Go right now
the thing is i dont have anything yet, because I dont know how or where to start. I cant figure out how to define the color shares r, g and b. And calculate the color value f.
I'm just gonna give it to you straight. C++ seems like the way to go for re-entry into the job, but if you want to be on the bleeding edge, Go is where it's at. I would really like a job in straight C. I love C. But, it's a paranoid time and project managers are choosing to be safe versus performant. As we see with companies like Target, Equifax, etc., you can basically destroy a company's brand equity in 2017 with something as simple as a buffer overflow opening up an attack vector. There's a lot of busted GPL C code out there that has given it a bad name. I don't want to say that C for systems engineering is dead, because it isn't, but the C jobs are basically: - Embedded C for EE grads - Maintenance of ancient C code, usually governmental - Kernel driver writing and that's pretty much it. There're always exceptions, but that's what I've noticed in my job hunt thus far.
Not really. You would define them as a number between 0 and 255, and then only when calculating `f` would you multiply them. So, `int f=r*0x010000+g*0x000100+b;`
How's it going? Did you break the problem down into subtasks?
Don't use a leading zero on constants, because it makes the compiler parse them as octal instead of decimal.
Good doggo, biscuits for you :)
Do you use the default options? I always try enabling LTO and release build and a bunch of other optimizations I've forgotten about, and it doesn't ever build correctly.
Makes sense, thank you!!
&gt; how do you know you have enough space in the destination string? They don't, but then again, `strcat` doesn't know that either. From the main page on Linux: &gt; If dest is not large enough, program behavior is unpredictable; buffer overruns are a favorite avenue for attacking secure programs.
Just did a simple LLVM + Clang build to make sure I had all the commands right. This is typically how I build it: tar xJf ~/llvm-5.0.0.src.tar.xz cd llvm-5.0.0.src/tools/ tar xJf ~/cfe-5.0.0.src.tar.xz mv cfe-5.0.0.src/ clang cd .. mkdir build cd build/ cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=$HOME/.local .. make -kj$(nproc) make install The part that runs out of memory is parallel linking. If it runs out of memory then I just run `make` again without `-j` to retry linking. One thing I never figured out is an installation suffix, like how Debian does it, since I'd like to have multiple versions installed and available at once. 
Oh, I build it from the git repo, and use the CMake gui to create unix makefiles.
As a 20+ year C programmer, I think this is WAY overstated. The linux kernel is written in C. Much of the OSS userland networking code is in C. There is a plethora of devices running the linux kernel out there. I agree that C needs to be replaced, but it won't be by C++, which without constraining your usage of it is as bad as C, but from what I can tell neither Go nor Rust is going to be the replacement. 
buy the code is worth it (15$ i think) some things like his : in-build perf. profiling framework simple build process that allows for insanely fast "code-compile-deploy-test" cycles and many other things that I'm not in a mood to recall are actually pretty generic and can be applied to any native programming language
just fyi.. http://www.hwaci.com/sw/mkhdr/ sample code using this is sqlite, fossil (i think) and other projects by people influenced by Hipp's work
C++ just got support for exactly this with the 2017 standard; I don't see why it couldn't end up in C as well.
That looks pretty good, yeah; that people doesn't write it like that is likely because the comma operator isn't really used productively outside some specific memorised cases. (You have a typo as well, it should probably be e.g. `buffer == NULL` and not `!=`)
Oh, interesting! Can I have a link to the proposal? Though I wonder, why don't you just use the comma operator for this purpose?
I was just talking about the job market at present. As far as the actual engineering underneath, I agree with you.
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0305r0.html The comma only separates expressions; it works fine if you're assigning to some variable that has already been declared, but then you potentially have to leak a variable out of the conditional's scope: object_t obj; // never used in this scope if (obj = foo(), obj.cond) { ... } { // Possible, but — really? object_t obj; if (obj = foo(), obj.cond) { ... } } if (object_t obj = foo(); obj.cond) { // properly scoped ... } This is particularly important in C++, where the lifetime of the object could have side-effects due to RAII, but keeping variable scopes clean is always a good thing even without destructors to worry about (*cf*. for loop initializers).
Thank you! So from this I get that the change probably won't really by all that useful for C as C doesn't have constructors or destructors, removing some need for tight scoping.
'she' is the exactly the type of candidate that fails an interview.
Then say that, but don't tell students that the sky will fall if they fail to free everything they've allocated.
I have no problems with the parentheses, so I prefer that form. But it's the style I grew up with (mostly BSD code) and there's always a strong preference for a style you learned early.
I skimmed to the end. At the end of this video it demos a hello world program. I wouldn't call this advanced. 
Honestly, I tend to forget that the comma operator exists, which is why I usually use the version using parentheses. On the other hand, most code I'm writing these days uses an error-code framework that is generated from a DSL, so the code looks somewhat like errval_t err; err = do_something(); if (err_is_fail(err)) { // notify user about error printf("Error while doing something:\n"); // we get a bunch of nice features from the error DSL, such as error stacks // which can be recovered, including the error description given in the DSL, // and printed as a call stack err_print_calltrace(err); } This has upsides and downsides. The upside is that generally there's just one local `err` variable per function that gets reused for all the error handling, and the number of instances of the check return value of function for negative numbers or null is much smaller. The downside is that we get a lot of functions with output parameters, because most interfaces use the actual return value to return an `errval_t`.
I prefer the first way. It may be confusing your first few times seeing it when first learning C, but once you know what it means, it is easier to read, and shorter.
On program I wrote tried to buffer as much in memory as possible. When allocating space for new memory failed, it would dump the oldest data to make room. But I agree with your general observation: if `malloc` fails, that's usually a sign the program simply can't do what it's being asked, and there's no way to recover. Terminating gracefully is often the only acceptable option.
A database server that fails to allocate enough memory to handle a query could simply clean up, decline the query, and continue to accept and process simpler ones.
1. 9 / 2 2. 99 - 4 3. 8 / 2 4. 7 * 4 5. 95 + 28
I've been thinking of proposing this for C, actually, and thought I'd make a post here to see if there would be interest. Unfortunately, it's not nearly as easy to justify in C as it was in C++.
Why not try it?
FYI this is a C subreddit. C follows the order of operations
Keep in mind that just because malloc() doesn't return NULL does not necessarily mean that the memory you allocated is available. "VM Overcommit" is a thing on many modern OSes - you don't actually get the memory until you step on the pages. Yes, checking for NULL is necessary, but it's not necessarily sufficient on many OSes.
Just to add a bit, you can't sell an OS. Microsoft and Apple can do it because they have very powerful and well supported ones that have legacy systems decades old, but no one will buy yours when Linux is free and most likely 100x better.
Semantically (?), it's what /u/a4qbfb said, but in actuality, if I recall correcly, the exact order of all the operations (those that can be carried on on every step of course) is undefined, as long as the resulting formula is mathematically equivalent. So, for example, the first step could be 8/2 or 9/2, then it could be [7*4 or 9/2] or [99-4 or 8/2] (which pair depends on which operation was carried on on the previous step). It depends on the compiler, and it shouldn't bother you, unless you have code inside the formula that may produce a different result if called in different order (like calls to functions that change and access a global variable or code that changes and accesses the value of a variable), which you shouldn't do under any circumstances.
MISRA C rule 12.10 actually forbids it: &gt;Use of the comma operator is generally detrimental to the readability of code, and the same effect can be achieved by other means. Granted, it's a deliberately conservative standard, but I generally try to stick to it. I think what bothers me most about the example is the mixed use of = and == without parenthesis in a conditional. I wouldn't be surprised if the = threw an unwanted assignment warning in some compilers. I just use the first style, with the exception that I never use ! for checking for null pointers, but always compare against NULL as a reminder that it's a pointer type and to make the intent clear. If the parenthesis are too dense, you can always add white space.
&gt;Yes, checking for NULL is necessary, but it's not necessarily sufficient on many OSes. But that's all you can do. If the OS overcommit, it's the OS's fault, there is hardly any way you can find out if the OS overcommited or not. If you don't get a NULL from malloc, you have to assume you got the memory.
It depends on how critical the thing you're developing is. You can turn off VM overcommits, or use OS specific APIs to query the system's memory status, or....... The point is just to mention that what you learn in "Intro to C" isn't the whole story. 
Ya generally I do the same, where I wrap my allocation functions in an "exit if null" function. Usually I register cleanup with atexit functions so I can bail from anywhere.
From what I understand about EEC, it's just basic math operations performed on very large numbers. I implemented bitcoin's EEC using just a big number library (libgmp) here: https://github.com/bartobri/bitcoin-toolkit/blob/master/src/mods/point.c Note that the code isn't exactly the cleanest. It was a dirty first pass to see if I could get it to work, and it does. Still planning on going back to refine it.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [bartobri/bitcoin-toolkit/.../**point.c** (master → e25183b)](https://github.com/bartobri/bitcoin-toolkit/blob/e25183b9a8a3e8e36c3e2340bfde4f9251bc5060/src/mods/point.c) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
True. I had forgotten that while typing my answer. O well.
I would recommend to detect those kind of problems as quick as possible. Otherwise, those would be harder to be detected as you advance. There are programs that helps doing that, such as checkmarx, but it's always important to prevent those from happening.
You just don't understand the nuance of hello world yet.
Hi there! There are countless situations imaginable in which a failed allocation doesn't bother the rest of the program much. Especially for scenarios which are not critical to the overall execution of the program. In a [plugin I wrote for Notepad++](https://github.com/MIvanchev/NppEventExec) for instance, I have a dialog which allows the user to see what rules are currently executing and to cancel them. The rules are ordered and I allocate memory for a buffer to hold their position strings: "1", "2", "3" etc. Now, if [this allocation](https://github.com/MIvanchev/NppEventExec/blob/master/queue_dlg.c#L647) fails, I just show a placeholder "n/a" instead of a number for the rule(s). It would make no sense to kill a whole functioning unit of software just because a simple position string cannot be allocated. I do like stable, robust code.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [MIvanchev/NppEventExec/.../**queue_dlg.c#L647** (master → a78a579)](https://github.com/MIvanchev/NppEventExec/blob/a78a579921578c1d920946c9c498ecc0a7c3c380/queue_dlg.c#L647) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
This is false, at least in my city. More Go than Rust, though not many of either compared to, for example, Java.
Are you being sarcastic? 
A C library/API should not abort if memory allocation fails; the user of the library should handle that in my opinion
In particular, the program must exit without allocating even more space for error messages. Tread carefully!
["Handling out-of-memory conditions in C"](https://eli.thegreenplace.net/2009/10/30/handling-out-of-memory-conditions-in-c/) by Eli Bendersky is a nice overview of the most common approaches to handling allocation failures.
In a library, I generally try to handle this case gracefully because I can never know the circumstances under which somebody uses my library. Gracefully means that I try one of the following strategies: * try to release some memory and try again * use a different method that doesn't require dynamic memory allocation; for example, when generating an error message fails for this reason, I use a statically allocated emergency buffer instead and accept possible truncation. * report an error to the user When I write an application instead of a library, I am much less strict because I can assess resource availability at design time and make the informed decision to terminate or restart the application in this circumstance. However, whatever I do, I always handle the error in some way. Not checking the return value of `malloc` is almost always wrong.
I wrote [this implementation](https://github.com/fuzxxl/digest/blob/master/sha2.c) a while ago by transcribing the implementation from the Go standard library. It should be trivial to make it one shot.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [fuzxxl/digest/.../**sha2.c** (master → 1ce5817)](https://github.com/fuzxxl/digest/blob/1ce58173b89dc7f662d632d0a9ec653719cfafdb/sha2.c) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
As a beginner I think you should work to find any of those bugs as they spend a lot of your time later. It's true that there are programs, like checkmarx, that might help with it but it is recommended to know how to detect those as you code. Good luck.
I just switched jobs from doing C at one company to doing C at another (both firmware, both linux OS). Do you have any stats to back up what you're saying?
how is that supposed to be helpful? there's not even libgcrypt used in there.
**I haven't found a simple and working example of using Libgcrypt with ECC -- eliptic curves. Is there any?**
Have you tried cranking up the compiler warnings and fixing all of them?
 -------------- Clean: Debug in Pong (compiler: GNU GCC Compiler)--------------- Cleaned "Pong - Debug" -------------- Build: Debug in Pong (compiler: GNU GCC Compiler)--------------- x86_64-w64-mingw32-gcc.exe -fexpensive-optimizations -w -Wfatal-errors -Wextra -std=c99 -g -I.\SDL2\include -c C:\Users\ingframin\OneDrive\projects\Pong\CPongC\ball.c -o obj\Debug\ball.o x86_64-w64-mingw32-gcc.exe -fexpensive-optimizations -w -Wfatal-errors -Wextra -std=c99 -g -I.\SDL2\include -c C:\Users\ingframin\OneDrive\projects\Pong\CPongC\main.c -o obj\Debug\main.o x86_64-w64-mingw32-gcc.exe -fexpensive-optimizations -w -Wfatal-errors -Wextra -std=c99 -g -I.\SDL2\include -c C:\Users\ingframin\OneDrive\projects\Pong\CPongC\player.c -o obj\Debug\player.o x86_64-w64-mingw32-gcc.exe -fexpensive-optimizations -w -Wfatal-errors -Wextra -std=c99 -g -I.\SDL2\include -c C:\Users\ingframin\OneDrive\projects\Pong\CPongC\text.c -o obj\Debug\text.o x86_64-w64-mingw32-gcc.exe -fexpensive-optimizations -w -Wfatal-errors -Wextra -std=c99 -g -I.\SDL2\include -c C:\Users\ingframin\OneDrive\projects\Pong\CPongC\utils.c -o obj\Debug\utils.o x86_64-w64-mingw32-g++.exe -L.\SDL2\lib -o bin\Debug\Pong.exe obj\Debug\ball.o obj\Debug\main.o obj\Debug\player.o obj\Debug\text.o obj\Debug\utils.o -lmingw32 -lSDL2main -lSDL2 -lSDL2_image -lSDL2_ttf -lSDL2_mixer Output file is bin\Debug\Pong.exe with size 197.66 KB Process terminated with status 0 (0 minute(s), 1 second(s)) 0 error(s), 0 warning(s) (0 minute(s), 1 second(s)) :'( Yes
Hm... Try to compile with optimizations turned on. gcc is much better at detecting errors when the optimizer analyses your source code.
Death with dignity. *sniff*-
No, it’s anecdotal. But, yeah - there are certain jobs where I see that C still dominates and firmware is in that wheelhouse of things, as it should. Firmware engineers like yourself who want to move laterally shouldn’t have an issue. You can ride the train to retirement. It’s those of us who want to work or re-enter that need to be concerned about how to “specialize” ourselves.
I got it! Buffer overflow ;-) First of all I realized that warnings were disabled... I would not be able to realize it without your hint. Secondly the problem was sprintf... I changed it with snprintf and now it works perfectly! Thanks a lot for your help! 
You made my day! :)
&gt; I recall correcly, the exact order of all the operations (those that can be carried on on every step of course) is undefined, as long as the resulting formula is mathematically equivalent. That is always the case with C, as per the “as if” rule. In fact, if you actually wrote `int x = 99 - 9 / 2 + 7 * (8 / 2);` in a program, the compiler will most likely produce the equivalent of `int x = 123;` instead.
Note that `if ( void *buffer = malloc(size) )` is already possible in C++; the C++17 addition is the second clause. Which is necessary if the thing you want to test isn't just the variable you're declaring implicitly converted to bool.
Misra is cancer IMO. If I can make an analogy to builders: it's like having to have their tools glued to their hands. Yeah if the builder is a bumbling incompetent in the first place then this will stop them dropping their tool on someone's head, but for good builders it just handicaps them and results in a shoddier final product.
Precisely what I've noticed.
&gt;I always find these difficult to read because of the high amount of parentheses bunched together. I guess you'll never be a LISP programmer then :)
Aside from all the cases others have already mentioned, I sometimes write programs that attempt to grab a fairly aggressively sized chunk of memory to use as a buffer, or similar, for performance reasons. If this large allocation fails, I can often make do with a much smaller allocation, and will re-attempt to allocate the buffer at a smaller size. As others have said, most situations still call for bailing if you can't allocate what you wanted to.
Another option (I wrote mine reading the SHA-256 papers and tested it against the OpenSSL implementation)...: https://github.com/boazsegev/facil.io/tree/master/lib/facil/bscrypt The `bscrypt` library can be easily torn for parts. Basically, just use the [`bscrypt-common.h`](https://github.com/boazsegev/facil.io/blob/c2b3589d89d0846b31c42e5f45edf0210acf46be/lib/facil/bscrypt/bscrypt/bscrypt-common.h) for endieness detection and than use the [sha256.h](https://github.com/boazsegev/facil.io/blob/c2b3589d89d0846b31c42e5f45edf0210acf46be/lib/facil/bscrypt/bscrypt/sha1.h) and [sha256.c](https://github.com/boazsegev/facil.io/blob/c2b3589d89d0846b31c42e5f45edf0210acf46be/lib/facil/bscrypt/bscrypt/sha1.c) files. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [boazsegev/facil.io/.../**bscrypt** (master → c2b3589)](https://github.com/boazsegev/facil.io/tree/c2b3589d89d0846b31c42e5f45edf0210acf46be/lib/facil/bscrypt) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply doucvdr.)^.
You may very well be right. Thanks for the thoughtful response.
Yes.
I have not done any testing at this point, but it seems to me that the comma form that explicitly results in two expressions has the potential to impede compiler optimizations versus the first form containing assignment and equality testing in a single expression. Without testing I don't want to jump the gun, but this being C, I generally avoid any change that harms performance.
MISRA doesn't say you can't do a thing, it just makes you document why you're doing it if you're going to go against a rule. I've been programming in C for 25 years. I remember a time when I was proud of my mastery of operator precedence and how much I could cram into a single statement. Now, it's all about clarity and safe coding habits.
What have you tried? Can you read one number from user input? Can you write a loop? Are you stuck on how to track the data?
Honestly, I’m stuck on everything. I’ve only ever written one code and it was nowhere near this difficult for me. 
Break it down into steps. Right a simple loop. Then write a way to get used input. Then combine the two to get input multiple times. Always break it down and go piece by piece
See that’s just it. I don’t know how to write a loop or use input
Dude, literally `while () { }` What condition do you want to break on? When the user has entered 10 integers, right? Go from there.
I currently just log it, but i've been thinking about exiting lately. I just don't like how many times I check each and every damn variable to make sure it's not null, once a variable has been determined to be non-null, it doesn't need to be checked again.
Wait, what? You're trying to tell if a number is divisible by both 2 and 3? for what purpose? Anyway, to do that, just do if (Number % 2 == 0 &amp;&amp; Number % 3 == 0) { // The Number is divisible by both 2 and 3 }
That's my bad they were meant to be two separate questions
What OS?
Looks really good, unfortunately it says MIT, which actually requires inclusion of the license notice in both source and binary distributions. Currently my project doesn't have a "show legal information" command yet because I haven't used a library that requires it, doesn't seem worth adding one just for a sha function.
Bretty bad. Not advanced at all. There aren't so much **really advanced** C tutors on youtube, but number of these helloworlds is overwhelming.
The mod function (%) is your way to go. It basically gives you the remainder. 5%3 returns 2. 6%3 and 6%2 both return 0 letting you know 6 is divisible by 2 or 3. 
iOS I just realized that I'm not passing the top level name in the array. However, how do I read the value as string with {CTL_HW, HW_MACHINE} as the argument?
That’s as far as I got and as far as I know how to do. I don’t know how to go from there. 
I literally just fucking said that dude...
You want to use the mod operator. Something like x % 3 == 0 to test if it's divisible by 3 and x % 2 == 0 to test if x is divisible by 2.
I write for embedded phones, PA speakers, and other VoIP hardware. Since it's embedded and has limited memory, we always have to check for null and handle it somehow. If we dereference null, the whole thing will crash and reboot, which is clearly undesirable. In our case, the error usually bubbles up until it gets to a point where the "current operation" can be aborted. That might be the network message it was trying to send, or the call it was trying to start, or the ringtone it was trying to play. Yeah, it might mean the phone doesn't do what you wanted it to, but the other 7 calls and audio streams it was processing will keep going, which is better than the whole thing rebooting.
I doubt that even if any performance difference existed, it would be unmeasurably small. 
The spelling error you pointed out grinds my gears a bit.
If you run into issues with that, the modulus operator may work. Try something like this: switch(x % 6) { case 0: //divisible by 2 and 3 break; case 1: case 5: //not divisible by 2 or 3 break; case 2: case 4: //divisible by 2 but not 3 break; case 3: //divisible by 3 but not 2 break; default: //you need a new compiler }
That looks like it could use a factory and maybe some synchronization.
Do you have a book? Notes? Have you searched for “write a loop in C”?
What does your choice of editor or IDE have to do with anything? It's programming language and OS that matter. [Beej's Guide](http://beej.us/guide/bgnet/output/html/multipage/index.html) is a good online resource.
Because not all of us are whiny crybaby little bitches like you.
You're doing it wrong. Write the code for humans, not the computer. Set performance targets. Then profile it. Work on the hotspot until you meet the performance target. Then move on to the next task.
No notes, but I just found my book online. It talks about while loops, but not for multiple inputs like this
Typically for `&gt;` and `&lt;`, you want to use `dup2` to assign to FDs 0 and 1, without involving any explicit pipery. There might be a FIFO on the back end, but that’s handled without the shell’s understanding or involvement. Piping is a separate matter from the `&lt;`/`&gt;` kind of redirection; the latter uses a file for input/output, whereas the former requires a program sitting there on both sides of the pipe—i.e., instead of a file, a pipe’s operand is an entire command, possibly with its own redirections (even another pipe with its own sub-command) and definitely with its own `argv` array(s). Unless your shell is actually generating or receiving the data on one end or the other, or unless you’ve incorporated enough logic for your shell to be used as an intermediary (e.g., `while read; do echo; done` sorts of things), you shouldn’t need to manually hand data around. Which means `bytesRead`, `readBuffer`, and `fd` are superfluous, as is the (unchecked, unterminated) call to `pipe`. Also, this function should probably return `int`, so that if you fail you can hand off an `errno` or other code vs. 0 for success. All kindsa shit can go wrong when trying to run something—`pipe` could fail (not that it’s necessary AFAICT), `fork` could fail, either `open` could fail, `exec` could fail… All you do is `perror` in one possible case, without the caller being able to notice. It’s also probably better to use two `if`s and an `else` to handle the three PID cases: if((pid = fork()) &lt; 0) { ... ; return errno;} if(pid) { /* parent */ } else { /* child */ } `switch` is typically better for when you have *mostly* specific, non-`default` cases, or for larger numbers of cases.
👍👍👍 voted you up
Have you tried casting? uint32_t Width = (uint32_t)ReadBits(32); Basically, you compiler complains that 64 bit do not fit into 32 bit. By casting you tell it to shut up, because you know what you are doing.
I could do that, but it'd clutter the shit outta my code :/
Depending on your compiler you could try to deactivate this specific warning.
&gt; it'd clutter the shit outta my code That's what you get for cheating the type system. I still think that casting is the right thing to do here, because it conveys the right message to the compiler and a human reader. One other way could be to provide multiple functions (`ReadBits32`,`ReadBits64`) with different return types. But I don't like this as much.
The code works... Just not when i compile thru sublime text(using minigw). I used to have a similar problem when I first switched to qt, I had to link the win32 library for example. Beej's guide is great and I have been using it for years. Thats not my question lol..
What you're asking for is what dynamically typed languages and languages with fat runtimes are good for. i.e. runtime *clutter* C is explicitly typed, allowing the compiler to eliminate any runtime checks for types which are ultimately the number of bytes allocated or moved or pushed. For example, how many bytes would the function you're asking for need to push and pull from the stack when "void int" is passed to it? This all translates to assembly code, and there's no instructions for abstract unsized integers. TL;DR: extremely incompatible C's philosophy &amp; strengths IMO
I was just explaining how it works, ***dude***
I think you may have chosen the wrong idiom for your function. The correct idiom depends on a number of factors: Is `Bits2Read` an arbitrary number, or is it always a power of two or a multiple of 8? What happens if `Bits2Read` is greater than 64? What happens if `Bits2Read` exceeds the number of bits left in the buffer? Where does the data in the buffer come from? Is the source just a stream of bits or bytes, or does it have a higher-order structure? If the latter, what is the original byte order? BTW, the `const` in your prototype has no effect.
It's not clear to me why you'd declare `ReadBits` to return a `uint64_t` and then assign it to a `uint32_t`. If you know the returned value fits in a `uint32_t`, why not declare ReadBits to return a `uint32_t`. In general, ReadBits should be declared to return a type consistent with the maximum value it can return. You're passing ReadBits a byte, which could, at most contain 8 bits? Or, did you mean to pass it a `uint8_t *` ? In any event, callers need to use the same type or they risk ReadBit returning a value that's too large for them to represent. Note: the type in C to use for buffers sizes and counts is `size_t` - but of course you should use something else if it's more appropriate to your situation. 
Your `sStructure` is a `struct sockaddr_in`, i.e. an IPv4 address, but `connect()` supports more than just IPv4. As a sort of poor man's polymorphism, it expects a pointer to `struct sockaddr` which shares a preamble with all address types, including an integer that indicates the protocol being used. This means you have to cast `&amp;sStructure` to either `struct sockaddr *` or `void *` when calling `connect()`.
It sounds like you need to invest a few hours into a C tutorial, have a go at the assignment then get back to us with any specific bits you're stuck on.
You can't pass a sockaddr_in pointer to something expecting a sockaddr pointer, without a cast. That line you posted will not compile.
If the compiler uses an SSA representation (which good compilers generally do) there should not be any difference in the SSA generated because the value assigned is immediately reused in both cases.
If your function returns a 64 bit value, you should really keep track of the whole 64 bit trough the rest of your program. Everything else is a recipe for hard to find bugs in case you try to refactor your program. You could of course also just turn off the warning. It's just a warning after all.
`hash` is declared to be a pointer to `Hash`. Where does `hash` point to? Before you can dereference a pointer, you need to make it point somewhere, either by allocating memory or by declaring a variable of type `hash` and pointing to it: Hash h, *hash = &amp;h; You could also remove the `*` from the declaration of `hash` and make `hash` a structure instead of a pointer to a structure. `int y = 13` doesn't seem to be the problem here.
The declaration of `y` is irrelevant. `hash` is an uninitialized pointer, and you invoke undefined behavior by trying to dereference it with `hash-&gt;v`. Also, when allocating memory for a string, you are computing the size based on the size required for eight pointers to char, not eight chars. And don't try to obfuscate basic types like `char *` behind a typedef.
Because i want to be able to return anywhere from 1-64 bits, and i have to return an integer of some sort. Because ReadBits isn't optimized for 1 specific variable, it has to work with any kind... I'm passing it a uint8_t because there's no smaller value, and it's just the number of bits to read. In the function definition it's checked to make sure Bits2Read is between 1-64. I simplified the examples to remove extraneous details, like the buffer pointer to read the bits from.
I know that `int y` was not the problem, Thanks a lot, this helped me. but why when I comment the `int y = 13;` every think goes Okay ? even with the first declaration `Hash *hash;`
Bits2Read can be anything between 1 and 64 inclusive. 
Friends, the posted link is a playlist of complete Advanced C Programming and above video is the first video of the series and there are total 18 videos which covers all the concepts of C. Please go through all the videos and you won't be disappointed. I assure you. Click on the Title of the post - Advance C Programming Video Tutorial. You will be redirected to the playlist of 18 videos.
Aha, I see, thanks a lot. but I didn't get the point about string allocation. Also for the base issue with initializing pointers, why when I comment the `int y = 13` the code compiled successfully without any errors?
&gt; but I didn't get the point about string allocation. You're calculating the size for eight pointers, not eight chars. &gt; why when I comment the int y = 13 the code compiled successfully without any errors? That's the nature of undefined behavior. You have no guarantees of what will happen when you invoke UB. Sometimes you get a crash, sometimes things appear to work. It depends on countless minor details. In this case, having that extra variable on the stack alters the layout slightly such that `hash` happens to have a value that points to invalid memory and causes a segfault. But by sheer chance, `hash` could also point to valid memory. That doesn't mean dereferencing it is in any way correct, it just means that you don't get an immediate segfault; the error would likely manifest in some other way, such as random corruption of something, or a later segfault. 
Undefined behaviour (which is what you get when dereferencing an uninitialised pointer) is weird like that. It might appear to just work as intended or break horribly.
The second example assumes that a pointer is wide enough to store an int. That's probably going to be true for most platforms you will ever encounter, but it's not a guarantee; it's implementation-dependent. But assuming that it is, as long as the caller and the callee agree, you can do that sort of thing. Your first example is risky because you have to be very careful about the object lifetimes. `x` is a local variable and its lifetime ends as soon as control leaves the scope it was defined in. If that happens soon after the call to `pthread_create()` then you have a race condition, because there's a chance that the thread will attempt to read `x`'s value after it's life has ended, which invokes undefined behavior. You can only do this if you use a synchronization primitive to ensure that there is no race condition. For example, the main thread could wait for all of the other threads to end before terminating. In simple example code like this it's very easy to convince yourself that there's no problem, but in more elaborate real-world scenarios it's very easy to make this mistake inadvertently. 
Yeah, the tutorial is doing it wrong. Don't do that.
Friends, the posted link is a playlist of complete Advanced C Programming and above video is the first video of the series and there are total 18 videos which covers all the concepts of C. Please go through all the videos and you won't be disappointed. I assure you. Click on the Title of the post - Advance C Programming Video Tutorial. You will be redirected to the playlist of 18 videos.
For the second example you can make sure that `sizeof(int) &lt;= sizeof(void *)` by using a `static_assert` -- this way at least you'll get a notice about it.
I see now, Thanks a lot.
the both points are clear now, Thank you.
MISRA is too far in the other direction IMO.
Friends, the posted link is a playlist of complete Advanced C Programming and above video is the first video of the series and there are total 18 videos which covers all the concepts of C. Please go through all the videos and you won't be disappointed. I assure you. Click on the Title of the post - Advance C Programming Video Tutorial. You will be redirected to the playlist of 18 videos. 
Thanks
The best way to learn C is by learning from the founder of this language Dennis M. Ritchie. You can buy his book from Amazon: C Programming Language, 2nd Edition Paperback. About how you can start, I suggest you use Linux or Mac, so you can start easily from the terminal.
Loops and getting input is not related. You are not going to just the answer on this sub, so I think you should do a little more learning. Understand what loops are used for to begin with.
LLNL's tutorial is bad and they should feel bad. A nit: in your version, the cast to `void *` is unnecessary. The cast back to `int *` is not, though.
Hmm on my cell phone the playlist doesn't seem to be working. I will check on my pc.
`static_assert()` is C++.
Playlist is not good anyway. These are basics, nothing advanced here.
If this is your own file you're creating, you could add meta data at the top, like how many numbers the file has. If not, you can create a buffer and when it runs out realloc the buffer so is oldsize + 1000 or whatever. If you don't want extra space, realloc back down to trim. Another way would be to do it in two passes, first read the file and count how many numbers there are without storing them, and then in a second pass create your buffer and store them.
Make a linked list of buffers and then at the end turn it into a single array if you need that or just use the list as is.
For a more blatant example of a similar: int fn1() { int a = 5; int *b = &amp;a; return *b; } int fn2() { int a; int *b; return *b; } int main() { int c = fn1(); int d = fn2(); printf("%d, %d\n",c,d); return 0; } When compiled without optimizations, it will print 5, 5, despite the fact that fn2 accesses uninitialized memory. However, turning on optimizations or even minute changes to this program outside the definition of fn2 can cause the program to segfault. For example, if you remove the definitions of c and d, and move the function calls directly inside the print call, which is a change which clearly should never break anything, can cause the order of the function calls to change and the program to fail. Why does this happen? Most programming languages higher-level than C contain a lot of checks to make sure that if you do forbidden things, like access uninitialized values, you either get a compiler error, or at least a runtime error at the point where things are broken. These checks are great for programming, as they tell you where your code is broken. However, these checks take up computing power, and as C strives to be as low-level and fast as possible, it doesn't have them. Segfaults are a minimal kind of protection provided by the CPU and the operating system when you access a pointer whose current value is outside the address space currently mapped for your program. This means the pointer cannot possibly have been correct, your program has to have been in error, and should be terminated. This memory protection has a major disadvantage when compared to for example, java: While having a segfault means that your program incorrectly used pointers, not having a segfault does **not** mean that your code wasn't incorrectly using pointers. It's possible that you instead just incorrectly used a pointer that happened to point somewhere that belonged to your program, but that is still not a valid place to point to. In your case, the uninitialized value of hash pointed *somewhere*. Removing that declaration somehow made *somewhere* be within the bounds of your program. It still wasn't a valid pointer to Hash, it might have pointed on top of some other structure and writing to it might have broken something later. That is, your code was still broken, the operating system just didn't know it was so it couldn't tell you. So, unlike in, say, java, when your code is broken it's not possible to fix it by making small "random" changes until it's fixed. It's entirely possible to make the error go away, without the code being correct. When you get a segmentation fault, you need to stop making changes to the code, first figure out where you are going wrong, and then fix it. For figuring out what is wrong with your code, I recommend firstly that you compile with all warnings turned on. With gcc, adding the argument -Wall would have made this trivial to solve, as it immediately tells you what is wrong: testF.c:19:10: warning: ‘hash’ is used uninitialized in this function [-Wuninitialized] Val *v = hash-&gt;v; Modern compilers have very nice warnings, in general you should always have them all on, and if they print any you should work to make them go away before doing anything else. For clang and gcc, you should compile with -Wall -Wextra, and for cl.exe (visual studio) you should compile with at least /W3. Secondly, if warnings didn't help, you need to either use a debugger or a lot of printf statements liberally sprinkled around the code, just to print out all the values of everything to confirm that they are what they should be before and after they are used. 
From the manual page for `fscanf`: &gt; On success, these functions return the number of input items success‐ fully matched and assigned; this can be fewer than provided for, or even zero, in the event of an early matching failure. &gt; &gt; The value EOF is returned if the end of input is reached before either the first successful conversion or a matching failure occurs. EOF is also returned if a read error occurs, in which case the error indicator for the stream (see ferror(3)) is set, and errno is set to indicate the error. Each time you call `fscanf`, you can check its return value to see whether you have reached the end of the file. If you do this, you don't need to call `feof` at all.
You might be able to work out why the extra integer definition changes the program behaviour by disassembling the computer output. (It likely also depends on the optimization level.) GDB can do this with the disassemble command, and you can go one machine instruction at a time with stepi. I suggest turning on the Intel disassembly flavour option because AT&amp;T syntax is brain damaged. If you aren't using GCC with GDB on an Intel Linux box then you may need different tools.
If you only return values in the range 1-64, why not make the return value an int or a uint8_t?
&gt; Why is the const extraneous though? I don't edit that variable in the function body? It's not extraneous - i.e. it does have an effect. It's just somewhat unconventional. Since C only support pass-by-reference (as opposed to reference parameters in C++ or var parameters in Pascal), people usually don't bother with making non-point arguments const because modifying them does not effect the caller of the function. I've seen people advocating for using const everywhere possible and I do see their point. It's just that the syntax gets a bit overwhelming. 
Ended up chopping up LibTomCrypt to create my own simple sha256 library [lonesha256](https://github.com/BareRose/lonesha256). Just a sha256 function and nothing else, no funky platform- or endian-specific stuff either.
[Check out helper.c](https://github.com/ahester57/fib_memo?files=1) helper.c counts line numbers and then can be used to od other stuff. It's a quick hack so don't think this is the best way to do it.
There are a few approaches, before each read you could malloc a new buffer and keep track of it and how full it is, someone suggested a linked list. Or process your file in buffer length sections. This is probably how most realistic programs would work. You could also put a file header that lets you calculate the memory size before you process, I have used this approach for image processing applications where it was useful to have the whole image in memory. 
Why is the file size unknown? Your file system definitely knows the file size...use it. Stat the file size (man 2 stat), then parse the resulting stat structure for st_size member.
while like many I'm often guilty of skim reading wikipedia articles, however its well worth taking your time to read this one... https://en.wikipedia.org/wiki/Struct_(C_programming_language) 
My suggestion is to move the *n &lt; size* inside the while loop, in a separate if block. If n == size and you didn't reached the file end use the [realloc](http://en.cppreference.com/w/c/memory/realloc) function to increase the size of your dynamic array. 
I see what you guys are saying thank you. Its strange that it compiles and works successfully under codeblocks using GCC. It shouldn't matter what compiler/ide I use.I was just curious why. 
`stat()` and `fstat()` aren't part of the C file API. Those are system-specific APIs. The C APIs only know `ftell()` and `fgetpos()`, but those can't tell you the size of the file. The stream associated with the `FILE*` might not even be a regular file. It might be `stdin`, or it might be something with a filename that isn't a regular file, like a pipe or socket. In those cases, it probably doesn't have a meaningful or knowable "file size".
I may be wrong but isn't the next problem that h-&gt;v is also an unitialized pointer?
Your first malloc allocates the wrong amount of space
First, get rid of "typedef char * string". It in no way helps, and just makes things more confusing. Second, "declarations" don't "throw seg faults". Invalid declarations are compile time errors. Invalid memory accesses cause segmentation faults. Do you get an error when compiling, running, or both? Those are different.
Look into realloc(). You can do an initial malloc() and check how much data you've read in. If you're going to overflow you can realloc with twice the size. Then twice that size, and so on so you grow by powers of 2. This is a common method for expanding the size of stacks and lists. 
Touche'. Guess I've been coding in a POSIX environment for too long.
Why not ask a more specific question?
Would you happen to know the best way to scan in input up until a /n is entered? 
Possibly.
I was trying to learn more about how they work and hoping I could answer my question that way. However my question is how to sort a struct of pointers. struct record { char first_name[21]; char last_name[21]; float grade; }; ... void sortScore (struct record *t, int numRec) { printf("Sorting by student score: \n"); int i,j, temp; for (i=0; i&lt;numRec-1; i++) { for(j=0; j&lt;numRec-i-1; j++) { if((t)-&gt;grade &gt; (t+i)-&gt;grade) { temp = (t)-&gt;grade; (t)-&gt;grade = (t+1)-&gt;grade; (t+1)-&gt;grade = temp; } } } printf("The sorted grades are: \n"); for(i=0; i&lt;numRec; i++) { printf("First name: %s, Last Name: %s, Score: %.2f\n",(t+i)-&gt;first_name,(t+i)-&gt;last_name,(t+i)-&gt;grade); } printf("\n\n"); } That's my struct and then a function trying to use a bubblesort to sort the grades. Only some of the grades are actually sorted and when it prints, the grades aren't lined up with the first/last name the user entered. Any ideas to help set me on track?
You should provide some sample input. And turn up your compiler warnings. You have undefined behavior in that last printf that your compiler should be warning you about. 
While char is not ‘\n’ Read another char
Simple array: char t[32]; char *p = t; Here t is a synonym to &amp;t[0], the address of the first member. In fact, &amp;t, &amp;t[0] and t are all synonymous; so the address of an array is also the address of its first element. When declaring a multidimensional array: char u[32][65]; Then what is u ? You told us that the address pointed by u would be the address of the first (N-1)-dimensional array. Isn't the address of a given array also the address of its first element ? Yes it is. So both are true.
The relationship between arrays and pointers is often misunderstood and poorly explained. I'll try to clear up some things. First, lets forget about multidimensional arrays for a second and just focus on arrays. One important thing to know: arrays and pointers are not the same thing. There's a relationship, but they are separate entities. Try to keep them separate in your head. Let's start by creating an array: int array[5]; array: ------------------------------- | | | | | | ------------------------------- 0x0C 0x10 0x14 0x18 0x1C Simple enough. You can see five contiguous integers, uninitialized, starting at the address 0x0C. When we want to access something in the array, we use the syntax `array[3]`, which will give us the third element from the start of `array` (at address 0x18). On the other hand, we can have a pointer: int* ptr = &amp;array[0]; ptr: ------- |0x0C | ------- 0x20 We've initialized this to point at the first element of the array. Where people get confused is that pointers can be accessed like arrays. They aren't arrays, but you can use them like one, as long as they point to somewhere inside an array that lives somewhere else. In this case `ptr[3]` is the exact same thing as `array[3]`, accessing the element at 0x18. but instead of just going to the offset from the start of the array, it goes from the offset stored in the pointer (which happens to be the start of an array). Further confusing people, under certain conditions *arrays can "decay" into pointers*. While I explicitly initialized that pointer to the address of the first element, I could have written: int* ptr = array; Think of this as a shortcut, if you want. The end result is the same: `ptr` hold the address of the first element, 0x18. Probably the most common place to see this decay is when calling a function (the easiest way to pass an array is via a pointer plus the array's size). Ok, what about multidimentional arrays? int mdarray[3][5]; mdarray: ------------------------------- | | | | | | ------------------------------- 0x24 0x28 0x2C 0x30 0x34 ------------------------------- | | | | | | ------------------------------- 0x38 0x3C 0x40 0x44 0x48 ------------------------------- | | | | | | ------------------------------- 0x4C 0x50 0x54 0x58 0x5C Notice that even though I've presented this as three rows of five elements, it's actually one contiguous block of memory. The compiler knows how to jump to the right element when you do `mdarray[1][3]` (0x44) via some simple math as an offset from the start of `mdarray`. But, there's another way of making multidimensional arrays! For example: int* ragged[3] = { mdarray[0], mdarray[1], mdarray[2] }; ragged: ------------------- |0x24 |0x38 |0x4C | ------------------- 0x60 This, I believe, is what you're talking about in your third paragraph. Here, `ragged` is an array of three pointers. I've initialized those pointers to be the first elements (via pointer decay) of the rows of `mdarray`. But notice that these three arrays don't have to be contiguous at all, they could live in completely different places in memory from each other. They don't even have to have the same length, which is why I used the name "ragged." We can treat `ragged` like a 2D array, though. `ragged[1][3]` does the same thing as `mdarray[1][3]`, but the mechanism is different. `mdarray[1]` provides the second row of the array, which is a pointer to 0x38. `[3]` treats this pointer as an array, giving the fourth index from there, or 0x44. There's another, less common way of doing this: int (*ptrmdarray)[5] = mdarray; ptrmdarray: ------- |0x24 | ------- 0x64 This declares `ptrmdarray` as a pointer to an array of 5. Those parentheses really flip things around from the last example. Now we know that each row has five elements in it, and everything has to be contiguous, but we don't know how many of them there are. This is similar to the original `ptr` example, but with a more complex thing being pointed to than just an `int`. And, of course, we can access it just like the last couple examples: `ptrmdarray[1][3]` gives the same result, this time as a simple offset from whatever is in `ptrmdarray`. Just for completeness, I though I'd show two more: int (*parray)[5] = &amp;array; int (*pmdarray)[3][5] = &amp;mdarray; This is how you declare pointers to the arrays. Though in this case, you have to dereference the pointers before using (`(*parray)[3]` and `(*pmdarray)[1][3]`). It's pretty rare to see this actually used, though.
You need to swap the entire array elements, not just one field of them. Can you use qsort()? That'd make it a lot simpler.
 temp = (t)-&gt;grade; (t)-&gt;grade = (t+1)-&gt;grade; (t+1)-&gt;grade = temp; You're only swapping the grades here, when you should be swapping the entire structure, like this: struct record temp; temp = *t; *t = *(t + 1); *(t + 1) = temp;
Please put four blanks in front of every line of code so the code appears readably.
I think there are a lot of good ideas here but what Koshfra said (make two passes) is perhaps the most straightforward. Something like this ... int countNumbers(const char *fileName) { int count = -1; FILE *f = fopen(fileName, "r"); if(f) { int tmp = 0; for(count++; fscanf(f, "%d", &amp;tmp) == 1; count++) ; fclose(f); } return(count); }
How do you specifically tell it to sort by grade? Also thank you. 
My apologies. 
We haven't learned that yet. :(
Didn’t you already post before? I mean, if you can’t figure out pointers after 10 years, this really isn’t your language. However, if you want it to be your language, then learn pointers first before interrupts and timers and whatever else. You cannot go anywhere in C without pointers and they’re not difficult at all once you practice using them.
Good time to learn, then.
Check out Jack Ganssle. Start playing with rtosses and don't use Arduino. Start with a breakout board from Atmel(Microchip), like an Xplained board, load up Atmel Studio and a sample project, and go from there. I design embedded for a living and that's how I'd recommend starting out today if I had to do it all over again.
nearly there.. int square = function(value1);
You are forgetting to assign the return value of the function1 to some integer. square variable is local to the function1 so you can only "see it's value" in that function. You should do: int square = function(value1); for example.
thank you good sir!
thank you!
Depending on your environment, there should be a delay_ms(), sleep(), or some other function to create a delay. A better way is the set up an alarm and a callback, or schedule a tick event
no problem, does it work now?. You should study the different scope of variables, local and global.
Thanks for the reply. I haven't posted before on reddit but thanks for your thoughts I'll take a look! Marc
Thanks, lots of good Ganssle books on his website - Ill take a look!
We were all there at one point. I assure you. Would be nice if you could learn to indent a bit and maybe use better names for things. The function "function" is pretty generic. How about calling it "square_me" or "sqr_of_int" for example? Also, and this is just an idea, you don't need to call "pow" to square that integer. You can just say foo = value1 * value1; That will let you throw away the include for math.h right there and your code becomes even more simple. Simple is good. In any case, if your system has the C Beautifier handy ( cb ) you can run that through "cb -s " and bingo it will be neatly indented for you. 
You put an if statement in front of the swap comparing the grades.
in what way is the *not* a regular linked list? Each node points to the next one. Free each node in turn until you get to the end of the list.
[zlog](https://github.com/HardySimpson/zlog) and [log4c](http://log4c.sourceforge.net/) require way to much configuration just to produce a simple log file. I really liked [log.c](https://github.com/rxi/log.c) but I wanted to more easily support multiple output streams. Unsatisfied with the current logging landscape I just wrote a dirt simple logger.
But what can you actually do on the board to learn? Making an LED blink or something isn't particularly useful or complex.
if((t)-&gt;grade &gt; (t+i)-&gt;grade) like that? I'm confused on using the arrow (-&gt;) vs the dot 
This pretty much cleared a lot for me, but also made me realize an error in thought, precisely because I was assuming that an array is a pointer. What I was describing was an array variable with a separate storage, that referred to the contiguous memory block. 
Right, I was thinking of it the wrong way (and maybe I still am about certain things). I made the assumption that, like a pointer, there is a storage space for that particular variable - that an array variable as separate storage space from the sequence of memory in which it pulls information from.
Arrows access members of pointers dots access variable members. Student * t; Would be t-&gt;grade And Student x; Would be accessed with X.grade
I'm not sure I've ever seen a real C program using scanf() from stdin that wasn't a homework problem... OP, your question has already been answered but I'm just going to add don't ever name a function 'function'. Get in the habit now of giving your functions meaningful names.
This fixed it, thank you very much!
&gt;I haven't really progressed so much. I wonder why. &gt;Ive been typing C for about 10 years now Now I know why.
it works fine! lol, don't worry, i already know c++ and java, i'm just doing c again for old times sake!!
lol, i already indent, just that reddit's stupid formatting messes everything up
well, i just use scanf_s in VS i'm using codeblocks right now, so i just use scanf(); 
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;conio.h&gt; #include &lt;math.h&gt; #include &lt;float.h&gt; #define CADUSD 0.822274 //(current CADUSA value as of 2017-05-25 01:08:43 PM) #define LKRUSD 0.0065 #define EURUSD 1.17 #define USDLKR 152.87 #define USDFRK 0.98 #define USDEUR 0.85 #define USDCAD 1.25 float convertedCurrency; float outputAmount; float inputAmount; char inputCurrency; char outputCurrency; void inputCanada(float); void inputLanka(float); void inputEuro(float); void outputLanka(float); void outputSwiss(float); void outputEuro(float); void outputCanada(float); void currencyTo(void); int main() { char C, c, L, l; printf("Please enter the currency you would like to convert FROM (C = CAD; L = LKR; E = EUR): "); scanf("%c", &amp;inputCurrency); fflush(stdin); switch (inputCurrency) { case 'C': case 'c': printf("You have chosen Canadian Dollars... \n"); printf("Please enter the amount: $"); scanf("%f", &amp;inputAmount); inputCanada(inputAmount); currencyTo(); printf("\n\nYou're converted amount is %.2f\n\n", outputAmount); break; exit(0); case 'L': case'l': printf("You have chosen Sri Lankan Rupees... \n"); printf("Please enter the amount: Rs."); scanf("%f", &amp;inputAmount); inputLanka(inputAmount); currencyTo(); printf("\n\nYou're converted amount is %.2f\n\n", outputAmount); break; case 'E': case'e': printf("You have chosen Euros... \n"); printf("Please enter the amount: €."); scanf("%f", &amp;inputAmount); inputEuro(inputAmount); currencyTo(); printf("\n\nYou're converted amount is %.2f\n\n", outputAmount); break; exit(0); default: printf("\n\n\nYou have chosen an incorrect option, please try again later... Goodbye!\n\n\n"); break; exit(0); } exit(0); getchar(); return 0; } void currencyTo() { char outputCurrency; char L, l; printf("\nPlease enter the currency you would like to convert TO (L = LKR; S = FRK; E = EUR; C = CAD): "); scanf(" %c", &amp;outputCurrency); switch (outputCurrency) { case 'L': case 'l': printf("Thank You...\n"); outputLanka(convertedCurrency); break; case 'S': case 's': printf("Thank You... \n"); outputSwiss(convertedCurrency); break; case 'E': case 'e': printf("Thank You... \n"); outputEuro(convertedCurrency); break; case 'C': case 'c': printf("Thank You... \n"); outputCanada(convertedCurrency); break; } } void inputCanada(float inputAmount) { convertedCurrency = inputAmount*CADUSD; } void inputLanka(float inputAmount) { convertedCurrency = inputAmount*LKRUSD; } void inputEuro(float inputAmount) { convertedCurrency = inputAmount*EURUSD; } void outputLanka(float convertedCurrency) { outputAmount = convertedCurrency*USDLKR; } void outputSwiss(float convertedCurrency) { outputAmount = convertedCurrency*USDFRK; } void outputEuro(float convertedCurrency) { outputAmount = convertedCurrency*USDEUR; } void outputCanada(float convertedCurrency) { outputAmount = convertedCurrency*USDCAD; }
here's a source that i made for one of my apps: https://www.dropbox.com/s/i9rqrang5mldr0h/cashconverterSHARE.cpp?dl=0 check the indenting ;)
10 years? Hoping u meant to say 10 hours
You can always push your source, with line numbering, through sed and cat : $ cat -n foo.c | sed 's/^/\ \ \ \ /' ready for cut and paste into reddit. Unless you are on winblows and there just is no help for that situation. Get linux!
Add comments to every line of your function, describing what it does. It does, indeed, look like that function only copies the 'grade' field between structs. How might you change it to also move the other info?
Because 64 bits can't be held in an int at once, and the entire point is to read a field as a single unit...
Readable code. void sortScore (struct record *t, int numRec) { printf("Sorting by student score: \n"); int i,j, temp; for (i=0; i&lt;numRec-1; i++){ for(j=0; j&lt;numRec-i-1; j++){ if((t)-&gt;grade &gt; (t+i)-&gt;grade) { temp = (t)-&gt;grade; (t)-&gt;grade = (t+1)-&gt;grade; (t+1)-&gt;grade = temp; } } } printf("The sorted grades are: \n"); for(i=0; i&lt;numRec; i++) { printf("First name: %s, Last Name: %s, Score: %.2f\n",(t+i)-&gt;first_name,(t+i)-&gt;last_name,(t+i)-&gt;grade); } printf("\n\n"); }
Make that LED blink to send out a Morse code, challenging enough?
Atmel studio provides ASF framework, so it should be quite easy to have the drivers set up for you. But if it doesn't work, then it can be a pain to get it working. Good experience and you'll learn a lot. 
I wish you were my 'C' Sensei when I was learning C. Made it so easy to understand, noobs will appreciate it.
Nice, and simple one! :) Maybe one little thing I'd miss is a configurable log level, so I don't need to always write something like `if (degug) {...}` in my code. 
That's a strange question to ask for someone who already knows C++ and Java.
&gt; if((t)-&gt;grade &gt; (t+i)-&gt;grade) { &gt; temp = (t)-&gt;grade; &gt; (t)-&gt;grade = (t+1)-&gt;grade; &gt; (t+1)-&gt;grade = temp; &gt; } &gt; Is it tee plus eye or tee plus one? Regardless, there is something strange about `sortScore()`. Please post the complete program, or at least include the part that calls `sortScore()`.
lol I broke it
C will probably never die as per its unique beauty and simplicity and freedom. 
Well no, that is just a slight variation on the same problem
Couple of suggestions: 1. A nice feature most log libraries have is supporting a run-time log level. If I run my app with `--log-level debug`, I see more output than if I run with `--log-level error`. Obviously the method of setting it would be on the user, not you. You just need to support filtering. 2. Your `_log` function is not thread safe because of the use of `localtime`. Obviously writing to the same file from different threads is never thread safe, but it should be allowed to write to different files in separate threads.
I really wish it were header only. But great job, it really is easy to use. Also first time I heard of Unlicense.
&gt; But very few people seem to write code this way. Which style do you prefer? Are there any other good ways to express this idiom? Discuss. I totally did not know the comma operator can be used like this. This is much more readable!
Quick question, why do you add all your includes to the header? You only really need`stdio.h`, right? Everything else could go into the c file.
Ya I mostly just wanted to reduce executable size for large projects. It should be pretty easy to make into a single header if you wanted to fork it, since the .c file has everything right there.
It's more of a style thing. I've found that on large projects it's easier to see everything a library needs (from libc) in the header then to have to look in two places. I usually go with putting as many non dependencies (that a user might not have headers for) in the .h as possible, although I know this style varies between people and companies.
I like that idea for (1) so I may look into setting up some sort of filter. For (2) I know it's not thread safe, but I'm wondering if it's worth fixing. Do you think it's worth bringing in all of pthread to implement a locking mechanism?
But it's really *not* a style thing. You include your .h into your other files - you *don't* include the .c file anywhere. Say I have 3 files that look like this: main.c: #include "example.h" int main() {} example.h: #ifndef EXAMPLE_H #define EXAMPLE_H #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;pthread.h&gt; #endif example.c: #include "example.h" Now if I compile with `gcc *.c`, I'll get a driver which has included `stdio.h`, `stdlib.h`, `string.h`, and `pthread.h`. If I move those includes into the .c file, they will only be included *in that .c file*. So as a user of your library, I now have more control over which libraries are being included in my own projects.
I believe it would be worth doing. Most applications where I want logging are either multithreaded or multiprocess (your library plays well in this case), so having a thread safe logger is a must for me. See my recommendations in a separate comment (currently writing up now).
A variety of notes as I go through the codebase. None of these are in a particular order. * Have only one `log` function. Passing an enum or macro constant to the function would set the debug level for output. For example `log(level, stream, format, ...)` would be much easier to refactor if a different log level was desired. * Additionally, you could implement `log` as a macro that conditionally calls an underlying free function based on the current debug level. Using a set of `#if`s, you could remove the runtime overhead of logging not required for the current debug level, either at compile time (define DEBUG_LEVEL_LOG, WARN, ERROR, etc...), or most of the overhead at runtime (via a CLI flag --log-level=warn, ...).
Just to be picky: fscanf(f, "%d", &amp;tmp) is enough, **1** is equal to the **true** assertion in C.
That's true. Generally in the environments I've worked in there hasn't been a specific use case where it mattered for files from libc, but I understand where you're coming from.
Awesome thanks!
&gt; Hi all, Ive been typing C for about 10 years.... 'Typing C' is an unusual statement to make. Do you mean 'programming in C'? And if you *have* been programming in C for 10 years what types of programs have you written?
Awesome. Thanks!
Thanks for your input. Yep I've been programming in C :-) Ive made pretty sophisticated end of line test rigs. I've done some projects such as fm radios, gps trackers, controllers. All of which I've done sequentially and used polling inputs, I just want to learn more. Do you know of any other good resources. thanks
I'm an absolute beginner myself. I was just really curious about your background, because of the 'typing C' thing, and also because I was under the impression that it's hard to do much serious C programming without using pointers. I didn't want to make any assumptions so thanks for clarifying. Sorry I don't have a helpful response for you post though.
Change is made. Thanks for help!
Since log level is usually global for a project, do you think it would be a good idea to have one global configuration for the log settings in the log.c and then have the user explicitly set that level through a function call, or do you think the log level should be able to be configured differently from different portions of a project?
 /usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crt1.o: In function `_start': (.text+0x20): undefined reference to `main' collect2: error: ld returned 1 exit status barf 
The arrow is just shorthand: a-&gt;b == (*a).b (a+i)-&gt;b == a[i].b
It's tee plus one. I'm calling the sortScore in a switch statement. The program in to take in a first name, last name, and grade input from the user (they can enter 5 to 15 student records) then they have a menu to choose from (the switch statement) which includes printing records, searching first/last name, sorting grades/last name and lastly finding min/max scores. I tried changing that part of the function to: if((t)-&gt;grade &gt; (t+i)-&gt;grade) { temp=*t; *t = *(t+1); *(t+1) = temp; } However it's only swapping the first two numbers. 
When I do either of those it gives me an error that grade is not something in a structure or union.
`t[i].grade` should work the same as `(t+i)-&gt;grade` if `t` has type `struct record *`. Not sure what code you actually tried.
Wait I'm an idiot. It works, thanks. 
`t` *decays to* `&amp;t[0]`, but it isn’t synonymous with it; `&amp;t` gives you a `char (*)[32]`, whereas `&amp;&amp;t[0]` isn’t permissible.
Yup thanks for your help