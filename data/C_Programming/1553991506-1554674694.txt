Man, I never knew you could use the values of an enum without having to declare a variable of the enum type and setting it to one of the values first. Thanks a lot!
You can think of the preprocessor as a sort of code editor that operates on the code before it gets passed to the compiler. The preprocessor operates on "#" directives. The #if directive tells the preprocessor to optionally keep or remove what comes after it until the matching #else or #endif. And what comes after the #else is removed or kept with the opposite sense. In your case, you have "#if 0". Since 0 is false, the preprocessor will remove everything between the #if and the #else. And it will keep everything between the #else and the #endif. The "return NULL;" statement is not inside the #if/#endif block. Thus the preprocessor doesn't do anything to it. That means that the statement remains in the code untouched, as does all the other code outside the #if/#endif block. Thus the final code that gets sent to the compiler is everything before the #if, then everything between the #else and the #endif, and then everything following the #endif.
Using the Editor is more torture than training. Get npp.
The error says there is no binary, that is not a C issue.
what do you think it might mean?
Hi there, Welcome to C :). It looks like eclipse cannot find the libraries you have added in your include statements. Therefore when eclipse tries to use your complier to make the executable it cannot do that. After this step eclipse looks for the binary to run and cannot find it. This is likely an issue with your eclipse settings of where it's looking for those files/libraries. 
This [StackOverflow answer may be relevant](https://stackoverflow.com/questions/17023235/eclipse-cdt-project-built-but-launch-failed-binary-not-found)
I do have np++! 
So I'm being told! Haha. Would you mind elaborating as to why, please? Just trying to understand the reasoning. 
You can use named indices in c99, but you will have to define the values somewhere. #include &lt;stdio.h&gt; enum myNames { DOG = 2, CAT = 4, RAT = 8, }; const char *animal_names[] = { [DOG] = "Dog", [CAT] = "Cat", [RAT] = "Rat", }; void main(void) { printf("%s\n", animal_names[DOG]); printf("%s\n", animal_names[RAT]); } 
Look on the web. Maybe it does not find the binary to gcc. And add "return 0;" after your printf statement ;-)
First, save your file. Second, you need to build the project before you can launch it. The build process produces a binary if everything compiled okay. Third, you should `return 0;` before `main` terminates.
No, if you create an anonymous enum you can use it just like a define. enum { ENUM_1, ENUM_2, ENUM_3, NUM_ENUM }; void func(int n) { if (n == ENUM_1) ... } func(ENUM_3) int array[NUM_ENUM]; 
Not a language issue
In one of the C standards(don't really remember in which one) function defenition "foo(){}" is equivalent to "int foo(int a){}" so you still can pass parameters. Also, I think you can pass parametrs through process registers using inline assembly. Or use variable allocated on stack with alloca.
Thanks so much! Very interesting example. Would you recommend doing problems (from something like leetcode) and conferring solutions, or going through a book and covering advanced subjects like this first? I took a course this winter about C but it never included this stuff, although I understood just about everything else in the solution presented in that github.
Is this a security course? What is the purpose of your assignment?
[Almost all.](http://www.clifford.at/icestorm/) And [a new one](https://symbiflow.github.io/).
Best beginning tips? I'm starting out and I'm terrified that I may be making a mistake because I don't understand right away.
&gt; and a lot of the reputation C gets for being scary and weird comes from corner cases with publicity? Yes. Also the fact that C has been independently implemented on anything from 8-bit microcontrollers up, on any machine that's byte-addressable, which leads to some quirky implementations. Like Microsoft's. Where I just got finished debugging, because I decided to macro-in `_aligned_malloc()` and then forgot about it. 
&gt; Most people start out with a high level language and get used to the luxury of having pre-coded "vectors", "exceptions", or "stringstreams" at their fingertip. Or strings without pointers, or with dynamic typing. 
Separate the idea of pointers -- a memory address that points to something else -- from the syntax of how to access them. Read out loud, right to left: `int *number;` means *variable number, a pointer to an int*. Right to left: `char *mystring;` means *mystring, a pointer to a character* but really that means *mystring, a pointer to a character array which is another way of saying "string"*. In C, a pointer to a string (char array) is the same as the address of the first element of an array of chars making up that string. 
Because a decent code editor will at least ha e syntax highlighting and keyboard shortcuts to help you navigate code. The better ones will have plugins for autocomplete, linting, etc. And that's before jumping to a full-blown IDE. Do yourself a favor, use an editor designed with programming in mind. Everyone has written code in notepad ot something like it, but if you're serious about it you will eventually find a better tool to use. I think it'll help you, not hurt you.
Write code often. If you don't understand a concept, experiment with it. If something goes wrong, figure out what went wrong. Don't be afraid of mistakes, if you don't make them you won't learn anything new. bonus tip: Keep a notebook of all the cool features, mistakes, and eureka moments that you've had while coding. 
Is the OS/environment specified? If you can't use globals or parameters you could change something about the environment (like `nice()` or setting `errno`). It's a hacky solution and not much to do with C programming but since the sensible ways to do it are restricted you might as well. 
That's incredible that it took that long to load emacs. I wonder how long the original vi took.
Rabble rabble!! 
Make lots of mistakes, it's the fastest way to learn. 
Are you using pointers to the actual nodes in the array? How are you retrieving the items from the array? How do you want to traverse the tree? Generally, if you're doing depth-first tree traversal, you need to process the items in a first in, last out order, i.e. a stack.
Oh I didn't even consider using stacks. Thank you! 
Because the implemention of scanf. Its better to use fgets instead.
Yep what you did is fine. I would do {} but I actually kinda like your way
I think you need to put a `space`, between input qualifiers in `scanf`.
If you really wanted to, you could reach into the return address of chooseOperationType() with something nasty like int \*i = &amp;i + 2; Insane, obviously, and spesific to cpu, OS, compiler, ...
Hello, my teacher has replied and has confirmed that its unreasonable that chooseOperationType() have no passed parameters and have made corrections. Now I just need to remove the global variable in my code. Thanks for your help.
Hello, my teacher has replied and has confirmed that its unreasonable that chooseOperationType() have no passed parameters and have made corrections. Now I just need to remove the global variable in my code. Thanks for your help, I'll try reading up on function pointers later since it has been not discussed yet.
Hello, my teacher has replied and has confirmed that its unreasonable that chooseOperationType() have no passed parameters and have made corrections. Now I just need to remove the global variable in my code. Thanks for your help.
It's Computer Engineering ((focused only in C language)). My teacher said that the restrictions are there to help us find ways of working around the restrictions.
Hello, my teacher has replied and has confirmed that its unreasonable that chooseOperationType() have no passed parameters and have made corrections. Now I just need to remove the global variable in my code. Thanks for your help.
Or just a environment where you don't need to make any use of your mouse like Vim or Emacs :)
Try `%s` in place of `%c`. You can then specify the length, and accept whole words, not just a single character. When you call this with `scanf`, you can drop the '&amp;': `scanf("%s%f%d", b1.name, &amp;b1.price, &amp;b1.pages);` You should also consider the way you are structuring your program. Nesting inside of main is okay for small programs, but good to get in the practice of separating this. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct Books { char name[10]; float price; int pages; }; int main(void) { struct Books B1, B2, B3; printf("Enter name, price, and number of pages for Book 1:\n"); scanf("%s%f%d", B1.name, &amp;B1.price, &amp;B1.pages); printf("Enter name, price, and number of pages for Book 2:\n"); scanf("%s%f%d", B2.name, &amp;B2.price, &amp;B2.pages); printf("Enter name, price, and number of pages for Book 3:\n"); scanf("%s%f%d", B3.name, &amp;B3.price, &amp;B3.pages); printf("\nHere is what you have entered:\n"); printf("%s\t%.2f\t%d\n", B1.name, B1.price, B1.pages); printf("%s\t%.2f\t%d\n", B2.name, B2.price, B2.pages); printf("%s\t%.2f\t%d\n", B3.name, B3.price, B3.pages); return 0; } Output now: $ gcc reddit_books.c &amp;&amp; ./a.out Enter name, price, and number of pages for Book 1: Thomas 19.40 334 Enter name, price, and number of pages for Book 2: TheTank 33.87 929 Enter name, price, and number of pages for Book 3: Engine 11.03 200 Here is what you have entered: Thomas 19.40 334 TheTank 33.87 929 Engine 11.03 200 &amp;#x200B;
Notepad has absolutely no coding features. No automatic intendation, no syntax hilighting... If you don’t want an IDE, get a decent editor. Notepad++ is ok, at least for beginners, IMO.
Is there such a thing as an IDE that will not compile before launching? Sounds terrible!
thank you. Now i understand. Just can you tell why we need a space then %c so that the compiler doesnt count a /n?
&gt; Because the implemention of scanf. Its better to use fgets instead. thank you
will try fgets function
This post sums it up https://stackoverflow.com/a/13543113. The %c conversion specifier won't automatically skip any leading whitespace, so if there's a stray newline in the input stream (from a previous entry, for example) the scanf call will consume it immediately. &gt;One way around the problem is to put a blank space before the conversion specifier in the format string: &gt; &gt;scanf(" %c", &amp;c); &gt; &gt;The blank in the format string tells scanf to skip leading whitespace, and the first non-whitespace character will be read with the %c conversion specifier. 
aha..got it thanks.
I don't if i am correct. You might try this. ptr=&amp;a. Pointer ptr holds the address of array a. I am new. I dont understand what do you want your code to do? Also i think the array that you declared is.....not what you actually want. Or is it? If you want to initialize the first element a\[0\[=a,a\[1\]=1, try this char array\[\]={"a","b",...};
String literals always contain a hidden NUL byte at the end so `sizeof(array)` inside the function is actually 11, not 10. This causes a buffer overflow. 
Array when used in most expressions becomes a pointer to the first element. This is what op was looking for in this case. &amp;array is a pointer to the array as a whole (it has the type `char (*)[10]`). This is rarely used as it'd be a readonly pointer regardless, arrays can't be assigned a new address. 
yeah bro!
Hi Morth, Thanks for the rpl but i think that's not where the issue sits, since the output says : `size of the array is 10` ... 
Sorry I'm a bit sick so have a it hard time typing. But basically sizeof(array) is 10 in main but 11 in the other function (where the array name refers to a different array). That's your problem. 
Hi Morth, Thank you very much and YES! That's solved my confusion! 
&gt;l but i think that's not where the issue sits, since the output says : &gt; &gt;size of the array is 10 &gt; &gt; ... i get it now. 
Cool, thank you. 
:-) thanks for showing me another way to do it, too! 
You'll actually notice notepad++ open in the background (to the left of notepad). Was taking notes on it and coding in notepad... Haha! 
it's a pretty undescriptive message thou
Perhaps /r/cpp_questions is a better sub?
Oh I feel even further like an idiot :(, thank you I will post there.
 include&lt;stdio.h&gt; int main() { char inputString[128]; printf("Enter a multi line string( press ';' to end input)\n"); scanf("%[^;]s", inputString); printf("Input String = %s", inputString); return 0; } From my phone but should be close. 
Yes, this is a pointer to a pointer. As you might already know, pointers are also used to represent arrays. char** is therefore often times an array consisting of char arrays or in other terms: an array of c strings. 
It is a pointer to a pointer. They are often used in the context of arrays of strings or other 2+ dimensional data. Strings are just arrays of characters terminated with a `\0` character. You can use a pointer to point to a location along an array of data. `array[3]` is the same as `*(array+3)`, and `array` itself actually stores a pointer to the first element of its data. When passed as an argument to a function, array syntax actually decays to pointer syntax, so a function signature like `main(int argc, char *argv[])` is basically equivalent to `main(int argc, char **argv)`.
Your code is working perfectly as of now in my system. But it contains a serious bug. You are printing the array of characters using a limit. It wont work when you'll print it with any of the standard output functions like puts() or printf(). Therefore, make the size to be 11 and place a '\\0' character at the end.
It is also used as a more [tasteful way to remove a node from a linked list](https://medium.com/@bartobri/applying-the-linus-tarvolds-good-taste-coding-requirement-99749f37684a)
From stackoverflow: If you want to have a list of characters (a word), you can use char *word If you want a list of words (a sentence), you can use char **sentence If you want a list of sentences (a monologue), you can use char ***monologue If you want a list of monologues (a biography), you can use char ****biography If you want a list of biographies (a bio-library), you can use char *****biolibrary If you want a list of bio-libraries (a ??lol), you can use char ******lol ... ... 
Yeah I use vim but I saw that he was using Windows.
So those parts of pointers I understand. What I'm struggling is with pointers for multi-dimensional arrays. I don't know if I should move forward with what I know and get the basics out of the way and get better at them through projects. 
If I had listened to sage advice from grey-beards about using vim or emacs when just starting out, I’d have quit. When starting out coding, people want to see the machine do cool shit, and without too much hassle. It’s why programming is exciting. Making noobs learn an expert tool that out of the box comes with defaults meant for 1968, and requires learning its own archaic customization language that is useless outside of the editor itself, is just a horrid idea, tbh. I’d at least recommend VSCode or something. No need to make the younguns suffer needlessly. 
Yes, you should move forward and work on code, and build your confidence level. Two-dimensional arrays are common, but [more levels of indirection than that](http://wiki.c2.com/?ThreeStarProgrammer) is fairly rare, and good code usually avoids it. Don't forget to add comments and write code for clarity! Yesterday I looked at a moderately-elegant piece of pointer work I wrote quite a long time ago, and I still had to think moderately deeply about how I'd done it. It wasn't particularly intuitive to me now, much later and with much more recent experience. 
I would do this: sscanf(argv[1], "%d/%d", &amp;numerator, &amp;denominator); You can also do your method with `strchr` instead of searching for the character yourself. Or `strtok` for a function that does it all, but `sscanf` is best IMO.
Thing is, im giving a const char\* as an argument and i would need the %d s to be strings in order for my other functions to work. Would sscanf work for this?
Both have their benefits. I personally like going through a book first just to get the work passed to me in a order that makes sense. Doing problems like the ones on leetcode are also good because they force you just to try to do the work and how to do research. However, I've never really worked with those sites much and have just picked a project that interested me and start working on that instead. Downsides to that are it can be hard to find something you want to work on, and the sites like that expose you to a variety of tasks not just ones you would want to work on. 
Consider this: A pointer is really just an integer value. It's an integer value that references a memory address. A *single* memory address (known as the first-available byte). &amp;#x200B; We interpret how much memory to read from that first-available byte by using the data type of the pointer. So if I have an int pointer to some memory address 0x00001000 , I would say that some int variable "x" belongs to memory addresses 0x00001000 to 0x00001003 (that's four bytes). &amp;#x200B; That's all there is to it for a pointer. Now as another commenter pointed out, char\*\* is often another way of writing char\[\] argv in a C main function. They are synonymous with each other. The array syntax "\[ \]" is really a *syntactic sugar* for " \*\* ". int main(int argc, char argv\[\]) { `//int argc represents the number of strings in an input buffer called "stdin".` `//char[] or char** argv represents the strings themselves, often used for command line arguments.` return 0; } You might be a bit confused as to *how* an "integer-like value" can reference a memory address. To help aid your confusion let me introduce you to a hardware component known as the [Memory Management Unit or MMU for short](https://en.wikipedia.org/wiki/Memory_management_unit). When your C code (or any programming language) gets compiled, references to pointers get translated into instructions to the CPU to read or write to some memory address/addresses in RAM (also can be CPU cache memory but ignore this for now if you're not familiar with cache memory yet). &amp;#x200B; So basically the way that it works is that when your C code needs to reference some location in memory, it's handled for you. There's a hardware component called the MMU whose sole purpose is to handle these instructions for you, otherwise the CPU-to-RAM communication model (called the "Von Neumann Architecture") would not be possible. &amp;#x200B; All *you* need to worry about with pointers is a few things: &amp;#x200B; 1) Since pointers are *integer-like* we can treat them the same way we would treat integers. This is called *pointer-arithmetic.* If `int* x_ptr`, some integer pointer I just made up, points to fictional memory address "1000" (simplified down without 0x notation to make it easier), then doing `x_ptr = x_ptr + 1;` is the same as doing "1000 + 4\*1". We're multiplying by 4 because that's the *size of* an int value. So to be consistent with memory sizes, when we add 1 we would really be adding *four*. We multiply the number we're adding by the size of the data type before we add it to the pointer. Normally it's bad practice to work with pointers this way but this is to explain how they work underneath the hood and more importantly *why arrays are able to work.* Since `x_ptr = x_ptr + 1;` is the same as doing something like "1000 + 4\*1", then `x_ptr = x_ptr + 2;` is the same as doing something like "1000 + 4\*2", because the same logic applies. We do the *location* of x\_ptr + *the size of x\_ptr* \* *the number we are adding*. It may not be immediately obvious but that's the same as saying "int fictional\_array\[2\]". Notice that the *number we are adding* is the same as the array index. This is how arrays work underneath the hood and if you understand how arrays work, now you understand how pointers to pointers work. So `char** argv is really the same thing as char argv[].` &amp;#x200B; 2) You need to check that your pointer does not point to null. A null pointer means a reference to a particular memory address that is basically used to mean "dead-end". Most compilers operate by a principle that if you tried to read a null pointer, your program will crash. This is because the operating system needs to stop programs from trying to read memory that does not belong to the program as this is a general tactic that malicious programs use to damage systems. &amp;#x200B; 3) You need to clean up any dynamic memory you make. Pointers help us keep track of things in memory, they let us know exactly where something is. If we call malloc() or a similar function to find and give us new memory (from what is called the "heap"), we need to free() the memory later to give it back to the system. Failing to do this will leave some memory reserved and unused for as long as your program runs. This is an issue called a "memory leak". Good code practice involves ensuring no memory leaks occur. &amp;#x200B; Hope this helps.
 char array[] = {"abcdefghij"}; // you are not supposed to put brackets there afaik
strtol to get the first number, and it will give a pointer to where the '/' is. Change the / to a null terminator and increment the pointer. Now you have a numerator and a denominator string. I can write some code when I get back to my computer if you'd like.
Yes that would be amazing! Kinda struggling to put those words into code :( 
Here's a minimal example: const char number[] = "123/456"; //using array brackets specifically so we can modify this string, if you can't modify it then copy it over char *numerator, *denominator; numerator = number; strtol(numerator, &amp;denominator, 10); *denominator = 0; denominator++; printf("%s / %s\n", numerator, denominator); // prints "123 / 456" This only works for numbers formatted exactly as n1/n2, if you want other formats you'll need to do slightly more work. Read up on strtol if you don't understand how it works.
Use fgets (or a similar function to read from stdin) in a while loop, and use break to get out of the loop.
Ah my bad. I forgot to mention that im working with a large integer api. that means i cant use stroi since it would overflow. appreciate the code tho thanks a lot!. I just looking to split "123 / 456" that is a const char* str into two strings.
If you’re on Linux, you might be able to use `strace` or its equivalent and look for futex calls.
If you read my code, you'll notice that both numerator and denominator are strings, not ints. Also, the return value of strtol is ignored because it is assumed to be overflown anyway. Strtol is only used to find out how long the numerator is and where the '/' is. Alternatively, you could use `while(isdigit(*denominator)) denominator++;` instead of strtol. I only used strtol because it's an easy function and the first thing that came to mind.
* means pointer, ** means pointer to pointer, *** means pointer to pointer to pointer, etc. Generally, arrays are declared using the same syntax, in that case it's a 1D, 2D, 3D array.
I'm looking for something within C and dont want to use bash commands. 
Ah makes sense now. Do you mind telling me why you wrote *denominator = 0? 
Introducing the [Three Star Programmer](http://wiki.c2.com/?ThreeStarProgrammer).
https://www.eskimo.com/~scs/cclass/int/sx8.html
It's mostly just fancy string manip and space saving. The idea is that if your string is "123/456" (without spaces, if you want spaces then you'll have to check for those too), it's changing the '/' character to a null terminator so that the numerator string knows where to stop. The denominator string already has a null terminator at the end implicitly because of the string literal.
You can implement what you need of `strace` in your own program. `fork` with a pipe for synchro, child sets `PTRACE_TRACEME` and pokes through pipe, parent `ptrace`s it using `PTRACE_SYSCALL` once it’ poked, and then your parent can filter through to see which system calls are futex ones. Probably want it to deliver them to the child through a shared memory segment created in the parent. Child can clear the futex count immediately before going into the test, then give it a few ms and xchg it with zero afterwards and you’ll have a reasonably good count. (Not perfect; might be off if the monitor’s running really slowly. You could use a socket or pipe pair for synchro, so the child can start/stop the parent and read until empty.)
I'm intermediate myself, and honestly the only thing that I know I don't know, is how recursion works.
TIL I'm a 4 star programmer, well until I refactored my code to use a huge 1D array instead for 3D images.
Phew, that's great to hear. Glad it was that easy!
How are you with algorithms and data structures? I found going through [CLRS](https://en.wikipedia.org/wiki/Introduction_to_Algorithms) to learn unfamiliar topics helped me a lot. How are you with architecture? Check out Hennessy and Patterson; either [Computer Architecture: A Quantitative Approach](https://www.amazon.com/Computer-Architecture-Quantitative-John-Hennessy/dp/012383872X) for a more in depth review or [Computer Organization and Design](https://www.amazon.com/Computer-Organization-Design-MIPS-Architecture/dp/0124077269) if you want a lighter text. Both are amazing books, but some people find the former to be more than they need. Operating systems? [Modern Operating Systems](https://en.wikipedia.org/wiki/Modern_Operating_Systems) by Tanenbaum. Networks? [Computer Networks](https://www.amazon.com/Computer-Networks-Andrew-S-Tanenbaum-ebook/dp/B006Y1BKGC) again by Tanenbaum. A great free alternative here is [Beej's Guide](https://beej.us/guide/bgnet/) although it is much more hands on, practical, but slightly less in depth. How are you with general design? [C Interfaces and Implementations](https://www.amazon.com/Interfaces-Implementations-Techniques-Creating-Reusable/dp/0201498413) by David Hanson is good for that. These are all subjects that I expect you to have at least *some* experience with, but studying them in depth will significantly help you to understand how to design better C projects that produce more efficient executables in general, while also helping you to discern when to use what. Anything beyond that I would say is likely specific enough that you should start specializing in that particular subject, like computer graphics or embedded systems (two areas where C really shines). It's also worth noting that these are not your only options. There are loads of free options floating around the internet, and if you learn better with tutorials there's nothing wrong with that. These are just the textbooks that I used, and I found them to be a better toolset for me than anything else.
Come up a project you want to make and start making it. Every time you hit a road block, start researching into it and learning. Alternatively, you can find a computer science topic that you enjoy and research into that. When you get sufficiently advanced in a programming language, the problems stop being about the language and more about the algorithms and data structures which are language agnostic.
- Read books. Linux Programming Interface is great - Read mature codebases. I love reading the kernel, system cli tools (like htop), protocol implementations, widespread libraries, etc. - Read reddit, SO, forums, etc. - Write code yourself.
Recursion works by a function calling itself or a different function that will ultimately result in it being called again. It's like making a loop without a \`for\` or \`while\`, though obviously it has other uses as well. I strongly recommend learning how it works and doing your best to learn when it is best applied. Personally, I use it infrequently, otherwise I'd cover it in more detail for you here.
They are also useful for passing to functions. Let's say you have a `char *name;`. You pass it to a function. That function can modify what name points to, but not name itself. Instead you do `myfunc(&amp;name);`. Now myfunc receives a char**. It can do things like call realloc and reassign the value of name by referencing the pointer-pointer once, or act on the actual character data by dereferencing it twice. 
 i &lt;= 8, j &lt; 8 What do you think this does?
While I did learn something from Linus' code example, the second example the author uses is terrible. It's mind boggling that someone (who is presumably not a rank novice) would ever write that first piece of code instead of jumping straight to the last one. Looking at the author's other articles, it's pretty funny that a year and a half later he writes [a post] (https://medium.com/@bartobri/the-pointers-to-pointers-idiom-7b15aaafafca) about the exact same pattern with absolutely no recollection of having seen it before. 
Here's the `strchr` version I mentioned before: const char* numerator = argv[1]; const char* denominator = strchr(argv[1], '/') + 1; int numerator_length = denominator - numerator - 1; int denominator_length = strlen(denominator); The caveat here is that `numerator` isn't a proper C string. That's why I calculated the length of the string. You can terminate it if you want, in which case you have two choices: modify the original string (replace the `/` with `\0' with `numerator[numerator_length] = '\0';`) or make a copy of that string (`strncpy(numerator_copy, numerator, numerator_length);`, with an appropriately-sized array to copy into).
These were almost the exact type of resources I was hoping for - subjects that, while maybe not specific to using C language, will help me understand and write better programs before I even sit down at a keyboard.
Do you understand recursive functions?
&gt; the problems stop being about the language and more about the algorithms and data structures which are language agnostic. This is more or less where I'm at now besides learning a few best-practices type things from experience. Are there any resources you'd recommend for learning about various algorithms and data structures?
So glad I could help!
 for (int i = 1, j = 0; i &lt;= 8, j &lt; 8; i++, j++) //form binary bits { myData\[j\] = (uint32\_t)(serialBytes\[3 \* i\]) &lt;&lt; 16 | (uint32\_t)(serialBytes\[3 \* i + 1\]) &lt;&lt; 8 | (uint32\_t)(serialBytes\[3 \* i + 2\]); } &amp;#x200B; I wanted to recreate something similar i.e., Channel\[0\] = 7FFFFF Channel\[1\] = 000000 .... &amp;#x200B; I just wanted some advice to recreate the same with 54 characters such as the picture in the main post.
I wouldn’t consider yourself an intermediate programmer if you don’t understand recursion. Out of curiosity? Is C your first language? When did you start programming? If you are new I would recommend choosing another language for your first. Although you can avoid using recursion in many situations, I think many consider it a fundamental programming concept. 
Right. Should have linked to Linus's TED talk instead. My bad. 
I don't know if you meant it this way, but your post reads as a bit rude to me. "Intermediate" is by no means a clearly defined skill level, and for all we know the person you were responding to may have a bunch of experience programming in C but just never happened to need to learn about or use recursion. Intermediate or not though, what's wrong with starting with C if someone is feeling comfortable with it so far? The biggest issues with C for newer programmers (in my experience) is that it confuses the shit out of them and makes them not want to continue learning. If someone likes it and wants to continue learning it, what would be the point of pushing them to an "easier" language? 
You could write an Apache Web Module! It was a great learning experience for me.
My normal work flow for solving issues that I just can't seem to figure out is * Start writing a post about how to fix it on a forum or website * Include all relevant information to help others figure out what my issue is * Try to explain the exact nature of the issue in my post * Realize what the problem was during step #2 &amp; #3 and solve it myself Hope this helps!
Interestingly enough I have been setting up my own web site and hosting it from my home server. What was/why did you write your module? Maybe it'll give me some project inspiration of my own.
Yeah, reading over my comment it definitely came off as rude, sorry about that. There is absolutely nothing wrong with starting out with C if it works for them. 
I wrote it for work last year! They are pretty easy to work with. Definitely find an example on github to start rather than try to figure it out from documentation. Learning the whole Apache HTTPD infrastructure is really interesting too. EG [OpenStreetMap Mod Tile](https://github.com/openstreetmap/mod_tile?files=1)
I do have a ton of resources that I reference depending on the project, although algorithms and data structures is such a broad topic that you'd really have to narrow it down to something you wand to learn about. Nevertheless, here's a few random links from my browser bookmarks which may pique your interest: * [Intel Intrinsics Guide](https://software.intel.com/sites/landingpage/IntrinsicsGuide/): If you want to try writing SIMD optimizations * [Crafting Interpreters](http://www.craftinginterpreters.com/contents.html): For learning about creating a programming language * [Fabien Sanglard](http://fabiensanglard.net/): A very cool blog where he explains the code on many 90s game engines and other advanced topics * [Beej's Guide To Network Programming](http://beej.us/guide/bgnet/html/single/bgnet.html): Is any list complete without this? * [Build your own (insert technology here)](https://github.com/danistefanovic/build-your-own-x): A catch-all, really. Browse that list for anything that looks cool. If any of those topics interests you, I have more resources on them. Hopefully this can help you find which area of study you particularly enjoy.
No worries, man. Shit happens. I greatly respect your sincerity.
Return an array
I'll start looking through these as soon as I get the chance. Thank you very much. In terms of specific algorithms and data structures, I was looking for any of the more fundamental examples or a few of the ones that appear the most often or in the largest range of fields. Still pretty broad, but they seem like the type of subject where you don't know what to ask for until you know enough about them. I'm mostly looking to work on embedded systems and controls (plus some game development for fun) if that helps narrow it down.
[std::tuple](https://en.cppreference.com/w/cpp/utility/tuple) is the best way to do this if you're on c++11 or newer. You can use use [std::pair](https://en.cppreference.com/w/cpp/utility/pair) if you're on an older standard. Alternatively, you can take parameters as mutable references and assign return values to those. int multi(int&amp; outval) { outval = 5; return 15; } Both approaches are valid.
You taking Rao? I think we are in the same class. Just use a while loop and a counter variable in your worker function. void * worker(void * data){ int i = 0; while(1){ i += 1; pthread_mutex_lock(&amp;mutex); do shit } printf("i:%d\n", i-1); //minus 1 because the while loop will run n+1 times } for my program I would have 1,000,000 total lock acquisitions so if I'm running 4 threads, each thread should should theoretically have 250,000 acquisitions.
My habit doing this kind of stuff is to fgets() into a string buffer and then extract what I'm looking for with sscanf() (or whatever the buffer-length-overrun-safe version is) and/or strtok()
out paramaters, struct, pointer to malloced array
Find an open source project that's written in C and start making contributions. You can search for issues like that on [GitHub](https://github.com/search?l=C&amp;p=3&amp;q=%22good+first+issue%22+is%3Aissue&amp;type=Issues) pretty easily. Ideally you'll want to find a project that does something you're either interested in, or that you can personally use. That's nice because you get to benefit directly from any improvements, etc. Good luck!
Bad idea in C. This limits you to only returning values of the same type. Moreover, you can't actually return an array -- only a pointer to the first value of the array, which means that you're going to malloc inside your function, requiring you to free outside your function... Bad idea all-around.
Return in the sense that you pass in a buffer and return the value in that. No need for malloc.
Don't forget something to check to make sure that user input doesn't overrun inputString\[\]'s buffer. That's how you make security vulnerabilities, or more likely crash-age/seg-fault-age. &amp;#x200B;
I started off with C and assembly and things have worked out fine for me so far. Ideally to be more intermediate you'll understand recursion since you can often rewrite a problem as being recursive (BST, Linked Lists, solving a maze, etc.). If you understand recursion you'll know more about stack calls and returns too, so you'll know what not to do and why you should try to write iterative programs instead. I don't think u/cursedhydra was trying to be rude they seem more concerned for you. Once you learn about recursion you can then learn about backtracking and memoiztion, which will make you a better programmer. P.S. I was originally going to say learn a flavor of assembly since that is what complied c becomes, check out "understanding linux/unix programming" by bruce morlay, and pick up hacking: the art of expolitation, so you can learn about what makes c special.
I left that as an exercise for the OP ;-) Seriously, excellent point and one that needs to be drilled into all of us. 
One of the things C is commonly used for is high performance, close to the hardware applications. As a result, I find it quite valuable to have good knowledge of how things work at a very low level - as in, operating system and CPU internals. Knowing how virtual memory and caches work can change a program from muddling to screaming without changing the "apparent" effort. These are good things to know in general, but C is positioned to make particularly good use of what you know.
In C++ you use a std::pair, but C++ isn't C; you're in the wrong sub bud.
&gt;Linux Programming Interface I found *Advanced Linux Programming* to be a lot more approachable; it's a third the size. 
I wasn't the person u/cursedhydra was responding to; I just explained how it came across to me when I was reading comments. I agree with your points if the person he was responding to reads them though. I was already fairly pretty comfortable with C beforehand, but going through and learning some assembly programming and getting familiar with simplified computer models really made everything else make a lot more sense. I couldn't recommend it enough.
Successful mutex lock means I'm not waiting for another thread to release lock no? I see your counter and it will be the same as the number of lock acquisitions right?
What is your end goal for this project ? I'd like to use/abuse it for another purpose (GPL octoprint plugin).
Woah. Who does that? I had to google it to figure out what it evaluates too. Hopefully this doesn't give something away that you wanted OP to figure out: [https://www.geeksforgeeks.org/comna-in-c-and-c/](https://www.geeksforgeeks.org/comna-in-c-and-c/) I tend to think I use a lot of the language and expect other people to understand it -- that's just hard to recall what the expression evaluates to when you're used to using it as a shortcut to do two assignments inside of the parts of a for() loop.
I was hoping they would be able to google it themselves, but no worries.
I'm not an algorithms guy. I am a heavy C user (not C++), embedded, close to the hardware. \-Read other people's code, look for usage that you don't understand and figure out (google?) what it means. (I just learned something minutes ago, or relearned it.) \-Work with other people and their code. You're writing for more than just the compiler and processor -- you're writing to be understood by other people maintaining the code and by the future-you maintaining your own code. Learn what styles and usages mean to different people. The little bit of open source stuff I've looked at tends to have a style that personally makes my eyes hurt, that I don't know why it's done that way. Other safety critical, closed source stuff I've worked on, the team develops a style and learns to communicate intent through the code, at least when things are going well.
See my other comment. The condition of your for loop doesn’t do what you think it does. Sorry for the delay in response, but I didn’t see this because you didn’t respond to my comment. You may also want to look up using char* to alias variables and access them one byte at a time. Based on what your goals seem to be that should save you some time. Anyway, good luck, have fun, and come back with questions. 
Right, that's what we are looking for, total number of successful lock acquisitions. The counter will only increment if it acquires the lock otherwise that thread will sit and wait and not run the while loop. You could put it before or after the spinlock or lock but you need to put it after for trylock since it returns no matter what and in that case you will get the number of times it attempted to get the lock. So it goes something like this: -Thread created -increment counter -wait for lock -do shit increment -do shit -increment (the extra 1) -exit condition -join 
I'm a randomizer of half-assed limit checking and paranoid limit checking. Both of those have come back to bite me later.
Sorry, it was my shock at the usage. That usage might turn me into a limit-the-instruction-usage guy (like the MISRA standard encourages). &amp;#x200B;
Good, now install it for Visual Studio Code or Sublime
return as std::tuple !
It is, I taught myself starting in 2015.
Visual studio gives you a popup asking if you want to use the old version or not. I can count the number of times I've wanted to start anyway on one hand.
Ehm, char is a character type. An array of chars is a string. You can declare arrays on stack (with char str[]) or on heap (char *str), and they would both mean string. They are different in the way they are presented in memory, but they are both strings. Array of strings, however, are char ** or char *str_array[] or whatever you can think of. The main function and its argv is the obvious example that proves my point -&gt; [link](https://en.cppreference.com/w/cpp/language/main_function). And char *argv[] in this case is indeed an array of strings.
What about code blocks? 
Doesn't matter honestly. Just stop using notepad lol
Okay, lots of great suggestions in this thread so far. Mine isn't like any of them: Write a small graphical DOS game. No, really. Target DOSBox and essentially treat it like an embedded target. This is _not_ an excercise in nostalgia, I promise. What's nice about targeting DOS is that unlike a modern operating system, DOS isn't trying to help you. Like, _at all_. You want to draw graphics on the screen? You need to understand how to write to linear video RAM. You want to get real time keyboard input? You'll have to learn how interrupts work. Want to read a bitmap from a file and display it onscreen? You'll need to understand how RLE bitmaps work and how to copy that information to video RAM. Because I never needed to do these things on modern computers with modern operating systems, it really gave me a feel for not only how hardware works but also how to write small, efficient code that's stingy with RAM. Optimization is not an optional step or an afterthought. Sometimes you just flat run out of RAM and your program fails. By the time I had a small 2D dig-dug like game working, I felt like I really had a _command_ of C that I didn't previously have. Things that used to seem complicated were less so. I spent less and less time referring to documentation for basic tasks. While I encourage people to go through the process of learning how to do everything for themselves, I've actually written a [small library](https://github.com/jaybill/absu) to share my research and help with the basics. Let me know if you end up looking at it!
Your buffer looks like it's not binary data, but ASCII characters, 6 characters per measurement, each a 24 bit value, right ? for (int i = 0; i &lt; 8; ++i) { char tmp[7]; memcpy(tmp, &amp;buffer[(i + 1) * 6], 6); tmp[6] = 0; Channel[i] = strtoul(tmp, NULL, 16); }
Any links to resources you used in learning how to do this sort of thing? Cheers.
Maybe you could make use of getrusage at exit time, to not pollute your benchmark with extra systemcalls while running.
The primary goal was to to gain experience, learn stl file format and to start basics of rendering/raytracing. I'm pretty sure that it's not as fast as you think for larger files with high triangle count since we're rendering with the cpu alone. Rasterization would be way faster for this issue. Still, if you need; go ahead use it. 
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
C# is off topic in this subreddit. Please post C# questions to /r/learncsharp instead.
Have you tried char *my_arg = argv[1];
I just typed in c# coding seemed to be more or less right I guess this proved my point of having no clue ha
Don't feel bad about this! Mistakes happen to all of us!
Have you tried posting on a C++ board, like one of the ones listed in the sidebar since this sub is for C?
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
thank you. i am clear now. You use fgets for the string element and scanf for other elements.
 char command = 'Y'; while (command == 'Y') { // your code scanf("%c",&amp;command); } &amp;#x200B;
I really want to do exactly this but don't know where to start. You can't just use gcc for that right? 
Something like this would allow you to modify the string: char *str = malloc(strlen(argv[1]) + 1); // One extra byte for null terminator strcpy(str, argv[1]);
Thank you! 
Thank you! 
I am also post beginner learner so what i planned is to code more by writing scripts or by competitive programming. I have started to read more advanced books to get better grasp about the system. Be thorough with all the data types and algorithms. Make some cool logical games. Look for the operating system basics and try to write your own code for system calls or write code for embedded systems. Well this is what i have planned for if there is something more i can do please let me know.
Put 4 spaces before every line in your code to preserve formatting.
Wouldn't a shell script be better suited for this ?
Well I can't I have told I have to do this way specifically using fork and excel 
That's actually how a shell (`sh`, `bash`) works. So, your code is... `bush` 0.1 (BUggy SHell) ?
I think that will add the '\n' at the end and you will get a problem later, or am i wrong? For some reason i can't remember now i think this also will not work on linux. Can you explain? I have to look up later at home :)
Lol
&gt;"-c 1 -q " You can't group flags with spaces when using exec(). Turn it to "-qc1" for quick fix, or "-c", "1", "-q". You should also change the way you spawn: if (fork() == 0) { execl("/bin/ping",... _exit(127); } wait(NULL);
You are misunderstanding how I do things. I use fgets() to get the whole line (string stuff and other elements). Then, I use ***s***scanf() (that extra s wasn't a typo) and other functions to parse out what I need.
A much better solution would be to just use `goto`
For this specific problem a `goto` might be manageable, but I wouldn't advise anyone to start a bad habit. It is generally considered better practice to user proper loops, such as `while`.
April fools yo!
There are lots of good suggestions here already on how to improve your C skills specifically, and CS knowledge in general. I have a couple of other suggestions: * Get familiar with a build system. Personally I use GNU Make. You should also know the UNIX shell for Make to be useful. (The Bourne shell isn't that hard but it is weird. Just remember: when in doubt use quotes.) Another good one to know is CMake. * Spend some time learning another language. Java, Python, C++, Ocaml, Scheme, Erlang, Javascript, SQL, etc. You don't have to become an expert with it, but being exposed to how people solve problems in other languages can help you see solutions that might not have been obvious if you had spent all your time writing C.
Alternatively one could use a `do while` instead. The do while ensures execution of the body at least once, which is the desired effect: char command; do { // your code command = scanf("%c", &amp;command); } while (command == 'Y');
yea I have changed it to wait(&amp;status) and put a int status to 0 so its fine
Line 27. `*b&gt;&gt;*a` is `&gt;&gt;` is a bitshift operator rather than a comparison operator. I haven't thoroughly gone through your code, but this immediately popped out.
Doesn't work. It shows error as: warning: this 'while' clause does not guard... [-Wmisleading-indentation]| this statement, but the latter is misleadingly indented as if it were guarded by the 'while'| Appreciate your help.
You cant address maxarray as you did, read more about pointers. You should right maxarrsy[i] or *(maxarray+i). And why did you used shift right? 
C (unlike C++), supports implicit casting of pointers to `void*` in function arguments. I forget whether or not this triggers a gcc warning or not... That said, it's a pretty decent practice to explicitly cast your pointers.
It does not trigger any GCC warnings. How would you rewrite this with an explicit cast? Thank you for the explanation! :D
ptr = (char *)s
Not just in function arguments. Setting aside qualifiers, any object pointer type can be cast to `void *`, and `void *` can be cast to any object pointer type. There are restrictions on dereferencing the result, though.
Because that's the purpose of `void`: as a naked type, it means “nothing”; as a pointer type, it means “anything”. Prior to its introduction in C89, people used `char *` instead (or equivalent typedefs, e.g. `caddr_t` in BSD kernel code). That aside, your code can be written much more succintly: void * ft_memset(void *s, int c, size_t n) { for (char *p = s; n &gt; 0; n--) *p = c; return (s); } Out of curiosity, did you write this yourself or did you find it somewhere, and if the latter, where?
*argv* points to modifiable strings, there is no need to make a copy, see /u/FUZxxl response.
Scrap your `max()` function and start over keeping the following in mind: if `arr` is the name of an array *or* a pointer of type `t` and `i` is an integer expression, then `arr + i` is a *pointer* to the `i`th element while `arr[i]` (or `*(arr + i)` or even `i[arr]`, but please don't do that) is the *value* of the `i`th element.
Or, on suitable systems, char *str = strdup(argv[1]);
pssst, p++
Do not post pictures of code. Please edit your post to include a copy of your code as text instead.
That's pornographic code, and a great explanation. Thank you! 
First, check that `top` and `who` really are in `/bin`. I suspect not. Second, when using `execl()`, the first argument after the path to the program should be the name of or path to the program, and each argument should be a separate string. Third, you are missing some braces in crucial places. I would recommend that you always use braces around each branch of `if` / `else` and around loop bodies.
Thanks!
This only works if you are sure that char is a byte, and you are usually not sure. Use int8u if you want to be sure. And do not forget to increase p.
Thanks, this fixed it, looked back at the lecture notes just to see why and it seemed I just remembered it wrong.
Man, what a question, was thinking just the same thing and would love to know which you go for. 
Ok, sorry, will do that from now on, 
If it's within a-z and case insensitive, you only need 5 bits per character. 6 to make it case sensitive.
9 bits per character allows you to represent 512 different characters.
Thanks! I’m interested to see what is recommended to me. I imagine I will get some K&amp;R recommendations, but I’ve gathered that it’s not a good choice for a new programmer. That book is definitely on to my to read list after I get my feet wet in the langauge. I’ll let you know what I choose assuming I get some feedback on this thread. 
Explain 
2^9. What more do you need?
2\^9 = 512. so 9 bits per character. so for example: 0 would be 000000000 1 would be 000000001 ....... 511 would be 111111111 
Yeah deffo, thanks so much. 
It is not necessarily a byte, but it is always the smallest addressable type.
mem\* and str\* functions are funny. Is it a historical accident that they return information, that is already known... All those wasted joules moving s to %eax or equivalent :)
Thanks
I read C Primer Plus by Steven Prata and I could teach the C class I'm taking at school. Also check ebay for a used copy. I got mine good as new for $7 including shipping. Whatever you end up getting, make sure you do the practice problems otherwise you're not learning. You could read all three of those books and learn nothing if you skip the exercises.
&gt;Because that's the purpose of void: as a naked type, it means “nothing”; as a pointer type, it means “anything” To avoid confusion, I prefer to think of the word "void" as "unspecified". That also explains why you cannot dereference a "void *" or use it in pointer arithmetic; you must first convert it to a specific data type. &gt;Prior to its introduction in C89, people used char * I'm not following -- so they would use char * and then explicitly cast to whatever type they wanted?
strudp works on Windows too, the Windows version is named *_strdup* and has the same syntax as the POSIX one.
&gt; they would use char * and then explicitly cast to whatever type they wanted? Yes, or `caddr_t`. See, for instance, the [4.4BSD kernel](https://github.com/weiss/original-bsd/tree/master/sys/kern).
All three of them are fine. My favorite is C Programming: A Modern Approach
Really? All I can find is that it should be "Smallest addressable unit of the machine that can contain basic character set" per wikipedia. Is this number bound somehow to smallest addressable type?
Since `sizeof char` is 1 by definition, there is no way for C code to directly access anything smaller. But regardless, `memset()` is defined to operate on *characters*, not bytes (C11 §7.24.6.1).
If you're on non-posix that's your problem.
In C any pointer type can be converted to `void*` and back safely. Also most C programmers I know would argue that you should not do an explicit cast as that can actually introduce bugs. From the standard: 6.3.2.3 Pointers 1. A pointer to void may be converted to or from a pointer to any incomplete or object type. A pointer to any incomplete or object type may be converted to a pointer to void and back again; the result shall compare equal to the original pointer.
In general I'm not on non-posix systems. But, if you are a professional programmer, it could also be your client's problem. Nothing wrong with knowing your way on more than one operating system. 
C++ allows implicit casting of pointer type **to** `void *`, but not **from** `void *`.
Ah yes... goes to show how rusty my C++ is... Thanks for catching that.
Warnings are not errors. Unless you have -Werror flag on, you program compiled and can be run.
It is not stored in the file. To make sure that no data can accidentally be interpreted as EOF, EOF is implemented with a bit pattern distinct from any actual character and why `fgetc` returns an int instead of a char.
system
Read this excellent guide: https://latedev.wordpress.com/2012/12/04/all-about-eof/
For sure it will help make things easier in your career. The front end dev where I work (for embedded devices mind you) is constantly naged with memory management issues. It doesn’t seem like he’s really ever encountered char arrays or null beyond a few weeks in school. Totally fine and we can help him out, but C will enable you to clear these hurtles more easily on your own.
The PDP-10, and its predecessor the PDP-6, count as mainframes, not minis. Unisys also has an emulator for MCP that runs on Windows, and they were offering hobbyist licenses though it seems like nobody much took them up on the offer. They were also offering licenses for a Linux-based OS2200-running emulator. 
I recommend that you go to r/csharp instead
`fork()` and `exec()` are used to irrevocably drop permissions from the spawning environment. Doing it in C can also allow mixed code, and moderately inhibit certain kinds of reverse engineering. Doing it badly and for the wrong reasons was more common in the past, though, so some people still have an over-reaction against it even when it's a pretty good solution. You might want to sanitize environment variables, also. 
Thanks i will do that
I almost exclusively work in Unix-like environments, so I may be way off the ball here, but it looks like you're using nonstandard libraries that are in a nonstandard location; you may need to configure your IDE of choice to look for those libraries in those places in order to properly link them. Someone else could give you specifics as I don't know off the top of my head how to do this, or you can google it.
Looks like you forgot to add the .lib into your project? https://stackoverflow.com/questions/4445418/how-to-add-additional-libraries-to-visual-studio-project 
* I keep a cache of notes. About half of it are good ideas I've lifted from somewhere, but somewhat to my surprise, about half of it are useful snippets and design patterns of my own that I might otherwise tend to forget. For example, one day I spent nearly two hours writing some macros to facilitate [binary reproducibility](https://en.wikipedia.org/wiki/Reproducible_builds) by eliminating non-determinism, because I was in the mood and had the right resources already open in front of me. * Read other people's code. Have the experience to know that most code is quite readable, but that when you eventually encounter a big pile of code that you don't understand, there's quite a lot of reason to assume that the fault lies not with you, but with the authors. I have a couple of other people's projects in archive that stymied me the first time I tried to dive into them, that I will return to in the future. * I've used multiple toolchains when developing for many, many years, but only recently have I started actively compiling for non-POSIX platforms. (Much easier with cross-builds, I've found, though I'm trying to keep the code compilable on MSVC as well, because Windows people like that.) The process has caught some bugs and opportunities for improvement. I don't know how badly I needed to spend those hours learning about Microsoft's libc foibles with aligned allocations, though. 
I moved the three files to an include folder and updated the gcc command to the following: gcc -g -o main c:\Users\me\VSCode-C-Test\main.c -I C:\Users\me\VSCode-C-Test\include I still get the errors though.
I googled it and made the changes you can see in the above post.
The `-I` flag indicates include directories. You want to use the `-L` flag to indicate library directories. You also need to indicate that those libraries need to be linked with the `-l` flag followed by the name of the library.
This implicit casting isn't actually my own code. It's copy-pasted from the actual memset function. I was more confused by it than anything else though. From what everyone has said, I've gathered that void is nothing, while void pointers are simply pointers to anything. That's my simplification at least.
It is indeed excellent
In main you need to do r+1 'free`s. 1 for each malloc.
Holy cow! That worked! Thank you very much. I'd give you multiple up-votes if I could.
So glad you got it working! Sorry my first comment wasn't much help; I know very little about tools on Windows, but `gcc` I know.
Try it for yourself! It'll take 5 mins.
Not really true. I have no idea what would happen in the case of double-inclusion of &lt;string.h&gt;, if gcc would even mention that this happened if it fixes it on its own, and this does not answer my question on how to prevent double inclusion if this does count as such.
You could try including your own .h files twice and string.h files and compare the results. Have a look at include guards. This is what prevents double inclusion.
The stuff about wrappers is good. Take the note about cpp optimization with a grain of salt, though, because not all C preprocessors are going to have that.
[DJGPP](https://en.wikipedia.org/wiki/DJGPP) is a version of GCC for DOS. I wish I would have had it back when I cared about PC DOS for non-legacy work. 
Isn't there something like delete [] variable; in c++
The most standard way to do this is with `#ifdef` include guards, but you can also use `#pragma once`, which is less typing and more foolproof: https://en.wikipedia.org/wiki/Pragma_once
**Pragma once** In the C and C++ programming languages, #pragma once is a non-standard but widely supported preprocessor directive designed to cause the current source file to be included only once in a single compilation. Thus, #pragma once serves the same purpose as include guards, but with several advantages, including: less code, avoidance of name clashes, and sometimes improvement in compilation speed. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
like there is no asci char or something that really mean EOF , like it was a thing a real character that mean and it's putted in the end of the file, but in 'C' programming EOF mean that there is nothing more to read , or the utility read() returned 0. here is a link that will kill all yours doubts about the EOF ! [https://latedev.wordpress.com/2012/12/04/all-about-eof/](https://latedev.wordpress.com/2012/12/04/all-about-eof/) (sorry for my bad english ! :D )
&gt; The little bit of open source stuff I've looked at tends to have a style that personally makes my eyes hurt, that I don't know why it's done that way. I mostly find it to be fine or good, but there are always exceptions to the rule. To be honest, one I'm recalling had such an obtuse build system that I can't recall how far I made it into the actual code. I'm not going to say what it was, but it seems to have been thoroughly orphaned as well. I'll make a fresh attempt at it some time in the future. 
Yes. Delete [] *your variable* 
delete [] M; will perhaps work then
Sure thing. So the first thing you need to do is figure out how you're going to compile/deploy your code. I like [DJGPP](http://www.delorie.com/djgpp/), because it lets you build protected mode 386 binaries. [OpenWatcom](http://www.openwatcom.org/) is another good choice. Both of these can (in theory) run under a modern operating system and target 32-bit DOS. If you really want to push yourself, there is actually [a completely crazy method of using a modern version of GCC to compile a real-mode COM program](https://nullprogram.com/blog/2014/12/09/), no standard lib, 64k limit. I did this initially, and it's actually kind of fun. Slapping together a basic arcade game is actually pretty straightforward. I chose DJGPP as that was the thing that seemed to have the most examples floating about. (Point of history: The original DOS version of Quake was compiled with DJGPP.) Initially I just ran djgpp from under DOS, but then I got the cross-compiler working. It ships with most Linux distributions and can even run on windows via Cygwin. For the sake of completeness: You can absolutely use [Turbo C](https://winworldpc.com/product/borland-turbo-c/2x) from within DOSBox. Unless you enjoy pain, do not do this. Okay, once you've got a compiler producing binaries and a way to run them, you can start your project. The resources I used to learn what I needed for this are at the bottom of [this page](https://github.com/jaybill/absu/blob/master/THANKS.md). While you can find VGA programming tutorials online, I _strongly_ suggest you pick up a copy of [Programmer's Guide to the EGA, VGA and Super VGA Cards](https://www.amazon.com/Programmers-Guide-EGA-Super-Cards/dp/0201624907). It's huge, out of print, and a used copy goes for $50US. That said, I would have been lost without it. For input, you're probably going to want to handle interrupts with inline assembly. If you don't know assembly, this is a great opportunity to learn the basics on a real world project. It's not as hard as it initially appears. I recommend [Assembly Language Step-by-Step](https://smile.amazon.com/Assembly-Language-Step-step-Programming/dp/0471375233/ref=sr_1_3?keywords=Assembly+Language+Step-by-Step&amp;qid=1554159597&amp;s=books&amp;sr=1-3). (Note: There are newer versions of this book, but this is the one you want if you're targeting DOS.) Sound is weird. PC speaker sound is actually less complicated than VGA graphics. If you want to use a sound card, however, it's a bit trickier. You're in for either a lot of work tracking down documentation for ancient sound cards...or...you can cheat. There's an _amazing_ sound library called [Judas](https://github.com/jaybill/absu/tree/master/vendor/JDAS209F) that I include with abSU. Hope that puts you on the right track! Feel free to ask questions here or PM me if you want help getting started!
See my answer [here](https://old.reddit.com/r/C_Programming/comments/b7t36w/best_ways_to_improve_as_an_intermediatelevel_c/ejuyckn/), but you can use [DJGPP](http://www.delorie.com/djgpp) or [OpenWatcom](http://www.openwatcom.org/).
Wow that's a great answer. Looks like a heck of an undertaking but I'd love to try it.
Thanks! I have to say, it was a bit daunting, but it was probably one of the most satisfying projects I've ever worked on. I definitely had a much deeper understanding of both C and computer hardware when I was done.
&gt; Mine isn't like any of them You did not disappoint. Sounds like a great project idea; I'll have to give it a shot.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
C# is off topic in this subreddit. Please try /r/learncsharp instead.
Thanks ! It may be suitable for my goals, it may not, its pretty basic. 1) Using a web camera take a picture of the 3d printer at center position. 2) Render the image at approximately the same distance (x/y/z) away from the camera. 4) Mask out the rendered shape call this new shape 'negative'. 5) Feather mask by ~N% for measurement error. 5) At regular intervals (Every 10 layers ?) send the printer back to center position. 6) Take webcam shot find majority color that was not visible during step 0. Ensure that this color is not overlapping the "negative mask" if so alter the user or stop the print.
Perfect timing as I'm in the middle of using Rust to replace C in one project. I agree partially. Some of the problems that he mentions (e.g., ABI stability) are just due to Rust's immaturity and not inherent problems. C didn't have a stable ABI for a long time, either. I don't see why stable ABIs wouldn't eventually grow up around Rust. I agree with him totally about cargo. IMHO it's a less than ideal design that cargo is mandatory. I don't even know how cargo works, but I'm reliant on it. However, there's a major sticking point here, which is his point "Concurrency is generally a bad thing". I totally agree: concurrency is generally a bad thing. However, in the real world in 2019, concurrency is very often a *mandatory* thing. I mean it depends on your application, of course, but it very often happens that concurrency is required. Concurrency is required. Concurrency is bad. (By which we mean difficult, error-prone, and adds complexity and unreliability to the code) How do we reconcile these two things? There are a few things ideas here and there. One idea is Rust's idea, which I think is actually a great idea, which is to force the language to provide more safety where it comes to concurrency. That necessarily adds complexity to the language. Every feature I've seen in Rust has been well-motivated: it's not thrown in willy-nilly like was done with C++. As I see it, now: C is a fantastic low-level systems language which is well-suited for non-concurrent applications. Rust has the potential to become a fantastic low-level systems language which is well-suited for concurrent applications. Unfortunately the different domain means Rust is going to be more complicated.
Use `strcpy` to copy strings.
&gt; Safety. Yes, Rust is more safe. I don’t really care. In light of all of these problems, I’ll take my segfaults and buffer overflows. Well, I won't.
Ditto. I learned C with an older edition of Prata (3rd, IIRC) and I've never read the Deitel book, but I read through King's book last year and have to say that if I were learning C today, that's the book I'd want to learn it from.
\&gt; "Go is the result of C programmers designing a new programming language, and Rust is the result of C++ programmers designing a new programming language”. &amp;#x200B; Maybe, but at least you can tell that Rust was developed by people who actually know some PL theory.
But I will. _Your move._
You either define hero before the scanf and store the string directly into [hero.name](https://hero.name) or you strcpy name into hero.name. Also , &amp; is not necessary when you're passing a string to printf.
Eh, when I do rust or cpp I usually don't use most of the language features. My solution is just to use a stable subset. c++ gives me C generics and few other goodies. Rust gives me C with a borrow checker and few other goodies. That being said I can only really do this because I have only worked in Rust in personal projects, and because of that the fact that my rust is very un-idiomatic isn't a problem
Seems strange then that they don't have a language specification.
Great comment. I would add that you are not actually tied to cargo at all, but it’s just so convenient just about everyone uses it. As I understand, you can compile directly using makefiles and rustc. [Theres a “book” about rustc](https://doc.rust-lang.org/rustc/what-is-rustc.html). If you want to know more about cargo works, [theres a book for that too](https://doc.rust-lang.org/cargo/reference/environment-variables.html). 
If your program has a bug, in Rust, there's a fair chance that it's not a bug in your code. That it's a bug in Rust. 
Not that c style is bad, but I would challenge you to try some of the more specific features of rust, especially traits. It’s a very powerful system with some really cool ways of doing things. I’d poke around in the traits std uses to get an idea of what they’re used for, but also some other big crates like serde. Even if you’re not looking for any kind of object oriented stuff, traits can be really useful for delineating proper uses of a struct in they type system. An example would be the Sync/Send traits. These are market traits (meaning they vary no data) that vouch for safe multithreading. So serde’s parallel iterators will only operate referencing data that handles concurrency safely. Or if you wanted to write a library for, idk, saving files, you might want to know some things about the structs that would be passed in, and maybe that they all implement a method, but other than that you don’t care what gets passed to you. Traits would be a good way of going about that. Otherwise, Builder syntax is really cool and I’d encourage you to try that. Also people seem to be really excited about the new procedural macros, but I haven’t tried them. That being said, personally, I find a lot of things that are suited to c programing don’t love iterators. They’re definitely something I reach for frequently, but sometimes I take them off the shelf, try it, and realize they’re the wrong tool and put them back. Anyways, c programing style is obviously very effective. I’m sure there’s a lot that will stay stable there for a long time. But rust draws from a lot of contemporary research, and it seems worthwhile to me to see what’s really up. 
Build and install it, and add `-lwhatever-the-library-name-is` to the link-phase compiler command-line. E.g., if the name of the library file is libsgx.so, you’d add `-lsgx`. If you install to some prefix other than /usr or /usr/local, make sure whatever lib directory contains the library is in your library path, which you can do by adding `-L/path/to/lib` as well, preferably before the `-l` option.
You need a compiler to compile your code. Visual Studio is somewhat standard for Windows-based developers, or you can use gcc. Either way, you need to install something. This walkthrough gives you everything you need. https://docs.microsoft.com/en-us/cpp/build/walkthrough-compile-a-c-program-on-the-command-line?view=vs-2017 gcc https://gcc.gnu.org/install/binaries.html To use vim, download and install vim. https://www.vim.org/download.php.
Specific, if somewhat biased, critisms of this article can be found [where it was posted on the rust sub](https://reddit.com/r/rust/comments/b5bpbb/drew_devault_rust_is_not_a_good_c_replacement/) 
Big push for it this year. Rust only stabilized in 2015, and it’s now _really_ stabilizing. 
Can you provide any code generation bug example?
&gt; Your move. I thought that C has no move semantics.
There will be bugs in code generation. Some of them (in llvm) will also affect C programs. This isn’t really special for rust programs.
I love C for ARM microcontroller , please I am not going to switch to RUST , it's impossible because C is already the King of Embedded Systems. 
&gt; C didn't have a stable ABI for a long time, either. On the contrary, C had a stable ABI almost immediately. Before people started investigating into register-based calling conventions, C functions were called nearly the exact same way on all platforms. I need some citation for this.
This article resonates with me in many ways. /u/flexibeast, are you the author?
&gt; C has a spec. No spec means there’s nothing keeping rustc honest. Any behavior it exhibits could change tomorrow. Some weird thing it does could be a feature or a bug. There’s no way to know until your code breaks. That they can’t slow down to pin down exactly what defines Rust is also indicative of an immature language. Weird point to raise, as the various C specs didn't manage to keep MSVC/GCC/Clang/other random C compilers honest ;) &gt; Code that compiles in one and not another is indicative of a bug in one of them, which gives a nice extra layer of testing to each. By having many implementations, we force C to be well defined, and this is good for the language and its long-term stability. Weird conclusion to draw. Personally, I've found that code that compiles in one compiler but not another is often a problem in the cross-platform ability of the C code, and not the compiler. (See also: bugs due to undefined behaviour in that same C code)
&gt; On the contrary, C had a stable ABI almost immediately. Before people started investigating into register-based calling conventions, C functions were called nearly the exact same way on all platforms. I need some citation for this. Isn't this a contradictory statement, given that C's immediate ABI was the one Unix used on the PDP-11? https://en.wikipedia.org/wiki/Research_Unix This says it took until Unix 7 for it to be ported to something other than the PDP-11. 
Not knowing well, but many compilers do not fully provide C11 features yet. And I wait for the day MSVC do...
This is a completely pointless and circular argument you're making.
i'm not; i just found it during my travels.
&gt; Isn't this a contradictory statement, given that C's immediate ABI was the one Unix used on the PDP-11 and only the PDP-11? An ABI is always tied to a particular platform and nobody really demands that ABIs are supposed to be portable through platforms, so it doesn't make sense to complain that C was only developed on one platform. The point is that C function calls and structure layouts work the exact same way these days as there did in the beginning. Even on the PDP-11, arguments are passed these days in the same way as they were passed back when C was invented. Of course, the details are different on every architecture, but they remain unchanged within each architecture. There are very few platforms where the ABI has ever significantly changed, only ARM comes to my mind in this regard.
Can anyone suggest me, why this program doesn't loop? It would be a great help. &amp;#x200B; &amp;#x200B; &amp;#x200B; `int main()` `{` `float water_level;` `char command;` &amp;#x200B; `do{` `printf("Enter the water level sensor readout in meters : \n");` `scanf("%f",&amp;water_level);` &amp;#x200B; `printf("The water level is: %f \n",water_level);` &amp;#x200B; `if(water_level &lt;= 0.5)` `{` `printf("The output valve is turned OFF \n");` `}` `else` `printf("The output valve is turned ON \n");` &amp;#x200B; `if(water_level &lt; 3.0)` `{` `printf("The water pump is turned ON \n");` `}` `else` `printf("The water pump is turned OFF \n");` &amp;#x200B; `printf("Do you want to run the program Again? \n Type y or n \n");` `command = scanf("%c",&amp;command);` &amp;#x200B; `} while(command == 'y');` &amp;#x200B; `}`
I just now saw your "Out of curiosity" question. Sorry for the full days delay. I wrote this code, as it was requested of me. The syntax was taken from the actual memset function. Why do you ask?
I would use std::tupels to connect the student name with the grade and put those tupels on the heap. You can use the heap in different ways. "Malloc" is the C method and is not very save to use. "New" is the C++ way and works fine if you dealocate everything correctly. But I would use a std::vector it's save and works like you want it. So recap use a std::vector filled with std::tuples. Std::vector&lt;std::tuple&lt;string, int&gt;&gt; gradeList;
The author is the creator the sway wm and one the main Wayland implementations. He also the creator of a Foss alternative to GitHub that uses mailing list. There was an ama with him awhile back on r linux
This also applies to C Fine
Your code is written in C++. C and C++ are not the same language. If you want to have an answer in C, then please repost your question with all C code. If you want an answer in C++, then please ask in /r/cpp_questions.
&gt;Beyond those situations, keyboard input is inherently unreliable, and fscanf(stdin, ...) would seem like it should have been just fine for reading from pipes or redirects. For console apps or programs that process human-generated text files, line boundaries should be sacred. I really can't think of many cases where line boundaries would be relevant but code would want an over-length line to be treated as two lines, but maybe such things used to be more common? I have no idea lol. The example I gave above was something I used a lot when making a game about buying and selling things. There's a lot of history to C though and that's one of the things I like about it even though its less convenient sometimes. I don't mind micro-managing my code, in fact I enjoy it, so I have a hard time telling when I'm being impractical sometimes. 
I tried rust. Sometimes it's nice, but other time it's just infuriating. Sometimes i need to alias properties for no reason, because only that way will the borrow checker stop complaining. Swapping elements in an array is extra difficult, takes way more code than it should. Sometimes the borrow checker is just stupid, then you need to fall back to runtime checking with one of the Boxed pointers. This only provides marginally more safety than C (i mean, sure you won't write invalid memory, you're program will just crash), and it adds a runtime memory and CPU overhead, which can be very bad on an embedded system. One of the "impossible with safe pointers according to rust" scenarios had only one solution: use id's instead of pointers. That was the point i said that Rust is not for me / for what i do. Using Ids instead of direct pointers destroyed the performance, and was pretty much unfixable (given my performance constraint). I had a few other problems that are probably no longer valid since they where fixed, the IDE support is probably better now than it was. &amp;#x200B; At the end of the day rust did not leave a good taste in my mouth. It's not really bad or anything, and sure it will improve. I'm just going to wait a few more years before i start using it.
This is an enormous topic, so just some pointers: first of all select a specific devboard, for example: [http://www.ti.com/tool/ek-tm4c123gxl](http://www.ti.com/tool/ek-tm4c123gxl). Then you can use the recommended software and get started. Start with veryfing your chain: use example software, compile it, upload it and see if it works. Then, dependend on how much C experience you have, just get started with modifying the example code and seeing what happens. &amp;#x200B; Finally: a word of warning: an embedded C project does not have the safeguard of an operating system, meaning that things like printing a string to your screen might be different from what you would expect. And there are no safeguards, so buffer overflow, stackoverflow or unsafe pointer usage never cause a segmentation fault and can instead cause the most abnormal irradicate behaviour seen by mankind ever period. Do not let this scare you! Just learn to debug. &amp;#x200B; You are picking a rather steep difficulty curve, but by all means do it! Embedded programming is extremely cool.
Because I've worked on a code base that used the `ft_` prefix and may well have had its own `memset()` implementation. But if it did, it would have looked more like mine than yours... so just a coincidence :)
The ft_ prefix is from my course. The course originates from France, and is called "42". Hence the "ft_" prefix.
The problem with adding complexity in the language is that, now the langauge is making the claim "I know better than you about how to do this" And this claim has been debunked massively through the failed experiment of C++. In C++, the language claims is "I know better how to manage code architecture through OOP, templates, etc, etc" and we have realized that OOP is not the mechanism of choice for managing complexity in all scenarios. Neither is templates. In Rust, the claim is "I know better how to manage concurrency through [list the methods rust support]". On the other hand, if you have a minimalist langauge like C, you can incorporate the mechanism of your choice through a combination of framework, metaprogramming, code generation, model-based-engineering, etc, etc. The upside: you're not limited by the language offering. You can have an OOP layer on top of C (yes C with classes is much preferable that C++, given your code actually needs classes, which is often times not the case). But if your code has no use of OOP, you can chuck that layer out, and use a different layer (like functional, or relational, or logic, you name it). Or you could use a combination. Or you could just do plain C. You might say, "but you can do all that using C++ too". To which I say, "then why make the language more complex?". C's strength is minimalism. You can't beat minimalism by creating a replacement that increases complexity.
You're on a C Programming subreddit. There's nothing inherently unsafe about `malloc`.
 &gt; C is far from the perfect language - it has many flaws. However, its replacement will be simpler - not more complex. Yea, I'd really like to have a new language which is a stripped down version C with lessons learned.
Shouldn't it be “qd”?
thank you so much for the reply and help :)
In Windows 10, enable developer mode and install Ubuntu from the app store.
By and large I have seen more compilers and standard libraries support more features from C99 than they do from C11. That being said, most of the features you'd likely want (alignment, generics, threads, etc...) with C11 are supported by many major compilers and standard libraries. I suspect, but haven't looked to see, that C99 still has a larger share of projects than C11. As time goes on C11 will get more of a share, but I doubt its share will ever overtake C99 because as far as I know C89 still has a larger share than C99, and I don't see why this would be any different. I think your question seems to disregard your intent, which means that some of the answers you'll receive here may be misleading. If you're trying to decide which standard to learn, I recommend C99 because its quality of life improvements over C89 are significant, especially for new C programmers, while those of C11 over C99 are less so in my opinion. If you're trying to decide which standard to use for a project, I again recommend C99 because its wider support will result in more portable code; the exception here would be if you need a C11 feature that C99 doesn't support, in which case you should know to use C11. In general, you should consider your use case before choosing a standard, but when in doubt go with the one that is more portable, mature, and documented. Hope that helps.
Doesn't Windows still use caller-saves on x86, at least for API calls? I forget the details...
Yes, but that's a separate ABI which you have to request by decorating your functions with `__stdcall`. By default, `cdecl` is used.
I guess you're in the wrong sub? This is for the C language. C# is in r/csharp
Lol. Spell it correctly
OMGGGG another hard lesson learned....
Woops wrong subredit. And memory leaks are pretty commen by using malloc.
POSIX specifies C99 as they haven't gotten around updating to C11 yet. MSVC is only now barely catching up to C99, let alone C11. On many exotic architectures, you are going to be happy to find a compiler that is at least C89 compliant. What is more mainstream strongly depends on the environment you are programming for.
Don't be discouraged by the effort, you'll learn a huge amount about how a CPU starts up. Also, remember that the "Hello World!" of embedded, is blinking an LED in your main().
&gt; C: 0.73 new features per year, measured by the number of bullet points in the C11 article on Wikipedia which summarizes the changes from C99, adjusted to account for the fact that C18 introduced no new features. If you are going to compare how many features are being added to Rust today, you should compare how many features were being added to C during its first 4 years of existence. I find it funny that the author went to the length of actually trying to calculate the rate of change in the language, as if the result is somehow surprising. 
&gt; \[list the concurrency methods built into rust\] Side note, Rust doesn't have any concurrency methods built-in. It has two traits that can be used to declare certain properties around data aceess ("This is safe to be sent to a different thread" and "This is safe to be referenced from another thread"), and you can build any kind of concurrency/parallelism you'd like on top of that. The standard library exposes OS threads, but there's a lot of other models you may want to use, and they're all implemented by users, not the language.
Have you seen Zig? You might like it.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rust] [Discussion at C programming about Rust](https://www.reddit.com/r/rust/comments/b8jjej/discussion_at_c_programming_about_rust/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Thanks 🙂
What have you done so far? Start typing the logic out in pseudo-code. Along the way, it sounds like you're going to need some type of representation of a card. Maybe a struct with a named value, a point value, a suit, and maybe a hidden identifier indicating which deck it's in. You'll need to randomize these to shuffle. Sounds like you can store them in an array, or better yet, a linked list/stack. You'll need a shuffle function to.... um... shuffle. This function can randomly addFront to a new stack, now to deal, you just need to popFront. You'll need a way to represent a hand. Maybe individual linked lists for each hand? Maybe a fixed-size array? Think about the pros/cons of each. You'll need a functions to evaluate a hand. Rather than doing all of the evaluation logic in a single function, a few helper functions like canSplit or canDouble etc. This is not an exhaustive list -- it's just inspiration to get you started.
No, author is [/u/nbHtSduS](https://www.reddit.com/user/nbHtSduS).
I'm curious why you and the author think concurrency is bad. It does add complexity, but we're talking about systems programming, which which there is already a good deal of complexity involved. Why would you want to avoid concurrency for IO operations like HTTP requests or multithreading for workloads?
(only if you suck at freeing)
I agree with this although I can argue the cpp and cc separation is the main issue with c plus some stuff only found exetentions. Basically c is almost there, but c needs a break in back compatibility. Stuff like cpreprocessor and vla are the issues with c. The only real thing about c which I fell will be very good is arrow functions (function pointer can define the function itself.
&gt; I agree with him totally about cargo. IMHO it's a less than ideal design that cargo is mandatory. I don't even know how cargo works, but I'm reliant on it. You can run cargo by using cargo build --verbose` and it will print every single `rustc` invocation it does. That's probably a good start into how it works. See more here: https://doc.rust-lang.org/rustc/what-is-rustc.html
I'm not aware of good simulators for ARM cortex parts. Devboards are relatively cheap though, I'd recommend STM nucleo boards. As IDE I use keil uvision(free version) and the mxcube HAL libraries. [Here's a pretty basic getting started video](https://www.youtube.com/watch?v=Xh3ORJ_-5Gs). 
No blog spam please.
&gt; MSVC is only now barely catching up to C99, let alone C11, so for Windows C89 is the way to go. MSVC supports the main features people care about in C99, has since 2015.
&gt; I would add that you are not actually tied to cargo at all, but it’s just so convenient just about everyone uses it. Be careful, the interface of the `rustc` binary (its flags, etc...) is not guaranteed to remain stable from one release to another; only the interface of `cargo` is guaranteed.
The last time I checked it still couldn't do variable length arrays.
&gt; Code that compiles in one and not another is indicative of a bug in one of them [...] And of course, as CSmith has demonstrated, there's also a huge swath of C programs which compile perfectly fine on multiple compilers, but return different results because not all compilers agree on the fine print :/
C's strength is minimalism, but that's also its weakness. If you had a C alternative with a sound and safe type system, it would almost necessarily be more complex than C. (After all, if simplicity were *always* an advantage, you should consider rewriting your comment in Simple English.)
This is incorrect; rustc has stable and unstable flags, and stable ones are considered stable. &amp;#x200B; (This caused problems in the past when we accidentally let some flags become stable prematurely, and when we tried to forbid using unstable flags on the stable compiler.)
You're thinking of `-Z` flags which can only be used on a nightly compiler. All the normal flags are stable and will not change. 
There is nothing to reason about scanf("%c %d",&amp;a, &amp;b); You're reading an integer `%d` into a single character (&amp;b). The behaviour is undefined and anything can happen.
&gt; Swapping elements in an array is extra difficult, takes way more code than it should. I don’t know how long ago you tried it, but [it’s been a single method call](https://doc.rust-lang.org/std/primitive.slice.html#method.swap) since 2015 at least: arr.swap(ix1, ix2)
 scanf("%c %d",&amp;a, &amp;b); // This is not written by mistake Maybe not, but it does contain a mistake. It reads a character and attempts to put it into an `int` variable, then reads an integer and attempts to put it into a `char` variable. *This is undefined behavior*, which means it probably won't do anything meaningful, as you said. But most compilers can detect it and issue a warning. Don't ignore warnings.
&gt;The behaviour is undefined and anything can happen It gives the same output every time on my system as well as on [jdoodle.com](https://www.jdoodle.com/c-online-compiler). &amp;#x200B;
1 is read by %c, then 998 by %d. Latter equals 0x3E6, and it happens to land over a and b in this particular way.
Nor are the flags of every other compiler for C/C++ or whatever language by the way. That is a poor argument, in no language the parameters to the compiler are standardized, and can change from release to release. 
So? It gives different output on my system.
&gt; I agree with him totally about cargo. IMHO it's a less than ideal design that cargo is mandatory. I don't even know how cargo works, but I'm reliant on it. For me Cargo is one of the best things of Rust instead, a system that is simple and manages build and dependencies very well, not the confusion of dozens of different more or less portable build systems. And you are not obliged to use Cargo by the way, for a very simple project you can use simply rustc as you would use gcc/clang, potentially you can use rust with existing C/C++ build systems if you want to, but I don't see any good reason to do that (maybe to link rust code to a big C/C++ codebase, but in general you would want to use Cargo that makes so simple to add a library)
class? I think you might be talking about C++ perhaps try /r/cpp_questions instead.
That's what I thought. According to me, 'E6' of 0x3E6 is considered for `b` as it uses only 1 byte. Since first bit of 'E6' is 1, it is interpreted as -26 (using 2's complement). Maybe -26 is then written into memory as 0xFFFFFFE6 using 4 bytes for storage. But why 4 bytes are required? No idea about what happens for `a`
You could have a minimum size defined at initialization time and grow the dynamically allocated array of grades if you require more space. An example implementation (untested) is e.g.: struct student { double* grades; const char* name; int grades_size; int elements; }; student* create_student(int init_size, name) { student* s = malloc(sizeof(student)); // Should check return of malloc here s-&gt;grades_size = init_size; s-&gt;name = name; s-&gt;grades = malloc(sizeof(double) * init_size); // Should check return of malloc here return s; } student* read_student_grades(const char* name) { student* s = create_student(10, name); int ctr = 0; while(1) { /* read input in here */ // return on -1 if(ctr == s-&gt;grades_size - 1) { // resize int new_size = s-&gt;grades_size * 2; s-&gt;grades_size = new_size; s-&gt;grades = realloc(s-&gt;grades, new_size * sizeof(double)); } ctr++; // Assign to s-&gt;grades[ctr] here } return s; } int main() { student* s = read_student_grades("John"); // Should deallocate student* here return 0; }
&gt; If you had a C alternative with a sound and safe type system, it would almost necessarily be more complex than C. What's wrong with the intly-typed bullshit that is C??! Real-life event: A&gt; "Why are you passing in an `enum` to a function that wants a `bool`?" B&gt; "Err, it's been like that for years, and all 3 compilers never complained..." 
Does the scanf not look for a space between the two reads? Always thought it did when you have a space in the format. It's not a function I use often, though, so I may be completely wrong about how it works... 
char argument for printf gets promoted to an int, sign extended in this case. Try unsigned char. Also, try using "data breakpoints" in your debugger for a and b, very educational.
The author makes a nice argument that Rust is more similar to C++ than C. But so what? Honestly, C++ could be a good systems language, too; kernels have been built in C++ before, but C remains the dominant language largely because of history. True, many embedded compilers for obscure platforms only support C and not C++, but I would argue that a lot of those platforms are going to die out as ARM continues to take over the world. The rest of the author's arguments are a hodgepodge of logical fallacies. &gt; C is the most portable programming language. Okay, but that's not because of the C language, that's because of history as I just discussed. Some other language *could* displace it. Maybe Rust hasn't yet, but that doesn't mean Rust's other strengths don't make it an ideal choice for some systems projects. "Being *maximally* portable" is not always among a project's design goals. &gt; Concurrency is generally a bad thing.... However, nearly all programs needn’t be parallel. A program which uses poll effectively is going to be simpler, reasonably performant, and have orders of magnitude fewer bugs. “Fearless concurrency” allows you to fearlessly employ bad software design 9 times out of 10. Tough shit, because concurrency is the way of the present and the future. For more than a decade we've been at an impasse where we can't make CPUs much faster; we can only add more cores. I worked on tightly-coupled embedded systems that had dozens of threads, and rightly so; trying to use a single thread to implement a VoIP audio processing engine and the multiple network protocols it requires and a user interface and HTTP and Telnet servers would be madness. &gt; Serial programs have X problems, and parallel programs have X^Y problems, where Y is the amount of parallelism you introduce. Parallelism in C is a pain in the ass for sure Maybe they have so many problems because you're writing them in C, a horribly unsafe language. Maybe if you used Rust, you would avoid a lot of those problems because the language would enforce much or all of the required safety. &gt; Safety. Yes, Rust is more safe. I don’t really care. In light of all of these problems, I’ll take my segfaults and buffer overflows. Well then fuck right off to your happy little hobbit hole where everything is single threaded and trivial enough to be safe. Even in a single-threaded program, there can easily be bugs that Rust's borrow checker could detect and prevent. And we shouldn't have to argue about whether buffer overflows and null pointers are problems: they are, and if we can prevent them from happening, we *must*. [Your theories are the worst kind of popular tripe, your methods are sloppy, and your conclusions are highly questionable. You are a poor computer scientist, author.](https://www.google.com/search?q=ghostbusters+you+are+a+poor+scientist)
I think it skips any ws, when it sees ws in format. Not 100% sure either.
Well, your reasoning for the output seems to check out, so, TIL, I guess... Thanks!
A whitespace character in the format string matches any number (including 0) whitespace characters from the input stream.
Makes sense, thanks!
Here's what's going on. To start, we need to understand how things are laid out in memory. Note that C doesn't say anything about memory layout, which is one reason this ends up as undefined behavior. So here's the way it looks: | | | | | | \-----------------/ \--/ a b I left the memory blank for now -- there will likely be some value there, but we don't know what that value is yet since it's uninitialized. The first thing that happens is you read `'1'` into `a` as if it holds a `char`. Again, we don't know exactly what this does according to the C language (it's undefined behavior), but what's happening for you is the following: | | | | 31 | | \-----------------/ \--/ a b Easy enough. Now we try to read 998 (0x3e6) into `b` as if it holds an `int`. Once again, this is undefined behavior, but here's what happens: | | 00 | 00 | 03 | e6 | \-----------------/ \--/ a b See how it overwrites part of `a` with the extra bytes of that `int`? Note how there's still a byte that's uninitialized. So, we're still not done. That byte could be *anything* that happens to be in memory when your program is run. As it turns out, every time you've tried it that byte happens to be 0, but with different compiler settings or for a thousand different reasons it might have a different value. So, the end result is you get `0x00000003` for `a` and `0xe6` for `b`. We're still not done, though, because `b` prints as 0xffffffe6. Where did the extra "f"s come from? This is because you can't actually pass a `char` to `printf` -- it's a variadic function, so the arguments go through [default argument promotion](https://en.cppreference.com/w/c/language/conversion). In essence, a `char` gets promoted to an `int`. At this point we hit (IIRC) implementation-defined behavior: C doesn't specify whether `char` is signed or unsigned. In your case, it's signed. That means promoting to an `int` requires sign extension: `0xe6` is interpreted as a negative number (-26), which is 0xffffffe6 when represented as an `int`. So ... yeah. Your code relies on undefined behavior three times and implementation-defined behavior once. The above analysis only holds for your machine, and even then could change for no apparent reason.
That is correct. The space skips any whitespace that might be present, but whitespace isn't required.
Rust doesn't really have any sigils, aside from `*`, `&amp;`, and `?`. It's not much worse than C in that aspect. Maybe you've used pre-1.0 Rust?
Quick formatting note: use the code block formatting option in the fancy editor (under the ...) or indent code 4 spaces in the markdown editor to correctly format code.
The printf only stops outputting a string when it finds a '\\0' on it, but I think you already know that. As for the loop, the condition (s\[c\] != '\\0') never actually enters the loop when it finds that '\\0', so the last iteration is actually for s\[3\]. 
That makes sense. When using unsigned char, value of b is 0xE6.
Give aces a value of one. Having a total where aces have a value of one and a variable that tells you if any of the cards in the hand are aces will make your logic a lot simpler.
Some hairy timestamp formats could benefit from extra blanks. TIL, metoo.
Thanks for such an explanation
There is the pre 1.0 state that some people stayed at, but also lifetimes. I wanted the same thing than the parent: C with borrow-checker. Unfortunately, the borrow checker means needing to express lifetimes, which are a great source of line noise. I think it is actually necessary, so afaic rust seems well made. I'm still hesitant about generics (they add a lot of complexity for a one-time gain), but having a lively ecosystem of packages might be worth it. Still, rust is just so much less readable than C... I need to have more experience in it to see if it's worth it, in a large and serious codebase.
First, let's assume the user put in the following string: "Hello". This is stored in `s` as follows: s: | H | e | l | l | o | \0 | | | | | ... In other words, 6 characters are used. Five for the text that was entered, plus an extra "null terminator" that uses the special character `'\0'` to designate the end of the string. Next, the code copies one string to the other. It iterates over each character of `s` until it encounters this terminator, copying each one over. At the end of the loop, we have the following: s: | H | e | l | l | o | \0 | | | | | ... d: | H | e | l | l | o | | | | | | ... c: 5 Notice that `d` isn't terminated. We never specified^(\*) what character is after the `'o'` that was copied. Trying to use this string could be problematic. For example, if we tried to print it, `printf` would just keep printing characters in memory until it finally just happened to encounter a `'\0'` somewhere else. That could be really, really bad. (I actually found this exact bug in someone else's code about a month ago ... this is a very, very common bug. Look out for it!) So, the line of code you're wondering about adds that terminator, so we get this: s: | H | e | l | l | o | \0 | | | | | ... d: | H | e | l | l | o | \0 | | | | | ... c: 5 And now everything is right in the world. ^(\*) Caveat: it could be that the way `d` was initialized here could implicitly fill it with null terminators for you. I'm actually not sure what the language standard says about this. Regardless, it's a good idea to just explicitly terminate things anyway. Like I said, this is a very, very common bug. ------ One last note: it's worrisome to me that your code uses `gets`. This function is well-known to be incredibly unsafe to use, having caused countless bugs and security breaches in the past. It was officially deprecated 20 years ago and removed from the language 8 years ago. Whatever resource you're using to learn C is incredibly out of date.
Since it's a `char` then you can use the fact that the numbers come in sequential order in the ascii table.
`'5'` is already a number, just not the number you want. `'5'` is 53. To get it to be 5, you need to subtract 48. The same goes for all the other numerals: `'9'` is 57. 57 - 48 = 9. But notice: `'0'` is itself 48, and 48 - 48 = 0. Which leads us to an even better way: don't subtract 48, subtract `'0'` instead: if ( p == ch - '\0' )
use sscanf or atoi #include &lt;stdio.h&gt; int main() { char ch = '5'; int c = atoi(&amp;ch); if (c == 5) printf("good job"); return 0; } 
&gt; You might say, "but you can do all that using C++ too". To which I say, "then why make the language more complex?". In my opinion Rust has done this much better than C++. It doesn't take over your data model, there's no inheritance or code pointers in your data. It's just structs. They spent nearly of that complexity just on making a really nice and watertight system to describe various properties of your API, so that the compiler can check its usage. I'm not talking just about lifetimes, but also about things like traits and the way it does enums.
 int c = atoi(&amp;ch); This results in undefined behavior: `ch` is a single character, while `atoi` expects a pointer to the start of a null-terminated string. The next spot in memory will *likely* not be a digit ... but there's no guarantee of that, and if it happens to be then you'll get strange results. But you could do this: char s[2] = { ch, '\0' }; int c = atoi(s);
Thank you so much im all clear now , im really greatfull . And wish u a nice day bro . And ya our course is really outdated .im from south asian country and they barely update the course.
Did you consider nested loops? It doesn't really become clear what you need to do
Github has 100s of job application assignments for this. Just search there and u will see tons of repos.
There was also as single unmatch `'` for lifetimes, which is a sin, and lots an lots of angled brackets. (About as many as in C++, or the average HTML document). 
^(pssst... that's the null char...)
You're entering territory not travelled by beginners often. You can do it though. I got a PIC up and running pretty quickly without a dev board and had no previous electronics/soldering experience. Cortex is far more complex than a PIC I would imagine though. Good luck!
Oh, good grief. Fixed.
I think you're under the impression that the loop **isn't** stopping and copying junk from s into d. What's actually happening is that your loop **is** stopping when s\[c\] == '\\0'. But then the '\\0' character isnt copied from s to d (because the loop condition fails, so the body is not executed), which requires you to do it 'manually' &amp;#x200B; See this program on [tio](https://tio.run/##jVDBTsMwDL33K6ygaa02aLmuFAkkJsGZG@XQpW4TqUuqxBVCaN9enHRC242c/J7fc54tb3sp5/lGGzlMLcKDp1bbO/WYXFEHa4dAakNwbLRJs@QnAQhQQgVFyUCqxoH/uC@K4nML7VJwU7y97PciKEbHhi4Vz9hZhyDt@K1NvwVSCJ642e@gFitfi9oIHpFdml7NOBE0ZyGQjf4diKjqkXzqrww8I@KQnbUctQJyEwbuS@kBIV3oDMIuvE2Xcn7JmauI21hHqozEeTII/nnU2MJKLkGDMFs0crMJxSn586/rYl1CHt@70p43aAiPaCjPL@I@dYTunzdxSJMz4eyneVY4DPYX)
I can buy that. I especially agree that generics are overrated... I use them and I'm glad they're there (especially for external, extensible interfaces), but they're usually little more than a syntactical obfuscation and definitely not a necessity. Though personally I would hesitate to call any language unreadable unless it was designed to be (like [Malbolge](https://en.wikipedia.org/wiki/Malbolge) or [Whitespace](https://en.wikipedia.org/wiki/Whitespace_(programming_language).) Rust in particular uses only a slightly unfamiliar syntax to express largely well-understood ideas. I mean, I can't read Korean for crap, but that's hardly the fault of the language or the people who invented it. It's just unfamiliar to me because I was raised speaking English.
My first book on C programming. I remember it was not very good. 
I would encourage you to discuss with classmates and your teacher. The point of the exercise is to figure it out on your own and learn from your mistakes though.
Things that might help: recursion dynamic programming knapsack problem (it's not exactly this but involves similar concepts) &amp;#x200B; I'd focus first on actually solving the problem and then worry about trying to make it fast. How would you solve it "by hand"? Break it down into steps and then reproduce that in a program step by step.
Syntax is just something you have to learn and get used to. The vast majority of the programs that are yet to be written aren't being written today not because we have a syntax failure, but because we can't make machines process large enough volumes of data in short enough periods of time. I think Rust helps with that. But syntax quibbling is... let's just I want to build tomorrow's nuclear reactors, not paint their bike sheds.
We have had lots of codgen bugs with the \`noalias\` attribute, which is used to implement \`restrict\` in C. Rust uses this concept much more than C code does, and so we work that feature extra hard. We've had to disable that attribute a number of times in Rust's history, then fix the upstream codgen bug, then turn it back on again.
They do. Have found both SICP and the Dragon Book there.
Why does 2+2=5986? I
http://www.xent.com/pipermail/fork/Week-of-Mon-20060731/042348.html 
"It is easier to make working code fast than fast code work."
I'm not familiar with that article, but [here's the committee FAQ](https://isocpp.org/wiki/faq/wg21) along with the favorite code snippet for each.
&gt;But syntax quibbling is... let's just say I want to build tomorrow's nuclear reactors, not paint their bike sheds. I think syntax is the primary reason Rust is better than C++ with the exception of the borrow checker. If C++ adds a borrow checker will people go with that over Rust? I think not. That's not to say Rust syntax is great, it's just not the shit-show that C++ has become.
My first O’Reilly book in the late 90s was the Perl one with a camel on the cover. I’ve been learning OCaml lately and I just keep thinking that to me, Perl will always be the “camel” language. 
I agree that the whole "Concurrency is bad" idea is unactionable and now basically useless. One of the most important contribution of Rust is that it solves crucial parts of the concurrency problems. Maybe those who don't want to take advantage of that should look for other approaches...
If you edit your post and add 4 spaces to the beginning of every line it will display as code properly. 
How is C++ a failed experiment?
&gt; a stripped down version C with lessons learned https://dlang.org/spec/betterc.html
Why put this obscure reference to a random internet user's error on your book's cover? 
Because it’s attention grabbing and intriguing
Nice catch ! 
Company I worked for years ago hired the guy based on his authorship of said book. All he did was wander around the halls jangling the keys in his pocket (enough that it was his most identifying attribute when talking coworkers) and work on his book(s) on the company dime. The very little work he did do was also not very good.
I would disagree there. C++'s syntax is not too different from Rust's, it is just that there's a lot of subtle semantics behind it. It is the design of the language that fails C++, not the syntax. Most of C++'s bad syntax is there only to solve problems in the language's semantics. For example: one of the 'big ideas' behind the design of C++ is that user types should behave like primitive types. (An very overrated goal, IMO.) To do this, constructors have to be builtin. But because constructors are builtin, you need a mechanism for handling when they fail. Enter exceptions. But what if they fail during array construction? Now we've got an obscure edge case that constitutes a minefield people have to walk through. Repeatedly making decisions like this leads to the kinds of circuitous bloat and confusion that C++ suffers. "User types must act like primitive types" is not worth that bloat. Neither is "templates must act like text substitution" (gross error messages) or "code must appear compatible with C." (a language should probably be backwards compatible with itself, not other languages.) I would not be surprised if few people knew these consequences when the decisions were made; the adoption of these goals doesn't seem properly motivated in hindsight, but it's also hard to see why they *should* have been motivations even without hindsight. That, and self-promoting design culture of "you would be a great C++ programmer like Meyers and Sutter if only you bought all their books and worshipped them proper." It's like they set out to make a popular language because they needed a hill to be king of.
Who cares why 2+2=5986 The real question is how is a fuckin cow related to C programming
Cow starts with C, c'mon. Also, it doesn't have anything to do with it, it's memorable, which often adds significant business value all by itself, as the cover illustrations did for O'Reilly's marketing.
Oh Okay then
The conditions of each `if` are checked sequentially. In essence, the computer first checks to see if the input is greater than 90. Since that's not the case, it then checks to see if it's greater than 40. And so on. Eventually it checks to see if the input is less than 20, *which is true*, and "Study hard!" is printed. It stops checking conditions at that point. To fix that, you need to think about the ordering for each of the tests, or change the condition for the tests. That last condition is more difficult. But take a step back: `age` is an `int`, which is an integer. It will always be an integer, and can never be anything else by definition. So you can't test to see if the user didn't enter an integer just by looking at `age` or its value. Instead, you have to look at how you got that input in the first place. In this case, that was `scanf`. This function returns a value that tells you if the format specifier (`%d` in this case) accepted the input from the user. A return value of 1 means that it did, and 0 means that it didn't. (A bit more detail: you can have more than one format specifier, so this is actually a count of how many were successful. You just have one in there, so you would expect it to return 1 on success.) Test this value to see if the user entered an integer or not.
&gt; I would expect segement 2 to be the one with the issue because it is releasing the mutex before reseting the ownership of its chopsticks, but I worked out different scenarios of execution an i am not coming up with any scenario where for example Philosopher 1 and 2 are both eating at the same time. Concurrency in C is definitely not my forte, but I would argue that it occurs in code snippet 2 for the reason you stated. Let's say I call `eat(1)` and `eat(2)` in separate threads, and let's say for the sake of argument that `eat(1)` goes first and locks up `chopsticks[2]` so that philosopher 1 can eat. Now, `eat(2)` can start up as soon as `eat(1)` is done with line 8, potentially even before line 9. Locking `mutex[2]` in line 2 of `eat(2)` would prevent `chopsticks[2]` from being set to `-1` in line 9 of `eat(1)`, so `eat(1)` would block until `eat(2)` unlocks `mutex[2]` in its line 10. This results in a line order like this: eat(1) line 2 eat(1) line 3 eat(1) line 4 eat(1) line 5 eat(1) line 6 eat(1) line 7 eat(1) line 8 eat(2) line 2 eat(2) line 3 eat(2) line 4 eat(2) line 5 eat(2) line 6 eat(2) line 7 eat(2) line 8 eat(2) line 9 eat(2) line 10 eat(2) line 11 eat(1) line 9 eat(1) line 10 eat(1) line 11 That overlap results in both philosophers "eating" at the same time since philosopher 1 is still considered to be "eating" until `eat(1)` returns. Hope that helps, if I've said anything misleading or outright wrong please somebody correct me in the comments below.
String handling stuff is probably the most common stuff I make into libraries.
Could be touchscreen keyboard autocompletion, which is computer humor, y'know.
There's literally an infinite number of criteria you could come up with. It all depends on what you're actually doing. The main ones of course are insert/delete and iterate like you said, but also find, space efficiency, serialization, networking, some more specific operations like pathfinding, 3D space partitioning, revert/undo capability, and a ton more. Those are just some of the criteria I've used; there are programming fields which have even more specific criteria.
&gt; I'm curious why you and the author think concurrency is bad. Because it's easy to make small mistakes that have significant consequences, and most languages don't protect you from that (Rust being an exception to this).
Ah, frauds are everywhere.
A custom container for `void*` objects. Very useful when you handle opaque pointers of external libraries.
`sll.c:9:24: error: unknown type name ‘node’ struct node add(char*, node*);` &amp;#x200B;
 sll.c:9:24: error: unknown type name ‘node’ struct node add(char*, node*); Should be `struct node add(char *, struct node*)` If you want to concat strings and integers like in line 24 you should use `sprintf` (ideally `snprintf`) e.g. `sprintf(str, "%s%d", "test", i);` sll.c:21:12: error: incompatible types when assigning to type ‘char[256]’ from type ‘char *’ If you want to change the value of a string you should use `strcpy` (ideally `strncpy`) [https://www.tutorialspoint.com/c\_standard\_library/c\_function\_strncpy.htm](https://www.tutorialspoint.com/c_standard_library/c_function_strncpy.htm) Same for line 24 &amp;#x200B; For a good explanation on linked lists in C you could read [https://www.learn-c.org/en/Linked\_lists](https://www.learn-c.org/en/Linked_lists). Instead of working with a head and tail, you should only keep the head. When adding a struct to the list you should walk trough the whole list until you find the last element (aka `current-&gt;next == NULL`) &amp;#x200B;
&gt; there's a lot of other models you may want to use, and they're all implemented by users, not the language. I believe that [`crossbeam`](https://crates.io/crates/crossbeam) and [`rayon`](https://crates.io/crates/rayon) are two great examples of it.
It's a pretty good question because text adventure games used to be pretty common topics in “teach yourself programming” books in the good old days (I'm pretty sure Usborne had one, for a start)... but it's also a very bad question because you could have googled “how to program a text adventure in C” and found tons of material. 
It's a pretty good question because text adventure games used to be pretty common topics in “teach yourself programming” books in the good old days (Usborne had [several books on games, including one on text adventures](https://usborne.com/browse-books/features/computer-and-coding-books/))... but it's also a very bad question because you could have googled “how to program a text adventure in C” and found tons of material. 
What about K&amp;R2? Isnt it the only book you need if you want to learn C?
This is linked list, dinamic allocation of array where first has pointer to locatiin of second, second of third, etc.. This is why it is called linked.
This work is cool. But unfortunately the parts supported by these free tools are too old and too small to be really considered a serious option for anything other than hobby projects. 
For each piece, precalculate anything you can think of, coordinate arrays, bounding boxes, etc. Then you can quickly fit a piece in a position, determine if you've reached a point where it is no use continuing the recursion, etc.
Which year is this book from, I wonder. I believe the best practices changed a bit since 19xx
So what you mean is concurrency is good but it's dangerous in most non-GC languages. "Concurrency is bad" means even in Rust we shouldn't use it because currency is the thing which is bad.
I have never written a text adventure, but essentially it will be a main loop that: 1. prints information 2. accepts input from the user 3. parses the input and performs an action based on that input 4. repeats The next, and probably the most important part, of the game is how are you going represent all of the elements of the game? 1. game map 2. rooms 3. players 4. NPC 5. items If it was me, I would start by writing the main loop, then start working on the map/rooms. Once that was working, I would start adding the other elements of the game one at a time.
Just to clarify, this is the Linux subsystem for a Windows. Just a terminal, no big install or GUI or anything. 
&gt; it's dangerous in most non-GC languages It's dangerous in most GC languages also. GC doesn't solve race conditions or deadlocks (though to be fair, Rust doesn't solve deadlocks either). &gt; So what you mean is concurrency is good but it's dangerous I'm not of the opinion that it's dangerous (I was just offering an explanation of why the author of the article and others might think that), I'm of the opinion that it's powerful but complicated, and care needs to be exercised when using it. I like having a language that helps alleviate some of the mental effort required to take care of that, while still giving me access to all of concurrency's power.
Sometimes the old ways are still best.
A text adventure was my first bigger project many moons ago. for bigger projects, you're going to notice that you have to do a ton of planning before you even think of writing a single loc. For a text based adventure game, as MR2Rick stated, the crux of your program will essentially be a REPL: Read, Evaulate, Print Loop basically you give the user a prompt, they type in some kind of a response (could be y/n, multiple choice (1,2,3), or string processing), you do some checking on it, process it, change state, advance. This loop will probably be your main game loop I like incrementally building things, so I'd start with a very bare bones loop. basically, I'd call a function that asks if they want to continue, if no, exit. Then add in something game related, like the basic build of the player character. Get a name, set basic stats and print them, then exit. Then add in a simple battle that basically will be done via dice rolls, etc etc, building bit by bit.
You have it backwards. The random internet user is talking about the book.
Python will be some help, but if you're new to C, I'd strongly recommend getting it securely under your control before trying to jump to embedded applications. As others have said, some of the things you'll be used to having even in C applications are not present in embedded spaces all the time. The best thing you can do to reduce headache is take things one step at a time, so if you don't have a good handle on C, trying to learn it and start with embedded stuff is going to get hairy fast
Ah yes. This shouldn't be to hard to implement.
1997. I am not learning from it. I just like to collect them.
Can anyone here summarize what's better about this verification method and how it compares to other ways, like mere code review and unit / functional testing? (Besides the abstract.)
Thx so much
strcat() makes this a O(L^2) implementation.
I think you'll really enjoy the [International Obfuscated C Code Contest](http://ioccc.org/).
Edsger Dijkstra famously said that "\[t\]esting shows the presence, not the absence of bugs". Formal verification seeks to address this: to be able to say not just "Well, we did lots of tests, and they passed, so it seems okay", but "We have proved, mathematically, that this software will behave exactly according to spec." In some systems the costs of doing formal verification might well outweigh the benefits, but in others - for example, in the context of medical devices, where lives might be at stake - formal verification can provide a higher level of QA than simply code review and testing. The [Wikipedia entry on 'formal verification'](https://en.wikipedia.org/wiki/Formal_verification) has more details.
The fact that you need to go through all characters of a string to get his length is a design problem of the C string library. If you want performance you should probably use a different string library, like [bstring](http://bstring.sourceforge.net/).
[Duff's device](https://en.wikipedia.org/wiki/Duff's_device) surely does qualify. 
There are some rarely used language features like bi- and trigraphs, old style function declarations. Another thing I discovered is that '\&lt;newline&gt;' is processd very early and you can put it literally anywhere in your code without braking it.
The tricky part is always the spec, and ensuring that it is translated in a meaningful way for the rest of the system design, implementation and v&amp;v. I think 737 MAX is going to play out, in front of out eyes, showing these kind of mistakes.
I've been building quite the library with used books on Amazon. 
From `man 3 free`: &gt; The free() function frees the memory space pointed to by ptr, which must have been returned by a previous call to malloc(), calloc(), or realloc(). Otherwise, or if free(ptr) has already been called before, undefined behavior occurs. If ptr is NULL, no operation is performed. So technically doing a double free is undefined behavior, and could cause anything from a segfault, to deleting all your data, to causing demons to fly out of your nose. Practically speaking, a segfault is most likely.
Yes 
Thanks :)
&gt; The fact that you need to go through all characters of a string to find its length is a fundamental design problem of the C string library. The C string library is generally fine as long as you use it properly. In this particular case, you know the length of `line`. Just replacing strcat with `strcpy(line + line_length, chunk)` will solve the problem. Other part of the code is not efficient, either, but it is mostly about the constant. This strcat() really kills me. That said, I agree `fgets()` is not well designed. It should return the number of bytes written to the buffer.
I think *strcat* should have a version that lets you pass as extra parameters the initial length of the destination string and the size of the destination buffer. An enhanced version of the non-standard *strlcat* function.
`strncpy(line + line_length, chunk, max_size - line_length)` gets the job done.
The Cube engine, from which a bunch of other little games/engines are derived.
I just recently spotted Duff's device in the wild for my first time. It was used as an optimization in the GSM full rate codec reference implementation, and it definitely would have thrown me if I hadn't heard of it before.
&gt;The above code compiled without any errors with GCC. Not even a warning. I am guessing this is because the array index is converted to arithmetic operations by the compiler. Pretty much. x[0] translates to \*(x+0) and 0[x] translates to \*(0+x), which ends up being the same address.
It's not IOCCC levels of wonky (then again not much is), but I always thought Carmack's [Fast inverse square root](https://en.wikipedia.org/wiki/Fast_inverse_square_root) was pretty cool.
`data_handler = (struct simple *)arguments; ` You are assigning a pointer to a struct, try this: struct simple *data_handler; data_handler = (struct simple *)arguments; Although there's no need to use a void pointer here. You can just do: int pass_to_f(struct simple *arguments){ // do things with data }
Always bear in mind that, under 5.1.2.3, a conforming implementation is free to cause demons to fly out of your nose any time it wants, even in the absence of undefined behavior, as long as your nose is not considered an "interactive device".
Have a look at the "Resources" on the sidebar. [CS50](https://www.edx.org/course/cs50s-introduction-to-computer-science) may be a good way to go.
Thanks for the reply, unfortunately I'm using an API (FreeRTOS) which expects only void pointers in task arguments. Also I totally did add the spaces - no idea why it didn't format properly...
huh if I click source on your comment I see a few `&amp;#x200B;` (zero width space) and a lot of escape chars `uint32\_t more\_data;` but no spaces in front of the code, must be the app you're using. For an API like that it makes sense, you want it to be able to accept any type of data. 
&gt; printf("%d\n", 0[x]); A fun thing to do is ask a newbie C programmer what `2["abcde"]` does.
More of an operating system question than a C question, but this particular fragment infuriated the hell out of me once: uint32_t GetDeviceStatus(int devfd) { uint32_t buffer[2]; buffer[0] = DEVICE_CMD_GET_STATUS; read(devfd, buffer, sizeof(buffer)); return buffer[1]; } See how long it takes you to figure out what this does.
Just as a reminder, the way to was originally implemented by just casting the float to int/long is prohibited by the standard for type punning. Instead I learned that unions or even memcpys give you the assembly output you want. Although the memcpy way is the only one that doesn't cause UB, I haven't had any problems with the other approaches so far..
awesome, thank you!!!
If you have absolutely no computer science experience I recommend starting with Python or a similarly "beginner friendly" language. That's not to say that you can't learn with C, but it is to say that there are a lot of things that C forces you to do as a developer that other languages automatically do for you. Moreover, learning C tends to require more knowledge of system utilities than other languages do. I'm not trying to discourage you, please learn to program, it's an unbelievably rewarding experience, I just worry that C may be too daunting as a first language. If you decide to stick with C anyway please come back with questions; we're always happy to help. Check out the sidebar for resources.
First of all i would reduce the logic inside the actual eat function. I would guess you have some kind of "run_thread" that gets the thread id from the main function. I would do something like this: void* run_thread(void *arg){ unsigned tid = *((int*)arg); const unsigned left_chopstick = tid; const unsigned right_chopstick = (tid + 1) % phil_count; while(__run) eat(left_chopstick, right_chopstick); return NULL; } Secondly try to avoid the deadlock by just locking the mutex for editing the chopstick owner and releasing it afterwards and just check if the desired chopstick is available (-1). This will slim down your code since you only need one mutex. And finally always keep in mind that every shared variable you change without a mutex lock is most likely cached inside the threads memory and therefore never synced with the other threads.
This code isn't wonky to anyone who understands the symmetry between pointers and arrays, i.e. any remotely competent C programmer. Check out the annual obfuscated C contest. 
I want to avoid having to traverse the list every time I add something, because that is very slow (O(n)). Granted this list should not be very big, but still.. Anyway, I was able to get it working how I wanted, and cleaned up the code a lot along the way. The add() function does not need the node parameter, and is more versatile for it ``` #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; struct node { char bfr[256]; struct node* next; }; struct node* add(char*); int main(int argc, char** argv) { /* Setting up the head and tail */ struct node* head = add("test"); struct node* tail = head; /* Adding nodes */ for (int i = 0; i &lt; 10; i++) { char str[256]; sprintf(str, "test%d", i); struct node* newNode = add(str); tail-&gt;next = newNode; tail = newNode; } /* Traversing the list */ struct node* current; current = head; while (current != NULL) { printf("%s\n", current-&gt;bfr); current = current-&gt;next; } return 0; } /** * Creates and returns a new node pointer with the specified string parameter. */ struct node* add(char* str) { struct node* n; n = (struct node*) malloc(sizeof(struct node)); strncpy(n-&gt;bfr, str, sizeof(n-&gt;bfr)); n-&gt;next = NULL; return n; } ``` Thank you for your help, you definitely helped me debug my string issues :)
Duff's is great because it shows how the compiler is actually treating all of those language elements.
May I have a hint?
Correct. Someday I'm going to use it as a coding question: What does this code do, why is it broken, how did it ever work?
hmm, ok, but how does `read` do that?
Term evaluates to \*(x+0) In this case \*(ascii(a) +2) which should be 99
Compile-time assertion (I'm not thinking real hard). The one we use here is: //If cond is false, then compiler throws an error #define COMPILE_TIME_ASSERT(cond, msg) typedef int msg[(cond) ? 1 : -1] The trick here is that you can'd declare an array with a negative length. The reason this is important: you can't check expressions using a #IF where the expression includes something like a sizeof() because sizeof() isn't evaluated during preprocessing, when all of the #-things are done. sizeof() is evaluated during compilation. The reason (#2) this is important: sometimes embedded engineers are doing scary things with alignment, packing and size of structures. Automatic checking makes sure that some future maintiner doesn't violate your assumptions. Checking at runtime annoys people and there might not be a good place to output the result anyhow. Clobbering compilation gets someones attention much faster, with zero runtime cost.
donut.c is pretty beautiful when it comes to crazy https://www.a1k0n.net/2006/09/15/obfuscated-c-donut.html
If I remember correctly from my OS class in college... Inside the OS kernel `read()` is actually implemented by a device-specific function. The kernel uses `devfd` to index into an array of functions, thus finding the device's individual `device_specific_read()` function. Then it calls `device_specific_read()` with the `buffer` and `sizeof(buffer)` parameters. So at this point `device_specific_read()` has access to the entire `buffer`. And can both read and write it. If it wants to read the first four bytes of `buffer` and then do something different based on the value therein, it can do that.
I'm pretty sure that accessing the "wrong" member of a union is also UB, if you're talking about doing something like: union intfloat { int32_t a; float b; } ... intfloat buf; buf.a = 12345; &lt;do something with buf.b or &amp;buf.b&gt; The reason it's UB is that there are most likely bit patterns that are valid ints but not valid floats (and possibly vice versa on some platforms). `memcpy`'s behavior *itself* is well-defined, but writing (essentially) random junk over a float and then trying to read it might cause UB. There are similar issues with `bool` in C++. It's NOT necessarily the case that `false` is represented as a bit pattern of all zeroes, and the compiler can optimize by checking some specific value as `true` rather than any bit pattern that isn't all zeroes. So you can't necessarily alias/memcpy between bool and int variables and have it work as expected, you have to actually use conversion operators.
the device driver gets the buffer it needs to write to. that driver decidedto read from it. this can break on some OSes, but can work for a particular implementation (ie: if the memory is readable and passed as-is, with new copy)
Ah, I just assumed `read` only ever writes data to the input buffer. Didn't occur to me that it would do things that read it as well.
In my opinion, `read()` (and/or `device_specific_read()`) should never do anything except fill up `buffer`. Anything else is a violation of the way `read()` is supposed to work. But there's always some jerk who is too clever by half and doesn't want to take the time to understand why APIs are created. Hint: APIs are explicitly supposed to be easy to understand, in order to make life easier for the people who are using them. If an API call is as hard to understand as the bare metal it's supposed to be protecting you from, then the person who made the API has failed.
Right. this kind of tomfoolery breaks the single responsibility philosophy UNIX espouses.
OK, you either saw my previous post on the subject, or you're a bloody genius. Yes, this is *exactly* what's going on. Took me like 20 minutes of slack-jawed staring at the code before I figured it out. I wanted to put a fist through my monitor. If I'd known who'd written it, I'd have gone to their office and put a fist through *their* monitor.
well? what ?
From Martin Uecker to Linus Torvalds on the Linux Kernel Maintainers List; a test for integer constant expressions which returns an integer constant expression itself which should be suitable for passing to __builtin_choose_expr might be: #define ICE_P(x) (sizeof(int) == sizeof(*(1 ? ((void*)((x) * 0l)) : (int*)1))) This also does not evaluate x itself on gcc although this is not guaranteed by the standard. (And I haven't tried any older gcc.) Here's Linus' response: That's not "an idea". That is either genius, or a seriously diseased mind. I can't quite tell which. [Read the entire thread](https://lkml.org/lkml/2018/3/20/805)
Here's the rub: I was in the process of converting that device driver from a kernel driver to a user-space driver under Windows. A user-space driver can *only* write to the buffer, it can't read from it. So the code in question was broken with a user-space driver. But I wasn't allowed to fix the code. I had to go to Redmond and sit down with their kernel team for a week to figure out how to make it work.
Anything with goto 
Oh that is just egregious. But I can honestly see myself writing that kind of code... I think I'll be more careful now that I've seen this tho.
Exactly. The code *should* have been calling ioctl() if it wanted to perform a read-modify-write operation. Why the original engineer decided to implement it that way instead of creating an ioctl() entry point to do it is beyond me.
&gt; If I'd known who'd written it, I'd have gone to their office and put a fist through their monitor. Save us all 10 trillion headaches, and break all their fingers. Nobody should be writing code like that.
Not quite. In general, a[b] is equivalent to \*(a+b). Thus, a[b] can be re-written as b[a] with the same result. "abcde" is an array of char of length 6. So 2["abcde"] is the same as "abcde"[2], which is 'c'
The worst part was that I wasn't allowed to fix it.
Do a lot of exercises, the more you fail the more you learn. And be patient, C can be difficult but once you learn the basics you can move between languages without too much problem. Learn to be a good programmer not a good C programmer.
Not only wonky, but probably broken. There might be compilers out there that let this pass unless you actually use the 'msg' type somewhere. I assume this was created before the #error directive was available?
And managers wonder why programmers are always grumpy. They *wonder*.
Oh. My. God.
I've actually made my peace with goto. If you're in a function and an error occurs that makes so that you simply cannot continue the function, goto is as clean a way to get out as any. I've seen this trick used: do { yadayada(); if (error) break; blahblah(); foo(); if (other_error) break; bar(); quux(); } while(0); but that's really just a goto with extra steps.
How would #error help? That's still during a preprocessor step. You can define unused types all day long, or in-every-compliation-unit. I supposed there are compiler settings that would allow you to warn or error on having unused types but that would break encapsulation using header files. We use this with a fairly recent version of gcc for arm. I'm pretty sure this is in MSVC compiled code somewhere around here too. It's never been a problem. The annoying part is that you need to be careful to have unique "msg" fields. Ususally this is done with something like a sentence\_with\_spaces\_replaced\_with\_underscores.
'c'
I think you are remembering correctly. This is the conclusion that I came to as well. Thanks for specifying the kernel internals, that stuff is cool. The code clearly works, so you just sorta work backwards from there to see what it does. Really nasty what they did there, though, that should be an ioctl().
There's not exactly a clear division between input and output parameters in C. You passed it a buffer. Read passed the buffer to the underlying device driver. The underlying device driver then decided to do some fuckery. It's perfectly legal, it's just confusing, and I'm guessing it was someone's method of getting around needing to implement an actual API for some device driver.
&gt; 2["abcde"] signal SEGV (no mapping at the fault address) in strlen so that can't be correct : printf("what is this? %s\n", 2["abcde"]); 
There's a difference between %d and %s! That expression evaluates to a single byte, which is not a valid string - that code you have there is trying to dereference the integer 99 as a pointer. The expression 2["abcde"] references to the 'c' in the string. GP's chunk of code prints 99 since it's then turning that into an integer (%c would print the c).
just silly ... silly ... #include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char *argv[]) { printf("what is this? %i\n", 2["abcde"]); return EXIT_SUCCESS; } c$ ./foo what is this? 99 c$ 
Don't look for the ideal IDE or dev environment before you start. Pick a bare-bones text editor you are comfortable with, and use it to write your files. I would recommend becoming familiar with the command line, particularly the Linux/Unix conventions. On Linux or OSX you can fire up a terminal. On Windows you can enable Windows Subsystem for Linux and use the terminal from there. Or if you really don't care for *nix you can try Windows cmd/PowerShell. At least, become familiar with navigating directories and the &lt;command&gt; &lt;arguments&gt; model.
C99. When we write something that should also compile with MSVC, we write `-std=c89` with all warnings except `-Wpedantic` (because it prohibits mixed declarations and code). C89 lacks a few things, but usually it's nothing to spend much time missing. For threaded concurrency, look first at pthreads, [even on Windows](https://locklessinc.com/articles/pthreads_on_windows/). But consider that there are a number of methodologies to concurrency other than the Microsoft-favored kernel threads. There's [multiprocess with IPC](http://www.catb.org/~esr/writings/taoup/html/multiprogramchapter.html), [green threads](https://c9x.me/articles/gthreads/intro.html), [protothreads](http://dunkels.com/adam/pt/). 
arr_name&lt;: I:&gt; is the same as arr_name[i]
I mean yeah goto is useful in that sense but it can be abused so easily to the point here only the original writer of the code can only understand his code. 
if the printf is printf("%d\n",2["abcde"]); as the OP did then /user/bsingh2 is correct and it will print '99'. To print 'c' it needs to be printf("%c\n",2["abcde"]); 
thanks for the explanation!
How to count the bits that are set in x. Where the loop is proportional to the number of bits that are set in x int i=0; while (x) { i++; x &amp;= -x; }
I personally wouldn't use calloc that much. afaik for aligned allocations, if you are using C11/C18 you should have an aligned_alloc function with the parameters being the reverse of the WIN32 ones, so its prototype would be void *aligned_alloc(size_t alignment, size_t size); where size is a multiple of alignment. I know its aviliable in glibc, not sure about windows.
int i=0; while (x) { i++; x &amp;= x-1; }
99 on an ASCII machine, and would be 131 on an EBCDIC machine. You usually shouldn't code in C on an EBCDIC machine, though. 
Why on earth are you passing 4*1024*1024 as the alignment parameter? That make no sense all. Neither for big nor small allocations. 
What kind of mind came up with that??
Time to use this in production code!
also arr_name??(i??)
Duff, of course!
From another comment somewhere I wrote: People always struggle with C when they start from scratch or come from a higher to lower level of abstraction. I struggled with this for a long time till I did these 4 things: 1. Read [Code: The Hidden Language of Computer Hardware and Software](http://www.charlespetzold.com/code/) 2. Watched all 41 videos of [Crash Course in Computer Science](https://www.youtube.com/playlist?list=PL8dPuuaLjXtNlUrzyH5r6jN9ulIgZBpdo) 3. Grabbed a copy of [C programming: A Modern Approach](http://knking.com/books/c2/index.html) and used it as my main course on C. 4. Followed this [Tutorial on Pointers and Arrays in C](https://github.com/jflaherty/ptrtut13) until I fully understood pointers and memory management. The first two really helped by approaching C from a lower level of abstraction (actually the absolute lowest level and gradually adding layers of abstraction until you are at the C level which, by then is incredibly high!) The third is just the best tutorial on C. By far. The 4th is a deep dive into pointers and by far the best tutorial on pointers out there.
Correct. 
Large memory pages are 4MiB on 64-bit Windows, so that's intended to be 4MiB alignment.
Ok, sure. But there's nothing about the start of the page that makes faster than the end of it. If your goal is performance, you should be avoiding to allocate new pages, rather than forcing it. Now I happen to know that VirtualAlloc is very fast on Windows, quite a bit faster than mmap on Linux in fact. But not calling it is still going to be quicker than calling it. 
I being the index and arr_name being the array/list etc
C differs from C++ in that this is legal in C but not C++.
Why are you using minGW in 2019? Clang can cross compile natively.
&gt; If your goal is performance, you should be avoiding to allocate new pages, rather than forcing it. The goal is mostly just alignment, for reasons related to [memory deduplication](https://en.wikipedia.org/wiki/Kernel_same-page_merging) at the moment. Interestingly enough, a version of the code uses/used static allocations. There's also a significant intention that the codebase end up being used on lower-memory and perhaps low-memory platforms -- quite a strength of C, of course. 
[Of course!](https://i.imgur.com/uQ9BK2K.png)
I did this myself a few years ago. The main thing that you absolutely NEED to keep going, is an idea for a library you want to build, AND that you actually depend on. if it doesn't matter, you'll just give up when it gets hard.
You have at least one bug. When you try to use the "-d" flag you execute the else in your flag check because your second if is always executed. The file is still generated but looks like an error occurred. Otherwise, I like it. Also if you are looking for some more experience you can polish it a little by using an option parsing libary (getopt for example) and adding a makefile. You also probably want to suppress the trigraph warning with a compilation line like: gcc -Wall -Wno-trigraphs -o digrapher digrapher.c 
Well, in C++ the expectation is you’d use `reinterpret_cast&lt;&gt;`. They built in an official way to state your intent. Went digging some more, and as of C11 it’s apparently preferred to do this through a union rather than force-casting pointers (since on some platforms, pointers of different types may enforce different alignment restrictions). The updated spec went from saying its implementation-defined behavior to saying you can read the memory but it doesn’t promise any particular value to be there. However, it does also specify that you can end up getting a “trap representation” (i.e. something that may exception if you try to do anything with it). https://stackoverflow.com/questions/25664848/unions-and-type-punning
Casting the pointer is generally undefined behaviour as it is in violation of the strict aliasing rule.
New "21st Century C" Old "Lions' Commentary on UNIX 6th Edition" But also reading code. Busybox is a good base.
arr_name??(i??) is also valid. "??(" = "[" and "??)" = "]". They are the trigraph equivalents like "&lt;:" and ":&gt;" are the digraph ones.
yea the only reason i decided on C was because i heard it makes it easier to learn other languages in the long run. i’m definitely using Python as a fallback though, thanks!!
i totally forgot there was a crash course comp sci haha thank you so much!
&gt; Why are you using minGW in 2019? Clang can cross compile natively. Good point. Took me about ten minutes to add it as a sixth toolchain combination because the triples aren't exactly documented, but I'm going to have to do some Makefile refactoring now. &gt; To answer your question, calloc is far more useful than some strange memory alignment requirements you don't actually have, and probably never will. Maybe, but I'm a bit dubious for allocations below circa 128KiB. And for a complete, opinionated post, you could also just suggest that I drop Win32. 
if (1 == +!!"") printf("Weird");
i wrote a small fapping animation this is the wankiest of mine https://www.reddit.com/r/C_Programming/comments/896v9c/nsfw_jerking_off_animation_v1/
Oh damn I thought you were confused, I might steal this one from you to make my code unique! 
This is actually going to be really useful, especially for class environments where people love to copy code instead of actually understanding. Thank you :) 
Sorry for the rant but god, I [hate sourceforge](https://www.howtogeek.com/218764/warning-don%E2%80%99t-download-software-from-sourceforge-if-you-can-help-it/)
I like the duff's device that u/bart2019 mentioned and also the [fast inverse square root](https://en.wikipedia.org/wiki/Fast_inverse_square_root#Overview_of_the_code)
A preprocessor macro over a `for` statement. #define TickTock(Timer) for( Run(Timer); IsRunning(Timer); Stop(Timer) ) TickTock( FooTimer ) TheTaskToBeMeasured(); And yes, preprocessor abusing is the origin of all disaster.
I started the project in 2014, before Github was a thing. Subversion was still huge then and I liked Sourceforge's svn-centric workflow, as well as the ability for users to pull it in easily via svn:externals. I still don't like Git all that much :P Since I don't plan to release any compiled code on Sourceforge I'm pretty safe from inclusion of crapware in my downloads heh
IMHO, if this sort tight virtual memory control really matters to you, you should just skip the C heap and do it yourself with `VirtualAlloc()` or `mmap()`. 
GitHub has been around since 2008. By 2014 it was huge. FWIW. 
The following code works and compiles with no errors/warning using GCC -Wall. You can also use `memcpy()`. #include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt; struct simple { uint32_t data; uint32_t more_data; }; int pass_to_f(void *arguments) { struct simple data_handler; data_handler.data = ((struct simple *)arguments)-&gt;data; data_handler.more_data = ((struct simple *)arguments)-&gt;more_data; printf("data_handler.data = %u\n", data_handler.data); printf("data_hanler.more_data = %u\n", data_handler.more_data); return 0; } int cpy_to_f(void *arguments) { struct simple data_handler; memcpy((void *)&amp;data_handler, arguments, sizeof(struct simple)); printf("data_handler.data = %u\n", data_handler.data); printf("data_hanler.more_data = %u\n", data_handler.more_data); return 0; } int main(int argc, char **argv) { struct simple data_to_send; data_to_send.data = 100; data_to_send.more_data = 200; pass_to_f(&amp;data_to_send); cpy_to_f(&amp;data_to_send); return 0; } 
This is a C sub. Try r/cpp_questions or r/Cplusplus or r/cpp
This is a C sub. Your code seems to be C#. Try r/csharp, r/AskProgramming or some other sub.
you're right! thank you.
Yeah, I just checked the commit log, and I actually started this in 2012. Regardless - if you're just going to shit on me for what color hammer I used while making this, and not actually try the code or whatever, then please go find someone else to bother.
You need to upgrade `char c` to `int c`. Check the return type for `getc()`and pay particular attention to `EOF`.
Trying to tell you I will not try your code if it's on sourceforge and that there are many who feel like I do so take it any way you want but spare me the excuse of why you chose them to host your code back then. 
From the article you linked: &gt; Since the writing of this article, SourceForge has been sold to a new company that stopped the DevShare program discussed in this article. We’re leaving this article here for historical reference, but it has since stopped these shady practices So, maybe they - and the OP - don't deserve that hate anymore? 
Got bored and wrote a short program demonstrating the various methods for dealing with struct in functions that I can think of. A pastebin for the code is [here](https://pastebin.com/RsAteDgF).
Most code should be compiled with strict aliasing disabled. Otherwise people will keep running into situations where it's impossible to reinterpret data as an array of `uint8_t` or `uint16_t`. There's really no reason why that shouldn't work.
Reading from a different struct member than you wrote is just as undefined in terms of what you’ll get out. But (at least as of C11) you won’t hit the case where you get a memory exception from trying to read at a disallowed offset if the types are different sizes. I’m guessing that on ARM and x86 most compilers will generate exactly the same code (unless the sizes of the stuff in the union forces a different offset).
Pshh. I don't need a program to make my code hard to read ;_;
I'm currently working on porting a suite of codes from HP-UX PA-RISC to Linux x86-64. The code was riddled with "gems" like packing 4 ASCII characters into a 4 byte integer and storing bit fields in doubles then using floating point arithmetic to set and get the bit flags based on comparing the results of the arithmetic with #define constants with a tolerance (because, floating point error) instead of using an int and the typical bit-wise arithmetic... 
Thanks for your input! You're right, getc() returns an int, so I made that change. I also added a check at the end using feof() after learning that getc() will also return EOF if it fails. Do you think that is sufficient?
It sounds like you may want to check out the `unsafe` keyword?
Thank you for your input! I changed it to use getopt to parse the command line arguments and added a makefile. Learning how to use getopt was a good experience. 
Just in case folks aren’t aware, a lot has changed at SourceForge since my company acquired them in 2016. No more bundled adware, all projects are scanned for malware, https downloads, and much more. We covered the improvements again here [https://sourceforge.net/blog/brief-history-sourceforge-look-to-future/](https://sourceforge.net/blog/brief-history-sourceforge-look-to-future/) AMA from when we took over here: [https://www.reddit.com/r/sysadmin/comments/4n3e1s/the\_state\_of\_sourceforge\_since\_its\_acquisition\_in/](https://www.reddit.com/r/sysadmin/comments/4n3e1s/the_state_of_sourceforge_since_its_acquisition_in/) Glad to have you with us u/wsppan !
Open any random reddit post and you'll have an 80% chance of finding one.
Cool. Got any examples of input/output transformations?
Sure! Here is a test .c file I created: #include &lt;stdio.h&gt; int main(int argv, char* argc[]) { if( 1 || 1 ) printf("Test file for digrapher: {}[]#|^\n"); return 0; } Here is the output when you use the -d option: %:include &lt;stdio.h&gt; int main(int argv, char* argc&lt;::&gt;) &lt;% if( 1 || 1 ) printf("Test file for digrapher: {}[]#|^\n"); return 0; %&gt; Here is the output when you use the -t option: ??=include &lt;stdio.h&gt; int main(int argv, char* argc??(??)) ??&lt; if( 1 ??!??! 1 ) printf("Test file for digrapher: {}[]#|^\n"); return 0; ??&gt; All 3 files compile and run correctly, but in the last example, you need to compile using the -trigraphs option with gcc. I also chose to have it ignore characters that are part of a string (in between " "). 
I think add/remove/find/iterate are the main operations you need and one of the most important criteria for choosing container type is expected number of nodes/elements. There's a huge difference between holding 50 items in memory versus 100,000. Linked lists are great for add/remove/iterate, but really bad for find if the size is large. Hash tables are the fastest for find, but you lose the ability to keep items in order (which may not matter). Arrays are good for fixed-size lists that aren't too big and you can use a binary search to find elements. You just need to think about all the pros and cons and decide which would be best for your particular use case.
Welcome to the C/C++ subs, where people have a strong opinion, which *might* be related to your post.
I have some comments: - Why did you find “writing” the config file to be a necessary feature? Can you split this out? For many apps, the config file is human updatable and only very occasionally and writing the config file programatically is unnecessary. - Why do we need another one? how does this work compare to all the other ini file parsers out there? https://github.com/compuphase/minIni https://michaeldipperstein.github.io/ezini.html https://github.com/hyperrealm/libconfig https://github.com/martinh/libconfuse https://github.com/rxi/ini
&gt; Reading from a different struct member than you wrote is just as undefined in terms of what you’ll get out. We are talking about union members, not struct members. And that is actually well-defined in C. Cf. ISO/IEC 9899:2011 §6.5.2.3 ¶3: &gt; A postfix expression followed by the . operator and an identifier designates a member of a structure or union object. The value is that of the named member,^(95) and is an lvalue if the first expression is an lvalue. If the first expression has qualified type, the result has the so-qualified version of the type of the designated member. &gt; &gt; 95) If the member used to read the contents of a union object is not the same as the member last used to store a value in the object, the appropriate part of the object representation of the value is reinterpreted as an object representation in the new type as described in 6.2.6 (a process sometimes called ‘‘type punning’’). This might be a trap representation
Sorry, but strictly speaking Sourceforge is just not secure enough. The only truly secure repository is a custom-made cryptocurrency with only two participants, each starting with an arbitrarily large amount of the currency, and each character of the source code is encoded to ASCII text and represented as set of transactions in order from one participant to the other on the day that the change was made.
C does not let you copy one array's contents into other using a simple assignment. So, your second loop is closer to be correct than the first. However, before going further: - You say the array is full and you need to make room for a new entry at the end, but you're not growing the size of the array. Instead, you're getting rid of the first element. Is that what you really want to be doing? - If you can, you might want to consider using a slightly different data structure, an array of char*'s. E..g char *hist[10]; This means you'll have to allocate (and free) each of the 10 strings separately as the array only allocates space for ten string pointers. But, overall you may find it a bit simpler/more-efficient to work with - i.e. the code from your first loop would be closer to being correct for operating on it. 
Okay, that's what I thought. Good question, in this case I do want to get rid of the first entry - the array should stay at size 10 for the assignment :)
In general, you don't have to worry about clearing - simply overwrite. Remember strings are Nul terminated. So, when you overwrite a larger string with a smaller string it won't matter because anything beyond the smaller string's Nul will be ignored.
I am disappointed that the source code in the repository is not itself digraphed. Come on! (Also, you should show an example in the README)
One of the biggest things that helped me really internalize recursion was dabbling in Scheme/Lisp. It's a programming language that pretty much forces you to use recursion even in situations where you'd use iteration in a language like C. I'd recommend downloading Racket and just messing around with some algorithms and building some really basic applications, you'll probably get the hang of it pretty quickly. A book called The Little Schemer has a really interesting approach to teaching Scheme, it helped me quite a lot. 
How big is user input? 
%d it has no size. 
This sub is for the c language only (which is different then c++). In the future you should use r/cppquestions for posts like this. But [this stackoverflow](https://stackoverflow.com/questions/4053837/colorizing-text-in-the-console-with-c) post will help you. 
the post shows how to change in general, and where you know beforehand what color you want. in my example I want to change the color in the main, that is defined inside of class B
Yep sorry I missed that part of your post. I have one possible solution as an edit to my original post, but there’s really no easy way to do it as far as I know. Maybe cpp_questions can help better. 
Your loop limit should be 9, to not reach over the end. Assuming hist\[\]\[\], try plain memmove().
while (!feof()) if fgets() looks funny in cfg\_load(). Should you keep track of line number and/or too long line, for nice error messages and to catch last\_url=lkjaslkdjasldkasldkjslakdlsakdjaskdlaskdlsakdlsakdlakdlaskdjlaskdlasklaksdlasklaskUnSecureMode=true
https://www.amazon.com/Programming-Language-2nd-Brian-Kernighan/dp/0131103628
I would recommend the following : 1. Mycodeschool- https://www.youtube.com/playlist?list=PL2_aWCzGMAwLSqGsERZGXGkA5AfMhcknE 2. The C programming language by K&amp;R
Ok. Thanks! 
In Windows 10 you can use [ANSI escape sequences](https://docs.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences) just as in *nix. However, you may have to call the Windows `SetConsoleMode` function to enable the functionality. I believe both Cmd and Powershell now enable it by default. But when the program is run in some other way it may need that `SetConsoleMode` call. 
thank you for the reply :) 
Thank you :) 
ahh okay cheers ! :) 
thank you 
You need a program to make ur code hard to read! Guess I'm gifted.
here on the **C** reddit we tend to prefer coding opengl with well... C...
The \* means "don't actually store it in a variable". I *suspect* your classmate is telling you to use it so that the newline character after the number is consumed. IMHO it's better and clearer to just use a space character instead: scanf("%d ", &amp;num1);
So when the user inputs a number for example 10, the complier scans in 10\\n? So by doing %\*c it accepts \\n? Is that what you mean?
That is very good news. 
Yes, exactly.
What value was provided for `userInput`, what output is produced, and what did you expect instead?
That way you throw away many of the guarantees of the Rust compiler, and i should not need to use unsafe blocks for everyday tasks.
Yeah but i couldn't find any subreddit for c++ so this was the best i could find. 
AIEEEEE
The [never ending finite loop](http://www.daemonology.net/blog/2010-08-02-neverending-finite-loop.html): int i,x[99];for(x[98]=i=1;x[98];i++)i*=!++x[i];
http://learn-c.org/ Not trying to be funny, it's a good resource.
Have you searched any of the MOOCS? 
Every five seconds, someone asks this question on reddit. Every 10 seconds, someone replies with the same answers.
I’m taking an intro to C course and I forget the name of the book we’re using, but I’ve acquired **C Programming: A Modern Approach** and much prefer it. I’m on mobile so can’t link it but if you search for ashley mills on YouTube, he has a really good tutorial series that I’ve been watching a lot, probably the best one I’ve watched on YouTube. Maybe I haven’t looked hard enough but most C tutorials I’ve found on YouTube are from non-native English speakers and it’s not always easy for me to follow what they say.
&gt; If you tried to do another %d right away, you wouldn't get the 34 because you've got to consume the newline character first. That's not quite correct. Many `scanf` specifiers, including `%d` read and ignore whitespace. The `␍` is whitespace.
usually memory access issues; bad/missing malloc, bad pointer math, stack overflows gdb can sometimes gloss over these (different heap structuring)
Wrong subreddit idiot
Wrong subreddit spammer. Go promote your rubbish content somewhere else 
If you simply run a program under GDB, without setting any breakpoints or watchpoints or catchpoints, your program should behave pretty much identically to running standalone. GDB doesn't need to modify or intercept the process in any way in this state. If you set breakpoints, the process image needs to be modified. Obviously your program's timing can be considerably different if a breakpoint is hit. Watchpoints (especially _software_ watchpoints) and catchpoints can also affect program timing. If your program is timing-sensitive (or it is multithreaded and has race conditions) this could change its behaviour. 
Job control related? With debugger, I see gdb as the foreground process group leader. Without, the program itself is the fg leader. $ ps axopid,tpgid,comm PID TPGID COMMAND 5106 5145 ksh 5145 5145 gdb 5146 5145 a.out PID TPGID COMMAND 5106 5193 ksh 5193 5193 a.out &amp;#x200B;
I didn't put any break points, but yeah the underlying libraries used by my program are threaded and have race conditions.
So maybe I should be using Valgrind in that case ? 
Can this change how threads and race conditions behave ?
&gt; usually memory access issues; bad/missing malloc, bad pointer math, stack overflows gdb can sometimes gloss over these (different heap structuring) There's no reason the memory layout would be any different in a program running under GDB. GDB doesn't replace the program's C library.
&gt; usually memory access issues; bad/missing malloc, bad pointer math, stack overflows gdb can sometimes gloss over these (different heap structuring) There's no reason the memory layout would be any different in a program running under GDB. GDB doesn't replace the program's C library.
It depends on what they do. Reading input from a terminal can suspend a process "that is not in foreground". Have you tried attaching to the hung process with *gdb ./a.out pid*, to see what's happening ?
&gt; I didn't put any break points, but yeah the underlying libraries used by my program are threaded and have race conditions. Hmm, having GDB shouldn't change whether those race conditions are actually problematic or not. (I mean, obviously they _are_ problematic... but it shouldn't be any "less" problematic under GDB.) When you run a program in GDB and you haven't told GDB to intercept anything, GDB is _entirely idle_. Moreover, your program's process image should be identical to that which it would have if you had run it outside of GDB. The only thing different is that the kernel knows that another program is tracing it and should be notified on certain events.
NP Despite what I said, embedded is fun. I do this kind of stuff, so hit me up if you want to chat it
I tried attaching with the pid, but I just realized I only did it when the program was already hanging. I will try to attach first, then to provoke the case that results in hanging.
Argh... I goofed. The fg process does change properly, whoever is active, debugger prompt or the debugged program. Sorry.
Isn't the already hung case as good, if better? Can you see at least the instruction pointer from the hung one ?
It has nothing to do with libraries, I've run into problems in the past where running code in debug works great but stand-alone not. It had to do with stack corruption in the cases I can recall, writing memory that wasn't allocated for a function
I've had contrary experiences.
What I kitd off are looking for is something like Codeacademy.
Thank you, I'll have a look at it! 
Thank you very much
Haha, good point! I wanted it to be readable though, so people could help me find bugs. I might have to digraph it and recommit once I'm satisfied with it! And thanks for the suggestion, I added some examples into the readme as well as a bit of explanation of what digraphs are.
Try asking on /r/opengl , that forum also has links to tutorials.
Here's a sneak peek of /r/opengl using the [top posts](https://np.reddit.com/r/opengl/top/?sort=top&amp;t=year) of the year! \#1: [OpenGL deprecated in macOS 10.14](https://developer.apple.com/macos/whats-new/#deprecationofopenglandopencl) | [86 comments](https://np.reddit.com/r/opengl/comments/8okcf1/opengl_deprecated_in_macos_1014/) \#2: [My particle based snowfall and accumulation demo, written in C++](https://v.redd.it/aji5has5nhn21) | [25 comments](https://np.reddit.com/r/opengl/comments/b3rovy/my_particle_based_snowfall_and_accumulation_demo/) \#3: [Want to share a renderer I made to educate myself on computer graphics](https://np.reddit.com/r/opengl/comments/andaa1/want_to_share_a_renderer_i_made_to_educate_myself/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/afd0dd/blacklist/)
Thanks very much, that's super helpful!
 variable = (struct abc)malloc(128 * sizeof(struct abc)); variable = malloc(128 * sizeof(struct abc*)); These are both slightly wrong. It should be: variable = malloc(128 * sizeof(struct abc)); This part: &gt; So what I'm trying to do is, copy over values from variable[i] to variable[k] such that both point to the same address i.e. &gt; &gt; variable[i].age++ implies variable[k].age++ Doesn't make a lot of sense as is. How many separate abc's do you want?
Thanks, those are good ideas. It does look like I could just do `while(fgets(...)) {}` instead and save a block. Also I like the idea of line number and printing error! Maybe I could add a "verbose" flag to cfg_init() that turns on some `fprintf(stderr, ...);` when issues are encountered. Too bad C doesn't allow default parameters.
&gt; Doesn't make a lot of sense as is. How many separate abc's do you want? I'm making an array of abcs, and then in the array, I insert abc[i] first. Then I want abc[k] to have the exact same address as abc[i], so that any changes I make to abc[i], is reflected in abc[k] as well
&gt; it makes it easier to learn other languages in the long run. Eh, yes and no. My knowledge has been greatly improved by learning how to program in C. It has put me in positions where I had to learn more about Operating Systems, Data Structures, Architecture, etc... which are all really valuable topics to learn for programming in general. That being said, I don't think C has improved my ability to work with other languages specifically. If anything it has soured me on other languages that restrict me in ways that C never would. Your mileage may vary.
I forgot to mention the *cfg\_load(cfg, "\~/.config");* in the example. You would need to expand the tilde by hand before fopen().
\+1 I've seen this behaviour too, often with a pointer miscalculation / overrun a program will consistently crash, run it in gdb and its fine (not in every case)
&gt; That's not quite correct. Most scanf specifiers, including %d, read and ignore leading whitespace. The newline character is whitespace. Only %c and %\[...\] do not skip whitespace. Just to clarify are you saying I should only use %\*c with characters as %d already ignores white space and not decimals? Does the same principle also apply with %\*d? &gt;It should be noted that using %\*c to consume the newline is thwarted if the user *doesn't* enter a newline immediately after the number Do you mean the user physically has to type in '\\n' like 10\\n when prompted with scanf? &amp;#x200B;
On FreeBSD 10, ktrace gdb ./a.out and ktrace ./a.out reveals that gdb'd a.out has 32 extra bytes on stack at entry. LINES variable has appeared in environment and argv\[0\] has changed to the full path. Automatic variables get a bit different addresses. It also has 4 extra open filedescriptors in addition to 0, 1 and 2! A pipe pair (created in gdb near NAMI .inputrc, a leak from readline?) and two opens of a.out itself. &amp;#x200B; Didn't catch any other differences. Doesn't help, but...
The sizeof(struct abc*) is giving you the size of the word size of the pointer. Your previous sizeof(struct abc) was on track. If your struct has the following: struct abc { int age; int x; int y; }; Then the sizeof(struct abc) will be 12. The sizeof(variable) will be 8 or 4 depending on your system, and the sizeof(*variable) will be 12. variable = (struct abc*)malloc(128*sizeof(struct abc)); for (int i = 0; i &lt; 128; i++) { v[i].age = i; } Also, you might want to look at pointers to pointers.
So you only want one abc and then a bunch of pointers to that abc?
This is as expected. Why is this wonky? You're taking the third index of that array. The ascii code of c is 99. 
Always use whatever is more easy to understand. The optimizer of your compiler is amazing at his job, so you will get the same assembly anyway. The only kind of optimization that you should do is (when needed) algorithmic (like using quick sort instead of bubble sort), and memory access (like using array and not linked list). In your case, you need to read at least one time the input, so `do … while` is probably the good choice.
Thank you for your help. I actually talked to the professor about this and I was misunderstanding. I assumed that two adjacent professors needed to both be executing the delay on line 7 at the same time. But in reality, he was looking for a scenario where adjacent philosophers are in "ownership" of all the chopsticks they need. so lets say eat(2) just executed line 8 and gets "held up" eat(3) can then access chopstick 3 &amp; 4 and be considerd "eating" I think this problem was just worded terribly. This particular professor is notorious for vague and unclear problems. You should see our final project -_-
If thing2 is used independently of thing1, then it can be cleaner to use a pointer so you don't have to pass thing1 around wherever you need thing2.
In the loop `for (i = 0; i &lt; 10; i++)` i will be 0 1 2 3 4 5 6 7 8 9 And exit because once i = 10, the for loop stops
What are the 2 executables supposed to do? Also, when you say 2 executables, I assume you mean 2 processes on a Linux system. Is this correct? If this is a non-Linux system, or a non-OS system, answer may vary. Is the semaphore present in shared memory between the 2 processes? &gt; This needs a redesign, right? To answer this, you need to explain what the current design is. What it is supposed to do. Why do the executables use this semaphore. How they use it. etc.
&gt;i couldn't find any subreddit for c++ Check out r/cpp , r/cpp_questions, r/Cplusplus
&gt; What are the 2 executables supposed to do? The one is like a data layer that populates the semaphore. The other is a GUI that displays the data from the semaphore. &gt; Also, when you say 2 executables, I assume you mean 2 processes on a Linux system. Is this correct? Yeah, POSIX semaphores on a Linux box. &gt; Is the semaphore present in shared memory between the 2 processes? Yeah. The `list` array is accessible from the GUI and has data but any attempt to access `sorted_list` from the GUI causes a segfault. Currently `sorted_list` is supposed to be used to perform a binary search from the GUI. From the data layer, `sorted_list` is populated before the semaphore lock is released.
This information would be useful in the main body of the post to describe your system (rather than calling it a "pile of shit"). That way people could easily find out - 1. How things are supposed to work. (Expectation) 2. How they currently work (Reality) 3. What you have tried to make it work (Effort) And provide appropriate advice/recommendation/help. Coming back to your question, From what you said, it seems one `struct db` object is shared between the 2 processes. In the `struct db` object, there are `MAX+1` pointers pointing some data. Is this data also shared? Specifically, are all the `list_obj` pointed by the `sorted_list` element, mapped to the shared memory by both the processes? For example, is `*sorted_list[0]` mapped to shared memory for both processes to use?
Understood. Correct. One `struct db` is what's shared. Each pointer in `sorted_list` points to an item in `list` and the items in `list` are accessible from both. 
I hadn't seen those others before starting this one, although I didn't look very hard... Some look more complex than I need (a library?). Oh well. Writing the file out was helpful for me, because sometimes I have an in-app "settings" panel that users can enable or disable stuff. I can then write the config file back so settings are saved across sessions. Though that can be troublesome as stripped comments aren't preserved. So maybe it's less of a "config file" and more of a "persistent settings" manager or... I don't know what to call it :)
One consideration is that your nested struct is way more cache-friendly, which may or may not matter depending on what you're doing.
Now your question seems clearer. Does the shared memory in process 1 have the same address as shared memory in process 2? Only then the addresses stored in those pointers would make sense. Otherwise those are just garbage values. Personally, instead of storing pointers in the sorted_list, I would have stored indices to the list. That way it becomes portable. 
&gt; Does the shared memory in process 1 have the same address as shared memory in process 2? Only then the addresses stored in those pointers would make sense. Otherwise those are just garbage values. Exactly what I believe the issue to be. I just wanted to make sure I wasn't losing my mind, thanks man. &gt; Personally, instead of storing pointers in the sorted_list, I would have stored indices to the list. That way it becomes portable. I'm wavering between this and just not sorting the data before I search it. The new hardware I was given is massive overkill and while I can profile the difference, I doubt it will be significant.
When considering the memory layout of nested structs, if you had e.g. structs A, B, and C and needed the contents of A in both B and C, as long as struct A is in the beginning of both B and C, you can cast a B to C or a C to B or to A and manipulate the contents of the same A struct through any three. Or use unions. &amp;#x200B; With that said, pointers are a cleaner way, of course, but nesting is more cache-friendly.
Can you explain a little more about your design of the combination of linkedlist and hashmap? Trying to learn some design skills here. Thank you very much. :)
There is no accepted rule. Sometimes you need a pointer, sometimes you don't. If you're embedded in another struct, you need to take into consideration the memory copy if you're not using a pointer. If you're using a pointer, then keep track of the memory so you don't have a leak. Also, with a pointer you lose the ability to down or up cast. struct thing1 { int x; int y; }; struct thing2 { struct thing1 vec; int w; int h; }; struct thing2 rect; struct thing1* pv = (struct thing1*)&amp;rect; pv.x = 0; pv.y = 0; 
Might want to try the cplusplus subreddit?
thank you didn't know about it
If you understand how a hashmap with separate chaining works then it's a pretty simple concept. I won't go too into detail on that because Wikipedia has a good section on it, but just imagine instead of a separate linked list for each bucket, all values are stored on a single linked list and the order of that list is used for collision resolution. I have some code if that doesn't make sense, but it's part of a bigger project and maybe harder to understand.
Ah interesting, thanks!
Do I understand that you don't want 128 structs? But 128 pointers, which in turn may or may not point to the same struct. So that variable[i] and variable[k] point to the same struct even when i != j? You can that with: struct abc *variable[128]; and allocate each pointer with: variable[i] = malloc(sizeof(struct abc)); and copy the pointer with: variable[j] = variable[i]; Bear in mind, you'll probably have difficultly keeping track of all your objects without some reference counting mechanism.
Could you maybe show me a way you would do that? 
If you mean after the function return, it doesn’t matter whether that reference was `const`; if you have some non-`const` access to it outside of that function, use it. If you mean inside the function, you have to either `const_cast` (*strongly* recommend against this unless you’re quite sure what you’re doing), or whatever you need to change in the `Cell` has to be declared `mutable`. Ideally, you shouldn’t be taking a `const` reference to something that you need to change through that reference.
A lot of the time, either you have to pack a bunch of prompting/input crap into the condition of a `while`, or you have to just set up some otherwise-infinite loop (e.g., `for(;;)`) and `break` out of it from inside. If you want to use a normal `while`, you’ll probably want to put your prompt+input stuff into a function so you can just do (e.g.) while(getInput(&amp;out) &amp;&amp; (out &lt; 500 || out &gt; 100)) { .... }
A bit OT, but don’t put the `struct abc *variable` declaration in your header. If you want multiple C files to be able to refer to it, do extern struct abc *variable; in the header and then `struct abc *variable` in exactly one .c file, so you don’t end up with multiple `variable` symbol definitions clashing at link time. Also, term of art: a “variable” inside a `struct`/`union` is a field.
So, as others said, the pointer style can be useful for situations in which thing2 is needed in other contexts independent of thing1. Or you may want multiple thing1's to share the same instance of thing2. Or you may want to quickly swap out different thing2's for each thing1. Another use-case for going the pointer route is if thing2 is big (in terms of bytes) and only a few thing1's actually need the thing2. Ie. if most uses of thing1 don't actually have any valid data in thing2, then you can leave the pointer NULL in those cases and not allocate an instance of thing2, saving memory. If none of the above is the case, then going with the nested approach will certainly simplify the code and probably give you better performance.
userInput is inbetween 1 to I think like 6 digits. Heres my output. Menu 1. calling displayAllDigit() 2. Quit Enter a Number: 1 Enter an interger: 123456 Calling displayAllDigit() with argument of 123456 - Positive 5 4 3 2 1 Number should be 6 Must be even? 0 Menu 1. calling displayAllDigit() 2. Quit Enter a Number: -9 Wrong option Menu 1. calling displayAllDigit() 2. Quit Enter a Number: 1 Enter an interger: -9 Calling displayAllDigit() with argument of -9 - negative 0 0 0 0 0 Number should be 1 Must be even? 0 Menu 1. calling displayAllDigit() 2. Quit Enter a Number: &amp;#x200B; &amp;#x200B;
No. You'll be picking one depending on your constraints, like cache-friendlessness, ABI stability, amount of memory available, etc.
ahh ok that makes a lot of sense. thanks!
Just open the file with binary append and write to it as you normally would. &amp;#x200B; `fopen("strings.bin","ab");` &amp;#x200B; You'll need to use a delimiter though to know where a new string starts and ends. You could do something like writing the length of the string at the beginning of each string too, to know how much to read. 
use a nested struct when you can, to improve cache locality, or just because it tends to be simpler. use pointer indirection when you have to, either for non-owned references or to avoid copying large structs.
be sure to look at the documentation for ‘’’strtok()’’’
float or am i missing something
Assuming the memory allocator (including `mmap`) is deterministic, there should be absolutely no difference in memory allocation behaviour when the program is run under GDB. Of course, memory allocators *aren't* deterministic &amp;mdash; deliberately so in the case of things like ASLR... but that just means your program won't have consistent behaviour even outside of GDB.
float/double use base-2. Some languages have a base-10 floating point type (i.e decimal, BigDecimal, etc...). I need portable base-10 floating point type in C.
Can you explain how a contrary experience could occur?
 &gt;Just to clarify are you saying I should only use %\*c with characters as %d already ignores white space and not decimals? Note that I said *leading* whitespace. `scanf("%d", &amp;v)` means: * First, read and ignore any number of whitespace characters. * Then, read one or more decimal digits, as many as are available, and write to `v`. &gt;Does the same principle also apply with %\*d? The `*` modifier doesn't change anything. &gt;Do you mean the user physically has to type in '\\n' like 10\\n when prompted with scanf? No, I mean that if the user entered: 10foobarbazbiff your `%*c` would read and ignore the `f` only, and you'd still be bother near the end of the inputted line. 
I think this is what I need! I'll give it a shot! Thanks :) 
&gt; Also, term of art: a “variable” inside a struct/union is a field. Yes I'm aware, my brain just wasn't very functional at 1 AM :( Thanks anyway haha
I tried pointers to pointers, but somehow I managed to screw it all up, still open to trying it again, just need to figure out where my system dies
The following works. It's most of the way to functionality that you can place in reusable headers. Note however that between 16-bit Windows 3.1, and Windows 10, Windows console windows did not support ANSI escapes. #include &lt;optional&gt; // std::optional #include &lt;sstream&gt; // std::ostringstream #include &lt;stdint.h&gt; // uint32_t #include &lt;string&gt; // std::string #include &lt;utility&gt; // std::move //------------------------------------------------------- Some basic support machinery: #define WITH( initializer ) if( auto&amp;&amp; _ = initializer; true ) namespace string_building { using std::string, std::ostringstream; template&lt; class Type &gt; inline auto operator&lt;&lt;( string&amp; s, Type const&amp; value ) -&gt; string&amp; { ostringstream stream; stream &lt;&lt; value; s += stream.str(); return s; } template&lt; class Type &gt; inline auto operator&lt;&lt;( string&amp;&amp; s, Type const&amp; value ) -&gt; string&amp;&amp; { return move( operator&lt;&lt;( s, value ) ); } } // namespace string_building #ifdef _WIN32 // Windows, either 32-bit or 64-bit. // DIY declarations because &lt;windows.h&gt; defines a zillion dangerous macros, and // pollutes the global namespace. All functions below from "kernel32.dll", hence // no special linking required. namespace winapi { using Bool = int; using DWord = uint32_t; using Handle = void*; //--------------------- Standard stream handles: const DWord std_input_handle = DWord( -10 ); const DWord std_output_handle = DWord( -11 ); const DWord std_error_handle = DWord( -12 ); extern "C" auto __stdcall GetStdHandle( DWord nStdHandle ) -&gt; Handle; //--------------------- Console mode: const DWord enable_virtual_terminal_processing = 0x0004; extern "C" auto __stdcall SetConsoleMode( Handle hConsoleHandle, DWord dwMode ) -&gt; Bool; extern "C" auto __stdcall GetConsoleMode( Handle hConsoleHandle, DWord* lpMode ) -&gt; Bool; } // namespace winapi namespace windows { using std::optional; const winapi::Handle in_stream = winapi::GetStdHandle( winapi::std_input_handle ); const winapi::Handle out_stream = winapi::GetStdHandle( winapi::std_output_handle ); const winapi::Handle err_stream = winapi::GetStdHandle( winapi::std_error_handle ); inline auto set_console_mode( const winapi::DWord mode_bits ) -&gt; bool { return !!winapi::SetConsoleMode( out_stream, mode_bits ); } inline auto console_mode() -&gt; optional&lt;winapi::DWord&gt; { winapi::DWord result = 0; if( not winapi::GetConsoleMode( out_stream, &amp;result ) ) { return {}; } return result; } } // namespace windows class Ansi_terminal_mode { bool m_has_console; winapi::DWord m_original_mode; public: auto has_console() const -&gt; bool { return m_has_console; } ~Ansi_terminal_mode() { if( m_has_console ) { windows::set_console_mode( m_original_mode ); } } Ansi_terminal_mode() { if( const auto mode = windows::console_mode() ) { m_has_console = true; m_original_mode = mode.value(); windows::set_console_mode( m_original_mode | winapi::enable_virtual_terminal_processing ); } else { m_has_console = false; } } }; #else class Ansi_terminal_mode { public: auto has_console() const -&gt; bool { true; } }; #endif //------------------------------------------------------- ANSI escape sequences: namespace ascii { char const escape = char( 27 ); } namespace ansi { using std::string; using namespace std::literals; // E.g. ""s auto format( const int n ) -&gt; string { using namespace string_building; return ""s &lt;&lt; ascii::escape &lt;&lt; '[' &lt;&lt; n &lt;&lt; 'm'; } auto reset() -&gt; string { return format( 0 ); } auto bg_white() -&gt; string { return format( 107 ); } auto red() -&gt; string { return format( 91 ); } auto blue() -&gt; string { return format( 94 ); } } #include &lt;iostream&gt; using std::cout, std::endl; auto main() -&gt; int { WITH( Ansi_terminal_mode() ) { cout &lt;&lt; ansi::bg_white(); cout &lt;&lt; ansi::blue() &lt;&lt; "hello world" &lt;&lt; endl; cout &lt;&lt; ansi::red() &lt;&lt; "error to the world" &lt;&lt; endl; cout &lt;&lt; ansi::reset(); // To not leave the console with last used colors. } } 
What for?
A financial pricing model application.
are you asking about precision of the floating point type 
I am not. 
100% this. This is a little off topic, but a lot of people focus too much on micro optimizations, like ++i vs i++ and don't focus enough on algorithmic optimizations. These micro optimizations often lead to code that is much more difficult to read, maintain, and optimize later.
When talking about currency, I've always used integer types, and simply decide ahead of time the minimum divisible value you want to represent. (Then convert accordingly). Surely `long long` should give you enough space to work with?
I'm not sure why `float` or `double` (or maybe even `long double`) wouldn't work just fine. Numbers are numbers, after all, and `printf` can show you the decimal equivalent of your results just fine. If you *must* use a binary-coded decimal format internally, it'll probably slow things down quite a bit. Your processor(s) likely have floating-point units designed and built to use a base-2 format, so code using a BCD format wouldn't be able to take advantage of the hardware. If precision and rounding errors are major concerns, consider using a BigInt library and just scaling all your values so that they represent integer numbers of 100000ths of cents or something. Floating point math often causes some loss of precision; integer math does not.
And managers wonder why programmers get grumpy. They *wonder.* ;] 
You can simply include an expression like: float f = 3.0; C recognizes the "3.0" as a floating point constant; it' part of the C language standards. To display the number, use something like: printf ("%f\n", f); Again, printf is part of the C standard library. Examples like these are included in every basic C tutorial... is there's some other factor that you mean by "portable." 
This is actually a good idea. 
Just offering my $0.0000000000000000002
I don't think you understand what I am asking. I have been a C programmer for a long time and understand float/double well. I am specifically asking if anyone has found a library for base-10 floating point numbers in C. For example, in C# and Java both have float and double data-types. For base-10 floating point numbers, C# has a decimal data-type and Java has BigDecimal. C does not have a built-in decimal type. However, I wouldn't be surprised if there is a library since all of these language implementations (i.e JVM and CLR) have support for base-10 floating point types.
What are you talking about? Cache-friendlessness?!?! Why are you making up words. ABI stability? This has nothing to do with anything. Don't waste others time.
Not 100% sure it has that but check out the [GNU Multiple Precision Arithmetic Library](https://gmplib.org/).
For pointer to pointers, define the pointer to a pointer. struct abc** pptr; Then allocate the number of items you want. struct abc** pptr = (struct abc**)malloc(128 * sizeof(struct abc*)); Now with a for-loop, allocate the memory for each pointer. for (int i = 0; i &lt; 128; ++i) { pptr[i] = (struct abc*)malloc(sizeof(struct abc)); pptr[i]-&gt;age = i; pptr[i]-&gt;x = 1; pptr[i]-&gt;y = 2; } Be sure to clean this up, or you will leak memory. 
"Programing"
None that I'm aware of, but it still seems easier to me to use isdigit () in a range-checking function to make sure to make sure that the numbers are all decimal, and limits.h contains the minimum and maximum values for each numeric type. It seems like the generic resources are already present. If I wanted to use numbers larger than an unsigned long long, personally I would use a most significant word/least significant word struct. The nanosleep function uses this scheme to keep track of nanoseconds. The purpose of having a separate class for a data type is that the type needs some kind of unique handling, I don't think it would be too difficult to put a class or library together as the specifics of the numeric handling become apparent. Hope this helps.
Maybe gdb -p &lt;hung_program's_paid&gt; word allow you to view the actual memory space where the program is hanging. 
Oops, that should be &lt;hung_program's_pid&gt; (auto completion should qualify as computer humor, I think)
I watched a basic course on youtube and just wrote stuff. \- Other things which are important: Try to use pointers in a crazy way at the start to learn how they work \- Read all the warnings and understand them \- debug your code without the help of forums, use your debugger! &amp;#x200B; Things which helped me even more: \- OpenBSD's malloc.conf (protection tool for your memory usage) + manpages (very well written manpages for nearly everything) &amp;#x200B; The learning curve of C sucks, there's no easy way to get through that
Thank you so much!
Thanks mate!
Yeah, strtok() is the key to slice file lines as you want. Is a powerful function worth to know. Good tip u gave him
Thanks a lot! This was very helpful! I did it. I used the last method you described. Every time I have to add more text, I store the information about length in the first 2 bytes. Later, when reading, I use one while loop and 2 fread() functions. It works. Once again, thank you very much! 
Whoa! You need to walk before you can run. Break your task down into manageable sized pieces. I suggest starting with just debugging the first few lines of your program. - prompt the user for a password - read the password they entered - print out the password they entered (i.e. prove you read it correctly) To help get you started I can tell you that your call to `scanf` does not do what you think it does. Read up on `scanf`. Specifically, when you use `%s`, what type of corresponding argument does it expect to write the data into (hint: it's not an `int`). Once you've convinced yourself you've correctly read what the user entered, then you can start to worry about looping over it, checking if it meets your password criteria.
Wow thank you so much! Yeah I always try to run before I can walk, maybe it’s a time to fix that habit.. thanks for a good advice and tips! 
Maybe instead of pw being an int do something like ``` char pw [50]; ``` I imagine password shouldnt be just integers.
FILE *pf = fopen("name.rb","r+b"); ^^reads and writes contents of a file fseek(pf, 0, SEEK_SET) and scan until EOF when you want to read contents. fseek(pf, 0, SEEK_END) and fwrite to append to file.
&gt;Numbers are numbers, after all I wouldn't be so sure. Floating point numbers are merely _approximations_ of numbers, nowhere close to exact values. For applications where exact numbers and exact math are crucial (i.e. finance), floating point numbers just don't cut it.
When i is 9, hist\[i + 1\] reaches over the end.
Division is not valid if the denominator is zero. Definitely skip the division if the second number is zero. I'm not sure what you should do if the second number doesn't evenly divide the first number, but you can use `a % b` to get the remainder from a division of a by b, and if that's zero, the numbers evenly divide.
BTW, you can streamline it a bit by reading character by character, classifying them on the go ("this is a lowercase letter, this is a digit...") and increasing the counters. Then just compare the counters with requirements. The sum of all counters is the length of entered password. No need for an array, unless you must do something with the password later - in that case, store characters in an array after classification. Keep in mind that C does not check array bounds!
[https://man.openbsd.org/scanf.3](https://man.openbsd.org/scanf.3) RETURN VALUES These functions return the number of input items assigned, which can be fewer than provided for, or even zero, in the event of a matching failure. Zero indicates that, while there was input available, no conversions were assigned; typically this is due to an invalid input character, such as an alphabetic character for a ‘%d’ conversion. The value EOF is returned if an input failure, such as an end-of-file, occurs before any conversion. If an error or end-of-file occurs after conversion has begun, the number of conversions which were successfully completed is returned. Code #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;err.h&gt; int main() { int i; if (scanf("%i", &amp;i) == 0) err(EXIT_FAILURE, "%s: scanf() failure", __func__); return EXIT_SUCCESS; } If you input a letter, err() gets executed
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
No blog spam please.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
There is a C extension for decimal floating point numbers, but I think only IBM supports it so far.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Glad I could help :)!
Thanks, This is how far I've come with my code: #include &lt;stdio.h&gt; int main(void) { int Integer1, Integer2, Sum, Product, Division; printf("Input the first integer\n"); scanf("%d", &amp;Integer1); printf("Input the second integer\n"); scanf("%d", &amp;Integer2); Sum=Integer1+Integer2; Product=Integer1*Integer2; Division=Integer1/Integer2; printf("The sum is %d\n", Sum); printf("The product is %d\n", Product); if(Integer2 ==0) { printf("The integers are invalid for division\n"); } if (Integer1 % Integer2 == 0) { printf("The division is%d\n", Division); } return 0; } However, when I add 0 for Integer2, I get this error: Thread 1: EXC_ARITHMETIC (code=EXC_I386_DIV, subcode=0x0) Why doesn't it just execute the first if statement? Do you have any recommendations on what I should do?
Alrighty, I’ll try that way too. Thanks heaps!
That’s true..! I feel like I’m missing bits everywhere. One of the reasons to study basics properly again.. 
The line `Division=Integer1/Integer2` is run regardless of the value of Integer2. If Integer2 is zero and that line is reached, *undefined behavior* occurs. In your case, the program crashes, but with a different compiler, literally anything could happen. 
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main() { char pw[50]; int chars[256]; printf("Please enter the password\n"); fgets(pw, sizeof(pw), stdin); int i; for (i = 0; i != 256; i++) chars[i] = 0; for (i = 0; i != strlen(pw); i++) { chars[(int) pw[i]]++; } for (i = 0; i != 256; i++) { if (chars[i]) { switch((char) i) { case '\n': printf("\\n\t%i\n", chars[i]); break; default: printf("%c\t%i\n", (char) i, chars[i]); break; } } } return 0; } Here's one of a million ways to achieve your goal &amp;#x200B; Input: password1234HHH Output: \n 1 1 1 2 1 3 1 4 1 H 3 a 1 d 1 o 1 p 1 r 1 s 2 w 1
I think I solved it: if(Integer2 == 0) { printf("Division contains zeros\n"); } else { printf("The division is %d\n", Integer1/Integer2); } return 0; } I just removed the "Division" variable and moved it to after the first IF-statement. Now I am not sure how to turn the division into decimals? Lets say I want to divide 7/2, the program only rounds the number to 3. I've read something about using float but do I then have to change every variable to float? 
So a little while ago I wrote [this](https://github.com/VKoskiv/c-ray/blob/6f503aa4e5a06e4b8a508991fcacdc1b32df1eef/src/renderer/renderer.c#L119), what I thought to be more vectorizable, but apparently it's not. It's just barely a hair faster than the normal render-loop, and a lot uglier. Anything I might be doing wrong?
Try this instead of that huge control block: &gt;if (input &gt;= 'a' &amp;&amp; input &lt;= 'z') { &gt; Beep(250 + 50 * (input - 'a')); &gt; putchar(input); &gt;} I'm on mobile and I don't do Windows programming but I think that should work, idk if I got the character printing function name right might be putch() or something
No way. You’re my hero 🦸‍♂️ Thank you!!! 
&gt; **#**SQRT &gt; &gt; const can define complex constants too. What a shitty article on an easy concept. It doesn't even explain when and why you'd chose one over the other. 
replace the first if(input == 0 || input == 0xe0) with while(input == || input == 0xe0) it does the same thing, just repeatedly until the user presses a valid key
I’m aware of that, hence the statements about precision and integers. Also, OP is looking to make *predictions*, which aren’t going to be exact anyway, and *specifically asking about floating point*.
You mean why the if(1)? Maybe someone wants to see which ASM Code generates ? I Guess if u use strong optimization the line is nonsense. Just writing my thougs no real facts
It's one way to add "debug code". You can include or exclude this block easily by changing `1` to `0` and vice versa. Preprocessor macros are better for this though.
- To create a new scope; so the variables inside wouldn't get carried outside. But the variable got removed - Maybe it had a condition but the condition was no longer valid and got removed Nevertheless compiler probably would skip the conditional as if there's no "if".
This looks like a log entry for debugging, possibly the idea would be to disable the block (`if(0)`) for the final product? Note that this doesn't make it a *good* idea. Normally, something like this would be protected by `#ifdef DEBUG` or `if(VERBOSE_LOGGING_ENABLED)`
I'd say it's a placeholder that helps you structure the code until you've worked out all the kinks. I think it's a bad habit that comes naturally from a lack of planning and a bad/naive workflow. I did it a lot when I started programming but I don't do it anymore.
&gt;To create a new scope No need for the if statement to create a new scope tho
Person who wrote it may not knew that
Should've probably added the source of the code: https://github.com/golang/go/blob/dee07c884e190c14caf1f82288455d37707da6bf/src/runtime/runtime.c#L993 Written by Ken xD
It can also go the other way. If thing2 is \_not\_ used a lot, it doesn't take up space in cache.
Ken Thompson wrote it hahaha
the most basic level of optimization removes dead code paths, so functionally it's the same as using an #ifdef. That said, ifdef does make more sense.
Ah! IBM software is always a pleasure to work on? (not)
Java’s BigDecimal uses powers of 10 for scaling, but that’s about the only sense in which it’s “base-10”.
I’ve just checked, and their suggestion is close to how Java’s BigDecimal works, if that helps you with your decision-making.
ifdef makes less sense because you want the compiler to parse the code for errors otherwise whenever anyone tries to make a debug build after a while they first have to fix a ton of crap code using variables that no longer exist etc
so pretty clearly it's modified from `if (debug)` (see all the other routines there). maybe at some point he's planning to change it back.
I have no super power to confer the author from the code, sadly. Nevertheless, it looks like an unfinished block of code.
You have to think if readibility of the code as well. No piece of code should have 16 people discussing what it does and how it works.
Wow. Seems complex Thanks. I’ll try and understand it 
That's a very good point.
That's easily addressed by having automated testing that compiles both ways.
You could also do `if (DEBUG) { ... }` where DEBUG is either a constant or a preprocessor macro, defined as either one or zero. That will compile the code inside the if statement, and allow debug-mode to be enabled or disabled from one location.
So you detect the problem when it reaches the master branch? And now you have to open a ticket and assign it to someone, then wait for it to reach master again. Meanwhile nobody can build with debug enabled unless they duplicate the effort of fixing it. Or just have the dev who broke it get the error immediately and nobody has to waste time on this. 
That's exactly what the person two comments above me suggested, which the comment above me declared as making less sense than an ifdef
Uh, no. Pre-merge CI is a thing that exists and works.
&gt; So you detect the problem when it reaches the master branch? So you're in the habit of committing and merging untested code?
Could you search for something which wraps the Intel binary coded decimal instructions, and go from there? Sorry, too lazy to do so myself ;)
You are correct, I amended my comment.
I have personally seen this exact situation and the guy was very surprised when I told him you don't need a statement. It's funny he knew enough about lock guards to know he needed the scope, but had never learned this.
How did you get (code) formatting on mobile?
So you want to automate the debug build compilation on all branches? 
I'll agree with you here, OP is asking the question in the worst way possible which is why he's getting to many "wrong" answers.
It's pointless to have it do the debug build in case you broke it, instead of always having the devs fix it immediately. The CI cluster's time is precious 
I would pick this and go with the #ifdef. While I do trust that the compiler will optimize away a dead code path consistenly, I don't want anything hanging around for a code reuse exploit. That said, I think both methodologies will have their ups and downs. Pick one knowing the tradeoffs and stick with it.
 Like this
Hot damn. That, my friends, will put some hair on your chest. In a somewhat related yet much more humane vein, writing a crude file system for my college operating systems course was my springboard into C confidence. It took me from a beginner to something approaching intermediate ability. If anyone wants to learn pointers before punting around electrons, learning how filesystems work is a good way to do it. 
Any if statement that evaluates to not zero will execute. That is why one will do this.
Keep in mind that you don't need to understand the inner workings of everything in order to use it. E.g. you're using `cout`, and like me you probably have only a vague idea about the details inside that thing. Same as with driving a car. You can drive it without knowing the complex circuits and programming of the car's engine control computer (if it has one). Anyway I tried now to reduce the above code , mainly by using my own *cppx-core* header-only C++17 library (note: still very much under construction). In this rewrite the `$` names are macros from that library, that provide a more concise notation. #include &lt;cppx-core/_all_.hpp&gt; // https://github.com/alf-p-steinbach/cppx-core //------------------------------------------------------- Some basic support machinery: #ifdef _WIN32 // Windows, either 32-bit or 64-bit. // DIY declarations because &lt;windows.h&gt; defines a zillion dangerous macros, and // pollutes the global namespace. All functions below from "kernel32.dll", hence // no special linking required. namespace winapi { using Bool = int; using DWord = uint32_t; using Handle = void*; //--------------------- Standard stream handles: const auto std_input_handle = DWord( -10 ); const auto std_output_handle = DWord( -11 ); const auto std_error_handle = DWord( -12 ); extern "C" auto __stdcall GetStdHandle( DWord nStdHandle ) -&gt; Handle; //--------------------- Console mode: const auto enable_virtual_terminal_processing = DWord( 0x0004 ); extern "C" auto __stdcall SetConsoleMode( Handle hConsoleHandle, DWord dwMode ) -&gt; Bool; extern "C" auto __stdcall GetConsoleMode( Handle hConsoleHandle, DWord* lpMode ) -&gt; Bool; } // namespace winapi namespace windows { $use_std( optional ); namespace impl { using namespace winapi; const Handle in_stream = GetStdHandle( std_input_handle ); const Handle out_stream = GetStdHandle( std_output_handle ); const Handle err_stream = GetStdHandle( std_error_handle ); } // namespace impl $use_from_namespace( impl, in_stream, out_stream, err_stream ); inline auto set_console_mode( const winapi::DWord mode_bits ) -&gt; bool { return !!winapi::SetConsoleMode( out_stream, mode_bits ); } inline auto console_mode() -&gt; optional&lt;winapi::DWord&gt; { winapi::DWord result = 0; if( not winapi::GetConsoleMode( out_stream, &amp;result ) ) { return {}; } return result; } } // namespace windows class Ansi_terminal_mode { bool m_has_console; winapi::DWord m_original_mode; public: auto has_console() const -&gt; bool { return m_has_console; } ~Ansi_terminal_mode() { if( m_has_console ) { windows::set_console_mode( m_original_mode ); } } Ansi_terminal_mode() { if( const auto mode = windows::console_mode() ) { m_has_console = true; m_original_mode = mode.value(); windows::set_console_mode( m_original_mode | winapi::enable_virtual_terminal_processing ); } else { m_has_console = false; } } }; #else class Ansi_terminal_mode { public: auto has_console() const -&gt; bool { true; } }; #endif //------------------------------------------------------- ANSI escape sequences: namespace ansi { using namespace cppx::basic_string_building; $use_namespace_name_in( cppx, ascii ); inline auto format( const int n ) -&gt; string { return ""s &lt;&lt; ascii::escape &lt;&lt; '[' &lt;&lt; n &lt;&lt; 'm'; } template&lt; int n &gt; inline auto format_() -&gt; string { return format( n ); } // Named function pointers: const auto reset = format_&lt;0&gt;; const auto bg_white = format_&lt;107&gt;; const auto red = format_&lt;91&gt;; const auto blue = format_&lt;94&gt;; } #include &lt;iostream&gt; $use_std( cout, endl ); auto main() -&gt; int { $with( Ansi_terminal_mode() ) { cout &lt;&lt; ansi::bg_white(); cout &lt;&lt; ansi::blue() &lt;&lt; "hello world" &lt;&lt; endl; cout &lt;&lt; ansi::red() &lt;&lt; "error to the world" &lt;&lt; endl; cout &lt;&lt; ansi::reset(); // To not leave the console with last used colors. } } 
This problem is not simple at all. The way I'd begin approaching this problem is to first find the smallest grid size that could possibly work. In this case, there are 8 pieces, and each piece has 4 'cells' so there must be at least 32 cells in the grid. A 5x5 grid has only 25 cells, which is too small, but a 6x6 grid has 36 cells, which can fit 32 cells. So the problem becomes, can you fit the given pieces into a 6x6 grid? If the answer is no, try 7x7, then 8x8, et cetera. Now, forgetting about the computer, how would you approach the problem of fitting the given pieces into a 6x6 grid?
Seconding the Make suggestion, even for really raw newcomers. Reading good code is vital to learning how to write good code, and it would be very, very challenging for a beginner to read and understand a production-quality C codebase without understanding Make. 
Spend a couple months learning a Lisp and build something with it. Thinking recursively requires some new brain muscles. It never clicked for me, either (it still hasn't, if I'm being honest--hence me writing C for a living), until I just sat down one summer and brute forced it. 
integer division returns an integer so it cannot have decimals. what you can do is cast to float (lookup c type casting), this way: `(float)Integer1 / (float)Integer2` example here https://ideone.com/IyHNl3
Please correctly format your code. Either indent all code by 4 spaces (if using markdown editor) or use the code block format option (if using the fancy editor, it is under the 3-dots)
Also, what functions don't work? You haven't said, and we don't have the data to run it ourselves. Also, what have you tried and where are you stuck? Please put in a minimal effort when asking questions.
sry my bad first time posting here. Its the minarray that's giving me trouble
the minarray function, ive even tried setting it up as an array and using pointers to try and combine the minarray and minarrayday functions to no avail
.... yes.
The format is now correct, thank you.
Check the sporadic i &lt; 366.
is this an alternative for if(true)??
That fixed thank you 
If you take input from stdin, you can use polling with timeout. `select()` can do that. Your platform may also provide better pollers, like epoll. 
What compiler errors are you receiving?
`benchmark.c:71:11: warning: format ‘%s’ expects argument of type ‘char *’, but argument 2 has type ‘int *’ [-Wformat=]` I don't need to do this in C however it's more of a personal challenge and development plan. I work as a Sys admin felt it was important to start writing in C.
A big part of being a sysadmin is also being comfortable in a heterogeneous environment and knowing the rights tools for a job. Calling processes from inside a C program is generally bad "code smell"; usually, there is either a library you can link to (for postgres in this case) and do the same thing faster and with more power, *or* you can leverage input redirection and the wealth of command-line tools and/or shell built-ins to write a one-liner in seconds. Or, you might use C to write a modular program called "average" which simply computes the numeric average of many lines of arbitrary numeric input, then compile that program and pipe your command to it. Regardless, in `scanf("%s", &amp;num[i]);` you are reading `char *` data as specified by `%s` (s for "string"). Then you are trying to put that data in an array of `int`, and C does not like that. So just change `%s` to `%d` in this line. 
&gt; Floating point numbers are merely *approximations* of numbers That's misleading. Floating point numbers are exact, they are just exact representations of base-2 numbers. Each of the 4,294,967,296 possible values that a 32-bit float could have corresponds *exactly* to a finite base-2 number with a terminating decimal (or whatever the numbers after the radix point are called in other bases).^[note] Those values may not have an exact decimal representation in base-10 or any other base, and base-10 numbers may not have an exact representation in base-2 floating point, but these kinds of floating point representations in any base *are* exact... in their own base. You're not wrong; floating point numbers don't cut it when you need exact math *in base-10* or exact math that preserves precision. But to say that it's because floating point numbers are inherently approximations is inaccurate. [Note]: Except for the handful of values used as traps for NaN, +Inf, -Inf, etc. And there's also some weirdness with +0.0 and -0.0 being different values, which AFAIK isn't normally a thing mathematically.
Is what you're looking for something on https://en.wikipedia.org/wiki/List_of_arbitrary-precision_arithmetic_software?
Mostly yes, but C doesn’t have a `true` keyword. (You can get a macro `true` via `#include &lt;stdbool.h&gt;`, but it’s just `1` IIRC, not even `(_Bool)1`.)
Your easiest options are using multiple threads, or `select`/`poll`. (I’d avoid OS-specific stuff like `epoll`, which often take more setup, are more complicated to use, and are optimized more for really high-volume stuff than just stdin+delay.) If you’re fine burning the fuck out of the CPU, you can set FD 0 to `O_NONBLOCK` and continuously check that + the current time. You might need to twiddle the TTY driver via `ioctl` or equivalent, because it’ll line-buffer by default.
First I don't think that everybody is better than you. Learn programming needs time and training. I'm in my 8th Semester and I really learned it when I start working as a Software Developer 14 hrs a week in the 7th Semester. So you can learn it if you look for a job while you do a CS degree or programming every day 1-2 hours for yourself at home. Sorry for my bad english. If you need an idea what you could code: Write a little Game, a calculator for the topics in Math class or maybe a Game engine Hope I could help you :)
This is highly subjective and it rather depends on your personality and temperament. But I'll take a stab at it ... You stare at a piece of code for 3 hours and get nowhere? You should try looking at it differently, then. I usually understand things best when I can see them work. Run the code with some test data. Use print statements or a debugger to see what the code is doing at each step. C is a pretty tough language with a lot of trapdoors so you can try coding something in Ruby or Python before coding it in C.
Do you have any examples of C code or concepts that you are having trouble understanding?
all the data structures, lists, nodes, structs, pointers... I could send you in pm an assignment we recently had to do using breadth first search and in which I had no idea how to proceed. (be warned, it's not easy!)
Data structures build heavily on basic memory concepts such as types, allocation, addresses (pointers) and alignment. If you want to make progress on data structures you need to have a solid but basic understanding of how computer memory works from a programmer's perspective (i.e. virtual memory). If you want you can PM me the assignment.
Open a thread for the timer and a thread for the main functionality. Have the main part continuously check the status of a shared variable, cleaning and quitting on condition.
I would say, `cargo` is like `make` in C's world, but it is much better. A big C project without `make` is unthinkable, and so as `cargo` for Rust projects. However `cargo` is easy for small projects as well, unlike `make` so this is the real reason that it becomes mandatory in Rust.
To be fair, the reason everyone uses `cargo` not `rustc` is not because some flags are unstable or it is not accessible to the user. It is because `cargo` is easier, even if you only have a single source file project. In C, if you have a single file you wouldn't border creating a `Makefile`. But in Rust, you simply `cargo init` and then start working on `src/main.rs`, even this is the only file you want to edit.
&gt;We just finished the course algorithms and data structures and I was pretty lost during most of it and can't code with them at all. That's what everyone believes about themselves at the stage you're at. Even if they're solidly within (or even above) the average of students.
&gt; `grep -i processed | awk '{printf $6}'` *sigh* awk '/processed/ {printf $6}'
well, that's pretty miraculous because that line is commented out... but read "man scanf", particularly the section on conversions. it's explained there.
I am now genuinely wondering whether the compiler will simply optimize away the code path that leads to the dead code or will also strip the dead code from the output binary. I also wonder if that is implementation-defined and/or how optimization levels affect that. I suppose that I could investigate. 
Because the original author didn't now how to write a while loop?
Most likely he wanted the output in the release build for debugging, but forgot to change it back after and didn't notice when committing.
It looks like you want to make `videohex` volatile since the compiler has no way of knowing otherwise if writing to that address has side effects. So use `volatile char *videohex` instead of `char *videohex`
That did nothing, as far as I can tell.
What exactly is the address you're writing too?
Does it work if you compile with no optimizations? (`-O0` on gcc)
The first space on the screen on color monitors.
Okay, what device/kernel are you trying to do this on?
Linux on a thinkpad T410. I already solved the problem, it was that the program never had a chance to declare videohex.
It doesn't work when using that flag.
Has the video memory been set up in the correct mode? https://wiki.osdev.org/Printing_To_Screen#Nothing_is_Displayed Do you have he correct privileges to be able to write to that memory? I mean this is low level kernel stuff here. Are you doing it via a driver/kernel module or are simply trying to write to the memory?
If you use `-S` you can look at the assembly and do a sanity check.
I'm making a simple kernel, so I'm just writing to memory. As I said, the program works perfectly when videohex is declared inside of the function.
If you don't understand *how* recursion works, then you probably don't understand how the call stack works. Once you understand what the stack is and how frames get added for each function call and popped off for each return, recursion is pretty straightforward. Now, some people know how recursion works but they don't get the point. For that, you just need to learn about some algorithms that use it. I suggest reading about the merge sort as a start. The main thing to remember about recursion is that you always need to make sure to check for the stopping condition, or the recursion will be infinite (the equivalent of an infinite loop).
Can you check the disassembly listing, or step through with a debugger to see what's different in the resulting code?
My first guess would have also been that you're missing the `volatile` keyword on the declaration of `videohex`; however, in another comment thread, you mentioned that adding it did not fix your problem. You should leave it on the declaration regardless. Otherwise, the compiler may optimize away accesses to `videohex`. You said that you're making a kernel. Are you doing anything unusual with the linker to avoid pulling in standard libraries and possibly the C runtime startup code? The startup code is responsible for setting global variables to their initial values and zeroing any uninitialized variables. If you're somehow excluding the startup code, then this step won't happen and `videohex` will be uninitialized. If this were the case, I'd expect a crash or some other more catastrophic failure than the program running with no effect; however, it's worth checking. Note that this could explain why the local variable worked and the global variable didn't. Even without the C runtime startup code, the compiler generates code to initialize the local stack variable inside `printchar()`, so it will be initialized upon every entry into the function. A quick test might be to move the variable back inside the function, double-check that it still works, then declare the variable as `static`. Static local variables also rely on the C runtime startup code for initialization, so if that's your problem, then this should fail as well.
I'm a bit late to the party but: 1. Great job. 2. tbh, I've never used digraphs / trigraphs before, and I'm not entirely certain if my memory serves me correctly with regards to what ISO-IEC 9899 has to say about them, so I'm going off of what [the wikipedia entry](https://en.wikipedia.org/wiki/Digraphs_and_trigraphs#C) has to say on the matter. In particular, it says that trigraphs are processed before anything else, so they should be replaced in strings? I've tested this with gcc, and it would appear that this is indeed the case. However, digraphs are not expanded inside of strings. With regards to your program which does the reverse, replacing symbols with their associated digraphs / trigraphs, it would seem that you do not process symbols within strings with trigraph representations. i.e "{test}" should become "??&lt;test??&gt;" when running digrapher with the -t flag. Running digraph -d on a file containing this string does not modify it (which is the correct behavior). However, running digraph -t on the same file should modify the string, but doesn't. 3. Furthermore, it would appear that you don't handle escaped characters in strings. For instance, consider the string "\\"". Consider the behaviour of your program in the following code. &amp;#8203; #include &lt;stdio.h&gt; int main(int argc, char * argv[argc + 1]) { putchar('\''); return 0; } Running digraph -t on this results in ??=include &lt;stdio.h&gt; int main(int argc, char * argv[argc + 1]) ??&lt; putchar('\''); return 0; } Note that the final brace has not been transformed into a trigraph. This is because your code reads the escaped apostrophe, and closes the character literal it is in incorrectly. It then reads the following apostrophe, enters another character literal, and remains in one for the rest of the program (also, as mentioned above, special characters in character literals \*should\* be transformed into trigraphs anyway). &amp;#x200B; In any case, you're code is otherwise pretty good. Very clean, and well written. I hope you will share your future work with us.
If the compiler is GCC, then writing the declaration in an asm macro prevents it from being optimized away. GCC also has a calling convention that allows C variables to be used in asm code. The other possible cause is that when declaring the variable locally, the compiler is also adding the code segment to the address when it relocates the code. If global and in asm it might be more precise to calculate the address of the video buffer based in a segment register and an offset. It doesn't appear from the example that this would cause a memory segment fault.
My experience with students like you is that they didn't learn the basics and wonder why they don't understand slightly advanced problems (i wouldn't even call them complicated, algorithms usually are very straight forward - they just rely on a solid understanding of the basics). So what i'd recommend you is to get a good book with exercises in it (you can probably find one in the side bar). Start from the beginning don't skip the simple things - those are usually what will cause you problems later. And for gods sake don't skip the exercises because you think you know the solution or they are too easy, just solve them without cheating: do you need google, reddit or stackexachange to solve them? Then you didn't understand the problem! Don't check the solutions, don't ask anyone - do it yourself. I've had enough students telling me they've practiced for weeks and all they do is look up the solution and say "easy, i would have done it just like this! next!" - no they wouldn't have, but they are very good at lying to themselves. And while you do it you can write yourself a cheat sheet with all the things that you learned, having this will help you with more complicated problems. But yeah there are no shortcuts and it seems like you are behind that means you have to put more work in than anyone else to catch up and get good. 
Check also the concept "linker script".
&gt; Calling processes from inside a C program is generally bad "code smell" I agree. This is very counter to the Unix philosophy, too. If you're going to pipe output from another process into your program, it should be done at the command line via `|` or `&gt;`
You could also popen just the pgbench, and while fgets line sscanf(line, "%\*s %\*s %\*s %\*s %\*s %d", &amp;num\[i\])
What operating system are you using ?
As others have said, you need the volatile keyword. Check the dissassembly. Other than that your function is declared to return int but you aren't really returning anything. 
On which operating system?
ubuntu 
You mean something like `dirname()`? 
how would that work in an example?
``` path_c = strdup("/foo/bar/baz"); dirpath = dirname(path_c); /* dirpath is now "/foo/bar" */ ... free(path_c); ```
Are you able todo depth first search? Do you know what a queue is? I think it’s time &amp; questions you need. If stuck think about things logically, draw pictures if that helps. Remember that nobody knows the right answer instantaneously all the time; we’ve all been there. 
What architecture and operating system are you programming for?
Why do you say you are programming for Linux when you want to make your own kernel?
Please post your whole program.
Warning ! Hackers can use your program to obfuscate their code. If you didn't yet, say that you are nog responsible for any misuse.
Bus errors occur when you're trying to access an address which doesn't exist. Check in your code you've assigned pointers correctly, especially uses of the \* and &amp; unaries. It'd be helpful to see your code and the gcc output with the -Warn and -Wextra flags. 
Okay! So I am back. I understood this concept. Conclusion. //here e is my variable name. 1. To get char or string use a 'SPACE' IN SCANF eg: scanf("%s%d", e.name,&amp;[e.page](https://e.page)); 2. 2.OR use gets("%s",e.name); then get the other one normally.... scanf("%d",&amp;e.age); 3. use fflush(stdin); to clear the memory or flush the memory/buffer to get a new set of input. //I am getting better at this. LOL
Not knowing anything about the field, unaligned variables in MMX, SSE etc, often result in bus error.
The code isn't wrong. It is from the official Cuda repo. It has worked in other machines 
LMAO thanks for the laugh.
look into red-black trees and avl trees, these trees change shape as you insert new things.
Always 😂😂
They are efficient when you nees to print sorted something(preorder print), for potfix to infix calc(inorder print)..
&gt; For example, if I set the root of the tree to be 50, and then later down the line, I added a number like 1000000. &gt; &gt; Is it easier than I realize to remake a binary tree, or are they only efficient with a known scale? &gt; &gt; What would be a good alternative to a binary tree if the scale is unknown, and searching was important? I applaud you for seeing the problem before being confronted with the solution; most computer science students these days have it the other way round sadly. The solution to this problem is called a *balanced binary tree* which is a tree structure that, well, balances itself automatically. The two most popular self-balancing binary trees are *red black trees* (which are another way to see B-trees with nodes of size 2–4) and AVL trees. I suggest you to familiarise yourself with them as they are quite popular data structures.
Please explain this Cache-Friendlessness. Also, how embedding a struct vs passing a pointer is going to affect the application binary interface. I would like to laugh as well.
This is depended on the size of the structures he is referring. On modern architectures this is not as big of an issue as it once was. The compiler helps a lot with it. If you want to get super anal about it, you can nest the struct and just point to what you want. &amp;#x200B;
Practical C Programming is a good book. It was required read for my undergraduate degree back in the early 90s. I still have the first edition of the book. Our Intro to CS taught Pascal (which I already knew as well) which I skipped because I took AP CompSci in HS, and every course after that was in C. They expected you to learn the language on your own before moving to more advanced courses. I had been programming in C on the Amiga and learned it using K&amp;R's book. I wish I would have had the Practical C Book. IMO the best way to learn C is to develop something that is semi-large, like a game, or chat program. Then start optimizing it. Look for things you want to improve. You will start picking the language up. Don't procrastinate. 
A binary tree is a sort of jack of all trades in terms of its insert/delete/lookup methods. It’s not crazy fast at any of them, but all 3 have worst-case time complexity of O(log N). A linked list, by contrast, can do lookups, insertions, and deletions from the ends of the list in constant time, but anything in the middle of the list will be much slower at O(N). An array list can do lookups from anywhere in the list in constant time, but insertions and deletions take O(N) time. If you don’t understand that notation, search for “Big O Notation” So you’ll want to use a linked list if you’re going to be working with the ends of the list a lot but won’t be accessing the middle very much (eg. using it as a stack/queue), you’ll want an array list if you’re going to build the list once then won’t be editing it very much after, and you’ll want a binary tree if you’re going to be doing a lot of insertions, deletions, and lookups from random locations. As for how to keep a tree balanced with wildly varying data: you’re right in that if you do a bunch of simple insertions to an ordered binary tree in sequential order, you’ve pretty much just built yourself a very fancy linked list. There are ways of fixing this, such as by automatically balancing the tree each time you insert/delete; this can even be done in O(log N) time! I recommend looking into AVL trees for more info on this 
Listen to /u/FUZxxl. His answer is great!
&gt; A linked list, by contrast, can do lookups, insertions, and deletions from the ends of the list in constant time, but anything in the middle of the list will be much slower at O(N). An array list can do lookups from anywhere in the list in constant time, but insertions and deletions take O(N) time. If you don’t understand that notation, search for “Big O Notation” Note that it is possible to build a balanced binary search tree out of sorted data in linear time. &gt; So you’ll want to use a linked list if you’re going to be working with the ends of the list a lot but won’t be accessing the middle very much (eg. using it as a stack/queue), you’ll want an array list if you’re going to build the list once then won’t be editing it very much after, and you’ll want a binary tree if you’re going to be doing a lot of insertions, deletions, and lookups from random locations. Arrays are often much more efficient for queues and stacks than linked lists.
&gt; I applaud you for seeing the problem before being confronted with the solution; Those are incredibly kind words, and really, really appreciated; thank you so much! The explanation you gave was also quite good, and appreciated. I will be looking into implementing both of those types of data structures soon, and reading into them. On the note of CS students having it the other way around, I actually have little choice to learn that way. xD The course I'm a part of (42) doesn't really teach you anything, they just give you practical assignments and expect you to learn on your own, with the help of your peers. They basically just replicate a workplace environment, all the way down to how they give you "work", rather than assignments.
Please post projects as link posts instead of self posts. I have removed your post so you can try again with a link post.
Ah, that sucks. My advice for you is to go and grab a good data structures book. Then read it cover to cover, doing exercises until you feel comfortable with the concepts.
&gt; The solution to this problem is called a balanced binary tree which is a tree structure that, well, balances itself automatically. The two most popular self-balancing binary trees are red black trees (which are another way to see B-trees with nodes of size 2–4) and AVL trees. I suggest you to familiarise yourself with them as they are quite popular data structures. I'd just like to add that yes, you should be familiar with these and how they function, but you don't necessarily need to know how to implement them yourself, a higher level understanding is perfectly fine. Some people might disagree, but the truth is that someone smarter than us has already worked out very efficient implementations for these data structures that have been tested and are bug free. Outside of, imo bad, interviews, you'll never be in a situation where you have to make your own implementation of these data structures without being able to at least look it up online.
&gt; I'd just like to add that yes, you should be familiar with these and how they function, but you don't necessarily need to know how to implement them yourself, a higher level understanding is perfectly fine. Sure, but implementing all the rotations yourself is an excellent way to get familiar with pointers. &gt; Some people might disagree, but the truth is that someone smarter than us has already worked out very efficient implementations for these data structures that have been tested and are bug free. What you should do is: write your own implementation until you are satisfied with the code. Then throw it away and use the battle-tested implementation from your language's standard library. &gt; Outside of, imo bad, interviews, you'll never be in a situation where you have to make your own implementation of these data structures without being able to at least look it up online. True. However, you should at all times know at least the gist of how these trees work so you have an intuition for their space consumption and performance characteristics.
Yeah. You’re right. Thanks for all the help! 
I looked at updating an app I'd written in Java, but what with modules and bunch of other nonsense I decided it would be easier just to rewrite in it C (yeah... Java is dead to me now...) I wasn't at all surprised to see that there have been steady and good improvements to GTK+ since the last time I used it in earnest, it makes a great GUI to use with C Just implemented saving, so its fully functional baring the polish...
&gt;or are they only efficient with a known scale? The overall scale doesn't impact the efficiency of operations in a data structure. At least not significantly. General efficiency depends on what type of operations are performed (Access, Search, Insertions, Delete). 
I'm on the OP's side on this one: &gt; base-10 floating point numbers &gt; Decimal floating point types These are both pretty straightforward. In terms of abundance of "wrong" answers, I think there are a lot of well-intentioned and intelligent people who have used floats quite a bit, but haven't yet really come to understand what's going on *under the hood* with floats. As such they haven't yet encountered the types of issues that commonly pop up when using floats for precision calculations (like money, or banishing the Kraken in early versions of KSP :D ). Either way -- it's a good question, and I have a feeling a lot of the people who came here with "wrong" answers will have probably learned something by reading through the responses!
That looks really cool!
C# is off topic in this subreddit. Please post C# questions to /r/learncsharp instead.
oh, okay!! sorry i didn't realise
thanks! :)
LoL the internet does make people ballsy, especially dumb people. Piss off, retard.
Yea, exactly. You don't know anything. 
Looks like op is writing the os, well at least the kernel.
I cannot tell if this is a joke or a legitimate concern. Can anyone really be held liable for what someone else does with their code, supposing that it has legal use cases?
It's quite likely your power supply isn't enough. I was running into this issue when porting some torch deep learning models over to industrial computers. The power supplies on the machines we used to build and test the models were significantly more powerful than the ones in the deployment boxes, and I ended up seeing this error quite a bit.
I am serious, this is not a joke. He has to take care of that
Huh. I was not aware of this. Would you know of any instances where this has happened? I'd be interested in reading up on the matter.
I do not know any instances where this has happened but I know this is a risk. Obfuscating code can make it much more harder to be detected by antiviruses. He can have problems if that happens.
Alright. I couldn't find any examples of this, but I'll continue. In the meantime, for anyone interested, I found [this](https://www.eejournal.com/article/20161116-liability/) article on liability (though it is presented in the context of bugs in programs, rather than the intended functionality).
Did you strace your program to check syscalls?
You need to check the waitpid result better. It will also return when the primary child exits and I believe it will also catch any SIGCHLD that gets delivered to any child. You don't have any signal handlers but you also normally need to check for EINTR. 
Once you look at those, take a look at Splay trees and skip lists. Skip lists might seem more like a linked list than a tree, but it actually shares a lot of properties with a tree.
Apologies I'm misreading you, but the example you used and some of your wording makes me wonder whether you misunderstood something about BSTs. You mentioned the case where you have wildly differing sizes of values (50 vs one million). That really should not matter at all. if you have a tree like 50 / 49 and you add 1000000, it goes in exactly the same place it would have gone if you had added 51 50 / \ 49 1000000 and searching for it is just as efficient.
Fillit, eh? Look up Knuth's paper on Algorithm X. It's a bit of a mind-bender, but you'll end up with something awesome.
Thanks for answering! `man` is telling me that EINTR is a return value returned/thrown when a signal handler is invoked while a system call (or function) is being blocked, but I assume in my code system calls are only considered blocked inside the tracee, not the tracer, so I don't see how the latter could be affected by it. Does a parent receive signals for their children exiting, whether it waits for them or not?
This is a really, really, really lazy question. Do some reading on your own, then come back and ask about specifics if you don't understand something. https://www.cs.auckland.ac.nz/references/unix/digital/AQTLTBTE/DOCU_068.HTM#stmnts_chap
https://en.m.wikipedia.org/wiki/Label_(computer_science) https://www.eskimo.com/~scs/cclass/notes/sx3a.html https://www.cs.auckland.ac.nz/references/unix/digital/AQTLTBTE/DOCU_075.HTM https://www.cs.auckland.ac.nz/references/unix/digital/AQTLTBTE/DOCU_073.HTM https://www.codingunit.com/printf-format-specifiers-format-conversions-and-formatted-output GoogleDuckBing
I was saying that going into such extreme numbers seems to make BST's inefficient, if the root node is such a small number. If the example you just printed was populated further, it would quickly become incredibly unbalanced. (Most of the data falling to the right.) This is resolved by what a lot of others mentioned to me, being a red-black tree. I didn't know anything about self-balancing trees before now.
Fillit is an actual, known thing? I assumed it was a randomly made task for my assignment. You've just helped me tremendously. 
All tree and list structures are inefficient in practice because of memory latency - pointer chasing is real slow. The complexity doesn't matter unless you actually have a lot of data. &amp;#x200B; If you don't need sorted iteration a hash table will probably work better.
No problem! And no, I don't think Fillit is a name for anything that exists outside of 42. But I had just seen another thread of yours where you mentioned that school, so I knew what this was. (Tetrimino packing in general is a studied problem, but that name is their own.)
&gt; Does a parent receive signals for their children exiting, whether it waits for them or not? Yes, a parent will receive SIGCHLD for it regardless. If the parent process has explicitly _ignored_ that signal, the child will be immediately reaped. Otherwise, the child process becomes a zombie until `wait`ed upon by the parent.
Your code is not explicitly waiting for any children, which means it's possible, in some cases, for the parent to exit _before_ some or all of its children. When this happens the children get reparented to `init`. The `SIGCHLD` signals generated when those children exit will go to `init`, not any of the processes you are tracing.
&gt; Btw I'm using C++ You may be better off asking in /r/cpp_questions then. This sub is for the C language, and your code is using a lot of C++-specific constructs.
Just so you know, the Linux kernel uses those structures, so they are in fact very practical and in use today. 
Insertion and retrieval, I think. Also there is a difference between best case, average case, and worst case. The counterexample you mentioned is relevant, if the keys are inserted in a bad order, you will get an unbalanced tree and it's performance will be bad. Check out "The algorithm Design manual" by Skiena and "Introduction to Algorithms" by Cormen, Leiserson , Rivest, and Stein.
Oh ok, thanks
Not helpful. Does markdown work on mobile, or are you using a third-party client?
man fscanf And read "Return Value". If a function returns a value, you should always check it.
How can I fix that sort of error? Plus this isn't a complicated piece of code, just running a vector addition code. 
The most commonly recommended path for beginners, based on the general consensus here, as well as industry professionals kind enough to give their advice is: 1. “C Programming: A Modern Approach, 2nd ed.” 2. “The C Programming Language, 2nd ed.” 3. “Expert C: Deep C Secrets.” 4. “C: A Reference Manual.” Go in order, and solve everything these books throw at you. Simply reading won’t make you much better at programming, so read the books to complete the exercises. In other words, start a chapter/section by looking at the first problem, then read to figure out how to solve it. Once you’ve solved it, move on to the next problem, read it, read the text to figure out how to solve it, etc. Be aware of the fact that you can waste a lot of time trying to find the perfect book, or trying things you’re not ready to tackle. These books aren’t perfect, but they are generally considered the best, most up to date books available (though they are old). With conscious effort and diligence, they will take you from a complete beginner to a pretty darn good C coder. If you run into problems, feel free to ask around. Find a good Discord group if you can—I found that very helpful when I first started.
You are using C++ and this is the subreddit for C.
Auckland uni eh?
First thing that popped up on Google -- ie the link the OP should've seen before posting here.
1. Your image is missing some of parts. 2. Have you at least attempted it?
yes &amp;#x200B;
Yes I tried to read it notes and look at YouTube but this is not my strong subject
The first two question is very easy
The first two question is very easy
A Google search gives [https://www.tutorialspoint.com/learn\_c\_by\_examples/simple\_linked\_list\_program\_in\_c.htm](https://www.tutorialspoint.com/learn_c_by_examples/simple_linked_list_program_in_c.htm) . All you need to do is change the struct to have your parameters as well as the insert function.
thank you so much &amp;#x200B;
Your call to waitpid is a blocking system call that can return EINTR. But you're right that EINTR probably is happening, since you don't have any signal handlers. But waitpid doesn't only return at the forks. It also returns when any signal, such as SIGCHLD is delivered to your tracees. It also returns when your primary child exits. In the latter case the pid doesn't exist anymore and the call to get_regs will fail, but you don't check the result there either. The struct you read then probably keeps its old values from the previous call. In the signal case the tracee is in a random state and you can't trust it's registers to contain anything useful.
Can it happen that orig\_rax contains SYS\_clone just by accident when a child/grandchild stops for other reason ? Not helping, but [https://pastebin.com/idsT4RA8](https://pastebin.com/idsT4RA8) I see this working reliably on FreeBSD.
Get the K. N. King book and read it. You won't regret it. If you're in the US, you can pick up a copy on ebay for like $5. I'm sure there are PDFs around as well, just get it however you can. And don't try to look up the answers, read it. Do the exercises. I'm assuming this is homework and you're being given confusing or inadequate materials to study from. Don't suffer through that, just get a better book.
I remember reading the original DDJ article, but now (many years later) I wouldn't be able to describe the kind of workload for which a skip list would be an efficient choice. The complexity overhead of allocating variably sized list nodes always seemed a bit off-putting.
Btrees are an exception to this generalization, because they include long contiguous sequences of value items, without need for pointer chasing.
Thank you for your answer! &gt;One problem you've got is that your `do_fork` code is not explicitly waiting for any children, which means it's possible for a parent to exit _before_ some or all of its children exit. Yeah, this is sort of by design, because I want a program that can trace the subprocesses of *any* arbitrary program, so having children being reparented after the parent dies is just another possibility. So, since I foresaw this problem as well, is there any way to guarantee that the children of some tracee are *always* traced, whatever may happen with the original tracee? &gt;A second problem is that it is not guaranteed for there to be exactly one `SIGCHLD` delivered per exiting process. Non-realtime signals can be coalesced. Tbh in my program I don't care too much about keeping track of who dies and who doesn't, as long as I can distinguish between signals caused by ptrace and other kinds of signals (which I will ignore).
Thank you for your answer! &gt;Can it happen that orig\_rax contains SYS\_clone just by accident when a child/grandchild stops for other reason ? This does seem to be the case, if I understand everyone else's replies. I wanted to check after every waitpid if it was a waitpid caused by ptrace or by something else, but I didn't know how.
&gt;std::string words[] = {} This is a zero-size array. And you're trying to write something to it's i-th index, effectively overwriting memory out of it's bounds and corrupting something important (stack frame I guess) Arrays in c/c++ does not autoscale, you need to know it's size beforhand. Use std::vector and it's push_back() or resize() functions.
This seems very plausible, so thank you very much! Now, the question is, how can I check whether a waitpid exited because of ptrace or because of something else entirely? Also, like I asked somewhere else, does a child being reparented make it be outside ptrace's control? If so, how can I guarantee that all the children of a given process are always traced, whatever happens with the parent (the original tracee)? Surely there must be a way, because if there was a way to escape the control of a debugger it'd kill the point of having debuggers. (Also, a small explanation about my program: I only want it to report forks, not deaths. It's more about controlling someone's syscalls than it is about processes and how they appear and disappear.)
I haven't used ptrace for several years so I don't remember what happens after a reparent but I would be surprised if it affects anything, I don't think that matters. You're allowed to ptrace processes regardless if you're the parent after all. To find out why waitpid returned you have to inspect the status argument according to the descriptions in the waitpid and ptrace manuals. 
&gt; So, since I foresaw this problem as well, is there any way to guarantee that the children of some tracee are always traced, whatever may happen with the original tracee? Well you seem to be doing that partly, based on your tracing options (`PTRACE_O_TRACEFORK`, etc.). I might have misinterpreted your question: I thought you were counting `SIGCHLD`s delivered to your tracees and wondering why you weren't seeing them all. However, I don't see where you're actually _continuing_ these newly-traced child processes. `PTRACE_O_TRACEFORK` will cause them to be immediately `SIGSTOP`ped just before `clone` returns in them. So... I really have no idea what you're counting.
Wait, so TRACEFORK et al *stop* the program after it clones itself? Don't they just make ptrace silently attach itself to the new child? Because I thought that's what they did: "if you specify TRACEFORK tracee's children will be automatically traced without you needing to do anything". Also, I'm not counting the children per se, I'm reporting every clone syscall, and then I count the number of lines in stdout (with `wc -l`).
&gt;To find out why waitpid returned you have to inspect the status argument according to the descriptions in the waitpid and ptrace manuals. Yeah, I'm going to have to read the manuals again, but I don't remember there being clear instructions on what kind of waitpid status was the one caused by ptrace.
&gt; Wait, so TRACEFORK et al stop the program after it clones itself? It stops both the parent and child tasks, immediately before they each return from `clone`. `waitpid` in your tracer indicates that the parent process was stopped with `WIFSTOPPED(status)` being true, and `WSTOPSIG(status)` being `SIGTRAP`. Using `PTRACE_GETEVENTMSG`, you can find out the PID of the child task. Once you've got all that you need to `PTRACE_CONT` _both_ the parent and child tasks.
OK, I'm going to try this as soon as I can (about six hours from now I guess) and if it works (or doesn't) I'll tell you!
One thing I'm not entirely sure about is what guarantees that `waitpid` indicates `PTRACE_EVENT_FORK` for the parent process _before_ `PTRACE_EVENT_STOP` for the child process. I'm guessing they must be ordered correctly, since otherwise your tracer could be notified about a PID that hasn't yet learned exists.
I should have added, that the fbsd tracer sees a stopped process by SIGTRAP for the execute of fork, and by SIGSTOP in the grandchild after the same fork. That was a nice post! Are you doing something interesting?
Aren't they quite similar? Why the need for such gatekeeping.. 
You can dump the bytes. Printing an integer involves making a string made up with \`'0',\` \`'1'\`, ... and then eventually using write.
What's the type of `head-&gt;data`?
The subreddit rules state that C++ is not on-topic for this subreddit. And the error messages seem to indicate that the code uses many features of C++ that are entirely absent in C.
[https://www.itu.int/itudoc/itu-t/com16/tiff-fx/docs/tiff6.pdf](https://www.itu.int/itudoc/itu-t/com16/tiff-fx/docs/tiff6.pdf) for example BITSPERSAMPLE is a tiff tag, you can read up what it means and then refer to the libopenpng documentation to find out how you access the appropriate information from a png, there are a few single header file png decoders, that you might find easier to use, for example lodepng ...
Int, and %d.
Like /u/CuddlyBeavers says, `printf` does more than just dump the bytes of an integer to a stream. It actually computes the decimal representation of a number.
write() transfers bytes from memory to a file descriptor. In your example the byte you specify gets thrown out stdout. In contrast, printf() renders data for the screen. To be specific, say you had the integer 35 stored at that address. write() throws 35 to stdout. This gets interpreted as an ascii character, which happens to be '#'. This looks much like garbage, especially in a loop. printf("%d", 35) converts that integer to the printable characters you would expect for display, specifically the ascii characters 51 and 53. These get rendered as '3' and '5'.
I was being silly (And I think for reasonably good reason, as people didn't easily notice the problem either) &amp;head-&gt;data is 100% how you would get an integer into the write function, and it's working flawlessly. Now, how you convert 0-9 to ASCII is simply +48, but the problem is how I did it. &amp;head-&gt;data + 48 increments the location of -&gt;data by 48 places, rather than increment the data inside of head-&gt;data. I basically just jumped to random nonsense data.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
While many features of C are also present in C++, idiomatic code in the two languages is extremely different and advise that is good for programming in C is often not good advice for programming in C++ (and vice versa). For this reason, we ask C++ programmers to ask for help in C++ specific subreddits.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Cython is a 'graft' between C and Python that I've found useful when performance is important. You can code your critical loop with a python-like syntax but C-like semantics. You can then import this as a module in your bigger Python app.
That's very interesting, thanks. I'm looking at cython.org now.
Wrong sub dude.
Fair enough. 
Submission statement: Nice and enjoyable read from Pike that recently celebrated 30 years; your mileage may vary. I agree with most of but privately I always prefer to go for quick 'n dirty while I work on my own project. As it says, *don't optimize*. I hope someone benefits from this.
Thanks for the information! I'm making a program that traces syscalls to reject some of them (file access to some particular directories, mostly). The small program here isn't really needed for the final program, since ptrace seems to already ensure forked processes are still traced (I of course didn't know this when I started with this), but since it seems to fail I'd rather fix any misconception I may have about ptrace with this one, which is small and easy to understand, lest I don't actually understand ptrace and I'll have to debug a huge program later on.
This was [previously submitted](https://www.reddit.com/submit?url=http%3A%2F%2Fdoc.cat-v.org%2Fbell_labs%2Fpikestyle) with a different link. The other discussions might be interesting, too.
Can you provide the code you're actually running? The link you give doesn't match your output. What do you learn when you run the code under a debugger?
&gt; Strange point to raise, as the various C specs didn't manage to keep MSVC/GCC/Clang/other random C compilers honest ;) A major part of the philosophy behind C89, which later versions have taken, is that it's more important to avoid forbidding implementations from doing things that might benefit their customers, than to require them from behaving in ways that serve their customers. I think the authors of the Standard thought it obvious that honest people seeking to produce quality implementations should make a bona fide (good faith) effort to try to serve their customers without regard for whether the Standard requires them to do so. Many of the C99 features that have MSVC has balked at supporting had sufficiently dodgy semantics that use of them would often make code needlessly inefficient. For example, consider the C89 code: struct foo { long long z[1000]; }; void outsideFunc(struct foo const *); void test(void) { static const struct foo foo123 = {1,2,3}; for (int i=0; i&lt;1000; i++) { outsideFunc(&amp;foo123); outsideFunc(&amp;foo123); } } It would seem that under C99, a more "modern" way of doing the same thing should be: struct foo { long long z[1000]; }; void outsideFunc(struct foo const *); void test(void) { for (int i=0; i&lt;1000; i++) { outsideFunc(&amp;(struct foo){1,2,3}); outsideFunc(&amp;(struct foo){1,2,3}); } } Unfortunately, a compiler processing the latter version of the code, which knew nothing about `outsideFunc` beyond its signature, would be required to allow for the possibility that `outsideFunc` might invoke `test` recursively, using a static object to limit recursion and keep track of which invocations were which, and might persist pointers passed to different invocations and compare them against each other. The lifetime of the compound literal passed to the first call extends through the second, so the compiler would have to pass it the address of a different object from the first. Finally, a compiler would also be required to allow for the possibility that even if `outsideFunc` might casts the pointer to a non-const type and modifies its target, behavior would be defined as passing an object initialized to {1,2,3,0,0,0,...} to each function call. To accommodate these things, a compiler would have to allocate 16,000 worth of automatic objects for each nested function call, and would need to initialize the contents of two `struct foo` values *for every loop*, a total of 2,000,000 otherwise-unnecessary 64-bit stores. I don't see much value in having compilers encourage compilers encourage programmers to write code inefficiently. Compound literals could have been useful in efficient code if the semantics had been specified differently, but I'm not sure which is more "honest": implementing them with semantics that would likely work identically *in nearly all non-contrived situations* but would behave in non-conforming fashion on some contrived situations, or simply refusing to implement them altogether. 
Thanks for the upload! I love cool bits like these.
There are a few ways for an implementation to handle situations where it's not possible to statically track everything that might happen to references: refuse to process such code, allow for the possibility of any access via reference via reference of uncertain provenance being an access to any "similar" object whose reference may have escaped, or assume that objects won't be accessed via any *pre-existing* outside references within certain contexts. The first will limit what programmers can do, the second will limit what optimizers can do, and the third is apt to yield unreliable programs unless the associated contexts are clearly marked. Unfortunately, it's often hard for a language or compiler to recognize situations between those where everything that happens to a reference can be statically tracked, and those where a compiler can't safely assume anything about how a reference will be used. If a reference to an object may escape, that may globally impact the efficiency of code using that object, and one could reasonably argue that it would be better to require that programmers explicitly indicate that they are aware of and accept accept such reduced efficiency, than to have a small change to a piece of that represents less than 0.001% of the total execution time silently degrade the performance of some unrelated code that might be performance-critical. 
Different platforms support different underlying mechanisms for concurrency, and achieving optimal performance will often require using those mechanisms in a variety of ways. Having a language provide intrinsics which may map easily and directly to platform behaviors in cases where that would be appropriate, but could be configurable to invoke user functions in cases where other behaviors might be required, could balance those issues, though I've not seen any languages do such a thing. For example, one thing I would like to see would be the ability to define storage classes such that accesses would be translated as invocations of user-defined (potentially in-lineable) functions. This would, for example, allow for the possibility that if e.g. a programmer manually assigns threads to cores, and knows that certain objects are known to be accessed only via threads running on cores #1 and #3, and if the platform provides core-relative memory barriers, those objects could use a qualifier that would invoke code that uses memory barriers for cores #1 and #3 without the performance cost of needless synchronization with the other cores. Such a design would allow system-specific aspects of a program to be confined to system-specific header files, while the main code would mark things with storage classes that could be treated specially on platforms where that would be useful, or as synonyms for other classes when that would be sufficient. 
Although the language will allow compound statement as a simple statement within a compound statement, compound statements which are not part of an `if`, `do`, `while`, etc. are often a result of clumsy edits and are *likely* to behave in a fashion contrary to what is intended. An important part of programming is not only ensuring that it will behave as intended, but also writing it in such a way that someone reading it will know that the behavior matches the intention. Someone reading something like `double1 = float1+float2;`, would have no way of knowing whether the programmer intended that the result be rounded to `float` precision before the assignment, that the operands be converted to `double`, or simply wanted the compiler to do whatever was convenient. Since some compilers guarantee the first behavior, some the second, and some may choose arbitrarily, writing the code as `double1 = (float)(float1+float2);` or `double1 = (double)float1+(double)float2;` would make the intention clearer if one of the first two behaviors was desired. If one sees: woozle(); { ... } it may be unclear whether *intention* was to unconditionally execute the code within the compound statement, as opposed to e.g. having intended to copy-paste over a piece of code that preceded an `if` statement, but instead having replaced one too many lines. Including the `if` makes clear that there's nothing "missing" before the compound statement. 
If it's expressly designed to be suitable for use as a form of high-level assembly language, that would make it closer to the language the C Standard *was written to describe* (the authors of the Standard stated they did not wish to preclude use of C as a form of "high-level assembly language", implying that they recognized that the pre-existing language was usable for such a purpose) than to the language the C Standard actually *defines*. 
Again I want to thank /u/morth, /u/aioeu and /u/o5nxo for your help! I've tried to fix my program (new [catch_fork.c](https://pastebin.com/1Q08bXf4)), now that I sort of understand how ptrace works, but I have been met with an even more terrifying and disconcerting problem: now it does work, even though it shouldn't. A small summary of the changes: * I've unified the two parts of the code (before and after a syscall), to make the behavior rely on a variable (`enter_syscall`¹) instead, which makes it easy to do *orphan* `PTRACE_SYSCALL`s * The code checks for `SIGTRAP`s (the 0x80 part is caused by `PTRACE_O_TRACESYSGOOD`, and helps keep it different from other `SIGTRAP`s) to detect if a given waitpid is due to a syscall starting or finishing. * The code also detects events caused by the PTRACE_O_TRACE family. And that's it. The reason it shouldn't work is in the 67th line: `go_on`, a variable created to skip getting registers and changing the enter/exit state, should only work once every time it's set (i.e., it should `continue` only once), but as it is it works every time except the second one (unless it's set again, of course). However, when I *fix* it, only the main process in the tracee runs at all, while the supposedly buggy implementation reports exactly 15 forks very consistently (it's not failed even once in some-hundred consecutive runs). So that's my new, desperate plea: help me make sense of this mess and/or make it run as it should. ¹ My neurons aren't exactly *working* right now, but I believe this variable behaves as if it was called `quit_syscall`. I intend to fix it at some point in the future.
Not particularly related to libpng but you could try stb_image for loading quite a few images https://github.com/nothings/stb/blob/master/stb_image.h it's a single header library, simple to use &amp; supports SSE
Many execution environments can support some languages that allow symbols to be defined and exported in ways that are not possible in C. For example, some languages may provide a means of exporting a symbol with a hard-coded address. If e.g. an execution environment promises that a table of functions that user code may call will be located at address 0x00000400, it may be useful to have a module written in a language which can export constant symbols export `FuncSet` as a symbol with that address. Since the address to be called wouldn't be knowable prior to the start of program execution, the only way the code could be optimized to perform the call directly would be if the compiler and/or linker could generate "fix-up" code that would patch the function call so it targeted the the appropriate address. While some systems have used similar techniques in the past, I'm unaware of any current systems that do so since code is so often run out of read-only storage.
...and?
It's the same, I changed it to 10 elements. 
What's particularly annoying about string-related functions that return a passed-in pointer is that it would in many cases have been cheaper for them to return something that would actually be *useful*: an address following the last non-zero byte of the string. If one had a string-copy function that accepted pointers to the start of the destination and "just-past" the end, and returned the address described above, that could be used for efficient and safe string concatenation without having to keep track of remaining space. Incidentally, the Standard could also have benefited from memory-compare and string-compare functions that return the address of the first mismatch, each in forms optimized for cases that exit early, or for cases that exit after comparing a large block. On many systems, if the cost of comparing N bytes with the former would be N plus a small constant, the cost of the latter would be N/4 or N/8 plus a much larger constant. If N happens to be 16,000 the latter could be four times as fast as the former, but if N is usually one it might be four times as slow. 
As soon as one calls `free`, the implementation would be free use the storage, or allow it to be used, for any purpose. One no longer "owns" the storage. If one calls `free` on storage one doesn't own, and which happens to be in use for some other purpose--even if that purpose is simply to be available for future allocation requests, it will generally be sufficiently difficult and expensive for an implementation to reliably prevent that latter purpose from being undermined by the improper "free" that few implementations make any particular effort to do so. Even if an implementation were to have `free` check to ensure that it was being passed a valid pointer, it would be difficult and expensive to guarantee that something like: void *p1,*p2; p1 = malloc(1234); free(p1); p2 = malloc(1234); free(p1); wouldn't assign the same address to `p2` as had been used for `p1`, and then treat `free(p1)` though it were a valid attempt to free the storage identified by `p2`. There are ways by which implementations could offer such guarantees, such as by having the representation of every pointer include a unique 64-bit `sequence` value which would never be reused during any particular program execution. An implementation could then keep a table of all live allocations, including their addresses and sequence numbers, and precede the storage of each legitimate allocation with its index in that table. An attempt to call `free` could ensure a pointer was superficially valid, fetch the preceding word, check that it's within range of the valid live indices, and then check that the pointer's address and index match the appropriate pointer entry. An implementation that did all these things could then either ensure that a double-free would consistently trap, or that it would consistently behave as a no-op. Carrying around a 64-bit identifier with every pointer would be rather expensive, however, and in most cases it would offer too little benefit to justify the cost. 
Such casting was supported in the language the Standard was written to describe, but is not supported in the gcc/clang interpretation of the language it actually defines. The only times those compilers will honor the Common Initial Sequence guarantee are when invoked with `-fno-strict-aliasing` or when accesses are performed *directly* through lvalues of union type. Operations using the Common Initial Sequence rule by dereferencing pointers to structures within a union are unreliable, even in contexts where the compiler should have no problem recognizing that they involve the addresses of union members. For example, consider: struct s1 {int x;}; struct s2 {int x;}; union { struct s1 v1[100]; struct s2 v2[100];} uarr; int test(int i, int j) { if ((uarr.v1+i)-&gt;x) (uarr.v2+j)-&gt;x = 1; return (uarr.v1+i)-&gt;x; } Unless invoked with `-fno-strict-aliasing`, neither gcc nor clang will allow for the possibility that the write to `uarr.v2[j]` might affect the value of `uarr.v1[i]`, even though there is not only a complete union declaration visible, but everyplace the code uses a `struct s1*` or `struct s2*` is within the immediate context of its derivation from an actual union object that contains those types. 
I've found two problems: 1. The length of the test input doesn't match the input (there are only 19 lines). This can be fixed by testing output of scanf (it reports number of items read.) 2. You need to avoid using half-perimeter by scaling: division by 2 will cause mistakes. Next, there are several deficiencies that won't cause incorrectness in this case. 1. It doesn't really need to calculate that function of area every time. Just save it when it's read. 2. C supports structure assignment, so triangle swap is unnecessary long. 3. Output of malloc is to be tested.
The name `C` has been used over the years to describe a number of languages. The relation between C-- and some of the early forms would appear stronger than the relation between those early forms and the later ones. Perhaps what's needed are some retronyms to refer to some of the older forms of C that included useful abilities that were excluded from later forms.
I still don't how this relates to what I wrote.
Sorry, no idea what this is, but where are you getting the nPipes value?
Better would be a couple of copy functions that accept pointers to the start of the destination buffer and a pointer "just-past" the end, and return the address just past the last non-zero byte copied. One version would guarantee that the destination buffer would be left containing a zero, while the other would allow all bytes of the destination buffer to be used. An advantage of using the just-past address for the destination buffer, rather than its size, is that when performing repeated concatenations, the just-past address would remain constant despite the fact that the remaining space would decrease. Alternatively, it might be useful to have a function that would guarantee that if passed a null destination it would return null, and that would return a null pointer if there was insufficient room in the destination to accommodate the new string. That would allow code to perform a sequence of string-building operations, passing each the address returned from the previous one, and then ensure that the final result is non-null, without having to test each individual operation in the sequence. The latter behavior could be especially useful in cases where the destination buffer wouldn't have space reserved for a trailing zero byte (e.g. because code would track the string's length, or the location of its end, separately), since there would be no way to distinguish the scenario where the string precisely fits the target space from the scenario where it doesn't fit, since the location of the last byte written would be the same in both cases. 
https://www.reddit.com/r/programming/comments/bak4bk/the_1973_bourne_shell_in_unix_version_5_was_only/
Javascript emulator shown: https://skn.noip.me/pdp11/pdp11.html
Ah, yes, sorry for not making it clear. nPipes is a global int storing the amount of "|" the user typed in. Example: "ls -li | grep shell | tr s x ", nPipes = 2.
Thank you so much for the help, I dislike asking questions like this, but I really can't find anything wrong with it on my own, and it was growing frustrating. How would you fix the problem with division by 2? I was trying to follow the formula given by the project itself. https://i.imgur.com/Q2gjxQu.png Which I think I did properly, but I may have failed in my implementation. I'll rewrite the swap function as well. I had no idea you could do it in such a short way.
If I recall, Bourne also heavily abused the preprocessor
Just imagine that all lengths have been doubled. Then p will be `a + b + c` and 16S^2 will become `p*(p-2*a)*(p-2*b)*(p-2*c)`. It needs to be done only with integer arithmetic. Floating-point one lets you calculate approximate area by following the formula exactly.
Thank you so much. Maths is unfortunately my weakness. You've been a god send of a help.
I can't figure it out. I don't have experience with pipes, but I can't spot a logic error. Usually a quit without an error in a program that compiles fine is a memory access error. Could try putting asserts to test the code.
I'm curious what the comparison to modern bash is. I can't seem to find a quick answer online. 
Was anything else changed? What does the debugger show you? Really, debugging the code is the way to figure out what's going on. Reasoning it out (and assuming you haven't made further undisclosed changes to the code), we know that you're only seeing the "[Vector addition of 10 elements]" output from the program. That means that none of the malloc() calls failed; if they did, we'd see the "failed to allocate host vectors!" message at Line 68. Most other calls are checked for safety, too, and print something if they fail. But you're not getting any other output -- so where does the program crash? Running it in a debugger would make the crash very visible. Have you tried that? Why not? What platform are you running on? Are you certain that casting malloc's or cudaMalloc()'s return values to a float* is safe, and aligned correctly? If you're unwilling to use a debugger (why?) then have you tried other techniques, like adding printf statements to show what progress in the program has been made? 
Get a better power supply.
Please post your Makefile into a paste service; triple backtick syntax does not work on reddit and your text comes out all garbled.
Thanks for trying :) As for the memory access error, I just tried running the program through Valgrind and it gives me "Syscall param execve(argv) points to uninitialised byte(s)" and "Syscall param execve(argv[i]) points to unaddressable byte(s)". The second one happens when I execute single commands (no pipes) as well, even though those get executed all right. I don't know how to fix those :(
Yes. And my mistake, this is a [Thompson shell](https://en.wikipedia.org/wiki/Thompson_shell) sorry.
My mistake, this is a [Thompson shell](https://en.wikipedia.org/wiki/Thompson_shell) sorry.
**Thompson shell** The Thompson shell is the first Unix shell, introduced in the first version of Unix in 1971, and was written by Ken Thompson. It was a simple command interpreter, not designed for scripting, but nonetheless introduced several innovative features to the command-line interface and led to the development of the later Unix shells. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Oh I wasn’t pointing out an error i was just adding a quick fact but thanks for clarifying
[https://en.wikibooks.org/wiki/C\_Programming/stdint.h](https://en.wikibooks.org/wiki/C_Programming/stdint.h)
So what are the reasons for using an int over the ones provided by stdint?
Fixed! Thank you for taking a look
The v5 shell wasn't the bourne shell, it was introduced with v7.
What I’ve heard is that an int is a processor’s ‘natural’ type, and it has to convert an int to another type to do arithmetic on it. 
Here's a nice discussion of the pros and cons of each approach. 
https://stackoverflow.com/questions/9834747/reasons-to-use-or-not-stdint
Awesome, that did it. Thanks for the link!
That's more of a basic programming question. a'th odd integer is \`2\*a-1\`. So, you have the recurrent relation: \`f(a) = (2a-1)f(a-1)\`.
I'd still love to see the comparison. Really, bash shell is still a spiritual successor. 
I like to apply the same approach to this sort of problem that I might apply to mathematical proof by induction. First I look for a pattern by looking at the first 3-5 cases: a = 1: return 1 a = 2: return 1 * 3 a = 3: return 1 * 3 * 5 After only 3 the pattern becomes clear to me: for any given value `a` greater than or equal to 1 I can return a value equivalent to `g(a) * f(a - 1)` where `g(a)` is a function equivalent to the `a`^th odd number and `f(a)` is the function we're creating. You'll notice that `f(a)` contains a reference to itself in `f(a - 1)`, which means we can recursively apply it like so: f(a) = g(a) * f(a - 1) = g(a) * g(a - 1) * f(a - 2) = ... = g(a) * g(a - 1) * ... * g(2) * f(1) So we can define our function as a function that will return `1` for all `a &lt;= 1`. For all `a &gt; 1` we define the function to return `g(a) * f(a - 1)`. Determining `g(a)` is less tricky than you likely think; `g(a) = (2 * a) - 1` a common, standard formula for the `a`^th odd number. I'd give you the code, but I think I've held your hand enough. Provide it below and I'll critique your code for you. Hope that helps.
The authentic Bourne shell source code is absolutely unrecognizable as C. It has hundreds of uppercase preprocessor macros that make the actual code look more like Pascal.
You may wish to switch to markdown so that those backticks evaluate properly.
It creates a shared library (libgldemo.so) via -shared to be included into other binaries. See https://www.cprogramming.com/tutorial/shared-libraries-linux-gcc.html
Apparently, it was the inspiration for the obfuscated C competition. [http://www.ioccc.org/faq.html](http://www.ioccc.org/faq.html)
That's perfect! I managed to get it working now!
Thank you very much for this insightful reply! I've managed to do it this way: int rek(int a,int n) { if (a&lt;=0) return 1; return n * rek(a-1,n+2); } and in main: int main(void) { int n,f1 scanf("%d",&amp;n); f1 = rek(n,1); printf("%d",f1); return 0; } I appreciate your help very much,truly thank you &amp;#x200B;
And STILL cmd.exe hasn't caught up with it. 