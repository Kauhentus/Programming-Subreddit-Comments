https://ideone.com/v6f3kb Closer? I'm now getting one key output. Funny enough, it is the very first legal hand state that can occur. That's it.
Five comes from five cards in a hand. And are you sure about how your teacher wants it? wFace["Jack"] is non-sensical. 
I don't know what this means.
Sorry I don't understand. I wish I did. 
It will come in time. There are several concepts at play that you will probably learn independently before they make sense together. That is part of why asking “are there other ways to do X” will tend to get you dismissal. There are always multiple ways to go about solving a problem, but the reason to use any but the most common approach will depend on what you are trying to do and how deep you are willing to go. 
I see what you're trying to do now. You have two main problems, First, your data organization around the deck is messy. There is no good reason for it do be a 2d array, and you don't have an array for a hand at all. The second is a problem with pointers. Don't mix and match \* and \[\] in your parameter declarations. &amp;#x200B; For organizing you deck, enums are super useful. They let you add any number of things and reference them numerically by name. It looks like this &amp;#x200B; `#define SUITES 4` `#define FACES 6` `#define CARDS 24` `#define HAND 5` &amp;#x200B; `enum suits{` `Hearts = 0, //force count to start at 0` `Diamonds,` `Clubs,` `Spades` `};` &amp;#x200B; `enum faces{` `Ace = 0,` `Nine,` `Ten,` `Jack,` `Queen,` `King` `};` &amp;#x200B; We can use a bit of math to make macros to assign all the cards unique values &amp;#x200B; `#define GET_SUITE(card) ((int)(card / FACES))` `#define GET_FACE(card) (card % FACES)` `#define GET_CARD(suite, face) ((suite * FACES) + face)` &amp;#x200B; Finally some function declarations &amp;#x200B; `//init random deck` `void shuffle(int *deck);` `//deal HAND cards from deck` `int *deal(int *deck, int *dealt);` `//Check hand for jack` `int has_jack(int *hand);` &amp;#x200B; Then your main function should look like this &amp;#x200B; `int main(void){` `//how to make an array when dealing with pointers` `int *deck = malloc(CARDS * sizeof(int));` `int dealt = 0; //number of cards taken from deck` `int *hand = NULL; //current hand` &amp;#x200B; `shuffle(deck);` &amp;#x200B; `//pass pointer deck` `//pass dealt by as pointer` `hand = deal(deck, &amp;dealt);` &amp;#x200B; `if (has_jack(hand)){` `printf("has jack\n");` `}` `else{` `printf("no jack\n");` `}` `};` &amp;#x200B; logic for checking if a card is a jack then looks like this &amp;#x200B; `int has_jack(int *hand){` `//enum face j = Jack;` `int i = 0;` `for (i; i &lt; HAND; i++){` `if (hand[i] == Jack){` `return 1; //true` `}` `}` `return 0; //false` `}` &amp;#x200B; Rest of the code that isn't related to your question &amp;#x200B; `void shuffle(int *deck){` `int i, j;` `int counter = 0;` `//init deck` `for (i = 0; i &lt; SUITES; i++)` `{` `for (j = 0; j &lt; FACES; j++)` `{` `deck[counter++] = GET_CARD(i, j);` `}` `}` &amp;#x200B; `//todo randomly swap stuff to actually shuffle` `}` &amp;#x200B; `int *deal(int *deck, int *dealt){` `int i = 0;` `int *hand = malloc (HAND * sizeof(int));` `for (i = 0; i &lt; HAND; i++){` `hand[i] = deck[i + *dealt];` `}` `*dealt += HAND;` `return hand;` &amp;#x200B; `}` &amp;#x200B; &amp;#x200B;
If anyone sees this and wishes to explain, I would appreciate it. Thanks.
Any situation you can think of where you can lock down your hardware and timing matters, in-line ASM becomes a valid consideration. Self driving cars, for example. Your car software is going to be running on a very specific set of hardware components, 'portability' isn't a concern. On the other hand, being able to square-root quickly buys you time when you're calculating distances, maybe doing image (road sign or living thing) recognition, etc. similar concerns exist for drones or UAVs. Ever seen the videos floating around of a machine blasting rocks out of a torrent of cranberries at the packaging plant using a jet of air? The software behind that won't have to run on the machine if anyone who downloads it, and the faster you can figure out where and how strong to shoot the air, the faster you can run your belt, the more money you make. High frequency traders don't target just any hardware. They buy in bulk the fastest they can get and specialize the software for it because the saved nanoseconds per transaction can mean thousands of dollars each.
Here's another silly method basic on the idea of subtracting towards zero, defining even-ness and odd-ness recursively in terms of each other: int get_sign(const int n) { if (n &gt; 0) return n - 1; if (n &lt; 0) return n + 1; else return 0; } bool is_even(const int n) { if (n == 0) return true; else return is_odd(towards_zero(n)); } bool is_odd(const int n) { if (n == 0) return false; else return is_even(towards_zero(n)); }
The case where your prof. is a dumbass and was expecting a loop.
Logical OR it with, 1 if true it's odd, if false even.
try wicd.
First of all, you should enable warnings in your compiler, and read them. Assuming you're using `gcc` try adding the following flags: `-Wall -pedantic`. Secondly, if you're declaring a variable to be global like superSalt you can write to it directly instead of using the local variable `salt`. Generally global variables are frowned upon but they do have their uses. Instead people pass things to functions by giving the functions arguments, e.g. #include &lt;stdio.h&gt; #include &lt;string.h&gt; void setString(char *target) { strcpy(target, "Hello, World!"); } int main(int argc, char **argv) { /* assign some space for our string */ char foo[16]; /* foo decays to a pointer to the first element of foo here */ setString(foo); printf("foo is %s\n", foo); return 0; } 
You are setting a global variable, superSalt, to point at a local variable, salt, which is on the memory stack of the function -- when that function returns, the memory location is void. &amp;#x200B; You need to set an area of memory to the value -- so you can memcpy from one location to another. And don't pass by global variable -- it's bad practice.
Thank you, I will try to rewrite this using what you have said as soon as I can, and see if it fixes it. Thank you for explaining.
yes, printf uses the format specifiers to figure out the number of arguments, which is why you can get garbage if you forget to pass some arguments
You'll need to memcopy salt to supersalt. Variables in functions are destroyed (kind of) when you exit your function. In function 1 you replaced your global address with your local address; then when you exit your function you destroy that address, effectively eliminating both. memcopy will copy the local values to the global variable. When the local is destroyed, the contents will have been copied to the global. Confusing, I know, but you'll get it with practice.
Thank you, I will try to look up memcopy to understand how to use it, this looks like a very thorough explanation, thanks. 
I'll try a metaphor I just thought of You have a giant poster board outside the house for everyone to see. Inside your house you make another poster board and put a creative slogan on it. Unfortunately at the end of this story your house burns down. Case 1: what you did originally, you took the poster board inside and put your inside one on top of the other. The house burned down and you lost both. Case 2: you copied the creative slogan to the one outside. The house burned down but the outside board was safe.
You are missing some braces in the code snippet.
This post is on topic. Please do not report it.
Nice blog! Didn't read the OP since I'm currently learning C, but found this instead: https://ds9a.nl/articles/posts/cpp-rust-go/ and it was a great read!
I'm not sure I believe that lambdas are syntactic sugar in C. I don't think there is a way to define a local anonymous function in standard C. 
They are syntactic sugar in C++. They're basically a class with \`operator ()\` that's then instanced with the captured values. If you want to do it in C you'd use a struct with the captured values and return it together with the function pointer I suppose. But you also need a destructor obviously.
At some point it cease to be "syntactic sugar", which I generally consider macro-like expansion behavior. For example, "a\[i\]" instead of "\*(a+i)", or a-&gt;x instead of (\*a).x. (These are directly from the wiki entry on the subject. But notice how I can formulate that as a simple process for the compiler -- "if you see a\[i\], rewrite that as \*(a + i)" &amp;#x200B; Now, let's talk lambdas. &amp;#x200B; if I have a C++ statement like: &amp;#x200B; int test_fn() { Notification n; auto trigger = [&amp;n](){ n.Notify(); }; SomeCall(trigger); ... } How would you syntactically sprinkle sugar on that in C? &amp;#x200B; struct capture_crc32_5378a58f { Notification *n; }; static struct capture_crc32_5378a58f global_crc32_5378a58f; void fn_crc32_5378a58f () { global_crc32_5378a58f.n-&gt;Notify(); } int test_fn() { Notification n; global_crc32_5378a58f.n = &amp;n; SomeCall(fn_crc32_5378a58f); } I can't think of an easier way -- and this pollutes the namespace, and seems a bit far from "syntactic sugar", since I bring in renaming rules and a variety of other things. It does sort of work, but I'm betting I'm missing a whole lot of stuff in between. And, yes, it's still basically missing a "destructor". So, okay, as I write it, I am a tad more convinced it could be called "syntactic sugar", but it seems like a stretch. &amp;#x200B; (By the way, the names in this case are from the filename/linenumber of where the lambda would have happened). &amp;#x200B;
create a variable x for the number of people, have an input populate the x variable, then use a loop to run the data entry function x times.
I don't understand. I have to assign variables to the value of name and age. These variables can't have their values changed.
Sorry, I misread yoru code and thought you made it different and tried letting me know to do it that way if that makes sense. I wasn't refering to the wFace["Jack"] part. 
I mean create a new variable for the number of people, we'll call it "number" then have code tat looks like this: &amp;#x200B; scanf("%d", &amp;number); while (number) { gets(name) scanf("%d", &amp;age); \--number; } The first line lets the user enter the number of people. The while loop will keep running while number returns true (while it isn't 0). In the while loop we have 3 lines, the first two get the name and age data from the user, the third decreases the value of number so that the loop ends after the right number of inputs.
So where would the age and name of the second person go. Say if I had 8 seperate people and wanted to print all their individual names and ages at the end. All this couldnt come from two variables.
report
First time anything has made me want to think about trying C++.
Maybe not using plain C strings, but libs like [sds](https://github.com/antirez/sds) have made string handling in C as easy as any other language at C's level
Do what as an array? Tje deck and hands are already arrays. If you're talking about the face and suite data structures, it doesn't make much sense to set them as arrays. if you do this int faces[] = {"Nine", "Ten"...} Then you still need a way to map it like so #define Nine 0 #define Ten 1 .... In which case, you don't really need the faces array to begin with. you can check the face value like so GET_FACE(card) == Jack Enums are great, but when in Rome, I guess
Having a means by which a prototype for a variadic function could specify that a function expects e.g. an unknown number of `float` values, would be helpful. Beyond that, I'd say that having arguments get converted to the type expected by the called function is a good thing. Having the type of floating-point value passed to a function depend upon the type of the expression is a bad thing--something I think Dennis Ritchie recognized but the authors of C89 didn't--a failure which led to the devolution of floating-point semantics. Quality floating-point semantics should perform computations with a type that has somewhat more precision than the most efficient floating-point "storage" types, but should make the floating-point types used for computations available to the programmer for holding temporary values. Quality language semantics should coerce floating-point arguments as necessary to meet a called function's needs. The way C89 is written forces implementations to choose between quality floating-point semantics and quality language semantics. Its failure to say that all floating-point arguments--*including long double*--will be coerced to a consistent type means that the only way implementations can provide quality language semantics is to use the same storage format for `double` and `long double`, effectively precluding support for quality floating-point semantics. 
What's a palindrome program? That could mean any number of things.
A computer program is a set of logical instructions to acomplish a task, so to write a program you must first break the problem down into a series of logical steps, then implement those steps in a programming language. To learn the syntax you should read a book on the language or follow tutorials online. The only way you'll get good at it is with practise. 
The issue of programmers knowing more about the target than the compiler isn't something limited to older compilers, but is actually a bigger problem with newer ones. A quality implementation intended for low-level programming on a particular platform should treat a call to a function that does a `volatile` access as though it might trigger any effect that a `volatile` access could trigger on that platform. Given something like: uint32_t *volatile rx_handler_addr; uint32_t volatile rx_handler_count; void start_reading(void *p, uint32_t count) { rx_handler_count = 0; rx_handler_addr = p; rx_handler_count = count; RXDEVICE-&gt;IRQEN = RXDEVICE_IRQEN_RXF; while(rx_handler_count) ; } int data_ready(void) { return (rx_handler_count == 0); } a quality compiler for a platform with asynchronous interrupts should not try to reorder loads of any object whose address has been passed to `start_reading` across subsequent call to `data_ready`--a restriction which older compilers would generally uphold by limiting optimizations across `volatile` accesses or function calls. Unfortunately, the authors of "modern" compilers like gcc and clang take the view that because the Standard doesn't require that implementations support low-level programming with asynchronous interrupts, they have no obligation to refrain from "optimizations" that would make them unsuitable for such purposes unless nearly all optimizations are disabled. 
The Unisys [OS 2200](https://en.wikipedia.org/wiki/OS_2200) is one's complement, supports C and had its latest release in 2015. I don't know if it supports anything newer than C89 though.
Yeah, we've come a long way since the PDP-11. I worry that if they *do* invent a language the optimizes well on modern architectures, I won't understand it.
The way I have it is the way the teacher wants it is what I'm saying. 
int main() { char *instr = 0; char *outstr =0; printf(“Enter string “); sscanf(“%ms”), &amp;instr); printf(“%s \n”, instr); outstr = malloc(sizeof(instr) + sizeof(“ Green “); strcpy(outstr, strtok(instr, “ “)); strcat(outstr, “ Green “); strcpy(outstr, strtok(instr, “ “)); printf(“%s \n”); return 0; } I just wrote it in the comment box without trying, no guarantee that it compiles without errors but it might provide some idea. 
I think the first task (copy the input to a new string) is missing but you can easily add it. Observe %ms and using reference to pointer in sscanf. This way you let sscan to allocate the memory for the input string, so you do not run into buffer overflow problems. Yea, you may have to delete instr, same as outstr at the end.
The sidebar has a resources section
[C Programming: A Modern Approach](https://www.amazon.com/C-Programming-Modern-Approach-2nd/dp/0393979504)
Pay attention and do all the chapter assignments and prohects
If this is yours then you are a lovely human being.
This would probably work if all your logic was in main. void bubbleSort(int arr[], int n); void printArray(int arr[], int size); When you pass an array to a function like this, it makes a copy and passes it to the function. Any changes made inside that function are made to the copy and not the original. So the array you're printing is not the sorted array. Best practice would be to pass these as pointers, but for this you can just return the sorted array in bubbleSort. int sorted[] = bubbleSort(arr, n)
wrong sub
These lines are just function declarations, and don't actually do anything: void bubbleSort(int arr[], int n); void swap(int *xp, int yp); void printArray(int arr[], int size); You need to actually call the functions. For reading the file, you should probably use `fscanf` in a loop. Since you know there's exactly 50 numbers, just a simple `for` loop should suffice.
if it's a general programming assignment, try to do it in another language first, like python. Get that working, then try to translate the ideas into C. What I'm suggesting is that there is the conceptual part of the assignment -- how to design a program, regardless of programming language, to achieve the problem. That must first be understood. Then it's just a matter of implementation.
The stdio library is line-buffering the output stream: the printfs are just adding to the buffer in memory and not writing to the file descriptor until the buffer is full, the stream is closed, or there's a new line.
It's printing eaxtly what is entered -- what would you like it to print instead?
What's the deal with the 2d deck? What are the rows and cols supposed to be? Is it four player hands?
for example in the position {0,2} i wrote the value "3". In the table down below is printing "4". the same in {1,2}, {2,2}, {3,2} and {3,1}
what are the rows and cols of the deck supposed to represent? and why are your loops from 20 to 24?
what are the rows and cols of the deck supposed to represent? and why are your loops from 20 to 24?
I'm not sure if I can follow it. So,do you mean that it wait for new-line and thats the reason why "parent" is printed later on?
We need to talk about arrays, how they're sized, and how to index them. This is a very common thing that beginners need to learn, and the source of bugs for professionals as well. I'm sure you've gone over this in class or with whatever book you're using, but it's worth reviewing. To simplify, let's look at just an array of one dimension: int array[3]; This is an array that contains 3 items in it. They have the indexes 0, 1, and 2. The best way to write a loop to access them is generally as follows: for ( int i = 0; i &lt; 3; i++ ) Note a few things here. `i` starts with 0, I use 3 (the same as the size), and I use `&lt;` and not `&lt;=` or even `==`. This combination ensures we get things write. Compare that to the two ways you wrote the loops in your code: for ( i = 0; i &lt; 4; i++ ) Notice this is has a 4 instead of 3. That will cause it to go one bigger than the array actually contains. for ( x = 0; x &lt;= 3; x++ ) The difference here is `&lt;=`, which will do the same thing. Essentially, your loops are treating `tabla` as if it's bigger than it really is: a 4x3 table instead of 3x2. That's 12 items instead of 6. This will cause some strange behavior -- if you worked through a diagram for how the table is stored in memory, you'd see why you get the results you do. This is a worthwhile exercise, honestly. The solution here is to make your loops consistent (see my example), and make sure the array dimensions are exactly what you want. The fact you weren't surprised by needing to input 12 things tells me it should probably be declared as `int tabla[4][3];` and you should alter the second set of `for` loops for consistency with that.
Actually, many of the applications for which C is most useful are run on processors that--aside from physical size, price, and execution speed--really aren't all that much different from the PDP-11 or its successor the VAX. One wouldn't have to add a whole lot to C to allow for more effective and safe optimizations. Unfortunately, some compiler writers would view the addition of such directives as a bigger change to the language than throwing out the principles the published Rationale for the Standard recognize as the Spirit of C. If the Standard were to recognize treat C code as operating conceptually upon a physical machine, but recognize circumstances where compilers can cache things or perform certain other optimizations, and provide that certain actions and directives will synchronize various aspects of the logical state with the physical state, such a model would be easier to work with for programmers and compilers alike than the present "abstract machine" model, especially the unworkable "effective type" rules. 
Look up how to use scanf
 int arr[50]; int length = 0; char c; FILE *fp; fp = fopen("fiftyrandom.txt", "r"); if (fp == NULL) { printf("Cannot read file.\n"); exit(0); } do { c = fgetc(fp); if (c != EOF) { arr[length] = c; length += 1; } }while (c != EOF) {
You are correct. i wrote int tabla \[3\]\[2\] thinking that as {3,2} is the index of the last number in the array this should be the size of the matrix. Now i see the index starts with a 0 instead of a 1 and the size should have been \[4\]\[3\] since the begining. Thanks for the explanation you made it so much clear than the slides of my proffesor . And for taking the time to help me, again thank you a lot :)
Since other posters have already given good resources, I'm going to let you know that generally, this is what college is like. Your professor will give a brief explanation of a topic, maybe an example or two, and then move on. It's *expected* that you fill in the gaps yourself - which is what you're doing now and that's great - just be aware this is how it will be for the rest of your course.
So std::function heap allocates? Is there any way to pass a lambda to a function without heap allocation or templates? I mean, you can type erase even if it's a pointer to the stack. 
The only time I'd say `string.h` functions could be described as "friendly" is when one is working with fixed-sized buffers that are large enough to handle worst-case inputs. In that case, they can be convenient if one doesn't care about performance or the lack of buffer-overflow checking. Beyond that, just the only thing good about them is that they can operate upon string literals. If C supported either static constant compound literals or gcc-style statement expressions, thus allowing in-line specification of literal strings with other storage formats, there would be little reason for many programs to use zero-terminated strings at all.
If the lambda doesn't have a capture then it can decay into a standard function pointer, which can be used for parameter passing. But if it has a capture, then you have a problem, since now an arbitrary, unknown amount of data has to be passed around. That's really what `std::function` gives you over a function pointer, and I'm not sure there's a way around heap allocation. There's a [CppCon 2018 video](https://www.youtube.com/watch?v=VY83afAJUIg) about alternatives to `std::function` that I haven't watched, though, so maybe there is another technique for situations like this?
Please do not post pictures of code. Always post your code as text so others can edit and compile it!
Okay, sorry about that I'll do that from now 
For the rows and column thing, it's supposed to be some kind of random thing From what my teacher taught us with arrays it randomly picks so you put the Suits in the row part and Faces in the column then it'll correspond with say (2,4) which I think would be 9 of clubs if that makes sense. And my teacher wants us to just have those five card faces (Ace, Nine, Ten, Jack, Queen, King) I went from 24 to 20 because for some reason it wasn't listing off five cars like it is supposed to. 
No problem. Just keep this in mind. Many people instantly skip a post where the poster doesn't post his code as text, so you might just get much better help if you do it right in the first place.
What are the unsigned ints you're storing it it, then? if wDeck\[0\]\[0\] is the ace of hearts, what does setting it to some number accomplish? is it 0 for not in the hand, some number for in it? &amp;#x200B; i thought it was deck\[players\]\[cards\] which would look more like this (but the comparison should still apply if wDeck\[suite\]\[face\] == true/false) #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #include &lt;string.h&gt; #define SUITES 4 #define FACES 6 #define CARDS 24 #define PLAYERS 4 #define HAND 5 #define GET_SUITE(card) ((int)(card / FACES)) #define GET_FACE(card) (card % FACES) #define GET_CARD(suite, face) ((suite * FACES) + face) //... void shuffle(unsigned int wDeck[PLAYERS][HAND]){ int card; int row; int col; int deck[CARDS]; //init blank deck for( card = 0; card &lt; CARDS; card++){ deck[card] = 1; } //shuffle for (row = 0; row &lt; PLAYERS; row++){ for (col = 0; col &lt; HAND; col++){ card = 1; while (deck[card] != 1){ card = rand() % CARDS; } //save card to hand wDeck[row][col] = card; //remove card from deck deck[card] = 0; } } } &amp;#x200B; print hands like this void print(unsigned int wDeck[PLAYERS][HAND], const char *suites[SUITES], const char *faces[FACES]){ int row; int col; int face; int suite; for(row = 0; row &lt; PLAYERS; row++){ printf("Player %d has ", row); for(col = 0; col &lt; HAND; col++){ face = GET_FACE(wDeck[row][col]); suite = GET_SUITE(wDeck[row][col]); printf("%s of %s ", faces[face], suites[suite]); } printf("\n"); } } find jacks void find_jack(unsigned int wDeck[PLAYERS][HAND], const char *faces[FACES]){ int row; int col; int jack; int face; for(row = 0; row &lt; PLAYERS; row++){ jack = 0; for(col = 0; col &lt; HAND; col++){ face = GET_FACE(wDeck[row][col]); if (strcmp("Jack", faces[face]) == 0){ jack = 1; } } if (jack == 1){ printf("player %d has jack\n", row); } else{ printf("player %d doesn't have a jack\n", row); } } } &amp;#x200B;
Wow where to begin with? https://www.google.co.kr/url?sa=t&amp;source=web&amp;rct=j&amp;url=https://www.itu.dk/~sestoft/bachelor/IEEE754_article.pdf&amp;ved=2ahUKEwin1MLtyr7eAhUDzmEKHcShCFUQFjABegQICBAB&amp;usg=AOvVaw3QPWA-oOCZuPQlDQ799zm9&amp;cshid=1541466685218
Without seeing your code we have no way of knowing why you are seeing this output.
Here is the code: #include &lt;stdio.h&gt; int main(void) { float dollar, result; printf("Enter an amount: "); scanf("%f", &amp;dollar); result = ((1.05f)*dollar); printf("With tax included: %f\n", result); //I can use %.2f and it will be truncated return 0; } &amp;#x200B;
Single-precision floating point (`float`) has very limited precision. Double-precision floating point (`double`) has greater precision.
Would that still be using a pointer?
You could do this: result = dollar * 105 / 100;
not an error in the multiplication, but an error in representing 1.05 as a float go here https://www.h-schmidt.net/FloatConverter/IEEE754.html and type 1.05 into the top box, it will show you the "actual" representation in binary and give you decimal conversion/error
hop onto /r/dailyprogrammer and look at some of the C responses to simple programs you'd be able to do in another language of your choice, that will give you a feel for the syntax you'll use in most of your workflow. For specific syntax like library functions, pointer &amp; structure syntax, and the like, just google things as you need them.
F
Yes, you're right, I should've put the "printf" inside the "do" , but even if I do it, the program print an infinite loop of the last number of the conversion.
The result is not wrong, floating point operations are 'interesting' to say the least and and there are lots of considerations needed when using them but thats probably a different conversation. The comment correctly states that you can use the format to truncate the number and the result will always be correct. Do this and your code is good to go. float and double are representations and will always contain some imprecision, you just need to ensure that there is enough precision for the numbers you are using. An interesting alternative which is very useful to know would be fixed point or Q encoding. You can represent decimal places in integer values but you need to do the work in scaling and so on and you need to implement those considerations for the mathematical operations so functions for divide. Its worth a google because its a much faster way of implementing basic maths used a lot in embedded systems where floating point can be very costly if you have a lot of math. Its simpler than I have made it sound. 
Banana fibers can be used to purify water. *** ^^I'm&amp;#32;a&amp;#32;Bot&amp;#32;*bleep*&amp;#32;*bloop*&amp;#32;|&amp;#32;[&amp;#32;**Unsubscribe**](https://np.reddit.com/message/compose?to=BananaFactBot&amp;subject=I%20hate%20potassium&amp;message=If%20you%20would%20like%20to%20unsubscribe%20from%20banana%20facts%2C%20send%20this%20private%20message%20with%20the%20subject%20%27I%20hate%20potassium%27.%20)&amp;#32;|&amp;#32;[**🍌**](https://np.reddit.com/r/BananaFactBot/comments/8acmq6/banana/?st=jfof9k8d&amp;sh=acd80944)
Those should be ands (&amp;&amp;).
First of all, you don't want the error message to show, when the value is not a OR b OR c... As soon as one of those conditions is true, the whole becomes true as well. So you want to AND them. Secondly, you can define your range smarter than that. Take the smallest value and the largest value in your range and make sure, that your variable is insidr that range. 
You can do the same in C++. std::function is not mandatory in any way.
How so? You know the lambda signature but don't know the type of the lambda. 
This looks awesome. I learned C++...back in about 1999. I found little use for it and never really kept up with changes to it. A couple years ago, I found myself trying to navigate through a big C++11 code base and looked a bit like an alien language compared to the C++98 I was familiar with.
You use the `auto` keyword for this. auto lam = []() { print("Hi from lambda"); }; lam(); auto lam_ref = &amp;lam; (*lam_ref)();
On my task description it says that if the second number is greater than or equal to 1,000,000, the program should give an error, so i'm assuming the limit is 1,000,000.
Okay, but we're talking about passing them to functions as references. auto cannot be used as a function parameter argument afaik. 
It has ti do with how computers store floating point nunbers, here's a good read on that: https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/
your loop variable (for) is "i" but the variable you use to scan the input is "j". It will always output error since array\[j\] will most likely not be defined. Got me? you either change the loop variable to "j" or the conditional to "i" for (i=0; i&lt;7; i++) { if (array[i] != 'a' || array[i] != 'b') { printf("error"); } } 
This issue isn't related to pointers, it's something to do with how you are trying to compile/run your code. Remember you need to have a `main` function to run anything: #include "stdio.h" int main() { int a = 42; printf("%p\n", &amp;a); } … and you also need to include the relevant headers, `stdio.h` here because that's where `printf` lives.
Can you add a screenshot of code blocks and the code? Something else is going on here unrelated to the code you posted
Currency is generally not handled with float or double types, it is often managed using a fixed decimal integer style data type. Floating point numbers are not exact but keeping your currency as integer type then setting up the display to format it with a decimal point will be more exact.
You are looking at the Linux command line as if it were a Matlab notebook. It isn't. You need to write a program into a separate file, then compile it. Once you get the steps once, the workflow will make more sense. 
Consider using /dev/urandom as input to srand() on Linux, and similar on other systems. https://en.wikipedia.org/wiki//dev/random
These days I'd use [getentropy()](http://man7.org/linux/man-pages/man3/getentropy.3.html) to avoid having to open and read from a file.
Initialize the seeder with time and PID. 
I’m still working on my random generator as part of my class project,I made it its own function. Used “srand(time(0));” to Set the seed, seems to be working fairly randomly. Don’t have the rest of the code offhand it’s on my home computer sorry... I think I did something like “n = rand() % 100; “ after the seed
`rand()` will produce the same results when seeded with the same value. In your case all three instances are using the exact same seed time and thus producing the exact same results. To fix this you need to supply `srand()` with different values for each instance. As someone else said, using `time(NULL) + pid` should do the trick. The pid is a unique process id that the host operating system assigns to each process, and it should be different for each one of your instances.
Even using your exact code, it does not work. When building and running the program, it simply does the same thing. I'm doing all of this in the main function.
I don't understand anything you're trying to say here. I defined an int in the main function in codeblocks, then tried to reference its pointer and always get given a "No such file or directory" when building and running a main function that does nothing but make an int, then try to print its pointer.
What is the environment you are building this in? &amp;#x200B; From my linux command line, I can type: &amp;#x200B; echo -e '#include &lt;stdio.h&gt;\nint main(){int a = 42; printf("%p\\n", &amp;a); }' &gt; simple.c &amp;&amp; gcc simple.c &amp;&amp; ./a.out &amp;#x200B; And when I hit enter, I get a result: &amp;#x200B; /tmp]$ echo -e '#include &lt;stdio.h&gt;\nint main(){int a = 42; printf("%p\\n", &amp;a); }' &gt; simple.c &amp;&amp; gcc simple.c &amp;&amp; ./a.out 0x7ffe400994ec &amp;#x200B; You are building in a weird environment that is not saving the file correctly.
it's not that your program is not working, but that you're failing to build and run it.
https://up-for-grabs.net/#/
Based on a [previous thread](https://www.reddit.com/r/C_Programming/comments/9u4y7f/can_someone_explain_to_me_why_its_never_leaving/e91hvbj/): (`or` should be `||`) `array[j]` | `array[j] != 'a'` |`array[j] != 'b'` | `array[j] != 'a' or array[j] != 'b'` | `array[j] != 'a' &amp;&amp; array[j] != 'b'` --------|--------|---------|-----------|------------- `'a'` | `0` | `1` | `1` | `0` `'b'` | `1` | `0` | `1` | `0` `'7'` | `1` | `1` | `1` | `1` `1` means it will pass the check, `0` won't.
Not got time at the moment to look at all the code but a few quick notes. - Indent each line with four spaces so reddit will format it properly - `fgets` will read from the file a line at a time - and will store the newline character in the buffer. So you need to strip that off before you run it through `crypt`.
I'm assuming you only want to enter the while loop if the base is a number between 2 and 10. While b is greater or equal to 2 AND b is less than or equal to 10. while( b &gt;= 2 &amp;&amp; b &lt;= 10) Then in your while loop just print the message " The conversion of N is " Then in your do while loop print out each digit as you get them. printf("%d", a); Then you want your N variable to change to eventually be 0 so the do while loop will exit when it is done printing off all the digits. N = N / b; Your do while loop doesn't need to check what the value of b is because that was already checked just that N &gt; 0. Then, after your do while loop but still in your main while loop, get number and base input to check if the main while loop should execute another time.
I didn't know that, how would I then make it read the file when using crypt?
Can you post what you’ve tried thus far?
also, sorry for the formatting, I'm not used to reddit quite yet :)
Google "C get character" tutorial. If you can't do that, you will never learn.
fgets stores the newline character at the end of the buffer. you need to remove it by doing something like \`\`\`buffer\[strlen(buffer) - 1\] = 0;\`\`\` after fgets &amp;#x200B; otherwise the newline will get hashed with the password
As /u/lolisamurai has shown you need to remove it from the buffer yourself after the `fgets` call and before the `crypt` call. Also you *don't* want to be running `free` on the result of `crypt` - only do that if the documentation explicitly tells you to.
I'm studying Multimedia, not computer science, and we used C without prior knowledge of it, since that's what Linux kernel is written in, as it was Operating Systems course. I'd assume most people (unlike me) pick computer science in general, so... It's not whether they'll learn or not, it's about how the fuck did they even get accepted into the university.
&gt;I am doing a work for my University and i am stuck with a problem that is probaly simple but i have no clue what to do. (new) So you're doing work, can you show us how much of it have you finished so far? &gt;I need a programm which reads each letter but only puts out everything except for a ´0´. It should be an End of File like Ctrl+Z So, are you writing it yourself or are you expecting it to be written by you?
&gt;I'm good at solving problems efficiently Googling for a list of open source projects for people ***who never contributed to anything before*** or simply looking through github, reading source code and checking whether something is crap (issues tab is worth looking at to figure out what's crap or not) is way more efficient than asking on reddit you know. TL;DR i'M gOoD aT sOlvInG prObLemS eFfIcIeNtLy
If you wanted to use the ascii digits to compare between characters you’ll have to cast the characters in the array into a n integer, If((int)testchar != 54)) {... // Do work }
&gt;Python That's like the worst language you could suggest, not saying that there's anything better for that... What I mean is, if you can't understand C, as much as I love Python, with it's special identation, lack of type declarations and "Pythonic" ways of doing stuff, you'll never learn how to do something in C. To do something in C you either know C or you're dead. Also, probably, if you "know" C++, but can't understand C, then maybe you don't know C++ that well, because at most basic level, they are almost the same, as evident by people who like pissing others off and compile C with `g++`...
Use math.h to round to the nearest cent &amp;#x200B; #include &lt;math.h&gt; #include &lt;stdio.h&gt; int main(void) { float dollar, result; printf("Enter an amount: "); scanf("%f", &amp;dollar); result = ((1.05f)*dollar); //round to nearest 100th of a dollar result = roundf(result * 100) / 100; printf("With tax included: %f\n", result); //I can use %.2f and it will be truncated return 0; } If you're using gcc to compile you need the `-lm` flag gcc -lm -o progam.o program.c &amp;#x200B;
That's essentially what `std::function` is, really. The difference is that the pointer to the context goes to the heap instead of the initial lambda object. This gives `std::function` value semantics. I think that's a better default, as it has less opportunity for incorrect code (danging pointers if the original lambda goes out of scope). But, there is a way to provide reference semantics to `std::function`, which will avoid the heap allocation. You do this with `std::ref`. This wraps the lambda with a `std::reference_wrapper`, and since that has a fixed size there's no need to allocation. Usage looks something like this: void foo(std::function&lt;void(int)&gt; f) { f(42); } void bar() { auto lambda = [](int i) { printf("%d", i); }; foo(std::ref(lambda)); } I think the only caveat here is that it's up to the caller to wrap their function. I'm OK with that, as it's also then the caller's duty to ensure that there's no dangling reference.
If you are using C in college, you most likely are in computer science or simply are going through OS course. What made you pick Computer Science as major if you can't even figure out "what's going on"?
Nice work! It sounds like a fun project. I do have some criticism, tho. I don't think it's a good idea to write code like int method_name(int arg) { if(true) { do_something(arg); } else { do_something_else(arg); } } Why? It takes up so much space. When I write code, I want it to be readable but concise, too. You should write it in a more modern style, something like this: int method_name(int arg) { if(true) { do_something(arg); } else { do_something_else(arg); } } Like this you can do the exact same functionality, but you need 4 less lines of code. Plus, I think it looks prettier. Also, I usually indent my code by 2 spaces (or 4 spaces), but not with TAB characters, because it looks strange to me otherwise. But I guess this depends on editor settings and personal preference. I also think that you need to make sure you have small functions. If you look at [btk_pubkey.c](https://github.com/bartobri/bitcoin-toolkit/blob/master/src/ctrl_mods/btk_pubkey.c), you can see that the function is 400 lines long. Generally it's a better idea to refactor that into subfunctions. I like your [Makefile](https://github.com/bartobri/bitcoin-toolkit/blob/master/Makefile), I think it's nice and clean. You should also consider checking out meson, it might be able to give you an even cleaner build script. I think you should consider adding some comments. You don't necessarily need to put them into the code, but you should at least comment the header files. If I look at [base58.h](https://github.com/bartobri/bitcoin-toolkit/blob/master/src/mods/base58.h), I have no idea how these functions work or what parameters they take. And if I'm going to use your code, I don't usually want to have to read the implementation to find out how I need to use the functions. When you have a look at [version.c](https://github.com/bartobri/bitcoin-toolkit/blob/master/src/mods/commands/version.c), on line 62 you can see an assert statement. Why is that there? Maybe you should add a comment there to explain it's purpose. In the same file, the function version_to_json, I think you can simplify this by using [jansson](http://www.digip.org/jansson/). That way you don't have to build JSON by hand and you don't have any issues with escaping. My last criticism is: it seems like you don't have any tests? I think you should write some, it's always good to have them to make sure your code works as intended.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [bartobri/bitcoin-toolkit/.../**base58.h** (master → 310e2b6)](https://github.com/bartobri/bitcoin-toolkit/blob/310e2b6ab9be26fcc133de2d3d56d185a0da12a6/src/mods/base58.h) * [bartobri/bitcoin-toolkit/.../**Makefile** (master → 310e2b6)](https://github.com/bartobri/bitcoin-toolkit/blob/310e2b6ab9be26fcc133de2d3d56d185a0da12a6/Makefile) * [bartobri/bitcoin-toolkit/.../**version.c** (master → 310e2b6)](https://github.com/bartobri/bitcoin-toolkit/blob/310e2b6ab9be26fcc133de2d3d56d185a0da12a6/src/mods/commands/version.c) * [bartobri/bitcoin-toolkit/.../**btk_pubkey.c** (master → 310e2b6)](https://github.com/bartobri/bitcoin-toolkit/blob/310e2b6ab9be26fcc133de2d3d56d185a0da12a6/src/ctrl_mods/btk_pubkey.c) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e961s1s.)
How many books have you read related to programming languages itselves as opposed to Computer science? If so, what's the main benefit of having a book with biased advice on how one should program when you can just look at the standard and successful projects to learn how it's done? I'm asking because I never read such book in my entire life, unless you count `man` pages as reading a book and I'm wondering whether I could get anything useful out of a book if I already know (as if that's hard) how to look for information related to language itself.
&gt; It's also ugly as sin and adds nothing Ugly is subjective, but it does add *something*. For a reader who may not be totally familiar to C, it explicitly lets them know that `argv` is an array of char pointers with a length of `argc+1`. For a tutorial book I think that's fine, and the author provides an adequate explanation of its use within his constraints of using C99.
fuck off motherfucker. YOU CAN SUCK MY COCK baby
i didnt know what i was doing wrong... until i discoverd tht ' ' doest mean the ASCII Code, it just means that the int variable is an letter so it can be excluded
I think the point is that is doesn't matte how long experience a programmer has. I have known developers with literally decades of experience who are truly horrible at programming. Likewise I have known freshly minted college graduates who are assume. Time helps developers get better, but it is really a bad metric for identifying ad "good" programmer.
You might get better help in /r/embedded, since it seems like you're doing a LOT of low level hardware manipulation. &amp;#x200B; I'd first try writing a test harness that doesn't do all the mmap() functions and make sure the client/server are both working, then start adding things back in and debugging. &amp;#x200B; Have you tried running it in a debugger?
The main benefit is its a a good starting point and a defined path. Most people use K&amp;R which is a fine start but I found the above book better for someone who is all the way into November without paying attention and putting in the hours to pass his class this semester. He needs to catch up. Reading the standard is not the way IMHO. Having a decent, well thought out, and effective tutorial to cram for a passing grade this late in the game is the way to go. 
I’m gonna be selfish and suggest my lil [project](https://github.com/VKoskiv/c-ray)
I'll post this over there as well. I am doing a lot of low level hardware manipulation and I have pretty much no idea what I'm doing. As I said in the post, server and client communicate just fine up until a certain number of commands are made in the code I've posted above. I've tested the server and client multiple times with none of the hardware manipulation and it works no problem. 
You might want to add some 'volatile' to your get_offset/set_offset memory functions.
Could you explain? I don't understand your instructions. 
Thanks for checking out the project and providing some feedback. &gt;I don't think it's a good idea to write code like... I used to write code like you suggest. I recently decided that I like the extra space above and below compound statements. I think it is easier to read. The extra vertical space tends to be an acceptable trade-off. And I prefer tabs over spaces. It's all just a matter of preference. There is no right or wrong either way. &gt; I also think that you need to make sure you have small functions. Agreed. 98% of my functions are small and very specific in purpose. There are only a few functions that govern logic and flow control that are somewhat big. One of those is the one you called out. That said, you still have a fair point. I'll add a TODO item to see if I can break out some of the code into other smaller functions. &gt; I think you should consider adding some comments. I like to believe that well structured code comments itself. But I agree with you about generally adding comments for the function declarations. I will add that to my list of TODOs. &gt; In the same file, the function version\_to\_json, I think you can simplify this by using [jansson](http://www.digip.org/jansson/). I initially looked in to using a json library of some sort, but C doesn't seem to have anything in its standard library, and I didn't want to add a dependency for it since I only use it in one specific case. If in the future json is used more broadly then i'll definitely use a library. &gt; it seems like you don't have any tests? You are correct. This is already on my TODO list. &amp;#x200B;
England 2018-02-15 2018-05-16 120 France 2018-02-15 2018-05-16 130 Belgium 2018-02-15 2018-05-16 140 Russia 2018-02-15 2018-05-16 150 Poland 2018-02-15 2018-05-16 170 Germany 2018-02-15 2018-05-16 200
 England 2018-02-15 2018-05-16 120 France 2018-02-15 2018-05-16 130 Belgium 2018-02-15 2018-05-16 140 Russia 2018-02-15 2018-05-16 150 Poland 2018-02-15 2018-05-16 170 Germany 2018-02-15 2018-05-16 200
Happy to switch to strcmp but that part of this code is working fine. 
I just switched it to strcmp and now it doesn't work right. 
You’re not getting it. You can not compare strings the way you did originally - you just use strcmp, or better strncmp. If it’s “not working” now, it never did.
I'm very surprised it does... by my understanding, that will compare the value of the "type" pointer itself to the value of a pointer to the string "S2MM". Those will never compare equal. You might find you get failures in some unexpected ways down the line.
Try disabling structure alignment. Performance may suffer. But anyway, you should avoid reading data directly into structure. Different architectures store numeric values in different format. File may be written with most significant byte first (MSB), but your program may work on a least significant byte first (LSB) architecture, which means binary data for - let's say - integer will be incorrectly stored in memory after loading it into a structure. Google "byte swapping" to get more info.
That looks like text instead of binary data. Is that just because it's how you've pasted it in for us to see, or is it actually a text file? Another thing I notice is this line: while ( !feof( btf ) ) { Since you're using `fread` to read the entire array in one go, no loop is necessary. Even if it were, you don't use `feof` to control it. Immediately discard whatever resource told you to use this function, because it's going to cause problems. `feof` doesn't tell you if the next read will fail because you're at the end of the file ... it tells you if the last read failed because you were at the end of the file. That's a small different, but important. In this case, it means that you'll read in the array, then the end-of-file check will pass since that read was successful, *and then try to read in the array a second time*. But, of course, the file is empty at that point ... so what exactly does that do? Honestly, I'm not sure, and the man page doesn't say. It might be that the array gets corrupted. And a last point, make sure that the structure matches what was used to write out the data (assuming a binary format) exactly. Any extra padding (which the compiler will probably insert before the `price` field in this case) can throw things off completely.
welp, just learned that argv is null pointer terminated! given the null pointer is redundant information, the argc+1 part just seems to complicate things. I'd stick with `char *argv[]` or `char **argv`
No I did not get any compiler warnings. I don't have any flags set though, either. Look I'm not good at C okay? A lot of my code is based off of whatever I can find online. I'm doing my best here but I wouldn't even describe myself as an amateur. 
Please heed the advice you're getting from /u/ibisum. Your code comparing a string literal by using `==` is only working out of random chance. I'm not sure why `strcmp` is failing for you but keep in mind that it will return 0 if the strings match and non-zero if they do not. Specifically, it will return this: &gt; RETURN VALUE &gt; The strcmp() and strncmp() functions return an integer less than, equal to, or greater than zero if &gt; s1 (or the first n bytes thereof) is found, respectively, to be less than, to match, or be greater &gt; than s2. So you want to do something like this: if (!strcmp(type, "S2MM")) { printf("Match\n"); } else { printf("Not a match\n"); }
I get it, and I'm sorry if I came off as harsh. I think you should have some clues now as to what is going on - the comparison isn't working how you think it works, and you still have a little work to do. The fact that the socket doesn't work if you add a single line of code is a 'smell' that indicates that maybe you're corrupting a pointer somewhere, through some other mechanism. Its a thing in C that the little bugs often add up to very, very big bugs - so my advice is to take this one step at a time and fix the string comparisons, and other things that folks have hinted at. You may find that the bug you thought you were chasing wasn't the bug you needed to fix .. welcome to C life. ;) 
I think the problem may be here: int new_socket,c; // c IS NOT INITIALIZED ... while(new_socket=accept(socket_desc,(struct sockaddr *)&amp;client_addr, (socklen_t*)&amp;c)) { // etc. From the [man page](http://man7.org/linux/man-pages/man2/accept.2.html): &gt; The addrlen argument is a value-result argument: **the caller must initialize it to contain the size (in bytes) of the structure pointed to by addr**; on return it will contain the actual size of the peer address. I cannot see that you are initializing the value of *c* as required. Unrelated - in *memdump*, *memsend* etc. you are wanting to access *n* bytes, but you are actually printing *n* ints, which are presumably 4B on this platform: void memsend(void* virtual_address, int byte_count, int socket_desc) { unsigned int *p = virtual_address; // CASTING TO int* MAKES p[offset] ADVANCE BY 4B AT A TIME, READING WAAAAY BEYOND byte_count int offset; for(offset = 0; offset&lt;byte_count;offset++){ printf("0x%08x\n",p[offset]); write(socket_desc,&amp;p[offset],sizeof(p[offset])); } } p[0] is equivalent to \*(virtual_address+0B) p[1] is equivalent to \*(virtual_address+4B)... etc. p[n] is equivalent to \*(virtual_address + n \* sizeof(*int*)) Now I can't see that you're actually using these functions, but if *byte_count* definitely means actual bytes, then these casts are causing you to access memory way beyond the bounds of what's intended. 
- How do I check what version of c I'm compiling to? - I am seeing no warnings when I compile, but I am not setting any flags either. What flags would you recommend? - I'm ignoring return codes from the system calls cause I'm a bad programmer. Working on adding error checking now. 
The version of C you compile to will depend on what compiler you are using. Assuming you're on some *NIX OS, you're probably using gcc, for which I'll refer you to this StackOverflow answer for a far more comprehensive list than what I know: https://stackoverflow.com/questions/3375697/useful-gcc-flags-for-c Although you will certainly want -Werror, to make warnings into errors. Good to hear you're checking return codes :)
'volatile' is a C keyword that tells the compiler that the variable it is applied to may change at any time, for any reason, that will not be obvious to the program (or indeed have even happened inside the program). It stops some kinds of compiler optimizations. I don't know if you strictly need it or not, it depends on exactly what/how your ADC needs to be triggered and what you expect to read back into the program for it.
 root@red-pitaya:/opt# gcc -o -Werror test_server test_server.c test_server: In function `_fini': :(.fini+0x0): multiple definition of `_fini' /usr/lib/gcc/arm-linux-gnueabihf/4.9/../../../arm-linux-gnueabihf/crti.o:(.fini+0x0): first defined here test_server: In function `__data_start': :(.data+0x0): multiple definition of `__data_start' /usr/lib/gcc/arm-linux-gnueabihf/4.9/../../../arm-linux-gnueabihf/crt1.o:(.data+0x0): first defined here test_server: In function `__data_start': :(.data+0x4): multiple definition of `__dso_handle' /usr/lib/gcc/arm-linux-gnueabihf/4.9/crtbegin.o:(.data+0x0): first defined here test_server:(.rodata+0x0): multiple definition of `_IO_stdin_used' /usr/lib/gcc/arm-linux-gnueabihf/4.9/../../../arm-linux-gnueabihf/crt1.o:(.rodata.cst4+0x0): first defined here test_server: In function `_start': :(.text+0x0): multiple definition of `_start' /usr/lib/gcc/arm-linux-gnueabihf/4.9/../../../arm-linux-gnueabihf/crt1.o:(.text+0x0): first defined here test_server: In function `_init': :(.init+0x0): multiple definition of `_init' /usr/lib/gcc/arm-linux-gnueabihf/4.9/../../../arm-linux-gnueabihf/crti.o:(.init+0x0): first defined here /tmp/cc1eNFEL.o: In function `open_socket': test_server.c:(.text+0x0): multiple definition of `open_socket' test_server::(.text+0xe0): first defined here /tmp/cc1eNFEL.o: In function `server_structure': test_server.c:(.text+0x4c): multiple definition of `server_structure' test_server::(.text+0x12c): first defined here /tmp/cc1eNFEL.o: In function `bind_socket': test_server.c:(.text+0x90): multiple definition of `bind_socket' test_server::(.text+0x170): first defined here /tmp/cc1eNFEL.o: In function `send_int': test_server.c:(.text+0xfc): multiple definition of `send_int' test_server::(.text+0x1dc): first defined here /tmp/cc1eNFEL.o: In function `set_offset': test_server.c:(.text+0x124): multiple definition of `set_offset' test_server::(.text+0x204): first defined here /tmp/cc1eNFEL.o: In function `get_offset': test_server.c:(.text+0x14c): multiple definition of `get_offset' test_server::(.text+0x22c): first defined here /tmp/cc1eNFEL.o: In function `print_offset': test_server.c:(.text+0x170): multiple definition of `print_offset' test_server::(.text+0x250): first defined here /tmp/cc1eNFEL.o: In function `memsend': test_server.c:(.text+0x198): multiple definition of `memsend' test_server::(.text+0x278): first defined here /tmp/cc1eNFEL.o: In function `memdump': test_server.c:(.text+0x1ec): multiple definition of `memdump' test_server::(.text+0x2cc): first defined here /tmp/cc1eNFEL.o: In function `get_status': test_server.c:(.text+0x230): multiple definition of `get_status' test_server::(.text+0x310): first defined here /tmp/cc1eNFEL.o: In function `main': test_server.c:(.text+0x3ac): multiple definition of `main' test_server::(.text+0x48c): first defined here /usr/lib/gcc/arm-linux-gnueabihf/4.9/crtend.o:(.tm_clone_table+0x0): multiple definition of `__TMC_END__' test_server::(.data+0x8): first defined here collect2: error: ld returned 1 exit status root@red-pitaya:/opt# 
To expand on what Itonto said, what it looks like you've tried to do is Undefined Behaviour (UB). This is a big thing in C, and takes a while to get used to. In this case, by not giving c a value you're invoking UB. At that point the compiler is free to do whatever it wants, as there are no rules in the C standards as to what to do. So it's perfectly valid for your program to fail, to segfault, to wipe the original source code from the disk, or to work exactly as you'd expect. Hence why seemingly random, unrelated changes can cause your program to start breaking in weird and wonderful ways.
See my answer below for why not initializing the c variable makes things appear to work. I believe you want to set the value of C as so: c = sizeof client_addr That will set c to the size, in bytes, of the client_addr structure. You might find it helpful to go through a simple networking tutorial. I recommend Beej's guide to network programming: http://beej.us/guide/bgnet/ If nothing else, there's a lot of code snippets that you can just lift and use if you aren't so interested in learning everything top to bottom. For instance, from its accept() section is how I checked that the suggestion I gave you was correct. There's a lot to learn about low-level networking. 
Cleaner! Let me know when you get it working .. ;)
I think you're including headers that include other heards, which you are also explicitly including again. Hence, you end up with two definitions of a lot of things. I suggest checking out Beej's guide, which I linked in one of my other comments, to see which headers you actually need and which you don't. 
Dude I think that fixed it. You are a fucking lifesaver. 
Credit to /u/Itonto for actually spotting the problem in the first place. Good to hear it works :)
Will do, thank you. 
This appears to have been the problem. Thank you for pointing it out. 
Simple code style thing, but in my opinion you should either include stdbool.h, or just use 0 and 1, not define your own boolean constants. Also regarding boolean conditions, rather than if(condition == false), or if(condition == true) just write if(!condition) or if(condition). This also encourages naming boolean variables with names that make it clear what happens when they are set e.g. if(should_eat_pasta) is much way clearer than if(pasta).
Thanks, I'll try it out. Also, this is off-topic, but are there any books or online videos you'd recommend to learn C?
i don't know much about learning c, but c a reference manual advanced programming in the unix environment are both pretty handy, but the APUE is pretty pricey
I do my braces like the OP and have for 30 years... I know the method you showed is more common (K&amp;R) but I find mine easier to read for me. All opinion, both have merits.
I am in the huge minority but I also use the same braces style. I have used both and for a multitude of reasons find it makes reading code easier and makes things clearer. 
&gt; This seemed to work well at first but it had a surprising problem: in some cases, output and errors of order.
Any lambda that doesn't need to extend the lifetime of the objects it captures could be encapsulated in a single `returnType(**proc)(void*, ...other params...)`, which would be invoked from C via `(*proc)(proc, ...other args...)`, without need for heap allocation. The direct target of the double-indirect pointer would function pointer stored somewhere within an object of arbitrary structure type whose layout would be known to the function in question. That function could then subtract the offset of the function pointer within that structure to get the base address of the structure in question.
bit coin .. I thought that was dead like ethereum .. it was a fun ride while it lasted 
This is pretty nit-picky, isn't it? I can't imagine any case where a developer is reading the code and is struggling to understand the conditional construct of `if (variable == FALSE)`. If anything it is more explicit and more easily understood than the more concise alternative of `if (!variable)`. 
Hmm this is odd. Try this: 1. Save the code blocks file to your desktop 2. Click the cog at the top of the code blocks interface (it should say something like build when you hover over it) 3. Click run (the play button) Do you still get the same issue? 
Thank you, I fixed it. Turns out, I create binary file not in a correct way. I now managed to create it in my program. Your advice was really helpful. But I have another question. Is it possible to create a binary file not with my code? 
I was making pretty simple blocks of code, just for the sake of learning C; so once it was pointed out to me that this error had nothing to do with my code, I simply abandoned the project entirely and have had no issues since. It was my own stupidity for thinking it was a problem with my code, even though no line number was given, but I thought "No such file or directory" was related enough to pointers that it was somehow my own fault, and I've never had my editor mess me up before today.
Did you look at how strcmp works? What does it return if they match?
In terms of the language definition, the two codes are exactly the same. `argv` has type `char **` . The reason the author uses the first one is as a form of self-documentation of the code. It tells the programmer that the function has a precondition; the `argv` pointer should be pointing to the first element of an array of that length.
I'm afraid I'm not sure what your question is asking, so correct me if my answer is less than helpful. I think you're wondering if a binary file can only be read by the program that created it? It's certainly possible to write a binary file using one program and read it with another. I do this in my day job, actually. But it can get tough. Writing arrays of structures out like you did is tricky, because the compiler's allowed to insert padding between different members, and you don't have any control over that layout in the language itself (though there are packing attributes and other pragmas to get over this). So it's often easier to read and write each member individually, so you know exactly what's going on and so the code is portable between different architectures, platforms, compilers, etc.
It's an old school kind of thing. I learned to program in C about 30 years ago and I'm just the same.
I'll tell you what's going on, you're a generic skid who gets taken to uni because they all care only about how much money you'll pay and not how much brain you have. Goodluck with that.
If we needed to get to the point then I'd just ask them why the fuck are they looking to contribute to some shitty free project when they could just earn as much money as they want since they are programming god who can solve any problem in most efficient way possible, but I'm not really in mood to go deep down the rabbit hole.
lol
r/atethepasta
You need to install the development package for the library. 
Engine is here https://github.com/EvilPudding/candle
Awesome work! This is really cool.
&gt; I used to write code like you suggest. I recently decided that I like the extra space above and below compound statements. I think it is easier to read. The extra vertical space tends to be an acceptable trade-off. And I prefer tabs over spaces. It's all just a matter of preference. There is no right or wrong either way. I think one of the reasons why python is so popular because it essentially forces you to use a certain style. That way, a lot of these style differences can be eliminated. Have you ever used an automated code formatter like clangformat? 
Thanks!
Unit tests. Like that scene in the Matrix where Neo says, "Guns. Lot's of guns." Lot's of unit tests. This isn't a project where you can turn it off and back on again. It's got to work all the time, every time on every release. Look at Parity Wallet for what goes wrong if you have a serious bug.
You open a file with fopen, read it with fscans, and then close it with fclose. I don't inderstand why your struct has only two variables for ten values, so I'll ignore the struct for now. include &lt;stdio.h&gt; main() { FILE *fp; char word1[255]; char word2[255]; float nums[8]; fp = fopen("/tmp/test.txt", "r"); fscanf(fp, "%s", word1); fscanf(fp, "%s", word2); fscanf(fp, "%f, %f, %f, %f", &amp;nums[0], &amp;nums[1], &amp;nums[2], &amp;nums[3]); fscanf(fp, "%f, %f, %f, %f", &amp;nums[4], &amp;nums[5], &amp;nums[6], &amp;nums[7]); fclose(fp); } 
Every function you use for input from the keyboard has another version that takes a file pointer. The name of the function starts with an "f". Reading in a file that you produced with your own code is going to be the simplest. Copy and paste and change the output functions to the equivalent input functions and it will usually just work. Reading in a file created in a text editor or another program I recommend incrementally reading a thing, checking to see if it matches what you expect then trying to read two things, check if it matches what you expect, and so on.
Google "man fscanf" for details. The docs imply that if you read one value at a time it will ignore newlines amd whotespace, so I edited my code. I'm ony phone so no promises it's exact.
What format did you use for skeletal animation? gltf? I’ve been looking for a c library to load skeletal animation but no such luck 
No one is surprised as me. The manpage implies fscanf ignores spaces, tabs, and new lines
Oh for sure thank you for that. Now I feel a little bit better knowing that complicated C problems (for a noob) can be tackled in an simple and elegant way. I was literally about to bust out all my knowledge on C and implement while loops, getchar, structs, etc. lol. Thank you again!
Although assimp is C++ internally, it's API is made entirely compatible with C, all you have to do is navigate the structures correctly. Currently, assimp integration is a plugin to the engine, because I didn't want it as a mandatory dependency. You can check out `candle/utils/mesh.c`to see how a mesh is loaded, and the assimp plugin linked in the `README.md`for the loading of nodes, bones, lights and materials.
Hey Diagonal_alley since you are knowledgeable in C and I have your attention can I ask you a quick question about floats and division? Let's say I have a float userNum = 10 and I multiply it by (10/100), in division form, why does it produce 0 and not 10? However, if I multiply userNum by .10 then it produces the correct value or if I multiply it by a value that results in a quotient greater than 1 it produces the correct value. I tried looking for an explanation for this online and I could not find one. Thank you
That's integer math. (10/100) evaluates to an integer and c rounds down. I believe that setting one of the numbers to have a decimal will evaluatr as either a float or a double. Try float f = userNum * (10.0/100); or float f = float(userNum * (10.0/100)); 
I would recommend starting with SDL. That library will handle everything for you (2D graphics, audio, keyboard, mouse, even networking) and is relatively straightforward. If you want the game to just save and load, no, you don't need a network. If you want to play with friends or communicate with friends, then yes, you need networking.
Thanks!! Didn't know about SDL. Thanks again!
Since someone else already recommended SDL, I will add [Allegro](https://liballeg.org/). Like SDL it is a cross-platform framework that takes care of the low level details of game programming. Qt is C++, but it is easy to use and very well documented with lots of sample code and tutorials. I have only done the tutorials in Gtk, but it is also pretty easy to get started with. 
Couldn't resit what?
This submission has been randomly featured in /r/serendipity, a bot-driven subreddit discovery engine. More here: /r/Serendipity/comments/9uwfv1/added_skeletal_animations_to_my_c_engine_xpost/
Also, assimp does have gltf2, but the mannequin in the video is loaded from a fbx.
Seems like it is because you've declared them as static 
Alright, I have never stated that I'm the programming god or anything like that, I just wanted to say I'm not the one who doesn't understand the difference between O(n) and O(n\^2).
Good point, you're right. I guess I couldn't think of another metric. I wanted to give you some kind of information about me, so you could recommend better-suited projects.
In C, function arguments are call-by-value, not call-by-reference. Basically, arguments to function are local variables inside the function. Setting min and max inside myfunction has no effect on the variables in main(). Normally you'd fix something like this by passing pointers to min and max. void myfunction(int x, int *max, int *min) { ... *max = x; } For good practices, I would not reference any global variables inside myfunction. So include a pointer to sum in the argument list, too. And use x instead of array\[i\].
Very cool!
After quick analysis, it looks good overall. Few things: 1. In comments, don't say what something does, say why it does what it does. For example, "Can/Can't be seen from outside" comments are not needed, because it's obvious from the code. Also, you gave up on comments fairly quickly. 2. In function: ``` static void initqueue(queue **mqueue) { /* Allocate and initialize space for new queue */ (*mqueue) = malloc(sizeof(queue)); if (!(*mqueue)) return; } ``` You are ignoring errors and that will cause segmentation faults later in the code. When allocating small blocks, you can safely `abort()` on error from `malloc()`. The only error this function can throw is "Out of memory", and there's not much you can do with your program when that occurs. With large blocks you should never ignore errors from that function. Also, if function returns nothing, don't `return` at the end. It doesn't make sense. The result will be the same, no matter if condition is fulfilled or not. 3. In function `enqueue()` drop that `return` and use `else if`. The code will be cleaner. 4. In function `qdestroy()`, remove `printf()`. Non-IO functions should not print anything unless there's a very good reason for it. I think it's a left-over from debugging. 5. In function `isempty()` you could just use: ``` return !(*mqueue &amp;&amp; (*mqueue)-&gt;first); ``` Also, you can make it `inline` or turn into a macro. 6. In several places, use `isempty()` instead of: ``` if (!*mqueue) return NULL; if (!(*mqueue)-&gt;first) return NULL; ``` 7. In function `qsize()`, don't iterate over queue. Add a counter to `queue_t` and update it on every `enqueue()` and `dequeue()`. 8. I would add `qclear()` function, that removes all nodes, but does not deallocate queue. It could be also used in `qdestroy()`. The rest looks OK :) Good job!
When I add both max and min argument with &amp;, it ends out with red line and stated identifier missing... 
If you want to be a kernel developer, stay away from C++, unless you are really interested in that language. Choose GTK for GUI. My advise is this: don't bother with games. Buy a simple microcontroller starter kit (Atmel, PIC, STM32, ...) and write C programs making all sorts of fun stuff on it. You will learn much more for future kernel development.
OH! OK.. but can I ask you why should I stay away from C++? Every other suggestion make sense for me but what about C++??
OK Thanks for your advice!
I'm not sure how this works on Red Hat, but given that there is no `/usr/lib/libcheck.so`, something is missing.
Knowing the difference between `O(n) and O(n^2)` rarely matters when you're actually programming. Most things you need to do have already been made a billion of times in one way or another and complexity has already been calculated at least half as many times. Also, everyone understands it, one is n^2 and is a lot higher number /s Unless it's a very niche algorithm that has a lot of steps, finding big O and trying to figure out if you can change it isn't something you normally do. Example: dynamic array. Anyone who ever used C understands that `realloc()` isn't free and it's better to just alloc way more than you need (normally you need +1 to size every time you insert an element) How is knowing the difference between O(n) and O(n^2) will help here? You'll figure "let's just double it's size instead of reallocing with + 1" way before you even care to go into semantics of what it means from the side of asymptotic growth. TL;DR "I know the difference between O(n) and O(n^2)" hardly ever matters. Unless you're writing yet another physics or math library, like, just why, there's already libraries that are so efficient, even 10 years of your own work won't touch that.
Autotools (also known as "Autohell") is a standard build system for portable code. It is... uhmmm... easy...ish. Requires very good tutorial. Most of them aren't. But it can be fun. In a weird way. Sometimes. Good luck!
I love it, I'm just doing similar project but with Vulkan for 3D. I love to see more projects like yours in C.
Do I spot imgui on the left
&gt;whereas the second one iterates while pointer is not NULL. But if the pointer is NULL, doesn't it point to NULL (and thus iterates like the first one)?
Just wanted to add my opinion on comments - if you need comments over function declarations, then your functions are probably too big or badly named (either the function or the arguments). &amp;#x200B; If comments are needed, it usually means that the code is complicated. I always try to refactor so the naming and the code is crystal clear on conveying what it does. Sometimes, a function is just complicated by nature and warrants a comment, but usually they just add noise and get outdated in my experience.
Add -I'path_to_header' when compilinig.
What do you have so far?
It's nuklear, imgui is C++ exclusive.
&gt; I've got the tensor files under /usr/local/lib/include/ currently. That's unusual. Did you pick that location yourself? Normally, libraries go into `/usr/lib/`, `/usr/local/lib` or `/opt/&lt;vendor&gt;/lib` while headers go into `/usr/include`, `/usr/local/include` or `/opt/&lt;vendor&gt;/include`.
I regret not having started this in vulkan, maybe I'll still allow for it if I get the time.
When you say failed for loops, what exact code did you use? We need a starting point to help you. 
Since, I've gone to while loops... Wasn't sure if a for loop was the best way. Someone here seems to think a while loop is better https://pastebin.com/5ikiZxw4
So what you're saying is that `while(*pointer != NULL)` will eventually make my program crash in case I initialized my pointer like `int *pointer = NULL;` because the dereferencing operation will find nothing in that memory address (which doesn't exist), while `while(pointer != NULL)` will actually get the value of `pointer`, which is `NULL`, and stop iterating. Am I correct?
Exactly. Also, if you do int *foo = NULL; /* a NULL pointer */ int **pointer = &amp;foo; /* a pointer to a NULL pointer */ then pointer != NULL is true while *pointer != NULL is false.
That's the wrong directory, but that's not what the problem is. Pass `-I/path/to/include/directory` (e.g. `-I/usr/local/lib/include` in your example) to tell the compiler where to find header files. Pass `-L/path/to/library/directory` to tell the compiler where to find libraries. Finally, pass `-llibrary` (e.g. `-lfoo` for `libfoo.so`) to tell the linker to link in the desired library.
That's better. A few questions. 1. What is lol.h? 2. Why do you think is the loop not working? Why are you incrementing loopcount twice in the loop? 3. Your else if program has multiple redundant checks. (Entries &gt; 3 twice). It will ask for user input at most once before exiting. It will probably will never work out the way you want unless you use just if statements instead of if..elseifs. what exactly are you trying to do there? All loop constructs have 3 basic things that make them work. Initialization, Condition and Update. So using a for against a while is very much a personal preference and not a logical preference. I prefer a for loop because all of the three things happen in the first line of the loop. So, don't change your preferred method of using loops unless there's any specific need to. 
For kernel development and working in C, I'd suggest a text based game. Link people with a network protocol, or use a gateway and make it work from a chat bot. Simple enough game system, without all of the pain of GUI design. 
Solved thanks
Solved thanks
Solved thanks
Can you please edit your post and format the code properly? Remove extraneous backslashes and blank lines and insert four spaces in front of every line, even if it already starts with spaces. Also, please give every function and parameter an explicit type rather than rely on “implicit int”.
Thank you very much, that was helpful.
I just want to achieve the goal in my post and have very little idea on how to go about it
I see, thanks for the answer. Do you have any suggestions regarding learning material. Clearly this may not be the best book out there!
I regret not starting in OpenGl as I had zero background in 3D :D
While technically not incorrect, I think having multiple return statements for functions is overall poor structure. Having so many exit points for a function can make debugging a bigger pain. You can still logically structure them to work well.
The only suggestion I have is *The C Programming Language, 2nd ed*. I've browsed a few others, but it's much easier to sport a bad book than to spot a good one. I definitely wouldn't recommend *Modern C* and I wish it weren't in the sidebar. It's more of a manifesto than a textbook, and if I recall correctly, the author doesn't even consistently follow his own advice.
Why not extend the existing makefile with pkg-config based rules for finding your dependencies? A build system that seems to be en vogue recently for projects is meson. You might like that as it's python based.
niceeeeee, looks sick man
Good thing I just bought a copy of K&amp;R then :) Many thanks!!
All the more reason to start with Vulkan, you learn only one API that is easier to port to OpenGL than the other way around.
Hey man, this is really helpful. I have a few questions too if that's cool... What's happening at: names = malloc (num * sizeof(char*)) Could you add detail to this answer: Memory is being allocated for the program for the data of names to be placed... I'm unsure. Still learning. fscanf? I'm assuming this picks up symbols, numbers and letters? Or would that be the **names variable being written how it is? printf("enter name %d: ", i + 1); fscanf(stdin, "%s", names[i]); Also here, every loop, i increases by 1 meaning the next input when the loops comes around again is the array number assigned to the string about to be inputted if that makes sense? stdin???? Allowing all characters? What is the 'free' doing? Any answers would be great! Thanks... 
`qclear()` could be a macro, but `dequeue()` does things, that aren't needed when clearing, like pulling data. I would move clearing part from `qdestroy()` to `qclear()` and in `qdestroy()` call `qclear()` before freeing queue.
Community 2017 is what I use for C++, though you're going to get C# with it too- there's no option to exclude it.
I agree here. Especially with C programs, autotools works best for portability. Of course, getting it all to work correctly the first time will be a "fun" challenge. Personally, I've found the Autotools Mythbuster to be a decent guide to navigating this.
upvote for another survivor of the Microsoft and IBM OS/2 revolution that went no where .. fun while it lasted.
Will totally follow up on this sugestion. Thanks!
sounds like it might be useful for plugins. 
your main blocker here is that there is no ** operator. that is simply one * operator followed by another * operator. 
Presumably you're familiar with int a = 42; int *p = &amp;a p is a pointer to an integer. And that because p is a variable, you can take it's address too int **pp = &amp;p; p is an `int *`. So something that points at p is an `int **` -- And that a pointer has no size information. p might be pointing at 1 integer, or 10. int b[10]; p = &amp;b[0]; p is now pointing at the 1^st of an array of integers. So if you had an array of pointers int *c[10]; Then pp = &amp;c[0] means that pp is pointing at the 1^st of an array of pointers.
The clockwise/spiral rule is what you need. It is the missing thing for most people. Learning it made it so much easier to understand C http://c-faq.com/decl/spiral.anderson.html
 #include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #include &lt;stdlib.h&gt; int main(void) { uint8_t a = 1, b = 7, c = 4; uint8_t *my_array[] = {&amp;a, &amp;b, &amp;c}; // ^ that's an array of pointers to bytes, size of 3. printf("%d and %d are the first member\n%d and %d are the second\n", **my_array, *my_array[0], **(my_array + 1), *my_array[1]); return EXIT_SUCCESS; }
Possibly. You can also compile with -rdynamic, which will make your symbols accessible to what you dlopen. Well, that's what I use in \[gwion\](httpd://github.com/fennecdjay/gwion).
We don't have that operator. to exponentiate you call the stdlib function...
Manual chunking optimizations can be useful on implementations that are configured to be suitable for low-level programming. Unfortunately, because the Standard doesn't require that implementations be suitable for low-level programming, the authors of gcc and clang aren't interested in making their optimizers compatible with such constructs.
Since this is getting too many downvotes, let me be the one that tries to give a reason. Every language has a set of idioms that are in common use. While there may be other ways of doing things, the idiomatic way is the most well known to most programmers. Hence, it is the one that causes the least friction when reading code. `if (pasta)` is not clear, but I'd claim that `if(has_pasta)` is clearer and faster to parse for most C programmers compared to `if(has_pasta == TRUE)`. 
in c an array is a chunk of allocated space in memory that's all together, that's why the size cannot be dynamically changed. it also means that you can point to the second element of the array by incrementing the address of a pointer to the first element by the size of the element type. same with the third element, and so on. this means that really all you need to access an array is a pointer to the first element. this is why when you pass an array to a function, it's really just passing a pointer. for example, if you are given an array of 3 integer values, int a\[3\], you could reference the first element either as a\[1\] or as \*a (dereferenced a). also, you can traverse the array with a second pointer you assign with int \*c = a because a is actually an int pointer. bringing this back to the question you asked, int \*\*a is a pointer to a pointer to an int. that int pointer could be the first in an array of int pointers, or it could be the only one. same, with that pointer, so in all actuality, it could be an array of arrays of integers. it's all about the context, and the actual content a is pointing to. it might be helpful to think of pointers as coordinates for an object. they are their own type, and that address takes up memory. on that note, it doesn't allocate space for what you're pointing at. that is to say, if you declare int \*a, you do not have an array to fill up. you don't even have space for a single int. the only space you have is to store the location of an int. so wherever the content of a is being declared or allocated is where you'll want to look to see what it actually is. &amp;#x200B; tl:dr int \*\*a is an address pointing to an address that is pointing to an integer. beyond that it could be an array of int pointers, an array of arrays of integers, or again, just a pointer to a pointer to an integer. it's all about context. not sure how clear that was, but i hope that helped. it might be useful to look up some talks on data structures with c or c++. it's really important to get comfortable with pointers and manipulators.
Well um, in python someone decided to make that the power (^) operator, but in c/c++ that indicates a double pointer.
Read your compilation errors and suggestions and fix accordingly. 
pointers can point to single values *or* arrays of values. int a[] = {1,2,3,4,5}; int b = 6; int *pA = a; int *pB = &amp;b; pA[0] == 1; // true pB[0] == 6; // true pA and pB have the same type, but one points to an array while the other points to a single element. the **int type is a pointer to a pointer to int, that means that at the adress pointed to by the variable contains one or more pointers to int, and those pointers point to adresses with one or more ints. The takeaway here is this: pointers can point to single values or arrays, and there is no way to tell at runtime. The reason everyone talks about it as an pointer to an array is that there is no good reason to have a double pointer to a single value, at that point you could just use a pointer of depth 1. If you have a double pointer it's most likely because it points to an array of pointers. But double pointers to a single pointer do exist, they're just quite uncommon.
Do not spam.
&gt; Knowing the difference between O(n) and O(n^2) rarely matters when you're actually programming. Just for this statement I would not hire you. Knowing this makes all the difference in the world when you want to write an application that scales from 100 records to 1000000 records.
I agree. I do both, include stdbool and stdint at the top of all of my headers, but I also define Yes and No.
Please be civil. I know you are frustrated, but it's not a good idea to lash out at other users.
what kind of spam it has, its just a free guide to people who wants to learn this 
Imagine you write a library that takes a descriptor as returned by `dlopen` and does something with the library it describes. By invoking `dlopen` with `NULL`, you can use the same code to inspect the main program which might come in handy occasionally.
Thank you!
The program works on my compiler, but never on ideone
Oh really? Tell me about Big O importance when deciding whether to use HeapSort or QuickSort. Just shows that you're retarded and have no clue about it.
This is a particularly bad example and not in support of my argument because both have in fact the same complexity (when choosing pivots in a suitable way). What I am trying to point out is that a common issue is to accidentally write an algorithm that runs in quadratic time instead of linear time. If you test your code over a small set of records, it might perform very good and might indeed be faster than more involved methods (cf. [Pikes rules of programming](http://doc.cat-v.org/bell_labs/pikestyle)), but as soon as the number of records goes up, the program slows down to the point where it is unusable. If you do not understand the difference between O(n) time and O(n^2) time, such problems are very hard to find. This is especially important because this kind of algorithm design problem is one that is only noticeable once the application is used in the field or if tested with suitably large data sets.
as /u/Ynglinga said look at the errors like this: prog.c:4:25: warning: incompatible implicit declaration of built-in function ‘calloc’ prog.c:4:25: note: include ‘&lt;stdlib.h&gt;’ or provide a declaration of ‘calloc’
If you are going to say sorry then at least say sorry for being unable to admit being wrong. I love when skids bail out when they realize that they were wrong.
You did neither reply to my actual point nor did you seem to have understood it. it is pointless to argue with someone who doesn't respond to your points.
I said that both have the same complexity, so complexity analysis cannot tell which of the two is the better algorithm. That doesn't mean that complexity analysis is useless per se, it just means that it's not the right tool to judge this situation.
&gt; Good, you realized that in sorting algorithms, complexity analysis is useless. &gt; &gt; Now realize that unless you're doing something very specific, such as creating new algorithms, for example, something like new way of rendering objects or new way to perform calculations in physics systems, you will never sit down and try to prove complexity of an algorithm, it will just be an insignificant indication of how well an algorithm scales, a 5th grader could tell that O(n) is better than O( n2 ), I don't see what I should see from your "point". Whenever you write a loop iterating over something, you create an algorithm with a non-constant complexity. Whenever these loops are nested, the complexity goes up. It's very common to see programmers accidentally writing O(n^2) code in their business logic which flies under the radar until the application is run on a million records and nothing works. It speaks a lot about your experience that you have apparently never written a loop in your entire career. &gt; Oh and, when you do sit down and do that, it's not like you'll have to do it ever again, because you know, it "hardly ever matters", because amount of time spent thinking about it is insignificant as things like big O actually are insignificant and there's more important variables in development, if you know anything at all about an algorithm you're about to use, big O will be useless because you actually know what's inside a tin can, not what's fucking written on it. So if complexity is pointless, tell me about all these high-quality O(n^2) sorting algorithms. Surely there must be any if it doesn't matter what their complexity is. Yes, I do get your point that performance considerations do not end at complexity analysis. However, complexity analysis is a vital step in algorithm design and a programmer who is oblivious about it should not be hired. However, a programmer whose only knowledge of performance analysis is from the angle of complexity theory should not be hired either. That I can agree with too.
There's also some sample C code in the RFC that defines the UUID format.
This seems to compute a checksum by xoring all 16-bit words of `public_key` together. Very poor checksum algorithm.
Use the libuuid or read the [RFC](https://tools.ietf.org/html/rfc4122) and implement it yourself. 
Why is the array index like this? checksum[i % 2]
I found the best answer on StackOverFlow long time ago. [Here it is](https://stackoverflow.com/a/5580952/3987167)
thanks kind stranger
thanks!
Yes, dlsym for dlopen(NULL) gives you back the handles to your program‘s process‘s symbols. It‘s useful for some kind of runtime reflection.
For doing things the way that you want (which doesn't make much sense to me), you'll probably have to allocate dynamic memory with malloc.
&gt; Very poor checksum algorithm. Can't stress this enough. If you thought the 16-bit IP checksum was bad... this is an order of magnitude worse.
You also need to initialize the contents of your point manager somewhere. Where you have `//wtf goes here?` You probably want to malloc() a point structure and add the pointer to PM-&gt;pool.
 typedef struct { int index; Point *pool[255]; } PointManager; No. Pointers are used when needed. You would generally never need an array of 200+ pointers. Especially not declared on the stack. For every point a point manager need to keep around, a memory allocation would be made for that point and an array of pointers reallocated. Or a memory added to a linked list.
But really I'm not sure what you gain by using `Point* pool[255]` instead of `Point pool[256]`. It might make sense if the caller is responsible for allocating memory. In `PM_addPoint`, you can probably just do `PM-&gt;pool[PM-&gt;index++] = dude` (although you'll have to check bounds first). Also your PM_movePoint function is wrong in many ways (not just indentation). Nothing actually gets mutated inside the PM structure, and the `&amp;temp != &amp;dude` check doesn't make sense -- they can never be equal (why?) Finally I'm not sure why you sometimes use `(*PM).index` -- use `PM-&gt;index` instead.
I've worked with embedded memory managers, and you seem to be on the right track. I wouldn't leave a bunch of "255"s floating around, instead, if you want this to be static do #define MAXPOOL 255 Then when adding the point: If (index &lt; MAXPOOL) { PM-&gt;pool[index] = dude; PM-&gt;index++; } else { assert(0); } Asserting isn't pretty, but, unless you can think of some way to recover from running out of space, that is probably where you have to just give up the ghost. You can always come back and make things dynamic later, or just bump up MAXPOOL.
Python and Java are controlled by corporations: the Python Software Foundation and Oracle. These organizations are responsible for the language, its direction, its documentation, and the reference implementation that almost everybody uses. That means that the documentation is pretty well centralized. C is different, because its history is much more complex. In the end, it's controlled by the International Standards Organization (ISO). They produce a document that describes the language. You can [buy it for about $200](https://www.iso.org/standard/74528.html). This is the official documentation. Of course, few people actually buy that. [The draft version](http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf) is freely available. `fread` is documented on page 243. A random PDF isn't very convenient, so it's understandable why most people would rather use some other form of documentation. Also, the standard that defines a language isn't written to be understandable by normal human beings, so a bit of interpretation and clarification is sometimes in order. These aren't officially produced documentation, so the quality varies, as you've seen. [https://en.cppreference.com/w/c](cppreference.com) is one of my favorite sites for documentation. If you noticed, it mainly deals with C++, but it's C documentation is just as good. It's kept very up-to-date, with clear examples, notes on which versions have what functions, etc. You can download it for offline use, it's a wiki so you can edit it. This is the best non-official resource I'm aware of. A more traditional resource are the man pages. C and Unix grew up together. The original C documentation, before the internet or even the standard itself existed, consisted of the output produced by the `man` command in Unix. This documentation has been kept current as the language evolved, so it's pretty good. It's also very convenient if you're at a Linux terminal: just type in `man fread` and you're done. In vi you just use `K` with the cursor over the function! If you're on a Windows machine you can usually just google "man fread" and [the first link](http://man7.org/linux/man-pages/man3/fread.3.html) is the man page that someone's published online. If you ever see documentation that names functions like `fread(3)`, that's specifically referring to the man page (section 3 has the library functions). The third site you posted is also a very good resource: it has the documentation for the POSIX standard (IEEE instead of ISO, but same idea). These are additional capabilities beyond the C standard library, but it's not uncommon to target POSIX compatibility as well. These functions are also in the man pages! The caveat is that if you *don't* want the POSIX additions then you need to pay close attention to the documentation (see the highlighted note: in this case, there are no differences). cppreference doesn't include POSIX, for better or for worse. And the we come to Tutorials Point. As you can see, there are omissions in that documentation ... so it's best to use one of the better resources instead.
Thanks!
Thank you so much. This helped my understanding of the C universo a lot. 
Don't worry. Happens to all of us :)
Also -- why "255"? When I see numbers like this, I tend to like an explanation of where the value came from. &amp;#x200B; /* Maxpool size is 255 which allows me to use a character for keeping track of clean/dirty buffers. */ #define MAXPOOL 255; &amp;#x200B; Otherwise, you get a bunch of random "magic numbers" that actually are cargo-cult related figures with no merit. "I picked 1024 because it's a power of two! Why does power of 2 matter? Don't know... but binary!" &amp;#x200B;
My "go to" resource for years is P. J. Plauger's *[The C Standard Library](https://www.amazon.com/Standard-C-Library-P-J-Plauger/dp/0131315099)*. Not only does it quote the relevant standard, but goes into the history of *why* the standard functions are the way they are, plus gives a sample implementation of each function. It only covers the functions in C89 but I still refer to it from time to time.
 Readable. And constructable. Now take your C++ functions and make an Application Programming Interaface around your engine.
In addition to the resources /u/boredcircuits listed, you can find draft versions of the C89, C99, and C11 standards in HTML format at http://port70.net/~nsz/c/.
Find a well respected source with a switch statement. Change that statement to horde of if / else if / else if......
scanf is expecting an integer and so if the next value is a character then it reads nothing (leaving the character there) and carries on. Next time around it tries again, reads nothing and carries on, thus the infinite loop. You can test for this. Scanf returns then number of characters it read. If that's zero then you didn't successfully read anything and you should do some kind of exception handling.
&gt; In vi you just use K with the cursor over the function! Holy crap, I never knew it could do that. Thanks a lot!
&gt;`object* newitem = malloc(sizeof(object));` You can also write `object *newitem = malloc(sizeof *newitem);`. It's a matter of taste, but slightly more defensive programming. Also, check the return of malloc for an error. &gt;`char* treasure = calloc(SIZE, sizeof(char));` `sizeof(char)` is pointless, because it will always be 1 (by definition of char). Although it's the default in C++, typedef'ing your structs is often considered bad style in C, although this is also a matter of taste and many people do it. Stylistic comment: Instead of `printf("hello\n");` you could also use `puts("hello");`. &gt;`char* treasure = calloc(SIZE, sizeof(char));` Why do you use calloc here (in info)? You are trying to reserve a fixed-length string of size SIZE that will be written later, if I got it right. Why don't you just declare it like you did with buffer? You wouldn't need the free calls at the end. I haven't looked at the logic of the code in detail.
&gt; Scanf returns then number of characters it read. `scanf` returns the number of arguments it successfully assigned to. In this case, OP would expect a return of 1 for success and 0 for failure.
You're the third person I've taught that in the last month!
\+1 on man for the longest time i didn't even know what man was. So if i needed the definition from the C standard library, i'd have no choice but to endure the arduous task of opening up a browser and typing in "some macro definition" far more work than typing "man something.h" in the terminal. 
Infix to postfix is also the secret to life.
Sounds like a fun read. Will check it out. 
A really nice style!
I looked at autotools, CMake and meson. Autotools and CMake did not look simple at all! The clear winner for the first round was meson, it was up and running in no time building for the host architecture only. So I was able to throw away the old makefile which I admittedly did not really understand and which was cobbled together copy-paste-try style. I will report back by the time I also managed to do the cross compiling part.
Thank you very much kind internet-comrade 
`crypto_box_PUBLICKEYBYTES / 2` because it is going to do it 2 bytes at a time? `((unsigned short *)public_key)[i];`casts public key to a pointer to unsigned short and then you increment it with [i]? At first I thought you had done it like this `((unsigned short *)public_key[i]);` which wouldn't work right and would have done what? I tested your code like this and it works: for (size_t i = 0; i &lt; crypto_box_PUBLICKEYBYTES; i ++) { checksum[i % 2] ^= public_key[i]; //fwrite(checksum, sizeof(checksum[0]), 1, stdout); //fwrite(checksum + 1, sizeof(checksum[0]), 1, stdout); } fwrite(checksum, sizeof(checksum[0]), 1, stdout); fwrite(checksum + 1, sizeof(checksum[0]), 1, stdout); fwrite(&amp;checksum[0], sizeof(checksum[0]), 1, stdout); fwrite(&amp;checksum[1], sizeof(checksum[0]), 1, stdout); unsigned short checksum2 = 0; for (size_t i = 0; i &lt; crypto_box_PUBLICKEYBYTES / 2; i++) { checksum2 ^= ((unsigned short *)public_key)[i]; } fwrite(&amp;checksum2, sizeof(checksum2), 1, stdout); ./test | xxd -g 1 
Thanks a lot!
Great, it worked when I added a symlink! I then removed the symlink and tried `dnf provides libcheck.so`, no matches were found. But when I listed the files associated with check-devel, it did indeed provide the libcheck.so symlink.
You need to provide a wildcard or the full qualified path for dnf (at least back when yum was a thing) Try dnf provides */libcheck.so next time 
Thank you very much, Regarding the const declarations, the way that I've managed to understand const is that I should/can declare something that I do not intend on changing to a const? Hash function, so I read up on your previous comment and took a look at Xorshift (also took a peek at your nifty blog, will do some reading tomorrow morning). What I've managed to pick up is that when I am hashing something the hash should always be declared as an unsigned integer (perhaps 32 bit). But also that I shouldn't be using pow() to hash due to return value being a double(?). Neither modulo should be used due to it being rather slow. Instead I assume it's time to study up on something like the MurmurHash? But would you mind dumbing down the bit where you comment on the hash function? Since English isn't my native language and I'm a novice coder some of that probably just goes over my head.
Agree, and don´t forget mostly all embedded devices without an OS, I think in trillions
Please format your code correctly.
I think that you are on the right path with your proposal
This would be hard to characterize. You'd have to define what you mean by "run C." Java uses a Java virtual machine (JVM) that runs Java code that has been compiled to Java byte-codes. C code is (usually) compiled to executables or libraries that run without a C virtual machine. On many platforms like Linux there are runtime libraries that your C executable programs and libraries can call. Those things _support_ C but they aren't virtual machines the way Java does it; they don't "run" your C program. Your compiled program calls out to use them. Some of the code I write in C does not run on an operating system, and doesn't have anything at all that you would call a "runtime." There's no libc that provides standard facilities like printf(). Some of these chips have as few as 32 bytes of RAM. In some cases I'm larger programs that use operating systems, like FreeRTOS. However, what we mean by "operating system" is considerably reduced and simplified in these cases. FreeRTOS is code you build into your application and provides low-level services like creating and switching tasks, managing timers, and queues for inter-task communication. So a better question might be "how many devices run code (libraries, programs, operating systems) that was written in C (before it was compiled)," and the answer is probably "almost anything with any kind of modern microprocessor in it." 
Well, every Android device runs a Linux kernel, and the Linux kernel is written in C. So, *at least* all Android devices run C. In reality I'd say something like 99% of anything resembling a computer run C. Including those 3 billion devices that run Java.
Well, Java runs in very unexpected placed. You may know that it's installed on many computers, but did you know that basically every SIM card and smart card (bank card, credit card, etc) runs Java? Yep, that's fucking weird but true. If you look at chips in general tho, the number that run Java is insigificant. And generally, most microchips are programmed in C. That is because it's easy to get a working C compilers (most vendors use GCC and write a backend for it). C++ is not that popular with embedded devices for various reasons. To put things in perspective, this article mentions that the number of microprocessors used in computers is insignificant compared to embedded devices: &gt; About zero percent of the world's microprocessors are used in computers. Yup. Every PC, Macintosh, engineering workstation, Cray supercomputer, and all the other general-purpose computers put together account for less than 1% of all the microprocessors sold every year. If you round off the fractions, embedded systems consume 100% of the worldwide production of microprocessors. [Source](https://www.eetimes.com/author.asp?section_id=36&amp;doc_id=1287712) Wikipedia tells us that *about 10 billion CPUs were manufactured in 2008*. That was 10 years ago. If we add the production up and estimate a 10% growth per year, we could say that at least 175 billion microchips have been produced since 2008. If we guess that there are an average of 25 microchips in every device, then we could guesstimate that about 7 billion devices run C. 
All of them. I say that with little exaggeration. You'd be hard-pressed to find a device with any sort of processor in it that *doesn't* have a C compiler available. So just count the total number of devices and that's a good enough estimate.
Create your own database and then implement a database manager for it. Cant get any more fun.
Thanks for you help.
About the file: &amp;#x200B; \- When adding an entry, it's easy since I have to add a new line \- What about reading data? Since I can't query it, should I loop over the file and decrypt everything in memory? \- Thus how to do I handle password updates?
You're welcome. Just remember to keep it simple, or C will bite your head off :) I'd also suggest running the code through Valgrind regularly. C programs frequently appear to work perfectly fine even though they contain all sorts of ticking bombs that will blow up in your face when you least expect it. Mine still do, and I've been coding in C for over 20 years.
I assume data will be stored encrypted, so even SQLite wouldn't be able to query it. The easiest way would be to decrypt all of it on startup and search in memory instead. For updates, the easiest option is to backup the existing file and overwrite the whole thing when storing changes. A slightly more sophisticated alternative would be to append modified structs to the end of the file and use the last version when loading, you may then add a maintenance routine to overwrite the file from the final data in memory to get rid of duplicates.
Made a huge EDIT.
If someone wants a rule, I've always found this one to be accurate and easy. [left-right rule](http://jdurrett.ba.ttu.edu/3345/handouts/RL-rule.html)
That can even be simplied further: `[]` and `()` (function parameter list) can only be to the right, and `*` can only be to the left. So you can start at the identifier and work like this: * `.....x[...].....` means `x` is an array of `T` * `....x(...).....` means `x` is a function returning `T` * `....*x......` means `x` is a pointer to `T` where you check those things in order, i.e. `....*x[]....` triggers the first bullet point, not the third. And to work out `T`, replace the unit you just identified with a new identifier, `T` is the type of that identifier. 
Just use cdecl if you're not clear on a type.
Since C doesn't "run", I'd guess 0.
or `EOF`
You are already using two libraries. Why not use a third party compression library with encryption. Can't SQlite be built with support for encrypted databases. 
how does that work? 
It's a [program](https://linux.die.net/man/1/cdecl) that parses C type declarations and describes them in English. There's also a [web interface](https://cdecl.org/) if you don't want to install it locally.
Yeah, they all run some sort of assembly. 
No worries!
Never use asserts for flow control or some day you will shoot yourself in the foot with -DNDEBUG. 
I don't see the problem. Use the URL + account name as keys and only encrypt the password. This is a school project, not a commercial product. If you really want to encrypt everything, you can write a [SQLite VFS](https://www.sqlite.org/vfs.html) that does the encryption between SQLite and the filesystem. I would recomment AES-XTS, or if you're just aiming for “good enough for a school project”, AES-CBC with a sector key derived from a combination of the master key and the sector number. And remember not to use the password as encryption key; instead, generate a random master key and store a copy, encrypted with the user's password (preferably passed through a KDF) in the file header. 
https://pastebin.com/La4gvTBd Maybe this helps
 for(i=0;i&lt;5;i++){ printf("%d", numberarray[i]); if(i==4){ printf("."); } else { printf(", "); } } This is basically how I always do it.
Well, another way of looking at it: perhaps consider printing the comma before printing the number on every element except the first. And print the period outside of the loop.
Thanks, very helpful.
I'm just learning C for the moment but will bear this in mind when I progress onto Java. Thank you
What happens when you compile that? Or run it?
Bus error: 10 I change it ever so slightly and Segmentation Error:11
When you're reading or printing? What change did you make? You're being way too vague.
You have an array of pointers. You're reading a string into each of the buffers the pointers are pointing at. Where are they pointing it? The array is irrelevent ... simplified, you're doing char *name; scanf("%s",name);
This is the proper way to do it IMO :) 
Now that I read your comment, I realize that that is definitely what I should have done. I think I got it in my head that using a separate object would help to share code between printf and snprintf, but now I'm realize that I can just pass some kind of output function which would decide whether to print to the screen or snprintf.
Happy cakeday btw.
Try `_getch()` on Windows.
Why don't you implement a rudimentary `FILE` structure and simply implement `vfprintf`? This way, the code is the same for both functions. The difference between a `FILE` for actual IO and for `sprintf` is that the latter has the buffer to print to as its internal buffer with length set to `-1` (or the length of the buffer in case of `snprintf`). In addition, a flag is set such that all attempts to flush the buffer are silently ignored.
Your understanding is correct. But note that `[i]` is an *index,* not an *increment.* &gt; At first I thought you had done it like this `((unsigned short *)public_key[i]);` which wouldn't work right and would have done what? This would have been like (unsigned short *)(public_key[i]) due to operator precendence. Clearly, that's not what we want. &gt; I tested your code like this and it works: Yeah it does and it's interestingly not even undefined behaviour (due to `char` being exempt from the strict aliasing rule), but it's still not code I'd recommend you to write.
I am not wrong. Not sure why I was downvoted. https://www.geeksforgeeks.org/double-pointer-pointer-pointer-c/amp/
[https://docs.microsoft.com/en-us/windows/console/readconsoleinput](https://docs.microsoft.com/en-us/windows/console/readconsoleinput)
Thanks a lot!
You are most likely about to get into multiple dimensional arrays and this is a soft intro. As in you can have an array of arrays. And keep track of them in memory as you go. 
That code is more-or-less a reimplementation of [`void *realloc( void *ptr, size_t new_size );`](https://en.cppreference.com/w/c/memory/realloc). So, you're right, it doesn't have to be a pointer to pointer, it's just a design decision.
memmove(,,ncopy) looks suspicious, number of integers in list, or length in bytes?
Oh, I'm a belt-and-suspenders kinda guy, so I would never say never, but throwing in a warning message so we know things have gone sideways even when asserts are off is a good idea though. Ideally, this assert should be unreachable because of good design decisions made elsewhere.
Another way could be to prepend the separator to each but first value, like for (int i = 0; i &lt; 5; ++i) printf("%s%d", i ? ", " : "", i); but it's a bit cluttery
Many small micros do not have a C compiler available with a floating-point type that can handle all whole numbers in the range +/- 9.999999999E9 as required by every version of the C Standard. There are also many small micros that cannot effectively process recursive stack frames. Personally, I think the Standard should have classified support for such features as optional in freestanding implementations. Quality implementations for CPUs that can efficiently cope with them would include such features anyway, of course, but the Standard makes no distinction between limited implementations of C (where constructs that are supported work in standard fashion) and weird "C-ish" dialects that define types like "int" as 8 bits and "short" as one(!) bit. 
My preference is to have a "general printf" function which either accepts an output-function pointer and a `void*`, or else a double-indirect pointer to an output function (which it will pass, without indirection, to the output function which can then interpret as a pointer to a structure whose first member is a function pointer). Such a function will be usable for any kind of output, even on systems which define a `FILE` type that isn't suitable for such purposes.
&gt; typedef'ing your structs is often considered bad style in C If by "often" you mean "by one opinionated person who happens to have written a highly successful kernel". I would say that *most* other code prefers typedefs. Most GNU software, much of newer POSIX, all of Windows... in my experience, code that doesn't use typedefs is in the minority. Plus, I've used embedded compilers where the debugger doesn't have a way to cast to a struct when you add a watch expression. (`(struct foo*)0x1234` was an error, but `(foo*)0x1234` worked.) So frankly, even if you prefer to write `struct foo`, I think for the benefit of others you should `typedef struct foo {} foo;` anyway.
Good point. "A C compiler" doesn't necessarily mean a standards-conforming C compiler.
I don't like your naming of thing. An "object" is an "item", but an "inventory" is a "storage", the result of a "hash" is an "index"... this is madness. Rename your types to `object_t` (or better yet, `Object` or `objectT`, since names with `_t` are reserved and shouldn't be taken by ordinary libraries and programs) so that you can declare `Object* object` and `Inventory* inventory`. I don't like the way you're using `SIZE`. If you want the array to be a fixed length, that's fine. But if you *know* it's fixed length, then be consistent and propagate that knowledge all the way down. If it's fixed length, then `object_hash()` shouldn't need a `size` parameter; it should just use `SIZE` in its implementation. I *absolutely* do not understand or like `ref`. What is this global variable? Why is it global? At best it ought to be a member of `inventory`, if it's needed. I'd like to think it's not needed at all, but I still don't understand what it's doing. It seems like it's a half-assed way to avoid hash collisions by modifying the has function in order to change the distribution of elements, but then how do you know how to find an element...? It doesn't make sense to me, it seems like a nonstandard and inferior way to deal with collisions in your hash table, and I *really* don't like how this global variable infects everything with state whose purpose and effects I don't understand.
&gt; Hash functions by definition map more than one output to the same input, by the pigeonhole principle. For an entire digest, yes. But, outside of compression, individual mixing/diffusion operations [should be reversible](http://papa.bretmulvey.com/post/124027987928/hash-functions) because it makes them more effective. &gt; Depending on the choice of hash function, sometimes a size that's a &gt; prime number works better. I disagree. The output from good hash functions won't have any particular properties that distinguishes one from another (e.g. each output bit is uniform and independent). So any particular choice of bucket count wouldn't do better with any particular hash. In addition to eliminating a division instruction, a power-of-two bucket count plays more nicely with memory allocation (less fragmentation). &gt; Alternately, don't write microoptimizations like using &amp; in place of % &gt; when the intention is modulus. The compiler is smart enough to make &gt; that optimization for you. That's true *when the compiler knows the divisor* (e.g. it's a constant), but that's not the case here. Consider this: uint32_t find_bucket(const void *key, size_t keylen, uint32_t nbuckets) { uint32_t result = hash(key, keylen); return result % nbuckets; } You may intentionally stick to powers of two for `nbuckets`, but it's unlikely the compiler will realize (and can prove) this, so it won't optimize `%` to `&amp;`. So this is a case where you have to do it yourself: /* Note: nbuckets must be a power of 2! */ uint32_t find_bucker(const void *key, size_t keylen, uint32_t nbuckets) { uint32_t result = hash(key, keylen); return result &amp; (nbuckets - 1); } 
&gt; I like your use of the `DELETED` special value. I don't. It seems like a way to indicate "there used to be something here, but now there isn't". What use is that information? Just set the pointer back to null. The use of `DELETED` is just a quirky, nonstandard alternative to `NULL`. It's poor form and serves no purpose except to confuse people and lead to future bugs. (I don't even like the way `DELETED` is declared... it uses `0` to null one pointer and `NULL` to null the other one.)
better use char\[256\] for each
Linked list of struct Points wasn't mentioned yet, I think. If memory is really tight,you could use global arrays and 8-bit indices as links.
That's a poor use of a double-pointer. Since they're returning `lnew` also providing it to the caller by changing `*list` is redundant. 
I like how you encapsulate the parameters state into a single object and then fetch a character at a time from that state. If you do the same for the your parent function 'vprintf', so you get a character at a time for the entire vprintf state. You'll be able to share more code between a printf and snprintf like function. Is there any reason you drop the 'const' qualifier on char *cur = (char *)fmt;
This was certainly the *intent*, though I don't know I'd go so far as to say it was the *rationale*. But the mincing of words aside, the first edition (1978) of *The C Programming Language* (8.4 in the reference section, page 194) does indeed support your view: &gt;Each declarator is taken to be an assertion that when a construction of the same form as the declarator appears in an expression, it yields an object of the indicated type and storage class. &amp;#x200B;
Yeah, I was avoiding that thinking it might make this more complicated, but I really just made everything harder by avoiding it. I think that's how my next draft will work.
You need an extra character for the nul terminator. E.g. with the string bob strlen will return 3. But it needs 4 bytes of storage.
(a) no need to cast the result of `calloc()` (b) it doesn't look like you're allocating enough memory to accommodate the terminator. (c) if you are using C99 or later, you should be able to use a variable length arrary to allocate your output file name. (d) of course you want to ensure that bothe argv[1] and argv[2] exist. either way, maybe an alternative way to allocate it could be: char extension = ".out", outputfileName[strlen(argv[2]) + strlen(extension)+1]; 
 while(L != NULL || L-&gt;next != NULL) If L *is* NULL, what does this line do?
So change the 4 to a 5 to account for that? I wasn't experiencing any problems without it, why is that?
&gt; why is that? Writing over memory you don't own can do anything. The program can crash immediately. Or it can crash later. Or, worst case, it looks like you're not experiencing any problems.
it would skip the while loop and return to main
&gt; a) no need to cast the result of calloc() Ah ok, assumed that was how you did by going off of examples from my book. Just looked up this [stackoverflow answer explaining it.](https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc/605858#605858) &gt; (b) it doesn't look like you're allocating enough memory to accommodate the terminator. Noted, will increase it by one. &gt; (c) if you are using C99 or later, you should be able to use a variable length arrary to allocate your output file name. Unfortunately can't for assignment so have to deal with those nuisances. :( &gt; (d) of course you want to ensure that bothe argv[1] and argv[2] exist. I have everything checked, just wanted to show just the code in question. For your alternative way, what benefits would it have besides less lines? Wouldn't it be creating an unnecessary pointer? Sorry if bad questions, still trying to grasp memory concepts. 
I like this approach, I forgot about sprintf. Just a follow up, is it bad practice to put define ".out" in header if I'm only using it once?
That makes sense, I think I can visualize that in memory. Would '\0' just be at the address directly after end of outputfileName location? 
Yes. So strcat writes to 1 byte past the end of the buffer given to you by malloc (`t` goes in the last byte).
Uh... so I wouldn't worry much about pointers, allocation, etc. C compilers are *really* smart and the optimizer is probably better than you are. The choice to use a macro vs. an actual C symbol is up to you. For some reason, I tend to avoid macros unless I really need them. I consider the preprocessor separate from the C language itself and I try to avoid it unless I really really need it. I like sprintf() because it makes it clear what I'm doing. I can look at the format string and parameters and easily know what's going on. I find it easier to decipher than the combination of strcat() and strcpy() you used. But yours is almost certainly faster? It doesn't matter in the end I think.
Yeah, I kinda realize that I shouldn't care about a minor thing like that too much especially for such a small program. I'll try out the sprintf function as I don't think I've ever used it. Just have to do a little workaround because no variable length array in C90! *sad* Thanks for answers, have a good one 
You pass the same va_list to printf_parser_compile() each time. Why is that? How will it know which argument is the current one?
What compiler are you using? Your compiler may not require you to explicitly link some libraries. Does the produced executable actually run without error?
It's a little unclear what you're asking. At a basic level, a library generally consists of two separate parts - headers (.h), and binaries (.so, .dll, .a, .lib). The `#include` directive adds the header file to your program, and the `-l` argument to your compiler links the binary to your program. You can generally `#include` a header file to your program without any significant effect, but you're not really *using* the library until you call its functions (and link against it with `-l`).
this is just my personal style, but you don't have to malloc everything, y'know? you could do something more like ``` queue q; memset(&amp;q, 0, sizeof(q)); bstatement stmt; stmt.blah = 123; enqueue(&amp;q, &amp;stmt); ``` this saves you some memory management and you don't have to deal with a double pointer everywhere in your code which leads to ugly bracketing. as long as the structs aren't massive it's fine to keep them on the stack malloc'ing every node of the queue is kinda slow but if you want a general purpose queue that's fine. for cases where the queue gets completely consumed often enough I would make a memory arena, a custom allocator that pre-allocs big chunks of contiguous memory and packs the queue node structs in there and allocs a new block only once the current one is full. then when the queue is empty you free all the big blocks at once and reset the memory arena. or keep it allocated and reuse the memory, it's up to you
Since you can't change the value of that pointer without a double pointer, wouldn't you have to give enqueue a return value? So you're passing a pointer by value there but to change it you need to pass it by pointer?
Hey I’m also learning C and just wondering, won’t this only detect duplicate values that are adjacent to one another? Any ideas on how you’d detect any duplicate value that isn’t necessarily adjacent to its duplicate
Hey, so I tried this one but no luck. It keeps saying "found jack" even if there is no jack
I am in the same boat, Prof. White is quite fun hehe. I have printing the board done with blank cells. This too karound 450 lines of code (yuck) and I still don't have logic to print a board with solutions but, to help you I'll try to answer your questions. &amp;#x200B; 1: At its basic level we are printing row by row of numbers along with column by column of data. As stated in class this can be done in many ways, one of which is a brute force approach where your print each "row" for each row. A row consists of 3 lines so you can break each row down by this. In addition the martix is square so you should be able to count using a loop to know when you are done printing a row. &amp;#x200B; 2: Add logic to print the board with its empty cells not filled in and when they are filled in. &amp;#x200B; 3: Mips has a syscall for reading in a number, do this first before you enter your main loop to read data in. &amp;#x200B; Hope this helps ! I am quite lost on how to exactly program my solver atm. Been thinking of it and though the DFS does sound doable I have not been able to do it on paper :/
It seems that you're trying to store strings into an array. As pointed out by others, I'm sure you know already what the problem is with your code by now. But here's a rather easier way to do what you wanted - #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int i = 0; char *array[5]; for (i = 0; i &lt; 5; i++) { *(array+i) =(char*) malloc(10 * sizeof(int)); // Dynamically allocating each shell of the array gets_s(array[i], 10); //gets_s can be replaced by scanf("%9s", array[i]) } for (i = 0; i &lt; 5; i++) { printf("%s ", *(array+i)); } return 0; } Note: *(array+i) and array[i] are the same things.
Oh yes I totally forgot about to take that into account, thanks!
You have a memory leak in `resetString`, since `outputStr` replaces `str` but `str` is never freed. I'd hazard a guess your issues are related to the fact you never zero out your string buffers. They'll contain garbage data that might muck up your character comparisons. Use `calloc` or manually zero out the buffers and see if that helps. FYI, your code is pretty gross overall. There's an easier way to do this that doesn't involve constantly reallocating buffers. See if you can rethink your algorithm to work more "inplace" (hint: use pointers that index the original string instead of creating copies).
There is no C standard naming convention. Most libraries I use seem to prefer camelCase or even PascalCase. Ultimately it doesn't really matter as long as you're consistent with whatever you choose to do.
Use whatever convention you prefer. My preferred convention is lower case without underscores for short identifiers and cam case for long ones.
Thanks, I will go with camelCase.
Thanks, I will go with camelCase. 
Sorry, I wrote something incorrect in my comment. I don't use camel case, I prefer snake case.
Look into getting the SMART values from the drives. You can probably check out the source code for smartctl for ideas. 
You should be able to find that info in sysfs. See the available nodes in the `/sys/class/block/*/device/` directories.
`lsblk` lists blovk devices and partitions therein
Thank you, that made me chuckle this morning. Reminded me of this (How to draw an owl)[https://imgur.com/gallery/RadSf]
On Windows the convention seems to be more camelCase or PascalCase, on *nix (within Kernels and APIs) it's more often snake\_case or just lowercase for short identifiers. I prefer the latter, but that's my personal choice. I tend to be prejudiced about code in one of the former styles, since most bad code I've seen used that style.
&gt;This is exactly qhat I was looking for and answers my question perfectly. Thank you!
Note that you might be better off using libblkid (part of the util-linux project) rather than parsing those files directly. This is the underlying library used by the `lsblk` utility mentioned by /u/EkriirkE. 
&gt; 0377 In C, integers with a leading zero, like this one, are interpreted as [octal](https://en.wikipedia.org/wiki/Octal) (base 8) values, not decimal (base 10). 377 in base 8 is 255 in base 10.
Unsigned char have only 8 bits, with max numeric value being 255. So value of c is actually 255. do while loop prints two numbers to console - 255 and 0 (after incrementing value of 255 by 1 - it's overflowing max value avaialable to char type). &amp;#x200B;
Contrary to what some others have said, `lower_case_with_underscores()` seems like the dominant C naming scheme to me, by a significant (if not huge) margin. Mixed case seems like more of a C++ thing, though I'd guess they're very roughly equally common and neither is weird. As a quick extremely unscientific test based on whatever shared libraries I happen to have installed at the moment: $ nm -D /usr/lib/*.so | grep '[a-z][A-Z]' | grep -v ' _Z' | wc -l 95510 $ nm -D /usr/lib/*.so | grep '[a-z]_[a-z]' | grep -v ' _Z' | wc -l 368598 There is certainly some platform bias here, though. Windows people tend to use camel case, following the system APIs. Personally, for what it's worth, I use `lower_case_with_underscores` for identifiers, and `CamelCase` for types, which keeps their namespaces separate (without stepping on POSIX's toes with `_t`). I find this most readable, and capitalized types is a pretty common convention for this in various other programming languages.
Rad, thanks for making this clear.
Even thought the effect is the same, many developers prefer to explicitly call `exit()`, and some style guides mandate it.
Indeed. This can be solved in a few lines of code with three or four variables (in addition to the string itself) and no library calls beyond `printf()`.
The main rule is follow whatever convention is already in place. Let's look at some style guides: * [Linux kernel coding style](https://www.kernel.org/doc/html/v4.10/process/coding-style.html): Explicitly chooses snake_case. &gt; mixed-case names are frowned upon * [FreeBSD style(9)](https://www.freebsd.org/cgi/man.cgi?query=style&amp;sektion=9) Explicitly chooses snake_case. &gt; The use of internal_underscores in identifiers is preferred over &gt; camelCase or TitleCase. * [OpenBSD style(9)](https://man.openbsd.org/style) and [NetBSD /usr/share/misc/style](http://cvsweb.netbsd.org/bsdweb.cgi/src/share/misc/style?rev=HEAD&amp;content-type=text/x-cvsweb-markup) Implicitly chooses snake_case. * [Windows Coding Conventions](https://docs.microsoft.com/en-us/windows/desktop/learnwin32/windows-coding-conventions) Implicitly camelCase. Major libraries go both ways. For example, OpenGL is camelCase while SQLite is snake_case. 
I see no `exit()` calls in the code above, so clearly OP does not prefer that. If a style guide mandates `exit()` only for errors in `main()` it is not a good guide.
From a different resource but the same way of explaining it was how it clicked with me. And the kicker that I was full able to grok pointers is all of this is used as a contiguous block of memory with pointers as offsets to the the various blocks of memory (char, word, sentence, etc...)
I like snake_case . camelCase is quicker to type but looks uglier IMO
it's really just style. the resize reallocates the array so you need to modify the list pointer itself. you can either do it through a double pointer: ``` resize(&amp;list, list_size, list_size + 10); ``` or by reassigning it explicitly ``` list = resize(list, list_size, list_size + 10); ``` I much prefer the first way especially because the old list pointer is invalidated and it's error prone to potentially leave a dangling pointer btw this is a slow poor man's implementation of ```realloc```. you don't even need calloc's zeroing here. you would normally call ```realloc``` on list and it would return a pointer to the resized memory with the previous data copied over
What is the reasoning? I can see it can cause undefined behavior that compiler can't catch (ex. negative number). Do most people use size_t instead? I really haven't learned much about those types of data types.
`size_t` is just an integer type, how would it replace VLAs?
Hey thanks for suggestion. I looked into sprintf and seems like a lot of people have strong opinions on it. I think my solution is effective but might just not be as clear to read as sprintf. outFilename = calloc(strlen(argv[2] + 5, sizeof(char)); outFilename = strcat(strcpy(outFilename, argv[2]), ".out"); Essentially just fixed the error because I didn't account for '\0' in ".out" when allocating memory.
You just did the hell out of this guy's homework for him :)
Windows people also use Hungarian notation...
I prefer a full ide that shows errors, both build and segfaults -- anything gdb or the sanitizer options could catch, in the editor and also allows stepping through the program from the editor. I need that visual context and less tool switching. I've heard it can be done with emacs, but I use Xcode and it's pretty great. People also tell me Atom and VSCode can do a lot of the same Other than that I can't offer tips on workflow because the capabilities of the tools define what's possible for my workflow. 
I'm not sure I understand exactly what is the problem for you. Could you explain a bit more what you'd like to change?
I'd say it's running into problems that I should've known about way earlier in development. Maybe the solution could be as simple as "use Valgrind way more frequently". I'm also curious if anyone somehow runs their debugging tools (ex. gdb and valgrind) during every single time they compile and run their project, in order to catch bugs &amp; errors early on.
`size_t` is an unsigned integer type of sufficient range to represent the size of any object you can create. It is generally equivalent to `unsigned long`, but you shouldn't assume that it is. It is used anywhere you need express a size, e.g. `malloc()`, `memset()`, `fread()`. You can use a `size_t` when defining a VLA, but it is no different than using any other integer expression. 
Workflow is of course very much dependent on you. Here's what I use: * vim as an editor, because it's more minimalist, it feels more modern to me and I like the keybindings (It's very rare for me to see people that still use emacs?) * tmux so I can split my terminal screen to have vim on one side and do other stuff on the other side. (tmux is really popular from what I can tell. Before we used to use `screen`, but tmux is more minimal). * For unit tests, I have honestly not really found a good solution. I use a variety of libraries or self-written testing code. * For compilation, there are two options for me: hand-written Makefile if it's a really small project (with pkg-config to link libraries), or meson for bigger things. Meson is just really nice, does exactly what I want. Seems to be getting traction, too. * I used to use valgrind, but honestly I much prefer using [sanitizers](https://clang.llvm.org/docs/index.html). They have a bunch, that do all kinds of checks. You should enable all the ones you need in your tests, but they do slow the code down so you don't want to have them enabled in production. These things are so useful! * I use gdb/lldb for debugging (more lldb nowadays). But only very rarely, tbh. If you have a good testing setup, you won't need that. * Git, obviously. 
1. By definition, `sizeof(char)` is always 1. 2. There is no reason to choose `calloc()` over `malloc()` here. 3. Chaining `strcat()` and `strcpy()` the way you do is... gross. This is C, not Lisp or Javascript. And the assignment pointless; you could argue that it's also harmless, but it makes the code harder to read. 4. Just use `sprintf()`, for crying out loud. 
All of the sanitizers are pretty helpful.
A condition in C is true if the value of the expression is zero or NULL. The ++ after the variable means this is a postincrement operation which means the value of the expression is the original value of the variable, but the variable is incremented after it is evaluated. The do while construct evaluates the looping condition after the loop body is executed. So the loop body is executed twice here, once when c is 255 and once when c is zero. As part of the last loop condition check, the variable is actually incremented to 1 which is its value at the end of the program.
For just about every implementation, there are going to be some positive values of `n` such that an attempt to create an automatic object `int foo[n];` will exceed an implementation limit. The Standard imposes no requirements on what happens if an implementation limit is exceeded, nor with regard to what values of N, if any, should be expected not to exceed that limit. Consequently, the creation of any VLA object will create of affairs which, while not described as such, is equivalent to invoking Undefined Behavior (the Standard imposes no requirements upon what happens). If a program contains a construct that an implementation can't process *usefully*, it would be better to let the implementation reject the program entirely at build time even if the construct would never actually be executed, than to require that the implementation process such program unless or until it receives input that would result in that construct being executed. [note: A similar situation would apply IMHO in the case of constructs like `memberType *p = &amp;someUnion-&gt;member;` if the Standard isn't going to define any situations where implementations must process such code usefully, implementations that can't process it usefully should be allowed and encouraged to reject it]. 
&gt;which means the value of the expression is the original value of the variable 255 &gt;A condition in C is true if the value of the expression is zero or NULL. If the above two statements are true, why does anything print at all? 
For the last, you can tell valgrind to log to a file instead. Easier to deal with lots of output that way. Using gdb from within emacs is way better than using gdb standalone. You can build from in emacs too (`M-x compile`), which lets you jump to the location of warnings and errors. Learning how to use emacs' version control modes is useful; makes dealing with things like merge conflicts easy. etags is handy.
Man this just confuses the hell out of me. Ok, so it executes the loop body once no matter what which prints 255? Then it evaluates the looping condition which is 255 so it should stop there because that's not 0 but instead it increments it then executes the loop body again printing 0. Then it evaluates the looping condition which is 0 so it increments it making it 1 but since it was 0, it executes the loop boy again which should no print 1...this just makes no sense to me.
I didn't add the printhead, but I just did and this is what happens Clubs of Nine Diamonds of Nine Clubs of Ace Ace of Ace Hearts of Nine Nine of Ace Hearts of Ace Nine of Jack Spades of Ace Clubs of Ten Clubs of Jack Spades of Jack Ace of Nine Ace of Jack Diamonds of Jack Spades of Ten Hearts of Jack Diamonds of Ace Nine of Nine Hearts of Ten Diamonds of Ten Ace of Ten Spades of Nine found jack 
I don't think that is right, a 0 or NULL evaluates to false. So what is happening is that it prints the 255, increments/wraps back around to 0, then it prints the 0, and then exits once the while loop sees that the value of c is 0 which means false. 
For a lot of moving parts, one thing you are missing is tests. &amp;#x200B; "Back in the day", or without wanting to go full heavyweight test-development, one way to solve this is to use a little define magic. For example, in assume you have "this\_unit.c" and "this\_unit.h": &amp;#x200B; #include "this_unit.h" int clever_tricky(char *thing) { ... } ... #ifdef TESTING int main(int argc, char *argv[]) { int kExpectedValue = 2; if (clever_tricky("Simple String") != 2) { fprintf(stderr, "Problem with Simple String."); return 0; } } #endif There are about a thousand testing frameworks to use instead of this craptastic method I've proposed, but unit testing goes a long way towards making systems sane -- they help with regressions, and point out things you need to check much easier.
"Conditional jump or move depends on uninitialised value(s)" "Invalid write of size [insert number]" 
Sounds like you could write more tests, but I'm not sure what sort of "problems" you're running into so its a bit hard to recommend anything.
The `c++` in the `while` condition increases the variable `c` from 255 to 0 (due to overflow). However, it will return the original value, or 255. So the condition is considered true and loops again, but remember the value of `c` is actually 0. So it prints 0, then the new conditional is evaluated. `c++` increases the variable `c` from 0 to 1, but returns the original value, or 0. At this point, the loop stops.
Try "valgrind a.out 2&gt;&amp;1 | head" or "valgrind --log-fd 1 a.out | head". Won't work nicely if you have your own stdout output because the lines will interleave; maybe "--log-file" and "head" from that, e.g. write a tiny bash script (or an "alias").
For the first one you can use an static analyzer, such as cppcheck
I think you should take a small number and manually write down the result of each command.
what definition of factorial are you using? you should work around the definition n! = n*(n-1)! with 0! = 1 so, you should create a variable x = 1 (arbitrary name), and then for every number from 1 to z (the y in your loop) do x *= y
I did try this however, the output will just be the same number I input ):
Will be doing this rn! (:
When you call return function exits and returns a value. You first reach return during first iteration of for loop and then function exits and returns (wrong) value, in this case z\*(z-1). First step is moving return statement out of for loop.
Never use Visual Studio and get used to live editing and recompiling running code. I.e. you’re stepping through some newly written pointer arithmetic code and notice and error, you fix it, step to the next line, and VS recompiles on the fly and lets you keep debugging. Once you get used to that you’ll miss it like crazy!
thats right now try to write down on paper an algorithm to find the factorial remember that n! = n(n-1)!, start working for small numbers and then try to generalize an algorithm
Invalid write of size one is what I'm getting on my assignment that's passing all my tests without leaks, I don't understand what is going on with it..
You might also want to see if something like DBus or udev can give you the information you’re interested in—IIRC there are ways of querying all that stuff in a sane/-ish format and listening for changes, but long time no play with.
When I did this change I got an output of crazy negative numbers
Thank you! (:
I thought that Vulkan was really difficult as a first API!
Just solved it for me. Mostly happens when you try to access an index in an array that doesn't exist. Also make sure you're not using `sizeof` on your dynamic array. That was my fatal flaw! ``` int *array = malloc(sizeof(int) * 20); sizeof(array); // This will give you '8'. Incorrect! ``` I got around it by creating a struct like this. ``` struct { int *array; int count; } MyArray; ``` You would update the 'count' variable anytime you alter the `array` size.
You might want to try piping valgrind into "more" if you want output one terminal screenload at a time? I've barely ever used valgrind manually, but if you pipe the output to file first, and then in a second command use "head" or "tail" on the output file you might have a better time. Otherwise, my advice would be to just not write buggy code to begin with. I know that's not terribly helpful! But "an ounce of prevention is worth a pound of cure" is still a true statement even in our computerized age.
From the man page: &gt; `*stringp` is updated to point past the token. Hence the pointer to a pointer. Since C uses pass by value, if you want to have changes to a variable passed as a function argument visible to the caller, you have to pass a pointer to the variable, not the variable itself.
#include &lt;stdio.h&gt; #include &lt;math.h&gt; #include &lt;stdlib.h&gt; int main (){ int n,u,l,i=0,v; scanf("%d %d %d",&amp;n,&amp;l,&amp;u); int a[n],b[n]; for(int k=0;k&lt;n;k++){ scanf("%d",&amp;a[k]); if(a[k]&gt;=l &amp;&amp; a[k]&lt;=u){ b[i]=k; i++; } } for(int k=0;k&lt;i/2;k++){ v=b[k]; b[k]=b[i-1-k]; b[i-1-k]=v; } for(int k=0;k&lt;i/2;k++){ v=a[b[k]]; a[b[k]]=a[b[i-1-k]]; a[b[i-1-k]]=v; } for(int k=0;k&lt;n;k++) printf("%d ",a[k]); return 0; }
you're dealing too many cards. Check your shuffle function
strsep keeps track of two values: stringp, which points to the null character past the token, and the pointer to the token itself which is returned. so to use stringp as a state you need the double pointer. I think it's a more compact interface compared to strtok_r where you have to pass three params, and just like strtok_r it doesn't have a global state
What part are you having trouble with? What have you tried so far?
That's a neat way to go about testing. Good tip!
&gt; Testing algorithms and function in python or matlab Out of curiosity, why do you use C in this kind of work and not stick with Python?
Good tip. If anyone else is curious this is how you do so: `valgrind --log-file="filename"`
if you aren't already doing it, i'd say write tests that are closer to real world usage and stress your code, those kind of tests usually manage to make crashes or memory corruption emerge. it's quite easy to skimp out on the test suite and end up with synthetic tests that might not even feel it when something is subtly wrong. anyway if you find yourself often making these mistakes definitely run valgrind more frequently but that's gonna slow you down depending on what kind of stuff you're testing. it's much better if you remember what kind of mistakes you often make and build up discipline and experience to avoid them personally I find that I rarely make major memory management mistakes. even when I run valgrind on the finished project just to be sure I often either get nothing or minor issues that don't really pose a risk. plus, it's a pain to add cleanup code for allocations that are supposed to last the entire process' lifetime anyway just to stop valgrind from complaining. all of my projects are under 30k LOC or so though, so probably nothing close to your scale, mainly because I try hard not to let bloat get out of hand also, I don't use a debugger. if I need to debug a complicated bug I just have very verbose debug logging that prints file/line and simply see where it crashes and at most add a few extra prints to debug values if it gets really bad. if I really can't figure it out from logs, valgrind's stack trace is enough basically all I need for my workflow is vim with no plugins, any terminal emulator and tmux. I don't even use a build system, i just make a shell script that calls gcc/clang
The algorithm for this is similar to how quicksort swaps elements in the list. You start and one end and find an element to swap, then you start at the other end and work backward until you find another element to swap. Keep swapping until the two indexes overlap &amp;#x200B; //int *nums = some list //int n = length //int u = upper bound //int l = lower bound int i = 0; int j = n - 1; //when i and j pass each other, we are done while ( i &lt; j){ //search from left for a number between lower while (i &lt; j &amp;&amp; (nums[i] &lt; l || nums[i] &gt; u)){ i++; } //search from the right while (i &lt; j &amp;&amp; (nums[j] &lt; l || nums[j] &gt; u)){ j--; } //debug printf("%d %d, %d %d\n", i, j, nums[i], nums[j]); //swap if still switching if(i &lt; j){ t = nums[i]; nums[i] = nums[j]; nums[j] = t; //move one more space i++; j--; } } &amp;#x200B;
Of course, your loop condition presumes that z is positive. Trace by hand what the function does for z=-3 for example.
A tool that might help you with these issues is [scan-build](https://clang-analyzer.llvm.org/scan-build.html). You can install it using `pip` since it's a python script and run it with `scan-build --intercept-first make`. What this tool does is perform a static analysis of your code and create a report that you can view using any browser. I should also mention that you should re compile your project from scratch in order for scan-build to perform the analysis on all your files.
I learned a good bit about memory management today and I'm now seeing what you mean. My big scary Valgrind error output was only a few errors (They just got repeated over and over again since the lines of code ran multiple times) Got all unit tests to pass, yay!
But less is more!
I know what I did now, I had #define CARDS 24 becasue I thought it stood for number of total cards but it stands for hand so I made it 5 instead and it works.
Change not much, compile often. Also I use `const` quite much, short functions with a few variables that are scoped as short as possible. You can additionally avoid much intransparent memory management, if you write your code appropriately. Usually you can then plan ahead where to free() just when you're malloc()-ing so you don't forget about it.
Yeah, 3,000 errors in val can mean you have just a couple of places causing problems. Congrats on getting to goodness!
I assume the types `foo` and `bar` are not completely unrelated. What I would do is add a common base type like so: ` struct base { /* any common fields */ }; struct foo { struct base base; }; struct bar { struct base base; }; ` And then have the callback take pointers to the base struct and calculate the outer pointer from there: ` typedef void callback(struct base *); void foo_callback(struct base *foo_base) { struct foo *foo = baseof(struct foo, base, base); } void bar_callback(struct base *bar_base) { struct bar *bar = baseof(struct bar, base, bar_base); } ` Where `baseof` is the inverse of `offsetof` and looks something like this: ` #define baseof(type, field, ptr) \ ((type *)((unsigned char *)(ptr) - offsetof(type, field))) `
Whoa! I was expecting something like "yeah... It's c, live with it". This is brilliant, thank you! I didn't know about offsetoff, the way you're using it here is very clever. Where do you learn this sort of things? I read "modern c" and It helped me a lot but I think this sort of things are in a whole other level. 
Also, just for the hell of it, is there a way to make it say there are 4 whatever cards in case there are four of the same face? I ask because it would be interesting to see how long it would take until I get it 
I guess I can talk you through the steps. You have some array A, and some bounds L and U. You iterate over A. If L &lt;= A[i] &lt;= U, then add A[i] to some array B. Otherwise, you add it to some array C. To summarize: A is your working copy. B is your subsequence of interest and C is the values not satisfying B. At this point, you reverse array B. Create some array D the size of B, and iterate backwards over B, such that i=0, j=B.length then: D[i] = B[j] for all in B. Now you can overwrite A with everything first in C and then everything in D. Display A. Make sense?
I've skimmed some of the answers but I'm going to go a different direction... Work out coding guidelines and follow them fairly strictly. I don't mean "max 120char lines", but more along the lines of: 1. Every parameter passed into a function gets tested for a valid value (generally just checking that pointers aren't null if they aren't supposed to be) 2. Check return codes for the same 3. Check allocations to make sure they worked 4. Free allocations in the same scope they were allocated. That is if you enter a function and allocate memory, free it before you leave the function and not somewhere else 4. Braces on every block even the "it's only a line after an if/for/while; it will be fine) one And things like that. The first four will catch a lot of issues that you otherwise might miss until valgrind or a core dump. The braces one will save you pain from when you go back to edit a block and may forget the braces. Is it going to be perfect and save all of your problems? No. But it will help reduce the small things that are easy to overlook and then your tests can focus on logic and algorithms rather than trying to test for every possible edge case.
You know that your range is -1000 to 1000 for the input numbers. So, we'll use 2000 as a flag. Iterate over input list A. If L &lt;= A[i] &lt;= U, then add A[i] to list B. Flag A[i] = 2000. Reverse B. Create new list C and iterate backwards over B such that C[i] = B[j]. Maintain index over C as i. Iterate over A as j. If A[j] == 2000, then A[j] = C[i], i++. Print A.
As a rule of thumb sure, avoid void * where you can. But it's fine to use void * in C where the type is unknown - just be aware that it makes your code a bit harder to read, a bit more complex and a bit less type safe. It's one of those things that when you absolutely need it you should use it but when you don't need it you shouldn't use it.
You can; but then someone adds a field above and the code still compiles just fine, or you want to have several bases. It's composition vs. inheritance, and composition always wins.
More like: "it's C, your imagination is the limit" :) You're welcome. I stole the idea from the Linux kernel, but I'm sure it's as old as C. I have some more of the same over [here](https://gitlab.com/sifoo/snigl) if you want to have a look...
On bigger projects I use [CompileTools](https://github.com/Zomojo/compiletools) for my build tool chain. This makes compiling easy and fast (which is nice) , but it also lets me run tests as a part of every build. The unit tests, run valgrind -q by default on every build. So I catch things sooner. 
Well, why should he have to do anything if someone reading his code can just use clangformat and make it into whatever format they want to read..?
We live in a free country, anyone is free to do as they choose. You can use hungarian notation, if you like. But most people will probably find it ugly and distracting. 
The do while loop does something at least once and checks the condition after each iteration as opposed to a traditional while loop which is not guaranteed to run a body at all if the condition is initially false. Now then, the code technically increments the variable "c" twice. Once after printing 255 and another time after printing 0. In C "false" is considered to be 0 or null, so after printing 0 the loop does its conditional evaluation and exits. The reason the code is able to print 0 and exits immediately afterwards is that c++ is a post-increment operator. Post-increment operators return the value of a variable before performing the increment. So, when c is 255 and c++ is called it will return 255 while incrementing c to 0. So the first while comparison comes back as true. When c is 0 and c++ is called 0 is returned and the value of c becomes 1. I know this comment is fairly long, but I'm not 100% sure where your confusion lies. I hope this helps you out.
I have programmed in Scheme and a little bit of Clojure (although that was a long while ago). I'm not a fan of the parentheses, but I get the appeal of the language structure as a whole. Anyways, the dude /u/always_programming3 posted this asking for opinions, and I gave my opinion. I thought his style was impractical. I don't care how *you* write your code, because I don't have to read it. If I contribute to other projects, I have to follow *their* standards (which are typically close to mine anyways, but sometimes differ, depending on how old the project is).
Very helpful. Thanks! 
thanks!
Programming, once you get past all the simple stuff, is about managing complexity. It sounds like you have stepped up to a more complex program, but haven't yet developed the techniques to handle it. I like coding C in an object orientated style. Solid separation of concerns with firm lines of encapsulation. The object can be thoroughly unit tested, this should eliminate surprises further down the track. If adding feature X is unexpectedly impacting feature Y then your lines of separation aren't clean. Things like global variables a big smells that indicate this is the case.
Sorta. It will give you information about where the segfault happened without having to run gdb. Try it, enable sanitize-address and then make your program use an out of bounds array index. The info it will print out is really helpful
C has the best ratio of power to simplicity of any language, ever. Now, C preprocessed with m4, that's a different animal entirely..
Write a generic linked list library (~50 lines). Write a recursive descent parser to check a C file for matching ()[]{}, or for more challenge, a big num calculator (~100 lines). Implement a wildcard string matching using state machines, or for more challenge, a DFA for a basic regular expressions (~200 lines). Implement malloc and printf.
Sometimes i have to run my code on specialized hardware. That's basically my only reason for C Code. Other than that i stick to Matlab and if i need more performance on my PC C++, but to be honest i basically wrote C Code in C++ for way to long and i just started relearning it after ~15 years. 
Plenty still use emacs, even if there are more vim users
Is it a school work? Are you tasked to find flaws in this programs?
breakpoints could definitely help. you can set breakpoints anywhere the values are being changed and quickly check that everything is running as expected. most programs have breakpoint functionality, i'd highly recommend looking into it. that way you can see exactly what line is changing the value so you get the wrong answer. it's hard to give much more of an answer without seeing the code, but hopefully, that gets you on the right track. 
I've done some research myself and after some consideration I've decided to go with the snake_case. Thanks for your thoughts on the matter.
I've decided to go with snake_case after some research. Thanks for your thoughts :)
no problem! honestly, they are a lifesaver. if you've got visual studio then it's really straightforward how to use them, just clicking on the left margin next to a line will set a breakpoint and then if you run in debugging mode it'll stop at that line with all the local variables displayed. code::blocks is a little more difficult, but still fairly simple to use breakpoints in and there are tutorials out there (look for debugging in code::blocks). being able to see what is stored in memory at any given point in runtime is such a valuable asset. good luck!
If I leave everything as initialized, then quantity of foods = 0 and pre-set prices. The output of production is: &amp;#x200B; price of pallets from big bags :-1243822529 price of pallets from small bags :-274877907 remaining carob : 1030792151 remaining honeycomb: 1030792151 ... and so on &amp;#x200B; &amp;#x200B;
I use Code::Blocks, I'll try it now! Thank you!
That isn't helping much. From what you have posted I can only guess you are printing junk, incorrectly interpreted types or you are overflowing. Without the code it is impossible to pinpoint the cause. If extracting the relevant part of your code is so difficult, I suggest firing up a debugger and trying to solve it by yourself. You will have to learn the use of this tool sooner or later, so why not start today? 
I appreciate the thought... programming is not my thing, I'm a lost case hahahah 
Your code is impossible to read because you did not add four spaces at the beginning of each line. Please edit your post to do so. Also, don't use floating point for prices. Express them in cents instead of Euros, then divide by 100 when displaying the result.
I edited it, thanks. &amp;#x200B; I will follow your advice, thank you very much! 
Remainder is probably set to something above the while loop.
I don't if this going to be any help, but if you need to see the full code here it is #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int main(int argc, char*argv[]) { int num1, denom1, num2, denom2, result_num, result_denom; num1 = atoi(argv[1]); denom1 = atoi(argv[2]); num2 = atoi(argv[3]); denom2 = atoi(argv[4]); result_num = num1*denom2 + num2*denom1; result_denom = denom1*denom2; int remainder = result_num % result_denom; int result_denom1 = result_denom; int result_num1 = result_num; while(remainder !=0) { result_num = result_denom; result_denom = remainder; remainder = result_num % result_denom; } int divisor, numerator, denominator; divisor = result_denom; numerator = result_num1 / divisor; denominator = result_denom1 / divisor; printf("The sum of the fraction is %d/%d\n", numerator, denominator); return 0; } &amp;#x200B;
Just choose one to stick to.
Why don't you run through it in gdb? This is a question you can answer very easily for yourself in about ten minutes, including time spent on learning a couple gdb shortcuts.
Yes and its build for software revision management. Its most useful for when you are a team working on some software but its also very useful to be able to rewind time to the last point where you know the code worked when you have made unsuccessful changes. 
Versioning firmware upgrades and then be able to revert back to a previous version on the fly.. damn!
It's not explicitly, but don't most C projects use git? And furthermore, git is written in C, which makes it a tad more relevant?
Alright officer. Sorry bout that, won't happen again.
This is a group for C, not C++. You will also need to post a discription of your problem to receive help.
I actually ended up using Linked Lists with pointers to the next point. I then made a Function that walks the list forward and another Function that walks the list backwards. The "next" and "prev" variables default to NULL using a jury-rigged Constructor. Now I can easily cycle through all the points for rendering and by walking backwards and forwards through the list, can detect if a point can be placed in the X/Y or not. While I would like to jump into getting a "point allocator" working to ensure strict memory management, the Linked List allows for more flexibility as long as the programmer keeps track of memory usage. Hell, now that I think about it, before constructing a new Point, I could figure out some sort of memory test.
I'm sorry but I see it with the correct indentation. Do you say I should correct when the string is too long? And I'm sorry to have ruined your day with my mess haha. The important thing that I solved the problem Now I'm going to delete the code in the text so we're all happier.
Does [this](https://i.imgur.com/bqg0LB6.png) really look right to you? If so, I'm at a loss for words.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Pinned as an interesting topic.
Is it a little better now?
I appreciate it. Learned a lot from this thread.
Generally speaking, what you use it for is more important than using C. Based on what little you’ve given us I’m not sure if I should be recommending systems work, embedded systems work, game development, or literally anything else C can be used for, which by the way is pretty much anything. Aside from teaching, where does your professional experience lie? Also, what do you mean by “online?” Do you mean that you’re looking for remote work, where you won’t have to be onsite? Take a hard look at your experience, in particular provable work, and bolster your github as much as you can. Then start looking for companies that are open-source friendly and among those pick open-source projects that align with your interests and contribute as much as you can. Having contributed to projects that solve real world problems looks great. This isn’t the only route you can take, there are tons, this is just my first thought based on what little I know. Hope that helps, but I’m also willing to share what little more I know if you’re willing to answer my above questions. 
Check your compiler's documentation to see how to define a macro at compile time. For most compilers its `-D`, and from your Makefile, define the build platform. Probably the easiest strategy is to have a macro for each platform, so on Unix pass `-DPLATFORM_UNIX=1` to the compiler and on Windows pass `-DPLATFORM_WINDOWS=1` to the compiler. Then in your code you can use the `if` and `defined` preprocessor directive. #if defined PLATFORM_UNIX // do the Unix stuff here #elif defined PLATFORM_WINDOWS // do the Windows stuff here #else // will an unspecified platform imply a certain configuration or abort? #endif /* PLATFORM_* check */ 
 // The content (data) associated with each inode is stored // in blocks on the disk. The first NDIRECT block numbers // are listed in ip-&gt;addrs[]. The next NINDIRECT blocks are // listed in block ip-&gt;addrs[NDIRECT]. // Return the disk block address of the nth block in inode ip. // If there is no such block, bmap allocates one. https://github.com/bitc/3/blob/master/fs.c 
Use of a union would require that the code which receives and invokes the callbacks include definitions for all the types of pass-through data the callbacks will be using. If another callback is added which needs a kind of pass-through data that isn't in the union, it will be necessary to add the type to the union even though the code through which the callback and its data are passed should have no reason to know or care about such things. If one wants to ensure that the callback and data are kept together, one way of doing that would be to pass a double-indirect pointer to the callback function, and have the function itself accept the original pointer as a parameter. The code that wants to prepare the callback would then create a structure with a function pointer as its first member, and any data needed by the function after that, and pass the address of that member (which would also be the address of the structure). Then code which needs to pass through or invoke the callback will only have to work with a single pointer for both the function and the data. 
Any form of read/sort requires the data to be in memory for comparison, however all of the data does not need to be in memory at once - I think this is what the task is. You can still likely use fread, fseek etc As a basic example, you could just fread/write to a new file, using a buffer(not keeping everything in memory) and once finished the first file, read/write the second file into the same new file. Then bubble sort the new file on disk. (Using just a buffer again) Might not be very fast, but should work. Can look at other sorting algorithms for something more advanced/faster. Hope that helps!
The language Dennis Ritchie invented was very good in those regards. The language that gcc and clang process with optimizations enabled, not so much. According to the published Rationale for the C Standard, the Spirit of C includes the principle "Don't prevent the programmer from doing what needs to be done". In cases where the behavior some action is defined by some parts of the Standard, but a different part regards an overlapping category of actions as invoking UB, the latter should only have priority in cases where it wont' interfere with what the programmer is trying to do. The attitude of the gcc and clang maintainers is unfortunately antithetical to the Spirit of C, since they view code which requires anything not mandated by the Standard as "broken".
Can you clarify what you mean by not read in memory? You can't operate on anything unless it's in memory. Even to sort the disk files, they'll need to come into memory at some point.
&gt; at the mercy of the compiler vendors to agree on macro names They do. It's `_WIN32` for 32-bit Windows, `_WIN64` for 64-bit Windows, and `__unix__` for various Unices. Each Unix flavor also has its own macro: `__linux__` Linux, `__FreeBSD__` for FreeBSD, etc.
They don't, notice none of the macros you listed appear in the comprehensive list of macros defined by the C standard: https://gcc.gnu.org/onlinedocs/cpp/Standard-Predefined-Macros.html#Standard-Predefined-Macros The macros you provided are _very_ platform (read: compiler) dependent - which one might naively think is ok given the task of identifying what platform is currently being targeted. However, compiler A on Linux may define `__linux__` while compiler B on Linux instead defines `__LOLWINDOZSUCKS__` instead. This means every time you try to use a different compiler you need to add a case for whatever that compiler defines to identify a specific platform.
You could use a global variable to indicate how deep you're currently traversing. But could you create a *node_create(int n)* function instead? So *tree_create() implementation just calls node_create(0), which is your actual recursive function? Or is that bending the rules?
Make a second function that has an argument: &amp;#x200B; t\_node \*tree\_create\_impl(int depth) {} &amp;#x200B; And then call that from the required interface. &amp;#x200B;
That is kind of the issue, what I quoted is as stated in the assignment and was the main cause of my doubt. But I think I'll follow the lead of the other comment and just read part of the files
Not op but do I understand correctly that static ints are global and their value is only set when instantiating (the first time)? I've never used static variables for anything really
They are instantiated once and afaik accessible only inside the function.
Okay I'll look it up, it seems like something I'll need to use at some point
Personally, I have only used it to solve weird/not well defined/obscure problems in the class. Then again I don’t program in C that often since the class has ended.
Perhaps it means don't have the all the contents of *both* files in memory the at once. I would imagine this to mean you can sort one file, then sort the other, then do a merge between the two that only reads one number at a time from each.
Most of our assignments so far have been "simulations" of processor architecture, so if I find a theoretical counterpart in some cases I can see it being quite useful.
First off, this is the C-language, not C#. Thus /r/csharp or something. But thats ok. You don’t iterate over the filenames you get from the getfiles() function. Start there. Don’t recreate the filename, that is error prone. Second, use the File-class. I think its something like File.Open(filename) Third, only read the first line. Skip the rest. You can use Linq for that, but there are more ways. One more, instead of the null-check, use String.IsNullOrEmpty 
I think you'll find that if your tree has 16 leaves, it has 5 levels. But anyway: t_node* tree_create() { return tree_create_levels(5); } Then you just write `tree_create_levels`. 
Show me a compiler on one of those platforms which doesn't define those macros.
C# is off topic in this subreddit. Please post this question to /r/csharp instead.
Welp despite all the advice you just gave me, I solved my problem with an = sign. &amp;#x200B; while (y &lt; txtfileCount) { &amp;#x200B; is supposed to be &amp;#x200B; while (y &lt;= txtfileCount) { 
&gt; There are about a thousand testing frameworks to use instead of this craptastic method I've proposed, but unit testing goes a long way towards making systems sane -- they help with regressions, and point out things you need to check much easier. Indeed. I can't recall the book I read this from, but the distinction between legacy and non-legacy code is that non-legacy code has tests.
IBM XL, Solaris Studio, HP aC...the list goes ever on.
True, the compiler vendor names aren't standardized by C, but in nearly 30 years of Unix programming, I have never found it to be an issue. I was easily able to find \[a list of OS specific defines\]([https://sourceforge.net/p/predef/wiki/OperatingSystems/](https://sourceforge.net/p/predef/wiki/OperatingSystems/)) that include systems no longer in active use (such as \`\_\_VMS\` and \`\_\_OS2\_\_\`. &amp;#x200B; The issue with your proposed \`PLATFORM\_UNIX\` is that is isn't fine grained enough. For instance, Linux and Solaris (both Unixes) support the POSIX function \`clock\_nanosleep()\` while Mac OS-X (another Unix) only supports the older POSIX function \`gettimeofday()\`. I find it easier to check for \`\_\_APPLE\_\_\`, \`\_\_OpenBSD\_\_\`, \`\_\_SunOS\` and \`\_\_linux\_\_\` that to define my own constant. &amp;#x200B;
Show me a hosted C implementation that targets GNU/Linux and does not define `__linux__`. Show me a hosted C implementation that targets FreeBSD and does not define `__FreeBSD__`. Show me a hosted C implementation that targets Windows and does not define either `_WIN32` or `_WIN64`.
[ctype](http://pubs.opengroup.org/onlinepubs/009604599/basedefs/ctype.h.html)
Exactly. it's the stdio buffering which is causing the unexpected behaviour: If you add newline to the parent printf, you'll see the processes are running together, as you'd expect. 
Also before you turn in your program make sure it can candle strings of zero length (first char is '\0') and strings that contain just a single word AND strings that only have whitespace. I think your instructor is being pedantic to teach you about requirements and specifications. I'd really push them for a formal definition of word and whitespace. 
Thank you for the heads up!
If I understand your meaning correctly, that you think that clang and gcc view UB as erroneous code, then you are simply wrong. It compiles; the behavior is defined. The C standard is entirely undefined behavior because there is no compiler that implements it (:
So the user gives you the 10 elements? As an array or just 10 separate element? Either way if you can put the information into an array and do a sort on the array you can just do a loop on the second element to the last element (note: sorted order) compute the sum of those elements and divide by 8 for the average.
Once you are done printing, you can reset the variable `intergal_3` value to some default value less than 0.00001 (For example, do `intergal_3 = -1;` below the printf). That way it will enter the inner while loop for all values of L2.
It still does not change the value of x2 
No dude I don't want a macro I don't want I don't want her nose definition I want to create my own macro or micro for further training 
Try putting your print statement inside the inner while loop
It only repeats the calculation of the x1 value for one l2 value and does not change the value of l2
If the callback needs the pass through data, then the callback does have a reason to know or care about it. I don't think I'm understanding you clearly.
Allow the caller to specify the function that releases the resource.
Is it a trait / implement? Is there a destructor in rust? If so just free it in there. If not, add a function that frees the memory when called, or add both.
What do you mean? It's a void pointer you add to the list from C. So I could just call free with the system allocator on it, but that assumes the system allocator was used to make the element. I could ensure that with a macro that simulates generic but allocates behind your back (using the system allocator)
Nobody who is commenting will be able to see your reply comments **because you haven't replied to our comments**. If you expect people to help you, can you please reply to their comments instead of creating a new comment each time you want to say something? &amp;#x200B; You are only updating L2 in your outer loop. So, all the things in the loop (including the inner loop) will be evaluated based on the value of L2 for the particular iteration. In your inner loop, you are updating x1. What is happening is, for a given iteration, say L2 has a value 100 and integral\_3 has value -1. 1. The condition L2&gt;0.49 is true. So we go ahead. 2. The trapezoidal uses this value and saves the result in integral\_1. (first line in the loop body) 3. The inner while loop uses the L2 =100. 1. Is integral\_3 less that 0.00001? (-1&lt;0.00001 evaluates to true. So continue inside) 2. integral\_2 is calculated by simpsons() using x1, x2, i and func. 3. integral\_1 is calculated by trapezoidal() using L1, L2=100, i and f 4. integral\_3 is calculated based on integral\_1 and integral\_2 5. x1 is decremented. 4. And exits the inner loop. 5. `Printf` prints to the console. 6. L2 now becomes `L2-0.01=99.99` 7. Reset `intergal_3 = -1;` **This needs to be added by you.** 8. We reach the condition again. Do you not expect this to happen? &amp;#x200B; &gt; It still does not change the value of x2 How and why do you expect value of x2 to change? Can you share what the simpsons() and trapezoidal() functions do? Are they supposed to change the values of x2? You are using pass-by-value for those functions. Can you try passing x2 by pointer to the functions? &amp;#x200B; Lastly, can you explain what you are trying to do instead of just sharing code as a screenshot? Things like: *I expect the code to give me* `xyz` *as output. I am getting* `abc` *as output. Here is my code pasted as text* ***and not image****. Can you please help?* That way we know what you are trying to do instead of suggesting the wrong thing.
hmm, I was assuming you were wondering how to handle it in rust itself. Not sure how to handle this exactly.
I'm wondering how to handle in rust, I don't get it, calling the system's free is not enough, right? Because the user could have allocated from another allocator.
http://idownvotedbecau.se/imageofcode.
Do you seriously not understand the meaning of the word “filename”?
The "FILE *" isn't a file name, it encapsulates the open file. You've got the file name as an argument to the function, so it looks like that should be the argument to fopen, not the constant "somefile.txt" - you'd call count_tabs("somefile.txt")
This looks like homework so I'll not give you the exact answer but point you in the right direction. Your file name is passed as a parameter, that's the name of the file not the name of the FILE * variable. 
Oh I see. Sorry for my stupid question, but thanks for the help!
Thanks for the help! Sorry for the stupid question but I appreciate your answer!
It means the caller passes the name of the file you are supposed to read in `filename`. Use it instead of `"somefile.txt"`. The rest of your code is fine, except that of course your `FILE *` needs to be named something else than `filename`.
The only way you'll really learn is to try something and ask if you don't understand. Don't think that asking questions is stupid. 
how about writing thin wrappers in c which will handle the life cycle of the pointers and you could also wrap things in a c struct and ref count using that struct 
Not your question, and not an error, but you might be better off not using feof(). Typically you use some input function, like getc() and react when it signals end-of-file.
Not your question, but \*(string - 1) could be written more neatly as string\[-1\]. Matter of taste, I guess.
Are you sure you got the assignment right? I would assume you are asked to read two text files and write one text file. Why "bin file" ?
Thank you a lot, I think I'll go this way
If you're using `feof()`, you have to read [this blog entry](https://latedev.wordpress.com/2012/12/04/all-about-eof/) about why you shouldn't be.
I'd too. I cannot recall ever using it. 
not about C programming - also consider what cryptomining is doing to world wide power consumption and the environment. 
This. Best practice in C is generally the layer of code that allocates should also free. If your library doesn't allocate memory, you should be passing control back to the caller's code for the freeing of that memory. A callback function is the simplest solution. You could also do something like build a list of pointers to "dead" nodes for the caller to free, but that's way more complicated for little reason.
Wait, what? Could you explain the difference between: str str[] \*str ? 
I wonder how those error/exception handling proposals are doing... This would really be a game changer for C.
I did it?
Probably the most controversial proposal. I'm not sure myself whether this'd be a good idea for C, it's probably simply to high-level. There are other languages for that and this is a good thing. Trying too hard to make C still relevant everywhere is bad for the current usages. I don't consider it a bad thing if at some point C "dies", if other languages superseded it in every aspect with a nice clean approach (Rust is close in some ways but not in every aspect better or good, IMHO), frankensteining an old language to adhere to modern expectations does noone any good. As long as C is still relevant, it should be C and not C++ or some other monster language.
&gt; Add a type aware print utility with format specification syntax similar to python I'm hoping this leads to something similar to Python's [TypeVar](https://docs.python.org/3/library/typing.html#typing.TypeVar) but for data pointers so we have a type safe alternative to `void*`. 
Everything is controversal in languages designed by commitees. Especially if the language in question is C. What does "simply too high level" even mean? Why should fixing old language problems be considered a problem? Some people, including myself, find that C is a very nice language for certain niche tasks. And, as all languages do, it has certain pain points that might be relaxed. What's wrong with that? The proposal in question doesn't even have any performance problems. If it's not you language, or you have no use for it, or it's too complex - just don't use it. That doesn't mean other people don't want the language to - carefully! - evolve. 
I do not consider this "fixing" a problem, at least not in the scope of C. A better solution at some point is to simply switch the language. The problem is not always about performance but complexity of the language and its compatibility with previous versions. &gt; If it's not you language, or you have no use for it, or it's too complex - just don't use it. The same can be said for those who push hard to make those changes, if you want such features, just don't use C. &gt; That doesn't mean other people don't want the language to - carefully! - evolve. I didn't say that, and I want C to evolve. But I have quite some objections about this specific proposal to be too intrusive. There are different opinions, and mine is that it's bad for my previously laid-out reasons. Saying that other people disagree is not an argument *for* implementing anything, just for *discussing* the issue.
I guess I'm still a little confused. As I understand it k=&amp;n would set \*k to the value of n \*k=n doesn't work So essentially in my mind I classify it as "okay k is the same type as &amp;n if you are able to set them equal to one another", but in the program you are passing the square it function the value of "&amp;n" despite the parameter being int \*k. How does the program know that in this case &amp;n needs to be given the value of k instead of the value of \*k. When I think of setting \*k to &amp;n it would seem like you have a address k that is equal to both &amp;n and \*k. k=\*k=&amp;n doesn't seem right though
Switching languages is sometimes just not reasonable. Besides, C is not a horribly big or complicated language. Given the 40 years of history it's surprisingly comprehensible and small. It has a few unique features: 1. C code can be used as is from any other language, unlike almost any other language out there. 2. C is performant. 3. C is (relatively) simple. 4. C is independent. No other language has all of of the features mentioned. Rust might be coming, but it's not simple, and is mostly controlled by a single company. C++ is... Not simple. And we also know what the problems of the language are: underspecification, painful error handling, resource deallocation and those nasty size-less strings. So why fight positive changes?
BTW, what are your alternatives to N2289? The error handling proposal?
It just is that way, either notation is valid. Even n\[str\] works, try it. I suppose it's a historical accident, which was not corrected in time. I'm not qualified to explain the difference properly.
I mean, I'm not trying to take credit for N2198 (u8 character literals) but I messaged a few people about needing that, and I'm REALLY glad to see it proposed. in fact, Jens Gustedt the OP was one of the people I talked to about it and he basically said it wouldn't happen lol. I mean it may not happen still, but it's far more likely now. IDK, I'm just happy 
It's an older way to declare functions, from pre-ANSI days. There's an example here: https://stackoverflow.com/questions/3092006/function-declaration-kr-vs-ansi#3092074 The name 'K&amp;R' itself comes from the legendary book "The C Programming Language" by Brian Kernighan and Denis Ritchie, which was the original point of reference for C before the ANSI standard was put in place.
Good riddance. It's about time that abomination is removed.
Then, good call I guess. Thanks!
Yes, you did it.
&gt; k=&amp;n would set *k to the value of n Nope. `k = &amp;n` would set the address `k` points to to the address that the value of `n` is stored in. &gt; *k=n doesn't work Depends what you mean by doesn't work. It doesn't do anything productive in this case, it sets `n` to be the value of `n`. However consider this case (`n` and `o` are ints, `k` is a pointer to an int): n = 42; o = 27; k = &amp;n; *k = o; What will the value of `n` be after that?
I've found that the internet is an invaluable repository for knowledge about how to write things in code. However, the vast majority of resources that i've come across do a pretty shitty job of actually explaining what's happening under the hood and why. I finally had a grasp on pointers after i stumbled across the following page. Everything clicked and i was like "well why tf doesn't anyone explain this? Is it something that we're just supposed to know??" http://aelinik.free.fr/c/ch11.htm Good luck!
##r/cpp --------------------------------------------- ^(For mobile and non-RES users) ^| [^(More info)](https://np.reddit.com/r/botwatch/comments/6xrrvh/clickablelinkbot_info/) ^| ^(-1 to Remove) ^| [^(Ignore Sub)](https://np.reddit.com/r/ClickableLinkBot/comments/853qg2/ignore_list/)
I hope this proposal is not going to come; it's the only proposal that requires significant ABI support and that support might not be there on more limited architectures.
yeah, let's just happily use errno.h, it's perfect as it is :-)
I think "Simply too high-level" means that while the Standard explicitly recognizes that implementations may process many actions "In a documented fashion characteristic of the environment", and the published Rationale recognizes that this is useful, the Standard itself fails to suggest that there are cases where quality implementations claiming to be suitable for low-level programming *should* process things that way, even though implementations that don't claim to be suitable for such purposes might reasonably do otherwise. As a consequence of this, some compiler writers view any code that relies upon such treatment as "broken", ignoring the intentions of the Standard's authors as expressed in the Rationale. IMHO, the Standard needs to make clear whether it is merely trying to define a set of minimal requirements for implementations (in which it wouldn't need to try to define enough behaviors to satisfy the needs of most programs for freestanding implementations) or whether it is designed to specify useful categories of both implementations and programs. Either purpose would be fine, if the Standard were clear about its goal and written in a fashion consistent with it. As it is, however, there's a catch-22 of the Standard declining to define behaviors that implementations could define if their customers need them, and compiler writers using the lack of mandated behaviors as evidence that programs requiring them are "broken". Unless or until the Standard fixes that problem, the notion of "Standard C" will be pretty much meaningless for many application fields. 
There's nothing really wrong with errno, though it should be thread-local.
In the function definition you declare k to be a pointer to an integer using int *k . Inside the function you dereference to n using *k, the integer that k points to. 
The client-supplied callback function would need to know about the type, but the code *invoking it on the client's behalf* wouldn't. Suppose I have a function which is supposed to output "Hey", then perform some caller-supplied action, and then output "There\n". If the function is written as e.g. void wrap_call(void(*proc)(void*), void* arg) { printf("Hey"); proc(arg); printf("There\n"); } there is no need for the wrapper function to know or care about what kind of object is identified by `arg`. The only thing `wrap_call` does with the passed pointer is pass it along to the caller. An alternative design: void wrap_call2(void(**proc)(void*)) { printf("Hey"); (*proc)(proc); printf("There\n"); } would let the callback and associated data be passed around as using one pointer rather than two. The pointer would typically identify some kind of structure whose first member is a `void(*proc)(void*)`, but `wrap_call2` would have no reason to know or care about the specifics of the type or anything beyond its first member. 
Multiple returns would be fantastic, especially if it wasn't a hard limit to 2 or whatever, but could scale up to maybe 4? no more than single digits at least.
The former approach allows the return value to indicate whether the operation succeeded or failed. An alternative design for realloc could have been invoked via: int result; thing = realloc2(thing, &amp;result); with semantics that a failure which leaves the passed-in `thing` allocated would return it, thus avoiding the need for the client to keep an extra copy of `thing`. On platforms that could support it, the approach of: status = realloc3(&amp;thing); would be semantically cleanest, but it would be impossible to implement on platforms that use different representations for different pointer types. 
BTW, there is no such thing as "blank int value". Intereger always has a value. It may be 0 when declared or junk when dynamically allocated, but it's never blank. 
Online tutorials won't suffice? There's lots of it. 
The maintainers of clang and gcc have indicated repeatedly on their support forums that they do not regard as a defect their compilers' inability to support constructs which earlier compilers--including previous versions of clang and gcc--had treated as defined. Such treatment even extends to cases which would have been considered non-controversially portable, such as code which is designed to, using the Common Initial Sequence guarantee, be capable of receiving a pointer to an object of any type which shares a certain Common Initial Sequence and examine the CIS members without having to know the specific type in question. It also extends to cases where the Rationale document describes how commonplace implementations were expected to process certain actions which invoke UB, e.g. invoking a function like: unsigned mul_mod_65535(unsigned short x, unsigned short y) { return x*y &amp; 65535; } on a 32-bit platform, with arguments whose product exceeds 2147483647. 
Because there aren't 255 different possible values for an 8 bit value. There are 256 different values. &amp;#x200B; So you should be calculating it like this: 256 - 3 = 253 \~253 = -254
It should be `256 - 3`, not `255 - 3`. Remember, `-1` in 8 bit two's complement has the same bit pattern as `256 - 1 == 255`.
Huh. TIL. Does that mean errno is not thread-safe? That's less than optimal.
`errno` used to be not thread-safe which is incidentally why all the pthreads functions avoid it. Nowadays it is (cf. ISO/IEC 9899:2011 §7.5 ¶2), but for legacy reasons, it is not specified how `errno` is defined. Many platforms implement it as a function all, but it should really just be something like _Thread_local int errno;
You're casting x to an unsigned char. The bits dont change and no substraction is done or anything like that. -3 in binary would be 11111111 11111111 11111111 11111101. Normally the ~ would change that to 00000000 00000000 00000000 00000010, and you would print 2. However because you cast x into an unsigned char before inverting it only the last byte gets inverted, but printf still prints the entire integer. What you print is 1111111 11111111 11111111 00000010 which is -254. For some reason 
They've been deprecated for 30 years. If we can't remove them now, then when?
There's also: &gt;Remove one’s complement and sign-magnitude representations of signed integers This will have a big impact on systems that do use those representations natively 
The authors of the Standard need to recognize that if a feature or guarantees could be usefully supported on many implementations but not all, then the Standard should make it usable on implementations that opt to support it, while allowing those that don't support it to indicate such non-support. Accepting that principle would not only reduce the need for compiler-specific directives, but in many cases could greatly improve the range of situations where language constructs could be useful. Many freestanding implementations, for example, are agnostic to the possible existence of threads, but many ways of handling exceptions require support for thread-duration objects. Different real time operating systems generally handle thread-duration objects in similar but not identical fashion. Since the programmer will generally know more about the target RTOS than the compiler vendor, it would often make more sense to have the specifics of an environment's requirements encoded in the program text rather than built into the compiler. Defining a standard way of doing that on implementations where it may be necessary would avoid the need for compiler writers to know or care about the target-platform OS. 
So you don't want it to be possible for someone to write portable multi-threaded code, bearing in mind that non-POSIX systems exist? Would you also apply the same rationale to filesystem access? Why should the standard include a way to open a file, or dynamically allocate memory? Those are also the operating system jobs. 
an (implied) unsigned char can only hold a value from -128 to 127, you are seeing overflow where the value rolls over. Consider using a variable type with more precision than char
The abstract of [N2161](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2161.pdf) is incorrect. C++ changed it so that the operation is implementation-defined in all cases. It's not well-defined in some, nor undefined in some, as claimed by N2161. 
char is an 8 bit value meaning it has a max value of 255. When you do z1\*z2 you get 120\*3 which is 360. Since z4 cannot go above 255 it cycles round to 0 and continue counting upwards from there. It ends up as 104 because 360-256=104
MS would probably have their own compiler continue to support it as a non-standard extension; and other compilers would have to update their Windows API headers 
OK, TIL some more. Thanks.
The purpose of the static dimension in such cases is not to facilitate warnings about erroneous code, but rather to enable optimizations. For example, given something like: int find_value(double array[static 100], double value) { for (int i=0; i&lt;100; i++) if (array[i]==value) return 1; return 0; } in the absence of `static 100`, the code would be required to behave as though it doesn't read any elements of the array past the first one that matches `value`. This would in many cases compel an implementation to refrain from reading any array element until it had determined that the previous element did not match `value`, which would in turn preclude the use of vector instructions. The `static 100` qualifier indicates to the compiler that while executing the function, it may read from any of the first 100 elements of the array at at any time for any reason, which would in turn allow it to make use of vector instructions, parallelism, or other optimizations to examine multiple elements at once. I don't see any particular advantage to using parameter declarations for this purpose instead of having an executable `__preread` intrinsic that would do likewise, save for the fact that the Standrd defines this syntax and doesn't define any sort of intrinsic, but the fact that the Standard defines this syntax is a pretty strong argument in favor of it.
only unsigned char can go up to 255. unless OP specified alternative defaults in a header or in compiler flags, that is a signed char.
&gt; So you don't want it to be possible for someone to write portable multi-threaded code, bearing in mind that non-POSIX systems exist? The point is that there are many ideas about what a multi-threading environment should look like. For hosted environment, POSIX is the standard that was agreed on years ago. If a hosted system cares enough to implement standard C, there is no point why it should not provide a POSIX interface. If your operating system vendor refuses to implement POSIX, why do you think he would be more willing to implement standard C? For freestanding environments, the question is an entirely different one. If your environment is a freestanding one, you probably either have to implement threads yourself or have a very specific idea of how they are supposed to work which might not be compatible to C. So there is no place left where C11 threads give any benefit.
Having considered and researched this briefly, I have concluded that no such systems of any relevance exist in this day and age. In repeated discussion of this topic, nobody could name a system with either representation that hasn't been obsolete since the 90s or is so special that standard code won't run anyway. So while there goes one of my favourite pitfalls to teach beginners, I don't particularly mind this change as it merely affirms what has been the de-facto standard design choice since the late 70s.
While optimizations can definitely occur in theory, I just tried compiling a few examples with the VLA argument vs a pointer argument, and the resulting assembly was the same. So although it's possible, I wouldn't say that it's really necessary for optimization's sake. More importantly I think the OP's use case was documentation, and because the compiler warns the library writer under ```-Wvla``` and does not warn the library user for incorrect inputs, I'd say the feature should not be used in non-vla environments, which is a little dissapointing considering I think the feature could be nice.
Yes, and I'd like it to stay that way. But I don't think I fight the positive changes, I simply think it's not a positive change, for once it probably breaks your point \\#1, and it also worsens point \\#.
I think it's simply too late for the language, and I'd let it stay as it is. It's not exactly nice, but not \*too\* bad either. It works.
Well, I'm not sure whether things in a parameter list qualify as an expression in that sense or are not some other kind of declarator. After all, this is an array of "variable size" but doesn't need have been allocated as one. I think it could catch some bugs, especially if you then can pass calculated lengths for arrays all the way down to other functions -- it's just not used for that purpose (yet?).
That's just the current compiler situation, I'd hope this to change.
But this part is not about some unclear specification which is what you're talking about, if I understood you correctly. It's rather about introducing a completely new feature.
Sure, just as they didn't have proper C99 support for years. It's more of a petty thing for me though :-)
I think cppreference.com is usually really good, and they have this line: void fvla(int m, int C[m][m]) // OK: block scope/auto duration pointer to VLA I think this means that ```C``` in this case is not a VLA (sizeof(C) is constant), but because it is of type "pointer to VLA", the compiler warns you.
Welp, I didn't even know it existed. Good riddance though.
&gt; If your operating system vendor refuses to implement POSIX, why do you think he would be more willing to implement standard C? C is implemented by C implementations, not operating systems. 
Which in case of hosted environments, do run on operating systems.
The example I gave also provides a warning The "OK" part was added by cppreference in relation to something other than VLA warnings - I just edited my comment
It's not too hard to macro multiple returns, is there a reason it should be added to the core language rather than just using macros?
it prints the input first then on the next line it prints the rest of the sentence and Ive tried using %s and it didnt work &amp;#x200B;
Show, don't tell.
Paste it here (four spaces in front of each line) or on pastebin.
[https://pastebin.com/zvumWkU9](https://pastebin.com/zvumWkU9)
thats my output &amp;#x200B;
Four spaces in front of each line.
You said `C` wouldn't be a VLA but it still produces a warning, since it's at least a pointer to a VLA However my example shows that even if it's just a pointer it still gives a warning.
I have and Ive been told countless times how to use it
Sorry--I misinterpreted the location of that comment within the tree. 
At present, K&amp;R-style function declarations can be used to allow functions to receive a pointer to a 2d array followed by the dimensions thereof. For example, I know of no way to express: void use2dArray(double[*][*], unsigned, unsigned); void use2dArray(arr, rows, cols) unsigned rows,cols; double arr[rows][cols]; { ... code goes here } using newer-style declaration without turning the convention of passing a pointer followed by the size on its head. 
What does it say about newline characters?
No worries - good luck!
I didnt see anything about that, could you explain? &amp;#x200B;
A C implementation that targets some OS will generally be limited to the semantics supported by the OS. If an OS can't support certain semantics, the Standard can either allow conforming implementations to refrain from offering the impossible semantics, or it can make it impossible to implement a conforming implementation on that OS. Neither approach would make the desired semantics available to programmers, however.
[Look closer.](https://linux.die.net/man/3/fgets)
hmm this looks interesting. Will check it out tomorrow since its pretty late rn and im not rly focused. Thanks man.
Can you name a single non-two's-complement platform for which a conforming C99 or C11 implementation has ever been available? While I know of a ones'-complement C89 implementation that was updated in 2005 and includes some C99 features, it is not a conforming C99 implementation because its longest unsigned type falls short of the 64 bits mandated by C99 and C11. 
The variable you defined in `main()` is not visible outside it. You will have to pass a pointer to it to your function.
so how would I fix it?
What have you tried?
1. Having read the man page, do you now understand what the problem is? 2. Show, don't tell.
No, and I've already shown everything. Can you just show me what I have to do 
You are going to either declare your array outside of any functions (including main) to make it global or change your function to take an array pointer as an argument. 
1. When you type in a string and press the Enter key, `fgets()` will store that string *and a newline character* in the buffer. 2. No, you *told* me that you had “used `%s` but that didn't work” but you didn't *show* me. It won't solve your problem, but if you did it correctly, it's probably a better choice than what you have now.
I'm not too worried. Every time I work on it, I modernize whichever module I'm editing. It's mostly ANSII C by now.
[https://pastebin.com/9sjszMwY](https://pastebin.com/9sjszMwY)
I want to be able to never modernise my code. I don't have time for bullshit busywork like this.
/u/necheffa gave you that. You can create a macro using `#define` or `-D` on the command line. Please don't shout at people who are dong their best to help you. #define THIS_IS_MY_MACRO 1 There. I just created a macro. #define HERE_IS_ANOTHER_ONE(x) ((x) * 2) This is a little different, because it has an argument. Any book on C will cover this.
OK, so in this version, you print `lang` out with `fputs()` and *then* tell `printf()` “I want you to print out a string for me” but without actually giving it a string to print. You need to drop the `fputs()` and use pass `lang` to `printf()`. But that won't solve your main problem, which is that `lang` contains a newline character. I haven't seen you make any attempt to remove it.
i guess it's best you can go with
`*` acts like dereference op there 
```for(char i = 'a'; i &lt;= 'z'; i++){ std::cout &lt;&lt; i &lt;&lt; endl; }```
for (char letter='a'; letter&lt;='z';letter++{ cout&lt;&lt;letter&lt;&lt;' '; } 
How do I remove it? The rest of your explaination does make sense now I appreciate it 
What have you tried?
&gt; Why should the standard include a way to open a file A file as an abstraction is fine, but any detail like how the filesystem is expected to be laid out shouldn't be in the language spec. This is the lesson we learned the hard way with file locking. 
Oh please, just let's make some progress. Let's delete some shit for once.
Similar to which python? Python originally used C's printf formatting, but now uses something that's deeply more cumbersome and has many more points of runtime failure. 
I'd rather see something like Rusts tagged unions.... the language doesn't let you look inside a union unless you switch on the tag. Very nifty for functions that may return error codes.
No problem. Just remember that it is easier to solve small problems. If you are having trouble writing a larger problem, start with the simplest program that does part of the problem you are trying to solve. Use a lot of strategically placed printf statements to help you understand/debug a program. 
Go through cs50 on edx.com That's how I started 1,5 ago, now working as a software engineer.
Doesn't work on Mac last i checked.
Can you show the code where you use realloc, malloc and frees? That would help in understanding how you are allocating memory. 
I see now. Thanks for sharing.
Thanks for taking the time to read. I hosted my project on Github so here are the files. Each data structure allocates memory in about 4 functions and frees all of it in the "destroy" functions. Here is the source file where I manage the char\*\* [https://github.com/AntonioBohne/KiwiLexer/blob/master/Sourcefiles/TokenizerSrc.c](https://github.com/AntonioBohne/KiwiLexer/blob/master/Sourcefiles/TokenizerSrc.c) &amp;#x200B; And here is the source file where I manage LinkedLists [https://github.com/AntonioBohne/KiwiLexer/blob/73813fb69d980a33bc710ad5575e7998676252cc/Sourcefiles/TokenizerSrc.c](https://github.com/AntonioBohne/KiwiLexer/blob/73813fb69d980a33bc710ad5575e7998676252cc/Sourcefiles/TokenizerSrc.c) &amp;#x200B;
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [AntonioBohne/KiwiLexer/.../**TokenizerSrc.c** (master → deb8fb7)](https://github.com/AntonioBohne/KiwiLexer/blob/deb8fb79dba1fe9c0a52d4095edb327fad278685/Sourcefiles/TokenizerSrc.c) ---- 
Adding on to henry_kr's answers for your questions: It is important to understand that C is a weakly typed language, which basically means that the type system is frequently ignored or not considered by the compiler for many cases. Once you're used to this behavior, you will appreciate it. In general, thinking about types when programming in C is counter productive. You should think about types as [syntactic sugar](https://en.wikipedia.org/wiki/Syntactic_sugar) to make your code shorter. Unlike in other langauges, the C compiler does not perform any type checking beyond the most trivial cases. Your thinking that if you are able to assign one variable to another, then those variables must have the same type, is not correct. C has a lot of 'automatic type coercion' and 'type promotion` rules, so you can do things like `int n = 5.0;`, `int d = 5.0; int n = d;`, `unsigned u = 5; int n = u;`, and `double d = 5.0; int *n = &amp;d;`. If you turn on [all warnings](https://stackoverflow.com/questions/11714827/how-to-turn-on-literally-all-of-gccs-warnings), you'll hopefully get warnings for most of these cases from the compiler. By the way, you can do stuff like storing a value as an address. `int n = 0x123; int *adr = n;` Now `adr` is the address `0x123` and `*adr` will retrieve `sizeof(int)` number of bytes from that address.
**Syntactic sugar** In computer science, syntactic sugar is syntax within a programming language that is designed to make things easier to read or to express. It makes the language "sweeter" for human use: things can be expressed more clearly, more concisely, or in an alternative style that some may prefer. For example, many programming languages provide special syntax for referencing and updating array elements. Abstractly, an array reference is a procedure of two arguments: an array and a subscript vector, which could be expressed as get_array(Array, vector(i,j)). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Frist, &amp;operator is used to get the address of variable, scanf needs a address as parameter.So you have to give it &amp;variable_name. however, printf needs string constant .
I came across some recently, they're still debating converting that codebase to 64 bit...
No one is gonna do your homework for you cheter
well you have to understand that the array of char* pointers also takes up memory in the first case you have 16 bytes per word and 24 bytes per token in the second case you have 16 bytes (cause of structure packing alignment) + 8 bytes = 24 bytes per word, and 12 bytes per token so the second case does use more memory just cause of that array of pointers
I'm sorry I don't know.
perhaps realloc is preallocating a couple pages worth of extra memory in advance so it doesn't fragmentate the memory when you resize it. no idea if that's supposed to show up on valgrind's report or not though. I would probably test with way more tokens, or see if ```busybox time -v ./myprogram``` gives the same result in maximum resident memory
Look it up and you will have your answer as to how it is stored in physical memory. It will be encoded as a signed integer (typically 2's complement) Being a multi byte value it's bytes will be stored according to the endian-ness of your system. 
on a little endian system (most modern desktop cpu's) it would be 00 FF 00 00 on a big endian system it would be 00 00 FF 00 you can print it out like so ``` void dumpmem(void* data, int size) { int i; unsigned char* b = data; for (i = 0; i &lt; size; ++i) { printf("%02X ", b[i]); } puts(""); } int x = 0xFF00; dumpmem(&amp;x, sizeof(x)); ```
Unless spesifically requested, looking at program contents is better done from command line or your development environment. objdump might help if you are on Unix.
There's a problen in getPaid(), don't zero the pointers, but the value they point to.
Use strchr for the newline and zero it out. Note that there might be cases where there is no \\n at the end.
To be able to handle the data, you need an amount of pointers. Law of nature. Roughly the same amount, no matter if the pointers are scattered down the list, or grouped together in the array. Actually, the array itself also needs space, so ... &amp;#x200B; Somehow this idea feels really ... 'ticklish'. &amp;#x200B; btw: check out strdup()
This proposal isn't actually about exceptions, it's about supporting an implicit error return without exceptions. Read again.
Hey thanks a lot! This worked perfectly. 
&gt; If a hosted system cares enough to implement standard C, there is no point why it should not provide a POSIX interface. Unless I remember completely wrong, pthreads design makes assumptions that require Windows implementations (as just one example) to jump through insane hooks. Another case would be many embedded systems using RTOS where requiring posix quirks would not be desirable. I can see the utility in providing a standard subset of threading functionality but lets please not marry it to the quirks of Posix threads.
&gt; Unless I remember completely wrong, pthreads design makes assumptions that require Windows implementations (as just one example) to jump through insane hooks. Another case would be many embedded systems using RTOS where requiring posix quirks would not be desirable. Which assumptions do you mean? &gt; I can see the utility in providing a standard subset of threading functionality but lets please not marry it to the quirks of Posix threads. I do see the value in this, but which quirks exactly do you want to avoid?
Show us your code and tell what the problem is. If you don't have the code, do something first. We really should not do your homework. 
This is not how "strings" work in C. You need to allocate space for your char pointers, like "char *unite = malloc(40)". Then print to it like "sprintf(unite,"%s", "I")". It's also good practice to free allocated memory once you don't need it, like "free(unite)".
The sample shown here is incomplete. It doesn't say what values appear in un/di/ce/mi. Please show how the function is invoked. Also, you don't assign const to non const. You've declared char *, but are assigning const char * to it.
The values that appear in un can range from 0 to 9, di from 0 to 9, ce from 0 to 9 and mi from 0 to 3. &amp;#x200B; What do you mean I am assigning const char \* ? &amp;#x200B; Thank you for you answer !
Hey using yours I was able to see exactly what I wanted. Thanks so much! #include&lt;stdio.h&gt; void dumpmem(void* data, int size) { int i; unsigned char* b = data; for (i = 0; i &lt; size; ++i) { printf("%p: %02X\n", &amp;b[i],b[i]); } } int main() { int x = 0xFF00; dumpmem(&amp;x, sizeof(x)); return 0; } 
You dont have a default case in the switches. If your function arguments are not right, the uninitialized strings show junk from the stack. The garbage values look like they came from stack (return addresses from previous calls). Check out how you call the romtoara() function. You could add default: abort(); to each switch, no harm playing safe.
As long as they are not trying to modify the strings, why would that be a problem? Also why use malloc here when you know the max size beforehand, rather than an array?
I am 100% sure the values in un/di/de/mi are what is expected. I put these variables on watch and they always have the value I want. &amp;#x200B; I'm a beginner, I don't know what compiling with this does or how to do it, I'm sorryy
the problem with the array is that the switch case won't let me modify an array.
I don't follow. As for the second question, agreed, but as pointers were used in original code I've wanted to be consistent.
This is C language right? You know how to watch variables in GDB but don't know how to change compiler arguments? Interesting.. :) I'll try the program in a while and get back.
you need tab\[4\]. 4 values.
Yeh you can %p and give it void pointers
Here we go: monkey@meatbeater-vm b&gt; gcc -std=c99 -pedantic -Wall -Wextra -Wformat=2 -Wswitch-default -Wcast-align -Wpointer-arith -Wbad-function-cast -Wstrict-prototypes -Winline -Wundef -Wnested-externs -Wcast-qual -Wshadow -Wwrite-strings -Wconversion -Wunreachable-code -Wstrict-aliasing=2 test.c monkey@meatbeater-vm b&gt; ./a.out Veuillez saisir un nombre en chiffres arabes 28 (null) - CC - (null) - (null)% See? There are som uninitialised values appearing inside?
I guess your logic is faulty. See the corrected version (mostly) below. I changed the order in which tab[] is applied to arguments. But the logic itself is inherently flawed. You should probably rework the logic itself. That said, this is how I compiled: ``` gcc -std=c99 -pedantic -Wall -Wextra -Wformat=2 -Wswitch-default -Wcast-align -Wpointer-arith -Wbad-function-cast -Wstrict-prototypes -Winline -Wundef -Wnested-externs -Wcast-qual -Wshadow -Wwrite-strings -Wconversion -Wunreachable-code -Wstrict-aliasing=2 test.c ``` Where `test.c` contains: ``` #include &lt;stdio.h&gt; static void romtoara(int un,int di,int ce,int mi) { int lg; const char *unite; const char *diz; const char *cent; const char *mil; int cpt; lg = 3; printf("un = %d, di = %d, ce = %d, mi = %d\n", un, di, ce, mi); for (cpt = lg; cpt &gt;= 0; --cpt) { if (cpt == lg) { switch (un) { case 1 : unite="I"; break; case 2 : unite="II"; break; case 3 : unite="III"; break; case 4 : unite="IV"; break; case 5 : unite="V"; break; case 6 : unite="VI"; break; case 7 : unite="VII"; break; case 8 : unite="VIII"; break; case 9 : unite="IX"; break; default: unite=""; break; } } else if (cpt==lg - 1) { switch (di) { case 1 : diz="X"; break; case 2 : diz="XX"; break; case 3 : diz="XXX"; break; case 4 : diz="XL"; break; case 5 : diz="L"; break; case 6 : diz="LX"; break; case 7 : diz="LXX"; break; case 8 : diz="LXXX"; break; case 9 : diz="XC"; break; default: diz=""; break; } } else if (cpt==lg-2) { switch (ce) { case 1 : cent="C"; break; case 2 : cent="CC"; break; case 3 : cent="CCC"; break; case 4 : cent="CD"; break; case 5 : cent="D"; break; case 6 : cent="DC"; break; case 7 : cent="DCC"; break; case 8 : cent="DCCC"; break; case 9 : cent="CM"; break; default: cent=""; break; } } else if (cpt==lg - 3) { switch (mi) { case 1 : mil="M"; break; case 2 : mil="MM"; break; case 3 : mil="MMM"; break; default: mil=""; break; } } } printf("%s%s%s%s", mil, cent, diz, unite); } int main(void) { int nombre; int tab[3]; do { printf("Veuillez saisir un nombre en chiffres arabes\n"); scanf("%d",&amp;nombre); } while ((nombre&gt;3999)||(nombre&lt;0)); tab[0] = nombre / 1000; tab[1] = (nombre % 1000)/100; tab[2] = ((nombre % 1000)%100)/10; tab[3] = (((nombre % 1000)%100)%10)/1; int un = tab[3]; int di = tab[2]; int ce = tab[1]; int mi = tab[0]; romtoara(un,di,ce,mi); return 0; } ```
`-traditional` is about the preprocessor. It doesn't change what the compiler does at all. Its main use is to preprocess assembly files where ANSI C's stricter tokenisation rules break macro expansions (or so I have heard).
All Intel and AMD CPUs are little-endian.
You mean instead of the (null)s ? 
Yep. You're seeing nulls because it's not being set to some value. Did you see my other comment? It's been fixed (mostly) but I think you may have to rework your logic a bit.
&gt; (BTW, you should learn the habit of writing `type *name` instead of `type* name`.) Why is this preferable?
Woah thanks for this it looks really good. Well edited, good production. Im also on a software engineering on college.
cpt is an unsigned integer. the loop condition is &gt;= 0. that means the loop never exits because when cpt is 0 it's gonna decrement, underflow and wrap around to 0xFFFFFFFF. either change it to just int (not unsigned) or change the way your loop works
GTK is the way to go for you, there is also QT out there, but its only for C++
Because typing `type* name` suggests that `*` modifies `type` when in fact it modifies `name`. This leads to the very common beginner's mistake of thinking that `type* foo, bar` defines two pointers, when in fact it defines one pointer and one object. It is much harder to make that mistake when you write it as `type *foo, bar`.
It's not, it's just people trying to enforce their style on others. (Yes we all know that you can have multiple declarators in a declaration). 
Good luck with that, pretty much every style guide in the world disagrees with you.
I'd say the majority of undefined behavior issues could be solved simply by changing the majority of undefined behavior to be unspecified or implementation defined instead.
A quick survey: [Kernel Normal Form](https://en.wikipedia.org/wiki/Kernel_Normal_Form), the original CSRG style guide still used by Solaris, [\*BSD](https://www.freebsd.org/cgi/man.cgi?query=style&amp;sektion=9) and a shitload of F/OSS projects. [NASA C Style Guide](http://homepages.inf.ed.ac.uk/dts/pm/Papers/nasa-c-style.pdf) §6.5 [Indian Hill](https://www.doc.ic.ac.uk/lab/cplus/cstyle.html#N10180) The [GNU Coding Standards](https://www.gnu.org/prep/standards/html_node/Formatting.html#Formatting), the [SEI CERT C Coding Standard](https://wiki.sei.cmu.edu/confluence/display/c/SEI+CERT+C+Coding+Standard), and [Google's C++ coding standard](https://google.github.io/styleguide/cppguide.html) do not mention it but use `type *name` consistently in code examples. ...not to mention the C standard itself.
Thanks
I would normally suggest the opposite. In C, unsigned integers have defined overflow semantics while signed numbers don’t. Because of this the for loop can be guaranteed to run ‘i’ times rather than worrying about overflow of an int is used
As I wrote above, you can eliminate `i` entirely.
Do not spam.
Your post got caught in our spam filter. I apologize for the inconvenience.
looks hard to use
That would make sense. I tested it with more tokens and the difference was less, but there was still some difference. The difference is biggest when the tokens are smaller. In one case with just one token the LinkedLists used only 400 bytes but the arrays used 800. Ill look into what you said, thanks.
The big question with tests is what's considered "good enough" test coverage? If _everything_ needs to be tested, you could easily spend years writing test cases for a project that would otherwise be a few months.
I think the authors of the Standard intended that the CIS guarantees would make it possible to write code which could operate on CIS members of structures without having to know the structures' exact types, but gcc and clang don't see it that way. As for the integer overflow, such constructs will *usually* work, but if the gcc's optimizer sees a something like `mul_mod_65535(65535,x)` [name should have been "mod_65536"], it may use the fact that overflow is UB to make infer that `x` can't possibly exceed 32768, thus causing calling code to malfunction if `x` could reach that value. If it sees that `x` will always be above 32768, it will squawk, but in some cases where `x` would be at least 32768 it will silently assume that it is always 32768. 
As I'm currently writing tests for the code I'm working on, I'll explain my general approach: 1. Cover the base use case. This also serves as a simple example for basic documentation purposes. It also shows what you think should happen normally. 2. Check the really easy misuses of the API. If you expect your code to be able to handle a null pointer as an input, test that. Zero length strings? Check that. Basically, every promise your API is making about the interface that you can check. 3. Then, that's it. There will be lots of other cases you don't end up covering. As bugs come up that point to it being a problem, add in a unit test to exercise that and show the bug is fixed. Leave it in to help look for regressions. &amp;#x200B; That's about it. You can even start with just bullet one above. 
That's usually what the interrupt signal is meant for, usually triggered with Ctrl+C. If you want to have it triggered the way you described it you could have a thread read standard input and exit on a match.
`exit(1)`
use a stop flag and set it to 1 when user types. The main while loop for your program is conditioned on this stop flag. also, you could just use a break statement `int stop_flag = 0; while (stop_flag == 0){ if (input == 'STOP') stop_flag = 1; }`
And I put my code inside the while ? And sorry for dumb question but if my code is after the if input stop does it still take it in count ?
yes put the code in the while loop. And yes, code below the `stop_flag=1` will still execute. If you were to use a "break" statement instead, it would close out of the while loop immediately without executing the code below it.
Okay !! Thank you very much for your help, I will try this right now. Thanks again
Note that this is pseudo-code. Only take inspiration from the logic and then implement this yourself.
i like to use int everywhere for simplicity. I'm aware size_t could overflow int but I prefer just the consistency of having int everywhere. also I used to write ```type *``` but I like how ```type*``` looks better yeah, you could increment a char pointer but you'd still have to have either an index to count the number of bytes left or another pointer to the end of the data, so the code wouldn't be any shorter
&gt; you could increment a char pointer but you'd still have to have either an index to count the number of bytes left Just decrement `size`.
Check out signal handling on any online tutorial. It will help you. 
Really? I have a program (I did not write) that compiles and runs on 32-bit systems, but will immediately crash on a 64-bit system. Why? Because the code was never "modernized" and assumes ints and longs and pointers are all 32-bits and completely interchangeable. A shame really, because it's a semi-decent gopher browser.
So you still use `gets()`? 
I don't use it, but programs that do better still compile. I don't want to dive into the millions of lines of code on my computer to do stupid maintenance fixes. Though `gets()` is a bit of an exception as it's an actual security problem. K&amp;R prototypes on the other hand are not.
So are you going to revisit the program and fix it? I think that as long as the program compiles now on one platform, it should indefinitely compile on that platform, even if the compiler adopts a new language revision. That doesn't mean that I intentionally write unportable code and if something is deprecated, I generally don't use it. That said, one the project is done and works, I really don't want to be obliged to change it every five years because some people decided to change the language it is written in. Bar bugs in the code, I want an environment where I never ever have to touch the code again to compile it with future versions of the language.
I mean, they've come out and said they'd support C11 ["Full C11 conformance is on our roadmap, and updating the preprocessor is just the first step in that process. The C11 _Generic feature is not actually part of the preprocessor, so it has not yet been implemented. When implemented I expect the feature to work independent of if the traditional or updated preprocessor logic is used."](https://blogs.msdn.microsoft.com/vcblog/2018/07/06/msvc-preprocessor-progress-towards-conformance/) So I don't see why they wouldn't, they support C++'s threads, why not C's?
Why not just use the regular control+c/control+z signals? you don't even need to do anything special to handle them, the OS does it for you...
I would consider K&amp;R style prototypes a security problem as they prevent the compiler from doing proper type-checking of parameters. 
&gt; old codebases would set their standard as -std=k&amp;r, and it would still work. Old code bases use complicated build systems nobody understands. Changing even one flag is typically at least half an hour of work, more if you want to make sure that you didn't break anything in the process. All of this is time I could have used to be productive instead. &gt; Really it just makes it easier to get errors on recent standards to change the interface. What stops you from enabling special fancy-pants diagnostics if you want the compiler to complain about valid and correct code? &gt; the API and ABI would remain the same (at least, I don't see why not...) Yes, likely; but that's besides the point. If my code is suddenly invalid even though it was correct and working yesterday, the people who revised the language did something terribly wrong.
So then, why don't they come out to support pthreads or even all of POSIX? Also, with respect to Microsoft I don't trust this before I see it before my eyes. I mean, Microsoft proposed Annex K and not even their own shitty implementation follows their specification in any way.
My workflow 99% of the time involves opening Xcode, and doing whatever I needed to do in there. Tho sometimes (for HUGE files, like almost 200 megabyte text files) I'll open less, or do some basic editing in nano or whatever.
Compilers can do so. It's just that the gcc people didn't feel like implementing that. Clang can do it just fine for example. Security problem means “code is vulnerable if you use this,” not “it is slightly less difficult to write vulnerable code” by the way. So no, K&amp;R declarations (which are the absence of prototypes) are not a security problem, though I agree that not using prototypes makes it slightly harder to write good code. Now, how many bugs do you think I'm going to introduce by adding prototypes to a 50 kLOC application that I'm not (or no longer) familiar with? Who is going to pay me for this time the C language committee stole from me by breaking my code?
The problem description provided does not include the environment the program will be running in. I see at least three different assumptions being made. OP, where is this program going to run?
Well, that the program compiles on 64-bit systems, but crashes hard. I would consider a bug, but from what you wrote, it compiles, ship it! And I've been slowly (past few years) working on it as the mood strikes me. First task is to get it to compile cleanly sans warnings. I'm still working on it, and I've already fixed a ton of bugs in the code just due to that. And yes, I replaced all the K&amp;R style prototypes which alone fixed several bugs. 
Okay, so slap a "use only C89 or prior to compile this crap" to the program. Or, add prototypes and possibly find bugs in the process. It's not hard, just a bit tedious. And yes, I've added prototypes to a program in excess of 150 kLOC that I was completely unfamiliar with. Found bugs too. 
&gt; I'm aware size_t could overflow int and all that jazz What is this about? thanks 
Under C89, the behavior of `signedIntValue&lt;&lt;valueBelowBitsize` was unambiguously defined for any `signedIntValue` on all platforms whose signed and unsigned integer types did not have padding bits or trap representations, and on two's-complement systems the behavior was useful and logical in all cases where the result would be equivalent to multiplication by a power of two. Systems with padding bits, however, or that don't use two's-complement format, could have benefited from being able to do something else, and left-shifts of negative values were changed to UB to accommodate such systems. While C99 and C11 don't require that systems where the old behavior was useful and logical must continue processing left-shifts that same way, I think that's because it would have been awkward to describe the action as defined on some systems but undefined on others, and because they expected that in cases where there is an obvious useful way to process an action, and no good reason to do otherwise, compiler writers would process the action in useful fashion whether or not the Standard mandated it. I think it should be noted that C++ treats UB in expressions in a fashion fundamentally differently from C++. In C, an implementation may be required to issue a diagnostic if a constant expression invokes UB (e.g. by computing `-1&lt;&lt;2`) but would be allowed to treat the expression as yielding -4. In C++, if there is a template whose first-choice expansion would compute -1&lt;&lt;2, but whose second-choice expansion would not, the Standard would require that the compiler use the second-choice expansion; treating `-1&lt;&lt;2` as -4 would be forbidden. If the C Standard were to add some long-overdue language describing the Spirit of C and indicating that quality implementations intended for various purposes should uphold the Spirit of C in a fashion appropriate to those purposes, rather than relegating such concepts to the Rationale, there would be no particular need to mandate the corner-case behaviors of left-shifts. In C++, making the 1&lt;&lt;31 case not be UB was necessary to *allow* implementations to accept such expressions in templates, but if compilers try to process things usefully absent a reason to do otherwise, that would be sufficient for C. 
int is 32-bit and signed, size_t is unsigned and can be 64-bit for example on 64-bit system so if theoretically you try to call that function with a type that's bigger than 2147483647 bytes (0x7FFFFFFF bytes) you would overflow int and it would wrap around to incorrect values, potentially negative too. we're being very pedantic here though, you aren't gonna dumpmem on a 2 gb struct/array
they mean something like this ``` void dumpmem(void* data, int size) { unsigned char* b = data; for (; size &gt; 0; --size) { printf("%02X ", *b++); } puts(""); } ``` I don't like this though, it's less readable for me and overall looks worse
&gt; the C standard itself. Oh that thing .. let's just ignore that thing :-) Nice list and well said and thank you for the list too ! 
That approach works if you’re writing trivial CRUD code or simple functions. As soon as you have anything more complicated and stateful it gets really time consuming to write the tests and to even figure out what combinations you need to test (”base use case” is no longer trivially clear).
Where is your code?
Both divide and mod are killer for performance, multiplications and power of 2 sizes and then masking off the top bits is what you want.
My hash table is 10,000 buckets, there is no resizing. Reading in the words and inserting them into the table is what takes 4 seconds. The max collision is 1100 in one bucket. 
Hi supercat In C++ a diagnostic for UB in constant expressions is only required if the expression is used in a context where a constant expression is required. E.g. `int x = 1 / 0;` does not require diagnostic, but `constexpr int y = 1/0;` and `int z[1/0];` do. 
Way too many collisions to be honest. Ideally you should have 400000 buckets for 400000 words. So 1:1. Otherwise the lookup function wont be O(1), but O(1+ #words/#buckets). "For open addressing schemes, the hash function should also avoid clustering, the mapping of two or more keys to consecutive slots. Such clustering may cause the lookup cost to skyrocket, even if the load factor is low and collisions are infrequent. The popular multiplicative hash is claimed to have particularly poor clustering behavior." (Wikipedia/Hash Table) Since you know everything about your data, use: https://en.m.wikipedia.org/wiki/Perfect_hash_function 
**Perfect hash function** In computer science, a perfect hash function for a set S is a hash function that maps distinct elements in S to a set of integers, with no collisions. In mathematical terms, it is an injective function. Perfect hash functions may be used to implement a lookup table with constant worst-case access time. A perfect hash function has many of the same applications as other hash functions, but with the advantage that no collision resolution has to be implemented. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I'm stuck with the idea how to proceed with implementing semaphores. Give me opinion on what I described up there 
Don't worry about solving a problem in the smallest number of codes - it is much more important to write straight-forward, simple &amp; readable code. Simple code is more likely to be correct and easier to debug. When I am not sure of how to solve a problem, I will start with the simplest working program then add features one at a time (testing as I go) until I have the problem solved. All programs take input, do some kind of processing, then produce output. This being the case, start with a program that reads the input, then just prints it out. Then modify that program to calculate the sum of the input and so on. 
no sauce?
On some non-Unix implementations, there may be a limit as to the maximum number of characters that `gets()` could possibly receive, generally with characters beyond that being ignored. If the size of a buffer exceeds the maximum number of characters that could be received on the target platform, then `gets()` could be safely used on that platform. Further, some non-Unix platforms have a concept of "receive a line from the console" which is different from "read data from the console as a stream until a newline is received". For example, some systems may process stream data in a fashion equivalent to Unix "raw" mode, but have a get-line function which buffers input until the return key is pressed, and which supports backspace. Using `gets()` with a buffer of platform-specific size would be icky, but the closest equivalent, `fgets()`, is icky on the programming side and on some platforms is icky on the UI side as well. While non-bounded `gets()` should have been deprecated and removed ages ago, it should have been deprecated by the introduction of a proper replacement--something that never happened. 
The wrong pointer is tested in the loop condition. The pointer to the previous node needs to be stepped in the loop. The value comparison goes the wrong way, you want to insert at the point where `temp-&gt;value` is larger than `newItem`. What happens when `newItem` is larger than all values in the list?
That would only work in the main loop of the program and only if input was being read. OP wants to be able to stop the program anywhere - even if it is in a subroutine. 
Others have already suggested interrupts, so I will suggest using a event loop such as [libevent](https://libevent.org/) or [libuv](https://libuv.org/) as another possible way to accomplish this. 
That scanf syntax is listed here: - https://www.quora.com/What-is-meaning-of-*-n-*c-while-using-scanf-in-c - https://stackoverflow.com/questions/30065675/what-does-scanf-nc-mean Why not just use `scanf("%s", file_path);`?
The filepath variable must be an allocated pointer. Right now it is pointing to nothing. Either you allocate the space using a malloc, or create an array.
1. This is off topic. 2. This is lazy.
This subreddit is about the C programming language. As your post is not related to C, it is off topic in and I have removed it.
Please never post pictures of code. See also: http://idownvotedbecau.se/imagesofcode.
Thank you for patiently explaining all of that for me.
Yes, please upload the code to Gist or similar code snippet sharing services. But by the hearing of your description it sounds like a scope problem. Try passing double pointer to functions and dereference inside them.
Ok, here it is. sorry for the mess, it's why I'm trying to put everything into functions. https://gist.github.com/sounderdsic/0d938b42b99825d06db45975e09c66f8
Yup, so basically, whenever you call those functions with `ifp`, actually the exact copy of that pointer’s value is sent to the function, not the pointer itself. Inside a function, you are dealing a copy of `ifp` not the original `ifp` declared in `main()` so any change is not reflected back to the one in `main()`. This is because fundamentally in C everything is call-by-value; there is no such thing as call-by-reference in reality. An ugly yet simple solution is to pass double pointer to your functions: `func_name(..., FILE ** fpp, ...)`. Then inside those functions, dereference `fpp` whenever you need to use the pointer, whether it be opening a file, reading/writing from/to the file, or closing the file: `*fpp = fopen(...);`.
Yeah, that's the problem. You haven't tried anything. You have a string. It has a newline character at the end. Try to remove that newline character so you can print the string.
Dude, I've literally tried everything within my power. I started learning C, 3 days ago I dont know how to do shit. Are you going to help and tell me how to fix it which is what I intended with this post or what.
&gt; it's less readable for me and overall looks worse Well, you could start by actually implementing the same thing as the original code: for (unsigned char *b = data; size &gt; 0; --size, ++b) printf("%p: %c\n", b, *b); or unsigned char *b = data; while (size) { printf("%p: %c\n", b, *b); --size; ++b; } 
&gt; Someone else must not have liked not being the smartest kid in the room It's not the first time. Some people get unreasonably angry when you point out that `type* name` is a bad idea and contrary to established practice.
I DONT KNOW HOW
A better solution is to have `openFile()` return the `FILE` pointer.
Don't you have a textbook that teaches you about strings? Here's one possible solution: for (char *p = lang; *p != '\0'; ++p) { if (*p == '\n') { *p = '\0'; break; } } This may be simpler to understand if you aren't comfortable with pointers yet: for (int i = 0; lang[i] != '\0'; ++i) { if (lang[i] == '\n') { lang[i] = '\0'; break; } } 
Don't be too fancy, just iterate one element at a time and turn up your compiler's optimization settings to let it do any unrolling or vectorization. In the case of gcc and clang, the appropriate `-march=XXXX` option will let it chose the best SIMD operations supported by your CPU (SSE2, AVX, etc.). Using OpenMP's [simd pragma](https://bisqwit.iki.fi/story/howto/openmp/#SimdConstructOpenmp%204%200) to give hints if needed is an option, though... double sum = 0.0; #pragma omp simd reduction(+:sum) for (int i = 0; i &lt; 1000000; i += 1) { sum += array[i]; } 
Thank you for your response. I need to clarify, this is for a class. The goal for this assignment is to learn how program efficient, and so using the compliers optimization is not allowed.
Looks pretty good - I can imagine in a real world situation that you'd also want to possibly change where log messages are printed. `stderr` is great, but what if I wanted to pipe to a file? You could consider that as an additional feature you could add. Also, I'd recommend wrapping your `__LOG_COLOR` macro in a `do { ... } while (0);` block. Consider too that when you use `__LINE__` in `__LOG_COLOR`, the line it'll print is the line of the `fprintf` statement, not the line where `__LOG_COLOR` was called.
For the most efficient solution n would need to be as big as the length of your array, since then there is not a single instruction used to jump back to the beginning. That, of course is not viable and bothersome to type. Id probably go for n=10 or something like that (choose something that divides the length of the array without any remainder). If you want to get really fancy you could use multiple threads to calculate sub-sums of equally sized chunks of the array. Then, in the end you just need to sum up, say 8 different values.
Your assignment is to find the optimal value for n? Can't you just try it with a bunch of different n values and time it?
A fundamental problem with the Standards process is that the authors of the Standard are unwilling to recognize that the reason a lot of code is prone to malfunction when processed by gcc/clang optimizers is that every version of the Standard to date has relied upon compilers to understand the Spirit of C described in the Rationale document (see http://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf on numbered page 3 after the table of contents) but the authors of gcc and clang willfully ignore that. If an implementation intended to be suitable for certain kinds of tasks can cheaply support behaviors that would be useful for those tasks, it should do so regardless of whether the Standard requires it. If a a behavior would be cheap on most platforms, and useful for many tasks, but an implementation targets a platform where support would be expensive and is intended for purposes where such support wouldn't really be useful, however, the Standard shouldn't require it. Unless the authors of the Standard were lying, they did not intend that the Standard be used as justification to require programmers to jump through hoops to work around implementations' failure to support features that they could have supported cheaply but decided not to. 
Loop unrolling will be beneficial, but your best bet is to use SIMD operations.
The most optimal N is that which allows you to keep all the instructions + the loop branching inside the instruction cache. Thus your unrolled loop won't have cache misses on the instructions and you reduce your branching factor. To figure out how big that is, you need to find your cpu's L1 instruction cache, figure out how big in size is sum+=array+i and the branching comparison/ops are after they get compiled and linked. Subtract the size of branching from the size of instruction cache, divide the remainder with the size of `sum+=array+i`.
The correct idiom is `do { /* ... */ } while (0)` *without* a semicolon. Consider the following code: if (foo) if (bar) MY_MACRO(); else something(); If you include a semicolon in the definition of `MY_MACRO`, the compiler will see two semicolons and will attach the `else` to the outer `if` rather than the inner `if`.
&gt; Why is everything a macro? Why not? &gt; Where's the actual implementation? In the macros.
Ah yep - sorry, typed quick.
Basically, macros have useful metadata like the line number and function, and more or less just generate the fprintf code as one line where you use the macro. I'm not particularly good at c but I know macros well from c++.
&gt; For the most efficient solution (in terms of speed) n would need to be as big as the length of your array, There is a balance to be struck between reducing the number of branches and keeping the code small enough to fit within a) the instruction cache and b) the CPU's instruction planner / predictor window. That balance will vary from one CPU to another, but in practice, 8 to 16 operations per loop seems a good compromise.
The line numbers should actually be all from the line number the macro is called on because the macro is all one line. The suggestions are good though I'll add those.
Oh shit yeah, I've made two dumb mistakes there 😂. 
What is it supposed to do, and what does it do instead? (and can you please fix the indentation?)
It's supposed to arrange numbers in ascending and descending order, it executes but when I enter the numbers it just shows a bunch of zeros and ones all over the screen.
Check the last for loop.
Thank you!!!!!
Clever scanf-format.
and that's why i never use for without brackets 
It would be cool if you could configure a different logging level for different source files, and for different segments of code. That would require a preprocessor like `m4` or using a CPP library like `BoostPP`.
Right now actually everything is per file, so far I've only had to use it for up to 3 files at a time. I'll look into m4 I've never heard of it.
You could also multithread the operation, have n threads, and add the 100,000/n elements per thread, then add them at the end.
Start with `yum install clang` (for [the Clang compiler](https://en.wikipedia.org/wiki/Clang)) or `yum install gcc` (for [the GCC compiler](https://en.wikipedia.org/wiki/GNU_Compiler_Collection)). What more you'll need to install is dependent on the sort of C programs you're wanting to write, as specific programs will need specific packages of C headers. 
The design of printf is effective at minimizing compiler complexity. That's about the only thing it really has going for it. If printf can chain to a function built into the OS, its code-size cost may not be an issue, but for stand-alone programs, it's unnecessarily bloated, not particularly fast, and not nearly as nice as what a language could offer with a small amount of additional compiler logic. While the "old C" approach to variadic arguments kinda sorta worked, a type-safe approach would be able to achieve code-space efficiency that was as good or better in many cases by passing a pointer to a sequence of bytes that describes the arguments' types and where they may be found. For the common cases of passing an argument which is in a caller's stack frame or at a static address, having the argument descriptor encode an absolute or stack-relative address would avoid the need to have the caller fetch and push the argument. Further, floating-point arguments could be formatted directly without requiring a conversion through `double`. This extra type safety would require a little extra compiler complexity, but the run-time cost could actually be below that of "printf". 
If you are Windows, you with need Msys2/mingw for GTK+, if you haven't set that up already. You could probably then use Glade to design the GUI...
Funny problem. I tried it on an old Intel i5, clang, no compiler flags at all, and 100 times the 100'000 loop unrolled (n = 1) took 0.026 seconds. 100 times the loop with n = 2 took just under 0.023 seconds and then for n = 3 ... 999 veeery little increase in time to just above 0.023. All very unscientific, but results don't change much when run is repeated. VERY shallow optimum, hard to see from the noise, at around n = 30...40. With cc -O2, hmm... compiling 1000 programs starts to take some time... Same pattern. n = 1: 0.0078 seconds, n = 2: 0.0060, n = 3: 0.0046 and finally 0.0053 at 999. Also shallow optimum 0.0044 seconds at around n = 30...40. &amp;#x200B; Just a datapoint.
1000 of these were used #include &lt;sys/time.h&gt; #include &lt;time.h&gt; #include &lt;stdio.h&gt; struct timespec a, b; int v[102000], sum; int main() { int i,j; clock_gettime(CLOCK_MONOTONIC, &amp;b); for (j = 0; j &lt; 100; ++j) for (i = 0; i &lt; 100000; i += 2) { sum += v[i + 0]; sum += v[i + 1]; } clock_gettime(CLOCK_MONOTONIC, &amp;a); a.tv_sec-=b.tv_sec;a.tv_nsec-=b.tv_nsec; if(a.tv_nsec&lt;0){a.tv_sec--;a.tv_nsec+=1000000000;} printf("%d.%09ld\n", a.tv_sec, a.tv_nsec); } &amp;#x200B;
I just decided to learn `m4` the other day. Here's a project I did in it: https://github.com/okovko/m4_x_macros
A problem you may have is numerical stability if the array is sorted from biggest to smallest. Also, you may want to check what is the real type of the data (is the problem specifying doubles, not floats? are they in a specific range?) Apart from that, on the optimisation side, the most important is probably to split the array in as many subarrays as you have physical CPUs and multithread the adds and add results together. Using logical cores may interfere with the next step of optimisation. Then, in each singlethread add, you will want to used simd instructions for the additions. You may have access to them via [intrisics](https://www.codeproject.com/Articles/874396/Crunching-Numbers-with-AVX-and-AVX), full list [here](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#). At this point, you may try loop unrolling. Of course, if you do loop unrolling, you [have to use a Duff device](https://en.wikipedia.org/wiki/Duff%27s_device) which is actually legal C code.
I've tried I just can't understand why you suggest these things. Why should size be capped. It's just specifying the size of an integer value which is 4 bytes on my system? What do you mean by capped? It should just print out 4 bytes. &gt;or at least to the maximum possible value of i if it is not the same type as size Why does this matter, we're only counting through a loop. An int seems perfect for this? Can you show me why this matters? &gt;You should declare size as size_t rather than int, and i as either size_t or unsigned int. I really don't get this either. What is the reason? Can you provide a concrete reason/understanding. I just do not get these recommendations. 
Find out what the corresponding package is called and install it with `yum`. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/c_programming] [Can anyone help me understand WHY each of these recommendations are made?](https://www.reddit.com/r/C_Programming/comments/9wz54x/can_anyone_help_me_understand_why_each_of_these/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Loop unrolling and prefetching are the keys for performance in such a loop. 100k doubles are 800k bytes so you can calculate if they fit in your CPUs cache. Vectoring instructions also speed up a lot.for simple loops modern compilers should be able to apply both optimizations so if you want to experiment with them "manually" make sure you compile without optimizations or that you disable relevant optimizations and/or usage of sse/avx instructions.
Sizes and array indices can never be negative, and `size_t` exists precisely for this purpose. If you mix and match types for these things, you will have to check for over- or underflow in *every single place* where you receive a value of one type but pass it on as a different type, and *every* standard C or POSIX library function that takes a size or a count uses `size_t`. By using `size_t` consistently, you move the responsibility for range checks out to the point of origin — meaning the point where the array is created or the value is read from a file or from `stdin`. There are several other types of this sort; the one you're most likely to run into is `off_t`, used for offsets, which unlike sizes can be negative. See also Hungarian notation (specifically “Systems Hungarian”, not “Apps Hungarian”) for a different expression of the same philosophy.
There are viable platforms with hosted C implementations where `int` is 16 bits wide and `size_t` is either 16 or 32 bits.
&gt; Why should size be capped. It's just specifying the size of an integer value which is 4 bytes on my system? You are writing a function to print the contents of an arbitrary region of memory in hex, one byte at a time. Why do you assume that `size` is always 4? And if that is the case, why pass the size as an argument instead of hard-coding it? What's more, that would be the point of the function when you could use a single `printf()` statement instead?
The excercise has been solved in the book "Computer Systems: A Programmers Perspective", under Optimization chapter. You can also benefit from two or four parallel sums that you sum together at the end. That said I guess the most efficient way to solve it would be to write a python script that generates you unrolls and parallelizations at demand and then you benchmark those sum1 to sum256 functions and discover which would be the most optimal *for your current processor*. It is processor and prediction and pipeline specific, sadly. Also cache specific, but I hope you'd refrain from having memory accesses all over the place. Also don't forget the -O3 option, it could make tons of difference.
Thank you! This is the worst thing about C.
The best way to program efficiently is to know when to trust in the compiler. Unless you are programming-Jesus and know your target architecture inside out, the compiler will be much much smarter than you. Of course the compiler needs to have all the same information that you have available or it will use more general techniques that might not be the fastest. In that case it helps to have a more expressive language and not ancient-as-fuck C but oftentimes there are additional compiler-specific commands to somewhat get around that.
We aren't talking about complexity here. A factor 100 speedup is still O(n). 
true! since I mostly develop for common desktop platforms I don't really spend time overthinking portability beyond x86_64 and x86, that would really take the fun away for me. but I can see these assumptions becoming a problem on some embedded platforms or retro and exotic systems.
Oh duh yeah I forgot about to include guards that was a recent addition. I feel like I'm about to get sucked into m4 it looks dope
Basically what I'm saying is that testing has a cost, you need to balance that cost with the benefit and that decision is non-trivial. Writing good interfaces makes testing easier but I'd put it instead as "writing good interfaces avoids making testing artificially harder". Worse, testing cost is made higher by test frameworks spending 90% of their effort in reporting and running tests automatically and less than 10% on making it easier to write test cases (iow, to get good coverage). To continue the sex metaphor, writing test cases is like going to see a prostitute. Maybe it's worth it, maybe not, but it _will_ cost you.
&gt; Don't do anything particularly destructive if given invalid data. This summarizes my beef with the compiler developers' language lawyering about undefined behavior. Modern compilers seem to go out of their way to explicitly do the most destructive thing they can when given invalid data. They take the logically rather insane step where they assume that "If operation X is done on value Y, Y must be in some particular range _everywhere else_." You then get insanity where int y = x*65536; ... if (x &lt; 32768) return; system("format c: /y"); gets transformed into system("format c: /y"); all in the name of vague "performance increase" (but never showing real world benchmarks). Defining integer overflow and similar things as unspecified or implementation defined would allow compilers to still choose the most optimal way to do _that operation_, but would not affect code that doesn't depend on the result.
variadic macros are only standard from C99 onwards. I usually prefer avoiding them and writing the macros in a different way, for example here's the logging function of one of my old projects: ``` /* prints "milliseconds.microseconds [file:line] message\n" */ #define logln \ log_print_header(__FILE__, __LINE__), \ log_println void log_print_header(char const* file, int line); void log_println(char* fmt, ...); ``` btw it would be nice to have at least some kind of time indication in your log so you can roughly tell how much time passed between logs i like the neatness that it's a single header and you don't have to worry about linkage but if it was me I'd give up and pull out ```__LOG_COLOR``` into a function and then add a define switch to include the implementation. but this is just cause 99% of my projects are monolithic builds where I don't have to worry about including something twice
Stderr is character buffered friend. 
I don't see the utility of checking whether or not to print function names or line numbers at build time; at runtime or at function-call-time you could at least make the argument that "I don't want this here," but at build time it doesn't really make much sense at all. Similarly, dynamically changing the log level is often hugely helpful for debugging builds; the existing work is fine for a release-type build where you can cull all of the verbose/informational logging by setting the `#define` high enough, but for debugging you very well might want to skip verbose logging up to a breakpoint, then turn logging up to its most verbose. Lastly, if the user does redirect the log output to a file, they're going to be in for a nasty surprise in the form of ANSI control characters in a text file. `isatty()` on UNIX systems can tell you if stderr is being redirected to a file.
&gt; I can see these assumptions becoming a problem on some embedded platforms or retro and exotic systems. Trust me, they will bite you even if you're only working on Intel, and “this is not a safe assumption” is much simpler than “the C standard says that this is not a safe assumption, but I think it is in this particular case at this particular time because X, Y and Z” — which inevitably comes back to haunt you in five years when X, Y and / or Z no longer applies to the latest and greatest architecture that your client wants to run your code on.
First, I agree that coverage isn't a good measure or target to strive for. Second, the moment you are interfacing with hardware, tersing gets very, very tricky. And the above method wouldn't work for that. However, large number of functions an interfaces are highly testable, even when non-trivial. Regex matchers, algorithmic logic, image processing, threading components, locking behavior, etc, are all readily testable and should be. In those cases, we're talking about a high price call girl -- certainly worth the money and fun to show off to friends. ;)
What type of codebases are you working on with that large of files? Interesting.
Use dnf to install the "Development Tools" group
you're absolutely right, if you're maintaining that kind of code it's important to do as much future/portability proofing as possible to save time later on. but that's not one of my goals nor the kind of code I strive for. that's the boring kind of code you write for work. I only write code for personal projects which I don't expect to want to reuse in a decade cause by then I'll probably want to rewrite it in a cooler way. I appreciate your knowledge on the matter (I had almost forgotten some systems can have sub-32bit int's) but I think explaining all these portability details might be too overwhelming for a beginner who just wants to poke the memory and thinker with code. it's gonna stick better if they learn with fearless experimentation.
C has three different kinds of integer types: * Signed integer types, and unsigned types *which are smaller than `int`*, are intended to behave like mathematical integers within their range. So given `numberType x=1, y=2;`, the value `x-y` will yield -1. Comparisons with other mathematical-integer types that represent numbers will work like numeric comparisons. * "Full-sized" unsigned types of n bits behave like members of an algebraic ring of integers that are congruent mod 2ⁿ. So given `ringType x==1, y=2;`, the value `x-y` will yield the largest value of `ringType`. Comparisons with negative numbers will be performed by first converting the number to the ring element which, when subtracting that number, would yield zero. So on a 32-bit machine, comparing -1000000000 to an `unsigned` value would first convert that number to 3294967296u [since =1000000000 3294967296 mod 4294967296) and compare against that. * The `_Bool` type will coerce any non-zero numeric value, including floating-point values which are smaller than 1, into the value 1, and will do likewise with any non-null pointer. This behavior is different from that of a single-bit bitfield which would convert even numbers, or floating-point values whose whole-number part is even, to zero. Personally, I'm not a fan of the type; even if a programmer knows that an object of some other integer type` will never hold any value other than zero or one, there's no clean way to store that value into a `_Bool` without forcing the compiler to generate unnecessary code to handle other values. IMHO, things which represent quantities or sizes should use mathematical integer types except in cases where the larger positive numeric range of unsigned types is required. If C had evolved to include ring types for signed values and small unsigned values, and large unsigned number types, rather than having the behavior of types like `uint16_t` vary depending upon whether `unsigned` is 16 or 32 bits, then it would make sense to use unsigned *number* types for quantities. Since it didn't, however, there's a lot to be said for using number types for most things except when the algebraic ring behavior or the extra bit of range is needed. 
If you just remove the include guards and `#define LOG_LEVEL n #include "log.h"`, can you put that anywhere and it'll work? I guess it should, although I've never actually done that before.
The reason `ptrdiff_t` and `size_t` exist is that there are some platforms which would require the use of long types to index large objects, but on many platforms the use of long types would be needlessly inefficient. The reason `size_t` is unsigned is that there used to be many platforms where the largest object size is between `INT_MAX` and `UINT_MAX` (most typically, both `int` and the contiguously-addressable portion of an address would both be 16 bits), and having the type be consistently unsigned was thought to be better than having it be signed on some platforms and unsigned on others, or requiring that 16-bit platforms either limit objects to 32,767 bytes or have `sizeof` return a `long` that would be inefficient to process. 
Your bug is almost certainly at ` n &lt;= 7 , n &gt;= m` Print out the values of `n` and `m` before the addition step. But this code is a mess; It is incredibly hard to follow. Why all the single letter variable names? And I'm sure you don't need 6 indices to loop over 2 arrays. 
n &lt;= 7 , n &gt;= m is wrong, I think. You need to use &amp;&amp; here instead of comma. Using comma, n &lt;= 7 does not affect the condition.
this fixed the segmentation error , thanks man :D.
Have you tried stepping through it with a debugger? Like gdb? You know, set the break point to where your code is trying to access the array and see what it's doing? C doesn't check array bounds so it might be a good idea to check the end points. I'm on mobile, so I haven't really looked at the logic. But if you're stuck that's my suggestion of how you could figure it yourself. Plus you'll learn a new tool. 
in your for loop: `n &lt;= 7 , n &gt;= m` i think you want &amp;&amp; instead of ,. also n starts at 7, i think you wanted 0.
To allow useful optimizations, one would have to recognize categories of behaviors which are characterized less precisely than "unspecified" or "implementation-defined" but more precisely than "undefined", and the Standard lacks the terminology that would be necessary to do that. To allow programmers and compilers to work together to generate optimal code, the Standard should recognize situations where the behaviors of the abstract and real machines may diverge, and where compilers would generally be allowed to freely choose between aspects of real machine and abstract machine behavior in arbitrary (Unspecified) fashion, but then provide ways of forcing the abstract and real machine to be synchronized at key points. For example, consider a piece of code whose behavior in non-overflow situations should be equivalent to: int z = x+y; ... operations that don't affect x, y, or z if (z &gt;= x) do_something(z,x); In many situations, it won't matter whether `do_something` gets invoked in the overflow case, and allowing compilers to arbitrarily invoke it or not could facilitate useful optimizations (e.g. simplifying the comparison to `y&gt;=0`). On the other hand, there also needs to be a way of forcing a comparison to be performed on the actual numbers that will be passed to `do_something`, e.g. int z = x+y; ... operations that don't affect x, y, or z __SOLIDIFY(z); __SOLIDIFY(x); if (z &gt;= x) do_something(z,x); Saying that `z` may have strangely after overflow unless or until it is "solidified", but solidifying it must make it behave like a number in the range INT_MIN..INT_MAX would avoid the danger of "optimizations" that would let `do_something` invoked with its first argument smaller than the second. To accommodate existing code, quality compilers should provide options to treat various constructs as forcing "solidify" operations, but reliance upon such options should be deprecated in favor of using __SOLIDIFY. Note that existing non-optimizing compilers could support code using `__SOLIDIFY` merely via `#define __SOLIDIFY(x)`, so there would be no reason for programmers--*even those targeting old compilers*--not to use `__SOLIDIFY` when appropriate. 
I think we may be talking about slightly different things. My problem with "undefined" is the compilers making (insane) inferences about the source values, not about the destination value being inconsistent. An example would be gcc outright removing a null pointer check in the Linux kernel when the pointer contents were read at a point before the check. I think a workable solution would simply be if the standard amended the definition of undefined behavior to explicitly forbid reasoning about source values based on it. IOW, "You are not allowed to assume there is no undefined behavior".
A neater version, that I think is easier to follow #include &lt;stdio.h&gt; int main(void) { #define COUNT 8 int inputs[COUNT]; int sums [COUNT]={0}; for(int i = 0 ; i &lt; COUNT ; i++ ) { scanf("%d",&amp;inputs[i]) ; } for(int sum = 0 ; sum &lt; COUNT ; sum++ ) { for(int input = 0 ; input &lt;= sum; input++) { sums[sum] += inputs[input] ; } } for(int i = 0 ; i &lt; COUNT ; i++ ) { printf("%d ",sums[i]) ; } printf("\n"); return 0 ; } 
Thank you!
Wow , this is actually very professional , thanks for your time :) .
Why not use a for loop? While (including do while) loops are for conditions that change, not values nessicarily. int CalculateShit(int Start, int Stop, int IncrementSize) { int Value = 0; for (int i = Start; i &lt; Stop; i += IncrementSize) { Value += Exp(2 * X, 4) + Exp(X, 3) + (-5 * X) - 7; } return Value; } You get the idea, I'm sure the actual body of the code is wrong, but i don't really care tbh.
This sounds actually helpful, I will make sure to use one in the future !, thanks for the suggestion .
What do you mean by "cute code"?
How could size be larger than anything an int could hold? All of the types in C are way less than 2,147,483,647 bytes.
How do you think locking should have been handled?
I'm not necessarily arguing for things to be declared non-UB. I'm arguing for the very definition of UB itself to be changed. Not being allowed to reorder floating point computations also prevents useful optimizations yet the standard doesn't just declare them associate and people use -ffast-math as the solution. I argue that a similar approach would be far more useful for UB than the current one as it would ensure sane behavior by default and only allow unsafe optimizations if explicitly enabled. I don't see how your x/y example is really relevant here. Whether x/y traps or not, the values don't change inside the loop and the computation can be hoisted outside it just by defining divide by zero as implementation defined / unspecified and the compiler simply generating whatever result from it (as long as it's not explicitly defined to trap). To reiterate my point, I'm not asking for current UB computations / access to yield sane values. I'm only asking for them to _not affect code that doesn't use the result_.
Just want to point out that if eg. B[1] is A[0] + A[1] then B[2] is B[1] + A[2], etc. 
Logging libraries are a perfect use case for macros. Disabling logging for a file? If using macros, no logging code will even be compiled in that file. I prefer it
 #include &lt;semaphore.h&gt; int sem_init(sem_t. *sem, int pshared, unsigned int value); Link with. -pthread. (sem_init())[http://man7.org/linux/man-pages/man3/sem_init.3.html]
File locking didn't exist in a uniform state, and no one really knew how remote file access was going to fall out. The only reasonable approach was to implement a set of high-level primitives with NO implementation, and allow individual platforms to define those implementation details. Instead, we got a standard library call that just assumed everyone would do the right thing with a highly constrained and simple implementation (turns out, not so much, and it was one of the largest headaches that C had in the 90s, until most people learned never to trust file locking). 
&gt;tmux so I can split my terminal screen to have vim on one side and do other stuff on the other side. (tmux is really popular from what I can tell. Before we used to use screen , but tmux is more minimal). &amp;#x200B; I'm with you and vastly prefer tmux over screen when I can. Everything feels more polished to me and it feels like it gets better support &amp;#x200B; Your last bullet seems to imply some CI it would seem, no?
RTFM
Yes you can initialize a semaphore using Sem_init(&amp;mutex,0,1) Which initializes mutex to 1. But how to initialize mutex to 0at the begening ans then signal it to one .
Yes you can initialize a semaphore using Sem_init(&amp;mutex,0,1) Which initializes mutex to 1. But how to initialize mutex to 0at the begening ans then signal it to one .
Of what failing? I am currently sitting in my office with a desktop computer and laptop which both have 16 GB of memory. In my home office, I have a laptop with 8 GB of memory, a desktop computer with 16 GB of memory and another desktop computer with 32 GB of memory. I am less than 100 yards from a data center which, among hundreds of servers, houses several machines with 1 TB of memory if not more. Any of these can easily run a program in which I define and use an array significantly larger than the largest number an `int` can hold, for instance: double bigarray[1&lt;&lt;30]; /* this is 8 GB on most 64-bit machines */ I have worked with software that generated and held multi-gigabyte data sets in memory. In at least one case, I used large arrays of structs to avoid the overhead of `malloc()` and friends.
Read their link. Set value to 0 instead of 1, if I'm understanding you correctly.
man sem_init: NAME sem_init - initialize an unnamed semaphore SYNOPSIS #include &lt;semaphore.h&gt; int sem_init(sem_t *sem, int pshared, unsigned int value); Link with -pthread. DESCRIPTION sem_init() initializes the unnamed semaphore at the address pointed to by sem. The value argument specifies the initial value for the sema‐ phore. sem_init(&amp;mutex, 0, 0)
With [`sem_post`](https://linux.die.net/man/3/sem_post).
Just Google "c++ function" and there should be a number of good tutorials to guide you through creating exactly what you are looking for. You won't improve unless you try it yourself. ;-)
c++ is off topic for this subreddit. Also, that's incredibly simple math. Literally just multiply the numbers together... int whateverthefuck(int a, int b, int c) { return 3 * (a + b + c); }
This sub is for C, not C++. You want /r/cpp_questions or /r/learnprogramming.
The Unix Programming Environment K&amp;R
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
sure, so what you would want to do here, assuming they are of type int, is the following: int returnVal(int a, int b, int c){ int sumTotal = (a+b+c); int cubedTotal = (sumTotal)\*(sumTotal)\*(sumTotal); return cubedTotal; } &amp;#x200B; So what this is saying is that the function returnVal returns an integer value, and takes as it's inputs three integers, a, b, and c. It adds them up in a local variable named sumTotal then cubes sumTotal and stores it in another local variable named cubedTotal. It returns cubedTotal. 
Read the POSIX standard. It has examples for the more difficult functions.
Fundamentally, I think the proper model for C to adopt would be to recognize the existence of many features which implementations may or may not support, and provide both compile-time tests which indicate that features are definitely supported, definitely not supported, or possibly supported, and run-time tests which can indicate whether a particular operation would be usable. Such a design would nicely accommodate programs that don't need the feature, those that cannot run meaningfully without it, and those that don't absolutely need a feature but would still benefit from it. Further, it would be useful to have the Standard take note of some constructs which various implementations handle differently, recognize the existence of code that relies upon particular behavioral variations, and recommend that people who are seeking to write quality general-purpose implementations and want to support a wide range of programs offer configuration options to support the different popular behaviors (e.g. on a platform which can't distinguish between read locks and write locks, offer options to control whether or not opening a file for read acquires a lock). Ideally the Standard would have a means of specifying "acquire this file for reading while forbidding writes if possible, or else acquire a full lock if possible, or else fail altogether" if those are the syntax a program would need. 
yeah ok, thank you dude 
not exactly, but you have the right idea. Node *node; Node = (Node *) malloc(sizeof(Node)); on second line, should be lower case node = ... Node is your structure definition name, not the variable. likewise, `Node = node-&gt;next`doesn't make sense. Node is the structure definition. Also `next` isn't defined. Instead you probably just want to set node-&gt;next to NULL, then do all of the linking in a different subroutine. 
:)
It's good practice to keep the scope of variables as small as possible. It is more readable and reduces the chance for bugs. Seeing for(int i = 0 ; i &lt; COUNT ; i++ ) { scanf("%d",&amp;inputs[i]) ; } I know what `i` is (I don't have to hunt for it) and I know it goes out of scope at the end of the loop, so nothing can depend upon its final value.
There are some kinds of actions which should be characterized as invoking UB as it's presently defined. If UB were redefined to describe the way things like integer overflow should be processed, some other term would have to be defined to cover the actions for which the current definition is suitable. Thus my call for a category of quasi-defined actions whose behavior is less strongly defined than yielding an Unspecified value, but more strongly defined than UB. I offered the `x/y` example because, on systems which trap divide overflow in hardware (IMHO a silly design, but commonplace), hoisting a division before some unrelated computations may allow a failure of the division to prevent the execution of other supposedly-unrelated computations which were supposed to have been performed before the division was attempted. 
I c - thank you! 
Yeah, I've used the gitlab integrated one or Travis for github. There's also AppVeyor for the weird folks who still use windows.
_The Unix Programming Environment_ doesn't teach C. It does, however, present some simple utility programs written in C which might be kind of thing OP is looking for. For example, it presents a small program called `vis` which does the same kind of ting as `cat -v` or `od -An -c`.
Johnson and Troan's _Linux Application Development_ is a bit dated now (though not as dated as Kernighan &amp; Pike's _The Unix Programming Environment_) but might be the kind of thing you are after. It presents a shell, built in pieces as the book progresses.
A person can write verbose, dry, methodical code that goes step through step through a process. It may be long, but it's clear what the code is doing. Conversely one could sometime write that same function in a short few handful of lines, that work and pass tests, but are way more cryptic and more difficult to understand. That's what I'm referring to as "cute code". It's the code that exists to show off how smart someone is or how much they don't really feel like writing out everything. This isn't a great example, but it's one on hand... I wrote something along these lines on a project back in the spring. I chewed on it because I found it too "cute" int retry = 4; printf("downloading"); do { rc = getThingFromServer(various, paramaters, passed); } while (printf(".") &amp;&amp; (rc == TIMEOUT || rc == BUSY || rc == NOTREADY || rc == PARTIAL_DATA) &amp;&amp; retry--); printf("\n"); It's not terribly difficult to understand really, but would it be easier to maintain if I did a `for` loop for the retries and threw in some `if` statements to check the various conditions (there were a handful more for retry, a few success, and a few failure). Something more like: int retry = 4; printf("downloading"); for (i = 0; i &lt; retry; i++) { rc = getThingFromServer(various, paramaters, passed); printf("."); if (!(rc == TIMEOUT || rc == BUSY || rc == NOTREADY || rc == PARTIAL_DATA)) { break; } } printf("\n"); It's only a handful more lines of code and it's a bit easier to follow what's going on. You know you are entering a loop and you can see it will be for 4 iterations. You see the function called. You see the conditions that we leave the loop on. Any random scrub can drop in and edit that if needed (Add new exit conditions, change retries, etc). In my first code though it's all thrown at you in a block. It isn't hard to understand really, but compared to the more verbose version, is it better? I ultimately thought so because I decided that the more verbose version didn't gain us enough vs how much more (relatively) complicated it ended up making the code (the entire module was very clean with little complicated condition checking; whatever the actual conditionals i felt I needed here would have killed the flow/readability of the code and I felt made it all more difficult to follow). And if anything goes wrong in the first block, they likely will need to rewrite the entire thing more like the second block anyhow. In code reviews (and the later skills transfer to the team taking the project over) this was one of the few blocks of code that required a little bit more review for everyone to get on the page. It worked, it was clean, and we all agreed it was a completely reasonable way to do the thing, but it required a few more seconds to stop and grok what all was going on. Does that make sense? It's kind of something you pick up and recognize along the way more than have explained to you.
Nice to know i'm on the right track at least :D So it'd be something like [this](https://ideone.com/hXNZib)? I'm not quite sure how to return the pointer to that node, unless the return node; does that. Also quick question, isn't giving node memory through malloc and then setting the values of next and prev to NULL a bit counter intuitive, or am I understanding it wrong? I remember that my lecturer did this too so I'm assuming it's right.
Yeah, there's [21st Century C](http://shop.oreilly.com/product/0636920033677.do)
yes that looks better. I recommend compiling your project as you go -- don't wait until the very end. So in main call initialize_node and make sure it compiles and runs before continuing on. malloc just makes space in RAM for the structure. Setting next and prev to NULL doesn't remove the space created -- it just makes sure the pointer isn't pointing to junk.
&gt; is mostly controlled by a single company. Small side note here; this isn't true. We work on consensus, no one organization can control anything about Rust. The team has said no to things that other parts of Mozilla have wanted before.
Messed up ur
Is there something like a TypeScript-kind of superset of C with a *real* type system? 
"Advanced Programming in the UNIX Environment" by Stevens &amp; Rago.
I believe this book would be of interest, its big and bad, but from memory it is exactly what you are looking for, infact it basically gives you all you need to know to start implementing your own fully featured shell: [https://www.amazon.co.uk/Advanced-Programming-UNIX-Environment-Addison-Wesley/dp/0201433079](https://www.amazon.co.uk/Advanced-Programming-UNIX-Environment-Addison-Wesley/dp/0201433079)
 return node; node is of type Node. You're allocating memory for the node with the call to malloc. You then test to ensure that node is not null. You next assign NULL to your next and previous, because you do not have existing nodes to point to. You finish by returning node. Node *initialise_node(void) Your function header indicates that you intend to return a pointer of type Node. With \`return node\` you are indeed returning a pointer to that node. &amp;#x200B; I've recently started to re-learn C and don't mean to derail your question. Hoping for input from more experienced around here. &amp;#x200B; Is there a reason not to use assert after the allocation here, rather than hand checking with the if statement? Assuming that I want the code to fail if a node cannot be allocated? &amp;#x200B;
I highly recommend The Linux Programming Interface. Its an excellent educational tool and bench reference. http://www.man7.org/tlpi/
Nice! Thanks for explaining.
[removed]
Pretty sure you need to create that function outside the union definition and create a function pointer as a member of the union.
That’s what I assumed, which would make the union just kinda normal and not have any real weird properties.
&gt; Is there a reason not to use assert after the allocation here, rather than hand checking with the if statement? Assuming that I want the code to fail if a node cannot be allocated? No. In fact, that is what I'd likely do if I wasn't going to write an out-of-ram handler.
The really tricky part is that when you first allocate new nodes in a new process (such as likely in all your tests), all the values in that piece of memory will likely be null as you get them. So the code will run just fine even without setting the pointers to null, and seems to do the same thing. Except that if you run for a little longer, and free some memory, and then call malloc, you're going to start to get the same memory back, and they will no longer all be filled with null, and then your program fails. Every value you use must always be initialized before use. Some languages (like D) have chosen to have the language initialize everything to a known state, others (like Rust) have chosen to make the compiler fail to compile code where you don't correctly initialize everything before use. C does neither, and correctly initializing values is left as the job of the programmer. Use of uninitialized memory is a major source of bugs, and wherever it happens there is almost certainly a lurking bug, even if the code appears to work. Often those bugs are also potential security vulnerabilities, that can be exploited if a malicious user uses you program wrong in just right way. 
\&gt; C does neither, and correctly initializing values is left as the job of the programmer. &amp;#x200B; Except for calloc, of course ;)
&gt;Is there a reason not to use assert after the allocation here, rather than hand checking with the if statement? Assuming that I want the code to fail if a node cannot be allocated? If you want your code to be re-useable and maintainable, I'd suggest leaving the choice of what to do on out-of-memory to whatever calls the linked list code. Iirc a failed assert will exit the program, which is a bit of a presumptive decision for linked list code to make. It's personal preference too, mind. &amp;#x200B; (while we're on that, isn't calling two different things "Node" and "node" respectively, going to lead to a lot of bugs and confusion down the line? I use node\_s for struct definitions, and node\_t for typedefs, so that it's harder to get mixed up)
Unix in its strict sense or Unix like systems like Linux?
It defines an array of one binary billion (2³⁰ = 1,073,741,824) double-precision floating-point numbers called `bigarray`.
["The Linux Programming Interface: A Linux and UNIX System Programming Handbook"](http://www.man7.org/tlpi/) - The author is the maintainer of the Linux man-pages.
Yeah, it's called `C++` and you can describe a `C`-like subset of it in a style guide for whatever project you're working on. Maybe you'd like `Rust`. You really shouldn't think about types when programming in `C`. You're supposed to be thinking about memory layout and alignment. If that's not what you want to be thinking about, then `C` is probably not the correct tool for the job!
I have it and it is great. Of course the example systems are not bleeding edge, but they are somewhat recentish. I think FreeBSD 10 and some version of Ubuntu and Solaris are used, but I'm not at home to verify this claim.
I own "The C Programming Language" by Kernighan and Ritchie, "The UNIX Programming Environment" by Kernighan and Pike and "Advanced Programming in the UNIX Environment" by Stevens and Rago. The first teaches you the language, the second the mindset and the third the interfaces. "The UNIX Programming Environment" is completely outdated, but it describes lots of the ideas how the Bell Labs team ought to use their system, which is very instructive in my opinion.
But can it be initialized to -1?
Ahh okay that makes sense, thanks a lot! Would you be able to take a look at [this](https://ideone.com/BYJ3T1) ? It's a different function this time which is supposed to free memory from the linked list, while also freeing the memory for all the nodes in the list, and I'm not sure if I've done it right or at least on the right tack.
Yes unfortunately i am serious, cheers for the heads up on the book. Will purchase it now. 
Thanks a lot ! You fixed it. Sorry for the late reply !
Well, if you're compiling `C` using `gcc` or `clang` a lot of things will work all the time.
The author is Ted "tedu" Unangst, one of the OpenBSD developers, a group known to not suffer fools gladly. For example, they [weaponize Comic Sans](http://www.openbsd.org/papers/bsdcan14-libressl/mgp00025.html), since it acts as a filter: anyone complaining about the font can be safely disregarded. Ted likes to play similar pranks with his blog. In this case it's intended to look like a phishing attack *because* it sets off these alarms. If you go to the "real" URL for this article: https://tedunangst.com/flak/post/strict-structs You'll get a certificate error. That's because [he's his own CA](https://www.tedunangst.com/flak/post/moving-to-https), his own little protest against the ridiculous situation we're in with CAs — bad tooling, lots of highly-trusted, but incompetent actors. 
Sure, but not this.
Could you explain what you're asking for more clearly? What do you mean by reading the code? Are you asking what it does? I could be sarcastic and just say that the first example just prints "abc" and the second example just prints "3", but I don't think that's what you're looking for.
I don't get your question. Do you need help understanding the code? Or do you need help reading it? &amp;#x200B; I can't help you with reading. However, if you need understanding the code, here goes. Check comments inline for the meaning. Code 1 : int main() { // main is a function that takes no arguments and returns an int char *s1 = "abc"; // Initialized a character pointer named s1 pointing to a constant character // array. char s2[]="hello"; // Initialized a character array named s2 equal to a constant character array strcpy(s2, s1); // Copied s1 to s2 printf("%s", s2); //Print s2 as a string return 0; // Return 0 from main } Code 2: int main() { // main is a function that takes no arguments and returns an int char s2[4]="abc"; // Initialized a char array of size 4 named s2 with a const char array strlen(s2); // String length of s2 is returned printf("%u", strlen(s2)); // String length of s2 is returned to the printf. Printf will interpret it as an unsigned int and print it return 0; // Return 0 from main } Note: 1. Functions that you should look into: 1. strcpy 2. printf 3. strlen 2. Find the difference between the two lines below. (Reply if you don't know the difference) 1. `char *s1 = "abc";` 2. `char s1[] = "abc";` &amp;#x200B; If this is not what you were asking, can you please clarify the question exactly? &amp;#x200B;
I try to debug it or dry run the program on page or notebook. Usually on the part that's not working. If it's a huge program. Google things or just post it on reddit if I am not able to find solution 
for part a s1 is pointer pointing to the address of "a" for part b s1\[\] is simply just an array that stores "a" , "b" , "c" &amp;#x200B; Am i right?
 int main() { char s2\[4\]; strlen(s2); printf("%u", strlen(s2)); return 0; } &amp;#x200B; In this case, s2 has 4 elements but they have nothing stored inside each address. strlen(s2) is trying to find the length of the string. but since there is nothing does it print 0?
There are a couple potential buglets in the second one. The lone `strlen(s2)` statement doesn’t necessarily do anything other than suggest to the compiler that `s2` is a NUL-terminated string (which it knows already), so the compiler will probably eliminate it if optimizing at all. Alternatively, breaking things up properly like size_t len; len = strlen(s2); printf("%zu\n", len); would work instead. More seriously, the `printf("%u")` should actually be using `%zu` for the format specifier, since `strlen` returns a `size_t`, not an `unsigned`, and passing the wrong thing in for a format argument is undefined behavior. This should generate a warning in a reasonably good compiler in a reasonably good mode, although if your target platform’s `size_t` happens to match type `unsigned`, then there won’t happen to be a problem. (`size_t` has the same format as `unsigned` on most 32-bit platforms like i386, but not on 64-bit platforms like x86_64.) If you’re on some elderly platform that doesn’t support the `zu` format specifier (e.g., MSVC pre-2013) you can do the following instead: #include &lt;limits.h&gt; #if SIZE_MAX &gt; 
Hi thanks for your reply! is char s2\[4\] = "abcd" the same as char s2\[4\]={'a', 'b', 'c', 'd'} 
Thanks for the great insight and the helpful information!
&gt; Apparently you always have to supply a short name ( -a)? Huh? No. Sounds like you're trying to use the ancient and useless getopt, check out my command line parser, CommandLineIO.
Sort of. But not completely. For part b, s1 is an array that stores 4 elements 'a', 'b', 'c' and '\\0'. For part a, s1 is a pointer pointing to address of 'a' yes. But it can also be said to be pointing to the entire NULL-terminated string "abc". &amp;#x200B; There is another difference but it is non-standard as far as I know. (Others can correct me if I am wrong). For part a, "abc" will be put in a read only section of the memory while execution. So, any operation that attempts to modify any element of the s1, (for example, `s1[2] = 'x'`) will encounter a Runtime bus error. For part b, however, the "abc" is put on the stack in the space allocated to s1\[\]. Here, `s1[2] = 'x'` will definitely not give you an error. &amp;#x200B; Let me know if you don't understand.
I've not used it myself but looking at the [struct argp_option docs](https://www.gnu.org/software/libc/manual/html_node/Argp-Option-Vectors.html#Argp-Option-Vectors) it seems that the short name is optional: &gt; int key &gt; The integer key provided by the current option to the option parser. If key has a value that is a printable ASCII character (i.e., isascii (key) is true), it also specifies a short option ‘-char’, where char is the ASCII character with the code key. 
No, I am using argp. Sorry, I'm new to C, only used python until now. But the options are defined in static struct argp\_option options\[\] = `{` `{"alpha",'a',"Alpha",0,"This is Alpha"},` `{"beta",'b',0,0,"This is Beta"},` `{0}` `};` and as far as I understad it, you can not leave the field where 'a' is empty, you cannot put 0 in there, and also not something with more than two characters. &amp;#x200B;
Yes, it can.
This library I assume? https://www.gnu.org/software/libc/manual/html_node/Argp.html I don't know the library, but my first question is "Why do you want more than 35 possible arguments?" Yes, there may be times when that is required, but if you think it is, are you sure that your design isn't flawed?
I need to ask the question again, do you know what the defining characteristics of a string are? Without fully understanding what a string is defined as in C, the rest of the conversation cannot continue.
think about your compiler commands though, for large projects or projects with specific needs you can have upwards of 100 command line arguments sometimes.
That in no way changes my statement. When the best design you can think of is to pass everything as a command line argument, your design is likely flawed. Someone looked at compilers and said "that's a shit way to do things", so they made the make system. (which then lead to others realizing that make was shit and spun up their own, but you get the idea)
How do you Read this? With new respect for \[the importance of\] the keyword "const".
how about for i for j starting from i + 1 if numbers sum up, print them and exit
Yep, that one. &amp;#x200B; I'm doing it for a physical simulation which takes 34 parameters. You really can not change this, since these are the ingredients for the simulation.
Indentation gets a bit unwieldy when you don't promptly exit out on usage and such errors :)
You completely missed the point of my post. Why do they need to be passed as command line parameters? Make a config file. Feed them from standard in. There are numerous ways to do it.
I just had a cursory look at your code. First of all, consider using a less wasteful indentation style. My screen can only fit so many lines and I really hate scrolling through dozens of lines just containing opening parentheses. I follow the KNF style (kernel normal form) promoted by many UNIX derivatives. You can find an explanation of the FreeBSD variant [here](https://www.freebsd.org/cgi/man.cgi?style\(9\)). Consider doing an early exit where possible. Nobody wants to read code with more than 3 levels of indentation. Use tabs for indentation to reinforce this rule; the strong indentation provided by tabs quickly makes highly indented code unreadable. You should not write such code. So instead of if (argc != 2) { printf("Usage: ./vigenere KEYWORD\n"); } else { ... } do if (argc != 2) { printf("Usage: ./vigenere KEYWORD\n"); return (0); } ... It's so much more readable. In the same manner, make use of `break` and `continue` where appropriate. It is much easier to follow a `break` than decipher how `argv_valid` affects the progress of the loop. Instead of while (a &lt; argv_size &amp;&amp; argv_valid) { argv_valid = isalpha(argv[1][a]); a += 1; } if (!argv_valid) { printf("Invalid keyword.\n"); } else { ... } Do while (a &lt; argv_size) { if (!isalpha(argv[1][a])) { printf("Invalid keyword.\n"); return (0); } } ... You should also consider returning 1 on error so it's easy to detect from a script if your application failed. Next, I don't get why you call `abs` in these statements: tmp1 = abs('A' - toupper(argv[1][b])); tmp2 = abs('A' - plaintext[a]); The result of the subtraction should never be negative and if it is, the call to `abs` silently converts one wrong number into another. It is smart of you to consider the case where `'A' - plaintext[a]` could be negative, but it's generally a much better idea to explicitly throw an error in situations like this. If this case can only occur due to incorrect code, consider using an assertion to check if the result is not negative: tmp1 = 'A' - toupper(argv[1][b]); assert(tmp1 &gt; 0); tmp2 = 'A' - plaintext[a]; assert(tmp2 &gt; 0); Your code checks if `plaintext[a]` is uppercase and then checks if it is lower case, but you don't do anything if it is neither. Is this intended? If not, consider adding a final else clause to handle the case where `plaintext[a]` is neither upper case nor lower case. If `read_text` fails, you print printf("Failed to allocate memory for input.\n"); Is "Failed to allocate memory" really the only thing that can go wrong? All relevant standard library functions set the variable `errno` to indicate what went wrong the last time anything went wrong. You can print an error description drawn from `errno` using the `perror` function. This prints what the actual error was, which might not be what you expect it to be (more on that later). In your case, do perror("read_text"); to print an appropriate error message. It should look like this: &gt; read_text: out of memory Now let's go to your `read_text` function. First of all, `status` is an `int` but you assign `true` or `false` to it. This is confusing. If you want to use booleans (which I recommend you to avoid for lack of clarity), then use a variable of type `bool`. If you want an `int`, assign numbers, not `true` or `false`. The clearest way is to make custom macros to indicate what exactly each macro means. Something like enum { FAILED = 0, SUCCESSFUL = 1, }; and then you do status = FAILED; to indicate failure. That said, the `status` variable can be entirely eliminated using early exit. Next, you write this: while ((((*(*addr_text + n)) = getchar()) != '\n') &amp;&amp; status) Nobody wants to read this. The C language has `a[b]` for `*(a + b)` and you should always use this syntax. Using the result of an assignment can be hard to read, too. I would have done it like this: while ((*addr_text)[n] = getchar(), (*addr_text)[n] != '\n' &amp;&amp; status) See? Much easier to read. That said, the code is wrong and leads to an endless loop if the input does not end with a newline. The `getchar()` function returns `EOF` on end of file or error. This macro has the value `-1`, to distinguish `-1` and the character `255`, you should never store the result of `getchar()` in a `char` variable; always use an `int` instead. Correct code first checks for `-1` and then for other conditions. Do it like this: int c; while (c = getchar(), c != EOF &amp;&amp; c != '\n' &amp;&amp; status) { (*addr_text)[n] = c; ... } later on you should also check if the error flag is set on `stdin` to distinguish end-of-file from an IO error. Just do if (ferror(stdin)) { free(tmp); status = false; } after the loop to take care of that. Now that the `free(tmp); status = false;` bit is duplicated in your code, you might want to consider defining a piece of cleanup code at the end of the function and then going there on error: if (ferror(stdin)) { goto error; } ... error: free(tmp); return (0); But sadly, your instructor might not like this, however much goto helps improving the structure of the code here.
make just invokes the compiler. With -- yep! 100's of items on the command line. Some compilers (and other tools) take a response file.
&gt;First of all, consider using a less wasteful indentation style. I will. In this case, I was entertaining the notion of using no breaks, continues, or returns in the middle. But I do understand that using these will make the code more readable here. &gt;Next, I don't get why you call abs in these statements: The use of 'abs' was left over from when I was still testing the main encryption algorithm. Cleaning that up. &gt;Is "Failed to allocate memory" really the only thing that can go wrong? When printing the message depending on the return value of 'read_text', isn't that the only thing that is shown to go wrong? (i.e 'status' (the return value) is set based on whether memory allocation was successful.) &gt;First of all, status is an int but you assign true or false to it. This is confusing. When changing certain ints to bools, I forgot to change 'read_text''s return value. Changing that now. &gt;Much easier to read. That said, the code is wrong and leads to an endless loop if the input does not end with a newline. The getchar() function returns EOF on end of file or error. This macro has the value -1, to distinguish -1 and the character 255, you should never store the result of getchar() in a char variable; always use an int instead. Will do. &gt;But sadly, your instructor might not like this, however much goto helps improving the structure of the code here. I am not averse to using gotos should the need arise. :) (the 'need' being 'improved code readability').
All the integers from 1 to MAXINT. Your options struct could have '465' or it could have 'a' as the key. Its just has to be unique in the set of options that parse\_opt() will eventually use to switch() on the command. The key, needn't be printable, but when it isascii(key), argp provides it as a 1 character shortcut for the long form. The options without printable keys are only accessible by long form. It's probably the example code that's got you off-track. It only uses printable characters as keys, and it kinda sucks since (I think) the example struct declaration is implicitly promoting the character to integer. 
 int c; while (c = getchar(), c != EOF &amp;&amp; c != '\n' &amp;&amp; status) { (*addr_text)[n] = c; ... } +1 for your use of the comma operator here. Another alternative is to use a `for` loop: for ( int c = getchar(); c != EOF &amp;&amp; c != '\n &amp;&amp; status; c = getchar() ) { (*addr_text)[n] = c; ... } However, you've slightly changed the semantics, as OP's original version would store the `'\n'` in the array.
&gt; However, you've slightly changed the semantics, as OP's original version would store the '\n' in the array. Oh yes indeed!
I wish you all the best with your career! Your code looks very good for a beginner and is very readable otherwise. That said, &gt; Will do. The reason I did not consider errors from 'getchar' was what did you mean to say here?
Yeah, a config file also has the advantage of being able to tell what you ran. And if your simulation gets more complicated (additional models, Monte Carlo analysis), you'll be happy to have a system in place for that mess.
&gt; When printing the message depending on the return value of 'read_text', isn't that the only thing that is shown to go wrong? (i.e 'status' (the return value) is set based on whether memory allocation was successful.) In your current code, the only problem you handle is that of `realloc` failing. However, other possibilities of failure do exit, you just don't handle them. You should never make assumptions about the implementation of a function that are not backed by the interface specified for the function. In your case, you shouldn't use the knowledge that you only handle allocation failures. The reason for this is that after someone (who might not be you) rewrites the function, these assumptions might no longer hold and lead to misleading error messages or actual bugs. This principle is known as *loose coupling* and is one of the basic lessions of software engineering.
I thank you for the compliment. :) I meant to say that I did not consider errors from 'getchar', to simplify my model of the program, but I understand that secure code needs to address such errors, and will do so in the future.
Does it make much of a difference that I also handle malloc failing?
Would removing the malloc call make a difference? 'read_text' malloc s memory first, then it checks if malloc was successful, and then it attempts to realloc. If malloc (which is outside the if block) fails, status is set to false. If realloc fails (which is inside the if block), status is set to false.
Getting rid of the first `malloc` would mean that there is one less point where your code could fail. That's all the difference it makes.
&gt; TypeScript I just can't take anything you say seriously soyboi.
I have a question about the expected results. Right now you're ciphering the result to a number in the range 0-25, stored as a character. I would have expected the result to be shifted back into a printable character. There's also some oddity about how you're doing that computation. `'a' - tolower(argv[1][b])` is backwards, isn't it? Maybe that's why you have the `abs` call in there? Anyway, I think sometimes it's helpful to see the way that other programmers would have written your same code. So here's my version: bool is_valid_keyword(const char* keyword) { for ( ; *keyword; keyword++ ) if ( !isalpha(*keyword) ) return false; return true; } int main(int argc, char** argv) { if ( argc != 2 ) { fprintf(stderr, "Usage: ./vigenere KEYWORD\n"); return EXIT_FAILURE; } const char* keyword = argv[1]; size_t keyword_len = strlen(keyword); if ( !is_valid_keyword(keyword) ) { fprintf(stderr, "Invalid keyword.\n"); return EXIT_FAILURE; } printf("plaintext: "); char* plaintext = NULL; size_t n = 0; if ( getline(&amp;plaintext, &amp;n, stdin) &lt; 0 ) fprintf(stderr, "Could not read input.\n"); for ( size_t i = 0; i &lt; n; i++ ) if ( isalpha(plaintext[i]) ) plaintext[i] = (isupper(plaintext[i]) ? 'A' : 'a') + ((tolower(plaintext[i]) - 'a') + (tolower(keyword[i % keyword_len]) - 'a')) % 26; printf("ciphertext: %s\n", plaintext); free(plaintext); return EXIT_SUCCESS; } A couple notes: * I shift the result back to a printable character, using the same capitalization as the original. Probably a bad idea for security ... not that you'd use a vigenere cipher anyway. * I'm using a POSIX function to do basically the same thing as your `get_string` -- which you probably aren't allowed to use for the assignment, but it's worth pointing out that these sorts of things often exist and you should avoid writing your own whenever possible. * I'm using the modulo operator in two places to do the wrap-around logic. This is quick code to write, but isn't necessarily the most efficient. There's often a trade-off in efficiency vs readability, and this is a great example. I'm not saying one way is better than another. * C didn't standardize on the ASCII character set, and it's not guaranteed that the alphabet is contiguous. See EBCDIC, for example. So technically `'a' - whatever` is isn't valid. But whatever.
My rule of thumb is that any `init_foo` should be accompanied by `fini_foo`.
If I removed that, how would I have restructured the code?
Yes, you should pass the pointer that you got from malloc to free. blah *init_struct() { blah *b = malloc(sizeof blah); return b; } int main() { blah *foo = init_struct(); free(foo); }
That is true. Full Story: A collegue wrote the c code, and that actually takes a config file and puts the results into an outputfile. I wrote a gui in python for that, which, at every click to change a parameter, a new config file is written, the results read, and the graphs displayed. But I want to implement an automated function that basically does a brute force of a couple of parameters. That would also work. But if I want to use all available cores, so each one could run one set of parameters, I can not use the same config file. So ideally, I could call the the program with command line arguments and have the output to stdout, so I dont have to bother with writing and reading files.
This is bad practice. foo should be passed into a free_struct function that calls free. The exact implementation of how to dispose of foo isn't main's responsibility. Consider the situation in which the struct contains a pointer in it that also needs to have free called on it.
You would start with `*addr_text = NULL` and `size = 0`. Then, the first time you try to insert a character into `*addr_text`, your code realises that the buffer is full and calls `realloc` to allocate it. This is possible because calling `realloc` on `NULL` works just like `malloc`. This is a neat little trick you might want to remember.
I think he's just giving an example for a simple case. If the free_struct function would do nothing more than call free on a pointer, what's the, er, point?
You need to call free on the pointer that the `malloc` call returned. For student programs, a popular approach is to copy all your malloc returns into a linked list and freeing that list's contents as well as the list itself at the end of your program.
If you're just going to free everything at the end of the program then you may as well not bother and just let the program end. Memory should be freed when you're done with it.
Because it violates separation of concerns. If you're going to have an init_struct to malloc the struct, you should have a free_struct to free the struct.
Kerrisk is excellent. Seconded. 
This is how you end up with memory leaks.