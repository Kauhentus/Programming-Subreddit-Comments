**Google Search** Google Search, commonly referred to as Google Web Search or simply Google, is a web search engine developed by Google. It is the most-used search engine on the World Wide Web, handling more than three billion searches each day. As of February 2016, it is the most used search engine in the US with 64.0% market share. The order of search results returned by Google is based, in part, on a priority rank system called "PageRank". *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Imagine an integer as an array of bits. Now, if you were to apply | or &amp; to this at equivalent elements of the array you’ll generate a result array. When you’re using them, oftentimes they’re declared in such a way that each flag trips a particular bit on an integer. So, you’ll often see 1,2,4,... defined so when you | them together you can then test if that particular sentinel is defined by &amp; the result value. Ex. (double check this) 1|4==5 5&amp;1==1 5&amp;2==0
GO FOR JAVA
You don't even need a tree. A simple frequency table can be constructed by iterating over s2 using ASCII values as indices that gives O(1) lookups.
Many modern embedded systems are also run programs written in C. C programs are tiny and very fast.
Simple question. What's the difference between C and C++?
There are a lot of answers to that, but I'll give you the most telling one for me: *"Hello, World!" to stdout in C* (Assembly compile from GCC) ``` .file "helloworld.c" .section .rodata .LC0: .string "Hello, World!" .text .globl main .type main, @function main: .LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 leaq .LC0(%rip), %rdi movl $0, %eax call printf@PLT movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .ident "GCC: (Ubuntu 7.2.0-8ubuntu3.2) 7.2.0" .section .note.GNU-stack,"",@progbits ``` *"Hello, World!" to stdout in C++* (Assembly compile from G++) ``` .file "helloworld.cpp" .section .rodata .type _ZStL19piecewise_construct, @object .size _ZStL19piecewise_construct, 1 _ZStL19piecewise_construct: .zero 1 .local _ZStL8__ioinit .comm _ZStL8__ioinit,1,1 .LC0: .string "Hello, World!" .text .globl main .type main, @function main: .LFB1493: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 leaq .LC0(%rip), %rsi leaq _ZSt4cout(%rip), %rdi call _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@PLT movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE1493: .size main, .-main .type _Z41__static_initialization_and_destruction_0ii, @function _Z41__static_initialization_and_destruction_0ii: .LFB1977: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 subq $16, %rsp movl %edi, -4(%rbp) movl %esi, -8(%rbp) cmpl $1, -4(%rbp) jne .L5 cmpl $65535, -8(%rbp) jne .L5 leaq _ZStL8__ioinit(%rip), %rdi call _ZNSt8ios_base4InitC1Ev@PLT leaq __dso_handle(%rip), %rdx leaq _ZStL8__ioinit(%rip), %rsi movq _ZNSt8ios_base4InitD1Ev@GOTPCREL(%rip), %rax movq %rax, %rdi call __cxa_atexit@PLT .L5: nop leave .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE1977: .size _Z41__static_initialization_and_destruction_0ii, .-_Z41__static_initialization_and_destruction_0ii .type _GLOBAL__sub_I_main, @function _GLOBAL__sub_I_main: .LFB1978: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $65535, %esi movl $1, %edi call _Z41__static_initialization_and_destruction_0ii popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE1978: .size _GLOBAL__sub_I_main, .-_GLOBAL__sub_I_main .section .init_array,"aw" .align 8 .quad _GLOBAL__sub_I_main .hidden __dso_handle .ident "GCC: (Ubuntu 7.2.0-8ubuntu3.2) 7.2.0" .section .note.GNU-stack,"",@progbits ``` 
There are a lot of answers to that, but I'll give you the most telling one for me: *"Hello, World!" to stdout in C* (Assembly compile from GCC) --- .file "helloworld.c" .section .rodata .LC0: .string "Hello, World!" .text .globl main .type main, @function main: .LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 leaq .LC0(%rip), %rdi movl $0, %eax call printf@PLT movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE0: .size main, .-main .ident "GCC: (Ubuntu 7.2.0-8ubuntu3.2) 7.2.0" .section .note.GNU-stack,"",@progbits --- *"Hello, World!" to stdout in C++* (Assembly compile from G++) .file "helloworld.cpp" .section .rodata .type _ZStL19piecewise_construct, @object .size _ZStL19piecewise_construct, 1 _ZStL19piecewise_construct: .zero 1 .local _ZStL8__ioinit .comm _ZStL8__ioinit,1,1 .LC0: .string "Hello, World!" .text .globl main .type main, @function main: .LFB1493: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 leaq .LC0(%rip), %rsi leaq _ZSt4cout(%rip), %rdi call _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@PLT movl $0, %eax popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE1493: .size main, .-main .type _Z41__static_initialization_and_destruction_0ii, @function _Z41__static_initialization_and_destruction_0ii: .LFB1977: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 subq $16, %rsp movl %edi, -4(%rbp) movl %esi, -8(%rbp) cmpl $1, -4(%rbp) jne .L5 cmpl $65535, -8(%rbp) jne .L5 leaq _ZStL8__ioinit(%rip), %rdi call _ZNSt8ios_base4InitC1Ev@PLT leaq __dso_handle(%rip), %rdx leaq _ZStL8__ioinit(%rip), %rsi movq _ZNSt8ios_base4InitD1Ev@GOTPCREL(%rip), %rax movq %rax, %rdi call __cxa_atexit@PLT .L5: nop leave .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE1977: .size _Z41__static_initialization_and_destruction_0ii, .-_Z41__static_initialization_and_destruction_0ii .type _GLOBAL__sub_I_main, @function _GLOBAL__sub_I_main: .LFB1978: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 movl $65535, %esi movl $1, %edi call _Z41__static_initialization_and_destruction_0ii popq %rbp .cfi_def_cfa 7, 8 ret .cfi_endproc .LFE1978: .size _GLOBAL__sub_I_main, .-_GLOBAL__sub_I_main .section .init_array,"aw" .align 8 .quad _GLOBAL__sub_I_main .hidden __dso_handle .ident "GCC: (Ubuntu 7.2.0-8ubuntu3.2) 7.2.0" .section .note.GNU-stack,"",@progbits --- 
Very helpful thank you!!
There are a lot of answers to that, but I'll give you the most telling one for me. A picture is worth 1,000 bits. ["Hello, World!" to stdout in C++](https://paste.ubuntu.com/p/xxNfB3z7QN/) (Assembly compile from G++) "[Hello, World!" to stdout in C](https://paste.ubuntu.com/p/d3t8MwPFq6/) (Assembly compile from GCC)
&gt; Are there categorically things which C just can't do? https://en.wikipedia.org/wiki/Turing_completeness But there are indeed thing for which C wouldn't be a my first choice.
Thank you! Turing Completeness! C is Turing complete! Makes sense. Will you share some of the reasons why it wouldn't be your first choice?
`pthread_join()` blocks — it pauses the thread that calls it — until the targeted thread finishes. The first version creates a bunch of threads, then waits on them one at a time. 
C doesn't allow your source code to be interpreted directly, so you need to manage at least twice as many files.
When it's more important to have code fast than fast code.
Any modern website? IOS/Android applications? Lot of stuff. But to be serious, the question is not what can't be done, but what can't be done with the same amount of effort. Surely you can use C for every task, but lack of functionality and stable libraries may highly increase its complexity.
In my experience, the reason people don't want to use C is that C typically doesn't do things for you, so it can take more lines of C code to implement some behavior vs Python, Java, C#, C++, etc. A valid reason for not wanting to use C is a lack of libraries. I used to work exclusively in C. As part of that project, I wrote the equivalent of a string library, linked list, hash map, hash set, etc. They were super fast because they were tailored to exactly our use cases, but for most projects (including ours for at least some of those data structures) this isn't worth the time. The other thing that comes to mind quickly is string parsing. People don't like to parse strings in C because it's tedious. However, in my experience string parsing is really tedious and fragile no matter what. It's best to store string data in something standard that solves this problem inherently.
So `pthread_join()` function just as the `waitpid()` function, more or less?
That is quit a difference. Can you show the source code as well? 
Yup, you've got it.
Aka reflection, like accessing its own variable in runtime dynamically by compilation time names, or integrating a new piece of compiled code at runtime. Doable, but sure is a pain.
Thanks for the answer.
I like that summary of the pros/cons of C. It's succinct and memorable, I'll probably use it at some point.
C is great, C++ is horrible! ... Done! 
Man, the C is quite close to hand rolling assembly. [Hello, World!](https://pastebin.com/fD9C4MmT) in assembly. 
[C++](https://godbolt.org/g/83vb8z) [C](https://godbolt.org/g/JzMQKw) I compiled with optimizations, which fixes things a lot (and in general, C++ really needs at least basic optimizations enabled, in my experience). The two versions are strikingly similar, in the end. The C++ version generates an extra cleanup function, which we can mostly ignore. Inside `main`, the only significant difference is C++ loading the `cout` object. After that, C++ calls the appropriate `operator&lt;&lt;` while C calls `puts`. The Hello, World comparison is actually a really poor way to compare the two languages.
An anecdote: I made a little program to get some weather data online, in some CVS form, to display on my taskbar. I wrote it in C, I had wrote the code to get the data, and I was gonna parse the data I started having regrets. Working with strings in C is *not* the most fun thing in the world.
That doesn't make sense, there's no reason for why c++ code would result in more assembly in the end. If both are written well the result would be about the same for both. Would be great to see the source code as well as the optimization level.
This is so dumb, it hurts. First of all i'm pretty sure this is unoptimized output. If i compile the same code, no optimizations, i get your asm. But if compile with `-Os` or even `-O` the number of lines is halved. Second of all you're comparing two different things: the streams facility of the C++ std lib is much more powerful than printf. For one thing it allows your own classes to overload the `&lt;&lt;` operator. This makes it trivial to print your own data structures along with other stuff in a uniform way. Good luck getting printf to do that. Basically for whatever you want 'printf' to print you have to look up the format specifier, and if what you want to print doesn't have one then tough luck! `gcc` gives you some functions to teach it new specifiers, but alas that's not portable. And third: no one is putting a gun to your head demanding you use streams in your C++ code. 'printf' and all other C functions are still there for you to use, they're neatly packaged into their own namespace. 
The key is what libraries and tools you have to go with your 'C'. If you plan to start from scratch, the only thing you can do is exercises from a text book.
C++ supports OOP, C does not.
Everything, and the answer is the same for c++, rust, ada, haskell, go, etc.
Yes, reflection and late binding of interpreted code allows you to write code that creates needed methods on the fly, effectively trading performance for flexibility. There are serious security considerations writing code this way, but it's also very powerful. 
I'm not quite sure what you're getting at, but I'm sure paulrpotts is talking about "functional programming" and not "functionality".
yup! agree
When `increase` changes the value of its local variable `strArr`, the value of `strArr` in `main` doesn't change. `increase` could return the new address of the array so `main` can assign it to `strArr`, or a pointer to `strArr` should be passed to `increase` so that it can be changed.
Yes, "moderately functional" as in the functional programming paradigm, where expressions all return values and you don't use mutable variables. You can program in a "moderately functional" style in C, since you can decompose problems into functions, have functions return values and updated state, and try to avoid global state. In general that's a good thing to do, and for example I have a book called _Functional C_ that has some good examples. But in practice this paradigm doesn't fit C all that well because there is a lot of mutable global state even just used by standard system calls and libraries, and the basic system calls were all designed around an imperative style. 
If you're using a global for `count` then you may as well make `strArr` a global as well since the 2 are inextricably linked.
Funny, I've written OO code in C.
Ah right. Durrr.
 *strArr = *add; Since it looks like both pointers are pointers to an array, it is equal to: strArr[0] = add[0]; However, the pointer in `strArr` might be invalid due to the reallocation, so it is not safe to dereference it. And since you don't change the pointer in `main`, which still uses the old, probably invalid, pointer, you get weird behavior.
String manipulations are *really* painful in C. Manually managing memory can get tiresome. 
I've been interested in coroutines and generators and such. It can be difficult to do in C. It's possible with preprocessor macros, but some implementations also seem to use assembly. Sorry, I haven't got any sources at the moment, but I could track some down. There's still plenty of uses for assembly code, be it for drivers, or for more efficient use of SSE or other specialised instructions. So technically there are things you can do in assembly that you still can't do in C. Is that a good reason to use assembly all the time? Of course not. Just like it's not worth using C for certain situations.
you can't do things that Erlang can do as simply in C
I believe it is difficult (or impossible?) to write a complete Android app in plain c. The Android NDK exists, but it is designed to optimize time critical parts of the app, not to do all the GUI stuff, etc.
everything can be done, but some of it will take a lot of work to achieve. which is why there are specialized languages that serve specific tasks really well. if i want to read data from A into B, i use Perl for instance. (A and B being random combinations of database,file,api, ldap directory, keychain). if would take weeks to do this in C. if i wanted to try writing something memory safe, i'd consider rust. C basically cannot do _easily_ what other languages excel at. but they can't do easily what C does either, which is bare metal programming.
95% of my professional back-end coding are Python + 4% Cython for the most performance critical parts. I only use C for private/fun projects.
I agree with you (before and after your edit). I like knowing what is happening by reading the code written in front of me, and C is absolutely the language that best facilitates it. I do like object oriented programming - especially being able to hide implementation details in ways that prevent the tight coupling of code - but avoiding tight coupling in practice requires good design, and good design in C will also prevent it even if the language doesn't help as much. I suppose object oriented development is another reason someone might decide to avoid C.
Highly parallel applications are a bitch to program in C as the threading APIs only support fat threads. Writing your own user-space scheduler is hard and impossible to do in a portable manner if you want it to be pre-emptive.
a much better question is, “what is the best tool available to me to perform this task?” C is a great tool for a lot of things. there are better tools for some tasks, though. your C skills will translate well to many of those tools. it’s a great foundation, but it doesn’t (need to) stand alone! try to avoid getting caught up in language dogma and purity. it’s, quite simply, not worth your time.
&gt; anything can be done in C with enough time and effort There's the rub. "What can't be done in C?" Anything that requires more time and resources than you have. There are lots of apps that are written in other languages that could never be written in C given the time and resource constraints. 
"Hello world" is not a good example for the differences between C and C++. Here's a more involved example in both languages: a function `splice_file` that takes three parameters, a path to a file `path`, a string `s` and an index `i`, and returns a copy of `s` with the contents of the file pointed to by `path` inserted at index `i`. #C C's advantages are that the language and standard library are much smaller in terms of features than C++, and so can be learned up to a medium level of proficiency much faster. Compilation times are also far better, it's easier to write portable and backwards-compatible source code, and the ABI is much simpler and more stable, which also eases the creation of portable and backwards-compatible binaries and libraries. ###SpliceFile.h #ifndef SPLICEFILE_H #define SPLICEFILE_H #include &lt;stddef.h&gt; char *splice_file(const char[static 1], const char[static 1], size_t); #endif//SPLICEFILE_H ###SpliceFile.c #include "SpliceFile.h" #include &lt;assert.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; struct Resources { size_t n_buffers; void *const *buffers; size_t n_files; FILE *const *files; }; static inline void cleanup(struct Resources r) { while (r.n_buffers--) free(r.buffers[r.n_buffers]); while (r.n_files--) fclose(r.files[r.n_files]); } _Noreturn static inline void fail(const char msg[], struct Resources r) { perror(msg); cleanup(r); exit(1); } char *splice_file(const char path[static 1], const char s[static 1], size_t i) { const size_t s_size = strlen(s); assert(i &lt;= s_size); FILE *file = fopen(path, "rb"); struct Resources r = {}; if (file == NULL) fail("fopen(3)", r); r.n_files = 1; r.files = &amp;file; if (fseek(file, 0, SEEK_END)) fail("fseek(3)", r); const long file_size = ftell(file); if (file_size == EOF) fail("ftell(3)", r); char *const spliced = calloc(s_size + (size_t)file_size + 1u, 1); if (spliced == NULL) fail("malloc(3)", r); r.n_buffers = 1; r.buffers = (void*const*)&amp;spliced; memcpy(spliced, s, i); rewind(file); fread(spliced + i, 1, (size_t)file_size, file); if (ferror(file)) fail("fread(3)", r); fclose(file); memcpy(spliced + i + file_size, s + i, s_size - i); return spliced; } ###main.c [(output)](//wandbox.org/permlink/mWepkj3iB1b1v5qn) #include "SpliceFile.h" #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { char *const s = splice_file(__FILE__, "'''\n\n'''", 4); puts(s); free(s); } #C++ As you can see, C++'s advantages over C include a larger and more modern standard library, and [RAII](http://en.cppreference.com/w/cpp/language/raii) classes (like `std::string` and `std::ifstream`) which greatly simplify the finicky and verbose resource management and error handling that's necessary in C. Another advantage is overloaded and generic (template) objects and functions, but that's a more advanced topic I won't get into. ###SpliceFile.hpp #ifndef SPLICEFILE_HPP #define SPLICEFILE_HPP #include &lt;filesystem&gt; #include &lt;string&gt; std::string splice_file( const std::filesystem::path&amp;, std::string, std::string::size_type); #endif//SPLICEFILE_HPP ###SpliceFile.cpp #include "SpliceFile.hpp" #include &lt;cassert&gt; #include &lt;fstream&gt; #include &lt;iterator&gt; using std::filesystem::path; // filesystem using std::string; // string string splice_file(const path &amp;path, string s, string::size_type i) { using std::ifstream; // fstream using std::istreambuf_iterator; // iterator assert(i &lt;= s.size()); ifstream file{path, file.in | file.binary}; file.exceptions(file.badbit | file.failbit); const auto pos = s.cbegin() + i; s.insert(pos, istreambuf_iterator{file}, istreambuf_iterator&lt;char&gt;{}); return s; } ###main.cpp [\(output\)](//wandbox.org/permlink/SpIrJ48RskUdROUY) #include "SpliceFile.hpp" #include &lt;iostream&gt; int main() { using std::cout; // iostream cout &lt;&lt; splice_file(__FILE__, "'''\n\n'''\n", 4); }
C is my favorite language, but I’m struggling to find a way to implement generic data structures. Currently I use void pointers but those warnings on the compiler bother me!
Love to see it!
I agree. I interpreted OP as how is C applied to solve problems.
generics
&gt; modern testing This is where I felt the first time that C is really limited compared to e.g. Java with the JUnit framework. Of course, I was aware that other languages offer many convenient features, but I think there's always a way to work around the lack of these features in C. But unit tests, especially with mock objects are nice and I don't see a good way to instantiate them in the same way I would do it with JUnit.mock(). Testing without mocking is painful.
Sure. [Here](https://pastebin.com/dXjU9KnE)'s a quick trivial example of inheritance and (polymorphic) member functions. A bit of a pain compared to a language with more built in support, sure, but quite doable. The linux kernel is [full](https://lwn.net/Articles/444910/) of other examples done better. And then there's [gobject](https://en.wikipedia.org/wiki/GObject) and other similar libraries... 
Casting to the right datatype should solve your problems.
I have written this so far and included step 1: #include &lt;stdio.h&gt; int main () { int user; int compchoice; char userChoice = '\0'; printf("Please input either rock, paper, or scissors.\n\n"); scanf("%c",userChoice); if (userChoice = "rock") {user=0;} else if (userChoice="paper") {user=1;} else if (userChoice="scissors") {user=2;} if (user==0) { if (compchoice==0) {printf("Computer chose rock"); printf("It's a tie!\n\n\n\n"); } else if (compchoice == 1) { printf("Computer chose paper\n"); printf("Paper beats rock!"); } else if (compchoice == 2) { printf("Computer chose scissors\n"); printf("Rock beats scissors! You win!\n"); } } if (user == 1) { if (compchoice==0) {printf("Computer chose paper"); printf("Paper beats rock! You win!\n\n\n\n"); } else if (compchoice == 1) { printf("Computer chose paper\n"); printf("It's a tie!\n"); } else if (compchoice == 2) { printf("Computer chose scissors"); printf("Scissors beat paper! Sorry, you lose!\n"); } } if (user == 2) { if (compchoice==0) {printf("Computer chose rock"); printf( "Rock beats scissors! Sorry, you lose!\n"); } else if (compchoice == 2) {printf("Computer chose scissors"); printf("It's a tie!\n\n\n\n"); } else if (compchoice == 1) {printf("Computer chose paper"); printf("Scissors beat paper! You win!\n"); } } return 0; } 
The numbers are passed to you as strings, not numbers. You need to use `atoi()`, `strtol()` or `scanf()` to parse them.
Thanks for the quick response! so after including the header file &lt;string.h&gt;, I would use: `` InputShort1 = atoi(argv[3]); InputShort2 = atoi(argv[4]); InputShort3 = atoi(argv[5]); Is this correct?
Hi there, thanks for the response. &gt; Are you trying to ask how to write test cases for use with Travis? Yes, this is roughly what I"m asking. It's tricky to find decent examples on GitHub (or at least, I'm having difficulty finding these examples) whereby users calculate the code coverage for tests written in C and publish these on github. 
Everything *can* be done in C. Just if you add syscalls to brainfuck, everything *can* be done in brainfuck. Not everything is the right choice to do in C, though.
This is really cool! Thanks for this. So, you're not using a standard framework to do testing? e..g check, Unity, etc. ? 
Sounds about right.
sscanf, not scanf, btw.
Actually do use unity for another project: https://github.com/isaachier/c-client.
I mean yeah I could put them in an array of shorts ideally.
To quote my CompSci professor: "Nothing." To quote the classmate sitting next to me: "If you don't mind spending hours writing libraries." In seriousness, though, I love C. And there libraries already written for pretty much anything you can think of.
This is kind of upside down. You don't need any more than 256 bits for your table if you process s2 first (128 if you're allowed to assume 7-bit ASCII). The table should just be a Boolean on "Is this char anywhere in s2?" For readability, though, you'd probably want to break it out into 256 (or 128) bytes. This also gives you the possibility of breaking out of the subsequent s1 loop early, so you only process all of s1 in the worst case scenario.
You can do anything in C, it has direct hardware access and most compilers support inline assembly. That being said, somethings in C may take a VERY long time with extremely complicated code. So if time isn't an issue, then it can be done in C. Otherwise you may want to use other langauges that offer more abstraction. 
No problem. You should look for books and articles that cover Test Driven Development in general, but if you can find examples in C that would probably be particularly helpful. A particularly simple means I've seen for writing tests, though still effective, is to use `assert.h` to check return values. There are frameworks like Unity that provide more features, but it largely depends on your use case.
They would be used in place of bit operations. So if you want to set a specific bit, its easier to assign a value the same way you would any other variable. However, bit-fields are not guaranteed to produce identical bit layouts across differing compilers or architectures. And because of this, one should stay away from them unless you know the platform and compiler very well. Hence, you'd find them seldom used in applications; developers prefer to manually set bits instead.
Bit fields are the same as structs. The caveat is the size of the members are defined by you. So for example if you had a struct struct { unsigned char widthValidated; unsigned char heightValidated; unsigned char depthValidated; } nonBit; This would equal 3 bytes in size. Now say these actually will only ever equal a 1 or a 0. We can cut down significantly how big the struct is by telling the definition how wide each member is going to be. The bits will always fall into a byte boundary line so in my case the bottom would equal 1 byte and each bit in it would be assigned a value. The remaining bits are unused. But the whole structure is only one byte now. struct { unsigned char widthValidated : 1; unsigned char heightValidated : 1; unsigned char depthValidated : 1; } Bit; So we saved 2 bytes by doing this. Which may be a big deal for some applications. To summarize, a bit field is a struct of custom size members that can is used to pack data into a tighter object.
This is an excellent explanation. Lemme see if I can put it together with the context of the original problem for OP. First, I want to label each bit. 0s and 1s are difficult to tell apart when they start shifting around. So, let's say that x is a pattern of bits: hgfedcba So for x=75 (01001011) a = b = d = g = 1 c = e = f = h = 0 Backwards? Yes and no. I'll explain in a bit. For now, just roll with it. What if my goal was to isolate whatever bit pattern was in the "gfed" positions: hgfedcba -&gt; 0000gfed What steps would I take? First, I'd want to shift the value to the right: hgfedcba &gt;&gt; 3 -------- 000hgfed Then I'd want to get rid of the "h" bit without changing the others. I can do this with the AND (&amp;) operator, with a value that is often referred to as a "mask". An AND mask is simply a value where I put a 1 in every position I want to keep, and a zero in every position I want to discard (meaning set to zero). 000hgfed &amp; 00001111 ---------- 0000gfed For the original x=75, this leads to the bit pattern 00001001=9. Voila! Okay, so now what if I want to generalize that? I want a function that gives me any "slice" of bits from my original integer placed at the least significant end of the return value. I want to describe which bit position to start at and how may bits to take. The starting bit position is the "p" argument. This doesn't seem right at first. p=6. Didn't we start at bit position 1? Not if you count from the right -- which you should! This seems backwards, because we want to read bit patterns from left to right, like text, but in many contexts, it's more useful to read them in the direction they grow. This is how things work in decimal too, even though you might not notice it. When 9 is incremented to 10, the new "tens" digit appears on the left. And because integers can vary in size in C, it's useful to make the 0th bit the one that's always going to be there at the least significant end. That is all to say that for p=6, we want to start at the bit position we labelled "g" earlier. Now for simplicity, let's just say we wanted to keep 1 bit ("g"). We'd shift 6 bits to the right before masking. What about keeping 2 bits ("gf")? We'd shift 5 bits before masking. What about keeping n bits? It looks like we'd shift 6 + 1 - n bits before masking. And if p is some other position? I'll let you confirm why this would be p + 1 - n. If you look, you'll see that this is precisely the left half of the formula above is. It's moving the appropriate number of bits down to the "low" end of the value. So what about the mask? Well, we know we want to keep some number of bits down at the low end, so we need a mask that looks like ...0000011111... where the number of 1 bits is n. If we can construct such a bit pattern, the "&amp;" will chop off (set to zero) the high (left) bits like we want. First, we start with the all-zero bit pattern, and negate it (~) to get the all-ones pattern: ~ 00000000 -------- 11111111 Then we shift this left by n, which for the example was 4. 11111111 &lt;&lt; 4 -------- 11110000 So this constructs a value with n=4 zero bits in the lowest positions. That's the exact opposite of what we want, so another negation flips all the bits back and gives us the final mask we need. ~ 11110000 -------- 00001111 ^* Rereading this, all the "we" talk sounds a bit patronizing. Sorry about that. I have a math background and it's a tic that shows up in a lot in proofs and other explanatory math text.
What says your array access is out of bounds? valgrind or AdSan or another tool? C doesn't do bounds checking by itself.
file sharing is pretty broad
hashCode is a signed int. Negative mod positive is negative. Cast the return of your hash function to an unsigned type.
Actually, that's wrong. Your hash function already returns an unsigned type. You just need to cast **after** you mod.
It seems the problem resolved itself without me changing anything? That makes me more curious. But as for the array declaration, does it look right? 
Based on what I can see, yes. But you haven't provided complete code, so I can't say for sure. For instance, I can't see how you're managing the character arrays you're initializing from. You may have some NULL values in there for all I know.
I'll post the code, maybe you can find some faults I cant! 
 // // main.c // hash_table #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; // struct for each entry typedef struct dict { char * word; char * translation; int flag; // keep track if info has already been seen //0 - Index has never had data //1-Index has data //2- Index has been overwritten(appended). }Entry; // Function prototypes uint32_t jenkins_one_at_a_time_hash(char *, int); int parseOp(char *); char * parseWord(char *); char * parseTransl(char *); void initHash(Entry *[],FILE *); void newLineRemover(char *); void hashAdd(Entry *[],char *[]); int main(int argc, const char * argv[]) { // Create "Hash table" Entry * hash[22433]= {NULL}; // Open file char filename[20] = {'\0'}; printf("Enter filename: "); scanf("%s",filename); while((getchar()) != '\n'); // Clear input buffer FILE * fp; fp = fopen(filename, "r"); if(fp != NULL) { initHash(hash,fp); } // Get user choice printf("%s",hash[15062]-&gt;word); printf("\n%s",hash[15062]-&gt;translation); char choice[103]={'\0'}; printf("Choices\n~~~~~~~~~~~~~~~\n"); printf("q: Quit\n"); printf("s \'word\': Search word\n"); printf("d \'word\': Delete word\n"); printf("i \'word\' newTransl: Insert\n"); printf("Enter choice: "); scanf("%[^\n]s",choice); while(strcmp(choice, "q") !=0) { int op_code = parseOp(choice); // parseOP() gets the operation from choice char * word = parseWord(choice); // parseWord gets the word for op_code to be used if(op_code == 1) // Search { } else if(op_code == 2) // Delete { } else if (op_code == 3) // Insert { //char * transl = parseTransl(choice); // gets translation if op_code is == 3 } else if(op_code == 4) { printf("\nUnknown instruction. Please try again.\n"); } printf("\nPARSED WORD: %s",word); while((getchar()) != '\n'); // Clear input buffer printf("\nChoices\n~~~~~~~~~~~~~~~\n"); printf("q: Quit\n"); printf("s \'word\': Search word\n"); printf("d \'word\': Delete word\n"); printf("i \'word\' newTransl: Insert\n"); printf("Enter choice: "); scanf("%s",choice); free(word); } return 0; } //function definitions char * parseWord(char * word) { char * temp = malloc(101 * sizeof(*temp)); temp[100] = '\0'; int len = (int)strlen(word); int i =2,index=0; while(i &lt; len &amp;&amp; word[i] != ' '&amp;&amp; i &lt;=100) { temp[index] = word[i]; i++; index++; } return temp; } int parseOp(char * op) { char op_code = op[0]; if (op_code=='s') return 1; else if (op_code == 'd') return 2; else if (op_code =='i') return 3; else return 4; } // Obtained by https://en.wikipedia.org/wiki/Jenkins_hash_function uint32_t jenkins_one_at_a_time_hash(char * key, int len) { uint32_t hash,i; for(hash = i = 0;i &lt; len;i++) { hash += key[i]; hash += (hash &lt;&lt; 10); hash ^=(hash &gt;&gt; 6); } hash += (hash &lt;&lt;3); hash ^= (hash &gt;&gt;11); hash += (hash &gt;&gt;15); return hash; } void initHash(Entry * hash[],FILE * fp) { size_t len =1000; ssize_t read; int i =0; char * line = NULL; while((read =getline(&amp;line, &amp;len, fp)) != -1) { char * array[2]; //let array[0] == word // array[1] == translation char * p = strtok(line, "\t"); while(p != NULL) { size_t len2 = strlen(p); if(p[len2-1] == '\n') p[len2-1] = '\0'; array[i++] = p; p = strtok (NULL, "\t"); } i=0; hashAdd(hash,array); } } void hashAdd(Entry * hash[],char * array[]) { Entry * temp = malloc(sizeof(struct dict)); char * first = array[0]; char * transl = array[1]; int size = (int)strlen(array[0]); int hashCode = ((int)jenkins_one_at_a_time_hash(array[0], size)) % 22433; // if(hash[hashCode]-&gt;word == word) // { // // } temp-&gt;translation = transl; temp-&gt;word = first; temp-&gt;flag= 1; hash[hashCode] = temp; } 
Ahhhhh, you were right. Thats why it "magically" fixed itself. It does need to be unsigned, the input I was using originally didnt produce negative numbers but a different input I used did.
Writing web applications or interfacing with web technologies. Sure it can be done in C, but it's a complete nuisance that people abandon the language for something else entirely.
48 is the ASCII code for the character `0` 55 is ten less than the ASCII code for the character `A`
1. I never claimed that printf was more powerful than the streams facility of the C++ stdlib. 2. The goal of my program was to "Hello, World!" to stdout. 3. Asked the difference between C and C++, not how to use C in C++. My point is not that C &gt; C++. If you think that's what I'm saying then you are mistaken.
Ah, that makes sense, but could you also explain the process of the for loop at the bottom please?
Sure *C++* `#include &lt;iostream&gt;` `int main()` `{` `std::cout &lt;&lt; "Hello, World!";` `return 0;` `}` *C* `#include &lt;stdio.h&gt;` `int main()` `{` `printf("Hello, World!");` `}` 
But you can do OOP in C.
https://www.google.com/search?q=oop+in+c&amp;oq=oop+in++c+&amp;aqs=chrome..69i57.2703j0j7&amp;sourceid=chrome&amp;ie=UTF-8
That was an observation, not an offer. Help finding a particular bug in problem code is one thing, but if you want general review, you should really finish the code first. At this stage, I would simply note that your use of getline and strtok are fairly dangerous. Feeding "a\tb\tc\td\e\tf" in strtok will likely cause a crash. getline may or may not reallocate, so you probably aren't storing what you think you are when multiple entries are added. It also represents a huge memory leak.
Of course you can! What stops you from interpreting with C? [C Interpreters](https://www.google.com/search?ei=yYHNWsuDLKm-jwT7qbDoCA&amp;q=c+interpreter&amp;oq=C+interpret&amp;gs_l=psy-ab.3.0.0l5j0i20i263k1j0l4.81954.83993.0.85769.11.11.0.0.0.0.89.725.11.11.0....0...1.1.64.psy-ab..0.11.724...0i67k1j0i131k1j35i39k1j0i131i20i263k1j0i131i67k1.0.m3r6blruZOY)
No, you're wrong. You are saying the programmer can't do it well, not C. C can do it better than any other language you mentioned.
The while loop puts characters into an array. The for loop prints them out.
They can't be done in those other languages either, given time and resources constraints.
And you can write your own libraries.
You can be just as abstract with C as any other language.
&gt; What can't be done well with C? &gt; Writing web applications or interfacing with web technologies. &gt; Sure it can be done in C So, iow, it can be done with C. &gt;but it's a complete nuisance The only nuisance is the people who can't do it but claim they know better.
But it can be done well with C.
&gt; So, iow, it can be done with C. Never said it couldn't be. It just can't be done well. &gt; The only nuisance is the people who can't do it but claim they know better. Oh please, there is hardly any support in the language or ecosystem focusing on web technology. Please go ahead and show me web applications that are actually built on C. I imagine you would count maybe 5 at most. Meanwhile the rest are using PHP, Python, Ruby, every other language that isn't C.
&gt; Never said it couldn't be. It just can't be done well. Then you're flat out wrong. &gt;show me web applications that are actually built on C. I'd show you ours but I've made that mistake before. I would be embarrassed to tell anyone I used PHP or Ruby but we develop high end apps. Python we use to interface to third parties that require it but those interfaces are handed to us in C. Isn't that interesting. Just cause you follow the herd and use those clunky, slow languages, don't go thinking everyone else does the same as the reddit headlines tell you to think. 
You haven't told us what/where the error is
A language only does anything in the hands of a user, I'm considering how a language performs in the hands of a phosita. It's not simply that C in theory can do everything better either. C++ has abstractions that have taken years to properly generalize and implement into a language, the average user isn't going to be able to reach for those abstractions ad-hoc without serious investment on the underlying theory and implementation details. C isn't as expressive for formal logic as Prolog is. It can't prove things as formally as Coq can. It doesn't have powerful inbuilt symbolic mathematics like Wolfram. It doesn't have currying. My argument isn't that C is worse because of these things, simply that it serves different needs and isn't as suited to do certain tasks as well as other languages. It's evident enough that those other languages exist and get regular use in their niche. Like Erlang with massive concurrent networking, and Haskell with banking.
&gt; C basically cannot do _easily_ what other languages excel at. but they can't do easily what C does either, which is bare metal programming. One of the best summaries for the differences between C and other languages that I've ever had the pleasure of reading. 
Did you typedef 1 as true and bool as int? If not, then you're if statement at the end of you PlayAgain function is your problem. C does not native have a bool type or true/false.
Try replacing scanf("%c",&amp;choice); with do { scanf("%c",&amp;choice); while (choice == 'y' | choice == 'n'); What is very likely happening is that scanf is picking up another character that is in the input before the y/n character, for example, a newline character that got sent when you pressed enter on the previous line. Another option is to do this: scanf(" %c", &amp;choice); This tells scanf to match and skip any whitespace before matching a character.
Ugh, this is why it's bad to have magic numbers. Please replace 48 with \'0\' and 55 with 'A' - 10. It will act the same, while being much easier to understand, C treats characters equivalent to the numbers they represent.
&gt; The for loop prints them out. unnecessarily, because `printf("%.*s", y, hexans)` would do the job just as well.
All my english come from youtube videos, es lo que tiene no ser americano 🇪🇸
Would you care to say what flaws you have found and, if possible, any errors or warning printed by your compiler. The code I linked to compiles without warning or error with GCC 4.8.4 with Wall, Werror and pedantic all turned on, so I would be most interested in hearing what your compiler has to say.
It all worked but the problem is that the cycle must be checked a-d and d-d. The program doesn't do that at the moment. Program works fine, no errors of any kind.
It is a real bitch to do though.
Sorry I do not really understand what is missing. Not sure what you mean by loop as I see no loop constructs in this code.
I was told. Cycle A to D and D for control(made by google translate). Sorry if you don't understand :( 
Thanks, Yes, I agree. But I was interested as the first windows program I tried to write back in 2000 took 4 pages of source code to just get a hello world window on screen. I went into networking instead. 
Very well, makes sense. #define bit_set(v,i) ((v)[(i) &gt;&gt; 5] |= 1 &lt;&lt; ((i) &amp; 31)) #define bit_get(v,i) ((v)[(i) &gt;&gt; 5] &amp; (1 &lt;&lt; ((i) &amp; 31))) static ssize_t any(const char *s1, const char *s2) { uint32_t tab[8] = {0}; for (size_t i; (i = *s2++);) bit_set(tab, i); for (size_t i, j=0; (i = *s1++); j++) if (bit_get(tab, i)) return j; return -1; }
``` if (remainder &lt; 10) hexans[y++] = 48 + remainder; else hexans[y++] = 55 + remainder; ``` Should be: ``` hexans[y++] = hex_digit( remainder ); ``` with: ``` char hex_digit( int remainder ) { assert( remainder &gt;=0 &amp;&amp; remainder &lt;=15 ); if (remainder &lt; 10) return '0' + remainder; remainder -= 10; return 'A' + remainder; } ``` 
stupid question limits of what a language (C, java) for a platform (x86, java) can do are dictated by the platform not the language in most cases 
I read something the other month ago about how the correct way to prevent those memory aliasing warnings is by using a union. I can't imagine using a union would be able to cover every single situation where having a cast is necessary.
With a huge library of preprocessor macro's and scripts, maybe.
Help me understand, won't "std::ios_base::Init::Init()" be called before the main function is called?
We write web applications in C. Not singular. And have been doing it for over a decade. I have no need to defend anything. &gt;I'm sure you'll claim it is secure, robust, easy to code and maintain, etc. &gt;It might just well be &gt;I'm sure it is incredible. You answered your own question. &gt;The other millions are written in language that are better suited to doing so (even if they're clunky). Again, you answer the question yourself cause, in the back of your mind, you understand why we use C. Our work runs everywhere on everything and works with everything using smaller hardware making everything we do less expensive with fewer people needed to make it work.There is nothing we can't do and no hardware our code doesn't run on and no software our code can't interface. Where your code needs more hardware or memory or some library to run fast enough or work at all, ours hums along with no effort.
Why would you need to ditch javascript? Or replace it with C? You can, now, with WebAssembly if you need the speed but not for anything else.
How? By writing the code! There are libraries you can use but we wrote our own over a decade ago but, even then, there's nothing to it. Our libraries are small and only standardize things for us to use in our way but anyone can write this. It's not hard at all.
Try selecting msvc compiler in his link.
This project is in C#, which is entirely different from C.
webservers isn't hard in c what's is hard is html templating i.e. making a "template" of your webpage and then replacing/adding stuff to the template to generate actual html and javascript dynamically.
The for loop is a little confusing at first because it is missing the indentation or the braces. Neither is needed, but would make more readable. Remember when you have a loop or an if statement it assumes the next line is part of the block. So look at the loop like this: for (x=y;x&gt;=0;x--) { printf("%c",hexans[x]); } or for (x=y;x&gt;=0;x--) printf("%c",hexans[x]); 
 if (userChoice == "rock") You cannot compare strings like that in C, you need to use `strcmp()`.
~Java~ JVM
OP: "What can t be done **well** with C"
This subreddit exists to discuss the C Programming Language. Please redirect this to r/csharp.
Similar to how you have a loop in noteSave, you'll want to loop in notePlay, so you can capture all the notes. Each time you call fscanf, you'll advance through the file. To store all of these, you may want an array, so that you pass around one variable that contains all the values. From a high level, you'd want to declare an array. Iterate (loop) through the values in the file. At each iteration, store the value you captured into the array. Then do something / return the array.
Not without changing the while loop too. The for loop counts down, not up
You bring up some good points, and many things that I have experienced through this assignment. The reason I had that flag was cause the assignment called for us to know which entries had been changed, so I was going to use that flag to update the translation, but I figured out a better way to do it in the end! As for the collisions, she wanted us to do double hashing or quadratic hashing, which i'll probably use double hashing. Thank you for taking the time to write that up, it was very useful!
No. Example, coding diffie helman simulator in C vs python, 6-8 lines in python, 200 lines in C and I still had a bug riddled mess. C can do anything, but its a question of time. I've done OOP in C, I've worked on systems that used overloading, and enheritance extensively (implemented in C). it can be done, but it would have been quicker to do it in C++ or another langauge (but it was embedded so thats why it was in C)
&gt; nan-sayers I know full well this is a typo, but I'm stealing this bug as a joke feature Gracias
&gt; there were some warnings: -Wint-to-pointer, -Wpointer-to-int and the use of tmpnam. I fixed them all in a commit. - LHash_InsertItem(This-&gt;mKIndices, (void*)theIdx, (ui4)This-&gt;mGoal-&gt;mIndex); + LHash_InsertItem(This-&gt;mKIndices, &amp;theIdx, (ui4)This-&gt;mGoal-&gt;mIndex); Casting something to `void*` is not the same as taking the address of something. So you have significantly changed the logic of the program here. I don't see a corresponding change to the function. As a side note - don't commit large changes to whitespace at the same time as committing real changes.
Yuck. `main` holds the same assembly as the g++ version. I'm not totally sure why all that extra garbage is in there right now ... I think it's basically the standard library being linked in without consideration of dead code removal. I'm not sure if this is MSVC being stupid or if it's the site's fault.
Try running with Valgrind. Just taking a guess, if large graphs are segfaulting then you may be exceeding array bounds.
I tried your program, with the same input as your example (https://paste.debian.net/plainh/e2bb1a5c) but i got an Exception : ** Couldn't run algorithm Exception LMemory_OUT_OF_MEMORY (0x80070000) in file ../ll/src/core/common/LMemory.c at line 46. It fail to malloc 2400000000. (2400 megabyte) 
&gt; MSVC being stupid it could be the msvc links the entire crt by default
So C++ standard library encourages the practice of executing complex code before even the control flow reaches main where your start point should be? I can understand platform enforcing that (eg. windows loader executes lots of code before main) but a programming language that does and encourages that doesn't seem agreeable to me. It just spoils your thinking. Also many real C++ projects could just be crashing even before they executed their main thanks to things like this. Now I don't know if C has a way of doing this (excluding compiler extensions) but I've not seen the practice of executing anything before main purposely.
What you're seeing is the static initialization. [For example](https://godbolt.org/g/NyRJYY). Global variables can have constructors and destructors, and those constructors need to be run before your program can use them. So yes, that happens before `main`. (Or on library load or on thread startup.) I'm not aware of any equivalent in standard C, though GCC has a `((constructor))` attribute as an extension that I believe can be used to the same effect. Instead, what usually happens in C is a library will require that some initialization function be called manually before anything in that library can be used. This has its own set of problems, in my experience, mostly stemming from programmers not knowing about this requirement and forgetting to call the initialization or a function being called too early (for example, in an error handler). The [`atexit`](http://en.cppreference.com/w/c/program/atexit) function is standard, so you can register an equivalent to destructors to be run when the program closes. C++ isn't the only language to have this feature, BTW. A recent example from my work, Ada has what they call "elaboration" which serves a similar purpose. *In fact, any language that has constructors and global variables must have some equivalent.* The other solution is for the constructor to be run on first use ... but that has its own complications (extra tests to see if it's been constructed yet, no constraints on initialization ordering, and there's no defined initialization step).
&gt; including support for UTF-16. Ugh, [please no](http://utf8everywhere.org/). UTF-16 is a relic that needs to be retired. &gt; TR 24731-1: Extensions to the C Library Part I: Bounds-checking interfaces More useless Annex K type stuff. &gt; TR 24731-2: Extensions to the C Library - Part II: Dynamic allocation functions Except for the widechar crap, this is good stuff. Brings some good things from POSIX over into C. Notably this includes `ssize_t`.
I wonder why we don't get the same output. Would you know what is making the difference? I am using Debian Stretch (Linux hp 4.9.0-6-amd64 #1 SMP Debian 4.9.82-1+deb9u3 (2018-03-02) x86_64 GNU/Linux) along with gcc version 6.3.0 20170516 (Debian 6.3.0-18+deb9u1). I compiled using `make` as specified in the Makefile.
The fix should be ui4 theIdx; theIdx = (ui4)LHash_GetItemByKey(This-&gt;mKIndices, (ui4)theX-&gt;mIndex); LHash_InsertItem(This-&gt;mKIndices, (void*)theIdx, (ui4)This-&gt;mGoal-&gt;mIndex); becomes void *theIdx; theIdx = LHash_GetItemByKey(This-&gt;mKIndices, (ui4)theX-&gt;mIndex); LHash_InsertItem(This-&gt;mKIndices, theIdx, (ui4)This-&gt;mGoal-&gt;mIndex); Treat all casts with suspicion. They mean you're saying know better than the compiler which , when you're wrong, it bad news.
&gt; In fact, any language that has constructors and global variables must have some equivalent. why should me just including a header cause complicated code to be executed, a code that usually allocates memory and executes out of sight even before the main control? what's the behavior when multiple source files include the header? why am i getting a headache and i'm questioning my life decisions? this isn't raii! including a header isn't "acquisition". i may not use that header's functionality. anyway it's matter of taste. just like some ppl like giving up control (cuckolding) 
I thought this was a really fascinating piece of history. These are emails between 1995 and 1999 by John Mashey arguing with others about how 64-bit integers should eventually be standardized in C. This didn't happen until 1999. There was a lot of push *against* `long long`, along with lamenting that mistakes were already made going from 16 to 32 bits. There's also speculation about when 128-bit computers would arrive, with one estimate being as early as 2004 (!) and the most conservative estimate being 2020. &gt; &gt; 32-bit machines started to arrive around 1978 and 64-bit machines &gt; &gt; around 1991 (my dates are approximate). 128-bit machines will become &gt; &gt; available around 2004. &gt; &gt; Right now, a 64-bit file pointer can address all the data in 4Billion &gt; 4GB disks ... which not everyone can afford :-) by 2020, assuming &gt; straight-line progression, suppose we've gotten 13 doublings, you'd &gt; want to have a single disk of 32,000 GB (!), and now a 64-bit file &gt; pointer can only address 2^19 or, 512,000 of such disks, still likely &gt; to be adequate for most uses. Even on x86-64 today we're still only sing 48 bits of address. 128 bit computers are still so long off that it's not even worth discussing in 2018. However, some filesystems have moved to 128-bit sizes (i.e. ZFS). 
Those are Usenet posts, not emails...
I would use: char str[11]; // extra character for null terminator '\0' scanf("%10c", str); for simple cases. However, I think it's important to note *why* your `fgets()` example doesn't work, and it's because you're trying to write characters to a NULL pointer. In order for your example to work you'll need to allocate space for that character array, either on the stack via `char str[NUM];` where `NUM` is a constant or dynamically using `malloc()` like: int maxLetter = 10; char *guess = malloc(sizeof(char) * (maxLetter + 1)); fgets(guess, maxLetter, stdin); Hope that helps. Please ask questions if I've been unclear.
This is why you don't listen to professors, they don't have a clue about anything outside their niche turning potatoes into processors or whatever it is they are researching.
That was brought up in the linked posts. Basically, nobody thought of it back in the 70's, when word sizes based on non-powers-of-two still existed, and later on, it would break a lot of existing code and make life unpleasant because of that.
I see. If I declare char str[11] ; // Allocates memory. In my case it changes But in my case a user inputs how many characters to read from stdin. Once I get the number of characters to read ( say x), I need to store x number of characters in an array. The characters typed by the user will still be in the buffer. All I need is to extract the first x characters from the buffer and ignore the rest.
&gt; why should me just including a header cause complicated code to be executed, a code that usually allocates memory and executes out of sight even before the main control? Just to clarify: including a header doesn't cause these to be run. It's when you link against a library that has the global variable (whether or not you've included the header). The standard library is a bit special, though -- portions of it get linked in for you automatically depending on what you include (I think that's how it works, at least), so the effect is the same for `cout`.
If you want to read X characters, use fread(). If you want to read X characters *or* a complete line, whichever is shorter, use fgets().
One reason I suggested using an OS-provided `struct ip` from `&lt;netinet/ip.h&gt;` earlier is that it doesn't have a problem yours does on little endian systems like you almost certainly are using - your version and len fields will be backwards from what's in the actual ip header packet. Including an option field is problematic too, as they're, well, optional and may or may not be present in any given ipv4 header. Maybe treat them as a flexible array member... I don't *think* there would be any alignment padding issues. There's also no point to making things like `int8_t tos:8;` a bit field. That field is already 8 bits thanks to its type...
&gt;&gt; TR 24731-2: Extensions to the C Library - Part II: Dynamic allocation functions &gt; Brings some good things from POSIX over into C. Yes: `asprintf()`, `getline()`, `strdup()`... &gt; Notably this includes ssize_t. Did you find its definition anywhere? (I could not.) To see if matches POSIX's definition, which is a bit special (one always thinks that `ssize_t` is to `size_t` what `int` is to `unsigned`, but that's not the case). --- But this document is 10 years old. If it should have been accepted, it would have made it for C11; and as it wasn't and it hasn't changed, it won't be accepted next time either, don't you think?
&gt; Did you find its definition anywhere? (I could not.) Good observation. I just noticed it in the prototypes, but I don't see a definition either. &gt; it won't be accepted next time either, don't you think? Oh yeah, good point. I hadn't noticed the date.
&gt; ignore the rest of the characters user inputs? That's a bit tricky. How do you define “ignore the rest of the characters [the] user inputs?” Is it everything up to the next line break? Everything up to the next end of file? Depending on what you want here, the answer might be different. Generally, to read a fixed number of characters, use `getc()` in a loop or `fread()`.
Is it just me or is this site really stuck in 2016?
I tried to implement what you suggested and I couldn't get it to work and didn't fully understand what it was doing. For instance, you used read and I wasn't sure how I'd do the same thing with fread. This is due soon and I still don't have a clue as to how I could tackle this problem. Many people have explained to me what I could do (like yourself) and even gave me a starting point, but nothing is sticking. I don't know what I can do or even ask of you at this point. Would it be possible to maybe provide a sampling as to what a part of it would look like (i.e. parsing the first few bits and converting to the desired types, etc.). 
On the other hand, modern amd64 CPUs have 128, 256, and with the latest AVX, 512 bit registers, so having very wide integers in the language would be very nice. GCC already has __int128_t, but it's not standard.
thanks for pointing that out. i pass in Hand hand[] on another function. hand[count].row_index = row; hand[count].col_index = column; kind of looks like this, it works fine so i just assumed it's okay do it &gt; I put ? on the lines I'm having problems with. the question mark is to kind of mark the parts I'm having problems with.
There are languages that use C to produce their binaries. I'm not talking about how compilation works.
The 'documents' and 'meetings' tabs are up to date. The rest is a bit old indeed, but maybe there is nothing new relevant.
So what's your real code? row_index = hand-&gt;row_index[i - 1]; ? If so, there's a big difference between hand[count].row_index = row; and row_index = hand-&gt;row_index[i - 1]; `hand` is a pointer so you can dereference it with `[]`. `hand-&gt;row_index` is an integer, so you cannot dereference it with `[]` 
Ah, that's all I needed to hear, excuse me while I go review pointers for the 89375th time. Thanks!
&gt; C can do anything That is the only thing you wrote that has anything to do with the question. &gt; it would have been quicker to do it in Fast, cheap or good. Pick two. You can slap any ol' thing together fast but I'll run rings around your work when it counts.
Is C the best language for that? I've seen people become quite found of functional languages to define grammars and target IR. I'm curious what do you think C can do very well? C has long been one of my favorite languages but I feel I've been pretty fair thus far.
I guess I wasn't 100% with what was going on: how exactly the data could be decoded from binary to what it should look when I dissect it, how I could conceptualize the problem of shifting bits, how I could store the data, etc. I finally hit I breakthrough (I think). After some extensive reading and research I think I have a better understanding of what's going on and have much more code to work with. Assuming what I now have is correct, all I have to figure out is how I'd shift the bits to access the different fields and print them out in the desired way. I'll provide a link to what I got now. I'm starting to think I don't even need a structure for this. Code: https://pastebin.com/srU9p8hV 
You can't do something relatively complex that just works (not super efficiency needed) in a few lines and minutes. For example doing in a C program what you do with sed and awk (text processing) is nonsense .
Proof that you can write Lisp in any programming language. For Pete's sake, just use a loop.
You can use a union if you have a limited amount of datatypes. It works well. 
Example: https://godbolt.org/g/1nEMEq int sum_signed(int *vals, int i) { return vals[i] + vals[i * 2]; } int sum_unsigned(int *vals, unsigned i) { return vals[i] + vals[i * 2]; } Assembly (GCC 7.3 x86-64): sum_signed: movsx rsi, esi mov eax, DWORD PTR [rdi+rsi*8] add eax, DWORD PTR [rdi+rsi*4] ret sum_unsigned: lea edx, [rsi+rsi] mov esi, esi mov eax, DWORD PTR [rdi+rsi*4] add eax, DWORD PTR [rdi+rdx*4] ret Because `i` is unsigned in the second case, it had to perform the multiplication in 32-bit precision in case there was overflow. In the first case, signed integers cannot overflow (undefined behavior) so the multiplication is done in 64-bit precision inside the `lea` which is more efficient. 
I found a talk on YouTube about a year back with a real-world situation, where they changed a parameter (essentially an index into a data structure) from unsigned to signed in one function and saw big performance gains. The video was breaking down the generated code for each to see why signed integers gave much better performance. Unfortunately I haven't been able to find the video since :( You can find [contrived examples](https://www.airs.com/blog/archives/120) all over the place that describe the issues, but they're not as good as an example from real working code.
&gt; "long long" \*breaks existing code\*. (Because existing code has been given an iron clad guarantee by the standard that long is the largest type, and yes, real code breaks mysteriously when this is not true.) Wait what? 1. Did ANSI really guarantee that `long` would be the largest type? 1. What kind of code could possibly break if there was another (unused?) longer data type existing in the compiler?
Any feedbacks are welcome
Uh, iOS apps are generally written in Objective-C, which is just a shit ton of macros around C, so technically, it IS C.
The flip side of this coin is that you can cause undefined behaviour in the computation with certain inputs for the signed version; but the unsigned version is always well-defined. Increased speed = increased risk 
Signed integers can overflow, causing UB. The "cost" of this more optimized code for non-overflow cases is that there is no detection or mitigation of overflow. Demons may fly out your nose if the inputs to this function are not controlled in some way to avoid overflow cases.
And if you are writing portable code, as you should be in most applications? 
Was it [this talk](https://www.youtube.com/watch?v=yG1OZ69H_-o)?
Yes that was it! Thank you! The part I was thinking of starts at 39:30.
what about using c++ in kernel? the kernel is a single process where modules (drivers) are loaded dynamically. suppose i have a windows kernel driver and i have an extern C entry point (driverentry) that windows driver loader calls after it loads my *.sys in memory and that file includes those c++ headers? when will the c++ headers init. code be executed? I don't think it will ever execute. I think non standard environments (like C++ in kernel, C++ in PIC etc.) don't implement everything of C++ because even they know it's somewhat bullshit.
I would have guessed you're expected to lay the pixels out in a single block as opposed to using an extra level of indirection (i.e. an array of pixels instead of an array of pointers to arrays of pixels) Something more like: PIXEL *PixelArray = malloc(InfoHeader.Height*InfoHeader.Width*sizeof(PIXEL)); This, of course means to access a pixel at x,y you would use: PIXEL *p = PixelArray + y*InfoHeader.Width + x; BTW - your use of capitalization in identifiers seems somewhat unconventional, but that's really neither here nor there.
fuck bullshit why u wasting the time go save ur mother 
Thank you for your quick response! Actually, the all of the variable names included except PixelArray were already given in my assignment. Also my assignment stated that I needed to use a two dimensional array of pixels, which made me figure I should allocate them as I did. I also figured that being able to pinpoint the pixel with PixelArray[i][j].Red (or .Blue or .Green as the case may be) would seem a bit easier to work with. Also, how can I make my identifiers more conventional, and should the dynamic allocation work in its current state?
bullshit timewaster psycho
Sort of. struct passenger plane[] = { { .seatnum = "2jaa" }, { .seatnum = "2jab" }, { .seatnum = "2jac } };
Thanks 
&gt; But it read a newline as well. Have you tried.... stripping off the newline? IO in C is stream-oriented. You have to think of the user input as a stream of characters that comes in. Whatever the user types ends up in the stream. There is no way to discard what is in the stream but hasn't been read yet. So if the user types a line of text and then hits enter, you have to read all the characters he typed plus the final newline or the remaining characters the user typed are going to hang around in the input buffer until you read them, causing unexpected behaviour. The correct solution for your problem could look like this: 1. Use `fgets()` to read a line of up to 12 characters (10 characters you are interested in plus a newline plus the terminating NUL byte) 2. If the line you read contains a newline character, strip it off by overwriting it with a NUL byte 3. otherwise, truncate the string to at most 10 characters and read characters with `fgetc()` in a loop until you find the newline. Discard the characters you read Other solutions are possible as well.
Looks like a stack overflow caused by excessive recursion. Try to rewrite your code in an iterative manner.
gcc (Debian 4.9.2-10+deb8u1) 4.9.2 Linux debian 3.16.0-4-amd64 #1 SMP Debian 3.16.43-2 (2017-04-30) x86_64 GNU/Linux it is a VM with only 2G ram. that's why i get an out of memory. i'll add more ram and try again. your makefile isn't very good, i had to manually create the bin folder, and also missing the .PHONY rule. 
It's almost certainly simpler to initialize it at run time, though. The binary will be smaller and you won't notice the overhead.
Thank you very much for your help. So, the casts I made in `ll/src/core/common/LDiskStack.c` looks good to you? I hope I applied your fix correctly. When I compile, I get `warning: passing argument 4 of ‘LHeap_GetEntryAt’ makes integer from pointer without a cast [-Wint-conversion]` multiple times. Is this expected? I can commit it if you want to see exactly the changes I made. I tried to apply the same reasoning to `ll/src/core/common/LGraphGen.c` with no luck.
Thanks for the tip, I didn't know about .PHONY. I have just added it to the Makefile. Let me know if you get the same error with more RAM.
Hi OP, Based off how you wrote this, I think you're hitting stack overflows (I'm not getting errors with -Wall at least) The way your multiply and power funcions are written are **NOT** going to be able to take advantage of tail-call elimination. The addition in the return on the multiply, for example, stops it. Consider something like this instead int rmult_guts (int a, int b, int acc){ if (a == 1) return b; else return rmult(a - 1, b, b + acc); } Then wrap that with this if you like int rmult(int a, int b) {return rmult_guts(a, b, 0);} The guts function is tail-recursive in this case. However, like FUZxxl said, iterative is fine. Finaly, based on this comment &gt; I don't get an error in the terminal but a window pops up saying the .exe has crashed. It sounds like you run windows. If you want a good close look at what's happening, run your program under windbg. It's a really powerful and useful tool, although the windowing on it is a little bonkers
I tried running it on my schools Linux system and it worked without changing it, but the changes made it run on windows too, thanks!
I can't add more ram atm (VM is working) But i sugest you turn on some compilation flag and resolve all the warning you get at compile time. https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html A good practice for all your project is to compile with **-Wall -Wextra** and why not **-Werror** (Make all warnings into errors).
&gt; Learn C the Hard Way lame
The problem to this is what if a user enters 10 new lines and 10 characters afterwards. fgets is gonna read those new lines and ignore the characters a-z. But i want to ignore ‘\n’ as many times until I actually get characters a-z. I tried it in loop using getchar(). If ‘\n’ ignore else continue. And it works. I was wondering if there was any other way to read character besides using getchar()
Well, you could also use `getc` or `fgetc` which do the same thing. Why are you looking for another way?
To be pedantic, 128 bit CPUs kinda already exist in SIMD registers.
I disagree. If a variable will never be negative, I make that bad boy an unsigned integer. I'm not gonna fuck my codebase because compilers are stupid. 
[Loops are the de facto iterative methodology in C.](https://www.cprogramming.com/tutorial/c/lesson3.html) If you force everything through recursion, you're probably going to make some folks grumpy. &gt; The point of the recursion is to avoid loops. No, not really. Both are iterative methodologies, and both get the job done. [Looking to Ackermann](https://en.wikipedia.org/wiki/Ackermann_function) recursion covers a larger iterative space than looping, but loops can handle the vast majority of things you need to iterate over. My guess is that you're coming from a Haskell, Lisp, Scala, etc functional programming background maybe (I know some colleges will introduce FP languages as the first language). FP does not allow for mutation of values, as a side effect of that method of thought, loop like structures become impossible since they require mutation of something to exit, thus the only remaining method to iterate is recursion. Indeed, many FP languages let you define "local" functions nestled in larger ones simply to make iterative needs easier to avail.
The type casting, while not necessary is likely used for readability of the malloc() call. The reason it's a double pointer is because the "row" variable is a type of address which stores an array of addresses, but each row has it's own length, so an array of arrays, which both are dynamically allocated which causes row to be an address**
You're almost there. You have extracted the version into the bits xxxx0000, but you want to print 0000xxxx So you need to shift the bits you have to the right by 4 places. version &gt;&gt;= 4;
How do you "split" the decimal number 69? You do `69 / 10`, and you get 6.9 (and then just discard the numbers after the dot like it was integer division). That was decimal, so now for hexadecimal: `0x45 / 0x10 = 0x4`, which is the same as `0x45 &gt;&gt; 4`. (One hex digit is 4 binary digits)
I tried to do that, but I still get really strange numbers. I think that the way I'm reading them in is way off and I'm getting values say for the TOS where I'm expecting the version. I'm just not sure how to make it work correctly by reading each packet. I tried doing just an fread with the length of the packet so I could do that, but I guess that's not right.
I didn't actually know &gt;&gt; 4 was the same as that, so thanks for sharing that. But as I said above, it's hard to see how it looks because how I'm doing the reading is off (I explained why I think so above). Also, how do you remove the 0 in the front? It's still giving me 0x04 (in the places that seem to work correct).
&gt; Also, how do you remove the 0 in the front? You used `"%02x"` in the format string, which means it should print at least 2 digits, and when it isn't, pad it with 0s. So you just want `"%x"`. &gt; I didn't actually know &gt;&gt; 4 was the same as that Bit shifting is essentially multiplying by 2 (`&lt;&lt; 1`) or dividing by 2 (`&gt;&gt; 2`). So `&gt;&gt; 4` is the same as dividing by (2*2*2*2 = 16).
You're a wizard. Lol. But seriously, that was my main issue with this. Just one last thing, so when I print the decimal value I just have an int and set it equal to the hex I'm using (and do %d in the printf for it). Is it really that simple? I mean it looks correct from the output, but I don't understand how that's possible.
What do you mean? Can you put an example here? BTW, `%x` actually wants an `unsigned int`, not an `unsigned char`.
Note that as well as being redundant, it can be [potentially dangerous to cast the result of malloc and friends in C](http://stackoverflow.com/q/605845/253056). 
Surprisingly, "two dimensional array", is too bit ambiguous a term for me to be sure what your instructor meant. In my mind, what I suggested _is_ closer to a two dimensional array vs your data structure which is an array of pointers. I agree, that syntax for accessing elements seems more "array-like" with your data structure, but I think the way the data is laid out in memory (contiguously) is the issue when it comes to determining "array-ness". Your instructor might disagree. As for capitalization. Usually, all caps is reserved for macros. Struct members usually start with a lower case letter.
You may want to read more about number bases. Decimal, Hexadecimal and Binary are just *representation* of a number. So you can just do something like that: (Assuming you mean `version` instead of `len`) unsigned char version = (unsigned char)buf[0] &amp; 0xF0; version &gt;&gt;= 4; printf("Version:\t\t0x%x (%d)\n", (unsigned int)version, (int)version); It wants `unsigned int` because [the C99 standard (draft) says so](http://port70.net/~nsz/c/c99/n1256.html#7.19.6.1p8): &gt; The *unsigned int* argument is converted to unsigned octal (o), unsigned decimal (u), or unsigned hexadecimal notation (x or X) BTW for you "misalignment" for your second package (apparently wrong values), you just read an constant number of bytes, ignoring the actual size: fread(buf, 1, 20, fp); /* Why read 20 bytes instead of reading len bytes? */ Also move the packet-length reading code also into the loop, since you need to do it on every packet.
This diagram kind of makes me want to die.
I see. Thank you for your help!
I think it's always good with beginners to try and nip any bad habits in the bud, particularly if you can explain why they are bad habits. As with any advice though, the recipient is completely free to ignore if it they wish.
No, don't get me wrong. I do agree with the intent.
No problem - walking the line between helpful advice and overbearing pedantry and be tricky at times. ;-) 
Indeed, and I do apologise if my comment came across as unduly aggressive!
Ah, I'll change that then. As for the misalignment problem, I made a ton of changes and it's still present. I'm not quite sure how many changes were made, but I'll just include what it is in case: https://pastebin.com/3UtTxBa1 As I type this and look at my code I see that I do as you suggested, but still have that fread you pointed out as well. You should see it in the code. Do I literally have to just take that out?
Not at all, old chap.
It seems to polarize people but I'm liking it so far. I've learned a lot. Thanks for your useless response. 
What does "it doesn't work" mean?
Sorry it starts with the first loop of tom and stops it doesn’t move on
In your "current code" (the one on pastebin you just posted) you have a `char *buf`, but you never allocate something to it. Also, why 20? If it should be the size of the IP header (which actually is 24 bytes), then it is fine to read 20 (24) bytes first, but you still need to make sure that the data is actually 20+ (24+) bytes long, and you still need to read the rest of the data so it aligns up (or seek, but then you might not be able to seek when piping the file to your program). So you would check if the length is even correct, then you can read and parse the IP header, and then you need to read the rest of the data that is after the IP header. And next time you put your code on pastebin, please set the Syntax Highlighting to C, so commented out parts are easy to identify.
I appreciate this exchange. I understand both viewpoints. So it's truly never *necessary* but may help with readability? I just wanted to make sure there was not some secret esoteric situation where it was required. As far as readability, if I was not already familiar with this particular program, I think it *could* help with readability. 
Im not familiar with seeding RNG and I guess since rand() worked for me in the past it is threadsafe or did I just get lucky? 
Probably has something to do with all the race conditions and multiple initializations. See edits to my original comment.
I honestly don't know what I was thinking with the 20. I just got rid of it. As for allocating, do you mean with like malloc? I also cleaned up my code and here's an updated version:https://pastebin.com/A1N4cRan I think I know what is going on, I just don't know how to account for it with pointer arithmetic. I found a post on stackoverflow (https://stackoverflow.com/questions/30158919/dissecting-a-binary-file-in-c) that I honestly think was made by someone who had a similar assignment. Someone explained the bytes and all that, and I think what's throwing me off is some of the fields take up more than one pair (i.e. the addresses). How would I account for that?
&gt; Thanks for your useless response. hahahaha
&gt; many FP languages let you define "local" functions nestled in larger ones Those are called closures and are a core feature of all functional programming languages.
So I would be able to do all the initialization within the struct?
just do the init in the main before creating the threads
Like this:? pthread_mutex_init(&amp;(*share).lock, NULL); pthread_cond_init(&amp;(*share).jerry, NULL); pthread_cond_init(&amp;(*share).tom, NULL); And I would be able to access the same as i currently am?
Because there are essentially two integer types 16-bit short int and 32-bit long int. int is just a synonym for short int or long int, depending on which is "better" (e.g. faster) on the target platform.
May I offer a suggestion? Threads make things quite hard. Learn the basics of the language before you throw yourself into threads. `(*x).y` is a quite loud signal that you haven't mastered the basics yet. It shows good progress (I've done the exact same first time I was dealing with struct pointers), but the basics aren't there yet. Leave threads for later. I suspect that the problem could be that you're initializing the same mutex and condition variables in two threads.
https://www.reddit.com/r/csharp/
&gt; As for allocating, do you mean with like malloc? Yep. Or just use some array, like you did before. If you just parse the IP header, then you can just throw away the rest of the data (make "dummy" reads). &gt; I found a post on stackoverflow (https://stackoverflow.com/questions/30158919/dissecting-a-binary-file-in-c) Oh wait, 20 is correct, since the last 4 bytes, in the SO post, is optional, so sorry, my mistake. You might wanna use macros (`#define IP_HEADER_LENGTH 20`) or constant integer for such magic numbers. &gt; also cleaned up my code and here's an updated version:https://pastebin.com/A1N4cRan You still only read the packet length only once at the beginning, not with every packet. Also, you don't read the rest of the packet. Looking at an previous thread, the data are: [packet count] [packet length][packet data] [packet length][packet data] ... But (currently) you read it is like this, parsing the other packet lengths and data which are not valid: [packet count] [packet length][packet data] [packet data with old length] [packet data with old length] ... 
Thanks, I'm not super deep into FP (yet) so a lot of the terminology glosses off me.
&gt; For the identification, I should be getting 0x5cbd with a decimal value of 23741. When I tried to deal with that, I simply added buf[4] and buf[5] and then use htobe16() to convert that. Well, for one, as I already told you, `printf` with `%x` expects an `unsigned int`, not some other type like `int16_t`. And you don't need the `decimal` variable, see one of the parent posts. Also, `htobe16` does endian conversion, something different what you wanted to do. You don't even need to use it here. I told you that you can do `0x45 / 0x10` to get `0x4`. The inverse is, of course, multiplying: `0x45 * 0x10` results in `0x450`. You can figure out how to use the knowledge to "combine" them. &gt; What are all those other values in there? Padding? Which values? Padding is just.. padding. It's just there to mostly get some data at a certain alignment (e. g. on a byte alignment so it is easy to extract data from it). &gt; I also wasn't too sure about the addresses, given they should be in a x.x.x.x form. I'm sure they would be similar to what I would do with the 2 byte values, just on a larger scale. Actually, the IP address `1.2.3.4` would be stored as (in bytes) `01 02 03 04` (hopefully the endianess is correct). So you don't need really anything to stich it together, since you can do something like `"%u.%u.%u.%u"`. (You figure out the rest) 
They're being an ass, but they're [not wrong](http://hentenaar.com/dont-learn-c-the-wrong-way).
I'm aware that certain things are the author's opinion. I don't view it as an all-encompassing authoritative source and it won't be the only thing I read about C. 
&gt; `&amp;(*share).lock` can be written `&amp;share-&gt;lock` FYI
You aren't dynamically allocating anything, so all you are doing is overwriting existing variables.
My apologies. I tend to be slower when it comes to things, so I appreciate the patience you had with me. I figured out how to combine the bytes: uint16_t ident = buf[4] | (buf[5] &lt;&lt; 8); However, I do have to ude htobe16 because the bytes do in fact need to be swapped (I checked the output). Thank you for all the help! I think it extends well beyond the program; I know have a better understanding of bit shifting! :)
C# is off topic in this subreddit. Please post C# questions elsewhere, e.g. to /r/csharp.
To initialize an array you can do, just dont give the element number for the ones you dont want to initialize \(not sure if you need to specify number of elements or not\) eg, int array\[4\] = { \[0\] = 0, \[1\] = 1, \[3\] = 3, }; Your example if more complex obviously, struct passenger plane\[3\] = { \[0\] = { .first = { \[0\] = 'f', \[1\] = 'i', \[4\] = ' ', \(etc\) }, .last = { \[4\] = 't' }, \(etc\) } \[1\] = { }, }; Also sometimes its usfull to initialize a separate statically initialized struct and reference it as a const pointer. eg. Initialize each plan separately then; struct passenger \*plane\[3\] = { \[0\] = &amp;plane1, \[1\] = &amp;plane2, }; \(or something like that\)
It's not “the author's opinion”, it's garbage.
Cool it's completely worthless thanks 
Yeah that was the solution thanks
Why are you freeing all of the memory that you allocate? The new string that you've constructed is no longer valid once this function finishes.
 comb1 = doublylinkedlist-&gt;first-&gt;val; comb2 = pnode-&gt;val; I guess those do not point to proper strings. Well indeed at least `pnode-&gt;val` doesn't: just before there is: pnode = (struct Node*)malloc(sizeof(struct Node)); and then nothing is ever assigned to the various fields of `*pnode`, so there is whatever in `pnode-&gt;val`.
What isn't garbage? 
Im not sure how to compile with c99+. This language is very new to me and the class I'm currently taking isn't really helpful at all. 
Another problem I noticed. All the outputs of the code are already preordained. So whenever I put 'r' computer always gives back 'p.' I'm guessing its a problem with determineWinner().
It looks wrong to free comb3 since node 1 points to that memory. But comb1 and comb2 should perhaps be freed by someone or there is a risk that they are leaked (unless the owner ia outside of the list somewhere, but then who will know that the comb3 memory must be freed?).
ain't no way i am working through all that, but likely one of your rotations is wrong. add some debugging print statements to indicate what code is being called and see which code is only called for that case. 
Think about the expression `buf[4] | (buf[5] &lt;&lt; 8)`. Imagine the `buf` at position 4 and 5 is `AA BB`. Now you're bit-shifting the `BB` byte to the left of `AA`, so `ident` is actually `BB AA`. So you could just have swapped the indicies (swap `4` and `5` when accessing `buf`), avoiding a call to `htobe16`, which might do nothing if the host system is also big endian (and thus no conversion needed) (many people use x86 systems which are little endian), so it could be the wrong result on BE platforms.
1) You're not allocating memory for `buf`, so your program doesn't crash by chance. Either declare `buf` as an array large enough for any packet, like: char buf[1024]; Or allocate memory as needed: buf = malloc(len); If you go with the first option, be sure to check that `len` is smaller or equal to the array size before you call `fread()`. If you go with the second option, don't forget to release the memory with `free()` at the end of the loop. 2) Some of your format specifiers are not right. For example, at line 44 you use `%hx` (which expects an `unsigned short`) but pass an `unsigned int`. 3) The way you read the checksum is a bit weird. First, you should be using unsigned values, since left shifting a negative value is undefined behavior. Second, you don't need `htobe16` at all, that's just a waste of can time. Just do uint16_t checksum = ((uint16_t)buf[10] &lt;&lt; 8) | buf[11]; you never need to know the byte order of the host processor when reading data from files, so you should never need to call functions like `htobe16`. [Here's an explanation](https://commandcenter.blogspot.com.br/2012/04/byte-order-fallacy.html). Enabling warnings on your compiler should tell you about problems 1) and 2), so be sure to always have them enabled.
No, when the user enters a character and hit the _return_ (or _enter) key - that will put a newline in the input stream.
For the other case (line 42): uint16_t ident = buf[4] | (buf[5] &lt;&lt; 8); I would do the same as well right? I thought so, I just wanted to verify that. I modified the cast to unsigned short at lines 44 and 51 and I think that resolved all the issues you pointed out. Thank you so much for providing the abundance of information! 
&gt; For the other case (line 42) [...] I would do the same as well right? Yep, just like `checksum`. &gt; Thank you so much for providing the abundance of information! You're welcome! 
I would have to say I found your code a BIT amusing.
Tried that. Still fails right at the y/n question.
The code would have to be run when the module is loaded. At least, that's how dynamic libraries work in userspace. The dynamic loader know to run the static constructors when the library is loaded, and then run the destructors if it's unloaded. That means the loader has to be C++-aware, of course, just like how you can link C and C++ code together, as long as you're using a C++ linker. The same thing would happen with a kernel module, I imagine. The linker would create the `init_module` (Linux) or `DriverEntry` (Windows) function and use it to run the static initializers before passing control over to the user code, probably provided in a separate function. That's what happens in userspace: `main` isn't the actual entry point for your program ... that title belongs to `_start`, which calls `main` at the end. C++ just generates a more complex `_start` than C does. &gt; I think non standard environments (like C++ in kernel, C++ in PIC etc.) don't implement everything of C++ because even they know it's somewhat bullshit. I'm not sure what you're talking about. MPLAB is a PIC compiler with g++ under the hood, and from what I can tell it has most of C++ available -- even exceptions. What isn't available is the full C++ standard library ... but not even the full C standard library is available when developing the Linux kernel, so that doesn't bother me one bit. Is there a specific feature you're aware of that isn't implemented? It's very common for a lot of embedded environments to not have a C++ compiler simply because it takes a lot of work to support. It's absolutely a bigger language, with many, many, many more features. It's just cheaper and easier to supply the same C compiler they've used for 20 years. And if they do implement a C++ compiler, it's certainly going to have less support -- not because the features are *bad* in that environment, but because it's a lot of work to implement ... and for very little gain. Why bother with exceptions, if most people have been trained to not use them in an embedded environment?
You've only posted your original code, so it's hard to comment on changes we can't see. There is more than one `scanf`. Did you _fix_ them all? Barring that, it's time to roll up your sleeves and do some debugging. I don't know what environment you're in and what tools you have available to you so it's hard to give specific advice. Stepping through your program is the obvious first thing to do. If you can't do that, put in some printfs. See what the actual characters you're processing are. Are they what you expect? Is your code handling them how you expect?
*drum roll and high hat* He's here all week, folks. Try the veal...
NOT FUNCTION POINTERS, CHADDY BOY now there's a pedanty, fresh from forchin!
 conn-&gt;db-&gt;rows[i]-&gt;name = (char *)memset(conn-&gt;db-&gt;rows[i]-&gt;name, ' ', conn-&gt;db-&gt;MAX_DATA); Does memset need a cast? Also, why is it being assigned? All of the examples I see don't show it being assigned to anything.
Thank you!! I was half asleep writing the code, was up all night trying to complete parts of the assignment. I didn't think it through. Really appreciate the help.
&gt; Basically
I think you should use the bitwise AND operator (&amp;) on it. I'm not sure what you're asking though.
From what I can see, comb3 is not freed. Is that on porpose?
If i free it, it doesn't do the intended action. Memory is corrupted and gives weird values.
Thank you! That fixed two of my memory leaks but I still don't know how to free comb3 without having issues. Any suggestions? Thanks again
Do you make sure to free the `val` of each element in the list when you destroy the list? You're right that you don't need to free it within this method, but it'll leak if you don't free it when you destroy the list.
https://pastebin.com/XXgGQsew this is how i initialize the doubly linked list and destroy it. Doesn't freeing the node free the prev, next and val associated with the node?
Nope - they're memory which have been allocated separately. Before you do `free(temp)`, do a `free(val)` to free the memory the value is stored in. Think of it this way - every call to `malloc` has to have an associated call to `free` to clean up the memory that was allocated. You call `malloc` once to create a node, and `free` to destroy it. But you also call `malloc` to create the pointer you place in `val`, so you've gotta match that `malloc` with another `free`.
f.com ?
how do i free it in my case? I can't seem to figure it out. It keeps having unintended effects. Again thanks for all you help
&gt; use it to run the static initializers before passing control over to the user code "static initializers" can (and will in big projects done by c++ hipsters) have "user" code. suppose I want to set the iostream init's code section to be discarded from memory after executing (like we do it for driverentry using pragma init) how do i go about doing that? &gt; C++ just generates a more complex _start than C does. I don't think c language generates any "_start" of any kind. Maybe the platform dependant and completely replaceable and popularly unused, C's standard lib, does but C language doesn't provide anyway to do it. It seems C++ explicitly allows you to have things running before main (or static initializers) even if you're not using C++ std lib. The name static initializers suggest they have a "static" or file specific scope? Do they? When multiple files have static initializers what is their order of execution? When multiple files include IOSTREAM.H does its static initilizer still run multiple times? It seems they've done some handling in windows code. _CRTIMP2_PURE void __cdecl ios_base::Init::_Init_ctor( ios_base::Init *_This) { // initialize standard streams first time if (0 &lt;= _Init_cnt) ++_Init_cnt; else _Init_cnt = 1; } &gt; I'm not sure what you're talking about. I bring up PIC and win kernel because those are the places I see maximum changes happening. The platform owners are out with pitchforks to scare away C. But everybody I know who's serious about their product still stubornly uses the old way (i.e. they use the old compilers and buy the older chips for PIC and use WDM for windows kernel)
You may want to indent your code properly. Anyway, think about what you wrote. ``` if (a &gt;= 1) { d = b + c; } else if (a &lt;= 2) { d = b - c; } ``` The first branch is taken when `a` is greater or equal to 1. Thata is also the case when you type a 2. So you want to change the condition to `==`.
Your first if statement is checking if the entered number is greater than or equal to 1, when you enter 2 this statement is true and the else if after that is ignored (because the first if was successful so it won't check the else) Change your statements from =&gt; and &lt;= to == and the if statements will check if it is precisely 1 or 2
oh okay now i feel dumb , Thank you so much 
got it Thank you for your replay
You see the big on the bottom of your keyboard? It's called a "space bar". It's used to insert "spaces". Try hitting it [once or twice](https://en.wikipedia.org/wiki/Indentation_style) while programming.
**Indentation style** In computer programming, an indentation style is a convention governing the indentation of blocks of code to convey program structure. This article largely addresses the free-form languages, such as C and its descendants, but can be (and often is) applied to most other programming languages (especially those in the curly bracket family), where whitespace is otherwise insignificant. Indentation style is only one aspect of programming style. Indenting is not a requirement of most programming languages, where it is used as secondary notation. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Under what circumstances would you need to do this? Let me know then I'll tell you more.
`memcmp()`
I'm not exactly sure what you're trying to accomplish. It sounds like you're reverse engineering a file and storing it as a new file. If that's the case it's best to have two data structures, one with the old and one with the new structure. You can always include the old structure in the new one. The extra 00s could be intentional or unintentional alignment padding. If you're asking if you can use that padding to store extra data, the answer is probably, but it's hard to know for certain.
I did try that, but I think I made a mistake somewhere and I couldn't compile it. I kept getting this error: warning: passing argument 2 of ‘memcmp’ makes pointer from integer without a cast 
And did you try to figure out what that meant? I assume you have access to documentation. If not, just google “man 3 memcmp”. Also, don't expect people to debug code they haven't seen.
I did look around but I genuinely couldn't figure it out. I wouldn't be asking here otherwise. Sorry if I broke any rules but I just can't figure this one out by myself.
I don't have more information, mate. I posted the loop I have in the original question and that's it. 
That's okay, I will try and post it. Below relevant portion of the code, the rest of it literally doesn't matter so no point in me posting everything. //print word and ciphertxt printf ("Word: %s Ciphertxt: ", key); for(int j = 0; j &lt; outlen; j++) // loop to print out the buffer { printf ("%x", outbuf[j]); } printf ("\n"); Which spits out every word from the txt file with it's cipher and looks like this: Word: zippy Ciphertxt: a6b5775d2aa6e308f596b40c5b86b383ba5c25b38fd4d34ce1cf740fb226645 Word: zircon Ciphertxt: ca969cbbe756e41b231b2f2515494583d3cd92ef68b0b671ddb2313c48327dad The next portion of the code (loop where I am stuck) is supposed to look through the ciphers and try and match it with the original ctxt array with hex in it, and find the corresponding cipher. for(int q = 0; q &lt; outlen; q++) { if (outbuf[q] == ciphertxt[q]) { printf("Found a match!\n"); } }
A better way would be to write a program that deserializes the file with the old struct layout, then reserialize with the new. When you add a field to a C struct, it's up to the compiler to determine how much space that takes, so it's not really dependable to edit a binary dump by hand. Take a look at [Cap'n proto](https://capnproto.org/) as a good example of implementing a binary serialization format that allows adding and removing fields without damaging backwards compatibility.
That kind of loop is not good. You want a positive output only when *all* bytes match : bool match=true; for(int q = 0; q &lt; outlen; q++) { if (outbuf[q] != ctxt[q]) { match=false; break; } } if(match) { printf("Found a match!\n"); } ------- BTW, the cyphers always have the same length, and that length is the same as the length of `ctxt`, right?
Here. Have a courtesy upvote. You're gonna need it.
here's the code of my game: https://ideone.com/fGJqCq
I've always written my own serialization and deserialization by hand, this way you control the bytes and the endianess of integers. I guess this guy just wants to pass the struct directly to fwrite and fread? That's the way Microsoft wrote out file formats in the 80s/90s so I don't think that's a great idea.
you may want to check the [r/csharp](https://www.reddit.com/r/csharp/) subreddit. This sub is for C specifically, so you're unlikely to find much help here.
You should also be aware of not having a fail safe condition, unless it doesn't matter. In this instance: If (a &lt; 1) { ... } else if (a &gt; 1) { ... } This will not do anything if a == 1 and can be a hard bug to figure out. Do your best to try and keep it as simple and concise as possible. I would recommend: If ( a == 1 ){ ... } else if (a == 2 ){ ... } else { ... Show error ... } 
If I understand you correctly, you save a file (like a game state) by writing your data directly to the file. This is not portable, even over compiler versions if you're unlucky. Serialize the data instead into a fixed format.
1) this is a C-subreddit, not C++ 2) no, you just keep returning pointers 
First off, this is a sub for C, not C++. An array in C/C++ is just a pointer, so if you want to avoid pointers just don't use C or C++ because they're essential to doing most things.
No. Arrays aren’t a first class concept in C++; it’s just some syntactic sugar for a pointer and pointer arithmetic. You could return a struct with a field for the pointer and a field for the “array length” (length of the allocated block pointed to). Basically what you return and pass around needs to have a known size at compile time. You probably shouldn’t do that; I was just listing it for explanation’s sake; your use case might fit std::vector; you can return one of those (its implementation is similar in principle to what I described above).
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
It's not a terrible idea, as long as you don't care too much about backwards compatability, or you can guarantee the compiler packs the struct in the dependable way (by say, [writing your own C compiler](https://en.wikipedia.org/wiki/Microsoft_Visual_C%2B%2B\)).
iirc if you're running on an x86 machine then it should be exactly the same because there are single instructions for both 
If you're comparing with a constant then the compiler should be able to choose appropriately in case of an execution time difference.
https://godbolt.org/
Wouldnt it be faster with &lt;=10 since &lt;11 will include float type check between 10-11 which would create more calculations if they are not integer? But either way dont matter cause the difference wouldnt be noticeable 
Depends on what you are doing. Don't think about performance here—the compiler is smart enough to figure out which way is faster anyway.
in terms of speed, you should look at the asm code, because the instructions will tell you remember that is not the same fewer instruction than faster execution, it depends on memory reads and stuff. So I probably will end writting &lt;=10 because it just looks better, only if the asm says otherwise I would change it
&gt; memory management, pointers These are not higher level topics. These are among the most basic concepts you have to understand to program in C effectively, if you have neither understood pointers nor the basic concepts of dynamic memory allocation, you should really not program in C.
Even without distinct instructions, I'd imagine a compiler would optimize the comparison when integer types are detected.
If you are using floats &lt;11 and &lt;=10 arent the same anymore. What you are saying makes absolutely zero sense.
&gt; in terms of speed, you should look at the asm code No, you shouldn't. The compiler knows better.
I think you would get more replies if you clarified what you were trying to do. Your code is undocumented as well which makes it hard for others to understand what is going on. That said, what it is you are problems with?
It doesn't matter if you're comparing a float to an integer. 10.1, 10.5 and 10.4638 all begin with a 10 so they must be larger than 10 and smaller than 11.
thats what im saying. If they are float comparison &lt;11 and &lt;=10 would be different
sorry man. reddit said that i should limit my words into 300. Anyway, my problem is that I want to make a scoreboard about the game(who can finish the game faster). I don't know how to start because my knowledge on files is limited. FeelsBadMan
What you said was, that &lt;= 10 was faster than &lt;11 if you compare floats. Which makes no sense since these statements arent equal.
Im sorry but I am not getting it. Please fix me if Im wrong. Since those statements arent equal, and assuming they are both float, there is variety of floats between 10-11(10.2,10.4,10.78,etc), which would make &lt;=10 faster since it includes less floats to consider. Or are comparisons just not done like this?
The assumption here is that we're talking a about integers. With floats, equality is basically meaningless. Which means that, when using floats, you should assume that there is no meaningful difference between &lt;=10 and &lt;10. 
No sarcasm whatsoever. I have some questions for you now. What makes K&amp;r C so good? Words like canonical, sacrosanct, and biblical often come to mind when I think about reviews. Is the book truly that good as a learning resource? Or is it just the nostalgia of a bunch of old programmers who had it as their first exposure?
Because of this, I would tend to use the number (10 or 11) that best corresponds to a significant value in the code. Am I iterating a loop 10 times, so 10 is significant? Or am I making sure that the value is below 11 because the number 11 is significant to the algorithm somehow. This improves readability, which is important.
&gt; But it seems most books do not speak of them as often That's because there is really not a lot to say about these two topics. Pointers point to things. Dynamic memory allocation works according to the simple rule that for every `malloc()`, there must be one call to `free()`. Everything else are design patterns built on top of these building blocks and thus out of scope for a book that teaches you the C programming language. What you might need to practice is programming in general. The C language is just a medium to express your programs in. It is not the purpose of a C book to teach you how to program. The purpose is to teach you the syntax, concepts, and idioms of the C language so you can use your existing programming skills to write programs in C. For programming in general, there is no good book I can recommend. Typically, people go to university and study for multiple years to learn how to get good at programming. If there was a book that could replace all of this effort, I would gladly read it. Though for starters, try a random algorithms and datastructures book as wall as a book on language theory. These are the two topics you learn first at university and they are the most fundamental concepts of computer programming. Also, practice a lot by writing programs. Read source code written by good programmers (I can recommend the source code of the OpenBSD operating system and its userland) to learn how well-designed C code is written. Never resort to copying code from other people, always think about the problem until you figure out a solution on your own.
It's short, well written, and straight from the horse's mouth, since the R in K&amp;R is the man who created C in the first place. It's old but not outdated, and it will teach you everything about C that you can learn from a book. The rest will come from reference manuals and experience.
Well, an idea would be to write a struct that holds a score (name and time) along with a read function and a write function that converts the struct to a text representation that can be stored in a file. When the program starts, read the file into an array of scores and when ends, write the new scores back to the file. Some tips: - To read a score you can use fgets which fetches a line from the file. - You can serialize scores in the format name:time and read up to the colon for example. - Writing a score to the file is as easy as `fprintf(file, "%s:%d", score.name, score.time);`
I've taken a couple of programming classes before and decided that I wanted to learn the C language. Unfortunately, my college didn't have a C language class until this upcoming semester so I've been teaching myself with various resources. I'd really like to become better at programming and C, but I wasn't sure if these topics went any deeper than what I've seen. Otherwise, I appreciate the time you took to say this and help me find the right direction in my questions.
If you are ever curious about what exactly your code is doing you can use objdump to help. After you compile your code use objdump on the generated binary file to view a disassembly of the code and see each instruction. In your terminal just use $ objdump -d yourcodefile.o In general, it is better to worry about clarity for small things like those operators. Focus more on learning as much as you can about systems with C, memory management, pointers, etc. Those will be much more valuable in your career as a programmer.
The compiler produced the asm code. It will definitely not hurt and it’s a nice exercises.
He meant the assembly generated by the compiler.
this tbh fam gcc and I'm sure many other compilers can even do TCO for ( at least when I tested it for a presentation) relatively simple cases.
I believe /u/mininny1004 is under the impression that the actual comparison is implemented by checking against every possible float. So `x &lt; 11` becomes `x == 0 || x == 0.0000000000000001 || x == 0.0000000000000002 || ...`, and the chain will be longer for `&lt; 11` than for `&lt;= 10` so it will be slower. This is in fact *not* how comparisons are implemented. Float comparisons are constant time operations.
Thank-you for your help, I actually did manage to solve the problem twice. My lecturer mentioned he didn't like searching through the whole alphabet, so I tried to search the input string instead and slowly managed to get a working program. 
Perfect answer. Clarity is King.
Variable argument lists, conditional compilation, double indirection.
&gt; gcc and I'm sure many other compilers can even do TCO It's often a question of whether you can ensure TCO (Tail Call Optimization, for those unfamiliar). Functional languages prefer recursion, but in Common Lisp, TCO is not a compiler requirement, so loops are best practice. TCO is mandatory in Scheme, though, so recursion is best practice there -- the language doesn't have loops in the standard library as far as I know. C doesn't mandate TCO even a little bit, and you have to bear that in mind when using it in practice, lest you risk blowing out your stack. Linux defaults to an 8MB stack, and Windows to 2MB I think, although the default Windows linker can adjust that. 
Which then leads to a discussion whether the compiler knows it's a constant. Defining constants as macros ensures it, but there are good points to using const variables, too. 
Just a question: which instructions are talking about? Just because there is a single instruction does not mean that each instruction takes the same number of CPU cycles. And this may vary from processor to processor. I do not know x86 machine code, but once the code is complied I am assuming that it would load the two values into registers, a compare operation would be used on those two registers and then the jump or branch would be issued on wether "&lt;=" or "&lt;". Just unsure of if the former ("&lt;=" ) requires an extra step.
&gt; "static initializers" can (and will in big projects done by c++ hipsters) have "user" code. You're right, I misspoke there. But I think you know what I meant. &gt; suppose I want to set the iostream init's code section to be discarded from memory after executing (like we do it for driverentry using pragma init) how do i go about doing that? That would have to be the job of this hypothetical tool, as it's generating the function for you. &gt; I don't think c language generates any "_start" of any kind. Maybe the platform dependant and completely replaceable and popularly unused, C's standard lib, does but C language doesn't provide anyway to do it. It seems C++ explicitly allows you to have things running before main (or static initializers) even if you're not using C++ std lib. As defined by the language, `main` is the entry point for your program. On Linux (and I believe Windows has an equivalent), `_start` is generated by the compiler as the actual entry point from the operating system, and that's what calls `main`. This is true for C as well as C++, as there are sometimes initializations that need to happen in C as well, before `main` can begin. The difference is that C++ allows you to hook into this process to do your own initialization automatically. None of this has anything to do with the C++ standard library, it's a feature of the language itself. &gt; The name static initializers suggest they have a "static" or file specific scope? Do they? No, that's not what the name means. In this case, "static" refers to ["static storage duration"](http://en.cppreference.com/w/cpp/language/storage_duration) -- a concept [common with C](http://en.cppreference.com/w/c/language/storage_duration), actually. It's not about scope. &gt; When multiple files include IOSTREAM.H does its static initilizer still run multiple times? It seems they've done some handling in windows code. The initializer is specific to the object in the compilation unit, and so will only be run once (per object being initialized) no matter how many times a header is included. For example, `cout`, `cerr`, and `clog` might all get initialized, but only once. Regarding that windows code, my guess (and this is only a guess) is that this has something to do with virtual inheritance, but I'd have to dig into that more. &gt; The platform owners are out with pitchforks to scare away C. Huh, I haven't noticed that myself.
&gt; I guess this guy just wants to pass the struct directly to fwrite and fread? That's the way Microsoft wrote out file formats in the 80s/90s so I don't think that's a great idea. They always justified it on speed grounds. Yet they couldn't manage simple `htonl()`, so you'd frequently get platform-specific files just because of the endianness difference between Motorola 68k and Intel x86. Let's not even get started on the different codebases and epoch dates of Mac Excel versus Windows Excel. Having said that, Microsoft was originally quite adept at producing separate, text-based cross-platform formats for interoperability. DIF was a Visicalc interop format that predated Microsoft's efforts, then Microsoft did the more-ambitious SYLK spreadsheet format, then moved on to RTF for word processing. As time went on, Microsoft decided that interoperability now helped their competitors more than themselves, so they dropped all pretense of supporting open standards. No more OpenGL, now carrot and stick developers into DirectX. Then, later, outside pressure pushed them into pseudo-documenting their file formats under "open specification promise". If only their software rigorously abided by the documentation, and if the standards weren't blatantly implementation-defined. 
Off the top of my head I can think of jl (jump if less than) and jle (jump if less than or equal). Since they're both jump calls I believe they take the same number of cycles but I don't know enough about x86 assembly to know for sure. I'm 99% sure they are the same number of cycles on ARM as well. Anyways like someone mentioned before even if they were different the compiler would most likely optimize it to be the faster one. 
`#pragma` isn't portable. I'm not sure if `#define __attribute__` is considered portable or not. 
The thing is, if you would iterate 10 times I would use &lt; 10 ;)
Technically, for integers, they're identical. But for a loop, when your loop index starts at 0, I I definitely prefer "&lt;", because it makes clear how many loops there will be: for(i = 0; i &lt; 11; i++) { ... } That's 11 loops, even if the index goes from 0 to 10. 
very useful comment
C# language is *related* to C language, but is also quite different. They're like cousins. Rather distant cousins. What the languages are most frequently used for in practice is also different. C isn't used directly to build websites very often (although it can be -- and they'll be fast websites). Most importantly, while software development in any language requires testing, this isn't a testing subreddit. Software testing is a huge endeavor of its own. However, a couple of tips. You can use ApacheBench -- `ab` as a basic testing tool. A more useful and modern tool is [Siege](https://www.joedog.org/siege-home/). Both are written in C, incidentally. Under optimum conditions, a modern two-socket server can handle [one million hits per second](https://www.techempower.com/blog/2014/03/04/one-million-http-rps-without-load-balancing-is-easy/). Good luck! 
You're right, but in this case I think the two I'm thinking of (jl and jle) are the same number of cycles
Thanks for the response. Again - I'm not sure if this is correct, but prior to the jump command (wether jl or jle) would not a compare command need to be completed? I think there may be extra work for a "&lt;=" operation versus a "&lt;" operation. But just guessing of course.
So I tried doing this and now it goes back to repeat the code, though it ends at the y/n question.
Yeah, this is where my knowledge of x86 ends so I'm not sure. I know that in ARM a cmp then any of the branch commands is the same number of cycles. Whether x86 is the same, I don't know
I'm so tired right now that I had a minor freak out reading "dynamic memory allocation" thought I didn't know what it was, then read malloc, and basically fell back asleep
On Intel, with no optimization, gcc produces almost identical code except for: cmpl $11, %eax jge LBB0_4 in &gt; 11 case and cmpl $10, %eax jg LBB0_4 in &gt;= 10 case. The `cmpl` instruction will obviously take the same amount of time regardless of its arguments. `jg` and `jge` have the same latency.
&gt; C doesn't mandate TCO even a little bit, and you have to bear that in mind when using it in practice, lest you risk blowing out your stack. Perhaps I should add that you're 100% right and in production C I wouldn't recommend actually relying on the compiler, It's just cute that for many cases today's C compilers are smart enough to perform such an optimization. 
It is a pointless exercise which will at best confuse you and at worst give you the illusion that you understand what is going on. You don't. Modern CPUs and compilers are indistinguishable from magic. When faced with a choice as that presented by OP, pick whichever version makes the most sense *to a human reader* and trust the compiler to do its job.
&gt; Based on my research, typecasting a malloc() call in C is actually discouraged. Casting the result of a `malloc()` is basically a C++ism at this point. I think Microsoft's C++-centric toolchain may have warned if you didn't do it in C. It always catches my attention right away, to be frank. 
Yes, because the serialization process is also written in code compiled by the same compiler, st. it "knows" the exact memory layout of the data. With serialization you can turn this platform-dependant data into platform-dependant data, eg. asa text file like json, toml, ini, ...
even if they weren't true, having the value as a constant a compiler could be smart enough to convert the code to whichever instruction is fastest. So it could convert the number to 10 or 11 and the according instruction. I recall some language even have things like "not" as a macro that convert a &lt; into &gt;= for example. 
The speed at which a float will be compared doesn't depend on the number you compare it to. So if you compare a number with &lt;10 or &lt; 100 it will be equally fast and we can only assume that if that &lt;= 10 or &lt;= 100 would be equally fast. The main difference you have with &lt;= 10 and &lt;11 with float is that if you step with a number smaller than 1, you'll never have a variable higher than 10 in the first test but in the second you could have as close as it can be to 11. But if your step is an integer both condition will be identical. 
Just make sure you don't do this if you aren't comparing an integer. If you are comparing a double/float a &lt; 11 is NOT the same as a &lt;= 10. There is an entire infinite number of values that exist between 10 and 11 that would make the first one be true and the second one be false.
This is about a binary format. Binary formats are not portable. 
Just for development with C, you can pick up concepts as needed fine; there's no point knowing about features you never need. If you want to learn C just in the pursuit of knowledge you could implement a C compiler. It's not clear from your post whether you are new to programming but if you were to attempt to implement a C compiler (even if you fail and give up after a week or two) you'd come out of the exercise with a much deeper understanding of C.
File format portability and code portability are largely orthogonal. 
Thanks for that. It was very helpful. I'm not necessarily new to programming or C language. I've been going through the basics and I believe I know them faily well. Ive honestly been thinking alot about C for embedded systems. I have an Arduino, which I think is good for that. 
You need a format like JSON or XML which basically includes labels for each part of the data it is storing. The upside is it is more portable and flexible, the downside is it isn't as dense and slower to process. JSON and XML is fine for small amounts of data or data where the format changes frequently.
Yeah, I am aware of rational numbers. Thanks, anyway :)
No worries :) It seemed like an obvious point, but not everyone on this subreddit is aware of these technicalities, so better safe then sorry.
in my opinion, optimization and readability are two important things to consider. If you have a big chunk of code that can be condensed and made more efficient without sacrificing readability, then by all means, do so. However, if you CAN make the code more efficient and compact, but it becomes difficult to understand, it might not be worth it. in cases like these, consider breaking the code into smaller pieces that are easier to digest. If the code connot be broken down or simplified for whatever reason, leave descriptive comments on how the code works and what it does. of course, speed isn't always a big priority. having lengthy code isn't always a bad thing if it's necessary and/or easier to understand. if you find things getting too long and complicated, consider refactoring.
I think the code should only be made smaller if there's a significantly better way of doing it that's shorter. Using a ternary operator instead of an if clause is useless in most cases (sometimes useful for not repeating code), and can make code harder to read. An example of what I'm talking about: converting a hexidecimal digit into a decimal one. I've seen a beginner do this: int hex2dec(char h) { int d = atoi(h) if (d &lt; 10) return d; switch(h) { case 'a': return 10; case 'b': return 11; case 'c': return 12; // ... } ...when the correct way to do it, which is both shorter and simpler, is to use the fact that, in C, a character is just a number, and so you can subtract from and add to it. int hex2dec(char h) { int digit = h - '0'; if (0 &gt;= digit &amp;&amp; digit &lt;= 9) return digit; digit = 10 + h - 'a'; if (10 &gt;= digit &amp;&amp; digit &lt;= 15) return digit; return -1; // error code } In short, my position is that code size is often not itself the problem, but a symptom of it, because one would expect a shorter code given the problem at hand. Ignore calls for making small changes solely in the name of having shorter code if they make the code harder to read for you, like using `if (!pointer)` instead of `if (pointer == NULL)`, ternary operators instead of if statements, or, worst of all, shorter variable names.
Not if you want to iterate through values in a vector and in your language -- god forbid -- indexes start at 1
Are you dividing by 0?
I was for a bit, but I caught that. The only division is on the diagonal elements, lines 101 and 102 on the pastebin should fix that.... Nevermind, operator facing the wrong direction. I'll fix that and get back to you. I guess I never rolled a 0 on any of my low-element count attempts and never avoided rolling a zero on any of my high-element-count attempts. It was a little too consistent for me to think it was my random array.
&gt; isn't the shorter codes sometimes harder to understand If time/space complexity is similar and there is no "magic", shorter code is easier to understand IMO. Unnecessarily long code is often caused by messy logic, excessive abstraction or suboptimal data structures, which make it harder to understand.
I added some extra debug output to show when various values first get set to inf or nan, and the first relevant output (For n=25) is: sum = inf when a[0][21](0.242887) * x[21](16364966961156317618218412224501614453165578878442643195552723448866172674412457129656247969166226277407042426348343373546428646196717404647750009120910171007694710744161473360531842603407891580574635102287782864195832553693965996857315665723784075744284890582733324101004852896847766882388776006212560879616.000000) from the add to sum part of system_solved().
Looks like `sum` does overflow to infinity. I just added this code at line 41: if (isinf(sum)) { printf("Error: sum is infinite\n"); for(i = 0; i &lt; n; i++) { printf("x%d = %lg\n", i, x[i]); } exit(1); } And it does print the error, and shows that the values in the array `x` are very close to overflowing a double (most of them have absolute value between 1e+306 and 1e+307). 
The top 3 illusions in our lives: 1. I'm smarter than my compiler; 2. I write better code than the standard library; 3. My code is self-documenting.
That's a cool blog. Thanks!
Are there any good tutorials on how to do this in c?
I didn't know about the isinf function, that'll be helpful in the future. Right now I'm writing an email to my TA to make sure there isn't some restriction on the input array they didn't list. If it isn't a language limitation/avoidable overflow, I can't think of what it is. jor should calculate [this](https://i.imgur.com/16VwXf2.png), exactly as specified by the professor. system_solved is all my own work, but I don't think any of it is wrong, and it does exit when smaller systems are solved.
I haven't used XML/JSON in c, so I can't help you there. Understanding basic XML/JSON is trivial and the basics can be learned in a few minutes. This is one of the reasons they're so common. Outputting XML or JSON in C isn't difficult (they're just text files). However, robustly parsing it can be more difficult. If your goal is to save time reading/parsing files, I recommend using a library. Otherwise you're probably better off just sticking to straight binary files. There seems to be a lot of free XML C libraries and I found [this](http://lars.ruoff.free.fr/xmlcpp/). I'm sure there are some for JSON too. 
Have you ever learned about looping through a 2D array? You can simply check each element until you find the O and the X
Thanks
I don't think you're calculating that equation correctly.
Short sentences are often easier to read. Too short not clear. (A sentence that's too short might be unclear or incomplete). Long paragraphs can be really hard to understand, especially if they have a lot of information or complex sentences that never end or repeat information that was already stated at the beginning of the overly long and winded paragraph. As with anything, balance is important.
&gt; 2. I write better code than the standard library That brings back painful memories of one project I worked on where the previous programmer had rewritten most of the standard library and got it wrong.
i is the element in x, t is the iteration. I'm not a fan of how the professor wrote the summation, but based on his algorithm for sequential over relaxation (more or less the same thing) and the fact it doesn't converge if I change it (until overflow), the -b[i] is outside the sum. We are supposed to be using a variation of the Jacobi method, that is the professor's formula for the next iteration of x as taken from the PowerPoint. I've been too lazy to understand what actually goes on in the formula beyond basic concepts, I've had more problems going beyond the instructions than giving the professor what they asked for, to the letter. I've contacted my TA, waiting to hear back from him.
Some instructions require multiple cycles. Exact number of cycles depends on the exact processor. You can check the latency of different instructions for different CPU architectures here: http://agner.org/optimize/instruction_tables.pdf
You don't *have to*. Parameters without an explicit type default to int.
Debugging/profiling tools like gdb, valgrind, gprof etc. 
&gt;Modern CPUs and compilers are indistinguishable from magic. No, they aren't. But that might seem true only if you have no clue what you are doing, and there are many people who *do* have a clue, and can read assembly language quite easily. Please don't spread your defeatist crap, anyone with half a brain who wants to learn assembly language can learn it and it's really not that hard. If optimization of a specific piece of code is important, then it will be worth knowing assembly language in order to optimize the C source code, or to write it in assembly language to get the maximum performance possible. Most situations don't require this level of depth, but some actually do. 
check out atmel studio if you're interested in programming and debugging the arduino in pure C, and check out the docs for the ATMEGA328P
I once took a class in applied scientific computing and I still have some of the teachers bonmots in mind when I think about the trade-off you asked about: No matter how good (short, effective) the code is, it is worth nothing if your results are not correct or your code is crashing or returning nonsense due to unhandled errors. Another important aspect is, if you revisit the code after a while, e.g. 14 days and even you cannot tell with the help of your own comments what is happening there, consider it as bad coding. In short this is what I want to say: Go for the shortest and most effective code as long as you can understand, maintain it and ensure the correctness of its results.
My rule of thumb when it comes to variable names is shorter scope --&gt; shorter name. For instane you wouldn't call the iterator of a for loop "iterator". "i" or "iter" will do.
Clearer. Try to make it understandable to the common man, fellow human!
The only change you need to make is to make sure you keep reading characters until you read either 'y' or 'n' when asking whether the user wants to play again. The loop inside `playAgain` is only checking whether it is 'y' or not, it should be checking whether it is 'y' or 'n', and otherwise keep looping.
At a certain point if familiarity it's really no longer just about learning the language itself. Find a hashtable implementation you like and can use. Learn about tree data structures. Learn how to use `qsort` on an array.
Judge yourself not by anonymous comments from script kiddies in their parent's basements. Code for clarity. 
&gt; anyone with half a brain who wants to learn assembly language can learn it and it's really not that hard. I didn't say that learning assembly language is hard. But predicting how it will perform is, especially because it can vary widely from one microarchitecture to another. If you think it isn't, then you really have no clue how modern CPUs work. Let's talk pipeline stalls, instruction reordering, branch prediction, speculative execution, speculative data fetching... oh, and changing strategies over time for the *exact same code* because they gather statistics on how it performs. Put another way: I'm sure OP could learn enough x86-64 assembly to write simple programs in a few days, but do you think that they would be able to understand how the Meltdown attack works, given a copy of the code? Would you, without consulting a reference manual?
&gt; when the correct way to do it, Both ways are correct. And both ways are incorrect. Both ways ignore upper case hex 'digits'. The second way assumes a particular character mapping, ASCII, and uses magic numbers, which are frowned upon. 
What makes you think OP is talking about x86 asseembly? This is a discussion about C, and that targets MANY cpu architectures, especially embedded - and embedded is specifically where assembly code would benefit the most, and is easy to learn. But sure, you go on thinking in ultra-specific terms to support your fragile argument.
To simplify the code and the argument, I didn't mention any of that, but I did do it when that beginner coded that first version. It's important to know that, but this was just to illustrate a minor point about code length, not about algorithm correctness, portability, or other best practices in code.
On x86_64, integer comparison is actually a substraction which result is discarded leaving only the flags, so same speed.
 for(i = 1; i &lt;= 11; i++) { ... } You can make the same case in favor of "&lt;=", so it's a bad argument.
If your loop starts at 1, then yes, use &lt;=. If it starts at 0, use &lt;. It's that simple. Capice?
It's like my wife told me, "Not too long. Not too short. But just right." 
The sequences are exactly as long and take as many cycles. The only difference between them is that one of them uses the sequence: cmp; jl and the other does: cmp; jle. jl and jle take exactly as long.
Understood. In my experience code length is not a minor point for beginners. They stress out if their code is shorter then their peers. 
&gt; when the correct way to do it, which is both shorter and simpler, is to use the fact that, in C, a character is just a number, and so you can subtract from and add to it. Fun fact: C does not guarantee that the character values of letters will follow each other, it only guarantees it for the character values decimal digits. So the only portable solution is the beginner's code, not yours :-) Yes, that's a huge disappointment when one discovers this, and one generally concludes: "oh well, fuck that, anyway my program will not run on system with super weird character sets". (Well, the beginner's code, but without `atoi()` which doesn't accept a `char`argument, and also returns 0 in case no conversion was possible, which means you return before reaching the `switch` when you have an upper hexadecimal digit.)
declare. you forgot to declare it. not initialize it. initialize it is setting a value.
I had to write some Jacobi back in my days as a Numerical Analysis student (later on I was the teacher heh, but this was quite a long time ago) and in general it should not overflow, it's quite a decent method (personally prefer QR, it's a neat one). You can do r/a[i][i]*a[i][j] as you compute it in the sum: this way it will be smaller (and then you remove line 43). This willmay help keeping it smaller
With my current array, all elements of a are less than or equal to 1, that could overflow worse. I'm not sure where in the algorithm it's overflowing, or if it's a bad input matrix. Also, ideally that is at the end - small improvements like reducing n multiplications to 1 multiplication add up when they're in 2 loops.
&gt; I used x86 as an example because face it, that's what 99% of people who post here work on. Bullshit. I am not here for programming C on x86. I doubt that 99% figure is realistic *at all*. You're going to have to come up with some actual statistics if you want to make that claim. &gt;&gt;or are you just waving your dick around &gt;It is a pointless exercise which will at best confuse you and at worst give you the illusion that you understand what is going on. Seems like you're the one that started the dick waving, you dick. You are making wild assumptions based on no data. That doesn't seem to be working for you when your comment gets -4 downvotes. It's time you go sit down over there. 
Given you want a uniform distribution of numbers in a range, you can think about those numbers as an offset plus an index. i.e you have 105, 106,... , 119. What do all those numbers have in common? The number 105. Therefore you can express them as 105 + x , where x = 1, 2, ..., 14. So instead of trying to select a random number between 105 - 119, you actually want a random number in the range [0, (119 - 105)], and then you add the offset, 105.
k
how can it be a spam?
It's for a class project. Thanks for the input, definitely helped me out.
read Deep C Secrets
I'm dividing r by a element of the diagonal, which is greater than 0 and less than or equal to 1. It would probably be less than 1, not quite guaranteed, but most of the time. Unless I'm forced to, I would prefer it at the end to be time-efficient. I'll look into diagonally dominant matrixes. The professor's sides only said to assume the diagonal was nonzero, so that's the only thing I'm enforcing. All elements are between 0 and 1... So definitely not diagonally dominant. I'll set the diagonal elements to the sum of all other elements in the row plus a random positive non-zero number to enforce that. Thanks!
Did you make this or you are just sharing? :) 
get try to implement using recursion :\)
ok i will ofcourse try. But the target was only the beginners and thats why I tried to follow the simple procedures.
Way too complicated. Just use this one: OBJ=foo.o bar.o baz.o prog: $(OBJ) $(CC) -o prog $(OBJ) That's all you need. prog is the program you want to build and OBJ is a list of object files needed to build it. The rest is automatic. make only feels complicated if you want to make it complicated.
I suppose, but what if you have a thousand source files and you changed a header? 
For complicated programs you might want to enhance this. But then you should really start to learn how to use make anyway because a template like yours (which isn't ecen portable to other make implementations) won't cut it.
Care to elaborate by what you mean with other make implementations? I'm assuming the programmer is in a POSIX environment.
Have you even read the part of POSIX that specifies make? Have you ever tried your makefile with other make implementations?
Care to enlighten us?
Still to complicated. Literally all you need is: prog : prog.o foo.o bar.o baz.o Though I prefer gathering all the sources automatically: SRCS := $(wildcard *.c) prog : $(SRCS: .c=.o) `make` already knows the rest. Then, if you want to take care of dependencies a little better, all you need to do is add: CPPFLAGS += -MMD -MP -include $(SRCS:.c=.d) Of course, the following is recommended as well: CFLAGS += -Wall -std=c11 -g
&gt; Let's talk pipeline stalls, instruction reordering, branch prediction, speculative execution, speculative data fetching... All of them almost completely useless to think about until you solve the problem of *cache utilization*. Even the most expensive, badly-ordered opcodes are less expensive than a cache miss, differing by an order of magnitude. There's plenty of confusing subjects when it comes to low-level optimization, but it turns out that breaking out a benchmarking program and measuring for concrete bottlenecks turns out to cover almost all of the work, with what variance left being a much lower priority than finding the next place you can easily bite out that majority-chunk. &gt; Put another way: I'm sure OP could learn enough x86-64 assembly to write simple programs in a few days, but do you think that they would be able to understand how the Meltdown attack works, given a copy of the code? Would you, without consulting a reference manual? You're confounding the apparent skill ceiling as an average case. As it turns out, the vast majority of assembly analysis doesn't involve world-class security vulnerabilities built on the basis of 4 broad intersecting areas of modern CPU design; yeah, there's a learning curve to being able to produce and analyse that level of work, but it's not relevant to the human's role in optimization. Sure, it's taken decades of extreme work to try and build optimizing compilers of the quality we have today, but the kind of optimizing they do and the kind of optimizing we do are two completely different kinds of work. The optimizing compiler is built for the general case -- recognition and simplification of patterns, using dozens of intermediate forms to extentuate every known cost that can be cut down. It accepts any piece of code built for any purpose, and guarantees to specutatively cut what it knows from what it sees. Meanwhile, we grab a concrete piece of code, measure for the greatest bottleneck, and attack using knowledge of the problem domain. Ultimately, it comes down to this: the way the architecture optimizes isn't at all funcitonally different from how the compiler optimizes, with one just being a portable version of the other. If you want to produce code good for the optimizer to crunch, you have to know how the optimizer works. A day, week, or month's work in a language isn't going to teach you that, and you probably aren't going to get a clear picture without breaking open some very advanced references. Sit down, measure and explore things, however, and you'll find you can build an intuition for solving the concrete cases of bottlenecks that you work with. This is all a bit of a messy draft, so let me try and make a clearer statement: *in the abstract case, optimization is one of the most difficult and abstract problems in the world -- in the concrete case, intuition and a stop-watch is about it.* Naturally we attach ourselves to the abstract, but trying to optimize a program is a concrete problem that we all have the skills to work at.
i am submitting my own blog link. and how can it be a spam? many others have posted links in reddit. so what is wrong with mine? 
Yep. Also the compiler will optimize stuff like that. Like the infinite loop thing (`while(true)` vs `for(;;)`). Even though `for(;;)` *should* be faster, both gets opimized to `A: ...; goto A;`
When I'm back home I can. For starters, percent rules are nonstandard and each implementation has a different syntax for file inclusion. Which is not standard either.
Most of these constructs are not standard and won't work on other make implementations.
Interesting to note, thanks
It's also important to adhere to conventions. * Support for PREFIX and DESTDIR in an install target in addition to a build target. * Pick up CXXFLAG, CFLAGS, CPPFLAGS, LDFLAGS from the environment if present. Given these, it's possible to build ports or packages for most package managers without patching the source. Things start going south IRL quickly though when interfacing with pkg-config or other tools to query LDFLAGS and CFLAGS for libraries and such. CFLAGS += $(shell pkg-config --cflags &lt;library&gt;) LDFLAGS += $(shell pkg-config --libs &lt;library&gt;) because -l, -L, -I may differ on different distros or OS (BSD vs Linux someflavour vs Linux anotherflavour). Then, if a prerequisite needs to be of a specific version, $(shell pkg-config --maxversion X --atleast-version Y &lt;library&gt;) or enable/disable different features based on the version of the prerequisite. Rinse and repeat for 20 libraries and submodules in a big project and the reason for Makefile generators (cmake, autotools) or replacements (waff, scons,...) becomes clear. Greenfielding a neat and contained project with straightforward Makefiles is not an opportunity you'll have as a professional programmer. 
Here's the POSIX spec for make: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/make.html
Or simply use cmake: add_executable(prog foo.c bar.c baz.h )
(assuming GMake) * The compilation and linking rules are already built-in, why write them down explicitly? Usually you don't even need that, you can simply do $(BINS): $(SRCS:.c=%.o) Also I'd use `$^` and `$@` for elss redundancy, if I were to write the rule explicitly. Also I'm missing `.PHONY` and you might want to use `$(RM)` instead of `rm -f`, I actually prefer doing: clean: @$(RM) -v # list of files Also please don't just set `CC` to `g++`, but simply use `CXX` instead. `CC` is the C compiler. You don't actually even need to specify the exact compiler, if you don't want to. And I would make a default rule that's not an implicit rule, eg. an `all` target.
I've been enjoying Gtk+. It's a bit convoluted but the documentation is great and it's still in development. 
LOL my game is consist of windows, buttons and inputs
oh thank you. Do you use Glade?
If all you need to do is open a window and take input for a game, something like SDL2 is perfect, but it doesn't have nay built in gui stuff. Honestly most of the C gui libs are a bit hit and miss cross platform (gtk for instance runs ok windows, but looks awful there), and all will have a learning curve. Although there is [IUP](http://webserver2.tecgraf.puc-rio.br/iup/), which is fairly simple and cross platform, and is, afiak built on top of win32 and gtk. The documentation is fairly sparse but it's reletively easy to use compared to the alternatives. 
Thank you for IUP!
Nuklear.
None of those are GUI libraries.
I know, and I don't care. Sticking to POSIX make is way too limiting for anything larger then small-sized projects, and I always have GNU make available for my small projects anyway.
&gt; GNU make is really not a representative make. I beg to differ. `GNU make` is so widespread that you cannot build many pieces of software if you don't have it. One of the first things to do on a bare system without it is to install `gmake`, otherwise you'll have a hard building all the existing pieces of software that rely on it. POSIX `make` was very limited, so every `make` program added extensions. Amongst them, `GNU make` was the more active, provided the most handy extensions and became some kind of *de facto* standard, and it is possibly more ported than the more POSIX-like `make`s. So, I am not sure there is a real point in targeting POSIX `make` instead of GNU `make`.
Nanogui http://nanogui.readthedocs.io/en/latest/
I tend to use [IUP](http://webserver2.tecgraf.puc-rio.br/iup/). Small, and easy to embed. Integrates with Lua well if you want to (but you don't have to).
&gt; Good, easy to use and lightweight GUI library? heh. you young uns.
suckless
I'm fairly new to programing.. ** I want to print my array (called var, 50 length) to a ".csv" file (called *filename). I want it to be stored from top to bottom in the first column, but I don't know how to print it in the ".csv" file. Can anyone help me to understand how it works? Thanks
Is each character supposed to be a row or something? Anyways, fprintf(), fputc(), fputs(), etc.
I have no problem with people writing GNU make only Makefiles. That's okay. But then, you should say so clearly in your documentation and in tutorials you write.
All of this is okay. Just say that you write GNU Makefiles and everything is okay with me. I only have a problem if you claim to write Makefiles (without the GNU) and then start to use GNU extensions.
First of all, do not post pictures of code. I have removed your post so you can try again with your post as text. It is extremely tedious to help you if your code is only present as an image, so don't do that.
Easiest thing to do would be to create a struct with number of resistors, and their resistance, so like 2 100 ohm resistors. Each point in your list would be a pointer to a struct and then when it's time to total just multiply the number of resistors times their resistance at each node
I forgot to include my header file where i include this. Here it is: #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; typedef struct resistor { int resistor_id; double resistance; struct resistor *next; }resistorList; void insertResistor(resistorList **sPtr, int id, double value); void deleteResistor(resistorList **sPtr, int id); void printResistance(resistorList *currentPtr); 
Please place 4 spaces before each line of code to properly format it. I'll read through and edit this comment once I have something helpful.
I am pretty sure that both libSDL and Allegro have windows, buttons and inputs - after all in most games you will need to get input from the user and display information. If neither of these are suitable, there are other options like immediate mode UI ([nuklear](https://github.com/vurtun/nuklear), [imgui](https://github.com/AdrienHerubel/imgui), [IUP](http://webserver2.tecgraf.puc-rio.br/iup/)) or traditional GUI toolkits ([GTK+](https://www.gtk.org/), [Elightment](https://www.enlightenment.org/). 
Looks correct to me. Just a style note and/or FYI in case you didn't know, instead of x = [some expression]; return x; you can just do return [some expression]; These will produce identical programs when compiled, so this would only be for readability or compactness.
Also, I don't know if K&amp;R addresses this, but both their example and your exercise assume that p&gt;=n is always true. If not, this code won't necessarily behave the way you think it should. I'd have to consult the standard for whether the behavior is defined. In the context of the exercise, this code is what the authors want you to write, but in "real" code, you'd have to account for it somehow. And since this function can validly return any value, its return code cannot be used as an error indicator. You'd have to get creative. 
Meh testing against all the versions of make ever written for a 100 line blog post is a waste of time.
The "point" is not appearing when the code is run. I think the if statement is wrong
I'd just like to interject for a moment. What you're referring to as Makefile, is in fact, GNU/Makefile, or as I've revently taken to calling it, GNU plus Makefile.
Or Meson...
I think I know what you are trying to do. But if not let me know. This is what I did. include &lt;stdio.h&gt; include &lt;stdlib.h&gt; include &lt;time.h&gt; define loss 15 int main () { int roll1; int roll2; int roll3; int done; int sum; int i; i = 0; int point; point = 0; int firstroll; firstroll = 1; srand(time(NULL)); // randomises the numbers roll1 = (rand() %6) +1; //Random no. roll1 from 1-6 roll2 = (rand() %6) +1; //Random no. roll2 from 1-6 roll3 = (rand() %6) +1; //Random no. roll3 from 1-6 sum = roll1 + roll2 + roll3; printf("You have rolled: %d + %d + %d = %d \n", roll1, roll2, roll3, sum); if (sum &gt;= 13) //You Win due to total is greater or equal to 13 { printf("You win\n"); } else { if (sum &lt;=6) { printf("You lose \n"); } else { point = sum; // Sets the point printf("Point is: %d\n",point); firstroll = 0; } } do { for (i=0; i &lt; done; i++) { if (sum &gt;=15) { printf("You lose \n"); done = 0; } else { roll1 = (rand() %6) +1; //Random no. roll1 from 1-6 roll2 = (rand() %6) +1; //Random no. roll2 from 1-6 roll3 = (rand() %6) +1; //Random no. roll3 from 1-6 sum = roll1 + roll2 + roll3; printf("You have rolled: %d + %d + %d = %d \n", roll1, roll2, roll3, sum); } if (sum == point) // If the sum is equal to the point, you win and leave the loop { printf("You Win"); firstroll++; } } } while(firstroll &lt;=12 &amp;&amp; firstroll &gt;=7); return 0; }
Yes, that's why you write "GNU Make". Nobody asks you to test.
Does this supports C?
Uhm, I cannot agree to these rules, I think one should think of semantics when writing code, ie.: if (!object) reads as "if `object` doesn't exist`. If it's however not a pointer to some data but a return value, I prefer: if (ret == 0) because it states the intention more clearly. Ternary operators are really nice for initializing values conditionally, eg.: void *a = P ? SOME_VALUE : NULL; which I think is far more readible than void *a; if (P) { a = SOME_VALUE; } else { a = NULL; } or void *a = NULL; if (P) { a = SOME_VALUE; } although the latter is okay. And similar thing goes to variable names: If a variable name is short, the variable is a rather unimportant temporary variable ina short scope. If it's long, it has importance and is possibly global. It directs the reader to what's important and what isn't.
Except that literally everyone uses literary this version of make
No. For example, the entire BSD ecosystem does not. The entire Solaris ecosystem doesn't either. Just because all you've ever seen is Linux doesn't mean that all systems have GNU tooling.
Roger that 
fprintf() worked wonders, thanks :) 
I personally prefer [Mk](http://doc.cat-v.org/plan_9/4th_edition/papers/mk), for regex metarules and shell scripted out-of-date determination.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](http://doc.cat-v.org/plan_9/4th_edition/papers/mk) - Previous text "Mk" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
Yes, I know. For example, if you build cdrecord, it first builds its own make implementation. Which is not GNU make. Was that what you meant?
I guess this code [some parts omitted] int c; while ((c = getchar()) != EOF) { if (c != ' ') { putchar(c); } else { c = getchar(); if (c == EOF) { putchar(' '); } else if (c == ' ') { c = getchar(); if (c == EOF) { putchar(' '); putchar(' '); } else if (c == ' ') { putchar('x'); } else { putchar(' '); putchar(' '); putchar(c); } putchar('x'); } else { putchar(' '); putchar(c); } } } would do the trick, but depending on your level, you may prefer to do a more generalizable code where you count the number of consecutive spaces you've found: if it's the number of spaces you want (3 in this case) you print an x; otherwise, you get the next character, and if it isn't a space, you print as many spaces as you've counted, plus the new character.
Lines like return x ^= (~(~0u &lt;&lt; n) &lt;&lt; (p + 1 - n)); Will look like Egyptian hieroglyphics 40 years from now 
My favorite linked list exercise comes from Chapter 2 of A Practice of Programming by Pike and Kern (I'm sure the PDF is somewhere online). They only one for loop in one function. Whats nice is that the function takes a function pointer so that you can pretty much do anything with it, like sum everything in the list or print everything in the list.
thank you for your answer. " but depending on your level, you may prefer to do a more generalizable code where you count the number of consecutive spaces you've found:" what exactly do you mean ? :) There is only one problem if it counts 4 spaces the output becomes weird
From the looks of your code, the reason why you are only able to get an x printed to the screen after two spaces and not three is because you have hard coded your program to putchar('x') after the second space is found. There is no opportunity for the program to look for any more spaces. You may want to consider using only the first while loop to getchar and determine what kind of character it is. You may want to consider having a counter to determine how many spaces are being inputted and then putchar('x') when a non space character appears. Then reset your counter. You will then get the result you're looking for. 
and when i put return 0 at the end of main it only outputs 1 letter 
If you want exactly three x's: #include &lt;stdio.h&gt; int main() { int c, spaces = 0; while((c = getchar()) != EOF) { if(c == ' ') putchar(spaces++ &lt; 3 ? 'x' : ' '); else { putchar(c); spaces = 0; } } }
thanks for your reply but i want the 3 spaces to be replaced with one 'x' 
Yeah, mk is really nice. I use it for some of my projects.
If you compile C code with a C++ compiler, you're just asking for trouble. C++ is not a superset of C and many perfectly fine C constructs and features don't work with C++ compilers. Just don't do that.
My bad, #include &lt;stdio.h&gt; int main() { int c; int spaces = 0; while((c = getchar()) != EOF) if(c == ' ') { if(spaces == 0) putchar('x'); if(spaces &gt;= 3) putchar(' '); spaces++; } else { putchar(c); spaces = 0; } } 
What I mean is that, as it is, the program only works to replace *three* spaces with an 'x'. If you want to make it so it replaces *four* spaces with an 'x', you will have to add more boilerplate code. So, instead of that, create an `int` variable that counts how many consecutive spaces you've found, and only when the number is 3 you print an 'x'. That way, you only have to change the part where you compare the variable to a number to adapt it to new numbers. Example: int c; int spaces = 0; while ((c = getchar()) != EOF) { if (c == ' ') { if (spaces == 3) { putchar('x'); spaces = 0; } else { spaces++; } } else { // we found a non-space character: we print the spaces we've read // until now while (spaces-- &gt; 0) putchar(' '); spaces = 0; // we print the non-space character putchar(c); } } // if we're here, the input is over while (spaces-- &gt; 0) putchar(' '); return 0; (The point of this sub is to let OP think and develop the program, but I think there's also much to be learned by understanding someone else's code)
I was asking pink_echos ;)
Agree, but can you really blame that on the left side change? It's hieroglyphics either way. Bit twiddling like this should almost always be implemented as preprocessor macros like #define LSB_MASK(n) (~(~0u &lt;&lt; (n))) with an appropriate explanatory comment. But I don't think /u/BornTuft has gotten to the preprocessor yet, so I didn't mention it.
Not related, but could you explain wth's happening in your function? Specifically where you assign x it's new value, looks like mumbo jumbo to me and I can't figure it out :(
Thank you the problem that I am having is when i put more than 3 spaces on in your code 4 spaces then the output becomes weird. I don't think there is a way to fix that 
I have tried it but still dosen't work :/ 
No array necessary If the getchar is equal to a space then increment your counter by one. The counter should keep incrementing until a character is found. Loop through the counter to add the number of spaces found then putchar the character then reset the counter to zero
I don't think so. Sorry, I didn't see that as a requirement.
The reason you are getting a wrong result when adding two numbers with the same exponent is you are clipping the add of the implied 1 you OR’ed in (0x80000). This carries out. Also, you need to add guard-round-sticky handling when normalizing the mantissas. And although you are not handling the different sign case yet, the sign is on the numbers, not their exponents, so the exponent difference logic you have in the same sign case also applies to the different sign case. What changes is adding or subtracting mantissas.
Not sure if I understand what to do. But basically what I need to do is something like if(expoa == expob){ mantr = ((manta+mantb)&gt;&gt;1); expor = expoa+1; }
Oh ok. Thank you. Maybe I'll do it in C++.
What does "becomes weird" mean?
Learn to use an appropriate debugger so you can step through your code, line by line, and check whether the calculated values at each point makes sense. Debuggers can have a lot of features, but you can probably get by with the bare basics: "How to start the debugger"; "Execute the next line" (there are a couple variations); and "What is the current value of X". (Debuggers aren't a replacement for understanding what your program needs to do and how it should do that, but they do help track down the source of the mismatch when your expectations don't match reality.)
When you OR in 0x800000, you are making a 24 bit number from a 23 bit number. If they have the same exponent, then 1+1=2 in the high bit position -&gt; you are adding two 24 bit numbers to get a 25 bit number. That carry into bit position 24 can also occur even when the exponents differ - any sum greater or equal to 2.0 can get this. What you need to do is check bit 24 of the sum -&gt; (sum &amp; (1&lt;&lt;24)) != 0 implies the carry out, so you have to shift the sum 1 bit right and add 1 to the result exponent. 
Thanks so much, I think I understand it!
+1 for glade and gtk+ :) I also use them!
thank you!
I'm actually a java developer, so I know how to use a debugger. My problem isn't the code logic. It's the binary and memory stuff.
The fact that it's written in C though allowed for many languages to easily bind to it. I don't know if the same could be said for C++
Did you do any of this object oriented programming in gobject? I want to learn more about it
Just don’t use exceptions and keep long-lived objects on the heap (destructors &amp; setjmp/longjmp don’t mix).
A more serious problem, and potentially related. When a or b is 0, you're accessing memory outside of your array with _board[-1][0]. That's bad. You need to include special cases for the edges. 
Thank you, I didn't know that was needed. But I had tried that and it didn't solve this issue.
I'm up for it fam!
1. You're using unconventional variable names, which makes your code hard to read for others. I would suggest using `width` and `height` (or just `w` and `h`) instead of `_board_pos_x` and `_board_pos_y` (why the underscores?), and `x` and `y` instead of `a` and `b`. 2. You got your indices backward. The correct way to address position `(x, y)` in a two-dimensional array `a` in C is `a[y][x]`. It seems counterintuitive, but it makes sense when you stop to think about it: the `y`th row is `a[y]`, hence the `x`th position in that row is `a[y][x]`. Then again, it doesn't really matter that you got it wrong if you're *consistently* wrong... unless your array is actually a memory-mapped framebuffer or something like that. 3. You need to check your edge cases (literally, when a and / or b is either the first or last line or column). 4. You're comparing each pair twice, once when you process the first one (looking forward) and once when you process the second (looking back). 5. I would recommend representing your board as a struct which contains both the array and its dimensions. 
Yeah, sorry. The variable names and x/y order were already set by my professor. Thanks.
I don’t have deep enough C knowledge to be much use as a mentor but I love coding streams as a way to learn and would be interested in following if you get it off the ground. Good luck!
What did you expect it to do?
What do you mean?
first scan the `input` then scan the `id`
Print out the value of "input". You'll see.
Fuck im sorry, trying to finish a project at 4 am and cant see the obvious things, thanks for pointing it out though
That's exactly what it did.
Yeah, I got that. Was just wondering what the hell is happening in your function. 
Sounds like fun. I’ve been programming in C for years, though mostly embedded stuff. Not sure if I’m the best mentor/teacher, but I guess I could practice that while you practice C and we could be self-conscious together. : )
Another life pro tip. Sites like fiverr.com do this Paid some dude $30 do do a c++ project for school a few years ago
No problem fella
Thank You! Looks like the code works now. This is my final code: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdbool.h&gt; #include &lt;time.h&gt; char userChoice() { printf("Input 'r' for rock, 'p' for paper, 's' for scissors\n"); char choice; do { scanf("%c",&amp;choice); }while (choice != 'r' &amp;&amp; choice !='p' &amp;&amp; choice !='s'); return choice; } char computerChoice() {/*random generator*/ srandom((unsigned int)time(NULL)); /*range of random generator assigned between 0-2*/ int choice = 1 + rand()% (3); if(choice==1)return'r'; if(choice==2)return'p'; if(choice==3)return's'; return choice; } /*Function that checks if user or computer won*/ void determineWinner(char user_choice,char computer_choice){ printf("User Choice is: %c and computer choice is: %c\n",user_choice,computer_choice); if(user_choice=='r'&amp;&amp;computer_choice=='s') printf("Rock beats Scissors. User Wins!\n"); if(user_choice=='s'&amp;&amp;computer_choice=='r') printf("Rock beats scissors. Computer Wins!\n"); if(user_choice=='s'&amp;&amp;computer_choice=='p') printf("Scissors beats paper.User Wins!\n"); if(user_choice=='p'&amp;&amp;computer_choice=='s') printf("Scissors beats paper. Computer Wins!\n"); if(user_choice=='p'&amp;&amp;computer_choice=='r') printf("Paper beats rock. User Wins!\n"); if(user_choice=='r'&amp;&amp;computer_choice=='p') printf("Paper beats rock. Computer Wins!\n"); if(user_choice == computer_choice) printf("Game Draw\n"); } /* If user decides to play again or to stop program. Bool is defined in order for this function to work. */ bool playAgain(){ printf(" Continue playing game(y/n)?\n"); char choice; do { scanf("%c",&amp;choice); /*Here the program checks for whether the input is y or n. Then after the do-while loop, there is an if-else statment. The if statement checks if the choice is y, then return back to main, else end the program*/ }while (choice != 'y' &amp;&amp; choice !='n'); if (choice == 'y') return true; else return false; } int main() { /*do - while loop*/ do{ char user_choice=userChoice(); char computer_choice=computerChoice(); determineWinner(user_choice,computer_choice); } while(playAgain()); } 
The whole program is over 1000 lines long haha. But I already delivered the program as it was due to about an hour ago. Thanks anyway
Did you get it worked out?
Afik you're allowed to install gmake on your unicorn system and be free.
Wow. It is actually kinda well formated and organized. &gt; +1
Switch to cmake.
… can you elaborate on why I should do that, and how you know this isn't cmake? (I don't know what the difference is)
Yeah this actually looks really nice.
haha, sounds good! Never hurts to try and then if it doesn't work out I don't think either of us would be offended
You know C? If so, lets do it!
Yeah, I've never taught anyone though, so I don't know how good I'd be at it, I also livestream coding my game engine sometimes, haven't in some weeks though. Here's the engine https://github.com/EvilPudding/candle, in my repos there's some examples of how to use it.
Even as a competent C programmer, I still love to download these PDFs just to browse when on long flights or car rides. Thanks for sharing.
Cool. When would you be interested in trying it out? I’m in CA, USA so, I’m on PDT/GMT-7 time. Can’t do tonight, but could probably find an evening during the week.
I think that the problem is you have it written as `bin/%.o` but it should just be `%.o: whatever` And then specify the output folder in the next line like `$(CXX) $(CXXFLAGS) -c -o bin/$@ $&lt;`
This sub is for C, not C++...
You can have multiple targets (created with add_executable(), add_library(), etc.) in a single cmake project.
And it will give me separate make targets for each?
Yes.
Thank you, that's really helpful!
No, that's not how it should be, instead one should make the dependencies of other targets also use a `bin/` prefix.
CMake has the problem of being difficult to specify what compiler flags etc. are called, it's rather hackish IMHO. I cannot agree that CMake is the only solution.
One hackish use for this is [named and optional arguments](https://modelingwithdata.org/arch/00000100.htm). ideal_pressure(.moles=2, .temp=373.15);
I don't want to say specifically, but this one is very similar to the one I used: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.39.749&amp;rep=rep1&amp;type=pdf
You'll want to ask this in either /r/cpp_questions or /r/Cplusplus
Yep, but most of it has become part of the standard by now at least
Also look into compound literals for a similar syntax when not directly initializing.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
make itself is barely on topic, but C++ is definitely not. Please post C++-related questions to /r/cpp_questions.
before others fall prey to this open any significant C project that's using this "cmake" like https://github.com/alanxz/rabbitmq-c and decide for yourself for me I'd prefer calling compiler directly from shell or makefile (not that automake, autogen etc. crap)
I’m late to this party, but there are a few things to watch out for, should you enable optimization: uint32_t ia = *(unsigned int *) a; 1. You can’t just pun like that, as it induces undefined behavior. The compiler can do alias analysis, where it would be free (per aliasing rules in the standards) to determine that `a` and `(unsigned int *)a` refer to different objects (or that this code isn’t reachable, or that the sky is pink and made of jellybeans), because `float` and `unsigned int` are incompatible types. Using `memcpy` is probably your safest bet: uint32_t ia; assert(sizeof(ia) == sizeof(*a)); // or _Static_assert or equivalent, if you have it memcpy(&amp;ia, &amp;a, sizeof(ia)); The compiler will almost certainly understand what you mean by that, and will reduce or eliminate it to what `*(unsigned int *)a` would do if it weren’t UB. 2. `unsigned int` and `uint32_t` are not necessarily the same type or compatible at all, unless you have a specific ABI or data model in mind. `unsigned int` is ≥16 bits, whereas `uint32_t` must be exactly 32-bit. Similarly, your `mant` variables should be (`u`)`int_least32_t` or something along those lines because a 32-bit float has a ~24-bit mantissa. Also, macros: - When you `BUILD` you’re doing bit-math with potentially-negative `int`s, which is also UB. Make sure anything you do bitwise ops on is nonnegative or unsigned; best bet is to cast `BUILD` operands to `uint_least32_t` first. - When `BUILD`ing, make sure the highest parts of the number are in wide enough types (≥`uint_least32_t`) so you don’t drop high bits with a left shift. - Your macro arguments should almost always be in parentheses inside the macro body, so if you pass an expression the compiler won’t poop itself or generate bad code. And of course, if you need to support NaN or infinities, this won’t do that, which may or may not matter depending on what you’re doing with it.
Thanks for the input! But the code you talk about is actually from our lecturer, so I can't change that. I managed to implement multiplication and addition with same sign now. The input we will get is between -10.0 and 10.0 so I don't need to worry about nan or inf. Only thing I still can't get to work is addition with different signs. Subtracting the mantissas instead of adding them doesn't seem to do the trick.
I suggest smacking your instructor/instructrix on the nose with a rolled-up copy of the standards then. \^\_\^
It looks likes the program was written for 32 bits computers then ported to 64 bits. I tried to compile it with `-m32`. Now instead of a segfault, I get an exception. Better than a crash but still I don't get my computation. I started fixing all the warnings I could. [ll/include/LException:47](https://github.com/Antoine-H/All-pairs-shortest-paths/blob/ac323975b41025fe03ca4e25e5a15220dcaa3f8a/ll/include/LException.h#L47) throws `warning: the address of ‘_theEnv’ will always evaluate as ‘true’ [-Waddress]`. I can't just remove the line and I don't see what else I could do to get rid of it. Would you have an idea?
Thank you very much for your answer. I understand a little better this warning now. I am not sure whether it is related to the segfault though. I realised that the program was writter for 32 bits computers then ported to 64 bits. When I compile with `-m32`, instead of a segfault, I get an exception. I have no idea how to go from 32 to 64 bits, what changes it entails...
&gt; One hackish use for this is named and optional arguments. Interesting. I did not know we were allowed to repeat and override initialisers.
I'm trying to prevent buffer over-read in a simple class I made, but I keep getting the error "undefined reference to sizeOf" it worked fine before I added the if statement, which was intended to fix the over-read issue.
No bloody camelCase in C :-)
The operator is called `sizeof`, not `sizeOf` `p1` is a pointer to unsigned int, so initialising with a string doesn't make much sense. And also therefore `*p1` is an unsigned int, and so `sizeof(*p1)` is the size of an integer.
Feel quite stupid now but thanks haha Oddly that causes the data to corrupt in the console. 
What are you trying to do? This code don't have any sense.
Given that the pointers weren't really pointers this may have been a benign warning. Your fix was wrong but reverting it should be safe. To go from 32 to 64 bits; remove as many casts as you can, fix all warnings especially those relating to the sizes of things, try and spot other places where ints and pointers are used interchangeably. For that crash, can you get a stack trace instead of a single line number - that line is in a helper function called from many places.
You need to watch like 10 min of YouTube tutorials or literally skim through tutorials point. You’re getting the basics all jumbled up.
`*arr` is an array of 3 int
If you think of it as an array of arrays, that may make it seem more intuitive.
What's happening is that `arr` and `*arr` have the same value (i.e., point to the same address) but have different types. Here are the types: int (*p1)[3] = arr; /* pointer to the whole array */ int *p2 = *arr; /* pointer to the first row of the array */ Things must be like that because, for example, `arr[1]` points to the first element of the second row, but `(*arr)[1]`, which is the same as `arr[0][1]`, is the second element of the first row, a completely different thing.
That seems overly complicated for what you are trying to do... What about counting the spaces instead?
The indentation makes this somewhat hard to read, and might be tripping you up too. The "if (third!= EOF)" line doesn't have any parenthesis after it, so only the putchar line will be in that if statement. The "third = curr" line won't be. I usually consider it best practice to always use extra brackets around if statements, even if they're only 1 line long.
Can't download the PDF on mobile, is there any mirror available?
so it can be done easier?🤔🤔🤔
French/english/turkish/armenian all appreciated Thanks btw
Every program needs to have a `main' function: int main() {...} It won't work with no main function, and it won't work with two. When you run the program, it starts at the beginning of main. If you want to run code from a second function, you need to call that function from main. int my_function() {...} int main() { ... my_function(); ... return 0; 
Go see the teacher in person. If they speak too fast, ask them to slow down.
So i need to prepare other fonctions before to be able to call in main fonction but do i need an other folder where other fonctions belongs
You can put them all in the same file for now. Try this program: int my_function(int x) { return x; } int main() { my_function(5); return 0; } Make sure you can compile it and run it. (When it runs it does nothing.) 
This algorithm for line drawing may interest you: [Bresenham's Line Algorithm](https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm) I don't know exactly what your skill level is, leave a comment if you need more help with the implementation.
No, just put everything in the same file. Don't you have a textbook that explains this? If not, look at the sidebar. I recommend *The C Programming Language*, but if you can't afford it (even a used copy from eBay), use one of the other two listed there, which you can get for free (legally) online. They're not bad, but *The C Book* would be confusing for a beginner as it does not follow a logical progression, while *Modern C* uses somewhat idiosyncratic idioms which you will probably not find in other textbooks or in your professor's slides and lecture notes, and is a bit preachy and self-righteous about them. (I just found [a list of books about C](http://www.iso-9899.info/wiki/Books) that seems well thought out. Perhaps it should be added to the sidebar?) Finally: C and C++ are different languages. As a beginner, you will probably not notice any difference, but as soon as you start learning about classes, any C resources you have will be pretty much useless.
Maybe you can tell us in a bit more detail what the symbols represent? What is the i input of the algorithm? What is the output?
Platform assumptions.
thank you very much :) but I have trouble understanding your code could you explain it to me briefly? :)
Thank you so much!! now I get it!
[No u](https://www.speedrun.com/themes/user/pellsson/image.png).
While loop and increment one space for each 'X' and one row for each 'Y'. The answer is a muddy as your question.
First, your code is incomplete and almost unreadable because you didn't follow the instructions on the submission page. Second, you need to replace the comma before `char` with a semicolon, but `linecount` and `count` will be of type `char`. Is that really what you intended? You should probably just leave the comma as is but remove `char` entirely. Besides, if you're going to use `c` to hold the return value from `getc()`, it needs to be an `int`. Third, there is no need to initialize `i` or `linecount` since global and static variables are initialized to 0 at startup. Finally, learn to [indent your code](https://en.wikipedia.org/wiki/Indentation_style).
If you really believe that your teacher's racist attitude is harming your education, complain to the head of department.
Why'd you delete your [previous post](https://www.reddit.com/r/C_Programming/comments/8ce8e2/replacing_three_spaces_with_an_x)? People even *gave* you the code to do this.
C++ is off topic in this subreddit. Please post C++ questions to /r/cpp_questions.
I'll recommend this, awesome.
I have seen this way using defines: typedef void _clk1(void *, int); #define clk1 ((_clk1*)0x200012EA) 
Can't you just add the symbol for the function name to the linker script? For example, with this linker script: SECTIONS { func_at_0x30000 = 0x30000; . = 0x10000; .text : { *(.text) } . = 0x8000000; .data : { *(.data) } .bss : { *(.bss) } } If you compile this code: extern void func_at_0x30000(int x); void f(int x) { func_at_0x30000(x); } with gcc -O2 -Wall -o test.o -c test.c ld -o test -T test.lds test.o The generated elf will be: test: file format elf64-x86-64 Disassembly of section .text: 0000000000010000 &lt;f&gt;: 10000: e9 fb ff 01 00 jmpq 30000 &lt;func_at_0x30000&gt; Of course that's just a dumb example (the addressed are completely bogus) but everything boils down to the line `func_at_0x30000 = 0x30000;` in the linker script. 
K&amp;R is an extremely important book and any C programmer should read it. But if you want to learn C, you can't go wrong with K.N. King's "C A Modern Approach"
Wrap the call in function that gets inline-expanded? Use some sort of linker magic to use only a function prototype and have the linker know the address of the function? (At least, I suspect you might be able to do this. I have used next to no linker script.) I guess the macro approach is probably simpler (grumble macros grumble).
Like u/Mansaber said. K&amp;R is great, especially if you know another language but Modern Approach is the where to go next.
I'm currently reading through the K&amp;R second edition and am posting my excercises to this sub. I decided to use K&amp;R as a start to reintroduce myself to C and programming. I haven't had up to this point much difficulty (with the exception of bitwise operations). Give it a shot, I think you'll enjoy it
Who said he was driving lol, doubt the guy meant he would actually browse a c programming pdf on the road...
I think this is the solution I'll use. I've already got a linker script (because it's an embedded platform) so this works really well. Thanks for your help!
Yep, I'm gonna go with some linker magic to solve the problem. Since I've already got a linker script, it's not too hard to add a couple extra lines to set the function addresses. Thanks!
What's the prototype for realpath?
I'm currently on a Windows 10 desktop with 16 GB ram. I don't have anything set up on this computer since I normally don't work on it. I just downloaded mingw-w64, and this computer doesn't have any IDEs aside from notepad++.
Are you using a 32 bit or 64 bit version of Windows?
Then if you're sure you have a 64 bit compiler you don't need the -m64 option. 
I'm getting an error that looks like this: https://pastebin.com/QNr59shV
I am almost done with chapter 1. Seems good so far.
Don't use -mcmodel either. If you do, everything you link with also needs to be compiled with the same setting, which nothing is by default because it's almost never needed. I don't even know what it's provided for... Maybe some embedded environment?
Compiling with only -o creates the exact same error message.
Are you using 64 bit libraries and compiler? That m32 in the path suggests not.
I'm not exactly sure. I found this [compiler](https://sourceforge.net/projects/mingw-w64/) from searching for a 64 bit cpp compiler on google. I installed it and changed my environment Path variable to point to the bin directory of the install. This is all I did. I'm not very familiar with features of compilers.
I think I might have found the problem: &gt; even with -mcmodel large there is a limit to the amount of data you can have allocated in static arrays for x86_64 architecture. This data segment is limited to 2GB. I would guess you have a number of COMMON blocks or arrays declared in your main program statically. The data in COMMON plus any other statically declared arrays PLUS your code must fit in 2GB. To fix this, make your data allocatable, get it out of COMMON and into modules OR reduce the size of your arrays.
Sure... When you get a space, add it to the count. When it reaches 3 print the star and reset the count. When NOT a space, print the number of spaces counted, reset the count and print the character. I should add that i did not account for the terminating state where count would be above zero, but i added it to the post above now.
Static memory goes on the stack while dynamically allocated memory goes on the heap, right?
Oh jesus, you should just install VS "community" edition, maybe with clang depending on how not-ms-extension-compliant your codebase is.
Static memory is built into the executable: it’s allocated when the program is loaded Local memory, like scoped variables and the like, are allocated on the thread stack. You want to limit that to small stuff so you don’t blow out your stack space, generally speaking. Heap memory is plentiful and you can allocate it however you damned well please. It’s not any faster or slower than stack memory, but, if you use a general allocator like malloc, it’ll generally be a lot slower to allocate. Accesses should be no different on an x86-64 system. For now, you should probably just allocate your big buffers and data with malloc. 
Im confused about this, is it not possible to just extern it, and link with the utility functions file? Or is it so you dont need an extra copy of that function in your executable you're making?
listen this guy
I’ve sent a message to you. Please check out. 
That's the right answer here.
No, both go in the heap. But because of how the x86 instruction set works, all static variables together may not exceed 2 GB. If you use `malloc()` or any other dynamic memory allocation function, the limit does not apply.
Static arrays don't go on the stack. What goes on the stack are *automatic variables,* i.e. local variables you declare in functions. Static variables go on the heap. The primary problem is that the x86 instruction set uses a signed 32 bit offset when accessing static variables, so the total size of the machine code and all static variables together is limited to 2^(31) Bytes (2 GB, negative offsets cannot be used) or some variables cannot be reached. If you pass `-mmodel=medium`, the compiler generates different, much slower code to circumvent this restriction. You really don't want that.
I used to do this by using a separate assembly file. External declaration in C, and definition of the symbol in assembly source code.
You nailed the answer perfect.
why is the exercise saying to use it with the input? Is it common to use bitwise on input to make sure it is compatible with the bitfield members?
Static variables in functions are initialized once and retain their value between calls.
im not super experienced with the nuances of c but from what i can gather, the for loop in the main is set to run until enumerate ends completely and since the for loop in enumerate runs to 15 and returns i each time the program is just bouncing between the 2 for loops. each time an i is returned the main for loop runs through with that i while the enumerate loop continues to run resulting in both loops printing in an alternating order.
How did you define the symbol? I can't see how to simply give label a value. Because doing this wouldn't achieve the right results, since the value of the function would end up being a pointer to the pointer, and not the pointer I want, right? PrintString: .long 0x20003AE6 How did you do it?
Thanks
It's very easy to call C from Python. That would be the more standard way of doing it however the converse is easy too once you understand the interface. Here is a really trivial example; https://github.com/guynan/finance
Allocating bytes with *malloc* and friends does not necessarily mean that your program is interacting with the kernel at all; managing those allocations is the job of the C library you're using (glibc, for example). When glibc itself needs memory to meet your request, it'll ask for memory from the kernel with e.g. the *mmap* system call, which does return page-aligned memory.
You could just use the python code from C, it's really easy, see https://www.linuxjournal.com/article/8497 etc. If however you wish to understand why the python code is more efficient you could strace it (on linux) to see what allocation and IO strategies etc are used.
Also, if the switch case into the for loop is what's confusing you... A switch statement is basically a goto. Much like a label can be anywhere in a function, a case statement can be anywhere in the body of a switch, not just top level. Duff's Device is probably the most famous abuse of this bit of trivia, but there are other examples, like this. The switch and static variables effectively make it something called a coroutine.
Try formatting it correctly..no one is going to read that as is. Indent each line an extra four spaces
TIL. I've been using C for years and never knew this. I'm simultaneously fascinated and repulsed.
You have to pass a pointer to the struct. Like you can define x and y but in order to insert them into the struct you need to use the -&gt; operator
Even better, use a pastebin service.
&gt; In you example, you are defining the function as being the bytes "0x20003AE6", no being at the address 0x20003AE6 Yep, that's what I was saying. I knew it wasn't right :) I can see the directive `set` seems to be in GAS, so I could definitely use that. I've gone with the linker file approach for now, but can definitely see myself switching to this soon. Thanks for mentioning this, it's really useful!
[What a C programmer should know about memory](https://web.archive.org/web/20180128073440/http://marek.vavrusa.com/c/memory/2015/02/20/memory/) 
I wished they would add more features C is a pretty slim language. 
Which is one of the reasons why people still use it, IMO.
Also, the overhead of calling the Python code from C would surely kill any performance you would gain. Either use the Python implementation directly if it's good enough, or try to find what C/Fortran library the Python algorithm is using under the hood (like BLAS, fftw, etc) and use *that* in the C implementation. On a side note, if you are a researcher with little Computer Science background, **team up with someone** with CS background for optimization.
Wow. Amazing compilation/reference book. Just realized too you can go up a level to goalkicker.com and they have similar books for basically every language!
Also, it's good to remember, since you are copying the structs around, changing them is inside the drawSprite function have no visible effect outside, unless you return (a copy of) them.
Please put four blanks in front of every line of code so your code appears readable.
+1
I agree. I love the fact that normal professional C is easy to completely remember. This is unlike another language like say Scala where I find myself googling frequently. I do like Scala, but I like that I can just sit and go at C.
It would be nice if more POSIX functions were added to the standard library imo
im reading this article and now im trying to understand this piece of code that implements a simple slab allocator, but can't fully understand the implementation: /* Super-simple slab. */ struct slab { void **head; }; /* Create page-aligned slab */ struct slab *slab = NULL; posix_memalign(&amp;slab, page_size, page_size); slab-&gt;head = (void **)((char*)slab + sizeof(struct slab)); /* Create a NULL-terminated slab freelist */ char* item = (char*)slab-&gt;head; for(unsigned i = 0; i &lt; item_count; ++i) { *((void**)item) = item + item_size; item += item_size; } *((void**)item) = NULL; can you please explain whats going on in each line? it will help me understand 
C11 has threads. Or are you saying you'd like to see certain compilers actually implement C11?
what it's function beside finding whether the number is even or odd?
I just compiled and ran the following program with no issues, in mingw-w64 7.3.0 64-bit: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main(void) { size_t n = 3UL * 1024 * 1024 * 1024; char *p = malloc(n); memset(p, 1, n); printf("%p\n", p); fflush(stdout); getchar(); } 
I do not see why the C standard library shouldn't have most of C++'s functions. The C *language* should not be as complex as C++ though
Yeah, that code isn't written so well, which makes it more difficult to understand than it should. In this example a slab is a page and the very first bytes of that page is the pointer than is the head of a linked list. The rest of the slab is a bunch of items packed end to end. The first bytes of each item serves as a pointed for a linked listed when it's not in use, like a union. It might be easier to understand when illustrated with defined types rather than a mess of manual pointer arithmetic: /* Example: item is a complex number */ struct item { float re; float im; }; union slab_item { union slab_item *next; struct item; }; struct slab { union slab_item *head; union slab_item items[]; }; Then I'd rewrite it like this: /* Allocate a page */ void *p = NULL; posix_memalign(&amp;p, page_size, page_size); // FIXME: check for error /* Create page-aligned slab */ struct slab *slab = p; slab-&gt;head = slab-&gt;items; /* Create a NULL-terminated slab freelist */ for (unsigned i = 0; i &lt; item_count - 1; i++) slab-&gt;items[i].next = slab-&gt;items + i + 1; slab-&gt;items[item_count - 1].next = NULL; 
&gt;Few compilers implement optional features. Every compiler but one implements VLAs. They were listed as optional for political reasons (similar to the addition of the awful Annex K). The compiler in question wouldn't have implemented them even if they were mandatory (as evinced by the fact that they were mandatory for 12 years and not implemented in that time), so it is a moot point really.
Here's a correctly (I hope) formatted version in case someone else has the time to fix this: include &lt;stdio.h&gt; include &lt;string.h&gt; /*Function prototypes*/ int recurrence_checker(char user_input[], int dupe_recurrences[], char duplicates[], int arraylength, int dupe_counter, int i); int recurrence_checked_checker(char duplicates[], char user_input[], int i, int arraylength); int main(void) { char user_input[30]; char duplicates[15]; int dupe_recurrences[15]; int i = 0, j = 0, dupe_counter, arraylength, input_checked; printf("Enter a word:\n"); scanf("%s", user_input); arraylength = strlen(user_input)-1; for (i = 0; i &lt;= arraylength; i++) { input_checked = recurrence_checked_checker(duplicates, user_input, i, arraylength); if (input_checked == 0) { for (j = 0; j &lt;= arraylength; j++) { if (user_input[i] == user_input[j]) { dupe_recurrences[i] = recurrence_checker(user_input, dupe_recurrences, duplicates, arraylength, dupe_counter, i); dupe_counter++; } } } } for (i = 0; i &lt;= dupe_counter; i++) { printf("Duplicate letter: %c, Occurences: %d\n", duplicates[i], dupe_recurrences[i]); } return 0; } /*Function definitions*/ int recurrence_checker(char user_input[], int dupe_recurrences[], char duplicates[], int arraylength, int dupe_counter, int i) { int recurrences, recurrence_check; for (recurrence_check = 0; recurrence_check &lt;= dupe_counter; recurrence_check++) { if (duplicates[recurrence_check] == user_input[i]) { recurrences++; } } return recurrences; } int recurrence_checked_checker(char duplicates[], char user_input[], int i, int arraylength) { int outer_counter, recurrence_checked = 0; for (outer_counter = 0; (duplicates[outer_counter] != user_input[i]) || outer_counter == arraylength; outer_counter++) { if (duplicates[outer_counter] == user_input[i]) { recurrence_checked = 1; } } return recurrence_checked; } If not, I'll see if I can look at it later.
Your code has two different array lengths in use but you aren't ensuring you're not overrunning one of them. The **user_input** array is sized at 30 and you grab the length of the input provided and use that as the boundary of your loops. However, your **duplicates** and **dupe_recurrences** arrays are set at 15 meaning if you type in more than 15 characters into **user_input** you'll overrun the dupe checking arrays. You need to put checks/guards in place to ensure you don't do that. 
&gt; Every compiler but one implements VLAs Because they were mandatory in C99. There is no reason to remove optional features of course, but having `threads.h` mandatory would give an incentive to actually implement it.
Agree.
Remainder after division For eg 6%2 = 0 41 % 7 = 6 etc 
In those cases you'll also want to implement them yourself as the memory layout of bit field structs is implementation-defined.
Happy to have been helpful. Beware that if you use a binary format where code is position independant, you may need additional magic (which is obvious because some symbols are fixed). Thinking about it, your attempt sort of reminded me of an entry in the [First Obfuscated C Code Competition](https://www.ioccc.org/1984/mullender/mullender.c), where ```main``` was defined as an array instead of a function (won't work in modern C). short main[] = { 277, 04735, -4129, 25, 0, 477, 1019, 0xbef, 0, 12800, -113, 21119, 0x52d7, -1006, -7151, 0, 0x4bc, 020004, 14880, 10541, 2056, 04010, 4548, 3044, -6716, 0x9, 4407, 6, 5568, 1, -30460, 0, 0x9, 5570, 512, -30419, 0x7e82, 0760, 6, 0, 4, 02400, 15, 0, 4, 1280, 4, 0, 4, 0, 0, 0, 0x8, 0, 4, 0, ',', 0, 12, 0, 4, 0, '#', 0, 020, 0, 4, 0, 30, 0, 026, 0, 0x6176, 120, 25712, 'p', 072163, 'r', 29303, 29801, 'e' }; (Won't work in modern C, of course).
Hey, F54280, just a quick heads-up: **independant** is actually spelled **independent**. You can remember it by **ends with -ent**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
just the explanation I was looking for. thanks man. Actually, I was looking for libraries in C++ to incorporate coroutines in my code and next thing I know is I am just staring at this weird and mysterious snippet.
A bit of background: the encoder seems to work but while decoding it looks like `fgetc` doesn't always return the value it's supposed to read. While iterating "manually" in gdb, the error seems to take more time to occur than if I ran the binary directly from the terminal. What can possibly happen?
One easy way of doing that would be this: char buf[10] = "---------"; size_t len = strlen(str); memcpy( buf + 4 - len/2, str, len ); Naturally assuming str != NULL &amp;&amp; len &lt; 10.
Why not use an opaque struct instead of void pointer?
How exactly does that work? I tried that and when I print it out I'm getting strange characters displayed. Could it be how I'm printing out the data?
&gt; How exactly does that work? *buf* starts out being filled with underscores already, and the string is then copied into the middle. &gt; I tried that and when I print it out I'm getting strange characters displayed. Could it be how I'm printing out the data? Possibly. I have no way of knowing though, since you didn't post any code.
I tested using a hardcoded string: for(unsigned int i = 0; i &lt; MAX_NAME_LEN; i++) { printf("%c", buf[i]); } I also tried adding a NUL at the end of buf before I try to print it.
&gt; anyway i've spent too much time on this. I completely agree. It's hard to have rational discussions with people who say, "Dunno and frankly don't care."
I'll hazard a guess: Is *graphic* a pointer that you are directly setting to *buf* in the makeRacer function? *buf* is on the stack, so that won't work; you need to allocate some memory for it (or have *graphic* be an array of bytes instead) and then copy it over.
Arrays are Static and you cannot change the size of them with user input.
`FILE` is just some internal stuff that keeps track things like EOF and other stuff. You want to use [`fseek`](http://port70.net/~nsz/c/c89/c89-draft.html#4.9.9.2) to jump to the location in the file and [`fgetc`](http://port70.net/~nsz/c/c89/c89-draft.html#4.9.7.1) to get the character at that position (and advance the internal "file pointer")
Yep, you hit the nail on the head. However, I think I forgot how I'd do it in a case like this (a pointer within an allocated pointer). This is how it was: Racer *makeRacer(char *name, int position) { Racer *r = malloc(sizeof(Racer)); r-&gt;dist = 0; r-&gt;row = position; char buf[10] = "_________"; size_t len = strlen(name); memcpy( buf + 4 - len/2, name, len ); r-&gt;graphic = buf; return r; } Now, I thought that simply changing the array to simply a pointer and allocating like so would do the trick: char *buf = malloc(sizeof(buf)); Which I added before I set what the value was and did all the copying. But I'm still messing up with something. I'm really embarrassed because memory allocation isn't new at all to me, I just had a brain fart as to how to do it correct.
You're fundamentally misunderstanding how a file pointer (`FILE *`) works. It's an opaque handle to a file on which you can use C's input/output functions, such as `fread()`, `fwrite()`, `fgetc()`, `fprintf()`, etc. You're treating it like some sort of file mapping. Instead you should *seek* (via `fseek()`) to the position you want to read, then `fread()` the bytes you want. Also if you're using Windows, make sure you open the file in binary mode: FILE *fp = fopen(argv[1], "rb"); Otherwise it does some decoding on your input as if it were text. You *can* achieve what it seems you want to do — a file mapping — but you'll need to use a platform-specific API to do it, and it won't involve `fopen()`. 
Any chance you can record the stream and share it here? I already know C, but would like to watch it anyway
I realized my mistake right before I read the comments... sorry guys. I appreciate the help, though!
`sizeof(char) * 10` should work – or just 10; sizeof(char) is always 1. It would result in this: char *buf = malloc( 10 ); memset( buf, '_', 10 ); size_t len = strlen(name); memcpy( buf + 4 - len/2, name, len ); r-&gt;graphic = buf; 
Yes, but it's platform dependent – [fstat](https://linux.die.net/man/2/fstat) on Linux or [GetFileSize](https://msdn.microsoft.com/en-us/library/windows/desktop/aa364955(v=vs.85).aspx) on Windows, for example. Doing it the portable way with fseek/ftell/rewind isn't necessarily bad or slow though, even if it looks a little ugly.
Allocate memory as you read it
Yeah, I think the plan is to do a couple hour stream hacking on a project and working together as mentor/mentee and then I'll take that stream and slice it into a more coherent video that we can post on youtube and link here. That way people who don't have time to sit through an unscripted stream can still see the good information
You can use malloc() to allocate a size that you know will be big enough. Read the information into it and realloc() to the appropriate size so you dont waste memory.
Read the file into a dynamically allocated array. Whenever the array is full, use `realloc` to make it larger until you have read the entire file.
It's easier to implement C11 threads using Win32 threads than it is using pthreads.
I have to confess I'm now trying to think of an excuse to use it in production code.
Boost's coroutine library is probably the most popular. There's also some movement to getting coroutines into C++20 or 23.
Another way to do this is by using a dynamic structure. The most basic will be a list, and if the number of username isn't gigantic, like less than 1000, it will work fine. Otherwise you'll need some more advanced structure, like a hashtable (finite array of small lists, index given by the hashing function) or a binary tree (using strcmp, if you'll search by name) 
Thanks for your quick response but can you recommande me a program that get the job done?
Thanks for your recommendations I'll try it.. But do you have the knowledge to use it so I can send you the program that I want to decompile?
Note that decompilation is an entirely different beast from disassembly. Disassembly is an automated task, but a useful decompilation takes many man hours and quite a bit of skill as you have to understand the code and reconstruct the parts that got lost during compilation. I'm not going to do this for you due to the high effort, at least not without payment.
I’m notoriously lazy and I K&amp;R’ed the heck out of it when I first started out. It’s why I chose C to be honest. I thought “a less than 400 pages programming book written by THE people that know it best? SIGN ME UP”. 32 keywords ftw!
Can you disclose what application you want to decompile? Note also that IDA is quite expensive and effectively not legally acquirable by a single person. Of course, the freeware version of 7.x exists but it cannot save the database. There's also a really old freeware version with limited feature set that should work for you too. The latest version that's acquirable by, *cough* other means, is 7.0 for Windows and macOS. However, decompilation is a really complex procedure, especially if you want "the complete sourcecode" because decompilers only provide pseudo-code, you need to rewrite the whole application with direct note of the original. There are also other decompilers like snowman which are non-interactive but can be paired with radare2, but I don't know how they comoare to IDA since IDA is comparibly really intuitive (but still a beast). The steps are 1. analysis (automatic) 2. find entry point, generate pseudo-code 3. Use your assumptions about what the program does to eg. look for filename constants etc. 4. Look for library functions that are loaded (on Windows: LoadLibrary() etc.) and lookup their signature so you can teach IDA that and with that new knowledge go further 5. Same thing for data structures or classes in C++ (complex, you need to create vtable structures) 6. All the time: Rename variables of which you found out what they do, refactor the generated code etc. It can take hours to take a single function completely apart if it's complex or you don't know the tools. Usually though you try not to stay at that function but "explore" the surroindings, ie. what functions call it and what function it calls.
I like radare2
Thanks for your time... The application that I want to decompile is not even complex it has no database, it was just a C program project that our teacher gave us long time ago and I want to see the code.. How can I send it to you so you can it yourself?
If you want a wrapper to be written, this is what I'm working quite a bit with at the moment. PM me some code if you would like me to help you out. 
I meant the database IDA generates when decompiling. If it's not complex I can only recommend you trying it yourself. Either download the old and free but only disassemblr IDA version, or the 7.0 demo. Both should suffice for your purpose.
I'm pretty sure nobody should be recommending Enlightenment :-P https://what.thedailywtf.com/topic/15001/enlightened
first time posting on reddit, it added a bunch of /'s and i didnt realize it when i copy and pasted. 
Cant you save the n least significant bits, then do a right shift by n bits, then put the saved bits into the high order positions?
&gt; `if (userInput &gt; 59)` You need braces around the contents of this `if` statement.
Try writing it using the `getbits` and `setbits` functions, then try simplifying it from there.
You want to know something.... it **never** crossed my mind to use the functions I had earlier. I can't believe I didn't clue into that. Rookie mistake if I've ever seen one. Thanks!
Been told they are not mandatory. Will add and reply.
So here is what I came up with in my third version. No if statements. I only use bitwise. My fourth version will contain all one line, but this is great, thanks! int tempBits = 0; int firstMask = ~(~0u &lt;&lt; n); int lastMask = firstMask &lt;&lt; (8 - n); tempBits = (x &amp; firstMask) &lt;&lt; 8 -n; x = (x &gt;&gt; n) | tempBits; return x;
Ok... here we go... version 4 with the rightrot function all in one line `x = ((x &gt;&gt; n | ((x &amp; ~(~0u &lt;&lt; n)) &lt;&lt; 8 -n))) | ((x &amp; ~(~0u &lt;&lt; n)) &lt;&lt; 8 -n);' Full Source Code: http://codepad.org/4vGLySQp Thank you to /u/dhmdc
#include \&lt;stdio.h\&gt; int main\(void\) { int age; char workingStatus; printf\("Please enter an age of a person: "\); scanf\("&amp;#37;d", &amp;age\); if \(age \&gt; 59\) { printf\("Is this person still working? Enter Y or N\\n"\); scanf\("&amp;#37;c", &amp;workingStatus\); if \(workingStatus == 'Y'\) { printf\("Working Senior\\n"\); } else { printf\("Retired Senior\\n"\); } } return 0; } Is what i have now, but it is still skipping the second scanf I enter the age, 60, then it just auto completes says retired senior.
Add a printf() statement after your scanf("%c", &amp;workingStatus) to see what is actually reading and what the value of workingStatus is.
I like what you did there in the first sentence. 
I would like cpp's **auto** type keyword in C.
I had a fair bit luck with GtkMM on both Linux and Windows/mingw32 sometime back, didn't find it too difficult. Did my top level GUI layout in Glade, and wrote a custom widget in C++ derived from Gtk::DrawingArea. It wasn't too arduous, but I appreciate that route might not be everyone's cup of tea. The app did look pretty much identical on Linux/Windows though. 
jesus christ, ty so much this fixed it
Of course, realloc does take time. For sufficiently large files, you might want to consider how often you call this function. Perhaps double the size every time it's called. Just a thought. 
The runtime is actually not that bad in practice as good implementations can remap the same page elsewhere to make more space, saving the copy.
To be honest, the most useful part of this project is the `vextex_state` and `vertex_data`, which are objects representing OpenGL's VAO and VBO, respectively. Texture objects are OKish, and framebuffer objects need a revamp, but are usable if you just want to render to a texture. Overall, it just repeats OpenGL (in a cleaner way), but add optional debug checks *everywhere*, like this one: ``` void gfw_texture_unbind(void) { glBindTexture(GL_TEXTURE_2D, 0); #ifdef CONFIG_CHECK_BACKEND_ERROR if (glGetError() != GL_NO_ERROR) { #ifdef GFW_PRINT_BACKEND_ERROR printf("Error: failed to unbind texture.\n"); #endif #ifdef GFW_ABORT_ON_BACKEND_ERROR abort(); #endif } #endif } ``` In the daily OpenGL routine, these checks are life saviors.
I don't know what's causing the error offhand, but I can give a few general pointers. 1) Don't do this unless you have to. Someone else has already written and troubleshot a bmp reader/writer library. Use that if you can. If not, carry on! 2) You're extremely confident that nothing can go wrong in your code. Lots of fopens, freads, fseeks, fwrite, mallocs etc without checking return codes. Checking those could help you figure out what's going wrong. It could be that some bit of code is erroring (say, an fopen?) and you're carrying right and trying to use the object it failed to create. Segfault city. 3) Debug output is your friend. GDB can be handy if you learn how to use it - In this instance, it would tell you the exact line the segfault is happening on, as well as allow you to investigate the state of all variables at that line. You may have done this already, but I'm guessing not based on your wording. 4) If you don't have access to GDB, printf can be your friend in a pinch. Check that &amp;InfoHeader is a sensible-looking pointer. Check that sizeof(INFOHEADER) returns what you think it should. You can also use print to search for the exact line you think a problem is occurring on - Put a printf statement just before and after where you think the problem is. If one fires and the other doesn't, you've found your line. If they both fire, your problem is after that line. If neither fire, your problem is before that line. Continue adding printf lines until you narrow down to the exact line with the problem. 5) I don't know bmp files, but that "MagicFix" bit looks awful suspicious to me. I took a quick look at the bmp spec, and I didn't see anything offhand that would lead me to believe there should be a two byte offset. 6) Another useful tool in this situation is 'valgrind'. Running it through valgrind on my end, with a random .bmp, I'm getting a segfault on line 170 - Looks like it's walking off the end of the PixelArray. It seems to be doing that because my sample image dimensions are bigger than 2^15, and both i and j are listed as 'short's, which are 2^15 on my platform. This leads it to fread until it hits 2^15, adds one due to the for loop, and then something undefined happens. But PROBABLY adding one to 2^15 results in -2^15 on most compilers/platforms, which isn't a valid array address, thus causing the segfault. TL;DR: 6 is probably your actual problem. But there are some good tips in the other numbers too. Cheers!
Neat thanks. I should test/time it for myself before mentioning it next time. 
Since C already has an auto keyword that means something else I imagine some broken code from that! But it would be neat 
C++ had the same auto keyword, and it used to mean the same thing as what the c auto keyword currently does. The C++ committee changed it because it was not only useless but almost never used, so not as much broken code as you might expect.
Thank you! MagicFix was something I tried after perusing the internet for possible solutions. I will have to try making i and j ints or longs instead of shorts, because the files might increase in size. I know there's a little bit left to figure out, but I knew coming here would be my best bet. Thanks again for all the time you put into your response!
You can give number in argument. ./YourPrgramName NUMBER and your program should contain int main (int args,char **argc)
I might look at it later but the name of the lib immediately made me think "OGL, GLES, GLFW, SDL, GLUT, GLM, GLEW and whatnot. Great,now there is also GFW..."
It was an accident!
sure, I don't like the idea of modifying parameters, but if needed I'd usually just pass a pointer...
In a declaration you have an initialiser on the right hand side, but in the assignment you have a structure literal, which has the syntax `(type){..., }`, it is not a cast.
You might have other structs with the same data types: the compiler cannot infer a type.
Thank you! After investigating further it seems to come from my stack. The three first values I push aren't changed but the fourth one changes from 116 to 8302. I'll look deeper at the casts I do in while pushing/popping.
I've always wondered why compound literals are explicit though. 
neat, so I could just do: #define auto __auto_type ?
Yes, you could. Actually using the "auto" keyword for it would be very confusing to anybody looking through your code, though.
I would like to have enum classes (and size specifier) from C++.
It afaik isn't an explicit cast, because it's not a cast at all. That's the syntax of a compound literal, which happens to be the same as an explicit cast. However it does make sense because the "actual literal" is untyped and has no information at all about it. It cannot infer the type from the left side of the assignment because there could be anything. As a rule in C, the right side does never look on the left side of the assignment to infer its types or similar.
Yes, that's a declaration with an initialiser. The right hand side isn't a normal expression and is unique to declarations. For example, wrapping the initialiser list in parens struct Foo foo = ({.bar = 1, .baz = 2}); would be invalid syntax.
ahem.. -int main (int args,char **argc) +int main (int argc, char **argv) // Argument Count, Argument Vector/Values, your choice. Thanks! I have always wanted to take the role of a programmar nazi :3 *_It doesn't really matter what we name these arguments but still, Imma programmar nazi :D_*
There is a pdf online called something like "advanced linux programming". In the second chapter it goes over the best way to pass command line args. There's a very useful function called get opt long.
Codefight.com is a website where you choose from many of today's languages and are given a task to complete. This might be a good place to start.
Because you never set lista-&gt;next to anything You're unlucky that it is not crashing .. that would highlight the bug better.
No, I'm sorry ready that wrong. Lista-&gt;next is NULL. It has not been set when you set lista- equal to it
Well, there are really no guarantees about anything by the C standard itself here as far as I'm aware of. The answer will obviously depend on the platform we are talking about. For some embedded systems, the pointer will actually be a physical memory address. On most modern hosted systems you will be dealing with some kind of [virtual memory](https://en.wikipedia.org/wiki/Virtual_memory), i.e. chunks of physical memory are mapped to a virtual address space that is managed by your operating system.
So why not just use the [a debug callback](https://www.khronos.org/opengl/wiki/Debug_Output)?
No, malloc does not initialise the returned memory to anything. &lt;http://en.cppreference.com/w/c/memory/malloc&gt; You will often see malloc followed immediately by a call to memset (after checking the returned pointer for NULL, of course). Or calloc used instead of malloc. &lt;http://en.cppreference.com/w/c/memory/calloc&gt;
I was wondering why it was printing out anything at all. But then I read and figured out the line aux=lista and the line aux = lista. You set lista to null with the lista=lista-&gt;next each time. You want to save the previous node and set the new node to be the next node. Does that make sense?
Yes thanks
Thank you
Yup, it's a declaration with an initializer.
 buff = (char*) malloc(sizeof(size)); I'm pretty sure this isn't what you want to do. Try just `malloc(size);`
This sub is for C only, C++ and C are not the same language. To seek further advice please visit the C++ related subreddits instead.
Use compound literals instead, and if you want readibility, create a makro for that: #define Vert(x, y) (vert) {x, y} and use it just like did, zero copying overhead. Although it's possibly still faster to pass a pointer.
It’s mostly for simplicity. The way the OS caches and maps pages is generally vs. an offset of 0, so if the offset is restricted to multiples of the page size, then the OS can reuse those cached pages for anything mapping the same file. If the offset isn’t restricted, then there could be (e.g.) 4095 different versions of the same byte of the same file mapped in different processes, and that’s a whole hell of a lot harder to deal with, both in terms of memory waste and in terms of figuring out whose pages actually get syned to diisk and how/when.
It’s probably more realistic to use `fseek` to find the right sector, then `fread` to read it in, or else just use `mmap`.
That limitation on the offset is because it makes for a faster and more efficient implementation in the kernel. Sometimes this means you may have to map a little more than you need.
The last node is when the `next` member is `NULL`, so why don't you check for that member?
If your program is often going to be adding a node at the end of the list, it might be better to simply keep a pointer to the tail along with the one you already have to the head. That way you wouldn't need to walk the entire list every time. 
that's what I'm doing with the while loop. It breaks out of the while loop when the node I'm on is now NULL (or so I believe it does). My question is how do I make the function return the pointer of that node. 
node *find_last(node *head){ If(head-&gt;next == NULL) Return head; head = find_last(head-&gt;next); return head; } Meh i think this should work, recursive function that returns a node pointer to the tail in a list 
&gt; that's what I'm doing with the while loop. No it's not. &gt; breaks ... when the node I'm on is now NULL You want to break when the *next* node is NULL 
Iterative way (the way youre doing) node *find_tail(node *head) { node *temp; If(head ==NULL) return NULL; for(temp = head; temp != NULL; temp = temp-&gt;next); return temp; } This may be bugged, not really great at programming so it may need to be debugged. 
If they're in a string, you can use strtol(), which gives you the number and a pointer to the first character after it, that can easily be advanced past a comma or whatever to the start of the next number.
Thank you! I finally understand. I'm just not sure with your first assertion since the CPU doesn't cope with physical addresses but maybe I didn't understand what you meant. Thank you very much for your time, this is very kind of you. 
 char *p = anString; size_t pos = 0; int n = 0; while( p &amp;&amp; *p ) { if( isdigit( *p ) ) { if( sscanf ( p, "%d%n", &amp;here[ pos++ ], &amp;n ) == 1 ) { p += n; } } else { p++; } } More or less.
Make that const char and we have a winner ;)
On most modern architectures the virtual memory mechanisms are handled by the CPU, so the executing program deals in virtual addresses, which the CPU translates to physical addresses. On certain chips the MMU can be a coprocessor or sit between the CPU and the bus, in which case the CPU would(/may, depending on setup) only deal in virtual addresses.
You can use strtok in a loop to get individual tokens with a character as a separator. Then either use atoi or a similar function to convert then to a number
Came here to say this too :)
You might want to consider what happens if your loop is circular.
How much did you test it while you were writing it? What does work? Or did you write it all, realised something was wrong, and posted here?
I did several test cases already. Firstly, before everything else I made sure that I was correctly creating racer instances (and deallocating properly). I then verified that it handled input correctly (i.e. when only given program, throw usage message, when &lt; 2 racers usage message, etc.). I then tried to get it to run a race with 2 racers. No matter what I did, the output is the same, just a single line with a bunch of "-". No clue what could be the cause. I have been messing around with what I've been doing with the cursor-control within the run function in racer.c, but no luck thus far. I just wasn't sure if I was correct in thinking it was even related to the cursor-control.
Don’t `typedef` around a pointer unless you’re making an opaque type (e.g., a handle). What you want is something like Node *p; if(!!(p = head)) { Node *q; while(!!(q = p-&gt;next)) p = q; } return p;
1. by putting the mutex lock/unlock around the whole thread function, you're serialising them all. The next racer won;t start until the previous one is finished. You only need the mutex around the drawing code to prevent screen corruption. 2. The main loop is only waiting for the last created thread to finish. It needs to save all the threads and wait for all of them.
1. I'm not quite sure what you mean? Isn't that how it already is? They're located within the thread function just before and after the cursor-control stuff. Unless I'm going crazy. 2. So put the join in the loop after I make a thread? 3. I'll look into that, thanks for the suggestion!
you have run() { lock while {} unlock } The while loop is inside the mutex. So the mutex won't be unlocked until the racer reaches the finish line. The next racer can't start until the mutex is unlocked 
Great book.
Reading binary data with `scanf` is a really bad idea. `scanf` is a function to read text, not binary data. Use `fread` to read binary data.
That's a very good book from the pioneers of the C programming language. Good find!
Worth every penny and then some. Kernighan and Pike are two of my favorite authors. Pike is the more opinionated one and some of his ideas are controversial, but you can't go wrong with anything that has Kernighan's name on it.
It's not a standard C definition. `#define` it somewhere yourself, or `#include` whatever third-party header you need that it is in.
Can I just define it to be as large as I want? That seems to defeat the purpose of having it as a maximum limit to read and write.
Solid reply. Thanks for the research and explanation!
Are you compiling it in Ubuntu or in Windows (mingw-64)? Realistically it shouldn't make a difference, since both of them are POSIX.
I tried it on Ubuntu laptop, but I can try on Windows desktop when I get home.
im looking for someone to do my homework PM if u do for me
Do you know of a better solution than this? Should I just do "E_DB_SIZE - remain" for the pointer?
Looks like the Go gopher.
Well, what are you trying to do?
good point... 
great book.
This is a excellent book.
The cover style looks very similar to another book they wrote together, The Go Programming Language. Anyway, nice find!
I'm trying to write 20.4GB of data into a file. I'm making a pattern database for the Rubik's cube and using it in a heuristic search to find optimal solutions to the Rubik's cube.
Never read it but if it’s written by rob pike and brian kernighan it’s bound to be worth at least 5 dollars.
Struck gold. :)
Worth it. Very good book.
I think I resolved all the issues. Thank you for all the help! Just one last thing, how would the deallocation work with this? Once I'm done with all these racer objects, I should probably free them all. I tried adding a double pointer and at the end going through and freeing but that ends up causing a ton of issues (like invalid reads and overwriting). 
main allocates them. You have 2 places to choose to free them - one at a time the end of the run function ie the thread is responsible for freeing i's racer or the end of main. main stores them all in an array and frees them all when the threads are done. My preference is the latter. running the race doesn't feel like transferring ownership; you may well want to look at all the racers at the end to decide the winner for example.
This is what I would also do! But I'm currently just practicing code, and I'm making a separate functions where a user can choose to add to the beginning, or end, or middle of the list. :) 
Addison-Wesley computer science books are _all_ worth reading. Including this one.
Did exactly that a million times and kept getting error after error message. I realized, as the guy below you mentioned, there must be an error in the code my professor wrote, though only having elementary knowledge in programming, couldn't tell ya how to fix it.
&gt; I figured the first part out a thousand times That's not what you told us. You told us you “didn't know where to start” and “didn't understand the question”. Now you tell us that you did in fact try a few things. We can't help you if you don't tell us what you tried and what happened. And “I kept getting error message after error message” does not count as telling us what happened. I recommend Simon Tatham's *[How to Report Bugs Effectively](https://www.chiark.greenend.org.uk/~sgtatham/bugs.html)*.
Everybody is trying to tell you that your last node function is equivalent to just { aux = NULL; } 
Manual pages are generally named for the functions they describe, not for the headers in which those functions are declared. Try `man 3 dlopen` instead, or search the [POSIX specification](http://pubs.opengroup.org/onlinepubs/9699919799/).
Try to write your lines to be under 80 columns to make it easier to read. Also, I'm assuming that the unsigned type is an unsigned int? Why not write out the full type? Why not write out the printf explanations as comments?
I mean, I know there's a man page on it, but if it's not a part of glibc (the GNU implementation of the standard C library), then who actually wrote and packaged dlfcn? And, if it is a part of glibc, why can't I find any info on it when I run "info libc"?
Ouch. The short answer is that it is provided by the run-time linker (and that `info(1)` is garbage, use man pages or web-based documentation). The long answer is... really long. POSIX has a certain idea of what an operating system is, and unlike, say, Solaris or *BSD, Linux distributions don't conform to that idea. Most of the “System Interfaces” section of POSIX is provided by the kernel and the C library (not necessarily glibc), but bits and pieces are provided by other libraries developed independently of glibc, or by run-time linker, or by the toolchain.
Thanks for the answer. I only mentioned info because I know that the info page of libc is equivalent to [this page](https://www.gnu.org/software/libc/manual/html_node/index.html), which is my absolute favourite resource on programming. I was kinda surprised not to see an entry on dlfcn, so I came here.
I found him in glibc: https://github.com/lattera/glibc/tree/master/dlfcn
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [lattera/glibc/.../**dlfcn** (master → a2f3483)](https://github.com/lattera/glibc/tree/a2f34833b1042d5d8eeb263b4cf4caaea138c4ad/dlfcn) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dxm56ql.)
info manuals are a great resource. I don't know what he's on about.
Awesome find!
Then what is the non idiomatic way to traverse a the linked less then? Or the non-useless way as you say.
I personally, probably organize it this way https://pastebin.com/Kmu86WNU
It seems as though you only changed the bracketing style and a few comments. Am I missing something?
Er. No. No, it's not.
split your code into different files, make some functions static (only used in their own file) group them broadly into similar functionality. for example you might have a file dealing with 2d sprites, stick all the initialisation, and actual drawing in the same file, you might need an extra function for example to set up the projection matrix any time it changes, just so that you can keep all the internal details (variables) static ideally of course you need to plan out the whole thing first...
Oops. Thanks. 
Ehm... You sure? On a 32 bit system, `SSIZE_MAX` is typically 2147483647 (about 2 GB) whereas on a 64 bit system it is typically 9223372036854775807 (about 8 Exabyte). Are you sure you have compiled your program for 32 bit mode? Otherwise this doesn't make a lot of sense. Anyway. `SSIZE_MAX` can be found in `limits.h` but only if you define an appropriate *feature test macro* to declare that you want to access the POSIX API: #define _POSIX_C_SOURCE 200809L You can also define the following feature test macro which gives you even more interfaces: #define _XOPEN_SOURCE 700
It is a standard POSIX definition and there is no easy way to define it yourself in a portable manner. See my other comment for how to access it. It's in `limits.h`, a standard header.
If you are on a 64 bit system, it should just work to write 20.4 GB data in one go. `SSIZE_MAX` is not a relevant limit here.
I can't reproduce your bug though and the too small `align` buffer doesn't seem likely to be the cause. Your corrupted value is 00000000 00000000 00000000 01001000 00000000 00000000 00000000 01001000 Those 2 bytes are both the same value (`H`) and there's no obvious place I can see where that would come from
bad bot
Thank you, jedwardsol, for voting on umnikos\_bots. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
What’s your OS? On some platforms eg windows a long is only 32 bits and a lot of your masks look like 64 bit values. Maybe that’s causing issues?
No blog spam please.
are you askting then into splitting the program into multiple files? any decent C book covers the topic, but it's basic programming stuff...
Yes, it is. It had its place in the pre-web era, but it was never *good*, just *better than nothing*, and it needs to die. We've had better solutions for hypertext for 25 years now.
Same place on the official repository: https://sourceware.org/git/?p=glibc.git;a=tree;f=dlfcn;h=master
I mean it depends on your definition of waste. https://www.google.com.au/url?sa=t&amp;source=web&amp;rct=j&amp;url=http://index-of.co.uk/Etc/The.Practice.of.Programming.-.B.W..Kernighan..pdf&amp;ved=2ahUKEwiap4nlnsbaAhXMXLwKHdlkAPQQFjAAegQIBhAB&amp;usg=AOvVaw3tAFSrWg0VrV2ljiMAmiAB
Not homework. Check my history
Well worth it.
This problem is indicative of poor design. Or no design. In a perfect world we plan our work and work our plan, or we fall back on Agile as an excuse for sloppy implementation. 
That view is so alien it's not even on the same planet. That I can look up something in a more structured document full of links to other parts (unlike man), and search the whole thing, from emacs or at least a different screen/tmux/terminal window, is what makes info so handy. Having to switch to a browser, search for something in it, and filter out all the stuff I'm not interested in to focus on just the HTML version of the same document I'd be looking at in info would just kill my work flow. Even if lynx was still a feasible choice it's just so many extra steps...
Modularize. If a function is turning into a mess, break it apart. If the source file is getting unwieldy, split like functions off into their own files. Group similar variables into structures where it makes sense and pass around the structure. Basically, just refactor as you go along. Organizing your code makes it so much easier to fix things when they break. You can ignore whole files, and concentrate only the areas that might be at fault. As you add new functionality, take a moment to reorganize things if it needs it. It makes it much easier down the road. As for code style, you'll find your own as you go along.
&gt; It's in limits.h, a standard header. Not in standard C it isn't.
In POSIX standard C it is.
Define standard C.
&gt; How do you deal with your program getting messier and more complex as you go? I abandon it and switch to a totally unrelated project :-) To play safe, I generally abandon them before they have a chance to become complex.
The artist who created the Go gopher is Renee French, Rob Pike's wife. It wouldn't surprise me if she drew the cover for this book too.
Old-timers like me, who grew up in the days before Agile, would say you should plan to throw the first version away. It's purpose is to explore the problem space and to uncover the flaws in your approach to it. Then, using what you have learned, refactor and re-architect the design for the second version, which is the one you ship. (Third versions -- the [second *released* versions](https://en.wikipedia.org/wiki/Second-system_effect) -- often suffer from [feature creep](https://en.wikipedia.org/wiki/Feature_creep) and other "messy" pathologies.) 
It incorporates the ISO C standard plus some additions. But he didn't mention that it's part of C but of POSIX C. Anyhow, programming C without POSIX is usually shitty anyhow, you can even assume `CHAR_BITS` to be 8.
Really? It's even got its own [Wiki page](https://en.wikipedia.org/wiki/ANSI_C). How can you not know what standard C is?
I know what standard C is. For me, POSIX is a standard for C, expanding ISO/IEC 9899:1999. For you, it apparently is not. That's why I'm asking you.
That definition is not a standard C definition. It's a POSIX definition. It's only in limits.h (a *standard* header) if it has been made non-standard. Do you know how we know it's not standard? This guy is posting because he doesn't have it. That means it's not standard. That's all you need to know.
If what's important to you is being able to look it up in Emacs, then Emacs is fully capable of displaying and navigating HTML and of browsing web sites with a much better user experience than `info(1)` or `C-h i`.
Not in a better way when it comes to the gcc maual, or anything else available in info format it doesn't.
&gt; I now need to write a program to have a string, then as I press buttons to add to string. Then decide if an operation was pushed. If + is pushed, then put say 123 from string into a result. Why add to string, have your internal representation use ints, and just transform it to a string when you display it. Have an accumulator and a scratch variable you initialize with 0. When you press one of the digits multiply the current scratch by 10 and add the pressed key. When you press an operation button, store the type of it and move the value of the scratch variable to the accumulator and then read the second number. On pressing =, do the operation, display the result, and reset the variables.
It would make sense to use that if he'd drive the 7 segment display directly from hardware, not exactly the case here where he uses a microprocessor to display stuff on the LCD.
[Yes](https://www.gtk.org/tutorial1.2/gtk_tut-1.html)
Read it and find out!
regardless of display, still wouldn't want to be doing maths with strings...
Nothing written by those two is a waste of money!
Namespaces? :(
If you need precise integer sizes, you should probably be using the uint types, as in uint64_t. Just include stdint.h. See http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdint.h.html
You never free `racers`.
Use `-fsanitize=address,undefined` instead of valgrind - it serves much the same purpose, but from my experience produces more helpful messages, runs significantly faster and is generally less buggy.
Looks like you never initialize `racers[0]` (`start` is set to 1, so the initialization loop will never touch `racers[0]`) but you use it at line 45 when `j` is 0.
Check out gtk3 and winapi. Those seem to be mainstream choises for gui in C. There is also Dear ImGUI, which has c wrapper.
AdSan doesn't catch anywhere near as many uses of uninitialized memory as valgrind in my experience. (I end up using both at different times during testing).
Thanks for the reminder !
&gt; I thought I did? Yeah, I realized that after I posted, I edited my comment. &gt; So for freeing racers [...] Usually you just have to free what you `malloc` yourself, unless you use a library function that documents otherwise. In this case, just `free(racers)` at the end of the program (e.g. when you free `rcrs`) is enough.
last time: It *is* standard -- just not ISO-C-Standard but ISO-POSIX-Standard. And that's all that's been said. Yes, we very well do understand that it's not the pure C standard, but we never claimed it was. You claimed we did, you're arguing against something we never claimed. So what is SSIZE_T? It's *standard POSIX C*. And thus in most cases available and one should rely on it or not use it but not try to define it by oneself because that's the least portable option.
I asked because I added a free, but it's still yelling at me for it: ==26656== Thread 2: ==26656== Conditional jump or move depends on uninitialised value(s) ==26656== at 0x4C30F78: strlen (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==26656== by 0x401206: run (racer.c:46) ==26656== by 0x4E416B9: start_thread (pthread_create.c:333) ==26656== Uninitialised value was created by a heap allocation ==26656== at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==26656== by 0x4010F4: makeRacer (racer.c:26) ==26656== by 0x400F12: main (pt-cruisers.c:45) ==26656== ==26656== Conditional jump or move depends on uninitialised value(s) ==26656== at 0x4C30F78: strlen (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==26656== by 0x4012C2: run (racer.c:57) ==26656== by 0x4E416B9: start_thread (pthread_create.c:333) ==26656== Uninitialised value was created by a heap allocation ==26656== at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==26656== by 0x4010F4: makeRacer (racer.c:26) ==26656== by 0x400F12: main (pt-cruisers.c:45) ==26656== ==26656== ==26656== HEAP SUMMARY: ==26656== in use at exit: 0 bytes in 0 blocks ==26656== total heap usage: 12 allocs, 12 frees, 132,046 bytes allocated ==26656== ==26656== All heap blocks were freed -- no leaks are possible 
This is what it's complaining about: /// Run one racer in the race. void *run(void *racer) { pthread_mutex_lock(&amp;lock); Racer* r = (Racer*)racer; r-&gt;row++; set_cur_pos(r-&gt;row, r-&gt;dist); for(unsigned int i = 0; i &lt; strlen(r-&gt;graphic); i++) { put(r-&gt;graphic[i]); } while(r-&gt;dist != FINISH_LINE) { int oldDist = r-&gt;dist; pthread_mutex_unlock(&amp;lock); usleep((rand() % wait) * 1000); set_cur_pos(r-&gt;row, oldDist); printf(" "); r-&gt;dist++; set_cur_pos(r-&gt;row, r-&gt;dist); for(unsigned int i = 0; i &lt; strlen(r-&gt;graphic); i++) { put(r-&gt;graphic[i]); } fflush(stdout); } return NULL; } Could it be because at the very beginning I have a pointer for the parameter (I use it to cast since the function doesn't know what a Racer is) that I never actually allocate for?
It's *a* standardized addition to C. It's not *the* standard. You can standardize some random libraries you make and publish papers about it, make a company to support it. But it's not *the* standard. I claimed it was not standard C. It's not. I'm not wrong. It is not standard C. It's an extension to C that people have made. If it was standard C, every standard C could compile it. They can't, and it's not. End of story.
OK: here's *one* problem: this line (at line 42 of your original post) Racer** rcrs = malloc(sizeof(Racer) * numRacers); you allocate space for a number of `Racer`s (which I'm guessing is typedef to a struct) but you use the allocated space as if you had allocated a number of *pointers* to `Racer`s. The obvious fix is to declare `rcrs` as Racer* rcrs = /* ... */; instead. There might be other errors depending on the definition of `Racer` (e.g., does it contain pointers, or only arrays of chars?).
I'm not sure if that was related to the issue we have been discussing, but I modified the code so that it was what you suggested and it seems to work so I guess it's good? I had to change parts with the pointer arithmetic so it silenced some errors. However, the uninitialized stuff is still present. Line 26 is a part of this function: /// Create a new racer. Racer *makeRacer(char *name, int position) { Racer *r = malloc(sizeof(Racer)); r-&gt;dist = 0; r-&gt;row = position; char *buf = malloc(MAX_NAME_LEN + 1); // this line? memset(buf, '_', MAX_NAME_LEN); size_t len = strlen(name); memcpy(buf + 4 - len/2, name, len ); r-&gt;graphic = buf; return r; } I'm not quite sure what exactly is wrong. I actually had other issues with that statement such as invalid reads that I resolved and thought would be it, but I guess not.
Yeah, sounds right. I did the same thing in my code. I strongly recommend you to make your array members atomic variables though. This way, the compiler generates correct read-modify-write operations, avoiding possible race conditions.
You're not writing the NUL-terminator t o`buf`. You should have buf[MAX_NAME_LEN] = '\0'; somewhere in `makeRacer`. (That's why Valgrind complains that `strlen` is accessing non-initialized memory, it's reading past your `_`s until it hits some '\0' that only exists by chance). 
Oh. My. god. I cannot believe something so simple has been the cause of my woes lol. So really, this entire time I've been lucking out right? Well, that was it. I want to thank you for sticking around and working with me through this. I learned a valuable lesson: be mindful of NUL-terminators!
You're right. Thank you for pointing that out! :)
I'm not sure what you mean by "make my array members atomic variables". Are you talking about the process of transforming the depth that is being stored? I know that atomic operations are essentially operations that can't be split (or maybe shouldn't be split). I've never taken a class parallel computing, but I remember reading a little bit about atomic operations in systems programming.
Just use the type `atomic_uchar array[SIZE]` from `stdatomic.h` instead of `unsigned char array[SIZE]` for the array and everything should work just fine. If an object is atomic, all operations performed on it are atomic. Operators of the form `+=`, `-=`, `&amp;=`, `|=`, etc. are upgraded to be atomic *read-modify-write* operations. So if you write foo &amp;= 0xf; and `foo` is an atomic object, you can be sure that this whole operation is performed in an indivisible unit, avoiding race conditions.
You need to ensure that this code database[add] = database[add] &amp; ((depth+1) | 0xF0); as well as the other assignment, each executes atomically. Otherwise, your code might do something like: - thread 1: reads the value at `database[add]` - thread 1: computes the new value to store in `database[add]` - thread 2: writes to `database[add]` (e.g. after computing the other half of the byte) - thread 1: stores the _new_ (now incorrect) value in `database[add]` /r/FUZxxi suggests you can accomplish this by declaring your array such that the compiler will generate the proper code for you. I have no experience using atomic variables, so I can't elaborate. The way I've done something like this was with atomic operations. In the MacOS world, you have calls like `OSAtomicOr32` which let you do what you want. In any event, the code as written has a race condition as you suspected. Actually, it's even trickier because each core may have it's own cache. So one core may have completed its write, but when the other core reads it gets an out of date value from its cache (read about cache coherency and memory barriers).
Do those types add locks to force atomic operations?
Depends on the size of the type and the CPU. [atomic_is_lock_free](http://en.cppreference.com/w/c/atomic/atomic_is_lock_free) will tell you if a particular one is or isn't.
You would probably need two stacks. One to keep track of your values and another one for your operators. As you type into the calculator you save each value into your stack of Values. Whenever you find/read an operator : 1. You first need to check if there is an operator in the top of the stack with equal of higher priority. If there is one you then pop that operator from the stack, and pop the amount of values needed for that operator from the stack of Values (Example: 2 values for + and 1 for exp). 2. You do the operation and save the result in the stack of Values. 3. Save the operator you read before starting step one in the stack of operators. This is just from the top of my head so you might need to adjust it to be able to manage operations inside parenthesis, but I believe you basically need a parser to process the input. You can google "Lex and yacc calculator" to get a better idea.
A lot of the time, switching malloc to calloc will remove this. 
How is this related to programming in C?
I apologize, a few of the bot sites say that their product is written in C# . I wasn’t sure if that was the same thing. 
C and C# are completely not the same thing. Generally speaking, you won't get any good help in /r/csharp either as the programming language has little to do with the quality of the program you bought. I have removed your question as it is off topic.
Ok I appreciate the clarification. My apologies, I’m new to computer programming and just looking for helpful individuals. Thank you for your time and hope you have a blessed day. 
Put 4 spaces in front of each line to format code for Reddit. Or better yet, since there's a lot, put it on pastebin or gist or the like.
I tabbed everything which increments it 4 spaces
It’s a self-balancing binary search tree. I just learned about it from this post- Wikipedia has a an interesting animation of the search in action.
It’s a self-balancing binary search tree. I just learned about it from this post- Wikipedia has a an interesting animation of the search in action.
It’s a self-balancing binary search tree. I just learned about it from this post- Wikipedia has a an interesting animation of the search in action.
You should create the removeitem with a while loop to check if node.first and node.last are equal to the passed in firstname,lastname. if they are not then you move the node pointer to the nextFirst and/or nextLast. 
AVL trees was the first self-balancing binary tree. Over the years people invented "better" trees that didn't need that many balance operations. But for the past 10-20 years computer architecture is such that the number of rebalance operations means fuckall and depth of the tree is everything (because that translates directly to cache pressure). And AVL trees have pretty much optimal depth. Which means that they are usually the fastest binary tree out there but no one teaches them because professors repeat "RB trees have fewer rebalance operations" that their grandfather told them without running a single benchmark to actually test it because computer "science" forgot that science means that sometimes you need to measure things. So AVL trees are mostly forgotten despite being the easiest binary tree to implement and winning every benchmark I've seen this century.
Please don't do this: #define my_cmp(p, q) ((p)-&gt;key - (q)-&gt;key) Other than causing UB if it overflows/underflows, if you actually get normal underflow behavior this makes the compare function non-transitive for keys are near INT_MIN or INT_MAX which breaks trees in spectacular ways. Pretty much every modern compiler will generate equally efficient code (when things get properly inlined) when you write something like: static inline int my_cmp(const struct my_node *a, const struct my_node *b) { if (a-&gt;key == b-&gt;key) return 0; return a-&gt;key &lt; b-&gt;key ? -1 : 1; } 
We never said it's in *the* C standard. However "standard C" is no reference to a specific standard and ISO POSIX C is a major C standard, if not the biggest. Anyhow, again: * we didn't claim SSIZE_T to be in the ISO C standard * we did neither claim that you were wrong saying that. I honestly don't understand why you think we said that. I explicitly denied that statement for all the last comments.
The fundamentals are solid. Starting with the more serious issue, original and escaped string are both length MAX, you have protected yourself against buffer overflows with the escape function checking for `j &lt; MAX -1` but your program will still produce unexpectedly cropped text if say a user provides 1000 tabs as input. Consider initialising with `char escapedString[MAX * 2];`. Also, the question asked for an `unescape` function as well. But thats just being pedantic on my part. 
... I really wouldn’t want to do any maths with BCD either...
You too have a nice day!
Implement a Mersenne Twister yourself! It's a great exercise. 
I would use a `for` loop rather than a `while` loop. And declaring function arguments as arrays is a bad habit (arrays decay to pointers when passed to functions, see the first few items in [chapter 6 of the C FAQ](http://c-faq.com/aryptr/index.html)).
Could you please pick an [indentation style](https://en.wikipedia.org/wiki/Indentation_style), reformat your code, and put it on [codepad](http://codepad.org/) or something? If you're on Linux, try `indent -kr program.c`. And either remove the commented-out code or use `#if 0 ... #endif` instead of a block comment.
**Indentation style** In computer programming, an indentation style is a convention governing the indentation of blocks of code to convey program structure. This article largely addresses the free-form languages, such as C and its descendants, but can be (and often is) applied to most other programming languages (especially those in the curly bracket family), where whitespace is otherwise insignificant. Indentation style is only one aspect of programming style. Indenting is not a requirement of most programming languages, where it is used as secondary notation. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I like [PCG](http://www.pcg-random.org/) as my go-to quality PRNG. The 32 bit integer generator has 2^63 possible sequences of period 2^64 derived from any given 64-bit starting state. That's a *lot* of room to work with. The 64 bit integer generator bumps that up to 2^127 and 2^128. The C++ version has variations with much larger periods without needing huge starting states (Which makes seeding a lot easier); not sure if they're in the C library too. If you really need an extremely high quality PRNG, the Mersenne Twister fails a lot more stress tests compared to PCG and a few others (Like XorShift\* and ChaCha). Plus its huge state makes seeding it with quality random bits problematic... I stopped using it in favor of leaner, meaner and all around better PRNGs some time ago.
No, the computer version is not formatted correctly, and it is not a matter of reddit formatting; it is a matter of you not indenting your code correctly. Please run `indent -kr` on a copy of your source file and compare the result with the original.
Unless it is something like money, secure messaging or crypto currencies. Then please use a battle tested library. There where multiple incidents in the recent past where the script kiddies implementing crypto wallet managers had weak randomness and money got stolen.
I usually go for [xoroshiro128+](http://xoroshiro.di.unimi.it/) (period 2^(128)-1) since it's [the fastest](http://nullprogram.com/blog/2017/09/21/) for my typical use case. PCG is my second favorite, but, due to its use of data-dependent shifts, it can't be used in some situations, such as SIMD. uint64_t xoroshiro128plus(uint64_t s[2]) { uint64_t s0 = s[0]; uint64_t s1 = s[1]; uint64_t result = s0 + s1; s1 ^= s0; s[0] = ((s0 &lt;&lt; 55) | (s0 &gt;&gt; 9)) ^ s1 ^ (s1 &lt;&lt; 14); s[1] = (s1 &lt;&lt; 36) | (s1 &gt;&gt; 28); return result; } I'll also echo not bother with Mersenne Twister these days. Its slower, bigger, and its output is lower quality than more recently designed PRNGs. 
That is just for this tiny example. In real programs, I [mostly use](https://github.com/attractivechaos/klib/blob/master/kbtree.h#L396): #define my_cmp(p, q) (((q)-&gt;key &lt; (p)-&gt;key) - (((p)-&gt;key &lt; (q)-&gt;key)) This requires you to define a "less than" only. I thought this is harder to understand, so did not use it in the toy example.
Unfortunately people copy toy examples all the time and then someone demands you debug some piece of toy code you published 10 years ago that they put into production. It's like child support for code, always wear a condom on your example code.
Fair enough. All examples are changed.
Mersenne Twister is often believed to be an inferior RNG these days. Its long period deceives people to think it is a good one, but in fact, it has more clashes than many simple RNGs. See [here](http://www.pcg-random.org/other-rngs.html). I have seen a more informative page explaining this. Couldn't find it.
I could not get MSVC to generate the `ROL` opcode that I think is necessary to make xoroshiro128 faster than xorshift128 on x86 using the algorithm from that site. So xorshift ends up being about 6% faster on an ivy bridge i7 at 1.21ns per `next` vs 1.296. Do you know if it's possible? 
I don't doubt your suggestions on pointers, however they havent been covered in the material I'm reading yet. I'll keep an eye out on this. Thanks
Thanks for the tips. Your right about extending the escaped string. I appreciate the response
Be aware that Monte-Carlo computations can be very sensitive to the choice of RNG. There was a well know crisis when MC computations were giving wrong answers to models with known analytic solutions (Phys. Rev. Lett. 69, 3382) https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.69.3382 The reason was a poor choice of RNG. I can only recommend to use PRNG specifically designed with MC computations in mind. In particular RANLUX (http://arxiv.org/abs/hep-lat/9309020) seems like a very sensible choice. It is "slow", but this should not me a problem unless your program spend most of the CPU time generating random numbers. There are very theoretical reasons to think that RANLUX produces random numbers without big correlations, that is exactly what you need for MC simulations. Personally I would stay as far as possible from Mersenne twister. There are free implementations end efficient implementations freely available in C (http://luscher.web.cern.ch/luscher/ranlux/) 
For random input, AVL and RB trees are about equal in most benchmarks I have seen. However, on ordered input, AVL is faster than RB. I guess practical applications are something in between. For a reference, [this paper](https://benpfaff.org/papers/libavl.pdf) by the author of libavl shows that AVL is faster than RB in a real-world application.
looking at your snippet and basing on your description, I think it is fine. coding like writing is inherently messy and not everyone is gonna write hamlet in one draft. just stick to the principles like modularization and commenting and KISS to get something working, like draft writing. you can worry about making things pretty and clean later on rewrite.
xorshiro128+ fails way too many test suites for my tastes.
Do your own homework
What version of MSVC? Here's what I'm getting with MSVC 2015. cl -Ox -c xoroshiro128plus.c dumpbin -nologo -disasm xoroshiro128plus.obj Output: Dump of file xoroshiro128plus.obj File Type: COFF OBJECT xoroshiro128plus: 0000000000000000: 4C 8B 01 mov r8,qword ptr [rcx] 0000000000000003: 4C 8B 49 08 mov r9,qword ptr [rcx+8] 0000000000000007: 4B 8D 04 01 lea rax,[r9+r8] 000000000000000B: 4D 33 C8 xor r9,r8 000000000000000E: 49 8B D1 mov rdx,r9 0000000000000011: 49 C1 C8 09 ror r8,9 0000000000000015: 48 C1 E2 0E shl rdx,0Eh 0000000000000019: 4C 33 C2 xor r8,rdx 000000000000001C: 4D 33 C1 xor r8,r9 000000000000001F: 49 C1 C9 1C ror r9,1Ch 0000000000000023: 4C 89 49 08 mov qword ptr [rcx+8],r9 0000000000000027: 4C 89 01 mov qword ptr [rcx],r8 000000000000002A: C3 ret 
Check out https://github.com/lemire/testingRNG for a comparison of the most popular algorithms.
If that uses the original arc4 algorithm, it's very slow and produces non-uniform output. If it's like the arc4random functions on recent OpenBSD releases and actually using ChaCha20, it's still slowish (but much faster) but produces much better output.
&gt;It's the one from OpenBSD since libressl is developed by OpenBSD. &gt; That doesn't necessarily mean it's the same as the functions in the OpenBSD libc. &gt;Define "slowish". Be aware that I have actually benchmarked it against other both random and predictable number generators. The OpenBSD implementations of arc4random and chacha20 regularly get extra high quality random bits from the kernel to mix into their states. With versions that *don't* do this and thus are faster than baseline (as well as actually possible to test in reproducible fashions), ChaCha20 is reportedly 70% faster, but still "an order of magnitude slower" than fast good quality non-CRNG generators.
You can do a couple things. The easiest would be to just have `f` take a `const int *`, which would allow you to just pass `args` to it. If you can’t change `f`, write a one-line wrapper function (inline, preferably) that takes a `const int *` and passes `args[i]` to `f` as separate arguments. Alternatively, there are libraries that would let you pass arbitrary argument lists, but that’s probably more effort than it’s worth.
Can you change the signature of `f`? If so, just make it take the array as an argument instead of the individual args.
Sadly, no I can't. This function is imported from a shared library (which I have to use), so I can't do anything about it.
Can't do. The function is imported from a shared library, I have to pass arguments manually.
Then no, sadly there's no better way than passing all the array elements individually. If you have to do this in many different places, you could save yourself some effort by writing a wrapper that takes an array and calls `f()` with the elements.
Guess I'll do that. Thanks!
I think I will do the wrapper, thanks for the suggestion! Can you please tell me the name of the libraries you mentioned? I tried to google it, but I could only find articles about passing arrays to functions...
I'm confused as to what that function would even look like. 
I'll look into that, thanks.
 int f_wrapper(const int *args) { return f(args[0], args[1], …, args[n-1]); }
 int w( const int n, int a[] ) { switch( n ) { case 0: return -1; case 1: return f( a[0] ); case 2: return f( a[0], a[1] ); case 3: return f( a[0], a[1], a[2] ); ... } return -1; }
ncurses. https://en.wikipedia.org/wiki/Ncurses
**Ncurses** ncurses (new curses) is a programming library providing an application programming interface (API) that allows the programmer to write text-based user interfaces in a terminal-independent manner. It is a toolkit for developing "GUI-like" application software that runs under a terminal emulator. It also optimizes screen changes, in order to reduce the latency experienced when using remote shells. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Just note ImGUI runs on top of openGL/directx
Try making a basic text calculator or a simple text game!
Sorry it is not helping with your question but I recently transferred to a university from community college and they teach only C language and I only learned java. How do you like this book?
RemindMe! 6 days "Recommened Project"
I will be messaging you on [**2018-04-26 20:05:25 UTC**](http://www.wolframalpha.com/input/?i=2018-04-26 20:05:25 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/C_Programming/comments/8dqahq/recommended_projects_to_make_while_reading_c/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/C_Programming/comments/8dqahq/recommended_projects_to_make_while_reading_c/]%0A%0ARemindMe! 6 days ) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
I can't judge it hard yet, I just started the 6th chapter of 32. But I do like it, it keeps it simple enough and has good enough examples. One thing it has done well is explain things that would give you errors in a super understandable way
I wouldn't say good randomness is slow, but true randomness is finite. That's why we use a PRNG in the first place to generate pseudorandom numbers from a truly random seed.
Why would you use libffi within a C application without needing to communicate with another language. FFI stands for *foreign* function interface for a reason.
**Multiply-with-carry** In computer science, multiply-with-carry (MWC) is a method invented by George Marsaglia for generating sequences of random integers based on an initial set from two to many thousands of randomly chosen seed values. The main advantages of the MWC method are that it invokes simple computer integer arithmetic and leads to very fast generation of sequences of random numbers with immense periods, ranging from around 260 to 22000000. As with all pseudorandom number generators, the resulting sequences are functions of the supplied seed values. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
You can create a macro, eg. for `N=5`: #define EXPAND5(args) args[0], args[1], args[2], args[3], args[4] or you can create a small (perhaps inline) wrapper function -- or combine both approaches: static inline int _f(size_t n, int args[n]) { return f(EXPAND5(args)); } I chose to also pass `n` to `_f` because this way I have more compile-time checks about accessing array elements, and the compiler should optimize this away when inlining. If it's really critical, one can just use the macro directly. Full example of both approaches: #include &lt;stdio.h&gt; #define EXPAND5(args) args[0], args[1], args[2], args[3], args[4] static int f(int i0, int i1, int i2, int i3, int i4) { return i0+i1+i2+i3+i4; } static inline int _f(size_t n, int args[n]) { return f(EXPAND5(args)); } int main(void) { int a[] = { 0, 1, 2, 3, 4 }; printf("%d\n", f(EXPAND5(a))); printf("%d\n", _f(sizeof (a)/sizeof (a[0]), a)); } 
Not sure what that has to do with C, but nifty project. Good luck.
If you know vim, you can macro the rest of the switch structure
You might have better luck getting help if you first make an attempt to solve this yourself and ask specific questions. It looks like what you are trying to do is to create a[menu driven program](https://www.geeksforgeeks.org/menu-driven-program-using-switch-case-c/). In that case, generally you will have a main menu that allows the user to choose what they want to do and functions to perform each task.
RemindMe! 1 days
If you like puzzles or are interested in security/cryptography, you can give the [cryptopals](https://cryptopals.com/) challenges a go and do them in C. They require no background knowledge, will make you use a lot of the C syntax that you learn, and are overall really neat!
This is gonna be super long, but the game idea sounds great and I just want to give you some quick examples of what you can gain from something like a "simple" text adventure game: Parts I, III: Game state - you'll become intimately familiar with variable scope (local vs global, etc.) and recognize the importance of minimizing global state, as well as how to properly organize code. After having dozens of variables, you'll instinctively want to use good naming conventions, and write good comments to figure out where you are in the code. To top this off, you can incorporate a game loop for background processes that change with each 'turn' or player action, like health, hunger, etc. Oh, and you'll learn how to interact with the user to accept input/output! Part II: Story - You can use if statements to determine what branches/paths the game's story will take. Operators can be used to check for different conditions which can affect the story or even actions (like a stat-based, Pokemon-esque combat system). Part IV: Inventory - There are tons of opportunities for arrays and other data structures. Right off the bat, you can declare a max inventory size and use an array to store the items. If an item has special properties (like weapon stats), you can create *structs* for those items, and save *pointers* to those in your array! Again for background processes you can use data structures. If there are enemies/animals that exist independent of where the player is, you can iterate over an array with pointers to the creatures to get them to move/act each turn. If new creatures/items can be generated procedurally, you might even go the extra mile and learn how to make linked lists! Part V: Save Files - This part will really make you think too! Learn how to save every important feature of the game into text files so the game can be played from where you left off! If you decide to procedurally generate items, you can also create files for those. You'll learn how to structure and encapsulate data, and think even more about how program state can be represented. Do this part well enough, and you might even be able to package the whole game into something portable that you can just copy across USBs or send through mail, and continue progress wherever you left off. On top of learning C syntax in your book, committing to a large project like a game can teach you many more software development principals. You'll learn how to plan and break a larger problem into smaller chunks (believe me, a few hundred / thousand lines of code in, and you'll get tired of charging in without thinking about what's coming up ahead). You'll learn how to abstract - that is, make a specific problem into something more general, so that solutions to it can be applied to other problems \*\*ahem, data structures\*\*. Getting a grasp for patterns in the logical structure of your program is also a plus. Having to manage state and interactions, as well as data structures could teach you some defensive program and error handling. You might even feel the need for source control and writing test cases, which feels almost like an obstacle when you first dive into programming. Whatever you decide to do, good luck on your journey!
That allocates a 1D array - ie. enough for one of your lines. Perhaps you need a loop.
right now you're allocating a 1d array ``` void doSmth(char **code, int lines) { int i; i = 0; *code = malloc(sizeof(char*) * (1 + lines)); *code[lines] = '\0'; while (i &lt; lines) { code[i] = malloc(sizeof(char) * your_word_size); i++; } } ```
That's not correct either. It's assigning to code[0] twice.
In the calling function, if you had something like: // example 1 int lines = 50; char *code[lines]; do_smth(code, lines); Do this: void do_smth(char **code, int lines) { for (int i = 0; i &lt; lines; i++) { code[i] = malloc((LINE_LEN + 1) * sizeof(**code)); assert(code[i]); } } Below is an incorrect example: // example 2 char **code; do_smth(code, 50); // `code` holds a garbage value (uninitialised) // note: it's good practice to assign NULL to uninitialised pointers However, you could do this: // example 3 int lines = 50; char **code = malloc(lines * sizeof(*code)); assert(code); do_smth(code, lines); And `do_smth()` would be defined the same way as for example 1. Example 3 has the benefit over example 2 of being able to `realloc()` a larger size for `code`. Alternatively, you can change the signature of `do_smth()` and have it create and return the pointer instead: char **do_smth(int lines) { char **code = malloc(lines * sizeof(*code)); assert(code); for (int i = 0; i &lt; lines; i++) { code[i] = malloc((LINE_LEN + 1) * sizeof(**code)); assert(code[i]); } return code; } The code in the calling function would be like: int lines = 50; char **code = do_smth(lines);
other than (not so) common sense - not really, but I really cannot emphasise enough that planning out the code before actually coding - with pencil and paper if needed is a very good way of proceeding, I will often go for a short walk as well post planning and pre coding, just because walking makes you think differently... (no really!) 
By the way, it's very memory inefficient to allocate the *maximum* length for each line. There is no point of using `malloc()` if you're doing this. You could've simply done `char code[lines][200 + 1];`. It would be much more efficient to initially allocate 16 bytes (for example) to each line. If you find yourself needing more memory for a line, just call `realloc()` and double the space allocated for that line.
If you know the size of both dimensions of the array, it's easy to do in one call: void allocate2dArrayAndElements(char **code, int width, int height) { code = malloc(sizeof(char) * (width * height)); } If you don't know both dimensions (or the elements hold diferent sizes): void allocate2dArray(char **code, int size) { code = malloc(sizeof(char*) * size); } void allocate2dArrayElement(char **code, int index, int size) { // NOTE: the +1 is for the null terminator code[index] = malloc((sizeof(char) * size) + 1); }
TL;DR you allocated space for each 1D array but not for the list of pointers to the 1D arrays. 
sizeof(char) is 1 by definition
Sure, this is true. But for clarity I still use sizeof. I see very little benefit towards one way or the other, if any at all.
https://xkcd.com/138/
The division is happening between integers because the numbers are parsed as integers. Do 12.0/7.0 so they are parsed as floats.
int vs float. 12 and 7 are both int's, so when it divides you are left with 1 which is then converted to a float. if you change either/both of the numbers to floats it will work as you expect. example: https://onlinegdb.com/rkC5vkK3M
try float gru = 12.0/7; otherwise 12 is treated as integer.
12 is integer, 7 is integer. Integer divided by integer produces integer. Therefore, `12/7` &gt;&gt; `1` and assignment of `1` to float happens in code. "Extra" part after decimal point is just trown away. Use float notation for numbers when you need fractions.
The question has been answered, but for more general cases, such as dividing two integer variables and outputting a float, you should [cast](https://www.tutorialspoint.com/cprogramming/c_type_casting.htm) one of the variables to a float: float gru = (float)12 / 7;
Also, don't *ever* post screenshots of your code. Use [Github Gist](https://gist.github.com) for code and output.
A decimal point is treated as a `double` by default, so I would use `12.0f` instead to specifically specify float precision, since `gru` is a float.
What ? Is it a book ?
/r/cpp
Thanks for the answer. Now I did this: code = (char**) malloc(lines * sizeof(char*)); for (int i = 0; i &lt; lines; i++) { code[i] = (char*) malloc(200 + 1); for (int j = 0; j &lt; sizeof(code[i]); j++) { printf("%c", code[i][j]); } free(code[i]); } free(code); It works without errors but it doesn't print anything. I think it should be working fine though.
First, `scanf` always expect some storage. You just padded `scanf` a `NULL` pointer to store to. You need to allocate some storage (malloc or array) and give that to `scanf`. Also, `scanf` returns the successful formatted reads, e. g. for `"%d %d`, reading 2 numbers would return `2`, but only reading one and failing to read the 2nd one would return `1`. You may be better off using the `getchar()` function which returns one character. You can then store it in a array, get the 2nd one, store it also to the array and compare. If it doesnt match, shift the array by one and read one more character and check. And so on.
Yes. The actual name is *The C Programming Language, 2nd edition* and it has a whole section dedicated to pointers.
http://libgen.io/book/index.php?md5=64D07F61BD71E1BC6A1D74F51D440C82 comprehensive and definitive book on C pointers. Read this and you'll understand everything there is to know about pointers.
but he wanted to show the output too
Well, he is able to copy the output and put it in Gist as `output.txt`.
[A TUTORIAL ON POINTERS AND ARRAYS IN C by Ted Jensen](http://pw1.netcom.com/~tjensen/ptr/pointers.htm)
I don’t think it is clearer to say sizeof(char). First, it gives the impression that you don’t understand the language, a bit like writing: if (my_flag==true) // or !=0 to be more pedantic instead of: if (my_flag) Second, and that may be harder to explain, having sizeof(char)==1 is a fundamental property of C. The number that is passed to malloc is NOT the number of bytes, it is the number of chars. It has important implications, for instance in the packing of structures, or the existence of platforms where chars are not 8 bits. Hence, when replying to “newbies” questions, I feel important that this aspect is not hidden. Malloc takes a char count, not a byte count. The individual adressibility in C is at the char level. That say, I may also be a pedantic old fart. :-)
There are so many issues with that I don't even know where to start.
I don't see a negative index anywhere... but even if there was, it would be the least of your problems, as this isn't even remotely valid C. (FWIW, if you have, let's say, an array of ten integers, and you set a pointer to point to the fifth, then you are allowed to use negative indices with that pointer as long as you do not go outside the bounds of the original array.)
No, you're wrong. No matter which documentation I read, malloc takes the number of bytes, not chars. Sources: [[source1](https://www.tutorialspoint.com/c_standard_library/c_function_malloc.htm), [source2](https://www.programiz.com/c-programming/c-dynamic-memory-allocation), [source3](http://en.cppreference.com/w/c/memory/malloc), [source4](https://en.wikipedia.org/wiki/C_dynamic_memory_allocation), [source5](https://www.gnu.org/software/libc/manual/html_node/Basic-Allocation.html)] Besides, you even contradicted yourself. &gt; having `sizeof(char)==1` is a fundamental property of C Which means that using sizeof (in the case of char) is completely fine, even if char was 7 bits. Besides, speaking practically, what (modern) platform is char not 8 bits?
I mean, most of the syntax is technically valid... Why am I even trying to defend this? 
Wow it's too hard to replicate/understand two lines of code
&gt; I wonder why B-trees with a radix chosen to have each node fit into one or two cache lines aren't popular. In-memory B-tree and its variants are usually faster and more lightweight than binary search trees (BSTs). For typical uses, I still prefer B-tree. However, BSTs can be made intrusive and persistent. These properties are useful in system and functional programming. BSTs are also easier to be extended for extra features (e.g. interval tree and counting in my application).
You shift all the values to the left when you hit the first zero, but you outer loop still increments, effectively skipping the check on the second zero. You should step through with a debugger when you hit shit like this. Quick answer is to not increment the outer loop when you get a hit. Though it probably has a more ellegant solution.
I don't understand the args in your sprintf, maybe it's pseudo code. But you best bet is to format separate strings then use strcat. There might be a more ellegant function in string lib.
Pick some kind of sort algorithm and implement it. There are loads of ways you can do this.
I was trying to figure out the proper way to write 20 GB to a file. I came across this: https://stackoverflow.com/questions/32387292/write-large-binary-file-in-c Should I not allocate 20 GB? Since the factorization of the database size contains all integers from 1 to 12, I could malloc an amount of memory based on how many threads are being used. However, there would need to be some additional processing to turn an encode into the proper value to write to a different chunk of memory on the heap. This probably isn't as difficult as it seems, but I'd rather not do it if mallocing 20GB isn't a problem.
Arrays are fixed size, so you can't really delete anything from one. You can move elements to the end and treat it like a shorter array, though. Or it was dynamically allocated you can use realloc() to shrink its space.
I'll take a stab at it. `c=a&gt;b?1,2,3` is not the same as `c=1,2,3`. c= the passed value from the outcome of a&gt;b. So a&gt;b is resolved, then the value to pass is resolved, and then that is passed to c. a&gt;b=TRUE? If yes, pass 1,2,3. 1,2,3 resolves to 3, which is what c becomes. To say it a different way, what does `c=a&gt;b?3+5:0` resolve to?
In fact, depending on your goals, it can be preferable.
The terenary conditional has a higher precedence than either. c = ((a &gt; b) ? (1,2,3) : (4,5,6)); So c gets set to 3. 
What happens is that `=` has lower precedence than `?:`, so that line is parsed as `c=&lt;expression&gt;;` where `&lt;expression&gt;` is `a&gt;b?1,2,3:4,5,6,7`. The text in your link shows that `a=1,2,3` is the same as `(a=1),2,3` because `=` has higher precedence than the comma operator. Parentheses are *one way* to force `1,2,3` to be evaluated before the `=`, you just discovered another.
thanks I have another doubt if you may see this program https://gateoverflow.in/213041/c-programming#c213227 I know this is an invalid operation in most of the new compilers as string literals cannot be modified but as it happens it is allowed on old compilers like C But still looking at the outpu , I just can't understand why the string literal p gets reiterated again after encountering an end of line character 
I'd imagine what's going on is that the two strings are laid out in memory one after the other. In effect, it's printing: b b c c \0 1 a 2 b 3 c \0 because your memory looks like "abc\0abc123\0" There's nothing stopping your program from printing until the return from *q++ is zero. The value returned from an increment is the value PRIOR to the increment. So, if a == 2, 2 == a++. You might enjoy looking through your compiled binary with xxd or some other hex editor/viewer, or watching what happens in memory with a debugger. And of course, if you compiled it differently, reordered things, or used a different compiler, the layout might be entirely different. Honestly, I'd recommend just avoiding weird little tricks and assignments like that in conditionals. Compilers are pretty smart at optimizations, and clean readable code is something everyone appreciates... including yourself when you go back to work on it in 6 months.
thanks man