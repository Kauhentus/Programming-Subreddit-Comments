i have updated my question much appriciated the help i can get
I second the recommendation for Edx.org CS50, an excellent course for beginners with world class instruction. Highly recommend. Plus it is FREE.
I like to do this, too, but I worry about readability. I don't want anyone reading my code to worry over why I've used `char`, since this habit is not common.
That's what `(u)int8_t` is for.
It's implementation defined. Generally, you shouldn't be using a `char` for general arithmetic; so, as long as the IO routines display the right characters, it's relatively irrelevant. You should use `unsigned char` or `signed char` (or probably `uint8_t` or `int8_t` if you actually need it to be exactly 8 bits) if you want a number instead of a character. The real question is why the type of a character literal is `int`. 
`stdint.h` is C99.
The others give good responses, but if I can give a recommendation, if you're able you should really make use of `stdint.h` and use the `uint8_t` type. It's guaranteed to be unsigned and 8-bits wide, and generally helps make it clear that you need a specific width of integer. As a note, there is the complaint that not all architectures will have `uint8_t`, but in that situation they also probably don't have 8-bit `char`'s either, so it is somewhat of a moot point. If an architecture doesn't support `stdint.h` at all for some reason (`stdint.h` is part of C99), it's not to hard to get around that by simply supplying your own typedef's for that architecture.
Why would an array of arrays be a use case for double asterisks?
&gt;These types are optional. However, if an implementation provides integer types with 8, 16, 32, or 64 bits, no padding bits, and (for the signed types) that have a two's complement representation, it shall define the corresponding typedef names. —ISO/IEC 9899:TC3, WG14 N1256, 7.18.1.1/3: Exact-width integer types
Then use the `(u)int_fast8_t` or `(u)int_least8_t`, whichever is appropriate. They are guaranteed to exist.
I could be wrong but I think that an int might be faster though because it would correspond to the processor word size.
try set free(contacts); outside your loob for free all entries, 
The only thing that you can pass to `free()` is a pointer that you got from `malloc()`, `calloc()`, or `realloc()`. So it's totally invalid to do things like `free( contacts[i].fname )`. You allocated a block of contacts with `realloc()` en masse, you didn't allocate individual fields. 
Sorry about the formatting - looked proper when I submitted it. 
It's what assemblers crave!
Thats exactly what I thought! How do I reformat so I'm not doing that? I tried early and kept getting compiling errors.
Meant to respond directly to your post earlier - how donI fix it so that its not referencing the pointer? I tried earlier and kept getting compiler errors.
Are you using an integrated environment with a debugger so you can step through your code? The variable labeled "marks" is well-named but your other variables are used semantically in ways contrary to what their symbolic names suggest. Take a close look at your assignment statements. Also consider what results from dividing an integer by a float. Consider what will result from assigning a float to an integer variable.
The biggest problem I can see is that you're trying to store multiple values the user inputs into one variable. You should use an array to store the user inputs since this is a relatively simple program. 
Time constraints
I highly recommend reading *The Little Book of Semaphores*, it's free online if you look.
If it's just a hobby, you might want to start with a higher level language. It can be difficult to get a compiler set up and an environment to program in.
 struct tPlayer { int number; char name [25]; }; void fn (const struct tPlayer* const players, const int num) { for (int i = 0; i &lt; num; ++i){ puts(players[i].name); } } const int num_players = 100; struct tPlayer players [num_players]; // initialize players name's fn(players, num_players); In C/C++, arrays decay into pointers when passed to functions. If you know more about assembly, it's because by your calling convention, you do not have enough registers to fit an array of structs in; it's more efficient to pass a copy of the address of the start of the array. You can pass the array (no need for the address of the array, unless you want to maybe realloc it, which is why I marked the pointer `const`), then in the receiving function note that it's now a pointer. You can still use the array access notation on a pointer. Because the pointer has a type (`struct tPlayer*`), accessing the next field is a O(1) offset operation of + `sizeof(tPlayer)` bytes.
&gt; What does the double asteriks means? So though it's not popular, and can lead to bugs when declaring multiple variables in one statement, I prefer to use the notation: int* i; Student** s; char* c; That way you think of the type as *int pointer* not *int*. Just like you can take the address of a variable and store that in another variable, you can than take the address of the second: int x = 42; int* y = &amp;x; int** z = &amp;y; **z = 10; // x, *y, and **z now all equal 10. &amp;x, y, *z refer to same address &gt; And how would i create a list that could hold every students information sounds like you need to allocate space for an array of `Students` on the heap with malloc, then return that address referring to memory on the heap. The definition of `create_class_list` seems fishy to me, I would have expected: Student* create_class_list (const char* const filename, const int num); thoughts: * why return a pointer to a pointer? you know upfront how much memory you'll need (`sizeof(Student) * num`), so contigously allocate once and return the pointer from malloc. * I doubt a function named `create_class_list` will be modifying an input filename or num, add `const`. * why pass an `int*` if you're not going to modify it? prefer to pass a copy of the int. Use pointer args for variables larger than a register width or in/out params. * sizePtr is a bad name; both hungarian notation and size implies `sizeof` but I bet you're passing a number of elements.
I'd like to expand on what's happening with the current code: average = marks + p; results in average just being the number of values*2-1 (because marks is the number of values and on the last iteration p will be marks-1) Also discarding the value you just read into average Then marks is divided by average (marks*2-1), and I guess it's done with integer arithmetic because marks is an integer (not entirely sure about this), which means dividing something by anything that is larger will be 0
The two operations I would use are a bitwise "comparison" (XOR) and a mask (AND).
&gt; char is only a character on ancient 7-bit systems that you're unlikely to be using anymore. There has never been a 7-bit system with C on it. A `char` is at least 8 bits in size. There have however been 36 bit systems with 9 bit chars. &gt; When you're thinking about things this way, you realize calling it char is confusing, when it isn't a character (anymore), and hasn't been for a long time. `char` is still a character and it has always been. Not all values of a `char` may actually encode characters though.
&gt; using chars to store non-character data is bound to confuse readers Only readers who are not familiar with C programming. People have used `char` synonymous with “byte” for over 40 years now. Nobody is confused by this usage except novices.
&gt; `char` is still a character and it has always been. Wrong. The snowman is obviously a character that does not fit in a `char`. Thinking that a character is "whatever a `char` is" while lazy, is not helpful and actually leads programmers to a lot of mistakes. Just stop it. &gt; There has never been a (system with 7-bit characters) with C on it. Of course there have. ASCII was one of the most popular 7-bit character sets. If you remember that a `char` is not a character this is clear. &gt; A `char` is at least 8 bits in size. There have however been 36 bit systems with 9 bit chars. 9-bits weren't needed to encode characters but things like font weight and character styling. You only think this is related because you are pretending that a `char` must be related to a character because it shares some letters with the word. This is of course wrong, and obviously wrong to people who know what Arabic and Chinese "characters" are. 
 &gt; Let the class_list be a pointer to a pre-allocated array It's not clear to me that from OP's post that this info is known without reading the file referred to by `filename`. I think it must be allocated dynamically at runtime, but maybe I misread. Returning the count is still no quite right. So maybe the in/out count param would have been correct. For example, how do you denote a failure to open filename or allocating memory without making `create_class_list` exit? What are your thoughts on this revision? int create_class_list (const char* const filename, Student* class_list, int* const count); and returns 0 for sucess, anything else is a failure. &gt; For example, the open(2) system call wrapper has this syntax, My opinion; that was a mistake in the interface. `open` should not modify the pointer. If I called `open` and the pointer pointed to different memory location afterwords, I'd be scared. The whole point of marking args const is a basic expectation that the called function won't be modifying the value. For us to invoke `open` without any warnings, we can explicitly cast it away. `open((const char*)filename)` I also think it was a design flaw of C to have values be mutable by default. I prefer Rust's choices where variables are immutable by default, otherwise must be declared `mut`(able).
&gt; Wrong. The snowman is obviously a character that does not fit in a char. There are characters and wide characters. I recommend you to read the C standard and to learn about character sets. &gt; Of course there have. ASCII was one of the most popular 7-bit character sets. If you remember that a char is not a character this is clear. Then tell me such a system. One where `char` is a 7 bit type. &gt; 9-bits weren't needed to encode characters but things like font weight and character styling. Now you are just bullshitting. &gt; You only think this is related because you are pretending that a char must be related to a character because it shares some letters with the word. This is of course wrong, and obviously wrong to people who know what Arabic and Chinese "characters" are. ~~PLONK~~ Let's not continue this discussion.
&gt; There are characters and wide characters. No, there aren't. There is `char` and `wchar_t` and there are characters. It is a common mistake to confuse them. The C standard says very little about characters, even though it says a great deal about `char` and `wchar_t`. &gt; Then tell me such a system. One where char is a 7 bit type. I am being perfectly clear: `char` is not a character. `char` used to be bigger than a character on systems with 7-bit characters, and this has confused you. &gt; &gt; 9-bits weren't needed to encode characters but things like font weight and character styling. &gt; Now you are just bullshitting. No, really. Both DEC SIXBIT and Baudot used a bit to select the font -- for example in SIXBIT a "lowercase" font was common, but a font with underscore was also used. Some lisp machines also used a 7-bit font and 12-bit characters, with the extra bits used for input to specify modifier keys like control and meta, and on output to specify italics and boldface.
I once had a [question with similar goals in mind](https://www.reddit.com/r/C_Programming/comments/3hcslw/oop_c_and_type_safety_why_void_pointers/) (although I have since removed the repo from github) and what I learned is that in general if you need a generic container in C your options are to (ab)use: 1. void pointers 2. the preprocessor Abusing the preprocessor was how I thought this should be done for a long time, and while I wouldn't go so far as to say that it is wrong now, I will say that using void pointers will save you time and headache. Of the preprocessor methods I've heard of the Linux Kernel is said to use some pretty solid generic containers (though I haven't had time to look into it myself). For void pointer methods I would suggest looking at [AT Schreiner's Object Oriented Programming in ANSI-C](https://www.cs.rit.edu/~ats/books/ooc.pdf); in particular Chapter 8 covers type-checking. &amp;nbsp; With all that out of the way, let's look at the idea you've posted: I would not recommend storing multiple fields in the struct to distinguish data types. This will increase the size of your struct to a point that it starts to become unwieldy. Moreover, you would still have to do some sort of magic in order to determine *which* field you need to access in order to insure you're using the proper type. If you still want to go with this option I would recommend instead storing a union in your struct that contains fields for all the types of stuff you'd want to be able to store in the list, and an additional variable in the list to denote the type of the variable stored. This will require a switch case style function to analyze the aforementioned type variable to determine which field of the union will need to be accessed, but at least by using the union your struct will stay smaller. &amp;nbsp; As a final note, I think you may be better off using a dynamically allocated array (sometimes called a vector) than a linked list. Arrays are faster and, in my experience, easier to implement and maintain. If your assignment require the use of a linked list then by all means use that, but if you can get away with using an array I think both you and your code would benefit. &amp;nbsp; Just my two cents, others will no doubt disagree. Please ask any additional questions, I'm always happy to help as much as I can.
This depends largely on what these threads are doing and whether or not they're sharing memory. If they're all working with the same data you're going to run into this behavior so long as you have that data mutex'd. In order to get them all to run concurrently on the same data you'd have to either unmutex the data (not recommended), split up what each thread is doing so that they can trade off the data more frequently, or split up the data so that each thread is only working on a specific subset and thus won't need to wait for the others. I think the last option will probably work best, but not knowing anything about what you're trying to do I could be completely wrong.
In this case, I'm just learning about threads, so not anything to do with data at all. Just trying to get them to print out in different orders. 
If istalling a virtualization software like VMware or Virtualbox is impossible, you could, and this is a long shot and totally not something I have tested, install DosBox on a USB stick and find a free C compiler to run inside that. 90's tech to the rescue!
You are going to have to post the code to know what the problem is. pthread_join takes as an argument the thread you want to wait for so if you wait for them in order you will get them in order. However, if the thread is printing out you should be able to get interleaved output. Again, you will have to show your work for anyone to properly explain what is happening. 
http://pastebin.com/HKa8w9Uz I've moved my print statement to thread and it still doesn't print out interleaved :o. But thanks. 
So I guess I'm confused on pthread_join now. You said: &gt;pthread_join takes as an argument the thread you want to wait for so if you wait for them in order you will get them in order. So now I'm confused. So it is printing them out in the different orders, but pthread_join also calls for them to wait? In my pthread_join for loop here: for (int i=0; i&lt;5; i++){ pthread_join(tids[i],NULL); } Can you explain what's going on? 
Since the size is small a lookup table is actually reasonable since it avoids 3 logical operators. This obviously doesn't scale, but you can even use a bitfield. ((0x8001 &gt;&gt; (x &amp; 0xF))&amp;1) Also note that this is operationally O(1) rather than O(N). 
So if I'm understanding this right, pthread_join makes sure that the main thread doesn't close/exit until all the threads have been completed. Right? 
This is genuinely fascinating. Thank you.
Write a ray tracer. It's a fun project.
Have a look through [this post](https://reddit.com/r/C_Programming/comments/4htvx3/im_currently_learning_c_and_im_having_a_hard_time/).
Yes. I was sure there had to be a better way. That was a good 15 minutes of thinking. 
Take a look at Arduino (and the subredit at /r/arduino). It's a microcontroller. There is an entire community that makes things with it (see hackaday.com).
Nope. It's "random". You probably can use some global variable to keep track of which thread got notified last.
At least an algorithm? Here's one: "FFFFFFFFFSCCCBBAAAAA"[mark / 5] There's also a quadratic solution that's pretty close: -0.625*pow(x,4) +10.8796*pow(x,3) -65.4861*pow(x,2) +172.295*x-116.667 However that is mostly me telling jokes. I will be serious now. Being able to tell the computer what to do, and being able to get the computer to do what you want, isn't what a programmer does: A programmer listens, and understands, and with some luck, communicates. If I show you *a* way to solve this problem, then your professor will give you bad marks because you didn't understand your professor. They want you to solve it *their way* to make sure that you're understanding. I could lecture you on functions, user input and output, storage, and what each character means, but you'll still be missing a trick: If you really are struggling with the problem description, then maybe being a computer programmer isn't for you. You should know that is quite nearly my whole day- understanding what someone wants from me: I might only spend an hour or so typing code each day. Try to break apart the problem. Think about what your professor has shown you. Try to ask *just* what you're having trouble with, and show us how you're interpreting it. All we can *or should* do is nudge you.
Can you provide us with an example of what the printout is supposed to look like?
Done so, sorry first time posting here
I see what you mean by that I'll go try some things out, thanks :)
Good luck!
A great and essential skill for being a software developer is being able to take a problem and break it in to successively smaller chunks until you get small tasks that you can accomplish. Break apart the problem as your professor describes it. As you read, he asks for the following: * menu to select operations * a password to prevent someone from using it without the right password * a function to take user input that are a student's marks * a function that takes a mark and converts it to a letter grade * a function to print the marks for each student and each course Your professor already broke the problem down in to some pretty manageable parts, but you now need to go through each one of the requirements and recursively ask yourself "What other information do I need to be able to implement this?" until you have a list of small tasks you can implement. To give an example, lets take a look at the function to convert the marks in to letter grades. The first question you ask yourself is what info do you need to do this? You might come up with "I need to know what the student's grade is" and "I need to know what the corresponding letter grade is" and "I need to return the letter that corresponds to the student's grade". Then you ask yourself for each one of those questions what you need. For "I need to know what the student's grade is", your answer might be "this should be passed in as a parameter to the function". For "I need to know what the corresponding letter is to the grade", you might answer "I need to be able to compare the grade to the values given in the problem". For "I need to return the letter once I know what it is" For each of those questions, now ask yourself what is needed to implement each of those: For the grade parameter you want to pass to your function, you ask "what is the type of the input parameter?". For "I need to compare the grade to values from the question", you might realize you can implement this by comparing values using an if/else statement. For "I need to return a letter once I know what it is", you might realize that you can implement this by making your function return a char. lastly, for the "what is the type of the input parameter to my getMarks function?", you might realize that a numerical grade will always be an integer, so you want to make your input parameter an int After asking yourself all of these questions, the task of making a getMarks() function you have now broken down in to the following steps: * a function that returns a char and has one input parameter of type int * in the function, use if/else statements comparing the input parameter to the values given by your professor to get the letter grade * when you find a letter, return it as a char Assuming you have been paying attention in class, each one of these small steps are now straight forward to implement in C char getMarks(int grade){ if(grade&gt;=75){ return 'A'; }else if(grade &gt;=65 &amp;&amp; grade&lt;=74){ return 'B'; } else if(grade &gt;=50 &amp;&amp; grade &lt;=64){ return 'C'; } else if(grade &gt;=45 &amp;&amp; grade &lt;=50){ return 'S'; } else{ return 'F'; } } By breaking the task of making a grading function in to smaller individual requirements, it becomes a bunch of small tasks to implement and connect rather than a larger task. This example is a fairly basic one, but the same methodology is something you need to get really good at doing. It will be the way to break down each of the remaining parts of your problem, as well as being the skill you use in just about every programming task you set out to accomplish. And when you are given less detail about your project, it will be a crucial skill for you to have to be able to break down large tasks in to smaller and smaller ones. EDIT: I forgot to add a side note as I was writing this up. Notice how your professor's problem doesn't specify whether the grade ranges are inclusive or exclusive(is a grade of 50 considered a C or is it considered a "SUPP". Although I assume a borderline grade rounds up here, this would be something you'd want to verify with your professor. You always want to clarify any gray areas in a problem's description and never just assume that the person asking you to write the program interprets the gray areas the same way you do. 
I'm mostly coding in C for hobby, and coming from other languages. Unshift is usually called when you prepend to to an array, and the function also adds a new head :D Maybe not the best name, I admit it. :D "Note that currently when you store a struct in your memory pool which contains a pointer to some allocated memory you will have a memory leak if the user isn't careful. " Could you please give an example? How could it cause any problem? If the user uses the pool_free function to give it back to the pool, and the pool_destroy, to actually free the pool, how could it leak? 
Lets say that I execute the following code: void my_function(Block *block) { // allocate 2048 bytes void *my_pointer = malloc(2048); if ( some_data.my_pointer == NULL ) printf("Something went wrong\n"); blockp-&gt;ptr = my_pointer; } // Initialize the memory pool... // If I read your code correctly I can get a block via new_block(...)?? Block *blockp = new_block(pool, false); // The only reference to blob of 2048 bytes of heap memory is stored // in your memory pool, because of the local scope of the function. my_function(blockp); pool_free(pool, blockp); // Now you lost 2048 bytes because you removed the only reference // to that piece of memory. This happens because as far as I can tell the only thing you do is switching the boolean. You are not checking if there is something stored in the block struct that points to some memory on the heap. You have three options: - Forbade the user to store pointers the point to allocated memory on the heap - Give the users the option to store a function pointer which they can use to point to a function that frees the memory if it is a pointer. Let me explain that a bit more, if a user stores a pointer that points to the heap they have the option to store a function pointer in the block which frees the heap allocated memory. Otherwise the user can use NULL if there is no pointer stored in the block. - ~~Use a boolean by which you can see if you need to free the pointer or not.~~ This is rubish. If you have any more questions ask away! 
No, you misunderstood. I updated the code, and added some comments to clarify, please ask if it's not clear. The Block struct is internal, only a void pointer is returned to the user, which size is determined during with pool_init. Given your example it should be something like this: struct test { struct test *next; }; int main(void) { MemoryPool *pool = pool_init(sizeof(struct test)); struct test *test = pool_alloc(pool); test-&gt;next = pool_alloc(pool); /** Not necessary to call. It makes the given block reusable. */ pool_free(pool, test); pool_free(pool, test2); /** Actually frees the memory */ pool_destroy(pool); return 0; } The other thing I want to know is, that should I somehow clear the memory when the user passes it back to the pool via pool_free?
Okay to be honest I don't know what the possible use-case of this library could be. I probably just don't get it, care to explain?
What is wrong with built in formatting of scanf functions? int arr[3]; char str[100]; printf("input 3"); gets(str); sscanf(str,"%d %d %d", arr,(arr+1),(arr+2)); printf("\n%d // %d // %d\n",arr[0],arr[1],arr[2]); You just need to add validation of input string. edit: Your program doesn't work because "isdigit(userInput[i]) == 0" is true when "userInput[i]" is a non digit. It should be just " while (isdigit(userInput[i]))". Also instead of "i = i + 1" use "i++". It is a lot easier to read.
I'm with /u/j0holo on this one. What use is the memory pool if I still need to make calls to `free` from outside of it? A memory management system should manage all of my memory needs for me so I don't have to deal with the bookkeeping. 
Well, it was a poor example, but let's say, I need to create a lot of the same type of structs and free them, and maybe its members are also fixed sized, so can be also returned from a pool, avoiding to keep calling malloc() and free(). Actually I'd be great if I could solve that the block sizes are not fixed, but I have no idea how to defragment the memory. Please let me know if you have any ideas.
I updated that post for the sake of the example.
Nice one, but it's not actually what I want. If I'm correct you also have a fixed size (ELEM_SIZE), resize the stack when needed. My ultimate goal is to have a pre-initialized chunk of memory, where I can return different size of blocks from, thus avoiding to call malloc/calloc and free as rarely as possible. 
&gt;What use is the memory pool if I still need to make calls to free from outside of it? Speed increases and lower memory usage (from bytes not wasted in alignment) are two advantages. However, you don't need that most of the time, so I'm with you for the most part.
Just decided to go with another solution. Yeah pointers are the bane of my existence right now. Thanks anyways. Thanks for the pointers too (not a pun). 
without seeing the code you wrote for storing and printing the values it's impossible to point you in the right direction. 
I can dig it. Did you see [this](https://www.tutorialspoint.com/data_structures_algorithms/linked_list_program_in_c.htm) ? Sample code and such, looks pretty comprehensive. Good luck to you!
https://www.gnu.org/software/libc/manual/html_node/Memory-Allocation-and-C.html
Problem with that one was that it didn't have an initializer, so it only created 1 linked list. I needed multiple haha. 
Thank you!
I'm assuming you're asking what happens if you do such a thing? Remember `#include` is pretty dumb, it just dumps the file included into the current file as it's compiled. So it will behave as if you just declared the variable as `static` in each file. What does `static` do? &gt; The static specifier specifies both static storage duration (unless combined with _Thread_local) (since C11) and internal linkage (unless used at block scope). [cppreference](http://en.cppreference.com/w/c/language/storage_duration) &gt; internal linkage. The identifier can be referred to from all scopes in the current translation unit. All static identifiers (both functions and variables) have this linkage. [Same page](http://en.cppreference.com/w/c/language/storage_duration) So the variable will be created once for each translation unit you include it in. That is there will be a seperate copy in `file.c`, `file2.c` and `file3.c` with each being inaccessible to other files.
You have to keep track of that information yourself. There is no way to get the size of a dynamically allocated block. `sizeof(b)` is the size of a pointer (typically 4 or 8) and has nothing whatsoever to do with the size of the buffer of memory that the pointer points to. You're already keeping track of the size in `k`, so just use that. You are also wildly over-complicating things. All of the code you've written can be replaced with: char *b = malloc(strlen(a) + 1); strcpy(b, a); ... free(b); Or char *b = strdup(a); // strdup is not ISO C, but is commonly available ... free(b); 
Embedded Linux may be a good route to take. It's still in the embedded world, but it opens up new options. You get experience with Linux and you can also learn about tools that complement C, such as shell programming and build tools. Yocto may be a good choice. It has the support of the Linux Foundation and vendors such as Intel. There's already a lot of support for a variety of architectures and software packages.
So I did your solution with making an array of structs, and the output is (also does this have to be done in the main thread? I'm creating threads in my readFile() function) thread 1 created thread 2 created thread 2 data thread 3 created thread 4 created thread 4 data thread 4 data It skips over the printf()s in my function :/ I'm joining my threads once I get done reading. 
Can you show me the code? And it's been a while since I did anything with pthreads, but in looking at the code in the OP, it might be the thread ID that's the issue? You can't just point back at the same thread ID on each pthread_create call. Edit: by thread ID I mean the pthread_t struct, the first argument to pthread_create.
Read code. Reading is the most important skill in coding. It will make you better and keep you involved in what other people are doing. 
A couple of things. You have a void function that is returning a number, and you have an else statement that is returning -1. So if the character your looking for isn't in the first index, the code will pass through the else statement.
ok so what do you suggest i do to return the intended value? I have made a few changes, I edited the question if you'd like to look at them. 
So the problem is the indexM assignment and the if else statement. First off, I don't recommend using the else portion at all. Instead, I recommend setting indexM to be -1 when you first declare the variable. That way, the else will not change it to -1 on each loop iteration (which is just extra work). So delete the else and set indexM to be -1 when declared. Second off, in your if statement you declare indexM = string[i]; this sets indexM to be the integer value of the character at position i. Instead, you want the position of i, which is where you found the M character. Therefore change this to indexM = i; after these two corrections, the function should be fixed! Edit: forgot to add that the reason you are getting 77 is because the ASCII value for 'M' (or the integer value of the character 'M') is equal to 77. Hence, you are storing the character, not the position of the character. 
You set b to the result of calling malloc. You then set b to the address of a. That address was not returned from malloc, so you can't pass it to free. You now have a memory leak because the pointer returned by malloc was never freed and isn't reachable from anything. free that pointer before storing a new value in b.
Does this mean I can't really say in a statement b=... for anything until I free b? So I can only use *b=... Is there in general a good way around this if I want to set space aside with malloc? Or am I using bad practice in some way?
Even removing malloc and saying a=&amp;b[0]; still gives at least an error with valgrind.
So, looking at your code, you're definitely messing up alignment depending on the size of the structure you're allocating - and of course, your data-structures are not thread-safe since you don't do anything to prevent data-races. All that said though, the code really isn't bad. Definitely shows a basic understanding of how this type of allocator should work and a good effort. I think you're actually making this a bit more complicated then you need. I've written an allocator like this before, and there are lots of ways to make this type of thing a lot simpler. The first is to throw away your 'header' for each block - it's a waste of memory and adds extra complexity. Think of it this way: What do you gain by having those headers? All the header contains is a 'free' marker, and a pointer to the actual memory that block is using. But keep in mind how you allocate them - the header is always *directly* before the memory it is referencing. Meaning the pointer to the actual memory is essentially unnecessary, because you could already go directly to that memory via the pointer to the preceding block (IE. Take the pointer to the block, cast to `char *`, and add `sizeof(Block)`). There are better ways in C to code this that I won't get into, so I wouldn't recommend making that change directly, but regardless my point is that the pointer in there is redundant, which is important to understand. The 'free' flag can also be made redundant. You keep a linked list of blocks, but *why* do you keep every block in the list? Remember, the location of the `Block` in relation to the pointer is redundant (Per above), so your `pool_free` can simply do a pointer subtraction to get the `Block` and then mark it as free. Because you can access the `Block` directly when you free, you can remove allocated blocks from your linked-list completely. This would have the effect that your list would become nothing but free blocks - making the 'free' flag redundant because it will always be true. Thus, we've distilled your code down quite a bit - by doing some math and recognizing the memory layout, all you *really* need is a pointer to the next free block. When you allocate, you take the first free block off of the linked-list, and when you free you put that block back into the list. The cool part is that, because all the blocks you need pointers too are already empty (IE. free), you can just store the pointer at the beginning of the block! Thus you don't need to allocate separate space for a header, just store the header in the block directly (Obviously, force the memory size to be at least as big as a pointer). When the block is allocated, you have no need for a header, and when the block is unallocated that space is free to use. With that in mind, your functions become basically `O(1)` operations (for the most part). `pool_alloc` is simply removing the first item in the free list (Instead of looping over all the items in your pool as you currently do now), `pool_free` is simply adding the free'd item to the free list. `new_block` just increments the end of the memory by `memb_size` bytes and adds that to the front of free list (IE. Writes the head of the free list into the newly allocated memory block, and then writes the address of that memory block into the 'head' pointer). Since you want a resizeable memory pool (I assume), you probably want to use `realloc` in `new_block`. It's not the most efficient, but it would work. As for alignment, the general rule is to align to the largest data-type supported. For 32-bit systems it's usually 8 bytes, and for 64-bit systems it's usually 16-bytes. The alignment requirement means that the addresses of all of your memory blocks (The actual block you return from `pool_alloc`) have to be a multiple of 8 or 16. With the changes made above (Removing the `Block` header), each block of memory is allocated directly after the one before it, and the initial piece of memory is allocated with `malloc` (Which will align it for us to 8 or 16, or whatever our alignment should be). In this situation the easiest way to force alignment is to simply make `memb_size` be a multiple of 8 or 16. So if someone passes in '14' for `memb_size`, you force it to be 16. If someone passes 23, you force it to be `24` (or `32`, depending on 32-bit or 64-bit). Note that 16 is a multiple of 8, so if you don't want to worry about 32-bit vs. 64-bit, aligning unconditionally to 16 is perfectly fine. If you have any questions feel free to ask, I'm not sure I really explained everything extremely well.
Your wording is confusing here because making a pointer to an already existing array has nothing to do with malloc. It is just creating a variable that is the same as the address of that array. You can already access a stack allocated array using your offset variable i like a[i].
To avoid having to use a fixed value like 16 for the maximum alignment requirement, you can also use `_Alignof (max_align_t)` (since C11).
Usually you to start like first speak not bad, Everytime then prepare storageclass (not ask some just triky question in Reddit blah blah)
Well, for a start, on line 90, you have a parenthesis in the wrong place; it reads: if(strcmp(player_entry, pass_check == 0)) but it should be: if(strcmp(player_entry, pass_check) == 0) More generally, you should use a debugger (such as `gdb`) to run your code and check where problems are occurring.
i suggest using gdb's `step` command to step through each line of your code to observe what's happening; you can use the `print` command to display the value of an expression at each point. Doing so can help one learn what the code is *actually* doing rather than what we *want* to be happening. :-)
I've got everything working except now when I use strtok_r() to try and set my strings, it doesn't work :/ But at least I got my threads sorted out. Edit: needed to allocate some memory and use strcpy() to finish the job. wooo got it. 
If you want to do it declare it as an extern and declare it in one of the files. //header.h extern int global; Then in some source file. //Source.c int global = 1337; All the files including header.h will now use the variable from source.c even if they don't include it.
In general, you should use the `memchr` standard library function for this purpose. That said, think about what the assignment `indexM = string[i]` does and think what assignment you need instead. Also, Please try to indent your code properly, right now it's a bit hard to understand all the nesting.
[try this](http://lmgtfy.com/?q=c+input)
Useless as always. I ain't asking for a cooking recipe bud. 
&gt; Useless as always. I ain't asking for a cooking recipe bud. I feel sorry for your professor. 
[here](http://www.slideshare.net/olvemaudal/deep-c) (but most of the slides are "blah blah")
&gt; And if I don't want to limit to fixed block sizes how should I handle the memory layout without fragmenting it? It has to do with pointer addition. When you add to pointers, it is the same thing as 'incrementing' an array index. In fact, these two syntaxes are 100% equivalent: a[1] == *(a + 1) The point to keep in mind is, how many bytes does the '+1' increment `a` by? The answer is `sizeof(a)` - Adding to a pointer takes you to the next 'entry' after that pointer. This is also why you can't add values to `void *` - sizeof(void) is invalid, so when you add the compiler doesn't know how many bytes to increment your pointer by (Note: `gcc` and I'm sure others offer an extension that allows you to add to `void *` types as though they were `char *`. It is still invalid by the standard though, but if you try it you might not get a warning). Thus, `char *` comes in. `char` is essentially the single 'unit' type - normally a byte. So if you cast something to `char *`, then you can increment that value and specify exactly the number of bytes you want to move. This means, for example, you could move half-way into an element in `a`, which is impossible when dealing with the original pointer view (It would be like doing a[.5] in a way, but obviously that makes no sense). That said, if you take my suggestion of storing the block information inside of the free block's data, then no pointer 'math' is necessary. You can just treat the `void *` they passed to `pool_free` as a `Block *` and then write to it like usually. If you make the headers separate from the data, then you have to do the above subtraction when you take the `void *` they passed, cast it to a `char *`, and then subtract to find the pointer to the `Block *`. &gt; And if I don't want to limit to fixed block sizes how should I handle the memory layout without fragmenting it? Generally speaking, there aren't any perfect ways to handle this, fragmentation is unavoidable in that case because the blocks don't fit together all nicely. Also, because the blocks are variable size, and the size isn't passed to `pool_free`, that means every block *has* to have extra header information so you can retrieve its size when freeing - that leads to a lot of extra overhead and more complexity. Once you have that information though, it is not tons different then the above. But, `alloc` becomes an `O(n)` operation, because you have to check every currently free block to see if it is large enough, instead of the above `O(1)` operation where you already know the size of every block and thus don't care which one you take. Generally, there are lots of allocators *don't* handle this case, and *don't* allocate variable-width blocks. That sounds counter intuitive, but it's actually really easy to solve the problem - just use multiple pools. So what you do is create a `generic_memory_pool` (Or whatever you want to call it), and inside of that it has several MemoryPools - say, one for 32-bit blocks, one for 64-bit blocks, one for 256-bit blocks, one for 4k blocks, and then perhaps special handling for blocks bigger then that, such as just allocating them stand-alone (Obviously, tweaking these settings can change both performance and how much memory you use). `generic_memory_pool_alloc` just take the size of your allocation and matches it with the smallest-sized MemoryPool it has that still fits that block (So, if you allocate 16-bits, then it takes from the 32-bit pool, if you allocate 200, then it takes from the 256-bit pool, etc.). You can also create the MemoryPool's on demand if it helps (IE. Don't call `pool_init` for every pool right off the bat, just call them when an `alloc` would actually use that pool and you haven't create it yet). Your `generic_memory_pool_destroy` just calls `pool_destroy` on all the internal MemoryPools, freeing all the associated memory in every pool. This approach gives you flexibility in the size of block you allocate, but still avoids fragmentation in the memory blocks with-in each pool, and also gives you all the benefits that come with that (Such as very fast allocation). &gt; And the last one, what kind of techniques are to take care of thread safeness? I know that C11 has atomics, but unfortunately I couldn't find any good explanations to understand. It's hard for me to answer this without knowing your background in threads and thread-safe data handling. The basic problem with threads is that they can modify a piece of data at the same time - called a data-race. If you have a data-race, then it's possible that you could do something like give out the same block of memory twice, or not free a piece of memory correctly, etc. So thread-safety simply refers to preventing data-races - in this case, on your MemoryPool structure and associated blocks. Generally speaking, the way you're going to want to solve this problem is by using a `mutex`, which is a construct found in most/all threading libraries (Like pthreads, or C11 threads, etc.). If you're completely lost after reading about them I'd be happy to explain, but the basic idea is that you'll put a `mutex` structure into your `MemoryPool` structure, and then whenever you need to modify or look at the contents of the `MemoryPool`, you'll "lock" the `mutex` and then "unlock" it afterwards. The `mutex` guarantees that only one thread can have a lock on it at any one time, so it in effect will force every one to "get in line" to use the MemoryPool and prevent data-races by only letting one thread use the MemoryPool at a time. Note: You could possibly solve the problem via atomics, but it would be much more complicated. Atomics essentially allow you to avoid locking in certain cases, but they can be very error-prone to use if you don't know exactly what you're doing.
There is no type-checking done on 'array' (actually just decayed into a pointer) function arguments. You know *nothing* about the size of the array without additional explicit arguments.
One way to solve this problem is to store the "edges" in global variables. Another way is if not all values are needed, you can use a special sentinel value to mark the edges. This is how the C compiler encodes the sequence `"foo"` as the characters `{102,111,111,0}`. Another way is to encode it into the higher bits of the address: If you're dealing with a lot of 100x100 arrays, you could use `posix_memalign()` with a *large* alignment (e.g. `1&lt;&lt;17`) and then you'll just *know*. Another way is to use a nested function. This is not "standard" but works very well in GCC, so I'd recommend it if you can use GCC. And yet another way is to use a macro so that you can pretend you're passing one value when you're passing several. 
There is actually some type checking done: void function(int array[100][100]); int main() { int array[100][50]; function(array); } &gt; prog.c:5:16: warning: incompatible pointer types passing 'int [100][50]' to parameter of type 'int (*)[100]' [-Wincompatible-pointer-types] &gt; function(array); &gt; ^~~~~ The above check requires an exact dimension match, and applies to all but the first dimension. Also I should have mentioned the `static` array size qualifier: void function(int array[static 100][100]); int main() { int array[50][100]; function(array); } &gt; prog.c:5:7: warning: array argument is too small; contains 50 elements, callee requires at least 100 [-Warray-bounds] &gt; function(array); &gt; ^ ~~~~~ This check only requires that the argument have _at least_ the indicated number of elements; If you give it more it doesn't care. This check applies _only_ to the first dimension.
For functions only: Remember that this is a **declaration**: &gt; void print_hello (void); And this is a **definition**: &gt;void print_hello (void) { printf ("hello"); } The .c file extension is used to specify translation/compilation units. Each of these translation units are processed by the compiler independently without knowing anything about the others (the other .c files). Inside each translation unit there are function **definitions** and variables. The compiler converts the functions to isolated executable code chunks and emits symbols for them. The compiler doesn't know where those pieces of executable code will be placed in the final program, so function calls to functions that are in other translation units (.c files) can't be made at the compiling stage. When you call a function that is not **defined** (and a **declaration** exists in the same translation unit), the compiler just writes on its output (object file) that it requires another symbol to do the a function call. It doesn't know where the functions will be located in the final program, so it can't do much more. Solving function calls is the work of the linker, the linker creates the final program by joining all those object files (generated each from a translation unit/.c file) and substituting the unsolved function/symbol references (calls) by references (calls) to real functions at its final loacation. So what happens when you call a function that isn't already known (**declared** or **defined**) inside a given translation unit ? The compiler fails, as it just knows about what's inside the translation unit (.C file) that it's currently processing. For this at least **definition** is needed. *To indicate to the compiler that a function **definition** exists later (code lines below) in the same translation unit (.C file) a "regular/non qualified" or "static" function **definition** needs to be known (needs to be in the code above the line referring it). *To indicate to the compiler that a function **definition** exists in another translation unit, an extern function **declaration** needs to be known. Each "#include &lt;somefile.h&gt;" directive is in fact just a rude copy-paste of "somefile.h" at the #include location. Nothing more. Such .h files use to contain extern **declarations** to be used from other translation units (.C files). Otherwise it would be tedious to hand-write all the function definitions each time. A "static" function **definition** tells the linker that this function may not be referred to outside of the current translation unit. It's a private function which doesn't generate external symbols. So you define everything static unless it's needed by another translation unit. 
I would recommend reading the code of software you're already using, especially if there is anything you want to change about it.
No, we are in a team. I am the designer and the director of the program. He is my programmer. He got lazy and told me that I should continue it.. He didn't even remove the bugs from his program and I did it for him
You can pass a box as a `char*` and unpack it inside.
I have a feeling you are doing something strange. Why do you call `malloc()`? If you want newly allocated memory to store value of `a` the you should use `memcpy()` to copy value of array `a` into memory allocated by `malloc()`. And later you should pass address returned by `malloc()` into `free()`. It is not essential what variable will be used but you have to pass correct address. When you write `b=..` you are overwriting its value and destroying address you should be using later to free memory. 
Grammar and spelling is much better in this post! Good!
Note that there is no such thing as C/C++. Can you tell us what language they program in? Is it C or is it C++?
Drop the class honestly.
What about C but not specifically embedded stuff?
we could absolutely use the help!
Ooops... Spelled his name wrong. Should be Torvalds.
Are you referring to the grid code before I modified it? Or after? If before, then yes, that was the point. It was an illustration of code that was "poor taste". If after, please elaborate. I think the change I made was about as optimal as it could possibly get.
I meant before but my issue with the first version of the grid code is that it isn't merely bad taste -- it is simply dumb and I don't think anyone with more than a brief introduction to programming would do that. I think most people would *start* with his final solution. I imagine he had to contrive an example of good taste vs. bad taste but I don't think the grid code does a good job. eta: I don't know why your comment is being downvoted. It wasn't me. 
But also I think "good taste" is more subtle than simply optimizing or code reduction. I think another term I've seen used and used myself is 'elegance'. Elegant code by nature is simple, compact, and clear. So in this way I think his notion of having good taste is about being able to identify and write elegant code.
How about utf?
This is a really great explanation, thankyou. I don't ever think I understood extern or static until just now.
https://www.tutorialspoint.com/cprogramming/c_file_io.htm https://www.tutorialspoint.com/cprogramming/c_strings.htm https://www.tutorialspoint.com/cprogramming/c_structures.htm this should be enough to get you going. If you get stuck on a particular part of your program post your code and what part you're stuck on. 
What kind of UTF (-8? -16?) support do you expect?
UTF-8 with maybe conversion utility functions between others as well.
Almost none of these functions are needed at all. You can use standard string functions to deal with UTF-8 encoded text just fine, UTF-8 was specifically designed to have that property. The only thing you need to do is to always work on strings, never individual characters. For example, instead of `strchr` use `strstr`, etc.
&gt; Almost none of these functions are needed at all. So why does pystring exist then?
I have no idea. Perhaps because someone wrote it?
I had a similiar challenge a while back, feel free to check out my code https://github.com/rubinkazan/magicsquareC/blob/master/magicsquarev2.c
This grid code would be a disaster for large grids. The way most architectures implement TLB cache lookup makes accessing memory at consecutive addresses radically more efficient than accessing memory that's all over the place. Edit: for what it's worth, off the top of my head, I'd say I would probably use 3 different loops. The first two would initialize the top and the bottom respectively. The CPU could highly optimize these. The third loop would handle writing to both the edges, which is going to risk page inefficiency for sufficiently large arrays no matter how you do it.
Hey ! This doesn't seem to be bad at first glance. Just this line : if((((int) pow(a,p)) % p) == a) is gross. Be aware that it's not because you write all your program in one line that the compiler will transform it into one instruction. If you want to write efficient code in C you have to think in terms of processor behavior (load/unload of registers, caching,...) and number of instructions (assembly). But also keep in mind that your code must be easily understood by someone else. Make it readable and simple. When it's not, add commentaries. this is what my small experience can tell you.
It is not good code because it is not documented. I cannot even tell if it is correct because there is no comment explaining what it's supposed to do.
Writing text editors is surprisingly complicated and terminal programming doubly so. You might want to look into the *libcurses* and its newer implementation *libncurses.* These libraries do most of the complicated stuff with respect to terminal programming for you. You might want to read the book [*Terminfo &amp; Termcap*](http://shop.oreilly.com/product/9780937175224.do) from O'Reilly which explains how this works. You are going to need a suitable data structure to be able to efficiently edit text. I recommend a *gap buffer* (the traditional choice) or a *rope.* &gt; I want it to be source compatible. What does that mean?
Did you write this code? Have you tried running it? Is it using the memory it has allocated correctly?
Yes, I wrote it. I have tried running it on an online IDE but I'm not sure how to properly test it? I just wanted to know if everything is correct. I haven't gotten an errors.
I certainly don't know the most efficient way to do this, so I will just point out some things I notice that I don't particularly like. First thing I notice, is that you are freeing inside the loop and then again outside the loop. That should be an error. It's been a while since I used C, so I don't remember if that will directly crash your program or not, but it is an error. Next thing I notice, is that you are allocating and freeing the same thing (buf) over and over in your loop. This is a waste. Just allocate it once and keep writing over it. Also, the way you are using it, buf does not need to be 2 bytes. You only need to null terminate if you are using the char* in string functions that expect the null termination. Next thing I notice, is ret is most likely going to be WAY larger than it needs to be. If your input is just "a\nb" then you have this gigantic memory allocation for just 2 bytes of data. Try to think of a way to only allocate what you need, or at least reallocate to what you need once you are done. I'm sure someone else will have some insight on a better algorithm.
Would this code work if I remove the line that frees new_node?
Thanks. I am looking in to that. The menu library looks tempting though. Anyway I want the code to be portable so no #IFDEF win32 and so on. At the most cmake can handle it.
Further to comments made by /u/bretoune and /u/FUZxxl: Looking at your code, I have no idea what your variables are supposed to represent. I could make an educated guess and assume that `p` is the prime number that you are testing but what then is the purpose of `a`? Choosing good variable names is the one of the fundamental practices in clean code.
I see. What does 8d mean though? Why is that value there? Is it hex representation of an instruction?
That's correct, that's the operation code for LEA. http://faydoc.tripod.com/cpu/lea.htm It's also worth noting that while you can't edit the section that holds the running code, you can totally run arbitrary instructions.
Either I misread or he/she mistyped and then edited his post, but i thought /u/Snarwin's comment originally said 8d. I think I get the concept regardless though.
I see, I've seen that before in classes; only so many bits are the representation of the instruction. I just haven't really experimented by myself with looking at stuff for c and my computers native instruction set.
If you have any further questions, feel free to ask.
The sad part is I had a hard time finding the opcode because I expected it to be a mov or a push, as that's usually what the first instruction is. Should have checked the OP!
You should probably check that the return value of scanf is equal to the number of matches you expect (2). Right now entering something that doesn't match, eg. "1 b", yields a floating point exception. b will remain unchanged, ie. 0, which leads to pow(1, 0);
In addition to what cathercy said, in standard C, avoid casting malloc. See [comp.lang.c FAQ list](http://c-faq.com/malloc/mallocnocast.html) for details.
Yes, 2 of the edges are going to be wasteful regardless, but you could, for example, do the top row, then the middle rows (left edge, right edge), then the bottom row, doing the whole thing in one linear scan of the grid memory. That way, at no point do you blow a cache line that you might want later, as you might if you bounce around. Note the the right edge of a row and the left edge of the successive row are adjacent, so the middle part isn't as scattered as it might seem at first.
Encryption is a language-agnostic topic that applies to any language. You can make these mistakes in C just as easily as you can in Python or JavaScript. The goal of this article is to educate the community to help us write code that is more secure.
In response to your -edit- section, I happen to be taking a class on malware analysis. Just last Tuesday, I presented a few ways to modify a program both during runtime and during compilation &amp; linking. There are quite a few ways, and modern operating systems aren't very good at protecting programs. Spawning it as a child process and modifying it's code from there is an obvious example of this (although this is easily detectable) Another good way is to link the program with libraries that replace some functions with your own functions. You can extent this (so the program doesn't crash or produce undefined behavior) by calling both functions in your modified library, I.e.: A printf that always prints your own message to stdout, then that printf calls the standard printf with the intended arguments From here it gets complicated and more theoretical, like determining the virtual address space of some variables on the stack and changing them. This can be done, and fairly easily, but the first two are no brainers. I'd also like to point out that these methods won't change a programs checksum... So you can verify that the program ~should~ be doing what you expect, while it gives you some ridiculous errors in practice. 
Thanks! That's definitely more searchable than the page I linked.
How ? I still cannot see your code. 
So let's say I need the program to work in 5 different ways - without any args, and with 4 different args. All I have to do is put an if check like "if(!strcmp("-r", argv[1]))" or "if(!strcmp("-S", argv[1]))" before each code?
You have to use the command line arguments passed to your main function. For example: int main( int argc, char* argv[] ) { // argv[0] is the program's filename // Arguments start at index 1 if( argc &gt;= 2 &amp;&amp; strcmp(argv[1], "-r") == 0 ) { // reverse logic } else { // forward logic } return 0; } Let me know if that helps
Check my reply to another comment. The truth is I need the program to work in 5 different ways - without any args and with 4 different args each arg does something else. I didn't state this in the OG post cause I had a hard time explaining it and it was the easiest way for me. Gonna edit the post.
I edited the post to provide more info.
Looks like the oc corrected the code
I edited the original post to clarify the situation.
I edited the original post to clarify the situation.
I edited the original post to clarify the situation. (see /e2)
Alright, so getopt is the way to go. Thanks a lot for your time.
Happy to help!
Sorry, it's all good now. 
I see. The right way to do that with `read()` only is to implement a buffer. You read a block of data with `read()` to fill the buffer, inspect the buffer for new lines and then copy data out. It is a good exercise to do all these, but it may take quite a while if you have done similar things before. Good luck.
[Here's a min heap by djb](https://github.com/amery/qmail/blob/master/prioq.c), curious is people find his code idiomatic, in good taste, or a crazy madman.
getopt sounds good for you, although i find it nonintuitive (I'm weird, don't let me discourage you). You might consider an iterative approach -- do a series of if- then- else if blocks to get the logic right and see how ugly it can be. Then try the idea of flags - consider a switch statement. Then use getopt. This lets you experience what getopt gains you, maybe get a sense of when it might be overkill. I'm a big fan of reinventing wheels for the sake of learning 
&gt; So if I get your base idea correctly, I should return a new Block, from the bool, one after the other, and when the user calls pool_alloc just return the next one from the memory chunk, or the free list (linked list of Blocks), or realloc if there is no more memory. But in that case I have to store at least a 'next' on each block, right? You actually only need `next` pointers on the free blocks, since only those blocks are in the linked-list. Because of this, you just store this information directly in the `memb_size`d block - that area is free for use in all unallocated blocks, and those are the only blocks we need it for. The big caveat is actually that you *can't* use `realloc` - It didn't occur to me you wanted to do that. The reason is pretty simple - `realloc` may copy your data to a completely new location, and when you do that pointers into the old location are made completely invalid. `pool_alloc` returns pointers directly into your `malloc`'d buffer, so obviously you can't just randomly invalidate those pointers. This solution to this is realy similar to the solution for varying sized blocks - just have each `MemoryPool` keep trach of multiple malloc'd buffers. When you allocate, you just go to the first buffer with some free space, when when you don't have any space you create a new buffer and allocate from that. However, that would add a lot of complexity to your current setup, so for now I would recommend just hard-coding the size of the malloc'd buffer and return `NULL` from `pool_alloc` when you run out. You could have `pool_init` take a size so users can define how many entities they want in their `MemoryPool`. Using multiple `malloc`'d buffers is really the way to go through. &gt; Edit: if I use multiple pools, then how should I decide which one should I pool_free on? That's a good question. I've personally done this by adding a `pool_has_addr` function - it is passed an address, and returns true of that address is managed by that pool. Thus, you would loop over all your `MemoryPools` and call `pool_has_addr` on them, and then call `pool_free` if it does. Alternatively, you could just have `pool_free` return false if the address is not in the pool. Then you would just keep calling `pool_free` for each `MemoryPool` until it returns true. Note that checking if an address is within a pool is very simple - you have the bounds for the `malloc` buffer, so a simple comparison will tell you if the address is within the bounds of that buffer. To clarify a bit about the layout of the malloc'd buffer, it should look a lot like this: Block: Block *next; /* Next free block */ MemoryPool: Block *free_list; /* Pointer to first free block */ char *block_memory; /* The malloced memory for this pool */ size_t memb_size; /* Size of each member */ block_memory: /* Each '|----|' is a memb_sized block of memory */ 0 1 2 3 4 5 6 7 8 9 |----|next|----|----|next|---|next|next|next|... The linked-list 'free_list' is in the order: 1 -&gt; 4 -&gt; 6 -&gt; 7 -&gt; 8 -&gt; 9 ... Notice tht the linked-list only includes blocks not currently in use. The other blocks without a 'next' pointer are currently allocated. In `pool_free`, you treat the free'd memory as a `Block` and then add it to the `free_list`, when you allocate it with `pool_alloc` then you remove it from the `free_list` and the `Block` is simply gone and will be written over when someone writes to that block.
You'd typically write a wrapper around the C++ using extern "C" {...} blocks. Most embedded systems support C++, maybe bit the bullet and use that. C never has been great for application level development, but knock yourself out.
would this be considerered null terminating if I did this: char appendedString[100] = ""; I get an execution error: *** buffer overflow detected ***: program.tsk terminated ======= Backtrace: ========= /lib/x86_64-linux-gnu/libc.so.6(+0x7329f)[0x7f34887aa29f] /lib/x86_64-linux-gnu/libc.so.6(__fortify_fail+0x5c)[0x7f3488841bbc] /lib/x86_64-linux-gnu/libc.so.6(+0x109a90)[0x7f3488840a90] /lib/x86_64-linux-gnu/libc.so.6(+0x108c2b)[0x7f348883fc2b] program.tsk[0x400838] program.tsk[0x40067d] /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf5)[0x7f3488758f45] program.tsk[0x4006cf] ======= Memory map: ======== 00400000-00401000 r-xp 00000000 07:00 35 program.tsk 00600000-00601000 r--p 00000000 07:00 35 program.tsk 00601000-00602000 rw-p 00001000 07:00 35 program.tsk 01d66000-01d87000 rw-p 00000000 00:00 0 [heap] 7f3488521000-7f3488537000 r-xp 00000000 00:2e 47 /lib/x86_64-linux-gnu/libgcc_s.so.1 7f3488537000-7f3488736000 ---p 00016000 00:2e 47 /lib/x86_64-linux-gnu/libgcc_s.so.1 7f3488736000-7f3488737000 rw-p 00015000 00:2e 47 /lib/x86_64-linux-gnu/libgcc_s.so.1 7f3488737000-7f34888f1000 r-xp 00000000 00:2e 35 /lib/x86_64-linux-gnu/libc-2.19.so 7f34888f1000-7f3488af1000 ---p 001ba000 00:2e 35 /lib/x86_64-linux-gnu/libc-2.19.so 7f3488af1000-7f3488af5000 r--p 001ba000 00:2e 35 /lib/x86_64-linux-gnu/libc-2.19.so 7f3488af5000-7f3488af7000 rw-p 001be000 00:2e 35 /lib/x86_64-linux-gnu/libc-2.19.so 7f3488af7000-7f3488afc000 rw-p 00000000 00:00 0 7f3488afc000-7f3488b1f000 r-xp 00000000 00:2e 32 /lib/x86_64-linux-gnu/ld-2.19.so 7f3488d14000-7f3488d17000 rw-p 00000000 00:00 0 7f3488d1a000-7f3488d1e000 rw-p 00000000 00:00 0 7f3488d1e000-7f3488d1f000 r--p 00022000 00:2e 32 /lib/x86_64-linux-gnu/ld-2.19.so 7f3488d1f000-7f3488d20000 rw-p 00023000 00:2e 32 /lib/x86_64-linux-gnu/ld-2.19.so 7f3488d20000-7f3488d21000 rw-p 00000000 00:00 0 7fffd25c4000-7fffd25e5000 rw-p 00000000 00:00 0 [stack] 7fffd25f2000-7fffd25f4000 r--p 00000000 00:00 0 [vvar] 7fffd25f4000-7fffd25f6000 r-xp 00000000 00:00 0 [vdso] ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall]
I was trying switch, but I didn't figure out how to run the program without any arguments.
Variables in static storage (that is, global variables and local variables declared `static`, not counting those also declared `_Thread_local`) are usually implemented as a a region of storage allocated for the variable and then a symbol that points to the beginning of that region. For example, the snippet static int foo; foo = 1; compiles to something like DATA foo DW 0 ... TEXT mov WORD PTR foo, 1 on DOS with the small or tiny memory model where `foo` is a symbol pointing to the beginning of the variable. When you take the address of a static variable, the value of the symbol is used instead of its pointee. Now because variables in static storage are implemented as pointers, they can of course be hear, far, and huge, just like other pointers. Variables in automatic storage (local variables not declared `static` or `_Thread_local` or `extern`) do not work this way. Traditionally, they are created by decrementing the stack pointer by the size of the variable with the compiler remembering this offset so you can use it. If you take the address of a local variable, the base pointer minus an offset is returned. So for example, this useless snippet: int foo() { int y = 0; return (&amp;y); } might compile to TEXT foo: push bp mov bp,sp sub sp,2 ; make space for y mov [bp-2],0 ; store 0 in y lea ax,[bp-2] ; load return value mov sp,bp pop bp ret with a non-optimizing compiler in the *tiny* model. Since automatic variables always occupy storage in the stack segment, they can never be near or huge. They are always far as they aren't located in the data segment.
&gt; C never has been great for application level development, but knock yourself out. That's simply not true.
If the platform supports C++, it's very likely that it also supports C.
oh right, it took me some time, char input[100]; scanf("%s", &amp;input); it should be char input[100]; scanf("%s", input); you are giving the address of a pointer for scanf to write into its forbidden (generaly it wont be error as long as the string is less than 7chars long) and after that tha pointer to char array is pointing to garbage 
A [question like this was posted 14 days ago](https://www.reddit.com/r/C_Programming/comments/577qyl/vi_in_windows/), but deleted. See the [kilo editor](https://github.com/antirez/kilo), and (shameless plug) my [hex editor](https://github.com/krpors/hx), which is based on kilo. Both of these implementations make use of raw ANSI escape sequences to manipulate the characters on the screen. You could use something like libncurses like /u/FUZxxl suggested. That's more compatible with all the termcaps and all that jazz. My editor is somewhat commented to explain why I'm doing things like that. It's my first actual C program, so take the implementation with a ~~grain~~ box of salt.
Thanks a lot for your help !
The standard solution to this task is to compute the Fourier transform of the signals you are interested in, multiply them element-wise and then untransform the result. This computes the [convolution](https://en.wikipedia.org/wiki/Convolution) of the two signals which at each point indicates how similar the two signals are when the first one is shifted to that point. You can use the FFTW library for this task.
Yes, initialising to `""` is correct. Your algorithm as a whole is wrong though, spot fixing crashes isn't going to get you to a solution. `shortestPalindrome` is appending `input` over an over until the answer is a palindrome - which it never will be - without regard to the length of the buffer. The maximum buffer you need is just less than double the length of the input. If the input is `abcdef` then your answer is `fedcbabcdef` And you may need less. If your input is `edbcbabcdef` then you can make it a palindrome by prepending a single `f`. 
Try it int main(void) { char input[100]=""; scanf("%s",input); printf("%p = %s\n",input,input); scanf("%s",&amp;input); printf("%p = %s\n",&amp;input,input); } 
I guess that you are compiling for a 16 bit microcontroller and this may be platform specific. These modifiers are for symbols in data segments (globals or statics) or variables in constant segments (constants). Local variables are placed on the stack, so you can't modify its location.
Not sure if you have to use fd or not, but in any case, from what I read of your requirements... why not just seek if ((off_t f_sz = lseek (fd, 0, SEEK_END) &gt; 0)) { char *buf = malloc (sz+1); // lseek back to beginning // check errno on errors 
`memcpy` takes a length parameter. Make sure that the parameter is filled with the correct value.
I'll give it a shot when I get home, I'm gonna be surprised if it works lol. Maybe I misunderstand something. Edit: I think I understand now, the first one decays to a char *, and the second one is the address of the array, which would be the first element. For some reason I was thinking it would give a pointer to a char*, but I suppose that would only happen if the array at some point already decayed to a char * in a function call or something, which in this example it hasn't.
Ask specific questions, get specific answers. 
Just to clarify: the expressions are not really the same (they have different types), but they point to the same address. See: #include &lt;stdio.h&gt; int main(void) { char str[100]; char *p = str; char (*q)[100] = &amp;str; printf("%p\n%p\n", p, q); return 0; } The two lines printed will be the same. However `p+1` and `q+1` have completely different values: `p+1` points to the second char of `str`, while `q+1` points to an array just past the end of `str`. 
How are you a "great game developer" if you are solving programming problems with such attitude?
* gets() is deprecated and removed from the standard C as of 2011. use fgets() * what is the reason you have a for loop in printResults() that only executes once? * what about scanf wasn't working for regNumber? 
The creator of the algorithm used for the audio search by [Shazam](http://www.shazam.com/) released a [whitepaper](http://www.ee.columbia.edu/~dpwe/papers/Wang03-shazam.pdf) about it. It's heavy on math so to help you digest it better here's a more [layman explanation](https://www.toptal.com/algorithms/shazam-it-music-processing-fingerprinting-and-recognition) of it. 
&gt; I assume beauty in a GUI usually comes at the expense of more memory and/or processing power? That's a REALLY open question, I mean higher res requires more ram for a video buffer, but if you go modern, minimalist it could easily use less ram and processing power than the 2007-era effects and drop shadow galore theme. Really, it depends on many, MANY variables you haven't mentioned. Honestly, you haven't really told us what you're trying to do, is it like Chromecast? that's kinda what it sounds like. But anyway the first thing I'd do if I was you, is I'd look and see if there's an opportunity there, and who your competitors are/who could end up being a competitor. that's by far your biggest hurdle at this stage. &gt; Are these capabilities even realistic with a development budget of maybe low 5 figures? I honestly have no clue about that. &gt; Just finding microcontrollers with hdmi capabilities seem few and far between... Have you looked at the Arduino/Raspberry Pi for development? obviously for a shipping product you'd cut all the stuff you don't need, but that would definitely get you on the right road to where you're trying to go... &gt; Are those goals above realistic for one or two guys to develop? Or is it too big of a bite. That's less of a "is it possible" question and more of a "will there be enough time for 2 dudes to get this done" type question, and that entirely depends on you. You haven't really highlighted how complex this project is, so the answer varies from "it would take a few months" to "it would take 10 years" for a couple people.
Thanks for the thoughtful answer. I'll start at the top. Yes, modern minimalist is definitely what we want to go with. Simplicity is beauty as far as I'm concerned. That goes for the display itself as well as the user experience. And I know, i am sorry I have to be so cryptic. Obviously I don't want to just share the whole premise in detail. My first task was getting a scientific survey developed and sent to those in our target market. The results (so far) look pretty good. Which is why I'm doing my further research! There are other products that serve this purpose, sort of, but they are old, clunky, and don't operate well. They don't operate on an HDMI signal either, so they don't have the advantage of an integrated UI. The one disadvantage here is that this is an accessory product and could potentially be put in the consumer products themselves. But we're thinking these things up as mainly a console accessory, and console life cycles are like 10 years. Chromecast-ish minus the IoT capability. We're trying to keep this thing relatively wireless for now, the exception being a physical remote signal of some kind. Can a raspberry-pi and/or arduino do HDMI stuff..? Basically, i haven't given you enough information to answer wholly. Sorry about that, I don't think I will be able to!
&gt; house an HDMI input and HDMI output so the signal can be passed through, stopped, or altered Get clear of regulatory issues especially DMCA, altering any random HDMI signal may require breaking HDCP. ^(But then how would a TV guide on a set top box work?)
&gt;Are these capabilities even realistic with a development budget of maybe low 5 figures? Just finding microcontrollers with hdmi capabilities seem few and far between... Probably not. The architecture you are probably looking at is a stand-alone HDMI IC controlled by a separate microcontroller. I doubt you can find what you need integrated in a single chip but I am sure there are some off the shelf boards with that capability, no idea what they would cost and if that works for your desired form factor. If you have to build the hardware, I would say you are probably looking best case 100k to get a prototype (mostly depending on how simple and low risk you can make the software/hardware integration effort). If you can find hardware and just do the software in a low risk fashion you can probably get away low-5 figures. &gt;What types of things do I need to look for in someone (or several people) who would take this on? Is previous experience in consumer product embedded systems preferred for example? You really need a board designer and a good software engineer. Both would ideally have experience with HDMI video before. for off the shelf solution you just need software engineer, preferably with video experience. &gt;Are those goals above realistic for one or two guys to develop? Or is it too big of a bite. It is doable with two people, all comes down to time and risk. There are some possible shortcuts, like if you could run a stripped down version of Linux on an simple, off the shelf hardware solution you can make the software a lot easier. Linux would handle most common video and processor combinations for you so then it is a relatively simple software project. But you have to keep in mind if you want to productize it now you are tied to someone else's hardware that may go obsolete and you are paying a premium for that hardware over designing your own card. Probably not a bad proof-of-concept route though. &gt;Lastly, is something like this really not even worth my time if I have to ask you these questions. The scariest part for me would be if you aren't doing some part of the technical work it is difficult for you to gauge if they are really on track, screwing up royally, or blowing smoke. If you got a good idea, I wouldn't discourage you from pursuing it. Couple of key ideas: Get multiple quotes/estimates on everything, hopefully you see some consistency which should give you some confidence. You generally pay for what you get (keep that in mind if someone low-balls). Once you get your quotes and estimates, take those numbers and schedules and double it and that is probably closer to what it will really cost and how long it will take.
HDCP is going to screw you over every chance you get, just to warn you.
 l = strlen( input ); c = 0; strcat( buf, input ); do { if( isPal( buf ) ) { return l + c; } memmove( buf, buf + 1, l + c ); buf[ 0 ] = input[ l - c ]; buf[ l + c ] = '\0'; } while( l &gt; c++ ); return -1; Seems legit.
Well if you are serious about this PM me, I can guide you to my credentials and we can discuss an NDA so you feel more comfortable disclosing a little more. From what you have said so far this sounds similar to how the text is added to screens in a CCTV system or a menu in a TV / VCR and its normally accomplished using a chip through which you route the video. The chip will contain a buffer for your display image/text which you can configure from a micro. (google On screen display). There are lots of options depending on expense, resolution etc but if the application is aerospace (friends employment) there may be other considerations here, rohbustness etc. Basically do not look for a micro that has this capability, buy the chip, interface to it using a half decent micro. From memory conexant had some good stuff but there really are lots of options. In terms of connecting via radio then IoT is opening up all kinds of possibilities with new tech and protocols being bounced around the markets but there are established methods and practices here. how to find people....personal connections + recommendations is always best but linked-in is a good start. If that doesnt work, headhunters/agents work with freelancers and they might be able to find the right specialist for you. Technical difficulty level. If the application is for something like automotive or aerospace then costs are going to rocket, you cannot just code, you have to register your project with the FAA, build a team, devise a process for that team, develop according to 178B/C etc. Same for hardware. these are high cost of entry markets. Dont see that as a barrier, now you need to build a prototype in your garage, get some more NDAs signed and get your foot in the door of some potential investors. write a business plan, get external finance and that is where you need a lot more advice from non-engineer people in nice suites such as yourself. Finally is something like this worth your time.... financially unlikely just from the percentages, lost weekends, holidays, evenings alone never mind the investments. Thats why the advice is to do something you love. Personal/Professional wise, the experience will teach you huge amounts about how things come together whether it succeeds or fails. Worth it or not is up to you. 
~~On POSIX, open it with `x` in the mode string. This causes the file to be opened in exclusive mode, failing if it has been opened already.~~ **Edit** Nevermind, that doesn't do what I thought it would do.
Copy the argument /dir1/dir2/file1.txt to a buffer (which in your example is argv[1]), search for the .txt file extension on that buffer (maybe using strstr) and replace it with .out. Open a new file descriptor with fopen, with the new filename and "w" or "w+" options (or "a" or "a+") so that the file will be created if it doesn't already exist.
I think I get it. Suppose the output filename is out.out. Where do I put these two commands? Should they contain the 2 opening of the input file commands in the middle? E.g. FILE * output = fopen("out.out","a"); FILE * input = fopen("/dir1/dir2/file1.txt","r"); fclose(input); fclose(output);
Thank you very much! 
Thats leaving out implementing TLS, which is pretty much the whole project. HTTPS not HTTP
 (kre^tmp) &amp; 1 Is true if the least significant bits of `kre` and `tmp` are different. kre^tmp == 1 Is true if all the bits of `kre` and `tmp` are the same except the least significant. EDIT: as u/attractivechaos says [here](https://pay.reddit.com/r/C_Programming/comments/59tzlf/what_dose_the_sequence_mean/d9bl6fy/), [order of precedence](http://en.cppreference.com/w/c/language/operator_precedence) makes `kre^tmp == 1` equivalent to `kre^(tmp==1)`and thus, likely not what anyone had in mind.
Show an example of this usage.
Would it be better to declare the pow as a separate variable and then validate it in the if statement
sure, tmp and kre are different variables. Thank you very much! :) 
In addition to the other responses, which I agree with, Visual C++/CLI uses the `^` operator as an operator for a garbage collected smart pointer. I can't imagine this is what a microcontroller professor is referring to though, as AFAIK Visual C++/CLI does not run on any microcontrollers, and is generally a forgotten dialect. It's possible that he meant "outside of functions" as in "outside of code". Like how we colloquially use it to mean exponentiation. In which case, it's not really a C question.
There isn’t much pure-standard-C bounds-checking that can be done without special knowledge about the pointers involved beyond information conveyed by the `memcpy` prototype. The compiler views pointers as referencing abstract “objects” rather than physical bytes in memory, and those objects are ephemeral compiler constructs, so information about them and their bounds might not even be available beyond the compiler’s optimization phases\*. (And the compiler may just be making safe guesses, so even then you may not have fixed bounds.) E.g., an object could be a statically allocated array, an integer on the stack, or a `malloc`ed area, and you have no C-standard way to tell what’s what or how pointers work for each. And walking a pointer inside ↔ outside an object is not safe even if the pointer has a valid representation, so generic bounds-checking isn’t safe/meaningful without flipping into and out of `uintptr_t`-like types. If you have knowledge about how a specific compiler or ABI treats pointers (e.g., the common case where data’s in a single linear space), you can bound the potential pointer values before generating them, but optimization can still ruin that. But another oft-forgotten caveat to `memcpy` is the need to ensure that the two regions don’t overlap, or else `memmove` is more appropriate. That’s one that’ll bite you in the ass if the compiler’s optimizing, and it’s much more easy to miss than bounds. Anyway, because of the weird pointer overflow rules, if you do need to bound things it’s generally best to use pointer subtraction; don’t blithely add the copied-region size to the source/dest pointer unless you’re sure it’ll come out within the pointed-to object. For example, if you know an object runs from `first` to `last` inclusive, then you can bound a `rgn_size` as something like max_size = 1 + (last - first); // not `(1 + last) - first` if(rgn_size &gt; max_size) rgn_size = max_size; // or complain Whereas you shouldn’t do anything like rgn_last = first + (rgn_size - 1); if(rgn_last &gt; last) rgn_size = 1 + (last - first); // or complain because an out-of-bounds `rgn_size` will potentially run `rgn_last` out beyond the end/beginning of `first`’s object and induce undefined behavior. (Omitting the `-1` and `1+` is another way to could get an OOB pointer.) Also be careful to use the appropriate signedness and sizes of types; especially `size_t` and `ptrdiff_t` or `ssize_t` for sizes. \*GCC and maybe Clang? can do `__builtin_object_size`, with a boatload of provisos. See [here](https://gcc.gnu.org/onlinedocs/gcc/Object-Size-Checking.html) for examples, including a bounds-checked `memcpy`.
Actually I might do this several times. Where I would have to go through a file several times modifying it each time and then passing it along but still in the same program. To me, it at least seems I have to close it after I finish printf to it.
Wow, it does work. I do not understand why.
What parts don't you understand, specifically?
Pretty much everything.
=&gt; isn't a valid comparison operator. You should use &gt;=. It sounds like you understand the while loop. Each time it loops it passes `ch` to the `ft_putchar()` function. Your ft_putchar function is using [write()](https://linux.die.net/man/2/write) which is sort of low level for a function to just be writing single characters. More commonly for beginners I would expect the putchar or printf function to be used. write's prototype looks like write(int fd, const void *buf, size_t count); The first argument `fd` is the file descriptor. In your example 1 is being used which is called [stdout](https://linux.die.net/man/3/stdout) (standard output). Then write expects a pointer. In your example &amp;c gets the address of c which is effectively a pointer to the c variable it was passed (pointers are variables that contain memory addresses). The size argument just tells how many bytes `write()` should write. Each character is a single byte so one character is written from that address to standard output.
An argument is said to be passed to a function. You could call it the function's input. If you take for example void ft_print_alphabet(void) Like every C function it has a return type, then the function name, and parentheses that enclose the function arguments. In this case the argument is void (which means nothing). So this function takes no arguments and also returns nothing (return type is also void). A pointer is like I said a variable that contains the address of something. They have a declaration like other variables, but use the * operator to indicate it being a pointer (i.e. `char *buf` `char* buf` `char * buf). Since the variable contains the address of some other thing it is said to point to it. If you're just learning simple things you probably shouldn't concern yourself with pointers much yet. They become more important when dealing with larger structures that are stored on the heap as opposed to regular variables which are stack variables.
Well, see, now I've got to Create a function that takes a pointer to int as a parameter, and sets the value "42" to that int. So obviously, I need to figure out pointers... what do the braces do? Do they contain, like, function commands? Or something? That feeling when you reread what you said and you think "omg i sound stupid."
I guess that I was confused about the order to do the operations in. So for ~, I should just assume that the value given is just a 1's compliment? Also for the third question, how did you get from the first step to the second?
That is the question that was asked, at the end of the problem I just convert the binary number back to decimal.
Also, are you treating 101 in the third question as a binary number?
Yes. Without sounding arrogant, why would you point out a typo? There are probably lots and lots on the internets - sounds like a thankless job. 
Oh, duh. Thanks man. Makes a lot of sense now.
Yup, you're right.
For the last one you could use the identity that `~~X == X`. 
You just have to loop over the original matrix and copy its elements into the appropriate positions in the smaller matrices. There isn't really a "trick" to it.
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; int main() { int file_desc = open("./test.txt", O_EXCL); if(file_desc &lt; 0) { perror("open"); return -1; } printf("test flag.\n"); return 0; } it does not work.
Probably not what you're looking for, but [the blocks language extension](http://clang.llvm.org/docs/BlockLanguageSpec.html) uses unary operator `^` instead of `*` in function-pointer notation: int (^my_block)(int, char);
“It does not work” is not an error description. Always specify what it does that it shouldn't do. That said, read the man page for `open()` where it says that you always need to provide one of the flags `O_RDONLY`, `O_RDWR`, and `O_WRONLY` when opening a file. That said, `O_EXCL` does indeed not do what I expected it to do and my previous explanation to use `fopen` with the `x` flag is indeed wrong. Have you tried using file locking with `lockf`?
It's supposed to print out the alphabet in lowercase using the write function and a "while loop." and putchar... i think...
Oh I always hated that advice.
Passing a struct member to a function directly, like you're doing in your first example, is fine. If your expression gets *really* long—for example, to the point where you can't fit the function call on one line—then it can be helpful to declare a variable to give it a shorter name. When I do this, I usually make the variable `const` (or `*const`) to emphasize that it's just being used as an alias.
I see, thanks for all the help, cleared up a lost of things for me!
Thanks I'll take a look at it. With which architecture could it cause problems?
Please don't post code as pictures. Always post text.
the problem only occurs on the third index :(
Can you paste in the entire source? What is the declaration of persons and its type?
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; typedef struct { char *name; int x; int y; } person; int countLines(FILE * file){ char ch; int lines; while(!feof(file)) { ch = fgetc(file); if(ch == '\n') { lines++; } } return lines; } int main(){ char *name; int x, y; FILE * file; file = fopen("mp1.txt", "r"); char ch; int count = 0; int lines = 0; lines = countLines(file); printf("Number of lines: %d\n", lines); rewind(file); person* persons = malloc(lines * sizeof *persons); while(file){ printf("Count: %d\n", count); fscanf(file, "%s %d %d", name, &amp;x, &amp;y); persons[count].name = strdup(name); persons[count].x = x; persons[count].y = y; printf("name: %s\nx: %d\ny: %d\n\n", persons[count].name, persons[count].x, persons[count].y); count++; if (feof(file)) break; } printf("\n"); for(int i = 0; i &lt;= lines; i++){ printf("%d: %s %d %d\n", i, persons[i].name, persons[i].x, persons[i].y); } fclose(file); return 0; }
You're allocating memory for 5 lines then reading and displaying 6. Reading in the 6th is overwritting memory beyond the end if the `persons` array
I tried `person *persons = malloc(lines+1 * sizeof *persons);` but it made the more names garbage values. I also tried adding another line at the end of the input but then the last value was printed twice :(
 malloc(lines+1 * sizeof *persons); And what is the value of `lines + 1 * sizeof *persons`? Hint : it's *less* than what you had before
Use pastebin next time pl0x
http://www.csee.wvu.edu/~jdm/classes/cs550/notes/tech/mutex/Peterson.html
You're saying that as if you wouldn't understand what this super-simple code does :P
What are you trying to achieve by doing so? Casting a pointer to an integer is almost never the right thing to do.
Perhaps you could show us the errorneous code so we can tell you what went wrong. Automatic variables (i.e those you declare in a function which aren't static) are local to the current function call. Each function call has its own copy of the variable, no spurious overwriting happens.
Oh, it works perfectly now, I think I was just getting confused with all the pointers and the thread argument etc... that's why I was using some nasty workarounds like scoping the malloc. :p
&gt; it is impossible to implement a lock without atomic operations Not really. I've worked with kernels that implement locks/semaphores/etc. by simply turning off interrupts for the critical section. Can't be preempted by another kthread if the scheduler is guaranteed to not be invoked for a little while. This may not be the best solution, but it's certainly possible.
char isn't necessarily a signed type. EOF can't be represented in an unsigned char, or portably in a char. Thus, int as the return type.
so why can't I use a signed char?
If we didn't have c, I guess we'd all be using BCPL, and TRIPOS. . Although I was under the impression that BCPL was portable.
It's an array of pointers, not a pointer to an array. That would be: card_t (*deck)[52];
No, there's no way to enforce that. A user has to know that if they pass an invalid pointer to a function the result will be undefined behavior. That's pretty basic knowledge, as it applies to virtually every function that takes a pointer (e.g. `printf()`, `fopen()`, `free()`, `strcpy()` and so on for about a hundred standard library functions that take a pointer and assume that the user knows what they're doing.) 
A file can easily contain bytes that a signed char can't hold. Utf8, other encodings, binary data, etc.
&gt; Why can't it hold EOF? EOF has to be a value that is different and distinct from every possible char value. `(char)-1` is a valid character value, so it cannot be used as EOF. `(int)-1` is a different value, which no valid char value can be equal to. Those are not the same value, because they have different widths. When the function widenes the char to an int, it treats it as an unsigned value (even if the platform uses signed chars), so if the char in question was `(char)-1` it will return `(int)255` not `(int)-1`. But you don't need to understand anything about sign extension or integer promotion rules to understand why `getchar()` cannot possibly return char. The reasoning follows solely from the observation that there must be a value for EOF that is not equal to any valid char value. Therefore the type returned cannot be char, it must be some type wider than char. 
Whether `char` is signed or unsigned is beside the point. You can't have a type that covers all of `char`, is as small as `char`, and also has things like `EOF` which aren't `char`s. If you want to represent `char` *and other things*, the type has to be larger than `char`, to make room for the other things.
Well, disableing Interrupts, when possible, is always a critical step when you obtain/own a lock. Otherwise the thread might lose it's time slice while holding the lock and potentially freeze the system. It doesn't protect you against concurrent threads however, so locking is still essential.
comparing a large unknown number of elements without using a loop ? if you do not care about precision ( which is lost very fast ), you could convert them to float or double maybe even quad-precision.
All the software ecosystem relies on C... Dennis Ritchie is a god .period. (Steve Jobs isn't... Sorry)
Well, it's ok if the implementation is POSIX only .
You should cross-post this comment to [this thread](https://www.reddit.com/r/C_Programming/comments/59a018/where_can_i_read_code/). *Uns ist in alten mæren wunders vil geseit* *von helden lobebæren, von grôzer arebeit,*
In the same file with the line you are not supposed to understand, there is also a [piece of code](https://github.com/dspinellis/unix-history-repo/blob/Research-V6-Snapshot-Development/usr/sys/ken/slp.c#L32-L33) you can still find more or less unchanged in every modern UNIX: if(issig()) goto psig;
Good thing it's not English.
&gt; while I know that C is more verbose, I can't imagine that there isn't some useful library for something as common as manipulation paths. You're putting a lot of faith in the designers of the standard library. They were Berkeley students, and I like to imagine that they were on all kinds of psychedelic drugs when "designing" C. &gt; Would I need to call getenv() You're trying to determine $HOME? Yes, getenv("HOME") is the right tool for that job. Stick that into snprintf. Note that stdio fopen() accepts forward slashes, even when you're on Windows (where backslash is the OS path separator), but when showing path names to users, it's nicer to use whatever the OS path separator is, which is another thing the standard C library can't tell you. 
What everyone is trying to tell you here is that your code would be better if written like this, without any calls to malloc: void* thread(void* client_ptr) { int c; c = *(int*)client_ptr; ... return NULL; } 
Is this a problem with all breakpoints? It's possible that the line that you've put the breakpoint in never executes. Without seeing the code, we can't really tell, though. Try `break main` and then `run`, which should break in the very first line of your main function. If that doesn't work, something is indeed fishy (but my guess is that it does, in which case you'll need to show us your code).
the gdb that's being used is really specific to the type of system that I am working with. I don't know if providing the transcript from the console will be over any help since the gcc is really stripped down and basic
Fortran and Pascal already existed lest we forget C wasn't that revolutionary
I thought Pascal was later... But os development in Fortran? 
It is going to help as the commands you typed tell us what you did and where the error is.
If I give your (second) program this file as input: 1 2 3 4 5 6 7 I get the output: last number = 7 sum = 35 which seems fine. It also works if I use the input: 1 2 3 4 5 6 7 So, the question is what does your input file look like? You've definitely written a program that can read numbers from a file and sum them.
IBM wrote their operating systems in PL/I as far as I know.
The file I made was: { 2 3 8 10 0 } The last number was correct, but the sum is incorrect. The program should add up all the numbers until it gets to "0". Once it gets to "0", it leaves the loop, closes the file, and prints the sum of all the numbers added BEFORE it got to "0"
I'm just surprised that [PL/M i386](http://www.slac.stanford.edu/grp/cd/soft/rmx/manuals/PLM_386.PDF) was a thing.
Finding the min, max, and mean of a randomly generated array is the same for any array, regardless of whether it's random or not. What you need to do is iterate through the array, probably with a for loop, and do some comparisons as you go. I see you've already defined the variables, so for each iteration through the loop compare the current value to the values stores in min and max, and add the current value to count. 
IMO you should get a linux VM (or similar unix-like OS) and learn to program through that. You'll learn a lot more about how everything works through using the command line than simply clicking 'compile and run' on an IDE. Plus , Windows is generally an annoying place to learn to program, from my experience. For actually learning the language there are some good links in the sidebar, so I would start with one of those (my personal recommendation being K&amp;R).
Post code by indenting four spaces. At the bottom right of every text entry box is a link "formatting help". 
Visual Studio generally supports the original ANSI specification C, called C89. It's OK to learn, but probably not the best for the inexperienced because you won't realize which problems are little compatibility things and which are actual code problems. MSVC 2015 apparently supports parts of C99, but I'm not sure how much. The most common code you'll find today is generally written in C99 dialect , which is C89 with a couple of features added. I'm sure some others will suggest using Linux or installing mingw-w64/MSYS2 compiler suite, but I don't have the experience to know which is the best path for learners on Windows. I'd prefer you to learn how to program on Linux/POSIX and not to only be comfortable with Microsoft-isms, but I suppose you won't run into those for a while. Except for lack of Makefiles. My local bookstore has several books on C. It's not the single most popular language, in fact by count of books it was 10th. But it's a big bookstore, so there were still 12 books about C (and not C++) on the shelves. 
Yes, and be sure to unlock if the `!queue-&gt;head` condition is met (e.g. unlock before `return NULL`). FWIW I noticed others recommending using atomic instructions, note that its *much* easier to have subtle bugs in lockfree code than with code using locks (and a lockfree MPMC queue is especially subtle, and a fully general one isn't possible on common hardware IIRC).
With -O0 it *probably* won't do anything like that. At that optimization level it does very little analysis, which also means you get fewer warnings than you would see at a higher optimization. The [relevant Linux kernel bug](https://isc.sans.edu/diary/A+new+fascinating+Linux+kernel+vulnerability/6820) would have been compiled under optimization. But you're not going to get any guarantees about it, nor should you rely on it. And I've tried. For example, I once disabled specific optimizations on specific functions to [work around a GCC bug](https://gcc.gnu.org/ml/gcc-bugs/2015-05/msg02025.html). It helped, but was never reliable.
When the user enters a blank line, `fgets` will give you a string consisting of the single character `'\n'` (newline) followed by a zero terminator (`'\0'`). You can check for this string, and then exit the loop with `break` if you find it.
The single quote is a special character for printf function. I think you should add the backslash character for scape then. printf("%s\'s stats are:\n", Target.name); 
Hmm, that's true but somehow it still doesn't print anything. I even got rid of it completely.
Unless you've mis-pasted your code, you may want to re-check those open/close brackets! The compiler should have given you an error, not sure how it even compiled...tried it on my machine with the fix and it works fine.
I edited my post now, hopefully it should be enough.
 void enterName(character Target); character hero; int main(void){ printf("Please enter name for main character\n(Up to 15 characters):\n"); enterName(hero); When you call `enterName`, it is getting and modifying a copy of the structure. The `hero` structure isn't getting the entered name. Pass a pointer to `hero` instead.
You don't need to escape a ' inside a string. And a ' has no special meaning to printf
Even better is just using two tildes ``, but i don't think they're multi-line.
You're misusing the struct member operator, if Target is a struct, did you declare it as the following? typedef struct Target { blah; } Target; If so, you can just write Target *Name in the function definition. Then you access it with `Hero-&gt;Name` syntax. define the function as: void displayStats(Target *Hero) { printf("%s's stats are:\n", Hero-&gt;name); }
That's an apostrophe lmao.
Divide and conquer. For that I'd just treat it like any other string.
Because ints are automatically allocated for you by the runtime. You don't need to free them. The runtime will automatically clean up after you.
You have a number of things wrong with your code. I'd suggest you start by fixing all the errors and warnings that ideone is giving at the bottom of that link. Secondly, you've obviously missed part of the program because that link doesn't show the end of your `main()` function. Aside from any other errors, you're not allocating enough memory for your `gradebook`. The initial allocation ends up being (probably) 16 bytes, but your struct is at least 66 bytes. How did you come up with the line below? gradebook = safeCalloc(baseGradebookSize, sizeof(int));
The most important thing when learning C is to be able to search for information on your own. Not everything will be readily presented to you. That said, look through the archives and use the search function. This question has been asked multiple times in the past and many good answers have been posted. Sort by “top” to see some of these posts.
&gt; are pretty cool tricks They used to be pretty common. There was a time where you would naturally do (x&lt;&lt;3)+x to multiply by 9. If you like bit fiddling, there are amazing ones in the [Bit Twiddling Hacks page](https://graphics.stanford.edu/~seander/bithacks.html). I actually used the parallel bit counting in production. 
I don't mean to hate on C, I love it. All I'm saying is there could have been a bit more consistency in the standard library.
rand() % ((hlim - llim + 1) + llim) should this be llim + (rand() % (hlim -llim +1)) so you are adding llim to the random number between 0 and (hlim-llim+1) inclusive? 
https://www.tutorialspoint.com/data_structures_algorithms/linked_list_program_in_c.htm I think this is what you need
Thanks for your reply. I am learning merge sort and I do want to use array and linked list. But in the case I want to go with array(not really array, but dynamically allocated memory). I want to know what is wrong with `malloc()` and `free()`. Do you have any ideas?
The issue is with the Python generated text file. That's all I'll say for now, since this is homework, I'll explain more later if needed.
Thanks, that's an interesting talk. I added the video link to the article.
I've only looked at the first example, but here's an explanation. For help in the future, I suggest you try things like putting more print statements in, between the calls to changeMeOne and changeMeTwo. The problem is that you've declared a again, inside of changeMeOne. This a is a different a to the one in global scope, and is probably the cause of the confusion. The local a will be the one that is used. In future, I would suggest that you never, ever declare two variables with the same name in global and local scope. What happens is that, after the call to changeMeOne, the global a (not the local one you defined) has the value 1. The global b has the value 12, and the global c has the value 3. You then call changeMeTwo. This function sets the global c to 2, the global b to c (which is now 2), and returns two which will again assign the global c to 2. I hope that makes sense, fell free to ask if it doesn't.
Okay, I really don't understand what you are telling me... sorry. I am a total noob and I don't understand what I am doing please try to explain again but in really beginner terms. Thank you
(I am slighly bored, so let me spam you a bit :-) ) Debugging is a skill that you can acquire. When creating complex algorithms, you have to use assertions all over the place. You can ask the compiler to generate them for you as there are options to force bound checking, for instance, but a) it is rarely portable between compilers, and b) with assertions, you can check for things *you* understand. Bounds checking is usefull, though. You can enclose code in #ifdef. Like #ifdef CHECK, add a -DCHECK to the compile line, or a #define CHECK in you code. If you code is "light", enclose it in #ifndef NDEBUG, and it will be removed from release build.(This is the standard way to do this. Note that last time I looked on OSX, it seemed to me that some moron at Apple changed the default way this worked for 20 years, so you may have to refer to the doc to actually specifiy NDEBUG in release builds) There are a few key type of assertions. * What I would call normal assertions. They are things like, "at this point, this value should be bigger than this one", that kind of things. Manual bounds checking would go into this group. * Pre-conditions. They are the things you check at the beginning of your functions. Stuff like "pointer is not NULL". In you case, the comment "p first element, q mid element, r last element" would be better written as an assertion in the code. * Post-conditions. They are the things that you check at the end of the function. For instance, I suspect that after merge_combine, all elements of 'a' between p and r as ordered. Why don't you check that with some code at the end ? (more on that later) * Invariants. Those are the things that are supposed to always be true. It is often use in object-oriented programming (which in C would transalte to checking that a structure have not been logically corrupted, for instance). You generally wrap those in small functions that you call to check at key parts of the code. [Some languages let you explicitly state them](https://en.wikipedia.org/wiki/Eiffel_(programming_language%29 ). Lastly, there is an extremely powerful way of debugging, that you should probably use in your case: the qsort function already exist, so you can easily check all you code against the reference implementation (ie: at the beginning of merge, make a copy of the input ans qsort it. At the end, check that your result is identical. You may think that it is a waste of time, but I promise you not). Also, beeing testable/debuggable is an important quality of the code. At some point, you'll look at your design and, between roughly equivalent design, will choose the one that is testable. Your quality of life will be much higer then. Have fun. Edit: congrats for having updated the post with the right answer so others can learn. Good netiquette here :-)
Nope the issue is not in the python code. The issue is in the fact that the "b" malloc'ed array does start at zero, while in the original code that used static arrays, it had the size of the full "a" array, hence the b[k++] was going out of bounds. Poter have corrected the code that now looks correct.
No, and I don't know him, but he did report that bug about a month before I discovered it independently. I'm the author of the small-size optimization article.
Roughly the same thing is going on: The variables declared in the function that have the same name as the global ones are in fact separate. As I alluded to previously, you could rename the variables in the functions to anything else (for example "int bb") and it may help your understanding in differentiating the global and local ones. Here's a step by step of it: * Start: a=1, b=2, c=3 * In changeOne: Local variable a is set to 4 (global variable a is still 1). Global variable b is set to 5. Function returns value of global c (3). * When changeOne returns, this sets the global b value to 3. So a=1, b=3, c=3 at this point. * In changeTwo, the global b variable is set to 6, the local c is set to 7, and then 7 is returned * When changeTwo returns, it sets the global a value to 7. * Observe that the global values at this point are now 7, 6, 3, as printed. Also, this code is not C. It's odd I didn't note it earlier. Is it Arduino code? That's what Google seems to suggest.
I kinda do understand that tho? It's pretty obviously talking about time sharing processes being swapped out of memory and back in...
At least OS X and iOS use Unix (FreeBSD to be more specific) unlike windows or linux.
I see. Juging from his Stack Overflow answers, Peter Cordes seems to be a very competent programmer.
See https://www.bell-labs.com/usr/dmr/www/odd.html for dmr's explanation. The problem was that the code relied on functions being able to use the stack of another function, which apparently didn't really work on the interdata. This was refactored in v7 so only two or three functions would have the stack switched out under them. I do wonder why the comment appears at that place though...the thing explained in the comment above seems to be unrelated. Maybe it's because they noticed the problem when the swap function saved its stack frame in u.u_ssav?
Using the open/read/write/close system calls are unbuffered (or raw) I/O. However the write() may write to the disk long after the call to write() returns. This is for efficiency reasons [discussed here](http://unix.stackexchange.com/questions/224415/whats-the-philosophy-behind-delaying-writing-data-to-disk). The stdlib cousins: fopen/fread/fwrite/fflush/fclose are buffered so the underlying write() may not be called until there is enough data to flush, which of course can be preempted by fflush(). &gt; Since the file is mapped into memory with mmap in foo() and isn't allowed to be empty, I thought the difference might be because I/O is somehow buffered? So if I read a file from command line which actually exists, there is content on the disk, if I create it with open() and write something into the file it might not actually be written, right? So if I go on and assume another function which refers to that file by a path finds certain content, that's not a safe assumption? If write() returns without error then you can assume you have written the data.
Note that this subreddit is about C only. If you want to program in C++, please ask in /r/cpp_questions. If you want to program in C, please ask here. Please choose a programming language before asking a question.
Thanks a lot dude, I fully understand it now! And yes, it is Arduino code and I just found out that Arduino code is C++ and not C, so I actually placed it in the wrong sub. Anyways, I'm happy that I put it here cause you helped me out a lot, thanks again!
This is not true. You cannot use `int` and `int *` interchangeably. Scanning to an `int` requires a pass by reference. Otherwise, how could `fscanf` know the address to store the new `int` at if only the existing `array[i]` *value* is being passed? The `&amp;` is required. If you don't supply it (I just confirmed this), you'll receive this warning: format specifies type 'int *' but the argument has type 'int' 
I not an expert on c and maybe not have as much experience as the average c user on this sub but that is some of the nicest looking c code I have seen
I'm pretty sure OS/360 was written in Assembly. At least, initially. Later, parts were added in BSL (based on PL/I).
One piece of advise: To not suffix your own type names with `_t`. That suffix is reserved by POSIX for system types.
Why reinvent the wheel? Your distro will already have a way to do all this. e.g. `service blah status` or `systemctl status blah`.
have an another option for dynamic pointers management https://github.com/kojiba/RayLanguage/blob/master/Classes/RayFoundation/RMemoryOperations/RAutoPool.h lib: https://github.com/kojiba/RayLanguage 
Thanks, I'm relatively new to C so apologies for coming across as a noob. 
libcurl is a great library for accessing web services inside of C. https://curl.haxx.se/libcurl/ This will help you get the raw data. The next task, as pointed out by baudvine, will be parsing the data. 
I was looking at libcurl earlier, it looks fairly promising, just need to get my head around it. cJSON looks like it will work great as well. Thanks for the for the help!
To illustrate the "do one thing well" idea, here is how on a Linux system (with jq and curl installed), you would get the weather data (if you figure out how to authenticate to the API, which I didn't bother to do), filter out the temperature, and pipe it into your program, which can read it from stdin: curl -s 'http://api.openweathermap.org/data/2.5/weather?q=London,uk' | jq .main.temp | yourprogram 
Again, I would advise you to focus on what value your program is supposed to provide, and use existing tools to solve the annoying bits like HTTP and JSON parsing, if you can modularize your problem that way. Edit: Obviously, that only applies if you're writing a short command-line tool. If your program is long-running, maybe a desktop application that shows the weather outside at all times, then it will need to handle HTTP requests and JSON parsing itself, in which case those two libraries are fine solutions.
The best way to examine the stack before and after a function call is probably to use a debugger. If your program itself needs to introspect the stack, it would be best to look in your libc implementation to see if it provides a way to do so. This is highly non-portable stuff and the C language itself doesn't guarantee any stack-level behavior; the specification doesn't talk about stacks at all, and various optimizations can change the kind of behavior you're talking about. Many C compilers recognize and understand what calls to 'memcpy' and 'printf' are doing at high levels of optimization and emit code to directly do those things instead of actually calling the libraries. So, if you want to do something outside the realm of standard C, don't assume you know what the compiler is going to do based on your understanding of basic compilation techniques or one-off experiments; look up pre-written libraries or compiler intrinsics *for your platform* that implement the non-portable stuff, because they're designed to work together with your compiler to do the non-portable things correctly even if you change your code or optimization levels.
Depending on the optimization options and the context, memcpy isn't necessary touching the stack; The procedure is usually inlined, and thus setting a breakpoint on the memcpy symbol with a debugger would have no effect. eg: https://godbolt.org/g/9QVGnO
Also, big note here, we work only with basic operations such as for, while loop if statement booles algebra (&amp;&amp;, ||, shzz) so yeah :D 
Changed the question. I need a C program
What do you want to test?
Well, compile it and run it. Where is the problem? The best way to test your code is to compile and run it. There are many so called debuggers, that will help you find mistakes in your code.
You can't run a program before you've compiled it. That's like trying to eat a pizza before you've made it. Java still needs to be compiled, just when you click the green button on eclipse it compiles and runs it in one go, which I believe is what you are confused about.
So have you tried writing the program? Are you stuck on anything in particular? 
probably why I am getting confused. 
We could start a compiled vs interpreted language discussion here :P There are C interpreters as far as I know.
&gt; I would like to run it before I compile it o_O
link, splint, cppcheck, and other static analysis tools can check your code before compilation. gcc and clang/llvm can check it during compilation. valgrind and asan (and the other sanitizers in the clang/llvm family) can check it after compilation, at runtime. 
It is just passing a function a reference to a type, and the function sets the value. int some_fun (int *a, int *b) { *a = 2; *b = 3; } main... int a, b; some_fun (&amp;a, &amp;b); printf ("%d, %d\n", a, b); // prints 2, 3
Note the numbers in the error messages, for example 44:13, refer to line and column numbers, i.e. line 44, 13th character in this case.
The code in the assert statement will not be executed it NDEBUG is defined (usually outside of a Debug build). Assertions should never have side effects like that.
Also, your `length_check()` return values are mixed up.
libcurl is a good option but another option that even include a json library could be: https://github.com/cesanta/mongoose
You are passing pointers to a type, not references. If this is C++, references would be better to use as output parameters. For more information, read this article: http://www.cplusplus.com/articles/ENywvCM9/
Recursion is really not the right way to solve your problem. You'll end up making an absurd amount of function calls and get a stack overflow in no time. This is much better suited for iteration. It's there a particular reason for solving it with recursion?
I don't see the point in using recursion, but then again I rarely do. The problem as I understand it is that you want to have a sequence incrementing by one letter each call. After it reaches 'z' it should wrap back around to 'a', but now be preceded by an 'a' as well. If you think about it, this looks a lot like the way we count in the decimal system 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 . . . decimal is a base 10 system, so you're just trying to create a base 26 system. Look into doing that, modulo will help. Also it'd probably be easier to ditch the idea of 'letters' and just let 'a' = 0 and 'z' = 25. You can add the correct ASCII offset to them before using them.
If you want to use it for brute-forcing a password, why go through the trouble of doing it recursively, in C?
I should also mention that modulo 26 arithmetic is really popular in older crypto stuff for the exact reason you're wanting to use it. I'll bet that you can find something similar to what you're wanting to do if you don't want to write it yourself.
The function I'm using right now to create my alphabet is "for (char c = 'a'; c &lt;= 'z'; c++)". In that sense it works well because it returns an array of char with my alphabet. My alphabet size is 65 chars. So when I'm testing the password I have 8 for loops that test each index with every conbination possible. The problem; its slow as hell, AND the array is initialised at "aaaaaaa" which means I do not have a way of testing 1 char, then 2 and incrementing that way. I hope you see my problem here.
It's going to be slower with recursion, not faster. Brute forcing is always going to be slow, no way around that.
Thank you, this makes sense after talking with my prof. I made the mistake of assuming that the structs were allocated in memory when I declared the static array of structs.
You should consider using threads for brute forcing, this way you can use all those sweet cores concurrently to crack the password, maybe even opencl, or use hashcat if the goal is just cracking the password, not actually programming the cracker. 
I was sure the strftime call was inside the assert, has his reply been edited since my comment?
I am actually using pthreads. At the start of my program I input how many threads I want to start by and I chop up the alphabet and feed a certain range for every thread to work on. It just that my loop logic was a bit slow. but I think im getting the hang of it. Edit: Would you happen to know how to kill all the threads if one thread happens to find the password? Currently once its found, the others continue to loop.
i think what popRiotSemi was hinting at was that you wouldn't need 8 for loops to print the following would you?: 0 1 2 ... 8 9 10 11 12 ... etc You would just have 1 for loop that increments the number. So you essentially want to implement your own way of keeping track of base 26 numbers... here's my attempt at that (note: i haven't tested with this but I think it should be correct): #include &lt;stdio.h&gt; #define NUM_DIGITS 8 // lets assume we want to go up to 8 digits (ie. a to zzzzzzzz) // the following code assumes that digits[7] is the right most digit and digits[0] is the left most digit char digits[NUM_DIGITS] = {0}; // function to increment our base 26 number void increment() { // increment the first digit digits[NUM_DIGITS - 1] += 1; // loop through and see if we need to update the next digit // since we are in base 26, anything over 26 should be carried over to the next // digit place int curr = NUM_DIGITS - 1; while(curr &gt; 0 &amp;&amp; digits[curr] &gt; 26) { digits[curr] = 1; digits[curr - 1] += 1; curr -= 1; } } // function to convert our base 26 number into alphabet void print() { int i; // skip leading 0s for(i = 0;i &lt; NUM_DIGITS;i++) { if(digits[i] != 0) { break; } } // note the -1 when converting to ['a', 'z'] // our digits array holds values between [1, 26], so in order to map 1 =&gt; a // we need to subtract 1 to make it 0, and then add a for(;i &lt; NUM_DIGITS;i++) { printf("%c", digits[i] - 1 + 'a'); } printf("\n"); } int main(int argc, char *argv[]) { while (digits[0] &lt; 26) { increment(); print(); } return 0; } 
 int16_t max = 0; for(i = 0; i &lt; size; i++) { if(max &lt; buff[i]) { max = buff[i]; } } There's a mistake right off the bat (which is a little embarrassing since the preamble to the question is talking about how simple it is). This finds the correct value only if at least one value is non-negative. `max` should be initialized to `buff[0]` (if the array is non-empty) or `INT16_MIN`, not to 0. The same error is in the intrinsics code, where `_mm_setzero_si128` is used incorrectly. I'm not sure if there's an MMX intrinsic that will initialize the values correctly to all-ones, though. You might have setzero and then negate it :(
I don't think this was the point of the article. Not really embarrassing imo. It's a dumb function in order to talk about something else. (Really feeling the need to try and shame someone over something so stupid, should be embarrassing for you)
Noted and fixed it. Thanks for the feedback! Will look for a way to correct the example for the intrinsics one. 
&gt; when the password length is around 8 chars long, 8 for loops one after the other takes a hell of a long time to crack Well, yeah... that's a lot of possible passwords! *That's* why it takes so long. If you were testing only passwords that are exactly 8 characters long, and you assume that all 96 printable ASCII characters are allowed, that means you have to test 96^8 = 7.21 x 10^15 passwords. That's 7 *quadrillion* passwords. If your CPU is running at 3 GHz, and it could test one password every cycle, it would take more than 27 days to test all of those passwords. And the CPU can't process them nearly that fast. Even just doing simple string comparison against an 8 character string, it would take a few dozen cycles to test each password, and every few passwords there would be a cache miss as it loads the next several passwords from cache or RAM, which takes anywhere from a few dozen cycles (L2 cache) to a few *hundred* or even a thousand cycles (RAM). There's a reason that all serious password cracking uses GPGPU to compute dozens or hundreds of passwords simultaneously using the graphics card.
Compiled without a single error. I'll try to implement this with multithreading and see if its faster than what I have right now. Thanks for the input :-)
i actually just tried it and there was a small bug in the main loop. editted the code above. :)
Why didn't you enable -O3? 
Since a few people pointed out that recursion is not a good idea within threads, here's another code that was shared with me. This one uses pointers, so I imagine its faster in the sense that we do not need to make function calls inside a thread? I thought you might enjoy it. My only issue with this one is that I don't know where I can get the code to begin printing from the letter I want and stop printing until another letter that I want. Check it out: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #define SIZE 5 int main( void) { char pw[SIZE + 1] = ""; char *ppw = NULL; char *pch = NULL; char characters[] = "abcdefghijklmnopqrstuvwxyz"; int used = 0; int out = 1; int last = strlen ( characters) - 1; //set pw pw[used] = characters[0]; pw[used + 1] = '\0'; while ( used &lt; SIZE) {//loop until all elements of pw have been used ppw = &amp;pw[used];//set ppw to point to last used element of pw while ( ppw &gt;= pw) {//so ppw always points to an element of pw if ( ( pch = strchr ( characters, *ppw)) != NULL) {//get pointer into characters for current value that ppw point to if ( out) {//print when appropriate printf ( "%s\n", pw); } if ( pch &lt; &amp;characters[last]) {//pch does not point to last element of characters ++pch;//pch points to next element of characters *ppw = *pch;//set what ppw points to to be the same as what pch points to if ( ppw != &amp;pw[used]) {//ppw is not pointing to last element of pw ppw = &amp;pw[used]; } out = 1;//allow printing } else {//pch is pointing to last element of characters *ppw = characters[0];//set what ppw points to to be the first element of characters ppw--;//ppw points to next lower element of pw. ex from pw[n] to pw[n-1] out = 0;//disable printing } } }//exit loop when ppw points to address less than pw used++;//increase elements in use memset ( pw, characters[0], used);//reset all elements to first element of characters pw[used + 1] = '\0';//just in case, terminate }//exit loop when all elements have been used exit ( 0); } 
i think what people were saying not that function calls in threads are bad, but to be careful with recursive function calls in threads, because the stack size for threads is smaller. When you call a function it increases the amount of data you have on the stack, and then when you return from the function, it decreases the data on the stack. So if you have a recursive function that keeps on calling things but takes a while to actually start returning from all the functions, the stack will get full.
How errors are handled really depend upon the context of the situation. For instance, you could have a program that opens a file that contains previous calculated information. If that file doesn't exist (open() returns -1 and the variable errno==ENOENT) then that might be okay---there is no previously calculated information (perhaps this is the first time the program is run) and all it means is the program recalculates stuff. But the same call, returning EACCESS (in errno) means the file is there, the program just can't access it. Context matters. On the difference between exit() and abort()---this time, it comes down to *how* the program termination will be reported to the parent program (usually the shell or command line). abort() will raise SIGABRT (a signal) on the program and this may be checked by the parent process (it can under Unix---I'm not sure about other systems). exit() will simply exit the program and return the value given to the exit() call (EXIT_SUCCESS and EXIT_FAILURE are the "portable" values, which are almost always 0 and 1 respectively; there may be some oddball system where EXIT_SUCCESS and EXIT_FAILURE are something else). So the parent process can, when a child program ends, determine if it called abort() (which should be used for critical errors where it's dangerous to continue, like out of memory or some other catastrophic error that should never happen) or just exit() (you can still exit on errors, even catastrophic ones if you want---again, it depends upon context). There just isn't one correct answer, and in this case, it probably takes a bit of experience to know how to handle errors. About the only rule-of-thumb that exists is that library code should never call exit() but just return an error to the caller since the application knows better how to handle the situation (I suppose a library routine *could* call abort() in a "this-should-never-happen" type situation, but I don't know any library in production use that actually does that). I know this doesn't really answer your question, but there are no real answers for this.
That's awesome of you, taking time and explaining everything. Thanks a lot dude. You definitely helped me out. :)
No sweat. In "real life" you might choose an equally simple iterative solution (i.e. "for" or "while" loop). But that's so obvious. ;-) And unless you're counting bytes of stack space or microseconds, it won't matter for this problem. Plus, IMO, developing an ability to recognize problems as recursive or with self-referential definitions is good even if you don't code them that way. It may help you understand why 1) functional programming (and programming languages) are valuable, and 2) how one can code without ever changing a variable's value (i.e. "immutability"). Good luck!
some things you can also play with: Boost::SIMD can reduce some of the pain of by abstracting away the intrinsics and making it easier to compile to different SIMD instruction sets Or you can do a lightweight approach with macros. Just dump something like the following into a header file that you can reuse: #ifdef AVX2 //process 8 at t time #define VECTOR_SIZE 8 //intrinsic functions #define Store(x,y) _mm256_store_ps(x,y) #define Load(x) _mm256_load_ps(x) #define Set(x,y,z,w,a,b,c,d) _mm256_set_ps(x,y,z,w,a,b,c,d); #define SetOne(x) _mm256_set1_ps(x) #define SetZero() _mm256_setzero_ps() #define SetOnei(x) _mm256_set1_epi32(x) #define SetZeroi() _mm256_setzero_epi32() #define Add(x,y) _mm256_add_ps(x,y) /// ... etc ... #ifndef AVX2 //we process 4 at a time #define VECTOR_SIZE 4 //intrinsic functions #define Store(x,y) _mm_store_ps(x,y) #define Load(x) _mm_load_ps(x) #define SetOne(x) _mm_set1_ps(x) #define SetZero() _mm_setzero_ps() #define SetOnei(x) _mm_set1_epi32(x) #define SetZeroi() _mm_setzero_epi32() #define Add(x,y) _mm_add_ps(x,y) #define Sub(x,y) _mm_sub_ps(x,y) // ... etc ...
Indeed. You helped me understand that you don't always jump to code something, you sort it out first and try to see what your problem is, and what possible solutions you can give to this problem. Thank you, sir!
I've been brushing up on C lately and I'm having similar issues. I've read a number of books on C (Learn C The Hard Way, 21st Century C, C Programming: A Modern Approach) and I'm still uncertain how I should be doing a lot of things because of how fractured the C community is. Everybody has their own style. I've been taking a lot of ideas from suckless.org and Go since it seems better to err towards simplicity until it's obvious a more complicated approach is needed. Learning C is painful compared to languages with a strong community like Python or Go where there's a dominant style and many idioms and cultural norms are explicit in the introductory learning materials on the official website.
Hope to get hold of one of those to test the AVX-512 performance
 void all_comb_(char *prefix,size_t len,size_t i){ if(i&gt;=len){ prefix[i]='\0'; puts(prefix); return; } for(char c='a';c&lt;='z';c++){ prefix[i]=c; all_comb_(prefix,len,i+1); } } void all_comb(unsigned len){ char str[len+1]; all_comb_(str,len,0); } void print_all(unsigned n){ for(int i=1;i&lt;=n;i++) all_comb(i); } It's impossible to do it without using a buffer to store the prefix we have so far. A lot of people complain about this blowing the stack: the number of recursion levels is proportional to the length of the string you want. This makes the number of recursions logarithmic to the total number of strings generated. In other words you generate 26^len strings for which the function calls itself len times. To be able to even get close to producing a stack overflow it'd have to call itself thousand of times therefore len&gt;1000 and 26^len &gt; 26^1000. That number is incredibly huge, you'll most likely die before having seen all of those 26^1000 strings produced. 
About the UNIX programming interface: First, read the [POSIX pages](http://pubs.opengroup.org/onlinepubs/9699919799/). When in doubt, read and compare the man pages for multiple systems and see where they differ. Vague wording in POSIX often comes from existing differences. You can do that e.g. [here](https://www.freebsd.org/cgi/man.cgi?). That said, some general advice: * Do not assume anything more than what the manpage says. If the manpage says “on error, -1 is returned,” then check for -1, not for a negative value. There might be an exotic system where a negative value can be returned. * If you don't understand what a flag or function does, do not use it. The defaults are usually fine and a flag you don't understand is usually for an obscure feature you don't need anyway. * Very often, the functionality of a thing becomes very clear when you read man pages for old UNIX systems. There you can see what that thing originally did and it shouldn't be difficult to then extrapolate what it does today. For example, `SIGHUP` used to be sent to all processes running on your tty when you hung up your modem connection to the UNIX box. Similarly, `abort()` is intended as a debugging function as it is meant to write a core dump. Many Linux systems have disabled coredumps (sadly), causing the functionality of `abort()` to be somewhat hard to understand.
Do not use MD5 for cryptographic purposes. It's outdated and insecure. Instead use SHA-2.
You have nothing to be ***embarrassed*** about. You pointed out a valid oversight in the sample code which I didn't even notice when first reading the article.
`gdb` is the GNU debugger; if you’re developing in C on Linux that’s what you use to poke through a program’s entrails. A core dump is basically a program-corpse, its memory image frozen at time of death + register state in an OS-/ABI-dependent format. `gdb` can load this, temporarily resurrecting the program. You could manually adjust memory contents and resume execution, but bugs rarely stay neatly confined—you can walk the dead Alzheimer’s patient around, but he’s not going to answer questions correctly on his own. Anyway, if necromancy isn’t your bag, or if you want to fiddle with/look at things as they run, you could also load the program in `gdb` and `run` it until it dies naturally, but sometimes the use of `gdb` can affect when the program dies if there’re compiler optimizations or race conditions involved. (It takes a fair amount of complicated, non-portable OS magic to debug one process from within another, and that comes with overhead; plus `gdb` is generally ill-suited to deal with multithreading or distribution. —Not that there aren’t good reasons for that, or that there’s much better out there.) While the program is running normally, `gdb` stays out of the way. When something breaks or exits, it suspends the program and gives you a command prompt. `where` is the command that tells you where in the program its register state declares it to be (based on [R/E]IP or PC register, mostly). Assuming you compiled with `-g`/equivalent and no optimization, it can pinpoint the exact line of source code for you. It also gives you a backtrace, which tells you about each caller, the caller’s caller, etc. up until `main` or `__init` or whatever. Initially, your/`gdb`’s point of view (a.k.a. frame) is at the deepest point in the call stack, and things like `list` will act relative to that; `up`/`down` will move the point of view up/down through the backtrace for convenience. You can do things like `print` arbitrary C expressions as if from within the source code (macros and preprocessor goodies notwithstanding) once you’ve picked the right stack frame. `bt` is a synonym for `where`; stands for BackTrace. `gdb` has all sorts of synonyms and abbreviations. Some are even documented. If you’re doing much C programming, a little skill and familiarity with the debugger goes a long way. `gdb` has “extensive” help (via aptly-named command `help`), as long as you don’t concern yourself with frivolity like command syntax.
&gt; I first tried to use this code, but failed. :P Can you elaborate more on which parts "failed" ? What steps have you taken to tr making it not "fail" ? How exactly are the other components connected to the ports on the board? Is your number display a simple 7-seg LED matrix or a complex lcd panel that needs additional steps to initialise it? Double check your data directions (DDR) setup and ports. What exactly is the for loop inside the while loop used for? Why are you looping over the same instructions 50 times? Is the number you are assigning into PORTB supposed to be in binary? (use leading 0b instead of 0x)
Please put four blanks in front of every line of code so the code appears readable.
Assigning a memory pointer beyond allocated memory is fine, as long as you don't dereference it. The pros and cons of C. :-) (And your first assignment `i = arr;` is unnecessary since your `for` loop initializer does that.)
I vouch for the modern approach book. Also I'd suggest /r/dailyprogrammer for ideas about mini projects if you don't have a specific goal. Even the easy challenges could be a learning experience if you decide to add some extra features. Also learn C the hard way is not a bad book IMO, but not as an introduction to the language.
All files are sequences of bytes that can hold arbitrary values. A subset of all possible files includes those files whose bytes represent text encoded with some character encoding. Those are referred to as text files. Anything else is generally called a binary file. But they are not materially different in any way, i.e. they are still just a series of sequences of bytes; the only difference is that the values of the bytes in a text file are intended to be interpreted under some character encoding (which needs to be known before the file can be meaningfully read.) And it's important to realize that this term "binary" means different things in different contexts and this is one of the more confusing uses, because it implies that the file stores binary values (it does not — it stores bytes, i.e. integers, which do not have a base), or that it's somehow different in some fundamental way from a text file (it is not.) In C, the difference between opening a file in text mode and binary mode comes down to the translation of newlines. In text mode, the C runtime performs translation from the platform's preferred line ending. When reading a file, the native line ending sequence (which can be a single character or multiple characters) is translated to the character `'\n'`, and the inverse when writing. Since this can affect the length, it also has ramifications for seeking. But that's the only difference. On platforms where the native line ending is the character `'\n'` (usually Unix-like systems), there is absolutely no difference between text mode and binary mode. &gt; why is initializing a array with a text file different than initializing an array with a binary file? That's far too vague. It depends on the contents of the file. It may not be different at all. Give a complete testcase, or at least an example. 
Your comment describes C on UNIX. On other platforms, what you say may not be true.
&gt;Assigning a memory pointer beyond allocated memory is fine, as long as you don't dereference it. Only one-past-the-end. Any further is undefined behaviour. 
All of it. For example, there are systems where text files are stored in lines and the C runtime translates fixed-length lines to \n separated linrs.
But *please* don't call a pointer variable *i*. *i* (and *j*, *k*) is for integer indices.
Sorry for the late reply but thank you for the suggestion, much appreciated.
Thank you for the suggestion, much appreciated.
Really helpful! Thanks
Yeah, as a start I'm trying to use libsndfile but I can't seem to get Visual Studio 2013 to recognise when I #include &lt;sndfile.h&gt;
I've looked at papers about this. Thank you.
It's a pleasure to me.
Alright, so, I managed to finish the program and get it to work. http://imgur.com/a/fMgTO But I have one slight issue (which I'm not sure if it's not correct). So, we've been told to make the program, and the loop should include +-- and +|. I've only included +-- and |, since I don't know if it's possible to use both combinations. Am I correct or kinda correct? :P
Huh? Could you provide a link to such a system? It sounds interesting.
I think VMS had record based files as an option. Edit: https://en.wikipedia.org/wiki/Record-oriented_filesystem
This is off topic, but I *really* don't like `int arr_size = 6;`. There's no reason to make a variable for something that should be a constant. Try something like: `#define ARRAY_SIZE 6`. Don't be afraid to type a little more. One letter variable names are hugely overrated.
When you say "portable", how portable are we talking here? Different PCs yes, but what about Linux? Different versions of Windows? The answer to that question may affect the overall answer. Broadly speaking, I don't think there's a good solution to what you want to do. You have to pass some information from program 1 into program 2; even if you assume some folder exists (for example, %temp% on Windows) you'd still have to have a hardcoded file name in both programs. Unless you have a specific requirement not to, I'd say your best bet would be to pass a command line argument into both programs, so you could run, e.g. "createfile /path/to/file.txt" and then "readfile /path/to/file".
http://c-faq.com/aryptr/non0based.html
Portable as in a different PC. Currently i have just given the second program a direct path on my PC since i know what directory the first program wrote it in. fPointerIn = fopen("C:/Users/John/Documents/codeblocks/HW5v2-Smith John/Sequence of Events Recording 10hz.txt", "r"); is there any way to, for example, have to first program write it to the desktop or a folder which is visible to all users of that PC not just "John". 
And if you just need a temporary file for the program's own use, you can use tmpfile() and leave it to the OS to make you a unique file in an appropriate location.
#include &lt;file&gt; //how you include libraries. I.e. #include &lt;studio.h&gt; to use the scanf function #include 'file' //how you include user made libraries, or other files/functions, from the same directory So, if you have file Example.c, and it's saved in C/Desktop/PracticeCoding/ and the other program, OtherProgram.c is saved in the same directory I.e. C/Desktop/PracticeCoding/ then you can use whatever code you have in Example.c by using #include 'file' in the header of your OtherProgram.c code and then calling whatever function or whatever else you need from that file. 
Since this is a homework problem, let's forget the esoteric solutions and focus on the simple ones. I'll call your programs Writer and Reader. Option 1: Writer and Reader agree at compile-time to use the same filename and location. This means in your C code, you put a string containing the filename, and possibly path, of the file to write/read. We can break that down a little bit more... Option 1a: Writer and Reader use absolute paths (something that starts with `C:\`). You can put `writer.exe` and `reader.exe` anywhere on your computer, even in separate directories or separate drives, and they'll always use the exact location you specified. Option 1b: Writer and Reader use relative paths (something that doesn't start with `C:\`, but might contain directory names or use `..\` to go upwards a directory at a time). This means that the location of the file depends on the [current working directory](https://en.wikipedia.org/wiki/Working_directory) when you run the program. Think of running it from a command prompt. The directory you're in at the command prompt when you run the program, that's the current working directory (CWD). Relative paths are relative to the CWD. So if you do * `"filename.txt"` — it creates `filename.txt` in the current working directory * `"foo\bar\filename.txt"` — starting from the current working directory, goes into `foo`, then goes into `bar`, then creates `filename.txt` * `"..\filename.txt"` — starting from the CWD, it goes *up* one directory, then creates `filename.txt` * `"..\..\foo\filename.txt"` — starting from the CWD, it goes *up* *two* directories, then goes into `foo`, then creates `filename.txt` Depending on what path you put in Writer and Reader, it's possible to be in different working directories but still get the same result. If the filepath was `"..\filename.txt"`, then you could run Writer from `C:\Users\canislupus20\` and run Reader from `C:\Users\bigpeteb\`, and they'd both use the same file, because they'd both put it in `C:\Users\`. Keep in mind, it doesn't matter where the `*.exe` file is. It just matters what the CWD is. If you're using Visual Studio or some other IDE, you should be able to set that in the project properties or run/debugging settings. Option 2: Writer and Reader use an argument from the command line (which you'll get from the `argc` and `argv` parameters to `main()`) to specify the filename and path. It's up to the user to point them both at the same file. The user can make their own choice whether to use an absolute path or a relative path.
&gt; If you’re doing real-world stuff, you should generally stick to binary mode and handle your own newlines—accept `\r` (MacOS), `\r\n` (DOS/Win), `\n` (UNIX), or `\n\r` (oops) and produce platform-appropriate ones—unless you’re sure nobody’s going to copy your input or output between platforms ever. The text-mode/binary-mode stuff is a shortcut, but real-world data comes in all kinds of formats and encodings that the `b`/`t` mode flags don’t address at all. If you get UTF-16 data, for example, that’s text but flag `t` could be catastrophic. I was all ready to disagree with you until you made the point about UTF-16. Yeah, that could suck in a variety of ways: seeing a 0x10 or 0x13 in the high byte where it *doesn't* represent a newline, reading a file that uses DOS line endings (where they'd be encoded as 0x00 0x13 0x00 0x10, so the 0x10 isn't 1 byte after the 0x13), etc. That's a bit beyond the scope of this question, though. And I don't have much experience with it; I know the i18n and Unicode concepts, but I mostly do network protocols so I just need plain ASCII and opaque blobs. :-) That said, I still think text mode may be the better choice. If you're on Windows, it looks like [fopen()](https://msdn.microsoft.com/en-us/library/yeby3zcb.aspx) can happily open a UTF-16 file in text mode and correctly translate line endings for you. (I assume you'd have to read/write using the wide-char functions.) A brief search shows that Linux probably has similar capabilities. If you're expecting UTF-16 or UTF-8 or some other format that the system can translate for you, why wouldn't you use text mode? And if you don't know what format you're expecting, then for all intents and purposes *your file is binary anyway*, and you shouldn't be touching line endings because you don't even know what they look like in this unknown encoding.
Wanted to edit the title but couldn`t. Can you please give me link to c download ? ty. 
Surely there's an easier way than dragging in OpenSSL as a dependency just to open a semaphore or shared memory segment.
You can't “download C.” You need a C compiler and standard library suitable for your system. What operating system are you working on?
I agree with http://stackoverflow.com/a/4176414. The SysV IPC APIs are bad, and should be avoided. If you're already using Pthreads or some other better API, stick with that. POSIX provides `sem_open` and `sem_init`, and if you only need them within your process, you can use unnamed semaphores and avoid the whole rigamarole of avoiding name conflicts. `shm_open` does shared memory, but just as with named semaphores, you'll still have to solve the problem of name uniqueness. If you are stuck or insistent on using SysV IPC and `ftok`... I don't think you need to put in a hash. The point of `ftok` is to *be* the hash, since what it gives you is an unpredictable token that's statistically likely to be unique. But, as the man page says, "Of course, no guarantee can be given that the resulting `key_t` is unique. Typically, a best-effort attempt combines the given `proj_id` byte, the lower 16 bits of the inode number, and the lower 8 bits of the device number into a 32-bit result. Collisions may easily happen, for example between files on `/dev/hda1` and files on `/dev/sda1`." The good news is that not that many programs use SysV these days anyway. Collisions are pretty damn unlikely. If it does happen, just change your `proj_id` (or the `pathname`). If you can, specify `IPC_EXCL` to check that the semaphore doesn't already exist (although that assumes that your program always exits cleanly and removes its semaphores).
Fair point, but it depends on how you define easy. I think as far as writing goes, a single include is pretty easy. You're right that it's not the most elegant way, and maybe not the easiest to distribute. 
Alternatively, you can manually initialize it to zero: int matrix[y][x] = {};
Ah yes the whole loop is an error I realised id made but hadn't corrected! How would I initialise the array to zeros? Im coming from MATLAB where they default to zero. Only way I can think is to us a for loop to loop around all the entries and set to zero but thats a lot of lines of code for something simple! Edit: managed to initialise it to zeros. Still having issues with the stack overflowing.
Yes `str + 256` causes undefined behaviour. One of the possible manifestations of undefined behaviour is appearing to do what you expect. You might have got a different result on a system where loading a value into an address register does a hardware check against address ranges or segments the MMU has assigned to the process, and `str` was near the end of such a range. See section 6.5.6/8 of the current C standard (past standards had similar text): &gt; When an expression that has integer type is added to or subtracted from a pointer, the result has the type of the pointer operand. If the pointer operand points to an element of an array object, and the array is large enough, the result points to an element offset from the original element such that the difference of the subscripts of the resulting and original array elements equals the integer expression. In other words, if the expression `P` points to the `i`-th element of an array object, the expressions `(P)+N` (equivalently, `N+(P)`) and `(P)-N` (where `N` has the value `n`) point to, respectively, the `i+n`-th and `i−n`-th elements of the array object, provided they exist. Moreover, if the expression `P` points to the last element of an array object, the expression `(P)+1` points one past the last element of the array object, and if the expression `Q` points one past the last element of an array object, the expression `(Q)-1` points to the last element of the array object. **If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined.** If the result points one past the last element of the array object, it shall not be used as the operand of a unary `*` operator that is evaluated. 
In the future, you can avoid some programming errors by compiling your program like this: gcc -Wall pgm.c -o pgm This enables all compiler warning messages. 
&gt; I just end up googling a lot and often I find some answers on stackoverflow. For any programming language, or library, or whatever, there is (or should be) documentation about it. * If you were doing Java, it would be the [Javadocs](http://docs.oracle.com/javase/8/docs/api/) and the [programmer guides](http://docs.oracle.com/javase/8/docs/) * If you were doing Python, it would be the [Python documentation](https://docs.python.org/3/) * etc. Since you're doing C, the things you need are: **The C language standard** An official copy costs about $60, but you only need that if you're implementing a compiler. Most people use draft copies of the standards, which you can find online for free: http://stackoverflow.com/a/17015061 (Actually, the C language standard is dry, dense, and technical. And the C language is generally pretty simple, so you really just need to learn the syntax and grammar once. (Surely once you learn how to write an `if` statement, you'll just remember it forever.) For that, you can use any of a variety of **books**; several are linked in this subreddit's sidebar.) **The documentation for the C standard library you're using** If you're on Linux, the easiest one to get at are the **[man pages](https://en.wikipedia.org/wiki/Man_page)**. Just drop to a command line and run `man &lt;function&gt;`. You can (and should) read the man page about the `man` command: `man man`. Man pages are divided into numbered sections. The C standard library is all going to be section 3. Section 2 is for Linux system calls, and section 1 is for regular executable commands. * If you just do `man printf`, you'll get the man page from section 1 about the command line executable `printf`, which isn't what you want; in that case, you need to specify the section you want: `man 3 printf`. * Some functions, like `exit`, have man pages in multiple sections. In that case, `man 3 exit` will tell you about the POSIX-compliant `exit`, and `man 2 exit` will tell you about options and behaviors that are specific to Linux and Glibc. (I swear there's some pair of pages for a commonly-used function that have tripped me up this way repeatedly in the past, leaving me wondering why all the details I wanted were missing until I remembered to check section 2, but I can't remember what function it was.) Also on Linux, you can also just read the prose documentation for the standard library you're using. This is usually the GNU C Library (aka "GNU Libc", aka "Glibc"). **[Glibc's documentation](https://www.gnu.org/software/libc/manual/)** is easy to find online; it might also be accessible on your system with the `info` command. On Windows, you would use the *fantastic* **MSDN (Microsoft Developer Network) documentation**. It's very comprehensive, thorough, and easy to read, although it is also of course *huge*, and other than following links it's hard to navigate. Fortunately, you can just Google "msdn &lt;function&gt;" or something like that. Just make sure when you get there that the breadcrumbs show that you're looking at a C/C++ page, and not a C# page (or any other crazy language). It should also say "Visual Studio 20xx" at the top with some modern year. If you're a little more concerned with cross-platform compatibility (which you're probably not yet, as a student), you probably want to stick with only what POSIX allows as much as possible. Fortunately, man pages in section 3 are usually similar or identical to the POSIX wording, but if you want to be safe, you can Google "posix &lt;function&gt;" and find a result from The Open Group or someone similar. Those will tell you pretty much everything you need to know. As a programmer, your job will entail knowing how to use those resources (or the equivalent ones for whatever language and libraries you're using) to find the information you're looking for and use the language/library correctly. As a student, you have to learn how to do this by, well, doing it. We can explain what a typical man page looks like and what kind of details it might have, but you have to get your hands dirty reading a bunch of them to really see how they work and figure out how you'd use that information to decide what code to write as a result. &gt; I learn about abort() and exit() after error checking to end a program. ... Well, which one should I use now? &gt; I learn that the open() system call returns -1 on error and that I should check system calls for errors. Should I now do &gt; if(open() == -1) &gt; or &gt; if(open() &lt; 0) To some degree, those are style questions. In a job (or any other large software project), you may have to write code in a certain **style**. That may include superficial things like how to indent code, format comments and documentation, etc., but it may also include rules about which functions to use or avoid, what code idioms to use or avoid (e.g., do you test for falsehood with `if (!thing)` or `if (thing == 0)` or `if (thing == FALSE)`?), etc. Questions like the ones you just asked might be addressed by such style rules. Or you may just have a mentor who will tell you "do it *this* way because it's the most correct way (which goes beyond just style and into correctness)", or "it doesn't matter, do it *this* way just because that's how we've always done it". But, if you'd like some specific advice, I can make some up for you: &gt; `if(open() == -1)` or `if(open() &lt; 0)` All of the various documentation for `open()` — man pages, POSIX, MSDN — say it returns `-1` on failure, so personally I'd test for `-1` just because it told me to. But it does also say, albeit indirectly, that the only way you'll get a negative return value is if there's an error, and since on pretty much all processors testing for negativity takes a few less bytes of assembly and one fewer register than testing for equality to `-1`, doing `if(open() &lt; 0)` is not a bad microoptimization. I certainly wouldn't waste my breath and hasten the heat death of the universe by arguing with someone who had a strong opinion about using one or the other. &gt; I learn about abort() and exit() after error checking to end a program. ... Well, which one should I use now? `abort()` is pretty drastic; you should probably use `exit()` in most cases. Actually, `abort()` just sends the `SIGABRT` signal, and the default handler for `SIGABRT` terminates the process. However, you or some library could install a different handler that would take a different action; it might doing some extra work, or it might even not terminate the process! So if you want the process to exit, it sounds like you should use `exit()`. But there are bigger design issues here. I don't want your program to exit in the middle of everything without any output. At a minimum, you ought to print a log message to tell me what went wrong and why the program is exiting. Maybe I just fat-fingered a filename, but if you don't tell me "file not found" I'll never know. (If your program normally generates no output anyway, I might even think it had succeeded when it actually failed! I'm certainly not going to manually check the return value of every command I run on the command line.) Even better, I don't want your function to think that calling `exit()` is an appropriate response to `open()` failing. Imagine your function is getting reused in some much larger application like a web browser. If you `exit()`, the *whole browser will close*. Every single window. No one wants that! A much better design would be to simply return an error code from your function (like the error code that `open()` put in the `errno` variable), and let whoever called your function decide what to do. If your function was called from `main()`, and `main()` decides that doing `exit(EXIT_FAILURE)` makes sense, that's fine. But if it was called from somewhere else where they might want the program to keep running, now they have that option available. edit: formatting
wall shows warnings and errors
A simpler technique is having your writer write to standard output. Then use your shell redirect the output to a file, or to another program (pipe). Your reader can then do the same. So: writer &gt; c:\temp\f.txt reader &lt; c:\temp\f.txt Or: writer | reader 
Do compilers allow this? I'd expect a `variable-sized object may not be initialized`
Depends. I think gcc allows it. I didn't even notice that it's a variable length array.
Thanks, I'm now getting a Segmentation fault when I increase the array size from 10 * 10 to 300 * 200. Whats causing this? 
According to http://en.cppreference.com/w/c/io/fprintf DevC++ is wrong. &gt; The exponent contains at least two digits, more digits are used only if necessary. Not really sure that's much help for you though.
The stack size. You need to use dynamic memory, see malloc
replacing my array declaration from: int matrix[x][y]; with: int * matrix = malloc(x * y * sizeof(int)); gives compile error: matrixCreate.c:10:17: warning: incompatible implicit declaration of built-in function ‘malloc’ Whats causing this? Is my implementation of malloc correct?
The "Segmentation fault" is to avoid the stack overflow, compilers add struff to prevent this error. On Linux, gdb and valgrind are your friends to debug this kind of error :) This work whit any size two dimensional array http://pastebin.com/ftQbKFrM, the only limit is your memory. 
Im not able to compile that code, I get a long list of errors so I believe you're using something slightly different to me. (I'm using the prepackaged gcc in raspbarian and as you can probably guess am running on a raspberry pi) But essentially I had a fiddle and managed to get it to compile with malloc in there but still get the error. Perhaps my implementation is still wrong, I will do some further reading. If I understand the code you have put on paste bin when you init the array by allocating the memory for the first dimensions then using a for loop allocate memory for the second dimension? As an aside, I've only ever programmed Arduino boards and MCUs before and I've never found it this difficult! Have I jumped in the deep end or is it simply more complex programming on linux? 
You have your indices backwards. Your array is dimensioned as `matrix[y][x]` (note y is the first dimension and x is the second dimension). Your variable `n` counts up to `y`, so it *should* be the first index, but in `matrix[i][n]`, you have it as the second index.
Yes, in the terminal. Yes, the memory will be released after your program terminates, but it's not a good practice. You can free the memory adding this line to your code: free(matrix); And the last problem... well, according to stackoverflow you can solve it by changing the matrix definition to int (*matrix)[x] = malloc(.... However I've never used this in real code, usually when you can't use matrix[i][j], you have to use matrix[i+j\*y], because... C. You will need a basic understanding about arrays, pointers and memory to understand it. *This may be a good time to give up and learn a programming language from this century.*
Thank you. Really appreciate the detail. I'm a long-time C programmer I admit to being surprised that "my" language is this "protective". I understand the system or hardware rationale. As you say, we may "get away" with a technically invalid pointer unless there is a system or hardware reason. (If we do not dereference!) Now I'm wondering ... if I have an `int *` into an array of `int`and I cast it to a `char *`, may I increment the `char *` by 1 `sizeof char` past the end or by 1 `sizeof int` past the last element? Example: int ia[] = {314, 159, 265}; int *ip0 = ia + 2; // &lt;- valid. (last element) int *ip1 = ip0 + 1; // &lt;- valid. char *cp0 = (char *)ip0; // &lt;- valid. (last element) char *cp1 = (char *)ip1; // &lt;- valid? (4 or 8 chars past last int of ia) char *cp2 = cp0 + (sizeof int); // &lt;- valid? (same (?) as cp1) Common sense (and the allocated memory bounds) suggests both `cp1` and `cp2` are valid, despite it being a superficial "`+4`" or "`+8`" increment "past" the last element. (The units of increment got smaller.) It's within the `int` array allocation. I think I've reasoned through and answered my own question. Thoughts?
Is C++ compiled by gcc ?? Ive used C++ for arduino and MCU programming, its all a bit different on a PC though. 
You didn't! Posting this question might have been what gave you the key insight. That's very common and a good thing.
&gt; Stupid question but where do I run man malloc? in the terminal or as part of a compiled C program? In the terminal. `man` is the command to look up a page in the system manual. Every standard library function has a page. It's extremely useful! &gt; after including the library you suggest I'm getting an error on the next line of code: Now that `matrix` is no longer a two-dimensional array (but rather a pointer), you should do memset(matrix, 0, sizeof (*matrix) * x * y); instead. Why you need to do this will be clear to you later on.
You can compile it using g++, it's like gcc but for c++. I would expect C to be used with microcontrollers, so you probably haven't used many of the basic C++ features (iostreams, vectors, classes). I would focus on modern c++ (look for the auto keyword) but obviously first you have to learn the basics.
It was a fairly long list of errors that were to do with simple things such as not declaring variables inside a for (something to do with different versions) and using his code as a sort of pseudo code I was able to infer what needed doing. The code is now working fine (turned out that all along I had my x and y mixed up so couldn't create non-square arrays. Is there a way to mark this question as resolved? 
Yeah, that really sucks. It's so frustrating to write a good answer just for OP to delete their thread.
I'm happy that you like it in here.
"one past the end" is the address you get from incrementing a pointer (of the element's type) to the last element. In other words, the address the new last element would have if we somehow could add one more element to the array. `cp1 == cp2` and both are fine and indicate this address. You probably "get away with it" until you don't! One side-effect even on common systems is that the optimizer, knowing this rule, could optimize `ia + 4 == &amp;b` to `0` , even if `int b;` does happen to be at the memory location you might expect `ia + 4` to indicate. 
Sticking with binary is more so you can take more than one type of file as input and write more than one type as output, without having to rejigger all your I/O routines from the prototype version when you were just lazily accepting ASCII. There are still quite a few UNIX utilities (even some programming languages) that choke on `\r\n` newlines, which IMO is silly at this point in time given that we’ve had this platform difference for what, 30? 40 years now? and we’ve been copying things freely between platforms since 1995. Windows Notepad *still* can’t deal with anything other than `\r\n` because it’s just a text box into which the file contents are shat unceremoniously—basically the same deal as the `t` flag but it’s fupping annoying given the fact that many of us have to work on two platforms and really shouldn’t have to install an extra text editor to deal with something so basic and common. In `t` mode, if you get a file left over from MacOS and open it as text on Windows or UNIX, you’re not going to see any newlines. If you get a UNIX file on Windows, you’re not going to see any newlines. If you get a Windows file on UNIX, you’re going to see C0 garbage at the end of your lines. I think that’s an exceedingly stupid state of affairs in terms of default behavior—if you know you’re going to accept ASCII text, you may as well be mindful of that and actually accept ASCII text (including the common newline variants); i.e., open in binary mode and handle the newlines yourself. That allows you to extend as needed; maybe you want to treat FF or CR FF as newlines so the file’s author can paginate (common in assembly and elder C). Maybe you want to treat VT or CR VT as newlines so the author can indicate section breaks. Maybe you want to accept the C1 NEL, which has been a slightly-more-standard-but-not-terribly-common newline for quite a while. Or hey, once you add in UTF-8 support maybe you’ll want to handle LSEP/PSEP. The only real reason not to use `b` is the convenience of things like `fgets`… but those really aren’t all that convenient when it comes down to it, beyond toy programming. `fgets` is easy for reading at a fixed maximum length, but at some point you’re going to get more than your statically allocated buffer will hold, and then you’re going to have to write your own buffer-extending input routine anyway. (Let’s not speak of `gets`, may its name be forever accursèd, may it live forever in infamy. \^_\^) And of course output is fine one way or another, barring more specific requirements; just generate whatever newline is natural for the platform, or just generate `\n` because it’s just as valid as `\r\n`, doesn’t really matter unless you’re specifically trying to appease the programs that can only handle their particular breed of ASCII. The only place it might matter is terminal I/O, and rarely do we have to open our own stderr or other TTY. On the Windows `fopen` note: I see no real benefit to the MS extensions except in toy code, and I have a few reasons for this. First off, given my experience with MS software/APIs (and their continuing at-best-approximation of C89–99) I would not, even if aiming at Windows as my primary target platform, rely on any Windows extensions to stdc. Relying on Win32/64 or their fragments of POSIX veneer is fine, but getting into stdc extensions will just make it harder to read or standards-validate, esp. given the `wchar_t` dealing the streams will end up doing in Unicode modes. Second, while you do generally know that you want text specifically as input, oftentimes you don’t know/care what *kind* of text you’re going to get until you open the file. If you can handle ASCII/UTF-8 or UTF-16 or UTF-32, then you’d have to open in binary, peek at the contents, close the file, and reopen in the proper encoding in the hopes nobody has exploited the brief window in between close and open to swap the file contents out and bork your pogram. (And I tend to do auto-switching between the Unicode formats because somebody’s gonna `cat` text files together at some point and expect the result to work, and there’s not really any reason it shouldn’t provided there’s BOM glue.) W.r.t. UTF-16 support specifically, &gt; Allowed values of encoding are UNICODE, UTF-8, and UTF-16LE. which means that UTF-32LE/BE, UTF-16BE, and the automatic order-picking/-switching versions of UTF-16/UTF-32 aren’t made available (even with BOM, which … feels rather lazy). IIRC their `wchar_t` is 16-bit too, which means they can’t even handle surrogation or longer UTF-8 sequences… so it’s kind of useful in a toy, MS-specific sense but not in a want-to-handle-Unicode-properly sense. And most UTF-16 I’ve encountered was LE only if generated by Windows, and BE otherwise—I think BE was the Unicode recommendation for default ordering for a while.
NP, I wanted to scan interface info a while back and found `ifconfig`/`ip` rather wanting, but a dearth of good documentation otherwise. Glad I could help.
Start with simple things. Take a look to this blog post https://balau82.wordpress.com/2011/03/29/programming-arduino-uno-in-pure-c/ There are lot of examples in Make AVR book
Yup, an optimizer is allowed to do devilish things as long as it's within the literal rules. Thanks for shedding some light on a rule!
Keep dividing by 10 until it is less than 1000
Yes, I use a special math library for numbers that long.
 n / pow(10, ceil(log10(n+1) - 3))
&gt; it becomes a lot of calculations Integer divs. On machine-sized ints. (uint64_t) Native. Computers are good at this. ;-) (I predict it will be much better than the string conversion/manipulation alternative you mention.) Why don't you start with this approach (the one /u/jedwardsol suggests) and benchmark it. If you find a more optimal way later, you don't have to break an interface.
I like it. This is a nice, tight expression. I would be curious to see how it fares with various sized numbers versus the iterative "`/10`" suggestion of /u/jedwardsol. OP has two good candidates to start with, here.
https://nickdesaulniers.github.io/blog/2016/05/30/data-models-and-word-size/
The master has failed more times than the beginner has even tried. I would also recommend reading: * Head First C * Deep C Programming
I thought you'd need: int matrix[y][x] = { 0 };
&gt; However, unless given a specific path the program doesn't know where the file is. So how do i make a general path to write the file to, so that my second program can find and open it regardless of what computer its running on. How is the filename communicated between writer and reader programs? Is it hard coded in the source or ...?
Why not do: uint16_t type; uint64_t counter; uint8_t block[BLK_SIZE - 8]; ?
Any particular reason for not recommending just using `sizeof(matrix)` instead of `sizeof(matrix[0][0]) * y * x`? It's a variable sized array yes, but the size is still known to the compiler and `sizeof` still just returns the number of bytes it takes up. Internally, the compiler generates code to do the math to calculate the actual size (So `sizeof` isn't a constant in this case), but it still works like expected.
Yeah. That works. I totally thought I did that before, but apparently it was something different. Thanks!
`char * strv[]` is an array (of unknown length) that contains char * pointers ("strings", if you'd like). What the function does is to break up str at each space (strtok(str, " ") searches for a space in str) into words (tokens), and assign each one to an entry in the strv array. Which means that the strv array needs to be big enough to hold as many words as there are in the string, or you're going to have a bad time. Example: void main(void) { char input[32]; char *words[4]; int i, n; fgets(input, sizeof(input), stdin); n = splitString(input, words); for (i=0;i!=n;++i) { puts(words[i]); } printf("%d words.\n", n); } This will read a string from stdin, and break it into words: Hello World Hello World 2 words Notice that the words array can contain up to 4 values, which is more than big enough for this "Hello World" example, but if the input had been "some men just want to see the world burn", then splitString would have smashed the stack and probably crashed when trying to write the 5th entry into strv. Edit: reading the string from stdin, to drive the point home that sometimes, you cannot know how many words there are.
Studied that in my first year at uni... Done already, sorry ahah
Can you post your code? It's much easier to tell you what the problem is when we can see what you did.
It is possible to loop trough an array with a while loop. My suggestion is that you read your code and find what you have done wrong.
The main problem for me is that i don't know how to go through my array till the end. I think i could find the numbers if i will manage the problem 
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int S[100]; S[100] = 0; int i = 0; for(int i = 0;i&lt;100;i++) S[i] = i + 1; while( S[i] != 0 ) { printf("S: %d\n", S[i]); i++; } return 0; } I believe that your intention with that scanf was to put numbers into the array. The way you did it does not do that. I removed the scanf from your code and used a for loop to put numbers in every position in the array except for the last position, which holds a zero.
A remake of the classic game Sentinel that runs on modern operating systems. 
So my scanf will be in a for loop, right? I don't get where shold i place my scanf
A lottery number picker?
OP never said they needed a *cryptographic* hash function.
What kind of key? The keys in a hash table are also keys.
Yes the idea is for the alphabet to be able to be changed easily. Also I run the code inside a pthread. At the start of the program I ask how many threads we want to execute and then chop up the alphabet accordingly and give each thread a certain range to work on. In my tests I found this code to be the fast as with recursive functions not only do you do a lot of function calls but also I couldnt find a good way to get the recursive function to generate within the starting and ending point in the alphabet. I consider this one to be complicated but also the fastest. What makes you think its slow (compared to another implementation)?
When in doubt, write a Lisp interpreter. It will work in an hour and be done in 30 years.
OP stated the purpose. Don't play dumb.
I'm not playing dumb. OP never stated that they wanted to generate cryptographic keys.
 int main() { int n = 0; printf("Enter the size of array .\n"); scanf("%d\n", n); int S[100]; S[100] = 0; int i = 0; printf("Enter you array .\n"); for(i = 0; i&lt;n; i++) { scanf("%d\n", &amp;S[i]); S[i] = i + 1; } while( S[i] != 0 ) { printf("S: %d\n", S[i]); i++; } return 0; } But it still doesn't work :/
Can you recommend a good graphics library for a program like this?
To be honest, I don't even see how the bottleneck isn't the other side. If it's a hashing comparison, you could write this in the most ridiculous way and it'd still be fast enough. Eh, I can't give you any one reason that this would be slower, but it just seems like your bottleneck is going to more be in systems calls than this loop. It's really quite simple and the loop section should be tiny, all in all. Context switching from the pipe to the other program is going to take hundreds of instructions. If you're on a Unixy system, I'd watch and see how many context switches you're getting per second when you run this and your cracker. It's probably quite high.
SDL? Or you could write directly to the VGA framebuffer under DOSBox :') 
windows 7 
So how should i solve this problem?
Make me an effortless VNC client with encryption! Except I got no money to fund you 😅
The previous function was made by my professor, but I'm open to anything that could improve it. As far as my understanding of C goes, I would not be able to do what I'm trying to accomplish with your code. With it, I would have no array to get the command from. I think that the point of your code is to use a function as a parameter, but this function is independent of each of the words. The point of the splitString function is to get an array from a command line that the user inputs through stdin. For example, if the user inputs: ls -li ~/nsfw Internally, I should get an array like this: array = [ "ls", "-li", "~/nsfw" ] So, in this way, I can first identify the command with array[0] and use the other positions of the array depending on the first one, which holds the name of the command.
What doesn't `doesn't work` mean? Does it not compile? Return the wrong value? Crash? sscanf(string_buf, "%d/%d/%d", &amp;v1, &amp;v2, &amp;v3); is correct
If you print a string with `printf` without a `\n` somewhere, `printf` has no obligation to actually print the string. That is, `\n` forces the string up to the `\n` to be printed (you can also call `fflush` on `stdout`, if you want to print to the console but not to start a new line). Without `\n`, `printf` usually stores the string into a buffer, which it dumps into the console when it wants (usually when the buffer fills up). Change this and then check at what point the program actually breaks.
Yes, that's where context is important. You could theoretically also do that with the function pointer version I posted, but it's hairy. How about adding another argument to your splitString function that tells it the maximum size of the array, and let it fail when there are more words in the string than that? The caller could then resize the array, and try again. This is getting a bit complex. Also, because strtok destroys the input string that it tokenizes (it inserts null-terminators where it find a space), we have to take a copy of it that we operate on. A possible solution looks like this: #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; int splitString( char *str, char *strv[], int size) { int i = 0; char * tok; tok = strtok(str, " " ); while(tok) { strv[i++] = tok; if (i==size) return -1; tok = strtok(NULL," "); } return i; } void doStuff(char *strv[], int n) { int i; for (i=0;i!=n;++i) { printf("%i: %s\n", i, strv[i]); } } void main(void) { char input[64]; char dupe[64]; char *words[4]; int n, s = 4; char **arr = NULL; fgets(input, sizeof(input), stdin); putc('\n', stdout); n = splitString(strcpy(dupe, input), words, 4); while (n&lt;0) { s *= 2; arr = realloc(arr, sizeof(char *) * s); n = splitString(strcpy(dupe, input), arr, s); } if (arr!=NULL) { doStuff(arr, n); free(arr); } else { doStuff(words, n); } printf("'%s' has %d words.\n", input, n); } Testing this with a longer input string: $ echo -n "life is but a dream" | ./a.out 0: life 1: is 2: but 3: a 4: dream 'life is but a dream' has 5 words. 
What is `S[100] = 0;` supposed to do?
“It doesn't work” is not an error description. Please tell us what you expect to happen and what happens instead.
My work is already working on some cooperation with Intel so we can get at these bad boys right away! I can't wait..
Write a NES emulator. Write your own language/compiler that compiles down to NES CPU instructions. Write a program to extract graphics/music from NES Roms. Write a client/server system to play NES on another machine (I.e. you don't write an emulator, just code that lets you play it from another machine.) Just spitballing, but emu stuff always seems fun to me.
[removed]
Indeed. What part is difficult for you?
Indeed. Maybe that's why I just pretend to be a programmer nowadays.
 Can confirm all these ideas are really fun. 
Why are there no comments?
Where specifically would you like comments? I prefer writing self-documenting code, but tell me if there's some piece of code you don't understand and I will rewrite it or add more comments.
You have the two `printf` statements indented like they belong under that second `for`, but there aren't any braces; so, only the first one is part of that second `for` loop. 
If there are no comments, I can only see what the code does, not what it is supposed to do. This makes it nearly impossible to find logic errors. This also greatly hinders the ability to reimplement functions differently because you never specified what you expect from the function; so either you need to look through all uses of the function to understand what callers expect from it or you need to replicate the behaviour exactly. Both options are time consuming and hinder improvements. Also, don't assume your code is self-documenting. Just because you believe it is obvious now doesn't mean it is obvious when you re-read it in half a year. Write comments so you understand what your thought process was when you wrote the program. I also expect a high-level overview over the program so I can easily understand how the data and control flows through it without having to dig through a dozen source files. That's really useful to understand how the program is designed.
If you indent your post with four spaces on the lines of code they will be highlighted properly. You can also use backticks (\`) to achieve a similar effect.
P.S Their are new lines after each printf's, it just didnt show up like that.
Pretty cool, what about three dimensional plots? :D Shading through some kind of ASCII dithering maybe.
the problem seems to be in your scanf, the format that scanf takes specifies the input you are going to give. you are not supposed to print any thing in scanf as what you seem to be doing with "lines?"
`scanf("liens?%d"` means the person must type out `liens?` and then their number, otherwise the scan will fail. Maybe you wanted to `printf` a prompt and then `scanf("%d`
The last element in the array is supposed to be 0. I have made an error. The correct syntax is S[99] = 0;
It's not `printf` that works like that, it's stdio in general. `FILE` is an abstraction over however the operating system handles IO. This abstraction has buffering designed for the common case. That is: * by default, streams have a buffer of `BUFSIZ` bytes * `stdout` is line buffered (that is, the buffer is flushed on each `\n`) when connected to a terminal * `stderr` is unbuffered so error messages are immediately printed in case the program crashes soon. You can configure the buffering mode with `setbuf` and `setvbuf`. You can manually flush buffers with `fflush()`. Refer to the documentation of your vendor for more details.
This is why you always check the return value when using scanf().
Yes, you are right. I'm going to document it better. Next commits are going to target that. Thank you!
~~Well, the title says *from* your phone, so ...~~ I was on mobile, and saw the screenshot, which says "from your phone", instead of the title, which says "on your phone." I did read it like you, though
You should write the comments first and then the code. that helps a lot as it forces you to think things through before programming them. You are also going to find that it is much easier to implement a function after writing a comment outlining its behaviour.
No... It doesn't.
Yes, I thought of that. It's very hard though.
Explain to us what the intent of the following code is: for(i = 0; i&lt;n; i++) { scanf("%d\n", &amp;S[i]); S[i] = i + 1; }
There's a nice macro that is sometimes used in these kinds of cases: #define PS(x) (char*)&amp;(x) , sizeof(x) PS stands for ptr&amp;sizeof. This makes it less likely to make mistakes when passing the buffer along with its size. fgets(PS(buffer), stdin);
C11 supports variable length arrays at the end of struct.Something like struct foo{ /*... struct fields ... */ whatever_type bar[]; } is perfectly fine as long as you provide `sizeof(struct foo)+(size of bar array)` space for it when using such a struct. Read the standard.
In addition to what Kristler stated, in this specific case, the reason a segfault would occur is due to overwriting the return address on the stack. Whenever your code calls a new function, a new stack frame is created. Depending on the architecture, a variety of things may be placed on the stack, but one of them is the return address. This is the address in your code where execution will resume once the function returns. In your code, the variable buffer is a stack variable; it reserves 15 bytes on the stack. One thing to note about the stack: it grows down. If function A calls function B, then function B's data are at a lower address than A's. This means that when you continue to write data into *buffer*, you are writing into higher and higher addresses. If you overflow your reserved space and continue writing, you will start overwriting the bookkeeping data of your current stack frame and potentially previous stack frames. This is a classic example of a buffer overflow vulnerability. The reason it segfaults is because you overwrote the return address for the function main(). Whatever data you dumped in there (leftover from your input string &gt; sizeof(buffer) bytes), probably wasn't a valid address for code, so when main returned, it tried to return to some area outside your allowed address space --&gt; segfault. But a user can actually control the data that gets written, so not only is this undefined behavior, but this is a security problem! An attacker can take advantage of a buffer overflow like this to modify the return address to something of their own choice and in so doing, redirect the program to start executing somewhere else, potentially their own code. Your user now has control over your program. Not good. Now if you look at how a stack frame is laid out, it doesn't usually show that much space between your first stack variable and the function's return address. But the compiler and system are free to move stuff around a bit behind the scenes to help with optimization and alignment. So where you might expect a failure as soon as you write off the end of your buffer, in reality, you're writing into who-knows-what on the stack. Hence the undefined behavior that Kristler talked about. Write enough though, and it will eventually destroy your return address. So you should always sanitize your user input to prevent these sorts of problems. Never allow a user to input data into a stack variable without limiting the input to the size of your buffer, as you did with the example code. 
Try translating programs which use multidimensional arrays into ones which use pointers manually. That should give you an idea about indexing and how the memory is laid out, plus it's always good to be able to use them both interchangeably.
linux is opensource, so you can look to see how they implemented it
I'm fairly new so i didnt think of this. Where would i find the actual source code? 
https://github.com/torvalds/linux/tree/master/kernel
That's a really terrible answer. The Linux source code is extremely complex and without knowing how these subsystems roughly work, wading through the source code is of little help.
I suppose I could make it easier. http://lmgtfy.com/?q=list+groups+user+c+linux
Debug symbols give you the ability to list the source code in the process of debugging, and step through lines of code, but they don't affect what I'm looking at. To clarify: the binary I'm reversing has all the information needed to allow a tool to show what standard library functions are getting called; `radare2` can do it. I just want to know how to turn that on in GDB for non-`clang` binaries.
I believe this is an option in the linker step that gcc is passing. gcc -v or -### will output the scripts its running. Same option for clang. You should be able to pass the linker arguments from the gcc call... if you can find what you need to do. Why I think this is the case... if you cpp hello.c -o ghello.c gcc -S ghello.c -o ghello_ as ghello_ So now we have to link I ran clang -v hello.c and used all the outputs after the /usr/bin/ld .... "--hash-style=both" .... etc to run ld manually ld "--hash-style=both" .... I did have to change the source input from /temp/hello-$(random numbers).o to my "./ghello_" and now gdb does have the printf label next to the callq when you disassemble...
"pass by value" vs "pass by reference" is a simplification in c. C does not have pass by reference, it only has pass by value. A pointer is an address to a type. The type is used to interpret the data located at the address (value of the pointer). So when you pass a valid pointer (address) to a function, it feels an awful lot like pass by reference. Because c passes by value the value the pointer has (a valid address). So if you have appropriately allocated space, passing a pointer is not copying all the data the pointer points to, it just copies the pointer value (address to the data) So you don't have to pass the address of the address to get the "pass by reference" feel... as long as the address the pointer points to, is appropriately allocated. So a junk or null pointer does not get the pass by reference feel. ie... void fill_hello (char *str) { str = calloc (6, 1); str = "hello"; } int main ... char *hello; fill_hello (hello); // this is a memory leak // and doesn't set the value of the pointer since the char *hello was never initialized, its value (address) is random junk. When it gets passed to the fill_hello function, it copies that junk value. calloc then sets the value of the (temporary "pass by value") pointer to an allocated space, and sets that value as hello\0. The scope ends, and we lose that valid address, so we are unable to reference the value it pointed to (hello\0) so in that case, you would want to pass an address to the pointer. This way we can retain the value calloc returns. void fill_hello (char **str) { *str = calloc (6, 1); strcpy (*str, "hello"); } int main .... // stack space for a pointer value char *hello; // pass the address of that stack space fill_hello (&amp;hello); // the stack space we call hello // now contains an address returned from calloc // which points to a memory location // that has the value (hello\0)
Your code is barely readable, try using more descriptive variable names and for things like checking if a pin is high use mnemonics instead of magic numbers. Compare: sw = PIND &amp; 0xc0; if(sw == 0x40) i++; if(sw == 0x80) i--; with sw = PIND &amp; 0xc0; if(sw == BIT6) i++; if(sw == BIT7) i--; In the second one you can immediately see that you're checking bit 6 and 7 and that you do nothing if both are pressed at the same time. To have one button press count up or down once, you have to first add some debounce (about 20ms is common), and store the previous value of the button. Then only count if the button was first not pressed and changed to pressed. 
ty 
Coding like this is fine. Note that you can actually declare the parameter as `Card *hands[][]` if it makes you feel more comfortable. Congratulations on becoming a three-star programmer!
If you want to have a career in which you actually interact with people, you need to try much harder at communication. for(i = 0; i&lt;n; i++) ==&gt; have i iterate from 0 to n-1. scanf("%d\n", &amp;S[i]); ==&gt;"scan" a number in the the ith element of S S[i] = i + 1; ==&gt; explain me in detail what this line does, why it is here, and what is its relation to the overall goal of "Scan n elements to array". 
You use your distro's package manager and related tools to find out the corresponding package for the 'groups' command, then you go to its website and look for the source code: https://github.com/shadow-maint/shadow/blob/master/src/groups.c 
I'm fairly certain the /usr/bin/groups command implements it by reading and interpreting /etc/group, but I don't think that's what this assignment is looking for.
Double precision is almost always required when doing scientific computing. In particular if you're doing anything larger than the 2 body problem, floating point roundoff has a large effect on the resulting dynamics. I assume that's what he meant when he said "no floats", but who knows...
Except that in your suggested code the behavior is _not_ what you describe (extraneous else). :( 
And here I thought I could write three lines of code correctly without double checking. fixed. edit: now my example looks stupid though, only the magic numbers are changed
Consider just using an array of 52 ints. You can assign suit/value by lookup table, but manipulating the array of ints may be a lot easier than arrays of pointers. Even just an array of structs (vs pointers to structs) would be much easier, imo.
You're right. I don't know what I was looking at. I swear I checked twice before posting, because I'd read it as "on your Phone". I discovered my problem -- I was looking at the screenshot instead of the post title. 
I can't use floats because of the length they create. I don't remember the specific reason why but my team lead said they aren't allowed. We are working on a student run satellite program. 
I can't use floats because of the length they create. I don't remember the specific reason why but my team lead said they aren't allowed. We are working on a student run satellite program. 
I like [minunit](http://www.jera.com/techinfo/jtns/jtn002.html). There's very little to learn, it is easy to extend, and doesn't get in your way. Then there's something like [this goliath](https://cmocka.org/) that I haven't used before. The website is pretty, so it is probably decent.
OP said right in the description that he wants to use it for `ftok`. There's nothing cryptographic about that.
Well, look at what your loop is doing... while (1) { if button X is pressed down increment sleep for 10 milliseconds } You run through the loop once, and increment because button X is pressed. You wait for 0.01 seconds, and then do it again. The button is still pressed, so you increment again. It's going to keep incrementing, 100 times per second, as long as the button is held down. You don't want to increment based on whether the button is *currently* pressed. Instead, you want to increment *once* when the button changes *state* from "not pressed" to "pressed". I mean, that's pretty much what you knew you needed to do, right? You asked, &gt; How do I Count up and down per one click this code? Well, keep track of clicks. What constitutes a "click"? It's the button transitioning from "not pressed" to "pressed", right? So go implement that.
Its outdated in that it was last written for ansi C. Most of it is still accurate. If you want to learn C I would highly suggest taking the free online course CS50 and reading C Primer Plus by Prata and C Programming A Modern Approach
Thanks buddy.. Also can you list out the topics to be covered to the point that i can do something useful with the language.. You 100%sure its oudated.?? 
the scanf fix worked, thank you all
this is a python wrapper around C code 
Doubles are fine. I asked and the reason is because the hardware we are using doesn't allow them. Floats are formatted in a way that makes them really slow with the hardware, but doubles are fine.
That is a pretty broad question. Do you care to narrow it down a bit?
This doesn't really answer the question of what is considered the idiomatic or best practice way to write the method signature for passing a 2 dimensional array of pointers to a function. A question more related to your comment: how would you define "pass by reference" if not by passing the address of the variable you want to use in the function rather than making a copy of the variable to use in the function? I get that "pass by reference" is still passing by value the address of the variable into the function, but the value being passed is an address of the variable rather than a copy of the variable, which is the definition of "pass by reference" in every context I've seen the phrase used. 
 I decided to enumerate suit and values and use structs for the cards because of the idea that if I wanted to reuse this code in the future to modify it to be able to be used in many types of card games that may require more than 1 deck of cards(or less if such a game exists) using a lookup table might be a bit harder to read the code for than initializing decks in a loop. I will see about trying to use an array of structs vs an array of struct * 's though, as that does seem like it'd be easier to follow. Would you mind showing me how you were thinking of making a lookup table as your deck of cards? 
compiling using visual studio 2015 on windows 10, I get an error saying that hands has a missing subscript if I use ```Card *hands[][]``` and also when compiling using gcc 6.1.0 through mingw on windows 10. 
It explains why you would use an address of operator on a pointer. It also explains differences with other languages, such as c++ with the reference parameters. If you read it, and understood it then you wouldn't have to ask the question. So I think it does answer it, whether it answers it well is another question.
Then I'm not sure how it is related to C programming. I have removed your submission for being off topic.
Additionally, why bother keeping track of state when you've got interrupts you can be using? You've already included the relevant header.
Two ways to answer your question, and I'm not sure which way you mean, but to go both for any others that wonder either way... 1. He's not freeing all of the memory back to the OS (possibly for fragmentation reasons). Since he has these blocks of available memory he's already acquired, keeping a list of them for reuse is useful. He could maintain two linked lists of blocks, freed and used, or he could maintain one list with a flag. 2. Since he doesn't release memory back to the OS, if he reports just the available memory, he's under reporting what memory is available to allocate (though, the fragmented memory may not be allocated depending on the malloc'd request).
Do you have any experience programming? If so, read K&amp;R. If not, follow my post above starting with cs50
Do you know of any kinemarics libraries? I looked for some on gitlab and github and couldn't seem to find any.
What have you tried? What in particular are you stumped on? Did you check your textbook, notes, professor, TA? I want to help you but it doesn't sound like you've actually begun, you gotta get stuck somewhere and then you can ask a specific question that we can answer... Rather than someone just doing your homework for you... 
https://en.wikipedia.org/wiki/The_C_Programming_Language Non-mobile link.
I recommend you pick it up at *some* point in your C life because 1) it's short, 2) it should be easy to find used &amp; cheap, 3) it *was* the Bible of C for a long time (and for some it still is), so familiarity with its style and its ANSI standard C is useful. In the real world, you *will* come across code bases and examples that use varying standards of C. There are reasons to use C compilers of different versions or standards, based on platform or project requirements. So being comfortable with high-quality C of any heritage is useful. K&amp;R demonstrates high-quality C and you should be able to understand all the examples in it, even with knowledge of more "modern" C standards. TL;DR: There's not *one* magic C book. Get this. Get others.
There are a few problems. Start with this line: while( S[i] != 0 ) The first time execution hits this line (before it has looped at least once), the value of `i` will be `n` because that will be the value of `i` as it terminates the previous `for` loop. But `S[i]` is out of bounds for values of `i` &gt;= `n` because you've declared the array: int S[n]; So accessing the value of `S[n]` in the first evaluation of the `while` expression is a serious problem. You should expect abnormal termination right there. 
I'm a team lead for C&amp;DH on a big university's CubeSat team. What kind of kinematics are you trying to calculate? Is this for attitude control, or is it for location determination? There's a standard format published daily by DARPA I believe that can be used to communicate the rough position and forward propagation constants needed to know the CubeSat's position at all times. I don't remember the name of the format, but if that's what you're trying to do, I would definitely consider offloading that stuff to the ground. ACDS is hard enough when you're just forward propagating the next few hours until contact, much less forward propagating for days into the future.
Nice code :)
Did you try compiling and running it? What happened? In general, you can replace `m=n++;` with m=n; n=n+1; And `r=++s` with s=s+1; r=s;
Maybe it would help if you built a table with each of the values after each of those lines. I've given you the first one for free below To validate, you can copy that print statement between each of the assignments. var: | x | y | a | b | c | a = x++; | 2 | 2 | 1 | 0 | 0 | b = ++a * y++; | | | | | | c = x++ + b++; | | | | | |
Haha welcome friend to the better side of programming subreddits (glad r/programming can't hear me here). This stackoverflow topic helped me quite a bit when I was first starting off and didn't know which direction to follow: http://stackoverflow.com/questions/562303/the-definitive-c-book-guide-and-list Read all these books (or most of them) and you'll be well on your way to becoming a C guru. The thing about C is it's a very small language (but highly orthogonal) so you only need to know the basics to be able to make practical programs. Although the programs will work, they won't be elegant, and that's where the more advanced C topics come in. If you really REALLY can't decide whether or not its worth reading k&amp;r so early in your c career, take my advice (which some will consider blasphemy on this subreddit) and read a more modern beginner book from the above link. Once you got the basics down, by all means read k&amp;r. God speed friend!
Try reading Pointers on C. This book goes in great detail on how multidimensional arrays are implemented and how they're mostly an artificial human construct ( they're just arrays with the elements being other arrays).
Look up the documentation for what the different registers actually do. I'm not sure what the maximum delay is, so you might need a surrounding loop. The Arduino supports timer-based interrupts, which would give you better accuraccy. This might be useful: http://playground.arduino.cc/Code/Prescaler
&gt; prog.c: In function 'main': prog.c:38:1: error: 'for' loop initial declarations are only allowed in C99 or C11 mode for(int j = i; oldword[j]; j++) ^ 
As a general rule, if you have ++x in an expression, it is the same as x=x+1; [statement containing expression with x]; Whereas with x++ in an expression, it is [statement containing expression with x]; x=x+1; 
It depends on your compiler. Read the manual/google.
Assuming 'inPtr' already has space allocated, you don't need to do anything other than the `scanf`. If it doesn't, you need to allocate space with something like `malloc` and return it, or use a pointer to a pointer to update the arg.
It all depends on what you're trying to do and what type of sanity checking is appropriate. To prevent buffer overflows, the main thing is to make sure that you don't allow more user data into your buffer than space you've allocated for said buffer. In your original example, that was done appropriately by setting the second argument of fgets to be the size of your buffer. As long as both of those are the same, no overflow will happen. You only had problems when they weren't the same. Also, for string data, you should always make sure your strings are null terminated, but if you look at the man page for fgets, it will do just that. 
Thank you! 
PSA: double-line-break your stuff on Reddit, otherwise (for some reason) it sticks it all on the same line.
Sizes of strings don't really matter. You don't have them, and don't need them here. What if d == s? I'm not sure I agree with your sentiment on returning NULL either, but that was predicated on the size thing, so I'll just ignore it. 
It's hard to say without looking at the code, but... 1. Do not include a full C file. Public functions should be declared in the header and you should `#include` the header only. If the function is not public, you'll have to "side test" it by calling the public function. 2. When compiling the test application, make it include the test object AND the source object. In Makefile terms, something like this: crawl_folder.o: crawl_folder.c gcc -c crawl_folder.c test_crawl_folder.o: test_crawl_folder.c gcc -c test_crawl_folder.c test: crawl_folder.o test_crawl_folder.o gcc -o test crawl_folder.o test_crawl_folder. (somethings could be simplified by using special Makefile variables, but I wanted to make things more explicit). We did exactly that using [GoogleTest](https://github.com/google/googletest) (even it is a C++ testing framework) and I believe the same process would work with [GLib](https://developer.gnome.org/glib/stable/glib-Testing.html).
Thank for answering. So you mentioned "side test" if i want to test private file, I have to declare them into public function by declare them in header file, right? BTW, like your Makefile term, in test_crawl_folder.c when i test private function get_name_folder(), i don't need include any header. Just compile them together like "gcc -o test crawl_folder.o test_crawl_folder"
It appears that you have been shadow banned. Please talk to the admins to rectify this problem. That said, please... * outline what your question is * if there is a problem with your code, describe the desired behaviour and what it does instead * put four blanks in front of every line of code so the code appears in mono space. 
 { int x = 2; int a = ++x; // increment the value before you read it // x == 3, a == 3 } { int x = 2; int a = x++; // increment the value after you read it // x == 3, a == 2 } Edit: Added semicolon after assigning `a`
Every function that you declare on your headers is basically "public": Anyone including your header can use that function -- that's what you "say" when you put the function there: "Here, there is this function, it has these parameters and this return value, use it when needed". If it's not in the headers, you're basically protecting the function from being called externally; it's *your* function and you'll call it when *you* want it, and nobody else should call it. (This situation is akin to using `const char*`: You're saying "this string area is mine and you shouldn't mess with it"; another developer could simply cast it to `char*` and use it the way they want, but they are one their on in this case.) So, when I say "side test", I mean that you shouldn't call that function directly because, since it's a private function, it's prone to change at any time (I actually had problems with libraries that tried to mess with internal functions with other libraries and that's a road nobody wants to be in); you'll have to call something in your external API that actually calls the behaviour inside the private function. You can compile both files at the same time, (e.g., `gcc -o test crawl_folder.c test_crawl_folder.c`), you won't need to explicitly point which functions are public and which are not; but again, you should think about the architecture you're building (again, that's akin to the "L" in "SOLID" -- [Liskov Substitution Principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle)). 
Why do you not want to use a framework?
Very interesting. Care to give a quick TL;DR on the method?
Petter use `fgets` instead of `scanf` for this purpose.
Parsing the code without types requires us to deal with ambiguities like `x*y', which we solve by looking at further syntax. Afterwards, we visit the AST and generate constraints, using a language of our own, for the C source. Finally, we extend a Hindley-Milner inference algorithm to deal with C particularities and to solve those contraints.
I usually use this approach: 1. think about what you want the program to do. Write that down (this step is important). 2. think about what components your program needs to have. Do not add components you don't need. Write that down. 3. For each component, create a header file. In these header files, declare data structures used to interact with the module and declare all functions you think you are going to need. Document every data structure and specify the invariants it has. Also document why you choose to do it that way. 4. Implement the functions. For each function, write a brief comment what this function is supposed to do, what the parameters mean and what the function returns. This comment is the contract for that function. It should be written such that you can make a drop-in replacement for that function just by looking at that comment. Most importantly, that means that no caller may assume anything about the function that is not stated in this comment. 5. Once your prototype runs, you have likely found design deficits in your original approach. So throw it away and start again. Your second design is usually good enough for future development, if it isn't, you may need to throw away more than one design. 6. If you did step (4) right, it should be moderately easy to reimplement or change parts of the program without having to touch too much code. 7. Make sure to document all changes and the general program design, optimally before writing the code. Documenting serves a number of purposes: a) if you write down the program design, it is very likely that you catch contradictions or design deficits before implementing a wrong design. b) documentation and justification helps you understand what parts of the program design you can change and what parts you cannot. c) documentation is exceptionally useful if you revisit your project after a number of years working on something else.
What university are you working with? I'm working with an ACDS team as their programmer. I don't have a ton of knowledge in the details of what is going on, right now I'm just asking them what they need and I'm making the code work for it. I just joined the project a few weeks ago so I'm still trying to get up to speed. 
`*c1` is dereferencing c1. But you can't do that because you never initialized `c1` to point to anything, so you're invoking undefined behavior. What are you trying to accomplish, and why are you using a pointer to a pointer to a char? 
Because I really understand the way for test unit. It's difficult to understand what framework do clearly.
&gt;I usually use this approach: &gt;2. think about what components your program needs to have. Do not add components you don't need. Write that down. I like to use post it notes for this. I can move the notes around to better understand how the components might work together, if there are things I don't need and if there are things I overlooked. Also, the input-process-output design model is often appropriate for me because much of the software my office works on takes data, does something, and then passes data to something else. 
Really, I just break it up into logical chunks.
I'm doing something similar, and I'm simply calling the file UnitTest.c, and each testing function is simply called Test-FunctionName(). My makefile is setup to compile UnitTest.c and link it against my library when I enter the command `make test` then I just run the Test executable, ususally through a debugger because there are hidden errors in most of my functions haha. Edit: My point is I don't use any external framework or library, the closest to that I have, is I wrote a logging function.
The point is that you can re-enter a function from the place it last exited. That can be handy if you want to run two or more functions seemingly in parallel, e.g. if you have one function which emits values and another which consumes them, coroutines provide a very neat way to express that relationship.
Thank you :)
You really should not be using inverse kinematics for attitude control. Our team (I can't say who) is using an inhouse MPC controller with Kallman Filtering and a redundant sensor voting algorithm for attitude control. There are a few published MPC controllers specifically designed for attitude control in CubeSats, I'm sure you could use one of those instead. 
Nice job.
Take a look at Simon Tatham's page which I linked to above for a robust example of the value of coroutines.
Been there, read that. I think the confusion is about who's revisiting :) And no, I don't see this very often out in the wild, especially not as stripped down to the core; so I wouldn't call it the usual way to do anything. Maybe I'm just hanging out in the wrong crowds...
What is your question? Also, as per the submission guidelines, please place 4 spaces before each line of code so it gets formatted properly.
You can create a thread for input reading and then check for events once in the main loop, if you don't support multiple events per tick this will be easy. You could also add a timeout to the read using the select syscall, not sure how to implement it though.
use select() (or epoll() on unix). You load it with the file descriptor for stdin and tell it to wait for input up to a timeout. more info to get you started and keywords to search on: http://stackoverflow.com/questions/9798948/usage-of-select-for-timeout http://stackoverflow.com/questions/6370008/is-there-any-good-examples-or-tutorial-about-epoll-udp
Or just plain old [poll](https://linux.die.net/man/2/poll)
You can use `alarm()` to set an alarm. Once you get the alarm, your signal handler is called and IO will be interrupted, meaning that your `getch()` function call should return without the user having typed anything. Not sure though if this mechanism works on Windows.
&gt; Also, the input-process-output design model is often appropriate for me because much of the software my office works on takes data, does something, and then passes data to something else. In which case I would first being with sample input and expected output, create test cases, then design/build the implementation. Once you have a correct implementation &amp; a testsuite, refactoring should be a piece of cake.
Post removed: Not sure how this is related to C programming.
Agreed. `poll()` is tons nicer then `select()` and still very portable. Windows doesn't support `poll()`, but Windows also doesn't really support `select()` in this way either so it's debatable how much it matters.
Think about it for a second and you should be able to figure it out. You have a formula that makes a random number between 0 and N. You want a formula to translate that to a number between A and B. Hm..... How might you move the range around a little bit? If I gave you a formula that made results 0-5, and you wanted the results to be between 2 and 7, how would you do that? 
Basic logic structure would be: for (int i = 2; i&gt;=0;i--) { sum = array1[i] + array2[i] + array3[i] print sum sum = 0 } *Note: this is pseudocode 
I'm using this book too for an online class in Intro to C programming. I'm in Ch. 6 now. I struggled a bit with Ch. 5's exercises. Most likely because it's an online course and there's no professor lecturing, or that there isn't anyone to go to when I have a question besides the online community lol.
TESU?
These open ended questions that show no evidence of research or prior thought are not going to get good replies. Look into SDL for graphics. If you want a stupid and ugly unbeatable tic-tac-toe algorithm, I wrote a one in Lua while back. Again, I have to warn you: https://github.com/teran-mckinney/foureightysix/blob/master/tictactoe.lua
I'm not an expert, so I'd be glad to hear any advice or your opinion about code quality.
&gt; The shell does that transformation as part of invoking the program. No it does not. At least not with `"..."` strings. In the POSIX shell, a backslash usually only takes away special meanings from characters, if a character has no special meaning, the backslash does nothing. (Thus, a good approach for escaping arguments to shell commands is to put a backslash before every single character). There is `$"..."` which does transformations, but that feature isn't standard.
Out of curiosity, what should OP use in place of strncpy()?
[strlcpy](https://linux.die.net/man/3/strlcpy)
 ./myprog `echo -ne "\t foobar\n"` Should work as well.
First: while(h = TRUE) This is an infinite loop, because it sets `h` to `TRUE` and then returns `TRUE`, which, of course, makes the loop to go on forever. Furthermore, `isalpha` takes a `char` (technically an `int`, but you're supposed to pass a `char`) as an argument, so your calls to `isalpha` with `y` and `z` are wrong (they should be `*y` and `*z`). At least on my computer, that's what throws “Segmentation fault” (curiously enough, not on the debugger). Also, you should not try to get the last character of the string going backwards from the end, as `fgets` only fills *at most* the number of characters you set as a limit (note: the limit should be 81, or the size of `input` 80, because `fgets` reads n-1 characters and places the `\0` at the n-th character, so there's no need to subtract one yourself), so with short strings you still have some of the uninitialized characters you get when you declare a local, non-static array. I'd either make `input` static (I wouldn't recommend it, to be honest; it's a bit of a hack, and I haven't tried it myself, so maybe it doesn't work) to automatically zero it out, or change `z=&amp;x[80]` to `z=&amp;x[strlen(x)]`. You should also change the `for` loops in `palindrome` (where you use 81 as a hard limit) accordingly. Last but not least, `strcmp(y, z) != 0` checks that the string starting at `y` is equal to the string starting at `z`, which in this case would only be right if the indices of the characters they pointed to were the same. I daresay you wanted to check the characters themselves for equality, so I think this condition should be `*y != *z`. Those are all the errors I've managed to find. Once I fixed them, the program worked perfectly. I hope this was not an assignment or something like that :-)
&gt; Why does '(node)' have to proceed the initialization? The `=` here is not initialization, it's assignment. This is using a [C99 compound literal](http://en.cppreference.com/w/c/language/compound_literal) to do the assignment in a more compact way. &gt; So how come it works for NULL? When providing an initializer for an array, any elements that are missing initializers are initialized as if they had static storage duration. For pointers, that means they are initialized to the null pointer. It's the same reason that you can zero out an array of ints by writing int foo[3] = {0}; 
Thanks for you complex analysis. I'll keep your points in mind and try to implenent these changes later.
Do you need the newline at the start of line 9? It might looks better at the start of line 19,
Editor * Visual Studio * Eclipse * Netbeans * Code::Blocks * Any text editor &amp;nbsp; Compiler tool-chain * Mingw * Cygwin * Visual Studio/MSBuild * https://en.wikipedia.org/wiki/List_of_compilers#C_compilers Then you need a .c file #include &lt;stdio.h&gt; int main(void) { printf("Hello World\n"); return 0; } Then you need to compile it. How depends on your tool-chain .
Quick note on compound literals: IIRC they were only kinda-accepted as initializers (i.e., actually initializing something at the point of declaration) by C99—that usage wasn't prohibited and made sense for compilers to accept since it just looks like a more explicit version of the usual `{}` initialization, but it wasn’t mandatory either. Some C99-era compilers like GNU/Clang did accept them as initializers, but there’s no formal guarantee of that until C11. They’re not all that commonly needed, and given the versioning and use limitations I’d probably avoid them in production code unless there’s a very good reason or you’re targeting GNU99 or C11 anyway. They’re only necessary because of the statement-expression divide that mostly crops up when fiddling with macros; for any other use you have a little more control if you just declare a variable, which also gives you the ability to add a storage class like `static` since things like the above example don’t need to be `auto`.
&gt; static storage duration Thank you! Compound literals and static storage duration seem a tad too complicated for where I'm at right now. Not many resources on the web attempting to eli5 either. Do you mind dumbing it down a bit- only started learning a few months ago. Appreciate your response though!
Wow, what a fantastic post. What background! What elaboration and elucidation!
Please don’t use Notepad as your primary means of programming. At best, you’re making your life much harder than it needs to be; at worst, you’re building bad habits for no particular reason. Notepad is just a leftover test app, a text box that Windows unceremoniously shits the contents of a file into. It has no ability to syntax-highlight, auto-indent, or regex search-and-replace, and it can’t even handle basic things like line endings properly. Try Notepad++ or KWrite if you want a lightweight-ish editor. (KWrite is my recommendation—part of KDE, so it’s cross-platform, and Kate is a reasonably good multi-file wrapper for the editor component once you get used to it. Both very easily scripted and extended, too.) And of course there’re always Vim and Emacs, but I’m not going too open that can of shit here.
You're using `=` (assignment) in your `if` statements instead of `==` (comparison), that's why it always sets inputFile to File1.wav. BTW I'm not sure if it's a typo you made just in this post but it should be `scanf("%d", &amp;chosenFile);` and not `scanf("d%", &amp;chosenFile);` You have to provide more info than just "stopped working" for the other problem.
Assignment and initialization are not the same thing. struct foo { int a, b; }; ... struct foo some_var = { 1, 2 }; This is initialization. You're declaring a new variable and providing an initializer. struct foo some_other_var; ... some_other_var = some_var; This is assignment. They both use the equals sign, but they are quite different. The right hand side of assignment has to be a value of a compatible type (in this case a value of type `struct foo`), not a brace enclosed initializer list. You can't do this: some_other_var = { 1, 2 }; // syntax error That's invalid because this is not initialization. For simple values like int or whatever, that isn't a problem, because the language lets you express literal values of that type easily. 42 is an int literal, 3.5 is a double literal, 'c' is a char literal, and so on. But until C99 there was no syntax for a literal of struct types. The C99 compound literal lets you create temporary values for arbitrary types. You have to introduce the type name first, followed by a brace enclosed initializer list, just as if you were initializing a variable. some_other_var = (struct foo) { 1, 2 }; This is really just a shorthand for assigning the individual fields: some_other_var.a = 1; some_other_var.b = 2; That's the traditional way that you'd do that. And some would argue it's the preferred way. Every object has a storage duration, which is one of: automatic, static, dynamic, or thread-local. The storage duration determines the lifetime of the object. Automatic lifetime is the most common, and it's what you get when you declare a normal local variable in a function. Static lifetime is what you get when you declare a variable at file scope, or if you declare a variable inside a function using the `static` modifier. Static lifetime means the variable exists for the whole life of the program. And for complicated reasons, that means they are always initialized to some value, even if you don't provide an initializer. That value is zero for numeric types, and the null pointer for pointer types. This is in contrast to variables with automatic lifetime, which are uninitialized if you don't specify a value. int a; void f(void) { int b; } `a` is initialized to zero at program startup before `main()` is called, and `b` is uninitialized. That's just background information. It's not directly relevant to an example like: int arr[10] = { 1, 2, 3 }; If you provide fewer initializers for an array than there are members, the excess members are initialized as if they had static storage duration, which means they are initialized to zero in this case. The storage duration part isn't really relevant here (as the lifetime of `arr` has nothing to do with whether you provide an initializer with ten members or not), it's just that the standard uses "initialized as if with static storage duration" as a way of not having to repeat itself, i.e. specifying that something is set to zero if it's a numeric type, or set to the null pointer if a pointer type. 
OK, you know what I would recommend? There are online programming tutorial web sites that are free. Some of them have text windows in the browser where you type your code and then hit "compile" and see your output in another text window. I've never tried one of those, but it might be a good way to get your feet wet. For really learning to program, however, you need your own computer and compiler and such. Seriously think about switching to Unix (MacOS or Linux) instead; it's much much much easier to program in. And their C compilers adhere to the C standards. Yes, I would get VS. Get VS 2015 community edition; it's free. I hear that revision 3 actually adheres to the C11 standard, but haven't tested that myself. You can program with any text editor (I use vim myself), but you still need the compiler, linker, libraries, and so forth. Those all come bundled with VS (assuming you check the right boxes when you install it.) I don't even know if there's another way to get them.
Cygwin has a compiler chain? Cool.
I'm not here for your entertainment, though. I'm just trying to get the ideas across, my real interest is improving the code. There's some more background on the linked Github page, in case you missed it: https://github.com/codr4life/libc4life
I'm with you. As a kernel developer, there are even places I use strcpy and I'm confident in its correctness. I actually can't think of a single place I've used strlcpy... Regardless, I was just answering the question of what might be considered an alternative to strncpy. Each are just tools; programmers should know what they are and how to use the right one for the job.
Meh. I figure if it's there and it works, no reason not to use it unless you know you're going to be moving your scripts to a system that doesn't have it. Personally, I've yet to come across a system that didn't have a completely functional echo -e. Even busybox's has it. But really anything that interprets the special characters can be used inside backtics on the shell. echo, printf, perl, python, etc...
So you have only ever used Linux.
You have the [XY problem](http://xyproblem.info/), I think. What are you actually trying to solve? For most use cases, the fact that the bytes you are processing are UTF-8 doesn't change anything – printf, for example, works fine out of the box as long as the terminal can handle it.
thanks a bunch! although i found out the problem a while back, and i've moved on to java lol https://ghostbin.com/paste/2ko78 a more recent program
Pay no mind...idiot me didn't notice it was LIBNET_ERRBUF_SIZE...sorry to even ask
Might be the case. I'm doing the simple: int chType; chType = getwchar(); while ((chType = getwchar()) != EOF) { putwchar(chType); } The header files &lt;stdio.h&gt; and &lt;wchar.h&gt; are included via another header file through an #include command. *Edit: Really, what i'm trying to do is to echo characters i enter. But letters like ÅÄÖ becomes gibberish.
getwchar() uses WEOF, not EOF. ☺ That loop should work fine in any character encoding with just getchar(), by the way.
EOF or WEOF doesn't seem to do any difference though. I tried using getchar() and putchar() earlier but with the same problem. It just doesn't want to echo UNICODE characters for some reason. :P Thnx for the help so far though.
Your issue is probably with the windows console then, which is famously shitty. You need to [change the console font](https://support.microsoft.com/en-gb/kb/99795) to an Unicode-compatible one, and then call e.g. SetConsoleOutputCP( 65001 ) to tell windows that you want to use UTF-8. You can also try printing the bytes for some character directly, e.g: 0xC3 0x96 &gt; printf( "%c%c\n", (char)0xc3, (char)0x96 ); If you get "Ö", your output is UTF-8 compatible and it's the input characters that are something else.
I've looked into it. First i thought i was because the laptop i'm using uses a Scandinavian keyboard setup, and since getchar() reads the input as an English keyboard, putchar() prints ÅÄÖ as the English keyboard equivalent characters. However, I've come to realize that getchar() and putchar() uses one byte characters, and cannot store UNICODE in the way i wanted, i'll have to find another method. Thanks for the help though!
Primarily Linux, the various *BSDs, and the OS I work on, but yeah, I've not done much with Windows. Or Apple's products. 
Then you should know that neither *BSD nor OS X provide `echo -e` as it's a GNU extension. Basically only GNU/Linux has that command.
Huh. Sure enough. Learn something new. 
And that's exactly why “works on my machine” is a very poor approach to portability. Nothing is portable unless specifically documented or tested as being so. And even then, you should better verify the results.
Call srand only once. If you call makeArray twice quickly then time() is going to return the same number.
Never suggested it was. Just erroneously stated that it should work without qualification, which you corrected, and then stated that unless you needed portability, it was an option. Even you suggested a non-standard option. 
Thats what I was afraid was happening. im still a bit of a novice at coding, how would I call srand only once?
would i need to put rand() in as a parameter to makeArray() like this? makeArray(rand());
standard `rand()` is a pseudo-random generator, not a real randomness source. This means that it takes value provided by `srand(...)` as start state, and then mixes bits in this state to provide next number, and next and so on. What this means, is that if you provide same input via `srand()`, then calls to `rand()` will return exact same chain of "random" values. Now to your problem. Value of `time()` has second resolution, i.e. it changes every second. Chance that `time()` will return same value if you call the function twice are not 100% but because your computer is fast, that chance is close to 100%. Feeding `time()` into `srand()` twice will very likely feed it same value twice and make it return same chain of "random" values twice. But this is a nice way to reproduce chain of random events when you want to replay a game session with same drops and same rooms (see "seed" in the Binding of Isaac for example, which you can reenter and get exact same game again).
srand ("seeds rand") provides the initial randomness for rand to work. what's happening is that the program starts and finishes execution within the same second so time() gives srand() the same seed.
you can do #define right? why enum?
Enums are also used for creating state machines.
Another reason to use `enum`s is that your debugger knows about them and will use the appropriate symbols instead of numeric values. With `#define` you only get the literal values of any constants when debugging. Note that in general you should only ever use `#define` for constants as a last resort. C has had `const` for a couple of decades now, and `enum` for even longer. If you're learning from a book or tutorial that uses `#define` for constants then throw it away and get something more up-to-date.
Thank you very much again! And you were right about the scanf("d%", &amp;chosenFile); It was a typo on my original code and after fixing that, &amp;chosenFile worked so I had removed the IF statements. Really appreciate it, now on to trying to create a .wav file from scratch. Thanks again!
You should call srand(time(NULL)) only one time in your main(). srand() initialize the seed (the initial value) of the random number generator: if you call more times srand() with the same argument the subsequent calls of rand() will give you the same value (by the way, time(NULL) returns the number of seconds passed from 1st January 1970, so probably the 3 calls have the same argument because your program terminates quickly) 
You can't read unicode chars with getchar() and putchar(), because these two functions does not work on characters (despite the name) but on raw bytes (that only in the ASCII encoding are effectively one character), they read and write only one byte (a char). Unicode characters can be more than one byte, the utf-8 encoding doesn't specify a fixed character length, you can have characters of 1 byte, 2 byes, 3 and so one... if you want to read one character (and not one byte) you should use other functions.
&gt; if pointers are defaulted to set to NULL how come some programmers, and in the code above, we explicitly told the pointer to point to NULL? Pointers aren't set to NULL by default. This happens just in some specific cases. For example, if you declare a local variable like we do all the time: int *p; That pointer doesn't get initialized to NULL by default. So if you want that, then you must set it up yourself: int *p = NULL; It's just that in some cases, like with static storage variables, or with the array case, that you get that "zero if nothing else is specified" behavior. Some people don't like to rely on that aspect of the language though. As to the reason some people think like that, you'd have to ask them. I've seen some people saying "Not everyone knows about this, so I'll zero this variable even though I don't need to do it." 
It depends on what device you're outputting to. I assume you mean clear a text console? If that's the case, you could probably get away with sending the [right escape sequences](http://bluesock.org/~willg/dev/ansi.html) to the terminal. `printf("%c[2J",27);` will clear a VT100-compatible terminal, though it might not reset the position of the cursor. A library like [ncurses](https://tldp.org/HOWTO/NCURSES-Programming-HOWTO/) would allow you to build a terminal-aware application which can adapt and Work Right™ on various different display devices, though this would introduce overhead that might not be worth it in your case.
For a console window, there's clrscr() from conio.h, which should work in devcpp being that it uses MinGW - but is a non-standard function so don't count on the code being portable.
Thanks for the tip! you explained it nicely, and yea movsb was just an example
Im far from skilled in C, but ill reply since noone else did. double array[size]; I think this will allocate memory on the stack? It will disappear when the function returns. Instead you could have double *array = malloc(blabla); which will allocate on the heap. This can be returned as you allready do return array; Be carefull to free that memory when you are done
Returning an array is uncommon. Before explaining why, I'll say that there are two actual ways to return an array from a function: 1. Have that function allocate the memory for the array on the heap (via `malloc`) and then return a pointer to that array 1. Wrap the array in a `struct` and then return that struct (by value). This is awkward and also typically a very expensive operation, as it requires the array to copied from one stack frame to another (i.e., the entire contents of your array are copied). Some platforms have an ABI which pre-allocates room in the caller's stack frame to allow an optimization which avoids the copy, but it's still awkward. So those are 2 ways to actually return an array, but neither of them is very good. The problem in C is that you must manage your own memory. You can't just make (or return) an array: you have to say *where* in memory that memory is going to reside. Option #1 mandates the heap, which may not be what you want. Option #2 mandates the stack, which may not be what you want. Typically, when you want to "return" an array, what you would do is force the caller to allocate the array and then pass a pointer to that array. This is very efficient (no copying from one stack frame to another) and, more importantly, it gives control of memory management to the caller. Your function will be agnostic as to which region of memory the array is allocated in, which makes it more useful. In your case, that would look like: void selectionSort(double *array, size_t size) { } void makeArray(double *array, size_t size) { int i = 0; double num = 0.0; // ... } int main(void) { // .... double array1[size1]; makeArray(array1, size1); for (size_t i = 0; i &lt; size1; i++) { // ... } // ... }
 int Encounter(int enc_r, int enc_m, int enc_t, int enc_d, int enc_b); You've declared the `Encounter` function to take 5 arguments Encounter(enc_b); Encounter(enc_d); &lt;...&gt; Each time you call it, you're only providing 1 argument.
Since points 1 and 2 are covered already, I'll add the third one which has been omitted: Three: Make it static: type *function( type arg, ... ) { static type array[ BUFSIZ ]; .... return array; } You'll need to be sure to take care of your data, because a sequential call to the function will possibly overwrite it.
I tried it on gcc.godbolt.org, and it seems GCC translated the call to memcpy into `rep movsq`, and also inlined the call to f_a(x,10,10), even when the call to f_a is quite expensive (including a call to sin and conversions between int and float). https://godbolt.org/g/cZ2bF5
The problem is how you allocate the array: if you write `double array[size];` you are allocating the array on the stack, that means that when the functions terminates, the array gets freed and you will return a pointer to a location that will probably be overwritten by subsequent stack memory allocations. To do this properly, you must allocate the array on the heap, using malloc(), like so: `double *array = malloc(size*sizeof(double));` malloc() takes as argument the number of bytes to allocate, in this case the size of the array multiplied by the size of a double (size*8 bytes), and returns a pointer to the allocated memory. You must also remember to deallocate the memory you allocated with malloc() when it's no more needed, to avoid memory leaks: the C programming language doesn't have a garbage collector, you need to free() the array when you finish using it: in your case you must add a free() in the main, after the cicle that prints each array, like so: free(array1); and free(array2). It's very important to always remember to free the memory you allocated.
wow cool thanks! I did the gcc -S but it was kinda hard to read the output. 
What benchmarks are used to test the code? It's very hard to optimize an allocator for an unknown but definite usage pattern.
The included, linked benchmark (https://github.com/codr4life/libc4life/blob/master/tests/malloc_perf.c) is used. It's simply a loop allocating and releasing a large number of random sized blocks.
No money, sorry; there's enough focus on money in this world as it is. I'll just mention that it's a pretty lousy indicator of what is worth pursuing in life and leave it at that :)
It's not so lousy when you have real responsibilities and no extra time to spare.
Okay, don't do that. You should only declare a variable once. What you're seeing is that the while condition checks the first variable, but the loop body sets the second variable. So you're not looking at the same thing in your loop body and loop condition
If you are not optimizing for the real world, then what are you even doing?
Okay thanks for your info.
Your code appears to be C++ code. Please ask questions about C++ in /r/cpp_questions. I have removed your thread as it is off topic.
it probably is not that they were terrible, but that they have to be good generally, which means particular scenarios will suffer.
I was thinking the same but the scenario I had in mind is to not use synchronization mechanisms if the program is definitely single threaded. 
If you want to read a line, use fgets(). 
The problem is you have specified "%s %s". This basically means: "Read a string (stop at any whitespaces) until a space character appears, then, read another string (stop at any whitespaces)" If your in.txt file doesn't contain any spaces, like this: this_is_my_key this_is_my_message Then you can use: fscanf(in, "%s\n%s", key, msg); This would mean: "Read a string (stop at any whitespaces), then there will be a new line, then read another string (stop at any whitespaces) If your in.txt file do contain spaces, like this: this is my key this is a message Then you can use: fscanf(in, "%[^\n]\n%[^\n]", key, msg); This means: "Read a string up to a new line character, then there will be a new line, then read another string not containing a new line character
How about this: http://vicsydev.blogspot.de/2016/11/the-malloc-challenge.html ? I'm serious; give it a spin. Start from one of the existing allocators and change something, instant feedback is a good teacher.
The "bug" would be in puts, it expects a null terminated string, and was probably running into garbage #include&lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { char message[50], encrypt[50], letters[27]; int len,i; for(i=0;i&lt;26;i++) { letters[i]='A'+i; } letters[26]='\0'; puts(letters); getch(); return 0; }
Your string `letters` is not being NUL-terminated. You're loading it with 26 characters, leaving no room for the `'\0'` that signals the end of the string; so when `puts` tries to "read" it, it reads right off the end, and in the two tests you ran, what happened to be behind it were the strings `"@"` and `""` (both properly NUL-terminated).
A lot of this type of quizzes are posted here and it's always just niche cases that a sane programmer wouldn't encounter anyway. I knew about half the answers, but learned nothing useful.
 int i; Node *head=NULL, *current, *previous=NULL; for(i=0; i&lt;100; i++) { current = malloc(sizeof(Node)); current-&gt;data = randInt(); if(!head) head = current; if(previous) previous-&gt;next = current; previous = current; } 
yes, i just wasn't sure how to implement it 
To answer the second part of the question (how do I run them at the same time): ./writer | ./reader The thing in the middle there is the "pipe" character, and means to "pipe" the standard output of writer into the standard input of reader.
When I do this, writer.c never stops or allows me to type ./reader so that it can run the next program and make use of the pipe. 
That is weird advice. If you look at the examples, it's using named pipes that are completely built in to the the binary.
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef struct node { int data; struct node *next; } Node; Node * insert(Node **head, int data) { Node *new = malloc(sizeof (Node)); new-&gt;next = *head; new-&gt;data = data; return *head = new; } int main(int argc, char *argv[]) { Node *head = NULL; insert(&amp;head, 1); insert(&amp;head, 1); insert(&amp;head, 5); insert(&amp;head, 10); insert(&amp;head, 15); printf("Contents of list:\n"); for (Node *cur = head; cur != NULL; cur = cur-&gt;next) printf("%d\n", cur-&gt;data); } 
Good point about it being not multithreaded. I have recently written a multithreaded malloc implementation (highly inspired by Hoard) and it took more than 100 hours with a partner. There is definitely a lot more to consider when you have problems such as synchronization, false sharing and "blowup".
Depends on your current level of understanding. I would first get a good handle of C and OS. Afterwards, you can read up on various memory allocators and implement your own.
I'll be honest: I didn't bother to read the code. He didn't mention that they were named pipes in the post title and a trivial first example with standard pipes would have worked with what I posted. I guess I jumped the gun being lazy on this one.
Can you identify which bits are repeating?
Could you walk me through your code? We only just started covering LL yesterday 
Actually, I'm not. There is no such thing as a one size fits all solution when it comes to things like developing an allocator. It really has to be tuned to fit the workload and usage pattern. In my experience, memory allocation and access patterns often are completely dominant in solution performance, but you can't optimize them without knowing what the pattern is. That's part of why there are so many different allocator strategies out there, and different implementations. Different approaches work well for different needs. The workload you described in your benchmark harness is so far from anything like a real world scenario, that anything like a real world allocator would underperform trivial techniques. I could create multiple arbitrarily complex allocators with different design tradeoffs, but all of them would fail to be utilized effectively by this test engine. As C programmers, we generally care about the last few percent of performance. It makes little sense to describe a general solution to an abstract problem, especially in C. With a given workload, or access pattern, we can begin to devise an allocator that is novel in useful ways. By way of analogy, "design a hammer" with the sole context of "it has to be able to hit nails" doesn't really inspire much in terms of the hammer design. A rock suffices. When we know things like whether we are trying to drive finishing nails or framing nails, we can start to create a design with meaning. As described, I just feel the problem statement is too broad to give rise to a meaningful solution.
OK so try wrapping something like that in a loop and see what happens. I'll be here to help if you need more *pointers*.
The "for-each" loop you have in the pseudocode at the end is part of higher-level languages, but not a part of C. To loop over an array in C, you need to be a little more explicit. Try something like: for (size_t i = 0; i &lt; 3; i++) { if (array[i] % 2 == 0) { // if array[i] is even array[i] = 0; } } I think your second question is asking if you can check for `i % 2 == 0` (`i` is even) instead of `array[i] % 2 == 0` (the element at index `i` is even), which is fine. Multi-dimensional arrays work the same way. If you want to iterate through all elements in a 2D array, you would use 2 (nested) for-loops. There's a bit of awkwardness in C regarding how you know how many elements are in an array. You can see in the for-loop example I gave you that the number 3 is hard-coded. If the array is in scope, you can use the `sizeof` operator to figure out the number of elements in an array (e.g., `sizeof array / sizeof *array`), but it's common in C to access arrays when you only have a pointer to them, in which case the `sizeof` trick doesn't work. Honestly, until you get comfortable with arrays and pointers, I think hardcoding the length of the array in your for-loop is fine when you're just messing around. (Others might disagree)
Yup, those things are possible! The usual way to figure out if a number is even in C is to use the mod operator (%). You can easily use it with either the value in the array, or the counter variable the for loop uses. In C, you tend to be handed pointers to contiguous sections of memory, rather than fully defined objects. I.e. Those 2d and 3d arrays are really just giant blocks of memory. And any giant block of memory is something C can walk through as a 1d array. These questions sound a little homework-ey. What're you up to? : ) Cheers!
Thanks for the response! Not actually homework questions (sadly I'm a bit past that point of my life!) working on a path finding algorithm in my spare time and wondered if I was going to have to write a for loop to iterate over each element of the array! 
I did this, and it wrote "Hi" twice. But thanks.
&gt; if (array[i] % 2 == 0) What a waste of time, why don't you just if(!(array[i] &amp; 1)) instead. /s
Gotcha. It's just rare to have such clearly defined, well-thought-out questions : ) And yup, for loops are the usual way to iterate over arrays in C. I work with a lot of 3d arrays in my day job. There's two major ways to do it. As a 3d array: int *Array = malloc(sizeof(int)*SizeX*SizeY*SizeZ); //Weird lack of intending is my own style that I use exclusively for multi-d arrays. for(x = 0; x &lt; SizeX; x++) { for(y = 0; y &lt; SizeY; y++) { for(z = 0; z &lt; SizeZ; z++) { Array[x + y*SizeX + z*SizeX*SizeY] = x+y+z; }}} As a 1d array: int Size = SizeX*SizeY*SizeZ; int *Array = malloc(sizeof(int)*Size); for(i = 0; i &lt; Size; i++) { Array[i] = 2; } In the first example, we have to use the 3d method because the thing we're filling the array with (x+y+z) depends on the 3d position in the array. In the second example, we can drop down to treating it as a 1d array because nothing depends on the 3d position within the array. Since simpler code is easier to read and reason about, I tend to prefer things like the second example when I can. Cheers! Edit: Boy reddit's code formatting sucks!
Seems pretty ridiculous, this is for some kind of a school requirement? Hint: you can increment and decrement a pointer without using any digits. 
Yes, its a school requirement. (:p) So, p=arr and then a loop with p++'s? Theoretically speaking.
I did this: p=arr; p++; p++; p++; for (p;p&gt;=arr;p--) printf("%d ", *p); Do I stand correct?
Thank you and I agree. It might be useful for him to understand this. It seems like it helps to try to read and understand code that is just a little beyond your understanding. Maybe it'll just confuse him though.
This is an excellent answer but I would suggest the following. The code below eliminates the check for head == NULL and prevents having to keep track of previous. Node *head = NULL; for (int i = 0; i &lt; 100; i++) { Node *cur = malloc(sizeof(Node)); cur-&gt;next = head; cur-&gt;data = randInt(); head = cur; }
Looks good, you could also use this (then it doesn't matter how big the array is), and judging by this assignment, the teacher might say something like: "aaah, but what happens if I extend the array to contain X elements instead" :D p = arr + sizeof(arr)/sizeof(int); p--; for(; p &gt;= arr ; p--) printf("%d ", *p); 
Yes. You're damn awesome. That was what I was thinking too. Thanks a lot buddy!
Aight, but you're still missing the point :) I agree with what you're saying; building a general purpose, system level allocator is very tricky. Which is why I'm proposing that we spend our energy elsewhere. The idea I'm pushing is building a stack of more specialized allocators, and letting the user combine the ones that makes most sense for a specific use in a specific part of the software. And the reason I launched the challenge was to find out how far that idea will take us.
Same here. BASIC text adventure game with absolutely no knowledge of data structures, not even arrays.
I mean the Linux Kernel is the first thing that comes into my head and for obvious reasons I'm at a loss as to why they would state things like that. The worst thing is that they don't offer any reasons as to why. The only possible reasoning I can think of is that they are trying to suggest that higher level languages might be better for a large program for whatever reasoning. 
I think the textbook's statement is fair. Linux is written in C, but that's mostly because C is the best (arguably, at least a very good) choice for writing kernels in, not because it's the best for managing tens of millions of lines of code in. You *can* write large codebases in C, but it requires skilled coders with discipline. Sad is it is to say, a lot of large commercial products these days are not written by skilled coders. I think a number of development teams today would find difficulty maintaining large codebases in C. Obviously these are not the sorts of development teams that would make a kernel, but that's no matter. Even amongst skilled coders, I suspect (I have no numbers to back it up) that C would require more development overhead (communication, code reviews, QA) than some higher-level languages.
Would c++ be one of these other languages? Or others like python? 
Props for guiding without feeding the answer!
I may have been missing your point; if so, doing so was not deliberate as suggested previously. The thing that you are advocating makes broad sense as a thing to pursue: a suite of allocators built around specific strategies to offer flexible choice for meeting a given application need. The problem is that you need a variety of different workloads to test and showcase the effectiveness of such an approach. Ideally, there would be multiple different benchmark tests, each with different allocation/deallocation patterns. Then, a crafty developer could attempt to analyze the workloads of the different benchmarks, design novel solutions to allocation challenges posed by each of those patterns, and compose the allocation functions in clever ways to solve the needs of each. The fact that there is only one, very trivial, benchmark means that it is impossible to draw any conclusions about the advantages of composability or flexibility in allocator choice. The one benchmark that exists uses randomly sized allocations, *never* needs to grow or deal with the possibility of fragmentation, etc. It's difficult to imagine an effective way to creatively solve this via various allocator strategies and actually demonstrate any kind of success. In practice, any kind of clever behavior added will just be slow for this trivial workload. I guess what I'm saying is: if you want to explore the thing you state you're trying to explore, there needs to be a robust suite of tests that exercise allocators differently.
They are command line arguments (the first represent the number of arguments, the second an array of strings, each of which is an argument), for when you call your program from a command line. But since he doesn't make any use of them, he could as well have written: int main(void)
&gt; You write a kernel in C because you have to, not because C offers the best experience for large projects. The Windows NT kernels are written partially in C++.
Disclaimer: I'm by no means a professional programmer, amateur at best. Feel free to correct me if I'm being an idiot anywhere. Thst all said, in my opinion what he means by this is C does not provide a lot of the frameworks and standard libraries that make managing large programs easier in other languages. For instance, in c a lot of useful data structures need to be implemented by hand. And while that might be simple for smaller programs, for large ones this can mean dozens of functions and files and stuff that all needs to be implemented, and maintained so that changes other places don't break their functionality. While all of this is possible in c, languages like java, Python, etc just hold your hand through it a little more, and you don't have to write as much to get the basics working. 
One of the biggest problems with C IMHO is the tiny standard library leading to inconsistent reimplementations of lists/vectors/queues/stacks argh!
I would say that higher level languages offers you the ability to write code in a somewhat different way which might suit some projects better. Higher level languages don't deal directly with memory management for example. In some cases you don't need or want that, which could be one reason to use a higher level language. Examples could include the backend code for a website. Here, PHP is popular language since it's geard towards web development Another example would be to use Java when developing an Android app
Well, to be fair. It's not only in C you have to take care writing your code. You can write buggy and insecure code in basically all other languages. I don't think this is what the author meant
That's probably true. On the other hand, the tools and libraries available to C programmers (debuggers, static analysis tools, code generators) is second to none, and probably for that exact reason. So at the end of the day, I'd say that the tools to write big systems in C exist, even if they're not in the language itself.
I wonder, do they suggest a language that *would* be suitable to write big programs in?
This is the best solution in relation to how idiotic the assignment is. It will be like giving the teacher who came up with the assignment the middle finger :D
&gt; My understanding is that a good programmer will use a language best suited for the task at hand. With the amount of PHP I've come across my entire programming career^1 , you'd think I've never met a good programmer. Whatever you do OP, don't do what I did, don't settle for mediocre jobs or work with mediocre people, it'll drain you. ^1 : I get the dregs of the job market and I blame myself mostly
You could restructure your program into something like this for example: #include &lt;stdio.h&gt; #define _CRT_SECURE_NO_WARNINGS void main() { int x, y, z; char type; type = 0; while(type != 'u' &amp;&amp; type != 'U' &amp;&amp; type != 'd' &amp;&amp; type != 'D') { printf("please enter 3 numbers and -u- or -d-\n"); scanf("%d %d %d %c", &amp;x, &amp;y, &amp;z, &amp;type); printf("\n\n\n"); } if (type == 'u' || type == 'U') { printf("%d\n%d\n%d\n", z,y,x); } else if (type == 'd' || type == 'D') { printf("%d\n%d\n%d\n", x,y,z); } system("pause"); } In this example, the while loop will not exit until type is either d, D, u or U
I'm not saying you should get into the habit of ignoring warnings but ...
I wrote this, and it works for me { "shell_cmd": "gcc $file_name -o ${file_base_name}", "selector" : "source.c", "working_dir" : "$file_path" } 
This is the most irritating thing, not only do the not suggest a more 'appropriate' language they don't even give any specifics on their assessment as to where specifically C falls short. There's been lots of answers in this thread that have cleared things up though. Just strange that a printed book would choose to not expand on such a statement. 
Oh god. Of course you're right. This is a stupid assignment. It seems like they're trying to coerce a recursive solution out of the student.
The problem is that sometimes I'll type in something I've used a million times. And I'll get an error on hacker rank, and I won't know why. So I'll keep looking for an error I made, but its just that the library isn't there. GetInt was literally the second function I ever learned, right after printf. When I got an error I thought I must have done something wrong, because it never occurred to me that GetInt could not be supported. In my knowledge it was a fundamental function. So to avoid this kind of problem in general I would like to add this library to my challenges somehow.
Why not just use scanf in stdio.h ?
Which is why I like /u/gnx76's answer :D https://pr.reddit.com/r/C_Programming/comments/5d5dxt/need_some_help_fellow_c_experts/da247ef/
C and surrounding ecosystem of tools is a fantastic to learn and timeless. To your original question, it is definitely used in large projects. [Toyota use C for accelerating/braking in cars](http://www.edn.com/design/automotive/4423428/Toyota-s-killer-firmware--Bad-design-and-its-consequences). I would consider that a life-critical and very significant project. Anyway, good luck in your journey to learn. At some point, [check out Olve Maudel's deep c slides](https://olvemaudal.com/2011/10/10/deep-c/). They're quite fun to go through.
You're relying on a Harvard specific library. Hacker rank won't have it installed. Look at and learn the actual standard library, since that's the only thing you can actually rely on having, and it's what everyone should know how to use.
And i like how most of these cases would never occur if someone is using sane and clear coding style.
&gt; is no better or worse than a bad C one I dunno, I'd take a bad C program any day over a bad C++ program. There's only so much rope you have to hang yourself with in C.
Care to mention the books in which you've seen the original claim?
K. N. King C: A modern Approach and Sams Teach yourself C. I don't rate the latter book at all but I just recall seeing it in there when I read a similar statement in K.N.King. 
I'm not sure if any language is "suited for" large programs. However, I'd agree that, if you have a choice of languages for a project, C is usually not the best choice. Thus, C tends to get used either because there is no real choice (e.g., low-level code where C has almost no competitors) or just by tradition (e.g., a lot of \*nix tools, which are traditionally written in C). I work on embedded VoIP and networking software. We write the full stack: RTOS, C library, network stack, high-level libraries, application. We use C because some of the components (like the network stack) we sell individually, and a lot of compilers for lesser-known embedded processors *only* support C, not even C++. That and people want a C API for a network stack, so implementing it in the lowest common denominator makes sense. But when it comes to the application-level stuff, boy it sure would be nice if we could use something other than C. I would kill to have real objects and inheritance in some of our application code, because it would save us a lot of coding if we could make the OO system do some heavy lifting for us automatically. But without rearchitecting things significantly, we're stuck with C.
All you work on there is well above me, but, say if you had your ideal scenario... with some object oriented stuff to handle pieces for you, to what scale would the work be 'easier' for you and what C workload would be replaced? 
Thanks.
 #include &lt;stdio.h&gt; int main(void) { int arr[] = { 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 }; int *p = arr + sizeof(arr)/sizeof(int); p--; for (; p &gt;= arr; p--) { printf("%d ", *p); } puts(""); return 0; }
When doing the finite state machine approach: You should decide in the beginning if 10010010 in that example counts as one (easier) occurence or two (more difficult).
True, I suppose.
Assuming we were implementing everything from scratch, instead of maintaining existing code, here's what we'd end up with: * RTOS: C is the obvious choice. You have to do a bunch of low-level stuff, and you don't have anything beyond a primitive object system yet (plain objects are fine, but no run-time type information and dynamic casting, and no `new` or `delete` because in at least part of the RTOS you haven't implemented the memory allocator yet). * C (and C++) library: Obviously has to be in the respective language. * Network stack: C still makes sense here. The standard Berkeley sockets API is a C API. You want your network stack to be extremely fast and efficient and compact, so this is a situation where the overhead of OO is really not worth the price. * Audio algorithms: C or C++ would both be fine, since these are purely compute-intensive, but the reference implementations all tend to be in C. * Voice engine: C++ would be nice to have here. We describe our system in terms of OO (objects with inheritance: there's a parent class `Channel`, and subclasses `AnalogChannel` and `DigitalChannel`, and subclasses of some of those), and it's kind of implemented that way internally. But the internal implementation is clumsy. A real OO system would just make it nicer and easier. * Network protocols: C++ would be a *huge* help in some of these. String manipulation in C sucks; using something that's more sophisticated than stone-age tools would make things easier. Automatic memory management (i.e. reference counting with `shared_ptr`) would eliminate a lot of tedious memory management and sources of leaks. * Call manager, and related application libraries: Automatic memory management would be a huge help here, too. OO would also be nice, because what we have is fundamentally OO anyway, just expressed in C. * Applications: This is the one place above all where OO would really help us. We have a lot of similar applications (intercom with protocol Q, intercom without protocol Q, intercom with door lock, intercom without door lock, etc.), but right now they're all fairly separate. We end up with a lot of code that's either hauntingly familiar, or straight up copy-pasted and then slightly modified. It would be great to combine these all into one sort of master application that is capable of doing all of those things, but without being required to do any. OO could be great for that: you can have arbitrary events and objects without knowing their type in advance, and either handle them or ignore them as appropriate, without needing to bake all that logic into every single file at compile time.
Are you working with video? I would be surprised if you need to go through the trouble of getting YUV-space values for SDL or Qt unless you need to. How you structure your output also depends on the consumer, for example, it isn't uncommon for some libraries to want all image data as one contigous chunk. So it depends what library you want to use. Frankly I think the easiest to concern yourself with would be getting RGB (sRGB) running, then you can write different output functions. It would be the quickest route to get something working :) 
It's possible without a FST. Using the naive approach: look at the first symbol if that matches then continue checking the whole needle (needle = string to search for). If we reach the end of the needle then we're done, but if not then we have to push back all the characters we have read (`ungetc` won't help you since the standard guarantees only 1 character pushed back, it's only useful when you have to do a 1 char lookahead). So we'll have to build our own stack from which to push/remove symbols. The only problem is that the stack should be at least as big as the length of the needle, but the FST has the same problem since you need at least as many states as characters in the needle. [Here](https://gist.githubusercontent.com/anonymous/24ef7c495d25ff0222909fa7b4364e47/raw/ce360c21f4f892da30fe0f6aa63ec453787d112c/search.c) is an implementation 
It is convenient to write kernels in C, but for virtually every major language that is compilable to native binaries, there exists a fully-functional kernel written in that language.
Can you post your complete code please?
so it was found in /usr/include/gumbo.h However, when going there I don't see the file. 
 sudo apt-get install libgumbo-dev solved my problem thank you very much :) 
 int main() { pid_t pid; pid = fork(); if( pid &lt; 0){ perror("fork error"); exit(-1); if(pid != 0);{ wait(NULL); } else{ execl("/bin/echo", "echo", "Hello, World", NULL); } return (0); } This program hangs. Edit: this doesn't hang. I don't understand what I'm doing differently from this. 
the program does compile, I was just trying to speed type it. And that program doesn't hang, and now I'm even more confused because my program hangs and this doesn't, yet it's virtually the same. edit: outside of that syntax error I typed when typing it on here
Try putting wait(NULL); at the end of your code. Not in your default case. Edit: you also don't need to break out of the default case since it is the end of the switch. 
I don't even see what you're trying to do there. You're forking a process and if the fork fails you just print an error and continue with the execution of the rest of the program? I don't know what you're doing, but I would bet it's a bad idea in your case. So the child process will execute a different binary and after that you terminate the child process and return EXIT_FAILURE? Why? I also hope you are waiting for the child process to terminate somewhere further down in your code as you don't want to have orphaned processes. You're not even doing inter-process communication, so why forking a process to begin with there?
Notice that the vulnerabilities listed aren't inherent of the C language, but of the C standard library which can easily be bypassed. 
I am using a named pipe, again this is for a school project so I couldn't post all my code. Secondly, I return EXIT_FAILURE because sometimes the fork can fail, and I should return that to show that. Also, when you use execv, if it runs it will never return, meaning EXIT_FAILURE won't run if it's successful. &gt;I also hope you are waiting for the child process to terminate somewhere further down in the code as you don't want to have orphaned processes. This is what the post is about. Where do I wait for this? How do I do it? I've provided an example in my other comments showing that it works, but for some reason my program doesn't do that. I'm not sure what's going on with it. 
Let me show you a little idiom I'm rather fond of: p = arr + sizeof(arr)/sizeof(arr[0]) This way, if someone later modifies the code, e.g. changing arr[] from int to long, your code doesn't break in subtle ways that take forever to debug.
To the people criticizing this assignment: I'm not so sure the assignment *is* idiotic. I think the teacher is trying to teach the students to avoid using "magic numbers" that can burn you later. int arr[] = {10,20,30,40}; int i; /* 100 lines of code later... */ for (i=3; i&gt;=0; --i) printf("%d\n", arr[i]); Now supposing after you've left the company, some other poor sucker inherits your code, and innocently changes arr to `int arr[] = {10,20,30,40,50}' Do you see how much grief you just caused the poor bastard? Most places I've worked would not let that code pass code review.
Which is, AFAIK, not redefining a macro (="reusing a name"), but assigning different macros the same value. But I see the point now.
True, but the context of the question was why are enums better than defines. ~~An enum wouldn't let you make that mistake~~. Never mind; I just tried it. It totally would. Disregard what I said.
Fair enough. You can use `*arr` instead of `arr[0]` instead.
&gt; after that you terminate the child process and return EXIT_FAILURE? Note that `exec` *replaces* the process with another one, so the `return` is never reached if `exec` succeeds.
The compiler is allowed to insert arbitrary amounts of padding between any two struct members and after the last struct member (but not before the first member.) It does that to get the necessary alignment. Alignment is always platform-dependent, but you can usually assume that each member will have its natural alignment, which means it will be aligned to its size. Assuming sizeof(float) == 4, a float will therefore always be at an address that's a multiple of 4. That means the compiler has to insert 2 bytes of padding after `uvar3` so that `uvar4` has the required alignment. If it didn't, then `uvar4` would start at offset 14 from the beginning of the struct, assuming sizeof(short) == 2 on your platform. That would mean that if you made an array of this struct, there would be no way for each of the `uvar4` fields to be aligned properly; the only way that can happen is if the offset from the start of the struct is a multiple of 4. (And the total size has to be a multiple of 4 as well, which is why the compiler is allowed to add padding after the last member; in this case that's not necessary.) 
Post a minimal, compilable bit of code and explain more what you're trying to do?
Use gdb to backtrace on the segfault. You can also inspect variables at the time of error.
&gt; gdb Im not sure how to use this. I have narrowed the error down by commenting sections of code to the line setting certain values to 1. What is gdb and what can it do? 
Ahh, I assumed it was something like this. How the hell did this ever work? 
The issue is in the condition of your for loop. Arrays, as you have noticed, start with index 0. That means if you have an array with the size of 300 the last element is a[299] and not a[300]. Since your condition in the for loop is n &lt;= y (or i &lt;= x in the inner loop) you will write to non-allocated memory and therefore produce a segfault. What you likely want to do is: for(n = 0; n &lt; y; n++) { for(i = 0; i &lt; x; i++) { if(i == 0 || i == x - 1 || n == 0 || n == y - 1) { areanaMatrix[i][n] = 1; } } }
Also any advice on tidying up the code would be much appreciated!
Interesting, This is running on a raspberry pi so I'm assuming the stack is very small. Someone else has mentioned that its actually my for loop using &lt;= instead of &lt; thats causing it and changing that has fixed it. I have heard of malloc before but Im struggling to understand it or get any of the examples I can find to run! I think I lack the understanding of pointers too which an issue. 
gdb is a debugging tool present on most *NIX systems. It allows you to step through the code as it is executing, which will allow you see exactly where it fails. If you're on Windows, you'll be able to do this sort of thing in an IDE like Visual Studio.
&gt; . Currently I am able to upload three 'starting grids' i have manually defined in main but am not able to upload their children despite using the same function 'Insert'. What's that mean? You never describe what is actually wrong. You also don't ever actually call Insertchild. Finally, the two functions aren't the same. One takes a pointer as its first arg, and the second does not.
Ah sorry! The three starting grids are the Cells called first, second and third. Insertchild isn't actual/y necessary to the code. I should not have included it! My problem is that when I run the code and try to read the queue the first three elements of the queue print out fine. However the rest (the 'children' of the first three cells which have now been added onto the back of the queue) are printed out as addresses rather than 3x3 arrays and I cannot work out why since I am using the same function 'insert' to load them into the queue and the same function to print out elements of the queue.
Shit, that's a good point. I wonder what would happen in that case? I guess it's not an issue on our modern flat-mapped virtual address systems because address 0x0 is reserved for the null pointer, so the largest possible object is 2^32 - 1. But if we were to go back to the 8086 and implement the C99 types, what would we want `size_t` to be? 16 bits, and sacrifice 1 byte? (Maybe restrict the compiler so you can't actually have an object that's 65536 bytes long. Makes it awkward to `mmap()` large files, though, since you can't work in nice 64KiB chunks.) 32 bits, and it's larger than you typically need? (Although it does allow you to use "huge" pointers that are normalized so you can act as if you have a flat memory model.) Both, with a compile-time option?
Great code! A couple of remarks: * `SIGWINCH` is not defined with `_POSIX_C_SOURCE` on some platforms (like FreeBSD) as it's not a POSIX function. * Don't set the variable `CC` and `CFLAGS` in your Makefile. By default, `make` fills these with reasonable default values. For example, on my system there is no `gcc` binary, so your code doesn't compile out of the box. * I get this warning when compiling your code. Is this intentional? cc -O3 -DHX_GIT_HASH=\"\" -DBSD_SOURCE -DNDEBUG -Wall -c editor.c -o editor.o editor.c:260:13: warning: comparison of unsigned expression &lt; 0 is always false [-Wtautological-compare] if (offset &lt; 0 || offset &gt; e-&gt;content_length) { ~~~~~~ ^ ~ Otherwise, the program is very nice! Good code and well documented. I love it.
Your code is quite well-written and well-commented, which makes it very readable. From what I saw, I don't have a lot of comments other than this: https://github.com/krpors/hx/blob/master/main.c#L94 In your signal handler you call the function clear_screen https://github.com/krpors/hx/blob/master/main.c#L94 which itself calls snprintf. It's usually not a good idea to call C library functions in a signal handler for various reasons, mostly undefined behavior. This could happen because the signal can be caught in a place of the program that it's not safe to return the flow back to, when the signal handler exits. You can never be sure of the implementation of library functions and how they handle those situations, so it's not considered a good practice in general. It's better to rely on low-level system calls like write/read for that matter. There's a list of Async-signal-safe system calls which are set by various standards (SUS and POSIX) if you look here http://man7.org/linux/man-pages/man7/signal.7.html You also call ioctl in your signal handler which is not on that list. Another thing is, if you plan on handling globals inside your handler it's better to declare them as a `volatile sig_atomic_t` type. Other than that your program looks pretty good and well-written code like that can be easily expanded. 
Do not assume that `stdio.h` defines `STDIO_H` when included. That's not portable. Same for the other headers. Other than that, the code has an acceptable amount of commentary and looks pretty readable despite the high amount of macro usage. One thing you might want to pay attention to: Your code uses many identifiers. User code might use some of these identifiers as macros, breaking your macros. Consider using reasonably unique names (e.g. `fa__len` instead of `len`).
I see, is there a portable way of stopping double inclusion of standard libraries then? Did I miss the point of include guards? On the second point, thanks for the tip, I shall commit changes to the identifiers later. 
In `editor.c`, function editor_openfile(), you calculate the file size this way: // go to the end of the file. fseek(fp, 0, SEEK_END); // determine file size long size = ftell(fp); // set the indicator to the start of the file fseek(fp, 0, SEEK_SET); But just a couple of line before, you've called `stat()` on the file, so you could just use your `statbuf` structure to read the file size, it should be in `statbuf.st_size`. Or was there something wrong about it? ------------------ if (fread(contents, size, 1, fp) &lt;= 0) { perror("Unable to read file contents"); If `fread()`'s return value is between 0 and `size`, it also means a problem occured (not everything could be read). You'd better test: if (fread(contents, size, 1, fp) &lt; size) { (BTW, `fread()`'s return value is not signed, so testing it with `&lt;= 0` was the same as testing with `== 0`.) ------------------- e-&gt;filename = malloc(strlen(filename) + 1); strncpy(e-&gt;filename, filename, strlen(filename) + 1); Calling `strncpy()` this way is the same as just calling `strcpy()` :-) 
The C standard library is guaranteed to have include guards, just include standard library headers, if they have already been included, nothing happens.
I see, thank you again. :)
&gt; If fread()'s return value is between 0 and size, it also means a problem occured (not everything could be read). You'd better test: A short read is not a problem and does not indicate an error. Instead of bailing out on a short read, OP should instead only process as much data as the read returned before going on with the next read.
Absolutely... If you are writing a library that you expect others to link to... Use C for your API. If you don't, then your C++ API method name mangling will be compiler specific and be a pain in the butt to anyone not using your exact compiler... i.e. If you compile with mingw and distribute, and I use Visual C++ and try to link to your library... it won't work.
Interesting, what's the cause of problems like this with C++?
I do weekly assignments, as well as 6 larger projects throughout the semester. Its a fair bit of programming in C, could be more of course. The projects are what are mainly causing me concern. Its mostly stupid stuff but it gets to me. I'll try to implement some functionality in C that I can do in Java no problem and it will be full of problems that I just am not catching in C.
Interesting! Thanks for that link
There is one key advantage C has over C++. It rarely matters nowadays, but... C las a much smaller runtime library than C++. You can often reduce this significantly in C++ by limiting the feature set you use (e.g. Disable exceptions and RTTI), but C only needs a couple of hundred bytes for its runtime.
C is pretty much the simplest language that's widely used. C++ is probably the most complicated. It only takes a year or so of constant use to get really good at C. It's harder to get started with C, but once you learn the basics and have some time to actually dig into the spec, it's relatively straightforward. 
Lower cognitive burden. Not that C's is low to begin with, but IMO C++ has SO MUCH TO IT. C++ let's you get pretty creative, which can be difficult to maintain. Some days I like it more but more often than not I like to keep it simple, stupid.
The larger a project gets the more a strong type system helps you refactor and maintain (it will help you feel more confident that you're not breaking a bunch of things, but compiler checks and unit tests aren't substitutes). C's type system is certainly stronger than a dynamically typed language, but still leaves a lot to be desired. Implicit conversions and undefined behavior land mines don't help. Lack of memory safety is a blessing and a curse. Writing properly multithreaded code without compiler help is literally juggling knives. So many security exploits (job security). Also, would depend on the constraints of the program. I honestly don't think of pointing at Linux, a god damn OS, and saying "that's big, therefor you could/should write apps in C" is a good idea. Just because C is universal and can be used doesn't make it the best tool for ALL jobs.
Some days, I'm happy that I can choose whether I want my lists to intrusive vs extrusive or which allocation strategy to use. Other days I just want a god damn hash map.
&gt; All of Google's core code is written in C++ How "core" are we talking? Google3 is pretty diverse. I'd say there's almost equal amounts of C++ and Java (with Go catching up). &gt; Android is about half Java, half C++. Don't forget the Linux kernel! Also, I think you're being generous to C++ with that estimate.
Note that the POSIX API was available on Windows as a part of the Windows Services for UNIX (SFU) but these have been discontinued and were not available for standard Windows programs anyway.
The idiom is to set `errno` to 0 before calling `strtoimax` to avoid this complicated testing sequence.
Try uthash, it's got a good license ;)
I *think* Microsoft has finally caught up with C99 somewhat (not completely) as of VS 2015, so this problem should be fixed now (better late than never).
This is actually pretty easy to do in assembly. I've done it by hand in a hex editor a long while back. You set the 0xAADD (something like that) sequence at byte... 510 and 511 (with 0 being 1) and it starts executing code at byte 0. But this bugs me: `const char *str = "my first kernel";` I don't know what it is about most C programmers, but so many of them can't or don't come up with decent variable names.
A nice tip for hard coding your loop limits/ array sizes is to `#define` them at the top of your file so that they are easier to update when you want to change them, and can easily point out to people reading the code later (I.e you!) what the "magic numbers" mean. 
There are a few (not many) decent paying C jobs, especially in embedded/systems/kernel level programming but just far and few between. I usually encounter obstacles. I rarely make it to in-person interviews. Most companies realise I'm not officially a C programmer (even though I use it quite significantly to understand the platforms I work and program in) so they disregard my resume even though I explicitly state embedded/systems/network programming in C is what I'm interested in. I find that companies that hire for C programmers tend to be very sensitive and selective about their programmers. Rightfully so, because it is an incredibly tricky language to learn and master.
&gt; I don't know what it is about most C programmers, but so many of them can't or don't come up with decent variable names They say the three hardest problems for programmers are naming things, cache invalidation, and off-by-one errors. 
In C, you can more or less expect the computer to perform exactly the operations you wrote down. There is no magic going on. For me this is the main reason for using C: I can reason about every single part of my program because I know exactly what happens when my code is executed. The same thing is not true in C++ which has so many high level features that are used all over the place that it's almost impossible to tell what exactly a semi-complicated C++ program does. That's why I don't want to program in C++.
Good call on the `SIGWINCH`. I don't know any other way (yet) to detect a window resize, so I'll look into that. About the `CC`/`CFLAGS` in the Makefile: fair enough I guess, I didn't know that. My target platform was Linux anyway (to begin with). CMake or an equivalent probably take care of things, right? I prefer not to use it (or autotools...) but if I can make it more portable that way (provided there's plenty of interest in the program) I can probably spend some time to make that work. The warning doesn't come up with me with gcc so I missed that. I believe somebody created a pull request to address (no pun intented) the signed-ness things. Thanks for the response!
Thanks for your response! I agree that the comments sometime do not reflect the actual situation. I was lazy; at first everything was in one big file. Then I started making .h files and their .c counterparts. I didn't update every comment but just for clarity's sake I should update those. &gt; You could check that len is not &gt;= CHARBUF_APPENDF_SIZE before calling charbuf_append() anyway, so if for some unlikely reason the buffer was not enough, the consequence would be a clean failure, and not a buffer overflow. I thought `vsnprintf` would only write `size` bytes at maximum? So effectively never overflowing the `buffer`. Or did I misinterpret the manpages? 
&gt; Or was there something wrong about it? No! In fact, I was unaware of telling the file's size using `stat` was an option. Good call. I saw the comments below about `fread`, so I will check on that. About `strcpy`: my train of thought was merely about being very careful with using that, regarding buffer overflows. So I tend to use the 'n' functions wherever possible!
With respect to naming constants, not too much. `#define` is global in scope, where const int and similar declarations can be made local to the file they are declared. I.e. Consider the two files called `foo.h` with some interface, and `foo.c` which implements it. If I were to have some constant that was part of the interface, I'd `#define` it in `foo.h` so that any file including the foo module would have access to it. However, say I had some other constant (a max buffer size perhaps) that was required only by the implementation. I would then declare it `static const int BUFF_MAX = 1024` or something similar inside `foo.c`. This would ensure that no one including `foo.h` would see my implementation details, and avoid all possible name collisions. Notice in both cases, a global (to everything or just one file) constant should be given a very descriptive, all caps name so there know exactly what they're dealing with. 
Interestingly, /r/cpp has a [good discussion](https://np.reddit.com/r/cpp/comments/lcy3c/the_top_10_ways_to_get_screwed_by_the_c/) on this post.
Can someone explain how the video memory is being read on the other side. For example, how does the machine know the pixel layout for char 'A'. Is this provided by the bios?
It was, until I tried to post before my morning coffee...
Yeah, my understanding is that VS2015 rev 3 is finally C99 compliant.
TL;DR: solve many of these "problems" with: `-Wall -Wextra`
it's a completely non-descriptive name. it's a string, but most programs have many strings. so, should we call them str1, str2, etc? better to name it based on what that string means to the human reading the program. 
Yes, well done Redmond, only 15 years late to the party.
Unless I've missed it, there's no question in your post, or any indication that the function fails, or how it fails. For that matter, you don't even say if the array should be used to store the new string, or to store every string separately in an array of strings.
I tried running the provided ("working") code. I'm having trouble getting it to do anything interesting
Yeah, keeping your sanity.
Yup. It's been about a year since I started learning c, and at this point nothing could stop me (altho I am still exploring the fringe, like using bitfields with arrays (which doesn't work unfortunately), etc)
&gt; Should I create a new array each pass to store the pair products from the previous pass? Depends on what you want, if you want the tree structure then you'll have do build them as you compute the products. Otherwise if you just want the result it's as simple as: double prod(unsigned v[],int cnt){ if(cnt==1) return (double)v[0]; int half=cnt/2; return prod(v,half)*prod(v+half,cnt-half); } I'd use `double` if precision is not that important (if the result is possibly hundreds of digits long, do i really care what the least significant digit is?), if you want precision use a bignum library, but the performance drop will be considerable as all multiplications will be done in software. The above implementation is recursive, so naturally we have to take into consideration the possibility of the stack overflowing. Notice that each recursive call has to deal with an array of half the length of the previous iteration, so the recursion depth is logarithmic with the number of elements. Even if you theoretically had an array of 2^32 elements (at that point i'd worry about other things) you'd make only 32 recursive calls. EDIT: It seems that the author of the page is wrong about the performance. Let `f(n)` be the number multiplications done using the above method for n elements. We have: f(n)=2f(n/2)+1 //do the algorithm for each half, then 1 mul between the halves f(1)=0 //base case The solution to the above recurrence is `f(n)=n-1` (check by plugging in, or as an exercise deduce it) which is the same as the naive method of multiplying sequentially the elements of the array. &gt; This is much faster than multiplying sequentially first times second times third etc., for essentially the same reason that merge sort is much faster than insertion sort. Maybe there's something i'm missing but the above remark is clearly wrong. 
&gt; Maybe there's something i'm missing but the above remark is clearly wrong. You're not taking into account the cost of the multiplication itself. DJB is never wrong.
If the cost is `c` in number of instructions. Then asymptotically the time is `c*(n-1)`. It's definitely not the logarithmic time complexity it promises.
Ok, sorry, I should clarify. What you say is true if your numbers fit in a register. In reality we're working with numbers that are usually 512-bits or larger in size. So you need to rely on multiplication algorithms. For example schoolbook multiplication takes time (n*m) operations - where n and m are the number of digits of the multiplier and multiplicand. I'm not sure about a logarithmic speedup, but the multiplication is not a fixed cost, and you not only reduce time, but also reduce the amount of memory required to compute the product when using a product tree.
Hmm, good point.
The name is perfect. It doesn't need to be anything more than 'str' for this context. The people who obsess over naming tend to produce large and unwieldy paragraphs which are worse. If you find that you need to have excessively descriptive variable names to keep track of what is going on, that is a big red flag that you need to reduce the complexity of your functions.
&gt; I'm not sure about a logarithmic speedup, but the multiplication is not a fixed cost, and you not only reduce time, but also reduce the amount of memory required to compute the product when using a product tree. I highly doubt that there is any space saving. Note that the product of two numbers takes about as much memory as the sum of the operands memory requirement. This immediately follows from log *ab* = log *a* · log *b*. Thus it doesn't matter what order you multiply in, memory wise. In case we do floating-point multiplications, then the size of each number is constant and the linear approach takes less (a constant amount of) memory if we can stream the input. If we cannot stream the input, it still takes less storage because we do not have to store any intermediate products. DJB may have a point, but there seem to be some unstated assumptions.
Hi, thank you so much for your insightful reply. I have only just had a chance to get back to my computer. So I agree that my pointers are all over the place at worst and at the best just pretty unclear. In the long term want to sort this out but for now am just going to try to 'fix' putting Cells into the queue. Currently my ideas are to use malloc to allocate space for temp as it is declared within the function 'Combinations'. Surely it doesnt matter that temp is a local variable and becomes invalid because I keep redeclaring it as I call functions within a loop? Thank you in advance!
I think the recursive approach as /u/benjade showed would work nicely. 
I would think this line while (str[j] != '\0') { might as well be written as this while (str[j]) { since the test would fail once str[j] is NULL anyways. 
YV12 has 3 pixels, not 4, and further those chroma channels are subsampled aka here's half as many color pixels as luma pixels. Also, YV12 and most YUV formats in general are planar, that is it's not an array of Y then U then V. but all Ys, followed by all Us. followed by all Vs.
That link has already been submitted here 3 years ago, but it did not generate any discussion at the time (the community was much smaller). I'd be curious to hear some thoughts from others.
Very good coding guidelines and wish more C/C++ projects did the same. I absolutely hate the whole beginning brace `{` starts at the end of the statement instead of on its own line even though the ending brace ends on its own line `}` that a lot of open source projects use. Cause it just makes it difficult to follow especially for deeply nested conditional and switch statements. And props to them for properly spaces usage instead of overly using them between everything, again unlike like I've seen some open source projects use where they just go too far: if ( ( someNum == 0x123 ) &amp;&amp; ( false == result ) ) { printf ( "Result failed: %d\n", result ); return ( false ); } instead of just simply: if ((someNum == 0x123) &amp;&amp; (false == result)) { printf("Result failed: %d\n", result); return false; } 
Remember to link against the library as well as including the header. On gcc, this is done with the `-l` flag. What you described happens because the structure/type is defined in the header but the function is defined in the library itself.
Interesting, I'm on linux so how can I run it with the -l flag? currently im doing this: gcc -o test test.c edit: got it it's gcc -o test test.c -lgumbo where -l is a "l" as in Library. 
Their scope is whatever you've defined the variable you ended up assigning them to when you call `open`.
You sir are the man! Thank you so much! 
It's only about 40 pages once you trim the intro, blank pages, table of contents, index and a few long examples. And it's not only about "pretty". 
The mingw project gives you cross compilers for this.
So change it. static char pagefile[ BUFSIZ ];
 [BUFSIZ]; ? Sorry new to C. What does that do? Also, I've tried removing static and const from it, and the curl won't run without it. Like it doesn't throw an error it just doesn't go out and grab the file. 
Pointers don't point anywhere useful unless you do it. The line is creating a string literal, which allocates space and sets it to that string. My version changes it from a pointer to an array, and allocates BUFSIZ number of bytes for it, for you to put whatever else you want in it later (your URL for instance).
Sorry, really new to C. How would I put my URL in it? A memcpy? strcpy? 
Do not put literal `␣` characters in front of every line! `␣` is supposed to be a visual representation of whitespace. Instead of each `␣`, hit the spacebar once.
I think you mixed up the *size* and the *count* parameters of *[fread\(\)](http://www.cplusplus.com/reference/cstdio/fread)* in your *[editor_openfile\(\)](https://github.com/krpors/hx/blob/master/editor.c#L133)* function. size_t fread(void * ptr, size_t size, size_t count, FILE * stream); where size: Size, in bytes, of each element to be read. count: Number of elements, each one with a size of size bytes. return value: The total number of elements successfully read is returned. but you wrote if (fread(contents, size, 1, fp) &lt;= 0) {/*...*/} So it actually reads one element that is *size* bytes long, instead of *size* elements that are 1 byte long. Therefore the return value of fread() is either 0 or 1; keep that in mind if you want to keep the current order of parameters.
I don't understand. Why are you simply not using `char *` for `string` in the first place? Also, that should work. What are you passing to the function? Is it a valid path?
You should do some basic debugging. If the syscall is failing, print the error number/text. Or run your program under strace to see what's going on. One or more of your assumptions is incorrect, but without a testcase that reproduces the problem, there's not much that anyone here is going to be able to tell you. 
gdb is the usual one. You should post your code.
Can't as it's a school project. I've posted as much as I can. 
This is how I do it as well for conditionals. However I place the opening bracket on a newline for function definitions.
I like this unsigned counting down: unsigned i; for (i = N - 1; i != -1u; i--) { /* ... */ } 
seems awesome
You didn't provide much information about what you're doing, but 8 months ago you were asking about Ubuntu, so I'll assume that's what you're still using. This is very easy to do on Ubuntu using, what others have pointed out, a *cross compiler*. The port of GCC to Windows is called MinGW (and has seen been forked as Mingw-w64). It's easy because it's all packaged up for you: sudo apt-get install mingw-w64 When you want to compile a program for Windows, use `x86_64-w64-mingw32-gcc` (Mingw-w64 cross compiler) instead of `gcc`. It will create a binary with a ".exe" extension which will run on Windows (or in Wine on x86-64 Linux). All the other cross-compiler tools will also get the `x86_64-w64-mingw32-` prefix. 
Looks cool. You misspelled matrices in "special_matrices". Will you be adding support for more operations?
No, not really. I have a draft of ISO C11 that is 700 pages (got it from [here](http://iso-9899.info/wiki/The_Standard)).
Yeah, "wb" will create the file. But is it a proper path where you have permissions to create files? You perhaps should use `perror()` to print whatever error message is associated with the failed creation of the file.
Thanks... I'll fix that. I do intend to add more operations. Suggestions are welcomed!
 ssize_t i = N; while (--i &gt;= 0) { /* stuff */ }
Do you welcome additional help or do you want to work on your own?
And by "four spaces", they obviously mean "one tab". And always in Vim, never in Emacs.
Let's see... 1. Find the inverse 2. Perform Gaussian reduction 3. LU factoring 4. Reshaping 5. Other matrices types other than `double` - Also... I'm a bit iffy on the memory allocation. You can actually make it so that you don't need to use `malloc` to create the matrices. For example, here's how I'd implement one of your functions: int cmat_add(MATRIX out, MATRIX lhs, MATRIX rhs){ if( lhs.rows != rhs.rows || lhs.cols != rhs.cols || out.rows != lhs.rows || out.cols != lhs.cols) { return -1; } int i; for(i = 0; i &lt; lhs.rows * lhs.cols; ++i){ out.data[i] = lhs.data[i] + rhs.data[i]; } return 0; } - So instead of dynamically allocating matrices, you just make the result be an output parameter. And since the MATRIX type is only 3 words, it's okay to pass it by copy. It will work the same because the `data` member of the struct is dynamically allocated. This way, it also allows the caller to output the result to the same matrix. For example: MATRIX ones = cmat_ones(3, 3); cmat_add(ones, ones, ones); - This is essentially doubling every element of the matrix and storing the result in the same matrix. I find this way to be more flexible to the caller. 
I have expressed the will of God. I trust this is self-evident.
Thanks! I'll keep these in mind.
&gt;For larger projects, or future projects, consider using a build tool on top of make. There's no sense in making the build process more complex, not to mention forcing users to install yet another build system.
the code is above the image
Yes.. it's just 2 dimensional array stored in single dimensional array. `col + (row * m-&gt;cols)` gives the index of element in 1D array. Where `m-&gt;cols` is total number of columns and `col` and `row` are index of element in 2D array.
I'm not fond of that approach :/ It kinda looks nice, but it's easy to become horizontal. Besides, if something goes wrong inside one of the nested function calls, how do you know which one threw an error?
In that case I would separate the source files to their individual platforms and allow the user decide to compile which platform they want. Autotools trades end user complexity for programmer complexity.
Thanks. EDIT: Wow, just noticed your username. Its really great.
 m-&gt;data = (double*) calloc(rows*cols, sizeof(double)); While `calloc()` will correctly initialize floating point values on every computer you'll probably ever use, it's worth pointing out that this is not necessarily correct for C. All bits zero is not necessarily 0.0. Also, there's a potential integer overflow issue. If `row` or `cols` is a large number, you may end up allocating a lot less than you realize. Considering the context in which this is used, it's probably already an error for the caller to be requesting a matrix that huge. But it's something you should be thinking about, and probably either fixing (report failure on overflow) or documenting ("don't pass huge dimensions"). struct matrix{ double *data; int rows, cols; }; Here's my suggestion for an alternate definition of this struct, using a flexible array member: struct matrix { int rows, cols; double data[]; }; The struct and data are then allocated as one big block, which saves on a pointer and has nicer effects on the cache. I don't think you'd have to change any of your code, either. I'd put `cmat_set()` and `cmat_get()` in `cmat.h` as `static inline` functions. You *really* want those functions inlined everywhere since you call it frequently from O(n^2) loops. Other small, frequently-used functions should get the same treatment. Since this is a tiny library, I'd cut it down to a single .c and .h file, or even a pure header library. That makes it easy to just drop into a project, and it skips all the complications with installation. Along those same lines, I'd also relax the license to something without copyleft. No one is going to use a small library that's under the GPL. Dealing with the license is far more cumbersome than just rewriting it all from scratch. 
lol
You might want to read [this page](https://en.wikipedia.org/wiki/Indent_style) for a number of indentation styles and their rationales. Personally, I use `style(9)` from \*BSD.
While certainly dated, overall it's not unreasonable. The main points of disagreement would be over syntax trivialities. &gt; To improve efficiency, use the automatic increment ++ and decrement operators -- and the special operations += and *= (when side-effect is not an issue). This was barely still true at the time of writing (1994), but is definitely not true today. &gt; To improve readability, separate functions in the same file using a single row of asterisks. Hell no.
I've already seen it years ago. I align with `Allman style`. Because of readability. 
The first image is what it looks like now. The second is the flexible array member version. * http://i.imgur.com/DxuXNru.png * http://i.imgur.com/DZYXuta.png The current allocation function is: MATRIX* cmat_malloc(int rows, int cols){ MATRIX *m = (MATRIX*) malloc(sizeof(MATRIX)); m-&gt;rows = rows; m-&gt;cols = cols; m-&gt;data = (double*) malloc(sizeof(double[rows][cols])); return m; } And with the flexible array member it becomes a single call to malloc(): MATRIX* cmat_malloc(int rows, int cols){ MATRIX *m = (MATRIX*) malloc(sizeof(MATRIX) + sizeof(double[rows][cols])); m-&gt;rows = rows; m-&gt;cols = cols; return m; } The `sizeof(MATRIX)` evaluates to the size of everything *but* the `data` field, which is added manually for the total size. The `data` field refers to the memory immediately following the structure. This was a feature added to C99. 
My problem with that argument is that the code block is defined by the braces of which means the braces are apart of the code block themselves, not any part the statement before it. Just like a chapter title in a book belongs on its own line above a context body of text. In [K&amp;R C Programming book](https://www.ime.usp.br/~pf/Kernighan-Ritchie/C-Programming-Ebook.pdf) it clearly states that a function definition has separate parts: return-type function-name(parameter declarations, if any) { declarations statements } So even the creators of C disagree with you. I prefer braces on their own lines cause of vertical alignment and so you can quickly visually look up and down to find where the code body begins and ends which greatly helps readability. 
You monster. :( 
He is a heathen and must be put down immediately.
Your matrix multiplication is suboptimal. By changing the order of loops you can get much faster. https://stackoverflow.com/questions/7395556/why-does-the-order-of-loops-in-a-matrix-multiply-algorithm-affect-performance
This program does nothing. x is not greater than 2, so Foo will never be called. If x was greater than 2, the while loop would run forever. What exactly do you think is "faster"?
So, I have come to this point: http://ideone.com/ZAESLp And somehow, this function does not write spaces as is has to, any ideas? 
I'd rather not have the matrix struct to be dynamically allocated. MATRIX cmat_init(int rows, int cols){ MATRIX m; m-&gt;data = malloc(rows * cols * sizeof(*m-&gt;data)); m-&gt;rows = rows; m-&gt;cols = cols; return m; }
Ugh sorry, that's what I get for rushing my post and not checking the code. I've edited my changes.
I'm new to C, so I apologize in advance if this is a trivial question. In your close_logging function inside logging.c, why do you need to cast *log_fd to int? Isn't a dereference of an int* an int?
Do you have an objective?
Well.. I need to process two txt files (I posted a link of the one) with these algorithms and compare the running speeds
Thanks very much for the explanation!
Thanks very much for the explanation!
Do you understand the algorithms? Do you know what the text files represent?
I understood the first two algorithms but I am not so sure what the txt files represent.
Why are you using those weird underscore characters? Format code in reddit posts with 4 spaces in front of each line. RES makes this super easy, btw. You need to use strcmp() to compare strings, not ==, !=, etc. Those just compare their addresses, not contents.
On posix systems at least, putchar is just a macro to putc, which putc is also just a macro to fputc. The functions in the standard library that use file streams (fprintf, fgets, fputc, etc) are buffered, meaning that they only print either when the buffer gets full enough, you flush the stream, or the buffer has a newline character. When you press enter it adds a newline character to the buffer, forcing it to flush.
Input is buffered too, not just output. getchar() will just pause until the terminal gives it a complete line of text after you hit enter. Then it'll return a character at a time until the standard input buffer is empty, and wait again for more input to be provided by the kernel.
However, I made a test program that just ran putchar('t'); it printed out t even though I didn't put a newline into the buffer
Yeah that was actually intentional. I figured I know the file size ahead, so I only need to read that amount of bytes, 1 time only. 
Thanks for your considerations and time spent. Really appreciated.
You have to understand how 'while' works. The while command will only assign c with the character you enter after you execute the command ( by pressing enter). If the line or character you just entered is a t, putchar will only print it after the while statement is true and not equals EOF (end of file, which is a shortcut in one of the C compilers standard headerfiles aka .h files)
Even though the output is line-buffered, the buffer can be flushed on a number of other occasions, such as: * the buffer being full (it's usually 4k or 8k bytes long) * the program terminating * someone calling `fflush()` on the stream you write to
Your comment confuses me. &gt; putchar will only print it after the while statement is true and not equals EOF I do not understand what you try to convey with this sentence.
Please put four blanks in front of every line of code. `␣` is supposed to be a visual representation of whitespace. Try to read the entire submission guideline next time.
I went for a solution where i decrement the pointer before dereferencing it. #include int main(void) { int *p, arr[] = {10, 20, 30, 40, 50, 60, 70}; p = arr + (sizeof(arr)/sizeof(int)); while (p &gt; arr) printf("%d ", *(--p)); print("\n"); return 0; }
Thank you, it worked.
It's the terminal that buffers, you can force sending the characters by hitting ctrl-d.
&gt;I know C (a little) hehe
I don't want to provide too much information, because learning is the whole point, but for getting your integer to ascii symbols, it might be worth taking a look at the functions in stdio.
 char toWrite[4]; sprintf(toWrite, "%d", number); Something like this might work? (Always going to be a 4 number integer), number is the parameter integer for the function
No blogspam please.
p is set to 1 because x^0 is 1. If `n` is 0, then the loop never runs and so 1 is returned.
Thanks!
If it may go below 1000, you can say: sprintf(toWrite, "%04d", number); to always produce 4 digits, and have the leftmost ones padded with `0` if the number is small.
This really seems more like a task for pthreads than `fork`. Both processes are trying to do I/O with the same stdin and stdout handles, since those get copied by `fork`. Since they become two independent processes, there isn't an easy way to do any sort of synchronization to make sure only one of them gets access at a time. This is probably the source of your problem. 
Thanks, I'll try posting there as well. 
Ah the living hell that is creating libraries, and dynamic link libraries... This example is OS X, but rest assured the instructions won't work anywhere else.
Not bad overall - you might also want to try posting the code on http://codereview.stackexchange.com where you'll get a good critique.
Before line 40,you check if allocation succeeded. If yes, you check if input succeeded. Now, if this goes wrong for some reason, you go to your error handling mark with err set to ERRNOINP. In this case, you just exit but not clean the allocated memory (if I am not mistaken of course). 
Even if there never is a ``goto out``?
It doesn't free it if there is an error, since it never enters the IF. He should free it before the go to IMO or maybe just free at the end without the if 
Sure, I don't see any exit or return statement. The program goes to out_err:, the switch handles the error code and prints out the appropriate message. The break will break out of the switch and continue to the out: on line 110. break doesn't exit the program, it only exits the switch, otherwise it would have printet 4 error messages instead of one.
An example that work on linux of a non blocking read, it print what you type without having to press the enter key. http://pastebin.com/N69BnDWy have fun learning how it work 
Why doesn't it enter the if-statement? It's the first piece of code after the switch condition, and the program doesn't exit during the switch.
I've never understood why teachers put such strict limitations on how to solve a problem. I would not use a loop for this myself, and if students find alternative ways to solve a problem, isn't that teaching them more than following instructions does? In your job, nobody is going to tell you what to name your variables, or what control flow to use. You're going to need to figure that out for yourself.
But if bfr points to null, there isn't anything to free.
 bfr = malloc(sizeof(char) * (BUFFER_MAX + 1)); sizeof(char) is 1 by definition, but that's fine. You don't *really* need dynamic allocation for 257 chars, but in practice you'd want a larger buffer anyway, so this is good. for (last = BUFFER_MAX; last &gt; 0; last--) { if (*(bfr + last) == '\n') { This is reading uninitialized memory if &lt; BUFFER_MAX characters are read. You can't trust anything beyond the first nul character in that buffer. If you want a challenge: it's possible to do this whole program with only one loop. That would also put you in a better position to handle input larger than the buffer. *(bfr + lower) It would be better to introduce another pointer and sweep it across the buffer, but that's a more advanced topic. Why not `bfr[lower]`? tmp += (pow(16, upper - lower) * mult); It's weird to see floating point math here. I'd really prefer to see bit shifting, but that's not exactly a beginner subject either. I don't know, I just find this hard to follow. But it *is* 3 AM here. printf("Error: no error\n"); Thorough. :) I could quibble with some of your naming, but on the whole I'd say this is a pretty good exercise in error handling.
yes there is, because the pointer points to null but the memory will still be reserved until the program ends. Unless malloc automatically frees everything you've reserved if it encounters a memory error, in that case you are right, i guess i should look it up lol
One of the hardest things for me to learn was that not everyone reads code the same way so legibility is just as important as function in "the real world". Having said that, others have mentioned good things but I also found one aspect slightly unintuitive. In your loop that is reading the buffer backwards looking for the newline, you can make the loop conditional on nl_found not true and last &gt; 0. It lets the reader understand the loop intent much more easily as well as allows for the removal of the last-- and the break call, both within the if check. 
You need to include stdlib.h if you're going to use atof. Honestly, atof isn't that great, though, because it's very difficult to detect errors. strtod is a little better, but still kind of a pain. I wish there were a nicer standard function that just told you, yes or no, whether a double was parsed correctly.
Sadly scanf does not check for overflow. Using %lf on a string that causes overflow invokes undefined behaviour :(
You want argv[2] and [3], not [3] and [4]
Yea I just tried it, but shouldn't it go like this? ./proj2 == argv[1] --log == argv[2] base == argv[3] iteration == argv[4] 
No, ./proj2 is argv[0]
Yea I am dumb (new to programming). Thanks a lot! Have my upvotes!
Thank you! This worked perfectly (and I've fixed my portability issue).
You should be concerned with all undefined behavior
Yup. `errno` will have the value `ERANGE` on overflow (and usually also on underflow, though that's implementation-defined in the standard). `errno` will not be set if the string couldn't be parsed at all, though, which means you have to do 2 separate checks to see if everything succeeded.
Not dumb. Inexperienced.
Cool, that'll help ensure that I can't compile it on any of the non-GCC compilers I use. :-(
You didn't read OP's description: &gt; He wants us to accomplish this by using nested while loops and pointers called front &amp; back, and newhead.
I don't see any *bind()* calls, I thought it was necessary. 
Fair enough, I have found a fair number of C++ implementations, perhaps you could translate? http://www.redblobgames.com/pathfinding/a-star/implementation.html#cplusplus EDIT: forgot to attach link 
actually how would one increment a pointer? thats kind of where im struggling here
All variables that you use in your program will be stored somewhere in the computer's memory. Different variables are often (but not always) in different places of the memory space. To reliably store and retrieve variables we must therefore know where we put it. How is that done? You can imagine computer memory as a long line of little boxes (or *memory cells*), each containing a small number (a byte on x86 computers). Each such memory cell is referred to by another number: The first one being 0, the second 1 etc. This number is the *address* of that memory cell. Several cells can be combined to form larger entities capable of storing larger numbers (in the same way we can express larger numbers with our 10 digits by using several of them). So we can for example store a 32-bit number using 4 byte-sized cells next to each other. Addresses are numbers, and memory cells contain numbers - the step is short to realising that we can store the address of some memory cell in another bunch of cells. This is the idea behind a *pointer*. It is a variable that *points* to some other place in memory. In C, this is slightly more abstract: We are talking about pointing to objects, not memory locations per se. The principle is the same, though: We have some variable that is pointing towards some other variable. To get the variable to point to something, we do the following: int i; int *p = &amp;i; That assigns the pointer `p` to point to the integer `i`. We can change what `p` is pointing to if we want: p = &amp;j; Next up is pointer arithmetic. Suppose we have an array of integers: int arr[10]; We can point to the first element of the array in one of two ways: int *p = &amp;arr[0]; int *p2 = arr; Incrementing `p` would make it point not to the next memory cell (for that could be anything, depending on the computer - some computers can only address cells larger than certain objects we want to use, but this will be hidden from us by the compiler), but to the next object, which in this case is `arr[1]`. This is done in the same way as any other variable: p++; // Now points to arr[1] You can decrement in the same way. You can also do other calculations: int *p2 = p + 2; // p2 now points to arr[2] Pointing to stuff is well and good, but how do you get to the value that is actually being pointed to? By dereferencing the pointer with the * operator: printf("%d\n", *p); // Print the integer that p is pointing to So you can loop through some array using a pointer: while (*p++ == 0) ; // Loops until whatever p is pointing to is non-zero Worth noting is that arrays tend to *decay* into pointers. For example if you pass an array to a function, the function will not receive anything but the starting address of the array - the size will be lost. Pointers can also be accessed in a way similar to arrays: printf("%d\n", p[2]); // Prints the number at p + 2 `p[x]` is the same as `*(p + x)`, meaning that we add x to the pointer and then dereference the result.
Pointers are literally just numbers telling you which memory address something is in. Starting at 1, going up to however much memory you have. Since arrays reserve blocks of memory, you can increment the pointer and look at the next value in the array. If you know the first element in an array is at address 2, you can add 1 to 2 and look at the thing in address 3. If it helps, think of memory as a giant array itself and the pointers just store indices. If you want to increment an index to look at the next thing in an array, just add one and look. Of course that is oversimplified (also pointer values are usually written in hexadecimal) but that is how it works conceptually. Edit: Just wanted to add a quick note. A problem you might see immediately is what about the size of the elements of the array? An array of 10 long ints will take up more memory than an array of 10 ints. Do you have to account for this when manipulating pointers? No. Thank god. Pointers have types and so incrementing an int pointer will actually add the appropriate number to the pointer to get you to the next int while incrementing a long int pointer will also add the appropriate number to the pointer to reach the next long int. 
There is more docs than Linux. None of this works in Windows. What about Solaris? A/IX? MVS? Plus you can use 'static' dynamic linking where you link against a library that will pull in the DLL at runtime, or you can load the DLL yourself at runtime. There is also more c compilers and linkers and archivers than gcc. Not many of them strive to be compatible. Different CPU architectures also can dictate how DLLs will be different if even at all possible. This is why libtool is a thing, and even that is a total clusterfuck.
In function `rightTrim()`: If the string contains only whitespace characters, the while won't stop when it reaches the start of the string, `end` will become negative, you will test whatever lies before the string in memory, and you will return a pointer to some memory before the string. Please test that `end` does not go below 0.
Sorry, only new lines that result in this particular code executing. Theres a couple different integers that can start each line, and then execute different code depending on what that integer was. Since I need to know what that initial integer is, and it would get "eaten" by this, thats not an option. Its also possible that 10.00 or any other double might just be part of the sequence and mistaken for the end of the line
After each fscanf, see if the next character in the stream is a newline?
Thanks, that worked. I guess I was just overcomplicating things
Yes, I have used libraries for YEARS, and yes I know about them on platforms other than current Linux, and you shoehorn yourself into one platform it really is best to title it directly for what you are going for as it does not cover dynamic libraries, but rather only a subset. Not to mention the fun of DLL hell, versioning, call back functions, onload, onunload, on the Linux side being able to force the dynamic linker to preload objects to override exports in libraries (I'm looking at YOU ORACLE!!!!!) and all of the other things that can possibly go wrong, and or correct with dynamic linking. I too have written incomplete, and impartial stuff on DLL's. I suppose I should update it, although I feel at this point I'd just be re-writing the book [Linkers and Loaders](https://www.iecc.com/linker/). But check other programs that do linking in a portable way, and you'll see it ends up being a mess of #define macro's and trying to use high level calls like dlopen that work on GNU type platforms (yes, even DJGPP/MS-DOS). But for libraries like libpcap/winpcap they have stated time and time again that instead of statically linking into the dynamic library. Actually I'd suggest to start with pcap/winpcap and see how they build their DLL, and sample programs for linking into it. Like I said, hours of fun..... haha
If you have the time I highly recommend watching this playlist. https://www.youtube.com/watch?v=h-HBipu_1P0&amp;list=PL2_aWCzGMAwLZp6LMUKI3cc7pgGsasm2_ The first few videos alone will help you understand a lot. He's got a bit of an accent, but the subtitles are spot on.
** Edited ** Tell you what, let's compromise? I'll put a disclaimer that my post is only for OSX and Linux. You can write a post about winpcap, Solaris, and AIX. I'll then put a link to your post from mine saying something like "for more info about other platforms, see this post". And I'll leave you genuinely polite comments. How's that sound? How's this? https://github.com/nickdesaulniers/nickdesaulniers.github.com/commit/7708640ba3b4dddf98cf066c0fd69060778268a2
Ah ok so I'm starting to understand now. So say for my project I wanted to create a Guitar. I'd create a guitar.c file and a guitar.h file, the former containing the data fields and the latter containing the actual functions. Then at the top of my main.c I would say #include &lt;guitar.h&gt;? How would guitar.h know how to interact with the private data fields created in guitar.c?
I don't believe the word "module" has any formal meaning in the context of C. My guess is that your instructor is referring to a module as the combination of a header file and implementation file, but as I said, this term isn't one with a well-defined meaning in C.
Yes, you are absolutely right! I forgot to update the gist!
by using 'goto's you mimic c++ exceptions, and as it might look clean, its not easy to read and follow. I spent too much time than i should to create examples, but here it is: typedef enum bool_e { TRUE = 0, FALSE = 1 } bool_t; /* Name of the function describes what function does: Allocate - allocate memory on heap (so we already know that we need buffer) String - C language defines string as array of char elements with end-of-string sign at the end Buffer - container for data tip1: google why double pointer (**) is used when storing pointer to allocated memory in function argument */ bool_t AllocateStringBuffer(char ** pointer_to_string_buffer, size_t buffer_size); /* if you allocate, you must always free */ void FreeStringBuffer(char ** pointer_to_string_buffer); /* Get - means that data is written to buffer UserInout - means that data is read from user, so IO (input-output) functions are used tip1: when you write something to provided buffer, call the pointer 'output' so people know that function is writing to this buffer tip2: in C, when providing pointer to array as argument, ALWAYS add parameter for its array size. */ bool_t GetUserInput(char * output_string_buffer, size_t output_buffer_size); /* PrintBase64 - print base64 FromString - from C string, so we know that input_buffer string end with end-of-string -&gt; '\0', so buffer size is not need unless we check if string is correct tip1: input_buffer argument -&gt; 'input' in name imply that buffer provide data, 'const char' say that data is not being changed google for 'c const correctness' paradigm to learn more. */ bool_t PrintBase64FromString(const char * input_buffer); With such functions you can then play with program flow, for example: http://pastebin.com/QckZ8RfK With this flow control you can already see, than if-else structure can grow to some high level indents, which is hard to follow/read. But with code split between functions we can easily change program structure to state machine: http://pastebin.com/jb7akTcW With state machine, we could very easy draw a graph, and add some new state to handle invalid inputs, etc.. 
Why are you linking to C++ references? You're only going to confuse beginners with the incorrect import names.
&gt; While the code works for n=3, 5, 7 Are you sure? I just tried running it and got some weird results https://ideone.com/gQGK4t Can you explain what the results are supposed to look like?
A magic square of order n is an arrangement of a sequence of n2 numbers in a square grid such that the n numbers in all rows, columns and both diagonals sum to the same constant value. In particular, when filled in with consecutive values from 1 to n, this sum is given by n(n2 + 1)/2. So for the example of 3, each row, column and diagonal should equal 15. eg. 8 1 6 3 5 7 4 9 2 For n=5: 17 24 01 08 15 23 05 07 14 16 04 06 13 20 22 10 12 19 21 03 11 18 25 02 09
Can you describe how your algorithm is supposed to work, in English? There are no comments anywhere in your code, so i doubt anyone is going to sit down and work out what you think it's supposed to do. Step 1: Describe _every step_ in English Step 2: Break it down into pieces Step 3: Write the comments Step 4: Now you can think about coding
Quite new to this, sorry. I just added comments, thanks for the tip.
From the link I posted, here are the results for 3 and 5. It looks like something is wrong? 3 is odd 0 1 0 0 0 0 0 0 2 5 is odd 0 0 1 8 0 0 5 7 0 0 4 6 0 0 0 0 0 0 0 3 0 0 0 2 9
don't quite know how to do it
Your question has been answered, but for interest's sake: It sounds to me like your instructor has a Fortran background. "Modules" are used in Fortran to compartmentalise the program much like C, but unlike C you need to pay more attention to explicitly defining an interface between the modules. When the instructor talks about having information passed between the module and the main program it makes me think he is thinking in this mindset.
Yeah, this word isn't used in C like it is in python. But a shared object in C is the closest to what a module is in python.
Wow thanks so much for the detailed reply!!! On an iPad?? I'm impressed!
My pleasure, hope it helps.
(I'm of course talking about procedural languages here) Back before the OO fad, there was something called structured or top-down programming. You started with writing down, at a top level, everything your program did, in order. Each one of those steps was generally made a procedure, module or function. Then each one of those modules were broken down into the substeps that that step would take. This would occur until it looked something like pseudocode and then you'd write your code. There was no arguing about what nouns to make classes or class hierarchies or any of that silliness. You simply broke down your program until it was simple enough to write. Occasionally, you'd run into situation where leaves from different branches could share code, and you'd make common functions for those, but it was mostly a tree-shaped, layered codebase. I'll note the new trend of languages like Go and Rust that eschew "fundamental" aspects of OO. There's no inheritance in either language. Python has no information hiding.
This is exactly how I began approaching C coding, 3 months ago (after reading lots of other C code). It seems to work like a charm for me as well. You cannot truly enforce enapsulation of the struct members, but when programming C you've got other 'problems' than that ;) As long as you tell your users (or yourself) that functions should be the only way to access or modify a struct, things work out pretty well.
I like this example and I would like to expand on it a little bit Using the **static** keyword on a function or a variable/structure will make it *"invisible"* to code outside the .c file. **Example (person.c)** static const int MIN_AGE = 0; static int valid_person_age(int age); static int valid_person_age(int age) { return !(age &lt; MIN_AGE); } Here we have a *"private"* variable and function, only visible inside person.c (notice the function definition inside the .c file). So, in a way, you could view the person.c/h files as "light classes" (no inheritance or overloading), but in the end; it's not the class mechanism per se we're after. We want **encapsulation, information hiding and clean interfaces** no matter what langauage we write in. Classes is just "one way" of achieving that goal. C does it a bit differently.
Don't forget context switching. That will cause some overhead too.
Why typedef? person.h: struct person; person.c: struct person { int age; char * name; }; main.c: #include "person.h" [...] struct person *alice = new_person(); struct person *bob = new_person(); alice-&gt;name = "Alice"; // GCC main.c:X:Y: error: dereferencing pointer to incomplete type ‘struct person’ 
Because 1) that's what /u/mnemonics_fail_me above used, and 2) because I usually do the same. Also, I would argue that if you're hiding the structs contents anyway, there's no advantage in knowing that `person_t` *is* a struct. So I prefer to use the typedef.
Fair enough.
One of the issues with OO is that we can't even agree what the properties of it are. We can all agree that loose coupling and tight cohesion are important, but OO doesn't have a monopoly on that. Associating code with related data? Again, OO doesn't have a monopoly. Go and Rust are at the point where they solve 90% of the problems that C++-style OO provides with 10% of the issues that C++-style OO has. Is it still OO? It is a question of semantics.
TIL, thanks &gt; The fflush function flushes the stream stream. If the stream was opened in write mode, or it was opened in update mode and the last operation was a write, the contents of the stream buffer are written to the underlying file or device and the buffer is discarded. -https://msdn.microsoft.com/en-us/library/9yky46tz.aspx I had assumed "underlying file or device" was disk for a FILE handle, but I hadn't before today read the next paragraph. After 20 minutes of digging: Linux kernel has fsync (unistd.h); Windows uses other methods
you *probably* won't get into any trouble doing this, but strictly speaking, names beginning with an underscore are reserved. from the c99 standard: Reserved Identifiers [...] — All identifiers that begin with an underscore and either an uppercase letter or another underscore are always reserved for any use. — All identifiers that begin with an underscore are always reserved for use as identifiers with file scope in both the ordinary and tag name spaces.
What's the problem with applying a transformation matrix to the vertices?
What you did here is actually a data type. An object abstracts both the data and the implementation of its procedural/functional interface.
No. Do you know how to multiply a vector with a matrix? Just implement that.
why?
Change `malloc(1)` to `malloc(sizeof (char *))`, for the same reason I said to change the realloc (sorry, I missed this one before)
Thank you a lot for help! I really appreciate! Just wondering, do you have a career in programming? Since when have you been coding in C?
I'm also from Canada. When I was interested in colleges I never found one that seemed to offer C, is your course teaching general C or is it something from Microsoft or Cisco?
If `vec_create` expands into a new `struct` definition then how do you return that or pass it as an argument to a function? If they are only used as members of other structs then that'll work, but unfortunately anonymous `structs`which have the same definition are not compatible according to the standard. If you going the traditional `void *` route then you can go further than `realloc` while staying in the same spirit. A situation that calls for a dynamic array is when you don't know the size of input or output in advance. Here it can be convenient to have a small data structure for book keeping and a function similar to `void *append(struct vec *, size_t size, size_t align)` which wraps the `realloc` function. The *append* function calculates the new size, checks for overflow, updates the data structure (i.e. beginning and end of vector) and returns a pointer to the newly appended member which can then be initialized normally. Sometimes when the vector has been built you can extract the vector pointer and forget about the book keeping data structure altogether, but other times you want to keep on growing/manipulating the vector for a long period of time. But in essence, you don't have to make it too complex and you don't have to make the vector type part of your interfaces.
please inform yourself about the notion of epsilon in float calculation, and why float are most of the time not exact, but an approximation of your numbers. your test could be replaced by if( fabsf( f - 1.0f ) &lt;= FLT_EPSILON ) edit : replaced **never exact** by **most of the time not exact**
thanks!
By the way you guys are so amazing I'm deciding to really get into C now, partly thanks to you. I enjoy lower-level programming so much more than the higher-level stuff. I've always loved how things worked and I also like to write my own routines/methods/functions and right now especially I am trying to strengthen my data structure/algorithm knowledge. I'm not sure why so many people are so scared of C but it's good because it weeds out the unpassionate. In any event, I'm at a time in my life where I can make a big change like this and right now I could continue down the typical web-dev route and live a life of lack and curiosity about what is going on under the hood or I could get into C programming and do something I'm really interested in such as driver, systems, embedded, or even just desktop programming in C. It's just so much more fun and appealing to me. Ofc. I won't quit C# or C++ but I notice theres a huge paradigm shift between modern web-dev style coding and this type of programming and this is definitely where I belong.
&gt; Also, I would argue that if you're hiding the structs contents anyway, there's no advantage in knowing that person_t is a struct. So I prefer to use the typedef. I actually think it *is* important to know that it's a struct (or enum, or union) so the user of my code can make better decisions about passing these things around to functions. I would also add something like `const size_t person_size = sizeof(struct person);` to the `.c` file and `const size_t person_size;` to the `.h` file.
I use structs to contain variables I want, and the occasional local variable, but damn near entirely structs...
I was gilded for [this comment](https://www.reddit.com/r/programminghelp/comments/4yq7lg/can_someone_eli5_memory_management_its_what_i/d6pudih/?context=3), maybe it can help you too.
The one thing I can say is that it suits programmers to keep an open mind to new programming paradigms. As an example, incorporating functional concepts into your thinking will help you a lot in the long run, even in a rather un-functional language like C. I mean stuff like knowing that there is always an issue with shared state, that OOP is one way to deal with that, and functional is another, and having a clue what the strengths and limitations of both approaches are.
The only place that belongs is in a landfill.