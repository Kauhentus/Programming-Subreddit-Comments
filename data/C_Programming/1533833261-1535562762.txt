Rather than implementing this yourself, can you just use `gpsd`? Your time would be much better spent using a daemon that has more than a decade of development towards abstracting away the complexities of GPS devices into a simpler, more consistent interface.
Yeah, please don't spam these to subreddits that have absolutely no relationship to your project. That's bad style.
These are the main data structures I use in C these days: * embedded linked [lists](https://github.com/basic-gongfu/cixl/blob/master/src/cixl/ls.h) * dynamic [arrays](https://github.com/basic-gongfu/cixl/blob/master/src/cixl/vec.h) * ordered [sets](https://github.com/basic-gongfu/cixl/blob/master/src/cixl/set.h). Lists are use for simple cases where items belong to fixed number of lists that don't need random access or lookup; vectors for almost anything else, including the implementation of ordered sets. The vector implementation provides value semantics, which extends the range of possible use cases significantly. The set inherits value semantics which makes it possible to implement maps on top by reusing existing structs or wrapping in a map entry.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [basic-gongfu/cixl/.../**set.h** (master → 369ea2d)](https://github.com/basic-gongfu/cixl/blob/369ea2d1093c7fc212454e578fc8d67495777647/src/cixl/set.h) * [basic-gongfu/cixl/.../**ls.h** (master → 369ea2d)](https://github.com/basic-gongfu/cixl/blob/369ea2d1093c7fc212454e578fc8d67495777647/src/cixl/ls.h) * [basic-gongfu/cixl/.../**vec.h** (master → 369ea2d)](https://github.com/basic-gongfu/cixl/blob/369ea2d1093c7fc212454e578fc8d67495777647/src/cixl/vec.h) ---- 
No, I mean check the value the user entered and don't proceed unless it is within the desired range, as I told you earlier. Also, it's spelled “u”, not “you”. Also also, I've been very patient but you have to try to think for yourself, and maybe find and read the correct documentation before asking more questions.
Here's a pretty simple guide on recursion: https://medium.com/front-end-hacking/a-quick-guide-to-recursion-by-example-c0e7949b8ab6 After working through a few sample programs, you should understand why and how to use recursion pretty well. 
 &gt; &lt;a file name&gt; which one? &gt; &lt;one of the extern variables&gt; which one? &gt; optimized for disk space, so I want to use extern these things have nothing to do with each other
You need to declare the variable without the extern keyword in the .c file. Extern means this variable is somewhere else in the code, so don't reserve here space for the variable as it's done somewhere else. But somewhere in a .c file you must declare that variable as non extern, so the compiler will reserve the space for that variable. 
I think there is arguments both ways for this. I think some people like having control over the memory management while using a lib, but also having the lib allocate allows you to use opaque structs
&gt;I know linked lists aren't used anymore They're used heavily. One example is the Linux kernel, which has its own doubly linked list implementation: [https://github.com/torvalds/linux/blob/master/include/linux/list.h](https://github.com/torvalds/linux/blob/master/include/linux/list.h)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [torvalds/linux/.../**list.h** (master → 112cbae)](https://github.com/torvalds/linux/blob/112cbae26d18e75098d95cc234cfa5059de8d479/include/linux/list.h) ---- 
Agreed. Sorry about that!
Wow that's uh, creative uses of define. I'm sure if I got a pen and paper and sieved through it for a while I'd figure out what's going on. But yes, seems like I was misinformed about the usage of linked lists. Thank you
Recursions is awesome, and whenever you have a recursively defined data structure, recursion will almost always be super useful. For example, a binary tree is defined recursively as follows: bin_tree = | NULL | Node with bin_tree left and bin_tree right Thus, a function on the binary tree will likely follow the same recursive definition: int bin_tree_size tree = if tree is NULL then return 0 if tree is Node left right then (bin_tree_size left) + (bin_tree_size right)
As stated by alerighi, the problem is that the 'extern' keyword should only be on the variables in the header file, but more importantly, 'optimizing for hard disk space' is a *terrible* reason to use global variables as the two are completely unrelated. Not only will you not get the effect you desire, but global variables are also almost always bad coding practice. Don't get me wrong, there's definitely good use cases for them (particularly when they're declared static) but I'd say, in general, if you don't know *exactly* why you're making a variable global, then make it local, and I'd say that's especially true for beginners.
Looks like an over-use of the "single-header library" idea made famous by Sean Barrett's STB. This has potential to really hurt compile times for larger projects too (especially if you extend the idea to c++).
ah, i thought i read that sort of thing on a forum, my bad. Any ideas then on how to optimize something for disk space?
What can I do to optimize for disk space? I read in a forum that you get a larger disk space by passing things as parameters, so i figured that if I had the one variable as global, it'd help with it. Though I suppose since arrays are passed as pointers that makes little sense.
Oh, alright. Thank you!
player-&gt;current_chance doesn't need to be capped due to the fact that the moment it is above 1000, the next roll a loot box will be granted if the player wins. This is because the rollPlayerLootbox function always returns a number less than 1000 Breaking printf down definitely makes it more readable. Thanks!
I'm always wary of putting structs on the stack but for 3 ints and a float, it should be fine. Changing it so the player was on the stack shaved about 3 seconds off the runtime on my hardware. Heap was approx 34 seconds whereas stack was 31 seconds.
Hard drive storage is disk space, isn't it?
The topic of discussion on that post is optimizing for memory usage, by minimizing stack and heap usage. This has nothing to do with disk space. I think it's fair to say you're optimizing prematurely if you're not even sure what the difference between disk and ram is.
There will be a *tiny* overhead for passing things as parameters, but it'll be negligible (at most a byte or two per function) which is more than balanced out by the increased clarity of code. The only time this will make a difference is on extremely limited embedded systems but even then you're probably better off writing the code using local variables and then, once you're finished, looking at the size of the executable and refactoring if needed. The quickest and easiest way to get a small binary is probably compiler optimization. In GCC and Clang you can use "-fsize -g0 -ffunction-sections -fdata-sections" (and, if using C++, "-fno-exceptions -fno-rtti") and link with "-Wl,--gc-sections". Dead code elimination with "-fdce" may or may not help - you'd need to try it yourself. Ultimately, I think most people would recommend writing you're program in the simplest way to get it working, then worry about optimizations afterwards. Firstly, this lets you get a working program ASAP which is much more satisfying, secondly, the code will be a lot simpler and less bug prone, and thirdly, it's much easier to reason about optimizing an existing piece of code than a hypothetical piece of code.
Yeah, that's fair. I wanted this thing to be quite small, and got a little too excited about optimizations. Thanks for the help!
It does matter in so much as the executable has to be loaded into RAM to be run so a smaller executable uses a smaller amount RAM, but you're definitely correct in saying it's premature. This is especially true for a *chess* program which, assuming it's just for two people to play against each other and isn't a full blown AI engine (ie; no opening book lookup tables), shouldn't be particularly memory intensive.
Hi I’ve looked through most of your implementation and have a couple of notes. Some of them are just syntactic preferences, others may lead to bugs. 1) Consider the fact that your ABS function may try negating MIN_INT, which leads to UB. 2) Your vec3_is_zero is missing the third element zero check. 3) Instead of writing ``` if (v0[0] &gt; v1[0]) { result[0] = v0[0]; } else { result[0] = v1[0]; } ``` you can use more elegant ``` result[0] = v0[0] &gt; v1[0] ? v0[0] : v1[0]; ``` or even ``` result[0] = max(v0[0], v1[0]); ``` 4) I don’t think that nearly_equals function requires intermediate value to store the result. It can also be expressed as: ``` return (a == b || MFABS(a - b) &lt;= epsilon); ``` Notes aside, nice job
here is a literal copy and paste .. again : Just for fun have a read of this article from the man that is considered the "father" of floating point : https://people.eecs.berkeley.edu/~wkahan/Mindless.pdf That is Professor William Kahan and he really does know what he is talking about. Most of us don't. I sure don't. However I have a handle on some of it. So the lesson to be learned here is that you won't get perfectly precise values from calculations with floating point numbers ALL the time. In fact, you will rarely ever get perfectly precise results. Ever. However if you are okay with an itty bitty teeny little error then you can work with floating point just fine. Don't listen to people telling you that you must use integers. That won't work in the real world doing financial calculations or fluid flow computations. You can also try to use a seriously precise library such as libgmp or libmpfr but that merely compounds the problem in that you need a ton of knowledge to use them. Correctly. Any damn fool can calculate the sine of an angle and then say "ta da!" there it is to twenty digits. Mostly you can't calculate the sine of an angle to twenty digits. Not on this planet or universe anyways unless you use outside math library packages. ( look into infinite Taylor polynomial expansion series and concepts like irrational numbers for fun ) Also look at the man pages for functions like "int isinf(real-floating x)" which asks the question "is this value x an infinity?" and other cool stuff like a value for zero that is negative. Here is a fun and entirely reasonable approach to subtracting some value from a floating point number while looking to hit zero. Don't do that. You should look for a value that is close to zero within some precision or error margin we can call epsilon. That greek letter epsilon gets tossed around a lot in floating point and it looks like this : set some value foo to 1.1 ( one plus one tenth ) set epsilon to a really small positive value close to zero enter a loop subtract one tenth from foo did a floating point exception happen? yes? report that. check to see if the magnitude of foo is greater than epsilon if we are not close to zero by some itty bitty bit epsilon then loop again print out the final value of foo That is worth doing for no other reason than to see floating point exceptions flying : #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #include &lt;math.h&gt; #include &lt;fenv.h&gt; #pragma STDC FENV_ACCESS ON int bin_printf ( uint8_t* f, size_t n ); int main (int argc, char* argv[]) { float foo = 1.100f; /* the suffix letter f means this is a float */ float epsilon = 1.0E-7f; /* this is _about_ 0.000001 */ int fpe; /* this is a flag */ int j; /* clear all possible floating point exceptions */ feclearexcept(FE_ALL_EXCEPT); if (fesetround(FE_TONEAREST)!=0){ fprintf(stderr,"ERROR : can not set floating point rounding!\n"); return EXIT_FAILURE; } printf("starting value of foo = %8.7e\n", foo ); for ( j=0; fabsf(foo)&gt;epsilon; j++ ){ /* do a trivial subtraction */ foo = foo - 0.10f; /* did we just toss an exception? */ fpe = fetestexcept(FE_ALL_EXCEPT); if (fpe!=0){ printf("INFO : Exception raised was"); if(fpe &amp; FE_INEXACT) printf(" FE_INEXACT"); if(fpe &amp; FE_DIVBYZERO) printf(" FE_DIVBYZERO"); if(fpe &amp; FE_UNDERFLOW) printf(" FE_UNDERFLOW"); if(fpe &amp; FE_OVERFLOW) printf(" FE_OVERFLOW"); if(fpe &amp; FE_INVALID) printf(" FE_INVALID"); printf("\n"); } printf("foo = %8.7e\n", foo ); feclearexcept(FE_ALL_EXCEPT); } printf("\nfinal value of foo = %8.7e\n", foo ); bin_printf ( (uint8_t*) &amp;foo, (size_t) sizeof(foo) ); return EXIT_SUCCESS; } compile and link that to libm and run it : $ ./foobarf starting value of foo = 1.1000000e+00 INFO : Exception raised was FE_INEXACT foo = 1.0000000e+00 INFO : Exception raised was FE_INEXACT foo = 8.9999998e-01 INFO : Exception raised was FE_INEXACT foo = 7.9999995e-01 INFO : Exception raised was FE_INEXACT foo = 6.9999993e-01 INFO : Exception raised was FE_INEXACT foo = 5.9999990e-01 INFO : Exception raised was FE_INEXACT foo = 4.9999991e-01 INFO : Exception raised was FE_INEXACT foo = 3.9999992e-01 INFO : Exception raised was FE_INEXACT foo = 2.9999992e-01 INFO : Exception raised was FE_INEXACT foo = 1.9999993e-01 foo = 9.9999927e-02 foo = -7.4505806e-08 final value of foo = -7.4505806e-08 10110011 10100000 00000000 00000000 Okay so that last bit simply dumps out the binary floating point value which is a single precision 32-bit floating point representation for that tiny remainer left over at the end. Note that nearly every single subtraction operation results in a floating point exception being tossed called "FE_INEXACT" which is very true. However when we fell down to around 0.2 the exception went away. Cool huh? edit : forgot to give you a ref link http://www.gnu.org/software/libc/manual/html_node/Rounding.html Note that "Round to nearest" is the default however you need to see the binary representation of the floating point data to really know what that does. The description is pretty clear : In this mode results are rounded to the nearest representable value. If the result is midway between two representable values, the even representable is chosen. Even here means the lowest-order bit is zero. This rounding mode prevents statistical bias and guarantees numeric stability: round-off errors in a lengthy calculation will remain smaller than half of FLT_EPSILON. 
&gt; The features Autotools provides were necessary 20–25 years ago Take a look at http://sortmail.sourceforge.net/. I wrote that package 28 years ago, and I didn't need autotools to make it portable. But I agree with your basic premise. Everybody supports (or nearly supports) Posix, and that's as portable as it gets. Even µsoft is finally coming on board.
Why do you want to optimize disk space? Using extern globals means they're only reserved once in RAM across multiple files, but as far as disk space goes, the biggest factors are the size of the assets you need to load (images and such) and the size of your save files, both of those can be optimized but I'm not too sure why you would, disk space is typically so cheap that it doesn't make sense unless you're really having a storage space problem.
Which one do you think it is, and why?
Try this https://cdecl.org
Try doing your homework yourself.
Well, the entire idea was to just make as small a chess game as possible to use in various things. Was going to try to put it in an arduino at some point
Well, I would love to that but still I am cofused hence asking you guys !
char *(*foo[3]) ?
ah but is it char* ptr or char *ptr
keep the type as one thing and the name separate from that I always find mixing the two ugly and confusing. What is the rationale behind the later?
char* fizz, buzz is a ug
&gt; Another one is to implement a stack using queues and vice versa. This is an exercise in like every intro data structures book. But really, what's the point? You'll never implement a queue using two stacks, and implementing a stack using queues guarantees at least one of the operations is no longer constant time.
By the same argument, you almost never implement any of the data structures, it's always an exercise in understanding the trade offs of each data structure. Implementing queues in terms of stacks and vice versa gives you a deeper understanding of both structures.
Note, I didn't downvote you. I'm pretty constantly implementing data structures in C. Its one of those things you have to do when the language doesn't support compile time polymorphism.
C has a nice symmetry between expression syntax and type syntax. If you write `int *(*foo)()[5]` then you know that `*(*foo)()[n]` is of type `int`. Keeping the `*` to the right emphasizes that.
I agree, i think it would be ideal if it was (*char)[3] ptr
There's no difference.
It's no different from calling another function. Anything you can do with a call to another function, you can do with a call to itself.
A bit late but: i'll follow your advice; usually i don't use paper and pencil for these things, because i'm really out of practice, my handwriting is full crap :v but again, i'll follow your advice... Thank you :)
I've decided to post it here as a link, since it would take a lot of time to format it in the same way as on StackOverflow. Please let me know if this question should better be re-created from the scratch on the Reddit; I just wanted to avoid duplication. To me it looks that documentation on kqueue is a bit scarce, and it's really unfortunate: whilst there are many articles and posts describing epoll, the kqueue interface seems a bit more superior to me, given that it can enqueue/dequeue multiple events at one time and doesn't require a special syscall for each activity (eventfd, signalfd, timerfd\_create and so on). However, I've just started investigating kqueue, and I currently struggle to discover some of its flags. Any help, including pointers to good articles and sources, is highly appreciated. Thank you!
You're probably not going to get an exact one to one correspondence.
I had to learn math myself since i flunked all my math classes in high school. I’m willing to help you learn the math you need for computer science starting from scratch. pm me I can’t be your personal tutor of course, i don’t have the time. but you can email me or message me whenever you have a question or need me to steer you on the right path. I am still finishing up my degree so I can only help you in learning programming but not in getting a job unfortunately. 
Assuming it's PCM, to downsample just chop off the lower 4 bits: int sample4bit = sample8bit &gt;&gt; 4;
OP is allocating a single structure, and then using that structure to execute 10^9 functions. I don't think the allocation time of the structure is particularly relevant at all.
Maybe try r/freebsd or the mailing list or email one of the developers once you've exhausted all the resources you could find and narrowed down your question to something more specific. Then write about what you learn. I would think it could be hard to find someone who has experience with something this specific.
In the embedded world, you use `extern` a lot. The best way I find is to declare the variable in main.c (without the `extern` modifier) and in the other modules (.h and .c files) that need to know about this variable, you declare as `extern`. If the variable needs to be initialized you do it only on the main.c file.
MinGW is indeed a port of the GNU toolchain used to build Windows applications. But it is **not** exclusively available on Windows. You can fairly easily get a copy of MinGW on Linux which allows you to compile Windows stuff on Linux.
Sorry, thats not downsampling, thats less precision. If you need to downsampling you keep the original precision (8 bits) and take fewer values. Say you have an original vector a\[\], you can downsampling by two if you take anly the values for a\[0\], a\[2\], a\[4\]...
How easy and irresponsible to make such a forward looking statement. You won't be around in 100 years to owe up to it. 46 years later plenty of new C projects are to be found on GitHub, never mind existing ones. The language may evolve quite a bit, but that doesn't mean investing in something like C/C++ today is risky. While the same cannot be said about Rust, and that is what the article is all about. Disclaimer: I'm not a C/C++ or Rust user.
Not C, but you could do this: cat input.wav | xxd -p | sed -E 's/(.)./\1/g' | xxd -r -p &gt; output.dat
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/freebsd] [\[x\/post\] How do epoll flags correspond to kqueue ones? • r\/C\_Programming](https://www.reddit.com/r/freebsd/comments/96enbx/xpost_how_do_epoll_flags_correspond_to_kqueue/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
The full correspondence is not something that's I need; I just want to check whether my understanding of the documentation is correct. Frankly speaking, the documentation is a bit tricky and confusing, so the reason to ask that question was just to clarify the details.
Thank you for suggestion! Cross-posted for now, but will certainly visit freebsd-hackers in case of no success.
If you get bored of data structures you could also try implementing some design pattern such as the ones covered here: [http://gameprogrammingpatterns.com/contents.html](http://gameprogrammingpatterns.com/contents.html) (Yes, this book is in C++, but that's not to say the core concepts can't be applied to C.) A good one to start with is the observer (aka callback) pattern. For event-based programming it is a must-have.
I never really thought much of define until I did a deep dive into variadic arguments and making prettier C API interfaces. Some pretty insane stuff can be done with macros like [exceptions in C](https://github.com/guillermocalvo/exceptions4c) and a [map macro](https://github.com/swansontec/map-macro/). The latter combined with variadic arguments can get insanely powerful. Below is a short practical example: \#include "map.h" /\* github.com/swansontec/map-macro/ \*/ \#define FREE\_ONE(ptr) (free((ptr))) \#define TO\_ZERO(ptr) ((ptr) = 0) \#define FREE(ptr, ...) \\ (MAP(FREE\_ONE, ptr, ##\_\_VA\_ARGS\_\_), \\ MAP(TO\_ZERO, ptr, ##\_\_VA\_ARGS\_\_)) // Usage example int main(int argc, char \*argv\[\]) { int \*a, \*b, \*c; float \*x, \*y, \*z; /\* Allocation and whatever work needs to get done... \*/ FREE(a, b, c, x, y, z); /\* Works with one or more arguments of any type! \*/ if (a == 0) printf("No dangling pointers! FREE() took care of that!"); }
maybe read your question again and try to phrase it so that your problem is understandable. A specific 0 ? All 0s ? The first Array element? to what last part? The last array element? Moving all the 0s to the end of the array? But in general you're an IT Student it's probably expected that you read some book about C, one of the fat ones that cover everything. At least my course was like that: 1. read this book! 2. solve this complicated task that requires you to have red every chapter to qualify for the exam! 3. Write the exam that's mostly unrelated to C! Even though i hated this approach by mainly learning by reading it was pretty efficient. Wouldn't recommend it for everyone, because it's basically just memorizing all the concepts and syntax without doing examples. But since learning from books without practical experience is basically your main job at a university you should become rather good at it anyway. 
Thank you! My professor did not recommend reading any books.I might go to library again since I saw some programming books there. So for the question im verry sorry if it is not understandable. Its like scan every number if one number is 0 move it to the last part and continue scanning until all 0 is at the last part of the list like (1,0,2,3,0,5) to (1,2,3,5,0,0).
All of that interest me. I want to do it one by one like which one will most likely to help me understand the language. Thank you for sugesting. I will try to sort it base on my interest.
Thank you, I will try what you suggested and thank you for that tip :)
at that point it's not really a C problem just a general algorithm problem. There's probably some highly efficient algorithm that does exactly that, which would be the best thing to use. But you'd need to know what this problem is called to find it. Which i don't that means you will have to come up with your own idea. 1. Step is finding a zero, going through the array from the beginning to the end using a for loop. Inside is an If that checks if the number is a zero. Just write a for loop that tells you the positions of the zeros to make sure everything works as you expected 2. Step move the zero to the end of the array, that means you need to swap the value of the array elements (it's a very common problem and you should probably try to figure out how it works just as a learning experience it's not hard but helps with understanding variables and how they work). 3. Figure out why that doesn't work, there's multiple things this approach didn't consider. A 0 is already at the end, that means you swap a zero with a zero and you didn't gain anything. And this happens right away in some cases but the second swap will swap the zero you put there in the first place back into the middle of the array. So you need to keep track of how many zeros you swapped and where to put the next one. Not hard but i will leave the thinking to you. Figuring this out will help you a lot later, you will need to debug programs and you will need to use additional outputs that help you figuring out where the algorithm goes wrong. Also you can use a good IDE/Debugger that allows you to set break points and see the values of the variables at each break point. That way you can just step through your program and look what happens each loop. 
because unlike type-names, stars are scoped only to the next identifier. char a, b; // Declare two chars char *a, b; // Declare one char pointer and one char char* a, b; // Still only one pointer char a, *b; // This cannot be made sense of using your logic. char* a, * b; // Now you have an implicit char for b? Types contain two pieces of information: the length of the pointer chain, and the kind of data at the end of that chain, these pieces are used very differently. Fundamentally, `int **foo` and `char **bar` are much more similar to each other than `int **foo` and `int bar`, which is more obvious at a glance by putting the stars next to the identifier. You have to first treat them like double pointers, and then like ints or chars, until you actually go to then end of the pointer chain, it actually doesn't matter what kind of data is at the end of it. This is also further exemplified by the existence of anonymous pointer types (`void *`) while there is no anonymous data type (`void` denotes the absence of return value or parameter list). It is possible to pass pointers around without knowing what's at the end of it, while that's impossible for data, it's also easy to see why at the hardware level: pointers have a consistent size, while the size of data varies. All of that to say: whether or not something is a pointer is actually much more important and influences behaviour much more than what's at the end of the chain.
since someone answered the "why doesn't it work part", here's how to make it work: divide at the end. `(2+((n-1)*2)` is always even so using integer division to divide by two will always be a whole integer. long f = (2+((n-1)*2)/2*n also, note that 2+((n-1)\*2) == 2 + (2n-2) == 2n, so actually the entire thing can be rewritten as (n/2)\*2n == n². If you're actually trying to compute the sum of the first n integer you're using the wrong formula, the right formula is n\*(n+1)/2, with this one you'll never have any problems with integer division because n\*(n+1) is guaranteed to be even.
For example, the way I would sove your problem in python would be: arr = [0,1,2,0,3,4,5] moves = 0 for i in range(len(arr)): if arr[i] == 0: if moves &lt; len(arr): arr.append(arr[i]) del arr[i] print(arr)
Just tried it and it tells me unknown error server overload. Even though the visualization might be nice I'll stick to my trusty offline IDEs for know (visual studio &amp; eclipse both work just fine for me) and it's probably good to get used to those tools. But if it works it's probably great for learning.
C++ is off toopic in this subreddit. Please post C++ questions to /r/cpp_questions instead.
Best suggestion I can give you is to get a piece of paper, draw an array as a row of boxes and fill those boxes with your data. Then imagine how \*you\* would solve the problem. What would you do first, then what, and then what? Then try your method on some other examples. If you've worked out how you can do it, try to write a program that uses the same method.
The stanford course programming paradigms is very helpful to learning C.
B
Program to find leap year using if else in c++ r/https://youtu.be/TP6qD4AoCEg
Guess you need to multiply all elements of supplied array? Like this int fnMultiply(int* array, int elements);
How to i ask the user to state the size of array
Disclaimer:not much of a programmer and claim no special expertise, but have tried a few things and have some experience of learning as a newbie. In my opinion, learning C as your first language is not a good idea. Sensible choices are python, javascript or scheme. Python is an all round language with lots of libraries - you will be able to make something useful very quickly. Javascript is the language used for web programming - again you could make some interesting things quickly. Scheme is a brilliant teaching language with minimal syntax - the point of learning it is to work through a book such as SICP,where you will learn some computer science that will stand you in good stead. Learning C as a second or third language is a much better idea. You can copy the code for linux utilities and write your own versions.
I think this is what the question asks for: fnMultiply(int *a, int n) { return n-- ? fnMultiply(a, n) * a[n] : 1; }
Learn about the C memory model. This is absolutely essential. 
Woah that's really damn cool. Hard to understand how you messed with the macros but thats such a cool function. I think I'll implement it for freeing up space when using data structures. Thank you! If you have any more of these cool tricks I'd love to see em :)
It's someones homework that you just solved for them. Not that the teacher will think this is his/her solution anyway :) No downvote from me though...
I can't complain since this is the language my professor use to teach us. I know a friend that will study I.T I heard they will use C++ as their first language (He has no experience or knowledge about computer/knowledge). 
Thabk you
Thank you for this one Might be one of our seat/homework in the futre
Eh, I don't think handing in that thing would help much at all.
My school curriculum is entirely based on C. The first project was to recode about 20 functions from the C Standard Library + code a 30ish functions that are similar. I feel like this is the best way to understand C in depth from the beginning. If you want more infos or a link to the project instructions just tell me and I’ll send you my GitHub repo.
Yeah honestly, just find a project that interests you and go ham until something works like you want it to. For me, that was rewriting shitty phone games that really got me learning how to program 
That's a clever solution
Former newb that learned C as his first language a couple years ago: You could not be more wrong, C is very easy to learn because there's not a whole lot of bullshit abstraction mechanisms in your way. 
Conway's Game of Life (https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life) is a good simulation to build and help with understand the concepts of loops, matrices, etc. For building this in C, you don't have to get fancy and build a graphical front end. Outputting to the terminal emulator in Linux works well.
**Conway's Game of Life** The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.The game is a zero-player game, meaning that its evolution is determined by its initial state, requiring no further input. One interacts with the Game of Life by creating an initial configuration and observing how it evolves, or, for advanced players, by creating patterns with particular properties. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
So, what did you actually produce?
C and C++ are low level languages. Sometimes they are hard to understand and you can even get cancer. If you really want to learn C (or C++) just dig in more and more. Learn structs, OOP, pointers etc. And learn network programming too. Learn socket programming. Also if you don't want to get cancer while struggling with for loops, semicolons etc, i suggest you to learn Python or Golang. You won't be struggling with lots of things because most of the things that makes you crazy in C are automated. Also as like others have said, try to develop a project and focus on a subject (Game developing, AI, etc) Good work!
Wouldn't this result in replacing values &lt;= 15 with silence (0)? It seems to me, that instead of cutting the bottom values off, it would instead be necessary to reduce resolution instead - i.e. convert each 2 bit region of the eight bit sample to one bit. So: 8-bit = 4-bit 0-3 1 4-15 3 16-64 7 128-255 15 Just a guess, as I have never done anything with audio. 
That's a good way to overflow your stack.
Just remember - confusion is okay. That means you’re about to learn something. Take your time and analyze the syntax in small pieces, and you will figure it out.
Get yourself a book and type out, compile, and run every example program. You need to learn things that some programmers forget isn't something you are born understanding. How the core components of the language behave, some knowledge of the standard libraries, how to read code and run it in your head, and how to take ideas in your head and turn it into a program that runs using your fingers. I don't recommend C for a first language because there's a bit of voodoo where you are including header files before you know what they are and declaring a main function before you know what a function is and there isn't a whole lot of intermediate level C programming resources out there. That said, the book I learned C from was 500 pages long and covered the core of the language, the standard libraries, compiling programs with multiple files and an introduction to algorithms and data structures. My C++ book was 700 pages long and I immediately had to start googling and reading a lot of documentation to do anything useful.
It's not just the phrasing, it's also woefully incomplete 1. What type should be used for the number of integers to multiply? 2. Is there a requirement for what should happen if the number of integers is zero (or even negative)? 3. Is there a requirement for what should happen in case of overflow?
To be fair, the question is poorly worded. There are a dozen more comprehensible ways to ask the same no.
The difference between 00000000b and 00001111b is simply smaller than the resolution of 4-bit samples. That's why they map onto the same 4-bit sample. If you merge 2-bit regions as you suggested then: 10101010b (170/255 = 67%) =&gt; 1111b (15/15 = 100%) Which is definitely not desirable. Truncating the bottom bits is better: 10101010b (170/255 = 67%) =&gt; 1010b (10/15 = 67%) The bottom four bits represent such small quantities that they're irrelevant at a 4-bit resolution. 
I wasn't referring to the student
Hey send your GitHub repo. Thanks! 
Learn basic data structures and their operations then build them in C. Learn memory management in C then learn pointers. Then arrays, linked lists, trees, hash tables, and graphs. They each build off core concepts such as using pointers and structs and will eventually lead you to learning about runtime. 
Because learning assembly is like learning two languages if you do not know one already. When you think of writing code to go through an array - you do not think of moves and registers and jump instructions. You think of each index in an array from 0 to the last one. Also C is not portable assembly. 
In that case, I completely agree.
Yeah, I thought about it more after I posted. 15 is only around 6% of 255. Most likely, most of the values this small are noise are wouldn't be missed. 
It helps now. Sometimes its easier to treat things like black boxes when learning. Should someone learn what a stack is in their first programming lecture? I think it is easy to treat C like portable assembly but it can be dangerous. Lets say you have a while loop and you repeatedly check a non-volatile integer's value, that could get optimized away and now you have this weird concurrency bug that is very hard to find. Lets say you call malloc twice and compare the pointers returned, that is undefined behavior.
**Dither** Dither is an intentionally applied form of noise used to randomize quantization error, preventing large-scale patterns such as color banding in images. Dither is routinely used in processing of both digital audio and video data, and is often one of the last stages of mastering audio to a CD. A common use of dither is converting a greyscale image to black and white, such that the density of black dots in the new image approximates the average grey level in the original. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/C_Programming/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
It is important to note though, that if you store the result of a recursive call somewhere, and then perform some more steps, then your function will not be _tail recursive_. This means that every recursive call will grow the stack, which might result in a stack overflow for high amounts of recursion. A common method to turn a normal recursive function into a tail-recursive one, is to pass the intermediate result (frequently called the 'accumulator') as one of the parameters into the recursive call, so the 'work to happen afterwards' can be done either at the start of the next recursive call, or at the end of the base case. [Example code here](https://repl.it/repls/LightblueNarrowNanocad)
Thanks guys I've (kind of) got it working :). It sounds a bit noisy so I'll keep working at it
Learning to program is a process of learning how to approach problems in a way that is translatable to a computer. It is not intuitive. Some languages make this easier than others. Some languages help prevent you from doing things that are counter-productive. Others don’t. C is a powerful language because it allows you nearly full access to all the capabilities of a computer with little restriction. C is also the grand-daddy of so many more modern languages that learning it is a jump start on languages like C++, Python, JavaScript and a host of others. There are many great resources to learn the language available on the Web. But at the risk of sounding like the old guy on the porch, here goes my recommendation. When I first started to program there was very little in the way of source materiel. I learned BASIC partially through school and a lot through experimentation. There were no text books, you experimented, you asked if you could do a thing and then tried to do it through trial and error. When I went to Uni and studied Comp Sci Lo and behold there were manuals.. big nasty boring IBM manuals.. until I took Small Computer Systems and was introduced to UNIX and C. The text book was the classic Kernihan and Richie. It was terse, straightforward, practical and like drinking from the fountain of all knowledge. It taught me to think like a Systems Programmer, to worry about optimization, utilities and versatile functions. Combined with the companion UNIX book and you felt like there was nothing you could not code your way out of. I still own both these books and I always find them inspirational. I know they are still floating around. Find a copy, crack it open and learn from the Masters of that language.
Regarding books, I recommend starting with "C Programming: A Modern Approach" by K.N. King. Once you have the basics down, you can try "The C Programming Language" by Brian Kernighan and Dennis Ritchie for a more advanced look at the language. Finally, "The Practice of Programming" by Brian Kernighan and Rob Pike provides a more general introduction to programming, for problems like that above.
Thanks to everyone who gave their advices I appreciate it alot and it will really help me learning programming :)
any idea where can I get a conio.h for Linux? google just gave me some replacements that use ncurses but with those result in linker errors.
Execute following command to resolve the linking error. sudo apt-get install libncurses5-devlibncursesw5-dev 
conio.h is not present in Linux, we can use curses.h instead. To get curses.h and related libraries, run following command. sudo apt-get install libncurses5-dev libncursesw5-dev 
This makes me happy. It's nice to see someone writing in C who hasn't been banging bits since 1976. Welcome, newcomer!
This. You shouldn't use recursion in cases like this. While they sometimes can seem like elegant solutions they can quickly flood the stack, just do it in a loop.
Note that there is no language named C/C++. Are you programming in C or are you programming in C++?
So Arduino uses the Atmega chip. You can buy an Atmega chip, I have a bag of like 20 or 30 for 5 bucks, and get a programmer that let's you upload your own header and source bit files. These have easy tools. If you want to try an older chip but with still a fairly easy architecture you can look into getting a PIC chipset and programmer or maybe even a development board. You can try by using an IED provided by microchip or code and upload it yourself. If you are serious about learning embedded MCUs then you will NEED to get comfortable with data sheets. I suggest you start easy with an 8-bit controller since it will only be 200 pages and you will be forced to learn conservative coding for memory control. This is the best advice I can give from experience and working in a firmware environment. There is also an amazing website on learning embedded systems that can be found by search r/ece that I suggest. He has a whole tutorial set on PIC16 along the lines of what you are doing. As a note, Arduino is great for quick prototyping and proof of concept before going to a more mature MCU. 
Arduino isn't a programming language, the code you write in sketches *is* C++, just with a thick layer of libraries that abstract the hardware. It's not a HW architecture, either; classic Arduino boards are typically Atmel AVR microcontrollers with a bootloader pre-programmed (there are also many ARM-based Arduino boards on the market today, too) You don't have to use these libraries if you want to work with the hardware directly. You can even discard the Arduino IDE altogether use any compiler/toolchain targeting AVR microcontrollers and upload the code to an Arduino board. Virtually every microcontroller on the market will have a C or even C++ toolchain if you want to something other than AVR. Sorry if this is getting too off-topic.
Thanks brother :) 
You can [program the Arduino in C](https://balau82.wordpress.com/2011/03/29/programming-arduino-uno-in-pure-c/). Ubuntu has the tools needed to program arduino from the command line in the repos. the Arduino is basically a hardware design, a set of libraries and a boot loader. As such, you can program it with any language that you can find a tool chain for.
almost too easy - thanks.
something isn't working as expected. I had three runs now, always "thought" of 27 and it was always wrong. output of the last session: THINK OF ANY NUMBER BETWEEN 1 AND 31 INCLUSIVE! FIRST ROW : 3 1 5 7 9 11 13 15 17 19 21 23 25 27 29 31 SECOND ROW : 6 3 2 7 10 11 14 15 18 19 22 23 26 27 30 31 THIRD ROW : 4 5 6 7 15 13 14 12 20 21 22 23 28 29 30 31 FOURTH ROW : 8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31 FIFTH ROW : 31 17 18 19 20 21 22 23 26 25 24 27 28 29 30 16 JUST KEEP THINKING AND TELL, IS THE NUMBER PRESENT IN THE ROW 1 ? (Y/N) :y FIRST ROW : 3 1 5 7 9 11 13 15 17 19 21 23 25 27 29 31 SECOND ROW : 6 3 2 7 10 11 14 15 18 19 22 23 26 27 30 31 THIRD ROW : 4 5 6 7 15 13 14 12 20 21 22 23 28 29 30 31 FOURTH ROW : 8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31 FIFTH ROW : 31 17 18 19 20 21 22 23 26 25 24 27 28 29 30 16 JUST KEEP THINKING AND TELL, IS THE NUMBER PRESENT IN THE ROW 2 ? (Y/N) : FIRST ROW : 3 1 5 7 9 11 13 15 17 19 21 23 25 27 29 31 SECOND ROW : 6 3 2 7 10 11 14 15 18 19 22 23 26 27 30 31 THIRD ROW : 4 5 6 7 15 13 14 12 20 21 22 23 28 29 30 31 FOURTH ROW : 8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31 FIFTH ROW : 31 17 18 19 20 21 22 23 26 25 24 27 28 29 30 16 JUST KEEP THINKING AND TELL, IS THE NUMBER PRESENT IN THE ROW 3 ? (Y/N) :y FIRST ROW : 3 1 5 7 9 11 13 15 17 19 21 23 25 27 29 31 SECOND ROW : 6 3 2 7 10 11 14 15 18 19 22 23 26 27 30 31 THIRD ROW : 4 5 6 7 15 13 14 12 20 21 22 23 28 29 30 31 FOURTH ROW : 8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31 FIFTH ROW : 31 17 18 19 20 21 22 23 26 25 24 27 28 29 30 16 JUST KEEP THINKING AND TELL, IS THE NUMBER PRESENT IN THE ROW 4 ? (Y/N) : FIRST ROW : 3 1 5 7 9 11 13 15 17 19 21 23 25 27 29 31 SECOND ROW : 6 3 2 7 10 11 14 15 18 19 22 23 26 27 30 31 THIRD ROW : 4 5 6 7 15 13 14 12 20 21 22 23 28 29 30 31 FOURTH ROW : 8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31 FIFTH ROW : 31 17 18 19 20 21 22 23 26 25 24 27 28 29 30 16 JUST KEEP THINKING AND TELL, IS THE NUMBER PRESENT IN THE ROW 5 ? (Y/N) :y GET READY FOR ANSWER! CLOSE YOUR EYES FOR FIVE SECONDS ... 1 NUMBER YOU ARE THINKING OF IS : 21 = ;-) 
I love JIT. Do you have more examples with more complex uses of it? Maybe examples f, accessing (and writing) RAM, jumping, branching, etc.
I'm the author of the article. Not long after writing that article I put this together, which does branching, memory access, and I/O: https://github.com/skeeto/bf-x86 And very recently I used the technique to [find better hash functions](https://nullprogram.com/blog/2018/07/31/), though it's use of JIT compilation is *very* simple.
I agree, that's a really a good solution for 2\^N downsampling
Maybe you are getting some kind of jitter (samples are not going out at exactly the same interval)
What is was doing was completely wrong. I was using signed rather than unsigned 8-bit wav data and sampling it at 4000hz rather than 8000hz. Also I was using stereo rather than mono audio tracks. Seems to work fairly well now. Still looking into adding dithering to try and make it sound a little better.
note for OP, your comment contains pseudocode (it is not legal C syntax) 
Well, I am stuck some.
flushing stdin is undefined behavior.
No, why?
Please try removing that function call
Programming paradigms by stanford
C, C++, and C# are three completely different languages. C and C++ share a common subset, but C# is much closer to Java than it is to C or C++. The topic of this subreddit is C.
Well, it doesn't work properly, but that's not because of the lack of `clrscr()` or `getch()` (or replacement of `delay()` with `sleep()`, which requires `&lt;unistd.h&gt;`), but because you use `scanf()` incorrectly and rely on `fflush(stdin)`, which invokes undefined behavior. THINK OF ANY NUMBER BETWEEN 1 AND 31 INCLUSIVE! FIRST ROW : 3 1 5 7 9 11 13 15 17 19 21 23 25 27 29 31 SECOND ROW : 6 3 2 7 10 11 14 15 18 19 22 23 26 27 30 31 THIRD ROW : 4 5 6 7 15 13 14 12 20 21 22 23 28 29 30 31 FOURTH ROW : 8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31 FIFTH ROW : 31 17 18 19 20 21 22 23 26 25 24 27 28 29 30 16 JUST KEEP THINKING AND TELL, IS THE NUMBER PRESENT IN THE ROW 1 ? (Y/N) :y FIRST ROW : 3 1 5 7 9 11 13 15 17 19 21 23 25 27 29 31 SECOND ROW : 6 3 2 7 10 11 14 15 18 19 22 23 26 27 30 31 THIRD ROW : 4 5 6 7 15 13 14 12 20 21 22 23 28 29 30 31 FOURTH ROW : 8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31 FIFTH ROW : 31 17 18 19 20 21 22 23 26 25 24 27 28 29 30 16 JUST KEEP THINKING AND TELL, IS THE NUMBER PRESENT IN THE ROW 2 ? (Y/N) : FIRST ROW : 3 1 5 7 9 11 13 15 17 19 21 23 25 27 29 31 SECOND ROW : 6 3 2 7 10 11 14 15 18 19 22 23 26 27 30 31 THIRD ROW : 4 5 6 7 15 13 14 12 20 21 22 23 28 29 30 31 FOURTH ROW : 8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31 FIFTH ROW : 31 17 18 19 20 21 22 23 26 25 24 27 28 29 30 16 JUST KEEP THINKING AND TELL, IS THE NUMBER PRESENT IN THE ROW 3 ? (Y/N) :y FIRST ROW : 3 1 5 7 9 11 13 15 17 19 21 23 25 27 29 31 SECOND ROW : 6 3 2 7 10 11 14 15 18 19 22 23 26 27 30 31 THIRD ROW : 4 5 6 7 15 13 14 12 20 21 22 23 28 29 30 31 FOURTH ROW : 8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31 FIFTH ROW : 31 17 18 19 20 21 22 23 26 25 24 27 28 29 30 16 JUST KEEP THINKING AND TELL, IS THE NUMBER PRESENT IN THE ROW 4 ? (Y/N) : FIRST ROW : 3 1 5 7 9 11 13 15 17 19 21 23 25 27 29 31 SECOND ROW : 6 3 2 7 10 11 14 15 18 19 22 23 26 27 30 31 THIRD ROW : 4 5 6 7 15 13 14 12 20 21 22 23 28 29 30 31 FOURTH ROW : 8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31 FIFTH ROW : 31 17 18 19 20 21 22 23 26 25 24 27 28 29 30 16 JUST KEEP THINKING AND TELL, IS THE NUMBER PRESENT IN THE ROW 5 ? (Y/N) :n GET READY FOR ANSWER! CLOSE YOUR EYES FOR FIVE SECONDS ... 1 NUMBER YOU ARE THINKING OF IS : 5 = ;-) 
Yes. I agree with you. Which method should have been used? 
Which method should have been used for what? BTW, my version of your program looks like this: THINK OF ANY NUMBER BETWEEN 1 AND 31 INCLUSIVE! FIRST ROW : 3 1 5 7 9 11 13 15 17 19 21 23 25 27 29 31 SECOND ROW : 6 3 2 7 10 11 14 15 18 19 22 23 26 27 30 31 THIRD ROW : 4 5 6 7 15 13 14 12 20 21 22 23 28 29 30 31 FOURTH ROW : 8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31 FIFTH ROW : 31 17 18 19 20 21 22 23 26 25 24 27 28 29 30 16 JUST KEEP THINKING AND TELL, IS THE NUMBER PRESENT IN THE ROW 1 ? (Y/N) :y FIRST ROW : 3 1 5 7 9 11 13 15 17 19 21 23 25 27 29 31 SECOND ROW : 6 3 2 7 10 11 14 15 18 19 22 23 26 27 30 31 THIRD ROW : 4 5 6 7 15 13 14 12 20 21 22 23 28 29 30 31 FOURTH ROW : 8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31 FIFTH ROW : 31 17 18 19 20 21 22 23 26 25 24 27 28 29 30 16 JUST KEEP THINKING AND TELL, IS THE NUMBER PRESENT IN THE ROW 2 ? (Y/N) :y FIRST ROW : 3 1 5 7 9 11 13 15 17 19 21 23 25 27 29 31 SECOND ROW : 6 3 2 7 10 11 14 15 18 19 22 23 26 27 30 31 THIRD ROW : 4 5 6 7 15 13 14 12 20 21 22 23 28 29 30 31 FOURTH ROW : 8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31 FIFTH ROW : 31 17 18 19 20 21 22 23 26 25 24 27 28 29 30 16 JUST KEEP THINKING AND TELL, IS THE NUMBER PRESENT IN THE ROW 3 ? (Y/N) :n FIRST ROW : 3 1 5 7 9 11 13 15 17 19 21 23 25 27 29 31 SECOND ROW : 6 3 2 7 10 11 14 15 18 19 22 23 26 27 30 31 THIRD ROW : 4 5 6 7 15 13 14 12 20 21 22 23 28 29 30 31 FOURTH ROW : 8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31 FIFTH ROW : 31 17 18 19 20 21 22 23 26 25 24 27 28 29 30 16 JUST KEEP THINKING AND TELL, IS THE NUMBER PRESENT IN THE ROW 4 ? (Y/N) :n FIRST ROW : 3 1 5 7 9 11 13 15 17 19 21 23 25 27 29 31 SECOND ROW : 6 3 2 7 10 11 14 15 18 19 22 23 26 27 30 31 THIRD ROW : 4 5 6 7 15 13 14 12 20 21 22 23 28 29 30 31 FOURTH ROW : 8 9 10 11 12 13 14 15 24 25 26 27 28 29 30 31 FIFTH ROW : 31 17 18 19 20 21 22 23 26 25 24 27 28 29 30 16 JUST KEEP THINKING AND TELL, IS THE NUMBER PRESENT IN THE ROW 5 ? (Y/N) :n GET READY FOR ANSWER! CLOSE YOUR EYES FOR FIVE SECONDS ... 5 4 3 2 1 NUMBER YOU ARE THINKING OF IS : 3 = ;-) 
https://www.youtube.com/playlist?list=PL9D558D49CA734A02
Ok, here's a hint that might help you on your way. `char something;` something is a character. `char *something;` something is a pointer to a char (the * means it's a pointer), `char something[4];`something is a character array of size 4. `();` at the end of an identifier is a function call now take every option up there and try to explain (in English or your native language) what each 'token' means and what ptr is. also fire up your code editor and see what happens with these things. p.s. `char* something;` and `char *something;` are equivalent. (though if you look bellow in the comments you can see that this breaks down somewhat when you define multiple variables at the same time)
Oh yeah. Undefined behavior is a pain. Optimizers abuse the hell out of it. But I still think having asm knowledge helps tremendously if one want to become a better C programmer. 
There are 4 C courses by Duke University on Coursera,starting from the basics to using make files and interacting with Unix system functions
Thanks for posting this and thanks to everyone replying. I'm taking my course of Numerical Methods and the teacher programs using C++ since it's more than C. Best regards!
Is it for noobs like me? Is it from 0?
I'll check this one out too. 
The first half or so talks about C, then goes on to Scheme and python. Not starts from 0 but it has the most complex part of C covered pretty well. Check it out and see if you can follow 
Do you know one that starts from 0? Like the Helsinki one for OOP.
The book :C programming the modern approach by k.n.king , has been recommended by many people. Btw, what is the helsinki one for oop, I live in helsinki and not aware of it, haha
http://moocfi.github.io/courses/2013/programming-part-1/ It's OOP for dummies from the University of Helsinki and it's considered a MOOC. Really good, I didn't completed it but it helped me understand the basics for my OOP course which I'm at right now.
Aint books an option too?
Sort of makes me wonder if anyone anywhere talks about the "go" language?
It's not a course but C Primer Plus by Stephen Prata really helped me understand C.
Does it start from complete basics ?
My Ultrix box doesn't and neither does my 386 box with FreeBSD 2.2.8. Shared libraries don't make sense on embedded platforms.
Just wanted to say "NVM, in section 3 of libtool manual it mentions "An Ultrix 4.2 platform with only static libraries.". I didn't know about Ultrix's existence. Looking it up I wonder if your reply is serious. It had been discountinued a long time ago.
I like to run old hardware and I'm grateful for their commitment to compatibility.
Too bad that as a programmer you will read a loooooooot! But well, articles are not that boring as books, I have to agree!
Yes it does. I have the book too. It's really good.
Thanks a lot
Is there a link? 
Ill second that book. Really easy to follow along. You have to put in the effort and do the programming exercises at the end of each chapter though. 
You accidentally put the source code of your library in a header file.
it wasn't accidental, it's meant to be a single header library. but I feel like I'm being wooooshed here
What is the secret to indenting copied code? I read it somewhere but forgot. You highlight the code and hit a key and it does the whole thing 4 spaces in. 
Header-only libraries are very good if it is relatively small. I think it was a good decision. Also OP, good job. I'll probably be testing it in the coming weeks and let you know what/if I find anything!
I strongly advise against making single header libraries as they come with a number of problems. For example, your library immediately fails to compile once you use it in more than one translation unit since all of your functions are external functions. Just make a normal library, everything is fine if you do.
I meant when its already in the reddit message box. 
I'm not sure if the redesign provides this kind of functionality. RES did, and the old reddit design does not.
I personally never had an issue with single header libraries though I'm sure the problem you described can be a very common issue. Plus I believe in make as much freedom available to the user as possible so I added the option to use the library as either single header or as a normal library. The last paragraph in the \`docs.md\` file describes how this can be done
I personally like single header libraries too but I can see why some people wouldn't want to use those. However I can't possibly decide what's best for the user so I simply added the option to use the library as a normal library if the user wishes, however it is single header by default. To see how you can use it as a normal library just read the last paragraph of the introduction :)
No problem!
Well, the problem I describe happens because you didn't make all your functions `static`. I wrote something about why I don't like this trend of single-header libraries [before](https://www.reddit.com/r/C_Programming/comments/92w1eo/rapidstring_maybe_the_fastest_string_library_ever/e391ctt/).
Another thing you might want to change: according to the C standard, the `#` of a preprocessing directive must be the first character in a line. Code like this: #ifdef LIBDOCX_DEBUG_LOG printf("%s%zu\n", "found all paragraphs, paragraph count: ", document-&gt;paragraphsLen); #endif is wrong even though some preprocessors might accept it. To fix this issue, move the `#` to the first column: # ifdef LIBDOCX_DEBUG_LOG printf("%s%zu\n", "found all paragraphs, paragraph count: ", document-&gt;paragraphsLen); # endif Though a better idea might be to define a debug macro like such: #ifdef LIBDOCX_DEBUG_LOG #define DEBUG(fmt, ...) printf(fmt, __VA_ARGS__) #else #define DEBUG(fmt, ...) (void)0 #endif
&gt; because I'd have to deal with mapping them to a string For strings, macros are okay.
That's a common way to achieve this goal. With this in hand, you might want to allow your header to be compiled in three ways: 1. producing `static` functions if `LIBDOCX_NOSINGLEHEADER` is undefined 2. producing external functions if `LIBDOCX_NOSINGLEHEADER` and `LIBDOCX_IMPLEMENTATION` are defined 3. producing just declarations if `LIBDOCX_NOSINGLEHEADER` is defined but `LIBDOCX_IMPLEMENTATION` is undefined this allows people to dump the implementations of your functions into one translation unit, referencing them from all others. This highlights the main problem with header-only libraries: because they just consist of code dumped into every translation unit, there is absolutely no code sharing. Every function in your library is copied once for every translation unit that uses it. This enlarges your binaries, slows down your code (due to poorer I-cache usage), and makes debugging much harder (because setting a breakpoint on one instance of the function won't set a breakpoint on the other instances). There is no real upside to single-header libraries as even the supposed convenience of just having to dump a single file into your project quickly breaks down once you work with incremental compilation or want to do proper dependency management. I advise you to instead learn how to make normal libraries and do that. 
Thanks for this! I added a slightly modified version of your suggestion.
https://linux.die.net/man/2/time https://linux.die.net/man/2/gettimeofday https://linux.die.net/man/3/timeradd
This is an online version of the Unix/Linux 'man" pages. The system manual built into every system. All C library functions and system calls are included. If you ever need to know how printf works, type 'man printf' at a Unix command prompt.
I know it, but sometimes I don't know how the functions that I need are named. Now I will visit the site you linked every day! Ahahahah
Between Debian and Gentoo, you're on a different kernel (likely with a completely different configuration), a different glibc, using a different version of the client library, and talking to a different version of the server, and all of those were compiled with different options between the two distributions as well. If you're timing the script, you may also be dealing with a completely different shell (`/bin/sh` is dash on Debian). That's a lot of variables to consider. Any of these, or more likely a combination of them, could be responsible for the difference in speed. 
https://linux.die.net/man/1/apropos will let you keyw0ord search the man page database. e.g. 'apropos time'
This is not true. `#` may be preceded by whitespace. Here's what the original ANSI C standard has to say: &gt; A preprocessing directive consists of a sequence of preprocessing &gt; tokens that begins with a # preprocessing token that is either the &gt; first character in the source file (**optionally after white space &gt; containing no new-line characters**) or that follows white space &gt; containing at least one new-line character, and is ended by the next &gt; new-line character. 
Still using dash on Gentoo, I don't think its script related considering that adding even one song takes longer than it usually does. Kernel should be faster considering all the stuff I've removed and glibc doesn't change much between versions I hear. Guess I'll look into mpd's inter-version server/client changes. 
Could someone explain to me what the advantage is of using a custom macro to define a static function instead of using the static keyword?
there isn't an advantage, its the exact same result. It just that if the user wants to make .so/.a library file you shouldn't have static in front of the function declaration. So what I did here was that I put LIBDOCX\_STATIC in front of every function declaration and if the user was operating in single header library mode then LIBDOCX\_STATIC would be defined as \`static\` otherwise if the user wants to use it as a normal library then's it's defined as nothing making it a normal function declaration.
https://www.coursera.org/specializations/c-programming
Debian &gt;
Well I'm not the biggest fan of systemd/dbus/*kits and friends, and didn't really like the defaults. Like for instance I would update the kernel and it would immediately run some hook which would erase the [grub config](https://pastebin.com/raw/PGDaD10r) and replace it with some 5000 line autogenerated nonsense. Also RAM usage is much lower also on Gentoo, not sure if thats a function of USE flags or openrc/sysvinit, probably both. And writing packages on Gentoo is easier for me at least. but hey maybe i'm just biased cause it's what i've used for a long time now
Sorry can you explain to me why you would do that? This looks like an avetaging filter which I think is terrible
Let's start by asking how you would downsample. T
That is weird. I have totally remembered it differently.
libxl it's paid though pretty easy to crack the demo version though
why would I use it over what I have?
Try diagnosing with strace.
it's probably better than yours
Also check out the `alarm` function which lets you set an alarm. After the given number of seconds, a `SIGALRM` is sent to your process which you can catch with a signal handler established via `signal`.
I absolutely agree with FUZxxl. Single header libraries only cause problems and unnecessary dependencies and turn any project using them into an unmaintainable mess, without any advantages.
Single header libraries are universally bad for the user. The user may just not know it yet, and think using them is simple and easy without being aware of the problems. Just say no to single header libraries.
Was it not viable to reuse or link against parts of LibreOffice or Pandoc?
Taking this further, there really is no reason not to use `#pragma once`.
I didn't know about arm_now. Thanks!
Most examples that “blow your mind” are things you should never do in a serious programs. Pointers are boring and mundane and neither exciting nor mysterious. Programming languages which do not have pointers use pointers implicitly. For example, in Java, every time you have an object, what you actually have is a pointer to the object. It's that simple.
I would have a look at the original spectrum, figure out what my target sampling rate is and then apply some filter depending on the bandwidth requirement, probably some FIR filter.
Show me a compiler used in production that doesn’t support it.
Ok. Fair enough. Do you know the curve of the filter I proposed and why it is superior to what was proposed above mine and why my option is commonly used?
well it's the same makefile but gentoo is running gcc 7 instead of debian stretch's gcc 6, hmm
Shouldn't be that much of a difference, there isn't anything to optimize in your code. Is `mpd_run_add` supplied from a system library?
thanks! strace showed read() being called on my giant hosts file (used for ad blocking). Removing it made it actually faster than on Debian. Still kinda weird why debian never had that problem even w/ the same hosts file, but I guess i'll use a browser based adblocker for now.
It's supplied from libmpdclient, the official mpd client library.
The filter you proposed is a moving average filter with two taps. It is also a FIR filter with not that well chosen coefficents. I guess for a two tap FIR filter the moving average is not bad and super fast to compute. I don't know the cutoff frequency of your filter but the frequency response looks like a periodic sinc function.
The cutoff is 1/2 of the original sampling rate, uses almost no computation power and is known as the "simplest low pass filter". [Smith] (https://ccrma.stanford.edu/~jos/fp/Sine_Wave_Analysis.html) The gain is damned near zero at Fs/2, it can be done without multipliers, it can be easily extended at only the cost of some memory. In addition to being cheap as hell, if you need to lower the sampling rate of something and aliasing is a more of a concern than high frequency information, this is pretty great. 
read the docs.md! it's so that the user has a choice between using it as a single header library or a normal library
Well Gentoo is a source distro so yeah I compiled it myself.
I was just asking to make sure that you didn't pass any funky flags during compilation.
I mean if you don't care that much about your passband signal (your audio signal is going to be muddy) and only want to eliminate aliasing then sure go for it. As I said if you don't specify your requirements then anything goes I guess.
I'm honestly pretty convinced by his argument, and it's really not that much trouble to just put \`-ldocx\` when compiling. So per your and /u/FUZxxl's advice I switched the library to not use single header by default, however I still want to give the user the freedom to choose which one they want.
A pointer can be thought of as the address (number) of a slot in memory. Dereferencing a pointer, gets you the value stored in that memory slot. This is a very basic explanation, not meant to be a substitute for a good book or tutorial. Pointers aren’t mysterious, they allow you to access what’s stored in memory.
Fair enough. The advantage is not having to wrangle with conditional compilation. Also no chance to accidentally mess up with macro names by using the standard-reserved underscores.
`char *src = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";` `char dst[100];` `while( (*src) != '\0' )` `{` `*dst++ = *src++;` `}`
Better hope dst[] was full of zeros when you started :)
It looks like English isn't your first language, so I'm not sure I understand your question. That's not a criticism ... just let me know if I'm off-base here. I think you're asking what happens when you declare `int array[10];` -- in what region of memory is this allocated? The answer is, unfortunately, "it depends." Here's an example program that will show each case: int array1[10]; // .bss section const int array2[10]; // .rodata section int array3[10] = {}; // .data section int main() { int array4[10]; // Stack int* array5 = malloc(sizeof(int) * 10); // Heap } I used the ELF section names for each section. The .bss section is the "BSS segment" from your diagram. The .rodata section is the "Read only area" of the data segment. The .data section is the "Read Write area" of the data segment. The stack and heap are obvious. Note that none of this is defined by C itself. It's up to the compiler to determine how to implement the language on any given architecture, and the layout in that diagram is just one possibility. But it's a very common layout in general purpose computers, so there's nothing wrong with using that for now.
You should be able to make hostname lookups faster by (installing and) enabling nscd.
Is it decided by the compiler or linker? For ARM scatter files are read by the linker I think, or am I missing something?
It's really a combination of the compiler, linker, operating system, and the architecture you're compiling for.
 &gt; "it depends" A good example that one can use to show that this is true is [Emscipten](https://github.com/kripken/emscripten) which can compile C to JavaScript; questions like "will this variable be stored in .rodata?" are naturally meaningless there. 
Do not spam.
Ahh that makes sense, thanks!
Can you tell us more about the use case you are working with? If you have only one producer-&gt;consumer pair, then using an ever-increasing number in the producer (and discarding any decrypted numbers lower or equal to the last received number) is one way to prevent common replay-attack methods, which is very tiny to implement. But of course, this will not work in more complex setups, and does not yet do the actual encryption/decryption part for you.
If you want to prevent a replay attack, use some sort of challenge response mechanism. 
Look at any tree or list algorithm. Those data structures are usually implemented with pointers.
Thanks! Now it's entirely fixed, i'll mark it as solved now.
1. Pointers let you build cycles 2. You can swap out a function pointer for another (of the same signature), allowing you to e. g. do some extra work on the first invocation of a call, without performing a check in all of the subsequent calls. 
That makes sense.
:)
I'm pretty sure you could rewrite it to something like this: ```c char \*src = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; char dst\[100\]; while(\*dst++ = \*src++); ```
&gt; Chacha20 Whoa. There's even [chacha-avr](https://github.com/mjosaarinen/chacha-avr)! And it's got the counter thing all built in. Thanks man.
You're welcome!
That's not necessarily a feature of the encryption library so much as how you make use of the encryption. If you have two-way communication, a challenge-response algorithm will do that. I have one hardware product that communicates with an Android app, and we don't want the app being used by competitors for their products, so it uses challenge-response authentication. The app sends out a random string and the device has to encrypt it (using XXTEA) with a shared private key and send back the result before the app will do anything. If you can't have a single shared private key, things get more interesting and key management becomes a significant issue. If your devices happen to have GPS or some other source of external timekeeping, you can use some portion of the time as a salt value. Or if you only have two devices and they have nonvolatile memory, you can send a sequence number as part of each message and only accept messages that have a higher sequence number than the last one you received.
Haven't been paying attention to crypto eh?
How do you protect against someone reverse engineering your app/product to find the shared private key?
I figure anyone who has the resources to extract the private key could probably write their own app anyway. Countermeasures are never absolute, you just have to decide who you're defending against and for how long. Just to have the option available, the devices do have a small number of alternate keys. If the app was compromised (a lot more likely than the embedded side) it could be switched to another key, presumably after more countermeasures were added to the app. The API used between the app and device is public since we want users to be able to interface with the device on their own if they want to. The goal of the authentication was just to keep someone from easily making a cheap knock-off device and using our app to avoid developing one of their own. Each device has a unique serial number so if we really wanted to we could require the authentication to be done through a secure server and you'd only ever have the key for your own device, but it wasn't worth the added hassle. If you require it to be online, that's negatively impacting the user's experience and the threat would have to be a lot more significant before I'd inconvenience users like that.
Abstract pointers....
it's an unsigned integer that's the same size as a pointer. if you're on a 32 bit system it's 32 bits and on a 64 bit system it's 64 bits.
Size_t is an unsigned integer that is able to hold the largest possible size of a piece of data or index for the system that you're using. It's defined differently on different platforms, so it is a portable type. If you used a standard uint on a 64 bit system, you'd only have 32 bits of precision and bad things could happen. 
For me personally I have used size_t to return time, why? Because the sw engineer before me used it for time . for example if I have sleep function. I been using C for a year, so not exactly expert. 
`size_t` is a typedef used to help code portability. When you use `size_t` you don't have to worry about the word size or the addressing space of the target platform, it's all dealt with in the standard library's headers. Typically, you should use `size_t` when you're referring to the size of sections of memory and when you have a variable used to index an array.
yes. First language is Vietnamese. I am trying use more English. I learned more by you. Thank you. 
you answered my question in " int array1\[10\]; // .bss section ". That is my search. I will improve english.
Um, sorry, i may be the thickheaded here: but where does it say that libraries should not print out to stdout/stderr?
Are you modifying the original applications code at all or just wrapping it? If you're just wrapping it you could hijack the dynamic linker(through something like `LD_PRELOAD` on Linux) and make `printf()` and `fprintf()` do whatever you want. If you're modifying the original application I would strongly advise going through and actually implementing a way to customize where all those `printf()` and `fprintf()` calls go. You could also take a lazy approach and just write some a little bit of preprocessor (like that below) to stub out those calls, you'll obviously only want to include the preprocessor within the source files and NOT the headers. #define printf(...) do { } while(0) #define fprintf(...) do {} while(0) 
This is a great example of how NOT to use size_t!
You could allocate a large-enough buffer, use `fmemopen` (assuming you're okay relying on POSIX C functionality) to give it a file descriptor, and then have your fprintf calls print to it. That said, if you are just looking to suppress the output, it is probably better to just set a global boolean indicating whether output should be printed and define a printing macro that prints conditionally on this boolean.
Holdit ... why is it architecture depend[e|a]nt ? Or is it ? 
&gt; Um, sorry, i may be the thickheaded here: but where does it say that libraries should not print out to stdout/stderr? Absolutely nothing, but if a library had no way to prevent its use of standard streams, I would avoid it in any application I were developing.
I love Pointers and they are freaking awesome 😂
The original code is being modified, and I don't want to go with the lazy route.
I actually need to save the output so this looks ideal!
If you want to redirect to a file instead of a buffer: freopen("stdout.txt", "w", stdout); fclose(stdout); 
https://en.cppreference.com/w/cpp/types/size_t &gt; std::size_t can store the maximum size of a theoretically possible object of any type However, you should only use unsigned types like size_t to represent bitmasks, and never for counts or sizes. The standard library's use of size_t is kind of a special case because the library is so old. People have learned over the years that using unsigned integers to represent sizes and counts causes more bugs than it's worth, so the generally accepted best practices among professionals is to only use unsigned when actually have to. For example, the ISO CPP core guidelines have several sections on unsigned: https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Res-nonnegative The guidelines are for C++ but of course some parts apply to C. As with everything in C, there are exceptions. And if you're just learning, don't worry about it too much. But it's very convenient to form the right habits as early as possible. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [isocpp/CppCoreGuidelines/.../**CppCoreGuidelines.md#Res-nonnegative** (master → e31a85d)](https://github.com/isocpp/CppCoreGuidelines/blob/e31a85dc2dbfad666f45e98fe4cbec946ac94158/CppCoreGuidelines.md#Res-nonnegative) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e47txm8.)
Thanks my dude, helped a lot! Appreciate it. 
No probs. If you haven't already heard of it, bookmark devdocs.io and keep it handy. It's a great tool for learning to program as you can easily look up and search coding docs for most popular languages and frameworks.
I actually haven't heard of it. I'm new to C and just working on a personal project, so that would be helpful. Thanks! So I did what you said and it worked well. I'm trying to get the program to quiz the user on all of the factors. Here's my code for the second factor. I'm using an if else statement, but it seems to want to think it's correct no matter what I do. It's as if it skips the last else statement. scanf("%s", Factor2); if (strcmp(Factor2, Factor1)==0){ printf("Stop cheating! What is the third factor?"); } else if (strcmp(Factor1,"A")==0 || strcmp(Factor1,"B")==0 || strcmp(Factor1,"C")==0) { printf("Correct! What is the third factor?\\n"); } else { printf("Incorrect! Try again, for the third factor.\\n"); }
Or use `open_memstream` which dynamically resizes the buffer.
Ah, yeah you're right. It's skipping the rest of my if statement. That's why it was acting wonky. I split it up into two separate if statements and it's acting normally now. Thanks again for all of your help!
Size t is just unsigned int 32 yo
It is common practice, for good reasons. If there is an error, it should provide the error code to the calling code and let it handle it as it wishes (maybe using some logfile, or a GUI, or something else entierly). Writting to stdout can interfiere with the client output, if it uses stdout. An more reasons I don't recall now .
Yes, each architecture has its set of instructions.
Thank you!
opcodes. memory etc etc .. which has nothing to do with the C source code. 
For this use case you should use `intptr_t` or `uintptr_t`. `Size_t` is for sizes, not pointers.
You should be able to have the stdout and stderr written to a file if you replace them with a file descriptor associated with that file using dup2. As for "other programs", each program has their own stdout fd. You won't mess up other programs by playing around with your own file descriptors, unless by "other programs" you mean the ones using the library, those would be affected by the things you define in your library. If you want to allow users of your library to use the stdout and sterr normally, while you log to a file from your library, writing to a file explicitly instead of redirecting the standard streams seems like a better solution.
Instead of saving the output to a buffer, you could allow the users of your library to set a printf-like callback function to receive the output. Many libraries do this for error logging, see abc_set_log_fn() in the [libabc](https://git.kernel.org/pub/scm/linux/kernel/git/kay/libabc.git/tree/src/) demo library for an example.
yes, there is no difference in the C source code, you are right. The topic is about "Compile and run C programs on different CPU architectures" in a very practical way, it gets you started within 5 minutes including: - cross compiling your c program - setup a virtual machine - run the virtual machine - run your program in the chosen CPU architecture.
The gcc compiler would scream at me if I did anh one of those things... Do people just ignore it's output, or not use -Wextra -Wall..?
When people write production code in C, they expect it to run on a variety of computer systems. On some, an unsigned int will hold any possible array size. On others, an unsigned long is needed. Or some other type. So 'size_t' is a portable way of saying "big enough to hold the size of a thing in memory". The compiler guarantees it is the right size. If you're writing code that will only ever run on one machine, it doesn't matter, but correctly using `size_t` is a good habit to develop. Generally, when you are referring to the size of a thing in memory, you should use `size_t`. You should also use `size_t` for an index variable when iterating through an array (*e.g.*, `for (size_t i = 0; i &lt; n; i++) do_something(A[i]);` (and `count` should also be a size_t)). In the 1970s, the Unix world migrated from 16 to 32 bit architectures, and we found thousands of bugs where 16 bit ints were used to store sizes. In the 1990s, Unix started migrating to 64 bits, and we found zillions of bugs of the same type. You'd think we'd learn... Other types of interest: `intptr_t` and `uintptr_t`: signed and unsigned integers guaranteed to be big enough to hold a pointer. `intptr_t my_int = (intptr_t) some_ptr;` `ssize_t`: signed `size_t`. The POSIX `read` and `write` calls return an `ssize_t`. When successful, they return the number of bytes read or written. When they fail, they return -1. (This is because `read` and `write` were defined in the 16 bit days, when developers were a lot less strict about types.)
Use `%zu` to print one. This was added to C 19 years ago; beware that there are some runtimes still out there that don't support it (e.g. Microcrap) , to be super defensive you can cast it to `unsigned long long` and print with `%llu`. 
Can you say it? I want more information. Thank you.
Ok thank you. Your'r comment is very convince.
Can you introduce about [Emscipten](https://github.com/kripken/emscripten)? I need information that. And more application of it.
Do not redirect stdout or stderr. The reason why is if the application that links your library relies on writing to either stdout/stderr they won't be able to use your library. Just suck it up and fix any places that does that.
Hey, one more question: I am coding my master thesis and it has a lot of command-line utilities that are backed by a library. for reference, I am a sysadmin with a CS degree, but I don't practice C every day. Is there a guide somewhere with common practices I could find so I can save myself from making rookie mistakes and, hopefully, headaches?
I dont know ... For example, dont malloc if you can avoid it, and if you need to malloc give a way to the client to provide their own custom malloc/free/realloc (function ptrs). If it is your lib, you probably dont need this. You can check some common OSS libs and see what they do. Also maybe you want to check "C interfaces and implementations". Basically any good C book too (N. King's book A Modern approach for example).
Thank you again!
I can't think of too many times where I've needed a do/while, almost always a while loop will suffice, in my experience. You can encase the entire thing in one big while loop. Start the while loop above the first printf() function. But change one thing, for case 3 instead of calling break, call return (0). That way the program should repeat anytime a user chooses 1 or 2, but will exit in the case of 3.
Why is it not good practice to use it instead of unsigned integers?
Alpha is a variable containing a char that can also be represented as a value. ‘a’ is 97 and ‘z’ is 122. By subtracting ‘a’ from the input char you just find the 0 base of the letter. So ‘b’ is 1 (instead of 98, etc). I certainly would not have solved this problem in this manner though. 
The visual studio extension yes, but for other platforms you have this functionality as well. (gdb) dump memory /tmp/mem.bin 0x1000 0x2000 (lldb) memory read --outfile /tmp/mem.bin --binary 0x1000 0x2000 (lldb) me r -o /tmp/mem.bin -b 0x1000 0x2000
If you try to compile this is won't work because `#include &lt;STDIO.H&gt;` should be `#include &lt;stdio.h&gt;`. It will also give the warning about the `getchar` which /u/redbeard_5000 mentioned. I would choose to use a `dowhile` loop as follows: #include &lt;stdio.h&gt; #include &lt;stdbool.h&gt; int main () { int choice; float cel,fah; bool quit = false; do{ printf("Please make a choice: \n" "1) Celsius to Fahrenheit \n" "2) Fahrenheit to Celsius \n" "3) Exit \n" ); scanf("%d", &amp;choice); switch (choice) { case 1: printf("You choose 1: Celsius to Fahrenheit \n" "Enter Celsius Temperature \n" ); scanf("%f", &amp;cel); fah = ((cel * 9)/5) + 32; printf("The Temperature in Fahrenheit is: %.2f \n",fah ); break; case 2: printf("You choose 2: Fahrenheit To Celsius \n" "Enter Fahrenheit Temperature \n" ); scanf("%f", &amp;fah); cel = (fah - 32) * 5 / 9; printf("The Temperature in Celsius is: %.2f \n",cel ); break; case 3: quit = true; break; default: printf("invalid choice. Please restart program"); } } while(!quit); printf("You choose 3: Exit \n" "THANK YOU FOR USING THIS PROGRAM\n" ); } ___ In a do while loop it does the test after doing the stuff in brackets, compared to a while loop where it does the test beforehand. Compare the following snippets: int i = 10; do{ printf("Loop %d\t", i++); } while(i &lt; 5); printf("THANK YOU FOR USING THIS PROGRAM\n" ); Output: Loop 10 THANK YOU FOR USING THIS PROGRAM and: int i = 10; while(i &lt; 5) { printf("Loop %d\t", i++); } printf("THANK YOU FOR USING THIS PROGRAM\n" ); Output: THANK YOU FOR USING THIS PROGRAM If you compare the outputs of the two you might expect them to be the same; `i` is great than 5 so don't do the loop. But the `dowhile` still prints `Loop 10` once. This is because the loop condition is checked after it's done something Hope that helps a bit. Happy to provide further detail or answer any questions you have. 
&gt;If I'm trying to printf a size_t variable what should specifier should I use, would %d work just as fine? I'd recommend using some type of semantic completion tool, such as YouCompleteMe, when programming. Means you don't have to worry about things like '%d' vs '%zu'
the trie uses `children[26]` so it's using 0:a, 25:z for characters. but internally, C uses ASCII code, where the character 'a' has some value i can't remember, but where the characters are in increasing order (so 'b' is 1 more than 'a' etc). to get from ASCII to 0-25 you can take the character code given (`alpha`) and simply subtract 'a'. for example, if `alpha` is 'a', then you get 'a'-'a' = 0.
 Ugly. However it works. As is. Just that a good compiler may say to you : line 40: warning: statement not reached OKay .. thanks ... but anyways : #include &lt;stdio.h&gt; int main () { int choice; float cel, fah; printf("Please make a choice: \n" "1) Celsius to Fahrenheit \n" "2) Fahrenheit to Celsius \n" "3) Exit \n" ); scanf("%d", &amp;choice); switch (choice) { case 1: printf("You choose 1: Celsius to Fahrenheit \n" "Enter Celsius Temperature \n" ); scanf("%f", &amp;cel); fah = ((cel * 9) / 5) + 32; printf("The Temperature in Fahrenheit is: %.2f \n", fah ); break; case 2: printf("You choose 2: Fahrenheit To Celsius \n" "Enter Fahrenheit Temperature \n" ); scanf("%f", &amp;fah); cel = (fah - 32) * 5 / 9; printf("The Temperature in Celsius is: %.2f \n", cel ); break; case 3: printf("You choose 3: Exit \n" "THANK YOU FOR USING THIS PROGRAM\n" ); break; getchar(); default: printf("invalid choice. Please restart program"); } } $ ./ug Please make a choice: 1) Celsius to Fahrenheit 2) Fahrenheit to Celsius 3) Exit 1 You choose 1: Celsius to Fahrenheit Enter Celsius Temperature -30 The Temperature in Fahrenheit is: -22.00 $ so yeah .. it works as is. However to get better logic flow you could toss in yet another scanf and then a "goto" ( barf barf barf ) and that gets the job done. Really the case switch isn't the way to go here and others have answered already on that. 
It's difficult to understand the context without part A, how does this function fit with the whole program? Just looking at the code above it seems like we need to know what "numwords" represents to understand why that if statement is required.
Part B refers to the part of the test , not the part of the question 
&gt;I certainly would not have solved this problem in this manner though. What would you do differently?
How are you reading the input for `range`? It sounds like the input is breaking on spaces.
You're not using %s with a scanf, right? Don't do that. You need to post the code to get a proper answer, though.
code or no help .. 
\#include &lt;stdio.h&gt; int main(void){ char Range\[100\]; printf("Define range.\\n"); scanf("%s", Range); if (strcmp(Range,"12+, A3s+, B4s+")==0) { printf("Correct!\\n"); } else { printf("Incorrect!\\n"); } return(0); }
\#include &lt;stdio.h&gt; int main(void){ char Range\[100\]; printf("Define range.\\n"); scanf("%s", Range); if (strcmp(Range,"12+, A3s+, B4s+")==0) { printf("Correct!\\n"); } else { printf("Incorrect!\\n"); } return(0); }
\#include &lt;stdio.h&gt; int main(void){ char Range\[100\]; printf("Define range.\\n"); scanf("%s", Range); if (strcmp(Range,"12+, A3s+, B4s+")==0) { printf("Correct!\\n"); } else { printf("Incorrect!\\n"); } return(0); }
UTF8 is a superset of US ASCII, hence 'a' has the same value in a byte regardless ASCII or UTF8 encoding.
Yes, although, &gt; but internally, C uses ASCII code isn't necessarily true. But by subtracting ` 'a' ` from `alpha`, it will work correctly no matter what the encoding. 
Thanks, didn't even know there were alternatives. What would you recommend using instead?
fgets is the most sensible alternative. fgets breaks at newline characters (in other words, it reads in an entire line of text). There's one "gotcha" with fgets which is that your string (assuming the line wasn't too long) will end in a \n character. You will probably want to strip that off. If you're just getting started and aren't interested in too many corner cases, something like this should work fine: char t[100]; fgets(t, sizeof t, stdin); t[strlen(t) - 1] = '\0'; // strip off the (possible) newline character
A trie is basically a tree that contains words decomposed in a chain of nodes. So the word 'trie' would be represented by 4 nodes: t-r-i-e Tries are good for searching words with common root because words branch out when the difference begins, so if we include the word 'tree' the trie would become: t-r-i-e '-e-e The exercise tells you that the set of characters you will use here is only the lowercase letters in the alphabet. They are 26, so each node can have up to 26 children. The exercise represents a node where the pointers to the children are stored in a table. To know which entry you need to access then you see which entry corresponds to the letter you are currently in. In the example above, when looking for 'tree', we first check 't' then 'r' and so on. You can do a chain of if/else blocks or a switch with each letter for the alphabet. However, since in C characters are encoding using US ASCII, you know that all the lower case letters' encoded values are consecutive: 'a' is 1 less than 'b' and so it is until 'z'. You can take the variable holding your current character and apply the "character to children table index" translation by just subtracting the value to the first in the alphabet: 't' - 'a' = 0x74 - 0x61 = 0x13 = 19 So for the character 't' you access the 19th position in your children table.
UCF student?
Oops, thanks.
Common problem. You have to strip the newline character. There are a million ways to do it
good advice !
&gt;Woah, that actually worked perfectly! Thanks so much for helping me with my code, really appreciate the info too dude.
That worked, thanks a lot! appreciate the help
That won't work. If the user enters "12+, A3s+, B4s+", scanf() will stop reading after "12+,"
It turns the ascii value of a into the distance of the letter from a. So a,b,c is 0,1,2, etc.
It's not a programming tutorial. It's a step by step guide on how to use your program. All (as in both) of your tutorials are low effort plugs for your own VSDebugPro plugin, which, otherwise, would be fine. But should be labeled as such.
I compiled your code, those are not the results it gives. How and on what arch are you compiling this? Also, the limit is not 6. What is 1130 / n when n is very large? What is any number / n when n is very large?
I was just playing with that and assume u[infinity - 1] = 6 exactly and the next element is always 6 exactly so that makes sense for a limit of 6. I tried this on a few systems and I get good numbers on my ppc64 servers as well as sparc. Anything intel falls apart fast and my arm system just chokes. However the real problem seems to be that a math library is needed to do this with any level of accuracy. The problem comes from "Handbook of Floating-Point Arithmetic" and is the very first example on page 11. Really tricky. https://www.amazon.ca/Handbook-Floating-Point-Arithmetic-Jean-Michel-Muller/dp/3319765256/ref=sr_1_2?s=books&amp;ie=UTF8&amp;qid=1534395587&amp;sr=1-2&amp;keywords=Handbook+of+Floating-Point+Arithmetic 
Would you use time_t instead of a normal uint? No? Why? Because it indicates the value is of type time and using it for something else reduces readability. There's also the portability reason which the other answer you got covers
Haven't had time to watch it yet (will do as soon as I am back from vacations) If you had time to check it out, what do you think of it? 
Or it is neither ASCII, nor Unicode-based, nor ISO-8859. And even in Unicode-based data, it may be a composite character.
Looks OK but the pace is very slow. I don't know why people want to learn from videos either - way too inefficient compared to books. But if you like this style of learning and you're happy to take it slowly then the quality looks reasonable based on a very quick skim through - certainly a lot better quality than the vast majority of horrendous spammy YouTube "tutorials" that we constantly get bombarded with.
C++ is off topic in this subreddit. Do not post C++ content here.
Yes, it's a shame that we seem to be going all "lowest common denominator" with learning. Videos are useful for certain things, when there is an actual visual component, e.g. how you take X apart, or how do you fix Y, but for things which can be perfectly expressed in text form, such as programming, it makes no sense to have to wade through an unsearchable linear experience like a YouTube video. I'm probably just showing my age... ;-) 
Do you remember when printed manuals from SunOS was a thing? Pepperidge Farm remembers.
&gt; `int main()` 🤔
I strongly prefer to learn from reading as well, though it doesn't have to be a physical book. The trend of putting everything in a video also annoys me. I can read so much faster and process the information so much better than someone blathering on in a video while I watch their mouse dance around for no reason.
Oh man, I bought a course on Udemy for learning Bash, and I had to watch it on 1.5x speed because the guy was so unprepared (for a recorded video!) and went off on so many tangents. I eventually gave up after wasting about an hour and a half, and I've learned more just by searching online for what to do with Bash. And this guy had the highest rating on Udemy for bash too. (Udemy has lots of trash series.)
C beginner here, what's wrong with that? I thought the main-function is supposed to return 0 at the end? Am I wrong? Genuinely trying to learn, no hate :p
You're not wrong, Walter, you're just an asshole.
Bad Bot &gt;:c
Sorry, messed up previous answer in a rush. Will re-explain in a moment.
Short answer: The C Standard specifies only two definitions of the main function: ``` int main(void) { ... } ``` and ``` int main(int argc, char *argv[]) { ... } ``` Note: the name of the parameters is just a convention. Other variations are considered implementation defined and are not guaranteed to be supported by all conforming compilers. Long answer: C Standard: 5.1.2.2.1
Huh, that's good to know. I thought the signature could be almost anything. Thanks!
If one wont use parameters then must use `int main(void)`
 So basically I need a stripped version of this program that only outputs the spot field and wavefront data. The WFS20 is the model of wavefront sensor that I am using (multiple to pick from in the script) which is basically a ccd with a bunch of lenses in front of it. The program needs to automatically trigger the wavefront sensor with some arbitrary input so that it knows to collect data. The standard way to read data from the WFS20 is to use the GUI application that comes with it but I need this to bypass that program and sense real time data once the matlab script runs. Matlab has a C code conversion call that I will be using. I know that there are drivers and the hardware that there are needed to run it but attached is the C script source and header files for the program that I am attempting to alter. I ran it on my computer with the WFS20 connected through USB and it worked just fine. Once it starts it opens a script detects any connected WFS and asks which one you would like to use. Then it prompts a few more questions and sees if the camera has the proper settings to collect data. Once it clears all of that it starts to read out the data to the UI. I need it to run the WFS20 without any prompts from the user. The following link is a library of commands that the program uses: file:///C:/Program%20Files%20(x86)/IVI%20Foundation/VISA/WinNT/WFS/Manual/WFS\_files/Hierarchical%20Function%20Index.html All I need are some pointers for how to go about doing something like this.
Heads up: That link is to a file on your hard drive.
Why would you use byte order marks with utf-8 which AFAIK doesn't use a byte order?
Have you tried setting your locale to a utf-8 one?
Thank you. You had guilde me more knowlegde. If i have a problem. Can you help me? 
&gt;int main(int argc, char *argv[]) Can someone ELI5 what this declaration means? How is does it differ from main(void) and what are these variables used for?
&gt; Does anyone know if linux or the BSDs or the more esoteric posix platforms support UTF-8 with BOM? Filenames are just strings. If the string you pass to fopen() starts with the three characters of the utf-8 representation of the BOM code point, then these three characters just become part of the name of the file.
Thanks for the heads up, I created a google drive specifically for that purpose, there is nothing else on there. should be okay.. hopefully. 
You are a bad person and should feel bad. Take your upvote and port this to Rust.
Why are people always putting _t in their type names? Those are reserved for the compiler right?
Hmmm, strange, it doesn't work for me. When I ran it I got this: lleHoW o!dlr So I tried it with another compiler, but then I got this: llWod! There are zeroes between those letters. Here it is in hex: 00 00 6c 6c 00 00 57 6f 00 00 64 21 |..ll..Wo..d!| *Though* I should probably mention that I ran the first on PowerPC (big endian) and the second on MS-DOS (Borland C++) where `int` is only 16 bits. 
Damn it! Back to the drawing board 
Fixed.
Just to identify a `typedef`. I don't believe it's reserved, but I never remember what is supposed to be reserved for the compiler other than maybe `__` prefix. 
Linus crappy indent
From what I understand is you could run a program with parameters. Since there is no way to guarantee what form the data will come in as from within that program, that is the most generic way to handle it. 
A couple things: 1) Just because a sequence has a limit at infinity does not mean you can simply state things like "thus any element in the sequence cannot be less than the limit". 2) This recurrence relation is drastically different than the Fibonacci sequence which, as a linear, homogeneous sequence is trivial to analyze in comparison to your highly nonlinear sequence.
fuck it, the program has undefined behaviour, compile it to something that formats your hard drive.
A couple things: 1) Just because a sequence has a limit at infinity does not mean you can simply state things like "thus any element in the sequence cannot be less than the limit". 2) This recurrence relation is drastically different than the Fibonacci sequence which, as a linear, homogeneous sequence is trivial to analyze in comparison to your highly nonlinear sequence.
It's pretty common in rust to set a env log for each library and decide to use it in runtime (setting env vars), I prefer to remove things at compile time anyway in release. But it helps a lot to debug things at possibly not cost at all.
&gt; how exactly does this stuff work deep down I can answer that for Linux: `fopen` passes the file name unchanged to the kernel (this is true of glibc and musl, I doubt any other libc's would be different). The kernel filesystem layer imposes two restrictions: the file name can't contain `\0` bytes (because it stops reading bytes at the first `\0`) and considers the `\057 ` bytes (`/`, a slash) as directory separator. Anything else is passed exactly uninterpreted and unchanged to the specific filesystem driver (like ext3, FAT32, NTFS, etc) that handles the filesystem where the file resides. Each filesystem driver interprets file names as it chooses. For example, ext3 writes/reads exactly the bytes you passed as the file name with no changes. That neans it doesn't care about character encoding, so you can use latin-1, utf-8, etc. as you see fit, but if you write a file using an UTF-8 BOM at the start, you must read it using the BOM also (i.e., a file name starting with an UTF-8 BOM is different than one that is exactly the same UTF-8 string without the BOM). Also note that other programs in the system may expect the file names to be in a certain encoding (pretty much all Linux distributions nowadays expect utf-8), and you might get strange results in these programs if you don't. 
No problem. I answer questions on this sub whenever I can.
For code as production ready as this, it really should be endian independent.
Valid point. We did have specific hardware in mind, but portability is a good idea. Would you suggest endianness detection of some sort? 
Fixed
 while ("false") should be while ("true")
What if I just change it to while ("cat")
Would you mind rerunning on your big endian machine?
You might be interested in [this](https://www.ioccc.org/) haha.
thx for the info!
Ok. I think your knowledge is large. So i will take a lot of it.
This is a player structure I wrote for some of the text base games. It uses pointers. enum { MAX_NAME_BUFF = 50 }; typedef const char * cString; typedef struct { cString playerName; uint32_t playerScore; uint32_t playerAnswer; uint32_t playerItems; }Player; /* --- Player public functions --- */ //create/allocate ( My Player ) Player * const createPlayer(void); void initPlayer(Player*const,const cString); //Player setters... const cString setPlayersName(Player*const ,const cString ); const uint32_t setPlayerScore(Player*const,const uint32_t); const uint32_t setPlayerItems(Player*const,const uint32_t); //Player getters... const cString getPlayersName(Player*const); const uint32_t getPlayerScore(Player*const); const uint32_t getPlayerAnswer(Player*const); //erase/deallocate ( My Player ) void erasePlayer(Player*); 
This is totally inconsequential, but do you know if there are any filesystems that do interpret the bytestream as some specific encoding? For example, NTFS uses UTF-16LE, does their filesystem try to decode the stream into UTF-32 or whatever? Shit, how does the hierarchy even work? and how do inodes fit in? How are block ranges on the disk associated with the inodes, and how are inodes associated with the specific path they appear in? does the structure just store the path straight up, or is there like a child field that says which folder X is associate with, and the tree is traversed like that? is there a book or website or something on how this sort of stuff works?
&gt; For example, NTFS uses UTF-16LE, does their filesystem try to decode the stream into UTF-32 or whatever? They probably use UTF-16 internally (since the filesystem uses UTF-16 on disk). On Windows, API functions that take file names in "ANSI" encoding (which is whatever the encoding Windows is configured for at the time) just convert the ANSI file name to UTF-16 using stuff like `MultiByteToWideChar`. Linux must do the same conversion to UTF-16 when using NTFS. I don't know how things are now (it's been a while since I had to deal with NTFS), but I remember that there were two NTFS drivers (`ntfs` and the new `ntfs-3g`, or something like that). One of them assumed the file name given by the user was latin-1 (iso-8859-1) and the other one UTF-8. Maybe there was an option to change that when mounting the file system, I don't remember. &gt; [...] or is there like a child field that says which folder X is associated with, and the folder tree is traversed from root down to whatever id contains the portion of the string between the 2 slashes and on and on until a match is found? Yes, that's very roughly how it works. Each directory contains a list of file/directory names with their corresponding inodes, and to find the inode of a file you traverse the tree from the root directory (which has a pre-defined static inode number). &gt; is there a book or website or something on how this sort of stuff works? If you want a book, the MINIX book [1] is not a bad place to start (it shows how to do a filesystem, but it also has a complete operating system). As for sites, google can find lots of descriptions and implementation of example file systems, I quickly found these two that look reasonable: [2], [3] (but I haven't read them). The link at [2] seems to be part of a book [4]. [1] https://en.wikipedia.org/wiki/Operating_Systems:_Design_and_Implementation [2] http://pages.cs.wisc.edu/~remzi/OSTEP/file-implementation.pdf [3] https://www3.nd.edu/~pbui/teaching/cse.30341.fa17/project06.html [4] http://pages.cs.wisc.edu/~remzi/OSTEP/ 
I do understand for part A. The symbol &amp; represent AND gate. Pls do correct me if I am wrong. Thanks in advance
The `sizeof` operator yields a result of some unsigned integer type. The choice of which type is up to each implementation. It can be `unsigned int`, `unsigned long`, or even something else. The `size_t` typedef is defined in `&lt;stddef.h&gt;` (and in several other standard headers) to document the choice. Remember that a typedef creates an alias for an existing type, not a new type.
What exactly are you having trouble with? What have you tried so far? Where are you stuck? It's probably worth noting that the `0b` prefix is not standard C (it's a GCC extension)
I have trouble understanding why the answer for part B is RA3-RA0. So far I have asked many said it is because of 0b00001111 and 1 shows that are ports for the switches.
20+ years of programming will do that.
A reasonable assumption here is that each bit of `PORTA` can be linked to a switch and you're only looking at the 4 bits represented by `0b00001111`. As you mentioned, the `&amp;` is a [bitwise AND operator](https://en.wikipedia.org/wiki/Bitwise_operations_in_C). You may need to do some more reading to figure out what the effects are.
what if it's run on a middle-endian machine?
bwahahh cool link!
How can the program be run with parameters?
I am worried how much good people are, at finding errors in such obfuscation. My eyes just skip through such code, with brain pretending everything ok.
It's not reserved for the compiler, it's reserved by POSIX for system headers.
Argc is the number of parameters. When you execute a program from command line, it's like ./Foo arg1 arg2 arg3. I believe the system counts that as 3 args and will pipe them into the program along with the int 3 as the arg count. If this isn't clear I can answer better, but it's a bit of a vague question and I'm no expert. What is confusing? I'd love to get into it deeper and I'm happy to PM or use the Reddit chat feature. 
I too thought he's kidding and was a PRO io3c contender. 
Yes! C only has _'call by value'_. When you pass a pointer to a function, the pointer is passed by value, but you are able to access (and modify) what it is pointing to, which can (and often is) used to do a pass by 'reference'. C++ has actual references, which secretly are just pointers that are passed by value just like in C, except that you are not able to do any of the pointer-arithmetic with a C++ reference (which is the whole point of them, because it makes your code safer, and also lets the compiler reason more about your code and therefore optimize better). 
`s` in the function isn't the same as `s` in main, so changing `s` in the function has no effect. As you can see though you can change what `s` points to in the function by dereferencing it. So taking that further, if you wanted to change where `s` in main pointed to you'd need to pass a pointer to `s`, which as `s` is a pointer it would need to be a pointer to a pointer. 
Look at the datasheet: ww1.microchip.com/downloads/en/devicedoc/39631a.pdf Page 66 shows the registers and which bit corresponds to which pin.
`int main() { ... }` is equivalent to `int main(void) { ... }` since in a function definition, empty parentheses define a function that takes no arguments. However, no prototype is provided which might cause rare and extremely subtle issues.
You misunderstood whatever you were looking at in C++ also. There is syntax for passing by reference; and if you don't use that syntax then it is passed by value. 
This is very advanced. I wish I had half of your skills. Is this your first language? Regardless, the one area you might consider working on is your commenting.
I get: Hello World!% 
I disapprove of that reasoning "because of colors".
wtf
If you want to manipulate the pointer you pass to a function you have to pass a pointer to the pointer.
s in fun is a copy of s in main. Modifying a copy does not change the original. It works the same way in C++. If you want to modify the original s in C++, you pass char* by reference like this: char*&amp; s. By the way correct me if I'm wrong but modifying the contents of "Arnie" is undefined behaviour.
&gt; By the way correct me if I'm wrong but modifying the contents of "Arnie" is undefined behaviour. Nope. If it had been declared as: char *s = "Arnie"; Then "Arnie" would be stored somewhere in memory, and s would point there. Attempting to modify the string would be undefined behavior. However, it was declared as: char name[] = "Arnie"; Which sets aside memory for a char array of six elements, and initializes them to {'A', 'r', 'n', 'i', 'e', '\0'}. You can freely modify the array, even through a pointer to its contents.
Nice first try!!! It doesn't work on Amiga though, I get "lleHoW o!dlr". Keep up the effort!
&gt; except that you are not able to do any of the pointer-arithmetic with a C++ reference Unless you do unsafe casting and expose the reference for the pointer it really is. Then you can have your way with it.
What do you exactly mean by move to last part do you mean by it to replace it with the last element if 0 is found in the array ? 
This is avr MCU. PORT A,B,C are register used to control gpio. If you look for "arduino port manipulation" you will find a nice introduction tutorial.
That register is used to set input (1) and output (0), each bit represent a pin. Is logic to assume the pin used by the switch are set as input.
Really? It should work with both endians
That's undefined behavior though, so you can't actually do it.
Arduino uses higher-level functions such as `digitalWrite` for setting pin state, but it's obviously a layer over these registers, yes.
the tutorial i point out talk about how things work in the lower layer (register). Direct link for the lazy: https://www.arduino.cc/en/Reference/PortManipulation
I completed solving the first algorithm make work here is the code(ignore the header files as you can use them as any way you want to) : int a[10]={0 ,24 ,16 ,0, 36 ,42, 23 ,31 ,0 ,27},n=10,ctr=0; for(int i=0; i&lt;n; i++){ if(a[i] != 0) a[ctr++] = a[i]; } while(ctr &lt; n) a[ctr++] = 0; for(int i=0; i&lt;n; i++){ cout &lt;&lt; a[i] &lt;&lt; " "; } *if you want me to explain this I can or you okay in this* 
A 0 length variable length array is undefined, as is out of bounds array accesses. That's a broken program.
How is `while (1)` not an infinite loop?
i imagine it would fail eventually. 
Try running it with [valgrind](http://valgrind.org/docs/manual/quick-start.html). You will notice a number of errors coming up due to writes to unallocated memory.
I edited the post to answer this. 
The invalid memory access ( write / read to arr[i]) can be optimized away by the compiler in some cases. Have a look here https://godbolt.org/g/pCtPk4 and change the compiler flag from -O3 to -O0, and see how the output changes.
What is the type of `name` in that `struct`, how is it populated, and what happening with `name_ptr`? It's an odd thing to cast, needs more context to be explained.
It doesn't need to be in parentheses since `.` has higher precedence than `&amp;` https://en.cppreference.com/w/c/language/operator_precedence So &amp;player.name and &amp;(player.name) mean the same thing.
Hey, are you still around? I can't seem to get either GMP or MPIR working on Windows. Do you know of any pre-made solutions? Anything I can buy/download that'll do this for me?
Gotcha just wanted to make sure I wasn’t missing a specific syntax, appreciate the response :)
I wouldn't know anything about windows development, sorry. Spin up a Linux VM, that's probably easier
Fuck, I thought it just broke the if because I'm dumb.
Yeah. This is why Linus doesn't like C arrays 
Wait, shouldn't your array be 0 sized instead of one?
Actually an array cannot have a size of zero I believe. Regardless in my example I size the array for 1 but write outside of its boundaries by writing to the second element of it
Gotta love C. the code don't work but the program does
I found my answer after searching for a bit longer. Thanks, all. https://www.reddit.com/r/C_Programming/comments/4m6s8u/kr_example_19_character_arrays/
Can you recommend a UNIX/BSD/NIX OS that I could use for extremely basic C programming and some occasional printf's! But of course one that easily installs either GMP or MPIR!
An array of N elements is N contiguous instances of that element type. It's a common misconception that an array is actually a pointer that points to the block of contiguous elements. This was true in the B language; where an array declaration would create both the pointer and the block; and the block could get "leaked" if you reassigned the pointer. But not in C, there is only the block. Because C uses similar syntax to B, people who learned the language by trial and error sometimes come to the conclusion that the memory layout is like B's. But actually in C, these two things have exactly the same memory footprint: `uint16_t x[2];` and `uint32_t y`. Just the syntax to access that memory differs. 
Can the compiler warn about all undefined behaviors and allow you to ban them (error on it)? I know there is a shitton of UB, but there should be a standard way of blocking them or almost all of them. I have tried to use C with a shitton of flags to emit errors, but it's a pain and it always misses something. There should be a simple flag to it.
I just really love code like this and the threads around them. Feels good knowing there's so much to learn. This community is so knowledgeable about how things work at all levels. 
Valgrind never stopped running. Is that bc of the infinite loop?
That explains how the memory is laid out, but there is still a pointer referencing that block of memory. None of your statement contradicts that a pointer is created to reference that memory location when declaring an array. I've dung as much as I can and the only thing I can figure out that you are trying to say is that an array has special typing that makes it so that you can't pass it as a generic pointer, but a pointer still exists below that protection.
It is doing an out-of-bounds access so it isn't really a compile time failure (although undefined behavior) but a manifests at runtime "eventually". If you're on a Unix system try: `yes | ./prog` where `prog` is your program. I reliably get segfaults in about 2-3 loops.
every array is also a pointer.. array decaying? every array is a pointer if u write it without subscripts..
Sure, so let's go down that path. Take signed integer overflow for example. This is when you take a signed integer type (one that can represent negative numbers) and ask it to represent a larger number than it is capable of. For example: #include &lt;limits.h&gt; int x = INT_MAX + 1; Clearly, a complainer could look for statements exactly like this one and throw a warning/error on them, however no one ever writes a statement like that. In the vast majority of cases where this form of UB is triggered, it occurs because of some value x takes on at runtime and may only do so on certain inputs. This quickly becomes very difficult to figure this out. So difficult in fact, that this problem is literally undecidable, meaning there does not and cannot exist a compiler that can do this in all cases (you could prove this via a reduction from the halting problem). You _could_ catch this behavior at runtime though, simply have the compiler add a bit of extra code that checks, after each addition of signed integers, if there was overflow and abort the program if so. This already exists actually in the form of the `-fsanitize=integer` in both GCC and Clang. This comes at a runtime cost though, of course. This applies to most forms of UB. tl;dr it is provably impossible to create a compiler that does what you want
Arrays are technically not pointers but have very similar semantics as pointers. Arrays are a label to a block of memory (allocated on the stack) A pointer is a label to a block of memory which contains an address to another block block of memory. Essentially indexing on an array doesn't require indirection. The compiler can jump straight to the location in memory rather than loading the pointer first, incrementing it and then fetching the memory. This is true unless you pass the array to a function in which actually creates a pointer to the array and passes that instead.
&gt;but there is still a pointer referencing that block of memory. No there isn't. &gt;I've dung as much as I can and the only thing I can figure out that you are trying to say is that an array has special typing that makes it so that you can't pass it as a generic pointer, but a pointer still exists below that protection. I meant exactly what I said, there is no pointer. Not sure why you are "dung"ing or whatever. 
It's just a strcpy() implementation. The copying is done in the condition of the while loop.
This is why we have [Compiler Explorer](https://godbolt.org/g/Wxh5Jz).
More to the point, any teacher that put that mess on the board as anything but a bad example should be slapped. Hard. Twice. 
&gt;An array is a constant pointer. It's not even a pointer, let alone a constant one. Your claim is refuted by the SO link you posted: the asker says he thought what you are claiming , and the answers correct him. In the text you quote from 6.5.2.1/2, it it saying that **in the expression `*((E1)+(E2))`** , it is equivalent for E1 to be either an array, or a pointer to the first element of that array. This is due to 6.3.2.1/3 (quoted in the SO answer) saying than an array is converted to a pointer to its first element in that context and others. It is not saying that the array is a pointer. &gt;I believe none of these statements trying to correct me have been useful in trying to understand the OP's original question. Maybe you could edit your original post to correct your mistake instead of trying to defend it? 
Noob here. What does i++; do?
You are accessing a position of the array out of its bounds. The compiler is allowed to make this program work or just "making demons fly out of your nose". These kind of things may work under specific circumstances, but you don't have any warrantee if you change optimization options, compiler or the execution platform.
No it isn't. You can convert an array to a pointer, but the array is not a pointer. The same principle can be seen here: int x = 5; float y = x; In the second line, `x` is converted to a `float`. But it would be incorrect to say `x` is a `float`.
This is what the exercise states. In a real world program you would state your assumption using an assert.
i++ will increment the value of i and return the original value that it held before being incremented
Also noob, but i think it's equivalent to "i=i+1". I think it's called syntactic sugar, because it's shorthand that makes code easier to write
Pass a pointer into the function of your struct and then assign values with -&gt; operator `void test(struct *your_struct, int parm1, float parm2)` `{` `your_struct-&gt;parm1 = parm1;` `your_struct-&gt;parm2 = parm2;` `}`
Everything in C is pass by value. If you're familiar with pass by reference from higher level languages, it is kind of re-created in C via pointers, but those pointers are themselves still passed by value (ie. copied in to registers as specified by the calling convention of the ABI). A simple rule of thumb ***in C*** answer to a question "am I modifying a local copy, or the parent frame's instance" might be "it's always a copy unless you're going through a pointer." An optimizing compiler elides these copies via inlining. &gt; Then we have: s = s + 1; which sets s to the memroy location of the letter r. Yes but within `fun`, `s` is just a local-scoped copy of a pointer. (It may help to look at the disassembly (checkout godbolt.org) side by side to see a non destructive move as part of the calling convention). That assignment has no side effects or uses, so I expect an optimizing compiler to elide it. If you want to modify the pointer instead, you need to pass a pointer to a pointer, ex: void fun (char **s) { **s = **s + 1; printf("%c", **s); *s = *s + 1; } int main () { //... fun(&amp;s); // modifies s } address-of if kind of a dead giveaway that this function is going to modify something. If address-of the parameter is a single level pointer, then the underlying value may be different after that function call (depends on const in the function signature, but it's not a strong guarantee against bad code). If it's a two level pointer, the pointer itself may be changing as well (but check the function signature). There's a joke about using more than two levels of indirection in programming, we call them "three star programmers." &gt; I find this odd because if I recall from C++ correctly, if you pass something as a pointer when you modify the pointer you modify it directly (as in passing by reference). You don't recall correctly. C++ has actual references So you might have something like: void fun (std::string&amp; s) { if (s.length() &gt; 0) { s[0] = s[0] + 1; std::cout &lt;&lt; s[0] &lt;&lt; std::endl; } } int main () { std::string s = "Hello"; // no explicit pointers, address-of, or dereference of needed. fun(s); } If you don't need to modify pointed to values, then passing by const ref is preferred, at least by Google's C++ style guide (so my previous example would not pass code review; it would be recommended to use pointers to make it obvious that the value may be changed in `fun`). C++ will let you mix references and pointers for a single parameter, but such patterns should be discouraged.
Why can't you do `structName.field = correspondingData`? I'm not quite sure what you want to do. Could you perhaps give us an example?
In the caller function you'd do something like this: struct MyStruct s; initStruct(&amp;s); In initStruct: initStruct(struct MyStruct *s){ s-&gt;param = something; }
If the variable **s** is a local variable, then wouldn't it be simpler to do something like struct MyStruct initStruct(int a, float b) { return (struct MyStruct){.fielda=a,.fieldb=b}; } Why pass by pointer if a simple structure copy will work?
True, I would rename the function to makeStruct though. I prefer to pass the pointer because I prefer to only have 1 instance of a specific struct running around. It helps me internalize my code and prevents unnecessary memory duplication. 
You have some typos in your code when you write a new password to the text file. You open "new_passOWrd_info.txt" (spelling) with the fp_pw file descriptor but then write new_password to fp which is already closed. In your while loop you are only checking if the usernames match and not comparing the passwords. This leaves the chance that the single characters you end up on in your passwords might match while the passwords themselves are mismatched. Also you are enforcing that the length of password must be one less than the length username with your checking logic. For example: myname myname 1234 5678 If my suspicions are correct, by the time you have compared all the characters in myname, ch1_pw and ch2_pw will both be EOF. So even though they are completely different passwords your logic will pass them.
Nice formatting, mate. Any chance you also do Python?
You forgot to include an example!
you should figured out that what line you have seen that make you wrong . if your ask yourself what line not going to work and after that you find why I was wrong then it will give you the correct answer . 
lmao! ok here it is.
I had the screenshot file ready just didn't put it here! haha
This isn't "char" but chr, which is the variable name for the char used in this example. All this is doing, is printing char chr twice in the last line, once in the form of a character (%c) and once in the form of an integer (%d). The way printf works is that it needs however many variables (in this case, chr and chr) as there are text formatters.
In the future you can enclose text with grave marks or indent each line with 4 spaces to have it formatted `like this`. You specify `chr` for each of `%c` and `%d`.
Nothing worse than bad variable names in beginner code. My cpp teacher did this and it really threw me for a loop during lectures. 
Your formatting is incredibly hard to read. Put it in an editor or use a gist. 
Have you looked at mbed tls?
If you can't be bothered to format your code properly then at least use pastebin because I can't be bothered to decipher this
&gt; when i try printing it doesn't work None of the code you posted prints anything. What does "doesn't work" mean? What were you trying to print? What happened? What did you expect to happen?
No, rust panics on overflow in debug build. It wraps in release.
For the next time: please do bot post pictures of code. Always post code as text!
I don't see where you are comparing the passwords though. Try amhopasha/122333 to create the account then amhopasha/999 to log in.
My guess if this actually compiles and runs is arr[i] ends up being written to the area of the stack that gets overwritten by the frame for calling printf(). When the main() is called it increases the stack pointer to reserve the space it needs for the address of the next instructions to execute after the function terminates, the arguments, the return value, and the local variables. Stack pointer + sizeof(int) * 0 = stack pointer, no stack space is reserved. If you tried to store a value at stack pointer - sizeof(arr) + sizeof(int) * 0 to store it at the 0th element it ends up being at the stack pointer. I don't know if the order of elements in a frame and the steps to create it are a part of the C standard or if it is compiler dependant. I don't know if the value is taken from the stack before the data for the frame for the printf() call is written, if the second argument of printf() gets stored in the first position of the frame, or if it gets written over but the optimizer writes the value from the register it was stored in instead.
... that's what I said? That the additional runtime overhead for checking for overflow is only incurred in debug builds. This isn't really an apt comparison in any case, as I said, since this behavior is defined in Rust (and there's no notion of a standard in any case). Both GCC and Clang also wrap (this is the most natural thing to do, at least on x86, and doesn't require extra instructions), however this is left as undefined behavior by the standard since this is not necessarily reasonable for all architectures (nor is there necessarily a reasonable behavior on all architectures). In any case, signed interfer overflow is among the simpler to check for at runtime, but how about memory unsafety? This would be quite expensive, to check at every write to memory that the value had been previously allocated. Rust has shown that by restricting what the programmer can do, you can get some great static guarantees in this regard, but the problem of determining if a program is memory-unsafe is still undecidable; rustc is not a counterexample here since it rejects programs that are memory safe. This is why `unsafe` exists in Rust in the first place.
So you are saying you can define the behavior in C without a runtime cost... Thats exactly what I said. Bounds check is also done in Rust. C could do all those things without a hassle.
Sorry, i don't know how to do it here. I'll edit as soon as I get home
When I try printing the content of the lists, which should be 1,2,3,4. 
It's not that I "couldn't be bothered", I just didn't know how to do it here on Reddit. No need to be aggressive or pissy about it, i will update it. I also didn't ask for your help specifically, so if you can't be bothered then let it go.
That's the point. The compiler doesn't need to know it's UB. It lets the compiler generate the same code for defined and undefined behaviour. For example, if a program writes an array at an index specified at runtime from standard input, there is no way for the compiler to know at compile time whether the index will be out of bounds.
You're almost correct, but to add an important nuance, `i++` is the post-increment operator, as opposed to the pre increment operator `++i`. The distinction comes in to play when it's part of a statement. int a = 3; int b = 3; int x = ++a; // x == 4 and now a == 4 int y = a++; // y == 3 but now b == 4 i.e., post-increment occurs *after* the value of the expression is determined. `x = a++ + a++` is undefined
why is that?
So you're telling me you can't write basic markdown?
Thank you and good luck to you; i hope you can find it in you not to be an asshole.
Pictures are worse than unformated code buddy
Wow, you must be a big shot talking down on me like that! I'm very impressed by your knowledge.
No, but the bounds can be checked, like in many system languages. No, you don't need the speed of doing things wrong and hoping it works, almost nobody needs and who does normally needs safety assurances.
Ubuntu is the obvious option. I prefer Fedora. 
I do not have access to K&amp;R, but the code you posted should probably be `high = mid - 1` to make sense with what `high` and `low` are. 
Does it work though? It appears to work by sheer luck since you're reading into a (which has a defined and valid place on the stack), then writing into `arr[i]` (an undefined location on the stack) but immediately reading from `arr[i]` as part of the function call to printf. It's undefined behavior though, there is no guarantee that it will work and the program is incorrect. I see some very strange results. * `yes 1 | ./a.out` keeps correctly reading an integer until it segfaults (ran out of stack space). * `yes 8 | ./a.out` works for a few times but then prints garbage and crashes. * `yes 0 | ./a.out` appears to be an infinite loop. Why should these 3 inputs produce such varied behavior? I'm honestly not sure, but that's because it's undefined behavior because the program is incorrect. BTW, everything changes if you compile with optimizations on, yes more indication of undefined behavior.
In my copy of K&amp;R, the lines you have as: if (x &lt; v[mid]) high = mid + 1; are actually: if (x &lt; v[mid]) high = mid - 1; i.e. '-' instead of '+'.
I think that does fix the boundary that high is supposed to represent yes
Which version do you have, I thought the 2nd edition/ANSI C was the latest one?
Yep, that's the version i have.
If I understand this correctly, the compiler has a pretty narrow view of the program. When it compiles a statement like `int arr[i]` it has i from the symbol table, can see that it's an integer and is in scope so it compiles it. It can probably also see that i is initialized with 0, but it doesn't know if there are any other statements in between the declaration of i and this array initialization. Similarly, the compiler can give you warnings about incorrect printf parameters. It has the format string, it has the type of the parameters you're passing, so it has all the information it needs to generate such warnings. It doesn't know if one of the parameters you're dereferencing is null for all the same reasons as the last example. It's just not designed to look for things like that. There is a tool for that though: a linter. A linter can see things like this and give you a warning. It can parse the program and do everything the compiler does up until the compilation phase and then look for statements in between that can modify i. The splint linter doesn't give a warning about the array declaration (which might technically be valid C, I'm not sure) but does give a warning that there is an out of bounds array access.
Pointer math already takes into account the size of the types. currState = stateList + 1; // currState is tr*, so adding '1' adds sizeof(tr*) bytes Does that help? 
Strange
I'll edit then. I'm actually trying to create a program that takes an input file and creates an Non-Deterministic Touring Machine from that and then tests some inputs telling you whether the input is accepted. To be able to do this as I envisioned it, I need to be able to dynamically create lists array of lists, but in the more complex code I've written for the purpouse, I run into some problems that are caused by me not knowing how to use realloc.
Nobody else can plug pictures into a compiler or cite excerpts from it to show you where you went wrong. Also, blind readers aren't able to read what's on your picture.
You'd be well served by using some encapsulation and typedefs to help you understand what you're writing better. In terms of what's going wrong with your code, the most egregious mistake I'm seeing is that your pointer arithmetic is wrong. When you add N to a pointer, you're actually adding N*sizeof(ptr). So when you're adding `sizeof(tr*)`, you're really adding `sizeof(tr*)*sizeof(tr*)`. You'll want to change your code to add just 1. Alternatively, consider treating it as an array and indexing it accordingly - in C, `stateList + 1` and `&amp;stateList[1]` are the same thing.
Every person doesn't know something until they learn it. You're no different. There was a time you didn't know basic markdown either.
&gt; Most C developers don't need the speed [citation needed]
It seems like it solved it! This was just example code I used to explain a bigger problem I had on another piece of code, so I'll try this fix there. Thank you!
On the fix, some other guy already commented that and it fixed it. I'll try it in the bigger piece of code I have written to see if that was the problem there too. Thank you so much! Can you tell me what you mean by encapsulation? And what more typedef should I be using? 
Yeah, it was a mistake with pointers arithmetics. I don't like that -&gt; notation because if I needed to dereference a double pointer and access a field, that i wouldn't be able to use it (or would I? I think don't think so) so than I would have two different notations in the same file. 
I use Rust as an example, you can do the same things you do in C and it's pretty fast, when it's not it's just because the compiler hasn't matured. So you can do system programming in safe ways, even go, that is garbage collected is used. You should cite why would C programmers need the speed but other languages don't. And why C code has a shitton of vulnerabilities because a lot of things are UB, so it can just not work as expected. You need the safety more than you need the speed, there are very few cases in which that isn't true, like HPC. Which is just a fraction of C code written.
Encapsulation is basically taking a subset of what you're doing and wrapping it together, to make it easier to reason about. An example is what you're already doing with your linked list node struct - you've put the pointer to the next item in the same "capsule" as the item data itself. As for typedefs, you're working two levels of indirection, and it can be easy to make a mistake. You could `typedef tr* node`, and then `typedef node* nodeArray`. Then your array of lists would be `nodeArray foo = malloc(sizeof(node)*N`, and your lists head would be `node head = nodeArray[N]`. Traversing your list would look something like this: `node curr = head-&gt;next`. Now you don't have to remember how many times you're needing to dereference pointers to get at what you're trying to manipulate, and it's a lot easier to read and understand your code, making it less likely that you cause a bug, and also easier to find the bug.
Peh, I'm in after creating with ahmopasha/122333 and entering ahmopasha/999 :( :( :( 
oh sorry. I apologize.
I'd make a loop that checks the username and then if those match then check if the password matches. Right now you're only checking if the username matches. Also did you fix those typos that I mentioned in my first comment?
Yes I have seen grammer mistake in the code. Thanks for that. Outside of that I will try what you said - going step by step while making sure every step works accordingly. 
Logical operators apply to two operands, each of which may be true or false. A value is considered to be false if it is zero, and true if it isn't. If the result of the logical operation is true, it evaluates to 1. If it's false, it evaluates to 0. For instance, 2 &amp;&amp; 0 == 0, and 3 &amp;&amp; 1 == 1. Bitwise operators apply to each of the bits of two operands. A bit is considered to be true if it's set to 1 and false if it's set to 0. The operation evaluates to a value where the bit in any given position is the result of applying the comparison to the bits in the same position in the operands. For instance, 2 &amp; 3 == 0...0010b &amp; 0...0011b == 0...0010b == 2, and 2 &amp; 4 == 0...0010b &amp; 0...0100b == 0...0000b == 0: 00000010 &amp; 00000011 -------- 00000010 00000010 &amp; 00000100 -------- 00000000
In C, logical operators treat '0' as 'false' and every other value (so every non-zero value) you use as argument as 'true'. They are evaluated once per argument. Bitwise operators treat both arguments as a sequence of bits, and perform their operations on each of the bits independently.
I found out yesterday that Chrome added a BigInt object to their browser, so I am actually using JavaScript and my Chrome browser haha :) I haven't used JS in years and years so I had to read up on it again a bit, but I got it all working! I'll let you know if my theories work-out over-all. They're working for small&amp;medium sized numbers.
You can use: *foo-&gt;field = 3; "." and "-&gt;" notation are mostly equivalent.
I wanted to hold off on a critique having only a couple hundred hours total in writing in C. I'm also pretty tired, so take this with a fat grain of salt. If I say something wrong, please let me know! I'm not trying to pretend to know everything. First off, I learned something about my own style. When I started learning C, I was/am enamored with the Linux Kernel Style. I like how (imo) the minimalism mirrors the simple, low level traits that is C. Feels like I'm writing assembly without having to write assembly. However, I think another part of that was due to rebel from comfy OOP and get a better understanding of what the hell is even happening under the hood, (I'm done trailing **here**) but seeing your code helped me realize longer names and typedefs don't have to be "evil". Anyways, I'm definitely digging your style. You use macros sparingly. I'm sure some Linus disciples/purists would disagree, but you're smart with typedefs. You aren't trying to turn your code into a magical clusterfuck of abstractions, and I don't have to pan through a million header files to figure out I'm looking at a struct (not to mention your names scream "yep, I'm a struct!"). In short for the above: naming conventions/style is consistent, functions longer than 20-30 lines make sense, and you know how to use typdef, macros, enums properly. I'm not an expert nor in embedded systems, but if your code is clear enough for a novice, I'm guessing it's clear period. I don't think I can comment too much on specifics, but all I can really see is maybe some function calling in loops. I might be wrong, but I always have a habit of writing "int a = my_struct-&gt;data;" and "for (..i &lt; a...)" instead of "(...i &lt; my_struct-&gt;data...)". AFAIK, compilers aren't going to pre-optimize pointers due to the possibility of changing elsewhere in the program. I always put a frequently-accessed pointer in a variable just to be sure it's closer to the register and not running out to memory each iteration. I'll also do the same even if it's a small macro or function just to save a few cycles. That being said, you're not building a CPU withering project here. Building something like this, I'm sure readability is more of a priority here. Anyways, your code was clear and a joy for a novice like me to read! 
\#include &lt;stdio.h&gt; int main(){ char chr; printf("Enter a character\\n"); scanf("%c", &amp;chr); printf("You entered %c.\\n", chr); printf("ASCII value of %c is %d", chr, chr); /\* Both chr are same. The compiler places this chr on its placeholder. %d for integer. According to the ASCII code integer value of char 'a' is 97. %c is for the chr itself. So, both these chr acts according to it's placeholder.\*/ }
&gt; __attribute__((__packed__)) If your are using GCC I think that you have to use `__attribute__((packed))`.
Correction: the name of the thread should be FROM Linux.
Could you explain a little bit more about this structure packing? In the end, it's not really something that's up to me, or not? If I want to read and write bitmaps, I will need to abide by the rules MS created.
Basically the structure is allowed to have blank spaces if the compiler wants (according to the c standard). Thus you have two options: tell the compiler not to put blank spaces in (with the packed attribute) OR you can read each piece one at a time (reading one byte at a time is generally safest, so you avoid endianness issues).
GCC has alternate spellings of its attributes for compatibility reasons; both `__attribute__((whatever))` and `_attribute__((__whatever__))` work.
You can't check the bounds at compile time
I'm passing the address of a function bar to function foo, then calling it. Foo, accidentally overwrites memory its not supposed to with that address. It corrupts the return address in the stack pointer, so when it leaves, it doesnt go back to main but instead to the function that hijacks control. At that point all is lost and we are doomed. 
This is one of my print functions. This will take in a constant refrains to a list structure and print each element forward then backward without returning unexpected results. void printSqdList(sqdList** const listPtr){ if ( NULL != (*listPtr) )return; const sqdList * last = *listPtr; printf("\n%s\n","Traversal in forward direction"); while ((*listPtr) != NULL) { printf("%s&lt;%5d&gt;\n","element",(*listPtr)-&gt;value); last = (*listPtr); (*listPtr) = (*listPtr)-&gt;next; } printf("\n%s\n","Traversal in reverse direction"); while (last != NULL) { printf("%s&lt;%5d&gt;\n","element",last-&gt;value); last = last-&gt;prev; } }//end of function printSqdList 
This is interesting. Why this happens?
So, 'funt' is being placed in a non-existent memory location and ends up overflowing into the stack? Could you elaborate further?
The problem is there's no such thing as a non-existent memory location it very much exists and in fact does not belong to the function foo. But, foo doesn't care and overwrites that memory location. That memory location served as storage for the return address of the function that called foo. So when it gets overwritten and foo finishes its execution and returns, it does so to a different function (bar). 
Return address is stored in the stack frame. I knew it eventually would
You can put runtime checks at compile time like many system programing languages do...
Test with valgrind. Test with `-fsanitize=address`. Compile with `-fstack-protector` or a related option. 
It's just how OP's triggering undefined behavior is manifesting on his particular compiler/CPU/OS.
But still, please edit your post to include the code as text.
Awesome! Glad you got it working :)
&gt; mbed tls Unfortunately with &lt;2k RAM on the AVR even porting of mbed TLS isn't possible...unless I'm totally missing something.
overwriting the return address in the stack frame
r/http://tpcg.io/0hred6
In general, locally defined variables are stored in a buffer on the stack.
In general, locally defined variables are stored in a buffer on the stack.
In general, locally defined variables are stored in a buffer on the stack.
In general, locally defined variables are stored in a buffer on the stack. That way allows for variables in recursive functions.
you are essentially doing Singular Value Decomposition in C++ :D
Undefined, fine, but what is the technical reason this is happening? 
In fopen, add "b" to the mode so it reads "rb".
`list&lt;Node&gt;` looks like C++, you might want to ask in /r/cpp or /r/cpp_questions. They will probably tell you that there is no way to find out and that you should use a standard container for `a`, e.g. `std::vector&lt;list&lt;Node&gt;&gt;` or `std::list&lt;list&lt;Node&gt;&gt;`. 
It's a really sweet article thanks for the link
First off, your comment blocks that are formatted like this: /*----- --| --| Includes --| -------*/ are redundant. I see a bunch of lines like: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stddef.h&gt; I don't need a comment saying these are include files. Same with defines, public data, private data, etc. I can see that without the comments. I would remove these as they add nothing. The rest of the comments you have are okay, but keep in mind that comments are better when they describe *why* you did something, not *how*. How, we can see from the code. Secondly, you have an inconsistent style with respect to braces. Some functions you have this: static int foo(int x) { /* ... */ } And some like this: static int bar(int y) { /* ... */ } Pick a style and stick with it. Consistency is key (although there are at time when you have to break the style, but when you do, you should have a good reason for doing so). I also noticed that some of the code uses some features from C++. Unless there's a compelling need to mix C and C++, in my experience, it's not wise to mix the two. The languages have evolved away from each other and there are semantic differences between the two that can cause issues (C++ *requires* the casting of `malloc()`; C *does not* and in fact, can cause issues if you do cast the result of `malloc()`, stuff like that). One last comment, you have a file `Switches.h` which "modifies" the language to include strings in a switch statement. I'm not fond of such abstractions. I can see the following being done: switch(argv[i]) { cases("foo"): /* ... */ break; cases("bar"); /* ... */ break; } Yes, the compiler will catch this, but then you wasted the programmer's time. Second, identifiers starting with leading underscores are reserved for the compiler, not for user code. And your `switches` syntax uses three such variables (granted, they probably won't shadow any existing identifiers ... probably). 
Are you sure that str1 doesn't have any extra characters in it?
No, I initialize it as follows: char str1\[10\], str2\[256\] I've been running it through the debugger and it seems like its not wiping str1 empty when it loops, which is why when it runs the first time, its fine. I've been trying to use: memset(str1,'\\0',strlen(str1)); inside the while loop to get it to reset but that doesn't seem to be working either.
Use strncmp. Also why are you escaping in scanf? Is that just from copying to reddit?
The scanf is just Reddit formatting :( I'll attempt to use strncmp now but I think my issue is the fact that it isn't resetting str1 and str2 when it loops, the comparison seems to be working fine (as seen by the first time it runs). I'll use str2 later in my code too, which is why I'm trying to get it working
You should be checking scanf()'s return value to see if it's the expected one and do some error handling if it's not. If it IS, and you're not seeing extra characters caught by that pattern (Check with a debugger, or good old printfs), but the string comparisons are still failing, then it gets interesting. (You should also consider what happens with input like 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx:blah' and figure out how to mitigate that)
Alright, so after looking into the debugger some more, I've found something interesting. The first time it runs, with the input d:Parent, in memory the following can be seen: str1 "d\\000\\377\\...." str2 " Parent\\000\\ ..." The second time it runs, with the input d:Parent, in memory the following can be seen: str1 " "\\nd\\000\\...." str2 "Parent\\000\\.."
Thanks for your review. I appreciate the feedback.
&gt; So it is definitely an issue with the \n being added. It's not being "added". The _previous_ `scanf` call isn't consuming it. Why would it? If you want to do per-line processing of input, `scanf` isn't a good choice. There are some non-standard ways to use it this way in some C implementations, but let's not go there. Consider using `fgets` instead.
and you didn't get an instant runtime error for overwriting memory that isn't yours?
&gt; I'm passing the address of a function I found your problem.
Pardon?
Person who's reported 5 bugs to Clang so far here. Too bad they never do anything with the bug reports. I generally agree tho.
C is not a managed language. There won't be any runtime errors for overwriting the stack in most cases, because the stack *belongs to your program*. You only typically get runtime errors when you touch memory belonging to *other processes*, because the OS has virtual memory protections in place (or the memory might just not exist)
Say what? Could you elaborate?
It's "-" in both of my copies of the second edition too.
I managed to solve it [here](https://www.reddit.com/r/C_Programming/comments/98f9zh/issues_porting_my_code_to_linux/e4gegbj/) Would you agree then that my solution is probably not portable to other OSs?
&gt;#pragma pack(push,2) Never heard about those in 15 years, must be a Microsoft thing. 
All computer graphics are, essentially, linear algebra, basic or advanced. A picture is essentially a flattened 3D matrix, right? Each cell has a triple tuple of values, namely, &lt;R,G,B,&gt;. [Singular-value decomposition](https://en.wikipedia.org/wiki/Singular-value_decomposition) is a linear algebra/arithmetic analysis technique, in which you basically brake the one matrix into three other, much simpler/easier to understand/easier/more sparce to store matrices. When you multiply the three matrices again, even though it looks like the three individual matrices have lost information, they recreate the original matrix. Now, if I understand your homework correctly, you have to find a secret message. I did a similar piece of homework last semester for grad school, but only with a picture gradient. It is essentially the same homework. I bet ya the secret message, will be in the middle matrix Σ, in the diagonal. The tough part? learning about SVD and matrix factorisation, if you have not done linear algebra, yet. 
&gt; tell the compiler not to put blank spaces in (with the packed attribute) This is what I tried and didn't work, right? &gt; OR you can read each piece one at a time (reading one byte at a time is generally safest One byte at a time, does that mean I need to calculate an int32_t after reading the four bytes separately? I found the solution in the wingdi.h header. You can find it [here](https://www.reddit.com/r/C_Programming/comments/98f9zh/issues_porting_my_code_to_linux/e4gegbj/)
#pragma is by definition not a portable construct. It's specifically for doing things outside the language specification.
it's an array of 10 values.
I'm not trying to be toxic, but this is one of the very first things you should learn when you start programming. It's an array. You need to learn how to teach yourself about things and do research or you're never going to be able to learn anything on your own. Just look up any tutorial series on C and this is likely to be one of the things they introduce in the first ten lessons.
You're fundamentally looking at the problem the wrong way. Don't think of the format as a memory dump. Think of it as [a binary format you need to parse byte by byte](https://commandcenter.blogspot.com/2012/04/byte-order-fallacy.html). For example, take this helper function: /* Read unsigned 32-bit little endian integer from a buffer. */ unsigned long load_dword(const unsigned char *p) { return (unsigned long)p[0] &lt;&lt; 0 | (unsigned long)p[1] &lt;&lt; 8 | (unsigned long)p[2] &lt;&lt; 16 | (unsigned long)p[3] &lt;&lt; 24; } I'll leave it as an exercise to write your own `load_word()` function. When you want start reading a BMP, start with the header like this: unsigned char buf[14]; fread(buf, 1, 14, inptr); // FIXME: check for errors bfType = load_word(buf + 0); bfSize = load_dword(buf + 2); bfOffBits = load_dword(buf + 10); This approach is strictly conforming and will work correctly on *any* platform that supports C. There's no need for compiler extensions or even fixed-width integers. I'd define the header struct something like this: struct bmp_header { unsigned short bfType; unsigned long bfSize; unsigned short bfReserved1; unsigned short bfReserved2; unsigned long bfOffBits; }; An `unsigned short` is wide enough to hold a WORD and `unsigned long` is wide enough to hold a DWORD. (There's also a reasonable argument for `uint_least16_t` and `uint_least32_t` here.) When you want to write BMP data, it's just the reverse: /* Write an unsigned 32-bit little endian integer to a buffer. */ static void store_dword(unsigned char *p, unsigned long x) { p[0] = x &gt;&gt; 0; p[1] = x &gt;&gt; 8; p[2] = x &gt;&gt; 16; p[3] = x &gt;&gt; 24; } Then `fwrite()` that buffer. 
&gt;I'm *very* new to ~~C~~ programming. FTFY
100% agree. It might sound harsh, but it’s something that needs to be said.
It's up again
I guess you dont know program. Its an array in most programming language!
You're declaring an array that can hold exactly 10 elements.
(Disclaimer: I only skimmed the article) You seem to be conflating undefined behaviour with "you did something stupid that the language allows but can't provide any guarantees about". While technically UB, I don't really consider that a failure of the language. Most of the rest of the UB in C is because for the standard to enforce a certain decision of behaviour, it would require that the compiler put in guards and checks for all uses, to ensure compliance. Since C was designed to be as close to assembly as you can get without it being assembly, this would be antithetical to its purpose. What happens when you left-shift some memory 64 times? That depends on your architecture. You the programmer are expected to understand your target architecture, and to handle these sorts of edge cases accordingly. The C standard (rightfully, IMO) does not attempt to make a statement as to how that architecture should behave, because they aren't making a standard for CPUs. Let's say I have an architecture where if I left-shift too much, it pulls in the bits from the next register over. Now let's say the standard defines that behaviour to be "the result is 0" (a perfectly reasonable requirement). Now the compiler needs to generate, in addition to the bit shift, a check to see how much is being shifted, and an assignment to the register to zero it out. This makes the command run slower, and that's undesirable.
&gt; You the programmer are expected to understand your target architecture, and to handle these sorts of edge cases accordingly. If this is what the C standards committee, I would have expected they would have said this was _implementation-defined behaviour_, not _undefined behaviour_. They clearly wanted to allow implementations to have no defined behaviour at all.
Implementation defined would say it's up to the compiler, when again, it's up to the architecture. A *lot* of thought goes into these things. When something is UB, the committee spent a lot of time thinking about it and decided that UB was the best decision. No one likes UB.
&gt; Implementation defined would say it's up to the compiler, when again, it's up to the architecture. The standards do not distinguish these. There is an _implementation_, which encompasses that "particular set of software, running in a particular translation environment under particular control options, that performs translation of programs for, and supports execution of functions in, a particular execution environment". 
None of what you posted as the definition of an implementation makes the architecture part of the implementation. The architecture is part of the execution environment.
Lol people always think just because I (re)posted this means I wrote it. Saw it in /r/programming and posted here seeing as it is more relevant to C than to most popular languages.
&gt; The compiler isn't make use of UB to perform an optimization. No sane compiler would ever do that. I was loose in my language. The compiler will happily elide any code path that provably leads to undefined behaviour. So yes, the compiler _does_ make use of the existence of undefined behaviour in the specification. If the specification did not mention the existence of undefined behaviour, this kind of optimisation would not be possible.
I'm not sure I follow. Can you give an example?
My link has two good examples.
I missed the link the first time (on my phone). You missed quoting the relevant part of the example: &gt; The constraint is that the behavior of i1 or i2 overflowing as an unsigned integer is defined, and the compiler is obligated to implement that behavior. On x86-64, where int is 32 bits, the result of the operation must be truncated to 32 bits one way or another, requiring extra instructions inside the loop. This is exactly what I was talking about - by making the behaviour defined, you force the compiler to insert additional code to handle the definition of the behaviour. It's not that the compiler is using the fact that it's UB to perform an optimization, it's that the compiler is assuming the UB will not happen - that the programmer has done their due diligence in ensuring that it won't occur. That assumption is perfectly fine and fair to make. The example you've chosen perfectly demonstrates exactly why the standard might declare some things UB - because the tradeoffs are worse. (As an aside, I had not previously known that using an unsigned int vs. an int was actually less performant. Now I know!)
I think we've now come full circle.
&gt; I'm still not sure I fully understand the points you were trying to make :) I'll try once more (but only once, since I really didn't want this to be an argument :-) ). You stated: &gt; You the programmer are expected to understand your target architecture to handle "oversized left shifts" correctly. But that can _only_ work if the behaviour is implementation-defined, not undefined; if it's undefined, there is nothing to understand about it except "don't do it". The standard says it is undefined behaviour. That is all.
Alright, I get what you're saying, but programmers handle UB all the time, because UB is typically deterministic. In the case of a signed integer, on most platforms an overflow will result in INT_MIN, or at the very least, a negative number. Programmers check for this when it's a concern - in effect, they implement the same checks that the compiler would have to make if it was UB. Same story for oversized bit shifts - if the programmer understands the behaviour that the platform engages in, then they can behave accordingly. Generally speaking, programmers should not be relying on UB for things to happen, because they have no guarantee that the behaviour isn't going to change. I think our main disconnect is over the definition of an implementation - otherwise we're on the same page (and I'm fine with not resolving that disconnect :p )
[GCC did this](http://thiemonagel.de/2010/01/signed-integer-overflow/).
&gt; In the case of a signed integer, on most platforms an overflow will result in INT_MIN, or at the very least, a negative number. Programmers check for this when it's a concern - in effect, they implement the same checks that the compiler would have to make if it was UB. Err, no, programmer's cannot simply test that an overflow "happened". The compiler is free to _remove_ such a check, since signed overflow can be assumed to _never happen_, since it's undefined. The correct approach is to put a guard _before_ the problematic code, e.g.: int add(int x, int y, int *result) { if ((x &gt; 0 &amp;&amp; y &gt; INT_MAX - x) || (x &lt; 0 &amp;&amp; y &lt; INT_MIN - x)) { errno = -ERANGE; return -1; } *result = x + y; return 0; }
You are correct in that that's a DB way to guard against that. However, if you know that overflow on *your* architecture results in a negative number, you can do this instead: int add(int x, int y, int* result) { *result = x + y; if (x &gt; 0 &amp;&amp; y &gt; 0 &amp;&amp; *result &lt; 0) { errno = -ERANGE; return -1; } return 0; } Now that code certainly isn't portable to any platform where that UB behaves differently. Nor are you guaranteed it will continue to behave the same if you change out parts of your system (OS, compiler version, underlying hardware). So your way is better.
Well, I would hope you're writing tests that test these edge cases, in which case the test should catch that ;)
You’ve got all the right moves!
In the math sense or the C++ container sense? Though the answer is yes either way.
In the C++ sense.
I mean, nobody stops you from writing typedef const char *cString; in your program, but I don't really see the point of doing so.
[Yes.](https://github.com/andymac-2/c_vector) That's just my implementation, but there are others.
I mean, i've done that lol. it's not hard, just make a struct, put the types you want to support in a union.
Bitwise operators operate on individual bits. 0xFF &amp; 0x80 selets only the left most bit. 0xFF &amp;&amp; 0x80, doesn't even make any sense...
I've never felt nor found the need to do so. I'm genuinely curious as to how often you use variables that are `const char*` that *aren't* c-strings.
 Type *Type_Init(uint8_t Param1, uint64_t Param2) { Type *A = calloc(1, sizeof(A)); if (A != NULL) { A-&gt;One = Param1; A-&gt;Two = Param2; } }
&gt; *s = *s + 1; Do not do this. Access your array as an array with s[X] notation, where the X is a variable from a loop.
The C standard/runtime doesn’t/can’t/won’t contain a vector implementation for you, because there’s no good way to account for all the possible variations in element type/size/alignment and allocation strategy without complicating matters terribly. Generally things like this are either pulled from some third-party library (usually suffers from the same problems, unless it’s tailored to your use case) or written by hand. The most straightforward approach is to make a `struct` with some functions to support it. Same as you’d do in C++ to set up your own `vector`, but the methods are (global) functions with explicit `this` parameters. struct int_vector { int *data; size_t length, capacity; }; #define int_vector_INIT() {NULL, 0, 0} void int_vector_init(struct int_vector *self) { self-&gt;data = NULL; self-&gt;capacity = self-&gt;length = 0U; } void int_vector_deinit(struct int_vector *self) { if(self-&gt;data) { free(self-&gt;data); #ifndef CARELESS self-&gt;data = NULL; self-&gt;capacity = self-&gt;length = 0U; #endif } } etc. etc. You’d have to either come up with a new `struct` for each element type, or come up with some macros that will define a new `struct` and accompanying functions for you, for a given element type. E.g., #define MAKE_VECTOR_STRUCT(name, elem) \ struct name { \ elem *data; \ size_t length, capacity; \ }; #define DECL_VECTOR_FNS(name)\ void name##_init(struct name *); \ void name##_deinit(struct name *); \ ... #define MAKE_VECTOR_init(name) \ void name##_init(struct name *self) { \ self-&gt;data = NULL; \ self-&gt;capacity = self-&gt;length = 0U; \ } #define MAKE_VECTOR_deinit(name) \ void name##_deinit(struct name *self) \ {etc.} #define MAKE_VECTOR_FNS(name) \ MAKE_VECTOR_init(name)\ MAKE_VECTOR_deinit(name)\ etc. etc. And then you’d throw calls to those macros in the appropriate places, hopefully without colliiding with each other or redefining things. Alternatively, you can use preprocessor tricks with `#include` to avoid some of the macro unpleasantness: /* main.c */ #define VECTOR_TYPE int #define VECTOR_NAME int_vector #include "make_vector.h" #undef VECTOR_TYPE #undef VECTOR_NAME ... /* in make_vector.h */ #ifndef VECTOR_TYPE #error "VECTOR_TYPE undefined" #endif #ifndef VECTOR_NAME #error "VECTOR_NAME undefined" #endif #include "make_vector_mname_def.h" #include &lt;stddef.h&gt; struct VECTOR_NAME { VECTOR_TYPE *data; size_t length, capacity; }; void VECTOR_MNAME(init)(struct VECTOR_NAME *self); void VECTOR_MNAME(deinit)(struct VECTOR_NAME *self); ... #include "make_vector_mname_undef.h" /* make_vector_mname_def.h */ #ifdef VECTOR_MNAME #include "make_vector_mname_undef.h" #endif #define VECTOR_MNAME(x)VECTOR_MNAME__0(VECTOR_NAME,x) #define VECTOR_MNAME__0(a, b)a##_##b /* make_vector_mname_undef.h */ #undef VECTOR_MNAME #undef VECTOR_MNAME__0 So `make_vector.h` takes a couple of parameters to let it do its work, and the extra `_mname_` files set up/tear down macros that let it paste together names easily. (You can’t just token-paste blithely with `VECTOR_NAME` because you’ll end up with name like `VECTOR_NAME_init` instead of `int_vector_init`. Hence the extra expansion step before `##`ing.) You’d do basically the same thing for implementation, but usually from a separate driver file: /* in int_vector.c */ #define VECTOR_NAME int_vector #define VECTOR_TYPE int #include "make_vector.c" #undef VECTOR_TYPE #undef VECTOR_NAME /* And unless you have things that are specific *just* to vectors of integers, that's all * for this file. */ And then `make_vector.c` would look something like this: #include "make_vector.h" #include "make_vector_mname_def.h" typedef VECTOR_TYPE Elem; typedef struct VECTOR_NAME Vector; void VECTOR_MNAME(init)(Vector *self) { self-&gt;init = NULL; self-&gt;capacity = self-&gt;length = 0U; } etc. etc. With any preprocessor-based approach, you’ll have problems if your element type doesn’t fit cleanly on one side of a variable in a declaration. `int` or `char *` would be fine (`int x`, `char * x`) but `int[5]` or `char (*)(void *)` would not—`int[5] x` or `char (*)(void *) x` are invalid, and should be `int x[5]` or `char (*x)(void *)` instead, because C/++ type syntax is very, very stupid. For the latter type of type, you’ll want to use `typedef` to encapsulate it cleanly: typedef char (*fpv2c_elem_type)(void *); MAKE_VECTOR_STRUCT(fpv2c_vector, fpv2c_elem_type) If you’re targeting GCC/Clang/ICC, you can wrap types in `__typeof__` to ensure they don’t break things; e.g., `__typeof__(int[5]) x` would be identical to `int x[5]`, and doesn’t require its own `typedef`. Now if all of the above looks awful—and let’s be honest, it kinda is—you can do other tricks to come up with a singular, rather more abstract `struct vector`: struct vector_virt; struct vector { void *data; size_t length, capacity; const struct vector_virt *virt; }; struct vector_virt { void *(*init_allocData)(void); void (*freeData)(void *); void *(*resizeData)(void *, size_t newCap); size_t (*calcNewCap)(size_t have, size_t need); size_t esize, ealign; }; This will probably come out somewhat slower than the preprocessor-based approach; this uses the equivalent of virtual methods to sidestep differences in implementation details, whereas the preprocessor approach would give you almost identical results to the C++ template `vector&lt;T&gt;`. If you’re using link-time optimization, you might be able to bring the performance of the two approaches roughly into parity with each other. Anyway, each element type would need its own representative `vector_virt`instance, possibly with its own separate set of virtual function implementations. You can macro-ize around some of these, but runtime actions would be handled through a single interface this way, and you’d have significantly less boilerplate per element type.
Use function strcmp(a, b) to compare strings. Using == operator doesn't compare the string contents, but instead compares whether the string vars point to the exact same address in memory.
 if( UTGFactors == "3") This is not doing what you think it does. You cannot compare strings in C like this. You need to read about [strncmp()](https://linux.die.net/man/3/strncmp)
You're on track to replicate a typedef and variable naming system like this https://docs.microsoft.com/en-us/windows/desktop/winprog/windows-data-types &amp; https://docs.microsoft.com/en-us/windows/desktop/stg/coding-style-conventions. Unless you have a very good reason, I'd discourage needlessly masking native C types, or at least follow some conventions like the Windows ones.
try with this: if (UTGFactors\[0\] == '3')
Nobody gonna mention buffers that work with every type without sketchy code generation 100% of the time? [see here](https://github.com/nothings/stb/blob/master/stretchy_buffer.h)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [nothings/stb/.../**stretchy_buffer.h** (master → e6afb9c)](https://github.com/nothings/stb/blob/e6afb9cbae4064da8c3e69af3ff5c4629579c1d2/stretchy_buffer.h) ---- 
Hey that worked! Thanks a lot! Why does that work and without the \[0\] doesn't.. isn't it a \[0\] by default? Either way, thanks my dude.
I'm sure you probably know more about C strncmp than I do, but I've successfully used it to compare whole strings before, and did in fact get it to work like that. All I had to change was it to was; if (UTGFactors\[0\] == '3'). 
... till you enter "30" or "3.14159" or any string beginning with the character '3'.
Doof! Oh yeah.. I just changed it to if (strcmp(UTGFactors,"3")==0) {, thanks for the insight.
But I get what you're saying, if (strcmp(UTGFactors,"3")==0) { is much better.
Yup. there are some setters and getters as well.
I don't see a point. I think every C programmer ever will automatically think "string" when they see char\*. I don't really like typedeffing pointers in general just because I find the asterisk to be more clear. Obviously you could make whatever typedef you want, but if you ever plan on distributing your code, users will expect char\* for strings and not a typedef.
It would just take the first digit, because it's only asking for \[0\] so it could be any string, (3, 321, 3xxxx) and it would register it as correct, so long as it starts with a 3. 
 if (UTGFactors[0] == '3') Is the same as if (*UTGFactors == '3') Because UTGFactors is a pointer to the first char
Or please just use [klib](https://github.com/attractivechaos/klib/blob/master/README.md), don't roll your own buggy version of it.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [attractivechaos/klib/.../**README.md** (master → 31cb030)](https://github.com/attractivechaos/klib/blob/31cb0301482a762af0adbfc85dff1632cecc2bb4/README.md) ---- 
Lol
...wrapped in a small shell script since sed can't edit a file in-place: #!/bin/sh for f ; do if sed -e '/^#include/y/\\/\//' &lt;"$f" &gt;"$f.$$" ; then mv "$f" "$f.bak" mv "$f.$$" "$f" else rm "$f.$$" fi done but Perl can: perl -p -i -e '/^#include/ &amp;&amp; y/\\/\//' 
Most versions of sed I know have a `-i` (in-place) option, so in your example: `sed -i.bak -e '/^#include/y/\\/\//' $f` will do the trick.
Not POSIX :p
It's all good and fine, but Windows users do not have such useful utilities, you need to write programs (with GUIs!!) for that...
&gt; The "b" is still important I think since otherwise Windows does some silly auto-mangling with text mode (which is the default). If it works without "b", it's basically luck. You mean when there's a pixel with color component that would correspond to an `\n` char? Or something like that?
This goes a bit over my head haha. I know how to do linear algebra (though I probably don't know about all the finer details), but I've never heard of "singular-value decomposition". Note, I come from a mechanical engineering, not programming or mathematics background. The homework assignment was a bitmap with, what appeared to be, some red color noise. The trick was to set all red pixels to white (and perhaps set all non red, non white pixels to black for better contrast. That would then give an image that showed a clue written in it. I think what you are hinting at is a way more sophisticated method to store secret information in a bitmap. That problem was fairly easy to solve, but since I already knew C++, I thought it would be interesting and educational to port the C code from the Ubuntu cloud environment to C++ code on my own Windows desktop and perhaps even build a small library that would easily let me read and write bitmaps (and perhaps some other file formats). Since I quickly ran into trouble, I thought it might be smart first compile the C code on my own desktop, but even that was not particularly straightforward.
And BSD sed and GNU sed behaves differently, `sed -i.bak` works for GNU, while `sed -i .bak` is working for BSD. But note that a move isn't always what is wanted as it clobbers with symbolic links, consider using `cat "$f.$$" &gt; "$f"` instead.
True, ah, the fun porting code from FreeBSD to Solaris was also great :P
What if instead of the `strptr[k] = buffer` you put a strptr[k] = malloc(sizeof(char)*j); strcpy(strptr[k], buffer); You are working with pointers, so probably you will want to initialize it.
&gt; And your function name does not include the fact it reads a little &gt; endian integer. Sometimes I'll name it `load_u32le()` ("unsigned 32-bit little endian") if I feel it's important, such as when I need to read integers encoded either way in the same program. That's not the case for BMP, though. &gt; Do WORD and DWORD imply little endianness? Not really. The BMP format specifically uses little endian for encoding integers (being a Microsoft-defined format), that's all. Due to this, on big endian systems the structure overlay approach wouldn't work even if you got all the packing right since the bytes would be encoded differently. Some other formats, such as network packets, use big endian (e.g. "network order") to encode integers. Some formats, such as .WAV, uses both big and little in the same file! &gt; And assuming &lt;&lt; and &gt;&gt; are bit shift operators Yup. I don't know any good resources offhand. There's not *that* much to them: they shift bits left and right in an integers. It's like dividing or multiplying by 2. There are a lot of neat tricks it can accomplish. The special rules for C are: don't shift at once by more than the width of the integer (undefined behavior), don't right-shift negative values (implementation defined: arithmetic vs. logical shifting), don't left-shift a 1 into the most-significant bit of a signed integer (implementation defined: two's complement, etc.). 
Point noted, thanks. Pedantic seems to be key with C. I'll try incorporating the memset function into my code, forgive me, but I fail to see how that will rectify my issue. I was unsure about which variables were going to be local/global, so this is a temporary solution.
Thanks for the tip. Unfortunately, this hasn't done the trick. also, im assuming you meant: strcpy(strptr[k], dest); Isn 't strcpy a poor method of doing this? It can lead to segmentation faults if used incorrectly and makes the program sluggish. Is this true?
Yeah, I mean `dest` instead of `buffer`. I had never have problems with `strcpy`, but if you are unsure, you can try `strncpy(strptr[k], dest, j)` or `memcpy(strptr[k], dest, j)`. I will see the code again looking for errros. I recomend you to try a debugger.
The main problem is that you are using a lot of times the `dest` location. In C strings does not exists, so every time you are doing `strptr[k] = dest` the whole `strptr` is pointing to the same block of memory, not differents blocks of memories (remember you are using pointers, not "normal" variables). So, if you modify the `dest` variable, all of the "strings" in `strptr[k]` are going to have the same value, and you are putting a `\0` in `dest` to reset the variable (i think), so all the `strptr[k]` are `\0` when the loop ends. That's why the last printf does not work. If you want to try this out, at the very end of the code put this: printf("\n *i\n", strptr[0][0]); And a zero (0) will be printed.
&gt; Pedantic seems to be key with C. Wait till you touch Assembly.
&gt; Yup. I don't know any good resources offhand for you. There's not that much to them: they shift bits left and right in an integer. It's like dividing or multiplying by 2. There are a lot of neat tricks it can accomplish. Also, they work the same way regardless of the host byte order, which is why they're well suited for this situation. I think I was forced to learn quite a bit about these operators today. I managed to implement the functions you suggested earlier. Since I wanted to do it in C++, I didn't need to use fread and solve your little bug (switching 1 and 14). This worked all successfully. Then I went on to the BITMAPINFOHEADER and here I had 4 longs. I used the following function to implement this: LONG load_long(const char *p) { return (long)p[0] &lt;&lt; 0 | (long)p[1] &lt;&lt; 8 | (long)p[2] &lt;&lt; 16 | (long)p[3] &lt;&lt; 24; } With LONG being int32_t. Two numbers (biWidth and biHeight) didn't get translated correctly. These numbers were x0280 (640) and x01e0 (480). They were translated as -128 and -32 respectively. The reason was that both numbers had bits starting with a 1 and a signed long starting with a 1 indicates a negative number, but, ofcourse, that's only true for the first bit. I did quite some debugging and the solution I came up with is this: LONG load_long(const char *p) { return (BYTE)p[0] &lt;&lt; 0 | (BYTE)p[1] &lt;&lt; 8 | (BYTE)p[2] &lt;&lt; 16 | (BYTE)p[3] &lt;&lt; 24; } where BYTE is a uint8_t. So now my program works, but I'm not sure if it is a good solution. If I didn't have any LONGs with individual bits starting with 1, I guess my original solution would have worked and I would later be surprised if it wouldn't. I would then be asking why one bitmap would read correctly but the other wouldn't. So, is the solution with BYTE acceptable, or would I run into trouble later? And, considering your solution where you cast everything to unsigned long, would it matter if I replaced them by BYTE?
It only reads a single digit at a time (plus leading whitespace of course) because you only supplied single digits numbers. If you had a number with multiple digits it'd read all of them when the loop got to that point. I don't think you understand the concept of a stream. Read a character from one and it's removed from the stream. You don't read the same one again next time you read a character... 
&gt;You mean when there's a pixel with a color component that would correspond to an \n char? Yes.
&gt; solve your little bug (switching 1 and 14) Here's the prototype for `fread()`: size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); Internally it multiplies `size` and `nmemb` (being careful about integer overflow), and that's the number of bytes to be read. On success, it returns the "number of members read." By using (1, 14) I'm asking it to read 14 1-byte quantities, and so on success it returns 14. With (14, 1) I'm asking it to read 1 14-byte quantity, and on success it returns 1. The big difference is when it fails. When (1, 14) fails — due to either EOF or some error — from the return value we can tell exactly how many bytes were actually read, which matters in some scenarios. For (14, 1), we only know the read was short, but not by how much. For a BMP reader, this may be sufficient since the response is probably to report the error and exit, not caring how many bytes were actually read. The only bug is not checking weather the read was successful. &gt; With LONG being int32_t. Do *not* use a signed integer to do these reads. As you noticed, you *will* get the wrong result. There are two mistakes in your code: 1. You're reading from a `char`, which is probably signed. Then you convert to a `LONG`, another signed integer. Then you left shift the result. Some of these `char` values will be negative, so ultimately you're bit shifting a negative value. Don't do that. 2. Also remember how I told you not to shift a 1 into the MSB of a signed integer? If you want to read a signed integer, read it as an unsigned integer then convert it to a signed integer. It will safely wrap around during the conversion to the correct signed value: long biWidth = load_u32le(ptr); // this works just fine Same goes for writing signed integers: convert to unsigned and write them out as if they were unsigned. &gt; where BYTE is a `uint8_t`. Your code is incorrect and only works by sheer luck. Think about what you're doing: you're reading a probably (as `char` may be either signed or unsigned by default) 8-bit signed value, converting it to an 8-bit unsigned value, then *left shifting by greater than 8 bits*. What makes this *seem* to work out is that integer operations are always done with at least `int` precision. The `uint8_t` is promoted to a signed `int`, which, fortunately, happens to be 32 bits wide. That's wide enough for your purposes, but technically not strictly conforming since it's not necessarily that wide. Of the two bugs above, you've fixed the first bug by converting to an unsigned byte, but you've made the second bug even worse with an implicit conversion to `int`. A language lawyer being *super* nitpicky with the C specification would point out that even a `uint8_t` isn't the right type for reading individual bytes from a buffer. Unlike `unsigned char`: 1. It's an optional type. (Though incredibly unlikely to be unsupported on any machine made in the last 40 years.) 2. It may have so-called "trap representations." (Though this has never actually occurred in practice). 3. It doesn't have the aliasing exceptions of `char`. (Though every compiler today allows `uint8_t` to alias as you'd expect.) In short: Use unsigned integers (`unsigned char`, `unsigned long`) for every part of these loads. Convert unsigned results to signed as needed. Don't bit shift values that may be negative. You don't need any fixed-width integer types (`uint8_t`, `int32_t`) to do any of this, nor typedefs like `LONG` or `DWORD`. 
I know you're supposed to be able to trim out functionality you don't need to reduce footprint, but if you've found something that works... [https://tls.mbed.org/kb/how-to/reduce-mbedtls-memory-and-storage-footprint](https://tls.mbed.org/kb/how-to/reduce-mbedtls-memory-and-storage-footprint) 
If you are doing a masters degree, get down with [Gilbert Strang](https://www.youtube.com/watch?v=ZK3O402wf1c) and Strang's books on Linear Algebra. I mean it: best bang for your money for grad school. Also take numerical analysis and some advanced linear algebra. You will no regret it, especially since you are already swimming in partial differential equations.
Thanks for the suggestion. I already did linear algebra during my bachelor, so, at first sight, the video seems a little too basic to me. Furthermore, I'm currently working through the CS50x course on edX. I'm trying to finish [this](https://github.com/ossu/computer-science) online Computer Science program, so I will be busy for quite a while and I'm not sure how Gilbert Stang's material will fit in there. I don't know what I'll do yet when I reach linear algebra as I've already done this during my bachelor, but I might be using the courses to refresh my knowledge or gain a different perspective. I might also postpone it for later.
scanf is a function that essentially ignores any whitespace character (like space, tab, newline, etc) and formats into what you tell it to (in this case %d - digit). if you want to understand this in a 'not easy way', you can write your own custom function that mimics this behavior. 
Thanks for the explanation regarding fread. Something I didn't mention: I had to changed the unsigned char from your example to a signed char because when I translated the original code from C to C++ the compiler got upset because I tried an invalid conversion from 'unsigned char*' to 'std::basic_istream&lt;char&gt;::char_type* {aka char*}' [-fpermissive]. So I tried to change your unsigned char to char and, luckily, everything worked again. I don't know if you're familiar with C++, but I tried to do the following: unsigned char buffer[54]; std::ifstream infile(argv[1], std::ios::binary); infile.read(buffer, 54); which only works if I drop `unsigned`. &gt; You're reading from a char, which is probably signed. Then you convert to a LONG, another signed integer. Then you left shift the result. Some of these char values will be negative, so ultimately you're bit shifting a negative value. Don't do that. &gt; Also remember how I told you not to shift a 1 into the MSB of a signed integer? By then I already had done that and it seemed to work, so I didn't really think it was worth mentioning at that point. &gt; Your code is incorrect and only works by sheer luck. Think about what you're doing: you're reading a probably (as char may be either signed or unsigned by default) 8-bit signed value, converting it to an 8-bit unsigned value, then left shifting by greater than 8 bits. Would an explicit conversion to a 32 bit int be a satisfactory solution? &gt; In short: Use unsigned integers (unsigned char, unsigned long) for every part of these loads. Convert unsigned results to signed as needed. Don't bit shift values that may be negative. You don't need any fixed-width integer types (uint8_t, int32_t) to do any of this, nor typedefs like LONG or DWORD. I'd agree that the goal should be to write correct and working code, rather than just working code, but if I'm forced to drop the unsigned, than what would be the best way to proceed?
Gotcha. The first five videos in that series is basic stuff. The fun becomes with matrix factorization and numerical analysis recipes 
I think I will make a note somewhere so that by the time I have time for that I can take a look at Gilbert Strang's material.
Thanks for your help. It's now working the way you suggested. I created the following cpp file (but it also qualifies as valid C). I won't show you the header file as it just has the function declarations. #include "bmp.h" /* Read unsigned 16-bit little endian integer from a buffer. */ WORD load_word(const unsigned char *p) { return (unsigned long)p[0] &lt;&lt; 0 | (unsigned long)p[1] &lt;&lt; 8; } /* Read unsigned 32-bit little endian integer from a buffer. */ DWORD load_dword(const unsigned char *p) { return (unsigned long)p[0] &lt;&lt; 0 | (unsigned long)p[1] &lt;&lt; 8 | (unsigned long)p[2] &lt;&lt; 16 | (unsigned long)p[3] &lt;&lt; 24; } /* Read signed 32-bit little endian integer from a buffer. */ LONG load_long(const unsigned char *p) { return (unsigned long)p[0] &lt;&lt; 0 | (unsigned long)p[1] &lt;&lt; 8 | (unsigned long)p[2] &lt;&lt; 16 | (unsigned long)p[3] &lt;&lt; 24; } Any suggestions would be appreciated.
I think you are making the problem more complex than it is with that nested loop. If you make it a single loop and then you keep track of the begin/end positions it will be a lot easier. For example: #include &lt;stdio.h&gt; #include &lt;string.h&gt; const char buffer[] = "I have(60438.0,63493.0)loads of(-2100.0,63493.0) stuff " "(87659.0,55553.0)to copy (-70048.0,-61111.0) to strings."; #define buffer_begin (buffer) #define buffer_end (buffer + sizeof(buffer)) char destination[sizeof(buffer)]; static char* copy_it(const char* base, size_t len, char* out) { memcpy(out, base, len); out[len] = '\0'; return out + len + 1; } int main() { char* ptr = destination; const char* first = NULL; const char* last = NULL; for (const char* it = buffer_begin; it != buffer_end; it++) { if (*it == '(') { first = it + 1; last = NULL; } if (*it == ')' &amp;&amp; last == NULL) { last = it - 1; char* next = copy_it(first, last-first, ptr); printf("%s\n", ptr); ptr = next; } } return 0; }
You've got it.
 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; char buffer[] = "I have(60438.0,63493.0)loads of(-2100.0,63493.0) stuff (87659.0,55553.0)to copy (-70048.0,-61111.0) to strings."; int main() { int nth = 0; char **numbers = calloc(1, sizeof(char*)); for (char *b = strchr(buffer, '('); b != NULL; b = strchr(b, '(')) { char *e = strchr(b, ')'); char *ctr = ++b; for (; ctr &lt;= e; ctr++) { if (*ctr == ',' || *ctr == ')') { size_t size = ctr - b; char *nstr = calloc(size, sizeof(char)); strncpy(nstr, b, size); numbers[nth] = nstr; numbers = realloc(numbers, 1 + sizeof(char*) * ++nth); b = ++ctr; } } } for (int i = 0; i &lt; nth; i++) { printf("%s\n", numbers[i]); } } 
[Sure you do.](https://docs.microsoft.com/en-us/windows/wsl/install-win10)
That's cheating!! :p
The strcpy methods gets a bad reputation because it’s possible to overwrite the allocated space. The strncpy() method is more effective, in that regard, but requires you to keep track of how many chars you’ve allocated.
Check the docs for strcpy, etc. Away from my desk, but I think the dest is the first arg.
This is great advice. Many years ago ( more than I care to admit ) I worked on a business application in an insurance company and had to deal with user input. Users will type in all manner of stuff. The actuarial department staff would often enter a negative number in parentheses. Sometimes with the negative sign and sometimes not. Sometimes people would use comma for $14,236.89 and sometimes not. You may get a dollar sign. Or not. You may get the word "zero" or "Zero" or "nil" or just a blank field for a zero value. Thing were far worse for date fields where I would see "next Tuesday" and "tomorrow" and "1st Jan 1996" or the ones I really loved were "29 Feb 2018" which isn't a leap year. Just all manner of fun. Here is some fun stuff for dates : Leap year rules are : If evenly divisible by 4 and not evenly divisible by 100, or is evenly divisible by 400, then a leap year if ( (!(y % 4) &amp;&amp; y % 100 ) || !( y % 400 ) ) { days_in_month[1] = 29; It may be a whole lot easier to simply keep a list of leap years for twenty years into the past and future. int leap_years[20] = { 1960, 1964, 1968, 1972, 1976, 1980, 1984, 1988, 1992, 1996, 2000, 2004, 2008, 2012, 2016, 2020, 2024, 2028, 2032, 2036 }; Each of those years have a 29th of February in them. n.b.: After 03:14:07 UTC Jan 19, 2038 is not supported That last line there is worth knowing. For entirely other reasons. 
Please provide a short but complete example which demonstrates the problem.
`%d` means decimal, not digit.
&gt; in this case %d - digit `%d` means decimal, not digit.
-0 is that a value that exists? And if yes what is it used for?
https://www.youtube.com/watch?v=BRRolKTlF6Q there are a lot of ideas on some of this.. which gets into physics, its complex. 
Look up floating point formats, especially IEEE754, they are a complicated topic and can easily be the source for problems if you are ignorant of how they work.
thanks, might come in handy one day. 
Sorry but this is some ugly code with useless comments, however what the function should *do* is not commented. And why spaces *in front of* the comma? And I still don't see the appeal, I seldomly want to just pass one byte or character per pointer, copying usually makes more sense there.
&gt; -0 is that a value that exists? The C standard allows the concept of a "signed zero", but it does not require it. You'll find it on systems that implement IEEE 754 arithmetic (and perhaps others, though I'm not familiar with those). &gt; And if yes what is it used for? It is numerically equal to other zeroes (both signed and unsigned), however it can affect certain calculations. For instance, on my system I get the following: printf("%f\n", 0.0); /* 0.000000 */ printf("%f\n", -0.0); /* -0.000000 */ printf("%f\n", 0.0 - (-0.0)); /* 0.000000 */ printf("%f\n", (-0.0) - 0.0); /* -0.000000 */ printf("%d\n", signbit( 0.0)); /* 0 */ printf("%d\n", signbit(-0.0)); /* 1 */ printf("%f\n", 1.0 / 0.0); /* inf */ printf("%f\n", 1.0 / -0.0); /* -inf */ printf("%f\n", sqrt( 0.0)); /* 0.000000 */ printf("%f\n", sqrt(-0.0)); /* -0.000000 */ printf("%f\n", trunc( 0.0)); /* 0.000000 */ printf("%f\n", trunc(-0.0)); /* -0.000000 */ printf("%f\n", fmax(0.0, -0.0)); /* 0.000000 */ printf("%f\n", fmin(0.0, -0.0)); /* -0.000000 */ fesetround(FE_TOWARDZERO); printf("%f\n", nearbyint( 0.0)); /* 0.000000 */ printf("%f\n", nearbyint(-0.0)); /* -0.000000 */ fesetround(FE_TONEAREST); printf("%f\n", nearbyint( 0.0)); /* 0.000000 */ printf("%f\n", nearbyint(-0.0)); /* -0.000000 */ Even though negative zero and positive zero are in all senses "numerically equal", in some scientific and engineering disciplines it is important to distinguish whether a value underflowed to one or the other.
That's a good point, I should have said a combination of that and the input that was provided caused a single digit to be stored.
Thank you and all of the other responders!
note that the expression `-0` is the integer +0 ; to generate a negative zero you have to do something different
True, I thought of "-0" as the general concept of a negative zero rather than a C expression as I think that's what OP meant.
Thanks!
Dear Daniel, I think that the use of c++ will grow. I started learning c++ when I was about 22, and now I am 48. For a long time c++ was being ignored but I predict a rebound particularly with the simplicity that android studio integrated c++ with java. There is always a need for speed and with the growing use of AI you are going to see more and more need for c++.
If I were to read a text file and store it in dynamically allocated memory location i.e. \*buffer, how would you implement this?
I think OP understands the pattern matching (`%d`), but not necessarily the streaming. Hidden away from you is the implementation of the `scanf` function. The operating system typically supplies programs with something like a `stdout` and a `stdin`. These are character streams that you can push characters into or pull characters out of (if there are any characters available). You can think of the streams like "pipes". When you read from a stream you are taking the next available chunk of data. After its been read it can't be taken again. Functions like `scanf` and `fread` and others can read from `stdin`. You can mix and match different functions for reading from streams and they'll all get whatever's next in the pipeline. 
What?
I don't really understand what you are trying to do, but i think you are in the wrong sub. C# and C are two totally different languages.
/r/learncsharp
....wat? you might be lost, I think you might want /r/csharp also read your post before pressing submit (accidentaly wrote #c instead of C#)
Question, I assume it does but does `-0 == 0`?
Yes most implementations will have this 
You should look in to arrays and how to use them.
Do arrays have a function that allows you to generate randomness? 
Probably something like this: // Define a structure that will encapsulate the pieces of the players that you need to use struct Player { int index; char* buffer; }; // Create a structure for each player and set the variables to appropriate values struct Player sPlayer1 = {.index = 1; .buffer=Player1}; struct Player sPlayer2 = {.index = 2; .buffer=Player2}; struct Player sPlayer3 = {.index = 3; .buffer=Player3}; struct Player *playerArray[3] = {&amp;sPlayer1, &amp;sPlayer2, &amp;sPlayer3}; // Randomize the array // For each position in the array for(int i = 0; i &lt; 2; ++i) { // Choose a random element in the array to swap with playerArray[i] int target = rand() % (3 - i) + i; if(target != i) { // Do the swap struct Player* temp = playerArray[i]; playerArray[i] = playerArray[target]; playerArray[target] = temp; } } // Use the array for(int i = 0; i &lt; 3; ++i) { struct Player* p = playerArray[i]; printf("What is the name of player %d?\n", p-&gt;index); // A really long name will overflow the buffer here. This should be replaced with a more secure variant, like // fgets() scanf("%s", p-&gt;buffer); } 
Not directly. But either you could write a function which shuffels the array entries or generate a random index that picks an element from the array. 
Thanks a lot. This code looks well written and is sort of advanced for me. Why are we using a buffer here? 
Look into the rand() or random() functions to generate random numbers, and use those random numbers to control the ordering at run-time. Hint: You should be able to do this without asking for the same player multiple times. You'll need a separate array that stores the ordering. Make sure to seed the random number generator (RNG), so that you'll get a different order each time you run the program. Whether you choose rand() or random() (or something else) depends on your OS and the randomness requirements of your program. Extra credit: Ensure a uniform distribution by rejecting some values that rand() or random() outputs.
Thanks for the solid starting place, you've been the only one to actually mention what the functions to look into are. I'll be reading up on them, appreciate the help my man!
Your question is a bit vague, there are a few issues which if you can explain would actually help you to learn the best way to write C code. * Why are you not using loops for repetitive code? * Why are you using global variables? * Did you notice the potential buffer overflows in your input code? C has a long history and unfortunately many beginning C books and tutorials don't use best practices. C is also a very flexible language due to its low level and one side-effect of that means that very strange code - like what I pasted below - actually does what you want, but you wouldn't want to use it. #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdint.h&gt; #include &lt;time.h&gt; int main() { srand(time(NULL)); char str[] = { 0x57, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x20, 0x00, 0x01, 0x01, 0x01, 0x00 }; char * player [3]; for(uint8_t i = 3, x; i; --i) { if(!str[28 + (x = (rand() % 3))]) { ++i; continue; } printf("%s%d? ", str, 1 + (--str[x + 28] | x)); scanf("%ms", &amp;player[x]); } return 0; }
Randomizing the positions in which each string will be stored in the array is simpler.
Your code also writes to random uninitialized pointers.
use Rand() also btw you should probably be using for loops for the scanf/printf stuff
it does not, scanf %m allocates the memory to store the argument and requires a char **
I don’t think that’s part of standard C. It’s true I didn’t notice the %m though.
Well, any solution would have to do what your pseudocode does, so I doubt you can speed up your algorithm (except perhaps by replacing the "%2" with "&amp;1", but that only matters if your compiler is failing at simple optimizations). Assuming that your function implements your pseudocode properly, there may be room to optimize your implementation.
Thats good to know, I will just use my linked list and stacks while I try to build a complex cVector with 16 functions or more. &amp;#x200B; Thanks.
It will be much easier for people to help you if you post your actual code. If it's too long to fit in a reddit post, you can use [Pastebin](https://pastebin.com/) or [Gist](https://gist.github.com/).
There's the one available through Amazon's cloud reader.
Remember to handle escaped quotes (\"). For parsing it is common to implement a simple state-machine.
type one out yourself
just might do that... but not tonight
Gotta check on copyright status to see if it could be an issue, but I'm actually interested. If we get 10 to 20 people to type out one page a day, we could be done in less than a month. We could have a Github and everything and we could work on editing it and make it nice too.
not an issue if you already own the book (i do) and you share with others who already own the book. i also have an answer book to all the problems. 
No legal copy. K&amp;R is still under copyright, please do not share illegal copies.
Please only post programming content that is specifically about programming in C.
If you can live with linux specific and dont need full portability, I would mmap the file and store the pointers to it. It looks like you want to parse something, so just perform the parsing inside the `if ')' ` block and store the result somewhere else.
I can joinn!!
perfect explained!
Safari Books have an HTML version. https://www.safaribooksonline.com/library/view/the-c-programming/9780133086249/
Are you sure? It is available on the Internet Archive: [https://archive.org/details/CProgrammingLanguage2ndEditionByBrianW.KernighanDennisM.Ritchie](https://archive.org/details/CProgrammingLanguage2ndEditionByBrianW.KernighanDennisM.Ritchie)
Here is full text, might save some time. https://archive.org/stream/CProgrammingLanguage2ndEditionByBrianW.KernighanDennisM.Ritchie/C%20Programming%20Language%2C%202nd%20Edition%20by%20Brian%20W.%20Kernighan%2C%20Dennis%20M.%20Ritchie_djvu.txt
That doesn't mean this copy is legal. Please take down this link or show evidence that this is a sanctioned copy.
While there is no standard function to shuffle an array, you can easily implement a shuffle function yourself. A [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle) is both easy to implement and quite fast.
I see. Thank you for the information. Are we decades way from the copyright running out?
Yes. Copyright in the US is 75 years from the death of the author if I recall correctly and Kernighan is actually still alive.
So [archive.org](https://archive.org) does not validate the legality of files uploaded on it?
Do not post links to copyrighted material. 
Which is why you stored the random numbers in a variable or array.
So the first call to scanf in my program prompts the user for input, whereas the next calls all read directly from the stdin stream? I suppose what is confusing me is why the calls to scanf in the loop don't stop and ask the user for input again? I made this test program below: #include &lt;stdio.h&gt; int main(void) { int a, b, c, d; printf("Enter three numbers separated by spaces... "); scanf("%d", &amp;a); printf("%d\n", a); scanf("%d", &amp;b); printf("%d\n", b); // now only one value is left in the stream. scanf("%d", &amp;c); printf("%d\n", c); // now no more values are left in the steam, do I get prompted again? scanf("%d", &amp;d); printf("%d\n", d); return(0); } which basically shows that scanf keeps reading from the stream until it runs out, then prompts again for input. &amp;#x200B; But can't a user abuse this really easily? When I ask to input an integer in the first call to scanf, if they instead enter say 10 separated by whitespace, won't they "confuse" all the following calls to scanf by filling up the stream? Cheers!
yes its combined with the buffer overflow but still the key here is to use format string vulnerability of this code
A "format string vulnerability" specifically refers to a hostile format string, which isn't the case here. For example: printf(argv[1], argv[2]); The format string above comes from an external source, and it may be possible to choose a string that causes the program to misbehave. You also have a bug where you're using `%x` to print an integer pointer and a signed `int`.
`static int value = 1122;` means that `&amp;value` is not on the stack, but in the data section, which is even below the heap. Exploiting %n will only write to addresses that are higher up on the stack. So, you can't really write anything there using the printf on line 15. But I do agree that there is a format string vulnerability since you can put a bunch of %n as argv[1] and corrupt the stack, even without causing a buffer overflow in strcpy.
From what I can tell, the static int, as initialized data, will be located in memory prior to the character buffer.
well, how do I change it to 9988 then? I am out of ideas, if it would be on the stack I could just find the address of it with %p and add some integers into it using %n
and why isnt on the stack? the main function uses it, so it is a local variable near the stack
It's declared as static, which means it needs to be in static storage and preserved across function calls. Since the stack is not preserved across function calls, the storage for the variable has to be allocated in a place where it can be preserved throughout the life cycle of the program. While this is implementation dependant, most compilers would choose to put it in the data or BSS sections. See https://stackoverflow.com/a/572550/4320738 and https://stackoverflow.com/questions/93039/where-are-static-variables-stored-in-c-c#93411 for a basic explanation.
you probably can't do it using format strings. also, if this is homework, you should probably consult your teacher instead of reddit for such questions.
Uh, -0 is only present in ones complement system, which basically doesn't exist and hasn't existed for decades.
`struct *` is an error, it should be `struct mystructname *`
I'd suggest looking into the win32 api on windows. Specifically the GetKeyState, GetAsyncKeyState and GetKeyboardState functions.
linux /s if you want to go super ultra minimal then you can use notepad++/vim and mingw. otherwise code::blocks is a good choice. I remember reading about someone who made a new ide/compiler called pellesC or something like that a while back. Don't know how good it is tho.
Vscode with MinGW should be fine, but really Linux is the best for this kind of stuff and will seriously speed up the time it takes for you to learn new things
What would the equivalent be for iOS?
iOS is locked down to the point where this is pretty much impossible
Remember that if you're on Windows 10 you can always use WSL and have a full native Linux experience. Also, I'd seriously recommend Address Sanitizer instead of valgrind.
CodeLite deserves much more mention than it gets
Is there a high-level IOS alternative?
Vim or notepad++ is your best bet.
Ops, edited
Notepad++ is awesome but you can't compile and run within it, so I recommend you Code::Blocks it's nice
Can you explain why you prefer Address Sanitizer? 
It's not very lightweight and does have many problems, but Cygwin is actually very good once you get the hang of it. It's the only way to get a environment that fully integrat both Linux (partial) and Windows. You can actually write programs that use Linux socket API and Windows GUI API at the same time.
It will print -1. `for (initializer; condition; iterator)` `{body}` Because the local variable will be initialized in the initializer, then the variable will be assigned to -1 in the condition instead of comparison. Then body will be executed and only after that the assignment will take place in iterator. Of course in this case there is a brake and no assignment will happen. There only one approach - understand how for loop works and remember execution order.
This. Qtcreator is great.
Have you tried tracing the loop step by step on a sheet of paper?
Congratulations!
Since each platform handles keyboard input in a different ways, there is no portable way to do this.
Either hook into Win32 for Windows to do this or try to use SDL2, it should be able to handle this abstraction.
On windows there are only two options for best experience: Visual Studio Community (heavy weight) Visual Studio Code (light weight) If you are haxx0r you can use vim or emacs through Cmder or Windows bash (ubuntu)
It has waaay less overhead than valgrind, and since it instrument only the code you compile explicitly with Address Sanitizer, you get only reports for the code you're interested in. With valgrind you get reports for lots of uninteresting stuff like libs, etc. Of course, sometimes you really need valgrind, but for the occasional segfault I've found asan to be more useful.
A Linux VM? 
Please don't be evil
Sounds like this guy’s code does speak for itself. 
One approach to try would be to take a chunk of his code that is hard to understand because of poor naming and no comments, and refactor it with better names that make the code easy to understand. Say that this is the type of naming you need if your code is going to speak for itself. Now if he’s not good at taking criticism or ideas from younger people, that may not work. He’s an expert beginner though it sounds like. https://daedtech.com/how-developers-stop-learning-rise-of-the-expert-beginner/
The quirk with this code is the &gt; i = -1 In the condition field, usualls there should be a comparison and not an assignment. Thats what is throwing people off when they first encounter code like that. From then on the code is pretty easy to understand. It will print -1 and then the following condition is true, since &gt; -1 != 1 And it breaks out of the loop.
I'm trying to do that actually. It's not easy to do as one global may require you change 3-4 functions at least and may change a bunch of other stuff, but I'm getting there. Thx for the suggestion. 
One thing I forgot: unit test! Write tests first. Make sure they work and then start refactoring. Don't forget the tests or you'll regret it badly. Also make heavy use of version control, I strongly suggest git, so you can easily go back and forth with the changes.
This is only for fun. I've always wondered about processing input, and this seems like a good opportunity.
Doing this is a good way to start a conflict in an office environment. Changing the style of people's code because you believe they are doing it wrong without talking this through with the project manager is a huge no-no, even if the other person is actually wrong. Some people see this as a personal attack, but generally it just makes you look like a huge smartass.
If you write it with OS api .. that will be hard . Try to find a Library cross platform , or something like that to get Better work "One code in more platform" Not only for small code .. but cause is less bugs 
make him read "Code Clean" from Robert Martin. And do you so 
In an office environment everyone "should" be professional enough to put the team / company before themselves but I realize that isn't always the case. Even still, having healthy discussion on the best way to do things isn't bad and it can be done in a way to not start bad conflicts. Conflict is good with the right goal in mind, but if peoples' egos get in the way, they shouldn't be in a team environment anyway.
Globals are easy to find, they have the same name in all modules and must be declared as extern in each one of them. You can rgrep for the name of that variable and you will find all the modules that use it. If the code has 15 years old and it´s working please don´t touch it!!!!
You can also find them easily with `nm`.
I rarely comment my code. Just to give you a reference point, I started writing my private book on standards I go by while programming (mostly adapted from Google, some code I found inspiring before and mistakes or things that made a certain project easier to manage). I love programming but I hate writing comments or documentation or tests. I have to force myself to do so. I would still hit Jerry in the face for not doing his job properly.
Do `nm` on the final executable or on the object files. All symbols labelled `B`, `C`, or `D` are global variables. Symbols labelled `b` or `d` are static variables that aren't global. The symbol name is more or less directly the identifier in the program.
The key is to do a constructive critique and to accept criticism as much as you give it away. You have to establish an environment in which it is seen as a positive thing to find bugs or improvements in your coworkers code. 
Indeed!
Oh man do I feel your pain. Although not that junior, I’m inheriting a massive codebase from my boss, who’s retiring. I’ve been working in the codebase for 8 years; my boss is the original architect, but definitely qualifies as an expert beginner. There are some tactics that can help in this situation. 1. Start/keep talking about the code. If it’s about the code, its performance, its structure and maintainability, folks will take it less personally. 2. Readability is a collaboration. You have to establish a collaborative space, before you can talk about it, and it always ends up being a compromise. 3. Coding style, while related to readability, is easy to measure and fix with the right tools, you just have to agree on a style first. You can even add a repo check-in hook to detect bad style, reject or even fix the submitted source files. 4. Better code is a longer road, but you can lead by example. If you have formal reviews, that’s great, but you can also mention refactoring, when you talk about the code. Be sure to talk about shared common design patterns, and why they’re good, for maintainability and proper function. There are best practices out there, to be used at design time, because they perform best.
Thanks! very useful
Agree
I work with a brilliant C guy. Sometime they go off the rails. He has more macros than code; and believes in hungarian notation. Nice thought but... 
He passes with global?? I have no idea why he would prefer to use global 
CodeLite is cool and light weight IDE 
OP can't "make" his co-worker do anything. Dropping a programming book on him, literally or figuratively, will go over like a ton of bricks and lead to instant bad blood. It's tantamount to saying "go back to school and learn how to program, dick," which may be true but it's a terrible way to start a conversation.
&gt; I love programming but I hate writing comments or documentation or tests. I have to force myself to do so. At some point you'll be changing some deep code with tons of dependencies and realize "holy shit I have no idea if I'm about to break everything." Quite possibly, it will be code someone else wrote. You won't be sure if you're handling all the cases properly. That's when you'll develop a new appreciation for tests.
A few of our teams don't have these problems. We align our goals with company goals and try to make each other better. Other teams at our company aren't that way or aren't given the chance to work that way yet.
Don't just go over someone and talk to the manager without talking to the guilty party in question first.
Talk to this guy use logical arguments and actual solid feedback with real examples and better alternatives. Sit down and talk with him. Don't just go to your manager and complain. Give the guy a chance to explain himself. If he is an ass who refuses to change when you were 1.) Polite 2.) Empathetic / sympathetic 3.) Logical explaining why your way is better with concrete evidence. then you go to the manager. 
Do a small project in C and read some source code.
I've been in this situation a few times and the key here is to assert your dominance as the alpha programmer. Last time this happened I whipped out my dick and started swinging it around. In self defence the beta programmer tried to do the same but quickly got intimidated by my girth and scampered off. After urinating on his computer equipment to mark my territory it really sealed the deal and he hasn't questioned my programming methods since.
Dunno how good is your level, but that "Modern C" by Jens G. (check the sidebar!) might be what you're looking for. Being said that, just search for the following keywords in your fav search engine: "awesome, c, projects, list, github". Good luck!
burn it with fire.
I recommend reading 21th Century C. Skips most theory and gets you up to speed on the modern parts of the language (while also refreshing what you know)
&gt;After urinating on his computer equipment to mark my territory Beware the urine is a conductor
Which language do you use? The C programming language isn't object oriented and doesn't have classes.
Sorry C++
Nice! I now write some teats to ensure it works the way you want it to.
In fact C++ classes are implemented as C structs. You can even access C++ classes as structs in C with some care.
\+1
I said what he should do, not how to. 
In C++ the only difference between a struct and a class is that the default access in a struct is `public`, while the default access of a class is `private`. Otherwise there is no difference.
I agree. The software works, right? Maybe it has style problems and is subjectively harder to maintain, but it's here and it's working. Everyone codes things differently, some closer to common ideals, some further away from it. There's nothing in life, even in extreme circumstances, where you can come along and tell someone that they should be doing things your way because it's better and expect a great reaction, an immediate change. Look at how hard it is to hold an intervention for a raging addict. You can try to find data, though. Maybe you can find a way to indicate that maintenance is really a problem, or you can solidly post-mortem bugs and failures on the design problems. Performance is often a good way to do this -- convoluted systems often waste performance on layers of convolution. Data will be more convincing than opinion. My current project has a bit more than a million lines of code. There are no comments; there are less as I go along because I'm deleting code that's commented out (!) instead of being plain old deleted. I add useful English comments as I go, but that's never at the line-for-line rate at which I delete commented-out code. So I hope it's clear I'm not defending your co-worker. My point is that it just doesn't work out, expecting everyone to do things the way you want to do them (even if what you're suggesting is better). 
If the OP goes this route, he should be sure that only technical issues are raised, in a very impersonal way. Rather than say "His code is..." or "His functions are...", he could say "This code is..." or "These functions are.." The OP could also point out the maintainability issues of global variables. By keeping the discussion on technical merits, it will help him look professional and help minimize defensiveness. There are good online resources for good code review techniques like I've discussed. 
Grin and bear it. Read it, run the code through a debugger, document it, read the commit log, and ask the coder what their intention is if it's not clear. Then slowly refactor it over time piece by piece. Know that this is a thankless job and there will be risks. Most coders I know avoid touching code like this because it's just not worth the headache.
&gt;In fact C++ classes are implemented as C structs Was true for the very first C++ compiler (cfront), which translated C++ to C, but has not been true for decades now.
That's more the manager's job than OP's duty.
*Personally* I think your approach to closures is the most sensible. It's also very similar to what was used by [POC](http://users.telenet.be/stes/compiler.html) for its closures ("blocks"). There is another very different way of doing closures, which is to use setjmp/longjmp to replace to entire call stack. In effect, you end up implementation closures via [continuations](https://en.wikipedia.org/wiki/Continuation). This has the benefit of simplify things if you have a lot of variables bound by the continuation (even variables bound in different stack frames, if you need to consider nested scopes). The obvious downside is, well, you're replacing the entire call stack, which can be expensive (see: why do so many C++ programmers avoid using exceptions).
Donate some of his exhibits to the museum of /r/badcode
Exactly! Good points!
I liked this book a lot. My only warning is that the C11 embedded struct stuff isn't correct (at least as of now). C11 only supports anonymous structs and unions, but the book says it is similar to Plan9 extensions, which is not correct.
For a quick refresher, you might find this useful - https://goalkicker.com/CBook/. It's a curated book of materials collated from various source, primarily C. I haven't used this book, but just skimmed through, and it looks good enough to act as a refresher. After that, you can simply do a few small hobby projects to get up to speed, and then you can maybe find out some interesting real-world projects to contribute to/create on your own. If you're interested in compilers, you might find this project fun - https://github.com/rui314/8cc. 
From the C side however a structure doesn't have associated methods so no default constructor or destructor. The scoping with **private** and **public** inner structures won't really hide anything in C if the structure definition is in a header file and included in source files, so those would have to be *gentlemen's agreement* definitions. I find it amusing that you're trying to make C look like C++ while much of the code I've written made C++ look like C with classes. Constructors, destructors and function overloads are nice to have.
And to add to your comment: it is often useful not to state criticism in the form *this and that is wrong* but rather *this and that could be better if we did it like so and so.* This way, you avoid that whole “why did you do it wrong?” question and move the discourse towards improving the quality of the code without making anybody get defensive about their own programming style.
Thanks a lot for pointing me towards continuations. Didn't even know such things were possible that easily with setjmp/longjmp and it also cleared up a lot of things for me. Very interesting topic.
Great point
You can't access C++ classes as C structs unless they meet certain requirements 
Yes, they aren't implemented in C++ (the standard) as structs. *Of course, most compilers implement them in some struct-like fashion, and with enough hops you always can view anything as a struct*
^ This is how I ride a bike
A bit OT: Types starting with '`_`' are reserved by the C standard, *types ending on '`_t`' are reserved by POSIX*, if you care for that. Also note that an empty parameter list in a function declaration as part of a implementation block (ie. `int main() {}`) specifies that this function does not take any arguments, *however* it does not constitute a prototype. This means that you can write `main(5);` and the compiler must allow it, even though it's UD on runtime (actually, if the compiler could determine it to be UD in any case, then it's allowed to not compile).
Another resource: [How to C (as of 2016)](https://matt.sh/howto-c)
I'm on mobile, I'll elaborate on this when I get home. One starting point would be something like a hash table. If you could come up with a way to have any hashed sub-string point to the words that contain the sub-string. Maybe create a "sub-strings" hash table. Then when a new word is added to the search engine it is parsed and every sub string is hashed and added to this "sub-strings" hash table. Then each entry would contain a list of all the words that contain that sub string. 
The best way to do this would be to assign each name a score (maybe using a `double` from 0.0 = 1.0 or something), you can add "points" for criteria that each name fulfills for example: `name` = the string the user is searching for `item` = the current item we are checking against name 1. `+0.01` for each character of `name` is found in the string 2. `+0.1` if all the characters are next to each other 3. `+0.2` if all the characters are in the same order 4. `+0.05` if the characters begin at the start of `item` or end at the end of `item` And then sort by the score. This was just a rough example, in practice you probably don't want to use constant numbers, instead weight them (e.g `1.` could become `+(0.1/(double)strlen(name))`, so the shorter the string the more it matters if a single character appears)
This is more of an algorithms question. See if you can adapt one of the [substring index](https://en.wikipedia.org/wiki/Substring_index) data structures.
Thanks for clearing this up, didnt know that types ending on '\_t' were also reserved.
learnbchs.org write code in ansi C89. K&amp;R second edition is good. unless youre writing desktop applications or video game do not code in C99 or C11 (those are useless for most things of interest because they are not portable between architectures and embedded systems). 
levenshtein distance
I can't see a problem with it. All my names are consistent and are easy to read with my very minimalistic color theme.
Look into levenshtein or jaro-winkler distances. They might help you with what you’re trying to achieve
Is there a good source for learning hash tables?
To get you started https://www.hackerearth.com/practice/data-structures/hash-tables/basics-of-hash-tables/tutorial/
Definitely the answer I’d go for unless fuzzy matching is important
Are you actually comparing names? Or is this a general keyword based search? &amp;nbsp; To put it lightly, fuzzy matching of strings is a complicated topic. Something that would work well is using the [Jaro-Winkler distance](https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance) or [Damerau-Levenshtein distance](https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance) between the incoming (search) string, and the stored strings. You then print as a match any string that meets or exceeds your desired metric. For instance if using the Jaro-Winkler metric you'd say, print only strings with a distance of 0.80 or greater; or with Damerau-Levenshtein you'd pick strings with a distance of 2 or less. The [Levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance) is also an option for fuzzy string matching, however it does not account for transposition errors. That is, when comparing "Thompson" and "Thopmson" (a simple transposition error), the Damerau-Levenshtein distrance indicates the difference between the strings is 1, while the 'straight' Levenshtein distance indicates a difference of 2. &amp;nbsp; In the case of actually searching names, might I recommend the [Western Airlines Match Rating Approach](https://en.wikipedia.org/wiki/Match_rating_approach)? Although this algorithm does allow for many false positives, as Western Airlines used associated information to help get a precise match. An alternative approach which still accounts for similar sounding names spelled differently (e.g. "Kathrine" or "Catherine" or "Kathryn", similarly "Stephenson" or "Stevenson", et cetera) is to use a phonetic algorithm, such as [Soundex](https://en.wikipedia.org/wiki/Soundex), [NYSIIS](https://en.wikipedia.org/wiki/New_York_State_Identification_and_Intelligence_System), [*Kölner Phonetik*](https://en.wikipedia.org/wiki/Cologne_phonetics), or [Daitch–Mokotoff Soundex](https://en.wikipedia.org/wiki/Daitch%E2%80%93Mokotoff_Soundex) (among the many options). And then using one of the string metrics from the first half (Levenshtein, Jaro, Damerau-Levenshtein, or Jaro-Winkler) to compare the outputs and selecting close matches.
pre-trained [word2vec](https://github.com/facebookresearch/fastText/blob/master/pretrained-vectors.md)
Your hash function (`ht_hash()`) could be a lot better — faster *and* better quality — without much work. The main issue is that each mixing operation is computed modulo the number of buckets. You're missing out on a lot of diffusion potential by throwing away so much of the hash state on each step, especially when the number of buckets is small. So the hash result is really poor for no benefit. Don't truncate the hash to the number of buckets until the very end. Not only is the modulo reducing your hash quality, it's making it slower. Division is slow, and you're doing a division by a run-time value on every byte of input. A third issue is that if the number of buckets is large, you're risking signed integer overflow, which is undefined behavior. Compute hashes with unsigned integers. Ultimately your hash function is just not well designed. You've essentially got a FNV-style hash function, and these aren't all that good, *especially* with a small multiplication constant and a small modulus. The main issue with this hash construction is that multiplication diffuses bits leftward, but there's no operation to diffuse bits rightward. The high bits will be highly correlated. Instead, you could just grab a better hash function from somewhere. The Wikipedia article for [MurmurHash](https://en.wikipedia.org/wiki/MurmurHash) includes C source code ready to drop into place (though it's a little dubious about alignment). It's a *keyed* hash function, which helps defend against certain kinds of denial of service attacks (hard for attacker to choose pathological inputs that always collide when they don't know the key). Or here's one of my own design. It uses the highly-effective xorshift-multiply design, just like MurmurHash. The xorshift (`x ^= x &gt;&gt; N`) provides the rightward diffusion I said was missing from FNV-style hashes. I chose the specific constants [through brute force experimentation](https://nullprogram.com/blog/2018/07/31/): uint32_t hash32s(const void *s, size_t len, uint32_t key) { uint32_t hash = key; const unsigned char *p = s; for (size_t i = 0; i &lt; len; i++) { hash += p[i]; hash ^= hash &gt;&gt; 16; hash *= UINT32_C(0x7feb352d); } hash ^= hash &gt;&gt; 15; hash *= UINT32_C(0x846ca68b); hash ^= hash &gt;&gt; 16; return hash + key; } I hereby dedicate this function to the public domain. 
Note that I mentioned structs are mostly the same as a C++ class, not struct are the same as a C++ class.
Thanks for the reply - All on one machine. Posix message queues are looking promising
&gt; levenshtein distance At least as described, I don't think this is what OP wants. I think if the search query is the word X, OP wants to find anything that matches x^1 .* x^2 .* ... .* x^n where x^i are the successive characters in X and .* is any string. Notice his query did not return "Sam" even though it's only one away via levenshtein distance.
Passing everything as globals... Either he is writing world class HPC code, or he is writing a disaster.
You have two problems, I think, and I would solve them in separate stages. First I would write a routine that takes each letter in an input string and sets a corresponding bit into an integer, something like this: unsigned long transform( char* input ) { unsigned long return = 0; for(int i=0; i&lt;strlen(input); i++) { char ch = input[i]; if(ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') return |= 1 &lt;&lt; (ch - 'A'); else if(ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') return |= 1 &lt;&lt; (ch - 'a'); } return transform; } Then you can see whether a word contains all of the search term letters very easily: if(transform(word) &amp; transform(search) == transform(search)) //match! Then first display show all the ones with strstr(word, search) != NULL;
Nope, we're not helping anyone write malware.
7.0 is coming out in days to week, they're already on the second RC and talking about the third on the mailing list.
Check the return value of malloc!
C's native integer types are not any specific size and they vary between platforms. Instead they have a minimum range of values they can represent. TYPE MINIMUM MAXIMUM signed char -127 +127 (at least 8 bits) unsigned char 0 255 signed short -32767 +32767 (at least 16 bits) unsigned short 0 65535 signed int -32767 +32767 (at least 16 bits) unsigned int 0 +65535 signed long -2147483647 +2147483647 (at least 32 bits) unsigned long 0 +4294967295 signed long long -9223372036854775807 +9223372036854775807 (at least 64 bits) unsigned long long 0 +18446744073709551616 (Note how the lower range for signed integers is one less than you would expect from two's compliment. This is because signed integers are not even necessarily two's compliment, though you would be *very* hard pressed to find a implementation that doesn't use two's compliment.) An `int` could be as small at 16 bits, though in practice this will only be the case on 16-bit systems. A `long` is at least 32 bits, though it's common for it to be 64 bits on 64-bit systems (Windows excepted). To make matters more complicated, each of these could be bizarre sizes, like 20-bit `int` or 40-bit `long` — though, just like the two's compliment thing, you'd be hard pressed to find a single instance of this in practice. If you truly want to work with *exactly* 32-bit integers, C99 has a solution for you: `stdint.h`. It defines (among others) the types `int8_t`/`uint8_t`, though `int64_t`/`uint64_t`. It also defines macros `INT8_C`/`UINT8_C` through `INT64_C`/UINT64_C` for specifying literals with an exact width. These macros just append the appropriate type suffix (`U`, `UL`, `L`, `UL, `LL`, `ULL`. Technically speaking, all the fixed-width types are optional (though, again, you'd be hard-pressed to find an implementation where they're missing). Very few programs *actually* need exact-width types like this. Those programs are mostly in the realm of cryptography where lots of operations are performed to a specific modulo power of two. My hash function is one of those cases. To get the correct result, each multiplication must be truncated by modulo 2^32, so I use 32-bit integers. So when you see this: hash *= UINT32_C(0x846ca68b); I'm multiplying `hash`, a 32-bit unsigned integer, *specifically* by a 32-bit unsigned constant rather than allow the implementation to choose the type where it fits. On a 32-bit system (32-bit `int`) the macro expands like so: hash *= 0x846ca68bU; And on a 16-bit system (16-bit `int`, 32-bit `long`) it would expand to this: hash *= 0x846ca68bUL; My use of `UINT32_C()` is probably overkill since `0x846ca68bU` should work correctly everywhere. In theory I could eschew fixed-width types so that it will work even on platforms where they're not supported: unsigned long hash; /* ... */ hash = (hash * 0x846ca68bUL) &amp; 0xffffffffUL; This will get the same answer, but I've found that neither GCC nor Clang compiles this to equally efficient code as when I use `uint32_t` explicitly. Some operations will be 64 bits despite the result being immediately truncated to 32. It's also harder to read. (Side note: As I wrote this I realized there's a pathological case. What if a `short` is 32 bits and an `int` is 40 bits? Any `uint32_t` operation will actually be performed with signed 40-bit values (via promotion to `int`), resulting in signed overflow for my hash function. Right?) 
That's correct, however if you turn the statement around it would be true: the standard does define structs as being a specific type of class. From C++98: "A structure is a class defined with the class-key struct" 
POD types can be safely accessed with care. Other types may work in specific circumstances, but that would be a matter of good fortune rather than anything guaranteed by the language.
Well yeah, but that's a different issue altogether, what you are comparing are C++ structs with C++ classes and not, as here done, C structs with C++ classes. C++ structs are different from C structs, they're just C++ classes with everything public.
Not really an answer to your question, but you might also want to check out an event queue like [libevent](http://libevent.org/) or [libuv](https://github.com/libuv/libuv).
You are moral development. I like that. Everybody have right to sercurity your information.
Indeed, so the hierarchy is: C++ classes &gt; C++ structs &gt; C++ POD-type structs and C++ POD-type structs are to a good approximation the same as C structs. To the best of my knowledge this relationship is not stated explicitly in current versions of the standard, however it was expressly acknowledged in older ones. From the ARM: "Thus the C++ class concept can be seen as a generalisation of the C notion of a structure or - looking at it the other way - the C concept of a structure is a simple variant of the C++ class concept."
Thanks, skeeto! I found your blog last week and I've greatly enjoyed reading it.
&gt;uint32\_thash32s(const void \*s, size\_t len, uint32\_t key) If I read this correctly, you use the `void *s, size_t len` to support any kind of key right? But what is the purpose in this case for the `uint32_t key`?
It was unnecessary verbiage, but nothing has changed since to invalidate the generalisation/variant relationship. On the contrary, it has been formalised through the concept of a POD type. It was the sentence later in that paragraph, about using C structs to access C++ classes containing C++ language features, which had to go as a result of allowing the implementation flexibility you describe.
&gt; to support any kind of key right? Yup, exactly. The hash function operates strictly on opaque bytes and *really* doesn't care about the type. &gt; Is it to make it like you said a keyed hash? Yup. To take full advantage of it, the key should be some unpredictable run-time value (/dev/urandom, etc.). If you're not worried about a DoS attack, using a constant like 0 is perfectly fine. (Though note that an all-zero input with a zero key hashes to zero.) 
If there's no mention in the standard of how C structs map to C++ POD classes/structs then there's no formal relation.
Hey cool! Thanks for spelling it out for me!
A program that takes text as input and outputs it all lower-case
No it didn't happen by accident for sure, it's for historical reasons at least, cfront compiled C++ to C.
Oh fun! He could try a customer database system too. Learn file access, structs, etc.
A simulated network would be interesting. Passing "packets" around and simulating different errors on the links (drop rates, corruption, etc)
Write an SS7 simulator and a client. 
Create your own simulated SMS service center and simulate sending messages between them.
Is there a specific reason you want to do this? Usually when I end up converting a while loop to a do while loop it's because I realize "I should probably execute this section of code at least once", ctrl + x my `while(...)` section, type `do` and then paste my while section after my curly brace. If the reason you are doing this is because you want to get the assembly code optimization, you might as well program in assembly.
&gt;Is there a specific reason you want to do this? to do what? macro or return value? Since I need multiple statements in macro, I used do/while(0) here. I think this is common way to this. The reason to using macro is create a TEMPLATE for int/float/double... because it is same code and I do not want to duplicate it manually. I'll announce this library later but you can see macros here: [https://github.com/recp/ds/blob/master/src/sort/sort\_common.h](https://github.com/recp/ds/blob/master/src/sort/sort_common.h) calling macros: [https://github.com/recp/ds/blob/master/src/sort/sort.c](https://github.com/recp/ds/blob/master/src/sort/sort.c) partition macro needs to return a value to its caller. 
Do/while(0) is a common idiom for macros. Defines scope for the code in the macro, and allows extra semicolons at the end to make it look like a statement/function.
This is only for windows? That's such a shame, it would have been great to try this out for linux.
Uses LCC compiler, a pretty mature compiler that targeted windows from the start, supports the full C standard, and has a free for non-commercial use licence.
You can have multiple statements in a macro without a do/while... all a macro does is paste that code in-place for where it's used during pre-processing. Then the compiler compiles it. The only reason do/while is a common macro idiom is because of what /u/james41235 says. You're not bound to that idiom. Do what makes sense for what you're wanting to do.
Depending on how simple the macro is, you could possibly use the `,` operator. But the current way you're doing it is absolutely fine. I might suggest doing something like capitalizing the name of the macro so that someone reading your code understands that `result` may be changed without having to read the macro itself.
There are local variables in macro so I must use do/while or scope block, because local variables in macro may conflict with variables in caller. I prefer to use do/while if there is no need to use **break/continue** keywords in macro &amp;#x200B;
You can add scope without a do/while... you can also make any local variables in the macro very uniquely named using the paste portion of macros...
Thanks for sharing that!
Yes this is my main problem, no one can understand where the \`result is set without reading macro :( This is why I desired to return a value from macro. It seems changing name of macro is good idea.
&gt;you can also make any local variables in the macro very uniquely named using the paste portion of macros... I'm sorry, I couldn't understand how to do that, can you give a very simple example if you have a time, please? What do you mean with "using the paste portion of macros" ? Since macro has its own scope after used do/while or scope/compound block, maybe making variable names unique is not a problem? I only concerned about output variables. Making them uppercase or append \_OUT or something like that could help to not re-define output variables in macro, I guess.
Any advantages over something like mingw?
Look up what # and ## do in the context of macros.
There are two open source PBXs written in C - [Asterisk](https://www.asterisk.org/) and [FreeSwitch](https://freeswitch.com/). You could write a plug-in, add a feature or close some bugs. You also use either one as the basis for your own project. 
I don't have a lot of experience using C on windows but I think there's more compatibility with libraries created in visual studio. It's nice that it comes as a package with an IDE. And again more of the C language than the subset that you get from visual studio's C++ compiler.
The book *"The Linux Programming Interface"* answers many of those questions. If I remember correctly pthreads are implemented by clone() syscall in linux. http://man7.org/linux/man-pages/man2/clone.2.html Found it: http://man7.org/linux/man-pages/man7/pthreads.7.html here go to 'Linux implementations of Posix threads'. If you like to learn about this kinds of stuff I can only *highly recommend* the already mentioned book.
How exactly it works depends on the operating system. On Linux threads are created [using the clone(2) system call](https://nullprogram.com/blog/2015/05/15/).
I use an old HP EliteBook with 8gb of ram. I've never had any problems even with resource heavy virtualization. But I'm also running xubuntu
[Here is a link to](https://github.com/ldx/winpthreads) the winpthreads library used in mingw-w64 . 
I thought that would be the case. I just didn't know if something similar existed with Linux, which prompted me to ask this question. Given the nature of Linux and windows, I should have already guessed that this is how pthreads worked on those platforms. Thanks for the responses.
Dude, when I'm debugging my code (which takes up multiple times more ram than just running it) it takes up like 5MB of code... You are absolutely not going to be able to use up all your ram.
College doesn't mean you write big projects or gonna teach you really much about programming, you learn that in industry. College is for theoretical basics, yes, you will code but not a game or something that will eat you RAM. If you choose to study subjects around data mining you might need more but usually you are then even provided with a server to work on. You can edit, compile and run C even on a bad android smartphone. Any PC should be good enough for that. Sure, Visual Studio has the habit of eating RAM but you don't need an IDE anyway.
Mutex is implemented with [futex](http://man7.org/linux/man-pages/man2/futex.2.html), again a linux-specific system call.
This subreddit is about the C programming language, not about buying laptops. Please post this in /r/suggestalaptop instead.
https://github.com/ocornut/imgui/blob/7adac4ab3e42950e45c34a1bc2237b2763c25c41/imconfig.h#L20-L22
Ah, ok, so it's there to allow the `__declspec()` declaration in its place. That makes sense! Thanks!
&gt; Ah, ok, so it's there to allow the __declspec() declaration in its place. ... or whatever you need for the target platform. That `__declspec` is just a suggestion.
My suggestion is to choose a set of *system calls* which have dedicated opcodes. Then you can implement everything else on top of these system calls. I suggest implementation `open()`, `close()`, `read()`, `write()`, `seek()`, and `exit()` at first; these should be enough for very simple programs. Note that I suggest `open()`, not `fopen()` as you can implement buffered IO in your VM language. 
The name "pthread" comes from POSIX thread. POSIX is an API that all (most) unixes implement. Windows is not POSIX compliant. It has it's own different API calls for just about everything.
One useful feature that's missing is optional arguments. For short options these arguments are appended to the option, and for long options they're joined with a `=`. For example: # Long form $ ls --color # default to 'always' $ ls --color=auto # supply optional argument # Short form $ foo -c # default to 'always' $ foo -cauto # supply optional argument 
[Unity](http://www.throwtheswitch.org/unity) is semi popular and very simple. It's the default for [platform.io](http://docs.platformio.org/en/latest/plus/unit-testing.html).
Some feedback: - Why does `LS\_VECTOR\_ENSURE` call realloc in a loop? `LS\_VECTOR\_ENSURE` looks perfectly fine to me. - `LS\_VECTOR\_SHRINK\` doesn't have to oom on realloc failure. - The choice of 2 as a growth factor is debatable.
I only took a quick glence at the sample application but I already like it considering the alternative I've been used to is argp. I wouldn't even care if this is just a wrapper over argp.
&gt;Why does LS\_VECTOR\_ENSURE call realloc in a loop? LS\_VECTOR\_ENSURE looks perfectly fine to me. Eh, did you mean `LS_VECTOR_RESERVE` in the last sentence? Suppose you have `LS_VECTOR_OF(Foo) vec`. You also have a function like `void get_1000_foos(Foo *buf);`. So you do for (int i = 0; i &lt; n; ++i) { LS_VECTOR_ENSURE(vec, vec.size + 1000); get_1000_foos(vec.data + vec.size); vec.size += 1000; } If you used `LS_VECTOR_RESERVE` here, it would be O(n^(2)). &amp;#x200B; \&gt; \`LS\_VECTOR\_SHRINK\` doesn't have to oom on realloc failure. &amp;#x200B; Is failure on shrinking \`realloc\` really possible? &amp;#x200B; \&gt; The choice of 2 as a growth factor is debatable. &amp;#x200B; It can be adjusted to whatever you what.
&gt; Eh, did you mean `LS_VECTOR_RESERVE` in the last sentence? Yes, sorry, my bad. Anyways, my point is that you should not call realloc in a loop. The above code is weird, as is `ENSURE`. Why don't you make `RESERVE` overallocate to the next power of two? That would be simpler and faster, I think. &gt; Is failure on shrinking `realloc` really possible? Well, if one shrinks to size zero, `realloc` is allowed to return `NULL`, isn't it?
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [v7unix/v7unix/.../**stdio** (master → ed636a4)](https://github.com/v7unix/v7unix/tree/ed636a47207476db76d53b7869447889dee3bbad/v7/usr/src/libc/stdio) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e4xjinc.)
&gt; The above code is weird Well… I use something like this to read a file: ```` LS_VECTOR_OF(char) buf = LS_VECTOR_NEW(); while (1) { LS_VECTOR_ENSURE(buf, buf.size + 1); ssize_t r = read(fd, buf.data + buf.size, buf.capacity - buf.size); if (r &lt; 0) { // handle error } else if (r == 0) { break; } else { buf.size += r; } } ``` &gt; Why don't you make RESERVE overallocate to the next power of two? Because RESERVE is for situations when you know how much space you need exactly. &gt; That would be simpler and faster, I think. In terms of code, no, it would not be simpler. &gt; Well, if one shrinks to size zero, realloc is allowed to return NULL, isn't it? Oh, this situation is handled: https://github.com/shdown/luastatus/blob/master/libls/alloc_utils.h#L76
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [shdown/luastatus/.../**alloc_utils.h#L76** (master → 1e0019e)](https://github.com/shdown/luastatus/blob/1e0019ecccae640e990a186df400fa39d5b7afce/libls/alloc_utils.h#L76) ---- 
* &gt;1000 lines * has like 30 API functions * uses dynamic allocation Why would i want to use this? I can write a perfectly fine arg parser in 50 lines that can accept all 3 styles of options (short, long, UNIX style: multiple short options in the same cli arg) + an optional arg. It's really not rocket science, folks.
Looks like it'll be pretty useful. Thanks a bunch!
&gt; Well… I use something like this to read a file (size of which is not known in advance): Interesting. I usually do things the other way round: ``` LS_VECTOR_OF(char) vec = LS_VECTOR_NEW(42); while (1) { static char buf[16384]; ssize_t r = read(fd, buf, sizeof(buf)); if (r &lt; 0) { // handle error } else if (r == 0) { break; } else { // parse buffer APPEND(vec, buf, 16384); // basically reserve + memcpy // loop parse + append if needed. } } ```
Yak shaving at it's finest. I can't figure out why the standard never added a countof() operator.
Criterion :)
So, your code does an extra copy of the data read.
Further on this topic: https://stackoverflow.com/questions/19452971/array-size-macro-that-rejects-pointers/ https://stackoverflow.com/questions/29924710/c-find-static-array-size-preventing-mistakes 
thats stupid. why would you exclude your code from being useful to people on most platforms by coding in immature unsupported standards like c99? just use javascript if you want to be a hipster. 
I used two libraries to do exactly this task. [libzip](https://libzip.org) and libxml2. Basically once you open the zip file you can use zip_fread and read into some buffer then pass that buffer to xmlParseChunk to build up the xml file context. I don't know if you can use just libxml2. The libzip library is really good. 
Im very aware of libzip, however I want to avoid using it if I can to reduce the number of libraries I use, that and I found some trouble with it on mingw among some other tidbits.
I agree there seems to be no documentation about this I could find. Here is a header that might be useful: https://github.com/GNOME/libxml2/blob/master/xzlib.h.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [GNOME/libxml2/.../**xzlib.h** (master → 33d7ca5)](https://github.com/GNOME/libxml2/blob/33d7ca53af11b751fc7be7cc22d2d2aafae9163f/xzlib.h) ---- 
I’m no C expert, but this article seems to be very informative. Short and concise, at the very least.
`zlib` is not for ZIP files, it's for `gzip`, which is a different format (they use the same compression method internally (DEFLATE), but that's irrelevant here), and `libxml2`'s support for this is to open gzipped XML files (`.xml.gz`).
Yes, but in my case I have to delete some data from the input. So I have to do the extra copy anyways.
&gt;With all due respect, ironically I think that the C89 purists are the ones who are considered hipsters nowadays. this might sound like a good argument to a casual observer, but then you said this shit right here: Also I have no idea why you call Javascript hipster either considering that it's one of the top 3 most desired programming job openings. Your understanding of what constitutes hipsterdom seems to be misguided. dont argue with your elders kid. you are embarrassing yourself. &gt;C99 when you can, C89 when you must is the standard adhered to by the majority of serious modern C programmers today. very stupid argument. you do realize that appealing to herd mentality like a sheep is not a good strategy among educated people right? right? &gt;To be honest, I think that insisting upon the lack of bools, fixed-width types, or internal for loop variable declarations is pretty hipster, and also totally unnecessary when better options are available. C as a language is unnecessary when better options are available. when they are not available C89 is the only thing worth a shit. if C89 is too low level get the fuck away from C and use a hipster language like javascript. 
I see, thank you so much for this!
You keep using that word, I do not think it means what you think it means. 
because it's masturbatory coding... please clap
That's fine, too may modern C developers disagree with you so I guess we can both take our disagreements in stride and be on our merry ways. 
there you go appealing to herd mentality like a sheep again. the people who fucking matter agree with me and disagree with you. 
Good point.
Only knew about this today. This sucks. We haven't learned anything about arrays but now we are given this kind of problems. Im sorry if this sounds like I'm lazy. I'm just confused right now.
What are you confused about with 11-13? Seems fairly straight forward.
i mean how should i put it? N[left]=N[left-1]??
Well, industry standards and best practice are a thing that you might want to care about. There's a difference between "heard mentality" and common practice. Also, calm down bro, no need to get that worked up about this. 
http://man7.org/linux/man-pages/man2/mmap.2.html
Yeah I've read all of that. Incomprehensible to me. I'm looking for sort of a "layman's" description. 
I don’t remember which header defines `EXTERN_C` but it’s likely coming from `windows.h`. Have you included that before `shellapi.h`?
Yeah but see I requested pseudocode. I have already done much googling and am interested in what I'd call an "expert interpretation." 
This is a very C like program, there isn't really any useful pseudocode for this without understanding what the mapping is doing. I'll give it a shot though. mem = open "/dev/mem" cfg = openMemoryPages mem, 0x40000000, 1 ram = openMemoryPages mem, 0x1E000000, 1024 // reset writer unsetUIntBit cfg, 0, 4 setUIntBit cfg, 0, 4 // reset fifo and filters unsetUIntBit cfg, 0, 1 setUIntBit cfg, 0, 1 wait 1 // enter reset mode for packetizer unsetUIntBit cfg, 0, 2 // set number of samples setUInt cfg, 4, 1024 * 1024 - 1 // enter normal mode setUIntBit cfg, 0, 2 for i = 0 .. 1024 * 1024 printShort ram, 4*i printShort ram, 4*i+2 end closeMemoryPages cfg closeMemoryPages ram 
Many peripherals communicate with the computer by reading/writing to a shared block of physical memory. The memory mapping is pulling that shared physical block into the app's virtual memory space, where the app can then control the hardware. No one here can tell you what the code is doing. This is entirely dependent on whatever custom peripheral happens to be connected to your computer. You need to find the manual for your hardware and find out how it's using those 0x40000000 and 0x1E000000 pages. There is probably a specification somewhere written by whoever designed the hardware. If you're lucky, the spec is detailed and well-written. Based on the comments, it looks like it's reading a 1024*1024 "samples" of some data from some peripheral. The rest of the stuff is probably how you trigger the peripheral to send the data. But again, without knowing the hardware spec, it's impossible to know for sure.
The thing puts some stuff into a place.
Hardware support for bounds checking sounds awesome!
Optional option-arguments are [discouraged by posix](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html#tag_12_02) though.
Thank you for the attempt. Looking for something a little bit more interpretive, though, if possible? 
You guys are such douchebags. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [pavel-demin/red-pitaya-notes/.../**adc_recorder** (master → 78b3e9d)](https://github.com/pavel-demin/red-pitaya-notes/tree/78b3e9db562db2a21b91dcb854bcec036aebbc51/projects/adc_recorder) ---- 
Not sure how much simpler I can get... # reset writer unsetMemUintBit 0x40000000 4 setMemUintBit 0x40000000 4 # reset fifo and filters unsetMemUintBit 0x40000000 1 setMemUintBit 0x40000000 1 wait 1 # enter reset mode for packetizer unsetMemUintBit 0x40000000 2 # set number of samples setMemUint 0x40000004 1MB-1 # enter normal mode setMemUintBit 0x40000000 2 wait 1 printShortsAt 0x1E000000 1MB If you are asking what it does, well I have no idea. I don't know what program it is accessing or why. The comments mention a packetizer, so it could be reading data from packets, or finding out what data was written to some packets, or reading the state of the thing that is doing something with packets, but that is only a guess.
I actually sort of know what it does, what I'm looking to understand better are the commands themselves. Like, for example - forgetting what the purpose is - what does the command *((uint32_t *)(cfg + 0)) &amp;= ~4; Actually *do*? 
For future reference, use this time as a learning experience of how not to ask for help on the internet. To get good help, show that you've put time and effort into understanding it. Break down into pseudocode what you do understand and show signs of research where you don't understand. To understand deeper levels of code it takes time and practice, something you can't get for free. Something else you want to do is not reject the help you do get by insulting people. If you don't know C very well, what language do you know? Give us/me something to work with so we know how to frame our answers to your context so you'll understand it. From just the initial question it would appear to me that you work mostly with languages that do this stuff in the background, java/js/python would be my guess. Bottom line; If we don't know what you already know, how can we help you without sounding condescending?
Well, if you don't want to sound condescending, you can start by trying to not fucking sound condescending. Yes I'm a plebeian python user. My impression of how to ask for help on the internet is - don't. 
That is true. It does nothing.
Huh. Any ideas as to why he put it there then? 
Just take it line by line. Assign one of the three variables to a register as they're needed. At some point you're going to run out of registers (you only have two, but there are three variables), so decide which variable isn't needed anymore and reuse that register.
Sorry dude, we just tend to assume a certain degree of base knowledge about how computers work. Stuff that's relevant to way more things than just C. Also, I'm fine with new people asking base questions, and I'm sure most people here are too, but there's kind of a vibe that you're not really interested in learning new things. Plus, understanding memory mapping, even to a general degree requires understanding memory, which is a big, general topic that there's already exhaustive coverage of that nobody particularly cares to replicate. The fact is, mapping is a technical concept and layman's terms lack the ability to describe it in any way that's interesting or likely relevant to you. So, even if you only want the gist of what this code does, you're kinda gonna have to read up.
That makes sense. 
I didn't call you a python pleb. The entire point of that paragraph was tell me what you know and don't bite the hand you're trying to get to feed you...
Huh. Well I sure as shit can't find any documentation like that in what I'm working on. Annoying. 
Stop with the self deprecating nature or it will become a self fulfilling prophecy. No one here is calling you stupid. You're only as stupid as you think you are.
Check to see if there's a support forum. These hardware interfaces can be complicated, although this one doesn't look too terrible. But they can seem weird and arbitrary, especially if you're not a hardware whiz. 
Okay, so a few things to help you understand. http://man7.org/linux/man-pages/man2/mmap.2.html http://man7.org/linux/man-pages/man3/sysconf.3.html These links give you all you need to know about the specifics of setting up the mmap() call and the sysconf() call The uint32_t / int16_t are data types. int16 means that it expects an integer of 16 bits, which means 2^16 or 65,536 total values, or from -32768 to +32767 uint32 means that it expects an unsigned integer of 32 bits, this is 2^32 or 4,294,967,296 total values, but it does not support negative numbers. This is from 0 to ~4mil A signed integer is one with a leading bit that shows whether it's negative or positive. Unsigned ints don't have this bit. for example, counting in signed bytes goes like so. 0000 0000 = 0 0000 0001 = 1 0000 0010 = 2 ..... 0111 1111 = 127 (The highest number a signed byte can have, since adding 1 to the next bit would make it negative. 1111 1111 = -1 1111 1110 = -2 1111 1101 = -3 1000 0000 = -128 (The lowest number a signed byte can be) So when you see the &amp;= and |= those are bitwise operators. They evaluate the similarity of two things on a binary level, comparing literal bits. The () around the uint32_t appears to just cast it as a pointer to an unsigned 32 bit int to evaluate it. as for exact values, I have no idea. It reads from a file. If you have more question you can reply with them or pm me
View in your timezone: [30/08/2018 at 18:00 GMT][0] [0]: https://timee.io/20180830T1800?tl=Writing%20an%20OS%20from%20scratch ***** [^^delete*](/message/compose?to=timee_bot&amp;subject=delete+request&amp;message=%21delete+eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJlNHp1bm96IiwiYWN0IjoiZGVsZXRlIiwib3AiOiJ6aXhjb29sIiwiaWF0IjoxNTM1NDg4Mjk1fQ.CgFKhuz8meup-A_qJikECB5yhyaFwfvJRuw92SgXKmg) ^^| [^^reprocess*](/message/compose?to=timee_bot&amp;subject=reprocess+request&amp;message=%21reprocess+eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJlNHp1bm96IiwiYWN0IjoicmVwcm9jZXNzIiwib3AiOiJ6aXhjb29sIiwicG5tIjoidDNfOWIyaTdhIiwiaWF0IjoxNTM1NDg4Mjk1fQ.iQ60Xo7L6ZB7_sOMh4y-kwCPhzNEgyrQxeDUY2PIdoc) ^^| [^^ignore ^^me](/message/compose?to=timee_bot&amp;subject=ignore+request&amp;message=%21ignore+me) ^^| [^^help](https://www.reddit.com/r/timee_bot/wiki/index) ^^*OP ^^only
Well, there is [this](http://www.gtronic.it/test/wp-content/uploads/2017/01/Red-Pitaya-register-map.pdf), but the program written to the FPGA associated with the code I'm posting here I think has remapped the memory, so this mapping is no longer valid. Also, is there any chance you could provide some insight on this [monitor](https://redpitaya.readthedocs.io/en/latest/developerGuide/software/clt.html#monitor-utility-for-accessing-fpga-registers) function? Is that a native linux thing? If not, is there a way to achieve what it's doing here with native linux or C commands? Thanks. 
Will be there :)
This sounds interesting! I’ll have to take a look :) 
womp womp. blocked at work
Will you record it and upload it somewhere too? I'd love to watch this but I'm not sure if I'll be able to make it that day :(
Upload to YouTube (or other video site) after streaming please!
Don't think I'll be able to make it but for sure will look over the VODs. Have you considered uploading it to YouTube?
That FPGA document is indeed the kind of thing you should be looking for. The code you posted mmaps 0x40000000 to cfg, so, cfg points to the start of the housekeeping block. I don't know anything about linux. Just from the sample, I would guess monitor is supplied by the people who do the hardware, but that's just a guess on my part.
IIRC Intel added it in skylake processors. Not sure if it is actually being used though 
Invite is invalid. :(
It'd be funny if it was one of the authors whom were under the "Warning" sub section. It'd be ironic, though, if it was Zed A. Shaw. But, I like his stuff.
I love this OS type of projects Thx 
[removed]
I included shellapi.h on the library but errors continue to exist. Now I'm using ShellExecute () for links to various websites, but I would have preferred to have a command that opened a folder for me. Not knowing I tried to put the folder directory inside ShellExecute, then ShellExecute (HWND\_DESKTOP, "open", "directory", NULL, NULL, SW\_SHOWDEFAULT). But even so doing I do not get the desired result
Please be civil.
Will the stream videos be saved, so that I can view it later ?
&gt;Features &gt; * Vim-like modal interactions. Bye.
this is a listening program, what do you mean you can't connect?
I can't connect to the server from my browser.
Yes! Please upload somewhere for after-the-fact viewing. I've wanted to know how to do this (not that there's much practical purpose, but still) since I was a kid. And I'll be at work during your live stream. 
what debugging have you done? print messages in the loop to see a connection request has come, etc?
I don't really understand the point of this project. It doesn't seem to try to improve on Vim, just to emulate it. Considering the state of the Vim codebase (everything dunked into a single maze-like C file) I can sort of understand that for future-proofing and maintainability for after Bram calls it quits, but this project has the _exact same problem_. One file, 4837 lines and growing.
I don't use any package manager. If a library is provided by my distribution, I install it from there. Otherwise I compile and install it into my own home directory. This package manager seems to be focused on micro-libraries. I do not use such libraries as (a) their functionality is sufficiently easy to replicate in your own code tailored to your need and thus (b) it's not worth the extra hassle of a separate dependency. Generally, my C programs only depend on established libraries to perform tasks that are too difficult or tedious to perform manually. Every library is a potential liability as it is code that I haven't written and can't reasonably patch (I would have to adapt my patch to every new version of the library which I don't want to do). So I only use libraries if they are known to be good and if the benefits outweigh the liability. For example, I frequently link against the liblzma (for compression), libsqlite (for databases), and other similarly stable libraries. I usually do not ship any of these libraries with my source code, instead I link against whatever library is installed on the host. This makes it easier to integrate the code into the distributions package management.
You are missing a `\r` in `http_header`.
I'm in the same boat as /u/FUZxxl. However this package manager doesn't seem to have packages for openssl (or libressl), curl, or sqlite. The limited number of packages will hurt adoption.
All the code in one massive file? Seriously why?
This is part of [a larger project](https://github.com/klange/toaru-nih) implementing an entire OS from scratch - and any worthwhile OS needs its own editor. This is stated several times in both the README and the comments in the code itself, so I'm not sure how the point isn't making it across.
Code re-use is only a good idea if you have stable interfaces between the re-used parts. For small pieces of code, it's often a good idea not to put them into a library and instead rewrite or copy them.
That's really not an issue and the fix proposed by the author does more harm than it helps. I mean, I'm not against fat pointers (i.e. slices in Go), but it's not a good idea to retrofit them into C.
If you think 5000 lines is "massive" for a single file in a C project, you're in for a surprise, but the answer is because it's part of a larger project with several single-file applications (where, admittedly, it is the largest).
Probably something a little more generic? &amp;#x200B; \#define FAT(T) \\ typedef struct \\ { \\ T\* i; \\ size\_t size; \\ } \\ T##s; \\ static T##s new\_##T##s(size\_t size) \\ { \\ return (T##s) { \\ malloc(size \* sizeof(T)), \\ size \\ }; \\ } \\ static void free\_##T##s(T##s x) \\ { \\ free(x.i); \\ } ···· typedef struct { char\* name; int age; double weight; } person; ···· FAT(int) FAT(float) FAT(person) ···· int main() { const ints ints = new\_ints(32); const floats floats = new\_floats(64); const persons persons = new\_persons(128); free\_ints(ints); free\_floats(floats); free\_persons(persons); return 0; } 
`#define FAT(T) \` `typedef struct \` `{ \` `T* i; \` `size_t size; \` `} \` `T##s; \` `static T##s new_##T##s(size_t size) \` `{ \` `return (T##s) { \` `malloc(size * sizeof(T)), \` `size \` `}; \` `} \` `static void free_##T##s(T##s x) \` `{ \` `free(x.i); \` `}` `typedef struct` `{` `char* name;` `int age;` `double weight;` `}` `person;` `FAT(int)` `FAT(float)` `FAT(person)` `int main()` `{` `const ints ints = new_ints(32);` `const floats floats = new_floats(64);` `const persons persons = new_persons(128);` `free_ints(ints);` `free_floats(floats);` `free_persons(persons);` `return 0;` `}` 
Are you also including windows.h, though? It should be included before shellapi.h. To open Explorer at the given directory you need to use `explore` and not `open` as the verb.
I don't think I'm missing anything.
I tried using netcat for debugging as I don't think the problem is the code anymore.
How about something a little more generic and built in? &amp;#x200B; [https://pastebin.com/nm5XNR6Z](https://pastebin.com/nm5XNR6Z)
::rollseyes:: thx for nothing 
Oh god no, please not.
You are not correctly terminating the second line in `http_header`. In HTTP, each line is terminated with `\r\n` but you write char http_header[2048] = "HTTP/1.1 200 OK\r\n\n" where it should be char http_header[2048] = "HTTP/1.1 200 OK\r\n\r\n" It is very likely that web browsers don't particularly like that.
Your “valuable members” started it by talking down to me. Don’t matter, this is exactly the experience and treatment I expected when I posted this question. Not surprised at all. 
Doesn't appear to work after changing it as well.
If you talk about /u/k_x90, he did not talk down to you. You showed that you are not interested at even attempting to understand how `mmap` works. Instead you ask for a “laymans explanation” without outlining what parts you have trouble with. This is very hard to do because you have at no point indicated what you find hard to understand about the linked manual page. Where are we supposed to pick you up? You have to tell us! /u/k_x90 provided—slightly tongue in cheek—an explanation that is as simplified as it can get to demonstrate why you need to be more specific with your desires. And even in your answer to his comment you still don't say where you are stuck. Instead, you just insult him for trying to help you formulate a question that can actually be answered.
I can honestly say i have never had a problem with this. It is just expected that if you pass a pointer to something that MAY overflow,you also pass its size. Why does this need hand holding???
You are weak. Goodbye. 
&gt; This seemingly innocuous convenience feature is the root of endless evil. It's ironic that people constantly complain that C should have more convenient syntactic sugar, and try to fix it with macro tricks and languages like c++. But at the same time, one of the few convenience features that C actually has is called it's "biggest mistake". The feature proposed here would add a lot of confusion too because it hides the fact that arrays decay to pointers, and silently adds transparent call-by-reference to C.
It's not the 30th of August, yet.
This was supposed to be a practice code on sockets so I didn't add any error handling. If you say it does in fact work on your machine then I suppose it's a problem with mine.
You should always always always add error handling, especially if it is practice code. If you add error handling (which can be as easy as checking return values and calling `perror` if something failed), it is much easier to see what the problem is. Which browser do you use and what does it say? Does your server work if you connect to it using `telnet`?
I am using Firefox, and no, connection is being refused.
Love the fact that it compiles and runs well under TCC.
Added some [error handling](https://pastebin.com/ztVSjfT6), but still nothing.
Are you sure you recompiled and rerun the program? Because the code you posted does not compile.
I don't like it because it encourages a style of libraries that have an ugly, unstable API and are only meant for static linking. BTW this is also the biggest problem I see with Rust and Go: Although these languages theoretically support shared libraries, their whole ecosystems are based on these statically linked micro libraries. Meson has a better alternative: You can use shared libraries installed via a proper package manager - but if a dependency is not available, it can be build along with the main project as a fallback, from a linked subproject.
There is a dollar sign instead of a parenthesis in the code somewhere.
Why not stream to something like Twitch? Seems easier than zoom.
SQLite and zlib are important pieces of infrastructure and are well worth learning.
Best library for what purpose? There are too many libraries to answer this question in general.
Why does an application have to be single file?
What about in the event that the user doesn't have the dependency installed on their machine? If the user is well versed in open source development I guess you can just tell them to download, build, and compile the dependency themselves from source, but from my experience that's enough to compete dissuade them from using your software (too much hassle). Recently I came across a dependency management solution that works incredibly well (IMO). Using CMake's find_package you can poll for the existence of a package, if it doesn't exist, you can download it using git submodes. After this CMake handles platform specific building (for the dependency and your own project). Obciously this solution in itself relies on preliminary dependencies to be installed (CMake &amp; git), but most developers will have this installed, and if they don't it's a relatively simple process. 
Even if the author is Walter Bright?
Don't know, but the same is done here https://git.suckless.org/9base/files.html
_That_ is nice.
Sqlite I know seems to be mportant, but why zlib over another compression library?. Would learning that cover all or most of the compressing one needs to do?. It looks interesting. Thanks for you answer. Do you have more recommendations for other libraries?. How about algorithms or datastructures or anything that makes programming faster and more efficient.