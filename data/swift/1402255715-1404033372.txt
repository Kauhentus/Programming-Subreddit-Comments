Actually in some cases ARC will be slower as the optimizer might not detect all unnecessary retain/release emits. That said, not using -O at all (and then not testing -Ofast) with a very alarmist title is in poor taste.
Is it really that different from doing one in Objective-C?
Well he confuses || with &amp;&amp; but otherwise, yeah, @auto_closure has some interesting possibilities. I don't understand why people would want C-style macros; those are horrible for the readability of the code.
Thing is that Swift/ObjC has different ARC emits. For ObjC you basically has something like this: obj_retain(myObject); // Added by ARC [myObject doSomething]; obj_release(myObject); // Added by ARC For Swift, it looks like this: swift_retain(myObject) // Added by ARC myObject.doSomething(); And in "doSomething()": func doSomething() { println("Something") swift_release(self) // Added by ARC } So the release occurs before the stack is popped on the doSomething call. I was told that "this was something they couldn't do in ObjC", so I assume that this is a good thing. However, it's clear that this difference in behaviour creates issues that don't exist for ObjC
Did he mention anything about C-style macros?
I think the only way Objective-C helps is getting to know Cocoa, but you can learn that with swift too. 
I think you should enrolled as iOS or OS X developer because one of my friend have iOS developer account and he can access all these samples which is presented on keynote...
with a thermometer?
[Maybe you should stop calling it bullshit and educate yourself](http://www.strongtalk.org/documents.html). Strongtalk's company was purchased by Sun and the resulting JIT/Optimizer became what is today known as HotSpot. Remember that? And I"m not fond of your tone either since you're the one not providing any documentation to back up your claims. I've heard it all before "you need type annotations to do refactoring" - no that feature first appeared in Smalltalk. "you need type annotations to optimize code" - no that isn't true either. There's a lot of mythology in the software development world. Most of it is actually false. Conventional wisdom is usually wrong.
I'm enrolled too, but where do i find them?
Anything specific? Maybe we can help....
Dictionary keys need to be hashable. I quickly glanced over the docs, I think closures are not hashable in Swift. However one could use an array, which is less beautiful syntax, but should work fine. I'll try that out and update the post accordingly...
Hey awsomo007, I think the issue you had with UserName in CoreData is a result of UITextfield returning an optional. https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-XID_428 `txtUsername.txt` returns an Optional, so you need to force unwrap it with '!' or use Optional Binding to get the value before you save. The reason the String concatenation worked was because were guaranteeing a String being there. 
Why would you downvote this? He asks in his video if someone could explain it.
No, it doesn't.
Probably under the WWDC or Sample code areas.
Your Swift tutorials have been awesome. Such a huge help. You planning to keep doing them for a bit?
So that explains what was up with my swift code I did for the programming challenge a couple days ago. It was taking seconds to run through an iteration when it should have been a lot faster. I thought i just had really bad code, now i know its only okay code and a slow compiler. 
Mainly how Closures differ from anonymous functions, and how can I say capture multiple return values out of a closure? Probably a good place to start
We are working on comments and the ability to create collections as well. The collections will let users group and organize the links however they like. They can save entire tutorials series, or everything from an author or a specific topic. Whatever makes sense. Any other suggestions or feedback is very desired!
I found [this one](http://www.weheartswift.com/higher-order-functions-map-filter-reduce-and-more/) a good start after read the Apple's book 
yes, I try to dump the llvm ir and finf that @tansparent means inline.
One other thing about the first example with the closure. It's important to understand that the code following that return statement isn't being executed. Instead it's defining an (anonymous) function which is returned, and can then be called multiple times by someone else. The anonymous part can be confusing, which is probably why the Apple documentation starts off with an example of variable capture involving declaring a function inside a function, rather than using the closure syntax. The example I gave above could instead have been written like this: func make_closure() -&gt; () -&gt; Int { var x: Int = 0 // local variable 1 var y: Int = 0 // local variable 2 func function_to_return() -&gt; Int { ++x // x is "captured" ++y // y is "captured" return x + y } return function_to_return } let c = make_closure() The function declared inside that function still captures the two variables, the same as the other syntax. In fact, Apple is adding to the confusion by calling anonymous function declarations in Swift "closures". Strictly speaking, a closure is a function combined with a captured environment. In that sense, named functions are also closures. Sorry, that last sentence probably isn't going to help your understanding much... My point is, that this: var a: Int = 42 func foo() -&gt; Int { return a } is much the same as this: var a: Int = 42 let foo = { () -&gt; Int in return a } Apple calls the first one a function and the second one a closure, but they are both closures in a computer science sense. edit: flubbed the syntax on the last example
maybe :P your welcome haha its fun recording these
Very good write up. Read both your comments and they have helped me immensely. Im about to read your blog post after GoT. Thank you so so much. I think I get it now
The terms 'closure' and 'anonymous function' are usually used interchangeably, but to be precise closures are a specific implementation detail of functions in most functional languages. I see others have explained how they work. They're called closures because they 'close over' variables in the context which contains the function, remembering and gaining access to them indefinitely. They're really cool and a lot of languages, including JavaScript, have them. I think you also asked about _returning_ multiple values from functions. The idiomatic Swift way (and incidentally also the idiomatic Python way) to do that is to just return a tuple of the multiple values: func getValues(...) -&gt; (Int, Int) { var x = ... var y = ... return (x, y) Of course, different situations call for different idioms. Swift's error-notification idiom is to return an optional type: func getValue(...) -&gt; Int? { var x = ... if success { return x } return nil } A normal value inside the optional type means the function succeeded; a `nil` value means the function failed.
How surprising... A flappy bird clone and a 2048 clone top the list.
No. You need developer account for Xcode 6 Beta or wait for official release. I already have an account by paying $99 and I think its totally worth it
I am not the one who created these videos!
Thanks for posting this, I'm pretty sure that you've hit the nail on the head here. it makes perfect sense. What i dont understand and maybe this is a bug of the language.... the .text? property even though optional did contain a value as i had explicitly set it in the view when debugging the application. I'd also done a test off camera println(txtUsername.text) where it printed out fine... so even though the value is optional it was provided and did exist.... why should it need to be force unwrapped if it exists. And your right btw, force unwrapping it works as does explicitly casting it to a string and concatenating an existing string with it but that scenario feels really weird that it didn't just unwrap it for us when using it with core data but it did when printing it out to the console :)
When you use the `where` clause like that, it makes the matching expression available to the body of the `case` as a constant. Using the underscore instead signifies that this expression won't be used.
I don't have a paid dev account so I can't test swift code, but could anyone tell me if my implementation works? func cond&lt;T&gt;( conditions: (@auto_closure () -&gt; Bool, @auto_closure () -&gt; T?)... // optional because maybe they want the answer to be nil, and the return is optional anyway ) -&gt; T? { for (condition, value) in conditions { if condition() { return value() } } return nil } answer: String? = cond( (a == 3, "a is 3"), (a == 2, "a is 2"), (b == 1, "b is 1") ) If this works the way I want it to, it should accept any number of conditions. I'm just not sure if @auto_closures can be in tuples like that.
Rust macros are interesting - more controlled than C, easier to make readable with custom syntax keywords between macro arguments in the invocation, and more powerful; .. r.e. this example in Rust you could have made `cond!{ condition1=&gt;expr1, condition2=&gt;expr2, ...}` (...but you wouldn't bother because if-else if... returns a value anyway). Rust has less inbuilt sugar (e.g. , no 'if let' for option acess) but you can use it's macros to cover cases the language designers haven't 
Watch a bit, quite good. Thanks for this!
Dig it, feels like Scala.
Assuming you mean open a webpage as in open it in Safari, then using openURL should work. UIApplication.sharedApplication().openURL(NSURL(string: "http://reddit.com"))
&gt; At its core, the language is designed to eliminate bugs, but not in the academic way that, say, Haskell eliminates bugs by preventing normal people from writing code in it. Brilliant! I've also started playing with Swift. As a fan of code uniformity, so far the one big gripe I have is that it somehow doesn't feel uniform because of the type inference. There are various scenarios of when you declare and when you set variables. For example, a class property that is initialized at its declaration vs. initialization in init(). Depending on the exact sequence and Swift's inference grokking which is not always up to snuff, you need to splatter type information in different places. One solution is to consciously always provide the type at variable declaration (like Obj-C!) which kind of makes var/let overhead. 
Yes, I do plan to implement as much as I can -- if you're feeling adventurous send me a pull request :) I mostly left the closures with longer syntax for clarity, but hugeRange.Where(isPrime) hadn't occurred to me, neat!
I think you mean "you're" if you're going to critique the grammar guy. =P JK, JK, seriously awesome videos though. Thanks for making them.
The videos are only a few minutes long. Why not watch the first one and see if you can keep up? P.S. I bet you'll be fine. =D
don't you want to do want to do 1...100? I keep getting these messed up, but I thought it was like this a..c means [a,c) a... means [a,c] In this case you want 1-100 inclusive, so it should be 3 dots.
bullshit, it's better to start with Java which is object oriented
Why? Computer science academia disagrees with you... I can tell you why. Most people can't program. It is better to start with procedural before OO. If you studied computer science you would know this. Unfortunately app programming is full of amateurs.
&gt; Swift is built on functional programming paradigms just like Scala, Ruby, Erlang, R, Python, Java Script and list goes on. These are functional programming languages? OP are you high mate?
Sorry about that I should have read up on it before saying anything. I'll edit it 
Apparently, not currently but it's slated to be added soon.
thanks for clarifying.... sleepy head, I interpreted as FP language, rather than paradigms. 
i wrote it properly in the critique message taking the piss haha but i don't write proper english ever.... lol and to prove it i have not upper-cased any of the i's in this message see #proof haha
Thanks for clarifying, @yawaramin
Completely Agree. Even though Swift is an Object Oriented programming language, it supports multiple programming paradigms, including object-oriented, imperative and functional programming or procedural styles. But Some of the above languages go way beyond, particularly Erlang (my favourite). These languages are more focused on solving specific problems, unlike Swift which I feel has potential to be a main stream language. Python seems to be the closest to Swift, but it doesn't stand a chance w.r.t Closures at least.
This is pretty staggering. There's absolutely no reason why a Swift sort should be slower than one run in standard Python (a famously slow interpreted language). Given that it's compiled language, it should be as fast (or, really, faster) than an implementation run in PyPy, yet it's slower by almost a factor of 50. For *sorting!* It looks like its array random access functionality is totally busted. This is not some tiny issue that only comes up in some types of programs, pretty much every program ever needs to do lots of array accesses. Apple needs to make this a top priority right now. It's not acceptable for a language of this caliber, and especially not for a language designed to run on low power devices. 
Ahh good to hear. :) "even though the value is optional it was provided and did exist" Yes, but the optional still had not been evaluated. "why should it need to be force unwrapped if it exists" - Because you need to provide a handler for when it doesn't exist. All about that Saftey. :) "but it did when printing it out to the console" - println can take the optional as a parameter CoreData can not. Anyway I hope that helps. Nice work on the videos man, keep it up!
Purely speculation, but isn't this because Swift's sort isn't optimized for a certain type of sort? It's a closure, and takes a condition that returns a Bool as whether or not to switch *n* and *n+1*. Basically, it functions like an insertion sort (?) because it can be very flexible, versus a better sorting algorithm that specializes in less-than or greater-than sorts.
The user NSArray has a point: &gt;with n set to 1000, the closure was being called about 11,000 times. I was surprised when I read the sort function took a closure that compares two elements. Python itself moved away from that and instead uses a function that will return a number for each object in the array and sorts those. This means the function is called exactly once per element, not however many comparisons it takes to sort the array. Still, this is beta software, and even if the language is set in stone as of today, any number of things can change in its implementation before autumn.
Thanks! It did exactly what I was hoping for. Sorry I didn't really specify how I wanted it to open, but Safari is just fine. Thanks!
Why not post the updates about additional functionality as a banner on sososwift.com? 
Besides just looking at the existing examples from apples site or other random tutorials? Without any IOS / Mac / Objc programming it's going to be tough. There are a lot of patterns with IOS/Mac programming that you aren't familiar with. It translates well going from Objc to Swift because a lot of it still seems to be the same just more readable and easier to write. I think your best bet is just to read through basic simple tutorials in swift and just read the documentation. You are getting in at the beginning so you just have to do stuff and make mistakes and fix them.
Yes, this really is a problem. All examples, tutorials and documentation from Apple isn't written for beginners or people like me switching from other languages. They all assume that you have decent Objective-C background.
"with no resources other than the language specs and Google" - I got a laugh out of that
It seems to me that the content found in [this documentation](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/BuildingCocoaApps.pdf), particularly pages 23–30, ought to contain a veritable sea of useful information for you as you grow in familiarity with Cocoa in particular. Cheers!
I think it's safe to say, all entries should be Flappy Bird clones.
The language has been released and Apple has a book posted publicly in iBooks. I would imagine that would make it ok. Your code is yours to do what you want with, there are only hints at syntax which you'd reveal (which again, would have been covered already by Apple's release). That makes me think it should be fine, but I haven't read the NDA since I'm waiting for the public beta of Yosemite since I don't want to pony up the cash for the dev license yet (not enough time to devote to it right now).
It would be somewhere in between, probably closer to F# (actually closer to Rust :). Note that currently it's not possible to implement it using enums in Swift, because it doesn't support recursive enums.
I have the same problem. I know Java well so Swift is not necessarily hard to learn, it's just the whole cocoa part which is the hardest. I've found looking at examples is the most helpful. 
TL;DR It looks like ARC is not correctly optimizing unneeded retain/release and if so, it is likely to be fixed since objc version knows how to do this. 
Came here to say this. "No resources other than the language spec and the entire internet."
The video is private now, would love to have access to it. 
Yes, you're right! The confusing thing is that this is the exact opposite of Ruby, which uses ".." for an inclusive range and "..." for exclusive.
Yeah, see I think another round of the same sort of madness that took them when they ported WebObjects to Java and began pushing Java bridge is upon them. They need to pay attention to that golden goose and not try to trade it in for an albatross.
&gt; It would be somewhere in between, probably closer to F# (actually closer to Rust :). Thanks. How exactly would Swift improve upon C# in the context of that program? Apart from recursion, how close are Swift's enums to union types? 
Swift is not under NDA. Check out this post for a good explanation: http://oleb.net/blog/2014/06/apple-lifted-beta-nda/
Exactly. It's in beta.. this stuff happens.. they'll fix it.
Nope. You gotta pay the dev fee to be a dev.
I guess it's all going to come down to the implementation. From what I've seen very far, the language is really bloody powerful and unlike Obj-C, doesn't give me headaches or the desire to scrape my eyes out with a rusty caltrop. They've got a few months to iron out the kinks. Here's hoping they get them all..
&gt; By the time windows/linux open source platform comes out, I feel as if I'll be behind. How so? The language documentation will still be around then. There's no point in treating the language like a trend or fad. It's not the case that people who learned Python in 2000 were behind because they weren't around in 1994 (Python 1.0 release). FFS many people who are contributing to glibc weren't around when the C programming language was specified, or even when gcc first arrived on the scene. So stop worrying about being behind, there is no boat to catch. You can't programming for iOS without getting a Mac anyways, so why so worried? 
I would strongly recommend downloading the book and/or [viewing the Introductory, Intermediate and Advanced Swift Programming videos](https://developer.apple.com/videos/wwdc/2014/). The type inference appears to be pretty decent, and pattern matching, although perhaps not quite as elegant as Haskell's, is a strength as well. Sorry, but I am not familiar with either C# or F#.
Wait until the fall, then you can download it for free when it's out of beta
Yeah that's why you can have Obj-C and Swift in the same project: they use the same compiler.
Oh, man, the dev forums are terrible right now, basically: * 90%: I paid $100 to get this beta, and I installed it on my primary phone/mac, it's buggy and I want to downgrade now, how do I do that? * 9%: I am an actual dev, but can't be bothered to watch any of the WWDC sessions, how do I do X which is completely described in the sessions? * 0.9%: Actual legitimate development question * 0.1%: Answers to the above questions.
You don't have to pay to get XCode 5.
Do you know when in Fall, or is it a TBD date?
Just fall, the same date everyone who doesn't work at Apple knows.
Betas and submitting to the App Store require a dev account. Public releases of Xcode can run without requiring a dev account.
Xcode 6 will have to be available when iOS 8 ships, iOS 8 needs to be available when the next hardware ships, Apple is due for a new phone this fall. Apple has a vested interest in getting Xcode 6 out the door as soon as possible, preferably *before* the new devices ship so that they can have apps ready on day 1 for it. It's *possible* that they could backpedal to using Xcode 5 for iOS 8, but it's *extremely* unlikely given all the support they'd have to back port to the old IDE for that to work out. 
&gt; I would strongly recommend downloading the book and/or viewing the Introductory, Intermediate and Advanced Swift Programming videos. That's a great resource I'd missed, thanks. &gt; The type inference appears to be pretty decent, and pattern matching, although perhaps not quite as elegant as Haskell's, is a strength as well. I see a lot of things like: func swap&lt;T&gt;(inout x: T, inout y: T) { ... func fibonacci(n: Int) -&gt; Double { ... func memoize&lt;T: Hashable, U&gt;(body: (T)-&gt;U ) -&gt; (T) -&gt; U { var memo = Dictionary&lt;T, U&gt;() ... Languages like F#, OCaml, SML, Haskell and so on don't need any of those types to be written in the source code. Scala and C# do. The enums and pattern matching look very interesting but not supporting recursive types is seriously limiting. I hope they add that. 
Same link: http://www.reddit.com/r/swift/comments/27m2wr/swift_performance_sorting_arrays/
I have to double check but I think Xcode 6 might be under NDA. If it is then we have to be mindful of screenshots and stuff like that. 
Awesome. CloudKit could be one of the libraries we support down the road. No guarantee on to how soon, but I will look in to it.
I'd sat that _they are_ union types. Just that the syntax is a bit heavier than that of languages like F# or Haskell. Also, I haven't look at how the compiler represents enums, but that's just an implementation detail.
Welcome to the dev forums post ANY beta. The dev forums just suck more right now. They are in a perpetual state of suck on the regular. 
Cool guy. Craig must be the closest there's been to a Jobs 2.0
Considering the built in value observation for self, I expect Swift's native interface for observing other's is going to look a lot better than all the code that seems to require. var totalSteps: Int = 0 { willSet(newTotalSteps) { println("About to set totalSteps to \(newTotalSteps)") } didSet { if totalSteps &gt; oldValue { println("Added \(totalSteps - oldValue) steps") } } } Excerpt From: Apple Inc. “The Swift Programming Language.” iBooks. https://itun.es/us/jEUH0.l
Is that the CREGG guy Tim keeps talking about?
 println(Array(1...100).map{ $0 % 3 == 0 ? $0 % 5 == 0 ? "FizzBuzz" : "Fizz" : $0 % 5 == 0 ? "Buzz" : "\($0)" }) one liner, yay
I really need someone to explain to me just exactly why he pronounces Craig as Cregg. Confused the hell out of me. Is it a regional accent thing?
cool, thanks!
https://www.youtube.com/watch?v=pWqh5ICqcWk&amp;feature=kp
Is there any way to get one of those tshirts? 
Who is the guy at extreme left? I have seen him somewhere, but I can't seem to remember where!
really nice question! thanks for posting.
According to the devs, Swift-native KVO (As in not requiring NSObject) is on the near-ish term roadmap, with the obligatory "filing a radar will help us determine our priorities". 
She missed c3p0
I'm from Texas, and I've never heard it pronounced any way other than with a short e. What are the other pronunciations?
More dots = more results, remember this!
So that it doesn’t call .count 25 times?
I don't understand... it will be calling .count in the first version, not the modified version
board.count is 26 and finalSquare is 25, they are not the same. Let's add board[25] = -10 to the code. In the first variant the game would set you back 10 squares when you land on square 25, in the second variant the game would just stop when reaching square 25.
Oops, my mistake. I had them backwards.
He's just a Craigular Joe.
http://youtu.be/BXfz9zBmNQQ
very underscore-ish! 
Oh god. Nested ternary...I think you stabbed my brain.
It's beautiful. *sheds a tear*
As said by 'thecw', you must be a dev to have access to new betas. Such as Xcode 6. If you do not want to pay the 100$ dev fee, then you must wait till sept to get Xcode 6
thank you for your help :)
Same here. I have extensive knowledge of Python, Java, and Haskell, and was really excited to at last be able to program for Mac and iOS without using the beast that is obj-c (sorry, Apple devs), but right now there is practically no support for people who aren't versed in Apple's frameworks. I expect/hope this will change once Yosemite and iOS 8 are out, especially if Apple releases swift as open-source (which I really, really hope they do for everyone's sake), but for now I suppose the best idea would be to invest in one of those comprehensive Cocoa guides, as Kazbin suggested below. 
Maybe some altruist experienced in Objective-C and Cocoa can write a guide for all us heathens.
Yes it is, even a MacBook Air is sufficient depending on what your building.
Awesome, thanks! Nothing complicated I think, just trying it out for fun :)
Branding! There's going to be a mini-goldrush on clever, single-symbol type names… (I'm half-kidding) But this raises a question. The Dollar.swift file defines struct $ { … } If you look at the grammar, a struct name should follow the naming rules for identifiers, described like this: *Identifiers begin with an upper case or lower case letter A through Z, an underscore (_), a noncombining alphanumeric Unicode character in the Basic Multilingual Plane, or a character outside the Basic Multilingual Plane that isn’t in a Private Use Area. After the first character, digits and combining Unicode characters are also allowed.* Which one of these conditions for what constitutes a valid initial character for identifiers does the dollar-sign meet? Does it count as alphanumeric? I don't think it counts as a character outside the Basic Multilingual Plane…that's plane 0 which I believe encompasses all of ASCII. (Please correct me if I'm wrong.) Could this library be exploiting a bug in the implementation of identifier enforcement?
But.. but.. Ruby :(
A used MacMini is fine, Macbooks are more than enough. 
Craig might be the most classy-handsome guy at apple! 
I'm not that sure, even it's still in beta and I guess youre asking about new apps with XCode 6, a plain macbook could be a problem versus playground runtime and storyboards. Ask around if anyone already tested it (Also a solid state disk is a huuuge improvement)
*var board = Int[](count: **finalSquare + 1**, repeatedValue: 0)* 
Thanks crawler23, you should consider an explanation for the full big example of delegation, you just jump from a simple protocol usage to that big bomb.
Same! I can't seem to find them available online at the moment though.
Thank you. I will include it in the revised version :)
Awesome, thanks!
Now for some fun. How about some closures? let fizzbuzz: (Int) -&gt; String = { let dictionary = [3: "Fizz", 5: "Buzz"] let keys = sort(Array(dictionary.keys), &lt;) func function(n: Int) -&gt; String { var str = "" for m in keys { if (n % m == 0) { str += dictionary[m]! } } if (str.isEmpty) { str = String(n) } return str } return function }() for i in 1...100 { println(fizzbuzz(i)) }
Keep in mind that an iMac is just a MacBook inside a monitor.
I use a Macbook Air with an external 32 inch monitor. You'll do just fine. If anything I find XCode 6 is faster than 5.
What's the point in making these functions static methods instead of just functions? Seems like a really ugly Javascript-ism. Doesn't Swift have modules? Modules seem to be undocumented for now though.
Yeah, about that... We done messed up and only printed 7. Sorry :(
Unfortunately, not at the moment. We printed just enough for us, not realising how much interest there'd be. It was a bit pricey too. 
That's not really true. The iMacs have better processors at a given price point. Most of the iMacs also have dedicated graphics cards, while only the top of the line MBP has one (which is $600 more than the top of the line iMac). On the other hand, the MBPs all come standard with an SSD, while the iMacs do not.
I'm from Australia and you won't hear "Cregg" at all here. 
- use tuples to return data where it's appropriate: let (summary, qualifications) = NDHTMLParser(HTML: html).parseJobDetails() - use enums, they're incredible useful: override func tableView(_: UITableView!, titleForHeaderInSection section: Int) -&gt; String! { return NDJobListingType.fromRaw(section)!.description } - use didSet and willSet, they're cool: var job : NDJobListing? { didSet { if let job = self.job { titleLabel.text = "\(job.title) (m/w)" detailLabel.text = "\(job.location), \(job.type.toRaw())" } } }
Well, that sucks donkey tits. Oh well, life goes on, swiftly. 
This is definitely going to be one of the biggest headaches for new developers and one of those things language detractors will harp on consistently. I'm not a huge fan of the costs of some of these performance improvements. Most of my code does not need the optimizations, and in Obj-c if I did need that little bit of performance I could switch to C or C++ to do it. In exchange for the performance gains I generally do not need, I lose many of the dynamic features of Obj-C and get very strange array/dictionary semantics. 
Thank you!
Thank you thank you thank you. I hate the "-&gt;" no matter what language it is using it.
Perhaps you could send the images my way? I'll get some printed.
Yeah, I've started doing the same. It feels awesome to skip entire pages of the book because they explain a bunch of boilerplate Obj-C code which you don't need in Swift. The downside is that because the Swift Cocoa API is not 1:1 with Objective-C, and because Swift's APIs are not really documented, well, at all right now, when something doesn't work the way it's described in the book, it involves a lot of messing around.
p.s. this is kind-of covered (in a slightly snarky footnote) in my article [here](http://airspeedvelocity.net/2014/06/09/mining-effective-c-for-ideas-on-swift/).
 Oops, if this was taken as mostly negative on Swift I messed up! One of the reasons I'm enthusiastic about Swift is that it's that bit closer to C++ than other similar languages like Java or C#. Copy constructors and more advanced template functionality would be nice, but they come at a price – people are always whining about how complicated C++ is, and not without merit. I think many of the missing features in Swift are trying to avoid this, rather than limitations of Obj-C. I've put up [another article](http://airspeedvelocity.net/2014/06/10/rundown-of-how-each-effective-c-item-relates-to-swift/) that gives a full rundown of all the Effective C++ items, and shows how several of them are describing dangers that just aren't there in Swift, which is definitely a win if its been done without losing too much power. Thanks for the feedback.
If you attended WWDC, perhaps you've seen him several times but can't really place it anywhere?
You're right, I don't know that ill set it to that. My guess is that \^= works well with his workflow / other keybindings 
Thanks for the reply. So what would be the benefit of using as switch statement instead of an if-else?
More concise and readable code , for starters 
A boolean can only carry 1 bit of information, while an enum type (esp. with associated data) can carry an arbitrary amount. So pattern matching is much more powerful.
Is this a keyboard locale problem? -&gt; is very easy for me to type. As a programmer that uses C/C++ a lot, I need to type it all the time (the indirection operator is much more common than Swift's return operator). It's never been an issue for me.
I started iOS dev on a 2008 Macbook. Anything more modern will work just fine. :)
It means hold in alt and press =.
Hm, that would make sense, but why wouldn't super use its own VTable and thus call its own someFunc()? I'm not sure about it but iirc, C++ does it this way. I'd have to investigate the internal implementation, but as of now, I'm still comvinced this more of a design issue. 
URL has changed to http://dollarswift.org
Surely it should be called swiftQuery? :)
I've already found out that I can reassign values but that would just bloat the code. As I've written below, I still think the decision to let parents call their child functions is wrong. :/
Also, the pattern matching allows you to deconstruct values and specify what to test for at the same time. And it's easier for the compiler to generate efficient code out of a switch.
Readability. I'd much rather write code like switch value { case let (x, 1...15, 3) where x == "hi": println("success!") } than if value.0 == "hi" &amp;&amp; value.1 &gt;= 1 &amp;&amp; value.1 &lt;= 15 &amp;&amp; value.2 == 3 { println("success!") }
That's called polymorphism and Swift didn't invent it, but did make it safer and more flexible during the initialization of classes.
I really hope they change that behavior, and make the default Array behave like any other struct. Otherwise that will be a source of many obscure bugs. Imagine you pass an array to a function and forget to copy/unshare. That function almost always appends something and then modifies a few places in the array. It will copy most of the time, but every once in a while it will not, and thus modify the original. Really really scary. If you need sharing, you can always use NSArray. If NSArray has performance issues (no idea, I never used ObjC), they could add another shared Array type that behaves like classes. I think sharing could also be easily achieved by simply using the Array in a class attribute.
Sorry, you're right, I got the reason for avoiding virtual methods in C++ constructors wrong... C++ dispatches to the most complete derived class (since the vtable assigned progressively). This means that you don't get the derived implementation in the constructor – even though you get it everywhere else, potentially leading to bugs not because of uninitialized memory but because the derived method is not called in the constructor when it might casually appear that it should be called. Swift (like Objective-C before it) sets the isa pointer (metaclass used for IMP lookup – i.e. vtable equivalent) at allocation time (before init) so the derived implementations are called, even in the superclass constructor. Swift can't change this even if it wanted to (for compatibility reasons) so Swift's derived-before-super initialization order is required. Incidentally, Swift's initialization order appears to be the same as C# (although C# is less explicit about it and will implicitly assign default values if you don't). http://www.codeproject.com/Tips/641610/Be-Careful-with-Virtual-Method
I think there are pros and cons. The big pro is when your format string has many (think dozens) of arguments. Tracking what matches what is a pain. This is definitely helps for that situation, and it comes up very often for me, at least. The biggest con is that it makes it slightly harder to pass around arguments as a distinct list like you can do in Python. I know this is possible, but I've never actually seen this done in half-way serious code, so I think Apple probably made the right choice here. String interpolation currently doesn't support format specifiers, and this is a huge omission; my guess is that it will be supported soon. 
Is this a real thing? Maybe it's the Scala talking, but typing the rocketship operator isn't that hard.
Kansan here. Can confirm.
 let str = "abc" println(str[0]) // will print a
http://teespring.com/doyouevenswift Let's get some shirts now.
There we go. If we get enough orders, everyone gets one: http://teespring.com/doyouevenswift
Watch the WWDC videos on Swift &lt;-&gt; ObjC interoperability. They explain why String isn't meant to do that. It wasn't obvious so it's worth checking out.
stack it on the heap.
Scott Forstall was the wonder boy of stage presence after Steve but they kicked his ass...
Thanks Apple! Conditionals are finally powerful. 
As of this post, site is down. Mirror: http://webcache.googleusercontent.com/search?q=cache:rOWlIupvFksJ:www.eswick.com/2014/06/inside-swift/+&amp;cd=1&amp;hl=en&amp;ct=clnk&amp;gl=us Edit: Mirror appears to be down.
I'll be sure to check it out, thanks.
i strongly recommend to undersand closures, Am I the only amazes with the power of it and try to avoid boiler plate/snippets?
After digging a little bit, it seems AudioServicesPlaySystemSound asks specfiically for SystemSoundID, and Swift apparently plays hard-ball in terms of strictness of the variable type it wants. SystemSoundID is a typealias of UInt32 and kSystemSoundID_Vibrate is just an Int instead of a SystemSoundID, therefore all you need to do is cast the value to SystemSoundID. In Swift this is done by constructing a new SystemSoundID struct with the value you want like so: AudioServicesPlaySystemSound(SystemSoundID(kSystemSoundID_Vibrate)) This line of code will compile and make the iOS device vibrate.
&gt;Swift (like Objective-C before it) sets the isa pointer (metaclass used for IMP lookup – i.e. vtable equivalent) at allocation time (before init) so the derived implementations are called, even in the superclass constructor. Swift can't change this even if it wanted to (for compatibility reasons) so Swift's derived-before-super initialization order is required. ah, that's a valid point, thanks! 
Cool website. I might have a crack at getting our actual design up there.
No, any Mac from recent years will do. A faster more modern mac will be... wait for it... faster than an older, slower one. That said on an older slower machine the main delays you will see will be in compiling, not in writing code (you'll be the slow bit there) or dragging things around in interface builder I used my 2.4ghz dual core 2008 macbook pro until late last year. build times were slow - id fire up a game of othello and et 2/3rd through before the iOS simulator was up and running. on my new macbook pro its a couple of seconds. More ram can make a difference to machine performance - if you have an older mac buy some 3rd party ram and install it. - on most macs this is an easy user upgrade. I wouldn't con side running the current operating system with less than 4 gigs , ideally a machine with 8 gigs
That's probably most likely. There were a few people at WWDC I kept bumping into at and away from Moscone West.
Give me some good examples of using closures. Kinda confused about it
Indeed as someone who uses C it is fairly common. I'm surprised it's not more common around here, it seems C pops up quite frequently when using objective c and in ios development. Though I do think it is a silly return operator I much prefer how it's done in C or ObjC. Not sure why they didn't just do that. 
www.reddit.com/r/swift/comments/27d8it/eli5_what_are_closures_and_how_do_they_work_in/ - they're great for small stuff like sorting but they can also be used like blocks in Objective-C, e.g. as callback / handler for asynchronous tasks. 
C ordering is unmanageably bad for closures and functions that return functions. That's why all new languages use the Swift approach (C++ uses identical syntax for closure return values).
One of the main Swift features not found in Python or C++ is algebraic data types. Switch statements are more important in Swift than in Python and C++ because they are used for pattern matching on ADTs, and therefore commonly appear in functions that accept ADTs as input.
Very good point. I'll get used to it, I've just only used c and objC, so the changes seem strange. 
Alright guys, we've put together a teespring with the original design. It's nice to be able to offer these way cheaper than we paid for our print run, with the same t-shirt quality. Thanks to everyone who got in touch asking for these. http://teespring.com/officialdoyouevenswift
See http://www.reddit.com/r/swift/comments/27nbl9/any_good_tutorials_examples_on_swift_closures/
Unless I'm missing something, they could have just stopped when they created the `String[]` of arguments, since arrays are iterable already. I agree that sequences, or enumerables, are very useful; but in this case it seems like overkill. Now, on the other hand a sequence that returns lines from a text file (e.g.) one at a time, _that_ would be useful. Final question: does Objective-C have the concept of sequences like this?
Sure he would've.
I'm probably completely off, but are closures just cleaner nested functions? Again, I'm more than likely wrong, but that's what it kind of looks like, especially when it comes to things like .map.
You're not off, that's (almost*) exactly what they are. Closures are essentially function "literals", much like 1 or "hello" are literals for ints or strings. func f() -&gt; Int { return "hello" } is basically the same as this: let f = { () -&gt; Int in return a } if f is a global variable. They even inhabit the same namespace unlike in some languages (i.e. in Swift if you try to declare both of the above in the same scope you'll get an error that you are redeclaring 'f'). What adds to the confusion is that functions declared with the func keyword can "capture" variables, and so are also "closures" in the computer science meaning of the word. A closure is just a function and an associated environment of variables. Apple using the term "closure syntax" to refer to anonymous literal functions is probably going to confuse a lot of people who then try to search for closures on the internet. It may have been a better move to use another term (like block as in Obj-C or Ruby, or lambda). Then again, it's good to be introducing the term closure and forcing people to understand what that means. \* there are some differences, for example a one-statement closure doesn't need a return, but a one-statement func does 
They are blocks of executable code that exist as values you can pass around in variables and arguments. So for example, you can fire off a network request and specify "run this block of code when you get a response from the server".
F# implements the same functionality but the expression is called "match" instead of "switch". This makes it clear that the "match" expression is the main mechanism for pattern matching. http://msdn.microsoft.com/en-us/library/dd233242.aspx
Sorry about that. Done.
Not currently anywhere that I can verify these figures. I believe that it's important to realize that this is public beta 1 for swift. They haven't even nailed down things like method signatures and array behavior yet. So, to bash the language based on benchmarks at this point feels a bit premature.
I talked to a Swift engineer in the #wwdc labs and he said recursive types are high on their list of things to implement.
This is the current state of the language in comparison with Objective-C. When it gets improved, I will research its performance once again.
I heard that tail call optimization is coming. :)
amazing series. Thank you for writing 
[mirror](http://goshdarnclosuresyntax.com/) if profanity is not allowed in URL
Thank you!
I just downloaded the project, and it is set to compile without optimizations, which makes the conclusions not just invalid but a complete waste of time. It has already been remarked by others that unoptimized Swift code is ludicrously slow in comparison to unoptimized Objective-C, but no one would run performance-critical code without optimizations so this isn't a "real world" test.
One important part people in here are forgetting is that closures can capture the current stack. Which means, in the current scope you are in a closure can reference a variable for future use, even when the scope that created the closure is long gone.
I hate typing this stupid thing too. But nothing shows up for me in Key Bindings. Any thoughts? I was thinking that .&gt; might be a good hotkey.
As it says in the post, I did try -Ofast on release builds, it provides some benefit, but swift is still more than 10 times slower than Objective-C in this settings. But with -Ofast you lose: Array bounds checking Integer overflow checking Floating point math becomes more imprecise. This changes the language and it STILL is much slower. It is very easy to disregard other people findings, but the tests show actual performance.
[Direct link to the gist](https://gist.github.com/breckinloggins/d9772f91b615365402e3)
No: you really can't say that these tests show anything like "actual performance" when the numbers you are demonstrating don't use optimizations; the reason it is easy to disregard your findings is strictly because your findings are disingenuous :/. If you built a graph showing the performance of the actually-optimized builds, sharing those numbers and treating them as the important numbers to be comparing, then you would have interesting findings: otherwise it is just some sentence at the end of your blog post saying "I also tried doing the test correctly and it didn't help much". As for the features you are talking about: those are really expensive features; of course the result is going to be slower if you want those kinds of runtime safety features. In the comments on /r/iOSProgramming you act like these are somehow the features that make Swift interesting, but even just from a safety perspective you are discounting that the primary benefits come not from runtime checks but from having a more reasonable type system to avoid errors at compile time :/. If you run these tests with optimizations turned on, you'd see sorting in Swift is twice as fast! You are correct, however, that some of your code still runs slower: I maintain, though, that it is a waste of time to look at how much slower or why it is slower or really pay any attention at all to the unoptimized benchmarks. Regardless, it turns out the issue is just that Swift's String is really really slow. If you modify the Person class to store NSString? instead of String? and modify randomString to return NSString instead of String the performance of your compoundClassTest, for example, becomes essentially the same (and if you want a true apples-to-apples comparison, you must). 
This is a cool example, but IMHO the structure is both foreign-looking and clever. This alienates a class of programmer by increasing the learning curve and potentially encourages gee-wiz solutions that few could replicate. It's probably a standard concern that people have when looking at ML or other functional, pattern-enabled languages. ("It's not C.") Very cool, really fucking hard to maintain and doesn't really make me want to code in Swift.
not if you are browsing from office or some external network. my school network doesn't open any URL which has some banned words like fuck
Awesome. This sounds like a really forward-thinking language in the making! One last question: the docs seem to say that Swift will not incur GC pauses. How is that accomplished? Real-time GC or reference counting that leaks cycles? 
 let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"] func backwards(s1: String, s2: String) -&gt; Bool { return s1 &gt; s2 } var reversed = sort(names, backwards) // reversed is equal to ["Ewa", "Daniella", "Chris", "Barry", "Alex"] The leading four space trick 
Maybe I'm misunderstanding you, but can't you just use the ternary conditional operator? var x = (something ? 1 : 2) I tried it and it seems to work.
Swift is only what ? 2 weeks old ? I'm pretty sure Apple has enough resources, engineers and computer sci guys to be aware of this. Swift is not a language made by some single guy that just released it to the public. A lot of people are behind it, let's wait until swift is available on a more stable release before jumping into the bashing bandwagon. 
You're right--`if` is a bad example. `switch` is a better example.
'It's not C' is IMHO an excuse one can only use for so long while the ML-like features permeate the C-like languages. After a while you get used to them. 'Hard to maintain'--a tradeoff. With sum types like `Expr`, Swift lets you design solutions that make it _impossible_ for the program to be in an error state. You can see this happening already with Swift's Optional type.
I'm not saying these are bad features; it's just a challenge for language adoption. But honestly it's sort of non-discussion as it becomes the default language for authoring iOS experiences.
&gt;Besides, having this key enabled strips certain features from Swift, like array bounds checking and few others, thus it can't really be deemed as a viable solution in production environment. Swift is at Beta 1 and will almost certainly have numerous more betas before it's finalized this fall. Consequently, *nothing* about it makes it a "viable solution in production environments", so you might as well put up the Ofast numbers.
The library doesn't want to pollute the global namespace by defining functions. Can look into modules when that is documented and public ally available. 
Ahh, I see what you're getting at now
Yeah, I've already found this part of documentation, but was surprised that they described at the 'Properties' section.
I agree with you, that's make sense. So Swift requires such stuff (variable initialization) to be done explicitly, without C-style magic.
 sort(names) { $0 &gt; $1 } Does the same thing
Thanks buddy.
Why not use "for s in Process.arguments" instead? Am I missing something? :-)
This question and similar ones seems to come up a lot, so I wrote a [blog post](http://airspeedvelocity.net/2014/06/11/a-basic-tutorial-on-functions-and-closures-in-swift/) covering it.
Your code is incomplete. It's not clear what context the initial block of code is being run in. I'm guessing that you forgot to hook up the `learnToPlayButton` outlet. 
Or, indeed, sort(names, &gt;) 
No it doesn't. If a function accepts a function as its last parameter it can go outside the parentheses 
Like I said, your code is incomplete. If you have a problem with a button and you're creating it in code, then show the code that creates the button.
I did in lines 12-19.
No, none of that creates a button, it just calls methods on an already-existing button. Where did you declare the `learnToPlayButton` variable? Where did you instantiate a button and assign it to that variable? Where did you add that button to the view hierarchy? The code you've posted won't even compile because it's incomplete. if you need help debugging your code, you need to show all the relevant code.
Oh. Didn't know what you meant. https://ghostbin.com/paste/mv6u9
That's a lot more helpful. You seem to be a bit mixed up in what view controllers are. Views are design elements that appear on the screen. View controllers are non-visual objects that handle the mechanics of how views are created and managed. A view controller typically manages one "place" in your application, one screen of content. You have something called `initialLaunchController`, but it's a view, not a view controller. It also doesn't seem to have any purpose - all you do with it is add it to the view controller's view and then add all your other views to it. The cause of your problem is that you add `initialLaunchController` to your view controller's view and use it as a container for all your other views, but you never set its layout, so it defaults to being zero size. Your views are spilling outside of their superview, so you can't interact with them - but views don't clip by default, so they still get drawn. You can verify this with the new view debugger or by setting `initialLaunchController`'s `clipsToBounds` property to `true` - its subviews will then disappear as anything outside of it is clipped. You can solve the problem you are facing by removing `initialLaunchController` altogether - it doesn't do anything. Just add your other views to `self.view` directly. But you really need to get a handle on how view controllers are used to build an application. You seem to be going down the path of confusing views and view controllers and trying to put everything in one view controller then swapping views around, which are mistakes I've seen a lot of newbies make. If you've got two logical screens, you shouldn't have one view controller that swaps the views around, you should have two view controllers that you transition between. Try one of the more common container view controllers to manage this, for instance `UINavigationController`. You will probably find it easier if you use storyboards too - most of these mistakes wouldn't have been made if you weren't going it alone in code.
It was used to organize the multiple screens. And that I need a different view when it is launched for the first time.
You can find an older Mac Mini on eBay if you have access to the extra peripherals needed. That would suit your needs.
I have no extra peripherals which is why I was going the Macbook route.
Here are results with -O3, and with a port of the code to C++ (code [here](http://pastebin.com/E9x8eJrX)). The C++ version is about 5x faster than the Objective-C one. I'd like to hope that Swift could end up more at the C++ end of things just because its generics and stronger typing ought to enable better optimizations. We'll see, I guess. PerformanceTestSwift 0.000 Started tests 0.002 Started array insert test 2.365 Number of elements in array: 100000 2.366 Ended array insert test 2.550 Started dictionary test 13.255 Number of entries in dictionary: 100000 13.255 Ended dictionary test 13.650 Started class generation test 18.750 Number of persons: 100000 18.751 Ended class generation test 18.788 Preluminary work 19.406 Started array sort test 26.993 Ended array sort test 26.994 Ended tests PerformanceTestObjC 0.000 Started tests 0.002 Started array insert test 0.145 Number of elements in array: 100000 0.146 Ended array insert test 0.148 Started dictionary test 0.611 Number of entries in dictionary: 100000 0.611 Ended dictionary test 0.624 Started class generation test 1.555 Number of persons: 100000 1.556 Ended class generation test 1.585 Preluminary work 1.591 Started array sort test 1.691 Ended array sort test 1.692 Ended tests PerformanceTestC++ 0.0000 Started tests 0.0000 Started array insert test 0.0288 Number of elements in array: 100000 0.0288 Ended array insert test 0.0367 Started dictionary test 0.2137 Number of entries in dictionary: 100000 0.2137 Ended dictionary test 0.2544 Started class generation test 0.3161 Number of persons: 100000 0.3162 Ended class generation test 0.3177 Preluminary work 0.3179 Started array sort test 0.3181 Ended array sort test 0.3181 Ended tests 
You can probably get a monitor, mouse, and keyboard for $50 if you ask around a bit... 
You need to set the contentSize of the scroll view to something larger than the current view.
Very nice. 
I'm pretty sure you have to include a `!` after declaring the type for all IBOutlets. You don't need to set them to nil, the bang will take care of that. 
Swift with OpenGL is just like C and Objective-C with OpenGL. All the same function calls will be made. You just gotta put it in swift syntax.
I'm not sure how swift will deal with the fact that OpenGL uses a lot of void* types. I don't know if that will wrap into swift's Any type so well
Even better! Thanks!
Hmm, true. Well, we'll see if I can get it working. I'll try to make a post here if I have any success.
Thanks, excellent contribution, could you make a pull request with c++ code?
Well, as I said in my comment, the code is on PasteBin [here](http://pastebin.com/E9x8eJrX). Feel free to add it yourself if you like. (I also modified my copies of the Swift and Objective-C code not to call the UUID function, since its performance isn't really what we should be measuring, and calling it from C++ would have been a pain.) 
As another has said, Swift can do anything Objective-C can do and the OpenGL code is roughly equivalent. The problem right now is twofold: (1) having a solid understanding of ObjC helps at learning Swift since even though the syntax is very different the backing object model is the same and (2) most example code you will find is in ObjC. What you *do* have going for you is that many examples are really just in-line C code with an ObjC wrapper, so you don't really need an advanced understanding of ObjC to see what's going on.
Although I'm disappointed by Swift's performance here, there is some hope. Here's an example of how good compiler technology can make a difference: Consider this C++11 code: #include &lt;vector&gt; #include &lt;numeric&gt; template &lt;typename F&gt; static int calc(std::vector&lt;int&gt; theArray, int initialValue, F f) { return std::accumulate(theArray.begin(), theArray.end(), initialValue, f); } int main() { int result = calc({10,20,30,40,50}, 100, [](int x,int y){return x+y;}); return result; } This code uses a number of powerful abstractions, including dynamic memory allocators, dynamic arrays, higher order functions, passing closures around, etc. Before a few recent changes to clang, this would have produced this code: _main: 1 0x0000 pushq %rbx 2 0x0001 movl $0x14, %edi 3 0x0006 callq operator new(unsigned long) 4 0x000b testq %rax, %rax 5 0x000e je 0x16 6 0x0010 movl $0xa, _main(%rax) 7 0x0016 movabsq $0x1e00000014, %rcx 8 0x0020 movq %rcx, 0x4(%rax) 9 0x0024 movabsq $0x3200000028, %rcx 10 0x002e movq %rcx, 0xc(%rax) 11 0x0032 movl _main(%rax), %ecx 12 0x0034 movl 0xc(%rax), %edx 13 0x0037 addl 0x4(%rax), %ecx 14 0x003a addl 0x8(%rax), %ecx 15 0x003d testq %rax, %rax 16 0x0040 leal 0x96(%rdx,%rcx), %ebx 17 0x0047 je 0x51 18 0x0049 movq %rax, %rdi 19 0x004c callq operator delete(void*) 20 0x0051 movl %ebx, %eax 21 0x0053 popq %rbx 22 0x0054 retq Which is really pretty good, with lots of inlining performed and pretty low overhead. But now it's _main: 1 0x0000 movl $250, %eax 2 0x0005 retq That's right, two instructions and five bytes of code. It just returns the answer!
Great insight into your thought process, particularly using Hopper to display pseudocode for the IR. Great stuff!
Curiosity got the better of me, so I inserted a couple of nibs intended to hopefully replicate whatever was in the storyboard: https://github.com/lowell/SwiftJson It's based entirely on the screenshot, so it may be missing functionality. It's 3am. Didn't spend any time going over the sources. Anyway, it both builds and runs in 10.9.3 with Xcode 6.
&gt; rocketship operator its called as rocketship operator? TIL!
Yes, that's definitely something you should be doing with view controllers, not views.
Why not "Swifttp:"?
Here's a wild idea...code something!
this is quite interesting... but I thought I should read something about Cocoa also. btw I have been coding with Swift also. I had couple of python exercises and I completed them with Swift.
with Cocoa? I need some beginner help right?
Yes you can, however a basic knowledge of Obj C will help you especially when working in a mixed team.
I am in the same situation. Coming from Visual Studio, I have no idea how XCode works. How can I drag buttons on a window? How can I create event listeners? Does anyone know a tutorial where this is explained?
I'm a complete noob to UI, but I was able to pick up some XCode basics just by looking up some YouTube videos. You can use CTRL + Click to drag elements from the Interface Builder to the appdelegate.swift file. With the elements I've dealt with you can choose 'IBOutlet' or 'IBAction' so that you can either reference their values as an 'IBOutlet' or use 'IBAction' to have something happen on a mouse click for example. Here's a basic Swift GUI tutorial video that helped me get started: https://www.youtube.com/watch?v=REjj1ruFQww Sorry if terminology above is not exact -- like I said I'm new to XCode myself. 
This is what I was looking for. Thank you very much.
Do you? Try jumping right in. There are plenty of resources out there but learning from your own mistakes first vs being babysat through can make a big difference. 
Aren't you basically asking for all blocks to be expressions?
I would agree with you if Swift existed in isolation of Cocoa. But because Swift is meant to be used with Cocoa, and Cocoa makes pervasive use of reference types which in Swift are mapped to implicitly unwrapped optional types they will show up all over the place in apps using Swift. So it's not an exceptional thing to have an unwrapped optional, it's going to be more or less the norm in code using Cocoa, which is going to be a good deal of the Swift code.
&gt; That's just not true. Raw pointers in C are the default. Following this line of reasoning, C++ would be a rather safe language because it actually favours value types instead of references.
You need to know exactly three things about using Cocoa with Swift: 1. **IBOutlets**: They connect UI elements to your code. Open up storyboard and drag in a button. Then open up code and type (right below the class line) `@IBOutlet var theButton : UIButton` Now in your code, hold down Control and drag from your ViewController (the yellow circle at the top) to the button. Select "theButton". Done. Now in your code, you can change anything about the button using `theButton`. For example. in your viewDidLoad, you can do `theButton.tintColor = UIColor(...)`. 2. **IBActions**: They invoke functions when UI elements are interacted with. Type `@IBAction func buttonPress() { println("Button!); }` Now in Storyboard, Control drag, from the BUTTON to the View Controller (opposite of last time). Choose `buttonPress`. Now when you click the button, it will invoke that function. 3. **Segues**: They change views. Make another view controller in Storyboard. Control drag from the first one's ViewController (yellow circle) to the second one's view. Under "Manual Segue" choose "Show". It will draw an arrow from the first view to the second view. Click the arrow, and under the Attribute Inspector in the right column (the 4th icon), give it a name under Storyboard Segue Identifier. Call it `mySegue`. Now in your code for the previous view controller, open up the `buttonPress` function you made earlier, and type this code: `performSegueWithIdentifier("mySegue", sender: self)` Now when you click on the button, it will segue into the next view. That's pretty much all you need to get started. The rest is practice. Some common tips: * Whenever you make a new view controller in Storyboard, make a new Cocoa Touch class and give it the subclass of UIViewController (or whatever your controller is). Then under Identity Inspector (third icon in right column), make it's Custom Class the class you created. You can separate each view's code in these custom classes. * If you subclass something and get the error "cannot find init(coder:)", just delete the whole init function it generated. Otherwise, you will have to implement all the other init functions, which is more work. * Command-click anything to find it's definition. Don't know which functions to implement when subclassing a UITableViewController? Command-click `UITableViewController` and it will show you which ones you need.
If you didn't watch the keynote, you wouldn't know, but they introduced Metal, which is an order of magnitude faster than OpenGL, SceneKit uses that. Metal is basically deprecating OpenGL in the Apple world the same as Swift may replace Objective C, but with Metal it's 100% certainty, with Swift it'll depend on how the next few years pan out whether or not it really replaces Objective C entirely or they coexist.
Do null references in Swift behave as they do in Obj-C, doing nothing and returning null/0? 
Excellent post, thank you for this.
I laughed much harder at that than I should have. Now my coworkers are staring *sigh*
No ... I guess really only for the `switch` statement to be have an expression value.
C++ would be a *safer* language than C because it favors value types instead of references. I can get onboard with that.
wow sir, you are amazing. Thank you very much!
Something like Mantle is much better, where it can load JSON dynamically rather than generate code.
Thank you! Very detailed and exactly what I needed!
How is this in any way bad? The function *explicitly* states a contract that `n` is not `nil`. The caller violated that contract. An exception occurs, catching that violation. Much safer than what happens with a raw pointer, I'd say.
One of my favorite glyph choices in Swift is the exclamation point. No other symbol has such a strong direct line to my fight-or-flight response, which is perfect for how they've chosen to use it. They are not meant to be sprinkled liberally. It's like SHOUTING IN ALL CAPS, Grandma. Don't write your entire email that way. Save it for a moment of need. This essay strikes me as claiming that Rust isn't safe because it has an "unsafe" keyword. Or like Tow-Mater saying "Do not eat the free pistachio ice cream…it has turned".
This is seriously awesome! :)
Exactly – safety is a continuum. C++ (especially modern idiomatic C++11 and the STL) is absolutely safer than C. You could teach a new programmer C++ without even telling them pointers existed and they could use it productively for many tasks, where as in C pointers and pointer arithmetic *are* the language. Java is, most would argue, in turn safer than C++, and hopefully Swift (in its final form) will be safer than Java. But none of them are as safe as they could be, they all sacrifice something for backwards compatibility/usability/performance/mass appeal or what have you.
Two things Xcode has to improve: 1. no need to outlets. If the button is there, it should be accessible from code. Fuck outlets. The same should be true for ibaction. I will fill a feature request right now. 2. interface builder should be fucking visual. I must be able to adjust every parameter of a control, something like photoshop where I can apply textures, gradients, color overlays, every-fucking-thing I want. Having the button on IB and having to adjust its properties on code stinks.
It gets more attention to take a popular thing down a peg with a pushy headline like "No, this thing you think is true isn't true".
Nice article, thanks. Since you asked for "nitpicking feedback". When passing a closure as an argument to a function, there are two more steps in implicit syntax simplification. following step 4 from the article [1, 2, 3].map( { $0 * 2 } ) Step 5. If the closure is the final argument to a function, then the closure expression may be moved out of the argument list. Like so: [1, 2, 3].map( ) { $0 * 2 } Step 6. If the argument list is now empty, after moving out the closure, the parentheses surrounding the empty arglist are now optional and may be removed. We are now left with this: [1, 2, 3].map { $0 * 2 } One great thing about this leaner syntax is that it has a similar pattern to control flow statements like while { }, for { }, etc.
That's part of my problem with implicitly unwrapped optionals as well.
Nice, thanks. Will add.
See also "Swell", my in-development Sinatra-like web microframework, which uses CocoaHTTPServer. https://github.com/breckinloggins/Swell (warning: very much a work in progress, but you can already create Sinatra-like routes) EDIT: I'll take a look at Swifter and see if it would be a more straightforward server backend for Swell.
I am talking about not needing dragging the shit from IB to the header. If it is on interface builder should be created automatically on the header 
But that's exactly what happens in most languages that have nil or null and make no effort to solve the null reference issue. Obj-C is a rarity in that you can call methods on nil by default without triggering an exception. If you're 'solving' the null reference problem then a runtime error of this sort should never be possible because the compiler wouldn't allow the situation to arise. Personally I don't think it's a failure of Swift, as a language feature it is opt-in and having the ability to write code the compiler deems unsafe can be occasionally very valuable. It's more a failure on Apple's part to overuse the feature in Cocoa so that it is no longer opt-in for the average developer. I expect over time this is something Apple will rectify.
The problem is that, to extend your analogy, Apple is the grandma who has written much of cocoa IN ALL CAPS.
I actually don't mind this in the slightest. Objective-C is doing it wrong, Swift's implementation is the right solution. The fact that NSDictionary makes copies of the keys when entering them into the dictionary is a waste of CPU cycles and memory, and it makes creating user-defined classes that can be used as keys more difficult than it needs to be. If your keys are only short strings, then it's fine, but it's entirely possible that your keys are large and heavy objects, and then that behavior is a problem. The answer here isn't to make the language use a less efficient implementation of dictionaries, the answer is to tell to be very clear to the users that using mutable objects as keys will break the dictionary, and that you should never do it. That's what most other languages do. Take Python, for example. Run this little piece of code, which is essentially the same as your Swift code: class Test: def __init__(self, value): self.value = value def __hash__(self): return int(self.value) def __eq__(self, other): return self.value == other.value a = Test(5) b = {a : "2"} print(a in b) a.value = 6 print(a in b) Which prints out: True False Which is exactly as it should be. Most other languages work like this, because this is the right solution to the problem. Objective-C has it wrong, not Swift. 
&gt;There is no harm in making a Swift class derive from NSObject, though it might not always be possible based on a project’s specific class inheritance needs. Normal Swift classes use vtable dispatch, or, iirc, where possible are directly inlined. If you inherit from NSObject then your objects will use message passing via objc_sendMsg instead. This was done specifically for performance, so by inheriting from NSObject you are sacrificing some of the benefit of using Swift in the first place. Now, obviously, a lot of code doesn't have tight constraints on performance, but to say there is no harm is not really true.
Same with C#, if I remember correctly. Most languages require that you only need two methods to use a class as a dictionary key: a hash method and an equality method, and that's it. Objective C makes it unnecessarily difficult by forcing you to also write a copying method, which in some cases is non-trivial to do. 
Same thing happens in python.
It looks as though Python defines Hashable as having the same hash value for the lifetime of an object. *Source: [Python Glossary: Hashable](https://docs.python.org/2/glossary.html#term-hashable)* Following that guideline would avoid this issue altogether. As far as I can tell, there's no documentation from Apple suggesting how the 'Hashable' protocol should be treated or how mutable keys for dictionaries are not defined.
As far as I saw, including by the explosive number of questions on Stack Overflow, the number of tutorials on youtube and others and the number of subscribed people to this reddit in such a small period of time, Swift already kissed goodbye to ObjC.
Just a guess, but iOS and OSX developers?
hello, anybody home? Swift is fucking beta.
How would I put color around the bird?
Yikes. Can implicitly-unwrapped optional types be handled as if they were normal optionals? E.g., class Person { var age: Int! } var p = Person() p.age? += 1 
Very cool, good luck with the effort.
you can extend Xcode Interface buillder use @IBInspectable eg @IBInspectable var color:Float it will be visible as a parameter on the attribute inspector. 
Well, at the moment, they would return "(colour) shape" and "(colour) circle". Missing some backslashes. Also, the method in shape returns the value, whereas the method on circle just prints it. 
There isn't currently any syntax in Swift to call your sumOf function from within your avgOf function. The guidance I've seen from Apple folks on their dev forms is to define another version of sumOf that takes Int[]; you can then call that one both from sumOf(Int...) and avgOf(Int...). This is similar to C's definition of both printf and vprintf (and all the other v* versions of its variadic functions).
Awesome! Thanks for the link. 
programmers and brogrammers alike?
Not only does swift automatically bridge from Cocoa but also from bespoke ObjC code that has been included in the bridging header. For your chosen entityForName method Apple had to choose whether to either automatically create a signature based on the ObjC interface or force you to wait until they had manually created interfaces for every single method of every single class. The ObjC interface merely says that the method returns "NSEntityDescription *" - but certainly nothing to hang your hat on whether it's nullable or not. I must admit I'm also not terribly familiar with CoreData - does that method return null if the entity name doesn't exist? In the absence of the ! notation, the best they could do would be to convert it as NSEntityDescription?, at the expense of making every Cocoa method that returned an object (ie quite a few of them) really irritating to use. The main downside of the ! notation is that they will be locked into it for backwards compatibility - ie changing the entityForName signature from NSEntityDescription! to NSEntityDescription? would be a breaking change. 
~~I'm not sitting in front of my computer but it seems to me like~~ ~~let sum = sumOf(numbers)~~ ~~would be what I would do. Does that not work? Then just simplify your complete function body to be~~ ~~return sumOf(numbers) / numbers.count~~ Edit: looks like my idea doesn't work. Arg. That's what I get for having a Java background.
Not in front of my mac at the moment, but when you first add a swift file to your project, Xcode offers to add a bridging header. Try adding your C declaration into the bridging header and see if swift picks it up.
There's a chapter in Apple's [Using Swift with Cocoa and Objective-C][link] on “Interacting with C APIs”. [link]: https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-XID_13
I'm certainly preaching to the choir, here, but I wanted to write this to remind *myself* that there are just some things up with which Swift will just not put. :)
While these features are nice (same with some of the overloading of some keywords and operators), they make the language a lot less beginner-friendly. Everyone sees the familiar Java/C#/etc. like syntax (mostly dots and parens), and think it's just as simple. I kind of wish they adopted the Haskell syntax even more than they have, as it'd make code much more readable as well.
Yes, you can add a '?' after them.
Cool. But then that solves the problem. Just use option chaining and checking, and you can avoid even runtime errors.
A variadic parameter of type &lt;T&gt; is wrapped up as an Array&lt;T&gt;[] So rather than considering an implementation which places the logic in a function with a variadic parameter, make your base implementation accept an array argument. Then for convenience you may define another variadic version of the function which calls the array version. That way, each of the two following things would work: sumOf([1, 2, 3, 4]) sumOf(1, 2, 3, 4) The two different type signatures of the parameters match the two different sumOf implementations so the compiler can choose the correct one. 
Yes, it does. What I was actually complaining about (though the wording was kind of bad in retrospect) was that Swift makes it too easy to do it :)
OK, I get you 😊 so the thing now is we really need to advocate for the good habit of always checking. That will result in less crashy code.
Swift is meant to replace the C in Objective C...
woah, that's pretty wild.
This is the right answer. The reason you can use C in Objective-C is that it is a super set of C so you're not really "dropping into C" you're "not using the Objective-C extensions". Swift is a new language to replace (or more likely live alongside) Objective-C and does not have any grounding in C so: no you can't embed C in Swift, no more than you can embed Python in Ruby but you can call C code from swift.
In most cases, namespaces are resolved implicitly, so if there's no conflict you can just type `String`. In your case, you actually don't have to do anything special to get `Utils.Foo`. Just create a Cocoa or Cocoa Touch Framework, set the language as Swift, define a class called Foo, and you'll be fine. When used outside your framework, you can type: import Utils let foo = Utils.Foo() https://github.com/modocache/Quick is an example of such a framework. Users may type `Quick.QuickSpec` or `QuickSpec` to create a new spec. I'm not sure about `String`, though, considering it's a builtin Swift type. You may have trouble defining a class called `String` in your `Utils` framework.
There are no namespaces in Swift (as of yet). You can however put classes/structs inside other classes/structs, put protocols must be defined on the root-level of your code.
Confirmed that it works. You need to put the C code in a separate file, but just put the header declaration in the bridge file and you can call it straight from your swift code.
Does beta status forbid running benchmarks?
What exactly is a bug here? Nobody is bashing Swift, I like it, I just wanted to show the performance.
Best thing I've learnt with trying out new languages (and most things in life really) is to just jump in first and try it first hand. Even if you don't know what you're doing, playing around a bit is the fastest way to learn
I wish iBooks had a printing service for authors that had allowed that (like Apple and the Swift series, for example, haha). Sure, iBooks for Mac and iPad is pretty and all, but wading through a total of 600 pages makes me a sad panda. :( I would find it far more convient to have an equally pretty book next to me as I work in Xcode, especially when on my 15" MacBook Pro. I need to work on buying that 24"-27" secondary display...
this is the right answer. 
I don't follow you... are you saying the last example should behave like a shape or a circle?
You need an unsafe route for optimization. The important thing is that Swift gives you the tools to write safe code. The compiler will know enough to lint your code in cases you are not writing safe code. Apple is still trying to write a performant language so you need to also have tools to write high performance code. I think they have a decent design.
Yes, but not the C calling conventions.
Because you instantiate a circle when you type var s : Shape = Circle()
Sorry I misread the article. Then you are right. It seems to behave wrongly
You can print the ePub file saved in your iTunes folder, you can also read it on kindle or another ebook reader like me which is the most comfortable and the simplest way.
Thank you, I will give this a watch! 
Please search before asking questions. Searching this subreddit for `scripting language` or `command line` brings up recent submissions that answer your question. 
Good to know about nested classes. That solves one part of the problem.
Not sure reposting content from Apple to YouTube is a good idea, assuming this isn't an official Apple channel.
I found another quite basic tutorial on swift http://selise.ch/tutorial/swift-tutorial/ DO you think i should give up objective C and only learn swift?
Isn't this just the subreddit equivalent of blogspam? Why not link directly to the article, rather than the submission in your competing Swift subreddit? 
I tried to follow that, but there's an apparently crucial step which I didn't understand: "Just hold control, and then click and drag from the tableview to the “View Controller” object in your storyboard’s hierarchy, and select ‘data source’. Repeat with the ‘delegate’ options." I held control clicked the table and a line appeared, which I dragged to "View Controller" at the top of the screen (in the breadcrumbs), but nothing happened. Also, even if it did work, it wasn't clear to me what this was accomplishing -- why do I need to do this?
No I found a very nice article and I wanted people to see it, but I was not just going to send the direct link. Also I am not competing I would just like people to know about mine. My subreddit is about making apps, asking questions, and sharing your newly released apps. Im sorry for advertising would you like me to add you to my sidebar?
&gt; I was not just going to send the direct link. You should. Links to your own subreddit that are nothing more than links to content is spammy. Don't do this. 
Can somebody explain to me how having the key entries in the dictionary tied to the variable you entered could be useful? It seems like op is complaining for the sake or complaining. 
Article has very strong opinions but fails to distinguish between a functional programming _language_ and a functional _paradigm._ Swift is a functional programming language that enables the functional paradigm but doesn't jump fully into it by default because it still has to interop with existing frameworks. Everyone is free though to write new code in a completely functional style if they so choose. Edit: for proof of Swift programming in the functional paradigm, see [swiftz](https://github.com/maxpow4h/swiftz).
An optional is basically a variable that can either hold the designated type or can be nil. (Correct me if I am wrong) More info [here](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.html#//apple_ref/doc/uid/TP40014097-CH2-XID_1) at Apple's documentation. 
I just sent it to my personal documents kindle mail with the title convert and it's fine, normally though I'd use calibre (I can't now).
This is available on ADC and iTunes.
For this case, entityForName() is documented to never ever return nil. However, here is a function with a similar return signature that can return nil, yet still returns an IUO class func dataWithJSONObject(obj: AnyObject!, options opt: NSJSONWritingOptions, error: NSErrorPointer) -&gt; NSData! My current thinking is most would agree this type should be a normal optional. It would seem implicitly unwrapped optionals could be completely eliminated if every single analog to dataWithJSONObject were converted to a real optional, and every analog to entityForName converted to return just the type, and functions were either assumed to meet their contracts or an automatic verification step was added. But this would have to happen in all objective-c code, everywhere. Then i guess all they are really doing is encoding 'documentation contract has not yet been converted into type system contract'.
Thank you so much for taking the time to write this out. The clouds are starting to part! :)
Jesus. Is this really that useful? Seems like you still have to do a helluva lot of manual work.
The main thing about optionals is that nil is no longer a pointer but a single value which means "there is no value." So, it can be used in contexts where some special value would have to be invented, remembered and documented (does that int value indicate a bad value. Is it 0 or -1 or MAXINT or what? With optionals, just make it an Int? and assign nil for an error condition.
Yeah, pretty uniformed article
Yeah, that demo wasn't very convincing. Not worth having to use/buy Photoshop.
Really depends if you have a lot of designers using Photoshop in your workflow or not. If you are on a team thats heavily invested into CS it certainly helps.
i'm currently using #!/usr/bin/env xcrun --sdk macosx swift -i for swift "scripting". That shebang line allows you to use imports etc in your swift scripts.
This is the [fish shell](http://fishshell.com/) function I use to invoke the swift compiler: # Swift function swiftc begin; set -lx DEVELOPER_DIR /Applications/Xcode6-Beta.app/Contents/Developer/; xcrun swift $argv; end end 
I'm not near my computer right now but if I remember right he actually had it backwards, and you drag from the View Controller to the table view. If I understand right it "links" the view created in the storyboard to your code
I wouldn't call Swift a functional programming language. Swift has better support for functional programming than most (or all?) other mainstream languages, but compared to dedicated functional programming languages unfortunately it still lacks some of the basics. For example tail call optimization. When there is no tail call optimization, you can't traverse big datastructures recursively without your stack blowing up. A functional 'if' is also essential, it is there but only as the awkward '?:' syntax, that becomes very ugly when nesting it. A functional switch is very desirable but not there. Both would be somewhat mitigated if they allowed deferred assignment for let-bindings. For now, you are more or less forced to use mutable variables in some places if you want to keep the code readable.
Can you give any more concrete examples of what you think is wrong with Swift's generics? They're pretty similar to Scala/Haskell/etc.
He's right that Swift isn't functional. Functional programming makes absolutely everything a function and absolutely nothing breaks this except literals. Swift has constants, variables, and various other things. Functional is declarative while Swift is imperative. But it brought many of the useful features from functional into OOP. I don't believe either paradigm is inherently better than the other. It think it's silly to say one is. So I greatly appreciate the mixture of the two that Swift brings.
sudo xcode-select --switch /Applications//Xcode6-Beta.app/Contents/Developer/ then for an interactive REPL xcrun --sdk macosx swift 
They work quite ok for me, can you clarify what you find insane about them? Constraints on Prototypes work like typeclass constraints in Haskell, and are especially powerful in combination with associated types. Much better than in Java, where the actual type gets lost when using generics. They are still limited compared to Haskell though, because they aren't first class and only allow concrete types as type variables. 
I agree with you on a lot of points, but you should be aware that: * TCO is widely believed to be on the way * Recursive enums and structs have been confirmed to be on the way You can have a functional `if`: func iif&lt;T&gt;(condExpr: Bool, @auto_closure thenExpr: () -&gt; T, @auto_closure elseExpr: () -&gt; T) { if condExpr { return thenExpr() } return elseExpr() } And a functional (almost-)`switch`: http://www.reddit.com/r/swift/comments/27mzuo/creating_a_swift_syntax_extension_the_lisp_cond/ci2qcox
Nice, @auto_closure is really awesome. I hope you are right about the TCO. If I remember correctly, it was rejected for Python because you don't get complete stack traces any more, and thus debugging gets harder.
Yes, see this article on how to write small command line scripts in Swift – http://practicalswift.com/2014/06/07/swift-scripts-how-to-write-small-command-line-scripts-in-swift/
I really don't get it. Was all this some crazy way to avoid properly using Xcode and Interface Builder for some reason?
I would begin by outlining the goals of your app. Right now it has two components, an alarm and a clock. The alarm can be broken down into two parts as well: a timer and a responder. Outline the logical actions that your program will take: * User sets an alarm * The alarm creates a timer * The timer creates a responder * The timer calls the responder * Alarm! Here is a [link](http://stackoverflow.com/questions/2313263/get-current-system-time) to a stack overflow discussion on getting current time with NSDate. Here is a [link](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Timers/Timers.html) to apples documentation on timers.
Thanks for the responses. I'll try again tonight and see how I do!
I uploaded it for you: https://www.sendspace.com/file/xletp5
&gt; ... and only allow concrete types as type variables. Are you sure? The author(s) of swiftz seem to think otherwise. See l. 11: https://github.com/maxpow4h/swiftz/blob/63c63fac8c31b27177c20330aa8201a5543eed73/swiftz/List.swift
I mean concrete types as opposed to "type constructors" that haven't received all arguments they need. 'List' is a type constructor that needs one argument, 'List&lt;Int&gt;' is a concrete type. I suppose inside a generic thing with type variable T, even List&lt;T&gt; should be considered a concrete type. A language that allows passing type constructors as parameters to generics is said to have "higher-kinded types". This is how I imagine it to look in a future version of Swift: protocol Mappable { static func map&lt;A, B&gt; (A -&gt; B, Self&lt;A&gt;) -&gt; Self&lt;B&gt; } func mapToAscii&lt;M : Mappable&gt; (thingWithInts : M&lt;Int&gt;) -&gt; M&lt;Char&gt; { return M.map(intToChar, thingWithInts) } While you can define a 'map' function for Array, List etc., you can't currently define a function like mapToAscii, that works with everything in a generic way that has 'map'. In Haskell, the equivalent to Mappable is Functor. You will find Functor in Swiftz, but it's just a empty stub because there is no way to define it. 
There's some stuff I need to do occasionally that you cannot do in objective C as far as I know. Like using handles (a pointer to a pointer). Some older methods that I have had to call in OS X need handles as function parameters, and could not be called from objective C. Also some of my command line tools are better written in C. I quite like objective C for high level GUI apps, but some lower level stuff, or stuff for intensive data processing, would be absolutely horrible to have to write in objective C. The data recovery engine of [this](http://macosxfilerecovery.com) app I wrote would be an example. And also I write kexts sometimes. Kexts are in a subset of C++ that Apple uses. You can also embed straight C into that. Shared code between the user land daemon (which is often required to accompany the kext) and the kext needs to be in C.
Yeah. I'd rather see them work off the dark gray in Half Dome than the orange of the sky.
&gt; Why did they design this instead of just going with the nil route, you may ask. The huge advantage is, that this tells you right away, whether a function may return nil. Imagine calling a method on a objective-c object (in objc) that says that it returns an array. So in your code you're expecting an array to come out. Great explanation here! 
Is there a compiled version i can run on mavericks?
Now this is much more like it. Thanks! I prefer it over https://github.com/toyamarinyon/vim-swift. That one has buggier syntax and highlights every variable name as an identifier so it's way too colorful for my eyes. I fixed that by linking it to Normal instead of the Identifier group but I couldn't see how to fix the buggy highlighting of operators. I also use this makeprg setting if anyone wants: `set makeprg=xcrun\ swift\ -i\ %` Or just do write up an autocmd to run it after a save: `autocmd BufWritePost *.swift :make` Or just run :make manually (or with a new key binding) to run your code. Better yet, if you have dispatch.vim, you can run it asynchronously. 
Nice! I made this because I thought that one was a little buggy as well. I hope to keep supporting it as needed. I'm toying with the idea of integrating this in with a larger plugin that does more for iOS &amp; OS X developers.
Cool, I also like the indenting script in this plugin better, I think the other one didn't intent properly after I hit enter after typing class properties. An omnicompletion plugin for swift would be pretty nice. I'm not too big on vimscript so I'm not sure how hard that would be to implement... Hey, it's already pretty cool that we have 2 swift plugins for vim this early! Imo, Swift is much easier to use with vim than Obj-C was.
Orange of the sky? I see orange from the logo. But I wouldn't mind the contrast improving so its darker, thus easier to read. But I don't think the schema is awful.
Your post inspired me to modify the sumOf to use generics func sumOf&lt;T&gt;(numbers: T...) -&gt; T { var sum = 0 for number in numbers { sum += number } return sum } Im getting an error cant find overload += … How can make sure that T complies to the operator += similar to &lt;T:Equatable&gt;?
Swift needs an is_computer_on() built-in
Sorry, somehow came to reddit assuming there won't be such a question. My bad.
Thanks! Any chance you are the one behind PracticingRuby?
But the behavior of that would be undefined if the computer is not on. :-)
Nope, sorry :-)
Have you tried something like let unwrapperdA = a, unwrappedB = b (I didn't test it), or maybe let (unwrapperA, unwrappedB) = (a, b) ... It's more logical to me...
For example, casting and containers: protocol Foo {} extension Int : Foo {} var a = ["A": 3] as Dictionary&lt;String, Foo&gt; let b = a as Any let x = (b as Dictionary&lt;String, Foo&gt;)["A"] // Works let y = (b as Dictionary&lt;String, Any&gt;)["A"] // Does not work let z = (b as Dictionary&lt;String, Int&gt;)["A"] // Does not work let c = ["A": 3] let d = c as Any let u = (d as Dictionary&lt;String, Foo&gt;)["A"] // Does not work let v = (d as Dictionary&lt;String, Any&gt;)["A"] // Does not work let w = (d as Dictionary&lt;String, Int&gt;)["A"] // Works In Java we could do an unchecked cast here, but that's not possible. What we really want is basically getting a Dictionary&lt;String, ?&gt; then do a dictionary["A"] and handle that result. Let me give a different example. You have class X1, class X2 inheriting from X1 and class X3 inheriting from X1 If you do the default Dictionary creation, you'll always get the exact type, so ["A":["B":X1()], B:["C":X2()], C:["D":X3()]] will make a dictionary which contains three dictionary types: Dictionary&lt;String, X1&gt;, Dictionary&lt;String, X2&gt;, Dictionary&lt;String, X3&gt; What we want is to actually pull out a dictionary &lt;String, X1 or subclass&gt; and then retrieve that X1 or subclass and finally (perhaps) handle X1, X2 and X3 differently. But we don't want to write a separate line of casts for every possible subclass. Because let's say we write a generic extractor, that can extract X1 or subclass by giving a path "A.B". We write this method once, and explicitly handle X1, X2 and X3 cases. Now someone makes a simple subclass of X3 and puts that one into a dictionary. Suddenly we have a Dictionary&lt;String, X4&gt; which we can't in any way recognize and extract. This issue is entirely due to the typing system and the default behaviour of the dictionary constructors. Contrast this to ObjC. In ObjC this problem simply doesn't exist.
You can stick it in a switch. I'd post demo code but the XCode 6 BETA keeps crashing when I attempt to write it out in the playground...
Done :) Sorry I was sick of waiting lol.
:)
Sadly it does not, I was also thinking about using tuples but nope. 
Wouldn't a switch only work as an or statement (if a || b), not as an and statement (if a &amp;&amp; b)?
I cant believe I'm saying this, but there *is* a difference between a library and a framework. Why not call it a platform while you are at it? They are all words!
Switch is and. Even if it weren't, you could still figure out the boolean logic tests to invert it to your needs. Look at page 190 onwards of the Swift book to get an idea of what I think it would look like.
You're right in saying that technically it is a library, but the Xcode project actually exports a framework for you to embed in your own projects, which is why I decided to name it as such
Your probably expect this to work because it does in languages like C# and Java, which suffer from a bad design compromise that is not necessary in a new language. The thing is, you are trying to cast Apples into Oranges. Incompatible types. If collections aren't treated as invariant, your type system is unsound -- if you try to insert something into a Java Array that was casted this way, you get a runtime exception. Java and C# had to do this because they didn't have generics in early times, see http://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)#Covariant_arrays_in_Java_and_C.23 In Swift you would normally use a type variable with constraints to the protocols it should implement, instead of passing around values that have the protocol as their type, which would result in boxed values that have to be unwrapped at runtime. Edit: Reddit doesn't like links with parentheses
Hey, that's pretty cool. I really love Totoro.
Hey, I just updated it and included a binary for Mavericks+. Enjoy :)
I think I get it: Demo: switch (a, b) { case (.Some(let unwrappedA), .Some(let unwrappedB)): let c = unwrappedA + unwrappedB default: ... } /cc /u/TheDroolingOne
Got it, I used the `switch` statement to do it: http://www.reddit.com/r/swift/comments/284f4e/unwrapping_multiple_optionals_in_one_if_statement/ci7k70s But I still think chaining is more idiomatic.
My only complain is about links and visited, I wish they were reversed so visited links were lighter and non-visited more reddish so I don't get confused as to what I have already read. That'd make my day.
 func all&lt;A, B&gt;(a : A?, b : B?) -&gt; (A, B)? { if let a_ = a { if let b_ = b { return (a_, b_) } } return nil } if let (a_, b_) = all(a, b) { let c = a_ + b_ } You could define 'all' for a bunch of different argument numbers. Alternatively with switch and pattern matching: var c : Int switch(a,b) { case let (.Some(a_), .Some(b_)): c = a_ + b_ default: {} // do nothing } Note that normal syntax for Optionals is just syntactic Sugar for the enum cases Some(value) and None.
You need to provide a permissive license, like MIT license, in your git project, so that people can actually use it in their projects. As it is, it has a default copyright (all rights reserved).
The deed is done.
I've outlined a working switch statement here. It will generate warnings though. It is also not perfect, but it's better than nothing for now. Getting rid of the warnings will crash the compiler. See bottom of post. http://appventure.me/2014/06/13/swift-optionals-made-simple/ 
This is as much about semantics as about efficiency -- forcing it either way is not good. You decide if you want reference semantics or copy semantics by choosing class or struct. Swift does it right to allow both as keys, though the compiler should definately emit a big fat warning if hashValue for a class depends on anything else than constant attributes. People that want to safely use classes as keys without reference semantics could always create a wrapper around Dictionary that always copies the keys.
When casting Double to CGFloat, aren't you silently losing precision on 32 Bit architectures?
I agree, programming is like math. You can read all you want, but to actually understand you must do.
How would func foo&lt;T&gt;(x : Dictionary&lt;String, T&gt;) { ... } work? Let's say I construct this: let a = [["A": 1], ["A": "Foo"]] In this case a actually becomes an NSArray. Inside we have a Dictionary&lt;String, Int&gt; and a Dictionary&lt;String, String&gt; How would I build a function extracting values 1 and "Foo" respectively? 
I would go with an Air instead of Pro. There is no advantages a Pro would give you over an Air for programming. 
Thanks for sharing! 
Next make a module to have automatic fallthrough in `switch` statements. :-\
Yeah completion with clang_complete would be ideal. But for now, maybe something like `setlocal completefunc=syntaxcomplete#Complete` would suffice? It's simple but it will allow it to complete using the syntax file from your plugin with `Ctrl-X Ctrl-U`.
Uh that's nasty, stuff like NSArray is alien to the clean generic statically typed world of Swift. It seems that everything you get out of NS* is typed as AnyObject?, you need a lot of casts with 'as' and checks with 'is' to creep through things like that. You should really only use such types when interacting with ObjC code. I think in idiomatic Swift you would encapsulate the Dictionaries in enum cases that indicate the different kinds of Dictionary. At least that's what I would do in Haskell.
I almost wrote a comment preaching about how implicit casts reduce safety and let you discover certain bugs at runtime instead of compile time ;) However, after looking at the code, most of the casts seem quite harmless to me. No truncation of floating point values or anything like that. Probably the whole thing would't be needed if you could change the default interpretation of literals for the current file, so that floating point literals always become CGFloat. Or can you? I haven't read the complete doc yet.
sure...
Got it saved to my iBooks and will likely check every time I need a quick refresh. Considering I'm still doing most of my work in Objective-C for now, it's going to be handy for a while until I make the full transition. 
that's the joke! http://www.haiku-os.org/legacy-docs/bebook/TheKernelKit_SystemInfo.html#is_computer_on
Uh-oh! There's already a library called Swifter; it's an HTTP server written in Swift: https://github.com/glock45/swifter I'm curious as to what would happen if I linked both projects. Surely Swift's implicit namespaces couldn't help me out if the two libraries had the same name(space)?
1. `NSFileManager` has a `contentsOfDirectoryAtURL:includingPropertiesForKeys:options:error:` method you can use to get all the contents of a directory. That returns an array of NSURL's for the folders contents. 2. NSURLs have a `lastPathComponent` property. Chain those two bits of knowledge together to complete the task. 
Thanks that led me to the solution. 
Check out the links in the sidebar under Resources.
Nice
Nice intro to using SpriteKit. 
Good call with many of the right reasons. Now what stock should I buy? :)
6 FPS?
Ah; I was unaware. But how can a voidref point to anything? Or was the link just accidentally relevant?
You can get an Array&lt;Any&gt; by explicitly declaring "a" as such. Still, there's not really any way of casting the dictionaries that "a" contains unless you try each possible permutation of classes as keyType / valueType
Just wondering if experiment 9 can be rewritten as: numbers.map { $0%2==0 ? $0 : 0 } Is there a ternary operator in Swift?
&gt; Ruby’s each is like map, but doesn’t generate any return value that's not true, it returns the original array. 
&gt; Type 1. into irb and hit tab, and it’ll ask you if you want to see all 105 possibilities Nothing happened for me. Edit: Apparently I need "require 'irb/completion' " in my ~/.irbrc file.
&gt; numbers.map { $0%2==0 ? $0 : 0 } Yep, that works! Awesome thanks for the suggestion. Will add it later as a neat possible solution.
&gt; Experiment 10: Add a constant property with let, and add another method that **takes an argument** None of the methods take an argument. Just add one. *( former experiment 11 )
Ah, good point. Though that's possibly to do with ruby's practice of making nearly every statement have a value. Maybe a less appropriate Swift practice (similar to += not returning a value).
The Swift language is essentially in an early public beta right now. You really need to know Objective-C to understand how the frameworks are designed anyway, so you might as well use it rather than a language whose compiler still crashes when it encounters valid constructs in your code.
In the book "Thinking, fast and slow" Daniel Kahneman points out that what a company does matters the least. What everybody else, the competitors do frequently matters more. Apple would be doing really good I think with what they have up their sleeve, but that is without the presence of Samsung and Google. 
Start learning Objective-C now, but check out Apple's Swift iBook once you're comfortable with Obj-C so that you'll be ready as development shifts from one to the other over the next couple of years. 
As you are having written more Swift code than me: How do you like the new language so far?
A friend shared this link with me. My reaction, pasted here: Always fun to measure stuff in pre-release against the established &amp; mature, isn't it. Functor is one of those things that result from a type system that supports higher kinds. This is typically not among the first features added to any language. Haskell and Scala were no exception. You can't create the desired Functor abstraction in Rust yet, either. Same reason. The Swiftz project (very much like the Scalaz library) already has a workaround for the same compiler crash that thwarted the author's lazy stream. Check out their source code and look at the Box&lt;T&gt; class and how it's used in their List type. The same workaround would be required in the lazy stream idea. They also mention that a rdar issue exists for that one. Apple's not as opaque on this stuff as the author makes them out to be. A casual attention to the forums turns up what they're looking for. Lazy generic sequences are specifically mentioned in the listing for the standard library engineer position. http://lists.cs.uiuc.edu/pipermail/llvmdev/2014-June/073669.html
I would suggest learning ObjC and read the Swift book afterwords. I can suggest the iTunes U course to learn ObjC as a PHP developer myself. 
Device or simulator? I also guess the -Ofast optimization is not activated in the build setting?
Which course did you do? I've looked through a few and haven't found one that I really click with.
I was in the same position you are a few weeks ago and opted to take the Swift route. What swayed my opinion in the end was thinking about the countless hours I'll surely spend debugging and frankly, Swift seems easier on the eye (coming from a Java and PHP background). Plus, both languages are interchangeable so choosing either one to start off with will result in the same outcome.
I think my only issue with Swift is the readability. I seem to be one of the only programmers that really loves the verbosity of ObjC. It reads almost like prose and I love it. Swift will never quite have that.
https://itunes.apple.com/au/course/developing-ios-7-apps-for/id733644550 - Make sure you do ALL the assignments, and take your time. Don't skip anything. Don't work ahead of the video's. Just follow it along as you would in real life. Enjoy!
https://itunes.apple.com/au/course/developing-ios-7-apps-for/id733644550 - Make sure you do ALL the assignments, and take your time. Don't skip anything. Don't work ahead of the video's. Just follow it along as you would in real life. Enjoy!
Pretty good but the variable naming and overall code formatting made me want to jump off something
Thanks!
Things are going to Swift, and you will need to eventually learn it. However, it's extremely early days for the language, and you will need to know ObjectiveC even when you do tackle Swift. http://www.bignerdranch.com/blog/ios-developers-need-to-know-objective-c/
Awesome. Thanks for that! It's been corrected.
&gt; You really need to know Objective-C to understand how the frameworks are designed anyway, I've seen this mentioned a few times but I don't get it. The design patterns used in any framework are language independent. If you understand the patterns in Swift why would you need to learn Objetive C? (As long as the samples and docs are in Swift too)
I haven't used NSFileManager yet, but wouldn't it be better programming style to use NSURL with fileURLWithPath so one could use stuff like URLByAppendingPathComponent, lastPathComponent and pathExtension etc.? 
Hm, wanted to write this as my first SpriteKit and Swift App. :( I guess I'll have to try something else now.
If you call it without any block, then #each returns an enumerator instead of the original array.
If you're doing anything but the most trivial sample app, you will eventually get to a point while debugging where you will need to know Objective-C. If you had learned it first, you wouldn't then be scrambling to learn it.
Just out of curiosity why do you need to init the gesture recognizer prior to super.init? Couldn't you just as easily call it after or is there a subtlety I'm missing? Edit: Sorry, just realized that you were calling the frame in your super. However, back to my original question, is that necessary?
Just out of curiosity, what did you want valueForPath to do? It sounds XML-ish. The book has a Container protocol with an "associated type" and they make Array conform to it with an extension, which sounds frustratingly similar to what you were attempting. But your case probably needs two associated types (for key and value) so I can see it falling apart quickly.
&gt; from what I've read message forwarding seems like a really bad idea Message forwarding (and related techniques that fall under the umbrella of "higher-order messaging") are the foundation of a ton of Cocoa technologies, including NSUndoManager, NSProxy, Key-Value Observing, and dynamic Core Data accessors. All of these rely on the language's ability to convert message sends into NSInvocation objects. Because this is expensive, Apple has added some faster paths that don't build the entire invocation but let the class provide a new target (`-forwardingTargetForSelector:`) or dynamically choose an implementation (`-methodForSelector:`). But really, let's come back to your initial statement. You said "The design patterns used in any framework are language independent." I don't see how you could actually ever think this to be true. Yes, all languages are Turing-complete, but how could you not think that frameworks hew to patterns their languages make simpler? Objective-C doesn't have generators. Python makes it really simple to write a generator using `yield`. Therefore a lot more Python frameworks expect to receive generators as function arguments, while Objective-C frameworks typically accept `NSArray`s. Likewise, C# has `async` and `await`, so concurrency is built upon `Task&lt;T&gt;` and managed by the standard library. Objective-C doesn't have that, so frameworks take libdispatch queues as explicit arguments. The Objective-C language spec doesn't mandate garbage collection. Therefore the frameworks have method for explicit memory management (to the point where Core Foundation classes can take custom allocator objects). These are entirely absent from frameworks written in languages with managed memory like C#.
Move your setup to `-viewWillMoveToWindow:`?
Experiment 8: How about returning a double instead! func average (numbers: Int...) -&gt; Double { var sum = 0 for number in numbers { sum += number } return sum / numbers.count } or even crazier, use the `reduce` method and make the whole function one line. return Double(reduce(numbers, 0, { $0 + $1 })) / Double(numbers.count) 
Expirement 14: The inner loop would be better expressed without literals for y in Suit.Spades.toRaw() ... Suit.Clubs.toRaw() { if let convertedSuit = Suit.fromRaw(y) { self.suit = convertedSuit stringTogether = "\(stringTogether) \(self.simpleDescription())" } } 
if its just a text, wouldnt it easier to use Core Data? 
theNamingSchemeForAllTheVariables makes thePersonViewingTheVideo want to jump off of theThingTallEnoughSuchThatJumpingOffIsFatal.
declare (see the ! at the end) let gestureRecognizer : UITapGestureRecognizer! then initialize the gestgestureRecognizer after call to super.init 
My biggest problem with Generics right now is that it is so easy to crash Xcode or the swift compiler. Even the smallest experiment goes boom.
&gt; I don't see how you could actually ever think this to be true. Because a pattern is always language independent. That's why it's called a pattern, even if it's only used by 1 language. True, not all patterns are used in all frameworks, not all patterns are implemented equally in al frameworks, and not all languages are able to use all patterns. For example you can implement the [delegation pattern](http://en.wikipedia.org/wiki/Delegation_pattern) in pretty much any modern language, but it's implementation is different in C#, Objective C, etc. Likewise, you can't implement a class in JS because the language doesn't offer that functionality. But, the idea of a class or delegation is effectively independent of any programming language. We can speak of or think about a generator or garbage collection independently of language, can't we? http://en.wikipedia.org/wiki/Garbage_collection_(computer_science) http://en.wikipedia.org/wiki/Generator_(computer_programming) Similarly if someone wanted to implement message forwarding (which originated in SmallTalk) in another language it could be done. Although honestly I fail to see why would anyone want to do this. Like you say, even Apple has abandoned that pattern in Swift.
I think there is a gold rush for creating good content for teaching Swift. Write some good books or articles and you can probably capitalize on it. 
Nope. 1. iOS jobs don't require "knowing Swift", they require knowing how to develop an iOS application, so there won't be special "Swift jobs". It's a mistake to market yourself as a single-language programmer. 2. Learning the language is the smallest part of iOS development, the biggest is Cocoa. Any iOS developer worth their salt will pick up a new language in no time.
Been writing iOS apps for 5 years, been spending as much time as possible post keynote on Swift. You're going to have a bad time starting with Swift. Xcode is not ready for Swift and the compiler is also not ready for production. Crashes and incredibly non-performant code is going to drive you off a cliff. I am confident that Apple will fix these things. But if you're wanting to ship anything anytime soon I would highly suggest sticking with pure ObjC for now. 
I was under the impression you could use any/all of them. You can browse emoji using the character browser you can turn on in the language preferences pane.
Cool thanks :) 
Let's do it!
I'm also new to iOS development. What I've been doing is following current iOS tutorials written in Objective-C and writing them in Swift. It's helping me learn both languages at the same time!
While knowing Swift is not a requirement for iOS work now it is certainly the future of iOS work. There will come a day when it will be a requirement for virtually all iOS work. I agree with both points made by rsqrt, and I don't think there will be a swift gold rush, I do think it is necessary to learn Swift if you are working on iOS or mac apps. If there is any sort of gold rush around Swift it will be in teaching it, code conversion tools, a JVM implementation (if that is even legal), and various supporting tools and libraries.
Simulator. How much does it give on an iPad?
Give a string "a.b.c" and return the value of dictionary["a"]["b"]["c"] wrapped as an Any? (If the value exists, return it, otherwise return nil)
I'm surprised that he went so terse on `theFileName`, and it wasn't `theFileNameForTheFileThatIsBeingSaved` Expressive names are important, when necessary, this is just absurd. 
If you save more information on a regular basis, then, of course, taking CoreData into account is valid point. However, this is just a very quick tutorial on how to use NSFileManager; CoreData would be a different topic.
Well, this is more a discussion about whether blond is better than brunette. This is also quite a personal thing whether someone likes it more expressive or not; hence, preferring longer, more expressive terms for any variable does have zero impact on the app performance or on the overall code quality. To the contrary, it is absolutely clear what the variables' jobs are. Calling it "absurd" is an opinion, such as I do not like blonds, because brunettes look better.
I think there is already a land grab going on for tutorial blog posts (SEO link juice), StackOverflow karma and rewrites of existing libraries.
You can do it either way. NSURL is also an option, but for this tutorial, it was not the focus. It should only be a quick tutorial on how to use it to get the basics of the NSFileManager. Of course, there are many more combination possibilities. Please remember, it is more for beginners to get a glimpse of how to use the NSFileManager.
Thanks :) 
There is the concept of cognitive load. If you have 2 identifier names, each of 20 characters in length, but only differing by 1 character, this is going to be hard code to read. It's on of the reasons why swift has been designed to infer enum types from Cocoa, they were getting too long and unwieldy. Consider: * `UITableviewCellCheckmarkAccesoryTypeStatusStateOn` * `UITableviewCellCheckmarkAccesoryTypeStatusStateOff` vs. * `.Off` * `.On` Contrived examples, but you get enough 20+ character identifiers, and it may as well be. It's the same reason people don't like trying to read a wall-of-text, and prefer well formatted paragraphs. We need the whitespace to aid in comprehension. Prefixing every identifier with 'the' is redundant, and just noise, it doesn't help anything, in fact, it hurts as all the identifiers start to look the same. 
This is the ideal way. Msg me if u would like a code example op.
Here, this discussion was about "expressive variable names." The particular prefixes and which one should be used or considered to be "noise" is a different topic, which is also quite subjective. Being more expressive also helps a lot the people who are not familiar with new concepts and, to the contrary, helps extraordinarily. Hence, using the same "formatted paragraphs argument" is exactly what it does, because we format it in a certain why, such as indenting certain texts. I understand the reasons for using shorter naming conventions, but everything boils down to personal preference. In cases such as these, personal preference is always about "I like and I don't like" and not about what is correct or incorrect. In addition, my personal opinion, and I would like to highlight it clearly that it is my personal opinion, I do not think it helps using infer enum types, I prefer the Objective-c style as it was more explicit.
I highly recommend looking into some of the core human factors information currently available. One of the tenets of current understanding is that people don't like to read. While we *are* talking about a programming language here, the core aspect still applies. What helps the most is small and succinct examples to follow, expressive identifiers are going to help in a much more complex environment, but they are something of a distraction if what you are trying to do is teach someone who is not familiar with the basic system. Short and distinct things are much easier to keep track of (mentally) than long explanatory ones, and as all things in programming are really symbols, it's important that this cognitive load be as light as possible.
Yes, it seems this is the way. Thanks!
yep. Job adverts "Required 10+ Years experience with Swift" coming this fall!
Going to the second controller you simply add a property to the second controller and set it. So var stringy : String on the second controller and do secondViewController.stryingy = "hello". Going the other way (from second to first) you implement a delegate with a protocol on the second and set the delegate to be the first controller. secondViewController.delegate = self // self being the first controller in your code above Then your first controller implements the protocol and your second calls self.delegate.method("hello to you too") to send the message back. While I'm at it, if you're coding a UI app I recommend using storyboards if you aren't already and use the seque callbacks to give data to your second view controller rather than create it manually. Creating a master/detail project should set all of that up for you and you should be able to look at the code to see how they transfer data to the detail view controller. 
I think the point is that the need for iOS developers will dictate the need for "swift" developers. You can't be an OSX/iOS developer without knowing ObjC and you will need to learn Swift now as well. Will swift somehow create jobs outside of iOS/OSX? Probably not. There's a ton of languages out there, most of them quite bad, but it's not languages that creates jobs but frameworks and the likes. It's node and rails, not javascript and ruby, that created the jobs. As nifty as swift is, trying to develop in it feels clumsy when I paid it with Cocoa Touch. A lot of the ways you solve problems elegantly in ObjC turns into trying to coax swift into somehow get the type of objC class you are referring to. I've found data structures (from json for instance) and nsdata to be a pain to deal with in Swift. This might change with time, but I feel that swift isn't ready for prime time yet. Maybe it will be by the time iOS9 hits. 
Or hit cmd+ctrl+space in a text field in 10.9+
Umm it's using the values hash to map, sounds perfectly sane to me, hashing a reference would just be silly.
Thanks. I was looking into writing the simplest base case of a text editor and data persistence always is missing from the example and TextEdit is far larger than what I was interested in implementing. I'll have to look at this more in depth tonight. 
&gt; Longer, more expressive naming has no side effects whatsoever. Is that true? How many slots are there in the working memory capacity of the reader? Do all possible identifiers occupy the same number of slots, or do some of them occupy more than others? Do the identifiers that you choose impose intrinsic, extraneous, or germane cognitive load? If it's not intrinsic, wouldn't you want to minimize the load? http://en.wikipedia.org/wiki/Cognitive_load_theory#Types
you said it all!
There will be an obvious influx in job postings most likely. This tends to be the case whenever a new technology comes out. Though there will be a lot of iOS developers converting over also. Like others said it's not really about the syntax that's difficult about learning iOS/OSX development, but more-so how to leverage and make use of the many libraries.
Submit a bug report to apple. This kind of thing needs to be possible. It's used often enough in ObjC
It's not a bug. An implicit unwrapped optional is the solution. See other comments. 
There's no better way to report something like this. It's not a bug but it really shouldn't be impossible to initialize variable using self. Using an implicit unwrapped optional is bad because it becomes possible to the value to be nil, which will cause loads of problems
I agree but I'm assuming most bugs and errors to be fixed by the time Apple releases Xcode 6 (which should be around November?).
I think that since Swift provides Array.map, it should provide Array.each, so that more concise iterations can be written.
They're typically good about that, but this is the first time that they've released an entirely new programming language. Objective-C has been around for over 30 years... There will be unforeseen issues in Swift for a number of years. That's not to say you shouldn't learn it. It is the future language of the platform and Apple is heavily invested in it. I am just trying give warning that you're probably going to have a worse time learning with Swift than ObjC at this point. There are a TON of resources for learning iOS development with ObjC right now. There's hardly anything for Swift and no one really knows what they're doing yet to help you out. 
I think global variable of let is like constants. 
http://en.wikipedia.org/wiki/List_of_Unicode_characters
Awesome post. Working on the challenges and will post my solutions up tomorrow.
Nice idea. Line 19 should be using `windowRect` While this is good for just seeing a window, it might be better to use constraints for placement so people can get in the habit of doing the right thing when designing layouts.
Thought this was interesting because of all the speculation on how industry sees Swift at the moment. AT&amp;T will be offering internships based on this program, where the core courses use Swift, and elective courses are described as: "Master the craft of creating graphic- and animation-intensive apps or learn to maintain and rewrite apps developed using Objective-C." **TL;DR** Objective-C will only be taught enough to maintain apps and to understand enough to rewrite legacy apps in Swift. Apparently will start by fall at the earliest but the press release is vague on which program(s) will start in the fall.
It doesn't matter when you add them. You can even add and remove them depending on the view's needs. IBAction is used for wiring actions in Interface Builder (i.e. IB), so you don't need an IBAction. 
I've been searching around and have been unable to find any examples written in swift. Can you show me in my code what I need to add for UITapGesture? 
As is to be expected! Just wanted to make sure it wasn't my install of the beta. Wonder what's causing it. Thanks for checking!
Setting up the tap gesture: override func viewDidLoad() { super.viewDidLoad() Image.image = UIImage(named: "Image.jpg") Image.userInteractionEnabled = true Image.addGestureRecognizer(UITapGestureRecognizer(target: self, action: "buttonTapped:")) } Changing the way buttonTapped: works func buttonTapped(sender: UITapGestureRecognizer) { if (sender.state == .Ended) { println("worked") mediaPlayer.stop() mediaPlayer.contentURL = NSURL(string: "/Users/User/Downloads/sound.mp3") mediaPlayer.play() } } Edit: Usually when you want have a view tappable (like a button) you use UIButton instead of UIImageView. UIButton has the ability to display an image and gives you basic target/action pattern event handling built in without having to use a UIGestureRecognizer
In the FAQs it says a "nanodegree" can be $200/month, is this going to be worth that amount? It feels more legit since ATT is shown there but what exactly do they have to do with it?
I'm not sure how the MediaPlayer framework works entirely as I've never dabbled in it, but for files you cannot use /Users/User/ etc as iOS apps are built into a sandbox. In iOS your app only has access to certain directories in your sandbox, and the files you add to your app bundle. If you add a file to your app bundle (for example, dragging a sound file into Xcode) you can use NSBundle.mainBundle().pathForResource(...) (you can look up the API details) to get a path to the sound file during runtime. NSURL also has another designated initializer to create a file path URL (prefixed with file:///) which you will use in conjunction. 
[**@merowing_**](https://twitter.com/merowing_): &gt;[2014-06-17 11:21:04 UTC](https://twitter.com/merowing_/status/478859871920877568) &gt;You think Swift immutability / mutability diff between Array and Dictionary was annoying? This.Good fucking riddance. [*pic.twitter.com*](http://pbs.twimg.com/media/BqVAhChIgAAmJkc.png) [^[Imgur]](http://i.imgur.com/RZ176HI.png) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/28d1nk%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
For readability, four leading spaces (in markdown), will format the text as code. http://markdown-guide.readthedocs.org/en/latest/basics.html
This is a small project I'm working on with Swift and Spritekit. Similar to the Crayon Physics game, whatever you can dream up will become a physics object in this world. There are still a few bugs I'm working out (mainly with certain shapes having strange physics bodies), but I'm really happy to see the improvement over the older iteration of Spritekit as what I've done in this video wasn't possible 3 months ago. Once I work some more bugs out, I'll put the source here so that the more creative types can do something cool with it!
It's a pattern Apple uses itself in the Swiftbook. So I guess it's a well considered decision. 
Very cool. Can't wait to see the whole source for this. Was it hard to implement?
My understanding of what this is showing is that: 1. Arrays as values of a Dictionary are immutable 2. Copies of those arrays are mutable, but don't affect the array it was copied from Can you still replace the value of dictionary["this"] with a new array?
All in all, it's about 80 lines of code. A lot of it is just manipulating SKShapeNodes to do what I want! The biggest problem comes in with how SKPhysicsBodies are treated with SKShapeNodes. There is still some pretty buggy behavior that I try to counteract, but in time I hope to have those ironed out as well.
1. That's how it looks like, but is that documented somewhere so that this is expected behaviour? because in docs it says "copy behavior for a dictionary’s keys and values is the same as the copy behavior for a structure’s stored properties" Yeah you can replace whole sub-tree, but that means it's going to be worse performance and way more code to do such a simple thing.
I don't have access to a Swift playground right now, but I'm going to guess that array literals within dictionary literals may be interpreted as constant/immutable by default. There's a performance boost, after all. It'd be interesting to see what happens if you initialize the dictionary without literals, or by using initializer syntax for the arrays (`Int[]()`). If it is a consequence of using literals, there might be syntax in the future for explicitly making them mutable.
I finally grabbed Xcode 6 and toyed with this for a while. I couldn't get the array values to behave as mutable, even if I tried type casting on the last line. It does work fine if you wrap the array struct in a generic class, though, something like this: class ArrayClass&lt;T&gt; { var store: Array&lt;T&gt; = [] init (_ initial: Array&lt;T&gt;) { store = initial } func append(val: T) { store.append(val) } subscript(index: Int) -&gt; T { get { return store[index] } set (newValue) { store[index] = newValue } } } var dictionary: Dictionary&lt;String, ArrayClass&lt;Int&gt;&gt; = ["this" : ArrayClass([1, 2]), "sucks": ArrayClass([3, 4])]
Great show, I can recommend to use the PODLOVE Publisher http://podlove.org/podlove-podcast-publisher/ (a wordpress plugin) to publish your podcast. It's a really good tool and will help you to simplify the whole process of publishing your episodes :)
yeah, I did play with custom class/struct as well, good call. I hope they make it supported natively (or at least consistent between collections) before official release.
Publishing benchmarks for beta software is beyond irresponsible.
Awesome will check it out. If you know of any tools that will make the process of podcasting a lot easier, I'm all ears.
I believe you mean to comment this on the main section
Yep, apologies 
That goes against what was stated in the Keynote and in documentation. Apple wants you to code in Swift. 
You can chain specifications like this: /* This specification checks these contraints 1. the string must be all digits 2. the string.length must be between 2..4 3. the string must not contain two zeroes */ let onlyDigits = CharacterSetSpecification.decimalDigitCharacterSet() let between2And4Letters = RegularExpressionSpecification.pattern("^.{2,4}$") let twoZeroes = RegularExpressionSpecification.pattern("0.*0") let spec = onlyDigits &amp; between2And4Letters &amp; !twoZeroes XCTAssertTrue(spec.isSatisfiedBy("42")) XCTAssertTrue(spec.isSatisfiedBy("0123")) XCTAssertTrue(spec.isSatisfiedBy("666")) XCTAssertFalse(spec.isSatisfiedBy("ice")) XCTAssertFalse(spec.isSatisfiedBy("too long")) XCTAssertFalse(spec.isSatisfiedBy("00")) XCTAssertFalse(spec.isSatisfiedBy("1010")) 
And in other news...the new/next beta is out. It will be interesting to see how much things have improved since the first beta.
Sandbox? You mean Playground? (BTW the Playground is not sandboxed, see the release notes) 
That's funny, I've made the same mistake already, and I didn't even notice that the headline got it wrong. I think it must be years of making little disposable projects called "playpen", "sandbox", "playground"… I can't wait to go download! *Edit: I don't want to jinx myself, but Playground would have crashed on me a couple times by now. I couldn't find any specific mention of fixed crashers in the release notes, but it seems better so far.* *Edit 2: Hours later, still actively using the same Playground sheet, and not a single crash. I'm very pleased.*
Is there some way I can subscribe to a feed in Downcast on my iPhone? I searched for "SwiftCast" and found one, but it's a podcast dedicated to Taylor Swift. (Come to think of it, how long do you think we'll have to wait for some irate blogger to come up with a linkbait headline about "breaking up with Swift"?) In case anybody missed it, the roundtable-talk that the Debug podcast did after WWDC ([Episode 38](http://www.imore.com/debug-38-wwdc-2014-developer-roundtable)) might be interesting to folks here. They talk a lot about their first reactions to Swift.
We have an rss feed at http://www.swiftcast.tv/podcasts/index.rss
One can hope... The playground crashes were super frustrating.
Thank you. I had never added a podcast to that app manually before, but I figured out how. Worked like a charm!
Maybe Swift is still a Beta...
Doh! Yeah, Playground!
In relevance to the video on the page, I personally feel like the prediction bar makes typing a lot slower. For me, having taken countless typing tests for college, 80 words a minute on a desktop keyboard makes me wish we could just disable the prediction bar entirely. Not to mention how many graphical glitches it causes, such as the UIScrollView can sometimes get caught behind the prediction bar. I'm sure it'll be fixed eventually, but I still wish there was some way to disable the bar.
Does ios8 perfect pixel run smooth? Would like to test the wheels idea from wwdc
Awesome, glad to hear! I'm still learning how to do the whole podcast thing.
From what I've seen, it runs fairly well. Of course, the more physics bodies you have that use it, the more expensive it all becomes. What I'm using above is actually a combination of SKShapeNodes and SKPhysicsBodies that use CGPathRefs as their "outline". The pixelperfect method requires a premade sprite which I can't have since the user will be drawing the shapes in real time. 
The Scene as a whole is about 80 lines. The parts that take care of the drawing and such account for about half of that. I've always been a concise coder, but Swift lends itself well to writing fewer lines. In objective-C, some things became unreadable if you tried to squish too much into one line. Swift is much more readable and thusly, you can do 3 or 4 things in one line and still maintain "self-documenting" code. 
I'm running into the same issue! It used to work just fine in ObjC. Seems weird. Reporting in Radar. For the time being, you can declare the outlet as a UIView (or whatever superclass you're using), set the actual object in IB to your subclass and cast it when using a subclass method. Crappy solution but should work. Update: I found that dragging a new outlet from IB into the .swift (using the Assistant Editor) works as well. Better solution than casting it every time :)
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Worms (series)**](https://en.wikipedia.org/wiki/Worms%20%28series%29): [](#sfw) --- &gt; &gt;___Worms___ is a series of [artillery](https://en.wikipedia.org/wiki/Artillery_game) [strategy](https://en.wikipedia.org/wiki/Strategy_game) [computer games](https://en.wikipedia.org/wiki/Video_game) developed by British company [Team17](https://en.wikipedia.org/wiki/Team17). Players control a small platoon of worms across a deformable landscape, battling other computer- or player-controlled teams. The games feature bright and humorous cartoon-style animation and a varied arsenal of bizarre [weapons](https://en.wikipedia.org/wiki/Weapon). &gt;The game, whose concept was devised by [Andy Davidson](https://en.wikipedia.org/wiki/Andy_Davidson_(game_designer\)), was described by the Amiga gaming press as a cross between *[Cannon Fodder](https://en.wikipedia.org/wiki/Cannon_Fodder_(video_game\))* and *[Lemmings](https://en.wikipedia.org/wiki/Lemmings_(video_game\))*. It is part of a wider genre of turn-based [artillery games](https://en.wikipedia.org/wiki/Artillery_(computer_game\)) in which each player controls characters who duel with [projectile](https://en.wikipedia.org/wiki/Projectile) weapons; similar games include *[Scorched Earth](https://en.wikipedia.org/wiki/Scorched_Earth_(video_game\))* (1991), *[Gorillas](https://en.wikipedia.org/wiki/Gorillas_(video_game\))* (1991) and *[Artillery Duel](https://en.wikipedia.org/wiki/Artillery_Duel)* (1983). &gt;==== &gt;[**Image**](https://i.imgur.com/l0jV0c1.png) [^(i)](https://en.wikipedia.org/wiki/File:WormsLogo.png) --- ^Interesting: [^Worms ^3D](https://en.wikipedia.org/wiki/Worms_3D) ^| [^Worms ^2: ^Armageddon](https://en.wikipedia.org/wiki/Worms_2:_Armageddon) ^| [^Worms ^\(1995 ^video ^game)](https://en.wikipedia.org/wiki/Worms_\(1995_video_game\)) ^| [^Worms ^Armageddon](https://en.wikipedia.org/wiki/Worms_Armageddon) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ciaeijh) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ciaeijh)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
That has since been added.
Oooo! What you said made me wake up with a new idea! I changed my project so that I turn the SKShapeNode into a texture, use that texture to create a SKSpriteNode, then I can use the "Pixel Perfect" technique to create a better physics body. It's working wonderfully, but the pixelperfect guys slow down the simulator quite a bit. I'll need to get iOS 8 on my wife's iPad to test. You probably didn't mean to, but thanks for reminding me about that! 
This is a Cocoa topic, you might be better served asking on Stack Overflow.
I will learn all the code samples in xcode. 
They don't magically connect. You have to connect them. The UIPageControl tells its owner its value changed. The owner tells the UIScrollView to go the correct page. The UIScrollView's tells its owner that its contentOffset changes. The owner tells the UIPageControl a new value. So, the owner has IBOutlets for the for the UIScrollView and UIPageControl. so it can tell them. It's the UIScrollView's delegate, and the target of the UIPageControl's valueChanged method. (addTarget 's in the UIPageControl's superclass UIControl.) Got it?
Right now, Swift is far too poorly performing to replace Objective-C for any serious software. Apple badly misrepresented the reality of its performance at WWDC which I think was kind of shameful. It has all the potential to be improved over time, sure, and maybe someday it will be a choice language for user space apps. I think if it can progress to maturity at a reasonable rate, that Apple would love to dogfood it for as much work as they can. It's too hard to predict that today, though.
I've started using the dragging into the assistant editor approach. It seems to mostly work OK, although I've found some instances (such as trying to add touch events to a custom view) where it still doesn't seem to work. There's a few of these kinds of niggle at the moment - today's is LocalAuthentication not seeming to even compile when you're using the emulator - but I guess that's exactly what you get for playing with an early beta.
Any chance you'll post the code online? On GitHub or the like. I'm really interested to see the code behind this in Swift.
Ohh I thought you were doing that way already, did not read your first comment. Its the way I would do it in cocos2d. Test it in devices and tell us how it goes! I dont remeber very well what I did in box2d, but I always had prpblems wirh joints in a game with the cut mehanism like fruit ninja, Thats why Im going to try out this feature
that's pretty neat!
Pretty much! As long as you have an image with alpha where you want the physics barrier to be, you can have SpriteKit make a physics body using that image. You can even give it an alpha threshold, basically a minimum alpha value that it will look at when considering what pixels to use to make the physics body. 
Yep! Once I iron out the bugs and comment the code with tips about some of the trickier parts, I'll release it. Would it be more beneficial to create another post or just put it here in the comments somewhere? 
Why not both? :). Create a new post, and link to that from a comment in this post.
I don't get it - why we *must* choose between Swift and Objective C? Yes, for JSON parsing dynamic language will always be better fit (and it's... interesting how the author carefully choose an example where ObjC dynamism works in favor of the solution) . But there's situations where Objective C verbosity is just plain awkward, and there's situations where having a strict static language works for the programmer. Swift is here to stay, but Objective C doesn't go anywhere. Does anyone really think that Apple will rewrite the whole OS in new language? Or that we should just drop all existing libraries? Stop whining, man up and use the right tool for the job.
The author is completely disregarding the benefits of typesaftey. If you have a well structured document, and that structure is known, it's a good thing to communicate to the compiler and fellow devs coming in later what the structure of that document is. Shame he's just using `anyObject?` in this contrived example.
Check out the ADT-based approach here: https://github.com/maxpow4h/swiftz?files=1
This has been one of the biggest concerns about those pushing for all Swift all the time, that Dictionaries are type specific. So if you have a large block of JSON, you pretty much have to go back to NSDictionary to do your parsing. Otherwise it's just gobbledygook. 
This is off-topic, but as a new parent, we no longer call that baby-jail apparatus a "playpen". Evidently that term makes our children sound like they're little piggies. Which they are, but it's not PC to say so out loud anymore. The current name for that child-retention device is "play-yard". Spelled with the hyphen, strangely enough. The whole thing makes no sense because a "yard" is an open space, and a play-yard is the definition of enclosed. Also my 10-month-old, who has the attention span of a goldfish, enjoys her play-yard for about 90 seconds before the escalating ramp of fussiness begins.
Did you see the newer eBook Apple released about using Swift with Cocoa? https://itun.es/us/1u3-0.l
Only 400 lines, and still relying on the ObjC parser.
Oooh, I'm so looking forward to code bases with random operator overloading. Surely there is no reason it is so reviled in the c++ community? (Fun, but also a very bad idea)
Isn't this Apple's job? :)
You should try what I did: https://developer.apple.com/library/ios/referencelibrary/GettingStarted/RoadMapiOS/index.html Just change it over to swift. It's not that hard.
Oh man... Try hiding this in someone's code &gt;:D
Awesome. Great job
This func a&lt;T&gt;(b:T){};a crashes it too, at least it deserves the term "beta" ;)
JSON is schemaless inasmuch as XML is schemaless. If you know the structure of the object you expect, you can either successfully decode the entire thing or return nothing. No need to have conditionals all over the place. Check out [Haskell's Aeson library](http://hackage.haskell.org/package/aeson-0.7.0.6/docs/Data-Aeson.html#g:1) for an example of this.
Yep. We're the first ones to land at Normandy, so a few hiccups are expected! Happy coding!
Xcode crashes anytime for any reason, you rename a file, it crashes, you create a macro, it crashes, your disk is busy, it is trying to save to that disk, it crashes. Every time you change targets it loses the provisional profiles, turn off in-app purchases, craps your entire project. Xcode is a piece of shit from hell, created by satan himself, who works for dark apple, the apple that deals with developers... the apple that hates developers and writes shitty vague documentations. The other apple is the good one and has nothing to do with the dark apple. That other one has Tim Cook as CEO. Dark Apple has Satan as CEO and Darth Vader as head of the SDK development team. Other members of the board of Dark Apple are: Freddy Krueger, Jason Voorhees, the Joker, Hannibal Lecter and Lex Luthor. 
canon
The first half of this talk didn't offer much, but the second half of the talk and the Q&amp;A together made it well worth my time. I just thought I'd share that in case anybody was reluctant to wade into it.
wha?
The golden question is, whats the max joints available. Because if so, you could just drop a maze sprite and voila, you hava a brand new game in seconds 
Nah... it's the job we pay for the privilege of providing them with when we buy into their dev programs and pick up a beta ;)
Pretty sure I've crashed Xcode with sequences no longer than three or four characters about 200 times in the last week, but this is good too.
This is the #1 thing holding me back from progressing on Swift. Every time I try it, I seem to stumble upon one of these "magic" incantations that causes an endless number of crashes.
`var a="";(a` 11 characters.
Why is the Swift compiler even run in a way that can cause Xcode to crash? Why wouldn't it be a separate process?
Save a character: var a=0;(a
can I ask why are you dealing with window? and what are you trying to do? 
broken link or server down.
I tested this in a playground, but I think it should work in a project: numbers.map
Nobody got my joke... that's ok.
Does this happen in beta 2?
The idiomatic approach in Ruby would be to use Enumerable#each or Enumerable#map, not a for loop. If you used either of these, it would work as you want in any version of Ruby since at least 1.8.7 (released 6 years ago), if not earlier versions.
At WWDC a couple of us were typing in the Swift code being shown in the Playgrounds session. I mis-typed one letter on one line, hit run, and it crash-dumped Xcode and Playground. I tried it standalone in Xcode. Kaboom! It's a nice language but way too early for production work. I was surprised Apple was pushing it as hard as they were as an Obj-c replacement. It's got a ways to go before it gets used for any serious work.
Perhaps these are syntax highlighting crashes?
Here's the [video](https://www.youtube.com/watch?v=08C4D6Zlie4), minus the synchronized slide viewer.
These are all great! I hope everyone's filing radars!
Could be. That actually makes sense cause it seems like it's crashing before the playground would even have a chance to compile.
UIView is an unresolved identifier in Playground. Even when I import UIKit (which it doesn't find to be a valid module either).
In an ideal world, where you write both sides of the API, this is true. However, in the real world, there are no real restrictions on how the JSON should look. You can have conditional JSON structures: "if this is set to x then y contains z, otherwise it contains w" and all sorts of variants on that theme.
C# and Java uses type erasure on generics. This allows you to bypass the type system in an unsafe cast when you really, really need to - and you sometimes do, because the generics in those languages (and Swift) cannot express certain relationships. The problem is that Swift does not allow unsafe casts, so there is no way you can work around the issue. An example, let's say you receive a Dictionary that might either be a &lt;String, Int&gt; or &lt;String, String&gt;. In Java you could have casted to Dictionary or (unsafely) to &lt;String, Object&gt; and extracted the values. However, in Swift this is not possible. You cannot unsafely cast it to &lt;String, Any&gt;. Consequently you need to try to cast the Dictionary to any of the possible permutations until you find the right type combination. For our example we only need to test 2 types, but usually there could be a whole lot more.
This should work: var player = AVPlayer(URL: NSURL(string: "&lt;pathToAudioResource&gt;")) player.play() Not in the playground, though.
You must make iOS playground (by default you have Mac playground). On XCode splash screen, don't click on "Get started with a playground"; Choose File -&gt; New -&gt; File... iOS -&gt; Source -&gt; Playground, and you'll see that UIKit is included by default.
Really? I heard that C# used type erasure but that's obviously wrong then. Regarding ObjC vs Swift: what I see is a lost opportunity. A rebooted ObjC with the same dynamic basic language but streamlined syntax and generics a la Strongtalk. Instead of getting an improved ObjC, we're getting an improved C++, and I am mystified at that choice. Sure, it would be nice to see an improvement to both languages, but at least for C++ there is both D and Rust working towards that goal. Why not improve on ObjC? Out of curiosity, how would you extract the following in C# and Swift: [["A" : 1], ["B" : "String"], ["C" : SomeClass()], ["D" : SubclassToSomeClass()]] Given that all containers are optimally typed, i.e. the Array is Array&lt;AnyObject&gt;, dictionaries are &lt;String, Int&gt;, &lt;String, String&gt;, &lt;String, SomeClass&gt;, &lt;String, SubclassToSomeClass&gt;
Apple is God.
 import AVFoundation var audioPlayer: AVAudioPlayer? if let path = NSBundle.mainBundle().pathForResource("mysound", ofType: "aiff") { audioPlayer = AVAudioPlayer(contentsOfURL: NSURL(fileURLWithPath: path), fileTypeHint: "aiff", error: nil) if let sound = audioPlayer { sound.prepareToPlay() sound.play() } } assuming you copied the file into your Xcode project. EDIT: OOPS it should be `import AVFoundation` not just `Foundation`
Still crashing here when trying to work with stuff that involve structs and dictionaries of enums (apparently). :( It's still been a HUGE help in prototyping my game even with all the crashes. I can't imagine having gotten as far in any other framework in as little time. 
I'd argue that they (Apple) didn't choose path of improving ObjC because they wanted some more programmers-friendly language. Now, before you jump in anger ;), I have no complaints on Objective C. I come from statically typed background, but once I learned learn how Objective C works, I saw all the opportunities it provides. That's the reason why I want to keep ObjC in my toolbelt. But for general population, Objective C looks just plain weird. That said, to be honest, if it isn't for Apple and their success with iDevices, Objective C would be forgotten long ago. Hence Swift - a modern programming language more in line with current popular languages. For better or worse. And I don't think Apple will cease to support Objective C, that's *the* OS language. Regarding your question - it's wrong question :) In statically typed language you don't put unrelated things in one container, and you don't parameterize your container on AnyObject, object or some other base class - that's a sign of weak design. You use discriminated unions, or interface/protocol.
Thank you!
&gt; I could accept structs being stack allocated and passed by value if they were also immutable. Interesting observation, but without being able to safely reference them it seems too limiting. &gt; you can still make changes that don’t affect length (immutArray[3] = "Whoopsie") This seems the opposite of what you need - transitive immutability but with a mutable array reference whose length and pointer can be changed. &gt; Arrays and dictionaries are passed by value with deep copies of both. Again, this seems like the opposite of what you typically want. &gt; Apple could still drop ADTs (i.e. enums with associated data) to create a consistent single-paradigm language. That would be counter-productive.
I had the same problem. I just upgraded to Xcode 6 beta 2 and the bug is fixed. See https://developer.apple.com/devcenter/ios/index.action
on the mean time he can simple use a NSArray and all its functions, @sum, average, etc.
Why are you doing this? :(
Yes.
I want to add Views to my game without using the XIB/storyboard file. In this case i want to add an SKView to the screen only with code.
Thank you very much!
 struct T { var t: T } Pretty sure.
For fun!
I downloaded it yesterday evening, glad it came out. 
These guys made a perfect video to convince us not to buy their app. 
i have read the book, and thats how swift array works. It clearly explain in different chapters how referenced/copy in different situations are array and dictionaries. In your post, sort the array do not move the array content, it update their values instead.
Yes, that's how arrays in swift are designed. The argument here is that it's a bad design. 
Or just have implementations for both, and default to reference arrays. If I had to guess, I'd say they went with this hodge podge design so they could claim 'c like performance' from their arrays. This seems like a bad compromise to me for most apps since they don't need the slight performance gain, but will have to deal with the repercussions of the design indefinitely.
We've had a few IRC bots pop up already but I think the most interesting feature is to make a REPL accessible on IRC. Unfortunately due to how powerful Swift is, this requires that the bot be running in a carefully constructed sandbox as the unscrupulous can NSTask on your machine/exec system commands etc. 
I don't think any of the benchmarks used by Apple are fake or didn't actually provide those results, but its important to understand that they may have been optimized in a way that people have not yet discovered. It is a brand new language and as such the best people to benchmark it were probably the ones who wrote it. It would be nice to see the actual benchmarks released. It also looks like some base parts of the language are being tweaked based on dev forum discussions so I wouldn't worry too much about the performance profile of Swift. Obj-C has gotten faster with almost every release, I'd expect Swift to be the same. 
I have done what you said, and for testing, I added the line a line of code that says 'println("Sound Played")' in the if statement. It prints "Sound Played" but the sound still isn't playing. I am getting no errors, and I have copied the audio file into the xcode project. Here is my code: var audioPlayer: AVAudioPlayer? if let path = NSBundle.mainBundle().pathForResource("mysound", ofType: "aiff") { audioPlayer = AVAudioPlayer(contentsOfURL: NSURL(fileURLWithPath: path), fileTypeHint: "aiff", error: nil) if let sound = audioPlayer { sound.prepareToPlay() sound.play() println("Sound Played") } } Any thoughts?
Nothing will give you as developer a better front end result from obj-c vs swift. iOS jobs demands to make real a product with quality/speed. Swift promise is the increment on the 2nd average because we hope to avoid a lot of boiler plate code. In the other hand if you act as colaborator and its a must, youll have to learn on the fly, not the end of the world tbh
MVC is what you should start leaning first. Learn like a bible how an iOS app works, from structure - appdelegate - windows - viewcotrollers- etc, etc Its like you would like to make a house and everyone says that you should start learning atom physics.
My main problem with arrays as structs is it makes them different from every other mainstream language - which makes the usual ways I write code "wrong". eg pretend the declaration for CPerson in the article is something like: class CPerson { var name : String var children : CPerson[] = [] init(name : String) { self.name = name } } so sure, I can write: frank.person.children += CPerson("alice") or: var parent = frank.person parent.children += CPerson("alice") but if I write: var children = frank.person.children children += CPerson("alice") it doesn't work - but would work in all the other mainstream languages. Now I'm probably blinded by my experience with existing languages - but I'm struggling with why collections acting as value types is a good thing. ie there are 1000s of instances of wanting to take a shorthand reference to a collection to write briefer code to modify it compared to each time I might want to write a sort function.
You're absolutely right, that did it. Thanks for clearing that up. Guess we found an error in the keynote! (See: Introduction to Swift - 37:53, 47:52)
how do you run this?
Arrays are currently broken in Swift. They are being fixed in later beta drops; they are supposed to have full value semantics.
(I'm the author of that article.) I didn't realize that thought experiments were an invalid way to explore a language. I happen to work with a lot of unstructered data and attempting to fit static typing, as currently implemented in Swift, on top of that is not terribly beneficial. What you refer to as "it's... interesting" is me exploring what I could be spending a good deal of my time in. Regardless, the post was about helping make sure that I'm not parsing the JSON in Swift incorrectly, and if there are better approaches, then what are they?
Try a different file? An MP3 track or something (and update the relevant code from `"aiff"` to `"mp3"`) Also try setting up a breakpoint on the first `if` and step into each line and watch what's happening. Which event are you starting the playback from? I'm doing it right in `didMoveToView` and it's working fine.
objc_msgSend is part of the ObjC runtime, and has nothing to do with Cocoa directly, although no doubt it was called due to a cocoa class.
Looks like a storyboard issue, have you change/remove it or the .sks?
This is a port of the Objective-C Facebook SDK Tutorial. So you need to follow the steps on it, but instead of write the official provided code, use this one. This is the tutorial: https://developers.facebook.com/docs/facebook-login/ios/v2.0
Nice!
Very nice!
The first day beta 2 was out I used my Playground for hours with no crash. The next morning the very first thing I tried was to make a class extend `NSObject` and define a custom quick look…exactly from the session slides: func debugQuickLookObject() -&gt; AnyObject? { return "Some Quick Look type" } XCode got into a loop where it would crash, restart, try to evaluate everything in my Plaground, and crash again… Has anybody else gotten this to work? I'm running XCode 6 on Mavericks…maybe that's my problem.
https://github.com/lingoer/SwiftyJSON
actually I was trying to adapt Python function decorators, but of course without Pythons '@decorator' syntax
To be fair, learning swift is a great way to get into the ecosystem. Objective C can come later as you need it.
Fantastic-keep up the good work!
Thanks! That means a ton! :)
Xcode should actually crash less on Mavericks than on the Yosemite double-beta. And this is yet another reason why you shouldn't trust and run someone else's code in your Playgrounds. 
Point taken, but my current frustration is I KNOW it can be done without any Obj-C because they did it in Adventure. Now I'm trying to solve this more out of curiosity. Anyway, thanks for the link, I'll post here when I finally get this figured out.
It is possible to produce an iOS executable from entirely Swift source code that can do 99.999% of what an app written in Objective-C can do. That does not mean you will be able to write such an application without knowing Objective-C. Debugging is a very large part of writing. So is understanding the frameworks you link against.
You're probably right about Mavericks likely being more stable than Yosemite in general. I don't think I was running someone else's code, unless you mean the `debugQuickLookObject` above. That's just the hello-world example of the [standard](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/CustomClassDisplay_in_QuickLook/CH01-quick_look_for_custom_objects/CH01-quick_look_for_custom_objects.html) `(id)debugQuickLookObject { ... }` method that the Xcode debugger calls, just translated into Swift, where the `id` return type becomes `AnyObject?`. But, since you mentioned it, experimented a little, and I can define and call this function from within the Playground without any problems. func foo() -&gt; AnyObject? { return "yo" }
"Can't unwrap Optional.None" on this line: loginView.readPermissions = ["public_profile", "email", "user_friends"] Thoughts? Thanks!
dispatch_after
If you're trying to dispatch a method via selector, that isn't possible in Swift. Pure Swift classes do not use message passing like Obj-C. Classes that aren't pure Swift (ie, inherit from NSObject) still use message passing, but have their dynamic capabilities intentionally disabled. If you're just trying to delay a call for some period of time, then you should use NSTimer or dispatch_after as /u/dexter0 suggested. Dispatch_after is simpler, but an NSTimer gives you more control.
Do you have a source for that? The documentation lines up with the behavior of arrays and dictionaries. Seems kind of hard to believe they would document known broken behavior.
says here: "Use of unresolved identifier AVAudioPlayer". on the 5th line (the one that starts with audioPlayer) 
&gt; The swift programming language is based off of Cocoa Touch That seems like a bit of a stretch to say
My bad, it should be `import AVFoundation` I'm retarded. 
Lattner wrote so in the apple devforum for Swift.
Since the world has only known about Swift for all of 19 days now, the beta releases of Xcode 6 are pretty much the best and only game in town for editing swift code. There is a testing framework built in. It looks like it's called `XCTest`. I see in the sample project I made for myself that a test class was automatically stubbed-out for me, that outlines how to make simple conformance and performance tests: import XCTest class FooTests: XCTestCase { override func setUp() { super.setUp() // Put setup code here. This method is called before the invocation of each test method in the class. } override func tearDown() { // Put teardown code here. This method is called after the invocation of each test method in the class. super.tearDown() } func testExample() { // This is an example of a functional test case. XCTAssert(true, "Pass") } func testPerformanceExample() { // This is an example of a performance test case. self.measureBlock() { // Put the code you want to measure the time of here. } } } 
Some discussion from [the last time this was posted](http://www.reddit.com/r/swift/comments/27sdy2/dollarswift_a_functional_toolbelt_for_swift/).
I thought so too. Inspired by in some ways maybe. You certainly can't leave out Cocoa in that statement either. Cocoa and Cocoa Touch are simply frameworks on top of the language Objective-C. Swift is also just a language. 
Right now everybody wants to extend built-ins. In Ruby monkey-patching was very popular at first, nowadays it is considered an anti-pattern
&gt; I don't think I was running someone else's code, unless you mean the debugQuickLookObject above. I meant that buggy or [even malicious code](http://www.reddit.com/r/programming/comments/27bsmm/psa_do_not_type_code_like_systemcd_rm_rf_in_the/) would get executed immediately in the Playground and cause a ton of problems, so you should always review everything before you copy any examples like from the site posted here.
Quick is another one which is a behavior driven framework. I'm working on a blog post outlining how to use it. You can find it at https://github.com/modocache/Quick
Found the solution: import UIKit.UIGestureRecognizerSubclass
In case anybody didn't know [where that forum is](https://devforums.apple.com/community/tools/languages/swift)
How did you find that?
I wound up going with an NSTimer only because it was easier to invalidate
great to hear! i would love to do more high-level extensions, which operate on more generic collections and not just specific implementations like Array. but how can i do this? it doesn't appear that i can extend a protocol, and i don't see a good superclass to extend
I figured importing that part was necessary in the ObjC as well. But to be honest. It didn't completely solve it. It needed to be added to the bridging-header.
Check out this result to see an example: http://www.reddit.com/r/swift/comments/28qupu/an_one_finger_circle_gesture_recognizer_in_swift/ 
One of the things that did make me nervous about swift were the Generics and operator overloading. I hope that the culture around mac and ios development prevents some of the craziness around these things from becoming commonplace as in C++ in the same way that the culture of application design itself has encouraged well thought out interfaces. 
This is seriously interesting. I had some crazy ideas of creating a json enum (TL;DR it worked and I wrote a little lib for it) but this looks more promising. Reading about known issues in beta2 was also quite interesting when it comes to dictionaries btw:)
The Cocoa framework is, and has always been MVC based. Swift uses the same framework as Objective-C
Xcode. 
Its mean to be sks files aka sprite kit scenes, you can add them as a file
The iTunes U app has a nice free course from Stanford about writing ios apps. Within the first session or two there's a nice description of the way MVC is done in Cocoa. https://itunes.apple.com/us/course/developing-ios-7-apps-for/id733644550
The only IDE with Swift support is XCode, and you'll need the latest beta to develop with it, which required a paid developer account. Because Swift is brand new, there isn't a ton of support or tutorials yet. Give it time, and if you can, follow along with Apple's official documentation of the language.
"Array semantics were in flux at the time of Beta 1, and have been revised to provide full value semantics like Dictionary and String. This will be available in later betas. -Chris" https://devforums.apple.com/message/989944#989944, post 98. That's Chris Lattner, guy in charge of Swift.
Not done in the way you may be used to with a template engine that injects data into templates or the like. Rather, look into Interface Builder and UIViewControllers. As Duckton says, the pattern is the same for both swift and objc. 
Swift was developed in part because learning ObjC is difficult. 
What's difficult about Objective C are the frameworks, like foundation and UIKit, not the language. Swift doesn't help with that. 
Swift syntax is clear and concise. I just finished refactoring a huge project from ObjC to Swift. The swift project takes maybe 1/3 lines of code.
Maybe it is easier for you to just create the obj-c files and use them in your Swift project. Then when the beta gets updated with Swift class generation for your entities you can just re-generate them. 
That's really cool! My one suggestion is to rename the rad2deg property to just 'degrees', and maybe add a property called 'radians'. Even if your internal representation is in radians, it'd be nice to have a clear, explicit call and use them almost interchangeably.
Thanks for the feedback! I made the changes. The following properties will work now: value.degrees value.rad2deg value.radians value.deg2rad 
as a beginner, I don't agree with you. It was very very easy to learn Swift for me compared to Obj C. 
http://m.youtube.com/watch?v=uB100xVS_Yc
thank thee! i shall go through this and see
Feel free to criticize it. It's my first work on Swift :)
The simple way: NSUserDefaults The hard way: CoreData Google and above search terms will help you.
This is how I learned MVC in the first place. :)
So NSUSerDefaults is the way I've been going. I guess what I'm confused about is how to write the data back to the plist file when it's been updated in the program. I mean, the writeToFile demonstrations I've seen always (always) are using writeToFile to write a string. Example from the class reference: &gt; - (BOOL)writeToFile:(NSString *)path atomically:(BOOL)flag Example from the swift with Cocoa/Obj-C book: &gt; var writeError : NSError? &gt; let written = myString.writeToFile(path, atomically: false, &gt; encoding: NSUTF8StringEncoding, &gt; error: &amp;writeError) Am I just being to literal about this? Can I replace myString with myUserDefaultsFileImportedDictionary and still write back to the file? Will iOS allow me to replace a file in the application bundle like that without a problem, or will I need to put it somewhere else? Sorry for all the questions, I'm just having a hard time getting my head around this. 
Hi Guys, Solved. xCode created some bridge file where I only needed to include all headers which I need in swift too. This is great for me, since I didn't liked when I needed to include every file when I used ObjC Thanks again
Just scroll down in /r/swift it's lousy with them. As to which are good, that's a little trickier. Just bear in mind everyone else just learnt Swift a couple of weeks ago, so may only be two steps ahead on the leaning curve. Be aware of that, and on the lookout for people preaching bad habits or perpetuating misunderstandings. But getting good at spotting stuff like that can be a great learning tool too. If you want something about pure Swift, not writing cocoa apps, my blog has a few articles. Try [this one](http://airspeedvelocity.net/2014/06/11/a-basic-tutorial-on-functions-and-closures-in-swift/) on functions and closures, or if that's too basic [this one](http://airspeedvelocity.net/2014/06/17/writing-algorithms-on-collections-in-swift/) about collections, and [this one](http://airspeedvelocity.net/2014/06/10/implementing-rubys-operator-in-swift/) or [this one](http://airspeedvelocity.net/2014/06/14/implementing-some-ruby-builtins-in-swift/) about writing some Ruby equivalents. edit: forgot to say also, watch all the Swift-related videos on the WWDC app/website. There's some really great stuff in there. The advanced one especially, but also the intermediate one and the one on playgrounds are interesting and have some things not covered in the Swift book.
I'm down to test. I'm running a iPhone 5 edit: sorry on my phone, I guess I need a PM app...
You should give a look on this site : http://www.raywenderlich.com/ There are many new tutorials on Swift. 
A Youtube user [SamDoesThat](https://www.youtube.com/user/SamDoesThat) has posted a few tutorials that I found useful to get started.
If I understand correctly, that cuts down not only on the compile time, but it makes the app run better on the device. Is that true? Being able to shrink your app down like that must have some benefits other than compile time. 
That would make sense, but I read that this gets thrown unexpectedly for many reasons, no matter where the crash happened. To answer your question, I haven't made any change to the provided default storyboard or .sks.
I was 1/3rd the way through the ObjectiveC book from Nerd Ranch and I would still have to agree with you. I've found Swift is much easier (and even...more fun?) to code with than ObjectiveC was. Mind you I'm only 1/10th the way through the SWIFT guide that Apple released a while ago, but I've been typing every last bit of code it's been telling me to and it's explaining it quite clearly for someone who has had almost no programming experience. I really appreciate them changing the way that there are no semi-colons and type inference works really really well. 
I've heard the author of Magical Record say that it's good to actually do it in Core Data first, then use Magical Record. Makes sense to me - it might seem like Magical Record is doing something kind of silly, but then you see why, and how it makes it easier than Core Data directly.
My route to learning Objective-C was: * HTML/CSS (although not a language) * JavaScript * PHP * SQL * Python * Ruby * C Swift is supposedly a simpler language to learn than Objective-C but if you want to become an iOS developer you will need to know both Objective-C and Swift due to legacy code bases. Swift also borrows a lot of good concepts from other languages so having a bit more experience other than the spaghetti PHP programming will help you. **I'm not saying all PHP code is spaghetti, I'm just a bit biased.** Due to the Apple non disclosure agreement there isn't many tutorials, screencast and the likes available on Swift, so my suggestion to is to read the ["Swift Programming Language Reference Guide"](https://itunes.apple.com/us/book/the-swift-programming-language/id881256329?mt=11). Edit: The non disclosure covers Xcode 6, not the language itself. 
I've used RestKit and a lot of other things like MagicalRecord for handling API/CoreData interaction, but this [Core Data Manager](https://github.com/vokalinteractive/CoreDataManager-iOS) combined with AFNetworking, using an API client subclass and categories to organise the API calls is easily my favourite way of handling API/Data interaction.
Depends on what you mean by viable. If viability means writing an iOS or Mac OS X app in about 2-4 years, than *maybe* go with Swift over Objective-C. And pay the $99 to get the Xcode beta. There is currently 1 book on Swift. Compare that to just about any other programming language. (There will be mounds of tutorials in the near future, but until then, there are only a few dozen people on this planet with more than 2 weeks of Swift experience.)
Swift has an easier syntax than ObjC, but the language itself is fairly complex, esp when using generics. In that sense, ObjC is actually very straightforward. The lack of material on Swift PLUS the fact that the language is changing right now, makes it a poor choice for novice programmers, esp with no previous experience developing for iOS/OS X. Better pick up a script language like Ruby or Python first. Once Swift solidifies (and you've gotten better), you might give it a try.
Apple released another book this week : “Use Swift with Cocoa and Objective-C” Excerpt From: Apple Inc. “Using Swift with Cocoa and Objective-C.” iBooks. https://itun.es/ca/1u3-0.l And probably will be releasing more. Plus i have seen authors of current iOS programming books state they are either updating their old book or planning new ones on Swift
Apple did not put in place a non-disclosure agreement this time. Yes, there are a lot of tutorials out there. People confound simpler language with simplified language. Swift is simpler because it was create to reduce redundancy and unnecessary stuff from the language but it is not a simplified language. Everything you can do with ObjC you can do with Swift but with this later you probably need less code. 
I haven't performance tested it yet. I think its too early for objective Swift testing, as Yosemite, iOS8, XCode6, and the Swift language itself are all still beta.
Fair enough. I'm just going off what I remember from Apple's keynote. I thought they mentioned it giving a performance boost as well. I could be mistaken. 
It is supposed to be faster than ObjC, but has been getting mixed reviews in practice. No one will know for sure until we've had a stable release and Apple has had time to let Swift catch up with ObjC. ObjC has been developed for decades. I'm certain that Swift will surpass it greatly, but it will likely take time for Swift to reach its full potential.
You are probably thinking of [this slide from the keynote.](http://i.imgur.com/tfy9o3y.jpg)
Oh, I see your meaning. I use CakePHP quite extensively as my MVC framework of choice for my website. And of course I use Cocoa as my MVC framework for Mac applications. So there are two things I can think of that you're asking: (a) can you leverage your MVC knowledge to write Mac/iOS apps? or (b) will there be a server MVC framework that uses Swift instead of PHP (or other scripting language). For (a) your knowledge of MVC will certainly come in handy, but even MVC for a webapp is highly procedural. Think of what you have to do for a UI: you're either using the framework to process lots of text, or you're _also_ adding some type of UI framework that you also have to learn. Programming in Cocoa will be 100%, completely different for you. That doesn't make it hard, because you know how to program. I go back and forth all the time. For (b) that's a really interesting proposition. Given that Swift is currently Mac only, it wouldn't have a lot of acceptance on other *nix platforms. Although if it's llvm-based, I don't see why it wouldn't show up on other platforms. And of course llvm seems to support it as a scripting language, too. There's a framework called Cappuccino (I've never tried it) that tries to mirror Cocoa for the web and even uses something called Objective-Javascript. That might be a good starter project for seeing what's possible with scripted Swift. I've kind of been holding off on doing much with Swift, but if I could use the same language for my web frameworks and my Mac development, it would be a really good incentive. 
Swift as a language it's as good as any other to start learning in depth programming, problem is you won't find much literature for beginners at this point. The 2 ebooks Apple has released so far are for experienced programmers and just talk about the language, not about programming. I'd say it would be easier if you picked a language like C# or Java where many of the patterns of Swift are present and there are plenty of books for beginners that not only deal with the language features but how and why to use them.
You don't even need to call `.synchronize()`. That's done for you.
No, most of all because it's beta quality software at the moment (you'll regularly come across bugs in the compiler and Xcode at the moment) and the language is evolving, which means what a newbie learns one day might change in a week, or a month, or a year. 
"Convention over configuration" doesn't really make a lot of sense in Cocoa development. Instead you can make use of storyboards and xib files. There are many third party Objective-C libraries that were inspired by Ruby for doing networking, etc.
If I ever try to learn more Swift, I should make a Reddit client.
Have you seen any third party libraries like [AFNetworking](https://github.com/AFNetworking/AFNetworking)? AFNetworking is a really great networking library that makes any kind of HTTP requests incredibly easy. let httpManager = AFHTTPSessionManager(baseURL: "http://google.com") httpManager.GET(success: { (response: NSURLResponse) in printf(response) }, failure: { (error: NSError!) in \* ... *\ }) But for the scope of a tiny, dead-simple HN client, AFNetworking seems like overkill.
Oooh, I like this even more. I'll be using this next time. 
Yes, however you're not (or at least I wasn't) able to login with an iCloud account so your access is anonymous/readonly.
The way that I am going through it is I learned the basics of ObjC and started on Swift. Because there is little reference material, I have just decided to learn enough ObjC to convert ObjC statements to Swift. Just buy a nice book on objective c and use that as reference material. The basics of ObjC are really easy to learn so good luck.
writing here so that I can refer to it later on as I need this as well.
Ah, I did not know about this. Thanks for the heads up! Because this method is automatically invoked at periodic intervals, use this method only if you cannot wait for the automatic synchronization (for example, if your application is about to exit) or if you want to update the user defaults to what is on disk even though you have not made any changes.
"Input via console" - Do you mean a command line tool (no UI) that loads up and prompts for input within the Terminal? Or accepts input via run arguments? Or an AppKit app which presents a graphical prompt box for input?
Oh, now I'm sorry I didn't see that comment before it was deleted. Sounds like a good laugh.
Maybe this? [Get user input...](http://stackoverflow.com/questions/24112718/how-do-i-get-user-input-in-apples-swift-language-in-a-command-line-tool)
It seems to have fixed many crashy bugs. They're probably just not enumerated in the relnotes.
Just something that runs in XCode that can be like "please enter a number" and you put a number in and it assigns that value to x. Nothing fancy. Just want to be able to write some interactive super basic swift apps for practise. 
No. Not like that. That's ObjC code. I want pure swift. 
ObjC and Swift are generally interchangeable. If you see ObjC code doing what you want, it can probably be translated to Swift. I think the linked (duplicate) answer from that page is actually in Swift anyway.
I understand they work interchangeably, I just want to use pure swift where possible to avoid having to deal with ObjC as much as possible. 
You may be disappointed that this can be a fair bit of work. If a UI app is OK, then I suggest you wire up an interface with a text field and a button. Set the button's target to a method which reads the value of the text field, then do with that value as you wish - voila, no command line required. If you really do want a pop up, look into NSAlert and accessory views.
Thanks
What I was getting at was, both use the same frameworks and method calls, they just call them differently. You will still need to interact with the same Cocoa APIs. Understanding some ObjC will greatly increase the number of tutorials you can use, though you will be implementing in Swift.
"This is actually not easy in Swift at this point. The simplest way is probably the Objective-C way, using an NSFileHandle with standard input:" That is from the article. I also looked through the documentation and there currently is no input stream stuff. Also, since that code is Swift and easy, it may mean that Apple will not be adding input stream stuff. Who knows at this point.
Why? Cloudkit is a persistence layer itself. 
CloudKit only acts as a transport layer, there is no local persistence in CloudKit
Just translate the Objective C code over to Swift code. Foundation is written using Objective C, does that mean you're going to avoid using Foundation? That's absurd. Look at it realistically. You're going to have to translate ObjC to Swift. There's really no way around it, yet.
I don't know more than absolute basic ObjectiveC and really have no interest in learning it. It's going to be phased out of iOS and OSX in like a year as they convert Foundation and others to Swift, so there's really no reason to.
Look again. That answer is pure Swift, using the Apple frameworks.
There's a database on apples side that stores the data...what else would it be for?
&gt;Coupon code REDDIT is sold out
Cloudkit IS a cloud based persistence layer. 
let cellInfo = sortedArray[indexPath.row] There is a book about the Swift language available in the iBooks store, I recommend reading it. https://itunes.apple.com/us/book/the-swift-programming-language/id881256329?mt=11
Hey man, really appreciate all of this advice. I'm always trying to write better code and will definitely spend some time refactoring according to these tips. Thanks a lot!
*...so there's really no reason to.* One reason you might consider is whether waiting for native Swift libraries appear at WWDC 2015 is the best use of the year.
Basically create a CoreData context as normal, then you will want 2 helper methods on your model objects, one to load data from a CKRecord into the model, and one to generate a CKRecord from the model. a CKRecord is essentially a NSMutableDictionary that can do some magic. So basically your design is still CD driven, with a CK communication layer. Now with that said, I think this is a really odd usage, if you want local persistence with CK, I would think it would probably be best to keep a very minimal caching effort and just dump the persistent data into a json file on disk. **EDIT:** after reflecting on this, CK really should have a local caching mechanism, especially due to the limited bandwidth, I'm guessing this *****MIGHT***** be taken care of behind the curtain. But I have yet to see a notion of this in the docs. 
Thanks for your answer. That method is what I've thought about so far. (I think I might have misunderstood the word 'persistance') My problem is when I want to generate a CKRecord from my model. Even though I save the CKRecordID and generate a CKRecord with that and my properties, it won't update the existing record in CK cloud database. It says the record has been changed on the database. I think it is because I don't provide the recordChangeTag - which I can't because it's read-only. Correct me if I'm wrong, but I think remember hearing in the Advanced CloudKit video from WWDC that there weren't any caching mechanism.
let employees = [ Employee(firstName: "Doug", lastName: "Bell", networkName: "dbell", imageName: "doug.png"), /* repeat for other employees) ].sort { $0.firstName &lt; $1.firstName } is the equivalent to your code. You can access your array with the subscript-function that allows you to use [] as operator, employees[indexPath.row] would return your Employee-instance. And you could use didSet for an Employee variable in your UITableViewCell so you wouldn't have to modify the cell's details in your UITableView Code but in your UITableViewCell implementation. I found the Swift Programming Language Guide to be very helpful: https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/TheBasics.html
In addition, I'd point out that Objective-C also has had the same subscript functionality for nearly two years now. It makes code a lot more readable.
nice, Michael have you got a twitter or email I could contact you on?
Just to clarify; Am I using 'persistence layer' correctly? I.e. to have a local copy of records (with CD) on disk from CK. I've been googling it, but maybe I haven't explained the problem clearly enough. (English is not my first language) 
This. Do some research before posting your question. Most often than not you'll find your answer online. 
Thank you for replying. 
When you hover over a post description there is a "save" button. [I have 'saved' some posts for later reading; where are they?](http://www.reddit.com/r/help/wiki/faq#wiki_i_have_.27saved.27_some_posts_for_later_reading.3B_where_are_they.3F)
OK, try REDDIT2
If anyone has a cleaner way to handle this, I'd love to hear about it!
It's near the beginning of the language tour, and it's described again in the chapter on collections. It's easy to find in the most obvious places in the official documentation.
In [SwiftFonts](https://github.com/roadfire/SwiftFonts), I wrote a couple tests using XCTest - you can see them here: https://github.com/roadfire/SwiftFonts/blob/master/SwiftFontsTests/FontSorterTests.swift I found XCTest to be sufficient for what I was doing. I've used it for Objective-C in the past as well, and it's fine for basic unit testing.
And here's an article to go with it, in case you'd like to read about what's going on there: http://roadfiresoftware.com/2014/06/unit-testing-with-swift/
Messaged you 
Have you been able to store data using CloudKit via the simulator?
Surprising is an appropriate word here, mainly due to it being different than other mainstream languages. Given a lot of the other safe choices they've made in the language,this just sticks out as a rather 'brave' opinionated piece of design. I would certainly prefer them to be reference rather than value - but I'm unsure if this is because it would be better or just familiar.
Doesn't clouding cache already behind the scenes?
Thanks, I used a NSTimer and it worked perfectly. 
locally or to the cloud? To the cloud is no problem, though you can't login with your Apple id in the simulator which can be a problem in most cases. Right now you more or less have to use a test device to properly do CloudKit. I really hope Apple provide some kind of test user in the simulator to fix this. 
You have of course done the first troubleshooting step, right - run a Clean then Archive again?
Yes, Clean gives a succes. Than i run Archive again and it gives these errors.
Absolutely nothing wrong with var act1SceneCount = 0 for scene in romeoAndJuliet { if scene.hasPrefix("Act 1 ") { ++act1SceneCount } } but you could also do: let act1SceneCount = romeoAndJuliet.reduce(0) { $1.hasPrefix("Act 1") ? $0 + 1 : $0 } or: let act1SceneCount = countElements(filter(romeoAndJuliet) { $0.hasPrefix("Act 1") }) the benefit of which are you can declare act1SceneCount with a let rather than a var if you want.
It seems that Swift's dictionaries aren't exactly made to be general purpose containers. A good use of a swift Dictionary is using what it's made to work with: a dictionary containing strictly typed data. For example, containing non-nested optional parameters. Once you get to something like Dictionary&lt;Key, Any&gt;, it's essentially useless though. For those situations NSDictionary delivers, but it feels weird to be so dependent on ObjC from Swift. 
Great Suggestions, @airspeedswift. Feel free to open a pull request @ https://github.com/hackswift/swift-strings-chars-pg.
Just posted the tutorial (source is linked at the bottom). [Check it out!](http://www.reddit.com/r/swift/comments/28ymtr/swift_drawn_physics_the_tutorial/)
No problem :)
awesome! I will experiment with the force fields aswell if you dont mind
Yeah that's great! I'm actually in the process of doing a tutorial for those too. Hopefully we figure out some pretty cool stuff.
Wasn't saying it needs changing, just pointing it out for interest. What gets more tricky is trying to do the example that follows, which by counting for two separate things, can be done with reduce but gets very messy so probably not a good idea: let (mansionCount, cellCount) = romeoAndJuliet.reduce( (0, 0) ) { let (m, c) = $0 if $1.hasSuffix("Capulet's mansion") { return (m + 1, c) } else if $1.hasSuffix("Friar Lawrence's cell") { return (m, c + 1) } else { return (m, c) } }) However, if Apple added two features to Swift – native regexes that work in switch statements, and switch statements that can return a value if each case is a single-expression (similar to closures) – you could do it very nicely: // not valid Swift but maybe some day let (mansionCount, cellCount) = romeoAndJuliet.reduce( (0, 0) ) { (m, c), s in switch s { case /Capulet's mansion$/: (m + 1, c) case /Friar Lawrence's cell$/: (m, c + 1) default: (m, c) } } Apparently plenty of people have filed radars on both regexes and switches as values, hopefully they'll both get added in a later version. p.s. yes I know you can make switch match a regex by overloading ~= but it's a fundamental and useful-enough feature it feels like it should be in the language itself. 
Likely you don't want to spend time trying to do this, because as you can see it not working for you now, it can break as Apple updates things. It's relying on a private API, could even cause your app to be flat out rejected. What you can do is peruse github and cocoa controls to find people who have had the same problem and instead implemented their own version of UIPopoverController from scratch and released it with a permissive open source license, or even build one yourself.
linkbait waste of time article.
For the "Code Libraries" section Specification Pattern https://github.com/neoneye/SpecificationPattern
I just found this. there's 7 parts to this baby: http://ios-blog.co.uk/tutorials/developing-ios-apps-using-swift-part-1/ this is where i found it. some of the other links may also be helpful: http://www.macworld.co.uk/how-to/mac/how-get-started-with-apple-swift-programming-3523633/
The same happened for me on iOS 7 (but worked on iOS 8). My conclusion is that SpriteKit in the default setup uses an archive .sks file and that this is not supported on iOS (and probably not on OS X 10.9 or earlier). What worked for me was to simply remove the part which relied on .sks file. Suddenly it stopped crashing. Try to see if something like that (relying on features only in Yosemite) is causing the crash.
have you been able to log into your cloud account via the simulator? I'm getting this when I try: [http://t.co/t594MJhwbg](http://t.co/t594MJhwbg) 
It's based on [Hpple](https://github.com/topfunky/hpple) and was written within a day. This is my first github-based release, let me know if something's missing. :) A quick &amp; dirty sample is included. Have fun!
I don't have experience with SpriteKit, but that error is an exception being thrown. You may want to check the methods you are calling and see if the docs mention conditions where an exception would be thrown. I ran in to this exception in interface builder when setting an objects delegate to an object that had a view controller implicitly set as the delegate.
I like it very much... will it come with a package/dependency manager,too? That would be awesome! Like Ruby's gems, you know
Agreed. CocoaPods is defacto go to here.
I think a cool tool for us to add though would be search integration from Alfred and copying the link so you can add to CocoaPods.
Nice. I'm not signed in to GitHub right now so I'll post a little bit of a code review here. In the file `NDHppleElement.swift`, the lines: if attributeDict[NDHppleNodeKey.Content.toRaw()] &amp;&amp; attributeDict[NDHppleNodeKey.AttributeName.toRaw()] { let value : AnyObject = attributeDict[NDHppleNodeKey.Content.toRaw()]! let key : AnyObject = attributeDict[NDHppleNodeKey.AttributeName.toRaw()]! ... } can be rewritten as: if let (key: AnyObject, value: AnyObject) = (attributeDict[...], attributeDict[...]) { ... = key ... = value } ... thanks to pattern matching in a binding statement. The benefit is you do the dictionary lookups only once and bind at the same time. In general, I think once Apple releases a version of Swift with proper recursive enums your design can be made simpler.
` let coolness = sort(temperatures, &lt;)` I too, have read the swift iBook.
Woohoo! Love this app
It's a repost of this, but hasn't been updated: http://jamesonquave.com/blog/developing-ios-apps-using-swift-tutorial/
I'm biased but I think my tutorials are the most robust so far: http://jamesonquave.com/blog/developing-ios-apps-using-swift-tutorial/
We would love to hear your feedback. This project is very MVP and definitely has some issues that we will be iterating on over the next week. Any features you would like to see, let us know. We plan on adding a much nicer view for all the libraries with more information. The ability to the community to add tags to existing libraries, and more. Hope you guys enjoy!
At the time of definition, self is actually pointing to a class (In swift's case "Type") reference and not an instance reference, so myCharacter doesn't exist yet. Get rid of the assignment at definition and add it before the call to the designated super init. ex: init() { characters = [myCharacter] super.init(nibName: nil, bundle: nil) }
Thanks for your comment, really useful stuff here! +1
What does this offer that the current cocoapods search tool doesn't? 
Thanks. this works, sort of. I assume that the GameViewController would run init() when the game started. It apparently doesn't ever run the init() so my characters array is empty still. Still trying to figure this out. 
My example code means that when you create your GameViewController you must create it with no arguments, like: let controller = GameViewController() If your code is currently using a XIB or you create it using something like "GameViewController(nibName: nil, bundle: nil)" then it wont call just "init", it'll call the designated init method that UIViewControllers use (nibName and bundle args), so you'd have to override that init method instead. Edit: for more info on this check out the "Class Inheritance and Initialization" Section in "The Swift Programming Language" that Apple made available
Do you know Stackoverflow? It is awesome resource just for browsing and less toxic for asking beginner questions than reddit: http://stackoverflow.com/questions/tagged/swift 
Good article, but I have issue with "Strings, for instance, are always passed by value, which means Swift will be making copies of strings left and right with every function call." That would be true of mutable strings, but when you're passing immutable data around - or even returning a mutable string from a function - then there's no need to copy. Immutable data is really great like that, it can be shared easily. I also wouldn't be surprised if they implemented it as copy on write, but I don't know how that would work with reference counting.
I'm having a **ton** of trouble with subclassed prototype cells with Swift/Xcode 6 right now, so I'd love to confer. However, it seems this post doesn't mention what problem you're actually having. So what's up?
Our focus is Swift. Their search tool currently does everything ours does, but we plan on adding more features that will change this in the upcoming weeks. There will be community tagging, upvoting, downvoting, recommendations, and all that jazz to make finding the library you want even easier. We are also up to any suggestions that would make this product work alongside cocoapods.
Cocoapods if I'm not mistaken only shows libraries that have actually podspecs. So any library that doesn't you wouldn't be able to find. So there are few key differences there. Hope this helps!
Oh, I changed the init method to be the init(coder:) method instead and moved what you suggested into there. That worked great. :) Thanks!
The publishers would pay the site to have its commercial works translated.
May be you can include a tag like "Dev. Required" or "Testing Required" so we can see projects that need some "Tech Investment" and join them. Just thinking...
Thanks for the reply! I get an error that states "Cannot assign to "name" in "vc" on the following line (line 2 in your example above): vc.name = myTasks[indexPath.row].name Name is a property of the task class. Any ideas?
whoops, forgot about that: You'll have to cast vc to DetailViewController, it likely currently is an instance of UIViewController. change *self.storyboard.instantiateViewControllerWithIdentifier("ViewController")* to *self.storyboard.instantiateViewControllerWithIdentifier("ViewController") as? DetailViewController* and it should work.
Definitely a possibility. We will look in to it and see what others think. We'd rather not introduce features the majority will not use.
I sort of get what he's saying. I mean, I love ObjC. A lot. There's a weird zen like balance to all of the brackets. That being said, I jumped into Swift the day it was announce with much gusto. Tuples, closures, var/let, oh my. However, after striving to re-implement a project I had been working on in Swift. I initially ran into some issues with Core Data. I eventually worked them out, but there was 0 help on the web. Hell, I even helped another dev on the apple forums who was having an issue with CD that I had already figured out. I ran into a lot of stuff like this. My enthusiasm started to wane once I realized that all of the open source libraries and cocoa pods that I'd come to use to handle the boring boilerplate stuff wasn't available. Well, I could use them, but then I would be mixing ObjC and Swift. Something I wanted to avoid for aesthetic reasons. It's gotten to the point where I haven't written a line of code in 4 days. I've found myself playing Civ5 and FTL instead. I guess I just can't bring myself to re-code the standard toolkits that are out there from scratch. After about 100 hours of swift, I feel like I should just go back to ObjC and try again in about a year. It's nice language, but much of the "icing" is still missing.
https://github.com/modocache/Quick is the second project on the page at the moment, and I definitely appreciate all contributions! The issues page had tons of suggestions on what to work on. I'd also like to hear about projects that use Quick to write unit tests. Please consider it when you're writing unit tests for your next Swift app or library.
&gt; Also, what would the screenshot be of? A screenshot wouldn't make a ton of sense for some projects, but it'd be invaluable for UI components. How do I know whether I want to use a custom UIAlertView if I don't know what it looks like? I don't think you would be able to pull a good screenshot automatically, though, so I think this would be dependent upon allowing human curation. &gt; How would you expect to see the sample? Would it be okay to click in to a page that showed you stats, the snippets, and others. Yeah, that sounds good. An icon to indicate that screenshots or a more detailed description are available would be nice, too. Kind of like Alcatraz, which displays a little eyeball icon to indicate that a screenshot is available: http://f.cl.ly/items/3q1b312M3V1M2R3t1g3P/Screen%20Shot%202014-06-26%20at%201.16.26%20PM.png
&gt; parts of Swift aren't in Obj-C tutorials (such as closures) What do you mean? We have blocks in Objective-C. They're an implementation of what other languages refer to as lambdas or closures. The runtime library is even called [libclosure](http://opensource.apple.com/source/libclosure/libclosure-63/)
Please contact the cocoapods people, you both are doing good stuff and it would be great if you could work together. I shall definitely take a good long look at that list :)
Lmao
hahahahahhaaaaaaaa
Had a look at all available options including creating an extension which is pretty much category in swift, but nothing worked out. Used https://github.com/nicolaschengdev/WYPopoverController to get around this issue while on iphone
For a brief moment I forgot I was on Reddit and thought this was 4Chan. 
Usually you would have a UIViewController for each view in your application. So IMO it is best to create a subclass of UIViewController for each view. When you use UIViewControllers you obvious get alot of control. There a lots of delegate hooks that are called for you when various things happen (the associated view loads, disappears, appears etc). The only time I really subclass UIView is when I want to create a little sprite on screen (which I usually use Spritekit for these days) or when I want to create a little floating menu or something of that nature that's not fullscreen - and as such I don't really need all the controller code. When it comes to sample code, I like this little app: https://github.com/austinzheng/swift-2048
As someone who writes code in Swift and drives a Suzuki Swift, I approve of this message!
Nice tutorial, thanks! 
You should definitely be a moderator
You're welcome :)
I think I have my answer thanks to [Ash Furrow](https://twitter.com/ashfurrow) and [Justin Spahr-Summers](https://twitter.com/jspahrsummers): returning UIFonts is not something a ViewModel should be responsible for. Twitter conversation: https://twitter.com/jspahrsummers/status/482160700899328002
I would put that in my resume!
&gt; I don't think you would be able to pull a good screenshot automatically, though, so I think this would be dependent upon allowing human curation. &gt; Awesome. Yeah pulling screenshots is probably not the best idea, though you could look at the README and see what's there. We can rely on community curation like you said. I think that's a great idea to indicate whether or not there are screenshots, or code snippets. Thanks for the great suggestions!
Definitely. Looks like I'll be meeting up with someone involved in the project Friday.
That's something I'd like to some how integrate is marking a project as using a library. Not quite sure how to go about it just yet.
Perhaps your viewmodel could be responsible for describing the font or style, and your viewcontroller could be responsible for creating it.
Is your function an IBAction that's tied to the UIDatePicker? You need to be able to retrieve the value from the date picker first. Then, this should help you accomplish what you're looking for (it's the very simple version): @IBAction func datePicked(sender: UIDatePicker) { var formatter = NSDateFormatter() formatter.dateFormat = "MM-dd-yyyy" // (you can format this however you'd like - for instance, "dd-MM-yyyy" or "MM-dd-yyyy HH:mm:ss" or any number of ways) var stringFromDate = formatter.stringFromDate(date: sender.date) yourFunctionThatAppendsAnArray(stringFromDate) // (I'm not sure what your function looks like, this is just a guess.) } Hope that helps!
Keep in mind that the entire iOS and OS X SDK are built with Objective-C in mind, and you can use all of these classes (NSString, NSArray, etc) in Swift too. So my guess is none of this will probably happen as long as Objective-C is still around, which probably wont happen for a long time. 
We can only speculate, but my money is on them having plotted a long-term strategy to eventually phase out the noise inherited from C's lack of namespaces. It won't be next year, or the year after that, but eventually. Each successive year we'll be introduced to some changes that gently nudge us all in the desired direction, and/or changes that at least remove impediments to moving in the desired direction. Eventually, you'll be able to accomplish anything with nary an NS in sight, and all of the documentation, tooling, and sample code will, by default, encourage you to do so. …and the sphincters of the die-hard Objective-C hold-outs will clench for the inevitable.
Why not start with ObjC and transition to swift over the next 2 years. 
Golly! Thanks! :-)
Looks like someone can't take a joke.
I agree, subs that are self post only generally have much more useful content and it cuts down on posting karma whore friendly stuff. Links can be put in self posts that often spur added discussion. 
But wouldn't that necessitate the publishers making their books freely available? It seems like, in most cases, that'd destroy any interest for them. Seems like they'd see more profit in creating new books, to hope people will rebuy books they've already bought.
I generally agree, link posts often have little context. Note that thread was deleted also; I go through the queue several times a day and approve/ban posts. The IRC channel is pretty strongly moderated to stay on topic, but its more a coffee shop atmosphere of discussion and if you aren't present to hear the conversation, you'll miss it forever. Pros &amp; Cons. 
No, the books would not be freely available. The service could, for example, make only a few pages available to each user for translation.
Marcel Weiher is all over those comments defending his article. He's as argumentative at HN as he was on the Objective-C mailing list, where he argued against using ARC and other forms of automatic memory management.
Nope. It's still in beta. But this is a great time to learn the language fundamentals so that you're ready to write your large, important app when the language is formally released later this summer.
I think what you just said is ridiculous, passing by value when dealing with expensive data sets is retarded. In any kind of serious application, passing by ref is essential, moreover when passing by reference mutations are reflected throughout. Can you give me any reasons you think that built in value types are 'essential in programming these days'? Further more ALL Class based objects in Swift implicitly pass by reference, to say that the framework will be completely built on value types shows fundamental lack of understanding on your part, and is completely naive.
agreed, serious apps need reference type arrays/dicts. even if NSarray/dict was deprecated everyone would simply have to wrap swift arrays in a Class.
I think a way to do this is to use the currentTime parameter in the update method. Use a variable that represents the time when the timer should be at zero, update the countdown display in the update method by subtracting the end of the timer minus the currentTime
Weiher has been using ObjC for a long time and I think it's worth listening to him even if you disagree with him. Incidentally I revided an old OS X game project yesterday. I wrote and released it 2004. Turns out I was using Weiher's old Accessor macros. If you didn't know better, you could almost think it was using ARC, judging from the lack of explicit retain/release code. Old school best-practice ObjC 1.0 was a lot better than you could guess from looking at the average ObjC 2.0 without ARC. Problem is - only a fraction the hordes of iOS programmers wrote anything close to best-practice ObjC. Thus ARC, ObjC 2.0 and now Swift. I can easily see how Weiher can argue that best practice ObjC doesn't need ARC, because it *is* true.
Thanks again for helping me with this problem. If you can help me some more, I was wondering how to put images in buttons, I've only gotten a blue box to appear where the picture should be. [This](https://gist.github.com/kinson/ef009a7ec0d45dc3b742) is what I have so far in the viewcontroller. The only thing on the storyboard right now is an Image, I'm trying to add the button programmatically.
I quickly made such a timer, check it out [here](https://github.com/Kametrixom/SpriteKitTimer)
Edit: First double check that image.jpg is indeed added to your Xcode project (like you dragged it into a folder in Xcode) The code that you've written should work without any problems. The only thing that I could see happening is that its not finding the image?
What time is it opening? I may be busy during that time. 
Midnight. Let me know if you can't submit that day, and we can arrange an alternate submission time.
Thanks for your thoughts!
Makes sense - thanks!
It's in the project folder. I also tried the add files part of xcode (file -&gt; add files), neither solution worked. edit: if I put in a invalid file name, there is no blue box (no image either)
Swift will rarely copy a value type. It will behave as if it is copied, but most of the time the actual copy is optimized out. I don't think a "class" version of an array or dictionary will be added. "inout" can be used in rare places it would otherwise be copied, however you are probably using poor design if you need to do that frequently. Best practices are much different then Objective-C. Be careful with the name calling. That doesn't belong here.
Kevin McNeish http://www.iosappsfornonprogrammers.com has written on his forum he has started one and Ray Wenderlich http://www.raywenderlich.com has started to redo his for Swift. 
Objective-C may stay around as a bridging language to C++ and macro-heavy C. I'd expect it to take at least 5 years to be completely free of legacy UIKit and Cocoa. This will probably be similar to the Carbon transition.
You don't want to do that. Learn how how Swift optimizes pass by value. In rare cases that doesn't work, "inout" will probably be a better option. Learn more about SSA optimizations if you want to know the details.
Hmm, Have you: - Tried adding it to the view instead of schoolView (ex: self.view.addSubview(qButton)) - Tried instantiating UIButton as Custom instead of System - You say "there is no blue box (no image either)" is the button showing a blue box around the image? or is the image a blue box? - I assume the image isn't a blue box, but is that code exactly what you have? (There isn't any special schoolView masking going on?) This reply chain is getting a bit deep, probably best to move this to PM's
I agree, except hold-outs are rare in the Apple ecosystem.
thanks friedocra (cool name btw) this tutorial you linked from AppShocker was very good and exactly what I was looking for. Now I just need to find how to take it further (tying buttons to take the map to specific locations)
Why then does Swift use references for all class types? You make it sound as if using value types only is some how an avant-garde approach to design. How well do you think UIWindow would work as a value type? 
Are you *trying* to kill everyone's battery?
What if you set the button's type to .Custom?
Hi! You'll find info on how to programmatically add a WebView in my article "How to write a minimal WebKit browser in 30 lines of Swift", see http://practicalswift.com/2014/06/27/a-minimal-webkit-browser-in-30-lines-of-swift/ Happy Swifting! :-)
Setting the type to UIButtonType.Custom should work.
Approx 2,000 people have, as far as I can tell.
Awesome! I remember my friend wrote code for a browser in Java, so he could get past my schools internet blocks. Somehow, it worked. I bet this would too, hehehe.
Don't let esummers78's use of the word "eliminates" alarm you. Nobody wants to come pry the reference types from your cold, dead fingers. Swift gives us both reference semantics and value semantics for different use cases, because each is better suited to different use cases. Your UIWindow will continue to be a reference type in perpetuity, I recon. Obviously I can't put words into the mouth of esummers78, but when I read the phrases about subclasses I was nodding in agreement because even in language communities where almost everything is a reference type and everything is object-oriented, there has been a strong trend to express that object-orientation through composition rather than inheritance wherever possible. Take modern idioms in the Java community, for example (probably best captured in the design patterns seen in Google's Guava library). It's not as if inheritance has been outlawed, but it certainly has become a tool of last resort. But there's another thing that the word "modern" probably alludes to: a lot of wisdom that has recently started to percolate from the functional programming ivory tower into industry over the last decade, which one might summarize as "endeavoring to keep side-effects to a minimum". Which brings us to Swift's controversial choice to give lists and maps value semantics, one of my favorite design decisions. Imagine you have `class Sentence` (having reference semantics), and that `Sentence` has an `Array&lt;String&gt;` of words, and that there is an accessor method that allows someone to get the list of words. Now suppose you have an instance of `Sentence` that you pass in to `func doSomethingWithThisSentence(…)`. When this function returns, has your instance changed? How do you know this function didn't call `getWords` and insert a naughty word? (Surprise! The function you just called turned out to be a meat-grinder!) Well, if your arrays have value semantics, you *do* know. The function can get the list of words, add the three words "said", "Sir", and "Fartsalot" to the end if it wants to, but the *caller* of the function doesn't have to know about the implementation details of `doSomethingWithThisSentence` in order to reason about the state of the instance it passed in. The fewer surprise meat-grinders, the better. A lot of people have a bit of a panic attack when they first wrestle with the idea of "value semantics", because it sure sounds as if a whole lot of copying is going on. But the copying is only supposed to be the *mental model* that the programmer is supposed to have. The copying is not necessarily something that happens every time you pass a value type. In a lot of cases, these value types are small and immutable, and they end up living on the call stack, which means we didn't have to dereference a pointer to the heap, which might have caused a cache miss. I realize that arrays and dictionaries don't seem like something that fits that case, though, right? A `Point` with an x and y coordinate is easy to imagine as a value type, taking up two slots on the call stack. Arrays and dictionaries, on the other hand? Not so much. But, then there is the whole field of "persistent data structures" *a la* Chris Okasaki's [excellent book](http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504). Couldn't it be possible that a Swift in the future has some nice data structures in that vein (all of which have value semantics)? *Edit: sorry, I accidentally used the word "reference" in TWO places where I meant the word "value" above. Fixed now. Also, one other thought: I like to think of value semantics as just the next step in the evolution of the pointer. In the old days, we could do math on pointers – but then references came along as a refinement of the same idea where we were no longer allowed to know or care about an object's location. Value semantics takes that one step further, where we're no longer allowed to care about an object's identity. This is one way that history rhymes with itself: we're being asked to give up something for the promise of some payoff in being able to reason about the code.*
Would have to be a really pathetic system if that works. 
I wouldn't be surprised in most school districts I've been to
I'm guessing they had the blocks in IE and prevented installation of software on the desktops (like a different browser), but had java installed, so running a jar was not an issue.
Really a case of the blind leading the blind. Current state of Swift blogs: "Look I figured out how to do a write struct! Let me blog about best practices for structs!"
And even if they had a competent IT, I'd like to think the IT thought, *if they build a tool to get past this, they've earned it.*
If I was IT at a school, I'd probably think that way tbh
Ohh wow, I'm an idiot. That makes so much sense now that you say it. Don't bother trying to fix it yourself. You have helped me more than you can imagine. I'll place my code into a view and report back on my progress. Thanks again.
Sadly he was forced to "delete" it. Well really they just told him don't spread it around and don't let us catch you using it. 
Thanks so much, I was able to fix it. I would give you reddit gold but i cant afford that so have [Reddit Silver](http://f.thumbs.redditmedia.com/wPjOQrGRacUELOnM.png). Now I have a different problem. The scrollView wont move when I call setContentOffset. I feel bad for asking for help again but you are just brilliant.
Really glad to see someone else is not happy with the decision to sideline message passing. Static typing definitely has benefits, namely code safety, but those benefits aren't free. Personally, I'd much rather prefer a solution that allowed me to choose what I want for different parts of code. Swift would hardly be the first language to take a hybrid approach like this, for example Scala has recently added the ability to mark classes as dynamic, which allows something similar to message passing.
.NET has many features to alleviate these issues that Swift does not, like powerful reflection capabilities and the dynamic type. These features necessarily undermine the type safety of the language, but when used responsibly can be powerful tools. Currently Swift either does not have similar features or relies on Obj-C to provide them. While the author would prefer true message passing, he made it pretty clear he's open to other solutions as well (like those in C#). I'd also point out that author isn't trying to say there are no solutions to some of these issues in Swift. His point is that a Swift implementation would be bloated and fragile which could be reduced by the expressibility of a more dynamic approach. Furthermore, even Apple sees the value of message forwarding as they've created the special @nsmanaged property for core data code that allows methods to be implemented at runtime. Finally, you seem to be approaching this as if it's a black or white issue, when really a hybrid approach can gain the benefits of both sides while simultaneously limiting their drawbacks. 
You should read about how Automatic Reference Counting works. It is not much like the non-deterministic deletion behavior in garbage collected systems. http://clang.llvm.org/docs/AutomaticReferenceCounting.html Swift/Objective-C's ARC is deterministic and is somewhere between std::unique_ptr&lt;T&gt; and std::shared_ptr&lt;T&gt; (different rules are applied in different situations). The ARC system performs lifecycle analysis over the local scope so it already does some of what the Rust borrow checker does – although its focus is not on preventing shared memory but on efficiently tracking reference counts. Remember: all of this applies to classes only in Swift. Struct types are value types.
Apple seem pretty committed to ARC. If you want to do all of your own memory management, I suggest that you stick with C++ as Swift might not be for you.
heh. C++ + does what i need &amp; i'm used to it - clunky syntax, cursed with header files Rust + cleaned up,match/enum, safety, same control of C++, no headers. - no 'open' overloading Swift + Copies a lot of what I like in Rust,+overloading - not same control over memory need yet another language, or wait for C++ modules to gain traction and so on 
I haven't looked at Rust yet, but no overloading? Really? What's the rationale there?
It centres all the polymorphism on traits. It can overload on multiple parameters if you use something like double-dispatch traits (which adds boilerplate). The plus side is runtime&amp;static dispatch is completey unified, and generics get checked. The downside is it feels very restrictive when you're used to being able to select on any parameter. (There are some proposals that will let them use a tuple of types to do controlled overloading)
You can also use `break` inside the empty `default` case instead of the empty curly braces. Not sure which style will become idiomatic Swift.
Yes, that's the point, most languages are not fully type safe and they are not fully dynamic either. As I said earlier, the situation is *not* black and white. This includes C#. For example if you look at the [wikipedia page](http://en.wikipedia.org/wiki/C_Sharp_\(programming_language\)#cite_note-dynamic-1), it even simultaneously lists 'static', 'safe', and 'dynamic' all in its 'typing discipline'. The OP here isn't asking for anything that isn't, as you pointed out, already in C#.
C++ of course gives you total control, but Swift is not as far from it as you seem to be thinking. Reference counted memory management is not the same as garbage collection (as in Java and C#), and is, as gilgoomesh pointed, out a lot more deterministic. For example, you can still use RAII patterns because when a object is created, not assigned to any escaping pointer, and then all pointers go out of scope, you are guaranteed the object will be destructed there and then. The Swift book even advocates doing this. References in Swift are essentially like shared_ptr (with weak references like weak_ptr). In fact following the recommended C++ practice of always using shared_ptr rather than raw pointers is almost identical to writing Swift code. You could likely implement the semantics of unique_ptr in Swift using a generic class that tracked ownership of a member variable, especially once they add private member variables. edit: also, if you must monkey directly with memory using malloc etc, Swift will let you do that too. I'd be skeptical of the use case most of the time tho. 
I understand that, I am looking for an example. That link does help though. I didn't know Apple released code examples in Swift.
&gt;&gt; I'd be skeptical of the use case most of the time tho. Certainly I realise what apple have done will suit application development 100%. &gt;&gt;" You could likely implement the semantics of unique_ptr in Swift using a generic class that tracked ownership of a member variable, especially once they add private member variables." .. thats's extremely interesting to hear..
I would think not. Just from playing around with it its not too hard to run into rough cases or areas that will clearly change. If I had a large project I might do small areas in Swift to keep it in my brainspace as it grows and becomes more widely used. 
Thank you, it's very helpful and looks less strange than two emits.
&gt;The reason this works fine, is because the compiler is actually converting aString to NSString implicitly. [...] &gt; This seems to go against Swift's policy of always requiring explicit conversions between types, but I guess it is a compromise to allow working with Objective-C much easier. It's actually pretty cheeky considering Swift's no-compromise approach to this elsewhere in the language.
This is why you typically want macros: macros can create new syntax constructs without any of the problems you get with closures. That said, macros are usually harder to create nice syntax for. There's also the question wether designing your own syntax is a good idea. In my opinion, this tends to be fall into the category "clever programming" which should be shunned in any project of medium to large size due to the fact that it makes the code much harder to understand at a glance. Incidentally this is why I avoid C macros: they can make the code much more concise, but it is always at the cost of clarity.
Just like C macros or excessive meta programming in Ruby. Eventually even these people will find out that these neat hacks isn't something one should randomly play around with (just like operator overloading)
I think the “this feature will just encourage ‘clever programming‘” argument is a question of degrees. You could make the same argument about closures, operator overloading or even polymorphism, all of which are cornerstones of Swift. If you take it to extremes, you just end up back at C. But I agree macros would probably be over the line, as attractive as they can be. The kind of language extensions I described are right on the edge of the line IMO. The article wasn't encouraging them as much as pointing out their potential pitfalls. (it's unfair to compare the C preprocessor to Lisp macros though – the CPP is pretty much a bad idea that needs to be replaced by higher-level language features wherever possible, which Swift mostly does, as in fact does modern C++)
To quote a Swift dev re these sorts of conversions: &gt;It probably shouldn't be inferred at all, frankly. We added a lot of implicit conversions to object types to try to making ObjC bridging feel clean, and they've been causing tons of problems like this.
&gt; Personally, I'd much rather prefer a solution that allowed me to choose what I want for different parts of code Then be happy, because Swift _does_ give you that solution: you can opt in to message sending. See the `@objc` attribute.
This really doesn't have anything to do with extensions. It only has to do with trailing closures. They may look like control blocks but they are not.
Extensions as in the meaning of to extend, not in the sense of iOS extensions, obviously. But yup, that's the point of the post. Edit: though I guess you're right, poor choice of words in the title as some might have been expecting something different Edit edit: sorry, my reply was unnecessarily rude, no more internet for me for the evening!
Im hoping it doesn't have to be super polished. Will we get extra points for doing everything programmatically? What about comments that tell exactly what is doing what?
Hi! Ok, so it wasn't an IBAction tied to UIDatePicker; I had a IBAction tied to a button press that would append the data to the array. But I used the formatter in my IBAction and got it to work, so thanks so much! By the way - two more questions, if you'll indulge me: 1. Do you know how to make a save file (i.e. data will stay there if I reopen the app?) 2. Do you know where to look for swift resources? This is hard because it's so new, but I looked at some Objective-C code and it's incredibly long and looks insanely hard Thanks again!!
Also if you could do my shift at Starbucks for me, and pick up my dry cleaning that'd be cool k thx bye
Ok, ya it wasn't so obvious to me, especially since you are using an Extension to "extend" the language. But I certainly understand why you used that wording and I appreciate the apology :).
Comments that will help other folks learn what you're doing in your code is a definite plus.
Great tutorial, thanks for this!
The so-called "vibrant third-party ecosystem" of unpredictable, unsafe method-swizzled hacks isn't large enough to justify forcing every Swift app to use slower message-passing by default. What a crazy argument.
I'm guessing if there are they'll stay quiet about it as there are pretty strict rules for social media/websites for Apple employees, especially on the corporate end.
I suspected that might be the case. It's a shame, because a little more community communication would go a long way.
While I partially agree, Apple employees have been quite active talking with the community on Apple's dev forums.
Some of them are in the google group.
That is a good point. Here's the link for the curious: https://devforums.apple.com/community/tools/languages/swift
What is it you are expecting this does in your other init? &gt; ScrollViewController() 
That really isn't what it does, but for the sake of clarity I removed everything outside of it. I have a array in my fontView that when a row is pressed, it executes a similar command taking it to my noteView at point (320,0). That is what it is supposed to do, in theory, at least
I mean the actual `ScrollViewController()` call That part, what do you think that is going to do? I think it must not do what you think it does.
Well, doesn't it call the ScrollViewController Class? In my code I seperated it into two lines of code: `var scrollViewClass = ScrollViewController()` and `scollViewClass.scrollView.setContentOffset(CGPointMake(320, 0), animated: true)&gt; I am not 100% sure if calling that creates a new instance of the class or if it just "points" to it.
So then how would I fix it?
call it on the actual scroll view instance. If you were asked "What is the difference between a Class and an Object" in an interview, what would you answer?
A class is the declaration of an object. An object is an instance of the class with duplicated properties that can be altered after its initialization. I am also new to the programming scene.
Right, instances are what you work on, the class is the ... Template for the data layout. So you can't (well, don't, normally) expect new class instances to alter properties on existing instances. Your design may be flawed, why are you trying to change the properties of Object B from Object A when Object A doesn't own Object B?
So then how can I transfer the action from Object A **to** Object B? Would I change the target? Wouldn't that create another instance? Still have no idea on how to direct an action.
I am trying to change the contentOffset of my UIScrollView in my ScrollViewController class on the touch of a button in my TextView class. The relationship between the two classes, I don't know. What defines the relationship. The ScrollViewController adds an instance of the TextView so my best guess is that ScrollViewController owns TextView. But how would I do it if they are completely unrelated. I am doing other stuff, like adding cells depending on what is written in an UITextView. How would I do it both ways is what I am trying to say.
Create a ScrollViewChildDelegate protocol that has a method like: func viewSelected(view: UIVeiew) implement viewSelected in your ScrollView and use it to scroll to the passed in view. assign the ScrollView as the delegate for each of your ScrollViewChildren classes. in your scroll view child (such as the font view), when it's clicked (or whatever), call `delegate.viewSelected(self)` That's the idea anyway, if it's not really that you want to show 'self', you may need to pass some other data saying what you want to happen (an enum, or what-not) The other way is using NSNotificationCenter, look that up in the documentation. There should also be much better explanations about the Delegate Pattern in other places. In fact, you are likely using a delegate protocol for you table view. 
So let me see if I understand this... First, I create a protocol with a method that takes a view. (Funny thing is, i already make a function that does the same thing.) Second, I assign ScrollView as the delegate to my three subviews. Third, I call that protocol.method whenever I need to change views. Am I completely delusional in thinking that is all I need?
cool. Make sure to read the Protocol section in the Swift manual, perhaps that will help too.
Did you read the Swift manual? Have it conform to the delegate interface: class ViewController : UIViewController, DelegateProtocol {
 childViewController.delegate = self your child views controllers cannot be plain view controllers, they will need to be subclasses that add a delegate ivar.