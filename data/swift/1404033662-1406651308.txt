From what I can see, I need a view that has a delegate `var` and to set the delegate, I need to call `myClass.delegate = self`. My question now is, how do I set the delegate var. I am understanding everything else.
Do you mean, 'declare' the delegate var? class Whatnot { var delegate : DelegateProtocol? } 
Now I am getting errors. Man you have been helpful today, thanks.Well, anyway, it wants me to type `delegate.?.moveScrollView` instead of just straight `delegate.moveScrollView` When I do, it gives me the error "Expected member names following '.'" If I instead use `delegate.moveScrollView` I get error "ScrollViewController?;' does not have member named 'moveScrollView'" Using `delegate!.moveScrollView` gives me EXC_BAD_ACCESS with "cannot unwrap optional.none" in the debugger when I click the button.
*Gasp* I got it to work! You sir will be gilded asap. Whenever I can, I will give you gold. I am 100% serious. You saved my project before the deadline. Thanks again.
Heh, glad it worked, I hope you learned some useful things. Rather than gilding me (I actually sort of have a permanent gold account), please pay the favor forward when you see someone else starting out in programming and having troubles.
Great! I will... I am actually on Stack Overflow everyday trying to help... If I don't know something, I check later and learn myself, if I know it, I try and help. (Btw, the tag I gave you was "PERMANENT GILD"(not even joking))
Looks like your code is setting the x coordinate offset which would move it horizontally. Do you want the scroll view to actually move vertically? Swap the args to cgpointmake there. 
I agree with one of the commenters on that site. Some people like a fresh start, bringing in the bridge is just not as refreshing. Why use Swift if you're going to drop back to Obj-C each time you can't immediately figure out how to do it in Swift? Why not just write it in Obj-C?
Using Foundation isn't "dropping back to Objective-C" though. Foundation may be written in Objective-C, but there's no Objective-C code in your code. If you're using the bridge *your code* is still going to be Swift. And if Apple is going to drop Foundation in the next 10 years they're insane. The Cocoa runtime is the reason there's all of this great software available for both the Mac and iOS. Asking developers to learn a new language is one thing. Objective-C is pretty old and computer science has made a lot of advancements in the past 25 years. While Foundation is also old, it's been proven to help write great software quickly. Asking developers to throw out their knowledge for an arbitrarily new system that is unproven and *may actually make their job harder* once they've gone through the considerable effort to learn it would be foolish.
The only classes I really try to avoid are those that have Swift alternatives like NSString, NSNumber, and NSArray. Lots of other classes don't have alternatives and I don't really hesitate to use like NSURL, NSNotificationCenter, and obviously the UI framework. However, every so I often I will fallback and use a bridge back to the Objective-C type. Swift was defined to be a pragmatic language, we should be pragmatists when using it (for non-academic purposes at least).
The views are different pages so yes, they should be moving horizontally.
CGRect already has `minX`, `midX`, and `maxX` built in (as well as `minY`, `midY`, and `maxY`)
Oh cool, thanks for the heads up. I didn't realize that. I still think it demonstrates the power of extending those basic struct types though.
Drewag provides a lot of good info. I'd say hold of on working directly with swift until it's released this fall. Right now swift is a terrible language to start learning. It's buggy and inconsistent and there are very few help resources out there. Almost all of the resources are about how to program with swift instead of how to program (with swift.) I'd recommend getting a basic understanding of OO programming using a common language like C#/ Java where there are tons of tutorials and experts to help. You could also try to jump right into objective-c which would give you good experience with Apple's APIs although many people are uncomfortable with the syntax of objective-c.
Alright, it's 1:30 AM where I live and I'm not sure yet if I'll be at home tomorrow, hence the early submission (I'll submit the app to the official thread as well if I find time &amp; internet). I wrote a tiny reddit client and used as much Swift as possible. I hope you like it: https://github.com/ndavidsson/NDdit
Check Kickstarter for Swift project at https://www.kickstarter.com/projects/alanforbes/learn-to-program-ios-and-os-x-with-apple-swift I
&gt;4. Multiple Functions with Different Types I've been coding in non-compiled languages for too long to be sure, but isn't this pretty common in many languages? I would swear I've written C functions with the same name, just variations on the signature. http://en.wikipedia.org/wiki/Type_signature#Method_signature
In Terminal, type: man xcodebuild that is, you can trigger a command-line build of an Xcode project with no graphical user interface. 
I believe Rust is another example of a language without function overloading.
Thanks, but I don't think this is what I'm looking for. I want to be able to compile multiple swift files together completely separate from Xcode, like how you can compile multiple C++ files together using makefiles. 'xcodebuild' seems to only work when compiling existing Xcode Project folders.
If you want a text file representation of a collection of sources that make up a project, like a Makefile, you can use CMake to generate an Xcode project, then call xcodebuild. I use [gyp](https://code.google.com/p/gyp/) 
You can certainly make a makefile do a build that includes swift, but you wouldn't really want to. You an look at how Xcode actually builds binaries in the build output tab.
It depends on whether you're writing Swift for the sake of learning Swift, or if you're actually working on creating a real thing in it. The first group is disproportionately large at the moment for obvious reasons, and for them simply using the Foundation functionality rather than searching for a pure-Swift solution is missing the point.
That just opts you into message passing internally in the runtime so that your class can be accessed by Objective C code. It doesn't actually allow you to use message passing features in Swift. Even if it did allow you to use these features, they'd still be getting provided by Obj-C or runtime.h and would not be idiomatic Swift code.
It must've been C++, C doesn't allow function overloading.
I've got a tiny reddit client for you. It automatically fetches data for a specific subreddit (/r/swift in this case) and displays the first 25 threads in a UITableView. I wanted to add some more features etc., but I didn't have much time. However I hope you like it and appreciate my Swift code. Github: https://github.com/ndavidsson/NDdit
Println will give you the object pointer. 
Aha! Thanks!
Give teamtreehouse a try. They have a free two week trial and a $9.99 student plan. Not sure if that includes high school students but I don't see why not. They'll teach you the fundamentals of objective c and how to build a few iOS apps to get you comfortable with iOS development. They also have courses in other languages suitable for web design etc. I'd start with objective c since it's a mature language that has a lot of go to material. Objective c isn't going away any time soon. Once your comfortable with objective c and have some experience then you can start playing around with swift.
Clang introduces `__attribute__ ((overloadable))` to C for function overloading, see last section of this: http://nshipster.com/__attribute__/
Sure. It's not "real" C, though, it's a Clang extension.
Here it is! This is a simple game I wrote, where there is a dot that moves to a random location when tapped. There is a timer going behind, and when you click the background on accident, you lose the game. Thanks for looking! ReactFast, by Ben Rosen. https://github.com/benrosen78/ReactFast
I would expect the [article on unit testing](http://roadfiresoftware.com/2014/06/unit-testing-with-swift/) to instantiate a new sorter object for each test using setup/teardown to ensure no side effects occur in initialization. 
Agreed.
FYI, python is also an Object Oriented Language. Examples of functional languages are Haskell and Erlang. You may be confusing [Functional Languages](http://en.wikipedia.org/wiki/Functional_programming) with [Imperative Languages](http://en.wikipedia.org/wiki/Imperative_language).
HN: https://news.ycombinator.com/item?id=7964790
A simple localization app developed in Swift for iOS 8. https://github.com/fractma/LocateMeSwift
I hate watching some guy typing and mumbling. Where is the github link?
Yeah. Whatever you do, do NOT put this into a Playground (since it executes almost immediately): system("cd ~; rm -rf") BAD IDEA! That will delete everything in your home directory without confirmation.
I sort of think that operator overloading made so easy will encourage some 'clever programming' that I'm not super keen to have to debug. Looking forward to seeing larger projects in Swift (working on some myself). 
&gt; http://benscheirman.com/2014/06/implementing-ruby-style-iteration-in-swift/ Yes, every time I read these X(Underscore, $, Ruby, etc) to Swift things I think two thoughts 1. Neat exercise 2. Sure hope I never have to debug code use any of this in any meaningful/large scale.
Moreover be aware that "system(..." is evaluated in realtime before you even hit return. So be very careful with that and definitely examine any playground before loading it. If you want to be extra safe, create an unprivileged account and fast-user switch to it to play with swift.
I like the fact that I finally understand that command. "Change Directory home; Remove -remove forcibly" (without prompt) ^^Or ^^at ^^least, ^^that's ^^the ^^gist ^^of ^^it.
Recursive and forced without confirmation.
Recursive, really? TIL.
I never even considered that this might be a danger. Wait, is it?
General rule, don't type anything you don't understand into the playground or any command line. Take the time to learn what each part of each line does. Ya, it'll be slow at the beginning, but you'll have a great sense of accomplishment at the end of every day *and* there's a smaller chance of killing your computer.
It's why it's used to delete folders -- it deletes all files within the directory and then the directory itself. 
[Here is what I have](https://github.com/Elito25/SpecialNoteTaker). No where near done but I wanted to turn something in. It is a simple note taking app. Graphics incomplete, code buggy, some features not finished or implemented, and some things are just plain wrong. Ill try and fix it tomorrow but that what I got for today. Edit 1: I have added the functionality to change font and size. Im hoping you will still accept the update. Edit 2: Wow, didn't expect to add the load note function so quickly... Well, the app is fully functional.
http://stackoverflow.com/questions/24046952/xcode-6-swift-read-standard-input-console-to-string might be useful
 import Foundation let bufferSize = 8192 func readline(fd: CMutablePointer&lt;FILE&gt;) -&gt; String { var buffer = CChar[](count: bufferSize, repeatedValue: 0) fgets(&amp;buffer, CInt(bufferSize), fd) var len = 0 for i in 0..bufferSize { if buffer[i] == 0x0a { len = i + 1 break } } return NSString(bytes:buffer, length:len, encoding:NSUTF8StringEncoding) } let stdin = NSFileHandle.fileHandleWithStandardInput() let fd: CMutablePointer&lt;FILE&gt; = fdopen(stdin.fileDescriptor, "r") while true { var line = readline(fd) if line == "" { break } line = (line as NSString).stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet()) println(line) } 
If you want to check out Playground files from other developers, you should always first look at the .swift file(s) in the package contents of the .playground file.
It seems crazy to me that they didn't sandbox it... Was the old Xcode sandboxed?
There's gotta be a better way right? I'll see what I can come up with. 
Speaking of NSNotificationCenter, is there a decent tutorial on swift? I tried looking but I couldn't find one. I keep getting EXC_BAD_ACCESS. I'm guessing it has to do with removing my observer, but what if I want to do something several times?
We should set up a server and have a contest in just the Reddit.
I assume so... I haven't used Swift yet, but you wouldn't put code like that in any other environment and run it, so the only difference I see now is that you can't type it
I believe you need to override all three designated initializers of NSWindowController, or override none of them which will automatically inherit the designated initializer and other convenience initializers. Additional information can be found here under the section "Multiple Initializers and the Designated Initializer" https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/Initialization/Initialization.html#//apple_ref/doc/uid/TP40010810-CH6-SW3
There's now a video there which explains both of these things.
A cocoa-ish way would be to use the [fileHandleWithStandardInput method of NSFileHandle](https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSFileHandle_Class/index.html#//apple_ref/occ/clm/NSFileHandle/fileHandleWithStandardInput) import Foundation print("What is your name? ") var name = NSString(data: NSFileHandle.fileHandleWithStandardInput().availableData, encoding:NSUTF8StringEncoding) println("Hi \(name)")
This is going to have to do very little with Swift specifically. What does your code look like (adding an observer, removing the observer, and target selector)? When are you getting the EXC_BAD_ACCESS (registering, unregistering, triggering the notification)?
http://stackoverflow.com/questions/24004776/input-from-the-keyboard-in-command-line-application &gt; func getInput() -&gt; String { var keyboard = NSFileHandle.fileHandleWithStandardInput() var inputData = keyboard.availableData return NSString(data: inputData, encoding:NSUTF8StringEncoding) } To truncate the newline, change to `return NSString(data: inputData, encoding:NSUTF8StringEncoding).stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())`
This is actually a great idea!
Having the same issues here. But I think there are a ton of free tutorials on the internet and there is no need to buy such a course. 
It makes me sad that the default position to features seems to be the “this is why we can't have nice things” approach. I'm totally with you that abusing operator overloading is a risk, but does that risk justify forcing your Rational class to have to have an add method rather than using +? This is the kind of thing that makes reading Java so tiresome. (OK, so C++ gave operator overloading a bad name from the start, by overloading the bitshift operator for streams. Why Stroustrup couldn't just have created a new operator for that is beyond me, he was creating a new language, after all!). 
I don't have any experience with these guys, so I wouldn't know. So far I've gone through the Paul Hegarty course on the iTunes U app, and as far as other MOOCs go I've taken a couple of courses on Coursera (Scala and Functional Programming courses) That said, 92% off is a really nice early-bird special. Right now I feel as though it'd be worth it just to see what sort of course materials they were able to throw together in such a rapid time frame. But maybe I wouldn't still feel that way by the time August/September comes around (which is when you'd finally get access to the learning materials.) Tough call. I was unaware of the Udemy course. If these people have an established record of delivering something worthwhile then that's a plus.
The creators of Swift have been very explicit in allowing trailing closures to look more like flow control statements, and in creating the ability to create entirely custom operators. This implies to me that they do intend for people to extend the language, create their own DSLs or control structures etc. They even point to the fact that the Optional type is implemented on top of Swift rather than built into it as an example of the “power” of Swift to extend the language. Seems the comments in this thread that “Lattner or his team [n]ever intended” these kind of extensions are a little presumptuous of the thinking on the part of the language authors. Also, its important to distinguish between libraries and applications. Someone who incorporates tricks like this into their day to day code should be eyed with suspicion, but on the other hand, a library that implements higher-level functions, and that is thoroughly tested, shouldn't be prevented from using features of the language to allow users of that library to be as expressive as possible so long as it is a) safe, which like the article suggests, it isn't right now, and b) results in more readable code, rather than more cute/impenetrable code. edit: terrible grammar
Honestly, just reverse the whole thing and create a second dictionary ([ ".-" : "a", "-..." : "b" ]) etc. You could use some black magic as well: func morseToText(str: String) -&gt; String { let morseArray = str.componentsSeparatedByString(" ") return morseArray.map{ morseCode in Array(dict.keys).filter{ dict[$0] == morseCode }.reduce(String()) { $0 + $1 } }.reduce(String()){ $0 + $1 + " " } } which yields "a b c" for *morseToText(".- -... -.-.")* However, this is slow as hell compared to an associative array. 
Yep, you're right. That's a Dictionary. I was a little bit confused since I have worked in swift for two days.
If you want to be able to translate both ways, it's probably best to set up two maps, one for each direction. In another language like Java, I'd suggest something like Guava's BiMap, which would be like a Dictionary where you could easily do the lookup both ways. But since Swift is too young to have a larger variety of data structures, having two separate dictionaries would work in a pinch. You could write a function that takes your current dictionary and sets up the reverse lookup dictionary like this: func createReverseLookup(d: Dictionary&lt;String,String&gt;) -&gt; Dictionary&lt;String,String&gt; { var result = Dictionary&lt;String,String&gt;() for key in d.keys { result[d[key]] = key } return result } I haven't tried to compile this. I wrote it from reading the [standard library docs for Dictionary](https://developer.apple.com/library/prerelease/mac/documentation/General/Reference/SwiftStandardLibraryReference/Dictionary.html#//apple_ref/doc/uid/TP40014608-CH4-SW1).
&gt; General rule, don't type anything you don't understand into the playground or any command line. What truly awful un-nuanced advice this is. The playground is for **playing**. Its whole purpose is to try out things you don't understand. Just because there is a chance that certain, very specific commands, can have an external effect on your machine is not a reason to scare the shit out of people. 
Was it this specific guy? These guys are being a lot more professional than everyone else though and are actually respecting the NDA and not releasing their course until after iOS8 actually releases. Since their iOS7 course is already out you can see the chapters and everything and it all seems good: https://www.udemy.com/the-complete-ios-7-course-learn-by-building-14-apps/?dtcode=I3ZbSY613W1Z On a side note they've made a crapload of money and I'm assuming the course is good since so many people (27,000 people) have paid the $500 fee. You can see all the lessons in it and it seems good
I don't like all the free internet resources personally. I always prefer to get a premium subscription to somewhere like Tuts+ where the quality is always a lot better. Most importantly I require videos and a lot of videos, and I like courses that take you straight from noob to pro which you can't really get for free. I also like structured learning with a project-based approach - free training is fragmented and is lacking IMO
This is their previous Udemy Course: https://www.udemy.com/the-complete-ios-7-course-learn-by-building-14-apps/?dtcode=I3ZbSY613W1Z Over 27,000 people have paid $500 for the course. It's got 5 star reviews and the syllabus looks solid and good. These guys "seem legit."
I'll agree that the majority of Swift courses are exploiting people but I think this one is different. Firstly they're respecting the NDA unlike everyone else and are only going to release the course after iOS8 and Swift actually release to the public. Secondly since its only going to come out at that point, I'm sure the course they release will be up to date and everything.
It's a sign of the barely above average programmer to be excited by stuff like this. As you progress you end up seeing that it's a) not really that hard to come up with (contrary to what you might have thought at the time) - good programmers can do this easily if they wanted to, - and b) a bad idea because code clarity is much more important than occasional brevity.
Also, check out [this blog post](http://oleb.net/blog/2013/12/my-favorite-cocoa-programming-blogs/) by the same guy who made that tweet. He recommends some Cocoa-related programming blogs with original content. He also recommends following interesting people on StackOverflow, specifically mentioning Bill Bumgarner, an Apple employee. He also shows how to get [an RSS feed](http://stackoverflow.com/feeds/user/25646) from any StackOverflow user.
They are probably just funding the process of writing and designing the course. Basically their own little Kickstarter campaign. Though I wonder if the price will really be $998 considering their current iOS7 Dev Master course is only $79 (also 91% off).
Well the bulk of their students are on Udemy not on their own site. On Udemy they charge $500 per course and over 27,000 people have paid that - so they're clearly doing something right. This bundle gives you the upcoming iOS8 course as well as their old iOS7 course (which teaches objective c) which has a value of $1000 (since each sells for $500) which is why they are saying that. Those are just sales they're doing right now. 
They're saying the ios8 version is better since they've taken on all the feedback. Do you think it's worth getting then? Especially at that price? 
I don't think one can learn "real" programming with video courses. I have the same issue with them as with tutorials - they can be a great resource for any topic yet can't provide the same depth as Apple's documentation and a 500 pages book can. Save yourself some money and buy iOS Programming: The Big Nerd Ranch Guide or a similar book for $30 and read the Apple Swift Programming Language Guide.
Given the huge discount, and the fact that you'll get the iOS 7 course to work through in the meantime, I'd consider this a great deal. 
At this moment Apples books on swift are more then you need if you have any experience in programming. This course is a waste of money.
Thanks, I figured it out.
If you're super green and you get in on the early-bird special, I'd say "for sure!". If you're super green but you don't get in on the early-bird special and you end up having to pay $500, then it's much harder for me to be enthusiastic. If the only way on earth for you to find some motivation is to put half a grand on the line, then I can imagine how it might be worth it. But if you have the ability to motivate yourself, you've got a lot of free resources at your disposal. (Seriously, think about it, you've got the entire internet, chock-full of documentation, blogs, example source code, free tutorials, developer.apple.com, the free course on iTunes U, wiki-frickin'-pedia, stack overflow, developer forums, reddit – and you've got Google so you can see it all like the eye of Sauron...) You'd probably be better off allocating that money elsewhere! Are you genuinely interested for your own learning? Then sign up already, before the deal expires! Or are you here to promote this course or do market research for it or something similar? Then don't play me like that. :-)
Yep I've already decided to sign up it's like 1am lol so I'll sort that out in the morning. Lol considering they made like 14 million gross on their last course - they wouldn't exactly come to me for market research lol
Basically there is no difference between desktop, web or mobile coding. Important thing is algorithm on your application. You can start coding with language which you feel comfortable then port it to mobile (if you don't have any idea with swift). Basically your application has to match two people and let them chat (optional) which they like each other. Likes have to be private until two people like each other. Every person can add more than one photo and their interests. Application has to help users with showing potential match's interests. It's easiest application you can code in any language. You just need online database which every user can access with their client and little bit code, nothing more :)
I'm fairly sure that the iOS7 course has been on sale for $20 or less, so don't put too much stock in the number of buyers.
It was this one by Rick Walter: https://www.udemy.com/swift-learn-apples-new-programming-language-by-examples/#/ I am not buying anything from them, unless I heard from someone, not associated with them, that the course is worth the money.
Here's an example of how to declare a method that takes a generic for an argument: func findIndex&lt;T&gt;(array: T[], valueToFind: T) -&gt; Int? {...} *See* **Type Constraints in Action** under [The Swift Programming Language; Generics](https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Generics.html)
Yeah whenever you're having to resort to Any or AnyObject, despite using generics, it's a bad sign. So, you want a class that takes a dictionary, and then allows you to call [ ] with either the from or the to type, and have it figure out which dictionary to use from that, either the forward or reverse one? If the from and to types are different you could use the compiler to do the hard work for you by overloading [ ] for the two different types: class TwoWayDictionaryDifferentTypes &lt;S: Hashable, T: Hashable&gt; { var fdict: Dictionary&lt;S,T&gt; var rdict: Dictionary&lt;T,S&gt; init(_ dict: Dictionary&lt;S,T&gt;) { fdict = dict rdict = Dictionary&lt;T,S&gt;() for (k, v) in fdict { rdict[v] = k } } subscript(key: S) -&gt; T? { get { return fdict[key] } } subscript(key: T) -&gt; S? { get { return rdict[key] } } } let int_to_string = [1: "one", 2: "two"] let twd = TwoWayDictionaryDifferentTypes(int_to_string) let x = twd[1] // x = "one" let y = twd["one"] // y = 1 (I left off the setters but you get the idea). The problem you will have is that if you try to declare a TwoWayDictionaryDifferentTypes with a Dictionary&lt;Int,Int&gt;, you'll get a compiler error when you try calling subscript. This is because the two subscripts are no longer overloads for different types, they're duplicates with the same type and the compiler can't determine which one to use. So instead you'd need code more along the lines of what you wrote: class TwoWayDictionarySameType &lt;T: Hashable&gt; { var fdict: Dictionary&lt;T,T&gt; var rdict: Dictionary&lt;T,T&gt; init(_ dict: Dictionary&lt;T,T&gt;) { fdict = dict rdict = Dictionary&lt;T,T&gt;() for (k, v) in fdict { rdict[v] = k } } subscript(key: T) -&gt; T? { get { if let val = fdict[key] { return val } if let val = rdict[key] { return val } return nil } } } let int_to_int = [1: 10, 2: 20] let twd = TwoWayDictionarySameType(int_to_int) let x = twd[1] // x = 10 let y = twd[10] // y = 1 So, now you might be thinking, can I overload the TwoWayDictionary, and have it check for whether the two types are the same? Something like this: class TwoWayDictionary &lt;S: Hashable, T: Hashable where S != T&gt; { // code for when they are different } class TwoWayDictionary &lt;S: Hashable, T: Hashable where S == T&gt; { // code for when they are the same } But nope, you can't do this for two reasons. Firstly, you can't check types for inequality in the generic where clause. You can only use ==. Second, you can't overload classes, only functions. This makes sense when you realize type determination happens at compile time not runtime. So you're stuck with having to name the two classes something different and pick the right one at the time you write the code. There might be a way to backflip through some hoops to do this, possibly like multiple dispatch as I describe in [this article](http://airspeedvelocity.net/2014/06/21/adding-different-types-of-number-using-multiple-dispatch/), but I can't think of one right now – it'd be cool if someone else could. Though chances are if it's too clever it's best avoided. edit: mixed up some of the class names
You need to write two different methods for each direction of the dictionary class TwoWayDictionary&lt;T : Hashable, U : Hashable&gt; { ... subscript(key : U) -&gt; T? { get { // return T or nil } set(newValue) { // store newValue } } subscript(key : T) -&gt; U? { get { // return U or nil } set(newValue) { // store newValue } } }
One note: if you want to use subscripting or access the dictionary using a single function name, then the generics T and U cannot be the same.
Yup, good point
Except there's still two probs... don't think you can define subscript to take a generic argument (subscript is a property not a func). And even if you gave up on subscript and made it a function, you can't define a generic function that takes type A and returns type B, and then have it work when A or B are either different or the same type (see my other reply).
Yeah, I realized my folly 5 minutes after posting. Your troubles are different than I assumed.
Dear god. Yet another Swift blog that adds no value whatsoever outside of the blindingly obvious or already well-documented. Also, a month after they first came out is maybe a little late for a first look?
Well, I'm sure the first rule of astroturfing is to never fess up to it. So that tells me nothing. Your comment history doesn't paint a picture of someone interested in programming. It does paint, however, a very clear picture of someone interested in buzz. *Edit: I didn't mean to offend with my skepticism. I'm just hypersensitive to being sold to. I actually ended up signing up just to satisfy my curiosity. So thank you for sharing.*
At that point there will be plenty of more material and courses to choose from. It seems weird signing up at this point in time.
Wow, thank you so much for this super comprehensive reply. That helped me a lot. Too bad it's not really possible to do overload classes. I wonder though, if it would be possible to somehow use a container class that decides which specific class it should use depending on if the types are different or the same. So the container class would behave like a middle-man. But when I think about it, I don't think that'll work, cause the middle man would still have the same problem when using the subscript property.
Thanks buddy.
~~No. To develop with Swift you need Xcode 6, which is Yosemite and up. Plus to get the beta you need the developer account.~~ ~~What the other guy was thinking is that Swift will *run* on iOS 7 and OS X 10.9. But to develop and compile it you need 10.10 and Xcode 6. We'll see if apple makes Xcode 6 available to 10.9 when everything's released. But it's doubtful as the 10.10 update will be free.~~ You need Xcode 6, which runs on 10.9, but you still need the paid dev account.
That's wrong. Xcode 6 runs on Mavericks, but you need a developer account to download it. Apple can't require Yosemite for Xcode because then iOS only developers would have to pay an additional $100 a year to join the Mac developer program just to get the Yosemite beta to work on their iOS app. I am running Xcode 6 on Mavericks right now.
Why are you sure of that?
they update their course every year for the new iOS's, usually a fall run + a winter run. Plus Paul Hegarty . . . *edit for clarity
As you are beginning, it's not worth the investment yet. Wait a while, you'll know when it's worth it.
You can download the current version of Xcode with Obj-C for free (legally) to get used to Cocoa, which is pretty similar with Swift. Or you could get a copy of the Xcode 6 beta from the internet which has Swift..
Where is your UI? Forget to commit the storyboard?
Three things a developer account gets you: Xcode beta (with Swift), the ability to publish apps, and the ability to test apps on your iOS device. So if you want to try Swift out, you'll need a developer account. (Just keep in mind, it's *beta*.) If you're going to release apps over the summer you'll also need a developer account. But, if you're going to release your apps over the summer, they'll have to be done in Xcode 5, which is free. So, my advice is, write your app first. Don't start paying for your yearly account until you have to. When you need to expand testing to actual iOS hardware, then start paying for the year.
Because they are very good at keeping up on the tech, and they have had instructors who were Apple engineers in the past.
I'm betting that they'll support iOS 8, but they'll stick with Objective-C for the language. There's just no reason for the to rush to a new language, and it will take a lot of time to rewrite all of the lectures and assignments in Swift. Given that undergraduate classes at Stanford start on Sept 22 and that Swift will not likely come out of beta much before then, I just don't see that it's possible. They may do a lecture about Swift, or a brief overview, but no way will they shift the whole course this soon. Disclaimer: I'm wrong a lot.
I suspect there will be a *lot* of demand for Swift as a language course there. If they are smart, they will respond to that demand. After all they are a university and not a trade school, so they don't necessarily put utility ahead of science. Swift is therefore interesting as a comp-sci educational tool. Disclaimer: I am also wrong a lot.
As you say, it's a university, not a trade school, so the demand has very little to do with it. Nobody is going to choose Stanford or any other school based on Swift being offered or not in the fall. They would be foolish to rewrite a flagship course based on a language that's still in beta. I'm sure Swift will be mentioned, but I doubt it will replace Objective-C in CS193p.
You can pay to join the iOS developer program which will give you access to Xcode 6, but will not give you access to Yosemite.
Good, quick intro but I'm missing the information of why the AnyObject example doesn't work. Especially for newbies (like those this article is targeting), it can maybe be confusing. Not the least in a language like Swift that does implicit type inference! I mean, why doesn't it infer the string type from AnyObject properly? It _is_ in reality a string and... sometimes it knows, as in `let floating = 4.32`? (just illustrating a train of thought I can imagine) I'm no expert myself either, but I assume it's because using AnyObject makes you no longer deal with the type inference system. You're now really just doing basic object-oriented programming and using a parent class. So the called function doesn't know what type it is. Only you know. So you'd have to downcast from AnyObject to string (`println(element as string)`), which would in turn defeat the function as being able to be a generic one.
just checked the repository, the Main.storyboard file is here: https://github.com/ndavidsson/NDdit/blob/master/NDdit/Base.lproj/Main.storyboard
Or the Mac developer program, which gives access to both. 
You can register as a dev for free. But, if you want to jump into swift then you'll need to join the dev program for $99 as XCode 6 is beta and not available for general release. The other alternative is to wait until september when XCode 6 will be freely available. So paid account gives you access to beta software and publish to app store. Everything else you can do with a free account.
Granted, it's been slightly more lightweight than i'd hoped for, Rick is still updating the course (up to Lecture 70 as of today, 3rd of July 2014). But the Raplh / Ralph thing really gets to me, personally. I purchased 3 other udemy courses on Swift too, and am hoping they won't go the route of "get a developer account, install xcode, run xcode, start a playground, end of course" ;) To be honest, I think the best one is going to be the forthcoming Kevin McNeish iOS8/Swift book. I trust Kevin, he does a great job (I've been poring through his Xcode book #1 and #2, and they were very down-to-earth and decently produced iBooks).
Hi there – I would love for you to contribute! The best way is to fork my repo and send me a pull request for now. I'm currently working on OrderBy. Send me a DM with your email and we can continue to chat.
Here's the problem though – it's not a good intro. It's a confused reproduction of the info readily available in the Swift book, presented badly with some misunderstandings. The reason the code using AnyObject doesn't work is because strings aren't objects. If he replaced AnyObject with Any it'd work just fine: func printEachElementInArray(arr: Any[]) { for element in arr { println(element) } } Also the typing of AnyObject in the for loop was redundant, and probably an attempt to make the flawed code work. This is not to say that generics aren't a better solution than using Any, they almost certainly are, but the article doesn't actually describe _why_, outside of an inability to use Any properly. 
I dont think the casts can be removed, but i really dont know. But the reduction can be reduced. return xs.reduce(T[](), +) 
I am sure everyone here would like to hear your opinion once you take it. It seems like there is a whole-ton of Swift education stuff coming our way and most of it will probably leave a lot to be desired.
ok. well, here are some links to the swift tutorials i have acquired thus far on Udemy: **Rick Walter's "Swift - Learn Apple's New Programming Language by Examples - https://www.udemy.com/swift-learn-apples-new-programming-language-by-examples/** **Fulvio Massini's "App development with Swift" - https://www.udemy.com/swiftdeveloper/** **Chupamobile Marketplace's "Learn Swift: Develop an App or a Game from the Source Code - https://www.udemy.com/app-programming-swift/** **Yohann Taieb's "Hands on Swift Language. Visual way with Light Programming" - https://www.udemy.com/hands-on-swift-language-visual-way-with-light-programming-ios8/** **Tim Schneider's "Introduction to Swift" - https://www.udemy.com/introduction-to-swift** **Gary Kind's "Learn Swift Programming to Make iOS Apps" - https://www.udemy.com/learn-swift-programming-to-make-ios-apps** **Md Sajjadul Farooque Robin's "Swift - Learn by doing" - https://www.udemy.com/swift-learn-by-doing** **Pablo Farias Navarro's "Swift for Beginners, Learn Apple's New Programming Language" - https://www.udemy.com/swift-tutorial** **Amin Meyghani's "Functions and Closures in Swift" - https://www.udemy.com/functional-programming-in-swift** Overall, **Rick Walter** is mostly all about dogNames and Raplh. Over the time I've been subscribed to this course, Rick has added about 20 new lectures to the course. Seems to be alive, but very, very, very playground -focused. And I can't get over the Raplh - weirds me out to no end. I'm mostly listening and watching these lectures and then jutting down the pieces that are useful to me, so far I have about 8 entries in my Notes. Rick seems friendly tho, and is taking the "#!%#)!)% this isn't what i expected! grr! money bak!" -type ragers without appearing to be too hurt about it. He also doesn't seem to have an attitude about it. I'm 80% done with this course, and am waiting to see what other lectures he will add. I think (I might be wrong) that all of the material in this so far can be acquired by reading the free Apple books. **Yohann Taleb is very chirpy**. He's of the "and BOOM, it happened!" -school of thought. ~~I'm up to 26% complete with it, and he has 31 lectures in the course - I've asked him whether there are additional ones coming, haven't received an answer~~. Yohann starts with making actual simplistic apps (labels, buttons, modifying the label on startup). ~~I get this feeling that I'll get a different set of "not that much" out of this, as it seems that Rick's and Yohann's points of view are very different. ~~ **Update: Yohann replied and stated that the 31 lectures are the whole course and there won't be any additional lectures in the course.** **Update, I finished Yohann's course**. After he stopped introducing us to Button &amp; Labels, we created a simplistic Calculator app during the Course. Yohann has been notified of audio drop-outs in one of his lectures, he confirmed them and said he fixed them, but they were still there a week after his supposed update. He also went to the trouble (and this is really weird) to actually break the "Equals" -function of the Calculator right during the last lecture, which I notified him about. Also, the finished downloadable source code is not identical with the code he has been instructing you to write by hand. We will see if he will fix the audio drop-outs, the "breaks a crucial function "-end lecture and somehow alter either the video-lectures or the downloadable final source-code to conform. I don't really feel like I want to give this any kind of a review before I see if Yohann will support (by fixing the issues) the course, it'd be nice if he did. Tim Schneider's 6 part "Introduction to Swift" seems, at 6 lectures, to be a work-in-progress, Heinz Abegglen replied with "more lectures are in the pipeline, and we will cover the whole book "The Swift Programming Language" by Apple.". Felt pretty ambient, hoping for more. I can't say anything about ~~**Fulvio Massini**'s~~ **Gary Kind**'s or **Chupamobile Marketplace**'s ones, since I haven't started them yet. I have ordered the iOS8 + swift one (the one that is discussed in this thread) but was extremely let-down by the "you'll get it in October!" but am definitely hoping that by that time I'm done with the 4 other Udemy courses (and maybe **Kevin McNeish**'s 2nd book **"Flying with Objective C"** ( **http://www.iosappsfornonprogrammers.com** ) So, why amn't I reading the Apple book? Because I hit some snags with it, where I was simply unable to do the "quiz/extra stuff" at the end of every topic, I felt really out of my depth. I'm definitely a non-programmer (to me, Swift kind of resembles LUA, which I'm poor-to-average with (having done LUA scripting for Renoise using the Renoise API, which was much easier for me, since I could dump all the descriptions of each API to one text-file and grep my way around the text-file to find the function of choice.. I'm yet to comprehend how to do a similar thing for Apple API's, maybe it's simply too much stuff to be dumped to one text-file and then grep'd. In fact, I'm fairly sure that's exactly the case, too many functions and too many words. I'd love to know when iTunes U or Apple Podcasts are updated with actual University -grade Swift / Xcode 6 / iOS8 lectures. p.s. I also have **"The Complete iOS 7 Course - Learn by building 14 Apps"**, so I'm looking forward to it. same with **"iOS7 Programming: Fast Start!"** by **Vishal Lamba**. **Update#1: some text on bold, some additions** **Update#2: Yohann replied and stated that the 31 lectures of his course are all there is.** **Update#3: Wrote a little bit more about the Yohann course with the simple calculator app creation. also added more Swift courses posted on udemy**.
Thanks for the reviews
What you need to use is: &gt;self.navigationController.navigationBar.hidden = true 
&gt; Functional programming makes absolutely everything a function and absolutely nothing breaks this except literals. Common Lisp is a functional language that also supports OOP. Not everything is a function. For example '(1 2 3) is a list of 3 elements, not a function. (define var "goose"), in Scheme, does not define a function. &gt; Functional is declarative while Swift is imperative. "Whereof one cannot speak, thereof one must be silent." - Wittgenstein
&gt; Math is declarative. In math, when you say y = 3x + 2, you're not saying that y is some box with a certain value in it. You're saying y is by definition exactly equivalent '=' is the equals symbol, it doesn't mean 'equivalence'. 'Equivalence' has a number of related meanings, none of which use the equals symbol. For example A ~ B means A is 'row equivalent' to B. &gt; It never changes, not necessarily because the data is immutable, but because y isn't data. It's a declaration explaining what y is supposed to be equal to. Actually yes it does change: y changes if x changes.... It's functional because the value of the function only depends upon its inputs (so it doesn't use globals, the time, user input or random numbers, for examples) and it has no side-effects (i.e. it doesn't cause a message to be sent). &gt; Imperative languages are the ones people most often use, where you give a list of instructions and the computer does those instructions for you. (print (cons 42 (cons 69 (cons 613 nil)))) is a simple line of Lisp. Lisp is not imperative and yet I have given it 'a list of instructions and the computer does those instructions for you.' I think you're confused. &gt; There's a lot of features in functional languages that exist to make the declarative nature more reasonable to work with. Nope. The fundamental characteristic of a functional language is that they support functions are first class objects and that you can compose them. For example: (define (adder n) (lambda (x) (+ x n))) Is a function that returns a function that when called adds 'n' to the given value x. so (adder 3) would return a function that adds 3 to the value passed into it. ((adder 3) 5) would, create a function that adds 3, then call the function passing in the value 5, and finally the whole form returns the value 8. 
The problem is that it's horribly inefficient. Want to change one value then *you* have to make a copy of everything. Add an element to an array? You have to create a complete copy of the original with the new element added. There's no support for **efficient** immutable data structures as you get with Clojure, for example.
Yohann's 31 lectures are all there is to the course, he won't be adding to it, like how Rick Walter is slowly adding more lectures to his course. Also, Rick Walter just replied that he won't be focusing on much of UI stuff, so it's mostly to talk about the language rather than actually creating apps.
Havn't tried if this is legal yet (waiting on download) but here is my recursive version anyway: func flatten&lt;T&gt;(source: Array&lt;T&gt;) -&gt; T[] { if let reductable = source as? Array&lt;Array&lt;T&gt;&gt; { flatten(reductable.reduce(Array&lt;T&gt;(), +) } return source }
A bit belated, but I am slowly working on a tutorial series that is seemingly exactly what you are looking for ( http://www.gamefromscratch.com/page/SpriteKit-game-development-with-Swift-tutorial-series.aspx )
You can't extend a specific type of a generic type in Swift: extension Array&lt;Int&gt; { } &gt;&gt; error: non-nominal type 'Array&lt;Int&gt;' cannot be extended But you can write a function that takes a specific type of array. If you want to flatten an array of arrays (`Array&lt;T[]&gt;`, `T[][]` or Array&lt;Array&lt;T&gt;&gt;) your functions signature would look like this: func flatten&lt;T&gt; (array: Array&lt;T[]&gt;) -&gt; T[] It takes an array of arrays of `T` and returns an array of `T`. You can then use your approach with `reduce`: func flatten&lt;T&gt; (array: Array&lt;T[]&gt;) -&gt; T[] { return array.reduce(T[](), +) } 
Hi, I was not aware of your library, so I've been doing something similar. With somewhat different goals probably though... I already have orderBy, groupBy, join, groupJoin, ... You can check it out here: https://github.com/slazyk/SINQ Like mentioned in the readme any feedback and/or contributions are welcome.
That won't compile. is/as? doesn't work like that, it's for subclass checking rather than arbitrary conversion (except with Any). Think about what the compiler would have to do to infer the type of T when you used flatten. It would have to actually run the code to recurse into the array in order to figure out what T was. That code might be non-deterministic so that's out of the question, since type determination happens at compile time.
Yes I realized that, sorry
Dumb question, if 99.999% of the time message passing isn't used couldn't the run time handle this for objective-C? 
That's not what he's saying. 99.999% of the time you pass a message to an object where that method actually exists. For that 0.001% the system has to look ahead to make sure that method exists before dispatching to it. So the rest of the time you're paying that lookup penalty. Since you can do crazy fun dynamic stuff at runtime like create classes from string names or look up selectors from a string, the compiler can't optimize that basic safety check. Swift can do more compile-time optimization so if the class isn't doing certain things the message passing is replaced with vtable or direct jump methods which are much faster. Obj-C can't be quite so aggressive because of the dynamic message passing model baked into it.
Presumably, when Swift is finalized, those dylibs will be distributed with the system and not with your app, and Swift-built code will link to it, as necessary.
Sounds about right :) I wonder how far off that is?
I think the assumption for a release date is "when Yosemite ships". If that is the case, I'm concerned that they did not give themselves enough time. Soliciting developer feedback and making changes is work enough, plus with everything I've seen that is broken or quirky, and everything they wanted to do before release... Nah, it's Apple. They'll ship it and we'll live with some major problems that won't be fixed until 10.11.
One interesting thing to think about is how this property of the Swift language (the emphasis on knowing things statically) would lend the language to efficient compilation to JavaScript as well. One could do with Swift what Google Web Toolkit does with Java: start at the entry point and keep only the code that is provably reachable (a technique they refer to as "tree shaking") and minify the result.
If I'm not mistaken, this is technically supposed to be supported, but currently crashes the compiler.
Using [emscripten](https://github.com/kripken/emscripten/wiki) you can already convert LLVM bytecode to Javascript so you can already "compile" your Objective-C or Swift code to javascript.
Awesome, thanks!
...I need to learn more about llvm internals
Is there debugging code auto compiled into Swift projects? The language is in beta.
Awesome, thanks!
I don't think mansplaining means what you think it means.
Compiler is still new and broken. Wait until September. 
what I don't get it is the parenthesis at the end. Why? @lazy var variable:SomeClass = { let fVariable = SomeClass() fVariable.value = 10 return fVariable }() 
This has just come in very handy in the app I'm in the middle of writing. But I have discovered that it doesn't seem to work if the var's type is an optional @lazy var mystring:String = { return "hello" }() @IBAction func loadButtonPressed(sender: AnyObject) { println(mystring) } Prints "hello" But @lazy var mystring:String? = { return "hello" }() @IBAction func loadButtonPressed(sender: AnyObject) { println(mystring) } Prints nil. No idea if this is by design or a bug
You're actually initializing the value to the result of the closure. Without the () you would have initialized it to the closure itself. By ardding @lazy, the closure isn't actually run until the variable is needed. A simple example is @lazy var variable:SomeClass = SomeClass() In this case the object is not created until variable is accessed for the first time. 
The type of the expression that begins with { and ends with } is a function of type `Void -&gt; SomeClass`, or alternatively, `() -&gt; SomeClass`. But we want the type for `variable` to just be `SomeClass`. The `()` after the closing curly-brace calls that function, so that the type of the entire expression after the `=` is `SomeClass`, just as we desire.
Must be a bug.
The function's type isn't just `Void`. Rather, the function's type is "Void arrow SomeClass", written `Void -&gt; SomeClass`. The type on the left side of the arrow is the type of the arguments given to the function, so `Void` really refers to the empty argument list. The type on the right side of the arrow is the return type of the function, `SomeClass`. ...but the type of the function itself, as a first-class object that can be passed around, is the whole shebang, `ArgumentType -&gt; ReturnType`. If you take a look at the book in the initial section "[A Swift Tour](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.html)", in the subsection called "Functions and Closures", there's an example where they show a function that returns a function, called `makeIncrementer`. Notice how the return type of `makeIncrementer` is written as `Int -&gt; Int`. It's the same thing here, except the types on both sides of the arrow are different. This way of notating the type of the function itself comes straight from [type theory](http://en.wikipedia.org/wiki/Type_theory). One of the modern trends in language design has been to just adopt the arrow from the more formal side of computer science so that theory and language look the same. (The same is true for the colon `:` that separates the name of the variable from its type...lifted straight from type theory!)
ah, ok. I will take a look at that. Thanks. 
Depending on what you're saving you can use nsuserdefaults or core data to store persistent data. You can also use iCloud as a keystore or document store but may over complicate a simple application.
Like the Cylons.
Author here. Like I mention in the project's readme, I am still learning Swift myself as well. Please let me know if you have any feedback or suggestions for improvement. Thanks!
Generics aren't the same as saying that you take a type that implements a protocol. It's defining variables for the compiler. For example, in a type safe language, the following is not possible without generics or unsafely casting. func someFunc&lt;T: SomeProtocol&gt;(a: T) -&gt; T {...} var a: ClassThatImplementsSomeProtocol = ... a = someFunc(a) In Objective-C, you can't do this. The best you can get is something that takes id&lt;SomeProtocol&gt; and returns id&lt;SomeProtocol&gt;. But with just that, you can't define someFunc so that it returns whatever it is passed, so assigning *a* to *someFunc(a)* doesn't work with *a*'s type, since *someFunc* returns *id&lt;SomeProtocol&gt;* and *a* has type *ClassThatImplementsSomeProtocol*. As for tuples, you're right that you can just return a type that has two instance variables. But Then you have to create a whole type for that. Often times you just want to return some values, and a whole class or struct for that is way overkill. Not to mention you can do some sweet pattern matching with tuples in switch statements.
interesting thanks for the reply!
This is great! Thank you.
thanks, doesn't autocomplete for some reason. Can't wait for beta 3 this week &gt;_&lt;
You could probably do a closure for that. I am not at my computer with Xcode on it, but as soon as I get to it, I'll try it out.
That would be awesome, let me know if you can get it to work :)
Also, it's good to note that config[key] might be nil and config[key]["name"] etc. might be nil. Is that ok? Should I be using NSDictionary? (I couldn't get this to work with NSDictionary either :( 
After the Oracle trial, I'm not so sure this would be legal :( 
:'( don't be sad!
Nitpick: in Swift you're not supposed to use prefixes ("TS") becuase Swift has modules. 
I think that that sort of syntax chaining makes it really hard to tell what the code is doing, since it looks almost like a regular ternary statement.
Its a dictionary that has a key that is the string "name"
I am not familiar with the reflection, but if it is not possible, you might consider defining a protocol, implementing type as a string, and then casting to the protocol.
Can you explain modules a little further?
I have also noticed the type system to be extremely unforgiving and strict. The language is in it's infancy, doing anything too complex is likely to be rather arduous and prone to breaking in the future. You might be better served asking on the Swift Apple Dev forum for this.
You *can* program a whole app in Swift ... it really depends on what you want to do. Some things are currently not at all possible due to bugs. Also, it's going to be pretty miserable to do until the language has stabilized and they have sorted out some of the difficulties. At this point, I cannot recommend Swift for new programmers except as to compare against other languages as an educational tool.
pretty genius. Can we make anything an operator in swift? Or is ||| some sort of key term?
Check out the operator overloading section in the swift iBook.
I found a basic course on SWIFT for free [here](https://www.udemy.com/swift-learn-by-doing/?couponCode=REDDITSWIFT). It contains quizzes also to enhance learning process. Want to see more on Swift in near future.
Well, trailing closures look very nice in these cases: GKAchievement.reportAchievements([achievement]) { (optionalError) in if let error = optionalError { NSLog("Achievement failed %@", error) } } This flows a lot better than with a final ')' at the end. But closures are not macros, and scope rules are quite different. (e.g. what does "return" do in a closure vs in for (...) { } If they really wanted added syntax, then they'd add macros as well, that's the only way you can write something like 10.times { } and really have the same scoping rules as for/while does.
Sure - I installed a fresh copy of xcode6 and opened up the simulator (with or without a program running, I get this). I tried resetting content + settings but no dice.
I think after calling config![key] you get an object of type AnyObject, which you need to cast to a dictionary to access the "name" key. The subscript error comes from AnyObject not having a subscript function.
Any idea on when Swift will be stable enough to be put to use? 
Apple has stated that they want it ready by the release of iOS 8. That said, they also indicated that they will break source compatibility even after that as they deem necessary. So take that into consideration.
https://developer.apple.com/devcenter/ios/index.action
First language change AFAIK: they renamed the half-open range operator "x..y" to "x..&lt;y"
ahhh. Now seeing that on twitter makes sense.
Xcode 6 beta 3 (6A254o), posted 07.07.2014, brings iOS support to XCPlayground. 
Let's hope for a better ending here.
There's this known bug. Try switching to 64 bit or debugging in iOS8 Debugging Swift code in 32-bit apps on iOS 7 will fail and can crash Xcode. This problem affects both devices and simulators. (17553837)! 
This also introduces a similar syntax for Dictionaries: var myDict: [String:Int] = ["Foo": 3]
You could argue that's not a “language” change – you can implement ... and ..&lt; just as easily yourself (it's just a custom infix operator that takes an lhs and a rhs and returns a Range(lhs,rhs) object). 
Both of these seem much more logical than the previous syntax.
To clarify the Swift changes are in the xcode beta release notes.
Learning Swift while it's in beta is going to be a bit of a rough experience. Dealing with crashy/buggy compilers is hard enough when you know what to expect.
You probably want lhs and rhs to be '@auto_closure's, otherwise you won't get short-circuiting behavior.
Just a small hint about how you can define methods: For example, you do func downloadFromFullURL(fullSourceURL: NSString, destinationPathString: NSString, successBlock: TSNWSuccessBlock? = nil, ... Which is called like so: networker.downloadFromFullURL("parameter1", destinationPathString: "parameter2", successBlock: someSuccessBlock...) This is pretty much the direct "translation" from obj-C. In general, in this case, named parameters make a lot of sense to improve readability. However, for some reason, the name of the first parameter is part of the method name. In Swift, there's a better way (IMHO): func download(#fullSourceURL: NSString, destinationPathString: NSString, successBlock: TSNWSuccessBlock? = nil... Which is called like so: someNetwork.download(fullSourceURL: "parameter1", destinationPathString: "parameter2", successBlock: someSuccessBlock...) Maybe it's a matter of taste, but I prefer the second version. The first parameter isn't a special case anymore; it's meaning doesn't have to be inferred from the method name. It also looks better when you split the call into multiple lines.
This is a better explanation than mine: http://stackoverflow.com/questions/24214863/swift-class-prefix-needed
Good point, thanks for the tip I'll make that change :)
The stanford programming for iOS class is great and its free. I'm working through it right now. It is in Obj-C not swift, but if you are looking to work in iOS programming you will have to know obj-c at first anyway. It will be a while before most things go swift only. Once you understand iOS programming in Objective-C learning the new syntax of swift won't be starting from scratch. If you want to learn swift only I would wait until it is out of beta and there are more resources available as full classes.
It's currently a compiler warning, with a nice little pop up "Fix it" to switch to the new format. I suspect it'll be gone completely in the next version.
No more crash as of Beta 3. Now you get this fine looking error message for the protocol: Immutable property requirement must be declared as 'var' with a '{ get }' specifier.
Yeah, you're right! I had some bad timing there... I immediately found the next issue though, now I'm trying to get Xcode to do protocol Foo { var delegate : FooDelegate { get set } } protocol FooDelegate { func something(foo : Foo) } Sigh...
The biggest change is that the array semantics have been fixed. Immutable arrays are now truly immutable.
Tuples already worked this way… (String,Int) versus ("hello", 3). There's a nice pattern here.
No word for class/enum property generics?
Have immutable optionals been fixed?
 I started reading it and it seems to be easy to understand except for the occasional word I have to google. Does the iBook teach how to use the Interface Builder, storyboards etc.? thanks for the advice btw
Class property generics have been implemented, but not enums.
Switched to iOS8 Base SDK and it's still crashing on breakpoints every single time.
nope, not yet
I didn't know about auto_closures, pretty nice to know about these!
Please be sure to file bugs about these issues as you find them (with a cursory glance around the dev forums first perhaps). The reporter is a lot less painful to use than it once was.
Thanks, I have moved the project over to [The Network](https://github.com/timsawtell/TheNetwork) which has done away with TS prefixes
I agree with this change to reduce ambiguity but agree with a number of commenters from the forums that the closed range operator should be: "x..y" to match the behavior in other languages (instead of the current "x...y" operator in Swift). Yes, this would be a weird breaking change (since double dot was recently half-open instead of closed) but it should still be considered for simplicity and broader conformity with Ruby and similar languages.
I recommend learning a similar high-level Object-oriented language such as Java using a book: The Art and Science of Java by Eric Roberts . Fantastic beginner's guide to programming. You could also check out one of the beginner's C-Objective books out there, they might be confusing for newbies though..C-Obj is a unique specimen. Oh ya, and Swift is fantastic, although I recommend waiting for books before jumping ship if you are new.
According to what I read from Chris L, they will move to Mutable Optionals right? - are arrays and dicts now pure value types?
You're just missing the return type. Should be import Cocoa extension CGPoint { func distanceTo(var point : CGPoint) -&gt; NSNumber { return sqrt(pow((self.x - point.x), 2) + pow((self.y - point.y), 2)) } } Running: var p = CGPoint(x: 0, y: 0) p.distanceTo(CGPoint(x: 5, y: 5)) returns 7.071 which is correct. 
 func distanceTo(var point : CGPoint) -&gt; Double
They wrote that for beta 3 all methods deprecated in ios7 was removed from the Swift libs. So check the suggested replacement in the docs.
Check out the UIAppearance protocol.
There's no indirection, which means a variable of this type in memory would theoretically need to be big enough to fit the entirety of the largest possible value of this type, which is infinite (think BinOps all the way down). I'd try introducing a wrapper class and using that in BinOp just in case the implementation isn't adding implicit indirection to overcome this issue, and see if that works.
This goes for Objective-C developers as well. You should almost never use NSNumber. NSNumber is there for when you need to box a number. But if you can avoid using it, avoid using it because using NSNumber takes away type information, you prevent the compiler from telling you when you mix up e.g. an integer and a double. I don 't know why this is, but people comming from other languages to Objective-C seem to be obsessed about using objects everywhere. That is a thing I was hoping would go away with Swift since it makes structs and primitive types blend in much better with the rest of the language.
If you don't know how to program yet then don't learn Swift first. Go for a similar language like go, and when Swift is released you can easily switch. But right now, there are a few language features that aren't even implemented yet or that don't work correctly, so it is in no means ready for a beginner
Besides the bugs, is swift any easier or harder to learn than objective c or java for a beginner? If I read [this](http://blog.teamtreehouse.com/an-absolute-beginners-guide-to-swift) will I be good to just move on to swift? As I figure that by the time I understand how the language works, majority of the bugs would have been fixed.
Okay, it turns out the solution was very obvious (as they often are): I needed to have the *classes* array not as a Swift array, but as an old-style NSArray. 
&gt; The values contained in an Implicitly Unwrapped Optional (or even an Optional) cannot be mutated This is currently a bug in Swift. At the moment, the unwrap operators only ever return const references. According to Chris Lattner, the plan (before Swift 1.0) is to fix this so that unwrapping mutable Optionals will return a mutable reference. See: https://devforums.apple.com/message/998882#998882
Learning a language as it evolves is a really cool experience. 
Anybody been stopped by this bug?: Xcode 6 beta 3: invalid virtual filesystem overlay file https://devforums.apple.com/message/999878#999878 
This isn't working for me at all. Xcode either crashes, fails to compile, or keeps disabling syntax highlighting. It's also recommending very strange syntax corrections (commas in weird places.) Worst issue is this. Keeps me from compiling or correcting any code: /Applications/Xcode6-Beta3.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift failed with exit code 254
Thanks for your reply! I may be missing something, but I don't see anything in the documentation under UIAppearance about deprecation and/or replacement. I hate to ask, but do you know where this is in the docs?
They pitch it as a note fun and newbie friendly alternative to ObjectiveC, and it is. I had very little ObjC experience but the iBook is definitely getting me somewhere with swift. It just makes a whole lot more sense. 
Then how do multiple dimensions work? I'm guessing: var twoDimensional: [[Int]] = [[1,2,3],[4,5,6],[7,8,9]] Is that correct? I can't test it right now.
&gt; var twoDimensional: [[Int]] = [[1,2,3],[4,5,6],[7,8,9]] Yep, looks like that works: 1&gt; var twoDimensional: [[Int]] = [[1,2,3],[4,5,6],[7,8,9]] twoDimensional: [[Int]] = 3 values { [0] = 3 values { [0] = 1 [1] = 2 [2] = 3 } [1] = 3 values { [0] = 4 [1] = 5 [2] = 6 } [2] = 3 values { [0] = 7 [1] = 8 [2] = 9 } }
From what I have read, Chris has said that they are looking into a fix for the immutable optionals. He did not specify the solution they are considering. It may be as simple as making optionals mutable somehow, but it may be a completely different solution. And yes, arrays are now pure value types (dictionaries always were).
The difference is that classes are **reference** types and structs are **value** types. When you make a copy of a **reference** type variable, both variables are referring to the same object in memory. A change to one of the variables will change the other. When you make a copy of a **value** type variable, the complete variable is copied to a new place in memory. A change to one of the copies will **not** change the other. If the copying of an object is cheap, it is far safer to make a copy than it is to share memory. Apple has a great [comparison](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13-XID_97) And they have a documentation on [choosing between classes and structures](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13-XID_109)
Here's a viewpoint that you might find illustrative: Consider an Array; a simple data structure yes? Just a contiguous list of objects. If your Arrays are (as Swift's are) structs, then that really is all there is to it. Very simple to reason about. If your Arrays are immutable classes (like NSArray), then you're in pretty much the same situation because regardless of how many references there are, none of them can have any effect on each other. In fact, NSArray takes advantage of the indistinguishability between immutable reference and immutable value types as an optimization: when you call -copy, it just retains self. But. If your Arrays are mutable classes (like NSMutableArray), then what you actually have is a vastly more complex data structure: a graph of references to an array, where the graph is implicit in the stack frames and ivar layouts of your code, rather than explicitly represented. This is more powerful, yes, and can sometimes help avoid expensive copy operations, but when the more complex structure isn't required it's unnecessary overhead (refcounting, heap allocations, pointer indirections), and more importantly it's unnecessarily difficult to reason about (as soon as the graph spans more than one thread, for example, you must introduce locking for it to be safe). TLDR: When they're applicable, immutable and pass-by-value types make your code faster, thread-safe, and simpler to reason about.
Good to see that it looks like a planned feature. It would be an awkward wrinkle in a language that abstracts away indirection to have to introduce it indirectly (ha) to work around memory layout issues.
Ah, interesting
When you go to build, make sure you have the iOS8 simulator selected. (I had mine on iOS7 &gt;_&lt;) Next to the run button, next to your target.
C# has the same concept of structs (value types) and classes (reference types). And because it's older and more popular (at least right now), there's more learning material for that. A quick search resulted in this: https://www.youtube.com/watch?v=0CsRK1HzJWk He uses C#, but it's easy enough to imagine the code was Swift. The concepts he explains still apply, and I think he does a great job at explaining. Maybe also interesting: http://www.albahari.com/valuevsreftypes.aspx Also with C# sample code, but the concepts are the same (up until memory allocation, from that point C# differs significantly from swift).
You can develop on the simulator without it, and the sim is pretty close No need to pay till you need to test on device
Thanks for the reply, correct me if I'm wrong here but right now (even using optional chaining) you can't set a value on an optional (the value type doesn't copy and set the new value) - how are optionals useful without the ability to change them ? Unless the value type is wrapped in a class which is then reference type and mutable. 
Thanks, can't believe I missed that.
Swift appears to be easier, although things like optionals would be confusing for a new OO programmer. Also, Apple uses a lot of software design patterns in their APIs and really enforces them which is also less newbie-friendly (C-obj and Swift). That, in combination with the fact that the whole thing is really unstable including XCode 6, I would recommend learning another OO language until jumping into Swift. You could still read a Swift guide, although you'll hardly be getting a proper introduction to OO programming unless you check out a more concise and complete book for beginner's. 
I don't like this change. It looks ugly to me.
I had to [head over to YouTube](https://www.youtube.com/watch?v=waGxPzdDGeo) to finish watching this. It kept getting hung up in the middle on the original link.
It depends on the expense of the copy, but yes, it would be much nicer to have the option of creating optionals with mutable values.
+1 for Core Data, it's pretty awesome. It might seem like overkill at first, but Core Data is an extremely mature framework and does lots of things nicely.
I am running the iPhone 5S and Settings -&gt; About indicates [that it's iOS 8](http://imgur.com/a/71pFj). Still crashing.
It really depends a lot on what the data is, how it is used, how often it would be updated, how it will be updated, etc. 
Ya, that should work, but that is a separate issue. If class optionals were not mutable the forced unwrapping wouldn't work either.
I didn't see any changes with NSURL init's, `NSURL(string: "http://reddit.com")` worked fine. Can you post the particular code that is crashing so we can help you better?
 let baseURL = NSURL(string: "http://luna.local:32400/system/players/192.168.1.3/") mind you this worked until i updated.
It seems to work fine in playgrounds but as soon as i build it it fails during runtime.
Seemed to work fine at runtime for me, so I'm not sure that it is your issue (I'm running on beta 3, in an iOS product build) Does appending "as NSURL" at the end do anything?
I tried it again in another project and its working fine, so something is up with my project settings I'm assuming.
hey guys, first off, I am new to iOS dev. Decided to start with swift! With that said, I am trying to learn Facebook login, but I keep getting error "while type-checking 'ViewController'", if I add the protocol FBLoginViewDelegate to it. Here is my [ViewController.swift](http://pastebin.com/yMQcekJm) I downloaded and added the framework to my project, and created the bridging header, but I can't figure out what's going on :(
Nope.
Thanks for the information, i'll have a look into it! I've read that dual booting like this could have a lot of risks that could delete all my current windows data. I use this laptop for all my university work, do you think it's safe to install OSX? 
The only thing you're missing is to set your sprite's position; it's a one line fix. let ball : SKSpriteNode = SKSpriteNode(imageNamed: "ball") ball.position = CGPointMake(size.width / 2.0, size.height / 2.0) self.addChild(ball) (draws the sprite in the middle of the screen)
You just use 'var' or 'let' to declare the 'property' as you would a variable/constant anywhere else. From "The Swift Programming Language" iBook: http://i.imgur.com/FNDOSh2.jpg
I really hope that Apple takes some of these great operator ideas and standardizes them somehow. If every project ends up using their own operators then things are just going to be a mess.
The project you uploaded is referencing files outside of the project directory structure, so it cannot be built by anyone else as is. Specifically, the Storyboard and ViewController files are in your .Trash, and the supporting graphics are sitting on your Desktop.
It's good, by why a symbol? Why not just something like {...} then {...} ?
How about running OS X in VMware?
You should be able to virtualise OSX on your windows machine.
I made this same mistake about two years ago with a C++ program I was working on. God damn it. Would a switch statement work better? Or maybe I get rid of toInt() and use the if-statement to check and see whether the title is equal to [name of option]? Hmm I'll test it out. Thanks for the help. 
You could do `run({...}).then({...})`. Of course, at that point you might as well just use promises.
When you declare something as a var in a class, you can define get and set methods in the declaration. class A { var variable:String { get { return "hey" } } } I believe that's the syntax
Honestly a point is a vector. I would just have the vector type, no point type, and + and - operators for the vector type.
No, just no.
What is probably going on here is that: Int(arc4random()) is overflowing. This explains the random crashing and the extremely large values of *rand* when looking in the debugger. You should use a bounded form of arc4random(): Int(arc4random_uniform( UInt32(wordBank.count) ))
I think that was it!!! No crashing now! Thank you so much! On a side note, is there any way to bring up the information on variable values and whatnot before the program crashes? So I can keep track of values while I'm testing?
The IRC is down.
Sounds like a good candidate to file as a radar bug. How up to speed are you with how the simulator works vs the iPhone? I can go into some details as to why the difference may exist, but it's definitely a bug in any case.
Was talking about the swift irc chatroom located in the side bar.
Based on what Apple's done in the past, Xcode usually exits beta along with iOS. So probably in the September-October timeframe.
The Swift-Code doesn't really help though, because he wants to have heterogenous dicts, if I understood that correctly. It's also not possible to put closures into a NSDictionary, it seems (as a closure does not conform to AnyObject).
I realize this post was 27 days ago, but I wanted to thank you for this post. I've been doing a bunch of searching for the segue stuff and couldn't find anything relevant. But searching the sub's top posts led me to your comment, which has solved all of my problems.
/u/ipacers is correct. If Apple follows its usual pattern, you can submit your app when the Xcode GM is released, which will happen a few weeks before the release of iOS 8. This will likely coincide with the release of the next iPhone. Last year it was mid-September.
Yes, I encounter the same. I just ignore it since it's obviously is a bug and doesn't have any effect on the app. 
do you have any updates for us thus far? :)
Hi, there is also a second book from Apple in the Swift Programming Series: **Using Swift with Cocoa and Objective-C Book 2, Swift Programming Series Apple Inc.** https://itunes.apple.com/us/book/using-swift-cocoa-objective/id888894773?mt=11 People seem to not know that this exists, yet they know that Book 1 exists. weird.
Thanks..
If people are willing to rewrite their programs to swift just because Apple made it then I think there shouldn't be problem with rewriting for android and yet there's so much resistance. Better rewrite to java instead of swift and use swift for new functions and apps, it should be way more profitable.
It's corrupted
*NSURLConnection.sendSynchronousRequest* - holy shit, why would you use a blocking network request? *NSURLSession* is beautiful for such tasks. BTW: Consider using a class + json for your response, public class Ad { $id = 0; $image_url = ""; $url = ""; public __construct($id, $image_url, $url) { $this-&gt;id = $id; $this-&gt;image_url = $image_url; $this-&gt;url = $url; } } $myAd = new Ad(1, "image_url", "url"); echo json_encode($myAd); will print some JSON and, as we all know, Apple has a nice NSJSONSerializer class. :)
A rewrite in Swift is much more realistic than a rewrite in Java, don't you think? Assuming the programmer doesn't know Java, that is. Seems to me like ObjectiveC -&gt; Swift would mostly mean a change in syntax, whereas Java and Android would be a complete change in syntax and structure of the program, UI, etc.
I replaced my code with yours in the tutorial and gave your credit and linked to your reddit account. Thanks for the great feedback!
How do you run your app when this causes it to crash every time
You have a fair point, but typically there's a lot more then just the language to consider. You have to learn the new APIs for building an android app. Need to account for testing apps on android, and so forth. Don't get me wrong, i think if you want to have a successful app, selling for both platforms is a smart move. But I don't think it's as easy as "writing java"
Yes, there is no business case for rewriting a project in Swift. Plus the language is so unbaked right now and changing between builds.
Actually using NSMutableDictionary doesn't work: var p : NSMutableDictionary = ["Key1": { (x: NSObject) -&gt; String in return x.description}, "Key2": 1]; Type '(NSObject) -&gt; String' does not conform to protocol 'AnyObject' You should ask this on the Apple dev forums -- I suspect it's a bug. Using a [String: Any] dictionary should work but it crashes the compiler, which is definitely a bug.
Sure, but there's no profit in rewriting the same thing in swift, there's some in rewriting for android even if it's harder. There's more profit in focusing on a new project too.
I've tried with `Any[]` as well (now `[Any]`) and was unable to get that to work. Can you explain why it doesn't work?
Yeah if you have an existing app that is pretty together, i think re-writing would only be smart if the current tool is giving you a lot of headaches that the other would solve.
Oh, and thanks for finding the unnecessary typing of AnyObject in the for loop - I've updated the post.
It looks like some people didn't actually read the article, so I'll summarize it here: "It's foolish to reimplement perfectly working Objective-C production code in Swift. However, porting your pet side-projects to Swift is a great way to learn the language." I agree wholeheartedly, and that's exactly what I did. My first Objective-C app was a simple Hot Key app for OS X, for launching apps, web sites, and scripts. I still use the app daily, but I haven't touched the code in 5 years. It was fun to look back at that old code and see so many rookie mistakes, and porting it to Swift was enlightening. 5 years from now I'll still be using that Hot Key app and I'm sure I'll enjoy looking back at the naivete of my first Swift code. 
If you still need a workaround, here is one; usage looks like this: var d : [String : AnyObject] = [:] d["a"] = Blocks.voidBlockToId({ println("Doing something") }) d["b"] = "Some string" d["c"] = Blocks.intBlockToId({ i in println("Called with integer: \(i)") }) Blocks.toIntBlock(d["c"])(1) Blocks.toVoidBlock(d["a"])() println(d["b"]) Output is: Called with integer: 1 Doing something Some string The Blocks-class is defined like this in ObjC (with corresponding header and bridging header, I won't put those here): typedef void(^VoidBlock)(void); typedef void(^IntBlock)(int); @implementation Blocks + (id) voidBlockToId: (VoidBlock) block { return block; } + (VoidBlock) toVoidBlock: (id) block { return (VoidBlock)block; } + (id) intBlockToId: (IntBlock) block { return block; } + (IntBlock) toIntBlock:(id)block { return (IntBlock)block; } @end You also need to add a new xyzBlockToId and toXyzBlock method for every new closure-type you want to use. Pretty ugly, but it works... 
Hey there! Thanks for the comment! I'm glad you liked the article. Great summery! Exactly my point. Good work on rewriting your own project! Cheers!
Oh, this makes sense for the business side of things, but in the post, I'm talking from the point of view of a person who is trying to learn Swift. Also, as someone already said, learning the APIs is the harder part when it comes to doing an android app.
This is one of the things that the WWDC talks about Swift goes over, but is still worth repeating. Strings, arrays, and dictionaries are not what you think they are.
Similarly, generics aren't reserved for classes/reference types either. You can use generics with structs and enums as well (but not protocols for some reason). If you think Swift enums work like C enums, you're gonna be surprised too.
Xcode crashes even when Apple is demonstrating it. See WWDC 14 What's New on Xcode. The crowd is revenged when Xcode crashes. All those years complaining to Apple about that shit.
Beta software. Use at own risk.
It doesn't crash for me. It simply gives a warning. 
AssociatedTypes for protocols. It's different from what I'm used to as well.
That's a good idea. My first real ObjC app was an expression calculator, which I originally wrote in C++ for BeOS (15 years ago), then ported to Qt in 2003, and *then* ported to ObjC/AppKit. I consider it my get-to-know-a-platform project. It's a simple app, and it might be fun to rewrite it in Swift. Plus, I haven't touched its codebase in 6 or 7 years, and animation in OSX has come a long way. It had help bubbles for highlighting bad inputs which were pretty cool in 2007 but are terrible today.
I think article confuses two different definitions of the term object: 1. lowercase "object" (i.e. objects in the broader computer science definition) 2. Swift's "AnyObject" (which refers to instances of any Swift "class" type). Swift's "struct" types *are* "objects" under in the broader computer science definition. They encapsulate data and provide methods to act on that data. They are *not* Swift "class" types, so they can't be represented by "AnyObject" (which is an @class_protocol so it can't be implemented by "struct" types).
Yep. In fairness, Apple sows the seeds of this confusion by calling it AnyObject instead of AnyClass (presumably they did so because it's there to help with Objective-C interop).
Just do it
NextStep. It's a holdover from when objective-c was created by NeXT to write nextstep (later os x) and all associated apps, etc. They represent elements that aren't part of the original C underpinning, for example, there is no 'string' element in C, so in objective-c, it's an additional foundation element 'NSString'. Edot: objective-c is a superset of C, not a whole other language like C++ or C# or even Java. Edot 2: not invented by next, just "made what it is today" by next/apple
So does that mean its an old tradition that doesn't actually serve a function? I can understand how it may be useful for other people who may be reading your code to recognize things, but if I plan on coding small projects for my own use, should I be using this?
It does serve a purpose: it differentiates NextStep superset code (objective-c) from standard C code.
It's just a name of a bunch of stuff. Imagine if you name a function raias4Reverse() and use it in a bunch of places. And imagine that someone sees this in your code and asks to use it, so you distribute it as a library. So, there's all this code from NeXT and software for NeXT. Rather than breaking all that code (internal and external), they didn't change the name of the classes and functions. That's all. Putting "NS" at the beginning of a class name or function doesn't do anything magical.
Apple backed themselves into that corner because there's an AnyClass too... it refers to the metaclass instances for classes. e.g. NSArray() is an AnyObject, NSArray.Type is an AnyClass Annoyingly... AnyObject is a protocol implemented by *classes* (not objects) and AnyClass is a protocol implemented by *metaclasses*, not regular classes.
Most likely you have some statement somewhere that causes the crash. I would open the source files of the project in some text editor, comment out everything, then reopen the project in Xcode and start adding code. When it starts crashing again, you carefully look at the code you put in last, and hope you can find the cause of the crash. I got my Playground to crash like 50 times today, but my "real" project doesn't crash everything (only the compiler crashes, but not xcode).
C doesn't have namespaces, so most libraries use a standard prefix as an alternative. Apple's libraries are prefixed with NS. Direct3D prefixes everything with D3D. OpenGL prefixes a lot of things with gl. Etc. NS in particular is a hold-over from NeXT developing NextStep and is all over Objective-C for that reason, but others have gone into that. Don't prefix your classes with it, but do use those classes when appropriate.
I could live with it if it was just some weird syntax (even though even that is bad), but protocols with associated types seem straight unusable for many of the use cases where you would use generics. Good summary of the issues: https://devforums.apple.com/message/985577#985577 (jump to response 19, not sure if that link works the way I intended...)
If I define :– struct S&lt;T&gt; { typealias U = Array&lt;T&gt; } `T` is an input which the user supplies while `U` is an output that `S&lt;T&gt;` returns to the user. You could try to implement this as type parameters :– struct S&lt;T, U where U == Array&lt;T&gt;&gt; {} but this would amount to requiring a user to know the result of calling a function and to supply that value as an input to that same function call—it's backwards. But this is ultimately what you would be doing if you put type parameters on protocols which are going to be used as generic constraints. If you had :– struct S&lt;U, T: Protocol&lt;U&gt;&gt; {} struct In: Protocol&lt;Out&gt; {} `T` is an input, while `U` is an input that's acting like an output, like in the previous example. If you pass `In` as `T`, then `U` *has* to be `Out`, since that's how the implementation of `Protocol` is defined for `In`. And yet the user has to pass `Out` as an input. Languages which work like this typically use type inferencing to paper over this and essentially turn `U` into an inout type parameter during inferencing. But why not just make `U` an output in the first place?! Of course, this all assumes you're using protocols as constraints. When you use them as types, you basically reverse the arrows. The associated types become the inputs, and the union of the types that implement the protocol for the given inputs becomes the output. This is why there were issues with using protocols with associated types as the types of values (which is presently disallowed): associated types are designed to be outputs, not inputs, so reversing the arrows doesn't work. Syntax would need to created to allow the client to supply the associated types for a protocol when it's being used as a type in order for this to work.
It's just namespacing since Objective C doesn't have namespaces. Like others have said this is a naming convention that started with **N**ext**S**TEP, the original operating system that became Mac OS X when Apple acquired Next. If you look at other Apple and third party frameworks they all follow this convention (e.g. CALayer in Core Animation or CGRect in Core Graphics). With Swift this convention changes. Swift supports namespacing so there is no need to put these prefixes on your class names. Swift maps its core types to the NS equivalents: &gt; Swift’s String type is bridged seamlessly to Foundation’s NSString class. If you are working with the Foundation framework in Cocoa or Cocoa Touch, the entire NSString API is available to call on any String value you create, in addition to the String features described in this chapter. You can also use a String value with any API that requires an NSString instance. https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html If you're writing Objective C you should follow this convention. Some people use their initials, others use initials of the app's name. If you're using Swift there is no need to do this.
So your Test 2 actually does what you want. The problem is that ALAssetsGroupAll is a UInt32, and ALAssetsGroupType is Int, so you need to cast. So that part is fine. Your crash has another reason, I strongly suspect that your assetLib is deallocated before any closures can be called. This happens when you don't store the library in some property. Eg. func blubb() { let assetLib = ... assetLib.enumerate... } This will crash, because assetLib will be deallocated when blubb returns, but there's still something "alive" trying to call your closures (which won't exist anymore as well). I assume that's what causes the crash. (An alternate outcome would be just nothing happening, if Apple had made the assets library class shut down cleanly when it gets deallocated). class Xyz { var assetLib : ... func blubb() { self.assetLib = ... assetLib!.enumerate... } } This works, because the assetLib will only be released when the Xyz object is deallocated (or the assetLib property is set to nil). That way, the asset library object stays alive long enough to call your closures. I hope you get the gist of it, I'm not so great at explaining this...
This actually makes sense to me. A class is a type, while an instance of a class is an object. So `AnyClass` makes sense as a metatype for class types. If we included instances of struct and enum types as objects, then `AnyObject` should properly be the type of instances of any class, struct, or enum type, with the type specifically for instances of class types being `AnyClassObject`. However, if we accept the definition of objects in Swift to be instances of class types, with instances of all other types just being values (albeit with properties and methods), then the current naming makes sense.
Thanks for the explanation, I can see now why this makes sense when focusing on the constraint use case of protocols. (That obviously doesn't change the problem that one can't use protocols with generics as a type, as you described).
Please use singletons responsibly.
Report a bug to apple. Ideally upload your project. https://bugreport.apple.com/logon They take note and fix things. In the short term, I would suggest that it's *most likely* an error in the project file not the source. Start a clean new project and import your source. If that still fails, do the same one file at a time until you isolate the problem file.
I get the impression that it's intended that protocols be used as constraints for parametric polymorphism whenever possible, with protocols-as-types only being available for the cases where you actually really need runtime polymorphism over protocols, which would explain why the constraint use case is the apparent focus of the design. Of course, it would be good if the runtime polymorphic use case *actually worked*. However, I think care needs to be taken that solving this problem doesn't lead to the overuse of runtime polymorphism where it really isn't necessary, as I've seen in a lot of the examples showing "how much nicer type parameters would be". Part of this should be looking at improving static encapsulation in order to prevent runtime polymorphism from being used for that purpose when it is otherwise unnecessary.
You should be using NS introduced in the NSFoundation framework. You wouldn't write your own classes with it. That said, Swift's built in classes serve as replacements and are interchangeable (bridged) when you call Objective-C APIs from Swift. So generally there's not much need of it.
A nicer way of doing it in my opinion would be: class MyClass { class var sharedInstance { struct Singleton { static let instance = MyClass() } return Singleton.instance } } Static properties are implicitly lazy in Swift which is nice and doing it this way means you don't have to have a global variable
Much better!
&gt; objective-c was created by NeXT Correction: Objective-C was not created by NeXT. NeXT simply adopted the language and then created the classes NS* to implement the OS
Examples of responsible Singleton use?
I have a singleton which I use to take care of all of my core data needs.
This is better than apples templates at least but in large projects these core data helper / manager classes can get messy and end up doing a lot of stuff (i know from experience), I find my code much cleaner since i started using the active record pattern
Yes, yes, they didn't invent it, but they definitely made it what it is today with all the class extensions, etc. As someone who is just now learning it, it's certainly an interesting language.
Somehow that took me to page 2. /shrug. My programmer brain is confused when it comes to protocols. It feels like an interface, I want to use them like an interface, but... they're not. All of a sudden I'm reminded that I can't use the same idioms that served me in other languages. Which is why it's beta, I guess. The objc slant on the design shows up from time to time and hopefully they'll address them.
As a quick response to all of this, I have spoken with a few developers (though none are iOS developers by profession, but have dabbled) and every one of them has said that Swift is a great place to start. There's tons of time to learn the harder languages such as Obj-C and alike, but Swift can allow me to produce an App almost as fast as I can learn the language itself. How do you respond to that? I see both sides, but then again I'm no developer.
Aren't they finalizing the compiling and interpretations languages now? There could be issues. In fact @jasamer provides examples. Send it to Apple as a bug and they'll get back to you.
I assume you don't want to invest some money to join the developer program. If you did, you'd quickly find the information you are looking for. It's right there in the developer portal.
Well, as a professional iOS developer let me tell you that while that may be true in the fall, it certainly isn't now. The bugs that are currently present in Swift will (in my opinion) slow you down more than the speed benefit it will have. Also note that although Swift might be easier to learn than Objective C, the Cocoa framework (what you will be using to display the UI, do network requests, etc. - basically most of the things you do on iOS will at least involve Cocoa, or Foundation for that matter) is the same for both. Consider these examples: //Swift var session = NSURLSession.sharedSession() var task = session.dataTaskWithURL(NSURL.URLWithString("http://www.reddit.com/r/aww.json"), completionHandler: { (data, response, error) in var json: AnyObject! = NSJSONSerialization.JSONObjectWithData(data, options:NSJSONReadingOptions.convertFromNilLiteral(), error: nil) display(json) }) task.resume() //ObjC id session = NSURLSession.sharedSession; id task = [session dataTaskWithURL:[NSURL URLWithString:@"http://www.reddit.com/r/aww.json"] completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) { id json = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil]; [self display:json]; }]; [task resume]; Note that all the methods and classes are the same, the syntax is just a little different. The biggest difference is that Swift allows us to omit the types in most declarations, though not in all of them. (Both download JSON Data from the aww subreddit, deserialise it and then use a fictious "display" method to display the data)
It might a good place to start, but a start is all you get until Big Nerd Ranch, etc. come out with their books. Which they're not going to do until the language is out of beta. Why don't you use a language your father knows? Please read this sub to see this question being answered about a dozen times. 
You would need to create a bridging header. https://developer.apple.com/library/prerelease/mac/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_74 After doing that, you can instantiate whatever class you have. 
But with the full release so close, won't those books be just a short way away? I was working on Objective-C but then Swift came out and he highly suggested I move to that.
I tend to agree with the main assertion. You talk about how enums, optionals, etc. will reduce and simplify some code. I think so too, but show some examples and suddenly you'll become a lot more convincing.
Honestly, it might be best to start out with OBJC swift is still super new. There will be way more resources available to you if you use objective c. 
You can roll your own higher type using an `enum`. You need the dictionary values to be _either_ strings _or_ functions which return strings, so define a type to represent that: enum MyDictVal { case ValString(String) case ValFunc(AnyObject -&gt; String) } Then, you can put it in a dictionary: let d: Dictionary&amp;lt;String, MyDictVal&gt; = [ "a": .ValString("a") , "b": .ValFunc({ (value) in value.description }) ] Then you'll need to process the dictionary values using pattern matching: switch d["b"] { case .ValString(let s): ... case .ValFunc(let f): ... } 
Is this the first official blog Apple has had for anything? I can't recall any others.
Either way it's a welcome development. They've been great with communication on the forum so far, this is a logical next step.
Apple also has several ebooks available on these subjects: https://developer.apple.com/swift/resources/ 
thanks!!!!
In that case...can't recommend the Big Nerd Ranch books enough. They and the forums associated are incredible resources.
The BNR iOS 7 book didn't come out until February after the OS was released in beta last June, so I would expect that a BNR Swift book will probably follow Swift's beta release in the same amount of time, if not more. A lot more to document with a new language as opposed to an updated OS.
I think so, or at least that is the twitter consensus on the issue.
Thanks! I just accepted the suggestion. I already took a few from /r/swift, but will try the find the other diamonds in here over the weekend!
I just setup a blog and will start writing tutorials including swift, I'll look into doing a tutorial for this over the weekend.
You rock! I'll definitely look out for it. Edit: To be honest, I'm surprised it's not already done. Seems like it would be a common request for new iOS programmers like myself. Even more reason for you to get one out quickly, I suppose.
But you won't be able to release it until XCode 6 is officially released! (Beta software)
You are right. Static typing would have been a more adapted and precise term. http://en.wikipedia.org/wiki/Static_typing#STATIC Strong typing is not very well defined apparently. http://en.wikipedia.org/wiki/Strong_and_weak_typing Thanks for your feedback!
Haha! &gt; Steve Jobs has asked me to write a posting every other day or so to let everyone know what’s happening with MobileMe, and I’m working directly with the MobileMe group to ensure that we keep you really up to date. Interestingly that mobileme news section was rather long lived. It ended 2011 when icloud was started.
That makes sense...everywhere I turn it seems Objective-C is the place to begin for iOS Development, even when trying to read the Swift book.
Awesome, I'll definitely be checking those out this coming week. 
No prob. I will be trying to do one post every day or every couple of days, not all swift but im trying to cover that as much as possible. Heres the [link](http://cocoakris.com).
&gt; Swift is his suggestion with mobile apps becoming bigger Go with Swift. Listen to your dad. If you start today by christmas you'll be delivering apps like a pro. This is the right time. If you start later, those who started now will have an advantage over you. Believe me when I tell you Swift will change the world. More than a million apps were coded using ObjC even though it was not a popular language for hobbyists. Now Swift will change that and everybody will be coding apps for OSX/iOs. Start with a clean slate, invest all your time in Swift. It'll pay a thousand-fold in the long run. Learn the tools, Xcode, the editor, the shortcuts, the designer, learn it all. You'll need the skills for both ObjC and Swift, so you need to be proficient with the tools. Learn about design, that's universal, learn about colors, UI controls, positioning, menus, interaction, lists, buttons, edit boxes, storage, apis, they're all universal and language agnostic. Learn the most you can about designing apps if you want to be a developer. Then use Swift to code them. That's all you'll need for the next decade. Once in a while, when you increase your expertise, you may start playing with Android tools and Java (if they haven't made another language available) and you'll notice so many similarities, that you'll be able to make the jump and develop apps for both platforms, seamlessly. Then you'll be god. Aim for it.
The fall is just a couple of months from now. Download XCode, the latest beta version that includes Swift and start playing with it today. Wrap your head around the tools and the concepts and by the fall you'll be proficient. If you start today, by the fall all noobs will be asking you questions, not the other way around.
But just to add, you will have to invest yourself. You won't be a programming pro if you don't practice. Learning programming is like learning how to play a musical instrument– you have to be willing to practice and be patient. It's going to be a journey. You won't be pushing out AAA apps within a month. You probably won't even be developing iPhone apps at all in that time. But that's normal. You just have to be a bit patient and you have to be willing to learn.
Something that gets missed often by people who've learned other languages first is the concept of prefixing your custom class names. Prefixing is necessary because Objective-C lacks namespace support. What that means is that if you have a class that provides video information and name it VideoInfo, and you then decide to use a library that helps with video playback and it has an internal class named VideoInfo you'll get compiler errors in the best case scenario, and random weird crashes in the worst case. In many, more modern languages you load a library and then access its classes using syntax like VideoDecoder.VideoInfo(). But in Objective-C they're all in the soup together. (Personally, I don't think this is a particularly tragic flaw.) Apple uses NS and a host of other 2 letter prefixes. They have reserved all 2 letter prefixes for their use, so it's a good idea to use a 3 letter prefix just to collisions.
You don't need to prefix your own class names in Swift, and you should **never** prefix *your* custom classes with NS or any of the other prefixes Apple has reserved. 
I think https://github.com/trending?l=swift is better than https://github.com/search?q=language%3Aswift&amp;type=Repositories
Webkit: https://www.webkit.org/blog/
Good one, I didn't know Swift in Flux yet! It's here now: https://swift.zeef.com/robin.eggenkamp#block_21427
Thanks for the tip. I think they both have value. Trending only gives you 25 (of the best) repos, the other link gives them all. They are both there now.
Okay, so feel free to give me all of the credit for this. Forking over $100 in June for a paid-up developer's account was just not going to happen. July would have been better, except for that need to blow serious cash on the first college tuition payment of the year for my kid. And then I thought, "If Apple really cared about Throwaway_bicycling, they would just release Xcode 6 for free right now to everybody." And, lo, it has come to pass. So go and speak well of me. :-) 
Yay! I can get Xcode 6 for legit now!
My guess is that the main reason they did this so teachers can start planing to add Swift to their iOS development classes this fall.
I tried to address responsible use of singletons in this blog entry: http://assoc.tumblr.com/post/51302471844/the-misunderstood-singleton Basically my view is that if to think of software as a series of layers, then try to avoid placing singletons at the bottom layers. Because that would mean potentially all your code depends on singletons which will make testing hard. However you can use a singleton object in lower layers if you just pass the singleton object as arguments to functions. Direct access of singleton objects should happen primarily at the topmost level where it introduces few dependencies. Another use of singletons is using it for something which is supposed to appear stateless, like network communication. Then you can use a singleton at any layer.
Hi, what's the link to the blog?
Default lazy initialization of globals is really cool. I've had so much pain with random initialization and deinitialization of global variables in C++. Basically the problem is when you have a modular system consisting of different subsystems and you want them initialized automatically so you make them global to make initialization happen automatically rather than having to manually add initialization. 
What do you mean? The language itself is not source. You mean like an open standard or do you mean the tool chain used to compile it?
www.cocoakris.com
There is a special deal for education iOS development. Most would already have dev accounts, the remainder wouldn't be enough for such a huge shift in their policy. I could see it being on of the items in the pro's column while brainstorming the should we/shouldn't we part of the initial discussion.
It's great to see them staring this blog. I hope they work on the design to make the text more readable, though.
My university just had people sign up for the free Apple developer accounts, they didn't have a paid program.
This is the program I was referring too. As I said, not all institutions will apply, or qualify. https://developer.apple.com/programs/ios/university/
Interesting. Coming to Swift from a year of Java in school and some C++ before that, I don't find Swift difficult at all. I really haven't encountered any bugs in my 15 or so hours of programming with it (aside from my own errors that were fixed through basic troubleshooting), and aside from the lack of reading material on the more difficult concepts to grasp for a beginner (like delegates and protocols), I don't see why OP would have any problems. However, I do believe OP would be better off elsewhere. He said he did a bit of Java, and although I might be biased because it's the first language I really learned, I think it provides a fantastic overview of the main concepts in OOP. There will still be a few gaps when he turns to Swift, but I think a good foundation is more important. If I would recommend anything else, it would be Obj C only so he gets used to Cocoa Touch, since coming from Java, I feel that's where my weakness is at the moment, not the OOP aspect.
Thanks, I am trying to put together short posts which will just simply explain things. There is much more depth I could go into but I come from a teaching background and too much info at once usually just makes things more confusing.
This is really great. I was having a few problems understanding optionals and no one was able to explain them as succinctly as you. Thanks.
There's one more interesting type about optionals. You can declare a variable as: var x : Type? = value which puts value inside a "box"/"candy wrapper" that can also be empty (ie. nil) like described in the article. But you can also do: var y : Type! = value This is the opposite of the ?. If you assign an optional to y, it will be unwrapped automatically. Eg. var a : Int = 5 var b : Int? = a // Wrap a var c : Int! = b // Unwrap b var d = c+5 // This is possible var e = b!+5 // Does pretty much the same as this Note that this: var a : Int? = nil var b : Int! = a has the same effect as var a : Int? = nil var b : Int = a! aka. it crashes. You probably should never declare a variable with the ! in its type yourself, it is pretty much a convenience feature for when you implement objC protocols. Because any object type parameter can be nil in objC (-&gt; it needs to be an optional in swift), but in reality it never is, it wouldn't be fun to unwrap all the optional parameters passed to you yourself. So, for example, the delegate method: - (void) something: (NSString*) parameter; // in objc func something(parameter: NSString!) // corresponding swift method Automatically unwraps its parameter for you.
Great initiative, but please repost when you have more than one.
we're all beginners aren't we?
alright, thanks. Yeah, I will definitely be spending some time here. 
Just added the flyweight :)
 &gt;What's an object-oriented language without the ability to hide implementation details? lol An unfinished one. 
Heh. ObjC still doesn't have access control for methods, and didn't get it for ivars until it was well over a decade old. It's useful (*especially* in a header less language), but hardly essential.
In general, I'm not convinced that Reddit is a great place for code-related questions. Due to search ability, tagging, visibility of top-level answers, longevity and the ability for the OP to nominate an actual answer, http://stackoverflow.com is almost always a better place to ask code-related questions. If you're asking higher level questions ("where can I find information about X" or "do we know if there are plans to add X to Swift") then Reddit is a good place to do that and /r/swift is certainly the appropriate spot. In any case, Swift doesn't really have the critical mass at this point to support multiple subreddits. New subreddits at this point would likely be ghost-towns.
Yeah, stackoverflow is definitely a good friend of mine. Thanks for the advice. I guess what I was really looking for was a dedicated place to ask general questions rather than specific questions about some code. Thanks again. 
You're running on a device? Or in simulator? I'm just saying in xcode make sure you're building TO the iPhone. What I recommend is, build to iPhone 5. I believe 5s is 64 bit by default, and maybe that's causing your issues. (Try a few different configurations, but I build to: iPhone 5 and it works fine)
Aren't they just pointers and "unwrapping" is just dereferencing? Implicitly unwrapped optionals are just pointers with automatic dereferencing. Or am I thinking about it wrong?
ObjC has rough access control (public/private) by declaring methods/properties in the .h or .m(m). I would argue that that would suffice for rudimentary access control for methods.
So optionals are actually an enum. Basically when you say Int? it means Optional&lt;T&gt;. They equate logically to a Yes or a No and are mapped to a value if there is one. Implicitly unwrapping on the other hand or ! is this ImplicitlyUnwrappedOptional&lt;T&gt;. It is a struct which contains an Optional&lt;T&gt; variable along with some methods to force the value out. It's interesting stuff.
Because it's not finished yet.
Yes, they're going to add it. In the meantime how about you maybe just try not calling the methods you would have otherwise have marked as private. ;-) I'm probably more put off by the lack of metaprogramming, but they'll hopefully get around to it. As for your particular complaint, this also makes handy (satirical) reading: http://steve-yegge.blogspot.com.au/2010/07/wikileaks-to-leak-5000-open-source-java.html
They've mentioned on numerous occasions it'll be in the language before 1.0, and I'd bet we'll see it sooner rather than later. Swift right now isn't for the faint of heart, it's for people who want to get a headstart learning it and/or being a part of the language's evolution via feedback and radars and such. If you want a finished language, come back later :D
Oh okay, that's a pretty neat implementation actually. I hadn't thought about what they are underneath, mainly the usage. The usage seems pretty similar to pointers however right? Raw pointers probably have a few more use cases though.
Hmm... I guess? I mean, in the sense that "you have to do something to them before you can use them" yes, but what that thing is, and what it accomplishes is really very different. To use the classic signpost analogy, a pointer is the sign telling you where your destination is, and an Optional is a note you can put on the sign saying it's closed. (edit: The direct analogues of pointers would be class types for automatically dereferenced pointers, and UnsafePointer&lt;T&gt; for non-automatic pointers)
Int? Is Optional&lt;Int&gt;, no?
Well, you can release a Mac app using it now, you just can't put it on the app store (and it would be a terrible idea). 
Yes I forgot to swap out the T. When you say Int? It is actually doing Optional&lt;Int&gt;
Not sure, actually. enum memory layout in general isn't finished, but Optional layout is so it might be.
Great write up. Just what I was looking for.
I ask because the documentation and other sources for similar patterns mention nothing about an extra bit, they say that it is an enum with a case of nothing and a case of something. I would assume it sets what it is based on the Init parameter being nothing or a value. I then don't see why you would need this extra bit so where did you come up with this?
This may or may not be the internal implementation of optionals, but it's not the correct way to reason about them. Optionals are enums with two cases: `.None` or `.Some(val)`. To prove this, you can pattern match: let x: Int? = 1 switch x { case .None: println("No action") case .Some(let unwrappedX): println("x is \(unwrappedX)" } What's happening here is that the `switch` statement pattern matches an object of type `Optional&amp;lt;Int&gt;` and thus has two cases to be exhaustive: `.None` and `.Some(let ...)`. The second case matches, and thus binds the pattern `unwrappedX` to the value `1`. /cc /u/eightoftwenty
Don't get so defensive. I'm simply trying to figure out where this info is coming from since it's not written anywhere. Regular enums are not adding extra bits btw, not sure why you say that's how all enums work. An enum is basically naming a value like the number 1 or 2. Let's say myEnumOne = 1. Then when I say myEnumOne, I am really saying 1. So you can compare and put through statements as you would an Int. Anyway, if you say a Swift engineer said that's how optionals work then mind as well wait until there is some sort of actual documentation from Apple on this matter.
You can use type evidence to achieve that: extension Array { func flatten&lt;U&gt;(evidence: [T] -&gt; [[U]]) -&gt; [U] { let xs: [[U]] = evidence(self) return xs.reduce([U](), +) } } func identity&lt;T&gt;(f: T) -&gt; T { return f } [1, 2, 3].flatten(identity) // does not compile [[1, 2, 3], [4, 5, 6]].flatten(identity) // [1, 2, 3, 4, 5, 6] `identity` function as `evidence` argument acts as a proof that `self` is a `[[U]]`. You'll get additional argument, but at least this approach is type-safe. Kudos to https://github.com/maxpow4h and his [swiftz](https://github.com/maxpow4h/swiftz)
Right. I was just trying to explain why there's no dereferencing involved. Getting the idea that enums have reference semantics would lead to some *very* confusing bugs.
I would suggest using the MKMapCamera object: println("Center map on user location.") let mapCenter = mapView.userLocation.coordinate var mapCamera = MKMapCamera(lookingAtCenterCoordinate: mapCenter, fromEyeCoordinate: mapCenter, eyeAltitude: 1000) mapView.setCamera(mapCamera, animated: true) 
&gt; You can roll your own higher type using an enum. You need the dictionary values to be either strings or functions which return strings, so define a type to represent that: &gt; enum MyDictVal { &gt; case ValString(String) &gt; case ValFunc(AnyObject -&gt; String) &gt; } &gt; Then, you can put it in a dictionary: &gt; let d: Dictionary&amp;lt;String, MyDictVal&gt; = [ &gt; "a": .ValString("a") &gt; , "b": .ValFunc({ (value) in value.description }) &gt; ] &gt; &gt; Then you'll need to process the dictionary values using pattern matching: &gt; &gt; switch d["b"] { &gt; case .ValString(let s): &gt; ... &gt; case .ValFunc(let f): &gt; ... &gt; } All fixed in Xcode-6 Beta 3 :)
The main purpose is class initialization: compare with obj-c that evey object inherit from NSObjetc (Alloc, init), you had to face somewhere to init your custom class with some vars: initWithX:(CGFloat)x and usage of self. for member variables.
It's not clear from your question whether you're asking about when you'd invoke init yourself or when you'd need to implement an init() method. I'll try to answer both. __Invoking init__ You never write myObject.init() yourself. When you create a new MyObject like this: var myObject = MyClass() the init() method with matching signature (in this case, the "no parameters" signature) is automatically called. __Implementing an init method__ You might be thinking... I can just do this: class MyClass { var a = "initial a value" } and I don't need an init() method. You'd be correct, you don't need an init method in this case. The primary use case for init is when you need to construct with values. For example: class MyClass { var a: String init(s: String) { a = s } } which you'd invoke with: var myObject = MyClass("custom value") 
Just found this. Pretty neat. Question: what is Json? Is it a method of retrieving data from an online database? And I'm assuming there's a reddit API/database that you can simply create a dictionary with for each post and save its url, title, author, etc.? Edit: Found this: http://www.reddit.com/dev/api. Is this what you used?
The docs clearly state that the playground shouldn't be used for testing or performance. There's a lot of stuff going on in the background that enables the neat features of the playground and it, understandably, takes some extra time to reach the end of your code. And I'm not even touching the performance of a beta language vs java. If you want performance, there are lots of other choices. Swift playgrounds are about playing and convenience.
Hi, json is a file format with a readable structure. Many (social) websites will provide an API to fetch data (because no one actually wants to parse the full HTML text) and this API will then return data in a more raw format, in this case json. json therefore isn't the method but the result / the formatted output from the database. I could have used the official reddit API but I just tried to append .json to http://reddit.com/r/swift.json and it worked. You can see what it looks like on this website: http://jsonformatter.curiousconcept.com/
You might want to try a [UIAlertController](https://developer.apple.com/library/prerelease/iOS/documentation/UIKit/Reference/UIAlertController_class/index.html)
I'd go with UIView - as you say just bounce the frame off screen when not required.
Ah, okay! Yeah, I've always been wondering how people draw information like that from sites like reddit and stuff for apps, but I guess this explains it! Thank you!
Hmm, that's a weird bug. I reported it to team at Github. It works for me, and sometimes didn't work when I switched from 'today' to 'this month.'
I would also like to find a few Swift tutorials for OS X. I only found 1 video tutorial on using storyboards for OS X Yosemite apps. The video doesn't really go into Swift, but still a nice video to watch. [You can find that video here](http://swiftvideotutorials.com/player.html?id=2)
Are the playgrounds supposed to do anything? If I click on Flyweight.playground "SourceKit terminated" is shown and then Xcode crashes.
[Lister: A Productivity App](https://developer.apple.com/library/prerelease/ios/samplecode/Lister-Swift/Introduction/Intro.html) on [Apple's blog](https://developer.apple.com/swift/blog/).
Unfortunate title really but the article is pretty good.
Swift programs (and objective-c also) usually use [GCD](http://en.m.wikipedia.org/wiki/Grand_Central_Dispatch) for multicore programming rather than threads
[Here's a very simple "Hello, World" style app for OS X in swift.](https://github.com/BergQuester/SwiftHelloWorldMac)
I think this is way too soon. If more non-Apple platforms support Swift, Swift would be useful. 
GCD uses threads, so that doesn't really have much impact on lock contention.
Swift (and ObjC, on ARM64) refcounting does not use locks, it uses atomic add and subtract. There's still a performance cost, but in practice ObjC apps have been performing fine for years.
GCD is a pure c library though so it doesn't use ARC
Where you'd get contention on the refcount is in the app-provided blocks that GCD is calling out to. i.e. something like (obviously trivial silly example, and non-ARC for clarity): dispatch_apply(100000, dispatch_get_global_queue(0,0), ^(size_t iter) { [anObject retain]; [anObject release]; }); will spend virtually all of its time contending on refcounting (though much much less on ARM64 due to inline atomic refcounts). At one point in the past (OSX 10.4 I think?), this ended up being a big perf issue for CoreData in some cases, and was worked around with inline refcounting. That would hopefully not be such a big deal now that ObjC does that itself :)
Dude, could you please upload it again? I'd like to read it on my Kindle. Thanks
They require Xcode 6 Beta 3, and yes they run.
I agree, I think it's too soon to say for sure, but I really like the article. Great share! 
Yes they are the same. The class method URLWithString is there because of the compatibility with Objective-C. The preferred method is the constructor `NSURL(string:"http://mywebsite.feed")` **Edit**: Also, those are not both class methods. The first is an initializer and the second is a class method.
The class method is the convenience constructor. In the "good old days", NSURL* url = [NSURL URLWithString: @"someurl"]; was the short, convenient version for NSURL* url = [[[NSURL alloc] initWithString: "someurl"] autorelease]; With ARC, the need for the autorelease call went away, and now with swift, there is really no more need for the former convenience constructor. You will still find them in a lot of classes, but there's no need to use them. Edit: To answer your question, NSURL(string: String) is probably a tiny, negligible bit faster, as the convenience constructors usually just call the equivalent init method, so you have one extra method call. 
Instead of doing + "6.M" you could also do + 6.months or + 6.M where months is an extension method on Int that turns the int into whatever time interval you use. It's a tiny bit safer because that way, you don't have the problem of parsing potentially malformed strings. I'm not entirely convinced that it's a good idea to do such stuff yet, though.
Hi jasamer, thanks for your comment! Right now, when you enter "6M" (a string), it actually converts it into an instance of "Term", which a length of 6 and a timeUnit of TimeUnit.Month. I like this because it allows for a lot of flexibility, e.g., you can do composite terms such as "1Y6M" (which gets converted into "18M"). What do you think?
Non-Apple support isn't required for the article's predictions to come true. The article's point is that all Swift needs to do is replace Objective-C (a language with negligible non-Apple support) and it will be one of top ten languages in the world. And it's basically a shoe-in to replace Objective-C. No one is standing around giving reasons why Objective-C will always be better than Swift.
Downvote for crappy hyperbole title : Surely if it will instantly change it, then it's been changed already.
This tumblr blog just started, but might be an interesting source for inspiration. i think it be nice following as it develops moving forward.
CODEPHENOM has a great YouTube channel with Swift tutorials, and below are some fantastic video tutorial from other sources. Many of the tutorials are similar, some add their own twist to things, but the last choice is by your preference. * [Swift iPhone Development Tutorial For Beginners by Sam Bensley](https://www.youtube.com/playlist?list=PLRCbZUDFiw3TRdmsorv31_p_uH0aa2RFq) * [100+ Swift Programming Videos](https://www.youtube.com/channel/UCml4lCH0xdl6Jm91RiPPIig) * [Learn Swift Programming Language by The Code Lady](https://www.youtube.com/playlist?list=PL31GjVbOFtfmvNk8IbHrEo7aP_CaONioK) * [Swift Programming Tutorial by Rasim Muratovic ](https://www.youtube.com/playlist?list=PLPedo-T7QiNtVD73fXrBT8KvngU3OiNo2) * [Learn Swift by Example Tutorials by Brian Advent](https://www.youtube.com/playlist?list=PLY1P2_piiWEY3W_aGo7r2OZmsk6Ww757Y) * [Swift Tutorials by Sonar Systems](https://www.youtube.com/playlist?list=PLRtjMdoYXLf5K460uUT_mJ3v3NSawUFh9) * [Apple Swift Programming Language Tutorial Series by Skip Wilson](https://www.youtube.com/playlist?list=PLfOZCUzRoPfKeOS_pwpiqbdviGcCOcTYb) * [Swift Tutorials by Apple Juice Teaching](https://www.youtube.com/playlist?list=PLJ7II9mlYqWip0nb6MUB-oSAlRSNo_jgh) If you find any other video tutorials, feel free to continue adding to this thread :) 
Hi pycet, I'm not the author of this tumblr blog, but most of the entries will be for iOS from what i know.
Note: This isn't any kind of referral link. I dont make any money from this bundle. I truly found it helpful to share with everyone who wants to learn Swift. I personally purchased this bundle, and I'm currently viewing the videos provide. I can answer any questions you may have. Feel free to reply to this thread if you have any questions before you purchase these video tutorials from Mammoth Interactive. 
There's no way to inherit from structures. 
That ending felt kind of tacked on.
I would actually recommend running the AsyncSocket ObjC lib and accessing it from Swift. It has a long history of working well - unless you do it as a learning experience of course.
Autolayout has been out for a while now. As hard at it might seem, it's time to learn it. If you want people to learn how to do things properly, show them the proper way to do things.
Agreed, pure speculation and far too early to say if the language will be open sourced and used for other targets.
Have you seen this on github, [SwiftAutoLayout](https://github.com/indragiek/SwiftAutoLayout)? It might be a nice place to start. 
I've been using it for a while, I just remember it having a steep learning curve, especially when it comes to scroll views and they content sizes
Definitely finish learning Objective-C. It's still the best way to learn the Frameworks, and that's really what iOS development is about.
idk man im just browsing /r/all/new and i have no idea what swift is and I don't know anything about programming. What does ternary mean? What's boolean literals? i'd say you prolly always need to set the literal to a variable first though but that's just a guess
Haha it's all a little complicated, but if you're interested, take a look at the [operator section of the language guide](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-XID_71) Swift is a new programming language just released by apple a couple weeks ago. I'm pretty sure your guess is right, and I need to set the literal (the actual value that a variable would represent), to a variable (the name of a place in memory that a literal is stored).
My thoughts exactly. Although to use the cleaner code you posted you would have to remove the explicit type definition (NSMutableArray) on the array properties because NSMutableArray does not conform to the Collection protocol. There are instances where typing an array explicitly as an NSMutableArray will be helpful. This is not one of those times. Thanks for posting!
I like how this guy thinks he knows way better than both the Swift designers _and_ Stroustrup. If only they'd listen to him. 
Okay, so it's just a matter of having "" inside of ""s? Thanks for the help. Also- why do you need the &lt;T: Integer&gt; in the function? Wouldn't this work just as well? func pluralize_is(quantity: Int) -&gt; String{ //blah blah blah }
Is a protocol in Swift similar to an interface in Java? 
Thanks! Yes, further adjustments must be made, I just focussed on the snippet posted above. I would have used a *Dictionary&lt;T, U&gt;* anyways, or probably wouldn't even store plain passwords in my code, but that's another story. :)
Basically, yeah. But don't think that means you can write this: func pluralize_is(quantity: Integer) -&gt; String { ... } Regular protocols you can, but not ones that have associated type requirements (such as Integer). Those you have to declare with a generic placeholder and then use that in the body.
Where does he mention Stroustrap? The hidden copy-on-write semantic is bad - C/C++ does this by forcing you to cast. It seems like he's also complaining that the contents of an immutable array are mutable. That's also not allowed in C, and shouldn't be allowed in Swift. Some scripting languages do copy-on-write, so I'm not sure if this is trying to mimic that, but I'd prefer that it require casting. So, I hope this does get changed.
The author seems to have a fundamental misunderstanding of what a value type is. An Array in Swift is a value type and that is why they changed it to behave the way it does now. It is now consistent with what a value type should be (everything is copied on assignment). The compiler optimization of sometimes secretly not copying it because it is never mutated, is not important from the programmer's perspective. Also, there is absolutely no reason to separate out the mutability of of a value type from it's contents because everything is copied and there are no pointers. The only reason that C has separate mutability declarations for a pointer and the memory that the pointer is pointing at is because these can be changed independently. This is not possible with a value type in Swift.
The copy on write is completely unimportant for us as developers. When writing code it is safe to assume that the array is always copied on assignment. It is a compiler optimization that we need not concern ourselves with except to be happy that they are making our code faster. It is no different than any of the other things a compiler optimizes.
I didn't make the title. Wired did. I am sure they saw your down vote though.
Is &lt;T: Integer&gt; the generic placeholder? Sorry, I'm about halfway through the language guide and am still trying to understand some new terms.
While I may not necessarily agree with this particular criticism, one of the major points of this beta is to reveal flaws in Apple's design. This goes doubly for arrays considering that they were literally just changed in beta 3 because of poor design. 
Try making a simple RSS reader. It'll teach you about networking, asynchronous HTTP calls, etc.
Yeah embarrassingly bad code. I hope no one uses this site to "learn" swift. Talk about the blind leading the blind.
I don't know if its completely unimportant. If your array was very large, it may be good to know when it's physically copied and when it isn't. For example to be reassured it won't be copied just by passing it into a function, unless the function explicitly chooses to make a copy and alter it, and to know if it was truly huge that your app may need to pause for that copy _later_, when you make a change, rather than right away (imagine not knowing that, and trying to debug an out of memory error when you were just making a change to an existing element rather than increasing the size of the array). Its useful to understand what's actually going on. But advocating understanding a nuance is not the same as being scandelized that there _is_ a nuance to understand in the first place. I was surprised when some interpreted [my article](http://airspeedvelocity.net/2014/07/10/swifts-lazy-collections-and-sequences/) on lazy collections as a warning that they were dangerous and Swift was to be avoided, which was not my intention at all. 
T is the placeholder, in a generic function pluralize_is. At compile time, the compiler sees the call to pluralize_is, and creates a specific version with the placeholder T replaced with an actual type being passed in (say, a UInt16 or an Int).* The : Integer part is a constraint, that states this particular function only works when T is a type that implements the Integer protocol, so you can't pass in a String or a Bool (because they wouldn't make sense for this function). Generics are really cool. They're covered in the penultimate chapter of the Swift book but it explains them clearly, so if my hasty explanation doesn't click, don't sweat it 'til you get to that part. *actually not completely true, one of the interesting comments on one of the WWDC Swift videos was that Swift can avoid creating multiple instantiations of the same generic function under some circumstances.
no need to be angry.
&gt; Where does he mention Stroustrap? Down the bottom, he links to a related post where he scolds C++ consts for not being to his liking either.
It's not criticism I object to, it's the know-it-all tone of this particular post. (pot, kettle, yadda) 
A nice example tree control in Swift with reorderable elements, perhaps? Seems to be a common element that could use a good demo. It's not really a project, but the outline control doesn't have a Swift example.
&gt; Doesn't look like the compiler can cope with string literals inside a string literal Yo dawg...
Hmm. I'm easily confused - placing this into the preloader definitely focused directly into something (seems to be the absolute middle of the whole worldmap), but when i attempted to change the mapCenter to anything else, such as let mapCenter = wilhelmReichAnnotation.coordinate it simply wouldn't work. How odd. It appears that these coordinates, while a-ok for showing a map, are not a-ok for the mapCenter? 
Edit: Posted twice by accident.
Hi! I guess the only problem with strings is that it's a source for runtime errors (ie. there's no way the compiler can catch a malformed string). The thing with terms still works! Just have 6.months return a Term with unit=month, and amount=6, and 1.years return a Term with unit=year and amount=1. Actually, I was a bit bored, so I created a pull request that implements the stuff I talked about. You can now do something like: let date = Date(year: 2013, month: 2, day: 3) let newDate = date + 2.years + 4.months Tell me what you think! Cheers!
That is a good point, knowing when something is actually copied could be important when dealing with huge amounts of data or with very high performant code, but I think it is very rare that a developer needs to worry about that. To your point though, it is definitely valuable for advanced developers to understand the nuances of when arrays will actually be copied for certain situations.
For the most part it is safe to assume that the array is always copied when being assigned. Let the compiler worry about the optimizations. When talking about high level concepts like passing arrays around, it is best not to confuse the idea with the way it might be optimized by the compiler until one truly understands what it should do at the conceptual level. The semantics of arrays are definitely different between swift and objective-c / c, I don't think it is high on Apple's priority list to make it work consistently with C.
Can you explain why? 
Totally agree with you, should only be relevant if you're pushing at the edges of the language. For most developers most of the time the benefit of this implementation is you don't need to think about it, it just does the right thing (unlike with the previous implementation which had gotchas anyone could stumble into).
The author appears to be confused by what the code actually does. From the article: let a = [1, 2] // a refers to an immutable array var b = a // b refers to a mutable array, a copy of array a b[1] = 3 // change contents of b, a does not change The author then talks about how the last line here is mutating b[1]. That's *not* what's happening. The statement "b[1] = 3" mutates b, replacing the element at b[1] with "3". Even if the code was: let a = ["zero", "one"] var b = a b[1] += " plus one" the code is not mutating the "one" String from "a", it is mutating a copy of the value owned by b. This is exactly how a std::vector&lt;std::string&gt; would work in C++. Copying the std::vector copies each of the std::strings. Except Swift is much better because the copying is *lazy* (only copied if needed). This means that the "zero" string is never copied in the last example, improving potential performance relative to C++. The only way that the program could actually mutate the children from "a" is: let a = [NSMutableString(string:"zero"), NSMutableString(string:"one")] var b = a b[1].appendString(" plus one") Then, finally, a[1] would have changed. This is because copying a reference creates another reference to the same underlying object. And "let" constness in Swift does not apply to the contents of "class" types. Both of these things were true in Objective-C and continue to be true in Swift. This behavior is why there are separate interfaces for mutable and immutable objects in Objective-C. The split the author is suggesting for mutable and immutable types is *only* required for reference types. And... it already exists. Answering the author's question: &gt; How do you pass an immutable array to a function? Answer: by value. If you pass the array by value (i.e. not "inout") then the function cannot mutate your copy. If it choses to mutate its own copy, that's its own business. If you pass the array as "inout" well... of course the function can mutate your copy, that's what "inout" is designed to do.
In many cases, swift can **infer** the type of a variable. In those cases, you do not need to explicitly give a type to the variable. In your example, the variable is inferred to be of type SKSpriteNode because of what you are setting as its initial value. In fact, in most cases you don't have to give a type. The main cases where at type is required is if you want to make a variable a superclass of the value you are actually assigning it to or if you are not immediately assigning the variable a value. Also you need to give an explicit type to properties with custom getters / setters. It isn't ever a problem if you want to give a variable an explicit type, it is just more code :)
Swift is young language, but there is a starting project on github: lubino/SwiftScript Right now it is in early development stage, check it out later.
Honestly structs, as subtly different, is a must. It's important that we have both value and reference types, and that's really the only major difference. I don't see this as a worse problem than not having structs. Especially considering it needs to be Objective-C compatible, since structs and classes are completely different there. And I guess it could take the C++ route of objects being passed by value unless passed by reference explicitly, but I think having classes be by reference automatically is much more useful, especially considering (again) the need to be Objective-C compatible. As for optionals' language, your do-no-wrong Haskell has special language for lists and for *do* blocks. Syntactic sugar is present in *all* languages, and writing Maybe for every optional's type and using extraction methods instead of the handy ? notation would have been a nightmare. Now this isn't me saying swift has no flaws. I just think these two aren't among them.
A sensor app? Showing your current (gps) speed, acceleration, the current sound level, camera light conditions, etc... Create a reusable view (gauge) to display the values. 
The article mentions `flatMap` which, if I remember correctly, is basically a monadic bind in the context of the optional type. But Swift already has optional chaining, which is a more succinct way of doing monadic binding. Plus, thanks to extension methods we should be able to add any new methods we want to the `Option` enum.
`"background.png"` is _not_ of type `imageNamed`, it's a function argument which is specified by the named parameter `imageNamed`. Named parameters in Swift are designed to look like ObjC's parameter-interleaved functions.
Thanks a lot jasper. This is quite elegant. I've merged your pull request!
Why is it necessary to have both value and reference types?
Can you post your code snippet?
As someone who has spent most of his programming life in the Java universe, I've lived with having only reference types, and it's sub-optimal. A lot of tradition has been built-up over time in order to mitigate exactly that limitation: best practices for setters &amp; getters that return/receive mutable objects like java.lang.Date are expected to make defensive copies. Immutable lists and maps are recommended to be used whenever possible, to prevent one region of code from molesting data structures managed by another region of code. A lot of work needs to be done to make objects immutable by design. Etc, etc… All of this work would be unnecessary if it were possible to choose value semantics in those situations.
Give it a shot! I'm likely one of those people following the blind as I am blind myself (not literally), but I'd really like to learn the better ways of doing things.
Here you go: http://pastebin.com/rUrjQshs
Based on your snippet.... @IBOutlet var mappers : MKMapView @IBAction func testAction(sender: AnyObject) { println("testAction") var CoralCastleAnnotation = MKPointAnnotation() var latitude:CLLocationDegrees = CoralCastlelatitude var longitude:CLLocationDegrees = CoralCastlelongitude var churchLocation:CLLocationCoordinate2D = CLLocationCoordinate2DMake(latitude, longitude) CoralCastleAnnotation.coordinate = churchLocation CoralCastleAnnotation.title = CoralCastlename CoralCastleAnnotation.subtitle = CoralCastletitle mappers.addAnnotation(CoralCastleAnnotation) let mapCoord = CoralCastleAnnotation.coordinate var mapCamera = MKMapCamera(lookingAtCenterCoordinate: mapCoord, fromEyeCoordinate: mapCoord, eyeAltitude: 1000) mappers.setCamera(mapCamera, animated: true) }
Okay, so, first...When importing the library, is [this](http://imgur.com/pyQcMnf) the correct way to do it? Next, I don't exactly understand what they're saying the purpose of the front and rear view controllers are, but I went with it anyway. It says &gt;If you compile and run the app, you’ll see an app displaying the “News Frontpage”. I didn't use their template, but should I have switched the arrow indicating the startup screen? Also, I don't know if it's necessary, but I'd prefer not to use a navigation controller if I don't have to (I don't like the bar up top for my purposes). &gt;#import "SWRevealViewController.h" How do I do this? I know how to import, but I've tried it with and without quotation marks and neither works. After that, I tried in a another project, and .target and .action weren't showing up as properties available to a UIButton. I'm not sure if a lot of my troubles are coming from the fact that I'm not using their template...but it's just a lot that I don't know if I'm doing correctly that makes it hard to follow the tutorial.
thank you! Hi, I did some adding and got this in the end: 2014-07-17 00:04:50.486 MapButtonage[20059:611353] Could not determine current country code: Error Domain=GEOErrorDomain Code=-2 "The operation couldn’t be completed. (GEOErrorDomain error -2.)" (lldb) (at first the whole app would crash, but when i re-added some lines, i got a crash after clicking on the button) @IBAction func ButtonOne(sender: AnyObject) { //CC println("testAction") var CoralCastleAnnotation = MKPointAnnotation() var latitude:CLLocationDegrees = CoralCastlelatitude var longitude:CLLocationDegrees = CoralCastlelongitude var churchLocation:CLLocationCoordinate2D = CLLocationCoordinate2DMake(latitude, longitude) CoralCastleAnnotation.coordinate = churchLocation CoralCastleAnnotation.title = CoralCastlename CoralCastleAnnotation.subtitle = CoralCastletitle var latDelta:CLLocationDegrees = asCloseAsSheCanGet var longDelta:CLLocationDegrees = asCloseAsSheCanGet var theSpan:MKCoordinateSpan = MKCoordinateSpanMake(latDelta, longDelta) var theRegion:MKCoordinateRegion = MKCoordinateRegionMake(churchLocation, theSpan) self.Mappers.setRegion(theRegion, animated: true) self.Mappers.addAnnotation(CoralCastleAnnotation) let mapCoord = CoralCastleAnnotation.coordinate var mapCamera = MKMapCamera(lookingAtCenterCoordinate: mapCoord, fromEyeCoordinate: mapCoord, eyeAltitude: 1000) self.Mappers.setCamera(mapCamera, animated: true) 
It works on my device. The error must be in some code outside the function
Just create various applications of the ViewControllers made by Apple. For example, the intro for the app could be a UIPageViewController, then display a UITableViewCon. that is embedded in a UINavBar which is also embedded in a TabBarController, then UICollectionViewController, etc.
 I recently used this to do something similar with an array of ints. var nameOfArray:[Int] = [] var thingToAppend:Int = 0 func appendToArray() { var isThingToAppendInNameOfArray = contains(nameOfArray, thingToAppend) if isThingToAppendInNameOfArray { println("\(thingToAppend) is already in the array") } else { nameOfArray.append(thingToAppend) } } Edit: after re reading your post I don't think this is what you wanted. This just checks if the array already contains an item, and either tells you it can't add it, or adds it. But I'm leaving it. 
So in principle, this should not be so hard. Swift was implemented as an llvm thing, and, from what I have seen so far, is not an especially "rocket science" language to implement unless you insist that (e.g.) playgrounds are an intrinsic piece of the language. So I am moderately to highly confident that other-than-Mac implementations will happen, and, if Apple is smart, they will be implementations at least initiated by Apple based on something like a stable version 1.2 of the language.
edit: it can be done, see corrmage's answer above Yeah, no, you can't do that. Because there is nothing guaranteeing the type T of the array you're extending will always conform to Equatable, you'll get a compiler error. Imagine you could somehow fix that compiler error. What would it mean for this function if the array were to contain non-equatable elements? Would it be uncallable? Not present at all? Would it prevent Array from being creatable with non-Equatable types? You can't write an extension that mandates the already-defined collection adheres to some further constraint. To do what you want, you either need to supply a function to Array.filter, and have the function do the comparison, or write a non-member function that took the array (or a generic function that took a Collection or Sequence) and filtered out the dupes. By the way, the function in your gist doesn't look like it'll filter duplicates, it looks like it searches for the presence of a specific element. You can do this with the standard library find command: let arr = [4, 6, 2, 3] if find(arr, 6) { // found it! } Note how that's not Array.find, it's a function that takes an array and an equatable value, for the reasons I gave. To find duplicates in an unsorted array, you'd need to use filter and stash the first of each value found in a dictionary caputured by the closure, then use that to filter out each subsequent one.
I don't think it's possible. You can't write extension methods for a specific type of array, say, an Equatable array. That means that even though you can specify your function parameters as conforming to the equatable protocol, you can never equate them with the inner elements of the array, since nothing guarantees you that those conform to equatable. In fact, I don't think there is any way to write methods for a specific subtype of a given generic object, even if you had access to it's implementation. Which is a shame, it's a powerful feature, it could be very useful An alternative is to define your function as a global one, like this: func include&lt;T : Equatable&gt;(array: Array&lt;T&gt;, element: T) -&gt; Bool { return generatorInclude(array, element) }
Good point. Personally, I'm inclined to go with \#2, which, while not often chosen by programming languages, is an acceptable option as well (and, I think, much easier to reason about for several other reasons). Swift makes it fairly trivial to write immutable classes, and I think those tools are superior to the mishmash of structs/value types and classes/reference types.
Or the work is unnecessary if you write immutable classes, which I find to be a much better option, for this reason and several others (ability to reason about the state of the code/program, for example). Luckily, Swift makes it fairly trivial to write immutable classes, and I think that route is a better option than the combination of structs/value types and classes/reference types.
Can enums have methods? I was under the impression that they do (`toRaw()`, for example), but those were essentially built-in and it isn't possible to define new ones.
Yes, test iAds appear in the simulator. You'll see a blue ad with the message 'You're connected to iAd Network'.
&gt;Give it a shot! I'd do if I had any ideas. What would you like to learn?
1) Yes. You need to create a bridging header to user Obj-C classes in your swift application. 2) The import statement goes into your newly created bridged header file. It's named &lt;projectname&gt;-Bridging-Header.h. After you import the .h files you want here, you can use them in your Swift classes.
I haven't played around with SpriteKit yet, but I would assume the solution involves writing custom shaders. And it also requires some type of normals for the sprites. I wouldn't say it is super easy to do. But maybe SpriteKit already has some functionality for this. I'm unsure.
hi, how can i add a new layer or view OVER the top of a gradient like this ?? (in swift!) thanks!
You can achieve that with type evidence: http://www.reddit.com/r/swift/comments/29qor6/how_do_i_implement_flatten_as_an_extension_on_an/ciwbw1i Here's how it may look like: extension Array { func uniqueElements&lt;U: Equatable&gt;(evidence: T -&gt; U) -&gt; [T] { var result: [T] = [] for value in self { let equatable = evidence(value) // do your magic } return result } } [1, 2, 3, 3].uniqueElements(identity) // fine [(1, 2), (1, 2)].uniqueElements(identity) // does not compile, tuples aren't Equatable 
The new automation language for Yosemite is Javascript which is always useful to know since it is used a lot on the web.
Value types are immutable by definition, which is always less work for you than going out of your way to make sure that the class you have written has an immutable design. The great thing about value types is that not only do you get the same ability to reason about your code that immutable classes give you, but the compiler also gets a greater ability to reason about the code. Swift's value types will use a copy-on-write strategy to minimize actual copying, for example. The Swift compiler will never accomplish that sort of optimization with reference types because they have reference semantics with the additional complication of inheritance. 
Applescript still works just like before and I believe the Applescript editor has been upgraded to support JS.
Does swift allow for automation as well?
I think so, not sure though. You should watch the [Javascript for Automation](https://developer.apple.com/videos/wwdc/2014/) video from WWDC if you're interested in learning more about automation in Yosemite.
I just finished watching that. It only talks about automation with JavaScript. 
The difference is exactly in the assignment. Think of it this way: instead of having to type out ! to unwrap it you type out .value. var attDict = attrs.value; Now it looks a lot different. There is a lot of syntactic sugar around optionals, so it's important to realize what's going on.
Take a look at a blog post I made which simply explains optionals and unwrapping. [Blog Post](http://www.cocoakris.com/tutorial/optionals-unwrapping-swift-explained/)
Okay, now for the code. _sidebarButton.target = self.revealViewController; _sidebarButton.action = @selector(revealToggle:); [self.view addGestureRecognizer:self.revealViewController.panGestureRecognizer]; Would those^ lines be transcribed as this: _sidebarButton.addTarget(self.revealViewController(), action: "revealToggle:", forControlEvents: .TouchUpInside) self.view.addGestureRecognizer(self.revealViewController().panGestureRecognizer()) Because I'm getting an error when I try to run it--"fatal error: unexpectedly found nil while unwrapping an Optional value"--on the line starting with self.view... Edit: [Here](https://www.dropbox.com/s/a5hyaolv3l7abnf/SidebarTest.zip) is a zip of the project, if that would help. I'm probably doing something stupid...
Swift can theoretically do everything Automation can, but it's not built for it. Just use JavaScript. AppleScript is a horrible thing, and Swift won't get you where you want to go.
Not directly. You can do it the same way you can do it with Objective-C, but it doesn't improve that situation at all.
Thanks, your advice removed over 50 lines! I've gone ahead and posted the updated version. Coming primarily C++ background, it was natural for me to make my own getters and setters, but I could definitely get used to the easy setup Swift has for properties. The Array convenience syntax cut out a lot of the lengthy for-loop initializations too! I also added subscript access, but kept element(#atXIndex:atYIndex) and setElement(newValue:atXIndex:atYIndex) for more formal access methods. I'll keep working on improvements, and maybe toss it on GitHub eventually. This has kind of turned into a small Swift template library project for myself. Thanks for the advice!
The Storyboard hasn't been set up at all to make use of the segues and views in it. I suggest you try and work through this tutorial in Objective-C to get an understanding of how the project and structure works. 
? Just get in there and hack around man. Everything in software dev changes constantly and being comfortable with managing that change is vital to a long and successful career. 
I would say focus on learning proper Objective-C for now, it's not going anywhere and swift won't replace it in next few years, Swift is unstable and so is new Xcode so it will be problematic. 
Don't do it if you have work that needs to be released soon. Aside from that, yeah hop in there. Everyone is new to it, and you won't be behind the curve for long.
Similar to what others are saying, dive straight in! BUT I would wait for it to be out of beta, because it still isn't complete and there are breaking changes being made, before actually making your app in it. 
Are you new to all programming or just Apple's technologies? If you are new to all programming then I strongly recommend you avoid Swift until it is out of beta. As a new programmer you really want to be able to trust that any problems you run into are caused by you and not the technology. This is not possible right now in Swift because it is in beta and it is quite buggy. However, if you are an experienced programmer and like playing around with new technologies, I would say go for it! (but not yet for products you depend on for money)
How is ActionKit different from BlocksKit? https://github.com/zwaldowski/BlocksKit
Sorry, but I'm not sure what you mean. I've set up the project so far just as the tutorial has it, haven't I?
More just to Apple. I have been doing programming for about two years now.
I've been programming for 3 years in Pascal, Java and Python and have just started to get into iOS with swift. I'm having very little problems - the biggest of which are with the SDKs and so as someone who knows Objective-C I see no reason why to not. Its the future of iOS, even if it is a little bit of work converting tutorials and documentation from Objective-C. As for the bugs and similar issues - what part of the computing industry doesn't have it's own quirks, isn't that one of the programmers greatest skills to work around them? I say go for it.
this is awesome!
I'm sorry but this seems like a horrible idea. Unless you are very careful, stored closures lead to code with ill-defined memory dependencies along with action code that is defined far from actual point of execution. If one wants to avoid selectors, you could build a lib which stores method reference + target object. Their storage / lifetime would be well defined, loosely coupled and completely typesafe. Using closures like this is setting oneself up for disaster.
This is a great collection.
Yes, as always is such for similar questions.
 I was trying to figure out how to put a live camera feed in an app when I stumbled across it. It seemed surprisingly straightforward so I tried adapting it to ios. Granted the ios simulator doesn't have a camera so I can't actually test what I wrote but it seems right. Edit, and yes this is awesome
This helped a lot - I was aware that there are strong reference cycles in storing the closures and was trying to think of ways to avoid it. I'll be more careful in the future, and I'll some warnings in the README. Thanks!
Sweet, glad I could help
Yes, they are being called. Overriding is just a notation identifying that the method is a part of the parent class and will be overridden in this subclass. Moreover, the parent classes' behavior will continue on, since you're calling super within each of the overridden methods. It seems like you might want to brush up on how object oriented programming generally works and also how these methods get called in the grander picture of cocoa. I would recommend reading "View Controller Programming Guide" found on the Apple developer site.
Different default rules: * Init: all parameter names required * Functions: no parameter names * Methods: first parameter name omitted, the rest required. It's like this to fit well with ObjC/C naming rules.
Nuoji's right in that this is just different default behavior between functions, methods, and initializers (with SKNodeTexture(imagedNamed:) being an initializer), but OP, note that these are only the default rules. You can make it so the parameter name in your function must be included by sticking a # in front of your parameter name like func sayHelloAgain(#personName: String) -&gt; String { return "Hello again, " + personName + "!" } which would then be invoked as sayHelloAgain(personName: "Anna") OR, by defining external and local parameters such as func sayHelloAgain(withPersonName personName: String) -&gt; String { return "Hello again, " + personName + "!" } which would then be invoked as sayHelloAgain(withPersonName: "Anna")
Exactly, if you have decent experience in programming, then Swift is very easy to pick up.
And in case anyone is wondering, I've written [swix][swix], a framework for general matrix language and machine learning functions. It integrates OpenCV and Accelerate and gives you a new matrix class, easy initers, FFT/IFFT and various machine learning functions. The goal behind this library is to facilitate easy Python/Matlab-iOS conversion. [swix]:https://github.com/scottsievert/swix
I didn't know about @auto_closure, that's pretty awesome :)
just do it bro, no need to wait
The problem with closures is that it puts the burden of resolving strong reference cycles on the user of the library, and that user must both take into account the library's storage policy on the closures, as well as the captures in each closure they write. Using selectors or function references the retain policy becomes solely the responsibility of the library which is miles better.
Overriding a function won't magically call the function too. Some functions/methods are called automatically by the framework. `viewDidLoad` and `didReceiveMemoryWarning` are two such methods. No matter if your have overrode them or not they will be called by the framework, after a view loads or when an app receives a memory warning, respectively.
No to storyboards. I'm working on problem will post here when I get a solution. Thanks for self.navigation bit.
I actually find it kind of horrifying. It seems like a way to make it pretty much impossible to guess what `f(x)` will do.
Hi skier_scott, your project is absolutely amazing! I'll modify the original post to mention your work!
How are they called automatically? How is it known to call them automatically?
Nice share! :)
Good point! That is now fixed :-) https://github.com/practicalswift/Pythonic.swift/commit/85b26d14b93b16f0f54f3f6f9edcc022bbc947b8 Thanks for the feedback! Feel free to contribute to the project
Cool, thanks! Though, I wouldn't expect that "UI which respect latest Apple guidelines" would have a button-like border around the number of votes, number of comments, and the author's username next to every post in the list. Are those borders idiomatic in iOS 8?
How does this compare with NSSet performance wise?
On the other hand, if you want to explicitly omit the name - say, in an init - it works like this: init(_ imageNamed: String) which is invoked as SKNodeTexture("imageName")
Nice, a great idea for a simple hello world project and quite well executed! Not perfect, but very good nonetheless! My suggestion for improvement would be to load in the conversion rates through json (see NSJSONSerialization), so you can customise without rebuilding (also because an understanding of using json is a really crucial thing for apps these days!).
What's the difference between a method and a function? I was taught the terms are more or less interchangeable. And how do you differentiate between them in Swift?
And we need this syntax sugar for set [:String:] :))
Here is a tutorial by Ray Wenderlich, who has been creating tutorials for iOS for several years now. http://www.raywenderlich.com/74438/swift-tutorial-a-quick-start Here's another by James Quave. http://jamesonquave.com/blog/developing-ios-apps-using-swift-tutorial/ Both provide excellent explanations of what's going on as the tutorial progresses. Also, I've found this cheat sheet to be pretty helpful. http://cdn2.raywenderlich.com/wp-content/uploads/2014/06/RW-Swift-Cheatsheet-0_4.pdf If you've paid for the Developer Account and have the drive you should check out this year's WWDC videos. https://developer.apple.com/videos/wwdc/2014/
1...5 produce a range object from what I can understand. This is pretty common in many languages. So the range in this case is just two numbers: start and stop. Then we basically just have a regular C like for loop where we set index to the start value and check if index has reached the end value. Not sure if that is the answer you are looking for. It really isn't that magical. Perhaps you were worried that an array of elements 1 to 5 was created in memory and iterated over?
If you wanna make an app, look on the right side of the subreddit under "Resources". Test out various viewcontrollers (I can offer code if you want it.) If you specifically want to make a game, then I recommend using a game framework that builds on OpenGL, there are many examples such as Apple's Spritekit or cocos2d.
Ok there's quite a lot to unpack here. Whenever you write this in Swift for x in s { } the compiler translates it under the hood into this: var gen = s.generate() while let x = gen.next() { } For s to be useable in a for-in loop, it needs to be a class or struct that implements the Sequence protocol. Sequence requires you to implement the generate() method, which returns another object that implements the Generator protocol, Generator requires you to implement a next() method. That method returns the next item in the sequence, or nil if they've all been consumed, at which point the while clause will terminate (because nil has the same effect as false on the while clause). The let x = part declares a brand new x every time around the loop, and also unwraps the optional. For more on why declaring a new x each time is helpful, see [this article](http://airspeedvelocity.net/2014/06/19/swifts-for-loops-avoid-an-easy-mistake-with-variable-capture/). What does 1...5 do? ... is an infix operator that takes two values and returns a Range object. That Range object implements Sequence. And the value its generator pumps out each time you call next() is the next value in the range, starting at the left-hand number, until it reaches the right-hand number. Lots of Swift standard library classes implement Sequence, including Array (next() returns each element in the array), Dictionary (returns each key/value tuple). Also lots of other functions in the Swift standard library take sequences, such as map (take each element returned by next() and apply a function on it), filter (take each element and pass it on if a function you run on it returns true), and enumerate (take each element and return a tuple with an incrementing number and that element). Also there are standard library objects that help you generate your own sequences easily, such as GeneratorOf that takes a function and runs it each time someone calls next(). See [this article](http://airspeedvelocity.net/2014/07/10/swifts-lazy-collections-and-sequences/) for more on them.
Great Idea!
Thanks. I made it because I found myself typing in -"Taylor" over and over again at the end of all my Google searches. Decided to expand the negative keywords and automate it. Thought others might be having the same problem.
now is definitely the best time ever to pick up swift, because there was no time before that where you could.
When I say functions I mean free global functions, not defined for a struct/enum/class.
I have done both, and IB can work extremely well in many cases. Discounting IB because you're using code feels a bit like saying Core Data is useless or C++ is useless because you're find yourself doing well without either ;) The original intent for IB was to allow designers to work with IB and send updated nib files back to the programmers. This is still possible, although probably not the way it's mostly used. That said, it's a great tool for prototyping and the alternatives for a WYSIWYG (which you really need to have) are much worse (code generation etc) Already today Xcode beta 3 will correctly show what IBActions / IBOutlets you have wired up and refactoring is possible from within Xcode, so those arguments are hardly valid. What is it you're hating about the assistant editor? 
You need to have a: if episode inside the loop to make sure that the object exists. Only unwrap objects if you are 100% certain it exists.
In the case of an optional value that is an array, it's pretty common to just have an empty array instead of an optional. You can think of arrays as being optionals themselves, as in they're a data type that optionally has more than one value in it. 
&gt; But if it doesn't contain any values, it crashes. Its important to distinguish between an array being nil, and an array being empty. Assuming you're the implementor of whatever hannibal is, if you have a list of eps that might be empty, you should probably be returning an empty array rather than a nil value. If you can't change that behaviour for some other reason, the following code is a way to avoid the ! (which should only be used in very exceptional circumstances, which this one ain't): if let eps = hannbal.episodes { for ep in eps { // etc } } Annoyingly, the above code doesn't let you handle no episodes (both nil and empty) in the same block. There might be a clever way to make that work but I'm not at a playground right now to tinker...
How would I do that? It seems I need to unwrap before going into the loop because otherwise I get the *array doesn't conform the protocol 'Sequence'* error.
&gt; Assuming you're the implementor of whatever hannibal is, if you have a list of eps that might be empty, you should probably be returning an empty array rather than a nil value. I don't really understand what you are trying to say here. Should I check if the array is empty before continuing?
What he means is that you probably wrote the class for hannibal yourself. Based on this assumption he suggests that instead of: **making hannibal.episodes either nil or an array with objects** you should: **make hannibal.episodes either an empty array or an array with objects** However, if you did not write the code for hannibal yourself you could use the example he gives to check if hannibal.episodes is nil before looping through it.
Yup, that's what I meant. It's a shame there are legit uses for !, otherwise the language would be much better off without it. I see a lot of cases of people sprinkling ! around their code to try and resolve compilation issues, like apostrophes in an ungrammatical sentence.
Don't know why your post is getting downvoted, this is a legit question not fully explained in the Swift book (though they do cover it in one of the WWDC videos).
I'm a noob. I still don't get what I should do. For clarity, I added my project's GitHub page to the original post. hannibal is of type TVShow, episodes of type [Episode]?
They've mixed up inside and outside. You need an if outside the loop, to check the episodes variable isn't nil, not an if inside to check the episode variable isn't nil (unless the array contains optionals as well).
Even includes a negative search for Jonathan Swift!
There are quite a number springing up on youtube now. Just search and sort by uploaded date as anything before June 2014 is not Swift!
I'd agree with that, the language is great for a beginner. The only quirks being the legacy of Objective C that will hopefully fade over time. As someone coming from Objective C its a breeze, and far easier to read!
omg yes
omg yes, YES!
Haha only just downloaded beta 3 a few days ago.
Is there a default?
Still needs 'protected' if you ask me.
Most entities are internal by default. (per the release notes)
Like Java? Wouldn't that only be meaningful in a subclass of a class? What would it do in a struct?
I never really got why access modifiers were useful (probably I'm just ignorant) but surely when it's your source you are in control. What's the big deal with making something private?
Encapsulation.
As soon as Programmer A starts using a symbol introduced by Programmer B (whether they are on the same team or in different organizations) then Programmer B can't change the name or meaning of that symbol without breaking what Programmer A is doing. So the choices are 1) control the visibility carefully so as to restrict what Programmer A can use, or 2) Programmer B accepts responsibility for refactoring Programmer A's code - which might work if they're on the same team, or 3) Programmer B changes the symbol and hopes that Programmer A doesn't become enraged at the disruption, or 4) Programmer B plays it safe and never changes anything, which is very unhealthy. Refactoring is as necessary to the health of code as tilling &amp; pulling weeds are to the health of a garden. These visibility keywords allow Programmer B to publish an API that they are willing to support, and make sure that Programmer A doesn't use anything they shouldn't.
I really like the "Python Gentlemen's Agreement" here. There is no private, but symbols prefixed with a "_" may be arbitrarily mutilated in a future release. Use at your own risk.
You should either look into refactoring your code to use a [UICollectionView](https://developer.apple.com/library/ios/documentation/uikit/reference/UICollectionView_class/Reference/Reference.html) or into [creating custom container UIViewControllers](https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/CreatingCustomContainerViewControllers/CreatingCustomContainerViewControllers.html). Your situation is probably best suited for a UICollectionView, which is similar to but more flexible than a UITableView.
Thank you for the advice. Can the UICollectionView inherit from UIScrollView or be inserted into a UIScrollView so that I can use the scrolling features? If you're not sure, no worries, I'll research it further tonight. 
You end up with the [fragile base class problem](http://en.wikipedia.org/wiki/Fragile_base_class), which is basically lost loststinger is describing in the other comment. It ends up being about keeping internal methods internal, so that you know that A) you can change/remove them at will and B) changes you make won't be overridden by a subclass. Hell you can even get into this situation in your own code when you end up with some "one time hack that I'll totally remember" that you forget about when you change the behavior behind that hack.
I also more prefer strict rules, but what can I do. Swift is more similar to Delphi in this case, but I more prefer how c# work.
Java screwed up protected. In C++ protected is public to subclasses and private to everyone else. 
Hi! NSSet is faster (at least in Xcode 6b3). It really boils down to the speed of the backing Dictionary and it (including Swift in general) will probably see massive speedups in the later releases, so stay tuned :-)
Hold up, there is no data storage? Kinda useless if you ask me, for app like this, should've included CoreData or Document based storage.
Excellent blog post as always. Thanks!
No. Internal members can be accessed from other classes in the same package/file protected members can only be accessed from their class or subclasses.
Why would anybody buy a course for a language which isn't even finalised? Also I believe this fall's under Reddit's "dont just spam, contribute also" rule.
If you only want to write apps for your mac and iphone swift is a great choice. If you just want to learn versatile programming language ruby is a better choice. Ruby also comes installed on Macs by default.
Others have suggested good reasons. I'll offer another. Frequently when you're creating a class for others to use, you have an idea of how you'd like them to use it. You may have internal helper methods or data that may change in externally unexpected ways which aren't intended for public consumption, public/private allows you to explicitly state that. It better defines the public interface.
Probably not. Swift is a new language which carries two main problems: rapid change and lack of documentation. Both will get better in time, but both may be needless points of frustration. If that's ok with you though, then I'd say look into it and judge for yourself. Everyone has different preferences when it comes to their language of choice, maybe Swift is yours.
As long as you think you can cope with it changing under your feet for now (there's been big language changes on a weekly(?) basis), go for it. The best thing for learning programming is doing something that you're passionate about and that you can come up with a project you'd want to make in it so that there's something driving your learning process.
As mentioned you probably want a uicollection view. However, in interface builder using story boards there are container views. These can be combined with an embed segue to host a view controller. 
Despite what some people are saying I would HIGHLY advise against it. Ruby is a great language to get the shared basics underneath you. Swift has been changing weekly, and code samples from last month will most likely not work this month. Stick with something that has a ton of references online and come back to Swift in six months.
In 6-12 months? Yes! Right now? Probably not.
Oh, thanks! I was trying to use class.function()
Oh lord no. The fact that generic types are usually written as a single capital letter makes them extremely distinguishable. Emoji would be more difficult to type and just hurts my eyes.
Yeah, I was confused at first as well by how it works. They aren't namespaced :)
Difficult to type? I'll give you that. But simple to pop open the character palette and grab a 🍀 and drag it in then copy/paste it when you need it. Distinguishable? Yes. But extremely distinguishable? Hardly. In that code snippet alone there are 19 other capital letters, a generic protocol or class you could have many more. Using emoji calls these cases out visually so they're easier to keep in mind. Descriptive typenames are good, and in a place like generics where there may be no good descriptive typename, 👻 and 🐷 are far easier to visually spot and keep track of than T and U. It's the same reason cocoa-friendly people avoid things like 'int i;', a longer name (or, in this case, a visually distinct symbol) is better for code comprehension because it's easier for our minds to distinguish as discrete symbols.
I'm not sure, but wouldn't it make sense to do something like toString instead of printToTerminal? Although perhaps using the [ObjC terminology](http://stackoverflow.com/questions/1104746/what-is-the-objective-c-equivalent-for-tostring-for-use-with-nslog). 
As a second year CS major, "Implicitly unwrapped optionals" is a cluster fuck of terms that scare me because I have no idea what they mean. 
**EDIT**: It seems SKColor (as color property) was changed to UIColor ?
No problem! Actually, that's the exact opposite of me - whenever I drop down into plain C I feel like I can't get anything done without writing a ton of code for simple stuff like string manipulation. App dev is different but it's a lot more fun I think. I'm not sure exactly which apps you should try to build (that's up to you depending on your interests!), but I think it's worth learning how to do the main building blocks such as loading stuff over the web (using [NSURLConnection sendAsynchronousRequest...] - this'll teach you about blocks if you're not already familiar with them), parsing JSON (NSJSONSerialization) and perhaps XML (probably something 3rd party like TBXML), and then mobile app-specific things such as UIGestureRecognizers (for pinch, tap, drag support), support for rotation, etc. There's a ton of things you can do in mobile apps and you have a load of cool new things to learn but my only advice would be to take it one step at a time and don't feel overwhelmed. Looking forward to your next project!
If you do decide to learn Swift, I'd be more than happy to give my class teaching it to you for free. Shoot me a PM and I'll send you a coupon https://www.udemy.com/swift-learn-apples-new-programming-language-by-examples/
You're in luck. As someone who knows Ruby and has been looking into Swift. I would suggest you stick with Ruby. But the good thing is, A LOT of Swift syntax and most of it's semantics is super similar to Ruby. Actually, out of all the languages I've ever used. I think Swift and Ruby are the most similar in syntax alone. I picture Swift as a mixture of Ruby and C++ actually. Stick with Ruby, learn the bread and butter in Ruby. You can do a lot more with Ruby then Swift. But once you have Ruby down and you are efficient enough to put it on your resume, check out swift. 
I'm sorry but your argument is counter intuitive from my perspective. I associate a T, U, i, etc. much easier than I would ever a ghost or a clover leaf or a pig (I almost copied and posted the emoji but I found the process too arduous... see my point, no different in code). Furthermore, the flow of coding using emojis in variable names would be running quick sand. It's explicitly confusing for other programmers looking/using your code (with an image infinite connotations can exist). I only justify emoji's place in swift with explicit literals that will be displayed to users.
T and U have no real meaning other than "Hey, I guess 'Type' starts with T and this is some type so lets go with T" and "well I already used T so I guess I'll go with U next because it's the next letter of the alphabet?" They provide no inherent clarity over an emoji, other than "C++ (or whatever) programmers have been doing generics with T/U forever" or maybe "I just hate emoji", but I don't think either of those are really valid reasoning. And I certainly doubt you could find me a programmer who sees 'func foo&lt;T: Equatable, U: Equatable&gt;(arg:T, arg2: U)' and thinks "oh okay I understand, that takes two possibly different Equatable types" but then sees 'func foo&lt;🐸: Equatable, 💣: Equatable&gt;(arg:🐸, arg2: 💣)' and thinks "oh god what are they trying to tell me about frogs?!"
the code can be made even more concise. var keys = [UIKeyCommand]() "ABCDEFGHIJKLMNOPQRSTUVWXYZ".each { c in keys += [.Command, .Control, nil].map{ UIKeyCommand(String(c), $0, "keyPressed:") } } 
it's hard because then you would get a variable timing issue that would just constantly repeat a false loop
As of right now, I'd say that Swift is not a good candidate for a first language as it changes every 10 days with new beta releases. For a beginner, this is too confusing. Ruby is an excellent language but I wouldn't recommend it either for a beginner. Learning Ruby (especially through an outlet like codecademy), you'll become a hacker, not a programmer. Too many basic programming concepts are left out, such as data types, for example. Actually, with my little team, we are betting on teaching programming using Swift. Have a look at [Brick](http://www.codewithbrick.com). One could argue that Swift has the same shortcuts as popular scripting languages like Python and Ruby. Still, to take the data types example, even though Swift can use type inference (shielding the beginner of the intricacies of types) but it can also make use of type annotations which is very suitable to really explain what a type is, why you'd want to cast between types, etc. TL;DR: wait until September to learn Swift if you are a complete beginner and check out www.codewithbrick.com ;-)
A CGFloat is actually a Double, the naming is kinda misleading. That is why you can't use a CGFloat as a Float: casting a CGFloat to a Float would be a loss in precision. In general, you can just use Double because you can pass a Double to any method that takes a CGFloat. You may still want to use CGFloat when you deal with UIKit coordinate specific stuff for clarity.
Did you add a type for foo? The following works for me (I'm still using beta 3 though) var foo: Int if a == b &amp;&amp; k == l { foo = 3 } else if a == l { foo = 5 } else { foo = 7 } Edit: foo can't be a constant, because checking that foo isn't assigned to multiple times is a different problem that the compiler can't solve (in the general case).
Maybe that is it. Do you think it's because it is of numeric type? Does it work when foo is a string, but where it isn't explicitly declared as one? I am not home at the moment, but otherwise I can test it myself tonight :). Thanks for your answer, it seems to be what I am looking for.
It's got nothing to do with which specific type it is, it just has to have its type declared.
Check this tutorial out: http://ios-blog.co.uk/tutorials/developing-ios8-apps-using-swift-create-a-to-do-application/ 
Why not assign foo the non-garbage value 7 and omit your final else clause, and only change the initial value in if/else? This doesn't solve your compiler wish, but it does avoid invalid values.
You're only supplying integer literals in the example above, so it's got no reason to infer doubles. I would assume that the reason you have to declare the type is that it's extra work to infer type in cases like this – you'd have to infer type from several different places at once then hoist it up to the outer scope. And the error condition of having mismatched types seems annoying to handle as well. I don't see anything that's impossible to solve, so Apple may remove this restriction in future versions.
That would absolutely make sense in this case, but it's just because my example sucks. There are some situations where it request makes more sense. 
I am implementing a kd tree (mostly just to get to know Swift), but I think it can be optimized more. I have a lot of explicit types which makes it harder to read I think. Maybe I will post it here later when I have looked at it some more. I think a discussion of programming style could benefit others as well.
The prem with cgfloat afaik was that it was either double or float depending on the machine and os being 32 or 64 bit. 
Might be best to ask this question in the dev forums: http://devforums.apple.com.
Check out the Stanford iOS lectures on youtube. They're in Objective-C but it works the same way in swift.
As with practically every programming language, learning the syntax and the specific features of a language is just the first step. Back when I learned Java (long time ago in a galaxy far far away) the dominant GUI framework was Swing. It annoyed me: I could code Java (and at that point I was working with SDL and OpenGL) but Swing bugged me. CocoaTouch has some annoyances, yes. But to be frank, I found it far less annoying than J2ME or Swing was. My personal method of getting accustomed with it was just making up small, reasonable projects (like a RSS reader for example) and googling every problem I stumble upon. After that I dissected the solution: what did what part of the code actually do and why did it work this way? https://developer.apple.com/library/ios/navigation/ is your friend - even though it might be overwhelming if you want to *study* the API, instead of using it practically.
Thanks, I had actually started checking it out before swift was released and they are indeed terrific. 
Makes perfect sense, should definitely give that a try. What I have been doing at the moment is looking at GitHub swift repo's and trying to dissect their code. Which APIs would you say are the foundations for nearly every project? Would make it a lot easier to know which docs to start reading on my free time :) 
I think you dreamt up that example :P. I haven't seen it anywhere and while awesome, it would be computationally expensive to figure out. For code like this it's more common to declare the type. For languages without stronger guarantees on code type inference gets rid of a lot of boilerplate e.g. Type x = Type(); turns into var x = Type(); For other languages, you could be able to infer the type from the variables scope. It's *possible* to do it. I just haven't seen it in Swift.
I've been working through the Big Nerd Ranch iOS book and translating the example apps into Swift. I've not mastered Cocoa Touch by any means but I'm now far more comfortable with the idioms and API surface that Apple has created. The book is also great because it demonstrates how you should approach Apple's documentation too. Good luck!
Big Nerd Ranch iOS book is good.
Thanks will definitely check it out, second person to suggest it already
There are several factors involved here that makes developing for iOS/OSX difficult for newbies. 1. XCode stinks infinity squared plus infinity. It is buggy, it crashes, it is non-intuitive and loses provisional profiles all the time. Want to see it crash? Watch WWDC 2014 video "what is new on Xcode". That video is apple receiving some karma back. 2. The shit of provisional profiles that should be transparent to user is obtrusive and stinks. 3. there are two Apples. The Apple we love, run by Tim Cook, that is the one that designs beautiful products that are easy and a joy to use and there are the Dark Apple, run by satan himself. That Dark Apple hates developers, writes shitty documentations that are vague, incomplete and difficult to understand. That Dark Apple writes APIs that are complex by design, they don't give a shit if you will understand it or not. Dark Apple hates the other Apple too. Other things that Dark Apple does to piss developers: they treat developers in a sub level compared to iTunes musicians or book authors. Book authors and musicians have special privileges like almost instant email support, phone support, discounts for hardware purchases and other things. Why developers don't have discounts for hardware? * you may ask: if Dark Apple writes shitty documentations what about the well written Swift Guide. Well, you see, Swift was created by one guy called Chris Lattner that worked in secrecy. Not even Apple knew that he was creating that language. He only presented Swift for Apple after almost two years into development. That took satan by surprise and he was not able to create a documentation that was shitty. It is barely the only exception in documentation.... but satan wrote the reference guide.
Sounds like a good idea! Cheers dude
[relevant](http://i.imgur.com/wP9kluO.jpg) :)
This thread has been linked to from elsewhere on reddit. - [/r/programming] [Swift is easy, learning iOS development is not. • \[x-post /r/swift\]](http://np.reddit.com/r/programming/comments/2begdz/swift_is_easy_learning_ios_development_is_not/) *^If ^you ^follow ^any ^of ^the ^above ^links, ^respect ^the ^rules ^of ^reddit ^and ^don't ^vote ^or ^comment. ^Questions? ^Abuse? [^Message ^me ^here.](http://www.reddit.com/message/compose?to=%2Fr%2Fmeta_bot_mailbag)* 
I'd say that would obviously be UIKit. Get familiar with the basic UI elements build some simple apps with simple interfaces, take a look at UITableView or UICollectionView, experiment with UIScrollview and UIGestureRecognizer. As soon as you are familiar and comfortable using these, you have already learned some of the important Design Patterns that are used throughout Cocoa Touch, like Target-Action, Delegate, Datasource, Composition which makes learning further APIs much easier. If you have access, you could start by watching this years WWDC session 224 'Core iOS Application Architectural Patterns' where they are briefly explained. 
I highly recommend the following lynda.com courses: Objective-C Essential Training by Simon Allardice Cocoa Essential Training by Simon Allardice http://rypress.com/tutorials/objective-c/methods.html Simon Allardice is a fantastic instructor. His courses are much better than the average courses, and well worth the money. I've looked at numerous free options, and none were nearly as good as his courses. 
Beautiful, thanks!
dude you took me back to my freshman year with the TurboC reference! Those were the good ol days. Borland was what I cut my programming teeth on. Taught myself SQL on Interbase database engine that shipped with their stuff. Personally I think XCode does a fairly good job and it's not that bad to work with. Intellisense is almost as good as VS. I do wish they had a nice quick and easy nuget type user interface for CocoaPods. There seems to be a fascination these days with doing everything on the command line as if working on the command line makes you "extra nerdy".
I feel ya dude, I'm coming from a C# background and learning the framework is very daunting. As others have mentioned the Stanford course is invaluable. It really helped me in finally being able to read and understand objective-C. There is a great book by Kevin J McNeish titled "Navigating XCode 5" - you can find it on iBooks. Its really helped me in understanding how to better use the IDE. He actually has 2 other books that have gotten good reviews also but I personally have not read them. Also you can check out http://www.raywenderlich.com/store/swift-tutorials-bundle the tutorials bundle is around $150 but they do sell the books individually also for about $50 each. And also there are a few free swift courses on Udemy.com. Other than that I'm just working thru every youtube video tutorial I can find. Each one provides little chunks of knowledge here and there. Hope that helps 
It was more something I used for testing and debugging than anything. I've since removed it altogether.
As for your web browser's incomplete support for Unicode (which is somewhat hilarious, as Google was the original company lobbying for Emoji's inclusion in unicode), try this: https://chrome.google.com/webstore/detail/chromoji-emoji-for-google/cahedbegdkagmcjfolhdlechbkeaieki?hl=en-GB For Emoji input, try using OSX's standard character viewer palette, which can as of Mavericks get shrunk down into a persistent, small view that makes selecting an Emoji quick and easy. As for other fonts, Emoji rendering in OSX falls back to a font that supports Emoji when you're using a font that doesn't (just like other unicode characters). As a ridiculous example, here it is working in Xcode with comic sans: http://imgur.com/FfAD9bJ
"IB isn't even VB4" LOL - thats a pretty accurate statement. I think Google has set the gold standard for IDE's with Android Studio though. I've been using it to work through some tutorials and it's pretty awesome - on par, if not better, than VS I think.
Off topic but is it worth it to even learn swift at this point? I started learning objective c and the framework about a month before swift had launched and I just felt like obj c is so documented and my app was halfway done that there was no point in rewriting my app to swift
&gt;Googling every problem I stumble upon. After that I dissected the solution: what did what part of the code actually do and why did it work this way? Using google and stackoverflow has been such a help for me in learning to write iOS apps. Pretty much all of the solutions to my problems have been solved by using google and SO
If you like coding in Obj-C then stick with it especially since your app is almost complete and you're learning the iOS framework which is really the ultimate goal. However once Swift 1.0 is finalized, I would focus on it pretty diligently as Apple has plainly stated that Swift is the future and we'll no doubt see the job market favor it over time. On a separate note, I sincerely admire your temperament in being able to learn Obj-C. I was just starting to learn Obj-C right before Swift was announced and I honestly hated it. I am so glad that swift was announced and haven't looked at Obj-C since (other than going thru existing tutorials that use it).
This and, perhaps it's a bit obvious, mastery of all data types helps ever so much. Luckily Swift made using the different datatypes much simpler, but the manipulation of variables is a core must imho. I cannot emphasize how much time you save if you don't have to look up basic functions on datatypes. As /u/iv_mexx rightfully states as well, it's a good thing to study the implementation of well known design patterns (I often wished I studied Delegate since I found myself *wanting* it often without knowing it's name). These are great examples on how a specific, sometimes abstract, problem is to be solved with logic and simple code. I believe understanding design patterns in programming are much much much more important than knowing a complete API by heart. 
It makes things easy to use correctly and very difficult to use incorrectly.
Swift variables *need* to have a value by default; nil (i.e. null) is not an option. Optionals are variables that can be null. So while an Int _must_ have a value, an Int? can have a value or be nil. To actually use it, though, you have to "unwrap" it which just means saying "hey, give me your value". An "implicitly unwrapped optional" works the same way as reference variables do in most languages: you just _assume_ there is a value there, but there might not be, and if you use it while it's nil you end up throwing an exception. Largely, you should avoid using them. However, they exist because sometimes they simplify things greatly. For example, when using an Objective-C library, a value could _technically_ have the possibility of being null due to its data type, but you know for sure that that factory function is always going to give you a valid object. To make using Obj-C code in Swift less painful, you use implicitly unwrapped optionals since that's how most libraries will work anyway.
There's one baseline for me, and that's productivity. One of my old coworkers was an ardent vi(m) user, and I was pretty settled in emacs. But, I was impressed with his workflow, and he would never try get me to switch after seeing mine. I take a little hit w/ Xcode in terms of pumping out code, but I think it'd be pretty hard to build an iOS app in emacs, so Xcode wins right now. (AppCode might be great, but the 30 day trial wasn't enough to find that out.)
Learn python for the syntax, then learn some data structurures/algorithms in C so you get used to pointers, memory addresses, etc.. Then learn java for OOP... Then try creating iPhone apps. 
I'm right there with you. While I can't refer to myself as a developer of any kind, with a straight face, I'm trying to learn Swift. I've watched the WWDC14 videos, got through 9 of these - https://www.youtube.com/playlist?list=PLfOZCUzRoPfKeOS_pwpiqbdviGcCOcTYb and have been reading everything I can find. I totally agree with you, I feel like I missed a step. I think I can manipulate information with Swift, but I don't know how/where to get that info. In one video, the guy makes a tic tac toe game and he rattles the code off like "of course we need to do THIS", but I have no idea where he pulled that from (out of his ass?). Half the time he runs back to the top and imports Cocoa, I assume that's called a library and allows him to do things like use a command called "sort", but that never really gets explained. Everyone says to "just dive in and build something", but I don't know how to scope a project. Is building my project a day long adventure or something that takes months? I keep telling myself that "I'm good enough, I'm smart enough and gosh darn it, people like me". AKA, if you can do it, so can I... I'll report back with how far the power of positive thinking takes me.
My last [blog post](http://blog.human-friendly.com/swift-arrays-beta-3-hooray) got some traffic from here (without me submitting it) so I thought there might be interest in my new one. Let me know if you have any questions.
Yes the frameworks are a much bigger thing to learn than Swift. Getting to know the frameworks is definitely a slog to start with and I'm not sure that there is a real shortcut but you reach a point where you become comfortable with the patterns being used (particularly the delegate pattern) and it starts to make more sense and be quicker to learn. Then you can apply the knowledge from the hard work getting UITableViews doing just what you want to many different areas.
I'm not sure about your code's context but I would like to mention computed variables: var foo: Int { if a == b &amp;&amp; k == 1 { return 3 } else if a == 1 { return 5 } else { return 7 } }
I recommend you learn ObjC. It's an easy language (easier than Swift:)) and there is an extreme amount of useful info out there on how to do all sorts of things. You can create a sample app in Xcode and search stack overflow for just about everything by now:) Don't worry about "getting it" but rather getting a few simple apps implemented. I recommend reading the API documentation when you find solutions to things to learn more about what things do. 
I've searched and haven't been able to find anything. I do have it, but I've reviewed Apple's NDA and there is an issue with redistributing software. If anyone can properly refute this, I'd be glad to share. 
[This is what you need](https://itunes.apple.com/us/itunes-u/developing-apps-for-ios-sd/id395631522?mt=10)
But aren't iPhone apps made in objective c?
Man, they give discounts to book authors and musicians. That pisses me off. Oh yeah, it is easy to control that. Just limit the discounts to developers with titles in the store and/or launching x apps per year ... and not just that, we should be able to get the hardware before it launches to public. I mean, in a time frame after the keynote and before the official release for public. I give you an example: I don't live in the US. The first iPad launched got almost 100 days to arrive at the stores in my country. Not a chance to work with conditions like that. Working with thad dark apple is hard.
Doesn't `#123` traditionally represent `#112233` rather than `#123123`?
This is unfortunate. I feel as though the nice tuple syntax should really be able to work here. It's a shame they don't have that working.
[Link](https://developer.apple.com/swift/resources/) to download it.
http://jsfiddle.net/85x7Y/
Why not download the new [beta 4](https://developer.apple.com/swift/resources/)?
In beta 3, Xcode crashed when I tried to merge changes from a branch to master. 
It's not like they're going to drop Objective-C. It's too valuable to have OOP with C baked in. Plus so much of their operating systems is made in ObjC. Point being, this is not a reason to choose Swift over ObjC. People should choose whichever suits their needs better. For example, writing with OpenCL/GL would be a bit of a nightmare in Swift.
SKColor has always just been #define SKColor UIColor Either there's been a change in the way Swift handles types defined by #define macros, leading to issues like this, or Apple decided to remove SKColor entirely due to its lack of reason to exist.
I think you mean "in *not* so many words". The future is swift, they make that quite clear. The really clever thing they did was make it compatable with the Objective-C runtime: the swift code you write (can get?) gets translated into the objective-C runtime. But because swift doesn't allow you access to pointers it can make your code much safer and they can do compiler optimisations which are not possible in a C based language.. It also means that you get Cocoa for free. It will be interesting to see how this develops. Unless they rewrite Cocoa in swift the Objective-C ness of Swift/Cocoa code will always shine through. This is because the Cocoa API is strongly influenced by the language features of Objective-C, which also has very strong set of conventions and best practices which the community follows closely. At the moment Swift doesn't really have any idioms and conventions simply because no large project has been written in Swift. But when it does I see people not wanting to write Swift in an "objective-c" style (i.e. the style enforced by the Cocoa API) because it will feel unnatural for a more modern language. At that point people will want pure swift APIs. This will put pressure on Apple to rewrite Cocoa in Swift. Writing Cocoa 2.0 seems like a mammoth task, it would be a multiyear effort! But it could also be done incrementally with different classes becoming Swifted and older APIs deprecated. This would avoid the abrupt carbon and carbon to cocoa style transition that occurred a few years ago. If you look at everything Apple has done over the last few years to Objective-C, they have executed a beautiful series of incremental changes. I reckon ultimately something like this is planned. Eventually Cocoa 2.0 will take advantage of the language features of Swift and ditch it's Objective-C roots. Although I love Objective-C, that's a good thing. *Edited: updated with opinion on a possible smooth transition to Cocoa 2.0 written in Swift.*
Yeah. Sure, but the point is, it is syntax that is sort of "hard coded" for Objective-C Devs, and that may cause confusion. Feel free to ignore the article, or hit the downvote button if you dislike it.
Great thinking! 
Ha! I started my programming gw-basic and qbasic from 1984! I jumped onto Delphi in 95 and used it for 10 years so can understand the sentiments regarding xcode. Delphi had 2 way code and UI synchronisation back then, something even XCode 6 in 2014 doesn't have.
Yeah, rewriting all of cocoa to Swift seems like a crazy idea. It would cost a lot and maybe introduce new bugs and therefore compromise system stability. Unless they have some kind of a migration tool (Objective-C to Swift converter) which I highly doubt. But I guess they might start developing new frameworks in Swift.
Well they do have a rewrites, it's what shows you the swift version of objective c code by translating it on the fly. 
At the same time, this sounds like typical CEO-talk, especially bringing IBM into it.
 😱
I get the point of the article, it's kinda like how Objective C was a bit of a puzzle for people used to C-style languages (ironic, I know). But it's just a bit of a pointless article, it's like explaining that people switching from Python to C will need to get used to using curly braces.
Possibly a Swift wrapper for Cocoa in a Swift fashion instead of Obj-C manner?
It will be easy for Apple to push its developers onto Swift. All they have todo is, once its stable, just start releasing new API's that work only with Swift, then the old saying will apply "Its my way, or the highway"
I'm not sure if it's xcode 6 or Yosemite. But when I saw it, all I could think was "Finally!"
Bought this one from Fulvio Massini https://www.udemy.com/swiftdeveloper/?couponCode=SWIFT-29 because topics went a bit beyond Apple's own book, speaking about Cocoa and Xcode... (can't do much without also learning about Cocoa) Hope it keeps the promise to develop real apps with Xcode, so far updates came regularly... Used discount code SWIFT-29 to get it for 29$ instead of 99$ (don't know till when coupon is lasting)
I think they plan on dropping Objective-C after everything has been switched over. I don't think they are going to be dropping it any time soon thought. You also don't have to choose right now you can make parts of your apps in Swift and parts in Objective-C.
I second reading the Big Nerd Ranch books. Also depending on how you feel about hands on theory I recommend reading about Cocoa design patterns: https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010810-CH1-SW1 Might not be for everyone but if you are like me and like to understand stuff in terms of concepts you already know this might be useful to read because it allows you to relate iOS development to regular Gang of Four design patterns. E.g. an iOS controller such a UIViewController is not what a lot of people call controllers. They correspond to what the Gang of Four calls a Mediator pattern. 
I've heard from people who have talked to Apple developers that Objective-C will never be dropped. It is needed for a lot of low level access. It is just that Objective-C will likely stop being used for regular application development.
&gt; If you have access, you could start by watching this years WWDC session 224 'Core iOS Application Architectural Patterns' where they are briefly explained. They are [freely available](https://developer.apple.com/wwdc/videos/) on Apple's website, after they have begun opening up to developers. :)
passing an empty array around is ALWAYS better than having an array being optional. It's either empty or it's not.
C is over 40 years old
My opinion on Swift is that I'll definitely use it...when it's finalised. I'm looking at the docs and getting myself familiarised with it ready for when it becomes the language of choice for iOS and OS X, but there's no way I'll even consider starting a project with it until it hits 1.0. I might just be pointing out the obvious here. 
If Swift is to be portrayed as a push towards the enterprise, then they need to give us a Swift version of the [Enterprise Objects Framework](http://en.wikipedia.org/wiki/Enterprise_Objects_Framework). Please?
I very much agree (once its out of beta and the playground is stable). A lot of people here have said "naw, ruby's the way to go", I guess mainly because of the duck typing? But that feels like a shallow learning curve with a trapdoor at the top. Beginners will benefit from realizing a float and an integer are different from each other, and that's an easy way to introduce types in general which are still there in ruby as soon as you move past the basics.
Another not-quite-but-almost, you could name the elements in the tuple declaration: let a: [(first: Int, second: Int)] = [(1,1),(2,2),(3,3)] a.reduce(0) { total, pair in total + pair.first } 
I love Ruby. Ruby is a great language and I do many things with it. Still, I also believe it is a language intended at coders who know what they are doing. It shields the beginner from too many hugely important concepts and it results in badly written code.
I also write new stuff in C almost daily. Just because its old doesn't mean it isn't useful. A dinosaur it is not. Its a trilobite, its got no reason to evolve any further.
"It is just that Objective-C will likely stop being used for regular application development." I am sure this was his/her point.
If you write in C everyday then you should probably reconsider your programming tasks. It is absolutely ludicrous to write using such a low level language unless you execute functions from kernel32.dll or another low-level file on Windows. O_O
 &gt;once its out of beta and the playground is stable That's the important qualification to make. It *will* be a great language for beginners, but it sure as hell isn't right now. 
Oh god my eyes. Yeah I find the thing with Chrome not working as very hilarious. Chrome is usually pretty good at these things. I still think you're just stirring the pot a little. Unicode support is there, fine. Emoji adds a bit of color to code, it's fun and different. I can take your argument of emoji and just turn around and propose Chinese character use because of unicode use. Good distinct characters with meaning, understood by a large percentage of the world, etc. In fact for brevity we should use Chinese characters to declare variables and those variables only need to be 1 character long. /s
The dependency on ~~Cocoa / CocoaTouch~~ Foundation, and thus on C / Objective-C as well, is way too large for Swift to be a good introductory language, imo. Swift needs to be able to stand on its own outside the Apple ecosystem before this will be the case. Just the requirement of owning an OS X machine in the first place is a significant barrier to entry. 
I would emphasize the playground as a great environment learn in. Once it gets stable it's going to be amazing. I can actually imagine beginner CS courses exclusively using the playground. I would disagree with is the financial reasoning. That's why javascript is recommended as a language to learn. It's big and it's here to stay. It's also the reason why .NET and Java are still good languages to learn if financial considerations are important. It's easier to supplement income with the app store than other things. It's harder to live off of it. The only thing that Swift as a language has going against it for beginners is... optionals. You don't really get to appreciate it until you've face the dreaded null pointer exception, null reference exception, and all the other names that it is known under. For a beginner it's just one more thing to worry about. Hopefully having the playground will more than make up for it though.
It was said during their earnings report...
I don't agree. The power of every language comes from its frameworks. Ruby wouldn't be as far as it is now without Rails. The same goes for C# and its dependency on .NET. Still, it is an excellent introductory language. I am not saying Swift is the ultimate/only language for a beginner. I'm saying that it is a very strong candidate for a first language in order to master necessary programming concepts.
Yes please. Give us the ability to do the amount of introspection and runtime goodness to make this possible in Swift. Swift is sorely lacking in those capabilities right now compared to Objective-C that it's not even funny.
Or maybe he works in embedded systems where those things are still important? Arguably there were important for mobile phones until recently. Android UI was slow until we got multicore processors and having a language like Java didn't help things. 
While I do agree that Paul Hegarty's lectures are excellent material to get into iOS programming, I'd suggest [the more recent incarnation of this course](https://itunes.apple.com/de/course/developing-ios-7-apps-for/id733644550?l=en).
Modern programming sounds too much like "no true scotsman." Btw, Nullable types only apply to value types in C#. You don't really get the same null pointer exceptions on Ints now. So no, they're not the same. They're both examples of what Generics and good syntactic sugar that optimizes certain cases on the standard library can do. Where they fundamentally differ is that Optionals give us null safety (ok nil safety). Nullable types in C# don't do that. In all honestly nullable types in C# make wrapper types like NSNumber look like ridiculous in contrast. My point on Javascript was about it being financially viable. Not that it's a great language to learn off of. It's damn terrible to learn off of (what all numbers are floats?). But everyone loves to bash on Javascript and there's a reason. It's stupidly popular. It's so popular that if we discover sentient life they would be using Javascript (and PHP. which is why I said sentient and not intelligent).
Embedded systems only demand C? Wanna provide some examples, because last time I checked, C was not quite so relevant unless you are one of those 'legacy' software engineers, which is a workplace 'reason'. Android's UI was not slow because of the lack of multicore processors. It was because of 'project butter', basically Google's way of saying they bought the Android OS and failed to properly clean it up after extending it with so many background processes. Sorta like what happened to Windows over the years, system architecture aside.
There is no such dependency. You can write a Swift console app without any Cocoa. If you'd said dependency on Foundation, that'd be a different matter. Swift doesn't have standard input without it – yet. None of which is to deny you need an Apple computer to run Swift. But that's a parallel issue to whether the language itself is good for learning or not.
Yup. But a lot of the prefer-ruby-for-learning comments are either “ruby is simpler” (deceptively IMO), or “ruby has more tutorials” (circular).
One of the better arguments that can be made against this is that C-Obj is incredibly hallmark to the Cocoa frameworks, so beginners are going to have to learn some C-Obj in order to read a lot of the existing references/books. That is changing rapidly however.
Did I specifically say C? No, I said where those things are still important. There is a good MSDN talk where they got the creators of C++, Go, D, and Rust on a panel and they were talking about what things they have to consider when designing their languages. Sometimes people just like C and they code in it. Why should they have to reconsider doing anything because it offends your sensibilities?
&gt;If you'd said dependency on Foundation, that'd be a different matter. Swift doesn't have standard input without it – yet. You're right, I should have said Foundation (edited my post), but i think that's a bit of a pedantic distinction. The point is that Swift's standard library is not sufficiently developed to stand on its own, and this is likely to continue for the forseeable future. &gt;But that's a parallel issue to whether the language itself is good for learning or not. It's not a parallel issue, it's a direct requirement for using the language to learn.
"Why should they have to reconsider doing anything because it offends your sensibilities?" Why do you have to act like I pissed on you? Calm down kid. Yes you did say C. Read your post again, you are referring to it. The rest of your post is irrelevant.
For a more long term solution it would be to add it to what they're using. http://stackoverflow.com/editing-help#syntax-highlighting Current language list seems to be here: https://code.google.com/p/google-code-prettify/source/browse/#svn%2Ftrunk%2Fsrc
Oh ok, thank you!
Thanks dude, will check them out!
Even better, cheers!
I'm surprised people said Ruby. I would think Python, and I know I would say Python. 
I'd tend to this agree at the moment, the problem in my opinion is that most tutorials don't really emphasise "real" Swift but are written by semi-professionals who don't have in-depth knowledge about programming and, in particular, Swift. :/ Yes, it's easy to write a program, writing idiomatic Swift is a lot harder, though. I'm afraid the (apparently) low entry barrier will lower the overall quality of code. :(
Chris Lattner said on developer forums that Clang modules for C++ is the only major blocker of C++/Swift interop
Basically @IBOutlet is the only one you should care about right now, although techncially there are others such as @lazy, etc. that can define certain behaviours (in the Swift language).
awesome point! Doing it in a more functional style could have some serious benefits. I wrote a follow-up [here](http://mattorb.com/swift-conciseness-and-trade-offs/) inspired by your comment! 
You enlightened me.
No doubt Ruby wouldn't be where it is without Rails, but that's not really what's under discussion. If you're teaching someone to program by immediately introducing them to Rails, well then, at least in my opinion, you're doing it wrong. Ruby is not Rails. Ruby can stand on its own with a pretty good standard library. Getting someone started by immediately introducing them to Rails is overkill. All that said, Rails itself is still actually written in Ruby, while Foundation / Cocoa / CocoaTouch are not written in Swift. Also, as much as I adore Ruby, I also don't think it's a great *first* language, for many of the reasons you outlined. Personally I still tell people to learn C first. Despite its warts, C will give you a great foundation in the absolute basics (some of which you outlined in your OP) while also giving you an appreciation for the conveniences available in much more modern languages (like Swift) once you get to them. Once someone is ready to start developing more tangible applications, I might recommend Swift (once its out of Beta), but for the absolute beginner I think it's important to master the basics. I wish someone had started me with C. Finally, I think you did yourself a disservice in the OP in not mentioning playgrounds, which are a place that Swift really shines for novice programmers.
Interesting, can you elaborate more about this "module" concept, wasn't it possible to create a class in obj c and distribute that also?
@IBAction @IBDesignable @IBInspectable
What conventions does Objective-C have that don't work in Swift? Do you mean things like taking an `NSError* __autoreleasing *` argument? Because the biggest things (besides that) that make using Objective-C APIs ported into Swift a challenge are: 1. Using `id` 2. Non-generic collections 3. Possible `nil` returns All three of those things could be just as easily solved by auditing the existing code and creating special, Swift-only, annotations (e.g., `-awesomeMethodName` returns `NSArray` in Objective-C but `Array&lt;String&gt;` in Swift). They could do the audit as slowly as they wanted (probably starting in Foundation and UIKit/AppKit first and moving from there) without causing problems or breaking anything. Completely rewriting Cocoa would be a much bigger, much more expensive and much more dangerous proposition.
Agreed! Great books, with some amazing examples. I started with the Objective-C book, which gave me a pretty good understanding of Object-oriented programming. Now going through the iOS book and translating the examples into Swift.
Great work! However, I don't have Chrome at work. Any chance you can make a Safari extension for this?
In general, Apple's documentation is very good. I recommend just looking up the classes there (eg. paste the class name into google, the first result is usually it). You'll end up with something like https://developer.apple.com/library/mac/documentation/SceneKit/Reference/SCNCamera_Class/Reference/SCNCamera.html
Holy crap how did I not know about this! This is a great tip.
At this point in time, yes, Obj-C dominates the Apple ecosystem. But that is *now*. Swift is still in beta and I think that not so far down the road, Apple will push Swift forward also by providing Cocoa docs using Swift examples.
The writer didn't say at any point that it was supposed to be? He could have, however, made a bit more clear that var simply is not a type, while id is...
There are a lot of articles like this on this subreddit. All they do is reiterate the most fundamental of syntax features of Swift, most of which are required knowledge to even begin with Swift. Guys. Swift is not that interesting. Not every little piece of syntax is some mind-blowing feature that needs an article written about it.
ok i'll try that one! thanks.
It's obvious that people are trying to drive traffic to their sites. Some good quality control will go a long way here. It'll die down once the swiftomania dies down a bit, but that's going to be well after release.
&amp;nbsp; ###Computed properties `var spriteName: String {}` If you include a pair of braces after a variable declaration, you are changing the variable from a "stored property" into a "computed property". A computed property allows you to define the "getter" (`myObject.spriteName`) and "setter" (`myObject.spriteName = "Donut"`) functions of a variable. A full implementation of a computed property looks like: var spriteName: String { get { return myObject.privateVar } set { myObject.privateVar = newValue } } Please note that "computed properties" cannot hold any value. That is, you have to use another `var` (like I used `myObject.privateVar` in the example above) if you want to store a value while having a computed property. Now, your code doesn't include the `set {}` function. Therefore, your computed property is read-only. This means you don't need to have the `get {}` part anymore, but you still need to `return` a value inside the braces. &amp;nbsp; ###Looking at the getter let spriteNames = [ "Croissant", "Cupcake", "Danish", "Donut", "Macaroon", "SugarCookie"] return spriteNames[toRaw() - 1] You shouldn't be declaring an array inside of your getter if it isn't going to be dynamic. You should move that array into the same scope of your `spriteName` computed property so it isn't created every single time you call `myObject.spriteName`. The `toRaw()` parts makes no sense, **unless** your `spriteName` property is declared inside `enum Pastry: Int { }`. This is because `toRaw()` is a function only available to `enum` members (such as `Pastry.Donut.toRaw()`). This `toRaw` function returns the `Int` value that the enum case is assigned to. Every enum case in `Pastry` **must** have an assigned `Int` value, in this case. &amp;nbsp; ###Conclusion If the intention of your code is to be used with an `enum`, this is one way you could do it correctly. enum Pastry: Int { case Croissant = 0, Cupcake, Danish, Donut, Macaroon, SugarCookie var spriteName: String { return Pastry.spriteNames[toRaw()] } static let spriteNames = [ "Croissant", "Cupcake", "Danish", "Donut", "Macaroon", "Sugar Cookie" ] } In this example, `toRaw()` makes sense! If you do `Pastry.Cupcake.toRaw()`, it will return `1` because it is right after `Pastry.Croissant` which is clearly set to `0`. The `static let spriteNames` part prevents the `[String]` from being created every time you call `Pastry.Cupcake.spriteName` (since you never change the `[String]`). &amp;nbsp; If you have questions, feel free to ask. :)
Where those thumbnails were obtained? Actual twitter users?
Thanks. Some people say it's similar to Python as well. Is it more similar to Ruby? Want to learn Ruby or Python. Definitely want to move towards iOS and osx dev as well eventually. Maybe programming robots too. Or AI. I probably sound so ignorant right now. Sorry. I'm a noob. 
Not sure why you are indicating the OS is made in ObjC, its not. You can see much of it here, https://www.opensource.apple.com. A quick glance shows a lot of .cpp and .c . One wouldn't really write an OS in Obj-C given some of its performance profiles. The Cocoa (API) can be interfaced with in many languages, Ruby, Python, Perl and Swift. Swift is a more special case than the other mentions however. There are reasons to choose Obj-C over Swift, the largest ones being Obj-C has been around for many years (well understood) and is several iterations in (it has a lot of polish addressing the complaints of people actively shipping software using it), there are substantial existing resources in place for learning &amp; asking questions about it.
"Low Level Access" would probably happen through C. 
That's how you make the future happen instead of hoping it happens. 
Faker.js code :)
Found them at http://uifaces.com/authorized 
what kinds of discounts to musicians? 
Thanks, I'm gonna check this one out! 
Makes sense... Nice wrapper by the way!
The fact that 'private' is file-scoped, not class/struct/enum scoped, is pretty important. It means you can declare an extension on some arbitrary type in the same file as a class you've defined, and that extension *but not the rest of the thing being extended* will have free access to private functionality of that file. You can also declare extensions themselves public, internal, or private, which is excellent for avoiding the kinds of accidental collisions that ObjC categories disastrously can cause.
Look at Apple's docs for the model, view, controller paradigm. That should explain what the view controller is for. As for what to put into which class, think of it like this: The view is designed to switch between different scenes. Any code that is specific to a particular scene (which usually represents one level in a game), should go in the scene class. Things that manage showing different scenes goes in the view controller.
what has this got to do swift??? Oops maybe I should have read it! Apologies, now I get it!
What do you mean with "load a subview"? If you don't want to have multiple controllers, I would add all three views into a single controller's view, and then set them to hidden or not depending on which of them should be visible. There's no "load relevant subview" step there, though, all views will be loaded, some just won't be visible. If the views aren't to heavyweight, that should be fine. About the properties being nil at first: keep in mind that you have to wait until viewDidLoad is called before the @IBOutlet properties are set.
This is something I've been thinking about too. I've seen some awful open-source Swift code on Github already but I think, ultimately, code that is really badly written won't pass the App Store barrier.
This information is also available in the quick help panel in the right-hand sidebar.
Well that is good to hear. You think they will stop allowing people to submit apps in Objective-C to the iOS store or the OSX store at any point?
On a side note what do you guys think about learning Objective-C as my first language ?
This is not Swift-related I'd say. To answer your question, I'd use a different controller for each: one for the menubar item and one for the popover. That implementation you posted annoys me because it unnecessarily uses delegation to pass around state that could be handled using KVO or other better solutions. That and Apple recommends against popovers tied to menubar items: &gt; **Avoid creating a popover that emerges from a menu bar extra**. Popovers emerge from controls and specific window areas (for guidelines on how to use a popover in your app, see “Popovers”). A menu bar extra can open a menu, such as the Keyboard &amp; Character Viewer menu. https://developer.apple.com/library/mac/documentation/UserExperience/Conceptual/AppleHIGuidelines/Menus/Menus.html
Thanks! Yeah, I'll definitely consider doing that on the next rainy day. It was kind of fun learning how to build a Chrome extension, Safari extensions can't be too different. (You're always willing to fork the repo and add a Safari extension too, if you'd like! https://github.com/willdages/untaylored-search)
Random thought not really related to the Timer aspect, but you could replace your randomString() function with a simple call with `NSUUID().UUIDString`.
Awesome! Thanks!
Hi, I'm happy to share my first UDEMY course to understand how works SWIFT and make your first SWIFT APP :) https://www.udemy.com/app-programming-swift/#/ Hope that will help!
Hey, Thanks for the reply! It is great! The only questions I have left is why use/ what are getter and setters? I've seen them before but never really got the point. Why is it beneficial to have a computer property? Btw, this is inside of an enum. I'm not really understanding the point of getters and setters
Since `spriteNames` is an immutable value, will the compiler optimize away creating it each time the property is accessed? I have minimal mobile development experience and have spent the past decade or so working with C#, so I know I need to fine-tune my understanding of Swift garbage collection semantics and memory conservation. Sorry if this is a stupid question!
I'm happy to see the power of digital books finally coming to fruition.
Look at their **[itunes connect](http://imgur.com/K19qj4X)** panel. You can see the item Apple Store (you can purchase up two mac computers and two ipods per year at a discount rates). As far as I know, the discount is around 10%, valid for US, Canada and Europe. They also have **[phone support](http://imgur.com/SxUwmgZ)** and almost instant email replies (if you mail them during the working hours). Why they are treated different is a big question mark.
Maybe I'm alone here, but I sorta feel like classes and functions should be public by default, and that properties and other variables should be private by default. The most common use-cases should require the least amount of syntax. Anyone else frustrated by this? I think my frustration is exacerbated by the fact that I'm trying to create a testing library for use by other developers and marking almost everything as "public" is really verbose and goes against the terse nature of the language that I initially liked.
Making the class public also makes every entity in it public. So you really only need to do this once per class to get that default behavior. But, this is actually awful design, you want things to be private by default. Exposing API methods should be explicit.
Sounds like a reasonable question. I'm assuming it doesn't just to be safe. Maybe someone else can chime in
Well, the problem is viewDidLoad wasn't called until after first openPanel call. &gt; I would add all three views into a single controller's view, and then set them to hidden or not depending on which of them should be visible. Well yes, but I add relevant by panelView.addSubview relevantView
I also have a similar extension, but it allows you to declare UIColors with integer literals. https://github.com/KristopherGBaker/KGBSwiftExtensions/blob/master/KGBSwiftExtensions/KGBSwiftExtensions/UIColorExtensions.swift Example: let redColor:UIColor = 0xFFFF0000
That won't work because I need "normal" view to be loaded and not NSMenu. &gt; This is not Swift-related I'd say. I know, but it's closest subreddit I found that is alive. &gt; I'd use a different controller for each: one for the menubar item and one for the popover. It's already like that. But popover has three different views. 
The new access controls offer better encapsulation. If you don't believe that's a useful thing, and you never work with other engineers, no one's stopping you. But, generally, people will find themselves in some broad categories: * Ideal: You take a look at the API for your class, and add "public"s to the few public functions and, generally, but not absolutely, no properties. * Most likely: Start with ideal, find where you broke your encapsulation, curse, and go back some new methods to fix where you were operating on private properties, etc. * Worst: Just add public to everything so you don't have to fix anything. 
i think you might be misunderstanding where I am coming from. I agree that encapsulation is good, and that I need to make some changes to my design in order to make my encapsulation better. 100% agree, actually. I'd just like to be explicit about what is private over being explicit about what is public. (edit to add, I like breaking things up into small classes so that I don't have a lot of private functions -- I want to avoid the [iceberg class](http://deviq.com/iceberg-class) anti-pattern) (edit #2 to add, /u/jjquave is incorrect about making a class public having a cascading effect on every entity within it, and that's what i was addressing)
Save yourself the trouble. Don't do it. This is a huge time consuming project, requires lots of research and funding. I guess requires 100 kloc for something barely production ready. I'm working on a version 2 of [GDT](http://graphicdesignertoolbox.com/) that is a werkkzeug / sketch environment. Perhaps look at how these tools works with building blocks. 
Cool. Would be nice with all these color converters in a single project. That perhaps also have functions for converting between different color spaces.
Looks like I solved my problem with IBOutlets by putting segment where I use them after self.window call. Who knew. (some who reads docs)
Hmm, I did look at it (logged in using my iTunes Connect user-account), and there is no Apple Store over here, it is replaced with "Support" instead. I guess it must be a Finland thing.
I want to start learning now. Since I have time on my hands and have somewhat of an original idea for an app.
IMHO, an IDE like you propose is the Holy Grail of computing science. Once something like that gets adopted (many have been attempted, but not adopted), we will be in for a paradigm shift in programming. The trouble is, it is freakin' hard to make it, and make it good. I say, why not go for it? The worst that can happen is it doesn't work, and you move on to the next project. 
Pm me I have dreamt of building an IDE and Dev tools, I have some great ideas myself, we should plan a google hangout one of these days for a group discussion
No. Let me explain why. When making an IDE (or framework) one makes assumptions. The more "helpful" the IDE is supposed to be in replacing programmer *work*, the more assumptions need to be made. In your concepts I see the assumption that programming views is a frequent, difficult problem due to the lack of liveness. However, we have vast areas where this is a non-problem: 1. Applications with simple UI 2. Applications with complex UI (which cannot easily be expressed in components) 3. Applications where live running code is too complex to be "live coded" 4. Applications relying on custom UI rendering The power of a tool is usually proportional to the amount of assumptions you make. If you want to solve the "general problem", then your tool cannot be equal a tool specialized for a certain type of problems, in saving programmer work. Look at frameworks for analogy: Storyboards can save heaps of work, but it is mainly for applications that easily conform to kind of UI that the storyboards facilitate. It's always a tradeoff, and when someone ever tried to make a general solution for all problems, what they really ended up doing was either make a huge chunk of applications hard to do, or otherwise just moved the difficulty elsewhere. Even aside from this: if you want to solve a general problem, you need the experience to have approached the problem from many directions - or your assumptions are guaranteed to be flawed. Incidentally, if you are intrigued by the "live code" idea, I think you should have a look at http://www.newspeaklanguage.org in which all code is "living" and editable. Working with that and trying out the concepts should give you a better idea if your IDE ideas are adding something or not. You should be able to create a demonstration of the key concepts for you and others to evaluate if they work or not. And it would have the added benefit of drumming up support for such an IDE if you can show through a demo that it adds value.
when wasn't it free?
Until the last Beta, you needed a paid Developer's account. And, again, [you can thank me for this. :-)](http://www.reddit.com/r/swift/comments/2ag83o/xcode_6_beta_with_swift_available_to_all/civ2v8e) 
That's good. The best proof is in a demo.
I think xCode was always free, but not the early Betas.
I don't know Swift, but I use OpenGL daily at work. What makes you say OpenGL would be a nightmare in Swift?
what do you sell on itunes? music, books or apps? The Apple Store option and the discounts are not for who sell apps. This is how I am pissed, by the difference in treatment. We developers are treated as second class.
Hey, you responded to my post the other and gave me really helpful advice. I pre registered on your site and I'm very excited to learn Swift. Seems like a great time to be a new programmer. :) In the meantime I guess I should teach myself Xcode and get familiar with the program. I was playing around with it and it seems pretty intuitive as well as kind of fun. Looking forward to a new hobby and possibly career!
Definitely anti-Objective-C since it's a Swift wrapper around a Cocoa class. Especially because I'm originally a Javascript developer. There is an unexplainable love for ambiguity. Haha
You can do this with less code. By drag-and-dropping the UIGestureRecognizers onto the views in Interface Builder, and then connecting the recogniser's selector outlet with the function that should be called, you don't need outlets for the gesture recognisers and the viewDidLoad() any more. (You might need to set multiple touch enabled in IB though). This even saves you from writing the ugly panRec.addTarget(self, action: "draggedView:") lines. No more way to misspell methods because they are taken as an ugly obj-c style string argument! Finally, you don't need outlets for for the views, because you can access them as recogniser's view property. That way, all you need to do in code is write the methods that handle the gestures. Configuration of the gesture recognisers can all be done in IB. Also, the title of the post is kinda bad - I was expecting to learn how to implement my own gesture recogniser, not how to use Apple's.
Hi all! I made a tutorial for people who want to get their feet wet with Swift. Feedback and contributions are welcome!
I think you should change that section that mentions 'Type Casting', what you are doing isn't type casting, you're creating an instance of another type through it's initialiser. You cast in Swift using the 'as' keyword. Rubbish example, but here you go: var myImageView: UIImageView = UIImageView(frame: CGRectZero) var myView: UIView? = nil myView = myImageView as UIView Otherwise, great no frills introduction. Very similar format/topics covered in a presentation I gave at work recently.
Thanks for this. I will check this out this weekend!
While we're working with Swift, it's useful to know what the current state of affairs is. If you're not building an app with it right now, it's not a huge deal to figure out optimization yet, but for anyone currently working with it, it's helpful to know things like "is this my code, or just the standard library?"
Short version of "why" is because it lets you do this: variable.computedProperty = newValue Instead of this: variable.setComputedProperty(newValue) Basically, you can use it like a variable instead of a function, which often makes more sense syntactically.
&gt; Since spriteNames is an immutable value, will the compiler optimize away creating it each time the property is accessed? Well, it's also marked **static** so either way it should only be generated once. I would *assume* the compiler could optimize it without that (Swift encourages using **let** everywhere for exactly that sort of optimization), but given things are in beta it may or may not actually do that.
That is absolutely right. I wrote the title initially as a part of a quick outline, but forgot to re-assess it once the examples were written. Fixing.
That must be why we have different perspectives on this. I love Objective-C and hate Javascript. Anyway, happy cakeday:)
Thanks!
That's a good point. I actually am developing an app and I guess I just haven't run into any major performance issues (yet). But, I can definitely see how that would be important for those people who do run into performance issues that stop their apps from functioning reasonably if they suspect that the performance issue might also be caused by them and not Swift itself.
Ya, I worry about those "temporary workarounds" because it doesn't take very long for those workarounds to become normal practice. Usually workarounds obscure the meaning of code and, especially in this day and age with the amazing computers and phones that we have, clarity of code is way more important than efficiency.
Who recommended you **not** to learn Cocoa fundamentals??
in the pdf it says it under the title :/ and its harder to learn it i guess since its wrapped around obj c and not swift?
ooo thank you just what i was looking for 
I personally went the route of extending dispatch_queue_t. Seemed a bit cleaner to me. import Foundation extension dispatch_queue_t { func sync(closure: () -&gt; Void) { dispatch_sync(self, closure) } func async(closure: () -&gt; Void) { dispatch_async(self, closure) } func main(closure: () -&gt; Void) { dispatch_async(dispatch_get_main_queue(), closure) } } let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0) queue.async { println("Background!") queue.main { println("Main") } } You do still have to create queues yourself but I think it's better to be able to make custom queues than rely on some secret Async thing's decision.
This also helps avoid the common pitfall of running into the 64 thread limit on the global queues (i.e. if you do something like loop over a huge folder of images dispatch_async()ing processing of them, your program will likely hang).
Love it. Thanks for this
That's pretty interesting. Fun fact: it works as expected if you don't subclass NSObject. I'm pretty sure it has something to do with ObjC-compability, most likely NSObject automatically creates the setSomething methods for properties dynamically (because those are called in ObjC), and they happen to override your implementation. It's still a bug, of course - I don't see a reason why your method shouldn't be called.
You could dip down into the objc_runtime and use objc_getClass(), but that's cumbersome, unclean, and non-idiomatic. Not to mention very unsafe. You might want to rethink this design first and foremost. Try to think how you can do this in a type-safe manner.
If you can make a function that has a switch statement for all the different class names, and then picks one to create and return, yes you could. But this is a dumb idea. It may seem clever on the surface, but it's not a good way to go about this. What are you trying to do that object creation is being dictated by an enum field?
I'm sorry guys, but where can I find beginner documentation and tutorials of "dispatch_async" stuff? I have no idea how or when to use them, thanks!
Multithreading/asynchronous programming/concurrency is a topic that has no beginner version. libdispatch (which is what dispatch_async is part of) makes it easier, and has many nice features, but it doesn't change the fact that it's fundamentally complex and subtle. Apple's concurrency guide is as good a place to start as any: https://developer.apple.com/library/ios/documentation/general/conceptual/concurrencyprogrammingguide/Introduction/Introduction.html Semi-brief summary: in a serial program (which is the "normal" way most people write programs), every thing that happens is ordered with respect to every other thing; that is, each thing happens before or after each other thing. In a concurrent program, that's not true, things can happen at the same time as other things (which is how multi-core processors make things faster: they run more than one thing at once). libdispatch provides a set of functions and types for managing the order in which things happen: • A serial dispatch queue causes all the blocks run on it to be ordered with respect to each other, but unordered with respect to the rest of the program • A concurrent dispatch queue causes all blocks run on it to be unordered with respect to each other and the rest of the program • dispatch_sync runs a block on a queue you pass in, waiting until the block finishes running before continuing. This implies some level of ordering between the current queue and the one you pass in, for the duration of the block. • dispatch_async runs a block on a queue but doesn't wait for it to finish, so does not force an ordering between the current queue and the dispatched-to queue By far the most common use for this is to make it so that the main thread of your application (where your UI is running) does not wait for a long-running background task to complete, so that your app can stay responsive even when it's doing things. Another common use is to split tasks into chunks that can run simultaneously, to take advantage of multiple cores. The danger is that *many* things you take for granted *absolutely require* a total ordering. If you do this, for example: var x:Int = 5 dispatch_async(queue_one) { x++ } dispatch_async(queue_two) { x++ } println(x) the program may print 6 *or* 7 (edit: actually it can print 5 too. It's possible that the println will run before either x++ has even started). This is because the "x++" operation is actually several steps (load current value, add one, save new value), so you can end up with your program doing this: queue_one loads 5 queue_two loads 5 queue_one adds 1 to the value it loaded, yielding 6 queue_two adds 1 to the value it loaded, yielding 6 queue_one stores 6 queue_two stores 6 when what you wanted was this: queue_one loads 5 queue_one adds 1 to the value it loaded, yielding 6 queue_one stores 6 queue_two loads 6 queue_two adds 1 to the value it loaded, yielding 7 queue_two stores 7 One of the reasons Swift focuses so heavily on immutable and pass-by-value types is that these are MUCH easier to work with in concurrent programs. If you can't share mutable state, then you can't have two threads or queues stomp all over each others changes, by definition. 
There are known performance bugs in both Array and Dictionary. These will be fixed in time for 1.0. Chris Lattner has said the following about performance in general: "The optimizer issues are well known. Later betas will provide significant performance improvements." So the future is looking bright :-)
Nice, and definitely less code. But, behind the scenes Async uses just the same GCD API. What "secret" stuff are you referring too? I don't mind using queues provided by Apple – are usually enough for my use. Else I go with NSOperationQueues for complex situations. The main reason for Async was to avoid indentation when nesting multiple blocks. Secondly, I like avoiding to the non-swift-looking function_with_underscore_stuff :)
Good short explanation. Dispatch is absolutely something that needs to be used carefully, but still a necassary tool in a developers toolbox. 
Though it could be an improvement for Async to support custom queues. Will look into it!
Really useful instructions - explained exactly what I wanted to know. There a few bugs in the code, I found, but if anything this ensured I understood how the code worked to be able to fix them. Would love to see more posts like this on this sub as I; and many like me, try to learn Swift and iOS development for the first time. 
I was about to sign up for a paid dev account yesterday! Thanks OP!
Ya, https://bugreport.apple.com
One more question: in the example, what is myObject.privateVar? What does that mean?
The scaleMode property of the Scene class expects a value from an enum called SKSceneScaleMode. Technically, the value you are passing in is SKSceneScaleMode.AspectFill. Since Swift knows that you will be passing in SKSceneScaleMode, it allows you to drop the first part and only pass in the relevant value, therefore: .AspectFill. This documentation page should explain it: https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html 
arc4random_uniform returns a Uint32, not an int. That means you would need to do this: var rand = Int(arc4random_uniform(4)) + 1 to get the correct result.
Self refers to the object in which the reference is. It's equivalent to the 'this' keyword in Java. 
Yes, they update the book. =]
Excellent; thank you. Is there anywhere where I can see a list of changes?
The Xcode Release Notes PDF has details on Swift language changes.
Hi /r/swift! I wrote a post a few days ago talking about "the types of data" driving the exploration with examples in Haskell. I just started learning Swift earlier today and noticed that now that there are nice recursive types it's easy to represent all of the types of data in Swift as well. Any feedback on my coding style is very welcome! I'd love to learn how to build this stuff more idiomatically.
I'm actually not sure. But I know that they've added e.g. support for public/private declaration when Xcode beta 4 came out.
In the back of the book there is a revision history section!
 let classes = ["TKTimer" : { return TKTimerViewController() }] ^ This did not compile "Cannot convert the expression's type 'Dictionary' to type 'DictionaryLiteralConvertible'" Also tried adding 'as NSDictionary' and it didn't work. :(
Nope.
String doesn't have a random-access index, so you can't just go straight to the 3rd character. This is because full unicode support means you can't go forward a defined number of bytes to find a specific character, because characters can be of variable length. The way to find the nth character is to iterate over the string collection. advance can help: let s = "Hello, I must be going" let idx = advance(s.startIndex, 9) s[idx] // = m, the 9th character But you should realize this means iterating over the string, not just adding some pointers together. 
Working with Characters Swift’s String type represents a collection of Character values in a specified order. You can access the individual Character values in a string by iterating over that string with a for-in loop: for character in "Dog!🐶" { println(character) } // D // o // g // ! // 🐶 The for-in loop is described in For Loops. Alternatively, create a stand-alone Character constant or variable from a single-character string literal by providing a Character type annotation: let yenSign: Character = "¥" More on page 138 of the Swift language guide. - this answer is straight from that book. 
Whilst pointing out that you shouldn't actually use it. They didn't just forget to include indexing by integers. It was omitted for a reason.
Likely a type inference issue. Try this: let classes : Dictionary&lt;String, ()-&gt;AnyObject&gt; = ["TKTimer" : { return TKTimerViewController() }] 
Modals don't block the UI thread. Modals are meant to block *user interaction*, not to block processing by the application. If you want something to be processed after the modal has completed, then put it in the handlers.
What does "the object in which the reference is" mean? I know what objects are, but that sentence didn't make much sense to me.
The shortest way to do it is Array("Hello World!")[0] //prints "H" Array("Hello World!")[6] //prints "W" and so on you could define a constant: let myArrayFromString = Array("Hello World!") and access letters like so : myArrayFromString[1] //prints "e"
You're amazing :)
Yeah sorry, that was a pretty poor explanation. Okay, so say you have a Car class, and that class has a method revEngine(). If you want to call that method from anywhere within the class, say for example, in another method pressAccelerator() (because if you press the accelerator you want the engine to rev), then you would type self.revEngine(), because the method revEngine() belongs to the object that the 'self' reference is contained in. To say 'self' is to say 'this class or object we are currently in'.
Thanks, that's really nice to hear! :) Would be nice if the contest were finished with an official result, though. :(
Thanks! It wasn't poor! That was great. Only thing is: why not just do revEngine() without the self? In this case, what would "self" stand for?
In the context of Swift specifically, I'm not 100% sure, but I suspect it's because of how Objective-C works. Invoking a method on an object in Obj-C works by something known as message passing, so you would have [carInstance pressAccelerator], where 'carInstance' is the target object and 'pressAccelerator' is the message. So within the object, you'd need [self revEngine]; revEngine by itself would be a message with no target. I have a feeling there are more reasons why you explicitly need to specify 'self', rather than the compiler or runtime implicitly assuming based on current scope, but I'm not completely sure what they are. Come to think of it, I can't remember when exactly you need to specify 'this' in Java, so I can't really compare to other languages. It's been a while. If you need more help don't hesitate to ask, I'll do my best to answer. 
As this forum seems to consist of arrogant, self-centered people..... I won't waste my time with my "petty uneducated" questions.... I can go elsewhere to be insulted by better people than this 
Not sure why your one liner takes so long to compile but here's a version that doesn't, and doesn't have trailing ampersands. ~~let postString = "&amp;".join(map(content) { (s1, s2) in "\(s1)=\(s2)" })~~ let postString = "&amp;".join(map(content) { "\($0)=\($1)" })
You're just running into compiler bugs. Any time the compiler takes an unreasonably long time and hangs the IDE, that's a bug.
Hm. I had though that map gave an argument of a tuple to the closure when you pass a dictionary. I guess not. EDIT: I guess I'll explain that thought. Map traditionally just passes one value to a function, so I figured the best way to pass a dictionary entry would be by tuple.
Oh you know what? I didn't realize that was a dictionary. Never mind!
Well you were right anyway =P apparently map has an overload for dictionaries that passes two arguments.
After thinking about it, I actually prefer tuple syntax, but I'd use (key, value) instead of (s1, s2) EDIT: can you call .join with a tuple? "&amp;".join(map(content) { "=".join($0) }
Seems like .join is perfect. Thanks!
As this forum seems to consist of arrogant, self-centered people..... I won't waste my time with my "petty uneducated" questions.... I can go elsewhere to be insulted by better people than this
Right, I see now. As I said above, there's one UI thread. In fact you can only call UIKit from that thread, you can't have a UI element that waits and returns. I think you're getting confused at what vc.presentViewController actually does. Unlike MsgBox.Show in .NET WinForms it doesn't wait for user action then return, it just schedules the view controller to be presented on the next event loop run. Methods in UIKit do not perform their actions immediately for the most part, then schedule a callback from the event loop then perform their task when your code is finished. The handler you provide to the alert controller will then be scheduled on the event loop by the alert controller and execute after the user performs an action. I'd recommend reading an introduction to iOS programming to get the full details, since the fully callback-based style required for iOS programming is quite different to what would be used on standard WinForms programming. You could also look at programming for the Windows Store, since that requires a single threaded UI and asynchronous programming, but the async keyword in C# masks a lot of the callbacks.
As this forum seems to consist of arrogant, self-centered people..... I won't waste my time with my "petty uneducated" questions.... I can go elsewhere to be insulted by better people than this
Thanks so much! This cleared things up a ton! 
Maybe try the .isEmpty() method?
TLDR: No, there is 100% no way you can make the code you've written work. You need to understand how Cocoa programming works first. Explanation: Well yes it is a help forum to a degree, you might have noticed my detailed replies attempting to explain what you're doing wrong. On the other hand this isn't a help forum for iOS or MacOS programming, it's for Swift, a new language that isn't out of beta that can call existing Objective-C based frameworks. The the reason we keep saying you're doing it wrong is because at the most fundamental level you don't understand how to use the frameworks. I say "calling UIKit" because all the "pre-defined, methods, functions and objects from within that framework" behave according to certain contracts, and I don't want to write that out every time. The most critical of those contracts is "Never block the UI thread", and the second is "UIKit doesn't do anything immediately, it schedules it for the future". UIKit is not multi threaded, it's an event-based model like JavaScript in a web browser. Once you think in terms of dispatching and handling events, rather than displaying a dialog and waiting for a response, you'll start to see the pattern emerge. I can show you an example of using a UIAlertView, but I can't make it behave how you want.
The problem is one needs to stop approaching it from a Windows design standard. Use the framework as it is designed instead of trying to make it work like Windows. What is wrong with the currently available Alert? Use the 'callback' style control flow instead of expecting to be able to hold up the UI thread. Also be aware yes/no/cancel/abort/retry/ignore generic alert buttons are an anathema to iOS UI style. 
Maybe try the `.filter()` method? let array0 = ["Title 1", "", "Title 2", " ", "Title 3", NSNull(), "Title 4"] // array0 is ["Title 1", "", "Title 2", " ", "Title 3", NSNull, "Title 4"] let array1 = array0.filter({ let s = $0 as? String if !s { return false } if countElements(s!) &lt; 1 { return false } return true }) array1 // array1 is ["Title 1", "Title 2", " ", "Title 3", "Title 4"] 
No offence or anything (we're all still getting used to swift), but I'm not loving OP's code style. It looks a lot like ported objc than code written natively for swift. First, why the long names to the enums? Swift can infer the enum namespace from the argument type. And why the casts to NSString and NSArray? We have built-in types that are preferred and automatically bridged to Foundation types. So instead of: var paths = NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory.DocumentDirectory, NS SearchPathDomainMask.UserDomainMask, true) as NSArray var documentsDirectory = paths.objectAtIndex(0) as NSString We get: let paths = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true) let documentsDirectory = paths[0] as String In addition, what's up with the indenting and brackets? Again, these are great habits to break from Objective-C: Instead of: var fileManager = NSFileManager.defaultManager() // Check if file exists if(!fileManager.fileExistsAtPath(path)) { // If it doesn't, copy it from the default file in the Resources folder var bundle = NSBundle.mainBundle().pathForResource("DefaultFile", ofType: "plist") fileManager.copyItemAtPath(bundle, toPath: path, error:nil) } data = NSMutableArray(contentsOfFile: path) We get: let fileManager = NSFileManager.defaultManager() // Check if file exists if !fileManager.fileExistsAtPath(path) { // If it doesn't, copy it from the default file in the Resources folder let bundle = NSBundle.mainBundle().pathForResource("DefaultFile", ofType: "plist") fileManager.copyItemAtPath(bundle, toPath: path, error:nil) } data = NSMutableArray(contentsOfFile: path) To me, this looks much more "swift-like" that the example code.
it's a string! not an 3d model needing to be rendered on the screen!
 let array0 = ["Title 1", "", "Title 2", " ", "Title 3", NSNull(), "Title 4"] let array1 = array0.filter { $0 &amp;&amp; !($0!.isEmpty()) } And in case OP also wants to strip their elements: let array1 = array0.map { $0?.stringByTrimmingCharactersInSet(.whitespaceAndNewlineCharacterSet()) }.filter { $0 &amp;&amp; !($0!.isEmpty()) }
As this forum seems to consist of arrogant, self-centered people..... I won't waste my time with my "petty uneducated" questions.... I can go elsewhere to be insulted by better people than this
I wouldn't bundle the pictures with the app if the size is larger than, say, 10MB. I would use prefetching for the images, ie. make the game always load e.g. the next 5 unplayed images in the background and caching them on the device. Of course, this would make randomly accessing any image of the 100 impossible, but there's not a big reason to have that in a "spot the difference" game anyway imho. Just have a "next" button to play the next picture. Or, if you want to have a list of the images, show just the prefetched ones, and put a "download more" button at the bottom. Using this approach has a number of advantages: - the App download is very fast because it's small -&gt; the user can start playing quickly - the App doesn't use much more bandwidth and space on the device than the user actually wants. Eg., if he plays just 10 games, it won't waste a lot of bandwidth/memory because most pictures won't be loaded. - in-game loading times are pretty much eliminated, except for the first image (assuming the next image can finish loading while the player solves the first image). - the player can play a few games even without internet connection, because some images are preloaded. This prefetching approach offers the best of both worlds, in my opinion. The obvious disadvantage is that it's significantly harder to implement than both other approaches (bundling images with the app/always loading the images from a server). Basically, your app needs to manage (and store) a list of images with information about where they are stored and whether they are finished loading; whenever you need to preload an image (when the player switches to the next image), you dispatch a download job to a background thread that saves the image and updates the list/UI if necessary. Probably, you already have a list in which you save the game state, so maybe you can add the prefetching information there.
Neat. I forgot that the .filter({}) parenthesis can be left out.
Great article. I wonder where one would use Calkin-Wilf enumeration?
To be honest, I haven't a clue. The idea of producing and folding an infinite tree is a great general technique, though. 
It's an unicode string, actually
One bonus of retrieving the files off of a server would be easily pushing new images, and thus new levels in a spot the difference kind of game, without having to push new updates through Apple. Especially if you're going to push the images from a server anyway to save on app size, then this is a massive plus. 
let &gt; var :)
That is awesome! I didn't know you can do this. :) I will try it as soon as I get home. Thanks for your lessons (:
Pros: * playgrounds give you quick feedback and show you results very quickly * Swift is relatively modern: clean syntax * the language is new enough that it doesn't have a bunch of "legacy old crap" built up -- compared to something like Java and ObjC at least * the iBook works nicely as living documentation Cons: * it's still a moving target * Obj-C interop can bring a lot of complexity in * XCode, especially the build process, can be hard to get the hang of.
I am doing the same. At the very least, and despite whatever drawbacks it has, it's a highly marketable skill.
No language is good for a beginner! Everything is hard, sucks, and sometimes you'll hate it! But why the hell not? Go for it. If you're gonna be a hacker or a programmer, you're gonna have a know a lot of languages. Swift is a good one to know. Whatever you do, don't become to reliant on any IDE's. Time change, and one day Apple will die, as every other software company every has. It will take Swift and Xcode with it. So make sure you learn how to use a terminal, and to program with command line tools rather than just whatever features the IDE designers gave to you. 
For the record, this was a question about how to make a UIAlertController behave like a Windows MFC MsgBox - that is blocking the thread until the user responds. Alas OP didn't see fit to leave the question around so others could learn.
I... don't really know what any of that means. I literally have zero experience with programming. I guess what I'm asking is this: Will all the resources for learning Swift assume prior knowledge of programming or will they start with the very basics? At this point guides for Swift aren't really available on programming learning sites like Code Academy. Will the official how-to guides from mac be too complicated and filled with Jargon for someone like me?
Not right now. Swift is in pre-release now, so there aren't any real training resources. There will be, but right now Apple reserve the right to alter the language in any way they like. I'm sure there'll be some, but waiting a few months is your best bet for from zero knowledge learning. In the mean time learning any language would help. The closest to Swift in terms of full functionality would be OCaml or F#, but they're not common first languages. I'd go for Java or JavaScript since they're commonly taught.
Swift is pre-release so it might be changing a bit more rapidly than someone with no experience would be interested in. It's really on the "bleeding edge" - which is part of the appeal to some of us. But I mean the Xcode environment (with playgrounds) gives you a way to run code and then see the output it provides. Seeing is believing, after all :) It's a great way to experiment, and since you're using it for things like stats and "hack your homework" types of projects, it's a great way to do that. I think that kind of "playing around" and seeing the results is way more useful than just reading a book or running a few exercises a la Code Academy. The book itself may be a bit jargon-y for you, but you should still give it a go. Run through some of the examples and try to understand them. And see if you can find someone else who knows a bit more about programming to help you "translate" some of the tech jargon into more simple English and help explain WHY certain concepts exist.
As this forum seems to consist of arrogant, self-centered people.... who actually know that they don't know a lot still, it's far better to be insulted here than get much worse treatment elsewhere.
Thanks, I'll take a look! Has there been any word on when apple plans on finalizing the language?
It's as good as any other language to start with, except for the fact that it's in beta and a new user probably will have a hard time differentiating from compiler bugs and their app bugs.
As others have said, currently Swift is a bit of a moving target, at least until the fall of 2014, but I think it should be pretty good for beginners. As for resources: [Apple's Swift Guide](https://itunes.apple.com/us/book/swift-programming-language/id881256329?mt=11) is a pretty good one. I feel that it really tries to teach you from the ground up about the different aspects. You might not want to read the whole thing at the beginning, but look up parts your curious about after the tour, and maybe "The Basics" section. [Ray Wenderlich's Website](http://www.raywenderlich.com) has always been a helpful place. At least until the fall, their [Swift Videos](http://www.raywenderlich.com/video-tutorials) are free to view as well, but they have plenty of free written tutorials as well. I also have been working on trying to explain things from a beginners perspective on my own website. Overall, I think Swift is great for beginners, and I wish you luck in learning Swift.
Just the answer I was looking for, thanks! Would love to check out your website if you don't mind linking to it.
Nothing more specific than "this fall when OS X 10.0 (Yosemite) is released"
Learn Python first. It's syntactically similar, works on more than just iOS and is far, far, far more commonly taught as a first language.
Ah! That's another good catch indeed.
I got it to work, thanks to the both of you... I am still quite new to closures so would you mind explaining a bit of what it is doing? I get the gist of it, but it is still quite fuzzy.
I've written a bit about closures before: http://www.reddit.com/r/swift/comments/27d8it/eli5_what_are_closures_and_how_do_they_work_in/chzolmv - don't hesitate to ask if you have any further questions!
Agree with this, also the vastly superior guides and docs that a mature language has will be crucial for beginners.
&gt; far, far, far more commonly taught as a first language. It's actually [the most popular introductory teaching language at top U.S. universities](http://cacm.acm.org/blogs/blog-cacm/176450-python-is-now-the-most-popular-introductory-teaching-language-at-top-us-universities/fulltext) now.
Can't agree with this more. You will have to learn basic programming constructs somewhere, and there's no Swift book that will teach you them right now.
Swift has a lot of features that will be confusing for the first time programmer. if you want to get better at programming quickly, it would be better to start with Python. Then you will appreciate Swift's type system better.
*sigh* Yet another article that does nothing besides reiterating fundamental syntax features. If your target audience is people who have never seen swift before, please don't post your articles on a subreddit for people who have.
Arg... Paris in February... I'm always looking for an excuse to visit the city, but that time of year is just.... Not fun (neither is New York, London, or Chicago. To be fair)
Not right now it's not. Maybe when it settles down some, but for now the language is changing too much from beta to beta. You don't need a moving target underneath you when you're trying to learn.
&gt; It's syntactically similar er, ...what? I agree with all your other points, but I don't find Python to be syntactically similar to Swift at all.
I think you're talking about CloudKit: https://developer.apple.com/library/prerelease/ios/documentation/CloudKit/Reference/CloudKit_Framework_Reference/ Like Swift, it's available to start developing with, but not releasing.
Oh, so you wouldn't use this to replace a database correct?
It would provide an easier transition into Swift. You'll be able to learn the fundamentals of programming more easily with Python since there are a lot more Python tutorials. Once you've learned Python, Swift will be a lot easier.
it worked! Thanks so much
This being said, Python is absolutely perfect for you. I've used a few languages, and python is the easiest BY A LONG SHOT. 
So you recommend not learning Swift at all and sticking with Python? What I envision eventually creating are apps that would do things like track fitness goals, organize my library and research, or basic planners designed around my needs. I primarily run OSX so I'd like these apps to run as smoothly as possible in that OS, and have the ability to go mobile if I ever get to that point. Is that all stuff Python is well suited for?
No, it isn't, however... I work in an environment right now that is built by people with a similar attitude to this. I find that if it applies to one case, it'll generally apply to all. This means, someone would choose the O(n^2) way over the O(log n) way, purely because it was faster to type.
Ah. I see. You had said you wanted to code as a hobby, I didn't know you meant iOS development specifically. If you want to dev for iOS, there are ways of accomplishing this with Python and even with Java (another great first language) but it's effectively a hack around the official *real* ways. (For more info, you can see an old post of mine [here](http://www.reddit.com/r/iOSProgramming/comments/28l7c5/ios_development_without_objc_alternative_sdks/).) In the real sense, you have 2 options if you plan to code specifically for iOS: Objective C and (now) Swift. Objective C is an old, ugly, and underused language, but there are resources all over the place for learning it. Swift, IMO a much better, cleaner language, doesn't have any beginner resources available that I'm aware of. If you're going to stick with the official, often-used methods, I would recommend Obj-C for about then next few months. It's a tough time to *start* in iOS development because of the lack of Swift resources, but not many people are doubting it's a better language. Otherwise, if the beaten path isn't your thing, python is the easiest language I can imagine learning, and *there are ways of developing for iOS in it.* It's just not as official, and might require a stronger understanding of the language to get it going on your iPhone.
Even after reading all I comments I still say start with Python, or my favorite, Ruby. Both of those languages are easy to pick up and will teach you about programming. You will learn a whole lot with them in 2-3 months.Then it would be much easier for you to start to pick up swift.
Recommendations are always welcome! In researching this the past few days I came across [this text](http://www.openbookproject.net/thinkcs/python/english3e/) recommended by /r/learnprogramming. Seemed like a good resource as it actually explained the theory behind what you're doing instead of just throwing you right into the practice of it like code academy and other sites I've seen. If I'm going to use python as a stepping stone, I suppose the concepts are more important than memorizing lines like print "Hello, world!"
You can, but you can't use it for publicly released apps and you risk data wipes until iOS8 &amp;c goes public.
Yep, I know. I'm working on something that can go start to finish that I'll manage so I won't feel like I'm stepping on someone else's toes =)
Unless your project is composed entirely of calls within the Swift standard library, all projects are effectively combined projects anyway as Cocoa has not been rewritten in Swift. Performance is probably the least important consideration in deciding whether to do a mixed or single-language project.
I've been doing it since iOS 2 and I'm still finding new things fairly routinely, and that's with many years of programming experience under my belt before that. Cocoa Touch and Foundation are enormous frameworks. I really would not recommend going with Swift as a first language. Multiple threads have popped up in this sub recently about beginning programming with Swift, and the general consensus is that while Swift is a decent language for beginners, it still has some serious drawbacks. For one, it's still a beta, so things could change unexpectedly. For another, it's so new that there are very few resources available. Finally, as you pointed out, you are going to need to understand Objective-C (and probably pure C as well) to be able to understand Cocoa. Swift has the pieces in place to become a great language for beginners, but it's not there yet. I'd recommend starting with C, Python, or Ruby personally. If you are dead set on learning iOS, then going C -&gt; Objective C -&gt; Swift could be a good path. Starting with C gives you a good foundation in the fundamentals of computer science and will help you better appreciate the conveniences in Objective-C and even more so in Swift. 
Cosign. C was my starting language. I personally recommend going C, Java, Obj-C, Swift. People tend to shit on Java, but if you can get a decent hold of C and a decent hold of Java, nearly every other programing language (Obj-C and Swift among MANY others) will be easy to pick up. Swift Playgrounds are absolutely amazing though... Kinda would like to see that with Obj-C and C. Now if you're gonna get into web development programing I highly recommend Ruby, but that's another story... Happy programming to you!
You could do a lot making web apps with django. 
I believe the navigationController() method returns and optional as your ViewController doesn't have to be in a navigation controller. I'm guessing your controller either isn't in a navigation controller, or that your viewcontroller in the storyboard has a navigation bar simulation
That's partly true (still a very enjoyable city ;). But we wanted to be as far as possible from WWDC.
Is there any pricing in this yet!
I got hired to build an iPhone app that my company had already sold. I'd made my phone tell me "Hello, World!", so that made me an expert. Up until then I'd been a developer for 10 years or so, but strictly web-based technologies. I sat at my desk full time learning iPhone OS (which is what it was called then) development. I went home most nights with my brains leaking out of my ears. I remember one night I had a dream about a girl in a one-piece bathing suit made out of a UITableView (it was scrollable and everything). I started building code that finally made its way into the deliverable around the 1 months mark. By around 3 months I was pretty comfortable implementing real features in a reasonable amount of time. Bear in mind, those are 40-hour-a-week months. I was employed full time to learn this stuff.
I am glad to see Apple improving on the documentation side. Until Apple launched the book about Swift there was two Apples: the good Apple, that is the one we know, run by Tim Cook. That apple loves customers, create beautiful products, beautiful software and the other one, the dark Apple, that creates crappy vague documentations. Dark Apple is the one that deals with developer. Dark Apple hates developers. Dark Apple gives book authors/musicians different treatment and privileges compared to developers. Dark Apple is run by satan himself. Because swift was created in secrecy by Chris Lattner without the knowledge of Apple themselves, I think that caught satan by surprise, that had no time to interfere, and Swift documentation has to be written by the good Apple. This blog thing is also another step of the good Apple. I hope this is a tendency. 
I have just run this test: class benchmarkingTests: XCTestCase { func testPerformanceExample() { Array("Difficulty on insensible reasonable in. From as went he they. Preference themselves me as thoroughly partiality considered on in estimating. Middletons acceptance discovered projecting so is so or. In or attachment inquietude remarkably comparison at an. Is surrounded prosperous stimulated am me discretion expression. But truth being state can she china widow. Occasional preference fat remarkably now projecting uncommonly dissimilar. Sentiments projection particular companions interested do at my delightful. Listening newspaper in advantage frankness to concluded unwilling.Greatest properly off ham exercise all. Unsatiable invitation its possession nor off. All difficulty estimating unreserved increasing the solicitude. Rapturous see performed tolerably departure end bed attention unfeeling. On unpleasing principles alteration of. Be at performed preferred determine collected. Him nay acuteness discourse listening estimable our law. Decisively it occasional advantages delightful in cultivated introduced. Like law mean form are sang loud lady put.Placing assured be if removed it besides on. Far shed each high read are men over day. Afraid we praise lively he suffer family estate is. Ample order up in of in ready. Timed blind had now those ought set often which. Or snug dull he show more true wish. No at many deny away miss evil. On in so indeed spirit an mother. Amounted old strictly but marianne admitted. People former is remove remain as.Maids table how learn drift but purse stand yet set. Music me house could among oh as their. Piqued our sister shy nature almost his wicket. Hand dear so we hour to. He we be hastily offence effects he service. Sympathize it projection ye insipidity celebrated my pianoforte indulgence. Point his truth put style. Elegance exercise as laughing proposal mistaken if. We up precaution an it solicitude acceptance invitation.Husbands ask repeated resolved but laughter debating. She end cordial visitor noisier fat subject general picture. Or if offering confined entrance no. Nay rapturous him see something residence. Highly talked do so vulgar. Her use behaved spirits and natural attempt say feeling. Exquisite mr incommode immediate he something ourselves it of. Law conduct yet chiefly beloved examine village proceed.Tiled say decay spoil now walls meant house. My mr interest thoughts screened of outweigh removing. Evening society musical besides inhabit ye my. Lose hill well up will he over on. Increasing sufficient everything men him admiration unpleasing sex. Around really his use uneasy longer him man. His our pulled nature elinor talked now for excuse result. Admitted add peculiar get joy doubtful.Am of mr friendly by strongly peculiar juvenile. Unpleasant it sufficient simplicity am by friendship no inhabiting. Goodness doubtful material has denoting suitable she two. Dear mean she way and poor bred they come. He otherwise me incommode explained so in remaining. Polite barton in it warmly do county length an.One advanced diverted domestic sex repeated bringing you old. Possible procured her trifling laughter thoughts property she met way. Companions shy had solicitude favourable own. Which could saw guest man now heard but. Lasted my coming uneasy marked so should. Gravity letters it amongst herself dearest an windows by. Wooded ladies she basket season age her uneasy saw. Discourse unwilling am no described dejection incommode no listening of. Before nature his parish boy.No opinions answered oh felicity is resolved hastened. Produced it friendly my if opinions humoured. Enjoy is wrong folly no taken. It sufficient instrument insipidity simplicity at interested. Law pleasure attended differed mrs fat and formerly. Merely thrown garret her law danger him son better excuse. Effect extent narrow in up chatty. Small are his chief offer happy had.She wholly fat who window extent either formal. Removing welcomed civility or hastened is. Justice elderly but perhaps expense six her are another passage. Full her ten open fond walk not down. For request general express unknown are. He in just mr door body held john down he. So journey greatly or garrets. Draw door kept do so come on open mean. Estimating stimulated how reasonably precaution diminution she simplicity sir but. Questions am sincerity zealously concluded consisted or no gentleman it. ")[1900] } } And it takes 0.003 seconds 
I've been doing it since iOS 1.1.1, and I too am far from knowing everything about even the core frameworks. It probably took me over a year to get comfortable with iOS, but that's because of the actually non-existent documentation and hacky toolchain back in the good old days. However, not knowing everything about the core frameworks doesn't mean that one isn't comfortable working with iOS. Once some core knowledge is there and one has learned how to gather the information one needs, it's pretty ok. So while it's true that you need to spend some time to learn Cocoa Touch/Foundation, it's not exactly an insurmountable problem. I agree that Swift is a bad first language right now. For example, quite frequently, the compiler errors simply have to be categorised as "bullshit", which is very, very bad for a beginner. A crashing compiler/Xcode doesn't help either. I approve of going with Python as the first language. I'm not sure that C is a great idea though, the way most programming languages develop mean that having know-how about manual memory management and pointers gets less and less important, and those are some pretty big topics when learning C. (Except if you plan to write code for very low powered devices or extremely performance critical applications, then go for it, I guess).
It's not really the documentation but the presentation. For instance Xcode gives me documentation for pretty much anything just by clicking on code, but it's not nearly presented in a way that makes how to use it obvious (at least initially). They do have plenty of example code though. 
Good news. I can answer my own question. There was a better approach, and I did need to look at this from a different angle. The answer is that the kind of shim I wrote for Beta3, is now no longer needed at all! If you need to pass a readonly utf8 string to a system call or C Library function just use a String and it will be seamlessly bridged for you by the compiler. The new entry on the Swift blog today. for example: var fh = fopen("foo.out", "w") will create (or open and truncate) the file named "foo.out" and return a stdio file handle to it. 
Thanks! What else do you think should be considered?
hmm. i keep encountering this same apple+dark apple post, everywhere, almost verbatim. i guess you're the one posting it.
Don't forget to call superclass implementation 
People will balk at you learning C, because the whole "Pointers are hard" thing. But you never actually get away from that in Objective-C or Swift. Even in Python, you have to know the concept. (value/reference/NULL). Beyond the concept of pointers, the other hard part of that is memory management. But if you're just learning, you learn that it's necessary to do, but just enough to see that it has to be done. Then, you can start learning the whole OO thing. And, learning the frameworks in iOS is 95% of the work anyway, whether in Swift or Objective-C. Sure, Objective-C might be "harder", but you've got legions of good tutorials, books, and stack overflow answers to help you.
Optional parameters are done a little poorly (IMO). When you call a function with an optional parameter, the compiler adds the default value to your call if you didn't specify it. That's why when you use this: class A { func method(variable: String = "HEY") { println(variable) } } class B:A { override func method(variable: String = "DUH") { println(variable + " is the default") } } let obj: A = B() obj.method() it prints "HEY is the default". It sees that you're calling A.method (although it's on an instance of B), and subs in the HEY parameter in the call. Point is, defaults are a syntactical trick of the compiler. So it makes sense that you can't use them in protocols.
&gt;So while it's true that you need to spend some time to learn Cocoa Touch/Foundation, it's not exactly an insurmountable problem. You're absolutely right, I didn't really answer the OP's exact question very well. It probably took me a few weeks before I wasn't constantly looking at reference material, and months if not over a year until I started feeling truly comfortable. That was as someone with nearly a decade of experience, though. If you take someone completely new and then throw in the hurdle of a beta language I'd expect those times to increase somewhat, especially if the OP is doing this part-time or as a hobby. &gt; I'm not sure that C is a great idea though, the way most programming languages develop mean that having know-how about manual memory management and pointers gets less and less important, and those are some pretty big topics when learning C. I disagree, these two things are still very important. Just because they are abstracted away doesn't mean you can ignore them. Understanding how your language works under the covers can be critical. It also causes you to approach problems with these sorts of things in mind.
I'd bet that pure ObjC is about the same as Swift+ObjC in terms of performance. Not much conversion has to take place between types, and what does need converting you can either type as the corresponding NS type to avoid conversion, or it generally isn't too expensive to convert. Pure Swift, once they get out of beta and have the optimizations up to snuff, I bet will be faster than ObjC in places that ObjC is slow. But ObjC is already really fast. I think the only place that ObjC slows down compared to straight C is method call overhead, which isn't significant and which Swift will still speed up (if your calling a method on a Swift class that doesn't inherit from an ObjC class).
I'm a newbie to the iOS framework but 20 years experience in C++ and C#. Someone else made a good point in another thread that learning the syntax for a new language is easy - its learning the underlying framework i.e. Cocoa that is overwhelming. I would say that if you're going to have to support a pre-existing app that was written in Obj-C then yeah you need to learn Obj-C really well. However if you're just diving in on your own time and plan to write your first app, then learn Obj-C just good enough to read and understand it and write your apps in Swift. Swift is still changing during its beta but its nothing so major that you can't overcome by reading a quick article that details the changes. And yeah the compiler is buggy here and there but again in a month or two it should smooth out. Developers are very quickly filling in the gaps with tutorials, tools and scripts. Before the end of this year you will be able to do a 2 minute google search and find just about anything you''ll need. So watch Paul Hegarty's iOS 7 classes on iTunesU. That will help you to learn Obj-C well enough to read and understand it and also to help learn the Cocoa framework. But I would write all my new apps in Swift. Don't bother learning C - you'll be able to get by just fine without it. And as to your actual question :-) learning any framework is like learning poker - takes a minute to learn and a lifetime to master - best of luck! 
I think we were trying to give him a basis for all programming languages. Not just swift. I say C and Java because they are considered to be "harder" languages, and i feel that if you can get those two languages at their basic levels you can get many other languages. But that's just my opinion. Different strokes for different folks. 
Thank you. I totally did. 
&gt; Yes, you will. For anything above the simplest Swift app, you will likely need to deal with C and Objective-C APIs that use pointers, and will for the foreseeable future Already this is pretty much abstracted away by swift, and simply knowing about inout parameters and understanding when things are mutable and not, is more than enough to interact with objectic-C APIs. &gt; It forces you to learn about very important concepts in CS which will lead to a better understanding of more complicated concepts in higher level languages once you get to them There is a reason that most universities have stopped teaching C as a introductory language. It's cumbersome to get started in, and you spend a lot of time fighting against the language instead of actually doing something. Yes, at some point if you want to get serious you should probably spend a few months working in C, but as a starting language? &gt; It has a very similar object model to Swift (single inheritance with protocols and extensions) You know what other language has a very similar object model to Swift? Swift! &gt;The vast majority of 3rd party libraries are written in Obj-C. Tutorials and support resources are still, and will continue to be in the near future, primarily Obj-C based. Which is why he will program in something else for the next few months. In which time the beginner resources will have matured quite a lot. And it's not as bad as you make it out to be even today. I wouldn't undertake a big project in Swift as a beginner, but spending a few months learning the basics is feasible even today. And working with Objective-C libraries aren't all that hard in Swift. Give it a few months and most of the bugs will be ironed out. Then it will be even easier. &gt;Learning syntax is trivial compared to the difficulty of understanding language concepts and features. As a beginner you want to focus on understanding concepts, not fighting against syntax. Python makes it easy, since it's almost English. Obj-C makes it hard. If you see: for name in names print("Hi " + name) You will probably have a good idea of what it means, since it's pretty much just an English sentence. If you see: for (NSString* name in names) { NSLog("hi" + name); } It is a lot less clear (even if it's not hopeless in this simple example). At the same time Swift borrows heavily from ML languages, it's object oriented, and it is fairly modern. C and Obj-C teaches you none of this, while forcing you to learn a lot of things you will probably not need for years. 
Don't let everyone scare you off swift - just go with it - you'll be fine. It'll be out of beta by end of september and you'll be swimming in tutorials and resources designed specifically for beginners. The team at RayWenderlich.com is already hard at work on their beginner tutorials and even now there are lots of beginner tutorials and videos on youtube. Before the end of the year we're going to be drowning in Swift tutorials. My only warning is to really research the tutorials before spending your precious time on them because some are really great and some will have you cursing your wife and kicking the dog. RayWenderlich.com has a really good reputation and I'm sure there are many more out there thats just the one I personally have experience with. Hopefully Paul Hegarty will be teaching Swift in his 2014/2015 Stanford class on iTunesU. But don't sweat it bro - Swift is definitely easy enough to learn as a first language and very soon there will be some great resources available for it.