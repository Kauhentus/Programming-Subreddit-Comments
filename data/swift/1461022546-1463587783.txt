I know it's not Haskell, but you can implement something similar by then having func pretendCurrying(x: Int, y: Int) -&gt; (Int -&gt; Int) { return { z in threeMult(x, y: y, z: z) } }
I got it working. Put the logic in TableViewControllerB inside viewDidLoad() func, then when I come back from C, inside viewWillAppear() I called self.tableView.reloadData()
You can write uncurried functions in Haskell also: it just uses tuples. threeMult :: (Int,Int,Int) -&gt; Int threeMult (x,y,z) = x * y * z In fact, that's *very* close to Swift 2, which treated function arguments as tuples implicitly. On top of that, you can write the "explicit" curried version in Haskell also: threeMult :: Int -&gt; Int -&gt; Int -&gt; Int threeMult = (\x -&gt; (\y -&gt; (\z -&gt; x * y * z ) ) ) Equivalent to the Swift: let threeMult: Int -&gt; Int -&gt; Int -&gt; Int = { x in { y in { z in x * y * z } } } So the difference is pretty much just syntax.
Objective C is actually a simpler language than swift. It's more verbose but simpler. Swift has much better syntax as you mentioned. The syntax is off putting to many who are new to obj c. (For the record I do think swift is a better language.) But there are countless mature iOS codebases out there written in ObjC. And it's too costly for companies to do a complete rewrite in swift. Remember in Objc nil is safe. You can send a message to a nil object you won't get a null dereference crash. That doesn't mean you won't see bugs in your code. Oftentimes nothing will happen, so you have to hunt around for an object that's unexpectedly nil. Also ObjC is quite dynamic. You can do all sorts of crazy stuff at runtime. Method swizzling so forth. A good book is your best bet. I highly recommend Effective Objective C by Galloway. 
If you are already familiar with iOS and OS X development then many of the class calls and high-level concepts will be familiar. In terms of actual syntax they are very different. I'm not sure I can think of an easy way to transition other than just jumping into it. If you're really good with Swift then you shouldn't have too difficult of a time overcoming the syntax difference after a few days of practice. Objective-C has a unique style with something like: [classOrObject methodName:argumentValue]; If you have multiple arguments then it's something like: [classOrObject methodName:firstArgumentValue moreMethodSyntax:secondArgumentValue];
[removed]
`-Wno-objc-missing-property-synthesis` is useful if you're still writing Objective-C code under OS X's 32-bit ABI runtime. Note that if you're targeting that, you probably aren't you don't have access to Swift anyway. Under OS X's 32-bit ABI, iVars must be in the main `@interface` block: Any other place and the compile fails. This is not true for 64-bit OS X, or any-bit iOS.
As far as programming: There's no support for the Metal 3D API. I haven't seen any performance issues.
I've worked with Bob in the past. He has a tendency to sometimes hyper-emphasize a point, especially when giving examples. But it holds true in some of his style: short methods, lots of helpers. But as long as they're named properly and especially if they're composable... Yeah. If they're changing state and doing all sorts of other craziness, id prefer that all stays at the top level. One of the reasons I like Swift is that they make function arguments immutable by default and encourage a style where you return values from functions rather than having some side-effect.
See this, think "cool I'll try for a ticket" so I click the link, see the cost 2099$ (Canadian), whelp maybe next year. 
I would suggest using SKMutableTexture
Short Answer: No. Building swift on OS X, doesn't create android binaries. It flat out ignores Android toolchain commands. It's also mentioned in the Android doc, that only Linux is supported. Long answer: I spun up an ubuntu vagrant box to build swift. It compiled fine, but now I'm stuck at ld not recognizing the armelf_abi emulation mode. I'll try recompiling CMake 3.2+ for LLVM and retry. Compiling Swift for android has been really an uphill task, and I'll probably create a build script, of I ever get it working. BTW: kudos for the BlurrSDK, I actually got inspiration from you to compile Swift on Android :-) 
They always cost this and have costed this for a long long time. Next year won't be different 
I would rather master Swift than half-master Obj-C.
Your own backend would be the best, as a tradeoff you might look at firebase.
If you look at the swift runtime source and tell me what the protocol conformance cache does, that would be great.
There have been sugetions of built in features for creating partial application of functions ([here](https://github.com/apple/swift-evolution/blob/4dfe2c2d9fd65f4454abac123bff5571f10a4764/proposals/0002-remove-currying.md#alternatives-considered) and [here](https://github.com/apple/swift-evolution/blob/4dfe2c2d9fd65f4454abac123bff5571f10a4764/proposals/0021-generalized-naming.md#alternatives-considered)), and although partial application is not currying, it's I suppose as close as we can get for now.
Up until a week ago I was going to enter the lottery. But for the cost of just the ticket alone I can buy a plane ticket to Spain, the conference ticket for NSSpain, and have money left over. I have no doubt WWDC is great but when your covering the costs on your own it's hard to justify it compared to some other conferences. Maybe next year though and it sounds like they are live streaming everything so I can at least couch it up and catch the action live this year.
Fantastic! The timing could not work out better for me since I wanted to take some time in May to go through a course or two and solidify some of my skills. For anyone out there who is just starting to learn Swift this course is one you need to watch and work through at some point in your learning. 
Here you go! http://stackoverflow.com/questions/27954721/programmatically-get-running-application-bundles-in-os-x
This. Plus going through the Swift github source (presuming OP knows compilers and has written a few).
Swift is the language. AppKit, UIKit, and CoreFoundation are some of the frameworks. If you are looking for how to do something on the Mac try "Get active processes with AppKit". If you wanted to know how to do something on the Mac search with AppKit, on iOS search with UIKit. If you need to do something that seems fundamental and should be present on both, try CoreFoundation (usually shortened to Foundation) Hopefully that will get you a bit closer :)
CloudKit is a decent option. I've used it in production apps. It has its strengths and weaknesses. I definitely think that it should be strongly considered. 
Thanks i really appreciate the help.
You have to create an overridden window controller to pop a new window. The button generates an *action* you handle and that code tells the new window controller and xib to open. In the xib you define the UI elements for the window. The content for those UI elements has to be provided by model objects that hold data to fill the fields (if you don't know about "MVC", google it). Where you get the data for those objects is application specific. How you update the UI fields from the model objects is through outlets or delegates (e.g. table view data sources) or bindings. The xib merely defines an empty UI shell. The "Controller" mediates the transfer of Model object data to View objects (UI elements in the xib) - hence MVC. 
For anyone who is super enthusiastic about Swift then try! Swift in NYC, on Sept 1 and 2, and being put together by the always awesome Natasha the Robot, is offering 10% off for the next 24 hours. They hosted a try! Swift in Japan last month and I heard pretty amazing things about that one so this is unlikely to disappoint. There are 5 other conferences too offering the same promo. For those who cant justify WWDC one of these might be a much better choice (and value) for you!
Oh, sorry. Well, I will confirm that yes, you can access CloudKit data via JavaScript.
I agree, plus you can use the SwiftyJSON library from GitHub https://github.com/SwiftyJSON/SwiftyJSON. I have personally used it in my first app and it is fairly easy to set up with Cocoa Pods.
I know this has prerequisites. But I'm starting from scratch. I know nothing. Is there a good course on iTunes U for me that will lead me to this course?
Nice! Paul's a master at this. 
Paul Hegarty is an awesome lecturer. I'm looking forward to watching this lecture. 
Thanks!
Whenever the class physically meets. It's usually once or twice weekly, but not more frequently than that. 
One of these days, I'm going to do this course without falling asleep during one of the lecture videos. 
I watch it at x2. And slow it to x1.5 or x1.25 when necessary. Makes it much easier IMO
This is great! Is there an online version of the prerequisite cs108 (or equivalent)? My OOD is a little weak.
Oh wow thanks! I didn't realized they released that.
Do you know what's included on each ticket?
That I don't know. You would have to check on each conferences website, or perhaps even email the promoter directly. Most include food throughout the day. Some will offer a t-shirt or some souvenir specific to the conference. Travel and accommodations will be up to you as well. 
I hope this man never retires.
All of the links others posted are good resources. There is also this page that lists common reasons for app rejection: https://developer.apple.com/app-store/review/rejections/
May I ask which Plymouth University?
I have taken both and Mark's course is better. Also he is doing a kickstarter campaign where you can get all his courses for $10 (iOS, Android, React Web Development, Apple TV, Objective-C) so better quality and more content. Although you wait 29 days to get it. 
Is this the Mark you're speaking of? https://www.udemy.com/user/mark-price-2/
Sure!
Thanks
The real value in the ticket price is being able to attend the labs. Pretty much every Apple engineer is on-site for the labs at some point, so if you are having trouble optimizing a Core Data query, or building a media player, or rendering some part of your game at 60fps, etc. you can get some help from the people who write the frameworks. Personally, these days I enjoy my Couchwide Development Conference, where I watch the livestreams in my pajamas :)
The swift compiler and runtime are almost exclusively written in C++. The Swift language isn't mature enough yet to write the tools in it yet. The language is changing too quickly, and the developers would rather work on getting it reasonably complete before worrying about the minor detail of which language the compiler is written in. Eventually it'll almost certainly be rewritten in Swift.
Must try and watch these weekly as if it was a real lecture set. Trying to watch them when they are all out at the same time can be overwhelming. Whereas if the limit is the next video is not out, I can feel less pressure to be doing it. 
This course here https://itunes.apple.com/ca/course/ios-development-in-swift/id950659946
"Redeclaration" I think is the wrong term here, since you're not redeclaring anything. After each loop iteration that variable is out of scope and discarded, next iteration it's like it never existed. tldr It's being declared, since it doesn't exist after each loop iteration.
It's probably missing the required CSS files - at least in GitHub the very same code snippets show up with colors.
Check the delegate methods if U want to know how to handle each scenario.
Your name makes it sound like it's part of the Core libraries offered by Apple, I would suggest changing it
I figured that, but it's a bad idea
Just using WiFi will probably work for the chat channel. Bluetooth can work but it's usually less efficient in terms of bytes/watt so you have balance the battery life issues of that. The issue is reliability of connection - strangely going via the internet up to a server hosted on the other side of the planet and then back again, might be more reliable. In terms of position determination, nothing really works well at 1-50 foot distances. This has been asked here before - see my answer to that. This is at the accuracy limit of GPS which means seeking distances in that range are potentially futile, deceptive and dangerous if you are risky life and limb, or a business model. It's helpful to understand what accuracy really means: Say you have a measurement accuracy of 10m, then the numbers you get back can only be trusted to ±10m. So if you get back 14m, the distance isn't really 14m - it's at best 14m ± 10m so the answer could be anything from 4m to 24m. If you get back 10m the real value could be anywhere form 0m to 20m. If you get back 5m, the real answer is anything from -5m to 15m (yes, &lt;0 which means the azimuth is behind you even though Location Services and *your math* says it's in front of you!! **you have no way of knowing the value better than this from the number itself.** If you have two separate people each with GPS positions trying to determine their distance from each other, it gets even worse - the errors add so the net accuracy is ±2m to ±20m instead. The 1 meter accuracy assumes perfect reception from 4 satellites without any interference or adverse atmospheric effects. This typically means: * You are on a flat open plain with no mountains and no buildings with clear skies with line of sight from horizon to horizon in all directions. You are not in a vehicle or any other type of metal. You've an ideal GPS antenna with specified gain. The 10 meter accuracy is for when you don't have all of these because each interfere with both satellite reception and signal propagation in ways that interfere with accuracy. Being in a downtown urban skyscraper canyon will definitely push things to the ±10m limit. Everyone has experienced this with Apple Maps. It's this span of uncertainty that causes the above mentioned "nothing really works well" claim. The accuracy is so bad at these ranges that GPS could put you right next to someone or it could put you on the other side of the block or in the middle of traffic. This is simple a feature and reality of the technology given the constraints of the laws of physics. Of course, if you have other data; e.g. in this chat applications, you recognize the person is sitting next to you or see them out the window walking down the street you could "refine your distance estimate" thus. The key here if you already know them so you can recognize them at all - this provides extra information not available from the GPS data itself. Some work has been done to electronics provide this "extra information" to make GPS more accurate but it requires something beyond vanilla GPS. Even Apple has tried by buying a company that specializes in "sensor data fusion" to achieve this. It's still not a thing at short distances. So the technology may not give you the answer which means you may need to alter your business plan and technical design to account for this. Basically if you couldn't determine positional distance better than 100 feet, how would affect your app and your business model? Could you still do it? Would it be a show-stopper or could you work around it? What app features would you do differently? How would you address situations when the accuracy changed? (This is a subject I know fairly well because I used to work in a "Think Tank" related to military space systems which includes the design and creation of GPS)
Expect a nasty-gram from Apple's lawyers. Just saying, the way trademark law works it's pretty much a guarantee of legal troubles. 
I'm not sure what book it is that costs $150 dollars, and you certainly don't NEED Sketch. I recommend the Big Nerd Ranch Swift programming guide and their iOS development guide. Those resources put together will give you a wealth of knowledge and a solid foundation to start building apps. Also the free course on iTunes U - Stanford iOS development will teach you the fundamentals such as MVC, Core Data, segues - all the good stuff, it will really solidify these concepts. 
First, read Apple's free iBook for Swift to learn the general/common knowledge. Then, decide what you want to do. Do you want to build games? Non-game apps? If you want to build 2D games, use Ray Wenderlich's SpriteKit 2D book. For non game apps, I also recommend Ray Wenderlich. Also, don't pay for the book or Sketch; you don't need Sketch right now.
Doesn't FireChat already do this?
I took Rob Percival's iOS 9 course on Udemy in December and I now have a simple app in the App Store and am working on my second one now. Highly recommend. Only $40 now. https://www.udemy.com/the-complete-ios-9-developer-course/learn/v4/overview
Yep.
That glitch has been resolved in the new patch. So you would have to get the older version.
I'm doubtful of it'll work. To compile Swift for Linux, you'll need tons of Linux specific dependencies like libicu, C++ headers, GNU Binutils, CMAKE, Ninja etc which AFAIK aren't available on the Ubuntu subsystem. Of course you can try building it yourself, it's not that hard.
I can totally vouch that Pro Swift is awesome (disclaimer: I wrote it), but someone _learning_ Swift might find [Hacking with Swift](https://gum.co/hws-book-pack) an easier place to start. Plus [it's available to read for free](https://www.hackingwithswift.com/) if /u/exjr_ would rather save the cash :)
https://www.hackingwithswift.com This course is free or you can get the PDF and videos for $30 but its very much worth it, has taught me a ton. 
I used Rob to get up on my feet learning swift. I am still in the struggle with learning but Rob was a good first start. 
Congrats! For your Github link, are you looking for contributors, code review, or just want to show off your code like a proud parent?
Since I'm new to Swift (I can do Obj-C pretty well, C++, C, Java, C#, and a whole host of other things, so no worries about *concepts*, just the language), could they have just said `return MySpecialCell(color: color, text: text)` instead of making it two lines? Just wondering if there is a reason they didn't do this, since in C++ and basically everything else, I would have done that. Anything I'm missing here, or was it just being verbose?
Actually the book is $50 right now because of a deal. I don't know if it is still worth it at this point. But either way, here is more info about the book: https://designcode.io/ I subscribed to the iTunes U course you suggested. Thank you!
Just subscribed. I will give it ago. Thank you!
I will give the Udemy course a go when I'm ready to start. I might be able to back that campaign if it really promises to teach me new stuff Apple might come up with. I will give the Udemy course a go when I'm ready to start. I also emailed the author of Design+Code to see if that's the case on his book too. 
I don't want to build games, just yet. I just want to start with simple apps
This is all you need. After I did that course (a few years ago, so one of the previous courses) I managed to get multiple apps in the store that are still being sold. A few tips: - Don't skip ahead. It's tempting from time to time. But stick to the lesson you are currently at. - Finish all your assignments. Even the bonus assignments. I know you obviously won't have to hand them in. But it's the best way to learn. - Do not lookup code online. Do not copy/paste any code that is not yours. Write your own solutions. - Don't do too many lessons/assignments on one day. Take a walk from time to time. Look forward to continuing the course the next day. This keeps it fun and and will allow you to process what you've learned. (And keeps your loved ones happy. ;)) And best of all: don't spend anything on books or software. You don't need it. (To start with ...)
There seems to only be 1 video up. Has Stanford's quarter just started?
Someone posted here like last week that the Itunes U course for this year started, so I guess the video's are synched with the course thats in progress right now. If you really want them and if you can't find them somewhere else, I believe I've got all videos from 2015 on a hdd somewhere. (Swift 1.1 or 1.2 though)
Yeah, that's just a verbose way to do it. Not only can you put it on a single line, you can use $0 and $1 in place of the variable names, and you can exclude the `return` statement: let cellFactory: (UIColor, String) -&gt; MySpecialCell = { MySpecialCell(color: $0, text: $1) } You can also use typealias (like typedef) to clean up the declaration: typealias FactoryBlock = (UIColor, String) -&gt; MySpecialCell let cellFactory: FactoryBlock = { MySpecialCell(color: $0, text: $1) } 
oh, havent tried it for a while. good to know :P i actually wanted to buy it but heard rumors they will release a new version soon that has to be bought again. maybe thats wrong
I just want to empathize that is **the best course** to learn iOS apps development. I took the course back in 2011 (it was on ObjectiveC, back then) and same as others, I have successfully published apps in the app store. Do the homework, they're actually quite fun.
If you want to build games, you definitely don't need Sketch. If you want start with simple but pretty apps, search for iOS templates. There is a lot of them and they are free. You should focus on learning swift, man… not in your design skills.
Well no, that's part of my point. _Anything_ that works on Ubuntu works on Windows Ubuntu as well.
I use swift on smartos via lx branded zones. It's a similar concept. 
Nice UI dude. I really like the color gradient and the simple interface. Btw how did you handle the timer in the background? Were you able to have it remain active for the alotted time? Last time I made a timer it would stop working around the 15-20 minute mark when the phone would totally suspend it. 
I just finished the first video and did all the steps listed (and boy, how much I learned here), however I can't keep going because there is no more videos/slides. Is this an error on my end, or is it like that?
What you want to do sounds like a REST app. Check this thing out. https://devdactic.com/rest-api-parse-json-swift/ Once you know how to make rest calls in swift you can set up a rest python app using any rest frameworks for python. Here is a tutorial http://m.youtube.com/watch?v=YX9vK11oX-E I bet you can find a lot more with googling! 
Use the NSTask API. If the user's data just needs to be provided to the script as an argument, that can be as simple as this: NSTask.launchedTaskWithLaunchPath("/path/to/scripy.py", arguments: [userArg, "otherArg"]) It gets a bit more complicated if the script accepts the input as it runs, as well as if you need to read any data it outputs in response. [Matt Gallagher does a great job of covering the most common scenarios.](http://www.cocoawithlove.com/2009/05/invoking-other-processes-in-cocoa.html)
With an already established background in programming languages, I'd say just dive in and build something. You don't need special learning materials. You already know the fundamentals of programming, so it's just a matter of learning Swift's keywords and a small handful of Swift specific idioms. Use all the same resources a professional Swift programmer would use daily. The official docs, StackOverflow, and general googling for blogs and Swift tips sites. Each time you need to know how to do something, go to one of those sources and search. Think of a simple project you want to build, something that can be reasonably completed in three months, then just do it. This is exactly how I skilled up on Swift, coming from a background in professional programming in other languages. In three months I felt adequately proficient to put it on my CV, and after six months it feels like one of my first languages.
Course just started, it looks like. You can look at the previous year, though it'll be a little bit of extra work since it's for Swift 1.2 while the current version is Swift 2.2.
i only briefly glanced through this app, but to just tag on and answer your question, use the current time + the amount of time chosen to calculate the end date, and store that end date locally so that you can always adjust your timer when it comes in and out of lifecycle
I disagree on that swift only has a "small handful" of idioms. There's a lot... 
Java, C++, JavaScript. I've been grinding swift at work and at home everyday since it was released. I still learn new practices everyday through blog posts, podcasts, Reddit, and conference videos. For example, I wouldn't call anyone savvy with writing idiomatic swift until they mastered use cases for stuff like @noescape, @autoclosure use cases. Proficient understanding of monads and usage of the higher ordered functions. Understanding arc is also crucial, and the numerous edge cases that arise from unexpected retain counts. Knowing when you should use lazy variables, immediately computed closures, didSet observers, and more importantly, knowing when not to use it. Reference vs. value semantics and decisions on when to use what. Protocol oriented programming, protocol extensions, the list can go on and on. Not to mention this guys in college with just 2-3 courses on programming on his/her belt. 
This is all modern programming language basics though. Granted the syntax and usage patterns are slightly different in each language, but they are not unique to Swift. So it's really just a matter of picking up knowledge of language features you weren't previously familiar with. And if you're familiar with a bunch of modern languages, you're good to go. 
Are you aware that the Swift standard library already contains an insertion sort? Look for `_insertionSort` in the following file: https://github.com/apple/swift/blob/master/stdlib/public/core/Sort.swift.gyb When you call `sort` on a mutable collection, this insertion sort is used if the sort range is smaller than 20. I haven't looked at your implementation or the official one in any detail but it might be interesting to see if you come out ahead or behind, and why.
&gt; If you really want them and if you can't find them somewhere else, Multiple sources for the 2015 CS193p vids are on Youtube.
Definitely read this guide made by Apple. https://developer.apple.com/library/ios/referencelibrary/GettingStarted/DevelopiOSAppsSwift/index.html?utm_source=statuscode&amp;utm_medium=email I followed this guide the first week at my new job, I don't think there's a better alternative out there to learn the basic of iOS/Swift programming.
I agree, for certain use cases it seems like an interesting idea. I came across a library yesterday called [CoreGeometry](https://github.com/Pyroh/CoreGeometry/). The library defined a postfix operator ("°") that allowed the user to use degrees( e.g. 180°) to describe angles. I'm not sure if it's easier to type, but I would argue it could make certain chunks of code easier to read.
there is no guarantee firebase will be anything different from Parse
Thanks! The timer doesn't actually work in the background. Instead, when the app is about to end, it sets a notification that pops up when the timer's finished. The code below seems to work, but there could easily be a better way to do it. In my main view controller, I have this (edited for clarity): var washer: LaundryMachine? var dryer: LaundryMachine? override func viewDidLoad() { washer = LaundryMachine(name: "washer", startButton: startButtons[0], stopButton: stopButtons[0], timeDisplayLabel: timeLabels[0]) dryer = LaundryMachine(name: "dryer", startButton: startButtons[1], stopButton: stopButtons[1], timeDisplayLabel: timeLabels[1]) let appDelegate = UIApplication.sharedApplication().delegate as! AppDelegate appDelegate.washer = washer appDelegate.dryer = dryer } Then, in AppDelegate, I make it so that it can look into the view controller: var washer: LaundryMachine? var dryer: LaundryMachine? When the app's about to be closed, I see if there is any remaining time : func applicationWillResignActive(application: UIApplication) { if let washerTime = washer!.getRemainingTime() { scheduleLocal(washerTime) } if let dryerTime = dryer!.getRemainingTime() { scheduleLocal(dryerTime) } } .... func scheduleLocal(timeRemaining: NSTimeInterval) { guard let settings = UIApplication.sharedApplication().currentUserNotificationSettings() else { return } if settings.types == .None { let ac = UIAlertController(title: "Can't schedule", message: "Either we don't have permission to schedule notifications, or we haven't asked yet.", preferredStyle: .Alert) ac.addAction(UIAlertAction(title: "OK", style: .Default, handler: nil)) return } let notification = UILocalNotification() notification.fireDate = NSDate(timeIntervalSinceNow: timeRemaining) notification.alertBody = "Laundry's done!" notification.alertAction = "stop the alarm" notification.soundName = UILocalNotificationDefaultSoundName UIApplication.sharedApplication().scheduleLocalNotification(notification) } I hope that's helpful.
Could I PM you with some questions regarding app development, /u/MrMaverick82 ?
Hmm. Driver? Show me how you would toggle a gpio using Swift.
Coursera has an intro class for swift. Itbuses playgrounds in xcode on Mac but you could do the non iOS GUI stuff on any Swift environment.
Well, [here's how in JavaScript](https://github.com/Soarez/node-wiring-pi). :P Either way though, it wouldn't actually actually prove anything. The question is whether the language is capable of producing compiled code that can runs even in minimalistic environments such as a GPU kernel. Given that, it's just a matter of mapping calls within that language down to the hardware ABI.
Hey man. Sorry, but /r/Swift isn't just a dumping ground for your links. It's fine if you'd like to start participating in other ways, but in the meantime we gotta treat this like the spam that it is. More Info: https://reddit.com/wiki/selfpromotion Regards, 5HT-2a
Remember that the reason UITableView and UICollectionView exist is to re-use cells. So let them do their job. Otherwise, you might as well not bother with a table view, and just put subviews in a view. If you know the different combinations of labels, textfields, and controls, you can pre-create subclasses for each kind you'll ever need, register them in the controller, and just ask for what you need in cellForRowAtIndexPath. If you don't know in advance, you can construct a reuse identifier like, in your two examples: "1L1T1B" and "1L1I", create a standard cell with that re-use identifier (if it doesn't already exist), add the subviews to its contentview, and fill it out. Next time you need one like that, call dequeue with the identifier, and it will hand it to you. In either case, you flow data into the subviews, and adjust the layout if you need to.
I feel like you're making a good argument against overusing custom operators, rather than against using them at all. Like, if custom operators are such a bad idea, then why does Swift have operators at all? After all, you could just have vanilla functions for everything, and it would work just fine. However, as /u/ElvishJerricco pointed out, humans seem to find operators more readable: add(divide(1, add(5, 2)), multiply(4, 6)) 1 / (5+2) + 4*6 So sometimes they make sense. It's a case of knowing when and where to use them. An exponentiation operator seems pretty sensible to me, for instance: infix operator ** { associativity right precedence 160 } func **(lhs: Int, rhs: Int) -&gt; Int { return (0..&lt;rhs).reduce(1) { (n,_) in n * lhs } } 3 ** 2 == 9 But it isn't in the Swift standard library. Does that make the above bad code? Of course not! (other than the dog-slow implementation, but you know what I mean) The right-composition operator, also: `&gt;&gt;` in F#, or `&gt;&gt;&gt;` (from Control.Arrow, although its definition is technically a little different) in Haskell, makes *tons* of sense to me. It changes code that looks like this: func reverseLines(text): return joinLines(reverse(splitLines(toString(text)))) into code like this: let reverseLines = toString &gt;&gt;&gt; splitLines &gt;&gt;&gt; reverse &gt;&gt;&gt; joinLines With any abstraction in programming, there's going to be a cost in learning about it and understanding it. With operators, though, I think it's pretty clear that the cost is *well* payed for by the benefits. As an aside, I think that using operators for mutating functions is iffy, and defining an operator to be used as both prefix, postfix, and infix is downright bad practice. 
I wouldn't be surprised if there ends up being some sort of language subsetting going on to support that. I know the Swift team has publicly mentioned they're opposed to dialects, but I just don't see how to deal with things like assuming a memory allocator, or assuming ICU.
Doesn't have much to do with Swift, but WOW!
[There's an implementation for the composition operator (using a unicode ring) in the "experimental" section of the Swift repo on github](https://github.com/apple/swift/blob/master/stdlib/internal/SwiftExperimental/SwiftExperimental.swift#L42-L44). There's a bunch of other out-there operators there, too.
meow
Interesting. Did not know that.
Dragging more than 1 seems to crash the simulator.
Holy game changer!!
c written in swift is just as fast if done right, and can sometimes be faster because the compiler can better reason about swift code.
Regardless, writing C in Swift is just a pain in the ass. It's better just to use something built for the job like C or Rust
Works fine here https://gfycat.com/PinkCreativeAmericanlobster
Well, it's less of a pain in the ass if you only use "c in swift" in the laces where performance is really important.
It is part of the [getting started] (https://developer.apple.com/library/ios/referencelibrary/GettingStarted/DevelopiOSAppsSwift/Lesson4.html#//apple_ref/doc/uid/TP40015214-CH6-SW1) for swift. **To add images to Simulator** 1. If necessary, run your app in Simulator. 2. On your computer, select the images you want to add. 3. Drag and drop the images into Simulator.
Woah. Never saw this
Maurandk is a witch! Burn them!
You wouldn't be writing C in Swift. To do so would be asinine. You would write the OS in Swift and be far better off in the long run. I'm not sure how this thought got crammed into your mind, but writing an OS in Swift is entirely possible.
An OS is mostly low level hardware interactions. This is not something swift is tailored to. Writing this kind of code would be very much like writing C in Swift, because you'd be writing code that directly interacts with memory, which is cumbersome to do in Swift, and is little to no safer than in C. You just incur a huge amount of boilerplate for no good reason.
Interesting. Crashes for me every time on 9.2.
Come on, when I browse through the Linux kernel source code I have to actually look through a lot of code before I see any hardware stuff. Quite a lot of it is pretty regular computer science algorithms and data structures. Yeah sure the hardware close stuff would be easier in C, but you could in principle write that in C and write the rest in Swift. That is what is good with Swift, since it doesn't have garbage collection and understands C ABI you can mix it with a kernel. Much harder to do that with something like C# or Java.
Those are cs106a, cs106b, and cs107. I asked specifically about **cs108**.
That's true. However, manipulating memory is less hard than you think it is. The whole Unsafe(Mutable)?(Buffer)?Pointer thing is actually a lot simpler and more "swifty" than you would expect (for example, allocating is done automatically, you just have to say how much).
Is that a Suðurlandish cat?? It looks quite much like it's a cat of the east-Mývatn breed! But this sure is awesome!
This also works for videos. You can automate this using `xcrun simctl addphoto` command
Sounds like you might benefit from a basic programming course before diving into iOS development with swift. Something like http://learnpythonthehardway.org
I looked to see if Stanford offered their CS108 Object Oriented Programming class on iTunes U, but had no luck. The only class I saw was from Liberty, but it doesn't seem overly recent or thorough. Anyone else have any tips? I'm just starting to learn Swift myself, but was able to understand the first Stanford course from some (extremely) previous experience with programming. Plus, I took a course on Lynda that had me build a calculator, so it prepped me for Stanford, though Stanford's way is definitely more advanced.
This is how I felt too. Although the first class + homework was the most fun I've had programming so far! Paul Hegarty is awesome :)
Wait... what was the homework?
There's a file called Programming: Project 1 and Reading: Project 1 in the iTunesU course.
Holy SMOKES. Thanks for sharing
I only see the slides and the video... What am I missing? ;o
I believe most of courses / guides for swift assume at least basic understanding of programming and concepts like oop. You should probably start with basic programming first. Perhaps start with Java course, since it's also a typed language. You could start with Python or JavaScript but both are dynamic language and are quite different from swift. C# is a good choice too.
Maybe /r/iosdev would be more fitting ;)
Why don't you give www.teamtreehouse.com a try?
Alternatively, can you provide a good reason for using semicolons? "I forget what language I'm in" seems like a weak reason.
Think that works
I wrote a library for doing segues that integrates well with R.swift: [SegueManager](https://github.com/tomlokhorst/SegueManager#typed-segues-with-rswift) With R.swift, it's very easy change the destination view controller in a type safe way.
Really wow thanx 
Oh please. Really?!? WTF?! No. To *anyone who thinks code should be (or more importantly, always will be) "formatted"*: if you can't live without color formatting of key words, as someone who's been programming for a long time, **you are not competent in talent, skill or temperament to ever be employed, hired or be deemed a professional programmer**. You simply are too delicate a snowflake to be of any use in the profession! Please, fuck off! This makes me realize this is an excellent new interview question: present prospect with code that is merely formatted in courier and b&amp;w - if they balk, t's an automatic end of interview! /u/MyNameIsNotJeff, do not sweat it!! Edit: showed this post to my start-up partner. His response to the "snowflakes": * IDEs are a privilege, not a right! * People who espouse such drivel should be punished by being required to use only punchcards for programming for a year
1. Great tip! 2. This is nothing to do with the Swift language. 3. It's *not an emulator*, it's a *simulator*. There is a difference: It's the user space part of iOS running as an Application on the OS-X kernel and is not emulating the iPhone hardware. The Android Emulator *does* emulate hardware, which is why it's significantly slower but arguably more accurate.
Has anyone taken the prerequisites for the course (i.e., Programming Methodologies, Programming Abstractions)?
I have zero knowledge here, but have you tried using a negative value for rate? 
I did. The problem here is simply translating the Obj-C code to Swift doesn't work as expected, there is some CFunctionPointers I have to deal with and older Swift implementations didn't have to do that.
Hoping for \#segue (or something of the sort) similar to \#selector. 
the only time you do need semicolons in swift is if you have multiple statements on the same line. Since the deprecation of C-style for loops, I haven't come across a scenario where it's needed.
It is possible to to use just Swift and asm but I wouldn't recommend it :) Ive been having a go at writing one (https://github.com/spevans/swift-project1) but you will still need a fair bit of C because Swift's stdlib relies on libc (and libc++) for malloc/free, stdio, and pthreads amongst other things. You can remove some parts from stdlib (I removed floating point and maths so that I could stop using SSE instructions) however your biggest problem will be malloc/free which is used all the time by Swift so unless you can write it in Swift using just pointers you will have to do it in C (which is what I did) Swift has raw pointers so can handle direct memory access, setting up page tables etc and it integrates with C much better than most languages, so its easy to add functions that wrap specific assembly instructions (e.g. loading a CR register etc). However you will still need to write exception and interrupt handlers in asm although you can easy call Swift functions from there Stdlib is also quite a large blob to link into your kernel however it could be reduced down by eliminating functionality but the nice thing about Swift is having everything available e.g. collections etc. I actually have it booting up on my macbook but I currently need to implement all of pthreads so that I can get tasks working but will be the next main chunk Swift is definitely a nice language to write in however Im using swift 3 and the constant changes can be a bit of a pain to keep up with however it is a good learning experience and will be a nice long term side project 
Look up the swift-evolution mailing list, people discuss lots of topics regarding the future of the language. If you have a Mac, there's an app called Hirundo with which you can browse the Swift mailing lists pretty easily.
So what would you recommend I do to fix it? Merge the two documents? Because I had an error from that last time I tried
Semicolons are a common language misfeature. The common case is that one statement is written as one line, and the uncommon case is that a statement spreads over multiple lines. Therefore, it is logical that by default statements are terminated by the end of the line and that a special character is used to allow statements longer than one line long. The only language that should have had mandatory semicolons (but as a misfeature has optional semicolons) is JavaScript, and that is because JS is used on the web, where whitespace is insignificant and both Windows style /r/n and Unix style /n line breaks are used. For languages like Swift that are used on fixed platforms, mandatory semicolons makes no sense whatsoever. 
pretty early on in that tutorial it says "Since we have deleted the View Controller from the Storyboard we can also delete the ViewController.swift file" so yeah get rid of that. all your code should be in your custom class. When i walked through the tutorial just now and ran it it complied fine but as you originally said there was nothing there. With the view controller selected I went to the Identity Inspector and changed the Class to my custom class (in my case "TableViewController", yours seems to be called "TableIndex") and then it worked fine. Not sure if they didn't mention changing the Class in the tutorial or if we both just skipped over that part by mistake. Give that a try though.
http://web.stanford.edu/class/cs108/
What are you talking to? Do you have a spec or something for the device your'e writing to? Are you sure it's the string 1 or the string 0 rather than just a value of 1 or 0? Also you may need to consider byte order. Also why enable notifications? Probably doesn't matter, but that might be messing it up.
Thanks for trying to help. But PowerPoint slides and handouts aren't really enough. You need the lecture, at least the audio.
So, do I delete ViewController and use TVC.swift (my custom file)? So, here's my code for the ViewController Swift file: import UIKit class TableViewController: UITableViewController { struct Objects { var sectionName : String! var sectionObjects : [String!] } var objectsArray = [Objects]() override func viewDidLoad() { super.viewDidLoad() objectsArray = [Objects(sectionName: "A", sectionObjects: ["Example for Reddit to shorten code"])] } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. } override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell { var cell = tableView.dequeueReusableCellWithIdentifier("Cell") as! UITableViewCell! cell.textLabel?.text = objectsArray[indexPath.section].sectionObjects[indexPath.row] return cell } override func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return objectsArray[section].sectionObjects.count } override func numberOfSectionsInTableView(tableView: UITableView) -&gt; Int { return objectsArray.count } override func tableView(tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? { return objectsArray[section].sectionName } } 
This is the problem I'm having. I might go through Stanford SEE first for now.
You can't. But you can make 'currentNode' an optional with default value of 'nil' and at the beggining of your function do something like this: 'let currentNode = currentNode ?? root'
No such luck, here.
Unfortunately, this is the only way to do it (besides making another function without that argument that calls this function).
There are several problems here. One:`bool` is a constant, meaning you can't change it. You could make it a normal variable by putting `var` before the declaration of it but that still wouldn't fix your problem because.... Two: Bool is a struct, meaning it is passed by value rather than reference. Thus, the bools you're using in the function don't reference the same bools you're passing in. They only have the same value. This could be fixed by making the parameter `inout`, meaning the value would be passed into the function, changed inside the function, then passed back out to replace the original variable, but you can't do that with the variadic (`...`) marking. I guess you'll just have to do it manually, I can't think of any way else.
Please do not change the name, its a good fitting name. A quick research on github shows over 4000 Repos starting with core And i really like coregeometry and will sure use it, many thanks for that!
 func peripheral(peripheral: CBPeripheral, didWriteValueForCharacteristic characteristic: CBCharacteristic, error: NSError?) { print("didWriteValueForCharacteristic \(characteristic.UUID) error = \(error)"); } When I hit the 'On' button on my phone to send the string value of "1" I receive the "sent" message on the xCode terminal window but I don't receive the message should be printed by **didWriteValueForCharacteristic** delegate. Does that mean it is not sent, or this delegate runs when there is an error with writing the value? I believe it should print **didWriteValueForCharacteristic FFF1 error = nil**
I realised that when I print the value I send by the following code print("Sent: \(data)") where data is let data: NSData = "0".dataUsingEncoding(NSUTF8StringEncoding)! I get the following response on the terminal for "0" and "1" respectively `Sent: &lt;30&gt;` `Sent: &lt;31&gt;` So probably the value I am sending is neither "0" nor "1", instead they are the corresponding hexadecimal values
[removed]
Found the solution to my problem Changing the `CBCharacteristicWriteType.WithoutResponse` to `CBCharacteristicWriteType.WithResponse` inside the peripheral!.writeValue(data, forCharacteristic: characteristics, type: CBCharacteristicWriteType.WithResponse) solved my problem. Now I still send the same data which is let data: NSData = "1".dataUsingEncoding(NSUTF8StringEncoding)! And doing so also enabled the response from didWriteValueForCharacteristic delegate. As far as I read from [Apple's documentation](https://developer.apple.com/library/ios/documentation/CoreBluetooth/Reference/CBPeripheral_Class/#//apple_ref/doc/c_ref/CBCharacteristicWriteType) difference between `CBCharacteristicWriteType.WithoutResponse` and `CBCharacteristicWriteType.WithResponse` is whether getting a response from the peripheral regarding the success of the writeValue action. So, either way it should be sending the value if there is no error but I will not be notified if it was delivered or not, but either way it should be delivered if there is no problem. This is a bit confusing. Appreciate if someone can clarify it.
Change bools from let to var
That's deprecated though. Was really looking for a Swift 3.0-allowed solution :(
Excellent. Thank you. On a side note, is COBOL the goto language for base-level machine programming?
I think Assembly is more base-level
Oh I see, you're looking to modify the bool array that's passed in. In that case, use inout
I don't know what I'm talking about.
&gt; Monads are about taking stupid dumb functions that don't have any clue about containers and applying those functions to the values inside the containers while preserving the containers in the result. That's not Monads at all. That's Functors. The functions you use with Monads care very much about the containers, because the container is in the return type of the function. Anyway, I think you're falling prey to [The Monad Tutorial Fallacy](https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/). Feel free to add to [The Monad Tutorials Timeline](https://wiki.haskell.org/Monad_tutorials_timeline) =P. Your examples display some neat capabilities of Optionals in particular, but you didn't really expand to the full scope of what `Monad` is, why it's significant, or what you can do with `Monad`. I think you would need a few more examples. For instance, how on earth can a parser be seen as a monad using your description? It's not a container, it's not wrapping anything. But sure enough, [context-sensitive parsers are in fact monads](http://www.cs.nott.ac.uk/~pszgmh/pearl.pdf). The point being, you haven't fully captured the scope of what `Monad` really means, and thus their usefulness isn't really seen. You used the template: "X is just the ability to call Y. That's it." But that isn't *it*. That's not explaining the significance of that ability, how it abstracts, or why it's useful. I've had the most success explaining `Monad` as an abstraction over imperative programming, using functional programming. The idea is that every `flatMap` acts sort of like a single statement in an imperative language. You're taking the value from the previous statement, and doing some action with it. In terms of parsers, a statement is taking the result of parsing input with one parser, and using that to figure out a new parsing rule. One rule at a time, you imperatively develop a final parser. Or in terms of `Optional`, you're just writing an imperative function where you can safely ignore the possibility of `nil`, because the `Monad` is thinking about that for you. I think the best thing about this explanation is that it's easy to see how it abstracts, and how that might be useful. Knowing that Monads are just imperative programming, you can write a function that doesn't care what Monad it's using, but does some imperative task in that Monad. `sequence` is a pretty good example. Since Swift doesn't have higher kinded types, I'll use Haskell sequence :: Monad m =&gt; [m a] -&gt; m [a] sequence [] = return [] sequence (ma:ms) = do a &lt;- ma as &lt;- sequence ms return (a:as) `sequence` is doing this extremely imperative-style computation; calculate `a`, then calculate `as`, then do something with them both; but it doesn't care about what `Monad` it's using. *Any* `Monad` enables this sort of imperative programming. And I think that's sort of the essence of what Monads do in programming. They give you a context to do imperative programming in. **EDIT**: Just for fun, I'll provide a counter-example for myself, just to prove how hard it is to develop a good explanation of Monads =P. With ~~[extensible effects](http://okmij.org/ftp/Haskell/extensible/index.html#lazy-state)~~ the [Tardis monad](https://hackage.haskell.org/package/tardis-0.3.0.0) it's entirely possible to create a time-traveling state Monad. That is, every time you try to `get` the state, you will be given the value that is `put` next, seemingly going forward in time to get that value. x = do put 1 s &lt;- get -- s is 2 put 2 Naturally, this can lead to some really weird recursion, and if you're not careful, is likely to go infinite. But the point is, this code sort of breaks my explanation of Monads. Not entirely; it's still being written in an imperative style. But it's breaking the spirit of what imperative programming is, by time traveling to the next statement.
That was the easy part. Now try getting a hotel that isn't $1000/night or in a crack den or both. Then try walking from your hotel to the Moscone center without slipping on human feces or going bankrupt from buying a drip coffee and a local-sourced bespoke artisan organic vegan gluten-free doughnut. 
You can do it by passing in an inout array and creating that array implicitly when calling like this: setAsTrue([x, y, z]) That being said, this is silly and its better to just do it manually. 
Ah well, was worth a try, thanks. 
WELCOME TO SF. Honestly, i would get a hotel on the peninsula and take the cal train in. Its a quick walk. I live in mountain view, CA if you need advise 
yeah i was able to infer what TVC.swift stands for; my point was that you're making up names that differ from those in the tutorial. if you're doing a longer tutorial you may forget what you decided to name a particular class or something, and its just much less error-prone if you follow the naming conventions used in the tutorial.
I lived in SF for years. I was trying to clue in anyone who hasn't been before ;)
I noticed that you weren't specifically doing anything with the init's you were making, except towards the end where you were providing default values for certain parameters. You can always omit the custom initializer because those get auto-generated for structs! Unless you were leaving them there for visualization needs, then right on. 
The Tardis Monad doesn't break your explanation at all. If anything, it demonstrates the power of monads in a lazy language. In Swift, trying to replicate such a thing is impossible because earlier let-bindings cannot depend on future let bindings [and because it would blow up, but you can just encode laziness back into things by parametrizing over the Lazy monad]. It's all about the flow of control. In a Lazy language, control flow passes to that next expression yielding a value that we need. (One way of looking at) A monad is a way of structuring that flow in an imperative style, but crucially a Monad is intimately related to CPS computations. With that in mind, it makes sense you could invent something like the Tardis Monad, you just ask your computation to yield the results of continuing one step further, then hook up "the past" state rather than the future one you requested. In a sense, you always look back, but what the user sees is you looking forward.
You know how the Stanford course (CS193P) says that before you do it you need significant previous programming experience and an understanding of object oriented design? How it says that if you dont have that background, you need to do a couple of other Stanford courses first, as pre requisites? That. 1000 times that. First do CS106A (Programming fundamentals using Java) Do not be put off by the age of the videos, they are just as relevant today and the professor is brilliant, enthusiastic and humorous. There are a few other alternative courses suggested to 106A. Dont do those, they use C++. Java is easier to pick up OOD fundamentals with and its a better beginners language, and its infinitely easier to run because it is not compiled the way C++ is. Java is not an ideal beginners language either, but its far better than C++. Follow that course up with: CS108 (Object Oriented Systems Design using Java). THEN do CS193P (the Swift based course). BTW, if you think you are apparently learning Java, no, you are learning how to program and THAT is the mountain, not the language. Java is just a tool you use for that purpose. Just as how Shakespeare did not use Microsoft Word but could seamlessly transition to using it in a few days if he came back to life today, so you will be able to transition to Swift once you have the background you need. 
You leave the vegan donuts alone goddammit. If you're near a Philz, try the Pepples 👌
Actually, the array isn't even important. It's what's inside it that is, which will be Boolean properties of reference types. So I'm not even sure how to go about representing them in the function. Basically I want to lazily set a bunch of Boolean properties to some other Boolean value (whether their opposite or a chosen bool value). Was hoping syntax like `view.hidden, button.selected, constraint.active = false` was available, but I can see why it actually wouldn't anyway. 
thank you! i discovered your library yesterday and wanted to use it for some gesture recognition, nice work!
Congrats!
While Assembly is definitely the most base-level language, I think you should almost always write in C rather than anything lower. C can do most low level tasks, usually as fast or faster than hand-written assembly (compilers are geniuses about optimization). Considering C is way more human readable, with a huge ecosystem of tools, documentation, libraries, and support, it's almost always going to be the better choice. Plus, C is more portable than any assembly language. That is, most C will compile on most processors; whereas most assembly is likely not to compile for a different processor.
What is something like the user interface of a digital camera or Garmin GPS written in? Would C work all the way to the bottom to operating with the different transistors and such on the circuit board of those things or is Assembly (or another language) required. 
Pepples is actually pretty legit. The owner in particular is really nice along with their salted caramel doughnut. 
Be more specific, do you mean a simple nested todo/bullet point list? Then yes this trivial to make. If you mean a step-by-step interactive tutorial then yes as well but this will require more work 
Not the tutorial. Just the actual application itself. Nested bullet points, tags, contexts, drop down menus, ability to search. 
And maybe even the ability to drag and drop small images (JPG or PNG) into bullet points. And when you click those small images (thumbnails really, you see a bigger version.)
It is indeed possible
What about small images within collapsable lists? 
Swift is a fully featured language and there are a ton rich APIs to work with on iOS, loading thumbnails, dragging and dropping, etc are all possible
Another example: Say you want to make your own HUD for your vehicle sort of like this one: https://www.navdy.com/#video 
Depends entirely on how its built. But most likely, it could all be done in C. Here's the configuration that comes off the top of my head. There's a central processor to which the GPS, camera, and receiver are all attached via some electrical interface. The processor should provide instructions for interacting with that electrical interface. If the manufacturer was particularly nice, they'll also have functions usable from C for interacting. If not, such functions would be trivial to write using either an assembly binding, or by using C to manually write to certain memory addresses (many hardware IO things are done just by reading and writing memory. Depends on the system). Either way, you'd end up with some sort of C interface to the electrical interface. Once you have the C interface, you can start writing a program using just C that will take input from the devices, do some processing, and output data to the devices. So at this point you simply need to know how the interface works, and what the program needs to do with that interface. Then you can do it all in C. Or, as I mentioned above, you can do it in an embedded language like Lua. This option is particularly nice because writing C can be a major pain in the ass, and it can be really hard to master the kinds of things that can go wrong with C. Something like Lua, however, makes it easy to write programs, and is harder to mess up.
Makes sense. Which is why along with the processor you also need a memory medium to store the actual instructions on. 
Exactly! =)
You've loaded a plist into an NSDictionary. The debug output of NSDict uses curlies to indicate dictionary, their objc literal is = @{ ... } import Foundation let plist:NSDictionary = [ NSString(string: "node1") : [ NSString(string: "inner"): NSString(string: "nested") ] ] print(plist) { node1 = { inner = nested; }; } Edit to add: You should be able to treat them as swift dicts due to toll free bridging.
Remember that when you call 'print' function on an object you're watching its representation and not the object itself. As you could notice, the representation of a Dictionary it's not it's constructor. Let's try to print(["foo": "bar", "foobar": 42]) and watch what I mean 
How could you tell there was an Array (vs a dictionary)? I'm not seeing the differentiator. EDIT: I think I'm seeing the difference (objects have key values with equal signs instead of colons, arrays are comma separated) one last question: I'm seeing arrays and objects both have curly braces when initializing. What then is the parenthesis here: connections = ( { connectTo = node2; prompt = "Wait to get rescued?"; }, { connectTo = node3; prompt = "Explore the dungeon?"; } );
Correct me if I'm wrong: You're saying this is JSON but it isn't the same as the actual JSON source code? So what I print is similar to JSON but formatted slightly differently than what is actually written in Javascript? Either way, I think I get it now. Thank you so much for your help!
Well yes, it is a programming language and thus turing complete. Additionally the Cocoa frameworks are sufficient.
Yer a wizard foBrowsing.
Not quite, rather than JSON it's deserialised from some XML in info.plist file which is an Apple representation similar to JSON in that it encodes things like key/value dicts, arrays and so on. The deserialisation is being done by the NSDictionary class, which reads the plist and turns it into a bunch of NSStrings, NSNumbers, NSArrays, etc, which are actually ObjC classes. These are 'toll free bridged' into Swift which means that you can treat them as though the dict is of type [String:AnyObject]. But under the hood, they're ObjC's NS* classes, and they use a different notation for their string representation when you print them. So whereas in pure Swift you'd get ["letters":["a","b","c"]] when you dump the ObjC variants you get something like `{ letters = ( a, b, c ); }` It's really just a difference in how the 'description' method is implemented on Swift dictionaries and arrays vs their ObjC counterparts. Hope this helps!
So, as far as I understood if writing without response is not supported by the device, the only option is to use write with response. Assuming you don't change the firmware of the device. Is that correct?
I'm so jealous.
you're shadowing `x` in your loop, the counter of a loop is defined as a `let` IIRC. Unfortunately it doesn't look like `-Wshadow` warns about shadowing in swift code in this case.
Two of my coworkers got tickets! I'm going to apply for a scholarship.
Indeed. OP should read about variable scope.
Try looking at this in the debugger. You can (in theory) explore the various types there.
Ahh, I see. The official pre requisites for CS193P are 106A OR 106B OR 106Z THEN 108. So, yea, after completing 106A you should skip 106B and go on to 108. 106B uses C++, 106Z is accelerated tuition using C++.
Nice solution, but `sumsTo(_:to:)` is not a very nice name for a function, in my opinion. :P Maybe something like func sumsTo(sum: Int, with dice: Int) -&gt; Int is better?
I find that the scala highlighting gets pretty close.
This is an absolute ridiculous advice. Java is riddled with boilerplate and will confuse a beginner much more than necessary. Any beginner should start with a language that has a REPL or similar low barriers of entry. It might not be swift (although the playgrounds feature lends itself nicely to beginners), but is sure as hell shouldn't be Java. If JVM support and Android development is a goal, Scala or even Kotlin would be better alternatives. But probably one should start with a language designed for beginners. 
Java actually copied Objective-C back in the 80's/90's when Sun and NeXT were partners (although not syntax-wise).
This was not a well received comment, but isn't altogether wrong (or, in other words, I'm prepared to join you at the bottom). Here's why I agree with you: If you are relying on your IDE of choice telling you there's a problem by having code coloring or other formatting be "off," then you don't yet understand what it is you're trying to do. That's fine for a novice or someone trying to learn, but a sign of a more competent developer would be to know this on their own and not rely on their tools. You should know instinctively that a variable name is on the left of an equal sign, and not because it's blue, or that strings are strings because they're being a pair of quotes, not because of the color. Formatted code is a nice to have, but not a requirement for being a developer. I wouldn't be opposed to hiring someone who relied on colorized or nicely formatted code, but they're coming in as a junior, and need to get a few notches in their belt before they get real commit access. And by the way, this isn't limited to Swift. 
No ads in /r/Swift, please. Note the banner for /r/SwiftJobs, as that is the appropriate venue,
Can you explain what the .lazy keyword is doing here?
Any chance of the book being updated with coverage on UnsafePointer, UnsafeMutablePointer, withUnsafePointer and the like?
I don't see why not – I'll add it to the list!
Any formatting tips for posting these things to Reddit are welcome as well. :P
Certifications for ANYTHING are only ever possible for a **late-adoption, non-bleeding edge technology**. When a technology is well established and old, is when certifications make sense - you no longer have early adopters primarily using but instead have the hoi polloi who can't be trusted to have the natural curiosity, skill and intention to be qualified on their own accord - thus you must test them to a well-defined standard. That's what "certifications" are all about. Swift definitely not this (yet).
Not too sure if this is the case, but it looks like you have a IB connection to an invalid keyValue. In your storyboard or Xib file right click on your FoodTracker.ViewController object and you should see a yellow warning symbol on the connection for setDefaultLabelText. You can click the X to remove the connection and re-connect to the properly named IBAction. It could be that the IBAction connected has been renamed or removed from your ViewController, which would cause this runtime exception.
This is a great idea, and is something I think the swift-evolution list would be amenable to discussing. There are a couple of other proposals in the pipeline aimed towards making C interop less painful. 
gist.github.com just put it there, post the link. It's make life so much easier
You do know that PDF is Postscript is a programming language...?
Perhaps PSPDFKit?
Wow, that's a bit more complicated than I initially imagined, haha. I had to read it a few times. Thanks for the insight!
I see. So the current default security rules allow everyone to read and write from my database. Is that correct?
Maybe CGPDFScanner might be a good start. BTW, I googled "parse PDF iOS swift" and got some answers. Next time you want might want to start with something like that.
I have done this with the standard Apple libraries for PDF in Swift and it worked perfectly (finding strings and modifying PDF) it was a simple example but worked well let me know if you'd like the playground
This website, although retired, has been updated to the current course (iOS 9, Xcode 7.3). There's hope that it will be updated with downloadable PDFs of assignments and demos eventually. http://web.stanford.edu/class/cs193p/cgi-bin/drupal/
So, I merged the two files, and while it runs, there's still no Index on the side. I think it's because only one line of functions can be returned, and I have two lines of code when merged. Here's what I'm talking about: override func numberOfSectionsInTableView(tableView: UITableView) -&gt; Int { return objectsArray.count return indexOfNumbers.count } override func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return objectsArray[section].sectionObjects.count return 1 } I think once these can be fixed, everything should work perfectly fine. How can I return both values in one line? Thanks!
My advice is to use a game engine like Unity. Collision is an incredibly difficult problem, and you'd be much better off spending your time thinking about game design rather than physics programming.
For one thing your db variable is an optional and you haven't unwrapped it. You initialised it `let db = try? ...` so you'll need ? or ! on subsequent uses as you've done earlier in your code. But that's not your problem. It's `for yourTable in ... prepare(yourTable)` that's doing you in. That's equivalent to saying `let x = double(x)` before you assign a value to x. The for loop introduced its own scope. Change the first yourTable to just table.
It's easy to do this using the `color` and `colorBlendFactor` properties of `SKSpriteNode`. I wrote about this in [project 20 of Hacking with Swift](https://www.hackingwithswift.com/read/20/2/ready-aim-fire-nstimer-followpath) – search for those properties on that page to see them in action.
Wow, thank you!
yes
I agree it should be done but it would be much harder than `NSError**` conversion. The problem is that a C function returning an `Int32` isn't guaranteed to be an error result (unlike an `NSError**` parameter named `error` on a function returning `id` or `Bool`). And even when it *is* used to represent an error, is the error `&lt;1`, is it `==0`, is it `!=0`, is it `&lt;1`? You wouldn't be able to do it automatically. You'd need a compiler attribute applied on import to Swift and manual auditing. Something like `@cerrno(lessthanzero)`.
Include "playground" in your Google searches. Theres plenty of tutorials that make good use of Xcode's playground. [Swifty](https://hellocode.io/swifty/)
I'd like to see how you did that. Because that's impressive sounding, I've had to work with PDFs and it's never been fun.
Or you can try out sprite kit and/or scene kit.
http://codingame.com supports swift and has tons of puzzles at all difficulties. You code right in the browser and test it against automated tests. When your solution passes all the visible tests you submit for a run against the hidden conformance tests. If it passes those too you have solved the puzzle. When you solve a puzzle you can view other published (optional) solutions in the same language. It would be great to have more swift solutions posted on the site. Also http://adventofcode.com/ came out in December 2015 and had challenges that could be solved in any language. You download text input and find a solution through whatever means possible and then submit the answer back to the site. I had an Xcode command line project in Swift which I used to solve the ones I did. There's no competition and/or social aspect to it though. Just for your own benefit.
Apologies it this has already been posted.
Have you done the Plymouth University class? I'm going through it and I've run into a problem with Single View Application Step 2 - common layout. In the video he shows how to put multiple graphics in so that when you use different views it picks the appropriate graphics. No matter what I do though it always puts the same graphic in.
Thanks all! I got started on Hackerrank. Exactly what I was looking for. 
I think this is a pretty good reason.
That doesn't actually shadow though, since it's the same variable.
When CoreBluetooth was released, you could get it working in Simulator using additional BLE USB dongle, but I think they scraped that in the very next SDK release a year later. One thing you can do is test your CoreBluetooth code in a Mac target since it's available on OS X as well.
You can use an extension to NSUsersDefault as explained [here](http://stackoverflow.com/questions/1275662/saving-uicolor-to-and-loading-from-nsuserdefaults) : extension NSUserDefaults { func colorForKey(key: String) -&gt; UIColor? { var color: UIColor? if let colorData = dataForKey(key) { color = NSKeyedUnarchiver.unarchiveObjectWithData(colorData) as? UIColor } return color } func setColor(color: UIColor?, forKey key: String) { var colorData: NSData? if let color = color { colorData = NSKeyedArchiver.archivedDataWithRootObject(color) } setObject(colorData, forKey: key) } } To save your color in your code : NSUserDefaults.standardUserDefaults().setColor(UIColor.whiteColor(), forKey: "white") then if you want your backgroundColor to be load when the view appears you can call this in your viewWillAppear() if let whiteColor = NSUserDefaults.standardUserDefaults().colorForKey("white") { self.view.backgroundColor = whiteColor } else { // You didn't saved a color before do something else }
Thanks for the reply. Makes sense but I guess I was expecting Swift to be a bit more intuitive with things like that. Although it might seem that it is with more practice. I need to loop through and check things and then just replace one object. I just changed all in the example for simplicity. But that's a slick way of doing it. 
[Here is one where you create a simple calculator](https://www.youtube.com/watch?v=ExB64WVemFA)
You should use forEach() instead of map() when you're not using the result of map(). Map() is for transforming one sequence into another.
Try one of these! https://github.com/tastejs/awesome-app-ideas
Awesome! Thanks
You've been caught out by the `for var .. in` syntax. I believe the ability to declare mutable loop variables may actually be going away with Swift 3, maybe for this reason. Ditch the `var`; you should just write `for object in arrayOfTry`. Your original function never touches the array: func changeArray() { let changeObject = tryToChangeMe() changeObject.stubbornArgument = "change please?" for var object in arrayOfTry{ // &lt;--- declares new, mutable loop variable 'object' object = changeObject // &lt;--- repeatedly sets 'object', never touching the array } } But the one that uses 'enumerate' does func letsTryThisAgain(){ let changeObject = tryToChangeMe() changeObject.stubbornArgument = "change now, dammit" for (index,_) in arrayOfTry.enumerate(){ // &lt;--- aside: this is how you do it; no var arrayOfTry[index] = changeObject // &lt;--- modifies array } }
Sure, but it's a subset of normal shadowing is all I'm saying. Shadowing that doesn't shadow away the previous value is much more evil.
I agree with u/pavr that you should leverage a TableView. With UITableView you get a lot of behavior out of the box with regards to cell actions (delete), reordering, refresh and more. Beyond that, your work won't be a throwaway if you decide to move to a CollectionView later. I assume you mean programmatically vs storyboard. That's all a matter of opinion. I personally don't use interface builder for anything. I don't agree that it's less obvious or takes longer. If you're making good use of constraints, code based interface is quite easy. If you do decide to go the code route, use something like SnapKit to simplify the effort.
for simplest cases in cells like you have only one label or something go for table view, for all of other cases go for collection view, it is just a better uikit element with has many different attributes for design, and other things, much more flexibility.
raywenderlich.com look for ios/swift apprentice, one of the best beginner source. 
What's it called?
Swiftybeaver
There is a great app on github for WWDC videos with full-transcript search https://github.com/insidegui/WWDC
the main thing is that it won't stop circling.
I don't think this is related to swift. They just happen to call their system SWIFT.
CollectionView is much more customizable (animations, different layouts) and can be used if you ever want to change to a grid layout or horizontal layout for iPad interface. However if you go with collection view you will lose some of the built in table view features like swipe to delete and rearrange cell. Either way will probably work for your case. There are lots of great collectionview sessions during that last few WWDCs, look them up. 
You should only use one question mark or you'll generate a help compiler error: Initialization of second question was never used, consider replacing with "!?"
IIRC it's also possible just to do `classOrObject.methodName(argumentValue, [more args]);`, no?
Wrong swift
The only thing I'm looking for is an almost pixel perfect reproduction of an image on Xcode. The rest is almost done.
Not the same but if you've never traveled internationally or transferred money overseas, it's an easy mistake to make. No harm/no foul.
&gt;If there is no Swift-specific precedent, follow the existing Objective-C precedent. If there is no Objective-C precedent, look for a C precedent. Please don't. If there is no precedent, use your judgement. C style is weighed down by going on for half a century's worth of baggage and arguing and ObjC is the bastard lovechild of a drunken romp between a C compiler and a Smalltalk interpreter one regrettable 80's night in Stratford, Connecticut. And there *is no* Swift precedent. Swift is like 5 minutes old in internet years. Doubt everything, find your own light.
Using your best judgment is always advisable. :) Sorry, I suppose I should have been more clear. This was more in regards to naming conventions. Not an absolute dogma. ([See here for more information on that guideline](https://swift.org/documentation/api-design-guidelines/)) &gt; ObjC is the bastard lovechild of a drunken romp between a C compiler and a Smalltalk interpreter C and Objective-C do have many things left to love ❤️ (even Javascript has _some_ niceties) &gt; And there is no Swift precedent. Swift is like 5 minutes old in internet years. Swift is very new but iOS and OS X development are over two decades old. Swift doesn't exist in a vacuum. As more convention is established it can be adopted. But while Swift is still being figured out, the old ways are likely to be recognizable to the existing Cocoa/CocoaTouch developer base. When working with others, and in doubt, see what fights have been solved in the past. :)
&gt; Right now, I've got 81 identical UIButtons arranged into a 9 x 9 square. This won't work, however, because there is no way to know where they are in relation to each other. (And it's most likely not the most efficient way of doing things.) Have you thought about storing the UIButtons in a 2 dimensional array data structure, and then through a lookup find the (x, y) coordinates of any of the buttons? It may not "feel" efficient, but unless you need dynamic sizes, or plan to deviate from the fundamentals, I would advocate KISS, and just use the array structure until you outgrow. If you abstract the lookup of the button coordinates, the storage mechanism could be altered without affecting other parts of the code. 
My initial thought would be to keep all game-state-data in a two-dimensional array of "BingoSquare" objects. The BingoSquare would have an Int value and a "set" bool. Redraw the board every time the array is modified. Should be simple enough to check the array for Bingos.
can't you set the button.tag value in order from 1..81 map that to an array of Bingo values then check after each press. Use a class or struct. class BingoValue { isPicked: Bool =false number: Int =0 } bingoCard:[BingoValue] = [] 
I'm a little confused about the line: let credentialsProvider = AWSCognitoCredentialsProvider(regionType: .USEast1, identityPoolId: "YOUR_IDENTITY_POOL_ID") Does "YOUR_IDENTITY_POOL_ID" include "us-east-1_XXXXXXX" or would I just use XXXXXXX?
it is as your first example, including us-east-XXXX
Great post, but having code that isn't formatted is not the best to have in there
If it happens while your app is in background, you will get a notification as soon as your app is back to foreground. If it's relaunched completely, you'll set up your views again anyway, so I don't see what the problem is.
From a UX perspective, this is probably a bad idea.
I learned about it and it seems like a decent way to use a global variable for tracking, however it seems highly limited in its use case there it would be far safer to just pass back a copy of the work on return. 
also thank you for answering me
Yes, .last would be better.
Is the second file marked as a member of your build target? When you have the file selected in the navigator, in the right side panel, under the first tab ([see here](http://i.imgur.com/bAwbXuq.png)), look in the Target Membership section. Is your build target checked?
Uhh why is there a carrot T as part of the function name, a comparable keyword before the arguments and why do the arguments have just a type of T? I know binary search and I know a good amount of Swift, but these look alien to me. 
hey thanks, that's a great point - any suggestions on the best way to structure code in a blog post for future tutorials?
That's generics! I bet you'll find a lot of info on it if you use Google, but in this case it basically means that this function is restricted to arrays which elements implement `Comparable`.
Just for knowledge do Ruby also have something like In Out in swift .?
You'll get the first lesson as soon as you enroll, then there will be a few days between each subsequent lesson until we wrap it all up with the Live Q&amp;A at the end.
From what I can tell you're init'ing a monster one time, the remove all actions is in this in init so it only checks if counter is &gt;10 one time if its not its never going to remove all actions, not to mention that you add the action to the monster -after- you call remove all actions. If you want to wait 10 seconds to remove an action I recommend making a sequenece like, monster.runAction(SKAction.sequence([actionMove, SKAction.waitForDuration(10), SKAction.runBlock{monster.removeAllActions}])) So it runs the action, waits for 10 seconds, then removes everything. To be more prescise I recommend using "runAction withKey" so that you can just do monster.removeActionForKey, this way, when your monster gets more complex, you just remove that spinning action, not every action thats running on it. 
Used it early on for a game. `SpriteKit` has a run loop that calls itself repeatedly for you to update your game objects. My central game mechanic is for the user to touch and leave their finger on their screen, and control a sprite changes direction based on the location of your finger on the screen. The way I kept the position of the finger updated is by using `inout` in a method that takes a `CGPoint`. I would constantly call this method in the `touchesMoved:` method of `UIResponder`. Because of the properties of `inout`, changing the parameter within the function doesn't require me to explicitly make assignments. I just change the parameter within the method and it automatically updates the property.
Only for burgers. Actually I use them when I want very clear documentation. Part of what I actually like about ObjC is its verbosity per guidelines. I've spent too many years dealing with other people's poorly written and documented code.
Awesome. Just out of curiosity, what do you get out of it? I'm not used to free things on the internet without a catch.
Why bother with the notifications at all? Just update the views on didBecomeActive.
Huh? It's not like view controllers have direct access to that. You can either use did become active notification which is another notification that doesn't serve the purpose as nicely or you can trigger view update from your app delegate in some crazy way, both are really stupid solutions to a problem that *has* smart solutions.
Thanks! I updated my code to .last
If `fatalError()` provides more useful info than simply crashing from an attempt to force-unwrap a nil value, then I'd still say the `guard let` is the right choice.
Especially if you add `fatalError("here is my reason")`.
Yeah, I mean, say there's six different reasons `thing` could be nil, all of them rare but possible, and all but one fatal. You can check for them and output the right answer with some simple conditionals, warning instead of crashing for the one that isn't necessarily fatal.
I guess you mean you use inouts instead of returning a tuple? I'd probably rather create a struct that returns multiple values if it wasn't clear what was being returned from the method, but either way works.
What's the advantage or point of using the second way
It's useful for properties that cannot be made non nil during initialization, but which will definitely gain a value between initialization and use.
If in your app it is a logical error for that value to be nil at this point. Force unwrap is the most succinct approach to getting the app to inform the developer of a crash in the right place. I don't think fatalError() is going to offer anything more other than make your code more verbose. Obviously if there are varying states for this optional then you should be checking them individually, but in the example given, looks pretty clear that if it is nil, this is a logical error and we should be crashing immediately so the problem can be fixed in code.
I haven't read the guidelines, but I imagine the "don't store it in icloud or share it" applies to data your app reads from HealthKit and not to data you generated yourself and are (partially) writing to HealthKit?
That would be nice. Maybe students that attend the class in Stanford could post that.
Will it work for Linux users?
Xcode, Xcode, Xcode! 
Panic Coda on the iPad Pro with fab to help with build commands and Dash for documentation. I have tried this for a few weeks to see how feasible coding on the iPad is. It's actually pretty rubbish. Would not recommend.
I had nightmares about this after seeing it posted in another iOS-related subreddit. I'm looking forward to round two tonight. 
Xcode and Visual Studio Code. But, Xcode first because it's the only environment so far with a full set of tools for editing and debugging the code. VSCode just provides syntax highlighting at this point (but it has replaced Vim in my toolbox after 25 years).
Are you writing for iOS? I really dislike Xcode and would like to do something similar
Pushing another Collection/table view controller instance on top of the navigation controller for every level that is dived into also works as the most basic/fast implementation that fits commonly understood UX 
It might be better to use an assert statement, then handle the error gracefully in case this code ever makes it to production without hitting your fail condition.
My main tool is a Ducky One with Cherry MX Blue keys. It's like typing on a cloud. 
Why is thing optional if it must exist? Granted it's not not always possible, but in my opinion it's generally better to push the unwrapping/crashing further up call stack where it's closer to the periphery of your system and the actual source of the problem.
wonder whether bash support in windows 10 will allow this 
http://stackoverflow.com/questions/9040319/how-can-i-get-an-nsdate-object-for-today-at-midnight I think that this is what you are looking for, more generally look at what you can do with timestamps. 
The example is obviously contrived to make a point. Real code would very likely be far more complex.
Thanks--that's exactly my concern. I'm wondering specifically about storing some data about the total amount the user has worked out, without having to pull and calculate the number from the individual workouts stored by HealthKit each time. Can i just store that the user has achieved "level 1" "level 2" etc in NSUserDefaults or is this considered sensitive data?
I can vouch for the fact that one of the creators has been involved in running various university courses. She's a former student and later a lab mate of mine.
Love that you're interested in sticking to it. You say you can write basic applications but can't wrap your head around programming? What do you mean by that?
Thanks for the suggest, I will look into getting that! 
I wrote [a bit of Objective-C](https://github.com/mdippery/bucknellbug/blob/master/Source/NSDate%2BRelative.m#L53) to shift a given date to midnight a while back. You could call it from Swift with something like: NSDate().isAfter(NSDate().dateAtMidnight()) (I think; I'm not on a Mac right now so I can't try including that source code file in a project and then calling it via Swift.) If you don't want to include Objective-C, it's only a couple lines of code that are fairly easily rewritten in Swift.
Thank you for the very clear answer! 
The code snippet is fine under Xcode 7.3, and `Dictionary` should have `map(_:)` inherited from `SequenceType` since Swift 2.0. Are you using Xcode 6 which comes with Swift 1.x?
Yeah, I found the guidelines frustratingly vague and I also agree that workout data seems pretty "overprotected." I haven't experienced lag per se but I'm displaying a different main view depending on the level the user has achieved, and it strikes me as really inefficient to have to pull and sum up all the workouts from Healthkit and recalculate this every time, it's fine now as I'm developing it, but in some theoretical user's world with thousands of workouts stored, I can imagine it becoming really slow/cumbersome. 
Thanks – I came up with the following: `var roll4d6 = [Int(arc4random_uniform(6)+1), Int(arc4random_uniform(6)+1), Int(arc4random_uniform(6)+1), Int(arc4random_uniform(6)+1)]` let dropLowest = (roll4d6.minElement()) let rollScore = (roll4d6 - dropLowest) The only error I'm getting now is "Binary operator '-' cannot be applied to operands of type '[Int]' and 'Int?'". I've searched for some answers but I'm afraid I don't yet know enough to understand why those two variables aren't the same type of integer. Could you break it down for me?
I dont know swift code but you should not need an array/search. You just need two values, lowRoll and sumRolls. Set lowRoll to 7 before a loop entry, then compare and replace subsequent lower rolls while sumRolls adds the value of every roll. On exit sumRolls - lowRoll gives you what you need.
roll4d6 is still an array so you can't subtract a number from an array. You probably want to do ```roll4d6.reduce(0,+) - dropLowest```
How about use GamePlayKit. You can create a d6 generator. import GameplayKit let d6 = GKRandomDistribution.d6() func roll4d6() -&gt; [Int] { var rolls = [Int]() for _ in 1...4 { rolls.append(d6.nextInt()) } rolls.sortInPlace() return rolls } This would generate an array of four d6 rolls sorted highest to lowest. You can add rolls 1...3 to get the value. 
Wouldn't mind helping answer questions and working through things with you. I've mentored someone from the ups programming subreddit before and we built a Reddit client together. Whatever help you find, best of luck to you!
I am writing for iOS and OSX, I use Emacs with Evil mode since I have become addicted to vim commands, my muscle memory has taken over. 
For mine its 7 because that is maximum_random + 1, its a range cap value unrelated to die size. You could set it to be the highest integer value the language allowed, but then it would lose its value as a cap. I understand your point in applying a function on an array, but I wrote mine to avoid creating an array, so it would be independent of the number of die rolls as well as the kind of die.
I see now, I am using Xcode 6 so that explains why it doesn't work. I'll update and try if it works!
Hi SexySama! Unfortunately, the link to the App Store you submitted has been automatically removed from /r/Swift. This is because – generally speaking – compiled products are not relevant to /r/Swift (even if the app was originally written in Swift). If this is an app you have written, congrats on your acceptance to the App Store! A great way to promote it would be [Reddit advertising](https://www.reddit.com/advertising). If you would like to release its Swift source code, we would gladly accept a link to that. If the content you were submitting *was* in fact related to the subject of Swift programming, please [message the moderation team](https://www.reddit.com/message/compose?to=%2Fr%2Fswift&amp;subject=Please%20review%20my%20removed%20App%20Store%20submission&amp;message=https://www.reddit.com/r/swift/comments/4gybsf/how_to_add_animated_games_into_ios_today/) to have it reviewed. Regards, The /r/Swift Moderation Team *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/swift) if you have any questions or concerns.*
VSCode looks super nice, will give it a try, thanks!
I am considering a WASD but still hesitating between MX Brown or Blue :3
&gt;I think this article is more applicable And you'd be absolutely correct as I fat fingered the wrong link. This http://alisoftware.github.io/swift/async/error/2016/02/06/async-errors/ is the one I meant. Using the async throw pattern from that post yields this version of the OP's code (and the post outlines more advanced techniques) : import Foundation enum MyError: ErrorType { case GeneralError case HTTPStatusError(Int) } typealias ThrowingHandler = Void throws -&gt; NSData func myFancyFuncWithCompletionHandler(completion: ThrowingHandler-&gt;Void) { let url = NSURL(string: "https://www.google.com/")! let session = NSURLSession.sharedSession() let task = session.dataTaskWithURL(url) { (data, response, error) in completion({ guard let data = data, let response = response as? NSHTTPURLResponse where error == nil else { throw MyError.GeneralError } if response.statusCode != 200 { throw MyError.HTTPStatusError(response.statusCode) } return data }) } task.resume() } myFancyFuncWithCompletionHandler { (handler:ThrowingHandler) in do { let data = try handler() } catch let error as MyError { switch error { case .GeneralError : print("General Error") case .HTTPStatusError(let status): print("HTTPStatusError \(status)") } } catch {print("Something else")} } Edit: Horrible formating. Edit2: Cleaned up error handler
there are vim files in apple's swift repository, emacs files too
Maybe some of the very handy methods in NSCalendar could help. Such as: /* This API returns the first moment date of a given date. Pass in [NSDate date], for example, if you want the start of "today". If there were two midnights, it returns the first. If there was none, it returns the first moment that did exist. */ @available(iOS 8.0, *) public func startOfDayForDate(date: NSDate) -&gt; NSDate 
Mostly for iOS. If I am writing bigger applications that do a lot of UI stuff, the rest of Xcode is ok and useful to some degree. However I do like to stay slightly more backend than frontend, so in as many cases as I can I use vim+lldb tbh. XVim has most commands in, but some more heavy commands like change inside block and change to next search hit and such seem to be lacking (at least when I used a couple of months ago).
Something like this might work (if I understand you correctly): import Foundation extension SequenceType where Generator.Element: Comparable { /// Returns self with the smallest element removed func dropMin() -&gt; [Generator.Element] { var min: Generator.Element? = nil return flatMap { el in if let x = min where x &lt;= el { return el } defer { min = el } return min } } } [1,2,3,4].dropMin() // [2,3,4] [2,3,1,4].dropMin() // [3,2,4] /// Returns a random number from 1 to 6 func rollDie() -&gt; Int { return Int(arc4random_uniform(6)+1) } let roll = [rollDie(),rollDie(),rollDie(),rollDie()] // 4 rolls .dropMin() // dropping worst roll .reduce(0, combine: +) // summing the remaining three
If you are a student or want to test the beta you can get it for free. 
Thank you! Is there a chance here that `lowRoll` might return a 0? If not, why is that?
I'm a member of http://github.com/crossroadlabs/Express team. We are working on a solid server-side foundation already. Very Scala-like (Play) approach. Some parts will be out next month already. So, stay tuned.
This is the latest in my series of algorithm posts for Swift. As always, I'd love to hear feedback on how these can be improved!
The only thing I can think of to convert a bool to an Int or Int32 is to convert the bool to an NSNumber then grab the integerValue (Int) or intValue(Int32). let bool = NSNumber(bool: true) let integer = bool.integerValue //for Int let integerThirtyTwo = bool.intValue //for Int32
I personally wouldn't write extensions on the `Bool` type or overload the `+` operator, because it makes your code less understandable for others (including future you). Also, in this case it slightly goes against the typesafe nature of Swift. I'd probably go with let margin = (row == 0 ? 50 : 0) + (row &gt; 5 ? 10 : 0) + 5 Edit: typo
Since mac minis contain laptop hardware, there probably wouldn't be much difference. (given you put a similar configuration into each). The mac mini would be a bit cheaper though. (but also doesn't come with a retina screen)
Swift, in general, doesn't allow direct conversions - Int to uint, Int to Double, etc. all need explicit conversions. The only exception is casts from Swift types to their Objective-C counterparts (string to NSString, etc, but that is unrelated to your problem). Also, Swift does not use casts to do these conversions. Instead, types just offer initialisers for the types that they can be converted from. For example: - Want a Double from an Int? Write `Double(someInteger)`. - Want a CGFloat from a float? Write `CGFloat(someFloat)`. - Want a Int from an Bool? You guessed it, write `Int(someBool)`! So that's the Swift equivalent of what you're looking for: let margin : Int = 50 * Int(row == 0) + 10 * Int(row &gt; 5) + 5 That being said, I'm not a huge fan of the conversion. I prefer /u/teddim's solution over the above one.
Are those computers powerful enough (cheapest versions) to run Xcode well?
Yes, I understand that, but I've heard that to be effective I should get MPB, I really would prefer to get ultralight laptop though. I'm curious if the people telling me that a MBP is necessary are correct?
I'm running XCode on a Mac Mini. Works just fine.
You can also work with a Hackintosh. If you don't want the extra work, then you should buy an original product. If you plan to work only at home, buy an iMac. If you didn't have enough money, buy an older iMac. 
Directly converting Booleans to Integers does not work, hence my question: let a = true let b = Int(a) Returns error: cannot invoke initializer for type 'Int' with an argument list of type '(Bool)' Edit: That's odd, it does not work on the REPL, but does work in a playground/xcode
If the machine can run El Cap, has a least 8GB RAM (16 preferred), and an SSD, it'll run great. MB or Mini doesn't really matter, I use a mini as my build server and it only takes a couple seconds longer than my top end Mac Pro. I highly recommend the MB because of portability, and the Retina screen. Get the MBP, it's worth the extra money for the screen size.
Thanks, I bought an iPad pro this year, so the new computer will have to wait til next year.
Yeah I guess you're right. I'm rather new to Swift, as in I learned it 2 months ago compared to ObjC which I've been using for years. 
That is actually a good thing! Why? I'm expecting a whole new generation of hardware with SkyLake. Hopefully they arrive in June of this year. 
What about performance? How well did it perform against the default `sort()` method?
The most *Swifty* solution is probably adding a constructor that turns Bools to Ints public extension Int { public init(_ bool: Bool) { self = bool ? 1 : 0 } } let x = intValue + Int(boolValue) In Swift, we appreciate explicit conversion. Implicit coercion between types like you find in other languages just isn't present in Swift, beyond LiteralConvertibles, because it makes code harder to read and reason about.
If you are merely looking for an excuse, that's a matter of your budget choices or your preferences, not what you asked us about. A Mac Mini will work perfectly fine. You'll still need USB mouse, keyboard and monitor but if you already have those from another PC, it's all good - zero incremental cost. Strictly so will older iMacs (I have a late 2009 iMac that I use as a backup when I want a bigger screen - as long as you have maxed out memory it works fine - cost to upgrade to that from its lesser stock: ~$100).
When I tried this initially I was still getting "Could not find Developer Disk Image", even after restarting Xcode. Gave my Mac a restart and then it was able to compile to my devices. So I am running Yosemite 10.10.5, with Xcode 7.2.1. Compiling to iOS 9.3. It can be done.
Yes, yes they are. I personally develop on a 2010 2Gb Mac mini. It's slow as a snail under El Capitan, but it does work. 
dammit Realm, that's not how decimals work I know this is supposed to be semantic versioning, but incrementing it to 0.100.0 just feels like they're pushing a bit too hard on it.
That's not how switch statements work since you're trying to match true or false against the time of day. Doing "hour == 10" is going to return true or false, and the switch is working off of the daytime value (a UIColor, in this case). You're really looking for a range also, so something like this is going to end up closer to what you want: func getBackgroundColor(hour:Int) -&gt; UIColor { let morning = UIColor(red: 255/255.0, green: 200/255.0, blue: 200/255.0, alpha: 1.0) let noon = UIColor(red: 200/255.0, green: 200/255.0, blue: 255/255.0, alpha: 1.0) let night = UIColor(red: 200/255.0, green: 255/255.0, blue: 200/255.0, alpha: 1.0) switch hour { case 7...11: // 7am-11am return morning case 12...16: // 12pm-4pm return noon default: return night } } var a = getBackgroundColor(6) // 6am var b = getBackgroundColor(7) // 7am var c = getBackgroundColor(11) // 11am var d = getBackgroundColor(12) // 12pm var e = getBackgroundColor(16) // 4pm var f = getBackgroundColor(17) // 5pm
The code you have makes no sense in this context. When you `switch dayTime` you are switching between all values of a `UIColor` which is inferred `dayTime = view.backgroundColor`. You can't have `case hour == 10:` because that's a case of `Bool`, which `dayTime` clearly isn't as mentioned above. I'm going to assume that you want the background color to be different at different times of the day. Here's how you would achieve it: var hour = NSCalendar.currentCalendar().component(.Hour, fromDate: NSDate()) let morning = UIColor(red: 255/255.0, green: 200/255.0, blue: 200/255.0, alpha: 1.0) let noon = UIColor(red: 200/255.0, green: 200/255.0, blue: 255/255.0, alpha: 1.0) let night = UIColor(red: 200/255.0, green: 255/255.0, blue: 200/255.0, alpha: 1.0) switch hour { case 6..&lt;11: view.backgroundColor = morning break case 12..&lt;18:view.backgroundColor = noon break case 18..&lt;24: view.backgroundColor = night break default: view.backgroundColor = noon } In the above snippet, you are switching through different values of `hour` and setting the background color accordingly. Please read more about switches [here](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html).
Written directly as code, highly likely. Doing something like Random(6) in most languages returns numbers in a range of 0-5 because thats a common coding convention. No idea about Swift but its probably the same. But when I think/write pseudo-code my style is more plain english than some, so Random(6) to me is 1-6 inclusive and if I wanted a more specific range my pseudo-code would list all possible return values, so seeking a range 0-5 would be Random(0..5).
Thanks a lot. That's great to know. I'll keep an eye on weird stuff happening that might be because of that bug. I haven't seen that many cases of the interface acting up, probably when I add more actions. Thanks again.
I tried to make another project and it works. Don't know what happened Thanks to all
Geek bench publishes performance numbers for all Macs. Just compare your current machine and see. 
You could put the code into a function and in your viewWillAppear you can use an NSTimer to call it every hour. Or minute if you want to be more precise. I'm not sure of the syntax by heart, just look up how to call a function with NSTimer
I'm still waiting on abstract models
For simplicity, put the frameworks in your project folder (like you have it right now). If you're using dynamic frameworks, keep in mind that you also have to make sure that the frameworks are embedded within the app. A "dylib not found" message (or something like that) is a big clue. Look at your target's "General" settings tab, and you will see an "Embedded Binaries" section. Add your dynamic frameworks there. Static frameworks will be directly linked to your code so no need to embed them.
I understand that the function of a changing background is purely aesthetic, and it might not seem like much value added. I think it contributes meaningfully to the overall polish of the app, though. I've found a lot of information on running NSTimer, but (as you say) not much on anything else, like using NSCalendar. The problem seems to be that the time interval for NSTimer starts when you run the app, and that's not what I'm after. This is about the best I could come up with: http://stackoverflow.com/questions/5495340/calling-a-method-at-nsdate
I code on a 2013 MacBook Air and a 2012 Mac Mini (although both are i7s). The only things you need to do is make sure that 1) you have an SSD and 2) have enough memory. Any of the current Macs are probably fine for Xcode, except possibly the Macbook (although based on benchmarks it's probably okay).
Here's another possibility: in your frameworks project, go to your project -&gt; Build Settings -&gt; Other Linker Flags, and add '-ObjC' It's possible that some of your code is being stripped out because the linker doesn't know what will be used. That flag is used for Objective C code to make sure this doesn't happen. 
You can create a custom object that runs the timer and keeps track of when the hour changes. Just remember the implications of battery use when the user is in the app. Also, do you see the user running the app for multiple hours in a single session?
Hmm, I tried it on my iPhone and it's working fine. Are you on Android?
That's very strange. I realized that I was using Chrome on iOS, and figured I might be able to reproduce what you guys are experiencing with Safari, but I just tried it, and I was still able to link through properly. In any case, does it help if I create a shortened URL? https://goo.gl/WsVN0D
It works fine
I'm using the new Reddit app on an iPhone running iOS 9.3.1. 
Could be. It is requesting https://medium.com/@maxalthoff/swift-class-initializers-inheritance-a-metaphor-419eb52535d4%23.5tc1vzohh Looks like the hashtag transformation is the problem. 
It works in Alien Blue on iOS, so apparently it's a Reddit app problem. 
Is a fusion drive considered SSD or would I be better off with pure flash storage?
I looked at many different frameworks big to small a couple weeks ago and settled on using [Zewo](https://github.com/zewo/zewo). It is very modular so I can use the parts of it I like and implement my own stuff for other parts. Also I submitted a pull request the other day and the community seems very passionate and active. I joined their Slack group and there are good discussions on there. I highly recommend it.
I was actually looking for a tutorial on this! Great stuff, is there a way to control playback speed? Like slowing it down to half speed or speeding up to twice speed?
If you do man swift It tells you to do either swift --help or swiftc --help The stuff you want is in the last one.
Hi, I just looked into it and you can set *mp.currentPlaybackRate*. I haven't tested it but I would imagine *mp.currentPlaybackRate = 0.5* would play at half speed, where setting the value to 2 would play at double speed.
My feedback is I want to gain your powers
Its a solid article but I would bring up johnnyDoe at the beginning, to illustrate his problematic relationship to BaseHumanBeing compared to janeDoe.
The same rules would apply. If you have a superclass with multiple designated initializers (though you'd probably want to minimize this, since it's usually not very solid design-wise), those initializers, along with any convenience inits, would be inherited by an empty subclass, or a subclass containing only custom convenience inits. However, as soon as the subclass implements its own designated init, it would lose all inits (designated and otherwise) from its superclass. In real terms, the case you'll most often see of multiple designated inits is when you roll your own in a subclass of some Cocoa class, and the compiler forces you (because you're no longer inheriting any inits) to implement one that's marked `required` in the superclass. `UIViewController` is the most glaring example of this, where you're forced to add `required init(coder aDecoder: NSCoder)`.
Pure flash storage is much better. Fusion drives are okay is you need the extra space, but always go just flash if you can. I use SSDs and supplement them with external drives.
Thanks 
Just create a new apple id. Someone created 10.
I'm in the middle of writing the code and think I should use a near-optimal idiom when writing. I know a quick sort is better than a bubble sort. :)
Now ported version of Swift available on Microsoft Codeplex https://swiftforwindows.codeplex.com/
sounds like a cell reuse issue. are you clearing the selected state in prepareForReuse()?
In the future when I'm more skillful in iOS Development, my thanks will be more meaningful. Thank you.
It may be there to prevent non developers from side loading apps on their devices. 
Don't.
How come? The text field size is based on the frame's height and width so with a smaller screen, it looks off with a smaller text field and bigger font. 
they still could've waited a week more
People usually get bigger screens to fit more content instead of showing the same amount of zoomed content. Use dynamic type and your labels will adapt for users who actually want bigger fonts, don't force them on everyone.
What you can do (but it is probably not the right thing to do) is set the font size according the device model. You can get the device name by using : let device = UIDevice.currentDevice().model then you can test something like this: if device.lowercaseString.containsString("4") {// iPhone4 or 4s // Do something } else { // Do something else } and then you can set your button title font size with: yourButton.titleLabel?.font = UIFont(name: "yourFontName", size: 20) And for your placeholder : let font = UIFont(name: "yourFont", size: 16)! let attributes = [ NSForegroundColorAttributeName: UIColor.redColor(), NSFontAttributeName : font] textField.attributedPlaceholder = NSAttributedString(string: "your String here !", attributes:attributes)
Ah, good point! Will include in future posts. Thank you!
If it doesn't work on your setup, or I'm doing something that seems obviously wrong to you, let me know. If you're interested in contributing in any way, see [here](https://github.com/r0fls/swiftstats#contributing).
Framework? Isn't this just a small library?
Hi, I don't wanna steal OP's thunder but I'm the author of the neural network that's used in this library - [Swift AI](https://github.com/collinhundley/Swift-AI). If you're looking for more info on how to use the raw neural nets I'd recommend you check out my docs!
It seems that UIDevice.currentDevice().model does not specify the iphone model, only whether or not it's an iphone, ipad, etc. There's a way to work around it, but it seems a bit much to scale the font! 
I've not used this code, but it might be useful to use as-is or maybe give you ideas on what to do or not to do: https://github.com/benzguo/MusicKit It hasn't been updated for almost a year, and I have no idea what sort of state it is in. But it has a wide range of music related classes, many of which are related to music theory, and some of which seem to have to do with MIDI.
Advanced Swift by [objc.io](http://www.objc.io/) is great! If you're a student, email them for a discount.
Thanks, I've bodged something together which I think is working as expected but it'd be good to see something a bit more comprehensive and to make sure I'm not wasting my time 👍🏻
Hmm. Maybe it should say: "*This* is only *a* collection of designable view*s* for storyboard*s*. It is able to *make* UIView, UILabel, UIButton, UITextField, UITextView, UIImageView designable."? Otherwise it doesn't make sense to me. 
Have you looked at [CloudKit](https://developer.apple.com/icloud/)?
I work with Xcode on the entry level late 2008 Macbook :P Just waiting now on the new Macbook refresh then I'll upgrade!
Never transmit unencrypted passwords even over SSL. Always encrypt before transmission.
&gt; Obviously I need to have user accounts (right?) because I don't want user X to be able to see data belonging to user Y in the database. Yes. &gt; And obviously I need to GET and POST via a web API (written in PHP) because it's crazy talk to attempt to communicate directly with a MySQL database from Swift. (Right?) You should always have an API layer in between the backend (PHP in this case) and database (MySQL in this case) that validates all types of requests (GET, PUT, POST, DELETE) before inserting, updating, removing any data in your database, or sending any data out to your potential clients. If this is the case I would recommend you to look into how to build a [Rest API](https://en.wikipedia.org/wiki/Representational_state_transfer). If it's a single user application you are building for your iOS app that does not need to be centralised somewhere you can use sqlite, NSUserDefaults or CoreData for locally storing your data on the device. If you need to back that data up to a third party you can use iCloud/Dropbox/Box.com/Google Drive or any other file sharing service. &gt; So ... Assuming I can create users (and / or let users register with Facebook / Twitter), can I authenticate them once and then save some local token confirming this rather than needing to authenticate on every database call? Yes look into the [Facebook iOS SDK](https://developers.facebook.com/docs/ios/getting-started) and [Twitter iOS SDK](https://dev.twitter.com/mopub/ios/getting-started) for receiving accessTokens and how to connect your backend service user X with Facebook/Twitter user Y. Also look at setting some sort of HTTP header once a user logins that you send along with any other request the user might perform whilst logged in to your application. &gt; And if my API sits on an https:// webserver, am I safe to send unencrypted passwords via POST and NSURLSession? Or should I encrypt them anyway just to be double-secret safe? (Of course they're encrypted in the database.) You should never send any personal/private data over an unencrypted network, period. By using regular HTTP traffic anyone can sniff that traffic and look at the data you send as a client, consider this JSON for logging into your service: { "username": "JohnDoe", "password": "MySuperSecretPassword1" } You could encrypt this POST data on the client let's say with SHA256 and a salt (I chose this for example: MyReallyLongLongSaltThatsNeverMeantToBeSeen) which would generate this output: DAEC8D76E836AC293A31187C156AD2420023D0EDD8CEDDD8447C8D5E15355DF6 And surely this long string would be hard to for some people to reverse engineer, but given that you are sending the data through an unencrypted network ill willed people can just log all the request made to *domain.xx/api/1.0/login* and eventually they will figure out your salt string. Let's pretend that you have an image sharing service like [Imgur](https://www.imgur.com) for instance: API Endpoint | Encrypted ---|--- domain.xx/api/1.0/user/x/publicgallery | Recommend YES, but doesn't necessarily need to be since this data is accessible to users not logged in domain.xx/api/1.0/user/x/albums | YES, not accessible without authentication domain.xx/api/1.0/user/x/favorites | YES, not accessible without authentication domain.xx/api/1.0/user/x/notifications | YES, not accessible without authentication Having your site and API encrypted is always a good practice. [Let's Encrypt](https://letsencrypt.org/) can provide you a free TLS/SSL certificate.
Thanks for the suggestion, I will update the readme file. 
Thats one possible solution. Thank you.
I recommend the iOS Development course by Stanford on iTunes U. It starts off with iOS fundamentals, Swift, and how to build and run your apps.
I'd recommend checking out [Haneke](https://github.com/Haneke/HanekeSwift), an open source image cache library in Swift. It turns your code into a one liner with its ImageView extension, and handles all the threading and caching for you. &gt;imageView.hnk_setImageFromURL(url)
You probably shouldn't use NSData(contentsOfURL:) since it doesn't really provide any error handling or the ability to customize the request (e.g. if you need to authorize your request), and it's single threaded (which you've worked around by putting it in a bunch of dispatch loops). If you use a NSURLSessionDataTask or the AFHttp methods if you're using that.
Thanks!
Agree to disagree then. I've heard the exact opposite. If you could list things that you can do in code to produce views that you can't do with XIB's, then I might be inclined to believe you, otherwise you have no argument that "XIB's are pointless" except some guys you think are good programmers telling you that. There's NO reason to not use XIB's, and if those "experience senior" devs think otherwise, well I'd have to argue with them and say they're wrong. XIBs make development faster and easier. What's wrong with that? And honestly, again, why do you think it's awful? It's not awful at all once you get comfortable with it. I can produce a single, detailed, screen using XIBs in half the time you do it in code AND half the time an Android dev can do it in their XMLs. I can guarantee you that. So again, if you can give actual REASONS it's awful and why you "don't blame them for hiring somebody who uses XIBs", then you'll have an argument. But as far as I can tell, there is absolutely nothing wrong with them and senior devs use them all the time.
Ruby on Rails isn't that hard to pick up. I started on it when parse announced and already have my own backend api up and running. 
I'd be interested to hear what confused you! Drop me a message here or email paul@hackingwithswift.com if you have the time. 
There are two things I want to make sure you know about strings - string.characters can't be indexed by an Int. It uses a special index of type String.CharacterView.Index - a string can not be mutable by using the subscript notation (i.e. string[0] = "a" wont work) If you want to manipulate a string character by character, you're probably better off getting an array of letters and working from there. Array(string.characters) But even then, that will give you an array of Character objects which aren't really the best to work with so you'll probably want to change them to strings. let array = string.characters.map { String($0) } An then you can get the even or odd positioned character with something like this. let evenCharacters = array.enumerate() .filter { $0.0 % 2 == 0 } .map { $0.1 }
Won't work. Character view doesn't have random access. 
There are a few basic constraints that exist but not are immediately obvious maybe. Text resists size with priority 750 and the text is spaced off with 250 (I might be wrong on that one). So if your constraint is &lt; 750 and you didn't change that text size constraint the constraint is suppressed by text size. This can be very handy of course but might throw a surprise when you start doing more complex layouts with different priorities for the first time. I think if you want your fonts to grow according to the size you reserve for the label you should set them to auto-size and a huge font size. Then you need to limit the height and/or width of the label according to the size you want to give it. For instance if you want it to fit to the width then you need to set relative widths. So the whole thing together should be 100%, the word Swift should fit next to the heart and hug the right side, the word "We" should be left of that in the same font height. The word "Swift" should have a tight fit for the word and then set to a ratio. The word "We" should get same height as "Swift" and no width constraint. This will allow the word "We" to grow in height the same way as "Swift" because "Swift" determines it's height according to the width available. Same goes for the heart. Give it a fixed ratio and set the height same to the wordt "Swift". Now the space between the heart and the right side determines how tall the word Swift will become through the ratio and the heights of the heart and "We" will follow because of that. ----------- OK I got thinking and I just tried it at home to be sure that what I was saying was actually correct. My method works. Caveats: * If you just drag a label up there and set the ratio to it as-is there is way more height than width available. So the perfect ratio for your label will be slightly more in the width. In fact you should have a few pixels to spare in the width not in the height to make the fonts just as high * You need to set the baselines to center otherwise they will not be centred because of the font-scaling * When I rotate my phone the animation has a little hiccup in the end where the rotation is done and it re-scales the font Recap: * Add the image. Set the ratio according to it's real width/height. * Center it * Add two labels, "we" and "swift". Give them ratios in such a way that the font starts touching the top and bottom. * Set the font to 500 and auto shrink 0.0000000001, baseline center * Connect the "swift" label to the image like 10px space and to the right of the screen like 10px space * Make everything (labels and image) "same height", the preset ratios do the rest
Thanks for the response. I did actually get MIKMIDI up and running in a project (my original problem was Cocoapods related, now solved). I've been experimenting with creating sequences on the fly in MIKMIDI, but I am still thinking about an ad hoc loop-based approach that uses midi (although not midi sequencing per se). If you don't mind me asking, do you think there would be a major advantage in using MIKMIDI over having a timed loop read through arrays of NoteOn messages?
I guess I chose a good day to search for this, posted one day ago from a three month thread haha. Thanks buddy! :)
why not format NSDate in the view side of things?
I don't. I prefer that my users know what they're paying up front.
To me this seems overkill. Why not simply inherit or extend the **Car** model rather than creating an entirely new model? In essence that is all that is happening in **carViewModel**. Also, There probably shouldn't be a situation where you should have a **carViewModel** but no **Car**. Making them optional would only be needed if you're going to allow a car that doesn't 'exist' to be displayed. Other than that, It's an interesting concept &amp; example.
I can attest this does not work. I tried it already hence i came here but i thought the exact same block of code would work. I used a new style for loop though for i in 0 ... string.characters.count { your code :( } 
I had thought of this in a sense of character access since String is just grouping of char. This is something i will definitely give a go at tomorrow am. I had one of those 30 days of code morning warm ups and i am doing them in swift to get a deeper understanding. They wrote the challenge to access every other character from a input string and then print the result back to the console. I am also actively trying to convert some python to swift to turn a script we use at work into a threaded application. So hence i am diving deeper into strings than i have previously. I did find a string extension to let you subscript access on a string from old stack however it did not seem to work for me in the manor i needed. My thought on how to do it was to create some sort of step through and append to an array or concatenate onto a string and print the results back. 
Not sure if this is the case, but your reuseIdentifier is Cell with a capital C. 
This is interesting code, a nice simple example of MVVM. Although, it seems optionals are being overused here. For starters Car has all optional fields, but the initializer doesn't take optionals, so you could likely have them just be regular non-optional types. Then CarViewModel also has an optional Car again the constructor takes a non-optional Car. On top of those car is a private variable so it can never be made nil. Hence you could make the Car field of CarViewModel non-optional and then all of the CarViewModel fields could be made non-optional.
works perfectly now thanks everyone, hopefully this can help someone! I added this to appearDidLoad() { tbl2Tasks.dataSource = self&lt;Enter&gt; tbl2Tasks.delegate = self&lt;Enter&gt; tbl2Tasks.registerClass(UITableViewCell.self, forCellReuseIdentifier: "Cell") tbl2Tasks.reloadData() }
SwiftyBeaver has an open-source Objective-C wrapper. Just join the Slack channel at https://slack.swiftybeaver.com to learn more.
I do, too. :/ I don't think it makes any sense. Having said that, these books are still great, the authors clearly know exactly what they're talking about.
Yep, it's mine. I was experimenting with the popup vs form but this is a legit concern I hadn't thought about. Thanks for the heads up, the form is now at the bottom of each post!
That was John Gossman's criticism of the MVVM process as well. It is an overkill for small apps. OP was using a simple example as an easily-understood example.
Yeah, the CarView would make sense if we'd reuse it in multiple places. Right now, the next step would be to subclass the UITableViewCell and call it something like CarCell. I used the native implementation of the Right Detail cell just to keep it simple, but you are absolutely right.
[First result when litterally googling your question](http://www.learnswiftonline.com/reference-guides/adding-iad-swift-app/) Now from a presonal standpoint I'd follow /u/Sir_not_sir recommendation
If you are using [HTTPS](https://en.wikipedia.org/wiki/HTTPS) your connection is secure. But that depends on which implementation you are using. You should be using [TLS v1.3](https://en.wikipedia.org/wiki/Transport_Layer_Security#TLS_1.3). You can read more about it [here](http://disablessl3.com/) to make sure you don't support older versions of TLS/SSL that isn't secure anymore.
You are making an incorrect assumption about hash values. Hashes for equal objects must be identical; beyond that, anything goes. That means the reverse is not guaranteed: non-equal objects don't have to have different hashes. If there is a hash collision, you must use the isEqual method to determine whether the objects are identical or not. So... You're only storing and checking hashes, which isn't enough information to guarantee uniqueness. You need to keep a reference to the object around in order to call isEqual on it in the event of a hash collision. Conveniently, that's exactly what a set does for you if you just store the object itself in the set. It shouldn't be any slower and is a hell of a lot more straightforward. 
why store the model data in the app delegate??
which in its turn (amongst other things) makes unit testing views A LOT easier, since you can test the logic and the rendering separately.
No problem
I think what has thrown me off is that it does not just take an int literal or variable for what in my mind is clearly an int. This explanation is along the lines of what i was originally thinking. I would always get a compile error and lack of knowledge of all the available options i abandoned it. The limit : will prevent me from hoping over a character into space. I suppose instead of print i will want to just do a index =+ index to get a smashing together of the characters. I wished there was a nice deep dive on string manipulation some where that was way more descriptive than the reference guide from apple. I have some python code i need to convert to swift for building of a parsing application. 
I want to say THANK YOU !!!!! to ever one that replied and will reply to this thread. The ideas have helped me in working with strings. If there is a good resource to read up even more besides the apple documentation. I went there first it was very sparse. I am all ears. New language new framework much to learn 
No problem :) Subscribed. 
The reason you can't subscript a `String` with an `Int` is that not every `Character` has the same size: emoji's will take up more space, to name something. It can be a bit confusing to have to use another index than `Int`, but it's actually not that hard. Just always use `startIndex`, `endIndex`, `successor()`, `predecessor()`, `advanceBy(_:)`. It's also a good idea to use these properties and functions in case the index is simply of type `Int`, though, it makes for very readable code. Anyways. For your particular use case, something like this might be simpler: let string = "Hello World" let characters = Array(string.characters) let evenCharacters = characters.startIndex .stride(to: characters.endIndex, by: 2) .map { characters[$0] } let evenString = String(evenCharacters) // "HloWrd" This is most likely faster than what the top comment suggests, but I haven't done any benchmarks.
I am aware of the process, just not sure what to use in Swift (Is there possibly an NSSocket? or something like that?)
If you have an array of strings, you can do this array.joinWithSeparator("")
Just for demonstration purposes, so the TableViewController is indeed ignorant of the Car model. Otherwise, we could obviously set up the cars array in the TVC itself. In a real-world app, you'd usually be fetching it from an API, CoreData or some other external source.
I definitely feel i have learned so much. So lastly any advice where you found this information how you came to obtain it vs. what i am doing here. I would like to try to head off these road blocks sooner than latter. I am trying to build a nice core foundation of knowledge as i ease into developing apps for mac / IOS. I also see this as refreshing my fundamental programing skills along the way. I was trained in Cobol in school and digesting objects and code reuse took some time. I was stuck in a linear mindset for years. 
Get started with RTFM of the watch SDK as /u/theWaveTourist says as well. Also realize you should revisit your design in the context of user interaction and the limits of what can be done with Watch. In general, blind porting of a iPhone app directly to Watch will be Epic Fail. All the design assumptions that work with iPhone need to be reconsidered.
Also that worked perfectly. I am still trying to digest why. so i think i need to dive some on arrays and all that they can do 
There's also something to be sad for the fact that Cocoa is a lot older than Swift and its conventions more closely follow Objective-C patterns than Swift. From a purely practical you have a job to do POV, I see little wrong with following the Objective-C conventions when a Swift one doesn't exist, since the Objective-C convention is effectively a defacto Cocoa convention. Just my $0.02
If you want to learn swift but are not interested in iOS, you can always learn in Linux, there are official builds for Ubuntu and I would suppose other distros have install scripts. At least in Arch Linux you can build Swift 3 from source with AUR.
I mean my opinion is formed off experience as well, and I too do Android and iOS with my focus leaning more on iOS. I'm also a senior developer with years of experience in the iOS field and know plenty others with the same opinion as me. I'll answer each point. 1) I've never had a problem styling what my clients want using UIAppearance and XIBs, and it was not difficult. So I don't agree with this. 2) http://stackoverflow.com/questions/12458603/change-the-order-of-tabs-in-uitabbarcontroller (Not limited by XIBs, there's always a way) 3) Not in my experience. Storyboards? Yes, crash a ton, slow as hell once they get too large. XIBs? I've never had many crashes with XIBs and they've run very smoothly. Also very very few bugs, and there's only one particular one that happens sometimes, but the fix is stupid easy and I don't need to do it often at all. So I disagree with this statement. 4) Container View Controllers. Yes you can. Again you're incorrect here implying that XIBs can't be re-used easily. That's simply not true. 5) No it's not. I never get errors and, again once you're used to it, I get it to work right away and it's much faster and easier than doing it in code. 6) Make an IB for the constraints, and change them dynamically if the device is a 3.5. You can still do it. This is also a very niche case as the phone is very old and no longer really supported that much. 7) What? Yes, you couple View Controllers to Views. The View Controller is the View in MVC. This isn't a separation. In fact, this enforces MVC MORE than doing views in code, because it forces you to have your views in one View Controller class. Don't be thrown off by the fact that Apple decided to call them View CONTROLLERS. They're not. They're views. You make other controller classes to handle your business logic and call those from your View Controller. Boom you still have MVC. Whereas if you have your programmers doing everything in code, I would DEFINITELY be worried they would screw up MVC when they're not restricted to putting their views in a VC class. However, if you mean that you can't have different views per View Controller, then yes we are forced to make a VC for each view (although there are some tricks to get around this, but they're not pretty). Again though, this is a very niche case, and in most mobile applications you're not going to need this kind of functionality. Here's the thing. The problem is that you consider XIBs absolutely pointless and made a statement that if somebody uses XIBs you wouldn't even hire them. This is just the wrong way to think when it comes to iOS development. There are times when using a XIB is a better choice (and it actually turns out to be the better choice in most situations) and there are times when making the view in code is a better choice. Most apps that I've worked on do both, but also have tons of XIB's. There are clearly pros and cons to both. I would definitely hire the guy who can do both, and knows when one is better than the other, than somebody who says "Nah I don't use XIB's. They're for noobs. You can't re-use them. I code." when they don't understand that the situation determines whether to use a XIB or not. The thing is, the limitations with XIB are extremely small. Yes, for sure, you might need to have a little code coupled between the View and View Controller (even though there are ways around this), but the advantages you get from using XIB's outweighs the small disadvantages significantly.
You should definitely look into how `map` works, and then cover `filter` and `reduce` while you're at it. `.map { // something with $0 }` basically means that `$0` iterates over the whole collection and that the results are combined into an array. In this case, each even index is put in an array with `stride`, after which it is mapped to an array of characters with `characters[$0]` (notice that `characters` is an array of characters and `characters[someIndex]` returns a single character). 
This is one of the best examples I have seen for MVVM and with unit tests as the icing. Great job on the article, looking forward to future posts. 
1. Ok. Its not difficult but its more tedious than it could be. Also you can only style based on a class level 2. I was referring to making your own tab bar not using the built in iOS ones. I was merely using it as an example for something which is ordered, as those often cause the most issues with AL in IB. 3. Xcode crashes on me at least once a day. Even more when I used the IB. I also program now in Swift which has its own huge list of issues on XCode. 4. ok can you please explain to me how? Take View 1, it has portable Widget A, Widget B, and Widget C(which inherits from widget B, IE any changes to B's view also happen with C) each of these views have their own API and a delegate to handle touch events. How is this easily done with XIBs? Do you have to use UIViewControllers for each? 5. Ok entirely disagree. Sure its easier in the beginning. But once you learn to read the code its vastly superior both in speed of setting it up and in your ability to read and decipher. 6. Exactly, which leads to cluttered and view locked ViewControllers 7. Your argument here doesn't make sense and is hard to follow. You mostly seem to be thinking I prefer to write my views in code. I don't I would much rather use some form of layout system with a live preview. Other than that I don't get what you are saying. My views are always constructed with my controller? "However, if you mean that you can't have different views per View Controller, then yes we are forced to make a VC for each view (although there are some tricks to get around this, but they're not pretty). Again though, this is a very niche case, and in most mobile applications you're not going to need this kind of functionality." Yup, of course my case is a niche case -_-. -edit- on 7 actually since I create my views in code. I am able to mix and match views with VCs. This very usefully, particularly with table/collection cells, however with base views as well. Everything it totally type safe and just safe in general. Swift's Tuples really help support this! "Heres the thing", your reaction is very typical on Reddit. You seem to take it personal that I don't use the same tools as you or that I am critiquing Apple's tool chain. I never came out and said that XIBs are "absolutely pointless". Yet you keep saying that I have. I also never said I wouldn't hire someone that does use them. I related that I have been told that before. I have also expressed that I would not like to get a job working somewhere that used XCode's IB. It would make refactoring and making edits to views very hard. I do use the IB where it makes sense, which isn't much and I continue to regret it where I do. As Apple expands the list of possible screen sizes for iOS, I see the issues with the IB getting exponentially worse. Go Google around on the topic. What I am saying is not an uncommon opinion. -edit- I'm not saying any of my issues can't be resolved with the IB. They just require lots of work arounds and extra code.
And just to be clear, there's still a View Controller, right? So is the View Model talking directly to the View, or is the View Controller pairing View Models with Views?
I would recommend reading https://github.com/raywenderlich/swift-style-guide 
Some questions you might have: - No, I haven't lost my mind. The book really is about Objective-C. I've seen lots of people here on /r/swift saying, "should I learn Swift or Objective-C?" and my answer is usually "if you have to choose, learn Swift." But when you've learned Swift and find that many companies are looking for people with Objective-C knowledge, that's where this book comes in: I try to teach Objective-C as quickly as possible, using all the Swift skills you have already. - Yes, it includes video. As well as the book, I walk you through a complete Hacking with Swift project, although this time it's in Objective-C. This lets you see side-by-side how the two languages compare. - No, I haven't forgotten about Hacking with Swift or Pro Swift. In fact, book books just got free updates today: Hacking with Swift readers got a Quick Swift Tips wallchart with 20 rapid fire code snippets, and Pro Swift readers got a new chapter on command-line Swift. I want to continue adding free content - The price is $15 now, and will go up to $20 once it's released, which is May 13th. - No, I really don't sleep as much as I ought to. Maybe next year.
For those that inserted in mobile/web development here is a great opportunity to get some great classes at a good price.​ I have done several mobile development classes and his are the best. You could buy one his classes on Udemy​ for more than ​the lowest tier on the kickstarter and it will include at least 3 of his classes.​ His youtube​ channel has some free classes too.
I've been injecting dependancies into my VCs with interface builder for a while now. I like it, but the thing that bugs is me is that I end up with code like this: @IBOutlet var _thingHandler: NSObject! var thingHandler: IThingHandler { get { return _thingHandler as! IThingHandler } } Where IThingHandler is a protocol.
Good point. I think Swift, and the discussions surrounding it, have made many of us better developers. I don't write much Objective-C these days, but I have no doubt it's better because of Swift and the thinking it's prompted me to do.
"In this blog post I will talk about some of the improvements I’d like to see in the future." Then just puts forward complaints. :(
Not directly but it was an integral part of the app design trend at the time. 
Parse is closing down. 
Can you post your code please ? 
Indeed you may try something else like CloudKit, Firebase.
Yes only iOS, with the exception of CloudKit JS.
This is just a GUI frontend for /u/tinysun212's Swift port (See "Based On" here: https://swiftforwindows.codeplex.com/SourceControl/latest#README.md) Tinysun posted a link to their project below, 22 days ago.
Start with the first two. Get a taste for it. Then get to making stuff, while doing the others. Park Git for now.
I don't disagree with any of that. But he's starting at zero on iOS / Swift already by the looks of it. He should put some miles on the clock there first. YMMV
If you're new to Swift I think getting going with Mark's course would be a good move: The Stanford route has a lot of prerequisite study suggestions, some of which look out of date: That could lead to frustration. Mark's course is newer plus he keeps it updated. He's focussed on getting you creating apps in Swift as soon as possible via practical assignments so you'll get the payoff of building stuff that actually works much faster that way! Mark is also producing courses to take students into more advanced Swift topics so that could also help you with your learning roadmap. He's already released the 'Intermediate Swift' course, designed to pick up where the one you mentioned finishes. BTW my site tracks the best prices for Udemy courses here are the links for the two courses discussed (At the moment the best deals are 46% Off &amp; 38% Off respectively): [iOS 9 and Swift 2: From Beginner to Paid Professional (with 46% Off Coupon)](http://best-course-online.com/reviews/course-review-udemy-ios9-swift/) [Intermediate iOS – Get Job Ready with Swift 2 (with 38% Off Coupon)](http://best-course-online.com/reviews/course-review-udemy-intermediate-ios/) I hope that helps!
Okay. Thank you. I forgot about the modulous / remainder operator. 
If I could piggyback off this thread for a second, how would you compare your guide vs the Stanford iTunes U course? Do you cover the same topics entirely? Does Hacking with Swift go over the Xcode IDE at all? Would you recommend taking one after the other or both concurrently? Thanks!
The View Controller is the link between the View and the View Model. It should handle all the communication and binding of View Model's values to actual UI elements.
Thanks! Glad to hear. :)
I think /u/Sebaall's point is that you can learn a little bit of Git when you learn a little bit of Swift, then learn a bit more Git when you learn a bit more Swift – that's a sound approach, although it would need to be managed carefully to avoid feeling overwhelming. The flip side is that basic Git usage can be taught in a couple of hours on someone's first day at the office, whereas basic iOS skill takes a lot longer!
Is it a Swift talk or a UIKit/iOS programming talk? One of the things I always feel Swift developers need a better understanding of is is the use of Generics.
Yes, that cleared things up nicely. The Xcode tips would be much appreciated by everyone, I'm sure. I do have one more question, do you have time estimates for your courses? You've already sold me on all three!
Hard to say. The only case I can think that involves the responder chain that would actually make a device make a sound would be invoking func doCommandBySelector(_ aSelector: Selector) without there being any responder in the chain overriding/providing the named selector for the event. It's a bizarro "feature" that it makes a beep when there is no response in the chain.
There's a lot of general Core Data set up required to get up and running, very little of which relates to Swift. If you have developers from Objective-C and a little bit of Swift, why not try something like functional programming? I find that when people see `flatMap` in action, they start to see how it can help them solve all sorts of problems.
I see , I have never had the need to use this for any reason so im no expert but you want to look for operator overloading or custom operators in google I think. Can you give an example of how you want to use the toDic function , would you not need an instance of your class to put the variables in there?
it's a waste of time for his level and it's not so hard you need to start learning it at day 0. 
the only reason equatable works that way is because its requiring an operator in the protocol and operators have to be public top level functions. it sounds like you want a top level generic function that accepts an instance of some type, for visual sake: // maybe make ObjectType constrained with a where clause // e.g. &lt;ObjectType where ObjectType: Hashable&gt; func doSomethingWithInstance&lt;ObjectType&gt;(object: ObjectType) -&gt; [String: String] idk if thats what you actually mean, but it sounds like you're trying to do something with protocols that either need to be done as private methods in a protocol extension or need to be generic top level functions that are scoped to a file somewhere
Rather than use didSet, can't you just use set directly? Letting a value get set and then changing it later seems ugly, and didSet seems more like it should be used for side effects.
It's not as simple as that. There are some language changes (some big ones aren't even done yet) which means it's hard to really compare the two. Not only that, but it's hard to know what you're talking about - compile times? Run times? Swift 3 is a "moving towards stability" release. One of its headline features is a stable ABI. It is not an optimisation/performance release. 4.0 will not be, either. Right now, the focus is on completing the holes in language functionality that exist today. Maybe there are some instances where the compiler can generate better code, but that's the compilers business and is nothing you can rely on. Any benchmarks that you see will only mislead you.
Why would it need to be a function that takes an instance of the class, rather than, say, a dictionary property? Something like this: protocol Dictionariable { var dictionary: [String : String] { get } } class MyClass: Dictionariable { var dictionary: [String : String] { return ["a" : "b", "c" : "d"] } } let instance = MyClass() print(instance.dictionary) // ["a" : "b", "c" : "d"]
FYI. Assuming your table view is in storyboard you can hook up the data source and delegate inside storyboard instead of code. 
Thank you, that answered my question. And unfortunately it also shows me that it doesn't solve my problem without creating a new one. But that's not your problem. :-)
""Heres the thing", your reaction is very typical on Reddit. You seem to take it personal that I don't use the same tools as you or that I am critiquing Apple's tool chain. I never came out and said that XIBs are "absolutely pointless"" "That they don't use IB and they wouldn't hire an experienced dev that does. Frankly I can't blame them." Ya man, totally didn't imply XIBs are pointless, and totally didn't imply you wouldn't hire somebody who uses them. I'm not taking anything personal, I'm having an objective argument with you because I don't agree. The only person acting like someone off Reddit is you, when you pull out the classic and pointless "I see you're mad and taking it personally because I can sense it with the force through your text, therefore your opinions have less credit". Classic pointless internet argument tactic. My only argument was that you should use XIBs when they make sense, and do views in code when it makes sense. You don't just choose one and always use it. I have no clue who you're talking to, but I've helped put tons of apps into production (white label, mobile ordering, loyalty, enterprise apps, for companies like NCR) and they have all used a mix of XIBs and code views. That's my experience, that's my argument. If you WEREN'T implying that they are useless, which you strongly did, then we just disagree on the frequency of their use. And at that point, I feel like most mobile apps do not have the complexity that requires such abstraction that you'd need to code most views in code. I think your development team, new people adding to your team, and project, would suffer in the long run (in most cases). I feel that it's better to take advantage of the clarity and speed of development XIBs provide, than to ignore its benefits for the sake of creating an unneeded level of abstraction. You'll argue "Ya but that abstraction is needed", and I'll tell you I highly doubt that. You're making a mobile app. Not a complex backend platform. That's my opinion. Done here, and cheers!
I second this, I mentioned it in the post announcing the start of the course but there was no response!
That does tend to happen in Swift, especially if using generics.
Hi there! I will try to guide you building this app. What you need is an app, a web service, a hosting platform where you will host your web api. What happens is, your app needs to register for receiving push notification. When you register you get the device token, large combinations of letters and numbers which uniquely identifies your device. And the apple push notification server uses that token to deliver push notification to your device. Your web service(api) does the nice job of telling apple push notification server to send the strings (i.e data) to your device. Now getting to the point, You will create an app , write the code in it to register for push notification. You will receive the device token. Then you will send this device token to your web sevice (api) . Your api will store this token somewhere preferably in database. It will also contains all the arrays of strings. Then whenever you want to send the push notification to device ( in this case every 5 minutes) you will write the code, which sends the data (strings in this case) along with device id to the apple push notification(APN) server. You cannot directly send the push notification to the devices, APN server plays the mediator role. 
Hopefully this helps: https://www.objc.io/issues/16-swift/swift-classes-vs-structs/
Functional programming makes up a whole chapter of my [Pro Swift](https://gum.co/proswift) book and video course – there are two videos on flat map, three on map, plus filter, reduce, and more.
Good job, bud! Congratulations and keep iterating now!
ish.. Again I have never said XIBs are pointless. But you continue to insist that I do. The quote is pretty obvious me relating what others have told me. I disagree to a point, but I understand their reasoning as well. If you need to support a project for multiple years, the IB is probably going to fuck you over pretty hard. I am not making a pointless argument when I say you reaction is very typical to reddit, I have had this same basic conversation with several ppl discussing the same topic. They were often as aggressive as you are. &gt; " I feel that it's better to take advantage of the clarity and speed of development XIBs provide, than to ignore its benefits for the sake of creating an unneeded level of abstraction." The IB is a level of abstraction. Are you referring to inheritance in my views? Because if you are you are making it sound as if thats the only reason I would use code rather than the IB. Its one among many. &gt; "You'll argue "Ya but that abstraction is needed"" No? Theres times where abstraction makes a ton of sense. Its not needed, I can go and manually do everything. Its just slower and more error prone.
I think....you're reading my posts with an angry voice or something. I'm not being aggressive and nothing in my post says so. So you can stop saying that I am please? It's really annoying and serves no purpose to the argument. You're just being obnoxious saying "I see you're mad" over and over. I'm not mad, trust me. Just having an argument. You're not personally hurting my feelings. "I am not making a pointless argument when I say you reaction is very typical to reddit" Yes. Yes you are. You're immediately casting me into a generalization of a bunch of reddit users, and then using that to cast doubt on my opinion. And your basis for that is because they agree with me (and you're somehow applying an aggressive pissed off voice to my text). So because other reddit users disagreed with you, got mad and were aggressive to you, I am therefore just like them and my opinion should lose credibility because of that. Hopefully as a programmer of logic, you can understand how stupid and pointless that "argument" is and you can understand how that is fairly rude and aggressive of you (don't understand why you think that's an argument. Saying "you're just like all the others" isn't an argument). And you're not....reading what I'm saying. " Again I have never said XIBs are pointless. But you continue to insist that I do" No man, I didn't say you directly said that. I said you implied it, and heavily. Read my last post, I use the word "implied" over and over. And you are implying that right here: "That they don't use IB and they wouldn't hire an experienced dev that does. Frankly I can't blame them." You can say all you want "Oh no man I didn't say THAT"....but....you did? It's right there. Look. You said "I can't blame them". You agree with them. But then you say... "I also never said I wouldn't hire someone that does use them". Well look there man. I'm not just coming up with this from thin air. You said it right there. Unless you seriously want to go there and argue you didn't SPECIFICALLY say that, so it's not true? "Theres times where abstraction makes a ton of sense. Its not needed, I can go and manually do everything. Its just slower and more error prone." Right. Thanks for agreeing.
Here is one that has recently been setup. https://groups.google.com/forum/m/#!forum/cs193p_2016
Really well done! 
The 10 App ID limit might be because you have extensions which also apparently count as App IDs in some cases.
Swipe can still work: http://stackoverflow.com/questions/26436643/uibutton-uitextfield-will-block-uitableviewcell-being-swipe-to-delete self.tableView.panGestureRecognizer.delaysTouchesBegan = YES; 
I love material design. I don't think it belongs on iOS, but I do love it. 
You can maybe clean up the initialiser for `.Call` a little bit with `@autoclosure`: func call&lt;A&gt;(@autoclosure(escaping) c: () -&gt; Result&lt;A&gt;) -&gt; Result&lt;A&gt; { return .Call(c) } Then, the triangular numbers becomes quite nice, actually: func tri(n: Int, acc:Int=1) -&gt; Result&lt;Int&gt; { return n &lt;= 1 ? .Done(acc) : call(tri(n-1, acc: acc+n)) } It's worth noting that Continuation-Passing is a slightly different thing to what's happening above (I think). Here, closures are letting you simulate lazy evaluation to do pseudo tail-call optimisation. In Continuation-Passing style, you pass in a continuation as an extra parameter to your recursive function. The continuation represents what happens *after* the function it's being passed into is called. Then, to evaluate the continuation, you (usually) pass in the identity function. This lets you transform non tail-recursive functions into tail-recursive ones. Obviously, since TCO isn't guaranteed in Swift, this isn't very useful. Regardless, here's what the triangular numbers example would look like in CPS: func triCont(n: Int, cont: Int -&gt; Int) -&gt; Int { return n &lt;= 1 ? cont(1) : triCont(n-1) { r in cont(r+n) } } func id&lt;A&gt;(x: A) -&gt; A { return x } triCont(10, cont: id) // 55
How do we get this on my campus?
I hated it at first, too. But it's improved a lot since the 1.0 days, and from what I can tell, 3.0 is definitely [going in the right direction](https://github.com/apple/swift-evolution). Some of the things I appreciate over Objective C: * enums, with associated values and methods * generics (definitely incomplete, but still useful) * protocol extensions (again, incomplete, but useful) * primitive types are objects. and you can extend them! * default values for function parameters, with a somewhat flexible order * didSet/willSet instead of writing your own setters I'm not sure what you mean by the 50 ways to instantiate arrays and dictionaries. [Int]() vs. Array&lt;Int&gt;(), or something? I'm still on the fence about optionals. I see the point, but I'm not convinced their presence is actually catching any programming errors in practice. I find closure syntax to be cleaner and more consistent than [Objective C's](http://fuckingblocksyntax.com/). Functions and closures look fairly similar. Capture lists are actually pretty great -- way better than the "__weak typeof(self) weakSelf = self" we had to do before; what bothers you so much about them? 
Thanks for this, I'll go through each one. Guessing this is using UIKit btw? 
Thanks for the reply, I'll give this a try. I can't help but think there is a way to trigger the delete button without a swipe.. 
What's messy about optionals? They're an incredibly elegant feature that add a lot of safety. What's messy about closures? Sure, the memory management stuff is meh, but at least it means we don't have to deal with a GC. And the power provided by closures otherwise is absolutely incredible. What makes Swift great is almost entirely it's safe and advanced type system, how it handles mutability, and higher order abstractions via closures like functors. There's just so much you get out of these, I can't imagine ever using Objective-C again.
Yes, you can also look into implementing edit mode on the tableview, but swipe to delete is still probably the preferred option since it's become pretty standard. https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/TableView_iPhone/ManageInsertDeleteRow/ManageInsertDeleteRow.html If you're planning to add more than delete on each row then maybe check out edit mode instead.
No. arc4random_uniform returns number greater or equal than 0 and smaller than its upper bound. So arc4random_uniform(15) will return 14 at best.
The [Codensity monad](https://github.com/typelift/Basis/blob/master/Basis/Trampoline.swift) approach is another way of doing this, though the lifting mechanism between this approach and that one leaves something to be desired.
Why do you increment `i` in the last line of the loop? AFAIK that loop only runs 7 times.
I understand the feeling. There are certainly some things that feel more tedious than objective C. Which you don't expect from a language touted as being its replacement. What helped me is to just recognize its a different language and not actually a simplified Objective C as it initially appeared. I've converted some of my Objective C stuff to swift and found that process to be a good learning experience. Not simply translate but also conform to new swift ways of doing things. Now I can't think of anything in Objective C I'll miss. But with a language that can "infer" things, why doesn't it know what I'm trying to do all the time &lt;g&gt;.
&gt; Swift thrust a lot of people who were comfortable in their expert knowledge back into the learner's chair. That is uncomfortable, but it is manageable... This. Nearly all of the consternation about Swift that I've witnessed falls into the category you just described. The language will put you off balance for about five minutes when you're learning it. But my experience has been that, the more I learn about how Swift actually works, the more eminently reasonable and logical it seems. Opening your mind to the differences, instead of remaining cloistered in Obj-C Land, only looking to disapprove of how things are done in Swift, is the key to learning more quickly.
Thank you all so much for the responses so far. I figured it had to be me since everyone else likes it. I'll have to reply to everyone when I get home. I'm currently at work.
The loop creates the pool, and I increment to run it 14 times. It runs correctly as it creates 14 SKShapeNodes and adds them to the pool. See the top of the log, the very top lines are the last few times the loop is running, and the glob of text is the finished pool. Where did you get 7 from? O.o
Sorry, originally that part was in a separate function, then I moved it to `update(currentTime:)`. See below: override func update(currentTime: NSTimeInterval) { for node in pool { if node.position.y &lt; 0 { print("Removing: \(node.name!)") pool.removeAtIndex(pool.indexOf(node)!) inPool.removeAtIndex(inPool.indexOf(Int(node.name!)!)!) node.removeFromParent() } } Edited main post to reflect this.
First of all, as princekolt said. You don't want to increment i. This is done in the for-loop. for i in 0 ..&lt; 15 { Secondly. Don't create a function that makes a side effect if there's no need to. You could easily redo it to simply return a pool. func createPool() -&gt; [SKShapeNode] { var pool = [SKShapeNode]() for i in 0 ..&lt; 15 { let circle = SKShapeNode(circleOfRadius: 50) circle.fillColor = .whiteColor() circle.strokeColor = .clearColor() circle.name = "\(i)" let randImage = arc4random_uniform(5) // var image = UIImage() if randImage == 0 { // image = snow1! // Image Needed } else if randImage == 1 { // image = snow2! // Image Needed } else if randImage == 2 { // image = snow3! // Image Needed } else { // image = snow4! // Image Needed } // circle.fillTexture = SKTexture(image: image) // print("\(circle.name!) : \(circle.fillTexture!)") let cat1 : UInt32 = 0x1 &lt;&lt; 0 let cat2 : UInt32 = 0x1 &lt;&lt; 1 circle.physicsBody = SKPhysicsBody(circleOfRadius: 50) circle.physicsBody?.dynamic = true circle.physicsBody?.velocity = CGVectorMake(0, -5) circle.physicsBody?.categoryBitMask = cat2 circle.physicsBody?.contactTestBitMask = cat1 pool.append(circle) if i == 14 { print(pool) } } return pool } I cannot comment on why your spawnCircle fails since you provide no details on how you call it. But with the modified createPool it goes through the list just fine. Also you need to think about how you handle your state. You are performing sideeffects for no apparent reason. `spawnCircle()` could just as easily have been: `spawnCircleFromPool(pool: [SKShapeNode], usedNodes: [Int]) -&gt; [Int]` where `usedNodes` is your `inPool` and the returned array is the modified `inPool`
I was simply calling to create the pool in the beginning, the on a timer to spawn after so many second.
Try fixing the `for in` to what I suggest and print `pool.count` before accessing it.
Right, I should've caught the removing prints in the console. The issue is definitely that you remove from the pool but still expect there to be 15 items. My suggestion of printing pool count would also have caught this :)
They've been prioritizing trying to do away with the need for that stuff by bridging things as best they can. With each new release, it becomes easier to do things "in Swift" (i.e. intelligently bridged so the programmer doesn't have to care about the conversion details).
Thank you!! UIKit and Core Animation for the animations.
I don't want to come off as dissing it, I know its something on my end. I'm not understanding the appeal of it and feel there's some giant "gotcha" that I am missing about the language that makes it so great. 
Are you sure that isn't because of Rx/Swift?
This is 100% correct and fixed the bug. Thank you. I really don't need to be writing code after midnight... lol
Coming from a C++ background, I naturally always put the i++ (which swift changed to i += 1 since ++ is deprecated). I didn't even know you didn't need it to be honest, TIL! 
I didn't like 1.0. 2.0 is much better. The thing about Swift is that it can evolve based on preferences, like yours. Just go bug the developer list. Objective-C is essentially stuck because of its C roots. I wouldn't say it's "sloppy" but it's definitely different. It borrows cool stuff from Objective-C and many other languages. In a sense, Objective-C is sloppier because of the lack of type checking and header file shenanigans. Swift makes type checking less cumbersome than traditional static-typed languages. `guard` and nil propagation/optionals are my favorite. Once you understand that implicitly unwrapped (!) optionals are only a stop-gap to bridge Objective-C code, the optional concept clicks. Here's a great example of Swift's power Objective-C: UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@""]; if (cell == nil) { cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@""]; } Swift let cell = tableView.dequeueReuseableCellWithIdentifier("") ?? UITableViewCell(style:.Default, reuseIdentifier:@"") Here's another Swift line I love that is many lines in Objective-C: if let rc = scrollView.subviews.lazy.map({ $0 as? UIRefreshControl }).filter({$0 != nil}).first ?? nil { // do stuff with the UIRefreshControl } You may think it's ugly, but it allows *real logic code* to be the code that takes up space, and not simple code that I could describe in a sentence. "Find the UIRefreshControl"
I'm not sure what to say. I responded to all of your points 1 by 1. How is that barely responding to anything you bring up? The only person dodging is you. You completely dodged the fact that I pointed out your contradictions in your quote, offering no explanation as to why you contradicted yourself. I'll place them here again below. "That they don't use IB and they wouldn't hire an experienced dev that does. Frankly I can't blame them." V "I also never said I wouldn't hire someone that does use them". Then you completely dodged the fact that I pointed out that you basically agreed with me in your last statement of your last post. "Theres times where abstraction makes a ton of sense. Its not needed, I can go and manually do everything. Its just slower and more error prone." That's.....my argument (minus the slower, error prone part, Ill get to that in a sec). Tons of abstraction isn't always needed and sometimes can make the codebase harder to deal with. Your primary argument (the only one that holds value, as the "it crashes a lot" argument is subjective because it doesn't happen to me or others I know) was that XIBs limit the amount of abstraction. And I said that abstraction isn't always needed, so there is no reason to neglect the tools Apple provides use to make developing clearer, faster, and easier (XIBs). Then you agree with a portion of that statement, by saying abstraction isn't always needed. Your only disagreement at that point is that (from your previous statements) XIBs are faster, but will be more prone to errors. That is from this statement below. V "5. Editing AL in the IB is very tedious and error prone" And that's simply not true. You can design XIBs extremely fast, and it's very clean and isn't prone to errors at all. It's not tedious at all unless you're simply not good at it. How is it prone to errors? It's a static design file man. It warns you of any errors you have before you even compile. Making the argument that dynamic views are less tedious and less error prone than static views is absolutely bonkers. That's the whole point of static things. They're the opposite of error prone. They don't have a chance to change. In fact, this point is in my favor. Dynamic views are far more tedious and error prone, as you have to type out every single thing (tedious) and the code can be altered from unseen variables (error prone). Then you respond with a bunch of random quotes of mine, and I have no clue what point you're trying to make. There aren't any contradictions in them. Are you trying to show me that I made a statement saying you said something you didn't? Because I just clarified all of that last post when I said to acknowledge the fact that I meant you IMPLIED those things. You didn't explicitly say them. So how is this not responding to what you're saying? If this is over, cheers and good luck!
Objective-C has a nil coalescing operator, too (`?:`), so the first example isn't totally fair. And using something like [BlocksKit](https://github.com/zwaldowski/BlocksKit), I could do the second one fairly concisely too: UIRefreshControl *rc = [scrollView.subviews bk_match: ^BOOL(id obj) { return [obj isKindOfClass: UIRefreshControl.class]; }]; if (rc) { // do stuff }
As I understand it, `[weak self]` only gives you the first half of the weak/strong dance. That is, you now have a weak reference that could become nil at any point during the closure. But maybe I've got that wrong?
Whats the need of putting it on the store if it's just for demoing libraries and helping through tutorials? Not trying to be abrasive just wondering like.
Why it's better than Objective-C? Swift is Objective-C without the baggage of C. No worrying about pointers, etc. I recommend watching the video of when Apple first announced Swift at the 2014 developer conference. You will see why it's better than Objective-C. I personally love Swift because of the clean syntax and it makes really good sense to me. 
Optionals provide a default failure/unset/noop value for all types. How is this messy? What's messy is using -1 as the failure value for ints, or "fail" for strings, etc. Objective C was a nightmare, there were absolutely no guarantees built into the language. With Swift, the only place your code can "misbehave" is exactly where the compiler makes you tell it things might misbehave (by, say, using optional chaining -- you know you might get nil, and you are telling the compiler that that's OK). The syntax is gorgeous; it has the legibility of Python while providing the necessary structure for a compiled language. The thing I'm having trouble understanding is what features other languages have that make them better than Swift. C/C++ are way too verbose for my liking, Java has no optionals, and I've never really liked that Python is interpreted, not compiled (although a linter can ameliorate that).
Yo, you submitted that three times.
So you're saying Optionals make code safer but not foolproof. That sounds like an improvement. By the way, that "one specific kind of misbehavior" is the misbehavior that Tony Hoare (who invented nil) called, "[my billion-dollar mistake](https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions)". So it's not an insignificant kind of misbehavior. 
Sorry, wasn't trying to say that optionals let you write bug free code, just that they are both highly versatile and are very good at preventing (a particular class of) mistakes 
I tend to agree that it's a mess. Use the parts that you like. Ignore the others as much as possible. Some things, like generics, are wonderful. Others, like optionals, create far more complexity and ugliness than they fix. 
It's been frustrating to see the Swift team's apathy for HKTs. I posted a proposal on the mailing list for HKTs and the only responses from the team that I could get were "how is this useful?" To which I replied with the ideas of Monads and the enormous range of tools that you get for free just by implementing a Monad protocol. But there just wasn't any interest in that kind of stuff. I've been sticking mostly with Haskell since that...
Do you have cocoapods installed? - https://guides.cocoapods.org/using/getting-started.html These steps work with a new or existing project. Here are the steps: 1. Download cocoapods 2. Create pods inside your project a. Create project b. Close project - find project through terminal navigate to it and do pod init inside that project c. In terminal, while still in the same project, do open -a textedit podfile d. Add use_frameworks! above target and inside your target {project-name} do add pod 'reddift' - Save. e. Now while still being in the same project do pod install. 3. Make sure your previous version of that project is closed and go to the folder of that project and open the new workspace - It is white in color. 4. You should have the reddift in the podfile can navigate through it to see the files. When you want to use it in a new file that you have created you have to do import reddift Here is another tutorial on cocoapods - https://www.raywenderlich.com/97014/use-cocoapods-with-swift
&gt; The first developer preview branch swift-3.0-preview-1-branch will be created from master on May 12. It will be released 4-6 weeks later. I'm guessing that will be 4 weeks, right in line with Xcode 8 Beta 1 released during day 1 of WWDC on June 13th. 
People are [working on it](https://bugs.swift.org/browse/SR-34). While indeed not a primary concern right now, they are [open to it](https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20160418/001814.html).
Do you recommend this course? Is there something comparable for OSX development?
As /u/svwolfpack said you should use NSNotificationCenter. But you could also register the observer for the key UIApplicationWillEnterForegroundNotification which is called everytime you app come from background to foreground and do you all your stuff in the selector for this notification.
I come from a similar background (and timescales) as you and felt the same way after first encountering Python. A few years later I needed to learn and use Python for a real project and ended up loving it. I *thought* I liked Objective-C but now would be very reluctant to go back after getting comfortable with Python. Re-reading Objective-C code now makes my head spin :-) Swift seems to borrow from Python and I'm very much enjoying learning it. This is a round-about way of backing up /u/ASnugglyBear's comment. You might appreciate it more once you get comfortable with some new concepts. I'd probably have been just as perturbed as you if I moved straight from C/C++ to Swift.
I would suggest kinvley has a free tier, similar parse interface, well documented and best of all includes push notifications. 
There is one articles saying 3.0 will be the last breaking changes to API, future release will be backward compatible.
@Edwurtle is right you surely forget to connect your table view to your view controller. In the storyboard you should ctrl + drag from your table view to the hello icon at the top of your view controller. Select data source and repeat and select delegate. 
It doesn't allow Linux to sit on top, it (partially) emulates Linux. 
No other contribution? Let me share another one: https://github.com/apple/swift-corelibs-foundation
You should be very careful with `[unowned self]`. Basically what you're doing is telling ARC not to manage the reference at all, so if the object does get destroyed within the lifetime of the closure, you're left with a dangling pointer that will crash your app.
That's a side effect of a rapidly changing not yet mature language. It's not a bad thing, it's just something we have to deal with as early adopters. Rust had the same going on for a while too (haven't looked at recent releases), where compatibility would break every release. Once the language is more mature, you'll see more backwards compatibility and more time until a new major version drops. That's probably a better entry point for a hobbyist.
I doubt you'll get many satisfying answers. Swift has not yet reached stability and maturity on Linux. The language is buggy and the standard library is super incomplete. It's just not suited for real projects yet. I think 3.0 late this year is the target for Linux stability / completeness. Really hoping to see some good web frameworks pop up. The ones that have popped up so far have been a [shitshow](https://xkcd.com/927/).
[Image](http://imgs.xkcd.com/comics/standards.png) [Mobile](https://m.xkcd.com/927/) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini\-USB\. Or is it micro\-USB? Shit\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 2866 times, representing 2.6102% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d2we1j8)
&gt; Swift has not yet reached stability and maturity on Linux Not great news but good to know. Maybe it'll have matured enough by the time I'm comfortable enough with Swift on iOS.
The idea is good, but the execution I find a bit lacking. Markdown's spirit (in my opinion) is that it's plaintext, and even unrendered it is still readable/understandable. This DrawDown, while unrendered, isn't exactly the most readable. Take for example the line `"logo" 35deg 50,50` - without having read the article, what does it mean? `35deg` is pretty self explanatory, but `50,50` could mean a lot of things. Relative positioning, absolute positioning, maybe it cuts out a rectangle from the source. For something like this I'd rather have a more verbose syntax that I can hand to someone who has never seen this format before, maybe something like this: AppStore: * Take background.png, fill the whole frame * Take logo.png, rotate by 35 degrees, move to absolute coordinates 50,50 
Thanks a lot, I've posted this three places and this is the only and best answer I've received!! 
That's basically why they got rid of them. People were using them because they were familiar and ignoring the ways of doing things that better fit in with Swift's design paradigm. They're only logical if you're already familiar with them. Swift is designing for the future, not for the past, and part of that is breaking things now and intentionally not supporting convoluted ways of doing things in order to have better code in the future. 
I'd maintained for several years that my ideal language would be Python with Haskell's type system grafted on top, so when Swift came along, it was pretty much exactly what I was looking for.
It's an interesting point... But I think the same is really true of markdown.... Whilst you can read markdown you still need to understand the syntax to know two asterisks are bold. Unlike markdown one doesn't have the luxury of the prose and personally natural language was not the goal (for me that's too verbose). Much more plain text rather than SVG just as markdown is plain text vs HTML. Perhaps perfection lies between... But I'm happy with it
As already said, you really should keep it asynchronous, but since you're not satisfied with that answer, I'm gonna share a small library I created to convert between sync and async functions: https://github.com/Kametrixom/Swift-SyncAsync. **Use with caution**
What's the question you're asking?
Wow thanks so much guys for all of the advice and discussion. There's just too much to individually reply to but I read and appreciate all of it. To be clear, I wasn't dissing Swift, I personally currently do not like it but I *want* to change that and love it just like everyone else. I'm going to work on revisiting things like function types, closures (which to be honest, I'm still not seeing a huge advantage over functions except that a closure can add a simple function in one place vs a callback elsewhere), and optionals (which I understand the concept of, but it throws me off when I'm doing something and have to randomly put an optional after it or it doesn't work.). 
Yeah, the mapping is a dictionary. I guess I always think of dictionaries as mapping one value to another. =)
Yes, aliases - having _multiple_ names for the same concept, is harmful; it makes it hard to keep track of exactly what you are talking about if there's more than one name for it. And that is a very important point which cannot be emphasised enough. However, used carefully, typealias can be used to create _one_ name which (whilst admittedly it is an alias for something else), nevertheless actually makes it easier to manage the concept. For example, suppose you have a large number of functions with deal with some entity (I'll call it eggs), and they all return a callback function. (code written in the browser, so probably not exactly runnable as is!): func doSomethingWithEggsAndReturnAFunc() -&gt; (p1: Int, p2: Float) -&gt; Float { let result = { (p1: Int, p2: Float) in return Float(p1) + p2 } return result } func otherEggFunc() -&gt; (Int, Float) -&gt; Float { ... } func andMoreEggFunc() -&gt; (Int, Float) -&gt; Float { ... } and to use those functions: var f1: ((Int, Float) -&gt; Float)? var f2: ((Int, Float) -&gt; Float)? var f3: ((Int, Float) -&gt; Float)? f1?(4, 3) f1 = doSomethingWithEggsAndReturnAFunc() f1?(4, 3) // and so on Now I would suggest that the constant repetition of (Int, Float) -&gt; Float is detrimental. It is expressing a repeated concept using low-level terminology, thus obscuring its higher-level purpose. I think it would actually be much clearer to the reader if I were to introduce a high-level _alias_ for that expression. typealias EggCallback = (Int, Float) -&gt; Float Rewriting func doSomethingWithEggsAndReturnAFunc() -&gt; EggCallback { let result = { (p1: Int, p2: Float) in return Float(p1) + p2 } return result } func otherEggFunc() -&gt; EggCallback { ... } func andMoreEggFunc() -&gt; EggCallback { ... } var f1: EggCallback? var f2: EggCallback? var f3: EggCallback? f1?(4, 3) f1 = doSomethingWithEggsAndReturnAFunc() f1?(4, 3) // and so on And now we can use and refer to the concept of EggCallback without having to drag in Int, Float return Float everytime. So even though it is an alias, and the two are interchangeable, I think the code is improved. I can immediately ruin it though, by doing something like: typealias HenProductCallback = (Int, Float) -&gt; Float Now I have introduced a second name (and therefore could be mistaken for a second _concept_) for the same thing. So, IMHO the first typealias is *a good thing* and the second is *a bad thing*. 
I guess one of the reasons for adding typealiases was the fact that they exist in C and Objective-C (and they are commonly used in Cocoa Touch). So it was the matter of C/ObjC interoperability.
What's the value of i after this code? var i = 0 i = i++ You might think it's one because the increment happens "after", but it's zero, because the increment happens after reading the value of i but before the assignment. Now, you might ask why anyone would ever write something that bizarre, but what if it's: j = k++ but j and k are actually reference types instead of value types and point to the same object? It's not as easy to follow as you think. And as for C-style for loops, to someone not used to them, it's crazy that they pack three statements, one of which is executed once, one of which is executed before every loop pass, and one of which is executed after every loop pass. If you're trying to convey doing something a set number of times or iterating over a collection, Swift-style loops much more concisely express intent. for i in 0..&lt;10 {} for item in collection {} As for being universal, C-style loops only in exist in languages with syntax that derives heavily from C, though those happen to be the majority of current production languages in use (C, C++, Java, Javascript, PHP). Everything else uses either explicit start-end indices or for-in loops. https://en.wikipedia.org/wiki/For_loop
I don't think that changes that there are a great deal more bugs on Linux than on OS X? Suffice to say, "buggy".
You make a good point, and I do have primitives on the list but wanted to start simply with a problem that hurts me everyday. Thanks for the feedback, input and thought. 
&gt; The date for creating the last developer preview branch — swift-3.0-branch — has not yet been established. When that date is determined the plan will be communicated both on swift-dev and by updating this post. I imagine this will also have a date filled in during WWDC. 
Switch statements are already as efficient as you can get. Far more efficient than if-then-else, for instance. (Apparently no one has ever looked at the assembly created by various types of code - that was standard stuff with C back in the day and very educational in terms of understand native and optimized efficiency of code).
Haven't used any of the BaaS features for Azure just yet but I love Azure. Ii've looked at the feature set and they look as impressive as the rest of Azure. You can even host your own Active Directory in the cloud if you wanted to go that route.
Inside todo model you can add a property for the type of todo item. I think better way is to use an enum for that purpose so that you also get type safety.
Firebase is perfect for this. You could setup a parse server if you need server logic (cloud code). You could also use AWS with cognito for auth if you want more potential for expansion. 
Firebase is perfectly secure, and it is perfect for this. They even have a chat room example on their website, which you can probably pretty easily find with Google.
I'm learning OS X with Swift as well, and the book I'm using is Cocoa Programming for OS X : The Big Nerd Ranch Guide. It's gotten reviews, the 5th and newest version was released in April 2015, so it's pretty up-to-date. So far, I love this book. It's very well written and concise. 
Well it can get more efficient. I replaced the switch with this: background.texture = SKTexture(imageNamed: BGSelection[BGPosition]) I'd say that's a lot better especially in terms of efficiency. Before if I were to add a new background image, I would have to edit the switch in 4 parts (2 scenes: the button and what background to load when the scene loads). Now, all I do is add the new background to the backgrounds array and that's it and it works for all scenes. The bounds checking occurs in the didSet of the background position variable. So I managed to condense about 60 lines of code to 10. 
I use Ray Wenderlich's books. 
I'll assume that after filtering gameBoard either list is going to be empty (because gameBoard had no zeroes) or list will be a list of one or more zeroes. Now, what you do next depends on your requirements. If you must use a switch, then I think the switch to use would be (written in the browser, so may not compile!): switch list.count { case 0: return false default: return true } But, if there's no requirement to use a switch, then instead of the switch, you would just need return list.count == 0 // I'm not sure I have this comparison right, if not, then I assume != is the right one! And, if it weren't for the strictures regarding implementing 'functional-style programming', the whole thing can be done with: return gameBoard.contains(0) // again, I may have the true/false reversed 
People are working on bindings to GTK+, and I would imagine there must be someone working on QT too, but I have no idea how you'd go about that, given my seething hatred of C++.
Looks like a big emphasis on iOS, but I did find a few OSX tutorials on his site that I will check out: https://www.raywenderlich.com/category/os-x
 return list.isEmpty
And what would the type exactly be? Would the todo object still be one object that represents all occurrences of that repeated todo? Or would there be multiple todo objects, one for every occurrence?
Thanks! I found this project: [SwiftGTK](https://github.com/TomasLinhart/SwiftGtk) looks pretty good! Might try it tomorrow and report back with findings.
I went through almost every chapter in that book. It's excellent.
First, you want to make sure that your willEnterForeground method is being called, so I'd put a breakpoint/log there and see what happens (you can press the home button while the app is hooked up to Xcode and running, and it'll keep running). It looks like you're seeing logs from your location manager, which is a good sign, but you definitely should double check that your coming to foreground stuff is what's triggering that. Once you're sure that method is getting called, there's a couple things to look at. First, you don't need to re-initialize your location manager each time. Remember, if you're listening for your app coming out of the background, it means that your view controllers are still all loaded up and you've already run the initialization code in viewDidLoad. Pretty much all you should need to do is start updating your location. Second, I'm not sure how devices/the simulator handle debug changing of location... Try it on a device where you actually physically change your location, and see if that works. Also, try using requestLocation instead of turning tracking on and off (https://developer.apple.com/library/ios/documentation/CoreLocation/Reference/CLLocationManager_Class/#//apple_ref/occ/instm/CLLocationManager/requestLocation)... That'll give you a one-off report of your location, and you won't need to worry about battery.
I see firebase recommendations but can cloudkit be used instead? I think I read cloudkit has some baas features now?... **edit: found the [post](https://www.reddit.com/r/iOSProgramming/comments/44f56q/cloudkit_can_now_actually_be_a_native_alternative/) I was saw.**
IUP is a lightweight, cross-platform, native GUI toolkit. It is written in pure C with the idea that language bindings can be easily created for it by doing this. Here is somebody showing an example of Hello World in Swift on Linux 6 months ago: http://www.allbasic.info/forum/index.php?topic=428.msg4578#msg4578 I've been working on a native Mac/Cocoa port for IUP as time allows. https://github.com/ewmailing/IupCocoa 
Close, you an optional to self that you can unwrap to see if your object is still around. We have a bunch of `if let safeSelf = self` all over the place as a result.
You're absolutely right that identifiers were unreliable in AddressBook. It seems like the framework would just get lazy about merging new data into the contact and instead would just nuke the old contact and replace it with a new one when it would connect to certain backend types (I'm looking at you, Exchange). I haven't done any extensive work with the new framework yet, but I _did_ ask this question last year in the lab at WWDC when the contacts team was there. They said that the ids should be able to be relied upon, but I'm still skeptical. If you look at the iOS 9 headers for the contacts framework you can see[ there's still an IVar for the legacy identifier](https://github.com/JaviSoto/iOS9-Runtime-Headers/blob/master/Frameworks/Contacts.framework/CNContact.h#L32) even if it's no accessible from the public interface. Maybe they're doing better and computing some kind of hash, but I'd be careful until you're able to prove that it's indeed consistent. **[edit]** - I'm recalling now how I came up against this issue in the wild many moons ago. You should create yourself a simple app that would basically copy the contact data and stash it into CoreData or whatever you like. Whenever you open your app just have it update based on ids. If you notice over time that you get dupes in your app then the problem is probably still happening. Make sure to test with a variety of contact sources though! iCloud always seems to keep its ids, but I know Exchange used to be a nightmare. 
Hey. First, I'd like to thank you so much for taking the time to help me out! It's part of what really makes this community great. So thanks. Also, definitely looked into using the requestLocation and I switched everything to use it. It's much more elegant for what I need to do, you're right. Finally, I'm putting detailed logs in everything now to track down what's going on. I actually seem to have got it working for the most part, with a few exceptions: namely, once in a while, when I update the simulator location, it gives me the old userLocation for some reason (though this seems to happen only under circumstances where the custom location is changed both from the debug menu and from the debug panel). So I'm going to have to try it on my app and see. Anyways, thanks again so much for your help! All the best!
Types can sometimes be complicated. Eg 'Int -&gt; [String: (Double -&gt; (foo: Int, bar: Int))]' (random stupid example). If a type like this occurs multiple times, making a typealias for it makes perfect sense. I wouldn't really create a typealias for 'Int' or something like that though.
Thanks for the input. I thought this might be a possibility because every Swift-basted tutorial I've seen so far involves searching based on first and last name, then processing the returned results. There doesn't seem to be any mention of searching by identifier which would indicate that it wouldn't be a preferred method.
You are expecting a lot very early into the delivery of Swift on Linux. This especially considering that Swift will go through a major refactoring for Swift 3. I can't read the mines of the developers out there but I could see them wanting a more stable environment before putting to much energy into GUI support. Consider also that some basic must have have yet to really stabilize on Linux. For example IBM is putting a lot of work into a modernized Grand Central Dispatch implementation. This and other low level infrastructure must happen if you really want to benefit from Swift. Beyond all of that Swift really cries out for a more modern GUI framework that GTK, QT or many of the others. QT is rather massive and frankly ancient C++ code that really calls into question the value in continuing to use it. In an ideal world the Linux community would use Swift to break from the past. &gt;I think being able to use swift instead of Java on my raspberry pi project would be cool. Except, there is no way to create graphical interface? As I understand UIKit and AppKit will practically never be implemented. Even NSURLSession is not implemented yet. Are we stuck with only Java for now? Here is the thing it would do wonders for Linux if work a likes for AppKit and UIKit were developed. As for what isn't implemented yet, you are simply expecting too much too early. Swift isn't even completely useful on the Mac or iOS platforms. There are areas where you have to revert to Objective C. In any event if you are driving a Raspberry PI you have many languages to choose from and Java would be the last once I'd select. Have you considered Python? If not Python, one of the C languages. 
&gt; Depends on use case I guess. If the events are fixed in time eg. birthdays then IMO best to generate them all at once. You gave the perfect example of where I get confused. You see birthdays don't have a defined ending (unless you know exactly when someone will die of course). And since you can't generate infinite birthdays, I wonder how you decide how many to create and when to create the new batch and so on. I mean, I'm pretty sure I can code that, but I have no idea how to do it in a neat way. But I like the idea of a template, didn't think of that yet.
I think the issue that you are running into is that NSBundle is not a thread-safe class. This means that you can't load assets from your app bundle off the main thread, leading to the nils that you are getting. Second to that, I don't believe that adding to the array is a thread safe operation either, so it is likely to end in a corrupted array, unless you use locks to enforce serialised access to the array. For operations like what you're doing, it's unlikely that cpu is the bottleneck, more likely to be disk I/O, and thus threading will only complicate things. I think in general your understanding of threading seems ok, you just have to be aware of what operations can and can't be performed simultaneously by multiple threads.
Swift isn't really all there for Apple's own products. I'm a bit amazed that people think Swift will instantly be 100% on Linux. The reality is there is a lot of work to be done. 
That's odd, how can a non-mutating operation fail just for being threaded, such as the case for NSBundle?
If RxSwift uses language features that the compiler can't handle, that points to buggy tools. It's not RxSwift's fault for using Swift features as advertised.
It could be internally mutating; it’s an object so there’s no telling. The most likely case is that `NSBundle` is mutating an array or dictionary internally (probably as a cache). If run concurrently, the same method’s lines will weave together and the state will be out of sync.
It's his responsibility to make sure that advertised features work. Yes.
No problem! Good luck with it!
Look into AVKit, particularly AVPlayerView.
It's possible I'm missing something, but OP is not using `NSBundle` directly, they are using `UIImage` with its `named` constructor. This has been thread-safe since iOS 9.
Hmm. Well, `missyPhotoArray.append(photo)` is not (AFAIK) a thread safe operation, so it could well be that. You probably need to sync access to mutate an array, something like : let arrayQ = dispatch_queue_create("array",DISPATCH_QUEUE_SERIAL) // ... dispatch_sync(arrayQ){ missyPhotoArray.append(photo) } Otherwise concurrent writes will clobber something. I was actually able to pretty much reproduce failing behaviour with the following snippet : let things:[Int] = [1,2,3,4] var thangs:[Int] = [] dispatch_apply(things.count, dispatch_get_global_queue(0, 0)){ i in thangs.append(things[i]) } This will similarly crash because multiple `append`'s are happening at the same time. Wrapping it in dispatch_sync makes the crash go away.
FWIW value types are thread safe in Swift (including Array), it's one of the big benefits of using them.
Putting breakpoints in at all those spots is genius. I should have thought of that. Thank you. And I will check out UIAppearance. Great reply, thank you kindly.
I am relatively new to swift so I might be completely wrong. In this situation I would use a switch for the possible cases.
The "misbehavior" I'm talking about (not sure about OP) is not the exception that you'd get in Swift if you force-unwrapped nil. That doesn't happen in Objective-C, where you can send any message to `nil` without an error. The trouble is (so the argument goes) that by allowing this, the developer may not even consider whether the logic is correct in the nil case, leading to more subtle bugs. Swift forces you to explicitly handle the possibility of nil. My argument is that there is still just as much room for poorly-thought-out logic. Say you replace @property (nonatomic, strong) MyClass *member; ... self.member = [possiblyNilValue someMethod] with var member: MyClass ... self.member = possiblyNilValue?.someMethod() Now the compiler will tell you `member` isn't an optional, so you can either stop it complaining by making it optional, or sticking an `if let` in the assignment. There's no guarantee that you'll actually think about the nil case any harder that you would have in Objective-C, especially if you use the `if let` solution (which could even cause new bugs -- now there could be a stale value in `member` because the assignment never happened). 
Oh I didn't know it let you keep a constant empty if you give it a value after. That was what I had in mind!
Well yes, being weak in Swift necessarily implies being optional. That's exactly what I mean, though -- you still need to create a strong reference (the second half of the weak/strong dance) to avoid it disappearing out from under you. If you just used optional chaining each time you used the variable, it could start out non-nil and change to nil during execution of the closure.
Yes I suppose that could happen. 
Thanks man. Any tools that you would recommend to work with it?
Ah, perhaps you're right. Looks like my understanding of thread safety is a little worse than I thought it was.
The SecKeychain API is pretty straightforward in Swift-land (vs a version or two ago where you entered all sorts of UnsafeUnmanaged hell). There might be some wrapper classes out there, but I haven't investigated them myself. You'll probably get error -50 (errSecParam) if anything is slightly amiss in the query dictionary. That's the rite of passage with this API :-) 
Thanks a lot for your feedback! Our main purpose is sharing knowledge with everyone. We appreciate your opinion! Have a nice time with reviewing our code.
I can totally see why you would think that, but `dispatch_apply` waits until all the blocks it schedules are finished before it returns, the call itself is synchronous (unlike, say, `dispatch_group` where you'd need to wait on a semaphore to block). From TFM : "This function submits a block to a dispatch queue for multiple invocations and waits for all iterations of the task block to complete before returning". https://developer.apple.com/library/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/#//apple_ref/c/func/dispatch_apply
You only see this when you're looking at what is effectively closed-source Swift – you're probably using Xcode to look at generated headers. If you clone the Swift source code from GitHub, you get this instead: public func debugPrint(items: Any..., separator: String = " ", terminator: String = "\n") The `default` is produced by Xcode and means "there's a default value specified, but you can't see what it is because you don't have the source code." It's not syntactically valid to write this yourself.
The ```!``` will crash if ```myTextField.text``` is ```nil```. Something like this would be better and reflects what I assume is your real intent: (myTextField.text ?? "").characters.count The expression in the parenthesis will evaluate to a non-nil string of zero characters if ```myTextField.text``` is ```nil```.
`!` exists to say to the compiler "I know for a fact that this should never, ever be nil once it's initialized. If for whatever reason it is nil when the program tries to use it, it is an unrecoverable, fatal error, and the right thing to do is crash." If that's the behaviour you're after (and there are times when it is) then that's just fine. In the case of stuff loaded from a nib, like text fields and the like, if those are nil something very bad is going on, and you get to choose between trying to handle the error gracefully, or bail out and start over.
It's a suggestion. The compiler wants to compile. Of the two options, `!` more closely resembles the semantics of your original code. 
Or a study app!
If you're just getting started with Swift, I'd argue that there are enough online resources if you feel like looking. It's important to remember to keep a skeptical eye on any blog mind you. Some resources are better than others. Once you become (or already are) a more advanced developer, certain books can really help with the intricacies of swift, iOS and other frameworks. But by then you should probably know what you're looking for, and can buy a book in and area you're interested. just my $0.02
I have a lot of experience with Java and C# but not much at all with objective-C or Swift. I think i'll follow your advice for now and just focus on what I can find online before I go and buy a book. Thanks!
Apple even offers a free book in iBooks for Swift. Now, if you're planning on learning HOW to make or do something with Swift, then you do buy a book. I learned Swift from Apple but I bought a SpriteKit book to learn how to make 2D games. The reason for this is because learning the material is a straight line when reading from a book whereas online you would be jumping around all over the place in SpriteKit. 
What's nice with most of the PDF books, such as the ones on RayWenderlich.com, is that they are kept up-to-date with changes in Swift, iOS, and Xcode. So it's nice to buy the PDF versions to always have access to the latest versions.
First, it's a dictionary, not an array. An optional is a special object wrapper that allows an object to be a specific type or be nil. Dictionaries return an optional when you use the subscript operator so you can safely test for the presence of a value rather than crash. Your statement simply says, if I can extract this value into a non-optional type, then execute the code block. 
This seems like a false dichotomy: you can do both. My book, [Hacking with Swift](https://www.hackingwithswift.com) is available online to read in its entirety, for free. It goes from zero Swift knowledge to thorough knowledge of UIKit and SpriteKit, by making 39 practical projects. It's also designed to follow a smooth learning curve, so you learn things in a sensible order. If you're looking for quick answers to coding questions, my [Swift knowledge base](https://www.hackingwithswift.com/example-code) has almost 300 questions and answers for the most common coding questions I've received. Now, [you can buy the Hacking with Swift book if you want](https://gum.co/hws-book-pack). One purchase gets you the 1300-page PDF (for printing, if you hate trees!), ePub (for iBooks), Mobi (for Kindle), and HTML. But the tutorials themselves are identical to the online version: you only have to pay if you want to support my work, or if you prefer reading without adverts. I am, slowly, adding exclusive content to the purchased version, starting with a quick tips wallchart last week. However, this is bonus content to thank supporters, rather than changes to the tutorials; I want to carry on releasing the tutorials themselves online for free, because a lot of people just can't afford the download version. In addition to Hacking with Swift, I also wrote [Pro Swift](https://gum.co/proswift), which is a book + video course that teaches advanced techniques for writing more efficient Swift, and I'm just making the final changes to a new book, [Objective-C for Swift Developers](https://gum.co/objcswift/). All three of these books are linear: you can jump around if you want to, but I've written them with a specific flow from start to finish so you learn things in a useful flow. All three of them will get a free update for Swift 3.0, taking into account any changes introduced at WWDC, as well as further free updates as I add new content. And I'm happy to answer questions on all three of them, either here, on /r/hackingwithswift, or on Twitter: @twostraws. So, apologies for the long reply to your question, but I hope you can see that you don't need to make a choice now: you can find great content online for free, enjoy that as much as you want and learn as much as you can, then buy what you need only when you need it. Swift is a *fun* language – dive in and start making something, and I'm sure you won't regret it :)
If you have no experience on iOS, i would recommend an introductory book to learn the basics of the various frameworks, way better than going through tutorials without a clear direction. The books from Big Nerd Ranch are the ones i usually recommend: https://www.bignerdranch.com/we-write/ios-programming/
Thank you for the encouragement and the explanation why you think it's a flawed proposal. I see myself as a bit of a basic programmer, so I was kind of expecting that I had missed some reason why this is a flawed idea. But I didn't know what the flaw was so the best way to find out was to just ask. I'll certainly continue to learn and try to think of ways to contribute to the language.
Right on! \*Internet high five!\* :)
&gt; if I do it by accident I want the compiler to treat it as an error Crux of the issue right there. The more accidents we classify as compile-time errors, the more bug-free our code can be.
Seriously, the Swift book provided by Apple in the iBooks Store is very good. You should begin by familiarizing yourself with the material in there as much s possible.
CleverError is right I run into this sort of thing all the time in my layouts and the answer is usually to place everything into another view which you control. Native iOS controls will almost always override whatever dimensions you try to place on them.
You can transport the value as an optional but you can not apply an operation to it as an optional. I believe jeremes suggested you use a 'guard let' or an 'if let' statement. put more simply, you should always test your variables for content with some sort of conditional statement before unwrapping them, but you must unwrap them to apply an operation to them. An optional doesn't know it is a String or an Integer until its unwrapped. That is how I think about it. That is what makes it nil safe before unwrapping. 
yea, it's basically only safe for UIControl events and the like, but that's a significant minority of my usage. I'm using block based categories for all the common controls to eliminate the stringly typed nastiness of target/selector. You're right though that it's always safer to do the dance even when it's not actually necessary.
I definitely want to get to the point where I can make something with Swift so I think i'll start online and then move on to books
I definitely agree that I can do both and I probably will end up doing both, I just wasn't sure if using a book is worth it since there's so much online. Thanks for the resources, I'll definitely check them out
Hmm, yeah, I agree with that. I also miss the syntactic shortcuts that more dynamic languages provide so I guess I was trying to find a middle way.
Alright, thank you very much :)
As an author of Swift books, clearly I think books are a good thing :)
I think they don't because the default argument might be a `private` or `internal` variable. When writing documentation for functions/methods with `default` arguments, I say what the default is.
Apple offers many resources for free all the people writing books started with apple's resources too
This periods of limbo between releases cause a lot of confusion and I think are very detrimental. I think the old syntax should be deprecated but not outright eliminated to ease these transitions.
I think this book is worth buying: https://grokswift.com/book/ The author just released a significant rewrite/update a few days ago for Swift 2.3, which makes me confident that they'll also do one for 3.0 (which is going to be a huge change). I haven't purchased either of the objc.io books (Advanced Swift, Functional Swift), but objc.io issues were always of such consistently high quality that I would recommend them. I've also held off on Pro Swift, but I like how the author posts on Reddit and provides Hacking With Swift for free. I will probably end up buying it at some point if/when it goes on sale. There is a great free source for learning algorithms &amp; data structures on Github: https://github.com/hollance/swift-algorithm-club The Swift Programming Language (the book provided by Apple) is actually really, really good. It seems like it was structured after The Ruby Programming Language (it's even named similarly!). Both books provide you with an excellent overview of their respective language in a succinct and engaging manner, while still managing to be thorough.
It...depends? I have a background in multiple programming languages, came off time learning Rust and Scala, and found picking up Swift really simple from the online material. If I had no experience in modern type systems, use of `Optional`, functional programming, pattern matching on `enum` types, etc., learning all those things would be a total slog and much of Swift (e.g., `if let`) would be a complete mystery.
I agree with most of what you say, but say we have a collection view with two columns where each cell is 100 points wide. Say you want to store the number of columns somewhere. Would you suggest storing it as a `CGFloat`? To me that looks unreasonable because obviously the number of columns must be an integer. However, say you want to calculate the total width of the cells. You'd explicitly have to cast the number of columns (which is stored as an `Int`) to `CGFloat`, which doesn't look too great either. If we think about high school physics for a second, 3 meters times 5 is 15 meters. 3 meters times 5 meters is **not** 15 meters. You wouldn't convert the 5 to the unit meters, because it doesn't make any sense. Likewise, I think it would make more sense to be able to calculate the product of a `CGFloat` with an `Int`, without having to do any explicit casting.
Alamofire is a great cocoapod to handle asynchronous network calls. Depending on your application it may be a good option.
I've never really considered doing sales. $30 always struck me as pretty cheap for a 250-page book plus six hours of video :) I'll have a think about it; I spend more time coding than doing marketing, as you might imagine! In the meantime, everyone who buys Pro Swift or Hacking with Swift gets a discount on my other books, so I guess that sorta counts. The "Swift Programming Language" title is following in a long tradition, not least [The C Programming Language](https://en.wikipedia.org/wiki/The_C_Programming_Language) and [The C++ Programming Language](https://en.wikipedia.org/wiki/The_C%2B%2B_Programming_Language). Like '…in a Nutshell", "The … Programming Language" has become a brand all by itself!
I hate ambiguity just as much as you, but obviously we can just define some sort of order. `CGFloat` comes first, then `Double`, then `Float`, then `Int`. Or something. I'm sure you don't mind writing code like this: let something = 3 + 2 * 5 Even though someone could argue it's not as clear as let something = 3 + (2 * 5) However, because we established that `*` has a higher precedence than `+`, we allow it. I think we could do the same when taking the product of an `Int` and a `CGFloat`.
I like this, one alternative is if myTextField has the chance of being nil (myTextField?.text ?? "").characters.count
You are definitely right about one thing, you are babbling.
It's fantasy land, I know, but: UXKit for OS X development, OCR built into Core Image, handwriting gesture recognizers, an integrated weather API, and a `UIImageView` that automatically handles remote loading out of the box. 
I'll second the OCR. Imagine being able to index all your images by the text they contain. And I'm sure I'm not even being imaginative enough. :)
As someone who knows nothing about swift: will 3 expand on 2, or replace it? Should I start after 3 comes out and materials are updated?
I had heart palpitations when iOS 9.0 introduced `CIDetectorTypeText` – but sadly it just says "yup, I found some text in this rect," without actually trying to convert it.
Swift 3 will make a number of very large changes, but the vast majority of people will be affected by one specific change called the "Cocoa renamification." The TL;DR version is this: lots of things in iOS have names that were designed to match Objective-C's style, but Swift's naming conventions are shorter and with less repetition. So, in Swift 3 they intend to rename large parts of the system to be "more Swifty." On the flip side, all the core parts of Swift won't change: optionals, closures, classes vs structs, functional programming, tuples, destructuring, guard and defer, operator overloading, etc, etc, etc. There's still a month before the very first version of Swift 3 is announced, and even then it will be a couple of months before it's considered stable enough to learn. As a result, I suggest learning Swift 2.2 right now, then upgrading to 3.0 when it's ready. I doubt it will take more than an hour or two to figure out the changes for Swift 3.0, so there's really no point waiting. Keep in mind that not all authors will be issuing free updates for Swift 3.0, and those that do might not have a fast turnaround time. If the final version of Swift 3.0 is available in September (which is likely), it could be October, November, or even later before some books get an update, if ever. For my own books, I think I'll probably wait until beta 3 before I put out a free update. I don't really want to make lots of changes then see them made redundant by newer betas, but at the same time I don't want to keep people waiting too long!
System wide dark mode on iOS 
Thank you very much for the detailed reply!
* Access to Siri (e.g. "Hey Siri, ask YouTube to search for Minecraft" and then the YouTube app pops up with search results for Minecraft -- obviously only if the YouTube developers added support for voice commands. Similar to how Alexa supports 3rd party skills. * AVPlayer caching * API to purge only memory objects from NSURLCache 
It might be possible to do it without breaking BC, in some places, by providing method overrides with an additional closure parameter, but TBH I expect you're right.
Hot view reloading. Build it once and see the changes update immediately in the simulator. 
Thanks! I also think learning the frameworks and OS would be beneficial before I dive into Swift.
its going to be the value after ??, in your case its fullName var which equals to"John" For testing you can create swift playground project
You're right, I feel really silly, of course The C Programming Language is the original (at least, I think it is).
thanks, Does it matter if I choose osx instead of iOs when creating a playground? Also, can I use the same playground to test objective c code ? or even c ?
In this case (pun intended), "let" creates a temporary binding of "side" so you can refer to "side" the line below. if you remove let, "side" means nothing and it won't compile.
Thanks for the solution, works great! :)
Yeah that's a good point 😬
That's a good plan :) I studied by reading books; A lot of books. I've read all of RayWenderlich's books, Advanced Swift, Functional Programming with Swift, and Apple's Swift guide. I also did the teamtreehouse Swift video course and Paul Hegarty's Swift Stanford iTunes U videos. I watched and rewatched WWDC videos as I commute to work. Even then, there are nice little gems that I find in blogs and articles. It's getting to be a big language, and I'm still picking up little trinkets every week. My verdict so far is no single book or series can cover everything. That being said, if I had to pick one that covers the most, it'd be the RayWenderlich site simply because they have literally 100+ contributing authors offering information at a large variety of angles. 
Did you try it on XBLA? It wasn't about hard sell, it was about customizing the experience when you knew someone had five minutes. I had a game on there that offered 28 or so minigames that were chosen randomly, but I made sure that in free trial mode the same five games were offered – five that I had chosen as showing a good mix of what the full game offered. Apple has rules for just about everything in their app review guidelines; there's no reason they couldn't add "Apps must not mention free trial mode or provide any incentive or encouragement to unlock the full version." Offering two apps a) continues the problem where high-quality paid-for apps appear lower in the App Store than low-quality free counterparts, and b) fragments your user base while increasing your work.
&gt;Right up until the point where you give it a certain input at which point it goes horribly wrong and you don't know why. I think you're exaggerating the issue. The compiler will know the type of the result of the operation, so if you made a mistake, the program will most likely not compile - which is similar to what happens if you try to multiply an `Int` with a `Double` right now. I don't necessarily mind explicit casting that much, but I think you're making the downsides bigger than they are.
The compiler is not able to read your mind, it is never, ever able to be sure that your implicit cast was on purpose, it cannot mark it as an error. The downside of having to remember another complex set of binding and precedence rules for casting operations - assuming it is even possible construct - is considerably greater than an occasional `CGFloat(x)`. And again, while you may find these features desirable they are the polar opposite of Swift's design goals - or those of any type safe language. Once you're doing implicit casting of any kind type safety is broken. Swift is not Python.
Reminds me of Samuel Vimes and the Gooseberry. 'It claimed to have 15 functions, although it appeared that at least ten were apologizing for the useless manner in which it performed the others. One is the ability to recognize handwriting - "I'd recognize it anywhere"'
I was referring to how the compiler will show an error if a function expects an argument of a certain type, but the result of an operator is of a different type. This has nothing to do with reading your mind. &gt;Once you're doing implicit casting of any kind type safety is broken. Swift is not Python. This is a nonsensical statement to make. The compiler still knows exactly of which type each variable is, so the language would still be type safe.
There's a [git repository](https://github.com/hollance/swift-algorithm-club) tackling this very topic.
(nickName ?? fullName) = (nickName != nil ? nickName : fullName)
Do you have a link to the tutorial? It's hard to know what's going on without more context.
Thanks guys. I'm still trying to get used to Swifts crazy syntax.
https://www.bloc.io/swiftris-build-your-first-ios-game-with-swift
Good. Vapor is definitely the best one. I'm also very glad to see Perfect so low on the list. It's just so... not-swifty.
Can you post the exact code for that you wrote for this class? From your question it doesn't seem like there's anything wrong. The self keyword should prevent such errors.
Most hope is "NFC". and have to make simple of some String functions such as "stringByTrimmingCharactersInSet()" "stringByReplacingOccurrencesOfString()" "componentsSeparatedByString()" to "trim()" "replace()" "separate()" etc.
What's Vapor? Can't find it anywhere on Google. EDIT: I'm about to start learning Swift, so should I use Vapor instead of XCode?
Vapor and Xcode are unrelated. Xcode is the tool you use to write Swift. Vapor is just a bunch of helper-code (called a library, or framework) to help you build web sites using Swift.
It's web framework in Swift. e.g., import Vapor let app = Application() app.get("/") { return "Hello, world." } app.start()
One of the biggest benefits of this is that it will stay up to date. Other books become obsolete before the end of the year. 
It can be done but why throw unnecessary obstacles in your own path, especially if you are learning still. You are setting yourself up to fail for no good reason.
technically that would work for a 6s screenshot, but im also looking to get a screenshot of a 4s with a scroll view - as in, all material in the storyboard, seen and unseen. 
Can you show us 100% of the relevant code and not just the errant line?
Optional refers to the variable type, not really an operator. var thing: String? So this variable is of a type sting, it can be nil. var otherthing: String This variable is of a type string and cannot be nil Edit: Exceptions are called ErrorTypes in Swift right now. The reason you would use an optional value would be to perform actions only if something has been set. If thing != nil { // do a thing } Though a more swiftly way to do that would be If let notNilThing = thing { // you can now use thing as though it was not optional } Or Guard let notOptionalThing = thing else { //exit the function here } Ps: sorry about the capitals, on my phone and it hates lower case letters
Noob question. So exactly does it mean? It's a framework used to create applications that load data from a website, or create a website within an app? 
Yeah, if you don't know, as long as you don't say "Dunno! Next question!" and express yourself as "Admittedly I haven't used a lot of other languages to compare it to, but I just have a blast writing in it." or something similar would probably be an answer at least *I* would be happy with. To answer your "how would you answer it" question, I'd probably state how I love that it's statically typed compared to many other languages, which means a lot of your nasty mistakes can be caught at compile-time rather than run-time. I also like that it's concise without being overly-so, so the code is highly readable but without having a lot of the cruft Objective-C has, for instance. Using structs and enums are also a lot nicer in Swift, I use them so much more than I did in Objective-C.
Siri, night mode, and more 3D touch power would make me really happy. Obscure but being able to access `UILabel`'s TextKit stack would be phenomenal as well. Oh, and Safari View Controller not being as limited as it currently is. Just being able to properly use it in a navigation stack would be a great start, but being able to preload it, give it a dark theme, etc. would be phenomenal. As is it's awesome, but limited. 
You could create an API using swift that runs on a server so your app could consume (use) it. So within your app, you'd do a GET request using afnetworking or alamofire or whatever to some url you're running this on https://mySwiftWeatherApi.com/weather/80401 and that weather API would return the current weather JSON data to your app for that zipcode. Traditionally, when you make a call to an API to get data for your app to use (maybe your using the reddit API because you're making a custom reddit app) the backend code for that api url is written in C#, Python, PHP, Node,js, etc. These are often referred to as server-side languages, and swift is joining that group.
New to Swift, but not to programming. Is this a front-end facilitating framework, or is it backend, a là Rails and Django? Server-side Swift sounds interesting, but why should I use to it over Rails in a new product?
So basically it's a way to get data from a website to load the data into my app using Swift? Isn't that what SwiftyJSON is for or am I not understanding correctly? SwiftyJSON is not like Vapor, right?
Can you can debug server-side through xcode with breakpoints? Kinda hard to tell from the docs. https://vapor.readme.io/docs/xcode 
 let characterSet = NSCharacterSet(charactersInString: "anystring") Mind you, the description of this object will still only be `&lt;__NSCFCharacterSet: [address]&gt;`, as character sets just contain bitmaps, and aren't intended to be human-readable.
Creating server-side stuff has always been my weakness. Where would this live/run? I'm assuming you would have to spin-up your own server on either OS X or Linux and open it up to the outside world I'm also assuming that you wouldnt be able to use a web-hosting service?
"cloumns"
Can you post your full code? There's *loads* of stuff missing here that you'd need in order to retrieve and print contact details. 
To speak about storyboards: I have never been happy working on an app that used them with more than one developer on the team. I started a new app recently, and have eschewed IB completely. Things have been much more predictable and easier to manage. It's more typing, but a lot less frustration. Also anchors, anchors are your friend.
This would be so awesome! &gt; All Swift code that uses libdispatch via the current C API will be affected by this change. That not so much...
Yeah, I feel like that's really unnecessary. The "new" api is just be a wrapper on top of the C api, so there's no reason why we can't still use the C version. The current SPM convention is to prefix C libraries with `Lib`. So, what I would do is rename `Dispatch` to `LibDispatch`, and call the Swifty api just `Dispatch`. This way, to use the swifty version it would just be `import Dispatch`, and to use the old, C api would be `import LibDispatch`. 
I can help, but I have a few questions: 1. Is parseJson() on a background thread? 2. Are you trying to delete all "Orders" before saving new ones? 3. Error handling?
parseJson is not on any specified background thread.. Does that mean that it is running on the main? Second, yes. For right now anyways, I am deleting all of the orders in my 'order' entity every time the user calls this parseJson function which is attached to a download button. I'm doing this currently because I don't have a good way to sync only new ones yet. 
Oh, you are going to need a web service that accepts the posts to store and distribute them. Do you have someone to run your server for you?
This is not directly related to your problem, but I have found a great JSON 'parsing' library called "Decodable" that you might check out: https://github.com/Anviking/Decodable Ok, related to your problem: If you are calling reloadData() and your dataSource method `numberOfRows...` is not getting called, I suspect that it's not the way you are calling it, but some other thing that's causing things not to get reloaded. If you have overridden any methods from your table view controller (or table view), always make sure to call into the super class's version in those calls. There's also the possibility that the tableview you are calling reload on is not the table view you think it is. 
Haha, great catch. My first thought was "Dumb swift compiler warnings", but then realized that there's no certain way it would know any better. The best they could do would be to use a heuristic for `init` methods and noticing you are assigning `self.x to x`, which doesn't match an input parameter, and then emit the above warning, with a trailing suffix of like `"... perhaps there's a typo in one of your init parameters"`
The proposal is about changing the way libdispatch is being imported. It is not just an additional wrapper. An accepted, related proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0044-import-as-member.md
How are you linking NSTableView and Core data Entities. NSArrayController provides you api similar to NSFetchedResultController on iOS. Also in IB, bind view based NSTableView content to NSArrayController and than select TextField in TableCell and bind it to Table cell value with model key path objectValue.yourAttributeName. I would suggest you to take core data [lessons](https://www.lynda.com/iOS-tutorials/Core-Data-iOS-OS-X/101461-2.html) by Simon Allardice available on lynda.com. Although it is in objC, you will learn the basic which is equally applicable to Swift.
I can't find appropriate codes for that. that is why I'm asking.
But I guess this proposal would be returned at its current state. There are a lot of doubts on the naming and proposal coverage in the mailing list.
check out Unity instead
So it looks like Vapor support Linux and Swift 3 - that makes it better than Zewo for me. Time to give it a go!
This is mostly as compared to Objective-C, and it's just a few of my many loved features of the language and syntax * extensions * higher order functions like map, filter, reduce * closure syntax is a lot more readable than blocks (at least to me) * no separate interface and implementation files * optionals * no fucking (required) semicolons
I'm confused, where did you get the idea that Zewo doesn't support Linux or Swift 3? Zewo most definitely does support Swift 3 and Linux, and is even more on the bleeding edge than Vapor is. In fact, unlike Vapor, Zewo doesn't even support Swift 2.2 :P. That's not to say that you shouldn't use Vapor. Just make sure that if you do use Vapor, use it for the right reasons. For example, Zewo is essentially a bunch of unopinionated tools that work together well, while Vapor is a single, opinionated tool (which incidentally relies on some Zewo modules). Depending on what kind of developer you are, it may or may not be for you.
I think what you don't consider is that, when looking at a colour circle, when adding two colors, your going in a line between the two colors, not along the radius. So of course, around the middle, you're gonna get some color with lower saturation. The whole 'let mixColor...' line is also super weird, what do you expect you get? At 100%, you get the average of red+yellow, which should be a brown-ish orange? At 50%, you get red+green, which is almost grey, and ad a bit of green, so it's grey-ish green? I'm pretty sure that what you want to do is this: let progress: CGFloat = 0.7 // use the exact values that you want here let startHue: CGFloat = 0.0 // red let endHue: CGFloat = 0.35 // green // I'll also leave figuring out the exact saturation/brightness up to you, you could get em from your original colors with color.getHue(saturation:brightness:). let color = UIColor(hue: startHue + (endHue-startHue)*progress, saturation: 1, brightness: 1, alpha: 1) This interpolates between two color's hues.
Somehow that slipped my mind, thanks for the idea. Sent the email :)
any recommendations 
It's like it was written ten years ago, before all the lessons learned from Rails and Node. It just feels like an ancient Java framework instead of a modern Swift one. Very little use of closures, generics, higher abstractions, or any of the features that make Swift great. Instead we're stuck writing boiler-platey code that feels like it's already 10 years out of date, and far out of line with Swift best practices.
I used it originally, but I had a hard time retaining information. It was essentially writing code they told you to write and I never really learned the material that way. I learned better with Stanford CS193P. Their iOS 9 curriculum just came out a month ago so it's up-to-date. 
Just pushed a code. May be it will be useful for you too.
Don't know if you have something like this already but what I would really find helpful is something that analyzes complex app layouts and provides an overview of what UI constructs to use to accomplish it. By that I mean take some well known apps with a complex layout and then break them down and say, "ok to achieve a layout like this you would use a presentation controller nested within a blah blah blah controller that has a foo container embedded inside it". It's that sort of thing where I find myself struggling with iOS apps. Writing code i.e. Swift is the easy part; knowing what UI container controls to use in a given situation is what I would find really helpful. Thanks for hearing me out. Btw, admittedly I haven't gone thru your courses so excuse me if you do cover materials like this already (and if you do please point me towards the specific section and I'll definitely purchase it).
A couple of others have said this is the kind of thing they would find useful, but I'm afraid I don't have a book following that style right now. I do have [a large collection of Swift example code](https://www.hackingwithswift.com/example-code/), though, which gives you a lot of code to solve common problems. It's not targeted at specific apps, but you might find it useful anyway.
The second comment of the accepted answer to [this StackOverflow question] (http://stackoverflow.com/questions/36314/what-is-currying) presents a very simple example of why someone might want to use this.
I'm learning Haskell now. Currying is fundamental in Haskell. If you're interested, that's a good way to investigate what it is and why it's useful. 
UIViewController has a method called prepareForSegue(). When you navigate to the new view controller, this method will be called, and you can use its parameters to pass data to the new view controller. For example, when you press a button, presumably you'd call performSegueWithIdentifier(identifier, sender: self). You just need to override prepareForSegue, add a switch statement for the segue.identifier property (will be an optional one, so don't forget to unwrap it) and test for the correct identifier. Afterwards, you can access the incoming view controller with segue.destinationViewController, which you can cast to the correct UIViewController class and set any property you'd like. Data should be passed to the new view controller as a result.
+1 for no fucking semicolon 
Currying and partial application are used extensively in some functional languages, but may not be useful for you. An example from [this article](https://medium.com/@jd./a-gentle-introduction-to-currying-and-partial-application-y-f-a-b-x-35953da71aa6) is a graphing calculator that plots mathematical functions: y = f(x) Let’s say you want to plot lots of lines. I.e. you need lots of `f`s. Here’s a curried function that works as a factory for linear functions: linear(slope, intercept)(x) = slope * x + intercept Thus you can make your lines by partial application: f = linear(1, 0) This makes `f` as a function that returns a diagonal line. The first two arguments have been passed (partial application), but the final `x` is pending. So you can pass it to the plotter which is expecting `f(x)`. Edit: obviously this is not a Swift example though. They’re used extensively in Haskell and Scala for example, including in the alternative format `linear(slope, intercept) = (x) =&gt; slope * x + intercept`.
&gt; but I'm afraid I don't have a book following that style right now well let's make it happen brother ;-) It'll sell like crazy I'm sure especially since there aren't any other resources like that out there
Ha! Thanks, I'll think about it :) I have a *big* list of books I'm working on right now – it will take me quite a few months to get through them all!
From what I've seen currying is a restricted and non-general subset of partial application, and even most partial application systems are crap (like if someone partially applies some value to X then you're stuck with that value). A good partial application system can be good and useful though.
&gt; Is it even something I have to worry about? Nope. They are removing this feature, in part because it has limited niche uses, and also in part because it is difficult for users to grasp. &gt; Does anyone know of a good tutorial on it with concise examples that show a benefit of using it? Not really; I agree the resources on it are limited, and I think that has to do with the fact that not many people would use it unless they are coming from a background in functional programming such as Haskell (as opposed to, say, an iOS developer). The best way I can summarize it in the context of Swift would be: It is a (theoretically) high-performance way of creating functions to pass to `.map()`, `.filter()`, `.sort()`, etcetera. Say you deal with arrays of `NSColor`: let someColors: [NSColor] = [.blackColor(), .blueColor(), .redColor()] If you frequently needed to set the transparency of each color within one of those arrays, you could start with a curried function: func setAlpha(amount: CGFloat)(color: NSColor) -&gt; NSColor { return color.colorWithAlphaComponent(amount) } If you wanted to set the opacity of an array's colors to 0.5, you could then derive a function like so: let halfAlpha = setAlpha(0.5) This new function has the type `(NSColor) -&gt; NSColor`, making it suitable for applying to one of your arrays like so: let semiOpaqueColors = someColors.map(halfAlpha) If you're thinking, "there are better ways to do that," then you're right; closures are a much more Swift-like approach, which is why they've decided to ditch currying altogether in their favor. I believe the benefit with currying was that it provided the same (or similar) performance characteristics as a "normal" function that took the same parameters all at once. Closures have a bit of an overhead, but this is negligible in the grand scheme of things, especially when they can better focus efforts on having the compiler optimize them without needing to worry about making currying work properly.
I personally think I don't retain the information in your book easily or as much because it's "jumping around." I personally learn more in a linear direction; still a good book though.
Yes it's kinda popular and well known here. I recommend as a reference guide.
Honestly you should have been and current be coding daily in Swift to get practice - the version isn't important because once you've learned 2.0 you should **trivially be able to pickup the differences with 3.0** because 90% is exactly the same. If you can not, you probably are not cut out to be a programmer at all. This is because programing is NOT an academic endeavor but a practical applied activity that is primarily learned *by actively doing it* rather than sitting in a class *passively listening about it*. A course makes sense if: * You've never programmed before * You are learning a radically new type of programing (e.g. learned OO, switching to Function or Assembly) that requires a different mindset/world-view * You have experience yet you have a commercial need to learn quickly and have deep pockets for an accelerated class pace and time set aside to not be interrupted by normal job interrupts For everything else, you learn by reading documents/APIs, coding on your own, talking to other programmers, etc.
I'm new to /r/swift (and software development in general). Have to say it's awesome how involved you are with the community and this is a great example! Keep it up, us newbies appreciate it!
Thank you for the encouragement! :)
I definitely recommend Hacking with Swift and its continuation [Pro Swift](https://gumroad.com/l/proswift)! I started learning iOS development in Swift a few months ago after years of working in web dev (Ruby, JavaScript) and these tutorials helped me a lot! What's important Paul (author of both books) is a really cool guy, always helpful and worth following on Twitter. ;) From other resources you can check: [Stanford CS193P in iTunes U](https://itunes.apple.com/us/course/developing-ios-9-apps-swift/id1104579961), they are running a new edition right now that covers Swift 2.2 and iOS9; [Design+Code](https://designcode.io) if you're interested in a more design-oriented approach to iOS development; and of course [Apple's developer center](https://developer.apple.com).
Thanks guys for all the responses :) This sub is fantastic for those like myself coming from C based languages to Swift. 
Eh. That's kinda an abuse of extensions. It's not really a big enough problem to warrant a library and dependency. But it's also not something that you want just sitting in some corner of every project you write, as readers of the code will inevitably ask "What's that?" when it could have just used the official name.
Yes, this is the orthodoxy but it's also deeply flawed for many applications, especially ones like OP describes. This technical only works well for extremely lightweight uncoordinated models. (Yes, Apple fucked this up!!) Doing a model that is even a little complex and this orthodox solution becomes utter Epic Fail. Singletons, if done properly and carefully, are far better in many cases like this. The other possibility (which also can fail) is to make a document-based application and use the document object as an effective singleton that passes recursively components of a well-designed model. The place when even this fails is when your model doesn't match the view hierarchy - which is not at all unusual - the metaphor for display is not essentially or fundamentally always the same as the metaphor for the model. One way to deal which this "impedance mismatch" is to create a View Model that is generated on-the-fly from the real Application Model. Then it's the dynamically created View Model that matches the View hierarchy but you can maintain the Application Model separately to match the Application's "bigger picture" requirements.
&gt; t's a great way to learn Swift if you can already program in a different language I have to echo this. I really liked Apple's book (although I only really glanced through it and read bits and pieces). I had a friend with no programming experience try and do the same and that's when I realized its definitely not a beginner style book. 
agreed. I think it should also give a warning any time there is an unused parameter to a function. func haha(x: Int) -&gt; String { let y = 7 return "haha" } That warns about the y, but not about the x. 
Concurrency and Parallelism will be implemented (cross platform) somewhen after 3.0. So why bother with a Mac only API? As far as I read the proposal it adds no significant new functionality. Instead it makes the existing functionality more swifty (+ breaking existing code). I think this proposal should be skipped and instead they should work on a (new) cross platform library.
Added a video showing a brief overview of the tool... https://www.youtube.com/watch?v=rfUpann-zG4&amp;feature=youtu.be
Never heard of it, seems dangerous! /s (Buy the book!)
Yes, it is kind of hard to retain everything, however, in my experience that will happen with any method you use to learn. The usage of swift in iOS apps is very complex and non-linear, unlike scripting languages like python. What I like about your method is that I remember what I applied in which project and can refer back to it anytime while developing my own stuff until I completely assimilate the contents. Keep up the good work man!
I didn't say it was a good idea, just possible lol I don't disagree with you.
Why not use SwiftyJSON to avoid all that boiler plate code? It reduces the amount of code you have to write and is way cleaner.
SwiftyJSON helps, but wouldn't you prefer to just read Swift classes/structs straight out of the pipe? The current workflow is just a byproduct of JavaScript ruling the web, and pretty inefficient for mobile development.
If this was the case then dnd wouldn't be very useful.
This is a massive security risk, which is why you see serialization to API-accessed data.
They're just removing that syntax. The example you provided will still be able to be written like this: func setAlpha(amount: CGFloat) -&gt; (NSColor) -&gt; NSColor { return { (color: NSColor) -&gt; NSColor in color.colorWithAlphaComponent(amount) } } I personally will miss the cleaner syntax. 
Right: That is a closure, not a curried function. The two are quite different under the hood, although I'm struggling to come up with an example where the end products couldn't be used interchangeably in any code, so in practical terms, it should just be a matter of rewriting the deriving function to match the pattern in your example.
The knowledge base articles are great. I find myself consulting them at least once a week to figure out something new or to remind myself of something I learned a while ago. I am also pretty excited for Objective-C for developers book since I started learning how to program in Swift and find myself needing to work with that wretched language from time to time so this is right up my alley! For anyone just starting out I think a mix of learning resources is the best route. CS193P is great, but if you also mix in the Hacking with Swift tutorials or books, and maybe some of the video series from Pluralsight (to get you started at the very beginning), or one from Udemy on something more specific (like WatchOS development) then you cant go wrong. Now that Swift has been out long enough there are finally enough great resources to make learning on your own a much easier experience then trying to learn it when it was first released (which was brutal at times).
Cool, but I honestly think this doesn't belong on iOS. Just like the iOS style doesn't belong on Android
Why would it be a security risk? The data still gets routed through your API, it's just in a format that's easier to parse in Swift. 
Seems like you haven't RTFMed what [App Extensions](https://developer.apple.com/library/ios/documentation/General/Conceptual/ExtensibilityPG/ExtensionOverview.html#//apple_ref/doc/uid/TP40014214-CH2-SW2) can (are allowed) to do: Some APIs Are Unavailable to App Extensions Because of its focused role in the system, an app extension is ineligible to participate in certain activities. An app extension cannot: * Access a sharedApplication object, and so cannot use any of the methods on that object * Use any API marked in header files with the NS_EXTENSION_UNAVAILABLE macro, or similar unavailability macro, or any API in an unavailable framework For example, in iOS 8.0, the HealthKit framework and EventKit UI framework are unavailable to app extensions. * Access the camera or microphone on an iOS device * Perform long-running background tasks The specifics of this limitation vary by platform, as described in the extension point chapters in this document. (An app extension can initiate uploads or downloads using an NSURLSession object, with results of those operations reported to the containing app.) * Receive data using AirDrop (An app extension can send data using AirDrop in the same way an app does: by employing the UIActivityViewController class.) The alternatives are 1) write your own app from scratch (e.g. do your own NSURLSession handling), or 2) work within what is allowed (and designed) by the App Extension (the Extension author can *choose* to prevent access to certain features on their whim).
That's really interesting, thanks for pointing it out!
No offence but it still looks out of place
I think it looks great, nice work!
you can't &gt;just read Swift classes/structs straight out of the pipe That's not how this works. You seem to be having an emotional response to JSON's association with JavaScript. As an architecture independent means of representing data, JSON is actually a really good format. Far, far superior to the "predecessor" that most people used, known as XML. Have you ever studied how data structures are stored in memory? You can't "just read Swift classes/structs straight out of the pipe." That's not how it works. Classes in particular. Are you advocating loading arbitrary code into memory and executing it? and even with POD (plain old data) structs, you can't reliably transmit that over the wire either. If the sender is using little endian and the receiver is using big endian, or vice versa, you will end up with the wrong data. If the sender and the receiver are not running the exact same code, one may be using a newer "concept" of the same struct, where some fields have been rearranged. Data will end up in the wrong places. JSON provides a platform-independent, architecture-independent, and human-readable format for transmitting and even storing data. It's relatively efficient as is, but you can use a highly standardized form of compression (like gzip) in cases where you need to maximize efficiency. One of the only real alternatives I've seen to JSON that's even slightly better as a general purpose format is Google's Protocol Buffers, and Protocol Buffers are no more native to Swift than JSON. You've used a lot of hand-wavy language to talk about why JSON doesn't work well with Swift and how it just feels dirty. All of the other responses have pointed out how easy JSON is to work with in Swift. JSON isn't perfect, but it's good, reliable stuff. That's my analysis of the situation, at least.
I ported Elm's JSON decoder (combinators) to Swift. // example JSON request payload: [1, 2, 3] let handler: Handler = { request in let nums = try request.json(JD.array(JD.int)) let sum = nums.reduce(0, combine: +) return Response().json(["sum": sum]) //=&gt; {"sum": 6} } https://github.com/danneu/hansel/blob/master/Sources/Hansel/JD.swift JSON is ubiquitous for web APIs because it's simple. Just look at the homepage: http://json.org/. It's not the wire protocol you want to be "Swifty". Binary isn't Swifty. Rather it's the encode/decode abstractions that you want to be Swifty. Ideally your abstraction is isolated from specifics of the wire protocol entirely. 
I'd also disagree with: &gt; it's incredibly annoying to work with in Swift and almost every other language Swift is a bit of a pain in it's current state, however in Java and C# it's *incredibly* easy, like one line of code, to map a json string to a class.
&gt; you can't &gt;&gt; just read Swift classes/structs straight out of the pipe Well, there's [Cap'n Proto](https://capnproto.org/capnp-tool.html) -- written by "the primary author of protocol buffers V2" -- which actually tries to make sure that the representation of the [object in memory is the same as its serialization](https://capnproto.org/index.html). Although, to be fair, [there is no Swift implementation](https://capnproto.org/otherlang.html) yet.
I mean I guess, but right now I can easily store these JSON models in a NoSql database (mongo) or even in a MySQL database and return them easily when I get a post request. Python plays really well with JSON already (which is what my backend is written in) so when I use SwiftyJSON it just feels like an extension of how I use JSON with Python, JavaScript and my back ends. 
Sorry man, you make some great points but you're really just reading too much into this. JSON was invented because it's a literal representation of an object in JavaScript, but that's not the case for Swift. I'm aware of how data structures and Swift classes/structs work. My post is literally just "Is there a better way to encode Swift objects for transmission?" It's great that you want to defend JSON and I agree with basically everything you said, but I guess I should have worded it better.
Give this man beer !
If you can post the code somewhere, we'd be in a much better position to help. I tried to follow your description, but it in itself doesn't raise flags.
I think what you're really looking for is a 0-boilerplate mapper, right? Other languages have this for two reasons: - they are less type-safe which means less casting going on - they have better support for reflection (getting and modifying properties of an object at runtime), which means that your model can be serialized and constructed by a library Essentially what this means is that you need to both lose some type safety (easily done) and be able to reliably reflect on your model (not supported by the language... yet). Ok, so that's asking for a lot. However, it's _technically_ possible. There's this really cool library under Zewo called [Reflection](https://github.com/Zewo/Reflection) (creative name, I know). It allows you to get the properties of an object at runtime in the form of a dictionary. With that, you should be able to serialize it to JSON in just a few lines of code. Going the other way is a little more tricky but equally possible using the `construct` method. I definitely feel the same frustration as you so keep your eyes open for an automagical (but still safe) JSON mapper, with absolutely 0 boilerplate. I brought up the idea in the Zewo [slack](https://slack.zewo.io) today and it got a pretty positive response, so its hopefully going to be a thing soon!.
Good explanation, that's what I was looking for. I'll have to check that out on Zewo.
&gt; 3) In a world where all code is written in Swift, what would be your ideal interchange format? If all code is written in the same language, built with the same tooling etc, I would probably not bother with a human readable format and go with a binary RPC protocol. The thing that makes formats like JSON and XML useful is that it makes no assumptions about the sending and receiving systems. 
&gt; Although these objects have their own meaning and inter**penetration** ( ͡° ͜ʖ ͡°)
This doesn't tell anything about the state of Swift as a server side language (currently). It's more like a short overview of the history of several frameworks, with zero technical details about most of them and just some sample code for Zewo and some more about Venice. How do they differ? Which one currently has the largest community? Mystery. 
I don't understand why you're calling it a misfeature. Although I don't see to the end of this I thought that was one of the features that allow one to analyze a function as provably correct (or incorrect), by breaking it down into to smaller chunks. (edit: replaced true/false with correct/incorrect)
I use http://www.json4swift.com/ to convert to and from JSON. This creates a Swift model. I can get a dictionary to send back to the server and JSON data from the server.
This comes up again and again to the point of boredom... 1) Swift is not the same as iOS. A Swift compiler does not mean you can build iOS Apps. 2) Even if you could do it, developing anything Apple based on Windows is simply a horrible idea. Run OS-X and thank yourself later.
I love swift. I looked pretty heavily at swift server side frameworks a few months ago. My conclusion is that everyone is focused on the http layer and that's only fun for proof of concepts. In this day and age I would rather use an api gateway and use swift for actual backend code, but there's not a lot of support when it comes to doing "real" things like accessing databases and the current lack of 3rd party libraries for APIs. Sure, I could write my own API wrapper for 3rd party services, but that's a pain. AWS SDK? Not for your backend. IBM is the only game in town for swift behind the scenes and that requires using their proprietary database. I'm really waiting for swift to be a first class citizen on aws lambda...then we're talking. 
Look at parser combinators they instantly make it obvious how awesome currying can be. Also only the syntactic sugar gets removed.
Try OpenCV. 
I modified some examples I found on Stack (which is full of info and yet very annoying at the same time) and created several methods that handle my use. I prefer to do that then use 3rd party libraries. Mainly because I want to learn and speed of writing a program is not the main driver. But I need to run through them again, convert them to swift and clean them up. 
Heard good things about Vapor.
Vapor's API won't be stable until 1.0 which will be released alongside Swift 3 later this year. But in terms of bugs, crashes, etc, by merit of it being type-safe and compiled, Vapor is incredibly stable. I've had my personal website http://tanner.xyz running on it for almost half a year with no issues.
unrelated, but do try respecting the single responsibility principle as it will make everything look nicer and easier to debug . move reload call outside of the for loop and don't dispatch it async as everything should be executed sequentially
There's points throughout: -good support from IBM -he particularly like Zewo -database support growing -good open source support -moving target in terms of language stability. -not ready for production use
&amp;gt; How do they differ? The author actually did a pretty good job going over this. Perfect feels like an ancient framework (design-wise). Kitura is pretty light on features. The reason Zewo is special is because of Venice, so it's APIs appear to be totally synchronous even though they are actually highly asynchronous. Zewo is also split up into a huge amount of modules. Vapor is like a batteries-included version of Zewo, and enforces a lot of opinion on your directory structure and so on, which is good in some cases. &amp;gt; Which has the biggest community? I'm not sure whether this statistic should be taken at face value, but [Zewo's slack](http://slack.zewo.io) has about 320 people in it, over twice as big as any other community. There are also a lot of people using Vapor. Edit: disclosure: I am on the core team of Zewo, though I tried to be unbiased here.
Is swift not able to serialize and deserialize objects/structures? I don't think he's calling for arbitrary code execution. Not that I have a problem with JSON. But you're attacking him from the wrong angle here.
Stuff like this only pushes state, not behavior.
Which ViewController do you think is at the source of the leak?
There is no built-in way to serialize objects/structures in swift, as far as I'm aware. But, more importantly, JSON *is* a serialized data format. If you search the internet for "swift serialization," most of the results that pop up are serializing Swift objects to JSON. JSON is exactly what OP wants, he just doesn't like the **JS** in **JS**ON.
Perfect has a wonderfully active community of developers, many working on production apps. It is currently trending about ~100 clones a day, with some days peaking over ~1000. Perfect has 4 full time developers, and 4 support members as well, and is funded for many years to come.
Good to know. I couldn't agree more about it being an early stage opportunity. It just depends on what you want to do with it, I guess. Soon, however!
This would probably have to be Lightning-to-USB and USB-to-SD in two adapters in terms of off-the-shelf capability. To create something new, you've have to become a [certified Apple Hardware developer (aka "MFi")](https://developer.apple.com/hardwaredrivers/https://developer.apple.com/hardwaredrivers/). This is not a hobbyist thing - you have to provide proof of incorporation and other commercial documents to become one (Apple had some bad experiences with "hobbyists" leaking confidential information and those people ruined it for the rest of us). In either case, it would simply be done by filesystem access APIs and require the app be setup to access files outside the user space sandbox. Traversal is 100% developer coded using foundation classes like [NSFileHandle](https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSFileHandle_Class/index.html) and/or [NSDirectoryEnumerator](https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSDirectoryEnumerator_Class/index.html)
I know what you're saying about the srp. Planned on cleaning that up after I learn the functionality. And that's what I thought about the dispatch, but it seemed like everyone online was telling me to use that because they assumed my thread was being blocked. 
So if I were using this to transfer photos, it would probably be easier to just transfer them to the iDevice and access the photo library and do what I need to with them that way, then?
parseJson should be running on a background thread (assuming that main thread is only used for UI?). 2. Yes, I delete all Orders every time the user downloads, because I didn't write the logic to only add/update new ones. 
Which offers nothing to the common knowledge base about the state of Swift. 
I only see one obvious culprit for a leak: let quitHandler = { (action: UIAlertAction) -&gt; Void in self.view.window?.rootViewController?.dismissViewControllerAnimated(false, completion: nil) } This causes a reference to **self** to be retained until that closure goes out of scope. Because it's just handed off to an alert, it's probably not a problem, but you can build safety around this using a weakify/strongify pattern as such: let quitHandler = { [weak self] (action: UIAlertAction) -&gt; Void in guard let strongSelf = self else { return } strongSelf.view.window?.rootViewController?.dismissViewControllerAnimated(false, completion: nil) } This makes it a weak reference and only executes the code in the closure if the weak reference can be unwrapped. I totally don't think this is it as it should be released as soon as the alert is out of scope. Good luck!
I think people forget the 5 month thing. Further they seem to think Swift is a done deal even on Apples systems, it isn't and is under very heavy development. The compiler itself has significant weak spots so you need to be careful there. Basically Swift is an advanced Alpha maybe beta release it isn't 100% anywhere. 
Your code didn't exactly work, but this did: public func ~=&lt;T: protocol&lt;ForwardIndexType,Filterable&gt;&gt;(lhs: String, rhs: Range&lt;T&gt;) -&gt; Filter { var array = [Filterable]() for (_, element) in rhs.enumerate() { array.append(element) } return .subset(lhs, .`in`, array) }
This is my very first thought and I don't even use dispatch often. It seems like a huge regression and not in tune with Apples own objectives with Swift. Hopefully we can get this changed before the improvements get set in stone. 
The article touches on an important aspect of Swift which is that it has the potential for usage in very many areas, not just writing clients and servers but also for scripts. I would love to use Swift as my script language. Syntax and semantic wise it has all it needs. The problem is both a lack of APIs suitable for it and the design of existing ones. Easy scripting requires making easy to do things one line at a time. But the traditional Objective-C design of Foundation means there is always a lot of setup. You can't do much without implementing some delegate protocol. While it is great the the Swift string API is so correct and good at handling unicode, for most of the type of work I like to do it is kind of in the way. Writing quick script like string manipulation is difficult to achieve. I wish they could add some syntax sugar to make it more pleasant. Also there are no built in easy to use facilities for calling shell utilities. Sure you can use NSTask but that is rather clunky. I could of course write much of this functionality myself, but I don't think it is nice to require every user of a Swift script to install a particular package or library. The most common things needed for scripting should already be in the standard library.
eek, thanks for spotting it.
Baloney! The whole point of Swift 3.0 is to make things much more Swift like dropping older conventions. This needs to happen with all C APIs. &gt;So why bother with a Mac only API? As far as I read the proposal it adds no significant new functionality. Instead it makes the existing functionality more swifty (+ breaking existing code). I really don't give a damn about breaking existing code. For one anybody with any sense would realize that Swift is under heavy development leading to a stable release. Apple has said as much numerous times. Beyond that who said it was Mac only. IBM is doing massive work to a significantly improved libdispatch for Linux. I would expect any cross platform solution will build on this. Beyond that the fear of breaking existing code has resulted in many languages dying quickly from a lack of interest. With computer languages you either move forward or you become a museum piece. &gt;I think this proposal should be skipped and instead they should work on a (new) cross platform library. Nope they are doing the right thing to put Swift into a position to be Apples primary development language for decades to come. You can't be looking back when building for the future. Beyond that this is a trivial improvement that won't impact a lot of code. 
You're making the mistake in thinking that Swift should support C support. In my opinion, that is one of its greatest features. I don't think you understand just how much C is used in the real world. Pretty everything has a C interface - why would you want to lose that ability? To be clear, this proposal does not suggest implementing Dispatch in Swift. It suggests that we change the way the C library is _imported_. I am really against this because it gives it special treatment which is really unnecessary. There are already plenty of GCD wrappers that have the same exact semantics. I am all for Apple providing an official GCD wrapper. I just don't like the way this proposal suggests they do it.
Your courses look fantastically practical! Would you recommend completing Hacking with Swift before jumping into Pro Swift though?
Thank you! To get the most out of Pro Swift you should either have completed up to project 15 in HWS, or have spent some months using Swift in your own apps.
Got one, thank you!!! Looks great :)
You're welcome! Let me know what you think :)
Missed it :(. Loved hacking with swift. To bad I can't afford this one at the moment :(. Thanks for your constant contribution to the swift community!
Great! I hope it helps you learn some smart Swift techniques :)
I've started to read through the Objective-C for Swift developers book and already a lot of things are clicking from the few times I have had to work with Objective-C code, so that is an encouraging start to the book! I will be posting a full review of the book on Monday once I have had a chance to read through it. So if anyone is on the fence about getting the book and needs to know a bit more about it check back to /r/swift on Monday and I will have it posted here.
Here is the major difference I see in your solution and the interpreter pattern: In your code, the operations are not stand alone expressions (or tokens in your case) they are actions or cases that apply a function to a token value. Now this is not a problem for a calculator since you know your number of operators are going to be limited to four. But if you are building a complicated language, your operators can expand indefinitely and having to add new cases for each enum is not scalable or clean. However if you take the route of building your tokens as standalone classes, and defining your operators using these classes then adding new operators requires no change to your general token class. You simply define a new token and add it your list of tokens. Imagine if you were to add new operators like &amp; or | which would apply their respective bitwise operation. You would need to add new case for each one of them to your token enum, operation enum, in your lex switch on case, and in your evaluate class. However if you were to define a new token/expression class for them you would only need to add new switch statement in the evaluator. buildSyntaxTree method and you're done. You wouldn't need to touch other tokens. It is also important to note that the Interpreter design pattern does not cover the parser. I would concede that the parser in my example is not the most elegant solution, but it is the simplest. (considering order of operations) and I think the reason you (and perhaps others) think the solution is messy due to the way I deal with order of operations. Perhaps reordering nodes on the syntax tree would have been a better looking solution... 
 &gt;You're making the mistake in thinking that Swift should support C support. In my opinion, that is one of its greatest features. I don't think you understand just how much C is used in the real world. Pretty everything has a C interface - why would you want to lose that ability? I don't want to loose the ability to interface to C. What I want is for the common components of Apples OS's to have very Swift like interfaces. The sooner the better. &gt;To be clear, this proposal does not suggest implementing Dispatch in Swift. It suggests that we change the way the C library is _imported_. I am really against this because it gives it special treatment which is really unnecessary. There are already plenty of GCD wrappers that have the same exact semantics. I am all for Apple providing an official GCD wrapper. I just don't like the way this proposal suggests they do it. Well the proposal isn't perfect and that can be addressed, after all it is a proposal. My hope is that the vast majority of Apples APIs become Swiftified if you will. There is no reason to hobble development for the next couple of decades with poor interfaces. Poor in the sense of working smoothly with Swift. 
Thanks. I plan to venture in to swift this upcoming week. I was planning to use JSON as I am building a website with vapor. I hate javascript as much as the next guy, but after years of XML, JSON catching on is a godsend. There might be something better, sure, but I'll take what I can get.
I don't see what you see at all. I've already used Perfect in a appstore app, and it works like a charm. What you call "ancient" and "not swifty" seems more like "great programming" to me. Certainly this is in the eye of the beholder. I've been through the Perfect codebase (https://github.com/PerfectlySoft/Perfect) and don't see anything you are talking about - it's absolutely beautiful to work with, modern and sleek. Sure, it doesn't feel like an App-side codebase - but it's a server-side codebase.
Say - aren't you one of the main contributors to the Zewo project? Perfect isn't ancient at all, it's genius. It's the only stable framework out of the whole bunch, based on my experimentation. Perhaps "ancient" refers to "ancient wisdom", and that's why it works? Perfect has thousands of active contributors and developers in various different places. Picking on other projects to make your own project look good is tacky.
It is a curried function, even though it is implemented in terms of closures. From Wikipedia: &gt; In mathematics and computer science, currying is the technique of translating the evaluation of a function that takes multiple arguments (or a tuple of arguments) into evaluating a sequence of functions, each with a single argument. It was introduced by Gottlob Frege, developed by Moses Schönfinkel, and further developed by Haskell Curry. This is normally how the term is used, although there are a number of ways to actually curry a function. Some languages, such as Haskell, has currying built in to the language, in such a way that all functions are automatically curried. Calling a function with fewer than all parameters, will only partially apply it, and return another function which expects the remaining arguments. Other languages, such as Swift prior to 3.0, has syntactic sugar that helps the creation of curried functions. Most languages though, such as Swift after 3.0, JavaScript, C#, etc resort to closures or inner functions and expect the programmer to implement currying on a per function basis as needed, or use generics to create a helper function to explicitly turn a non-curried function into a curried one. Swift 3 is only removing the simple syntax, not currying as such. 
I appreciate that you took the time to write this out! Note though that I *was* just discussing the implementation. Sorry if I confused you and anyone else!
Bought your Pro Swift book because it looked interesting, learning a lot just going through the first few chapters.
Thanks for your support! I'm glad to hear you're learning new things; let me know if you have suggestions for topics I can add as a free update. 
No problem. Just beware that function currying is not being removed from Swift. For as long as there are higher order functions, and functions as first class types, there will be currying. Whether useful to OP, is another case. 
Yes, you can use the command line compiler, if you don't want to use VS. Simply uncheck the VS option in setup. I'm afraid there are no other IDEs for Silver on Windows at this time.
That's very good to hear. Are those developers working on server side applications based on Perfect? /u/ghostfacechilla mentioned in another post that they had apps based on Perfect in the app store...
Nice, a worthwhile exercise. Did you know about "Modernize libdispatch for Swift 3 naming conventions"? https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md 
If you have a conflict of interest, you shouldn't be posting your opinions on a public forum. (https://www.reddit.com/wiki/reddiquette) Or, so as not to be tacky, you should at least declare your conflict out of the gate. I haven't contributed to any one of the code bases, but I've tried Vapor and Perfect (not yet Zewo, sorry), and I just happen to think Perfect is farther ahead. I hate to see it - or any project - get bashed directly by other authors. 
NTFS does support symbolic links &amp; hard links: https://msdn.microsoft.com/en-us/library/windows/desktop/aa365006(v=vs.85).aspx I would suggest something like link shell extension to help deal with them on the windows end. I also don't know the status of support for it in the subsystem tho.
Yeah jumping into binary formats is the kind of thing I only like to do once I know I need it. JSON is always the right decision unless you really *know* you need something else. 
I did see that! I'll be interested to see what the outcome of that will be. I certainly don't have an issue with cleaning up the GCD API for Swift, but it would be nice to have built in Swift language support for Concurrency and I was kind of hoping they would add that instead of cleaning up GCD.
You can use the open source version of Parse (available on GitHub). Last time I checked, it was not possible to sign up a new account on Parse.
Just for my own knowledge, what were the concepts that tripped you up during the interview? Are there any questions in particular that you can remember?
Need others than WWDC. I found Swift Summit SF 2015 at Skilled.io but was a hardest find.
You get none of these through XCode, Xcode is the IDE. 
The docs have pretty good code snippets https://developer.apple.com/library/ios/documentation/HealthKit/Reference/HKSampleQuery_Class/ Perhaps post what you're doing and it will be easier to tell you whats wrong.
You could probably actually do the first one in a lot less time them others are suggesting, to an extent. If you can find a library or API , something like this bot : http://www.pcworld.com/article/3056029/data-center-cloud/microsofts-latest-ai-party-trick-is-a-captionbot-for-photos.html you can get some basic image recognition going. You should be able to find another API for looking up nutritional values. This will obviously be super limited, for instance you could probably recognize an apple and get a relatively solid nutritional fact for that via lookup. However, you'll stumble with more complicated things like a plate with eggs and bacon likely will be extremely difficult. Even if the image recognition worked and gave you eggs and bacon, the amount would be difficult to determine and thus nutritional facts next to impossible to determine. 
Checkout https://realm.io/news and www.pomo.tv
dotSwift: https://www.youtube.com/watch?v=QCxkaTj7QJs Functional Swift Conference: http://2015.funswiftconf.com/ ⌘R Conf: https://www.youtube.com/channel/UCSjxcYzYuJ-D4QdOjT63oSg Pragma Conference: https://www.youtube.com/playlist?list=PLAVm70iJlMusekZaxufRPS4OjNOs7L7zi
This is an extremely stupid question but what is gcd? My first thought was greatest common denominator and I'm 98% sure that's not what this is hahh Edit: I decided to not be lazy and I looked it up and figured it out. Left the comment for shame though. 
Right what I meant is SDK
He mentions not wanting to add RXSwift because his codebase's architecture isn't reactive. (Although I, myself, would much prefer an architecture that is reactive in general)
I suspect you don't have much experience with this. The arity of a function cannot be determined just from its type signature in Haskell.
Thanks for your reply. For this project I am not using a UIStackView. From the feedback I've gotten so far it seems as if it is a bug in Xcode, which will hopefully be fixed soon.
Well I was just unsure if I could do something like that. The parent view is a pageViewController. override func viewDidLoad() { super.viewDidLoad() let pvc = parentViewController as! QuizPageViewController print("\(pvc)") setupQuizViews() setupAnswerLableViews() quizViewNavigationBarTitle.title = "Page \(index+1) of \(pvc.answer!.answerKey.count)" // Here is where we call the method that giving me the error if !pvc.timer!.fromResultView { updateTime(pvc) } else { timer.text = pvc.timer!.mins + ":" + pvc.timer!.secs endButton.title = "Result" setupLablesForImageView() } } func updateTime(pvc: QuizPageViewController) { let currentTime = NSDate.timeIntervalSinceReferenceDate() var elapsed = currentTime - pvc.timer!.startTime pvc.timer!.minutes = Int(elapsed/60.0) elapsed -= Double(pvc.timer!.minutes) * 60.0 pvc.timer!.seconds = Int(elapsed) let secs = (pvc.timer!.seconds &lt; 10) ? "0\(pvc.timer!.seconds)" : "(pvc.timer!.seconds)" timer.text = "\(pvc.timer!.minutes):\(secs)" self.performSelector(#selector(QuizViewController.updateTime), withObject: self, afterDelay: 1.0) }
You'll need to substantiate your claims with sound arguments for this to go anywhere. Swift is a very different language and the expressiveness of its type system is downright primitive compared to that of Haskell. Provide me with some concrete code samples.
So much overhead
With a quick look-through I don't see anything glaring, but you could try casting the changes dictionary to NSDictionary before you archive and after you unarchive (in the latter case you can then cast again to the Swift dictionary with the appropriate types). I haven't done any NSCoder stuff since Swift 1.1 but IIRC that was occasionally a problem back then. Maybe it still is. Also FYI you should be using NSSecureCoding. 
You have to implement NSCoding on **every** custom object. If you do this, the recursive coding "just works". If this isn't working, likely you screwed up this part. Debug/validate/unit test on the object class alone.
Looks like a great, much needed project! What stops me from using it currently, and may stop others, is that it's not compatible with Swift 2.2. That's the latest official release, and personally, I experience way too many Xcode crashes on the 3.0 snapshots to be able to develop with those. A big reason people choose Swift for their backend is to unify their codebases. That can't be done with your package since it's Swift 3.0 only, and current apps ship 2.2. If your driver had Cocoapods support and was simple to drop into a project that would really be awesome. Otherwise, I'll definitely try it out when Swift 3 is out in the fall!
Have you thought about progressively downloading them? If you download 10 quotes on launch then it will show just about immediately. You can then issue requests for more quotes. Saving the quotes as you download them will also prevent having to download them on every app launch. Distributing the app with your quotes, then downloading only the newest ones is a route you can pursue also.
I agree. We should make a Swift 2.2 version after this. It probably won't even take longer than a day.
Incredible work and definitely useful. It's exciting to see well written native DB drivers.
Interesting, I hadn't heard it was being removed.
Thanks for reading, I'm really excited for Swift 3 :)
As u/my_work_acct_ says, an array of widgets is not an instance of Widget, so it isn't appropriate to have an *instance* method of Widget operate on said array (emphasis mine). However, you could make a static (aka class) method which operates on an array of Widgets. I'm just keyboarding here, so there may be some errors... // ...somewhere inside the Widget class or an extension thereof static func gimmeAWidgetFromTheseWidgets(widgets: [Widget]) -&gt; Widget? { return widgets.first } Of course, that could be just a free-standing function, but I think there is some value in keeping something like that in the Widget class. Here's an example of Apple doing something similar with an array of UIImages in a class func inside UIImage: public class func animatedImageWithImages(images: [UIImage], duration: NSTimeInterval) -&gt; UIImage? 
Any news about the renamification? I expect a conversion tool but I don't know any details.
Thank you so much -- this is definitely more of an answer than I deserve. I thought about what you said, and your #1 point was that this is an array that I'm acting on, so asking it, at the instance level, to interact with the entire array is flawed from the beginning... What do you think about something like this: class WidgetObject { var number: Int var color: String } class Widget { var arrWidgets: [WidgetObject] = LoadWidgets() func widgetWithBiggestNumber() -&gt; WidgetObject { // do stuff return theWidget } } I'm kind of using Widget as a single instance for the array of WidgetObjects. And, I still have access to the array via something like: var myWidgets = Widget() print(myWidgets.arrWidgets) // print the whole array for no reason print(myWidgets.widgetWithBiggestNumber()) Thanks again for the help! 
Not sure why you need a widgetobject and a widget class. The array should be handled with some sort of class that manages the data. You can keep the widget as just that and have a DataManager class that handles the storing and sorting/filtering/manipulation of whatever you need.
Here's a marvellous quote from one of the Swift developers, Joe Groff: "A late ABI is only late until it's finished; a bad ABI is bad forever."
It is a swift talk. But I am not sure if I should pick a topic that I may not be very comfortable with.
FP is a very good topic, but I guess that topic has been covered exhaustively. I will end up just repeating stuff mostly.
That is a very good option there sir! Do you know of a list where they have kept a changelog of swift 3? Would be very helpful!
Will this be required, or merely recommended (like upper case class names)?
Funny, reminds me of the quote from Nintendo game designer Shigeru Miyamoto: "A delayed game is eventually good, but a rushed game is forever bad."
Swift 4.0 will be actual 1.0 release in my book.
Partially. It was also trickier to get generics the way they wanted. 
Sure, I'd be down for this.
I'll be glad to help.
[Here's the better version...](https://www.youtube.com/watch?v=oc6xCgSZqYE)
No.
Just watching the many, many ambitious Swift 3 proposals roll in, it was getting harder and harder to believe they'd be able to achieve every last thing in just 4-5 months, even with community contributions. Taking the time to do it right is fine by me. Too much Apple software feels rushed and half-assed ever since the move to yearly OS releases IMO. I'm glad the Swift team isn't going to let themselves fall into that trap. 
From experience, I think you will be able to learn Swift by actually building an demo application. It could be something as simple as pulling data from an existing API (iOS stack). That's the way I have been able to learn! Let me know if you would like any help!
Now that Swift is a few years old there are more than enough resources out there that you can find something that will work for your learning style. It is just a matter of looking at the options and trying them out until one really clicks with you. If you check out https://manitoba.ninja/2016/02/07/resources-for-learning-swift/ I have put together a list of the different categories of resources and the best options within them. You might also want to see if there are Swift for C++ type books that might help you translate your existing knowledge to the Swift language.
This mailing list is by no means obscure. It's the official mailing list for enhancements to the language and it is publicized on the website and links to it figure in almost every proposal in apple/swift-evolution. I seem to recall that this is where the ABI stability goal was first stated too. If you're interested in what's coming to Swift, you should be watching it.
?
I'm happy to consider Swift 2.2 the first real 1.0 release. It's a solid and dependable language. The stuff coming in 3.0 and later is sugar on top. 
Thanks for your reply! Does Swift support a persistent connection? 
If you want to keep up with the swift evolution process, I advise you to read http://swiftweekly.github.io/ Jesse Squire summary work is awesome ! 
I need to ask a person who knows swift. I don't have time to patiently read a book at the last minute. However, I do understand your reason, after this exam I will thoroughly read the book on swift.
The question isn't whether *Swift* takes advantage of it, but whether the underlying libraries do (the language used is largely irrelevant). Although Apple have kind of confirmed HTTP/2 support, there's not much information about how well it works and it's not even mentioned in the docs, though personally I suspect it does use persistent connections automatically.
http://i.imgur.com/51Mixdk.jpg
It's a project under examination conditions I should've mentioned that earlier sorry. I am willing to do the work and it is due this Friday. Teacher hasn't been clear with the work set for our small project.
You need the simulator and that requires running on OSX. Because development builds of iOS apps really are OSX apps that display their GUI in the simulator window. 
Almost all your values *should* be constants in swift. There are idioms to entirely avoid mutation in most places, and parameters should be constant in functions. So in short: no, this isn't a big problem, everything is constant when you're doing it "right" Value types such as structs makes constants even more explicitly not a problem as well
Just a short note: the Swift API design guidelines mandate variables to be named in camel cases. Since constants at top level and in classes, be it an instance property or class/static property, are just defined by `let` anyway, these have to be camel cases too - just like any variable. The same applies to enum cases. Of course you are not required to follow. Just that it should be known that the community has grown a heavily debated convention at least for the stdlib and the core libs. P.S. I don't see a necessity in making special arrangements for literal constants anyway, since usually they are represented as enums or static properties. Both of these can be easily differentiated at the call site.
I'd love to help! EDIT: I have been learning/coding in swift for roughly 7 months now if you need a gauge for experience. 
Super interesting stuff to read! But since you're using the same compiler, doesn't the same optimization happen in the C and C++ tests?
I have not tried editing the user info but I assume it works because I have been able to edit the notifications title and message without having to delete and reschedule it. You should consider using a unique ID in be user info though in case the user adds the same description to more than one task. You can generate a unique ID with NSUUID().UUIDString
Thanks! I'll give this a look!
I'm using Perfect very successfully for personal projects. Very happy with the results.
Been using Perfect on personal projects, and think it's going a great direction. Really happy to see so much interest in Swift these days.
The performance with strings is very worrying indeed. Have you profiled it at all to see what makes them so slow? It could be a major bug. It could also just be something that needs optimization. Either of these things could likely make it into the 3.0 release of Swift.
LLVM/Clang?
&gt;naming constants all camel-case LIKE_THIS That's not camel case Some names for cases: camelCase / lowerCamelCase UpperCamelCase / PascalCase kebab-case HTTP-Header-Case snake_case Camel_Snake_Case SCREAMING_SNAKE_CASE 
Yea that was a red flag to me as well. Converting strings to bytes means you're choosing an encoding, and if you're not careful, that's easy to screw up. That said, I think it's possible to make correct **and** fast Strings. Swift's implementation makes it a matter of interpreting the underlying representation to get a desired format. I see no reason that the underlying representation can't be made fast for this sort of use case.
Oh shit. You're right. The dude with obviously attention grabbing hair grabbed attention, but I'm the one in the wrong. 
This article is interesting, I think it points to something I've been thinking since I've started using Swift. Swift is a really nice language. I like programming applications in it. I'm perfectly fine if its performance never eclipsing C or even Java for that matter. People seem caught up in the idea it will become the language to replace all languages and it will produce insanely performant code, I think you are in for some disappointment if these are your wishes for the language.
I didn't realize that the people on the Swift mailing lists were jobless. The Swift blog didn't state any design goals for Swift 3. Why would you expect that rectifications go there?
If your job involves Swift, a rapidly-changing language, it would be to your benefit to pay some attention to the low-volume mailing list that announces what those changes are going to be. https://lists.swift.org/mailman/listinfo/swift-evolution-announce
I think some of the reason behind that is that Apple has been marketing it as such to get people to take it up. There's a part of the community that will have your approach - Swift has a bunch of nice features that mean you don't have to think about memory management at the C level, for instance - but there are others that have the aforelinked approach to see performance as critical. The point of this article was not that Swift is slow, but that it's entirely possible to be very fast in Swift as well.
We are supporting a dozen server side application projects at this time. Mostly mobile back-ends, but also full web systems, all using Swift and Perfect in unison. We know of a few active live apps on the Apple store using this stack, and dozens more in production. Hope that helps!
Hi. I wrote this article. He also ran a consulting firm called "Treefrog," so I'm pretty sure he's leaning into the whole thing. 
Doesn't optimization occur in LLVM though? Clang is just the front end to C-family languages. Its main purpose is to parse the code and turn it into an abstract syntax tree isn't it?
Passing around the GameState is the right way to do this.
You could maybe use a plist, I've loaded plists into a dictionary before. I found this too: http://stackoverflow.com/questions/27197658/writing-swift-dictionary-to-file Edit: Have you thought about using core data? It's a pain but this might be a valid use case.
&gt; I tried using a process that involved stringByAppendingPathComponent but apparently this has been deprecated. That hangup is just the fact that `String`/`NSString` no longer include methods for working with filenames and paths. This functionality is provided by Foundation's `NSURL` class: let someBaseURL = NSURL(fileURLWithPath: someBasePath) let someSubdirectoryURL = someBaseURL.URLByAppendingPathComponent("Subdirectory") let someSubdirectoryPath = someSubdirectoryURL.path! If that was the only error you were encountering, then the rest of the method you were following should work just fine. (I'm guessing you're casting Swift's Dictionary to `NSDictionary`, and using its `writeToURL()` or `writeToFile()` methods?)
I don't know the technical details but I just messed with this really quickly to see what's up. So the important thing is note is that it applies the transform "symmetrically", so to speak. Let's say you apply a scale transform of (1.0, 0.5), you would expect the view to stay the same width but have half the height. But it chips off height simultaneously from the top and bottom of the view (it transforms around the horizontal center line, in other words). So the transformed button will have a different apparent origin. Does that clear things up a little? 
No clue if this is the cleverest way, but the easiest way I can imagine is to just manually set myButton.frame.origin to the original origin after you apply that transform. So you can save the original frame of the button whenever it first appears, then use that to preserve the origin whenever you apply a transform. 
Really? He's complaining that NSDate *date = [NSDate date]; is terrible but let date = NSDate() is beautiful? 
Poor practice. If you want to charge for your content just charge for it. See free tutorials as marketing, they drive more people to the site where you can then up sell them. Trust me I understand the hard work people put into creating content - but practices like this cost you more in goodwill lost than what they do in added ad revenue. 
I imagine the C implementation takes security as its first and for most concern, then interoperability for stuff built on top of it, then performance. I doubt a full implementation in Swift would operate in the same order of magnitude. Why is it surprising that Swift can compile code that runs in the same order of magnitude as C? Especially for micro-benchmarks, where its mostly inlined anyways. The JVM can operates in the same order of magnitude as C and has been shown to out perform it in certain circumstances. Especially with large very complex systems where AOT compilers have a hard time inlining (of course running on top of a system written almost entirely in C/C++).
The big issues here are how is this “user generated content that has some basic formatting” being created, stored, and who is going to see it. These are crucial to your issue. If you are using taking unfiltered HTML from online users, it is a big security risk if the content will be shown to other users as HTML. Presumably you are taking a filtered subset of HTML only? You may be better of using a popular text markup format (e.g. markdown, bbcode). Or, if you are staying completely within iOS and only showing the text back to the same user, skip HTML altogether and just use text kit, i.e. collect attributed strings from the user’s text view and setting the attributedText of a UILabel or text view the next time the user needs to see it.
Add `use_frameworks!` to your Podfile, and reinstall with `pod init`. Then, in your swift files, import the project with (AFNetworking used as an example) `import AFNetworking` and you're good to go! 
Worked fine for me. Use something like fuckfuckadblock
Last time I used Swift it was almost impossible to write open and operate a socket. Wonder if things have changed.
The problem is he wasted the persons time. It's a stupid approach. Hitting the user with an ultimatum on arrival after he's freely advertised it to the swift community on Reddit. He's not posting on Reddit for the good of the community - it's to drive traffic, and that comes in many shapes (some with adblockers, some without. So effectively putting a pay wall on 'bad traffic', it's in poor taste. He'd be much better off letting users who are using adblockers know about how it can potentially hurt him midway through his article. It's actually the best time to do it - as I'm gaining from the content to request me to give back by disabling Adblock. It helps maintain the likability while also getting the exact same message. 
Great, thanks for the input.
Vapor has several backend projects up and hosted, qutheory.io starredsearch.com emergency-phone-numbers.herokuapp.com
[Here](https://www.hackingwithswift.com/) you have very good tutorial and project for starting from scratch. I also recommend you Stanford online courses on iTunes U, I think it's CS139P it is well explained but it will require you to have knowledge in OOP.
[removed]
Well it's actually the opposite I'm looking for :D I want to import one of my swift files (the AppDelegate) into the objC cocoapod (it's fine as long as I'm not redistributing it right? I kinda need functionality that's in my AppDelegate) but can't using the recommended method by Apple. 
I believe the point is that there is no *correct* way to do it that is faster. The world of text and encodings is both complex and subtle. If you think you found a fast way to do it, you are probably making assumptions that will not be correct all the time, just in some limited set of test cases. This is how bugs happen. Unicode is an absolute beast. It has amazing capabilities but is by its nature heavy-weight compared to any number of fast/naïve solutions. EDIT: you can make assumptions that make your code fast, but the Swift builtins are made to be generic. It's a given in most software engineering that if you have the freedom to make assumptions or put conditions on your input you can make your code a lot faster - but the Swift standard library needs to be flexible enough to handle anything thrown at it - which means taking the slow road.
Swift uses llvm and needs clang, one of its compilation steps is llvm ir
until type inference among all the other things begins to fall apart as it often does
 &gt;So I am new to programming. I started learning java 5 months ago, I made a big progress, THIS a common mistake in my opinion. That is trying to learn a language without learning computer science. &gt;then I realized it is not that useful for me, so I moved to swift. The thing is that im really confused on how to learn swift, itunesU! Beyond that it is just like learning anything else; books, practice and communications. &gt;I registered for some online swift courses, they are fine and im learning, but i feel that there is something wrong. anyone here has any tips on how to learn swift? OK what are you feeling. Learning to program won't teach you to think nor create. As mentioned above learning Swift is just like learning anything else, read and practice go a long ways. 
&gt;"We have this Apple DNA that no one else has" Well except, you know ... Apple. 
You should adjust `view.layer.anchorPoint` to something other than (0.5, 0.5). This is what's used to calculate the position of the layer and also transforms you apply to it.
Why is this downvoted? That's a great site.
Did he lose a bet or what?
Yes, I think you're right – then I'm not sure *what* point the author is trying to make :)
The blog is definitely wrong. After seeing that OP shouldn't trust anything in that article. 
Vapor rules! You should try them both out for yourself and decide. http://qutheory.io
Yes because with Swift, we know that date is an instance object. If I'm reading Objective-C, looks like a pain and mess to understand. 
You are right - any old Joe on the street would say that the Swift is simpler. In this specific example, the Swift code is interacting with Objective-C Foundation framework, and the compiler will generate the same instructions as the Objective-C version. As an old Objective-C practitioner, I see how the how the machine will actually execute [NSDate date] - I see where the message lookups, the allocations, the retains, and autoreleases are. I see that in fact, a pointer to an object is being created and assigned. So for me, the abstractions of Swift hide all of that and get in the way of true understanding. I worry that Swift practitioners will think they understand, but because they are working at a level of abstraction that hides what's really going on, they won't be able to find problems that would have been obvious if they'd written in Objective-C.
But pointers are scary!
Look at SIL - there are a bunch of optimizations that occur at that point, specifically because LLVM is too late in the process. https://www.youtube.com/watch?v=Ntj8ab-5cvE http://llvm.org/devmtg/2015-10/slides/GroffLattner-SILHighLevelIR.pdf 
And dozens of other companies that have several apple engineers
Optimizations happen in both the Swift compiler and in the LLVM backend.
Parts of Clang are used to build the generated headers used for Swift/Objective-C interoperability. Check out the links in this comment o SIL - https://www.reddit.com/r/swift/comments/4jrs28/10_thousand_times_faster_swift/d3a6sj6 You'll notice that Swift, while it uses some parts of clang, is _not_ clang. It doesn't make sense to presume that something Swift does, Clang automatically gets (and vice-versa). They're two independent large bodies of software that happen to share chunks of common infrastructure.
I would be more than happy to help
I solved this before by converting the dictionary to an array of a custom objects that could be encoded to disk. The custom object looked something like this: struct Entry&lt;T:Encodable, D:Encodable&gt; { var key:T var value:D } For Encodable and Decodable, you can use any JSON serialization library that can encode the object to NSData.
Core data is great but not very Swift-y. Of course you can use it no problem in swift but your data objects must inherit from NSManagedObject, forcing them to be classes, whereas the Swiftier way would be to use structs. (Better immutability and copy-by-value semantics)
I think we're in violent agreement here :-) The top-level comment is "you're using the _same_ compiler, why don't you get the same optimizations?", which of course is not the case.
No, the clipped portion was talking about how the obj-c gives UTC and the swift gives local - nothing about the syntax.
They certainly spam reddit a lot. Pretty much every thread on Swift frameworks gets hijacked by their marketing people. For that reason alone, I'm not a big fan.
That's funny, we haven't had any problems with them. The people who do Perfect, however, spammed to the point where we had to threaten to ban them. Then of course they still [do things like this](http://i.imgur.com/TK1QKWP.png).
This friday isn't very last minute. Anyway, look up global variables.
With Objective-C I can clearly see that date is an instance as well... not sure what you're getting at. I love Swift, but listening to people new to Swift with no experience in Objective-C saying Swift is better is hilarious.