Then you could make the same argument about any OO language that doesn't incorporate C-style pointer syntax. I'm sure all those Java programmers have no idea what's going on in their code.
yeah, just jump into it, as long as you start writing Swift code instead of sticking to whatever old mindset you might have it will be wonderful.
* NSCoding compliance * Plists * JSON serialization * Core Data * Custom NSString serialization * NSData Take you pick based on what you need to achieve with "saving". stringByAppendingPathComponent is for constructing file paths such as taking a string with "/var/opt/log" and appending "myapp/log.dat" to create "/var/opt/log/myapp/log.dat" to obtain a full path to where you want to read or write something. This method automagically inserts the "/" as a convenience. 
Well, it is better. And especially for new people, Swift is easier to learn. I think personally it's because a lot of people hate the syntax of Objective-C. When I was learning, I hated the brackets so much that I ended up just quitting from learning it. haha
There's a proposal going around but I don't think it's a good idea. Foundation is an objective-c api and until it is changed to follow Swift best practices the namespace (NS) is a good way to show that it isn't Swift.
Thanks for letting me know :)
Not sure why this posted twice, thanks for letting me know.
&gt;until it is changed to follow Swift best practices the namespace (NS) is a good way to show that it isn't Swift They're actively updating the classes in Foundation to follow Swift's best practices, though.
Let's say you want the values of a [Int: String] dictionary to turn into an array, sorted by the key of the value. You could do something like this: let z: [Int: String] = [ 1: "Hello", 4: "World", 2: "Foo", 8: "Bar" ] print( Array(z).sort({$0.0 &lt; $1.0}).map({$0.1}) ) // prints ["Hello", "Foo", "World", "Bar"] It looks like you could apply this concept directly to your ```entities``` variable (to get an array of entities sorted by their ID).
Hi thank you for your advice. I have tried to do what you suggested and I am getting the error message "argument of '#selector' refers to a method that is not exposed to Objective-C" Any idea why I'm getting that message? 
Are all your IDs small integers? Then you can just use an array of type [Entity?]. Swift arrays can hold nils, unlike NSArray. (If your IDs are really large integers, then this will be inefficient due to the size of the arrays.)
I can help too 
Thanks. In my limited experience I hadn't come across OptionSetType. Could be the answer!
This can be tricky in Swift: many of the struct types in the standard library are backed by private class types in order to implement copy-on-write. So making an Array can allocate memory, when you might expect it to be on the stack. Swift 3 is getting smarter about promoting heap allocations to the stack using escape analysis, but it'll still happen sometimes.
If you just want to learn the language, then you can use some online tool to do it: https://swiftlang.ng.bluemix.net Otherwise there is a compiler available: https://github.com/tinysun212/swift-windows/releases It has no integration, so you have to create the swift files with a text editor and compile it from the text editor or from the command line.
okay got it i just like the eaziness of xcode i want to really use it but im on a windows platform actually come 2 think of it i might just install MAC os on my computer dont know if its possible but if it is possible will probably will do it can figure out visual studio how to make deployable swift code on it asap and easily as possible or how to make it functiononing can u tell me how to use silver its something about swift being implemented in windows 
I guess so. I put it mainly in to make it obvious that I needed that number in a later function, that depended on the number of cases. If I changed the number of cases, the later function would not work, and I was hoping that a separate function would make it less likely for me to make a mistake.
I'm sure they're working on all of that, but such changes aren't made overnight. The important thing is that the standard library will eventually (hopefully) feel very Swifty. :)
Ok, before I take the time to help you out here could you specify which snapshot you're using? The 05-03 snapshot introduced huge changes to the entire collection model which would make the code very different than pre-05-03.
Yeah, it's because of that "hopefully" that I don't support Apple's decision to make Foundation 100% api compatible. If I were Chris Lattner and friends I would have made another framework which is similar to Foundation but built from the ground up rather than trying to meld Foundation into something that fits the language.
My advice is to buy a second hand Mac Mini and avoid any legal or performance problems (OS X tends to be very slow in a VM). If you really want it, you could install OS X in a VM and use it on Windows, keep in mind that this is not sanctioned by Apple and probably against the OS X license. Youtube has a few tutorials about this.
nevermind I have solved my problem through research. thanks for your help. 
Have you investigated the SequenceType protocol? It's how you can implement the `for user in userCollection` functionality. Then you can implement subscripts for your class. Subscripts can return an optional. Finally, have a private dictionary where you store your data. Expose the data in the way you want through the two mechanisms above.
How long did it take your app to get a few hundred million ad requests a month? Thats really impressive!
Around 4 years. Lots of luck involved!
Did you spend any money on marketing or did you just keep making the app better in those 4 years and it finally clicked?
The one you are talking about is dropping all the `NS` prefixes on all presumably platform independent classes. There is another proposal on introducing more bridged value types, whereas `Date` is one of them. Some are wrapping its Foundation counterpart with copy-on-write semantics, while some are a reimplementation in Swift. Moreover, for these bridged types, their counterpart would not drop the `NS` prefix IIRC.
So you gave up because you couldn't understand something? That doesn't make Swift better... just saying. There are plenty of things that make Swift better than Objective-C, an incorrect blog post showing NSDate initialisation in two languages isn't one of them.
The apple docs about the transform property: &gt; WARNING &gt; If this property is not the identity transform, the value of the frame property is undefined and therefore should be ignored. In other words: Nope, don't do that. Bad idea.
Why not apps with ads to support the developer while allowing user to test the functionality and an in-app purchase to remove? Seems like a win-win?
Thanks for that!
This is an issue that seems to crop up when you use inferred typing with large or complex dictonaries. Try making the types explicit wherever you can. For example, I had a dictionary where the keys were an enum. When I changed over to the full EnumName.Case syntax and explicitly declared the dictionary's type, the issue was resolved.
For me Admob has been total shit compared to iAd. Like $0.1 vs. $1.0 cpm. Facebook Audience Network is better than Admob but not quite as good as iAd for me. Just try a lot of networks, not everything works the same for all apps…
Fine on Chrome here.
I'd be happy to help :-)
When the build fails it lists all of these: -Consecutive statements on a line must be separated by ';' (it suggests putting the semicolon before 'else') -Braced block of statements is an unused closure -Expected expression -Variable used within its own initial value -Expression resolves to an unused function -Use of unresolved identifier 'guard'
If you are trying to nil check the lastTick use lastTick != nil statement. You can also use the if let way if you like, then you just have to wrap the code around the if statement
If there are no error or warning messages, you must debug with breakpoints. Put the breakpoint at the earliest point possible and keep moving it further into your code until the failure occurs. Then you found the problem location. Then figure out why and how to fix it.
I managed to get there without having to put dollars into marketing. I just constantly iterated ASO until it stuck. After 2 years, the app was maybe top 3,000 in the store until I managed to get some good keywords into the app title (at which point it jumped to top 80).
You're trying to assign `lastTick` to `lastTick`... Use a different name, like such: guard let last = lastTick else { return } . . . 
Sounds like you are missing a curly brace above this block?
This must be the problem. Currently updating.
Thanks!
You don't need Zewo. Swift takes up after Objective-C. And while it doesn't have all the awesome KVO capabilities, you could reasonably expect them to port of at least some form of reflection. And they did. http://nshipster.com/mirrortype/ https://appventure.me/2015/10/24/swift-reflection-api-what-you-can-do/ If you just do it in Objective-C you can just use KVO to get the class properties. Although I'll warn that I've written a custom Model-&gt;Json-&gt;Model mapper with validation using only KVO in Objective-C and that shit was not easy.
Maybe it is confusing lastTick with self.lastTick? You might try "guard let lastTick = self.lastTick else"
Exactly, as long as developers don't overdue the ads or incorporate them in a way that hurts the user experience, a few here and there to support them doesn't hurt. I've deleted apps because every few seconds an ad popped up and it was absolutely infuriating haha
Ah thank you ... That sucks ...LOL (I have a lot of ugly code to write) 
Could you show us the code? That would help solve the issue.
I assumed, possibly wrongly, that this must be very common. The output from my most recent one is ... 2016-05-19 20:28:12.305 TrafficLights[22267:1323850] Unknown class _TtC13TrafficLights14ViewController in Interface Builder file. 2016-05-19 20:28:12.378 TrafficLights[22267:1323850] CUICatalog: Invalid asset name supplied: 2016-05-19 20:28:12.378 TrafficLights[22267:1323850] Could not load the "" image referenced from a nib in the bundle with identifier "resr.TrafficLights" 2016-05-19 20:28:12.394 TrafficLights[22267:1323850] *** Terminating app due to uncaught exception 'NSUnknownKeyException', reason: '[&lt;UIViewController 0x7f9d7a4156d0&gt; setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key button.' *** First throw call stack: ( 0 CoreFoundation 0x000000010c39f0e5 __exceptionPreprocess + 165 1 libobjc.A.dylib 0x000000010e145deb objc_exception_throw + 48 2 CoreFoundation 0x000000010c39ed29 -[NSException raise] + 9 3 Foundation 0x000000010c7702eb -[NSObject(NSKeyValueCoding) setValue:forKey:] + 288 4 UIKit 0x000000010cd594ac -[UIViewController setValue:forKey:] + 88 5 UIKit 0x000000010cf91173 -[UIRuntimeOutletConnection connect] + 109 6 CoreFoundation 0x000000010c2d99b0 -[NSArray makeObjectsPerformSelector:] + 224 7 UIKit 0x000000010cf8fb56 -[UINib instantiateWithOwner:options:] + 1864 8 UIKit 0x000000010cd60076 -[UIViewController _loadViewFromNibNamed:bundle:] + 381 9 UIKit 0x000000010cd609a2 -[UIViewController loadView] + 178 10 UIKit 0x000000010cd60d00 -[UIViewController loadViewIfRequired] + 138 11 UIKit 0x000000010cd61473 -[UIViewController view] + 27 12 UIKit 0x000000010cc3769c -[UIWindow addRootViewControllerViewIfPossible] + 61 13 UIKit 0x000000010cc37d85 -[UIWindow _setHidden:forced:] + 282 14 UIKit 0x000000010cc49868 -[UIWindow makeKeyAndVisible] + 42 15 UIKit 0x000000010cbbe803 -[UIApplication _callInitializationDelegatesForMainScene:transitionContext:] + 4131 16 UIKit 0x000000010cbc4ef4 -[UIApplication _runWithMainScene:transitionContext:completion:] + 1769 17 UIKit 0x000000010cbc20a0 -[UIApplication workspaceDidEndTransaction:] + 188 18 FrontBoardServices 0x000000010ffb28c8 __FBSSERIALQUEUE_IS_CALLING_OUT_TO_A_BLOCK__ + 24 19 FrontBoardServices 0x000000010ffb2741 -[FBSSerialQueue _performNext] + 178 20 FrontBoardServices 0x000000010ffb2aca -[FBSSerialQueue _performNextFromRunLoopSource] + 45 21 CoreFoundation 0x000000010c2c5421 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 17 22 CoreFoundation 0x000000010c2bb34c __CFRunLoopDoSources0 + 556 23 CoreFoundation 0x000000010c2ba803 __CFRunLoopRun + 867 24 CoreFoundation 0x000000010c2ba218 CFRunLoopRunSpecific + 488 25 UIKit 0x000000010cbc18ad -[UIApplication _run] + 402 26 UIKit 0x000000010cbc6895 UIApplicationMain + 171 27 TrafficLights 0x000000010c1bf782 main + 114 28 libdyld.dylib 0x000000010ec049e9 start + 1 29 ??? 0x0000000000000001 0x0 + 1 ) libc++abi.dylib: terminating with uncaught exception of type NSException (lldb) 
As someone who is curious about functional programming, but has not had the time to do a lot of research or go through tutorials, I really enjoyed this. Funny because I've been using higher order functions sometimes and didn't even realize that was a concept of functional programming. 
TLDR: You can now turn this: button.addTarget(self, action: #selector(ViewController.buttonTapped(_:)), forControlEvents: .TouchUpInside) Into this: button.addTarget(self, action: .buttonTapped, forControlEvents: .TouchUpInside) He just created a Selector extension. Great stuff.
Cheers for the reply. I have done that. I deleted them, re added new buttons/text/image , re linked them. Still a crash. I never removed the IBOutlet in the code, just the faulty code that caused the crash. Everything looks identical to my second project. I don't understand why if I made an error in my code, I think this time I called a functions incorrectly. Surely when I delete the code it should work just like before I added it?
Class is "ViewController". All Identical to my working project. 
Adding to the discussion, another common convention that you'll frequently see if you're on a project with former Obj-C devs are camelCase constants beginning with a 'k' (for constants that developers previously had in all-caps in Java and Obj-C). This naming convention is especially popular with folks with an Obj-C background. e.g. DAYS_IN_A_YEAR in Java or Obj-C lends itself nicely to: let kDaysInAYear = 365 // in swift However, if everyone on the project you're working on is hip to a more Swifty way of doing things, I would cast a vote for using enums (as other folks on this thread have already smartly suggested).
Am I going crazy or did he just use several lines of code to indirectly accomplish what he'd already done explicitly in half a line of code..?
I like this better than writing #selector bs every time. Why couldn't it just be .thisButton(_:). 
Very beautiful controller! You might want to check over your Readme.md a bit though, there's quite a few typos. Just curious, where is Ramotion originally based out of? Twitter says Palo Alto, but a few things point to overseas.
You can create a subclass of UITableViewCell and then assign it to that reusable cell. Then Control-Drag the button to the table view cell code and create an IBAction. If you want to also modify the button you need to create an IBOutlet for the button as well. Edit: Don't forget to cast the cell to the new subclass when you dequeue it, i.e. let cell = dequeueReusableCellWithIdentifier(......) as! YourTableViewCellSubclass
This requires adding code for each of the different selectors that you want to define in the extension. Normally, I am only using a specific selector once or *maybe* twice in an app, so I doubt this would really slim down my code. I don't find this very useful to be honest.
Xcode is usually super good about providing automatic fix-its when there's breaking changes. I'm sure that updating it won't be too difficult.
From my experience those auto fixes work about 50% of the time. For whatever reason, xcode will randomly decide to mis-format one
As long as you can download Xcode you should be alright. 
Thanks. This works great for me! I am also trying to have some function called when the particular button in the cell is pressed. Currently using cell.addTarget(). It's working. But I am wondering if it's correct usage of this function. 
Compile Swift to the Erlang VM is mine. :)
You will need the latest OS X, El Capitan, in order to be able to use the latest Xcode and deploy on iOS 9. I've recently installed Xcode 7.3 and El Capitan on a 2011 MacBook Pro with 8GB of RAM the development speed is decent.
I run OSX through VMware workstation pro. Xcode and El Cap both run very well for me, and I'm doing it with a surface pro 4. If I can run it on a tablet, you can probably run it on what you're working with. The only issue I have is that my native screen resolution is so large I have trouble using the UI for extended periods of time.
Only a google query away: https://www.raywenderlich.com/87008/overlay-views-mapkit-swift-tutorial https://www.raywenderlich.com/21365/introduction-to-mapkit-in-ios-6-tutorial https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/LocationAwarenessPG/Introduction/Introduction.html For geocode data, search for "library" within the current user location with: https://developer.apple.com/library/ios/documentation/MapKit/Reference/MKLocalSearch/index.html 
Because `Comparable` is using `Self` in its definition. When you use the magic `Self` parameter, it becomes unsafe to refer to a protocol in non-generic contexts because you can re-instantiate `Self` to whatever you happen to feel like. For illustrative purposes, imagine `Self` like an implicit `associatedtype` defined by all protocols and instantiated automatically by all conforming structures and classes. Now, for classes, removing the restriction makes some sense, especially when you're taking about Equatability or Comparability: after all, if you've got an Animal class and a Dog class with the former implementing `Comparable`, you'd expect comparison to succeed because of variance. But now imagine both are structs. You've now promised the compiler that the two can be compared regardless of their individual implementation of `Comparable`. Not only that, you've promised the compiler *any* 2 types you can conjure up that are `Comparable` on their own are `Comparable` together! And that's just nonsense!
I've always had to delete the old and create a new. I wrote a helper function called scheduleUniqueNotification() for the purpose. Agree with the dog pic.
Literally one word
Awesome. Seeing a lot of great designers and development agencies coming out of Russia recently.
Xcode. Not XCode.
Only if you're being silly and doing recursion for everything. 
very detailed and helpful, thanks 
Doesn't this mess up inheritance?
I run El Cap on my early 2008 MBP.
Dick
Thanks man I appreciate the feedback! I'm definitely going to try out various services and find which one does best! =)
It's "incredibly easy" to blow the stack with OO too, just message yourself recursively for a bit and wait. You can get ⊥ just as easily writing under either paradigm.
What Mac do you have? Almost everything since 2009 supports El Capitan. The upgrade is pretty painless. XCode likes SSDs, and those are dirt cheap these days. At least 8GB of memory is also good.
It's something weird with the way Medium.com's links work. Just search for the title in Google.
Can I get a link, would like to read up about all this. The language is changing so quickly a lot of the literature out there is from different versions of Swift.
Every Mac that supports Mountain Lion (10.8) also supports Mavericks (10.9), Yosemite (10.10), and El Capitan (10.11). Upgrade your RAM if necessary &amp; upgrade! If you really to keep your 10.8 then get another drive/make a partition and dual boot.
it's in fact the "LessOne" part that's particularly silly
Sounds like you want something a little like a ordered dictionary. There's a github repo of one [here](https://github.com/lukaskubanek/OrderedDictionary) that looks pretty good, I'd suggest either using that directly, subclassing it to specify always `Int` keys &amp; the iteration you need, or modify to build that in directly.
What would you name it? Or write it?
One of the reasons I that they still have a strong design schools left from the Soviet Union.
In the code you posted, where **specifically** does it die? What's the actual error message?
Have you hooked up the IBOutlet via Storyboards for filePreview (the WebView)? If you don't do that filePreview will be nil.
A single array containing 14 array is less faster but it's trivial if you don't call the arrays a lot of times. Basicly the difference is you make and extra instruction call for the main array. So 1 intruction call more for each call you make. For memory it's only 8 bytes more. 
Does Xcode give you an auto fix it suggestion? Usually means you need to add @objc to your fund (the one you are attempting to set for the selector) Hard to say without seeing full code...
What you mean by "The web view is located in a separate view controler divided using a Split View."? Are you saying you are using UISplitViewController? If so, you should state that, because UISplitViewController is not the same as the iOS 9 "Split View" feature.
Why are you doing this? filePreviewController().loadHTMLTable(pathToSave) I have a feeling you don't understand how the iOS UIViewController lifecycle works.
This is not iOS Development. The way NSViewController and UIViewControllers behave are slightly different. The filePreviewController is active concurrently and needs to react to a completed process in convertFileController.
Part of your problem is the "http://www.google.com" - it should be "https://www.google.com" since iOS 9 forbids non-https URLs by default. If you need "http" URLs you can look up how you adjust your Info.plist to allow them.
Thanks for the correction!
Agree. I can't imagine a case when 14 arrays (which are obviously related) is in any way understandable. But, having 1 array of 14 arrays is not necessarily the only alternative. For example, suppose your 14 arrays were like firstNames, lastNames, favouriteColours, heights, weights, etc (ie 14 attributes of biographical data for each person). It would be better to define a structure to hold the attributes (firstName, lastName, favouriteColour, height, weight, etc), then define 1 array where each element of the array contains an instance of the struct. Then you could access an attribute by doing: people[n].favouriteColour or people[0].height, and so on. 
no
I'm going away for the weekend but I would really appreciate you having a look at it 👍 I'll send it when I return!
Cheers, I did try that :(
This is way too vague. Screenshots (of both the simulator and Storyboard, if you use that)? Code?
Yep. My bad. 
You can now unwrap multiple optionals on one line by separating them with commas. if let x = y, let z = w { // Do some things }
this isn't a panacea but a commonly missed thing is that you can use map on optionals instead of if let e.g. func add1(value: Int?) -&gt; Int? { return value.map { $0 + 1 } }
Do you have proper constraints set up? It sounds like you put some elements in a storyboard without adding in constants to hold them to the spots you added them to.
That would be faster due to data locality as well, but only assuming you are doing row-based operations and not columnar-based operations (like finding the minimum height, for example, would be faster if you stored all heights in a single array).
I have a mid-2009 Mac with 4 GB of memory. When I first got it, it had leopard on it. Now I've updated it only to Mountain Lion. Can it handle El Cap?
Thanks for the reply! I figured as much. I'm just not sure how to stay in scope or give scope to my function. I would think that since filePreview and loadHTMLTable() are declared/linked inside the class scope wouldn't be an issue. I tried changing the filePreview declaration to **strong** but no dice.
I don't see how you're disagreeing with me; you're just getting more specific about "wherever possible." I was clear that it requires you to error/return. IME the place where I unwrap optionals the most is right at the beginning of a function, where I want to use guard to check/unwrap various inputs. I barely use it-let because by the time I get to the meat of a function everything is unwrapped already. 
I guess the point I'm making is that people shouldn't try to massage a usage of `guard` if they don't actually *need* to return early. By putting usage of `guard` at the front of the list, and suggesting that people begin there "wherever possible," the usage and meaning of the `guard` statement is being muddied up. "Wherever necessary" would be a better way to phrase it. They introduced in-line `if let` statements to handle the general case of the "pyramid of doom" problem. The `guard` statement was introduced to solve the tangential problem (which also sometimes led to the "pyramid of doom," but more commonly just forced people to invert logic and write harder-to-read code) of needing to exit early but having no convenient means of doing so. You can actually end up with similarly tortured logic if you use a `guard` statement purely as a means of avoiding "pyramid of doom."
In other words, do it like Objective-C always did it. Swift just requires the ? operator, but it's still a useful pattern.
Probably, here you go https://support.apple.com/kb/SP728?locale=en_US I have a couple of 2010 machines that run El Capitan just fine. See OWC for memory upgrades, they've done a bit of research on maxing out memory. My 2010 MacBook runs with 16GB, though Apple only official supports 4GB. And definitely get an SSD, I've used crucial MX drives (avoid the BX) and SanDisk drives. You can find them for less than $80 for 240GB drives. Ifixit and OWC have videos on how to add memory and replace drives.
Nice! You can also shorten it to ```if let guess = Int(userInput) { ... } else { //error }``` If the user doesn't enter something that can be turned into an int, the first block won't execute. Also saves you from making an intermediary variable :) Well done!
I hadn't seen it before myself, but I really prefer it just at a glance. 
No, that's definitely not a standard Swift function (thank god :P).
But he doesn't import anything other than Foundation.
I was going to suggest using switch as well. With Swift, anytime you see a conditional statement that is bigger than "if" and "else", you can probably find a way to use a switch instead. 
thats ray wenderlich code! lol func randomIntBetween(low:Int, high:Int) -&gt; Int { let range = high - (low - 1) return (Int(arc4random()) % range) + (low - 1) } 
Haha it took me a bit but good job! Time to play that lottery 
It's a method of optional unwrapping. When you say if let, you're defining a variable, if you had to say just ```if``` then you'd be defining the variable a line above of the type you want it to be, this just concatenates it. Also you need ```var``` or ```let``` to create the variable. You could totally define it earlier and just ```if guess =```
Just use for l in indexToStartAt+1 ..&lt; longerWord.listOfPhonemes.count { ... }
This is one of those rare cases where a force unwrap would be acceptable. NSCalendar has to have a failable init since in the general case the string could be anything, but the programmer knows at compile-time that the given identifier (being system-supplied) is guaranteed correct and cannot ever fail. 
That initializer for NSCalendar is failable. IE it could return a nil. It is similar to the initializer for UIImage, UIImage(imageNamed: String). If you pass a string that doesn't correspond to an actual image you'll get nil. Similarly if you pass a string to that NSCalendar initializer that doesn't correspond to an actual calendar you'll get nil. You could implicitly unwrap it by adding an ! onto the end on the constructor call or, preferably imo, wrap the whole thing in an if let like a previous commenter said. This is actually one of the things that I really like about swift. It makes you think about whether or not things can return nil and whether or not things at different points are possibly nil. 
I would like to see guard be given the option to not exit early. guard let thing = stuff else { //some code to run otherwise } continue I find it really weird that this isn't a feature of the language. Probably my biggest gripe (besides how incomplete generics/protocols/constraints are).
Implicit Int var upVotes = 0 Implicit Double var upVotes = 0.0 Explicit Double var upVotes:Double = 0 
Thanks. 
Interesting - that code doesn't follow the APIs design guidelines. Also, why use low/high instead of a range? Something like `random(in: 1...10)` is very simple and arguably much better. Is RayWenderlich code usually this sloppy?
i'm not really sure. i'm also a beginner lol thats how i recognized his code. i did it 2 weeks ago
I suggest adding: pod 'Firebase/AdMob'. I am currently able to use interstitials with that pod. 
Thank you so much! That was definitely the problem
Be aware that the Swift challenges don't (yet) allow you to `import Foundation`. So if you're used to that framework you might be forced to come up with alternative solutions.
Thanks, have emailed you.
I'd argue that extending `Range` (or more general, `SequenceType`) would be even better. :)
Can you please make a youtube video about the installation process ( no vagrant or docker) . Seems like it doesn't work in ubuntu 16
I meant implementing it, since you would be extending a protocol which gets into associated types, default implementations, etc. but yes, if it was a more advanced blog, obviously extending the range would be a better solution.
I purchased this book and worked through the whole thing. It is worth it. I was immediately able to apply what I learned to my current project.
Thanks guys I really appreciate all the responses. I guess I need to check the docs closer. I missed that the init was an optional. 
Did you set the view you want to launch first as the initial view controller? That's what I would check first if I had a black screen. From the screenshot you posted, it doesn't look like you have an initial view controller set (no arrow on left side of any storyboard view), but I could be wrong.
I'm really glad to hear that! Do let me know if you have suggestions for new content to add.
Happy to hear it helped!
Yes, by creating a new instance of AVAudioPlayer in your pause function and assigning it to backgroundMusicPlayer you no longer have a reference to the instance thats playing the music.
Yeah, don't reinitialize backgroundAudioPlayer in your pause function. Just pause the instance you have.
I believe, in the pause method, you initialized a new AVAudioPlayer. So the new player is paused, the old one you initialized in play method lost its reference once you point backgroundMusicPlayer to a new object in pause method. 
Great! Happy coding. 
Going off of your title, I'm guessing you are looking for the UITableview method indexPathForVisibleRows, which gives you all index paths for the currently visible cells, so that you can then access them and their elements. But as the other poster explained in good detail, your post lacks a lot of details.
If anyone is still reading this post, I just added four sample videos to the Pro Swift page so you can get a feel for what's inside. There are 70+ videos in total all recorded in high resolution, but at least this way you'll see something before buying.
I use [Argo](https://github.com/thoughtbot/Argo).
Rewrite pauseBackgroundMusic as: func pauseBackgroundMusic() { if backgroundMusicPlayer.playing { backgroundMusicPlayer.pause() } } Or you can simply put that block into the if died == true block.
Just create an SKAction for each those arrays and store them either in 14 different variables or create a dictionary and name each animation so you can easily get it later. You don't need to have the actual array of textures around after that. 
Isn't "framework" a bit of a stretch for what is a fairly simple library?
Sorry. I'm a noob and I use framework and library interchangeably =( I still can't wrap my head to distinguish the two terms even after reading many discussions online.
You invoke a library, a framework invokes you.
There are certainly cross platform solutions server side, see Vapor, Perfect, Taylor... But yeah, you really want to get a MacBook for development.
I didn't know about the server-side deployment options, so I updated my comment. Thx.
If you have an intel graphics card then installing a hackintoish , until you get an apple device won't be too bad. 
NP, tooling will likely take a very long time. Developing for Windows client sounds like it would be a struggle.
Swift 3.0 is definitely not coming at WWDC. Planned release date is still autumn 2016. Xcode 8 beta with better support for the dev snapshots and SPM would be nice though.
What? I guess I misread some press release... Maybe they're just announcing it at WWDC and releasing it with OS X 10.12? Maybe I'm remembering it wrong. I've been up for 36 hours...
In terms of raw tech specs, I'm of course speaking of the past gen Intel chips in the latest mbp, and their non-upgradability. Do you think that's something that'll change this next gen? 
Please let Apple know about that distinction (where everything is a framework or a kit)
Try to double click on a reading material :). It is just a pdf file and your Mac will open the file in Preview.
Getting so tired of their "Thinner is better" philosophy. Give me enough ports, battery, graphics. I am working, not playing. Macbook PRO, not Macbook TOY
I would only recommend a hackintosh for work-related purposes as a method of last resort - it is way too easy to make a hack inoperable. Even then it is difficult to get started without a genuine Mac around in the first place.
I just worry about the MacBook syndrome of "One port to rule them all." Hell, I have a 2013 MBP and 2 USBs aren't enough either. 
So I assume you have something like below for each of your arrays already. let frame1 = SKTexture(imageNamed: "something") let frame2... let animationFrames: [SKTexture] = [frame1, frame2, frame3] How ever you don't need to keep them like that at all, just create an animation like so for each of those arrays. let animation = SKAction.animateWithTextures(animationFrames, timePerFrame: someTimeInterval) Then in what ever place your storing your animations have this dictionary. var animations: [String : SKAction] Then just add that action to the dictionary with what ever name you want. animations["first animation"] = animation You can forget the original animationFrames/animation vars now as that action is stored in the dict. Then just use it like so on a sprite node. Obviously you might not want to force unwrap it, but that will play the correct animation and you only have one dictionary with all of those actions. spriteNode.runAction(animations["first animation"]!) Personally I'd go with something like below as a universal place where all your animations are stored (well the ones you can predict and are reused a lot). Any sprite that wants an animation can grab it from this class safely, as long as you unwrap the optional correctly :P. class animationLibrary { private var animations: [String : SKAction] = [:] func loadAnimations() { // load from json/property list maybe? or some other place. Can be called when the game starts so your resources are preloaded. } func addAnimation(name: String, frames: [SKTexture], timeInterval: NSTimeInterval) { animations[name] = SKAction.animateWithTextures(frames, timePerFrame: timeInterval) } func getAnimationNamed(name: String) -&gt; SKAction? { return animations[name] } } 
Repeat after me: **MacBook Pros are NOT MacBooks.** (Edit: I meant to be reassuring here ^^ , not to come off as a jerk. I apologize if it seems like the latter.) Edit: what do you use USB for, anyway? Get a Bluetooth mouse already ;) Personally, I use my USB ports to charge my iPhone and iPad and to test builds from Xcode or interfaces from Sketch or Flinto. My externals are FW800 and TB (both with USB alt ports JIC), so I'm ok with 2 USB ports. 
Okay so once each action is assigned each array, then I can just clear the arrays then right? That's what you mean? Sinc e the actions have been assigned already there is no need to keep the frames arrays in memory. Yeah I do have 1 dictionary with the actions. Yeah how did you know? I first made it when I wasn't as experienced so I literally had 14 arrays and 14 actions when I first made it last year lol. So now I'm just cleaning my code. I made it go from 2300 lines to 1700 lines without removing any game features, just making the code more efficient. And thanks! I use it as a personal project to experiment/practice my Swift skills.
Whats coming in swift 3 is an improvement overall, but its still not great. What they did there is keep the respective transforms as structs and just add less verbose initializers and static methods. I am taking advantage of pattern matching and enumeration here and there are no static methods, which is in my opinion a better design that what is planned for swift 3.
I have a friend who works in a design studio with a few hacking oh rigs that use TB2 xGPUs. He says they're great, but slow because of the TB2 limiting the bandwidth. TB3 will change everything.
Most likely the beta (and Xcode 8 beta) will be out at WWDC, but the final release is planned for autumn.
Yeah, I'm sure you're right. I remembered incorrectly because I'm severely sleep deprived. I've been up playing Diablo 3 for so long, I didn't even notice it wasn't Saturday anymore!
Okay so just clear the texture arrays then since I don't use them for anything else besides to make animation actions and that's it. The [game](https://itunes.apple.com/us/app/chompd-how-long-can-you-last/id1023110939?ls=1&amp;mt=8) has majorly improved since then (graphics, user interface, etc). That Stack Overflow question was in regards to positioning objects that depend on the frame of the device since I was making my game universal, so I had to make sure all objects are placed correctly. I actually have a [Github](https://github.com/jozemite/SpriteKit-Playable-Area) about it. I'll improve the read me file later since I was just testing out Github at the time. That code works wonders if you're making a game for any device (and on AspectFill) since it will create a rectangular frame of the device's screen and then just position your HUD based on that rectangle. So no matter the device, the HUD will be placed accordingly for all devices.
It's Monday where I'm at… You should go to sleep.
Yes it looks like something I will definitely need in the near future :)
All the stuff from Ramotion it's always quite nice, just saying.
Cool, I'll have to check this out. I'm a fan of http://codingame.com as well. Also http://codewars.com has a nice interface but they still don't support Swift. Hopefully they will soon.
I just can't deal with Windows. I fucking hate it with the intensity of the infinite big bangs of the multiverses. I've turned down jobs at design studios because they were Windows shops. I flat-out refuse to work on that platform. It's a fucking nightmare.
What are you trying to achieve with having them login other than creating an account?
I bought a 2014 Macbook Pro and haven't looked back. I see tons of viable reasons for wanting to use Linux, but most of them are satiated by OS X for me. Most things that work on Linux work on OS X, and OS X has way more support by the industry in terms of desktop apps that you'll use every day. I haven't had any problems with hardware not being upgradeable. As long as you cash out up front, whatever you get is almost certainly gonna be good enough for the next five years. The PCIe SSD in the Macbook is absurdly fast, and easily the most valuable feature of the laptop to me. The rest of the laptop is up to par at worst, and very good at best. It's just a really good machine, with the phenomenal build quality and subtle features that Apple is known for. The trackpad is literally the best one I've *ever* used, and the difference is much more noticeable than you think it will be. All I'm trying to say, is that if OS X is the logical choice, the Macbook shouldn't be holding you back. They're great machines.
Jesus. This is some beautiful polish. Super nice of them to open source all of it. 
I'm fairly certain OS X is free. You should be able to download it outright or borrow a friends and make a bootable flash drive. You can find more here: https://developer.apple.com/osx/download/. This is an old article but the premise is the same: http://www.makeuseof.com/tag/how-to-install-mac-os-x-on-a-pc-without-using-a-mac/ Also, If your close to a university you should check if they have a surplus. At my university they do public offerings and you can get past generation Mac Pro's starting around $125. 
Maybe you could try to create a `ArrayTypeExtracting` protocol, and requires an `Any.Type` computed property. Conform `Array` to that, and return `Element.self` for that requirement. Then you can test whether the returned type conforms to the required protocol (need to have no associated type or `Self` requirements though). I don't know your exact needs, but this should be doable without using reflections.
Holy shit that sounds like it could actually work! I'm gonna try that right now! To clarify why I'm so excited: I've spent hours and hours trying to make my custom-mirror thingy work in swift 3 and I became quite hopeless that I could solve this problem. **edit:** awesome, that completely solved this problem. Thank you SO MUCH!
I'm going to release my app outside of MAS too, but the whole licensing/ordering setup is so convoluted that I'm postponing it all the time. I have this in my notes for serial numbers: https://github.com/glebd/cocoafob/ One thing to keep in mind is that you can't make an unbreakable piracy protection, so don't sweat much and keep it simple. For payment processing you can use many services. Look for apps priced similar to yours and sold by independent developers. As long as a service can fetch your URL to get a serial number for an order, you can pick solely based on the service pricing.
What's `int2`? If that's the name if your custom type, then capitalise it. To answer your question, put the `==` declaration on the global level (so not inside your struct/class/whatever) and change `self` to the type name. For example: struct Int2: Equatable { var x, y: Int } func ==(lhs: Int2, rhs: Int2) -&gt; Bool { return lhs.x == rhs.x &amp;&amp; lhs.y == rhs.y }
&gt; And still they prevent you from doing your job. &gt; facepalm.gif &gt; The point is not to get the most technically advanced device you can find. The point is having the right tool for your job. Pretty amazing really. If he had said that the MBP's are expensive I would have agreed with him. Frankly I really don't think he is being objective at all when it comes to his comments about being technologically advanced. He certainly isn't considering the advantages the OS brings to the platforms. 
I switched to Swift development after working mainly on web stuff (Drupal, Django, Javascript, etc). It's definitely different, but you'll change your way of thinking over time. All of a sudden you'll realize "DAMN I know a ton about this language" and start impressing yourself with how you solve problems. Getting to that point requires you feel dumb, and like you don't understand things. If you keep at it you'll develop an understanding and not even realize it. I think a lot of the difficulty is picking up on different "patterns" in Swift. When you first start, you might have nested ifs everywhere, then you realize you could use guard statements instead and clean things up. Suddenly that's your new "default" and you're writing much clearer code. I wouldn't spend any money on school or courses. Just keep practicing and you'll pick things up over time. Edit: Thinking back, I remember that after I finished the Swift course on iTunes, I sat down to start working on an app and had a hard time. I obviously learned all the basics in the course, but couldn't think of the functions ("prepareForSegue" comes to mind). After working on an app of my own for awhile I started to memorized those things.
Is there any reason you don't want to just use CachedPlayer, and get rid of the struct entirely? I am using realm as well, and all the data is displayed in a collection view. I just use the realm objects exclusively. I have a singleton that is the collection view datasource, and it's essentially an array of the realm objects.
Oh jeez, the code it generates is not very 'swifty'... NSArray/NSDictionary? come on.
These are great. Can't wait to overuse the shit out of them for a few projects until I learn to use them responsibly.
&gt; func ==(lhs: self, rhs: self) -&gt; Bool { &gt; return lhs.x == rhs.x &amp;&amp; lhs.y == rhs.y &gt; } The error is: Expected parameter of Type following : I think you are right, though I'm an amateur and don't know much about using generics. int2 seems to be used in SpriteKit, and GamePlayKit. It's like a point with two values x and y each of which is an Int32: int2( Int32, Int32)
I can't help but feel like you're approaching the problem from the wrong direction. If you every have to use `Any`, that should usually be a red flag that what you're doing could be done better with generics. Could you elaborate on your use-case?
I understand the argument, but I feel like it makes things more complicated to the point of not being worthwhile. What are the benefits of using a different representation of the model? I know the answer is a single point of coupling to the datasource, but if you have to refactor you're changing code everywhere you use the (decoupled) object anyway.
Well, it's convenience over 'correctness'. I agree with you here, its a lot of boilerplate and to be honest not that much gain. This is one of the reasons that I use a simpler approach whenever I don't have to work with the cache in advanced ways. For example, I like to serialize to JSON and store it in a file, or sometimes I get _really_ dirty and just store it in NSUserDefaults. Simple and the code is surprisingly beautiful since I don't depend on any outside framework that dictates what my models have to look like.
Like you, I find Apples obsession with making things thinner misplaced. Their devices are already sleek as hell but - like some kind of eating disorder - they just don't seem to be able to stop... Their dis-morphic 'ideal' seems to be to removing all evidence that their devices are a piece of nuts &amp; bolts technology, and instead make them frameless, like a book, or paper. A nice enough concept, but maybe out of touch with what most users actually need and want? To my mind, they got the balance 'just right' with the 2013 rMBP... It has the performance, the ports, the battery life and, yes, it is *thin*... dare I say, it's almost perfect, so hold it there! I've asked my iOS Developer friends and colleagues (numbering 7 or so) if they want thinner devices... the answer is always 'No!'; the sizes are fine as they are! I'm not against progress, but I don't want to break a device just by looking at it; not do I want battery life jeopardised.
By coincidence, I wrote an article this week that also implements Xoroshiro: http://www.cocoawithlove.com/blog/2016/05/19/random-numbers.html My only major comment on your implementation is that you should use a tuple instead of an array, e.g. `var rngState: (UInt64, UInt64) = (0, 0)`. Swift can't optimize arrays to the stack (yet) so using a tuple is much faster.
If you really still want Linux, even just to test and play around with, you can dual-boot most Linux distros alongside OS X on a Mac (or boot up Linux in a VM, inside of OS X).
How the data is stored in the persistence layer and how the data is being used by view layer could be different. For example, you could store data as many-to-many relationship in realm but the view layer may only care about part of that data. It is better to only have the persistence layer worry about how the data is stored and the view layer only worry about how data is presented. Another example could be where the view layer requires data to be transformed before being display, but the calculated result is not persisted. You could have the transformed data in the "data preparation" layer. Such approach requires you to reconsider the architecture of your app. In my case, the architecture was decided and designed before implementation. So it was simple and obvious what code belongs to which layer. As the number of lines grows, a clean architecture is very important.
Relax man the Mac Pro will be updated when the hardware to do an update is available. At this point nothing exist to make a worthwhile update. This will change latter in the year. 
I found [this tutorial](https://www.raywenderlich.com/110536/custom-uiviewcontroller-transitions) to be fairly helpful when learning how to do custom transitions... might be helpful.
Hi! I'm an experiences SpriteKit developer and have a game already in the App Store. I ran your code and got a BUNCH of errors. mostly deprecated code errors. I suggest you update to the latest Xcode. For example, you used "++" which is no longer supported. I found the error. The problem is that when spawnEnemies() is first called, MaxValue is equal to 1004 and MinValue is equal to 128. You have SpawnPoint convert (MaxValue - MinValue) into a UInt32, which is unsigned (can't be negative). Now, when you press the restart button, a new instance of GameScene() is made but nothing is passed regarding it's size, so when you restart again, it's creating an empty GameScene object; MaxValue equals -19 and MinValue equals 0.125 because size is not defined. When spawnPoint is calculated (-19 - 0.125) and converts into a UInt32, it's an error because UInt32 can't be negative and the calculation is negative. Here's how to fix it. Make sure that GameScene has a size initialized. In the ViewController, you probably have code that looks like this: if let scene = GameScene(fileNamed:"GameScene") { // Configure the view. let skView = self.view as! SKView skView.showsFPS = true skView.showsNodeCount = true /* Sprite Kit applies additional optimizations to improve rendering performance */ skView.ignoresSiblingOrder = true /* Set the scale mode to scale to fit the window */ scene.scaleMode = .AspectFill skView.presentScene(scene) } That initializes the GameScene object to have the same size as the GameScene.sks file (it's in your folders on the left bar) so the first time the game load it works because the .sks file has a size. Now, when you try to restart, you pass an empty object "GameScene()" that has no sizes and refers to no item with sizes. Use this instead in the retry button. func Restart(){ if let newGame = GameScene(fileNamed:"GameScene") { newGame.scaleMode = .AspectFill self.view?.presentScene(newGame, transition: SKTransition.crossFadeWithDuration(0.3)) restartBtn.removeFromSuperview() } } The above code only runs if the newGame object refers to an .sks file named "GameScene" which is where it gets its size from. And now it works fine. :)
Gorgeous, thanks for sharing
I don't really see what you get from using an enum to represent the transforms. The benefit could be that you can check whether, for example, a transform is a simple translation, except that doesn't work, since a .Init and .Custom transform may also be translations. So the enum is misleading in that you can't actually infer the type of the transform from them. If you had a constructor for the enum that takes an arbitrary transform that actually returns .Translate for transforms that only translate (and the same for the other types), that could be useful, although not all too often. (At least I don't need to know the type of a transform after I've created it very often). So basically my problem here is that the enum cases don't actually represent distinct cases. Another nitpick is the use of the + operator for transform concatenation. I'd expect + to add the transforms, not concatenate them. That, of course, is not very useful for the geometric operations are used usually. I'm not entirely sure which operator to use - * isn't entirely correct either, and introducing a new operator (•) is annoying to type. Also, I'd introduce an additional transform type for "Shearing" - it's not very commonly used, but it's the final transform type needed so that you can create all possible transforms from your "primitives" (i.e. with scale, rotate, shear and translate you can make any transform you can make with your .Init).
 var val = 1 aLabel: while(true) { switch val { case 1: print("this is 1") case 2: print("this is 2") case 3: print("this is 3") case 4: print("this is 4") default: print("jump out") break aLabel } val += 1 } See [here](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html), in the section _Labeled Statements_.
[don't worry](https://www.reddit.com/comments/3bwo68/how_much_does_an_experienced_programmer_use_google/)
Besides the things that others just said, I think that this approach enables you to use value types (structs) across your app instead of reference types which is also recommended.
Yep, I have done something like this in previous apps but I was wondering if there was a "more swifty" way. I was thinking of maybe using protocols for this. Thanks for your answer!
I've been consistently learning swift for a couple months now on udemy and honestly I feel the same way as you. If you check out [my GitHub.](https://github.com/JasonMcCoy) I have 12 projects I made, from watching videos. Some people starting out will think, damn this guy can make a calc app? He must be able to make something even simpler than that on his own. Nope... I have zero experience in programming in my life, so I'm not like that one guy on the internet who says, "I'm not that good in programming, but I've done x years in x language". To me that doesn't make me feel confident because people who are learning will think, as I did, geeze, if he can learn that and work in a professional environment, then you know... I feel you man, I'm in the same boat. I have to honestly say that when given exercises, I end up having to watch the lecture again, but edit some things around and boom I'm done. I feel guilty because I did make the app like the instructor did like in the video, but I can't do it without following the video closely. I'm starting to know why iOS Devs get paid so much! Also, a big concern I had was my lack of math ability. I'm not that great and I've been pretty good so far. I'm not that type of person who says that "I'm not that great at math" and is having a hard time in AP Calc or all that stuff...lol. Hope you know what I mean by that. I also don't want to watch math video in algebra lol. If I have to I will, but until that day comes, I wont bother. Hasn't held me back so far. Check out my GitHub and see what I've been doing and know that there are people out there like you and me who have all the odds stacked against them, but are still having fun. All I got man are consistency and hard work on my side unfortunately, hopefully I'll be useful enough one day to contribute to this field without burdening other people's business/time too much. I'm not going to lie, I want that damn iOS Dev job! Hope this helped you out brotha!
Maybe they mean they could goto out of the switch...?
I do not believe this is possible. If it were there would be tons of spammy apps doing this at every opportunity. 
Because it's not licensed for that except on Apple hardware.
A big complicated app is just a bunch of smaller apps thrown together in an elegant way. If it's too intimating, work on smaller apps that implement features you want to see in your big app.
I'm tempted to down vote you just because using labels is too horrible, not because it's wrong. It should come with a "don't try this at home" warning. I would rather use a more clear way to exit early than abusing a switch and a label: for val in vals { guard 1...4 ~= val else { break } // do your happy path code here, use a switch if you want just don't use it to break to a label } The main take away is that it's confusing to have the flow of your program jumping around like that. Also the label break is actually a pre condition check but it happens *after* other statements if you read it. Putting a pre-condition leading to *break* or *continue* on the top of your loop or function is a very good practice. So to sum it up: I would never do it like this because there are better more clear and safe options out there.
So I just tried [Google VR SDK for iOS](https://developers.google.com/vr/ios/?utm_campaign=cardboard_launch_vrview_033016&amp;utm_source=gdev&amp;utm_medium=blog) and it seems to work ok. Still have a few crashes when I jump between several different movies but overall feel more stable than other solutions. Thanks!
You are right that the label is very seldom going to be the right choice in reality. But answering beginner questions like this is hard, because there is always a better way of doing something that uses more advanced features of the language and properties of the problem domain, but that will be more confusing. It is very hard to learn when every time you ask how to do something you are told that you should not have even wanted to do that. There is no need for this switch statement at all of course. And there is no need for the while statement when a for statement would do. And there is no need for the guard statement either of course, as we know the pattern beforehand, and actually now we don't need a for statement, we can use a function: (1...4).forEach{print("this is \($0)")} Your completely correct in all your statements, I just had a couple of seconds free earlier to answer the specific question "how do you break out of multiple levels in Swift" rather than to discuss the merits of declaring preconditions as the question didn't really have enough structure to frame that debate anyway. And given the low level of the question, the OP might not understand the guard statement, the `...` operator, the `~=` operator, etc. PS — I feel I should say: I'm not trying to rebut, you are right that I should have included something saying that this probably isn't actually what OP wanted.
You are doing it wrong. try this: var val = 1 while(val &lt;= 4){ switch val { case 1: print("this is 1") case 2: print("this is 2") case 3: print("this is 3") case 4: print("this is 4") default: print("jump out") break } val += 1 } Or even better: var val = 1 while(val &lt;= 4){ print("this is \(val)") val += 1 }
What do you mean a count variable? Are you trying to append a value to the end of the array? Or are you trying to initialize the array with "count" elements called "something"?
Im trying to add variables into the array. Then I want to access it later
Or just use a `for` loop?
Yup. But, I think OP is looking for a way to do something different for each number, which is (I hope) the reason (s)he chose the switch.
emptyArray += [Something] and then... You want what? To know index of this las added element? https://www.dropbox.com/s/bqsamvjldiaf514/Screenshot%202016-05-24%2022.04.14.png?dl=0
The code would have been hard to put into a simple test problem. Was in the middle of some nasty async AWS calls.
Oh I see. Do you know how many you want to add? Or does it change every time? What type of element will yoU be placing in the array? 
I believe `+= [something]` is actually way less efficient than `.append(something)`, I ran some benchmarks a while back. I'm guessing `+= [something]` always copies the entire array to a new location in memory, while `.append(something)` only does that if the space allocated for that array has run out. I'm not sure why the compiler doesn't compile the two statements to the same assembly.
Make sure you are declaring that variable _inside_ the class definition, eg between the lines `class Blabla {` and the matching end bracket `}`, and it's not enclosed in a function definition `func somethingSomething()...` either.
Wrap the switch statement in a closure and call return instead.
what's the error? override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) { let destination = segue.destinationViewController as! FirstViewController destination.minuteInput = minute } 
i like that way of looking at it. thanks! 
That's refreshing to hear because I just looked at your git and it looks pretty legit man. You're a bit farther along than I am, but reading all this stuff and thinking more about it I know i can get there with consistency and hard work. Thanks again for the kind words. PS - i downloaded Catch Crisis and it's pretty fun! Great job
An instance property is a property of the class itself. Make sure the variable is not inside a function.
I usually subclass the tabviewcontroller and put the data there, to be used by anyone who wants it.
What would cause the method epilogue to be expensive (yes, the method is called many times)? Would moving variables local to the method outside make the epilogue less expensive?
If you want it to be completely automatic you'd have to either use a jailbroken phone, since that's not possible through public APIs and the app itself will require entitlements or need to be injected into another process, or you'd have to integrate with a service like [Twilio](https://www.twilio.com/sms)
You can add music if they're subscribed to Apple Music via [[MPMediaLibrary addItemWithProductID: completionHandler:]](https://developer.apple.com/library/ios/releasenotes/General/iOS93APIDiffs/Swift/MediaPlayer.html)
https://youtu.be/3BcBu30thIA?list=PLZlGOBonMjFXDbJvSkkrUeoJU4aXW6qui
I did a similar project for automating sending reminders to my phone at at specific time. If you send an email to Phone#@carrier-domain they will route it to the right mobile number. http://www.emailtextmessages.com/ 
How much experience do you need? I'm just starting to learn and haven't actually made any serious attempts to making apps but I'm willing to learn all I can from anyone who can teach me. 
I could work on it for you for a good rate, pm me but however cost depends on experience of dev, plus features you want 
use 'if' statements instead of switch cases? I don't know any fancy tricks.
This might be for me. I have minor programming experience and want to put an ios app on the app store as a summer project. Having some people to casually ask for advice for general things like when to use SpriteKit or a SingleView Application. Out of curiosity, what does the distribution of ages look like in the group?
Thank you so much but I am unsure this coding will work because I am using XCode Version 6.1. Should I still make similar changes then? The only error that appears is when I restart for me. It doesn't have to do with sks or the game scene itself. I am currently not even using an sks file. Thank you so much though. Now I kind of understand the error, I am just confused how to solve it because I am using an earlier version of swift and xcode.
My favorite is Mapper by Lyft. But there's also Argo, Gloss, Unbox, and countless others. Check out the sample code and pick the one that has your favorite syntax. 
See, I'm basically trying to emulate a basic USB keyboard with an iPhone. I want to be able to plug in my device via USB to any machine (like you can with a standard USB keyboard) and type, without preloading any software on the host (again, like a standard keyboard). Thanks for your reply. I'm going to keep researching
Your users helped me complete the other breakpoint errors. this is a different one 
Wait, how? I don't think that'll work.
Without a special app/driver on the computer I'll say no. The device needs to support the HID USB profile and iOS devices do not. It could be possible with a jailbreak but even that would surprise me. Depending on what you want to do, you could maybe DIY something. Arduino boards support the USB HID profile by default. That could be a startimg point. With a Bluetooth LE shield you could even do it with just programming and no soldering.
I see, my mistake. Go ahead and post it again!
40 dollars is very expensive?
Any Mac will do and from what I remember development accounts are free now. Just buy a Mac. 
Hmmm I just tried out and yeah, I stand corrected. What happened to the original code and what was wrong in his code?
I would call it very expensive in the domain of mobile apps, yes.
Are there such communities related to Mac OS X development.
There was nothing wrong with his code per se. OP was using Swift 1.0 or 1.2 and guard is available from Swift 2.0
You should replace your setUp method with this: func setUp() { b.setUpEventTrigger { [weak self] string in self?.display(string) } } Explanation: You created reference cycle because when you passed `display` as a closure, there was implicit `self` in it (`display` = `self.display`). You have to wrap it around closure which 'weakens' `self`.
Yep. Thanks for the comment. I just thought of this as well. Lack of sleep fried my brain.
This is a great explanation. I've always had a little trouble wrapping my head around this. Could you explain why you might use weak self? For example, what's it's purpose in this code. 
Just went back and added a couple paragraphs about that :) Please let me know if it makes sense!
Yes! I think I'm getting it now. Not sure it will fully click until I play around with some code, but you did help me understand it better. Thanks!
If `something` is an element that you want to add to the array, then `[something]` is an array consisting of just that element, so `+= [something]` has the same result as adding `something` to the array using `.append(something)`.
Is this just for a project? I ask because the stock iPhone and watch alarm mostly already does this. Set on iPhone, both watch and phone go off and can be cancelled by either. Timer set on watch only goes off on watch.
Yes, for a school project. My app does more things, and this is just a part of it. So what you are saying is just setting an alarm on the default clock? Thanks for answering. 
Hi! This is awesome, thank you! Also, if you are aware of anymore cheatsheets that are explained the way you have, i'd be more than grateful. 
Thanks for the thorough answer. Just to clarify - is there a difference between assigning self to a local variable to ensure self survives the completion block, and using a strong [unowned self] reference? In the example I used, infoTask is calling a networking function so it would be asynchronous. The completion block updates the contents of "self", so it utterly depends on self's existence, but cannot guarantee it will exist. I would imagine the view could disappear before the network call returns.
Is [unowned self] a strong reference, or simply a compact that self will never be nil?
guards and defers are fantastic too.
By using unowned self you are saying that you guarantee that self will never be nil at this point but you only want a weak reference. You can view it as a force unwrapped optional.
First off, there's no such thing as a "strong unowned" reference. "Strong" references are tracked by the reference counter, while both weak and unowned are not. This means that an object can disappear out from under both a weak and unowned reference. The big difference between weak and unowned is that weak references ask to be set to nil when the object is deallocated, while an unowned opts out of that "convenience" as well. This is why weak refs are presented as optionals, while unowned are presented as regular types. **This does not mean it is safe to access that variable**. It just means the reference will keep pointing to the same address in memory, even after the object there dies. [As noted in the Swift section on unowned references](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html#//apple_ref/doc/uid/TP40014097-CH20-ID54), " Swift guarantees **your app will crash** if you try to access an unowned reference after the instance it references is deallocated." In Objective-C, I believe you'll just happily dereference whatever garbage (or other object's memory!!!) is at that address. TL;DR: to answer your root question, passing `[unowned self]` doesn't guarantee "self survival" the way assigning to a strong lvar does *and* actually removes your ability to test the original `self` reference for nil the way `[weak self]` does.
To expand a bit in a second reply, the choice between `[weak]` and `[unowned]` is essentially a matter of *intended semantics*, along with the default `[strong]` and the two Optional types. You use them to communicate both with the compiler and *with your fellow developers* about your design. Here's a table showing what your design claims when it uses each type: RefType | scope ownership | upfront existence (non-nil) | lives through this scope ---|---|----|---- T | owns | guaranteed | guaranteed T? | owns | maybe | guaranteed T! | owns | assumed | guaranteed [weak] T | doesn't | maybe | maybe [unowned] T | doesn't | guaranteed | assumed "Guaranteed" means the design uses compiler type checks to rely on this. "Maybe" means your design considers either possibility valid, and the compiler forces you to add runtime checks before using the object. "Assumed" means it assumes only one option valid, and so will not check at runtime. If it breaks, it should crash because **a developer broke an invariant of the design somewhere**. So let's convert that to sentences that a designer says when they use each type in a function argument, datatype property, or any other scope: RefType | semantic "mission statement" ---|--- T | "I expect the compiler to guarantee an object exists here when I'm initialized, and that it will continue to exist as long as I refer to it" T? | "It is valid for an object not to exist here and I know how to handle a nil value any time I use this, but I expect compiler guarantees that its existence will not change as long as I refer to it" T! | "I need a guarantee an object exists here any time I may need it, but the compiler cannot guarantee it by the time I initialize, so I will pretend I always have it. I expect a developer to place something here before I need it, or I'll crash. I expect a compiler guarantee that an object here will not disappear as long as I refer to it." [weak] T | "It is valid for an object not to exist here, and I know how to handle a nil value anytime I use this. It's neither my job nor right to keep this object alive, and I expect an object to disappear from this spot at any moment, and will put the object somewhere more secure if I need to use it for more than one operation." [unowned] T | "I need a guarantee that a value exists here any time I may need it. The compiler can guarantee that only valid objects are placed here and that one is here when I'm initialized, but not how long objects here live. Likewise, it's neither my job nor right to keep an object alive. I therefore expect a developer to keep my object alive throughout my lifetime, or I will crash." Looking at your use case, the completion block's "mission" for `self` falls squarely in the `[weak]` camp. It cannot and *should* not be the reason a view stays alive, and since it's asynchronous, `self` may even disappear mid-execution on another thread! The operation "utterly depends" on self's existence, but nobody "utterly depends" on the operation completing if they don't already care about the view. It sounds like `completion` therefore knows how to handle `self == nil`: just return right away! And remember, when you look at ObjC code, you may see a lot of completion blocks that don't re-strengthen `self` even when they use it on multiple lines. There are times where this is technically okay, but Swift makes it much easier to use `guard let` than repeatedly unwrapping with e.g. `?.`, and there are is really nothing but upside to it if you're repeatedly using the object. Err on the side of using `let guard`.
Not a direct answer to your question, but have you looked into using a struct instead of dictionaries? It really makes handling your data (including sorting it) much easier.
I haven't, but Ill make sure to look into it! 
Again, thanks for the thorough explanation! One thing I wanted to ask pertains to performance. I am wondering if unwrapping an optional multiple times and checking against nil performs significantly slower than the assignment to a local variable. Also, am I understanding you correctly that if I *don't* assign to a local variable I should use a guard before each statement? For example let's say we are inside the completion block, guard self != nil else { return } self!.someVariable = 1 guard self != nil else { return } self!.someVariableStr = "two" guard self != nil else { return } self!.someVariable3 = [ "three", "four" ] vs. guard let s = self else { return } s.someVariable = 1 s.someVariableStr = "two" s.someVariable3 = [ "three", "four" ] So overall I'm asking if the second path is not only cleaner to read, but better performing, as well. 
I don't have a swift compiler available, so the closure syntax is probably wrong, but: {() -&gt; () in while true { switch val { case 1: break //switch case 2: return //loop } } }() 
I actually wrote an explanation on this topic, but deleted it because I tend to be... verbose (ObjC is my soulmate) and wanted to stay on point :) The **TL;DR** answer is that the first path isn't even *safe*, while the second path is safe *and* still cleaner to read and better performing! Following is a more general discussion of why: **Regarding Multiple Unwrapping** Multiply unwrapping an optional takes *very* little time, even ignoring optimization, You're just comparing a 64-bit number with 0, and doing some branching. That said, I wouldn't be surprised if Swift optimized down to one unwrap that it use throughout the scope.. sort of like one big `guard if... else`. When dealing with `weak`, the performance answer is foggier. Before you can even trust that a nil-check is worthwhile, you have to pause the other threads long enough to snapshot the memory address in the reference and, if it's non-nil, create a `strong` temporary reference to the object. That's the only way the compiler can guarantee that an object will live long enough to use for accessing a property or passing it to a function, etc. Once we finish our single usage, we release the object, even if the very next thing we have planned is to use the `weak` var again. As a rule of thumb, this happens essentially every time your code uses the name of the `weak` var, including when you use `!.`– the expensive part isn't the nil-check, it's atomically retaining the non-nil value. In my informal experience reading ASM, the compiler is shy about optimizing this chain of locks because the ethereality of a `weak` is a guaranteed semantic, and it's not sure if you rely on it disappearing between uses for some reason. Even if I'm mistaken about the compiler's willingness to optimize (and hey, I'm not on the compiler team), the best case is *still* going to be one atomic retain, which is the same number you get with a `guard let` statement. The only performance "downside" to `guard let s = self` is that you potentially use 8 bytes on the stack to store a strong reference. That's not a high price to pay *and* is likely to be optimized so that `s` stays in a register. Swift is *very* good at optimizing local variables. In general, there's nothing wrong with creating lots of local variables even if you use them once–LLVM essentially converts all code to "single static assignment" style where every operation gets its own immutable variable, so it's prepared to optimize away lots of single-use variables. The major win, in my humble opinion, for `guard let` and `if let` is that it allows me to have one, declarative line about how my scope expects to handle a nil `T?` or `weak T`. Everyone on my team, including the compiler, can agree about the semantics of these two blocks, because one, unambiguous line controls how the block reacts to nil. Ex 1. Return early (your second code sample) guard let strongSelf = self else { return; } strongSelf.someVariable = 1 strongSelf.someVariableStr = "two" strongSelf.someVariable3 = [ "three", "four" ] strongVarPassedAsArg.someVar = "Done"; // this won't run if self != nil, even though it's unrelated! Ex 2. Run as much as you can if let strongSelf = self { strongSelf.someVariable = 1 strongSelf.someVariableStr = "two" strongSelf.someVariable3 = [ "three", "four" ] } strongVarPassedAsArg.someVar = "Done"; // this will always run! We have a lot of completion blocks that take `weak self` and care about using it. It's easy to remember I only do actual work in terms of `strongSelf`, a name I use in every completion block, and that I never need to use `?.` instead of `.` for that name. The code that cares about `strongSelf` is identical between these two sections. If I need to swap from one to the other, it's just a matter of changing the top line and matching the brace. Re-indenting is a right-click away in Xcode. Even when I'm working with something less ubiquitous, there's often little reason *not* to do all unwrapping in `guard let` or `if let`. The first person consuming that object declares the semantics around unwrapping it, just like the first person to create a local variable decides to use `let` until they know they want `var`. Again, that means the object in question always uses `.` and it's easy to change semantics as needed without tweaking a bunch of `?` and multiple if-else chains. **Why your first sample is broken** So regardless of whether you accept my arguments *for* making new variables with your `guards`, let me explain why avoiding them doesn't really help your first example. With a `weak` reference, you have no guarantee that the referenced object will stay alive between uses. It can die and be nilled as soon as you set the thing down. This extends to your first example; there's no *actual* guarantee that self will stay the same between each `guard` and the ensuing `self!.`. You're increasing the frequency at which we stop the world and open our little ring box to check on `self`, which I guess improves your odds, but there's nothing *actually* preventing a nasty Baggins from removing the last owning reference on another thread, so you still run the risk of a crash with every `!.`. Something closer to the semantics you're thinking of would be : if let s = self { s.someVariable = 1 } else { return } if let s = self { s.someVariableStr = "two" } else { return } if let s = self { s.someVariable = ["three", "four"] } else { return } Here we avoid crashes, and we only atomically grab `self` once per statement, but the repetition is still obvious, painful to read, *at least as slow* as the version with a single `guard let s = self else { return }`, and possibly tripping other threads up far more often than needed, defeating the point of GCD. NB: As a rule of thumb, you *probably* don't want to use `!.`, especially when working alongside someone else's code. As I mentioned in the previous post, there are times when you want to make a *pointed* statement about how an optional *really should* exist at this special point of code, and should break otherwise, but I don't know that I've actually used that operator in real code. If there's some scope where an optional *shouldn't be optional*, there's probably an obvious place to handle that threshold with an `if let` block, and then call a function/method that takes a non-optional argument of that type. Similarly, If you're designing your own data types, I'm not sure you want to use `var T!` as a property very often. It makes sense for things like UIKit and even other ObjC APIs shimmed to Swift. Maybe there are other reasons a general library would want it at the API boundary, but I'd avoid opening your internal code up to runtime errors if you can refactor around your use case to avoid it.
I think `UInt8` has an initializer that takes a signed number and returns the same bit value: `UInt8(bitPattern: -1)`. Make sure you read the documentation of the init method.
What types are "endTime", "endDate", "startTime" and "startDate"? In your example dictionary they seem to be strings, but in your sample code, you are casting item1["startDate"] to Double, which doesn't work. The fact that you cannot get the good suggestion from /u/Obbut to work indicates that there is likely something wacky with the types of the data. Also, since you say 'I tried that and it doesn't seem to be working. It is displaying by dates" you should show us your sort invocation; 'it is displaying by dates' is troubling. Finally, I agree with /u/teddim, use a struct.
Do you know if it takes awhile to get the invite to join the slack group once you submit your email?
Can't get any more simple than how it's explained in the [Apple docs](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID254) Pretty much you have willGet, willSet, get, set, didGet, didSet and they serve as a way to provide an event for when a property is accessed or altered. So if you wish to perform some calculation whenever someone sets a value, you can do it in one of these blocks!
Sorry I know this isn't quite what you asked for, but maybe it helps in the meantime. **History** Back in the old Objective-C days (and in other languages), if you declared a variable as part of your class, it would by default be an Instance Variable (ivar), which was private so only the class and subclasses could see it. If you wanted to make it public, you had to create a Property. At the most basic level, the way you did that is by basically creating two public methods, one that returned the ivar, and one that set/modified it. Your (public) header file could then show the property @property (nonatomic, retain) NSString *name; which could refer to the ivar NSString *_name; That's a huge pain to do for every single property, so objc had the @synthesize keyword, where all you had to do was to match the name of the property to the name of the ivar (the standard practice was to declare ivars with a _ in front), e.g. @synthesize name = _name; would create a property called "name" that referred to your ivar called "_name", and created getter and setter methods that you could use, but weren't actually in your code. Eventually Xcode made the @synthesize and ivar redundant, so just declaring the @property in your header file automatically created the @synthesize and the ivar for you behind the scenes. So for example, right now in Objective-C, if you create @property (nonatomic, strong) NSString *name; in a class called MyClass, there will be no extra code in your class, but you can still write things like [instanceOfMyClass setName:@"newName"]; or even access _name from within the class itself, even though you never created a variable called _name. **Swift Implications** Swift is a modern language and doesn't make the developer worry about a lot of stuff like that. There is no backing instance variable, because Swift has the public/internal/private keywords. But, having that getter/setter functionality allowed you to do some pretty flexible stuff, so that's where computed properties come in. For example, say you had two string properties, a firstName and a lastName. Sometimes, you'll need a full name. Instead of having to write let fullName = firstName + " " + lastname everywhere you need a full name, you could create a computed property called fullName where the get function returns firstName + " " + lastname. It isn't actually storing any data, it's just a convenient way of accessing a combination of other properties. Another common example is if you want to store the property somewhere else, i.e. a cache. You can use the set function of a property to save that property directly to your cache, and the get function to read it from that cache, instead of saving everything in memory and manually caching things at an arbitrary point later on. So you might wonder, why not just write functions to do this, what does this accomplish that a function can't already do? Nothing, really. It looks cleaner because you don't need the () at the end. I mean, as I mentioned in the History part, getters and setters essentially *are* functions. One last point, that does actually give an advantage over functions, is the property observers willSet and didSet. These aren't getters/setters exactly, but instead they just react to the property being set. You can do things like automatically call reloadData() on a tableview when your datasource object is set, or begin some animations when some other property changes. 
There's a margin on the right edge that shows up. Xcode slowed down for me last time I used it (a few days ago) although it was probably because I had a lot of applications open. I was just wondering what online lecture course you were using as I am also beginning using Xcode after using other languages and IDEs?
/u/twostraws has a brilliant site called [Hacking With Swift.](https://www.hackingwithswift.com) Specifically there is a chapter about properties which covers computed properties [here](http://www.hackingwithswift.com/read/0/17/properties) 
Try taking a look at [HKStatisticsQuery](https://developer.apple.com/library/ios/documentation/HealthKit/Reference/HKStatisticsQuery_Class/) and [HKStatisticsCollectionQuery](https://developer.apple.com/library/ios/documentation/HealthKit/Reference/HKStatisticsCollectionQuery_Class/). You'd supply a predicate to limit the date range. I found the sample code at (Natasha The Robot)[https://www.natashatherobot.com/healthkit-getting-fitness-data/] to be helpful as well. 
Well, the cheat sheet says &gt;Single precision (32-bit) floating-point. Use it when floating-point values do not require 64-bit precision. This suggests that you should default to `Float` unless you *need* `Double`. I think it's better to use `Double` by default because most libraries and frameworks do that (so it makes for less casting).
Okay, I'm just used to some languages either having their own recommended guidelines or their communities having self adopted best practices. This looks like a really clean way to do it though! Thanks! 
[NSObjectProtocol](https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Protocols/NSObject_Protocol/) is a protocol that defines methods "that are fundamental to all Objective-C objects." marking your own protocol with [@objc](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html) is described below from the link: &gt;Optional protocol requirements can only be specified if your protocol is marked with the @objc attribute. &gt;This attribute indicates that the protocol should be exposed to Objective-C code and is described in Using Swift with Cocoa and Objective-C (Swift 2.2). Even if you are not interoperating with Objective-C, you need to mark your protocols with the @objc attribute if you want to specify optional requirements. &gt;Note also that @objc protocols can be adopted only by classes that inherit from Objective-C classes or other @objc classes. They can’t be adopted by structures or enumerations. Basically, marking a protocol with @objc is not even similar to NSObjectProtocol. NSObjectProtocol is a defined protocol in foundation whereas marking a protocol with @objc allows your own protocol to be exposed to Objective-C and therefore have optional requirements. 
There is one app, which is the best one on the App Store. It's called Flashcard Deluxe. You can adjust everything. This is so cool. Maybe you get inspired from that. 
I'll look into it... Thanks :)
I most certainly will, I initially subscribe to team treehouse for android programming
Looks like printing to PDF with gitprint results in a corrupt file. Has anyone gotten it to work?
Right. First step is to stop converting everything to a string. Health kit is giving you the data in the right type, you need to keep it as that type. I have never used health kit, so I'm going to stay away from the exotic items like the heart rate, but here's an example using a very straightforward data type: NSDate: Take the start date for example. You have: let startDate = String(element.startDate).componentsSeparatedByString(" ") If I do a similar thing in a playground, I get: let d = NSDate() // "May 26, 2016, 6:52 PM" let startDate = String(d).componentsSeparatedByString(" ") // ["2016-05-26", "17:52:37", "+0000"] (the first one _prints_ as a string, but that is only the playground doing a favour for us; it really is an NSDate. As a result of the String() and separating components, it is turned into 3 strings. Then, you store the date and time in separate items in the dictionary. About the only thing you can do with the date string or time string is print it out. It is no longer any good for arithmetic or comparing and comparing is the biggest part of sorting. I'm guessing the same thing is happening with the heart beat: it is being turned into a string and then sorting numbers stored as strings, as I mentioned elsewhere, just doesn't work. So, the solution (again, focusing on start date), is to do: let aNewDictionary = ["beats":BeatsPerMinuteArray[0] , "units":BeatsPerMinuteArray[1], "startDate": element.startDate, "endDate":endDate[0], "endTime": endDate[1], "QuantityType":quanitityType] IOW, just stick the start date right into the dictionary. And the same for the other items. Look at https://developer.apple.com/library/ios/documentation/HealthKit/Reference/HKSampleQuery_Class/index.html (about two screens down) to see their Swift example code for pulling energy consumed in joule units out of the results and converting it to a Double. You should be able to do a similar thing with the heart beats and the store the resulting number (which I imagine is either an Int or a Double) in the dictionary without converting it to a string.
Setting means when the value has been set (changed), and getting is when the value is read (retrieved). didSet is called when the value has changed, and willSet is called when the value is about to change. didGet is called when the value has been read, and willGet is called when the value is about to be read. Do note that didSet/willSet/didGet/willGet are only called after initialization. They are not called when the variable is about to be initialized. For example, in my game, I have the following variable: var gameScore: Int { didSet { gameScoreLabel.text = "\(gameScore)" } } Instead of updating the gameScoreLabel in the update() function or in a game over, the label gets updated when the value of gameScore changes. The didSet is called when the score is changed. Using these properties allow you to write less code. Usually when you use get and set on a variable, you make a temporary one to prevent itself from recursively calling itself. For example if I have: var _childVC: UIViewController? { set { // Some Code } get { //Some Code } } If the variable _childVC changes or gets accessed, it will call itself recursively infinitely. So to go around this, a temporary variable is made. var _childVC: UIViewController? { willSet { // Remove the old view controller } didSet { // Calculated controller properties, etc. } var childVC: UIViewController? { set { if newValue != _childVC { _childVC = newValue } get { return _childVC } } [Stackoverflow Question](http://stackoverflow.com/questions/24006234/what-is-the-purpose-of-willset-and-didset-in-swift) regarding this.
Got it. Thanks.
I wrote a free online series called [Hacking with Swift](https://www.hackingwithswift.com). You learn iOS development by building real-world projects, and every third project is a game. I start teaching SpriteKit from project 11 onwards – before that the games are made using UIKit for simplicity. Projects 11, 14, 17, 20, 23, 26, 29, and 36 are all SpriteKit, so you get a huge amount of material. Like I said, the whole series is free to read online, but you can [buy a copy of the book for $30 if you prefer](https://gum.co/hws-book-pack) – it's a 1200-page PDF plus ePub, Mobi, and HTML, and includes exclusive content not on the website.
&gt; That's a huge pain to do for every single property, so objc had the @synthesize keyword Your history is a bit off: Objective-C didn't start with properties: that feature was added around 2005 with the release of what Apple called "Objective-C 2". Also, iVars weren't private (I don't think) until Objective-C 2 came out, allowing the programmer to declare an iVar's visibility. And until 10.6, iVars *had* to be in the main `@interface` block; this still holds true for OS X's 32-bit run-time. Directly accessing an iVar is considered bad form, but it can be done if you need that extra burst of speed without worrying about the overhead of method look-up. &gt; […] if you create @property (nonatomic, strong) NSString *name; in a class called MyClass, there will be no extra code in your class[…] *You* won't be adding extra code, but the compiler does.
This is exactly what I was looking for. Thank you! 
Can't you just set no top border on the segment and no bottom border on nav bar and then just match color! 
I'm a SpriteKit developer and I used Ray Wenderlich's book called [iOS Games by Tutorials 2nd Edition](http://www.ebay.com/itm/191868581088?ssPageName=STRK:MESELX:IT&amp;_trksid=p3984.m1558.l2649) to learn how to make 2D games. That's a link to my Ebay but nobody seems to be interested in it. If you want it, I'll ship it to you for free. The code is a bit outdated, but if you're familiar with Swift basics, you'll get through it. If you're not familiar with Swift, I suggest you start with Apple's free [Swift Documentation](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309), which is the same one from the iBooks app. This is what I used and read everyday to be familiar with Swift. After reading it, I moved on the the SpriteKit book. I released 1 game so far called [Chomp'd](https://itunes.apple.com/us/app/chompd-how-long-can-you-last/id1023110939?ls=1&amp;mt=8) in December and been busy updating it and working on a 2nd game which deals with physics. 
Thanks. Going to check these out!
I'm the author of https://grokswift.com/book/ (iOS Apps with REST APIs). It'll definitely get a free update for Swift 3.0, once the dust settles on that update. I'm hoping Xcode will do at least half of the code changes for me but updating the text will be a major project. That's partly why I had a reviewer help me get the latest update as Swifty as possible so I wasn't trying to go from really old style stuff to 3.0. There are guard statements on twice as many pages in the new version as the previous one :) I just bought the 3 objc.io books and started reading the Advanced Swift one. It's great but heavy. I think it'll take me a while to work through but improve my code a lot. Reminds me a bit of NSHipster: tough but worth the effort.
i went through the swift guides step by step at https://www.raywenderlich.com/category/swift 
Of course I've seen this, but I'm not able to make use of them so far sadly, I was looking for something more helpful, thanks alot 
Nope, it is not shorthand for that; it will always return `true` if `string` is nil, regardless of whether or not it is empty. To determine whether `string` is either nil or empty, you would use the following: (string == nil || string!.isEmpty) Or, alternatively: string?.isEmpty ?? true
How did you learn it that easily?
That is what is happening when the code runs but I don't understand why, I read it as: if (bool == nil) Rather than: if (string == nil) Is the .isEmpty simply ignored?
holy fuk this is awesome
Ideally, a solution that applies equally to Objective-C (which isn't going anywhere) as it does to Swift (which gets better every year, but is a long way from mature). Edit: What, you downvote me because I don't think Swift is mature? It's not mature. It didn't *exist* ten years ago. By definition it can't be mature. It's still a kickass language with a bright future.
Let me clarify please: * String is non-nil and empty, returns Optional(true) * String is non-nil and non-empty, returns Optional(false) * String is nil, returns nil Correct?
I believe the convention you have inherited is at worst flawed and at best redundant. It is nothing more than a map of Optional(String) -&gt; Optional(Bool) followed by a nil check. If the optional-chain is always paired with a nil check in your codebase and the nil check is always evaluated at the end of the expression, you end up always throwing away the value of isEmpty even if the string is non-nil. The entire expression evaluates to a Bool which only represents whether the string itself is nil or not. 
Cool, thanks for your help. I'll purge the rest of the codebase on Monday :-D
Yeah thanks for sharing. We've got a good start. All this helps so much! 
I bought hacking with swift...its awesome! definitely worth the money. Check out the iTunes U stanford course as well.
The end for loop is to remove the \n from all the elements the out put should give you a nice array with every html element as it's own index. You could then use another for loop with some string.contains() to further parse the elements. I was in the same boat and I didn't want to use a third party library.
I have no idea why valid posts get down voted here without anybody being able to say anything useful against it. I think you can do a lot of those things in other languages like C# by using slightly different mechanism like observers, extension methods and reflection. 
Right? If I've been doing iOS wrong for almost a decade someone should let me know. I do agree there are acceptable workarounds when proper design is done up-front, but they require more consideration - which I'm afraid I haven't seen in other toolkits. The awesome thing about Cocoa is Apple didn't have to anticipate a lot of the ways it's being used.
interesting scraper, keep up with the great work! 
&gt;For some reason it's seems you are certain that those objc runtime features are the only mean to your end. I never said such a thing. All I did was offer perfectly valid uses of dynamic dispatch that have no clear analog or future in a pure Swift ecosystem at the foreseeable moment. I really enjoy both languages. My real concern is that, if this article is representative of the pro-dynamic argument, then it's not a very good argument that enumerates the other benefits we have been reaping. I really don't care about target/action as a paradigm and it's easily replaced with closures. (And before you lecture me about monkey-patching, take a long walk in my shoes. Sometimes you really don't have much choice, and it's nice to have *that* choice.)
Take a couple of quarters of Comp Sci at a local college. Note Comp Sci!! Stay away from organizations that just want to teach you programming, skipping theory and other aspects of computer science. 
&gt; There is no concept of nil in Swift Swift very much has a concept of `nil`, much more than Objective-C in my opinion. Swift forces you to deal with the `nil` case every time, while Objective-C doesn't. &gt; (unlike objective C where you can even send a message to nil) I'd argue that this is also an argument for Swift having more of a concept of `nil` than Objective-C. &gt;which has two associated values, either an object of type &lt;T&gt; or None `None` is just the name of the second enum member, and it doesn't have an associated value. &gt;I was wondering what's the return value for None.isEmpty The whole point of the `?` in `string?.isEmpty` (optional chaining) is that nothing happens in case `string` is `nil`.
Yes, the current system doesn't do the same as what I'm proposing. For example, right now the Swift compiler does not recognize if you've handled all possible exceptions that could be thrown. So you have no guarantee that your app does handle all different cases / possible outcomes. And another reason `throw` is less desirable is that it [hijacks control flow](https://github.com/antitypical/Result#result-vs-throws). And lastly I think the current implementation of `throw`, `try` and `catch` just makes for ugly code. **edit** if you don't see the difference between `throw` and ROP then I recommend you watch that talk I linked to, because that will explain more clearly why ROP is so much better.
Well railway programming is about short-circuiting on errors. The last point about accumulating validation errors even when the first error is encountered is the opposite of short-circuiting. That being said there's a simple and proven solution for that: validation applicative functor. Look up `ValidationNEL` in Scala, or something similar in Haskell. I used a custom implementation of `ValidationNEL` for form validations in my app. And it also helps to know operators like `&lt;^&gt;` `&lt;*&gt;` from Haskell. The operators combined with `ValidationNEL` and `Result` makes elegant code. **edit** I'm dubious about about the suggestion of implicit `Result` type. With `Result` or `Either`, the type of error is explicit. The caller knows what error to expect. With your proposition, the type of error is hidden. 
It is ;-)
I read the article and while the new operator is pretty and his ideas sound new, what he described is already built into the language with the optional chaining operator (?) and exception handling (try). Your beef with the throws keyword is that you can't catch all cases. This was suggested on the mailing list from nearly the beginning and the swift team didn't like the idea because eventually your functions would have to list a huge amount of errors that they propagate at every level. For now it's best to just catch all the errors you are expecting and print out "unknown error" for those you aren't :)
Oh man, that looks incredible. I may have to change my policy about not depending on ui libraries...
I started watching the Stanford videos. The professor is really good. 
&gt;is already built into the language with the optional chaining operator (?) This isn't really true, because you can't use optional chaining with an optional function parameter.
I think Swift is a great language too, but there are a number of problems I have with Swift as a first language. The first one being a lack of really simple ways to read input from stdin - I know there’s `readLine()` and some ways using Foundation, but there’s nothing like Python’s `input()` (perhaps for obvious reasons of type safety) or Java’s `Scanner` class. Unless I’m missing something so obvious, this seems like a big stumbling block to me for recommending Swift as a *first* language, unless it’s being taught exclusively in the context of iOS/OS X programming. There’re also far more concepts that might get in the way of learning the basic logic behind programming, like Swift’s type system, or optionals. Things you can basically ignore or not worry too much about in Python. And, again, while it’s not necessarily a huge bonus in the days of IDEs, teaching the importance of indentation is no bad thing! Basically, Swift is amazing, but could be a bit overwhelming for a first language, especially without a really easy way to take input from stdin to build, I dunno, a calculator application. The sort of thing that could be done in a few minutes in Python to teach the basic concepts.
Not sure about Swift but I learned that try / catch statements are not great for performance in either C# or Java classes and it seemed obvious at the time. You set up the application to not simply crash but monitor a block of code to see if it crashes or not and then handle it instead. Definitely not inner loop material while the Monad approach does not have the same penalty.
They are, if you google on "Swift Monads" there are plenty of people thinking about exact the same thing!
It replaces both checked exceptions and null-for-not-found responses. If you want to get a record from a database you don't want to get null as it might surprise a less-than-stellar programmer that didn't anticipate somebody deleting the row in the mean time and an Exception might be too much for something not so exceptional at all. Returning Maybe would be perfect, you force people to deal with the possibility there might not be a result yet you don't tempt people into constructing those try { ... } catch { /* basically anything because I'm to lazy to check for specific errors, could be database not connecting as well */ } blocks we all swore we would never write yet enter into production because of the fairies did it. Here's a good explanation: http://programmers.stackexchange.com/questions/150837/maybe-monad-vs-exceptions
Both comments are correct, you'll want a regex which stands for regular expression.
You can use a regex, as others have suggested. You can also separate the IP address string by dots and check to see if each part is an integer in the range 0 to 255: func isValidIP(s: String) -&gt; Bool { let parts = s.componentsSeparatedByString(".") let nums = parts.flatMap { Int($0) } return parts.count == 4 &amp;&amp; nums.count == 4 &amp;&amp; nums.filter { $0 &gt;= 0 &amp;&amp; $0 &lt; 256}.count == 4 } (Assuming you're only checking IPv4 strings.) --- You can also do it pretty nicely with a regex, as has been suggested: import UIKit infix operator =~ {} func =~ (left: String, right: String) -&gt; Bool { do { let regex = try NSRegularExpression(pattern: right, options: []) return regex.numberOfMatchesInString(left, options: [], range: NSMakeRange(0, (left as NSString).length)) &gt; 0 } catch { return false } } func isValidIP(s: String) -&gt; Bool { let regex = "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$" return s =~ regex } The problem is that it will match strings like "192.168.256.1", which is _not_ a valid IP address. The regex for checking only valid IPs is actually fairly detailed and non-trivial.
that worked perfectly, thanks!
Make sure you cache the NSRegularExpression object. They're expensive to allocate and parse. So at the top level of your file you could do private let ipAddressRegex = NSRegularExpression(...)
Or better yet use &amp;&amp; !nums.contains { $0 &lt; 0 || $0 &gt; 255 } to avoid allocating an additional array.
This looks awesome, I was just looking for something exactly like this for a new app I was starting.
I have some difficulty reading the code in demo, would love to see a video tutorial instead how its construct.
A much simpler demo can be found in the file `ViewController.swift`. If you open up `Main.storyboard` you can switch the initial view controller to this file. Good idea on the video, though. I might be able to do something like that.
I read that earlier, some functiona name are confuse without the comments of what each do. Appreciate to see the comments.
Oh ok thank you! I didn't know! What's your favorite up-coming feature?
Just going to throw this out there, if I was trying to achieve this I would be using a custom view controller transition.
Only problem with this is that I'd need a navigation controller for every view controller, which I'm not fond of.
Is that the case even when using UIViewControllerAnimatedTransitioning, such as is demonstrated in the accepted answer here: http://stackoverflow.com/questions/26569488/navigation-controller-custom-transition-animation? In the past, I have been able to do custom transitions with a single navigation controller using the above technique. However, if you have determined that it doesn't work in your situation, perhaps it would be possible to make a container view controller and put your navigation controller inside that, and the container would do the blurred background. This requires the navigation controller being clear so the container shows through, which I have never tried.
Reducing segfaults whilst using protocols extensions and other voodoo magic up to 90%.
If you use Swift like plain C (no class types, no generics and UnsafePointer to tuples instead of using an Array) you'll get zero heap allocations (and the code will be nearly identical to C code compiled with Clang). It's not a lot of *fun* but if you're trying to squeeze maximum performance out, that'll do it.
You can read the repo and see those without enough Swift experience will understand without comments?
Nice! Good explanation as too what is going on in that make file. 
just bought proswift
Swift classes are pass by reference. Is LLVM smart enough to allocate them on the stack when the objects don't persist?
You're right: &gt; Error handling in Swift resembles exception handling in other languages, with the use of the try, catch and throw keywords. Unlike exception handling in many languages—including Objective-C—error handling in Swift does not involve unwinding the call stack, a process that can be computationally expensive. As such, the performance characteristics of a throw statement are comparable to those of a return statement. From: https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html It's still kind of wieldy to set up and requires all of your code to work with try catch throws. But yes they theoretically achieve the same. But I think @live_love_laugh is still right that it has some drawbacks apart from the fact that it leads to ugly code.
The solution is just do it: make stubs and organize them properly.
yea it seems really useful, i will try to keep it in mind for the future
That's exactly my fear: that the new way is based on "hope", while the old way is based on 30 years of success with building actual systems that work. When's the last time I had a type error with Objective-C? I can't recall. That's just not an issue I have. Trying to fix "bug-prone" code by making it more "explicit" is like trying to improve the Middle East peace process by making somebody sentence-diagram the Bible. It's hilariously wrong because -- as with every Objective-C application I've ever written -- lack of strong type information is so far down the list of problems it might as well not exist. Maybe once I'm good enough with Swift, it'll seem better. I'm no Wil Shipley, though. In my first 5000 lines of Swift code, I've had far more trouble with `!` and `?` than I ever did with type errors and `nil` before, in hundreds of thousands of lines of Objective-C. (Don't get me started on PATs.) So far, when porting my old Cocoa application to Swift, I'm spending a lot of time figuring out the right incantation to placate the compiler, but I'm not seeing any fewer bugs because of it. 
[Have a github link](https://github.com/alexdrone/Render).
Swift is much more what-you-see-is-what-you-get than older languages like C. 1&gt; var x = 2 2&gt; var y = x++ 3&gt; print(x,y) 3,2 This is non-WYSIWYG. It's old fashion compiler voodoo. Apple doesn't want this behavior in Swift. 
I wouldn't really call this "compiler voodoo", it exactly follows the implementation of `++`. That said, I also like that they're doing away with it.
Yea it was an exaggeration, but I meant it wasn't the logically obvious result. If you ask somebody what they thought x++ was they'd probably guess that it incremented x. Which it kinda does but also kinda doesn't depending on how you use it. 
I don't understand what you mean. If you don't have "enough Swift experience" you won't even understand what part of the code is comments and what is code!
Thank you. That site's format looked a lot like Reddit's so I was wondering if I clicked the wrong link.
There's also reswift https://github.com/ReSwift/ReSwift
The thing is, the regex for checking if a string is a valid IP address is a bit complicated: ^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$ In this case, it may be more straightforward to use some other method.
https://github.com/iwasrobbed/Swift-CheatSheet
Swift 3 does heap-to-stack promotion based on escape analysis. It helps, but it's difficult to rely on without carefully profiling to make sure it kicked in where you needed it.
One easy thing to do is let all your objects collect their own touches and translate those into high-level event messages you dispatch. You can turn those off and on with userInteractionEnabled, if you need some to be dormant for some state. Then, let your SKScene manage a state object that handles this high-level input. An easy way to do that would be to just have it keep a reference to "the current state" as a separate state object and have a protocol set up for switching states that lets the states register event listeners with NSNotificationCenter when they become active and shut them down when they become inactive. With this setup, you can easily change behavior based on state. However, one nice trick I have found is to either make your states SKNodes or create them. This gives your states the ability to cleanly present their own UI, which can be really handy in some situations. You can even design these states using the built-in scene editor and call them in using an SKReferenceNode. Since you can give nodes created in the editor a custom class, you can directly edit your states' presentation and just drop them into the scene as needed to display the UI elements you want.
It's sounds like using NSNotifications would be a good option.
Unfortunately I'm not really able to read Objective-C so this wasn't of much help. However, one of the related posts helped out! I ended up using CATransition. I wasn't able to achieve a perfect result yet, but I've made progress. Take a look [here](https://gfycat.com/SingleFittingDaddylonglegs). The code I used was: let transition = CATransition() transition.duration = 0.3 transition.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionDefault) transition.type = kCATransitionPush transition.subtype = kCATransitionFromRight self.navigationController!.view.layer.addAnimation(transition, forKey: nil) I'm still trying to perfect it, so any ideas on how to improve the animation would help greatly. Also, I did try to apply the blur effect to the navigation controller, but the blur overlay would not show up regardless of what I did. I'm still open to other ideas as a whole as this feels really gimmicky and hacky.
Then that explains it. Unfortunately when everything is clearColor, that means you see what's behind the top view controller, so for a half second the artifact you see is the other view controller's view before it is removed from the window. You're going to have to set an opaque backgroundColor for your view, unfortunately.
Im just now learning swift, so I don't exactly know the syntax. That said, it sounds that you want to use an if not statement. It should look something like: if !(displayDigits.text!.rangeOfString(".") != nil &amp;&amp; digit == "."){ displayDigits.text = displayDigits.text! + digit } Notice the "!" at the beginning of the if statement. Hope it helps! EDIT: parenthesis. 
I see. Thanks for explaining
&gt; For example, if two variable have the same underlying data then it automatically reference the same instance This isn't necessarily true. This is only the case for value types that explicitly make it so. The distinction between value type and reference types should probably be clarified. Values aren't "objects" in the same sense as references. A value represents its contents, while a reference represents a pointer to its contents. Which means that when you assign one value from another, those two become distinct instances, with disjoint contents. A reference, however, does the opposite. When you assign a reference from another, they become the same instance, and manipulating one manipulates the other. This is why references need ARC. It doesn't know when to deallocate until all the references are gone. But values don't have that problem. Since they're disjoint, the compiler knows they can be "deallocated" once they go out of scope. Now, in reality, they're not really "deallocated" in the same sense. They exist on the stack, which means that they don't use allocation / release calls to manage their memory; they're just placed on the already available stack for free, and then forgotten about when they go out of scope. Back to the point, the only reason two arrays can reference the same underlying instance is because arrays are specifically coded to do this. In reality, a Swift array is a value type whose contents is just a reference type representing the array contents; so in a way, arrays are actually reference types. Arrays *behave* similar to values because having two array values with the same underlying reference causes that reference to have a ref count of 2. When you attempt to write to an array, the `subscript` code for the array value checks if the ref count for the reference is greater than 1. If it is, then its a shared reference, and shouldn't be mutated; so it creates a new reference for the contents and copies the old contents into it, *then* performs your write operation. This is an implementation detail of arrays. They *behave* like value types, and on the surface, they *are* value types. But underneath it all, they're references, because they are built to do that. You don't get this feature for free with arbitrary value types. You can duplicate it pretty easily in your value type, but you do have to do it explicitly.
It's a link to buy his book. Which is separate from the site. 
Okay that makes sense. Good explanation!
The stanford course does that. 
Read up on UITextFieldDelegate and see how you can use it to detect changes in the textField. To detect those specific characters, you can use method "hasSuffix" or other String comparison methodologies on the textField's text property to see if the last character in the textField is '@' or '#'. However, if you believe the user may type those characters at any location within the textField, UITextFieldDelegate also has a method shouldChangeTextInRange which will be of use to you. Good luck!
Twostraws' site is pretty great. He does a great job of breaking down the why and the what of swift. Seriously big shoutout to you @twostraws, your site is great. However if you have no programming experience at all, I recommend YouTube to get a grasp on the very very basics of classes, functions, variables, etc....
The swift iBook is actually pretty great for basics as well. Helped me a lot.
Thanks, that was helpful, I'll look into game engines.
You can buy my books if you want to support the site, but all 40 Hacking with Swift chapters are online to read for free. 
Awesome – good luck :)
Depending on what you consider to be a 'complete noob', if you have some programming experience but are looking for something interesting on Swift, try the Stanford iTunes U course on iOS programming in swift by Paul Hegarty. https://itun.es/nl/51O1bb
Is there a reason you have your properties as implicitly unwrapped optionals? Nice work by the way. 
Yes, and how to try things out, without messing up everything?
Use playgrounds
Do you really think you'll be in better position to learn Swift 3 knowing nothing, than knowing Swift 2.2? If that were true, then if a company were using Swift 2 and wanted to upgrade to Swift 3, their most productive path forward would be to fire everybody and hire a new team that had never used Swift.
It is a fair point. I was told there were so many changes in 3 that I would have to learn almost 1/2 of it all over again. But as am digging further, it seems that the changes are not quite as invasive. So, I will move forward with 2.2. Are there any courses that would be good prior to 2.2? I am thinking in terms of CS 101, but that is particularly relevant to iOS development. 
This is how I work. Idea -&gt; Research for APIs -&gt; Research for Designs -&gt; Design mockup -&gt; Make project with version control (I use Git with Github or Bitbucket) -&gt; Model data/Connect API -&gt; Make UI -&gt; Connect UI to data. Test things as you produce them. As someone pointed out in earlier posts I also test code in playground for a quick test. Make sure that you have the data before you design, because you will end up having to redesign unnecessarily. 
You can just use contentsOfURL as you are suggesting, however that is not necessarily considered best practice. Using an NSURLSession is the recommended method these days. It looks like they're downloading and then writing to disk, this benefits the, by storing it locally so that presumably next time you need to display the image it doesn't have to be downloaded again. If you have some sort of an image provider in between that first checks local storage for the image and if not found then handles the download, then you can create a sort of local image cache. When using NSURLSession instead of just contentsOfURL you get all the optimization provided by the sdk around downloading content, including the ability to easily continue in the background if the app is back grounded. 
I downloading it to local storage bad?
No, not all, it's more about how you download it. When you download to local storage it uses disk space, but that is to be expected with any app. By doing so, you save having to download the same image again. 
I'll take a look at the docs. Thanks!
www.hackingwithswift.com Some very good tutorials there. 
That is just your launch screen. It's a static storyboard or image you provide to show while the app is loading. Just look in your file inspector for a file named LaunchScreen.storyboard and set it there.
http://stackoverflow.com/questions/33862098/swift-dictionary-with-weak-reference-keys
I don't have suggestions for a general CS101, but I'm currently finishing up a new book and video course on meta-skills you might find useful – how to use the Unix command line, how to build regular expressions, how to make the most of Git version control, etc. [More information here](https://gum.co/beyondcode).
Why not use storyboard references? Use segue identifiers to distinguish between different scenarios. Then you can use a switch or if statements to handle the various responses. 
The mobile site doesn't look very good tbh, but the app and the desktop site look a lot better. 
You can use it with navigationController?.navigationBar.hideBottomHairline() because `navigationController?.navigationBar` is your reference to the navigation bar, and that's what you send the message to.
Look at WWDC 2015 session 411: "Swift in Practice" at the 26:50 minute mark. Describes how to use enums, protocols, and protocol extension for segue identifiers. Very clean approach. https://developer.apple.com/videos/play/wwdc2015/411/
An extension is just adding your own functionality, or extending the current class, etc. to do what you want it to do. For example, suppose I have the following code to position my score label in the rectangular view called playableArea. This will position it to the top right. score.position = CGPoint(x: playableArea.maxX - score.size.width, y: playableArea.maxY - score.size.height) Well, the width and height is of type CGFloat, and let's say I'm tired of having to write size.width/size.height everytime. I just create an extension on CGFloat like this: extension CGFloat { var w: CGFloat { return self.size.width } var h: CGFloat { return self.size.height } } Now, I have extended CGFloat to also have a "w" and "h" property. score.position = CGPoint(x: playableArea.maxX - score.w, y: playableArea.maxY - score.h) Using extensions is the same as just calling a method of a class with dot notation, etc.
Ha! It's literally the same as his! Good luck!
It's still incorrect...
You can always break up that line into multiple lines :) Or you could first compute `x` and `y` before passing them into `CGPoint(x:y:)`.
Swift has a type called optional and it is defined as enum Optional&lt;T&gt; { case Some(T) case None } If you declare var thing: Int? = 5 It is actually shorthand for var thing: Optional&lt;Int&gt; = Optional.Some(5) This code: if let temp = thing { //do stuff } Is the same as this code: var temp: Int if thing != Optional.None { temp = thing! //do stuff } So if let is just an if statement that will automatically take the .Some value out of the optional for you.
How so? 
An Optional either has a value of some type you specify, or no value at all (`nil`). You should first check if an Optional variable actually has a value before you use it. You can compare the variable to `nil` and then use an exclamation point after the name of the variable to access the actual value of the optional. If you try to access the value of an optional that is equal to nil, your app will crash. You can also use `if let` to check if an Optional variable actually has a value, and if so, do something with it. If the value isn't nil, the constant you define in the if let statement is given to you as an actual value, and not an optional, so you don't have to use an exclamation point to get to its value. Example: var name: String? if name == nil { name = "Josh" } print(name) // prints 'Optional("Josh")' print(name!) // prints 'Josh' if let personsName = name { print(personsName) // prints 'Josh' // You can only use personsName in the body of this if statement } name = nil print(name!) // Makes the app crash - 'Unexpectedly found nil while unwrapping an Optional value'
Haha brilliant. Thanks!
I was hoping that this would be another one of those [is-it-christmas](https://isitchristmas.com) sites where it's just a big fat NO. The changes that Swift 3 is bringing are so massive that literally every codebase will be affected one way or another. This article should have been named "Just how fucked is your Swift 2.2 codebase? You can find out today!"
And that's what I'm doing for at least a couple of hours tomorrow.
I honestly hate breaking up a function call into multiple lines. Haha I didn't compute them because they would only be used once and that's it. 
It's simple if you only want to develope mac/ios programms you should learn swift. The changes in 3.0 aren't that big. If you want to develop cross platform applications you should learn about any other language.
Yeah, when you add the toolchain and see 130 errors on just one of 6 view controllers, your know you're in for a bad day. CGRectMake is unavailable, thats been my big one I've see so far that I need to study a bit more up on. Some issues with my in-app purchase code as it doesn't like NSSet for my product Ids, but that shouldn't be too hard to work around. AppDelegate needs redone too, thats broken my Google Analytics pod. I mean, nothing terrible, but it's going to be about a week of frustrations to get back to where I was. Thank goodness I just released a version (medical reference app) and don't have anything planned in the short term that needs to go out. 
"Learn Swift the smart way" Hah, I like that subtle (or not subtle?) jab at Zedd's annoying books. 
&gt; Just use the initializer of CGRect. CGRect(x: 0, y: 0, width: 44, height: 44)
I see others commenting to just use the initializer, but to add to that it is probably a good idea to do that across the board, switch from any Make Method to the swifty initializers. 
thanks for the tutorials will definitely go thru them this weekend. does anyone know how CocoaPods and the upcoming swift package manager will play together? By that I mean will the package manager make CocoaPods obsolete or will CocoaPods evolve to somehow use the PM behind the scenes or are they already pretty much the same thing? Just trying to understand the whole eco-system a bit better, thanks!
Yeah, it's just the time component to some of these I'm not looking forward to. At least some of them will self-correct when selected. 
Good point. I'll have that in mind.
It's a package manager for Xcode iOS dev in Obj-C or Swift. Easy peasy tool for installing third party libraries and sources to projects from provided specs by CocoaPods or authors or any source from GitHub
I code on a late 2013 MBP and Xcode runs pretty ok. The only downside I've noticed is that when opening a complicated storyboard for the first time in your current project session it stalls for about 5-10 secs. Not really a big deal imo. 
I think the swifty JSON github page has plenty of examples for you to look at 
 json["current_observation", "display_location", "state_name"].string is one of the ways to do it
The issue is that the `array` you are referring to is immutable, as the error says. This constant is coming from `shuffleArray&lt;T&gt;(array: Array&lt;T&gt;)...` which isn't a `var` (aka mutable). You really want something like the answer in [this stackoverflow response](http://stackoverflow.com/a/24029847), and the part you want is: extension CollectionType { /// Return a copy of `self` with its elements shuffled func shuffle() -&gt; [Generator.Element] { var list = Array(self) list.shuffleInPlace() return list } } extension MutableCollectionType where Index == Int { /// Shuffle the elements of `self` in-place. mutating func shuffleInPlace() { // empty and single-element collections don't shuffle if count &lt; 2 { return } for i in 0..&lt;count - 1 { let j = Int(arc4random_uniform(UInt32(count - i))) + i guard i != j else { continue } swap(&amp;self[i], &amp;self[j]) } } } The `shuffle` function returns a new collection whereas the `shuffleInPlace` shuffles an existing variable.
You might want make a copy of your array as var like var copiedArray = array, and pass it to swap function 
Thanks! So I am assuming you could use this with an array of strings. NameArray = ["Sally", "Suzie", "John", "Tom", "David", "Amber"] would I just do NameArray.shuffleInPlace The end goal is really to take sections of the arrays and put them into separate arrays from the shuffled list, so making sure that the values are unique is important.
Yup. Just make sure to declare it as `var NameArray = ...` and then you should be able to call `NameArray.shuffleInPlace()`. I don't quite understand what you mean by "take sections of the array and put them into separate arrays... Can you walk through an example?
Have you seen [Zewo/Reflection](https://github.com/zewo/reflection)? It seems to do similar things but with 0 boilerplate (no code gen going on) since it reverse-engineers the memory layout for structs and classes.
1. It is a model, but not a car's model. A model is based on real-life objects (in your example a car). It's not car data structure's business how the data is saved and loaded. Hence a class saving and loading a car is a responsibility of another class (SRP from SOLID) 2. You should use a repository pattern for storing a collection of objects. This class may want to, for example, paginate the results. So it's a third class in total (Car, CarLoaderSaver, CarRepository). Now that I think of it - `CarLoaderSaver` should be split into `CarSaver` and `CarLoader` and they might be only protocols because you may want to save and load cars from different destinations (e.g. save to disk, load from network, vice-versa or both the same); 3. I think view hierarchy and screen transitions do not belong in the VM. It's one thing to tell what color text should be and completely another to tell where the label for your car's plate number should be. 4. It is wrong. Apple's documentation states that every view controller must receive their data before they are presented. This means that you have two places to pass the data: - In case of storyboards do that in `prepareForSegue:` - In case of xib's or code-only initialisation do that when initializing VC or right after that; The MVVM pattern was developed by Microsoft. So you should be lucky finding something in msdn portal/blogs. You can start here: [The MVVM Pattern](https://msdn.microsoft.com/en-us/library/hh848246.aspx).
Yes, I've seen [Zewo/Reflection](https://github.com/Zewo/Reflection), however it has some limitations: * It can't call methods by name * AFAIK It's not using property accessors so didSet/willSet will not be called
Thank you so much. I took 1 Visual Basic class in college.....lol. I'm just praying I get over the hump and don't quit.
Alright thanks for that, My computer is a 2013 vintage and my project sounds bigger, so that at least puts a bit more perspective on it 
It's so that you can encapsulate functionality someplace else. It also gives you clear protocols for getting stuff done 
Yeah, it doesn't use dynamic dispatch so that's a little bit difficult (though methods might be possible). We encourage the models to be as dumb as possible, so there isn't usually a reason to call a method by string.
Modularity. You can have a type hierarchy of delegates separate from the type hierarchy of the things delegating. It's always a good idea in code to decouple functionality whenever possible.
Eh man thanks, that sounds good. I got it working but when I use string nothing prints out, I have to use the .description field. Do you have any idea whY? 
This is a great answer. I'd like to just expand a bit on the ViewModel portion because I think this is where the most confusion lies. Here's a quick example to help illustrate that /u/zintjr mentions, consider this super trivial example: Here's our model: struct Task { let name: String let dueAt: NSDate let order: Int let description: String? let category: String? let deleted: Bool let id: String } and here is the actual data that one instance of this model might have: { "name": "Send timeline to client", "dueAt": "2016-03-08T18:20:28.770Z", "order": 110, "description": "", "category": "Logistics", "deleted": false, "id": "093Y3ehvXX" } And we'll make a view model like this one: struct TaskViewModel { private let task: Task? private let taskService: SomePersistenceService init(service: SomePersistenceService) { self.service = service } var dueDateForDisplay: String { guard let task = self.task else { return "" } let formatter = NSDateFormatter() formatter.dateStyle = NSDateFormatterStyle.LongStyle formatter.timeStyle = .MediumStyle formatter.timeZone = NSTimeZone.localTimeZone() return formatter.stringFromDate(task.dueAt) } ... (more exposed properties would be here...) var isPastDuel: Bool { guard let task = self.task else { return false } return (task.dueAt.compare(NSDate()) == NSComparisonResult.OrderedAscending) } func getData() { self.task = self.service.getTasks() } func deleteTask() { guard let task = self.task else { return } task.deleted = true self.service.updateTask(task) } func updateCategory(category: String) { guard let task = self.task else { return } task.category = category self.service.updateTask(task) } } There are 3 key things that I consider to be the "responsibilities" of the view model (oh snap, burn the heretic for no SRP! :[ ) 1) **The ViewModel contains all of the logic around how model data should be exposed to the end user.** We don't expose the models directly to views, let's take a look at why that is. Notice that our "dueAt" data is stored in that nasty UTC format. Someone is going to have to know how to translate that to a user friendly format. The model should not own that responsibility. Here, that responsibility will fall to the view model and that's why we have the "dueDateForDisplay" property. Whatever view is using this view model should reference that prioerty for display. Let's also say that we want to have the underlying view make the due date text red when it's in the past. The view model doesn't really need to know that we want it red, but it should try to help simplify the reasoning about what "past due" means. In our case, we'll expose the "isPastDue" property and the view can simply look towards that for logic. 2) **The ViewModel contains the logic on how it loads it's own data.** Notice that we inject the "SomePersistenceService" here, the ViewModel doesn't know HOW the model info is stored, but it does know that it needs to call that service to get it's underlying model data. You can see that in the "getData()" method. 3) **The ViewModel contains all of the business logic about how the models operate.** Another way of thinking about it is the ViewModel is a micro-API for interacting with a model. In my case, if you look at the model struct, you can imagine the things you might want to do to a model -- the most easy to grasp is the "deleted" property. Obviously, we can mark a task as deleted. Our ViewModel will be the place where we expose that method. We could easily add that onto the model directly, but consider a case where there may be user permissions involved and not everyone can delete tasks, etc -- that logic could get hairy and we do not want to muddy up our model with that. 
You should start with MVC. It's Apple's recommended approach and you will find the most documentation on that. Once you have mastered that, then you can explore other design patterns.
There's a known bug in the Swift compiler relating to type inference that should be fixed in the next release. This may be contributing to your slow compile times. You can determine where the compiler is slowing down using the information in [this article](https://thatthinginswift.com/debug-long-compile-times-swift/). If you're using IBInspectable, then make sure you are aware of the view dependencies. Remember that in order for IBInspectable to work, it has to compile the view class (and therefore everything it depends upon). So if, for example, your views depend on your models, and your models on other things, then you'll end up recompiling an awful lot very often. It's usually a better approach to have your views dumber with fewer dependencies. Check your scheme. This tells Xcode what to build when you perform an action like Run or Archive. Sometimes I've seen projects get misconfigured and compile multiple targets unnecessarily. Don't put too much in your precompiled header (if you have one). Every time something you import there changes, every other file needs to be recompiled. 
That's odd. Can you try this and see what gets printed? let stateName = json["current_observation"]["display_location"]["state_name"] print(stateName) print(stateName.string) ETA: Try this too: print(stateName.stringValue)
Thanks for help. I'll give it a try!
The easiest thing is to think like a building architect. Is there one physical architectural style that fits all buildings? No way! If I'm building a Burger King restaurant, I'm not going to try and outdo Frank Lloyd Wright. Likewise, if I'm building a simple calculator app, bringing VIPER into the mix is beyond overkill. An architecture is a tool like any other. You'll need more than one of them in your toolbox and you need to understand when the situation calls for a hammer and when you really need a wrench. 
Here you go, this what the company required for an interview:Try it out its a really practical exercise in stuff you will really do if you are looking for a job in app development. Code Exercise : RSS Feed Reader Write a news app based on the Google News RSS feed (http://news.google.com/?output=rss). The app should launch into a table view with: • An image (or place holder image) related to the story. • The title of the story • A short description from the story (first few words, abstract, etc) Clicking a row should take you to a second view that: • Have one image related to the story. • The title of the story • The story Additional Requirements: • TDD is very important. Show us you know how to test your code. • We want to see what YOU can do but feel free to use any pods or frameworks needed. o Please include a README with any steps needed to start, and test your app.  You can assume we have: • XCode • Ruby • Bundler • CocoaPods • Git  If there are any other required tools or please specify or include a bundle or pod file. • The app should cache data for offline use. • The app should be attractive if initially started in offline mode. 
I think you''re overestimating my post. I said something based on what I've learned. I don't know how to use that RSS link. I don't know how to fetch the data. I don't know how to save it for offline use. I meant a simple app idea using what I already know from the bullet points above. I guess I could give this a try maybe a few weeks later.
That works with stringValue, the way you wrote it is different from mine: json["current_observation", "display_location", "state_name"] instead of what u did, do u know what the difference is? The way you did the syntax I can use stringValue but the way I did it, I have to description. Also, I'm using AlamorFire for the HTTP request: I'm not fully understanding the syntax: Alamofire.request(.GET, baseURL).responseJSON { (response) -&gt; Void in if let value = response.result.value { let json = JSON(value) } } Do u know what type of syntax it is?, this part: Alamofire.request(.GET, baseURL) is calling a function and returning a request type, but I don't know what the rest is doing. Thanks for the help! 
Yes, you can install Swift 3 today and start testing with it, but as far as I know you can't ship apps to Apple built with it. Right now, the current Swift 3 build is also incompatible with playgrounds. 
 &lt;^&gt; j &lt;| "id" &lt;*&gt; j &lt;| "commentText" &lt;*&gt; j &lt;| "username" Why does everything have to involve an inscrutable pile of custom operators these days?
Yeah, I'm a high school student who is in the car a lot, I think I will sell my old MacBook and buy a newer one.
Just wanting to know, do you have any guides or the Apple Swift book open while you code?
I can enter my passcode from my bluetooth keyboard on my ipad so I'm guessing it's possible. Also when my ipad is asleep it still responds to keyboard commands (mainly me accidentally hitting play and embarrassingly playing music in a quiet workspace. 
It's not a shortcoming of the language to allow for features that may make sense here and there. It's a problem when people abuse them, as you said yourself. I like this take on the topic: https://m.signalvnoise.com/provide-sharp-knives-cc0a22bf7934#.cqc7beohj 
With those definitions how is a viewModel different from a view controller?
[removed]
To the second question: yes, it says on the snapshot download pages that, if you want to submit to the App Store, the Swift code must be built using the version of Swift that comes with Xcode.
You would not be able to turn on a powered-off device from a custom-built Bluetooth device, mainly due to security restrictions on the operating system. Unless you jailbreak your phone and do some serious OS manipulation wizardry you're shit out of luck unfortunately 
At least they're consistent. It's the same as in their JSON (de)serialization library, Argo (which is heavily inspired by the Haskell JSON library Aeson).
Here is the only tip that matters. Write code. The more code you write the better you will be. It doesn't even really matter what you write. Make an app that when you click a button it just displays a random number. Honestly. Just write as much code as you can. 
Why doesn't it? If `B` provides all the methods needed to implement `A` in all cases, why shouldn't it be possible to say "all `B` types are `A` types"?
It's possible in Haskell: class A a where -- class is the term for Haskell's version of protocols. -- `a` is the type implementing `A` ... class B a where ... instance A a =&gt; B a where -- All `A`s implement `B` ... But this is generally discouraged. If a type implements `B`, we generally want that type to be able to define its own `A` instance, in case they have a better implementation. Also, there's some module importing problems called "orphan instances", but that's more Haskell specific. The solution is that whenever it's provable that all `A`s are `B`s, we just say that `A` is a subclass of `B`, allowing the implementing type to implement all levels of the hierarchy, while guaranteeing that whenever you have an `A`, you automatically know it's a `B`. In swift, you can do this with protocols just fine. protocol B { func get1() -&gt; String } protocol A: B { func get2() -&gt; String } extension A { func get1() -&gt; String { return get2() } } struct S: A { func get2() -&gt; String { return "2" } } let x = S().get1() // x = "2"
Maybe he thought OP meant that the extension made a protocol conform to another protocol without actually implementing the required functions. At least that's how I understood it at first, and I was very confused why OP thought that would be possible. But yeah, I agree that it actually makes a lot of sense.
No. The generic system would not have any non-trival changes in 3.0. All new generic features are pushed into future minor/major releases, with the priority in those necessary for ABI stability. You can search for the generic manifesto to see what may be implemented in the future. But I am pretty sure conforming a protocol to another protocol is not on the list. It doesn’t seem logical to me either. A protocol defines a set of requirements, and extensions to a protocol can only provide default implementations. That means trying to conform a protocol to another would never succeed, since the protocol can never contain the extra requurements.
That's what inheritance is for. 
I don't really understand why it (supposedly) would make sense to throw in `maxElement` but not in `sort`. I've never thrown an error in either, but both `isOrderedBefore` parameters have type `(Element, Element) -&gt; Bool`, so closures of that type could be used in either. &gt;In the case of sort you want to reorder the sequence. You'd expect the same elements contained in the resulting sequence =&gt; the predicate should not fail. Can you clarify on this? I don't think you can just assume that nobody will ever want to throw an error inside `sort(_:)`. Besides, marking `isOrderedBefore` with `throws` (and `sorted` with `rethrows`) only adds functionality.
Swift is here to stay. I can easily see it replacing scripting languages such as Ruby/Python. Pretty exciting times. 
Hi frowat! Unfortunately, the link to the App Store you submitted has been automatically removed from /r/Swift. This is because – generally speaking – compiled products are not relevant to /r/Swift (even if the app was originally written in Swift). If this is an app you have written, congrats on your acceptance to the App Store! A great way to promote it would be [Reddit advertising](https://www.reddit.com/advertising). If you would like to release its Swift source code, we would gladly accept a link to that. If the content you were submitting *was* in fact related to the subject of Swift programming, please [message the moderation team](https://www.reddit.com/message/compose?to=%2Fr%2Fswift&amp;subject=Please%20review%20my%20removed%20App%20Store%20submission&amp;message=https://www.reddit.com/r/swift/comments/4mijry/ive_been_learning_swift_since_january_with_little/) to have it reviewed. Regards, The /r/Swift Moderation Team *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/swift) if you have any questions or concerns.*
A view controller is concerned with controlling the view, the view model holds only data, so the controller can ask for what it needs. A view controller wouldn't hold a var for the cars make, it would hold a var for the cars view model and ask for carViewModel.make when it needed it. 
I started off by using the tutorials over on raywenderlich.com. If you already know the basics of Java and object oriented coding, Swift itself is pretty easy to pick up. For me, the biggest challenge of learning iOS development was learning how to properly use XCode and storyboards, and raywenderlich does a fantastic job of getting you on the right track with that. Good luck!
Late to the party, but I think generic typealiases are pretty neat (https://github.com/apple/swift-evolution/blob/master/proposals/0048-generic-typealias.md). Feature-wise, Swift 3.0 is pretty underwhelming. Most of the awesome generics stuff got pushed back because of lack of time. The real draw will be finally getting official releases of the Swift Package Manager, Swift Foundation, and libdispatch (think GCD for Swift on Linux). 
a bit off topic but I would like to ask you if you can point me a tutorial to publish a github project to cocoapods.org. I could not find anything explaining that. My point is this: I have a project on github that is a fork from another guy's project. That project is seen on cocoapods.org. How do I make this project I have forked appear on cocoapods and be installable by that? Thanks.
Nice! Thanks for confirming it.
It would be nice if you'd use more protocols of the default library, such as `SequenceType`, `CollectionType`, `CustomStringConvertible`, etc.
No, I'm afraid not: OS X is quite a bit harder to work with than iOS. Unless – fingers crossed! – Apple releases UXKit at WWDC, I recommend people start with iOS first then transition to OS X only when they are feeling confident.
Thanks, you raise some good points also. I've had a similar situation with the user permission business rules that you mention in #3. I chose to let those functions that have the user permission business rules reside in the Data Service. I concluded that those DS functions will be used by multiple view models and those rules needed to be exercised regardless of which view model was calling them. So letting them reside in the DS class made the most sense to me at the time. Also the formatting function mentioned in #1 is a great example. I let functions such as this reside in my models instead of the view model since the formatted date has to be displayed across multiple view models and I didn't want to duplicate the code across view models. 
Awesome job! 
&gt;If ViewModel needs to use data service to get data, how do you update the view when the data is downloaded? I used simple delegate notification, for example my view controller implements a protocol like this (btw I use the "I" prefix to indicate a protocol/interface; 16 years in C# so this naming standard works for me; it's also why I use object_Event to name my event handler functions; again another .Net standard; I know I know but again it works for me as I can quickly identify this function as an event handler; use whatever standards work best for you). protocol ILoginEvents { func loginViewModel_LoginCallFinished(successful : Bool, errMsg : String) } class LoginViewModel : ILoginVM { var delegate : ILoginEvents? func loginUser(username : String, password : String) { Services.LoginService.loginUser(username, password) { [weak self] (error) in if let this = self { Helpers.Threads.RunOnMainThread { let errMsg = (error != nil) ? error.description : "" this.delegate?.loginViewModel_LoginCallFinished(error == nil, errMsg) } } } } } class LoginViewController : UIViewController, ILoginEvents { private let _viewModel : ILoginVM func viewDidLoad() { _viewModel = Core.retrieveViewModel(Views.Login) _viewModel.delegate = self } func loginViewModel_LoginCallFinished(successful : Bool, errMsg : String) { if successful { //segue to another view controller here } else { MsgBox(errMsg) } } } &gt; Do you have to use KVO or ReactiveCocoa/RxSwift? I've never used ReactiveCocoa/RxSwift as I simply have not had time to play around with it. I keep hearing nothing but awesome things about it though. Delegate notification was all I needed at the time but you definitely can't go wrong by learning these technologies. 
Awesome job. Bookmarked. looking forward to using some of these libraries.
Thanks so much for all your suggestions! How long do you guys think it will take me to be able to publish an app (rough estimate) with any of the three recommendations? Side Note: my 'highly proficient in JAVA" is an APCS level proficiency HAHA
Should add a link to it for the lazy! haha
Add the link in the description. 
No.
If you rework this in Swift, you'd be like the most amazing person ever! I don't know much about Codea, but because I'm still in the research phase, I can learn :). Thanks so much for the response. 
Awesome looking app! I'm going to give it a try now. I currently use an app called TVShow Time, so I'd like to see how you're compares. Also, how long was the approval process for you? I've been hearing that it's down to a few days now.
With a little research you may find the answer in Swift faster than I get around to this, but I promise that I'll post my results once I do get around to it. Sorry, this is probably the least helpful "help" I could have offered. I'm sure the answer is out there though too!
Alright. Let me know when you do! :D 
Here's the link to the App: https://itunes.apple.com/us/app/binged/id1120570590?ls=1&amp;mt=8 Thanks! My very first Swift iOS App, it was quite a lot of fun. Show info is actually free from TVMaze and TheMovieDB, they provide a JSON API.
The description of the DemoBots mentions "on-screen thumbstick", so perhaps there's something here you can use? https://developer.apple.com/library/ios/samplecode/DemoBots/Listings/README_md.html#//apple_ref/doc/uid/TP40015179-README_md-DontLinkElementID_96 Good luck
All those `import UIKit` make a bad first impression.
Check [http://appreviewtimes.com/](http://appreviewtimes.com/). Currently very fast cause approching the WWDC. Usually, about a week (check [annual graph](http://appreviewtimes.com/ios/annual-trend-graph)).
There was a recent article about policy change with Schiller taking over. It went from a week down to about 2 days. http://9to5mac.com/2016/05/12/app-store-review-times-improvement/
Check out the official documentation on https://guides.cocoapods.org/making/making-a-cocoapod.html. That's the resource I was using to publish the pod.
Looks cool! I just went through a similar process learning Swift by building an OS X app. Prior to that my experience has been mainly web and JavaScript. Can I ask what your motivations were for the project, I noticed no in-app purchases. Do you want to use it as a showcase to get paid work or happy just for the learning experience?
It was just a way for me to build an app, learn Swift. I was enjoying the development process, learning something brand new and seeing an app slowly come together. I love Swift, excited for what's upcoming in WWDC2016!
Getting the data into an array doesn't have anything to do with table views, though. Also, it's hard to help you if we don't know what you have tried and what goes wrong. The approach I usually take is to make a custom struct/class with a failable initialiser that only takes a snapshot. Then query your firebase reference and loop through the snapshots, put them in the initialiser one by one and add the results to an array.
Nice one. I would love morr if this has a trakt . tv integration. Cheers!!
looking to add trakt!
I think that this is an oversight, I don't see any reason why this is the case either. Pretty much all of the methods in Swift that take a closure as a parameter are allowed to throw (like map, filter, reduce, etc). I can see that there might be implementation-specific reasons why supporting a throwing 'isOrderedBefore' predicate is hard (specifically: if the array is uniquely referenced, the sorting can occur in-place; however, if the predicate may throw, in-place sorting is impossible again because the original order of the array would need to be restored on throw; however with in-place sorting that order is lost if some elements have been swapped already). All in all: I agree that that sort should have a "rethrows" in it's signature.
&gt; I'd argue the latter is a less correct design choice, since "there is no max" is not really a semantic we consider valid in the common case; the developer should consider not even calling this on an empty collection. The swift designers obviously saw that differently though (and so do I). The standard library never throws when an element doesn't exist, and uses nil instead. One other example is `emptyArray.first`, that doesn't throw either but just returns nil. In some cases, an element not existing results in a fatal error (e.g. `emptyArray[0]`), but that's not throwing either. &gt; Once it's clear the function itself will throw, it's trivial to let the closure argument throw as well. Something being trivial/hard is a bad argument for making it so. We want to have the best possible standard library, not the one that's simplest to implement. &gt; Now the caller has to consider whether to become rethrows or contain the call in a do/catch block. Either way, it has to add an extra try decorator to the line. I second /u/teddim's comment on this - you should look into how rethrow works, because it's really nice and it's also used everywhere in the standard library. You can use a higher order method that rethrows like a method that doesn't throw, if you pass in a closure that doesn't throw.
Here's a snippet from one of my apps on how I do it -- I used "snapshot.children" to iterate over the children and make my own array (sounds like I may be doing something similar to /u/teddim): var tasks: [Task]? = [Task]() fbRef.child(Task.childClassName).child(fbUid).observeSingleEventOfType(.Value, withBlock: { (snapshot) in for child in snapshot.children { if let childSnap = child as? FIRDataSnapshot, let task = Task.fromSnapshot(childSnap) { print("Task found: \(task.name)") tasks?.append(task) } } }) { (error) in print(error.localizedDescription) }
Ah, I stand corrected, I had errantly assumed that Cartesian systems always had values descending from top to bottom.
Use the App Store API to go and fetch the icon for an app name. But yeah, if purely programmatic I don't believe you can know if an app is installed or not. Question wasn't clear Edited for clarity. 
Hi jam510! Unfortunately, the link to the App Store you submitted has been automatically removed from /r/Swift. This is because – generally speaking – compiled products are not relevant to /r/Swift (even if the app was originally written in Swift). If this is an app you have written, congrats on your acceptance to the App Store! A great way to promote it would be [Reddit advertising](https://www.reddit.com/advertising). If you would like to release its Swift source code, we would gladly accept a link to that. If the content you were submitting *was* in fact related to the subject of Swift programming, please [message the moderation team](https://www.reddit.com/message/compose?to=%2Fr%2Fswift&amp;subject=Please%20review%20my%20removed%20App%20Store%20submission&amp;message=https://www.reddit.com/r/swift/comments/4moij6/i_rewrote_our_production_app_in_swift_10k_lines/) to have it reviewed. Regards, The /r/Swift Moderation Team *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/swift) if you have any questions or concerns.*
&gt; UIKit and SpriteKit have different origins to their coordinate system. In UIKit, the y coordinates increase as you go downwards, so the origin is the top left of the view, but in SpriteKit the y v You guys are right about the coordinates, I had forgotten that SpriteKit reverses this. The problem I'm having is the image generated by the path is reversed from the physics body created from the same path! Here is a github project: https://github.com/soggybag/Shapes-Test Note: I used PaintCode to generate the drawing code. Then modified the class produced by paint code to create a function that returns the shape path. 
What's the worst thing about Swift right now ?
Why did you do it?
You got performance improvements?
* Testing is hard. You have to jump through a lot of hoops to [create maintainable mocks and protocols](http://masilotti.com/better-swift-unit-testing). * Some Objective-C &lt;-&gt; Swift interfaces are still ugly. This should improve with Swift 3.0. * Swift 3.0 will introduce a **lot** of breaking changes with the new [API translations](https://github.com/apple/swift-evolution/blob/d709546002e1636a10350d14da84eb9e554c3aac/proposals/0005-objective-c-name-translation.md).
Have you enjoyed writing in Swift? Is there something you hate in Swift? What IDE/Code Editor have you used?
No, that's not what happens. `a` is a `let`-constant after all, so it can't be changed. `sort` won't sort `a` in place (after all, currently calling `sort` on an immutable array doesn't mutate it either). First `a` is copied to a `var` and then that copy is sorted. In this code, `a` won't be mutated: let a = [2,3,1] let b: [Int] do { b = try a.sort(somePredicateThatThrows) } catch { return // or leave the scope in any other fashion } print(a) // still [2, 3, 1] print(b) // a, sorted in some order
The legacy app only received bug fixed during the rewrite, no new features. I was also responsible for taking care of those changes while I rewrote the app in Swift. This obviously slowed down the timeline, but not as drastically as you might expect. We took a very pragmatic approach to what we fixed: if it wasn't "game breaking" we held off on the fix until the new version was released. I learned a lot during the rewrite. Both in Swift and application architecture design. Also about the app itself! You always learn something new the second time around and this was no exception. The only things I wish I knew before the rewrite aren't related directly to Swift, such as `UIStackView` and the new auto layout anchor APIs. Then again, I wouldn't have been given a chance to learn them if I didn't do the rewrite.
Deciding which third-party libraries to use is always a tough decision. I try to keep my dependencies at a minimum. I like to categorize third-party code into a few categories: 1. Helpers and wrappers of Apple frameworks, like Alamofire and Masonry 1. Backwards compatibility porters, like [OAStackView](https://github.com/oarrabi/OAStackView) 1. Third-party services' APIs, like Fabric or Google Analytics I try to avoid #1 whenever possible. Sometimes the time it takes to learn the framework/library outweighs the benefits it provides. Also, I would have never learned about all the neat Auto Layout Anchor APIs if I had just been using Masonry! I'm a big fan of #2, especially if it's a well known library. These kind of dependencies really speed up development time, especially when adding support for an older version of iOS. I will almost always use #3, unless it's just a wrapper around an HTTP API. This is because the framework will usually handle a lot of boilerplate and nasty error handling for you. For example, the Google Analytics API gathers events and sends them in batches. It also handles if something fails by writing it to disc and retrying later. I would much rather be writing new features than handling that kind of work! Here is the app's current Podfile, for reference: pod 'Turbolinks' pod 'AlgoliaSearch-Client-Swift', '~&gt; 3.0' pod 'OAStackView' pod 'Google/Analytics' pod 'Fabric' pod 'Crashlytics' pod 'MBProgressHUD'
How can copying an array be avoided if you call the non-mutating `sort`? You end up with a sorted array and you keep the original array. Of course it was copied. Or am I missing something?
It's not done yet, but this code currently draws a thumbstick and the hat moves around under your thumb, stopping at the bounds of the main outer "ring". Next I need to include some hooks for the stick to apply some sort of "thrust" or movement to whatever node it is controlling. I'm sure there are better ways to do whatever it is I've done here, I just hacked this together to get started. The idea though is that you drop this into your scene and pass in whatever SKNode or subclass thereof that you want it to control. Like I said right now it's not actually doing the CONTROLLING part, but I'm not finished yet. https://gist.github.com/dancemonkey/549019a9ae1407eb567e5d6f8f1c70b3
Do you think that rewriting the entire app was a good solution for you? And what consideration did you put into this that led you to make the decision to? This is as opposed to just creating new code in Swift, but leaving the old, working, Objective-C code intact.
I basically already asked this ("Why did you do it?") :)
It there a reason why you were able to reduce LOC so much using swift? It would seem more likely to me that you were able to reduce LOC because of refractoring the entire app and not because you changed programming languages. If it was because of the programming language change, what made Swift so much cleaner?
Oh, I see. Those kind of optimisations might take place if the original array wasn't used anymore (but then it wouldn't matter anyways). Don't worry about it, it was a very interesting conversation. :) And it will still be tricky to implement. Even if the array doesn't have to be restored to its original value, it still needs to contain the exact same elements, so each sorting algorithm must be able to at least restore the array to a permutation of the original array. I threw this in the swift-evolution mailing list and we'll see what happens. 
Sounds like you want to make sort of a spiral why not use sin and cos. Set the step to π/2
Not sure if this was covered yet. When an object creates an instance of another object the owner has a reference to the owned object. The owned object does not have a reference to its owner. When the owner assigns itself to the delegate property of the owned object it allows two way communication between the two. All of the other ideas are abstract and hint all of the ways you might apply this concept in different situations. The idea that when created an object doesn't have another object it can communicate with is a concrete idea and the core reason for the delegate pattern. Protocols allow the system to be flexible. Rather than a delegate being a specific class. Remember you have to set the type. With protocol delegate can be any class that conforms to the protocol. Really the protocol is just a list of properties and methods. If a class has these it conforms. Declaring the protocol allows the compiler to check your work. 
You're joking, right? No header files. No Swift imports. Do you really think Objective C and Swift need the same amount of code? http://ctarda.com/2016/05/clarity-is-more-important-than-brevity-sometimes-you-can-have-both 
I'm also unconvinced by this approach. Does currying add anything besides terseness, here? I can't see it. Of course, basic traversal of JSON structures is overly verbose in Swift, but with so many different low-level solutions possible, we have to ask what do we really want to achieve? 'Remove boilerplate while clarifying intent.' might be a good start. Matthew Cheoks [JSONCodable](https://github.com/matthewcheok/JSONCodable) hits this mark well for me; and there are undoubtedly many other good libraries already in existence. The custom operators here are barely 'Swift' at all; may as well be hieroglyphics until you do a deep-dive; which with other solutions would be unnecessary.
It came down to a combination of a few small things. 1. As /u/mmellinger66 mentions, there are a few staples that Swift doesn't need. These include header files, **class** imports, `@implementation` marks, and simpler block syntax, just to name a few. 1. Taking advantage of Swift's protocols, extensions, and other language features allow a lot of code to be simplified. This creates more obvious code that is easier to read and understand. 1. After writing the app the first time I learned a **lot**. And a good portion of that learning was the right way to do things inside the app itself. For example, our push notification flow was overly complicated and reimplementing it made me realize I could cut out a lot of code. 1. I'm a better developer than I was a year ago! Which always translates to cleaner code.
I believe it was 100% the right decision at the time. I wouldn't recommend rewriting **every** app in Swift just because it sounds fun and exciting, though. A lot of variables lined up for us to make it a good time to reimplement a lot of flows and features. Before the rewrite the approach was different. All new classes were written in Swift but existing Objective-C code was continued in Objective-C. This created a nice balance of swapping back and forth between the two languages.
Agreed! I've been writing Objective-C since the manual reference counting days. But it is definitely dated and Swift takes care of a lot of error handling "automatically" for you. (See optionals, guard statements, and `ErrorType`). However, as I've mentioned in a few other comments, the timing was right. Our big third-party dependency was updated and upgrading would have required rewriting a third of our code anyway.
[BeerMenus](https://itunes.apple.com/app/apple-store/id917882057?pt=106837806&amp;ct=reddit_ama&amp;mt=8)! The app helps you find places selling beers you love or want to try, and browse up-to-date beer menus for bars, restaurants, and beer stores nearby. You can also follow beers or places to get push notifications when they have new inventory in stock. 
If I own that object and I want to be certain it sticks around as long as I need it, then I use strong. If that object is owned by someone else and the only reason i'd be looking at that object is that someone else is around, then I can get by with weak.
Loading the groups in the for loop causes all the problems. class GroupsViewController: UIViewController { var groupNames: [String?] = [] var groupIdsArr: [String] = [] override func viewDidLoad() { super.viewDidLoad() ref.child(uid).child("Groups").observeEventType(FIRDataEventType.Value, withBlock: { (snapshot) in let Dict = snapshot.value as? [String : AnyObject] if Dict != nil { var newIds: [String] = [] for (groupIds, accesBool) in Dict! { newIds.append(groupIds) } self.groupIdsArr = newIds // You can create a loop, that loads each value of the array. I inserted this into a tableview, and used indexPath.row self.loadGroups(groupIdsArr[0]) } }) } func loadGroups(groupID: String) { ref.child("Groups").child(groupID).child("GroupName").observeSingleEventOfType(.Value, withBlock: { (snapshot) in let GroupName = snapshot.value as? String print(GroupName) --&gt; Prints the string 1 time }) } 
Awesome dude. I'll start working on stuff tomorrow. 
ARC, or Automatic Reference Counter keeps track of how many references exist for an object so that its memory can be released when that number hits 0. Simply put, a strong reference is counted by ARC and a weak one is not. 
Did you factor in time for ABI changes with the swift version releases?
I second #1 (pun intended). It's a great course, and Paul Hegarty does a great job explaining the reasons why things are as they are. You can clearly see the code he is typing and he explains every single line of it. There even are 'homework' assignments, where you are challenged to continue on or improve the app developed during the lecture. Advanced topics are covered as well, everything from MVC to publishing the app is covered. I really like that there are a few 'projects' (Apps) he creates and works on during the course and explains the theory while coding. A must-watch when leaning swift!
Thanks for your response. I never thought about adding the overlay that way. So I added the rasterization to the CATextLayer but it's still slightly blurry. Would it have something to do with it being a sublayer of a CALayer? 
TBH it's been a while since I used the NSMutableComposition API so I can't really remember and I'm not at my mac so can't look at any of my old code :( will try edit if I get in front of my mac today :D
I'm not OP, but learn Swift. Make sure you learn to at least read Objective-C code at some point because there's still a lot of Obj-C code out there, for instance if you'll work for a company that still has an Objective-C codebase. But I'd write my own apps in Swift without any hesitation.
Looked over some previous code and this looks fine over a video for me :/ private func addLocationToVideo(parentLayer : CALayer, videoLayer : CALayer, scaleToFitRatio : CGFloat, segment s: VLGVideoSegment, desiredSize : CGSize) { let tFrame = frameConverter(s.segmentTextFrame, scaleRatio: scaleToFitRatio) let height = tFrame.size.height * 0.4 let imgFrame = CGRectMake(tFrame.origin.x + (tFrame.size.width / 2) - (height / 2), tFrame.origin.y + height, height, height) let image = UIImage(named: "location-pin") let imageLayer = CALayer() imageLayer.frame = imgFrame imageLayer.backgroundColor = s.segmentColor.CGColor let imgMask = CALayer() imgMask.frame = imageLayer.bounds imgMask.contents = image?.CGImage imageLayer.mask = imgMask imgMask.shouldRasterize = true imgMask.rasterizationScale = UIScreen.mainScreen().scale let textHeight = tFrame.size.height * 0.2 let dateLayer = CATextLayer() dateLayer.string = s.locationTextString!.componentsSeparatedByString("-").first dateLayer.font = UIFont.Custom(FontWeights.Normal, size: 120) dateLayer.alignmentMode = kCAAlignmentCenter dateLayer.frame = CGRectMake(tFrame.origin.x, imgFrame.origin.y - textHeight, tFrame.size.width, textHeight) dateLayer.foregroundColor = s.segmentColor.CGColor dateLayer.fontSize = VLGCaptureTimeView.locationFontSize * 3 dateLayer.shouldRasterize = true dateLayer.rasterizationScale = UIScreen.mainScreen().scale let numberLayer = CATextLayer() numberLayer.string = s.locationTextString!.componentsSeparatedByString("-").last numberLayer.font = UIFont.Custom(FontWeights.Normal, size: 120) numberLayer.alignmentMode = kCAAlignmentCenter numberLayer.frame = CGRectMake(tFrame.origin.x, dateLayer.frame.origin.y - textHeight, tFrame.size.width, textHeight) numberLayer.foregroundColor = s.segmentColor.CGColor numberLayer.fontSize = VLGCaptureTimeView.locationFontSize * 3 numberLayer.shouldRasterize = true numberLayer.rasterizationScale = UIScreen.mainScreen().scale parentLayer.frame = CGRectMake(0, 0, desiredSize.width * scaleToFitRatio, desiredSize.height * scaleToFitRatio) videoLayer.frame = CGRectMake(0, 0, desiredSize.width * scaleToFitRatio, desiredSize.height * scaleToFitRatio) parentLayer.addSublayer(videoLayer) videoLayer.addSublayer(imageLayer) videoLayer.addSublayer(dateLayer) videoLayer.addSublayer(numberLayer) } 
How did you learn proper memory allocation techniques? The first app i'm building is a social media app, and I'm finding with more testing that my code uses a lot of CPU as well as battery power. Also how do you continually build smarter? Meaning, how do you keep learning information that helps you save time. Are there any blogs or people you like to follow? As a new developer, it's very daunting and I have no one to typically ask dumb questions. I appreciate you taking the time to AMA!
If you are starting now I recommend learning Swift first. However, you will still need to be able to read and understand Objective-C for quite awhile. Lots of books, blogs, and Stack Overflow questions haven't been updated for Objective-C. Also, you will most likely need to read "legacy" code at some point. There's a great chance this will be written in Objective-C as well.
Is the app covered by tests? If not, add them during your rewrite. This is usually my flow when rewriting a portion of an app. 1. Ensure module/class is covered by unit tests 1. Re-implement module/class in Swift 1. Ensure tests remain green 1. Refactor to my heart's content! This allows me to make all the changes I want without worrying about breaking anything. Another approach that is complementary to a good test suite is playing around with Swift external to the app. You will learn a lot by trying to implement the code **without** looking at the existing code. For example, writing a flow to log the user in from the business/product requirements first. Then going back to the Objective-C and seeing if you missed any edge cases.
I'm confused...they are all 1's.... jk :D
Eh sure for new apps I wouldn't pick Objective-C over Swift unless there were some really compelling reasons (lots of C or C++ libraries to integrate could be a good reason) but I like the recent generics and nonnull additions to Objective-C. But they remain hacked on additions that you have to force yourself to use while in Swift those things are natural to the language.
Sure thing! If you need help writing Swift tests I've written an article to get you started: [Better Unit Testing in Swift](http://masilotti.com/better-swift-unit-testing/). Happy to answer any questions on testing as well!
It wasn't an easy decision. Hybrid apps have huge tradeoffs compared to fully native ones. The simplest comparison is that you can move a **lot** faster with hybrid views but you will potentially sacrifice performance and the "native feel". It's also harder to debug hybrid apps, especially when you start to have JavaScript events and manage different versions. The app was built after the mobile website was completed. This helped us move **extremely** fast in getting v1.0 out the door. The website covers about 20-30 screens and iOS only had to implement two natively. We are slowly converting the high-value screens to native but can do it incrementally, which is awesome. I write some of the web views, but most of them are handled by another developer. However, any of the interaction between the two is handled by me. For example, if the iOS client needs data from the information on screen I will write the JavaScript hooks and relevant meta data.
Is the code migrator built and ready to download? I can only find mention of it in the proposed evolutions.
Imagine our object is a dog, and that the dog wants to run away (be deallocated). Strong pointers are like a leash on the dog. As long as you have the leash attached to the dog, the dog will not run away. If five people attach their leash to one dog, (five strong pointers to one object), then the dog will not run away until all five leashes are detached. Weak pointers, on the other hand, are like little kids pointing at the dog and saying "Look! A dog!" As long as the dog is still on the leash, the little kids can still see the dog, and they'll still point to it. As soon as all the leashes are detached, though, the dog runs away no matter how many little kids are pointing to it. As soon as the last strong pointer (leash) no longer points to an object, the object will be deallocated, and all weak pointers will be zeroed out. [Source](http://stackoverflow.com/a/9262768/1835856)
Great job. 
You would consider using Zewo for handling networking, is there any performance impact? Sometime developers will compare Node.js vs PHP7 with nginx vs Swift on any frameworks, have you tried to benchmark if PHP7/Node.js or Swift have better performance?
There's a huge difference between Alamofire and Masonry. NSLayoutConstraint has a terrible API and anything that makes more sense is very welcome. I like the syntax of more high-level Autolayout wrappers, that's code that explains what it's doing instead of a huge assault of cryptic big methods. Alamofire is not essential at all, you can write a small wrapper yourself in 100 lines to pipe all your requests in the same format to the same domain etcetera.
Thanks for the reply. The user will need to type your birthday, but I don't know if the value needs to be formatted as a date. The years start from the 1960 and I'll have 12 collections (1960 until 1971) with plus 11 variations each (e.g. for 1960: 1972, 1984...2092). I though to use a list that store the variations (12,24,36,...132) and anytime that I need to check it, the script sum the year for each element, but I don't know how to implement it. Thanks.
What's the size of the sticker? I want to put it in my car.
I don't know you so I can't say what would be useful to you. But think of times where you say "shit I wish I could do this" and try that. That's how I get my ideas. Generally for iOS however it's a little easier since an app (well designed app*) is better than a browser so I start writing an app for what I feel like doing. It's the best way to come up with ideas I think. Do them for you, because I find that working on something you don't care about is _much_ more difficult than working on something you like. 
So a given input x, you need to know if it belongs to 1960,1961,...,1971. I.e 2013 belongs to 1965 because 2013 = 1965 + 12 * 4 ?
Ah, ok, that makes more sense. Anyway, sorry I can't help you out with the code part, but I'm sure someone here will be able to. :)
I would recommend NSURLSession, it will be very trivial to pull down the content for a URL, and if it turns out you need extra functionality which NSURLSession can't offer, then it will be simple to switch to something else. However, once you have downloaded the content, then what will you do? You will have a big pile of html to sort through. You might be able to use XML parsing if the HTML is kind of standard-ish, but XML parsing is pretty boring code to write! An alternative would be to use WebKit. When WebKit was introduced, there was a WWDC presentation: https://developer.apple.com/videos/play/wwdc2014/206/ where they use WebKit and a combination of Objective-C and Javascript to extract information from a Wikipedia page. Of course, you can do the same things from Swift rather than Objective-C. 
Nah, in my experience the playground is just slow... I am using a 2011 macbook air though xD
There are some font that are transparent. The text color only colors the outline. I figured it out. Its called bitmap font. There's serveral tools that I am looking at now that allows me to fill in the transparent part and customize my own .ttf files. 
Yes. I've think about it. But how can I implement it?
`%`, not `/`. `1961 % 12 == 5`, because `1956` is a multiple of `12` and `1956 + 5 == 12`. So, `a % b` is the remainder if you divide `a` by `b`.
What I would do is the following func belongsTo(x: Int) -&gt; Int { return (x % 12) + 1960 } Edit: What this does would give you a number between 0 and 11 inclusively - then add it to 1960 to get what value between 1960 and 1971 it "belongs to".
In my experience Playgrounds have been a little bit quirky. I still prefer tinkering around and learning inside a blank new project... But yeah, they can be a little slow. Xcode overall is pretty sluggish...
This is similar to [how we build apps](https://artsy.github.io/blog/2015/08/24/Cocoa-Architecture-Hybrid-Apps/) at Artsy, think it's a smart way to provide a lot of business value in the breadth of your support, while being able to focus on some really deep user interactions in your native code. 
Udacity is much better in my opinion. $300 a month comes with a job guarantee. $100 a month without a job guarantee (if you finish within 12 months)
NO NO NO NO NO they are so subpar and not taken seriously just no.
 &gt;Hey all, new in this sub. Maybe you can link me to a past post about this topic, Try search! However Sift is changing rapidly as is materials related to learning Swift. &gt;but if not...what's the best way to get started with Swift? Right now download XCode and install on a Mac. You can go the Linux route but the tools situation there needs more development. After you have a working system start with Apples texts and read all the way through. &gt;Got a good book recommendation, online course or another way to learn?? Any input is greatly appreciated! The Apple sponsored Stanford courses n ITunesU. You should have basic knowledge about Object Oriented Programming first though. 
got it! I will look for another resource.
* Public: Anyone can see/call/have access to the property/function on your type. * Private: Only the type can see/call/have access to the property/object. Think of it as similar to your own personal information. There are certain bits of that information that you don't mind other people seeing, like your height, eye colour etc. These are public properties. But there are other bits of your personal information you don't want everyone to access like your SSN, you want to keep these to yourself, these would be private properties. It is also worth noting that there is also the internal access control, which is the default. As Swift will compile your project into a module. The internal access modifier allows properties/methods be accessible to all types in your module, but these are not accessible to anything outside of the module. So to recap... * Public: Everyone can see/access anything that is public. * Internal: Only types within your module can see/access anything that is internal. * Private: Only that specific type can see/access anything that is private.
It's loading fine for me. I learn better by having access to different books or videos. Right now I'm watching the videos from Mastering Swift 2 and I can say I'm learning a lot of new things. If you want a step by step tutorial, I heard the iOS Apprentice is really good. You can go through the tutorials and if you feel like you need a better understanding of a particular topic, you can consult one of the books. In the end, the best way to learn is by building something and learning from others that have more experience. That is not always possible, but I think the books help a lot.
Wish there was something at the back as well 
Side note: I think this is the incorrect sub for your question If you have money to burn and feel like learning iOS. why not. But it seems like you are doing this as some form of career development, and you expect a job in iOS development, in which case all of these things are a waste of money. Go to an actual college and study CS and get a real degree. No serious iOS job is going to hire someone from one of those schools when there are so many students graduating with actual CS backgrounds.
Yup, currently on Project 3. Personally, I recommend having some background in Swift and iOS before taking the course. Treehouse is a good start (the regular membership). Ray Wenderlich's iOS Apprentice (first two of the four books) and App Coda are great. Udacity is amazing, couldn't recommend it enough. Treehouse is good for introductions and beginner-level stuff, which has its place.
Can you explain more practically? What does it mean for another object to "see" the properties/function of another object? What does it mean to hide things from other objects? I guess my issue is I have nothing concrete to compare it to. Let's say personA has a property called SSN. If it is a private constant, does that simply mean we can't store the SSN into another var/constant or instance variable? If so, how would the same concept apply to a function? Aren't functions by definition only accessed by the object it is contained inside? What does it mean to have an object with a public function? Sorry for the noob questions, just really trying to understand and Google and Swift docs assume a certain level of fluency..
It actually took too much time and for some reason I always ended up having the same issue so I just got rid of the old project and recreated it (thankfully, I was in the beginning with couple login/sign up screens mostly)
Why don't you post them here so everyone can read the answers?
agree on the Udemy part, after I finished there I've invested in the books from Paul (surname missing) who is behind hackingwithswift. more than enough material for a long time. and really awesome way to get started (Rob + some of the free courses) and then deep dive with the books from Paul.
Consider UIButton: it has an imageForState() function, which you can use in your program despite not having access to Apple's source code. You have *no idea* how that works internally, and it may in fact call many other functions. imageForState() is a public function on UIButton. The stuff it may or may not call to do its job is private. So no, object functions are not only accessed by the object; objects can and often do call functions on other objects.
You should read the free tutorials on [Hacking with Swift](https://www.hackingwithswift.com). (Disclaimer: I wrote Hacking with Swift.)
I don't agree, as someone who just graduated from a 4 year CECS program, every job I interviewed for asked what I could do not where I learned it. In fact they were more willing to hire someone with more Apps in the store than someone who went through a college program and had a App in the store. 
I believe I heard before they're not threadsafe, but I might be wrong. The best thing to find out is to test it yourself!
Don't worry about it. It's not really useful in most cases anyway. Mostly it's only good for when writing libraries. 
Ah yeah, my words fail me sometimes. My apologies. I was meaning the fake degree stuff as well, but I have heard of some boot camp programs that are online giving good results and a PDF saying you completed their work. That some companies actually take value in. The place I ended up landing a job was the first one to ask me OOP questions and not just iOS specific ones.
I can't recommend the [books](https://gumroad.com/twostraws) by /u/twostraws enough. Hacking with Swift is an **absurd** amount of content for $30 (the book clocks in at over 1250 pages), and Pro Swift takes a deep dives into some of the easier to miss but extremely useful features of Swift. If there is $60 I have spent that I haven't regretted while learning iOS development, it's those two books.
Have you looked at [Apple's Book](https://itunes.apple.com/us/book/swift-programming-language/id881256329?mt=11)? What are some things that it doesn't address?
Strongly disagree that the best way to find out is to test it yourself when it comes to threading issues. The story of threading is full of examples of "works on my machine" but has catastrophic data corruption on some other machine even if you try your best to trigger a problem. Fortunately, Apple's pretty good about documenting whether things are thread-safe; if you can't find out, it's best to assume NOT thread safe.
I think understanding SOLID is a must for just about any dev. This collection is very neatly organized with links back to Bob Martin's original docs for each principle. 
True, but if you do tests and see clear signs of thread-unsafety, that means it is thread unsafe. If you do *not* see these signs, you can't know for sure.
The best way is unfortunately also the hardest way: start reading through the standard library source code. Another way is to read the Swift mailing lists, where many of these issues are discussed as part of the process of designing changes to the language and library.
Sounds good! Not really looking for a resume padder in the form of some kind of degree but a good resource that can help me build the projects that I want to. I really like this resource you linked, as it seems much more up my alley. Thank you!
Hey, thanks for linking me to this. Not really looking for a resume padder in the form of some kind of certificate degree but a good resource that can help me build the projects that I want to. Thank you!
"Crazy value" is pretty much what I'm going for – I figure if I'm able to give people above and beyond what they expected, they are happier with their purchase, happy to recommend it to others, and hopefully also happy to buy any future iOS books. Not that I'm planning another iOS book……… ;)
I think you'd like [Advanced Swift by objc.io](https://www.objc.io/books/advanced-swift/). They really like to dive into the source code if it helps them explain how something works.
Well it is a really interesting strategy given how much lower the cost is relative to other resources. But I can totally understand why you would take the chance going that route for a long term gain. Just a few thoughts. Overall the screencast videos with Pro Swift are great and well done, so that is definitely adding a lot of value to your books. And speaking of other iOS books, a Pro Swift part 2 that continued on and covered more advanced topics yet would likely be really well received. What makes your books valuable is that they are actually accessible to people completely new to programming so the more, high quality, material that is available to this group of people the better.
i simply want to have users post a link and display the title and main image in a tableview.
The way Swift arrays work is that they are values, but they don't store their data directly. There is a reference-type buffer that copies of the same Array instance share. When you mutate (for example, by appending), it uses the standard library function 'isUniquelyReferenced' to see if there are any other Arrays pointing to the buffer it's about to append to. If there are, it makes a copy and the copy becomes its new backing store. This is called 'copy-on-write'. So for Arrays, which use a reference-type backing to avoid excessive copying, it all boils down to 'isUniquelyReferenced'. It is thread-safe, so all copy-on-write values should be, too. If any other copy is mutating, it'll be doing so on its own copy of the buffer. (I'm explaining this in case you want to make your own value-types thread-safe). From the Swift blog (https://developer.apple.com/swift/blog/?id=10) &gt;&gt; In Swift, Array, String, and Dictionary are all value types. They behave much like a simple int value in C, acting as a unique instance of that data. You don’t need to do anything special — such as making an explicit copy — to prevent other code from modifying that data behind your back. **Importantly, you can safely pass copies of values across threads without synchronization.** In the spirit of improving safety, this model will help you write more predictable code in Swift.
Swift is fully open-source. It's not the most comprehensive info, but it's everything you could ever know about Swift: https://github.com/apple/swift
Hi! I used to work with Bob himself at my company, and I have been doing training in his style of writing code for half-a-decade now, so I have to say: a lot of people really don't get a full appreciation of SOLID. So, thanks for posting this. But I have a bit of feedback, if you're willing to hear it: First, Swift isn't really, as a language, a great fit for a lot of these sorts of OO patterns: the first example contains a "textbook" example of the Command Pattern in `DoorOpener` and `DoorCloser`, but in Swift, we don't need `Command` objects, because we have functions: new CommandObject(args: myArgs).execute() // versus doCommand(args: myArgs) // or even wrapping it in a void closure to pass it around { doCommand(args: myArgs) } When the _capability_ of our languages expand, we should investigate the _suitability_ of our old practices as they relate to the new tools. Some of these practices are now overkill because Swift's compiler is sufficiently advanced. I also think it's important to emphasize that the single responsibility principle means that a module has one responsibility and that it represents the _entirety_ of that responsibility. It also is important to emphasize that the responsibility is more about _domain_ responsibilities: persist this thing, represent this piece of data, whatever. The SRP example in the book pages that you linked, I think, is a more informative snippet to illustrate the purpose of the principle. This example makes me wonder why it would ever possibly make sense to create objects that exist solely to mutate state on another object. Bob himself says that overuse of some of these principles is an anti-pattern that creates endless middlemen. In my history of teaching LSP, I'd say that it's better to show what happens when a violation occurs than to show a "good" case: we need to know _why_ this is important rather than just a simple example of subclass substitution. So yeah, I hope that didn't come across as too nitpicky -- and if it did, sorry! Best of luck! And thanks again for sharing.
If you need beta testers I'm glad to help you out through test flight or whatever :), feel free to send a message any time
I should probably clarify, I'm not the owner/creator of that repo. I just came across it and thought I would share. Still good feedback though, and your experience in this particular area is great to have in the discussion so thanks for that!
Not needed :) wasn't my answer. Just passing along a good answer. 
I second this recommendation for anyone who wants to go beyond the basics, it's a great resource.
That's really cool. However, I do think I saw the Swift coding guidelines (or someone on the swift-evo list) say to reserve global functions for really important things, though. Unless you mean something else...
Hi /u/JeffBNimble, welcome to Reddit. Please take a moment to read [Reddit's site-wide policy on self promotion](https://www.reddit.com/wiki/selfpromotion). Thanks!
What are some of those other principles?
Conversely, I've noticed that many of the functions are still broken in swift retrieving values from NSUserDefaults using their associated helper functions. I.e. `stringForKey(_:) or dictionaryForKey(_:)` The work-around for this is to just use objectForKey(_:) and cast to whatever object the returned value to whatever type you want. `let abc: String = NSUserDefaults.standardUserDefaults().objectForKey("abc") as! String`
They're mostly things that tie back to SOLID but are more concise/concrete. So maybe not so much principle-y and more pattern-y. * Composition over inheritance * The Rule of Three / Don't Repeat Yourself / You're Not Gonna Need It * Dependency-injection * Model-view-controller * Declarative over imperative * Defensive coding The way I see it, SOLID principles can be used to back most of these up. I've been meaning to read the Gang of Four book. I think a lot of design patterns that I find 'natural' probably have more specific names that I should be using. But, SOLID makes design patterns 'obvious' and everything else sort of follows.
Isn't Core Graphics one of the APIs that's going to *objectified* in 3.0?
I'm not expert, but I think a game is a bit overkill. I mean you don't need a physics engine/bodies, so why use Game? For animation your best bet is to look at Core Graphics or CG. You can do a lot with that, even in a single view application.
Game would be helpful in the sense that if you give correct answers the animation effects would follow physics.
Game is fine. Just delete GameScene.sks and delete some of the useless functions from GameViewController and GameScene asap to avoid confusion later. Core Graphics is an easy way to animate in swift and there are tons of tutorials on YouTube. I might even recommend using SpriteKit if you're new to Swift. Creating the background scene and your characters will be easy and then you'll have access to SKAction animations that are easy to pickup. Best of luck. Edit: As an afterthought I'm sure you can find an entire tutorial for a quiz-type iOS game online somewhere and alter the source code to fit your needs. 
You can still import SpriteKit in the view controller that needs this without setting it up as a project.
Hackingwithswift is pretty regularly recommended for absolute beginners. 
Plus I (the author) come by here several times a day, so if you hit problems just ask and I'll do my best to help!
Hacking with Swift is a great place to start. You can then follow that up with Pro Swift (the second part in that series which is $30 but well, well worth the price), and the Stanford iTunesU CS193P course (which is an introductory computer science course for iOS development but you will want a good understanding of Swift before tackling that). If those aren't working for there are tons of other resources out there as well. Udacity has some free iOS development courses. As far as free resources those are really the only ones I would recommend. You get what you pay for and spending a few dollars on a properly written book (like Big Nerd Ranch's Swift Programming) is going to be worth it instead of trying to learn through mediocre website and resources.
It's accepted for Swift 3 after all (and I'm guessing that means 3.0): https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md
Alright cheers! Looking into it now :)
Good luck! If you have any specific questions feel free to reach out to me on Twitter, [@joemasilotti](https://twitter.com/joemasilottI), once this thread closes.
iTunesU has a great course on Swift and developing iOS9 applications.
That's good to hear! I'll be sure to come back with any issues I may have.
We did something similar for a certain client. Study your unit circle math and core animation and you'll be fine. 
As soon as all the leashes are detached, though, the dog *might* run away 
Here is a more practical example. I am currently writing a framework to deal with requests for Google Calendar information and their responses. I will then convert the response into an object that has properties with the correct values instead of the raw JSON NSData object or the serialized [String: AnyObject] Dictionary that would normally be provided. If I were to make this available to for anyone to download, I want to help the person using the framework to understand what parts are for use in his/her application vs. what I have included only to process information behind the scenes. struct Request { private var httpType: String private var resource: ResourceType private var token: String private var apiKey: String private var url: NSURL! private var httpBody: NSData? private var baseURL = "https://www.googleapis.com/calendar/v3/" private init?(type: String, resource: ResourceType, token: String, key: String, body: [String: AnyObject]? = nil) { self.httpType = type self.resource = resource self.token = token self.apiKey = key guard let url = createURL() else { return nil } self.url = url addBody(body) } static func get(resource: ResourceType, token: String, key: String) -&gt; Request? { guard let request = Request(type: "GET",resource: resource, token: token, key: key) else { return nil } return request } static func put(resource: ResourceType, token: String, key: String, body: [String: AnyObject]) -&gt; Request? { guard let request = Request(type: "PUT",resource: resource, token: token, key: key, body: body) else { return nil } return request } static func post(resource: ResourceType, token: String, key: String, body: [String: AnyObject]) -&gt; Request? { guard let request = Request(type: "POST",resource: resource, token: token, key: key, body: body) else { return nil } return request } static func delete(resource: ResourceType, token: String, key: String, body: [String: AnyObject]) -&gt; Request? { guard let request = Request(type: "DELETE",resource: resource, token: token, key: key, body: body) else { return nil } return request } private func createURL() -&gt; NSURL? { var URLString: String switch resource { case .calendarList: URLString = baseURL + "users/me/calendarList?" case .eventList(let id, let min, let max): //TODO: Add min/max values as parameters URLString = baseURL + "calendars/\(id)/events?timeMax=\(max)&amp;timeMin=\(min)" case .event(let id, let calendar): URLString = baseURL + "calendars/\(calendar)/events/\(id)?" } URLString += "key=\(token)" return NSURL(string: URLString) } func send(responseHandler: (response: Response?) -&gt; ()) { let request = NSMutableURLRequest(URL: self.url) request.addValue("Bearer \(self.token)", forHTTPHeaderField: "Authorization") request.addValue("application/json; charset=UTF-8", forHTTPHeaderField: "content-type" ) request.HTTPMethod = self.httpType request.HTTPBody = self.httpBody let session = NSURLSession.sharedSession() let task = session.dataTaskWithRequest(request) { data, response, error in assert(error == nil, "error in response from send:\nerror: \(error)\nrequest: \(request)\ndata: \(data.debugDescription)\nresponse: \(response)") responseHandler(response: Response(data: data, response: response)) } task.resume() } private mutating func addBody(dictionary: [String:AnyObject]?) { guard let dictionary = dictionary else { return } if let data = try? NSJSONSerialization.dataWithJSONObject(dictionary, options: NSJSONWritingOptions(rawValue: 0)) { httpBody = data } } private static func requestColors(key: String, responseHandler: (Response?) -&gt; ()) { if let url = NSURL(string: "https://www.googleapis.com/calendar/v3/colors?\(key)") { let request = NSURLRequest(URL: url) let session = NSURLSession.sharedSession() let task = session.dataTaskWithRequest(request) { data, response, error in assert(error == nil, "error in response from requestColors:\nerror: \(error)\ndata: \(data.debugDescription)\nresponse: \(response)") responseHandler(Response(data: data, response: response)) } task.resume() } } enum ResourceType { case event(id: String, calendar: String) case calendarList case eventList(calendarId: String, minDate: String, maxDate: String) } } This is my request object. By making all of the vars private, I am telling anyone who use it that he/she shouldn't be concerned with these values but should construct his/her request by using the 4 static methods get, put, post, and delete and execute the request by using the send instance method. 
I have used Zewo on Linux 14.04 and really enjoyed the experience. The people who are working on it are pretty amazing. They have a slack I hang out in often and are super helpful if you are struggling with something. Spending time in their slack had helped me appreciate the state of server side Swift, since it is all utilizing Swift 3 they all have some inherent pains. They are constantly working on bug fixing and feature building, then about every 2 weeks Apple releases a new snapshot that just about breaks everything, so it is a scramble to get everything working on that snapshot. Once it is all working again they are pushing to make improvements again and about a week goes by before the cycle starts over again (it isn't even that predictable since Apples isn't releasing these on any type of schedule, the last two snapshots are dated 6 days apart). As for how Zewo compares to Vapor, Zewo is much larger of an undertaking. They are essentially providing an alternative to Foundation, while Vapor is just a about serving up web content. If you look at the Package.swift file for Vapor, it is using 4 Zewo packages. 
Not free, but I'm currently taking a Udemy course by Rob Percival. The interactive nature of the course makes it easy and fun to learn. About $50 but there is a lot of content. Probably only 1/3 of the way through but love it so far.
A lot of Udemy courses I have found to be not worth the money. Any of the iOS ones I have found to be useful have all been done by Rob Percival so his courses are not a bad choice. Udemy does also have sales from time to time where you can get courses for $10. The full price of most of the courses are not worth it but at $10...I would say it is worth it (especially for some of the courses which focus on very specific topics, such as WatchOS2)
I think you mean that you want to figure out how to connect to an IRC server, right? IRC is a TCP-based protocol, so you're looking at using the low-level socket API which was ported more or less directly from C. It's sort of a pain in the ass, but it should feel somewhat familiar given that your previous implementation was in C++. This SO question http://stackoverflow.com/questions/33727980/basic-tcp-ip-server-in-swift and its answers deal with how to write a TCP/IP server – not exactly what you're building, but the fundamentals of opening, reading, and writing sockets are more or less the same.
Are you looking for port level information or are you looking for make general URL level information? for URL information [NSURL](https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSURL_Class/index.html#//apple_ref/occ/cl/NSURL) is the direction you want to look. For Port level you might want to look at the [NetworkExtension](https://developer.apple.com/library/ios/navigation/#section=Frameworks&amp;topic=NetworkExtension) framework or the [MultipeerConectivity](https://developer.apple.com/library/ios/navigation/#section=Frameworks&amp;topic=MultipeerConnectivity) framework. 
Hey twostraws I actually have a question. I just finished project 9 of HWS and every time I encounter a selector parameter they're always "#something" and don't work. Can you explain what the # is doing in this instance and why the selectors are not working? I can try to find specific examples from your first 9 courses later but I don't have them with me right now. 
I can't speak for other tutorial writers, but I certainly have no intention of updating Hacking with Swift (or my other books) until I feel Swift 3.0 has settled. I'll definitely be updating everything before Swift 3.0 goes GM – maybe beta 3 or 4, or around then, I expect. The last thing I want is to put a major update out for beta 1, only to have beta 2 change it further! Until then, you might find my [what's new in Swift 3.0](https://www.hackingwithswift.com/swift3) article useful.
Oh jesus hey man! Was just looking over your site, may have to invest! (in the eBook that is)
Yeah I've seen some on there, downloaded a few now along with the iBook books.
I downloaded the Swift book from iBooks and was having a mess around in the playground, sort of opened me up to the basics. I haven't finished reading it yet but i'll keep reading.
Downloaded kind sir.
Awesome! Let me know what you think :)
The playground contains some embedded tutorials and examples, if you work through those and really pay attention you should be able to figure out swift pretty quickly. At least that's in my experience. If you're completely new to programming it might take a bit longer though. 
Yes, sorry for the mix up, i meant IRC Server. I am a bit tired :p 
I have successfully used NSURLSession to dump the HTML and parse the info I need, however, I've found that if i change the link, the code can break. It doesn't break everytime, but it does break depending on the website. I've been using "description\" content=\" and componentsSeperatedByString - but I think there's a better way. Any thoughts are appreciated! 
Thanks for the input. Recommend to focus learning on Swift 2.0 for the meantime and worry about 3.0 when the time comes?
I'm temporarily using FSCalendar in my current project, until I get round to building my own custom one. But there's a whole heap of calendar widgets on Github. Have a sift through this list: http://cocoapods.org/?q=calendar
I can't guess why your conversions to Int are failing, but you could try using an NSNumberFormatter to do the conversion; it might be a bit more flexible. But I'd really suggest you check out [NSScanner](http://nshipster.com/nsscanner/), it should help you do what you want to do and be more efficient about it, too.
This is not a situation in which you should force unwrap; do a guard-let unwrap and in the else (failure) case, log the failed value (and do other error handling as necessary) then break from the loop. Glancing at your code again, I notice you do `each.componentsSeparatedByString(",")` but do not assign the resulting array to anything. I can't tell if this is your real code or not (it's obviously incomplete) but that might be a problem.
more specifically [this](https://itunes.apple.com/us/course/developing-ios-9-apps-swift/id1104579961) course
Thanks, this looks helpful. I'll give it a spin.
That sounds like a nightmare.
When you copy the code, you should stop and take your time and try and understand how the code works. If you're having trouble with that, then it might be too challenging for you, and you should maybe find an easier course, or find some simple "challenges" and build up, maybe using Playground. 
Yeah. I'm sure more experienced people wouldn't find it too difficult, and would cringe at how I did it. One particularly horrible thing was to get the right amount of blank cells for the first day. I made an NSDate for the 1st of the month for that year then got the day of the week and found the index of the day in an array of days of the week to get the offset. Then for every other cell it was dayOfTheMonth + startingDayOffset + 7 for the item's indexPath. The first 7 cells were M, T, W etc. But hey, it worked!
I mean I'm a fresh out of college programmer with one semesters worth of swift, that sounds like a gigantic pain in the neck. How many hours would you say you worked on that?
[PromiseKit](https://github.com/mxcl/PromiseKit) is a fairly decent implementation of promises for Swift. It's relatively simple and doesn't take long to get your head around. Though there are some language traps (the closures don't completely play nicely with the Swift compiler yet), so I don't add it to projects until a genuine need arises. 
If you don't feel like you are actually learning then it is probably not the right resource for you. Ultimately everyone learns differently so what is going to work best for you is going to come down to trial and error. If you feel like you need to learn more of the fundamentals then I would try a book like the Big Nerd Ranch Swift Development book, or hackingwithsift.com and the books that Paul has which are quite excellent. When you first start out it can be crazy overwhelming at times so the first part is tough to get through, If you are really passionate about the idea of development though then be persistent and keep trying different resources until you find the one just for you.
Yes: learn Swift 2.2 now, then upgrade to 3.0 when it's ready. 
Didn't read, but raywenderlich.com just had an article about making Frameworks posted the other day. 
Too many. I am a nobody with no degree who learns by doing, even if it's the wrong way. This is just a hobby for me mostly, although I have been finding the cravings while I'm at my jobby job increasingly hard to ignore. To be honest the whole app was me doing things the hard way. I wanted to use as few external libraries as possible, which I succeeded in I guess, so that I could learn.. well, the hard way. 
In my opinion, the answer to the question is both yes and no. It really depends on your use case and needs. Reactive programming solves asynchronous problems quite elegantly. It really shines when you have a bunch of different asynchronous events that needs to be composed (for example, running serially, or in paralell, or there is a relation between async calls). The best example of code elegance can be found in the example app in RxSwift repo. One more pro point is that RxSwift is one of many implementation of Rx. There's implementation for Java, C#, Javascript etc. I believe those three are the widest in usage. I guess it somewhat shares the same mantra as `React` and `React Native`? **“Learn once, write anywhere.”** And I don't quite agree with the poster's comment on the code being hard to understand. Yes there's definitely a learning curve, but look at it from this perspective: the first you encounter the more functional approach, for example `map`, `filter`, `reduce`, `foldl`, `takewhile`, etc, of looping and handling array, did you really understand all of them without reading documentation ever? I believe for most people, they first learned loops using `for` and `while`. Eventually they discover the functional approach and realize it does the same thing and is more concise. Would you say you'd never use `map`, `filter`? After you've learned what those functions do, you can easily understand and remember them. I guess it's a matter of how much time you would spend on learning. That being said, the learning curve is definitely there. I'd rate it "medium" difficulty. At the end of the day, it depends on use case. If you are a lone wolf and already understand Swift and UIKit quite well, by all means learn Reactive Programming. it's eye opening. You will be a better programmer by the end. If you are a busy man and just want to pay rent, stick with the old and tried. If you are a team envrionment, let the team choose something they are most comfortable with unless there's a massive benefit using another. Edit: If you are not already familiar and experienced with Swift and UIKit, don't bother with RxSwift yet. Learn the standard sutff first and learn them well. Reactive Programming a different beast.
Well they are just asynchronous constructs. You can consider them working like `NSOperation` in logic (without the queue). For example, in ReactiveCocoa, you may construct a producer to start a network request in its start handler, but *asynchronously* send back the data or a status (e.g. not found) to the observers at a later point of time. I would say it is better in my own experience, since I use KVO a lot and RAC helps me wrapped a lot of ugly code into a composable format. MVVM is another tidbit that shines with reactive or event-driven programming. Though TBH even if you follow Apple's MVC paradigm, you can still take advantage of it. Anyway, it is important to at least understand the basics (of what being wrapped) before using any higher-level wrapper.
To my knowledge, you can't have a specialized Array conform to a new protocol in that way. You'd have to have all of Array conform to that protocol instead, which I'm not sure is possible for this case either. I've actually been working on a very similar structure recently. I ended up with something like this: public enum TaggedData: Hashable { public typealias Dictionary = [TaggedData: TaggedData] public typealias Array = [TaggedData] // ... case declarations etc. } extension Int { init?(_ data: TaggedData) { switch data { case let .int(i): self = i return default: return nil } } } func Array(taggedData data: TaggedData) -&gt; TaggedData.Array? { switch data { case let .array(a): return a default: return .None } } with a very similar Dictionary function, of course. I'm not actually using an Array.init method, but this function will look pretty similar in usage to a failable initializer. I provided a public argument name here so Swift (2, at least; haven't looked at 3 yet) requires callers to type `Array(taggedData: myData)` just for clarity's sake (I may remove it). I'm not sure that's the best way to do it, but I haven't found a way to extend Array with non-generic inits yet. I decided it was a good enough prototype for my use case to move on to some other scaffolding for now. A couple other notes: you may want to change the spelling to `JsonConvertible`, and it may be worth removing that protocol altogether if your Array and Dictionary can't conform to it anyway–but it also may be worth keeping! I haven't fully explored that question for my own little enum; I think it's just a matter of writing consumer code with an eye out for places a protocol may fill a gap this already unifying type can't. In case you aren't already planning to, consider making a UnderlyingType.init for each of the concrete types alongside your current one: it's repetitive to write, but you get to make them non-failable which saves your callers from unwrapping whenever the compiler knows the input type. E: Oh, and you can have your generic init delegate out to the type-specific ones, so any future type-specific validation is only run in one spot.
Don't use the Percival course. It is very low quality. The guy doesn't even mention OOP.
I'll take a look at it! Thanks.
Looks really promising thank you for sharing this, I'll definitely be using it :)
The advice I always give is that you learn the language (Swift in this case) first, and only then do you start really digging into the frameworks (UIKit, etc). These video courses always want to start people off with frameworks, hoping that by introducing the language in drips and drabs, everyone will just "pick up on it" with a minimum of explanation while doing "the fun stuff," but lots of people don't learn very well through this technique. **Swift Materials** * The Swift Programming Language (iBooks) * Swift Programming: The Big Nerd Ranch Guide * Swift Apprentice (raywenderlich.com) Of these, I'd give my highest recommendation to the BNR book as a learning text. While Swift Apprentice feels like learning from a condensed version of Apple's official documentation (not necessarily a bad thing), BNR has a bit more pedagogical depth to it, and does an excellent job of explaining some of the more advanced features of Swift. One upside to Swift Apprentice, though, is that it's certain to be updated continuously (as with all of the Ray Wenderlich "Apprentice" books) as Swift changes, whereas BNR is typically set in stone until a new edition drops (though I believe they're now putting up errata and content updates on Github, at the very least). Honestly, you probably can't go wrong with BNR or Swift Apprentice here. But BNR is my pick. **iOS Materials** * iOS Programming: The Big Nerd Ranch Guide (5th Edition) * iOS Apprentice (raywenderlich.com) Of these, I would recommend iOS Apprentice, because it's based entirely on the concept of demonstrating the realistic process of designing and building an app. Over all four projects, not only are you absorbing (IMO) very solid code style and OOP techniques, but you're learning that constant refactoring is a fact of life. In other words, they're not just building out complete projects with perfect code the first time. They're starting with credible first-pass solutions that prove suboptimal as the code develops, and demonstrating how you go back over the code and make it better. iOS, by its own claim, is designed to teach Swift alongside the major iOS frameworks, but again, I would start by getting solid with Swift first, so you can focus all your energy on the frameworks once you start building real apps in iOS Apprentice. What you learn about Swift from building those apps should be more about style and program design than about language basics. BNR is solid, as it's always been, but it feels more like an exploration of frameworks than a book that's thoroughly about iOS software development. iOS Apprentice has a great pedagogical perspective, and pretty much supplants the BNR iOS texts, in my view. As for the courses by Rob Percival and others, if you can get them during the $10 fire sales they run at Udemy, then sure, they can be of some value. They might cover, in a very basic way, some part of the framework that other materials left out. But they are, in my estimation, a really slapdash way to learn Swift and iOS development. You'll find yourself left with all sorts of questions about basic stuff you should already know, because they're skipping depth in order to get you to what they feel is the "fun stuff" as quickly as possible. While this may be effective at building the learner's interest and confidence early on, it quickly leaves him/her with the feeling of being lost at sea, or standing on shaky ground. Don't blame yourself. This is simply bad teaching. The right materials will get you where you need to be.
Have you ever looked at code and knew it was gross but didn't know how to say it to another developer? Have you ever looked at code and knew it was gross but didn't know what to suggest to the other developer instead? Have you yourself thought your code was fragile but didn't know where to start attacking fixing it? Instead of saying: * "Wow, this class is huge and looks like a mess" --&gt; "This class breaks the single responsibility principle" * "This code is spaghetti and I don't know what's going on - could we restructure this in a more intuitive way?" --&gt; "I think this could be restructured better in a way that leverages the open/closed principle" * "I don't think I would have made this class hierarchy" --&gt; "This class hierarchy doesn't follow the Liskov substitution principle. You should use [composition instead of inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance)." * "Why should your client object care about this?" --&gt; "You would be better off segregating these interfaces" * "the high level and low level APIs are being mixed and it doesn't make sense" --&gt; "this does not follow the dependency inversion principle" SOLID is not necessarily about programming or even object-oriented design - it is about dependency and *dependency is bad*. Dependencies cause maintenance, fragility, and robustness/reusability issues (ex: unit tests if you care about that). The principles can tie back into each other or blur lines because their analogs in programming might be similar in many real-world cases. [Single responsibility](https://en.wikipedia.org/wiki/Single_responsibility_principle) is the cornerstone. You do one thing, and you do it well. Don't make a class that does half of the abstraction. Don't make a class that does two levels of the abstraction. Think in terms of what the client wants from your public interface. [Open/closed](https://en.wikipedia.org/wiki/Open/closed_principle) says you should isolating dependencies that *change*. This is so you do not accidentally break the core functionality and it allows you or others to focus on what needs to be changed and not tempted to break other unrelated things. So, you have one class that does something very well, but it has a method that maybe takes too many parameters to change 5% of its functionality, and you're constantly updating that method and causing it to break. Rather than having one class where one small piece of functionality is constantly changing, you might [delegate](https://en.wikipedia.org/wiki/Delegation_pattern) out that functionality. The goal is to have as many pieces (files/classes/functions/etc) *not* change, but allow them to change in functionality through, say [dependency injection](https://en.wikipedia.org/wiki/Dependency_injection). [Liskov substitution](https://en.wikipedia.org/wiki/Liskov_substitution_principle) is a litmus test to see if your inheritance hierarchy makes sense. Inheritance could apply to any interface or abstraction but it's most commonly applied to objects. High-level, it says "If you are a subclass, don't break the interface contract." My favorite example is List&lt;&gt; in many languages - if you want an unchanging List, it is typically a subclass of a changing (mutable) list - THIS IS A VIOLATION. **Subclasses should add functionality and not break or remove functionality.** If you are subclassing in a case where you cannot interchange the subclass with the base class without breaking something coded against the base class, then maybe you should look at other design patterns like dependency injection (above). [Interface segregation](https://en.wikipedia.org/wiki/Interface_segregation_principle) - this is slightly similar to single responsibility, but from a different perspective. Having multiple client interfaces is better than having one monolithic client interface. A good example of this is iOS's UITableView - it has a delegate for injecting functionality, and it has a dataSource to provide the data to display on screen. In practice 99% of the time, the delegate and dataSource are the same object. However, this does not have to be the case and so you can imagine the world where one might want to farm out the dataSource responsibilities - and that is inherently built-in. [Dependency inversion](https://en.wikipedia.org/wiki/Dependency_inversion_principle) is one I've had to struggle with, because on the surface it seems like a strangely worded dependency injection - but that is only one pattern in which you can achieve this. I think the critical point in its description is the *level* of abstraction (which can be a bit subjective sometimes). Anyhow, it's basically "make (and rely on) an interface when interacting with a different level of abstraction". IMO, probably the least useful principle to app developers and more useful at an architecture or infrastructure level. Hope some of that helps.
Don't buy Rob Percival's or Mark Price's course. It's a joke. I was working full time as an iOS Developer in Objective-C and got the Percival course for $9.99 during Udemy's winter sale and I actually wanted my money back after 10 hours of it. The first 8 hours, he's basically telling you where to download Xcode and how to install it. He burns through SO much time showing you stuff like how to sign up for a Developer account and how to verify your email and all this other useless nonsense and opinionated garbage just to rack up his "video time". Then he gets into his actual tutorial and uses pure garbage coding standards. you can tell he's cooking some over the counter microwaved copy pasta because he literally goes "and then you... uh... UH..." and the video cuts for a second and bam, he types out this huge wall of code and goes "so that's how you do it". He unwraps optionals by default without explaining why or when you should do that, he builds massive view controllers and doesn't teach you proper MVC early on like he should. Your last resort should be Udemy. If you want to pay money, donate to Hacking with Swift, use that, buy BNR to bridge you from Hacking with Swift to iTunes CS193P and upon completion of CS193P, you're ready to build your own application and apply to jobs. 
Don't buy courses from Udemy unless you want to learn web development. The web dev bootcamp by Colt Steele is pretty good. The iOS courses on Udemy are pretty much garbage. Do: Hacking with Swift Big Nerd Ranch iTunes CS193P In that order. That's how I've been learning Swift coming from an Objective-C background and those are resources that are done by people who know how to do iOS development. Especially Hacking with Swift. 95% of the time working as an iOS developer, you're **GOING** to be hacking solutions together. 
IIRC I ran into the same problem, and when I made the app a Cocoa one, it compiled, due to some Swift environment limitation. I decided then to give my command-line tool a user-interface.
If you're going to drop thousands of dollars, you might as well do a physical boot camp. However, I wouldn't even approach a solution like that unless you've had a few months of exposure to the work and decided if you even want to pursue this career. Hacking with Swift and iTunes CS193P are free (although, $25 for Hacking with Swift has been worth it for me, just got it today after doing 1~3 through the website) and will get you at 40~50% job ready and at least enough exposure that you won't drown in a boot camp. Why not do those first and then re approach this decision when you're able to comfortably navigate through Xcode, build stories, write thread safe table views and dynamic navigation trees? I am a full time iOS Developer and I paid $0 for my training. I didn't start paying for training until I got a job and could afford it (I have a $25/month TreeHouse subscription and just bought HWS PDF). The only time I would consider a boot camp as being necessary is if you want immediate exposure to physical connections. I still consider doing a boot camp even after working full time because it would be a great way to get into the bay area. But if I were going to not do it physically on campus at their location, I wouldn't even bother. **EDIT:** Anyone that says "no can do without CS" doesn't know what they're talking about. I have a non-CS degree, my job title is iOS Developer/Mobile Developer and I get anywhere from 5-10 LinkedIn messages per week. Sure my degree is technical (Engineering) but my boss/mentor has a liberal arts degree from a for-profit art school. He knows more about development than my former boss who had a CS degree from a highly ranked program. So ignore elitists. 
Is there a reason you're using the old UIWebView rather than WKWebView (there are some valid reasons to do so)? Where are your delegate methods? They will keep you updated on the status of your page load, and any errors. Have you confirmed you're not receiving memory warnings?
No release date for Swift 3.0 just yet (though you can install a dev build from the master branch of the repo if you're desperate to get started), but going by previous years I'd imagine Swift 3.0 will launch with the next Xcode in about September. As for whether you should buy more books or courses: I dunno. The changes in Swift 3.0 don't look too massive (especially now a lot of the changes to generic types have been delayed), and are more about improvements to ObjC interoperability than anything else. It certainly wouldn't hurt to be up to date with Swift 2.2 before 3 is released.
Basically the same as for any good piece of code. It should be readable, short functions, small classes especially view controllers, not too much indentation. I think Uncle Bob Martin's Clean Code still is a very good book to read even if it's about Java. Amateurs do the following generally in iOS: * Large ViewControllers * AppDelegate doing a lot of different things in detail * MVC layers mixed, which goes hand in hand with Large ViewControllers
For something to be a valid identifier, it needs to be defined somewhere; either in your own code, the Swift standard library, or that Foundation framework you've imported. `randomIntBetween(high:)`, `input()`, and `inputAsInt` aren't defined in any of those. I'm guessing the guide you're following intended for those to be pseudocode that you replaced with your own implementation, in which case you'd want to research how to generate a random number, how to accept user input (hint: `readLine()`), and how to convert that input to an `Int`.
Last time I parsed HTML I did it by hand. Not something I would recommend since there are probably all sorts of decent libraries available these days. Unfortunately once the web moved to Javascript, it became near impossible to parse in any generic way. 
A Command Line application has no bundle so dyld isn't going to find the swift runtime libs. And as those libs currently are not distributed with the OS there's nowhere for dyld to look for them besides in your nonexistent bundle folder. Try playing with the linker settings, etc.
No. Mail/Message composers are tightly coupled to the device and accounts on the device. If the user doesn't have an email service attached in settings, emails won't work for that user.
This sounds like a good idea in the abstract, but keep finding that the easiest way to get my task done is to add forced unwraps. I'd love to see some examples of Swift code that uses forced unwraps, and how to alternatively structure it so it doesn't need them. EDIT: Geez, asking for sample code earns you a downvote here? Tough crowd!
if let foo = bar { } There, you don't need forced unwraps. You can also use guard if you want. It takes an extra line of code, but at least your app won't crash. 
Messy code is usually what bothers me the most. Extra line spacing for no reason, no //MARK:, variables thrown around in between methods, outlets, and helper functions, etc. If you can't organize your code in a meaningful way, I automatically assume you have no control over what you're doing. 
In additional to other things mentioned: * Proper and consistent usage of `flatMap`, `filter`, and `reduce` is a sign that the programmer has good control over the language. * `@noescape` and `@autoclosure` at the proper places * proper usage of generics, typealiasing and associatedtypes * leveraging protocols and protocols extensions over inheritance * usage of `lazy` variables when appropriate, usage of `LazySequences` when appropriate You can do everything without the above, but those who have actually embraced Swift and knows the optimizations they can leverage is what I expect "good" Swift code to be. This is just a small list of all the trinkets you can use in Swift. The more they know, the more "advanced" I would consider their Swift is. Note that this perspective doesn't necessarily mean the person is a good software engineer. A veteran in C++ with 20 years of experience can still be an amateur in Swift. 
I intend to give my command-line tool a user interface, but at a later date. Taking things slowly ;)
I'd regard those as good iOS engineering principles. A 20 year Objective-C veteran with immaculate software engineering principles can still do bad Swift if they don't know enough about the language constructs; For example, if they didn't understand how `guard` works they'd likely have pyramids of `if let` constructs in their code. 
Well, if you can live with the risk of your program crashing and taking the user's work with it fine. But then again why are you using Swift? If you don't care for type safety you could go back to Obj-C where sending messages to nil won't cause a crash. 
On the contrary i think the code example you gave is mostly self-explanatory. The code block tries to extract user entered text from search bar and do something with it. You'd definitely need to throttle the speed of input. and obviously throttling cannot happen on main thread, therefore a scheduler has to be specified. But we all now that UIKit can only be manipulated on main thread, what do we do when the executing thread is not on main thread any more? `observeOn` solves the problem. It brings the observer / subscriber back to the specified thread. I think `distinctUntilChanged` should be self-explanatory too: ignore duplicate data. So the only thing left that is not immediately obvious is `flatMapLatest`. Yes go read the documentation and/or code example on the repo; you need to study on that. Guess what, if you can understand whatever code example given by any library without reading some docs, then the library is either too simple or you are very very good. I've never used any non-trivial libraries without going through some docs and occasionally scratch my head. Lastly all the functions / operators are very common from functional languages and functional style libraries (for example, lodash and ramda for Javascript). The same operator express the same idea for different data structures. For example you can call `map` on array, optional in Swift, or on Observable in RxSwift. And there's a very good theoretical reason (it is somewhat difficult to explain but suffice to say it does exist) the function name is the same and serve exactly the same purpose albeit on different data structure. In other words you can learn the basic concept once and apply it to many places. I guess it depends on where you coming from. If you are familiar with functional programming, this is a piece of cake. Otherwise stick with whatever works for you.
Why don't you post some of your code and let's see if we can improve it.
Yeah that should just be `:T`. Also they should be `@autoclosure $name: () -&gt; T`, too.
`$name`?
There are multiple variations of that argument (small, large, etc.). What strange thing to be picky about, anyway.
I was just confused, that's all. :)
There is no official date for Swift 3. I follow a lot the Swift evolution process, they don't expect it to be released this fall. 
Copy all, thanks! My intent was to make a kid's app compatible with first generation iPad (now to be had for cheap second hand) so parents wouldn't think twice about using it as a dedicated toy. I expect with an older version of Xcode I wouldn't be able to publish, and it didn't occur to me that I would have to work in Objective C (never learned it, don't want to now). A few minutes on eBay proved that iPad 2 (still targetable) can be had for about the same price, so the idea isn't shot all to hell... but it's frustrating. Those devices ARE out there, and they'll be in use for many more years to come. Sucks they can't share in the splendor of my amateur development efforts!
`input()` is supposed to return a `String`. I'm guessing `inputAsInt` is supposed to be `Int(userInput)`.
It would be better done as a handful of small methods in the controller, making it more readable, more self documenting, and safer to edit and extend. 
WWDC is so soon, I would imagine everyone will know more then. You can always follow [swift-evolution](https://github.com/Apple/swift-evolution)
&gt; ears ahead in t So did I. And since I moved to Firebase, the problems started. Right now it's this http://puu.sh/pnjMw/93205f3d0d.png and there's nothing I can do about it. It's just their server is down. But I am considering the idea of creating my own Parse server (as Parse is an open source now) as it's just easier to deal with it. That's my personal opinion.
I'm a dir confused as to the value of this "kit" . All this info is already easy to get via the iOS SDK. Second the name of the kit makes no sense, what assistance does it offer. Frankly it sounds like a name Apple would use for ,more advanced features. 
Feature wise it doesn't do anything special, but it offers a Swifty api (i.e. what the foundation app _should_ be). Naming isn't really important but I agree with you, not much of a kit.
The other problem is that Apple will likely offer a Swifty interface to this data at some point. 
Firebase is awesome, except for the data storage. It's just too hard to add or delete data. They'd better turn it into a database instead of a simple JSON-string.
I started with Parse then moved to Firebase after the news of the Parse shutdown. Firebase is definitely harder to grasp. And the docs didn't help much at all. I had to go find 3rd party , outdated tutorials to piece together what was going on. I never figured out security. I read the document a few times but found it really confusing. Good thing my projects are hobbyist things so no one is gonna go hacking into the DB but yea, i wish the security was easier to understand and setup. I think firebase is proibably the future but the current tools and documentation are so lacking. 
Take a look at UIPanGestureRecognizer. I would first try attaching the pan gesture recognizer to your cocoa touch class. Then test it and make sure it recognises and drags correctly, and also make sure if you 'jerk' your finger very rapidly so that it moves faster than the view that the gesture recognizer doesn't lose its place. (i have no idea if it does or not; my guess would be not, but guessing is so 1990's). If it _does_ lose its place, you'll need to add the pan guesture recognizer to the parent of the cocoa touch class and then you'll have some new challenges because you only want to start panning if the initial touch is inside of your view subclass. Hours of fun!
Noobie here just started using Firebase, and never used Parse before. I know Firebase database is simple JSON format. Could someone elaborate how Parse was better with data storage stuff?
[Previously discussed here.](https://www.reddit.com/r/swift/comments/4cvl8v/what_common_mistake_or_antipattern_do_you_see_the/)
The biggest warning sign for me is one object – usually a view controller – adopting more than a handful of protocols.
Honestly? None. Building a backend with something like Rails API and scale it using something like DigitalOcean when the need arises, is what I'd personally recommend. *Stay in control of your app, end to end*.
You can try this: http://www.appcoda.com/simple-barcode-reader-app-swift/?utm_source=sendy&amp;utm_medium=email&amp;utm_campaign=swift30
Parse has datastorage like a database. So with classes, rows, relationships, queries, etc. Firebase lets you store a JSON-string which is, in my opinion, a little to hard to edit.
Can't recommend this enough.
Arrogance would be insisting on ones' own opinion without citing respected sources - respected sources who can explain better than I can. Maybe you're just bitter about all of this because it hasn't clicked yet. :P There's that part of development that is partially art and SOLID helps conceptual that into words. Like I alluded to, if the guitarist had to re-explain the concept of the A minor scale to his band every time they played, his band would get nowhere and constantly be playing the wrong notes.
Explain that to the 1 star reviewers though :) While theoretically undefined behaviour is bad and a clean crash is good in practice the user doesn't care for that when your crash takes his document he's been working on for a few hours with it. But then again undefined behavior leads to ... well ... undefined results. Maybe a part of the user's document won't get saved correctly, etc. That's why I prefer Swift over Obj-C and why I prefer to do the extra legwork and unwrap-check every optional just to make sure a crash won't happen. Yes, you have to type more initially but the code becomes more maintainable and more safe in the long run.
&gt; Big Nerd Ranch Honestly I don't feel like their Swift book is up to snuff. It's painfully obvious Hilligass didn't write it and a lot of it just comes from Apples examples in their book (which so far I find to be the best Swift book). Their iOS book in my opinion isn't as good as the books of the past, but its not bad at all, just not as good. I feel the challenges aren't worded well and leave too much ambiguity in what they want. 
Short answer: compiler bug. It should be impossible to get an EXC_BAD_ACCESS in Swift without unsafe pointers, threading or calling into non-Swift code. I've seen a couple similar issues related to `indirect` in my own code. Search bugs.swift.org, see if you can see the bug already and otherwise, submit a new one.
AVFoundation is the framework you need. It has classes which allows you to create a pipeline to process video data. You create a pipeline which you attach an input to which typically will be one of your phone or iPad's camera devices. At the output you can attach an output which looks for metadata. You can just configure this meta data capture object to grab a QR code, bar code or some other code. Each of these codes are just an enum, so you can set it up to grab any number of codes. There are a dozen different types or 2D and 1D codes you can scan. It all works like standard Cocoa stuff. Setup things and register a delegate. Whenever some code is identified by the pipeline it calls your delegate and provides so info about what it found and you can then inspect the captured objects to see if it is what you were looking for.
Of course sometimes you need to do it, but where people go wrong is that they keep using it for the same variables again and again within the same function. Unwrap it once and store it in a non-nullable variable. Also use ?? to provide default values instead where that makes sense. The point is to keep the places where you have to do it to a minimum so they are easy to keep track of and control. A stupid thing I see people do is that they create an object and immediately store it to a member variable which has to be nullable, since it can't be set on init. However then they go on performing operations on this nullable member variable. Don't to that. Assign the result to a non-nullable, perform all operations on it and then assign it to the member variable. That way you reduce the usage of forced unwrap to a minimum. // Instead of self.foo = Foo() self.foo!.doStuff() self.foo!.doEvenMoreStuff() // write let foo = Foo() foo.doStuff() foo.doEvenMoreStuff() self.foo = foo Why does that matter? It is about mental overhead. With the latter approach anybody reading that code never has to consider any forced unwrap. Any statement using a forced unwrap is a potential problem statement. 
Dropdowns are for HTML. Your picture shows a UITableView with collapsible sections. Use one section for each question and then programmatically collapse and open the next section after each response. 
I mean... That's fair and I will concede they aren't all intuitively named. But just because someone made it an acronym doesn't mean it has to be learned, valued, used, and remembered via an acronym. E=MC2 is catchy but it doesn't help me understand physics, ya know?
Thanks! 
Hmm, maybe it's time for a new acronym and better short explanations. E=mc^2 should help you understand physics somewhat though :P
In the past I have linked to posts that I have done that offer a list of resources for helping people learn Swift and iOS development. Since then I have gone back, combined all the separate posts into a single article, updated some comments on some of the resources, added new ones, included links to proper book reviews that I have done, and included sections on what type of learning might be best for you, and a list of resources that someone could start with if they really had no idea where to start. A lot of the suggestions and recommendations have come from feedback that users in this subreddit have left. So if you have any comments, suggestions on resources you think should be on the list, or thoughts on what resources worked best for you definitely let me know. I am continually updating this guide and always looking to make it better and more useful to newcomers to Swift.
You can use a UICollectionView inside of a cell to achieve this.
The Parse backend is open source though.
Why would you do it??
No, you can remove it from sale while you wait for approval. I once pulled a very popular app from sale while waiting for expedited review because of a critical data loss bug. Review is unrelated to availability.
This was exactly what I needed. Didn't just give me code to copy and paste but instead explained exactly what was happening. Would you have any suggestions for resources on how to draw a highlighted section around the barcode when detected? 
&gt; import UIKit &gt; &gt; let path = UIBezierPath() &gt; let cg = path.CGPath how's about the other way around? can you make a UIBezierPath from a CGPath? 
Super helpful for someone coming from a c and COBOL background to learn Swift. I'm half way through BNR's book and can't recommend it enough. Hacking with Swift is next on the list, then the Stanford class. I'm glad to see that path outlined in your article. For more advanced stuff I'm still deciding if/which online site to try. I've checked out Udacity, Udemy, Plutalsight, Coursera, and Treehouse. I like structured and this is only a hobby for now, so Nano degrees might be the way to go. Thanks for posting!
To build an app as trigger
This would be perfect for UIPresentationController and an interactive transition animation. No need to subclass.
Hold power button until the slide to turn off appears, then hold home button for some secs. Done. Cache cleared (in case you are talking about RAM cache) And about creating an app for that with swift, I'm not sure but don't think it's possible, and if it is it would probably not be accepted in App Store. The thing is that you don't have to clean the cache. Like, never. This is android paranoia. Works like that: Person with android sees person with iPhone and wonders why his phone is not as fast and responsive as the iPhone (since he got a phone with 3747373 cores and 64gb of ram). Then he looks on the Internet and finds out about cache, background apps, multitasking and etc. Without real knowledge of how this things works (and with the "help" of misinforming article), the person starts to believe that it must close all the apps and services not in use every time (which was "true" for android for sometime, but never for iOS). One day, this person goes out and buys an iPhone, but still have this paranoia. Let me clarify: iOS handle all the background tasks, apps, services and cache on the run, as it's needed. Of course there will be thousands to disagree on what I said. There's no problem. People are free. What I just wrote is true anyway. If you are interested, go and do some deep research about the OS and how it handles these stuff. Just be careful with what you read. People nowadays with no knowledge about what they are writing have main roles in informing the world about technology 
Cool little project. Reminds me of something similar in the Spotify app.
The general question for this is whether or not you prefer composition over inheritance (as you should). Protocol-oriented programming is a good way to build composable objects instead of doing lots of inheritance. Instead of building objects based on what they ARE, you're trying to build objects based on what they DO. If done right, you should have less coupling between the objects so when you inevitably need to make changes it's going to be easier and safer to do. Good explanation: https://www.youtube.com/watch?v=wfMtDGfHWpA 
Are you using auto-layout? It may be messing with things when you change the text. See this as an example: http://stackoverflow.com/questions/26953966/with-autolayout-label-position-is-reset-when-i-change-label-text-solved
In reality the guy you give your laundry to doesn't know what the best laundry place is, he'll ask the KnowsBestLaundryPlaceGuy and then the KnowsFastestRouteGuy will tell them to go with BusDriver, TaxiDriver or SubwayDriver. At the best laundry place he just passes your laundry to the LaundryWashingGuy that works there because the guy that picks up your laundry surely would mix red socks with white shirts. So instead having all that knowledge inside the laundry guy because he promised you he would know about speaking English, washing clothes, paying money, finding cabs and all that stuff in protocols he just hands that stuff over to smarter people than him specialized in doing that stuff. The nice thing about protocols is that the BusDriver, TaxiDriver and SubwayDriver all understand what GetMeThere means. You could give our laundry driver a new driver called UberDriver one day and he wouldn't notice. But slapping more than two pushing it three protocols on a class is usually a disaster. The real advantage is you can mock tests easier with Swift this way.
Brilliant response!!
You're totally right! Thanks a lot.
Love the laundry example. So nuanced but clear.
A Java "interface" is the same thing as a protocol in Objective-C and Swift. (Well, nowadays Java interfaces have some additional features, but traditionally they were the same thing.) A Java exception is analogous to an `ErrorType` in Swift or an `NSException` in Objective-C.
Hmm yes, this confused me because it explains how protocol-oriented is superior to OOP, but protocols (or interfaces) is one of the cornerstones in many common OOP languages. They are important concepts in both Java and C# for example. Their standard libraries are littered with them, yet these languages are not "protocol oriented". Is it really about "lean towards interfaces/protocols rather than inheritance" being a recommendation by Apple / pushed by Swift? However I'm not really convinced. OOP languages often have both inheritance and interfaces, but use them for different reasons. Interfaces for traits, inheritance for "a special kind of" relationships. The upside with inheritance is if the base object is complex and you just want to add a few things. With an interface, both different objects would need a full implementation. With inheritance, just what is "special". But yeah, just like a special kind of car demands some knowledge about how it compares to a normal car (i.e a faster car needs to know that modifying a maximum velocity property as defined by its parent makes it fast), you often need the same in an inherited object.
haven't you merely described options to how you call your object? i.e. protocol-oriented is merely object-oriented with a bit more control. how is your example any different to driving a car by putting the gear lever in Drive .. as opposed to driving the car by manually using the gear level to add control over what gear the car is in at any point in time? in both cases you are interfacing with the Car object, but in the latter case you are taking a bit more interest on how things will be done. 
Most languages, not just Swift.
A protocol (which is a first class type in Swift, like a class in most languages) specifies what it can do without specifying how to do it. A class specifies both what it can do and how it will do it. Protocols are more flexible because they don't require implementation; they just do something sensible (hopefully) based on the names of their methods. Protocols allow you to specify (i.e. tell the compiler) that a given variable will be capable of certain functionality without worrying about how it will do so; you can write any class conforming to the protocol and plug in an instance of that class for that variable. This makes your code more modular.
Do you have any dev experience?
They are not diametrically opposed, but that they were so intimately related was also not the point I was getting after. Notice I didn't talk about "adding" anything to OO [this is not OO++], I talked about *generalizing*. Practically, most developers aren't interested in "lower-level" details like the particular algorithm, or underlying data structure, or memory model, etc. of a component. They care about how to use it; they just want it to work. To take your example, a protocol lets you talk about a common set of operations anything that even wants to call itself a car has to support. 
ok thx so how would you describe the person who wants his clothes laundered, but wants to stipulate that the laundromat uses machines powered by solar energy as opposed to coal .. because of some other agenda. in this case, his definition "i just want it to work" .. i.e. clean clothes .. comes with some boundary conditions. the more conditions imposed suggests the the "i just" part of the quote no longer applies. 
touche. 
Thanks, this solves part of my question. another part is how can I schedule some task to run in background so I can upload the data even when user is not using the app?
Swift functions can only return one type so I don't understand what you are talking about
Just slap everything into `UILaundryGuyViewController`and you'll be fine. No need to muck about with all these other classes/protocols. 
If you're starting from scratch, I would recommend building your own backend and ignoring Parse altogether. If you're not migrating from an existing Parse backend, you may as well take full control and start with a very minimal backend that you can build on top of. I would recommend using Python and Flask, since this stack has a minimal amount of dependencies and you can add libraries as you need them. For example if you need RESTful endpoints, you can add Flask-Restful. If you need a good database ORM, you can add SQLAlchemy. But even before adding any of those libraries, you can quickly create a bunch of endpoints and have a backend up and running with just one Python script. I think having control over your own backend and server is worth it. Yes, if you want to scale your app you'll have to learn more about servers and databases (if you don't have experience with that kind of thing), but that's much better than trusting such an important part of your infrastructure to a third party.
You'd be better off building your own backend if it is a big project, you'll have independence and more flexibility. I would recommend using ruby on rails, with following gems: Devise token auth: for user management Paperclip: for user files management Rack Cors: to enable cross origin requests For databse, i would recommend postgres
Try background task. https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplication_Class/index.html#//apple_ref/occ/instm/UIApplication/beginBackgroundTaskWithName:expirationHandler:
Treehouse do a tutorial on this I believe 
Why Ruby on Rails? If he's able to choose anything I think Python and flask or Django are much better. Django has a fantastic rest api (Django rest framework)
Or Django! Although really depends what he wants to build and flask would be much better in some situations...
Going through this right now. Probably going down firebase route so I can get it out the door. When it takes off, I will build a custom solution. Things change when it's in the wild and I don't want to sink time into assumptions of what I think I need. 
I did it php and mysql. I wish I used Python 
Is the IBOutlet for myWebView connected? I threw your code into a playground and the myHTMLString wasn't nil so it likely isn't that. You also have a lot of force unwraps, for safety it is a good idea to throw some guard statements in there to unwrap those optionals so you can use them safely, and then handle the error case when they are nil.
You've definitely definitely installed the dependencies? I get that error if I try to launch Swift without clang et al.
You still need to remove the `!` after `myHTMLString`
I've used [this util](https://github.com/PaulTaykalo/objc-dependency-visualizer) to generate an interactive dependency graph of my swift projects before. Don't know if that meets your needs, but the setup is quick so you can try it out easily.
Finally! I was getting ready to respond with the same answer. Everyone thinks protocol based design is this brand new approach to designing apps but it's been around for 15+ years now. Most are just not aware on how to architect their apps properly but interfaces have always been just as important, if not more, than base classes. Thankfully Apple is helping to promote this approach more visibly now since adopting it with Swift. Now if only they would do the same with promoting MVVM!
Why? What setbacks/challenges did PHP bring? Having to make the same decision myself pretty soon.
I had to learn from scratch when I already knoww Python. Also security in PHP is a total bitch
You have any good tutorial on that?
&gt; guard let myURL = NSURL(string: myURLAdress) else { return } This isn't very good in this context. If the source of the string is a hard-coded URL in the application (as it is here), then failure to parse this as a URL is a developer fault not a runtime error. In these cases, it's better to fail fast and be explicit about what has happened. This code merely hides the mistake. That leads to difficult to debug problems and the possibility of mistakes making it into production. This would be better: guard let myURL = NSURL(string: myURLAddress) else { preconditionFailure("Configured with an invalid URL: \(myURLAddress)") } If the URL comes from user input or is otherwise sourced at runtime, then that's a different matter. But even in that case, simply ignoring the problem is still not usually the right approach. You'd want to throw an error so that you could handle it wherever the bad URL came from. 
It's an Apple/Swift recommendation. Swift makes extensive use of value-types, which have no inheritance. If you want to abstract across different value-types, or you don't care if it's a value or class, you need protocols. Maybe other languages don't emphasise it so much because their value types are not as richly-features as Swift's. For example, Collection is a protocol and Array, Set and Dictionary are structs. If I wanted to iterate over some generic collection, I couldn't do that any other way. Swift protocols in this sense replace abstract/virtual classes. Protocols are probably a better fit for that anyway.
I have a cloud storage app in the App Store with a back end written from scratch in a couple of hours(rails new - deploy) and I love it. The Rails API is so simple and there's a gem for everything I don't have the link but Google "Aaron Krause rails API" it's a great start. Or my github Hart87 and its stormioBE
Look at NSFileManager you can get access to the documents directory and the temporary directory for the app - you can delete its contents from those file handles.
You have to create an outlet in the view controller, from there you get an instance variable where you can assign a property of it to something. To create an outlet, control + drag the item to the view controller
Sounds like a bug to me. I'd file an issue. Calling super methods that return `Self` should return the `Self` type, not the superclass type.
Here is an example of someone doing that through the treehouse tutorial that kid mentioned - https://github.com/tordasnes/Snapchat-clone and here is the tutorial https://teamtreehouse.com/library/build-a-selfdestructing-message-iphone-app
[**@twostraws**](https://twitter.com/twostraws): &gt;[2016-06-12 11:36:52 UTC](https://twitter.com/twostraws/status/741957437511602176) &gt;[#WWDC](https://twitter.com/search?q=%23WWDC) is almost here, and to celebrate I’ve discounted my [#swiftlang](https://twitter.com/search?q=%23swiftlang) books for the first time ever – save 50%! [*hackingwithswift.com*](https://www.hackingwithswift.com/offers) ---- [^[Mistake?]](/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/4nriek%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/joealcorn/TweetPoster) [^[Issues]](https://github.com/joealcorn/TweetPoster/issues) 
Declaring variables such as var sentence: String! Is just asking for trouble. Don't use implicitly unwrapped optionals (except for `@IBOutlet`s) and don't force unwrap optional values. It will make your life a lot easier!
That actually helps clarify the situation a lot to me, thanks. Java and C# don't rely on value types nearly as much and only use protocols/interfaces whenthey need to give potentially wildly different classes (i.e. not "kind of" compatible where inheritance is suitable) certain common "traits". Equatable. Comparable. Sortable. Stuff like that... This whole discussion has been pretty enlightening to me. I come from a 2000's background where Java was all the rage, so I guess I still had the Java perspective on all this and thus got pretty confused when I had a simplified view of Swift, thinking it was yet an object oriented language of the same branch as Java or C#. There are clearly many more factors that influence protocols vs inheritance and why inheritance may even suddenly be problematic in a more value-heavy language like Swift. This also helps me realize why Rust is going with "traits" and Go also being very interface-oriented. It seems like a more modern way of abstracting types in a sense.
I've already did that, but the type is selected as UIControl . However, it only allows me to change the properties of the outlet. For example the background color of the view object (I assigned the class to a view object). If I select the class itself as type when creating an outlet, it gives me an error regarding **weak var**. If I select **strong var** , I get the **Use of undeclared type 'handle'** error. If I try to import my handle class as `import handle` I get the error of **No such module**
You could just use a normal optional instead.
When I define it as follows `@IBOutlet weak var handle: handle!` I get the following errors **Use of undeclared type 'handle'** **'handle' used within its own type** **'weak' may only be applied to class and class-bound protocol types, not '&lt;&lt;error type&gt;&gt;'** Note that I change the subclass of the handle from UIControl to UIView 
Yeah just rename the class to Handle with a capital H and let me know what the error message says
You would specify this in the class that implements the protocol (or another protocol that inherits from the first). Remember protocols designate what can be done and a default way of doing it. If you need a specific implementation then your class or another protocol should handle it. Use protocol to add functionality to objects of various types that don't share inheritance between them.
Did you do weak var Handle: handle!
While you could do a lot of work to try and capture this all in memory, you're really going to want to write the file to disk and then upload it. Unless you're thinking about doing something much more advanced, like streaming the file live (similar Periscope)?
&gt; I've also held off on Pro Swift, but I like how the author posts on Reddit and provides Hacking With Swift for free. I will probably end up buying it at some point if/when it goes on sale. [You inspired me](https://www.reddit.com/r/swift/comments/4nriek/50_off_all_paul_hudson_books_announced_in/) :)
Hah, I actually bought it a few hours ago when I saw the post :p
Oh I confused the first handle with the second one. Yes this way it worked well. Now I can reach to variables. Thank you.
Jumped on this. I started going through Paul's website last week to get my feet wet with Swift (Java background here) and its so much better than following youtube tutorials that can be hit and miss and just don't go into the same detail explaining what the code actually does. Highly recommended!
You should probably do some research on who Erica Sadun is.
Here is something that is similar to what you are doing https://github.com/miwand/30-Days-of-Swift/blob/master/MyLittleMonster/MyLittleMonster/MonsterImg.swift The whole project can be found here https://github.com/miwand/30-Days-of-Swift/tree/master/MyLittleMonster. 
I am a coding bootcamp grad from a school here in Miami. I am happy I did the bootcamp but as I start to learn things on my own I realize I could've saved myself a boat load of money. If I were to do it all over again I would've learned on my own OR went to a bootcamp that guarantees you a job with a money back guarantee. Udemy / Treehouse / Piratebay are majority of the sites I use to learn. Tutorials are easy to find on Youtube / Google. Also be on the look out for meet ups. Those help out alot! (www.meetup.com) Best of luck :D
I don't think that is crazy amount, but where are you getting this info from? Yelp does not allow you to store their data and it is against their policy. Foursquare allows for storage of data up to 30 days. You also have to think about if data is changed, for example the store changes its hours or it is closed or a new store is added. Are you going to manually add new stores to that list? And if so, you will have to do a new release on the app which will take some time before it reaches your users. It just does not seem feasible to store such data inside the app rather than saving it to say firebase and then getting the data from there or just making a call to an API to get that data.
Thanks and how come they get jobs after that course? 
how is knowing python retarded?
no it's not, everything this you're saying is retarded
Try this https://makeapppie.com/tag/arc-graphs/
thanks! bought the objective-c book.This is the only book I could afford for now. 
Both Flask and Django are good choices for building APIs quickly. Lots of nice 3rd party packages, very good tooling support and lots of tutorials on the net. If you need more performance than Golang might be another option. I am currently evaluating it myself as an alternative to Flask. 
That is pretty impressive Swift does that well just using threads. I would like to see how it does using coroutines, like [Zewo](https://github.com/Zewo/Zewo), or Grand Central Dispatch's dispatchio.
This is the first time I've seen a bump on Reddit. 
Last time we (Zewo) ran performance tests, we significantly outperformed the other server-side-swift players (Vapor, Kitura, Perfect). However, that was a long time ago and since them I'm sure their performance has increased, so the tests should be rerun. I'll try to run the tests and report back with recent results. Keep in mind: with Swift's optimizations currently broken on the latest toolchains, Zewo suffers significantly since it is broken up into so many modules. Very impressed that Vapor outperforms a lot of other frameworks regardless. 
&gt;Benchmarks are always in-accurate and biased. I'm not sure this is valid or contributory criticism of the article at hand. You'll need to point out any problems with the article more specifically. Such a claim would be true of any scientific experiments -- however publishing findings and methodology and allowing peer review is a good way to minimise error and bias, which is exactly whats happening here. &gt;These guys are not experts in all the frameworks they tried and therefore probably wrote them incorrectly. Did you just assume that or is there a red flag that suggests it?
When you write that this is unoptimized... How bad is that? I remember easily getting 100x performance by running with optimizations on OS X on some toy project I wrote....
I'm of the mind that well written multithreading code is always the fastest of the different asynchronous programming styles. But it's easy to screw up and give yourself huge performance / debugging headaches. Spawning too many threads is *way* more expensive than spawning too many coroutines. I think languages like Haskell have the ideal approach; use stupidly fast green threads and keep the burden of efficient threading on the runtime. EDIT: To exemplify this, you can launch literally millions of Haskell threads and still not see any major performance hits. I'd really love to see green threads of this caliber make it into more languages.
I'm just getting into programming, how good would this book be for a beginner and not someone who has done any sort of programming?
Sorry I was in a meeting that started early when I typed that or I'd of given you a better response with code. Glad to see it worked for you! Incase you didn't see this in the documents anytime your view needs to redraw itself you call ".setNeedsDisplay()" . There's also .setNeedsDisplayInRect() for when you want to update a small portion of your view. 
lol, i'm really stuck with this one :) 
I don't as of now, but I think its great your still working to improve your tutorials! I hope that from doing all the tutorials that the repetition of learned concepts will make me internalize it. I just tried to make a tableview for the challenge part of project 4 and got lost. 
I am surprised that a Swift server side framework can beat C# and Java based ones. They have nearly decades of optimization and development behind them. I really would not have expected Swift to challenge Java and C# in this space. I had expected this to at least take a couple of years more.
This should give you a heads start: https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIImageView_Class/#//apple_ref/doc/uid/TP40006889-CH3-SW8
Yes – it will install side-by-side with Xcode 7.3.
Full API diffs: https://developer.apple.com/library/prerelease/content/releasenotes/General/iOS10APIDiffs/index.html Broad overview: https://developer.apple.com/ios/
awesome, thanks
What's new in Xcode? Can it do stuff that Visual Studio can do for years like implement protocols?
Definately looking forward to this talk
This is interesting. I am looking to get into coding and Swift, from what I have seen so far, is the language that aligns with what I want to achieve. Are these books good for beginners who only have previous experience with HTML/CSS to begin learning swift on?
Is this how you get the iPad Swift Playground Beta app?
It promises simplified signing and an improved Interface Builder that lets you change interface sizes easier. Welcome changes. Let's see how my Swift 2 apps hold up in Swift 3 :) Download takes forever - 5 hours more to go?? What?? 10 hours now? Guess it'll be christmas tomorrow morning...
Swift is compiled, this makes a huge difference.
What's new in Xcode (may require paid dev account): https://developer.apple.com/library/prerelease/content/documentation/DeveloperTools/Conceptual/WhatsNewXcode/introduction.html#//apple_ref/doc/uid/TP40004626 I haven't tried running or building anything, as waaaay too much stuff breaks right now.
If I save the file like you said would it be permanently stored there or would it delete as soon as the app closes?
At this price it's worth buying all 3. Thanks 🙂
Available this fall
https://developer.apple.com/library/prerelease/content/documentation/Xcode/Conceptual/swift_playgrounds_doc_format/index.html#//apple_ref/doc/uid/TP40017343 You can download an example project....perhaps you can run it in Xcode as well?
Can I get iOS 10 beta without paying for a developer account? Just having a free one?
Thank you! This is exactly what I was looking for. 
Looks like Apple's version of scratch. Looks very cool.
Hm, didn't know that. The rest of my point stands. Well implemented green threads are the best system in terms of raw performance.
Interesting. It's kinda hard to do a talk on web servers without a web library. I wonder if they'll just use one of the new open source ones like Vapor, or if they'll roll their own. It would be uncharacteristic of Apple to essentially demo a 3rd party library in one of their WWDC sessions.
Yes, you can learn Swift as your first programming language - programming languages are easy, and Swift has very clean syntax, which will help. The challenge will be in learning data structures, algorithms, design patterns, and APIs. That's going to take a while, but that's true in any language.
I think you just have to run the iOS 10 beta on an iPad for that.
You can in about a month when the public beta releases.
Hive, protect the queen!
Got stuck with Nimble and Quick... heh...
If you want to learn it. Why not just try?
How much are you paying?
As far as I know the learning resources that exist are for programmers to learn Swift, not for people to learn programming using Swift. This is part of 'the challenge' KyleCardoza talks about. Vis.. I can point you to resources about learning data structures, algorithms, design patterns, problem solving and the like.. but they are in a different language to Swift. Many new people think learning a language and learning to program are one in the same, but they are very different things. Once you learn how to program, if you learn a language of the same paradigm (design methodology/principals) as one you already know, you can transfer your knowledge to that new language very easily.
Learn how to code in Swift -&gt; https://www.weheartswift.com/swift-programming-scratch-100-exercises/
&gt; It would be uncharacteristic of Apple to essentially demo a 3rd party library in one of their WWDC sessions. To quote the session description "Come for an overview of available projects at Swift.org and examples of the community in action." That sounds a lot like third party. 
Here you go - https://github.com/cargath/WWDC2016-Xcode-Color-Scheme
These are quite hard for someone who has never coded before.
&gt; Full API diffs: https://developer.apple.com/library/prerelease/content/releasenotes/General/iOS10APIDiffs/index.html Oh shit. Another game of "find the real differences among case changes". And this time in extra hard mode, because apparently every single function has changed 
Xcode*
That whole fucking session was hard agenda pushing and pretty cringe worthy. Also two adults playing 15 minutes with emojis pretty much gave me the rest.
Or just read the article I wrote: [what's new in iOS 10 for developers?](https://www.hackingwithswift.com/ios10) :)
What a party pooper. I am a professional software developer but I have kids and I care about other people than just my own needs. This looks like a great way to get more people into enjoying programming which has given me joys over many years. To grow the Swift developer community we need things like this. As for Xcode being lightyears behind the competition. That is just silly talk from people who thinks all an IDE does is refactoring code. To just take Jetbrains as an example since I know that best. Jetbrains is far behind Xcode on everything besides code refactoring and navigation. If you want to do performance analysis, static analysis, debugging, inspecting GUI at runtime, thread and queue usage, configure your build system, design a GUI, internationalize your app, build a scene graph, manage assets, create visual effects etc then xCode and apple tools are going to be a better choices.
This is something I've been hoping for since I heard of Swift Playground on Xcode. However, I wished for it to be more like a scratch pad for developers to test new ideas and not a tool for kids but hopefully it can be used for both :)
It's an XAR archive, not a zip file. Perfectly safe.
I can't remember a time where I wanted to downvote someone twice...
Check out Skip Wilson's YouTube series Swift for Absolute Beginners. He explains the fundamentals of programming very well but in a swift context. 
You can also check out this post that I did as well over at https://manitoba.ninja/2016/06/10/a-beginners-guide-to-self-taught-swift-and-ios-development-edition-2-0/ take a look through there as I created the guide specifically for newcomers to programming.
Usually those were .dmgs
Yeah but on a lot of the Cocoa pages for example, there's no toggle..
They specifically called out FreeBSD, Android, and Windows in the Platform State of the Union talk.
Are you similarly upset when they use a "developers conference" to announce such non-developer-specific products as new faster laptops, desktops, or (heaven forbid) wifi base stations? Or when they have a DJ or band play?
Dude... You are comparing MacBooks with larger emojis. 
It's an agenda of, "Hey, let's make it easier for people to learn to code." I don't see any problem with that.
This will *definitely* be in the book – thanks!
Just purchased your book the other day and I'm looking forward to the updates. I'm pretty excited about being able to zoom out and still work in interface builder, the new size assistant, the cutdown verbosity. Are you also going to update Pro Swift to Swift 3? I just purchased it.
Good of you to share this, though unfortunately I don't think it's a good idea to host links to copyrighted material in /r/Swift. I think users may just have to find it via their own means! :P
Can confirm thanks!
The zoom feature is such a simple change, but it's a huge deal for laptop users like me – it makes storyboards so much easier to manage!
It's no where in Xcode.app, hence why I shared it. No harm done if you remove the post. I understand, just made a bunch of people's lives easier.
There's a manual page for it: 'man xip'
Oh, I think he means things like 15 minutes of Emoji demos. Not that Swift is too easy to learn.
Every 48 hours for the rest of time or is there some specific end date?
Has anyone tried out the swift windows port? I'm very interested in this for a pet project.
You should crosspost to /r/programmerHumor
They will never be "officially" supported. Swift is open source now, and open source engineers have ported the language to other platforms. That's as official as it will ever get, but that's not a bad thing at all. 
I haven't looked at the shipped preview yet but I do see that [SE-0069: Mutability and Foundation Value Types](https://github.com/apple/swift-evolution/blob/1116f49cba960762be9e77af026d3e41e3cef0d7/proposals/0069-swift-mutability-for-foundation.md) is accepted for Swift 3; it seems like that means the implementation is complete, so it should be imminent if it's not in the current preview. Note that the value types seem to be coming in with their original NS-prefixed names. The proposal to rename them is tracked separately in [SE-0086](https://github.com/apple/swift-evolution/blob/476d420157eb7d0eef776f75cbb935e5d8783dc5/proposals/0086-drop-foundation-ns.md), which is still under review.
I'm sorry that I don't, but this is only one of many reasons to not Storyboards or Interface Builder. Without them you can write custom constructors/initializers.
You know you can set properties on a viewController after it's been instantiated, right? It's cleaner and WAY more readable that way.
irc.freenode.net #swift-lang
The best place I have found so far is on Twitter. If you start following people like Chris Lattner, Natasha "the Robot" Murashev, Chris Eidhof, Ayaka Nonaka, Peter Steinberger, Ash Furrow, Gwendolyn Weston, to name a few off the top of my head, you are going to find some of the best insights on WWDC and Apple development in general. Yes I know that it isn't a forum but I cant say that I have come across a forum yet that offers the diversity of opinions and ideas as a well curated Twitter feed.
Yes, it says in the requirements "[You must have an Apple Developer Account](https://developer.apple.com/reference/applepayjs/)"
From what I've heard the migration tool was really good for converting to the new syntax/method naming. Care to try it and post results on your projects?
any other resources you would suggest for a beginner 
They are in the Foundation framework. 
Fair enough, you are entitled to your opinion. I just started part-time on the side of my start-up. My experience has been positive so far, but I come from the curriculum design and can't say how much development occurs for students yet since I'm new to it. Personally, I just graduated computer science from a formal university and would agree that I could have learned most without it (and generally did learn through stack overflow more than class).
ok thank you :)
We dont need cocoa pods to use all those open source projects, but we still use it :) Maybe its just me(strong java background) so i always go in favor DI.
I dont agree, without manager you need to think about * object scopes * thread safety * circular dependencies If you work on app with 15+ modules (separate functionalities) dependency manager is great way to provide dependencies. If you dont mind, provide an example of good design without something that looks alike dependency manager. On app(android) i worked on, i picked to not use dependecy manager. It worked but it could be much easier if something did heavy lifting for me. On same app(ios version) i decided to use Swinject and so far its working.
Would one something need 15 modules?
So long as you can install iOS 10 (which the iPad 4 supports), it'll come pre-installed with the beta builds of iOS.
Yeah. Lets wrap it up, dependecy injection is way to go, with manager or not.
Don't disagree with you on that ;)
Is anyone else super stoked for SiriKit? iOS 10 looks awesome overall but leveraging Siri is going to be so cool!
One more thought, do you find the example used in this blog post to be a better introduction? https://corner.squareup.com/2016/06/cleanse-swift-dependency-injection-framework.html
The "What's new in Security" session talked at length about distribution of applications on macOS. One of the things it talked about was .dmg's and .zips in particular. My hunch is that Xcode needed a way to distribute and .xip fit the bill. .xip isn't new, I believe it shipped in 10.6 or 10.7! Suspicious Package distributes as a .xip (http://www.mothersruin.com/software/SuspiciousPackage/) Note the talk refers people to Signed DMGs, new in 10.11.5. 
Then you probably want to add an extension to UIStoryboard with the init method of your choosing. 
Thats my goal! glad to hear that.
You can join the ios-programmers slack channel, but there's not a huge amount of wwdc chatter there either. www.ios-developers.io 
Swift 3.0 will probably break it
You might enjoy NSHipster.com.
still looking for these too :( haven't found anything about it
Nothing wrong with some Early morning humor; it should always be appreciated. Lighten up.
Ouf, trying to wrap my head around it. So my understanding is that the NS prefix is dropped for * NSAffineTransform * NSCharacterSet * (NSMutableCharacterSet) * NSDate * NSDateComponents * NSData * (NSMutableData) * NSIndexSet * (NSMutableIndexSet) * NSIndexPath * NSNotification * NSPersonNameComponents * NSURL * NSURLComponents * NSURLQueryItem * NSUUID And the mutable versions are dropped completely and are implicitly created when we declare a variable using the 'var' keyword. Is that correct?
Are books of this guy really worth it ?
Open up Playgrounds and work your way through the Swift 3 Programming Guide https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html
like this? view.addSubview(progressView) 
Sure! It is quite long: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swiftc -incremental -module-name CompilingTest -Onone -dump-ast -sdk /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS9.3.sdk -target armv7-apple-ios9.3 -g -module-cache-path /Users/frs/Library/Developer/Xcode/DerivedData/ModuleCache -Xfrontend -serialize-debugging-options -embed-bitcode-marker -enable-testing -I /Users/frs/CompilingTest/TestBuild -F /Users/frs/CompilingTest/TestBuild -c -j4 /Users/frs/CompilingTest/CompilingTest/ViewController.swift /Users/frs/CompilingTest/CompilingTest/AppDelegate.swift -output-file-map /Users/frs/Library/Developer/Xcode/DerivedData/CompilingTest-fzlntnegzxcfpeftmnshzyumyuzq/Build/Intermediates/CompilingTest.build/Debug-iphoneos/CompilingTest.build/Objects-normal/armv7/CompilingTest-OutputFileMap.json -parseable-output -serialize-diagnostics -emit-dependencies -emit-module -emit-module-path /Users/frs/Library/Developer/Xcode/DerivedData/CompilingTest-fzlntnegzxcfpeftmnshzyumyuzq/Build/Intermediates/CompilingTest.build/Debug-iphoneos/CompilingTest.build/Objects-normal/armv7/CompilingTest.swiftmodule -Xcc -I/Users/frs/Library/Developer/Xcode/DerivedData/CompilingTest-fzlntnegzxcfpeftmnshzyumyuzq/Build/Intermediates/CompilingTest.build/Debug-iphoneos/CompilingTest.build/swift-overrides.hmap -Xcc -iquote -Xcc /Users/frs/Library/Developer/Xcode/DerivedData/CompilingTest-fzlntnegzxcfpeftmnshzyumyuzq/Build/Intermediates/CompilingTest.build/Debug-iphoneos/CompilingTest.build/CompilingTest-generated-files.hmap -Xcc -I/Users/frs/Library/Developer/Xcode/DerivedData/CompilingTest-fzlntnegzxcfpeftmnshzyumyuzq/Build/Intermediates/CompilingTest.build/Debug-iphoneos/CompilingTest.build/CompilingTest-own-target-headers.hmap -Xcc -I/Users/frs/Library/Developer/Xcode/DerivedData/CompilingTest-fzlntnegzxcfpeftmnshzyumyuzq/Build/Intermediates/CompilingTest.build/Debug-iphoneos/CompilingTest.build/CompilingTest-all-target-headers.hmap -Xcc -iquote -Xcc /Users/frs/Library/Developer/Xcode/DerivedData/CompilingTest-fzlntnegzxcfpeftmnshzyumyuzq/Build/Intermediates/CompilingTest.build/Debug-iphoneos/CompilingTest.build/CompilingTest-project-headers.hmap -Xcc -I/Users/frs/CompilingTest/TestBuild/include -Xcc -I/Users/frs/Library/Developer/Xcode/DerivedData/CompilingTest-fzlntnegzxcfpeftmnshzyumyuzq/Build/Intermediates/CompilingTest.build/Debug-iphoneos/CompilingTest.build/DerivedSources/armv7 -Xcc -I/Users/frs/Library/Developer/Xcode/DerivedData/CompilingTest-fzlntnegzxcfpeftmnshzyumyuzq/Build/Intermediates/CompilingTest.build/Debug-iphoneos/CompilingTest.build/DerivedSources -Xcc -DDEBUG=1 -emit-objc-header -emit-objc-header-path /Users/frs/Library/Developer/Xcode/DerivedData/CompilingTest-fzlntnegzxcfpeftmnshzyumyuzq/Build/Intermediates/CompilingTest.build/Debug-iphoneos/CompilingTest.build/Objects-normal/armv7/CompilingTest-Swift.h -Xcc -working-directory/Users/frs/CompilingTest 
&gt;I recently took an internship for the summer &gt;I need to make an iPad app for them. &gt;my boss wants me to use AWS sdk for the app because they are using that web service &gt;I'm not too familiar with AWS's sdk so could anyone explain what language would I have to make the app in Speaking frankly, you are probably biting off more than you can chew in 2 months with no local guidance. By "local", I mean a mentor on site with you daily guiding you through the project as they lead it and you (as the intern) do "intern things" on the app. Do you understand the business? Do you have detailed requirements? If not, then you are flying blind. I would see if I could reframe the project into something like you: - Gather requirements for an iPad app - Make a complete set of wireframes for the iPad app You can probably do those. Those two tasks alone will keep you *very* busy for 2 months. Gathering requirements, figuring out XCode, learning Swift, learning what Apple frameworks to use, learning to use the cryptic AWS framework, negotiating AWS, setting up AWS credentials, setting up your AWS data store, coding, testing, deploying...aren't gonna happen. It's ambitious, but that's asking a lot of a seasoned developer, much less an intern who may not have experience doing so. Go back and say that you are probably in over your head as you have figured out being that you made this post!. It's *much* easier to say it now than to say it in 2 months as you deliver nothing they can use. If you gather the requirements and maybe make wireframes, they can use that to make the app later and you get some *very* valuable experience.
iPad 4 does not support Swift Playgrounds, I guess. &gt; Starting today, Swift Playgrounds is available to Apple Developer Program members, and will additionally be available in the iOS 10 public beta this July. The final version of the app is expected to launch for free on the App Store sometime in the fall. All iPad Air and iPad Pro models will be compatible with the app, as well as iPad mini 2-and-later devices. 
This is such a great addition! I've been all in on storyboards and, as you said, it could challenging on laptops. Have you seen anything on what might be new, if anything, with creating frameworks? I haven't seen anything, but I haven't been able to dig really deep into all the material yet either.
Swift 3 has `CGFloat.pi` so you don't have to bother with `CGFloat(M_PI_2)`.
Oh I would keep going with Swift 2.2. I was a newbie with Swift 1 and lots of things carried over. Especially lots of stuff from ages-old Apple software libraries dating back to Steve Jobs's NeXT days.
you mean is it already available online? do I just have to put the iOS beta on my iPad?
The SQL Spring benchmark fetches every row in the user table on every single request and then randomly selects one of them in Java which is incredibly inefficient. The Spring JSON benchmark also introduces synchronization overhead by using and incrementing an AtomicLong while all of the other benchmarks just return a static JSON object that is never mutated. 
I haven't seen anything new there just yet, but I suspect they might be waiting for the ABI compatibility to arrive.
Great! Glad that helped. Sounds like I at least need to make it more findable. So the "magic" in that case is that its a struct, and they have implicit constructors. In the docs they're called [memberwise initializers](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID214). The cool thing about using structs &amp; memberwise initializers is to add a new field, all you need to do is declare it, no adding a new parameter or assigning it. Cleanse takes full advantage of this since, so if you add a new field to a struct, say in the case of `GithubListMembersServiceImpl`, it would go from using to&lt;P1, P2&gt;(factory: (P1, P2) -&gt; Element) (where `P1` and `P2` resolve `TaggedProvider&lt;GithubBaseURL&gt;` and `NSURLSession` respectively) to using to&lt;P1, P2, P3&gt;(factory: (P1, P2, P3) -&gt; Element) So no other code changes required. Another cool property of this system is that if you reorder fields, you still don't have to refactor any other code. Say we swapped the order of `githubURL` and `urlSession` in `GithubListMembersServiceImpl`, `P1` would just resolve to `NSURLSession` now. Anyways, I'll hopefully have time to take another pass at the documentation this weekend. Thanks again for your feedback! 
&gt; I'd rather start with something useful. [this might put things into perspective](http://githut.info/) 
Well first you have them sign a NDA (nondisclosure agreement) which bars them from using your idea. As far as finding one? You could always try freelance websites. You should probably do a good amount of due diligence on your part to know what an app developer is and isn't responsible for that way you'll go in with reasonable expectations. 
Lol I'm using an i3 and it's perfectly adequate for even large projects and for as many tabs open as i want. I'd say go with the newer one but there really won't be much of a performance difference between the two. 
This is nice. Sometime when I relax with ipad on my couch, I can play with some code concepts.
Xcode &gt; Toolchains Edit: I don't know why it doesn't show up for everyone, but this is what it looks like for me: [image](http://i.imgur.com/Wy6Uq5k.png)
This is generally not a real concern. If your idea is particularly good, you will have competitors soon anyway. If someone can beat you simply by making an app that does the same thing, you are going to get killed by bigger and better companies anyway. If your idea is particularly novel, get some kind of general legal protection, like a patent. If you're making a location-based image sharing social network, or a music game, or whatever else, the truth is that: a) Nobody else cares about your idea, and b) If it's so easy to "steal" it from you, you're going to lose anyway "Ideas are cheap"
You can pay me! I'm cheap because I'm new. But I currently have an app in the store. Pm me. 
Get the i7. It has 4 cores instead of 2. The .3 ghz difference between the processors will be completely hidden by 2 more cores. It's cheaper anyway. 
I've replied to your PM.
"Ideas are worthless. Execution is everything." (Scott Adams)
Any ideas? 
Bigger screen is useful when developing. 
Ah. So it's able to know the contents (subject and first line of body) of each email, and display the notification dynamically to represent that. Each notification displays text that's unique to each email. Does that make sense?
Go the opposite route. Investigate the creators of apps with similarities, and approach them with your idea.
Just take the plunge and upgrade to Swift 3. You'll have to do it at some point, so why not get a head start! 
Are you using the local notification API or the remote one? Because if you're using the remote one it should be pretty obvious. 
Not sure if this has gone over my head, but is it using UILocalNotification()? A good page on this in [Hacking with Swift here.](https://www.hackingwithswift.com/read/21/2/scheduling-notifications-uilocalnotification)
Xcode 8 uses Swift 3.0 as default. But you can turn on Swift 2.3. Go to project's Build Settings and set 'Use Legacy Swift Language Version' to YES.
I'm using a dual core i5 Mac mini from 2012 and absolutely no issues with it. You'll be fine with those options
I was wondering if there is a book that gives brief explanation about such classes/codes in iOS which developers like me have to use/interact with I tried option + command clicking, iTunes would not help explain NSIndexPath class, and I can't post every single class/code I don't understand to a site like SO.
Do you get the `didChangeAuthorizationStatus` callback? if so, what is the status? Are you running your app in the the simulator? Concerning your "hard coded" location data: If you are running your app in the simulator, you need to provide an actual location to use. You can do so by creating a .gpx file (File -&gt; New -&gt; File... -&gt; iOS -&gt; Resources -&gt; GPX). You can set the location within that file. When you now run you app, you can activate this location (in Xcode while running app: Debug -&gt; Simulate Location -&gt; yourLocation) One more thing: have you added `NSLocationAlwaysUsageDescription` key and description to you info.plist? 
I have both a 15" (2013, personal) and 13" MBP (latest model, work issued). My 15" seems faster compiling Swift, but I move around a lot and have come to appreciate the 13"'s smaller size and lighter weight very much. Neither screen size is great for running Xcode, it just takes too much screen real estate. It's also not great ergonomically to spend long hours slouched over a laptop screen. I almost always supplement the laptop screen with one or more external monitors, in which case 13" vs 15" hardly matters at all. Also, for my personal laptop I've always bought refurbished ones from Apple and have never regretted it.
This, as a professional developer, I won't sign an NDA since there is no upside for me. I've incurred a legal liability (I can't work on anything similar) without even knowing what I'll be looking at. Besides, my reputation is worth more to me than your idea.
Seriously dude? This question doesn't set off any warning bells for you? Best of luck with that. 
Glad to hear it – thank you for your support!
They could also trigger an instant local notification from within the app once the app receives an email via a background process.
Thanks! I'll check out their sample code!
Remember you are under NDA and not supposed to discuss beta APIs.
Didn't work seem to work got the same error upon build.
Are you telling your `locationManager` to `startUpdatingLocation` someplace? `startUpdatingLocation` will notify your delegate by calling its `locationManager:didUpdateLocations:` method. I have not used location with CLBeaconRegion so I can't help with that but the [Documentation](https://developer.apple.com/library/ios/documentation/CoreLocation/Reference/CLLocationManager_Class/index.html#//apple_ref/occ/cl/CLLocationManager) is pretty good. As far as a default location goes you can create a CLLocation with your values using `CLLocation(latitude: 40.440624, longitude: -79.995888)` and use that object if the user denies location or if the location update fails. 
Extensions add new functionality to an existing class, structure, or protocol type which you do not have access to original code. However, Extensions cannot override existing functionality.
Probably a bad time to release this given the overhaul to libdispatch.
Did you purposely name it after the Android API?
Can be used till swift 3 is released :). 
^ This right on point. I have a 13" MBP open box and it is awesome. Yes the screen is smaller but you will probably want an external monitor anyways so kills the big advantage over the 13". I move around a lot as well and it is the reason that I got this laptop so it depends on what you prefer. Do you want a big screen, although it was too bulky for me to carry around as I would with my 13". If anything you could try the 13" and if you really get annoyed by the screen size then you get a full refund for it. Then buy the 15" afterwards. 
http://fi.co/posts/937 - Trust me no one wants to steal your idea. It requires too much commitment on the developers part. Developers are generally lazy and have a ton of their own ideas they want to pursue. 
It's not exactly "normal" but it does happen. There are a couple obscure APIs that have gone without documentation for years. Generally though, documentation should FYI, you can get *slightly* more information by command-clicking on "CallKit" in your "import CallKit" statement at the top of a file in Xcode and then command-clicking on the various components within. Some of the elements – like CXProvider – have documentation comments that *aren't* a part of the HTML documentation yet (I assume that's due to the code being newer than the documentation at this point).
Playgrounds in Xcode 8 always use Swift 3. Projects in Xcode 8 use the project's settings. Click on the project in the Project Navigator (aka File Tree) and search for "legacy" in the search field at the top. If the "Use legacy Swift language version" is set to YES, then you're using Swift 2.3, otherwise you're using Swift 3. 
Does it run if you try it on device?
I could be wrong, but I don't think you're able to block calls with CallKit. The spam detection still lets the call come through but will show a message stating that the number may be spam.
I hope that isn't the case.. I fear you may be right though.
No, in Swift. I prefer to use the C interface (handle you pass to functions instead of object you perform operations on).
The Stanford iOS CS193P course is pure gold. A truly pivotal point in my iOS 'career' was taking this course. https://itunes.apple.com/us/course/developing-ios-9-apps-swift/id1104579961
Wow, this angered me by a considerable amount. And I'm a hobbyist, I don't have code I'm significantly invested in. Unless there is an interest to *objectify* every C API Apple supports, I do not see how this reasoning is valid. Audio Units and Audio Queues are still imported as C APIs. And C's support in Swift is a feature...
It's a preference. C's support **is** a feature of Swift and the C framework is still there. Swift would have been dead on arrival if it couldn't leverage the Carbon and Cocoa APIs. It's fine and dandy they're providing an OOP interface but Apple is going out of their way to block the C API. Do you think, given time, people will find a way to access the C API?
That's fair, I also figured that could be the case, but just wanted to get some other peoples feedback on the matter. 
GCD is a core part of almost all development on iOS, macOS, tvOS and watchOS. So it's almost like it's a part of the language itself. It's not at all the same as those other things.
Honestly I think the Swift documentation is the best place to start. 
Get a Mac if you are serious about learning swift. Not sure about tutorial in swift 3 and I don't think there is any right now given its only recently announced. Otherwise hacking with swift is a great resource for learning swift.
thanks! 
haven't read the project info yet, but the [logo](https://camo2.githubusercontent.com/8672b7a513c2bfda90112d56a28690d5bbabfe4a/687474703a2f2f74696477616c6c2e636f6d2f5377696674576562536f636b65742f6c6f676f2e706e67) has *so* much attitude
Sadly there is no feedback app in the dev beta. I will be moving to the public beta when it comes out later to give feedback. 
You should sign up for the free tier of the developer account on developer.apple.com this will allow you to download and install the XCode 8 Beta, which includes Swift 3. as far as tutorials, there isn't much out there now, however a lot of the stuff you will be learning initially is going to be very similar to Swift 2.2. For example, learning how to use ViewControllers and InterfaceBuilder to display information to the user and respond to user action. You could also start by learning in Swift 2.2 (by downloading Xcode 7.x), since the 3.0 update is more of a naming change than anything else, you will be learning mostly transferable skills. I thought the [Swift Education](https://swifteducation.github.io/teaching_app_development_with_swift/) stuff to be good for initial understanding of swift. Also [Developing iOS 9 apps in swift on iTunesU](https://itunes.apple.com/us/course/developing-ios-9-apps-swift/id1104579961) is amazing but requires a bit of knowledge about development (mostly an understanding of control flow and basic data types) [Here is the standard 2.2 documentation](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html), lots of great information here as stated elsewhere
that is a great information to me! thank you very much! 
thank you a lot! awesome advice! I will do that!
Oh yea and fiddling with strings is super annoying. There are generally a lot of rough edges you might expect when comparing a super new language to something quite old like Python. 
Sure, but pycharm is so damn awesome :P
Honestly you just sound stubborn here! It should be pretty obvious to anybody that Swift is Apples programming solution moving forward.
Sorry, I can't take credit for logo. It's sort of an unofficial WebSockets logo in the industry.
Found it a bit hard to read having all the source in one big file.
Huh. There definitely is on mine (iPad Pro 12.7 and iPhone 6).
if let time = element["time"] as? Int { print(time) } Or guard let time = element["time"] as? Int else { return } print(time)
Thanks for the feedback. The source file for the class has grown quite a bit since I began the project. I have chosen to keep it self contained because everything in the file operates on the single WebSocket class. The file is1800 loc, which I feel is still rather modest. Also some of the users of the project choose to drop the single file into their project instead of importing through package management and the single file model works well for that. That being said, I may consider refactoring in the future.
If you are using json. You should use SwiftyJSON as it will help you make your code cleaner. Multiple ways to do it. You can do let time = element["time"] != nil ? element["time"]: 0 Nil coalescing method: let time = element ["time"] as? Int ?? 0 or if let method if let time = element["time"] as? Int {//do stuff } or sometimes this can be used the guard let method guard let time = element["time"] as? Int else {return} I prefer the if let or nil coalescing method.
These questions aren't particularly relevant to /r/swift. You should review the https://www.reddit.com/r/swift/wiki/faqs which covers basics around learning how to code, including topics like games. 
 let time = element["time"] as? Int ?? someDefaultValue Where someDefaultValue is some other Int that time gets set to if element["time"] is nil.
I wouldn't recommend using SwiftyJSON as an answer to this question, but rather look at the source code for SwiftyJSON so OP can learn how they do it.
What's the difference between normal sockets and web sockets?
Like CoreMedia I/O for example! Still waiting on docs ... four OS updates later. =D
That's my guess too. Won't be too bad.
"TCP isn't cool so we reinvented it... over HTTP!!!!111". More seriously, it probably exists out of necessity to reach all browsers which may be behind 'port 80 only' firewall configurations, as are typical in business. But the concept still grates on me TBH, I'd far rather developers pushed admins towards configuring network layers the way they were intended, instead of stacking ever higher on top of the web... for that way leads ever-increasing packet bloat and madness. Like them or not though, Websockets are here to stay, so thanks to OP for a nice looking library (and still nicer looking logo - very sexy!).
Swift newcomers are being placed in front of low level multithreaded code at an alarming rate? This is a thing, and we want to prevent it? &gt;It has different naming rules and simply doesn't match the function or method naming of other Swift APIs. It's not a Swift API!!! This could be said about any C API, they weren't written with Swift in mind. And why are we forgetting about all the other APIs that aren't getting the *Swift treatment*?. It's not enough to write an OOP wrapper for GCD, but Apple had to go and block access to the C layer... why advertise that Swift supports C libraries then?
How do you cross-compile your obj-c stuff?
I use ObjFW as the base library, which is *more* cross-platform than GTK+, so my wrapper will work anywhere there's clang (probably GCC too, but that's untested) and GTK+. It doesn't use any undocumented GTK+ APIs or X/cocoa native stuff, so it doesn't care what platform it's running on - I work on it on my Macbook pro (just committed a couple new widget wrapper classes a few minutes ago, actually), and test it on a FreeBSD VM.
Ok link please!