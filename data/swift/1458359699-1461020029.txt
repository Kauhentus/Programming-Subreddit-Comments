Great! @thelemoncookie on Twitter. I'm interested in meeting new people and going through the process with someone else. 
They have been doing that for whole time. I think it's just message that they show for whole time.
Just wait. It's in the queue.
Yes.
Isn't this 100% objective-c? Why would it pop up on /r/swift...
yep. according to GitHub there is zero swift in its repo
I know. It's really not meant for that. The idea behind this is to use the technologies that exist on os x and ios. The moment that I plan for it to make this cross-platform is when most of those cool API's (libdispatch, AVFoundation NSDataDetectors, etc) will also run on linux. 
There is really no stopping you from using it with Swift..
You will get more help if you ask on one of the Swift.org mailing list. I doubt that many on this reddit are building Swift from source. https://swift.org/community/#mailing-lists
 for i in 0...10 where i % 2 == 0 { print("even numbers: \(i)") }
So the problem here is actually that something has gone horribly wrong when configuring compiler- rt. You'll notice in the clang commands that it is building in this directory: clang_rt.builtins_armv7_10.4.dir What that means is it is building the clang_rt.10.4 archive which provides back ported library functions to OS X 10.4. Obviously 10.4 didn't support armv7 as an architecture, something has gone really wrong here. If you're on the latest swift it is probably a regression caused by 53f48f8. You need to email swift-dev to get support from Dmitri Gribenko and Vedant Kumar. Source: I wrote most of the compiler-rt builtin build system for Darwin.
You can learn Swift without a Mac, with the open source compiler. The skills will transfer, but you won't be able to use any of the Mac or iOS APIs without Xcode on a Mac.
man.. these are about my specs right now. on windows 10, 4gb ram, i5. do you have any specs on getting it to run smoothly? I've only run into trouble, and have only actually gotten to the desktop twice, usually the thing crashes while trying to boot up. how much ram have you allocated to the VM? which OSX are you running?
this is an option that I had not considered... thank you!
The fundamentals of the language are cross-platform, which is the point of the language - Apple wants Swift to be used by everyone for everything, not just in OS X and iOS and watchOS and tvOS.
Right... This is what I'm leaning toward, but it's going to take a couple of months to save up the cash, so my question was what I can do to start learning in the meantime. 
Agreed fully, max the RAM. Scrimp elsewhere if you have to, but CPU and RAM are vital on a development box.
My funds aren't *that* limited... I'm just impatient. If I'm spending money I'd rather get a used Mac instead of buying and building a hackintosh. If I could get OSX working on my current system while I save up the cash that would be great, if there's something cross platform I can use to practice/learn the language that works too.
I was in your situation but I solved it by saving up for a Mac Mini and now i'm studying Swift programming.
I'm going to second the upgraded RAM recommendation. I had a VM on a 4gb box that shut my computer down.. I doubled my RAM for like $50, gave the VM 4gb to play with and it was *so* much better. 
I'm running El Capitan on an early 2008 Macbook Pro. I think you can pick one up for like $400.
It's OK: you won't get charged until release day. 
thanks for this info... this is very likely what I am going to do. Just depends on how much cash I can save up before I want to buy the thing. Saw some 2011-12 i5 MBPs on eBay for 400-500. 
From what I've heard, metal is easy to learn if you already have significant OpenGL experience since it's fairly similar (shaders, triangles &amp; stuff). There are some specific metal tutorials (a couple on raywenderlich for sure), but I haven't seen them and I doubt they're extremely beginner friendly.
Last year, we had 1 request for a Swift dev, now we have 6! Amazing!
API documentation's goal is not to teach you how to use the framework, it's just there to explain how it works. That is, it won't tell you how things fit together and how to use them with one another, it only tells what a particular interface does in isolation.
I really don't recommend doing this. Swift is far from ready on Linux. Learning Swift when lots of things are generally unimplemented, immature, and buggy, like Foundation (an important piece of Swift), sounds like a recipe for confusion and complication. Plus there simply aren't sufficient libraries to many tasks. If you can't get a Mac, I strongly recommend learning a different language in the meantime until you can get one.
Have you considered used? http://www.ebay.com/sch/i.html?_from=R40&amp;_trksid=m570.l1313&amp;_nkw=mac+mini&amp;_sacat=0
Thank you for that, this seems like the best route, I will look into the implementation.
I don't think learning Swift, or any other language now makes a lot of sense if you're going to get a Mac eventually. Different (not to mention unfinished and buggy because ElvishJerricco already talked about that) compiler, lack of anything close to Xcode, no non-iOS/OS X-specific frameworks... Sure you might be able to learn Swift syntax, but that's such a small part of iOS development and everything else you will have to go through to learn it would be useless and cumbersome. If you're that impatient, better spend your time making money for a Mac.
I'm not sure why my previous response was deleted, but here goes again. The team will not consider a full move to swift. That is a task for another project. I am not sure why people hate ObjC as it's purpose was to be a simple superset of C. Additionally, there is plenty of future in ObjC as there are millions upon millions of lines of code written using it. Swift's future is inevitably linked to ObjC as it uses the ObjC runtime.
Thanks... I mentioned that in the OP. 
What Nigel said plus: yes, make a function that takes a string ("instagram.com" or "facebook.com") and a value(facebookName/instagramName)
You can probably move the UIApplication open URL portion into it's own function, which takes a parameter URL. That way, if you choose to add twitter support let's say, you won't have to rewrite that portion again. Furthermore, if you want to distinguish between which button called which function, the sender parameter is set equal to the UIButton used. You can access things like the UIButton's tag or title, which is helpful in distinguishing which button called that function.
I think this can be improved a bit. First, we can abstract out the most obviously shared code: func openAppUrl(_ url: NSURL, orWebUrl alternate: NSURL) { let app = UIApplication.sharedApplication() if app.canOpenUrl(url) { app.openUrl(url) } else { app.openUrl(alternate) } } Now, there's nothing about those URLs that are "app" or "web", but the func name at least indicates the intended use case. If you can ensure that those are the formats for both Instagram and Facebook and they won't change (I wouldn't bet on URI formats never changing, but this should be good enough to get prototyped and running before you consider something more robust), then we can make use of string interpolation to generate those URLs: func openApplication(named appname: String, forUsername username: String) { let appUrl = "\(appname)://user?screen_name=\(username)" let webUrl = "https://\(appname).com/\(username)" openAppUrl(appUrl, orWebUrl: webUrl) } Finally, we can make those IBActions a little lighter by calling into our other funcs. We can use Swift's `guard` clause (as I've done here) or `if let` syntax to ensure safety: @IBAction func openInstagramPage(sender: UIButton) { guard let instagramName = self.selectedSal?.instagramName else { return } openApplication(named: "instagram", forUsername: instagramName) } You might also consider a `where` clause just to ensure that the string isn't empty (or even provide some means of verifying a username): guard let instagramName = self.selectedSal?.instagramName where !instagramName.isEmpty else { return } *** I've put the whole thing below so that it's easier to see at once. private func openAppUrl(_ url: NSURL, orWebUrl alternate: NSURL) { let app = UIApplication.sharedApplication() if app.canOpenUrl(url) { app.openUrl(url) } else { app.openUrl(alternate) } } private func openApplication(named appname: String, forUsername username: String) { let appUrl = "\(appname)://user?screen_name=\(username)" let webUrl = "https://\(appname).com/\(username)" openAppUrl(appUrl, orWebUrl: webUrl) } @IBAction func openInstagramPage(sender: UIButton) { guard let instagramName = self.selectedSal?.instagramName where !instagramName.isEmpty else { return } openApplication(named: "instagram", forUsername: instagramName) } 
thats the wrong swift ;-p
I've used PromiseKit in both ObjC and Swift, and it was pretty nice. It also comes with extensions for some of the more common SDK classes like URLConnection/Session.
Have you looked into the system provided GCD and NSOperation? That's what all of these other tools are built on top of. It might be worth it to you to avoid external dependencies and know how it all works. 
Did you check the Apple docs about this? They exist. Did you watch the **several** WWDC videos about exactly this subject?
I have read apple docs extensively, i am still struggling. The problem is that the code used for api in objective c is thwarted into their sample app, which makes it substantially confusing for me to extract the objective c code that i need. I need help D:
I have not, actually. I've touched upon the topic of GCD on occasion, but I haven't used it. I think it's worth looking into just because it's stuff you should probably know as an iOS developer, but if there's a library out there that does the heavy lifting for me in terms of a solid Promise or Observable implementation, I think I'll just go with that. I don't want to go about reinventing the wheel. :)
Amen! Besides its easy to pass a callback in (closure/block) to something doing async work. Just like node I find it easier to use callbacks. Promises in node are horrible at least and I've never looked at them in swift. 
Sorry, what is Compute?
Please someone help! D:
Kotlin has some similar concepts
How about out of the 6 that Code Academy has lesson for?
RxSwift benefits from its Rx* lineage: well-documented and powerful. I've used it in a few apps and the community is great. As long as you're willing to learn the Rx way of doing things, you won't find a better framework. Like others have said, you may not need the complexity of a full-on Observable library. Using RxSwift makes my app architecture completely different. But if you're wondering what the difference between Observables and Promises, I like this slide: http://image.slidesharecdn.com/labcamp-rx-150927171043-lva1-app6891/95/taming-asynchrony-using-rxjs-30-638.jpg?cb=1443388768
Javascript?
Why not use metal instead? https://www.raywenderlich.com/77488/ios-8-metal-tutorial-swift-getting-started
OpenGL is cross platform.
Thanks. Do you know if it is possible to use it with Cocoa instead of GLFW? Or should I not be using Cocoa?
google
Afaik there is no other language with strong protocol oriented semantics like swift. You're out of luck. 
I would suggest looking up the book Clean Code.
Metal can be used for graphics and GPGPU computing. The APIs for the later is less complicated than that of graphics.
Well, yes, perhaps. Still, I would argue that going with a library has its clear benefits. * Proper documentation * Tried and tested (both in terms of test coverage and lots of users) * Active developer community If I were to roll my own solution I would get none of these things without putting effort into them. And yes, I realize that many of these libraries might just be thin wrappers around GCD and NSOperation, but I tend to quite like microlibraries so that's totally fine with me.
I'm leaning towards RxSwift. Where I work we use RxJava quite heavily, so for the sake of consistency (and me being able to ask other developer questions), RxSwift is a good choice.
I have a background in JavaScript, so I like and am used to thinking in Promises. Learning to use Observables seems like a natural evolution of that though. :)
I think there are three big reasons why I want to use promises. 1. Inversion of control. You run the callback from where you make the asynchronous function call. 2. You treat asynchronous values as if they were synchronous (a function that performs an asynchronous task returns a value) 3. Error handling. I find it so much easier with promises. Btw: I always use Q when dealing with promises in Node. :)
It's lower-level, is it not? OpenGL is probably a much better place to start.
Were you actually "using" the source control, or did you just have it initialized? If you have been committing to your repository you can try this from SO: http://stackoverflow.com/a/20206664/4760331 Unfortunately if you weren't committing your progress (Source Control → Commit) as you went then nothing was actually versioned, so you possibly would only be able to go back to whenever you initialized the source control, which is presumably when you first created the project. A last ditch effort could be possible if you use Time Machine on your computer, and you could possibly restore the project folder from a backup that would have the storyboard still?
If you just need to see how to render a single vertex why don't you use the default GLKit project? Open XCode -&gt; New Project -&gt; (iOS section) -&gt; Game Then on the dialog boxes select Swift and OpenGL ES. The default project renders two cubes and rotates them. This should be enough to get you started and see how general things are done with swift in an OpenGL environment. From this point you should be able to apply most open gl tutorials/code to your liking. 
I'm not even there yet. Trying to run through the basics as much as I can for better practice. 
You should do something like that : slider.target = self slider.action = "valueChanged:" Or even simpler you can control-drag from slider to controller in Interface Builder and choose "valueChanged" in the menu. 
Technically you can get all the xibs the storyboard compiles into from the IPA on the device, not sure that'll be exactly what you're after. If you were using version control and committing your changes you can try what /u/imheretocode suggests 
First method works! Thank you!
I am also in favor of creating UI in code and I also use storyboards just for the Navigation flow. I didn't find any Tutorials in the beginning because, it's just code :) Steps 1. Choose a class UILabel, UIButton, etc 2. Call the initializer 3. Assuming that you use Auto Layout turn off translates auto resize mask to constraints(I am from mobile and I don't remember the name, sorry) 4. Use addSubview 5. Use an AL framework like snapkit If you don't know how to do something, just look at the API. Everything comes from there.
Using source control means to me you've committed it by accident some time. This would allow you to get it back. I think the easiest way if you don't know how to do it is to use a tool like SourceTree to get the latest commit of the StoryBoard before you deleted it and restore that version. Also it needs to be re-enabled in your project file so you should add the file as well after you've put it back. Good luck!
If it was “accidentally” saved to the trash (how could that ever happen I don't know), it wasn't actually under source control, source control is by directory.
Doesn't Metal accomplish the same tasks as OpenGL but more efficiently ? (actual question, I'm not sure about this)
Exactly. I can't stand people giving iOS advice instead of Mac advice. Some docs are even only available for iOS when they should be for Mac!
I typically have an SKScene for every screen or main area of the game. MainMenuScene, GameScene, HelpScene, SettingsScene, GameOverScene, etc. You can get by with combining things in one scene too (e.g maybe you don't need a dedicated GameOverScene and a pop-up will do). Ultimately it's up to you.
I see. I remember Apple announcing this at WWDC 2014 as if it were the perfect replacement to OpenGL... As expected, that wasn't quite true, from what you're telling me.
I'd say Scala. Never actually used it, but from what I've read it has a lot of parallels with swift. They're both built on top of an older OO language with inferior type systems that they have to interop with as seamlessly as possible. They both add a much more powerful type system w/ type inference, they facilitate but don't require a lot of FP style, and eliminate a lot of cruft and boilerplate of their parent language. Pretty sure I heard someone somewhere refer to Swift as Scala for Obj-C, which seems like a fairly accurate description.
I don't like a lot of big computed properties cluttering my overview of class variables. It also just moves the problem around to the top of your ViewController and the only thing you gain is separation in functions. It just breaks the clean overview of what the class has in terms of variables. I tried the didSet pattern on outlets a while and I think it's only useful for setting up controller-ish functions that can be done in one line, doing a few lines inside of it is just terribly ugly. Move alle the View related stuff out to the View layers is the only real solution to fat VC's because of big viewDidLoads.
will do thanks
I asked a similar question regarding MVC a few days ago in [this post](https://www.reddit.com/r/iOSProgramming/comments/4b9gb1/how_far_do_you_go_to_do_a_proper_separation_of/). So with Swifty way, I could modify views in closure instead of subclassing but it will be still in C layer =( I don't know if creating another view class will be an extra overhead...
Approved!
I'm glad you're learning Swift! Keep in mind you're quite early on, so please don't jump to too many conclusions :) &gt; For example, in Javascript, if you want to find if a string contains another string, it’s simple It is also simple in Swift: import Foundation let duckSoup = "duck soup" let containsSoup = duckSoup.containsString("soup") You might find my [free Swift tutorials](https://www.hackingwithswift.com) useful.
It looks like it might be expecting a `return` outside of the loop. I don't know if that's right, but I was able to get the code below to run on the playground: func fizzbuzz(i: Int) -&gt; String { if i % 3 == 0 &amp;&amp; i % 5 == 0 { return ("fizzbuzz") } else if i % 3 == 0 { return ("fizz") } else if i % 5 == 0 { return ("buzz") } else { return String(i) } } for i in 1...100 { print(fizzbuzz(i)) } 
Why is it overhead? a UIViewController has a view, and you're just replacing it with your own. override loadView and return your own. 
You might find my [what's new in Swift 2.2 video](https://www.hackingwithswift.com/swift2-2) useful while you are downloading the (massive!) Xcode update.
Out of curiosity how is it lacking? I can understand 5 or so lines (I do that myself) but when it comes to multiple subviews its instantly it's own view. 
We've added a workaround in 5e342aa7. You should be able to cross-compile swift again, but the build system changes required to get compiler-rt support for your targets are still WIP.
It has absolutely no performance penalty whatsoever if you use your own implementations of UIView instead the base UIView. And this is not "the Swifty way", just a guy that just got half way understanding how to really clean up his ViewControllers.
Hi sarkarsh! Unfortunately, the link to the App Store you submitted has been automatically removed from /r/Swift. This is because – generally speaking – compiled products are not relevant to /r/Swift (even if the app was originally written in Swift). If this is an app you have written, congrats on your acceptance to the App Store! A great way to promote it would be [Reddit advertising](https://www.reddit.com/advertising). If you would like to release its Swift source code, we would gladly accept a link to that. If the content you were submitting *was* in fact related to the subject of Swift programming, please [message the moderation team](https://www.reddit.com/message/compose?to=%2Fr%2Fswift&amp;subject=Please%20review%20my%20removed%20App%20Store%20submission&amp;message=https://www.reddit.com/r/swift/comments/4bedzo/started_off_as_a_beginner_in_swift_with_an_idea/) to have it reviewed. Regards, The /r/Swift Moderation Team *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/swift) if you have any questions or concerns.*
Try a few chapters from [Hacking with Swift project 33](https://www.hackingwithswift.com/read/33/overview) to learn how to record audio. Playing audio is covered in [project 17](https://www.hackingwithswift.com/read/17/overview). You might also find useful the Media section of my [Swift 2 example code](https://www.hackingwithswift.com/example-code/media). Good luck!
Thanks, I was just on yours site funnily enough, however my brain simply does not take well for written tutorials. I really need someone talking and showing me (i'm slow that way) which is why I am looking for video tutorials specifically. Willing to pay for a course if there is one. (enjoyed your swift 2.2 video)
[removed]
Look, I'm right there with you and think the solution they are suggesting is terrible simply from a code aesthetics point of view. However, you can initialize UICollectionView in this manner. Like this: let collectionView = : UICollectionView = { let collectionView = UICollectionView(frame: CGRectZero, collectionViewLayout: { let layout = UICollectionViewFlowLayout() layout.itemSize.height = 34 layout.scrollDirection = .Horizontal layout.minimumInteritemSpacing = 18 layout.minimumLineSpacing = 10 return layout }()) collectionView.backgroundColor = UIColor.redColor() return collectionView }()
Does this include the swift package manager?
It does not, unfortunately: $ swift build error: unable to invoke subcommand: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift-build (No such file or directory)
Awesome, thank you for sharing. **edit** hey did they remove curried functions in swift 2.2 ? If so, why?!
I'd like to add, I have just one SKScene (GameScene) and create different SKNode files to transition to. This means I can completely control the transitions and animations between them and also have them overlaying or both on screen etc...
damn
Download speed is too slow. :-(
I'll need to Google that, because I have no idea what that is. 
Your first start should be using a UICollectionView to handle the horizontal scrolling. The CV is extremely powerful, and can have nested interactive views (scrollviews, etc) within each of its cells that are displayed. As for persisting the data models, look into a simple core data application. You should only need 1 data model (Location) with a few properties to display. Networking? Use NSURLSession. Don't waste time on 3rd party libraries, etc, they will keep you from learning how things REALLY work under the hood. Lastly, use storyboards for total-ish control over Auto-Layout. Doing it in code for the first time isn't hard, but isn't easy either. Keep it simple to start. Good luck!
I would argue against even having a viewModel. The view should have a decorator that is supplied the model, thus allowing for the view to not care what model is being passed. That is the decorator's job.
Oh I really hope they'll implement the Scala style `f(_, 1)` freeform partial application. That looks even more powerful than curried functions. 
I've been looking into Facebook's open source swift version of Bolts! Their Task object looks pretty awesome: https://github.com/BoltsFramework/Bolts-Swift
What this post espouses are fantastic goals to strive for when writing functional code. I offer, in addendum, a warning from experience. Swift is not built to handle large-scale declarative programs. Using these abstractions at scale comes at significant cost, can and will produce difficult code, and often be a pain to debug. Equivalent programs in Haskell, Scala, SML, etc. that consume very little space or memory will wind up blowing the stack or ballooning the heap when translated directly into Swift.
Carthage fails to build the project now.
Downloading via terminal work quickly for me. softwareupdate -i -a 
I create 5 line files all the time. However, nothing forces you to do that. If you think it makes more sense, you can just define both the view and view controller in the same file.
What are you trying to do? What is the code doing? is there an error? is it at compile time? runtime? what is the message? 
How can I word this to look like something other than a mindless +1? All I can do is assure you this is not a mindless +1! u/rohlman82 has said, succinctly and accurately, just the right amounts of everything you need to be doing. And the best is saved until (very nearly) last: 'Keep it simple to start.' Can't be emphasised enough. You won't go wrong following u/rohlman82's advice. 
I can't give an answer, but I can say that you will receive the notification on the same thread as where your context's queued up save operation happened and since NSNotifications are posted synchronously, you actually probably can interact with them. Ok yea, go for it would be my answer, since the next operation in your contexts queue won't start until you process that notification. 
Here's the snippet I'm referring to: for time in timePoints { do { let imageRef = try generator.copyCGImageAtTime(time, actualTime: nil) CGImageDestinationAddImage(destination, imageRef, frameProperties as CFDictionaryRef) print("Image added") } catch let error as NSError { print("An error occurred: \(error)") } }
They only removed the shorter syntax, you have to use the complete form now func curry(a: Int)(b: Int) -&gt; Int { return a + b } is equivalent to: func newCurry(a: Int) -&gt; (b: Int) -&gt; Int { return { b in return a + b } } 
 typealias ReturnBlock = (newTask: Results&lt;Task&gt;) -&gt; Results&lt;Task&gt; This will create a Type that accepts a task and returns a task I think what your looking for is just typealias ReturnBlock = () -&gt; Results&lt;Task&gt; Takes in nothing and returns tasks.
++ -- and C-style for loops
Haha, so in other words, you are unhappy with them removing those?
Alternatives? The "alternative" exists already and you can use it now: i+=1
Thanks for your response. Yeah I looked through all the code that I run before and after this for loop. Everything loads instantly but it just gets caught up here. Even the code after, where I run the gif, runs immediately once the for loop finishes. 
And if too.
Im sorry but could you please provide more information? Let me know if I'm not being clear enough.
Not really upset, its the reasoning that irks me: *it's confusing to beginners*. Come on, we were all beginners once.
Why did the language include these if they planned to take them out so soon?
&gt; Mark classes as `final` unless you’ve explicitly designed them to be inheritable. This is terrible advice and I'm sick of hearing it. 
Just a quick guess, but are you calling tableView.reloadData() after you've fetched the data?
Is the roadmap for Swift 3 public? Are they aiming for a dev beta in June after WWDC? 
I am. I was hoping this would resolve the issue as well but no luck there
What's the error?
i++ and i-- will be missed by me. I use them in my projects 
Seems to be, but maybe it was slow because i had the fuzzy autocomplete plugin from Alcatraz
Did the finally add fuzzy auto complete!?! Ugh about time...
I honestly don't understand the hate for ++ and --. Maybe it's because I learned programming using C 
I will really miss var in the parameter list. It's very useful for recursive algorithms.
I was initially put off by the author diving straight into custom operators, but then the author went on to show how the same things can be achieved without them. I find that far too many "introductory" posts on functional programming focus on all the fancy custom operators. That turns off lots of developers. The suggestion is often to install some dependency that will create the operators for you. But dependencies are the bane of some developers, and provide their own steep learning curve. The best way to explore functional programming in Swift, in my opinion, is to explore map, flatMap, reduce, filter, sort etc... Learn how they work, and explore using them. Then see how that informs how you structure your code and data. 
This isn't really what I'm looking for. Im looking for a way to capture an image that is being seen through the preview of the camera, but only capture the part inside a frame. It would look like this: http://i.stack.imgur.com/N61sA.png. Or this: http://cdn1.tnwcdn.com/wp-content/blogs.dir/1/files/2014/10/Screen-Shot-2014-10-20-at-5.41.44-PM-730x392.png So basically what is inside of the frame on the screen would be captured, without everything else. I appreciate your help so far!
I don't think it's really hate. They discussed that the difference between ++x and x++ only made sense if you were using it inline with another statement. They concluded using it inline with another statement was confusing and "code smell". So the only place you would use them would be on their own line to increment, and += 1 is barely any longer or more bulky, and would eliminate both what they saw as an unnecessary operator and one that has the potential for confusion. To them it was a "We think the benefit of simplicity is greater than the loss of functionality in this case" 
That RosyWriter sample isn't great, but if you intend to capture live images from the camera, it is not a simple task. I just wrote something that does something similar and all the above mentioned classes were required.
Yeah the fuzzy autocomplete is amazing! I've been using it with the 7.3 dev beta and it is just awesome. Are you comparing code completion speeds to 7.3 beta or to 7.2 ? I'm wondering if I should download 7.3 GM.
Downloading is not an issue. It's waiting for the darn thing to install!
If you haven't seen this already, you should check out [this course on iTunes U.](https://itunes.apple.com/us/course/developing-ios-8-apps-swift/id961180099) It's a great course from one of the best iOS professors in the field. Also, you should really consider learning Objective-C as well. Although you might get along fine without it, a lot of Stackoverflow answers to the more rare issues are dated, and in Obj-C. With a decent grasp of Obj-C terminology, you can easily guess how solve the same problem in Swift.
what do the "-i -a" things do ?
i think it was an apple engineer who proposed that, i might be wrong 
It was [Erica Sadun](https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md), who is not an Apple engineer.
thanks
i've mistaken the writer for the original author
They may add ++ in Swift++
Don't bring ideas of code structure from Java to the table with you. OOP background is important, but you should read the Swift Programming Guide, and really understand extensions and protocols. Classes are great, but Mixins are super powerful. I'm still learning, but number one rule is don't be afraid to reach out and ask questions.
So are you considering this as era++ or era--?
I think I have it figured out. It's a lot more simple than I thought. I think my misunderstanding came from not fully getting closure syntax. func readAllTasks(withCompletionHandler handler: (tasks: Results&lt;Task&gt;) -&gt; () ){ let taskList = uiRealm.objects(Task).sorted("name", ascending: true) handler(tasks: taskList) } thanks guys! 
Do you know if there is a 2016 version available? I looked around, but I couldn't find it. 
Same as here: https://github.com/Carthage/Carthage/issues/1152
I disagree. The fact that `final` helps performance is an implementation detail and broadly not very interesting. I would not be surprised at all if Swift 3.0 deprecates the `final` keyword and makes everything final by default, so that you need to use a new keyword to say "yes, this can be subclassed." (At least outside of your own module.) It does not make code easier to reason about when everything can be subclassed. Protocol extensions and regular extensions exist and are awesome – we can now work sideways using protocol-oriented programming, and it frees us from deciding a hierarchy up front that can be hard to refactor. Composition over inheritance is the key here. You only need look at the Swift standard library to see that a) almost everything is a struct (as final as it gets!), and b) extensions are used across the board to add functionality. &gt; If you mark every class final then you are basically throwing away object orientation principles. This is a straw man. The original quote was "Mark classes as `final` _unless you’ve explicitly designed them to be inheritable_" not "mark every class `final`." And the quote is fair: unless you've looked at your design and decided that it was safe to be subclassed, it's a mistake to leave that open for others. &gt; "Basically, you don’t know what the future will bring. And are prematurely stating you are 'done' when you have not way of knowing." That's true, but so what? Here are two possibilities: 1) I create a class and don't make it final. Other devs subclass it and cause all sorts of problems. I then update my class to make it final to stop those problems. Result: a lot of people are annoyed because all their projects are now broken. 2) I create a class and make it final. Other devs want to subclass it, and complain at me. I look at their reasoning, and decide they are right, and delete the "final" keyword from my code. Result: no breakage. As one of Apple's Swift engineers put it, "a class that starts out ‘final’ can certainly become non-final later; it doesn’t change how the class is currently used." TL;DR: Yes, right now marking things as `final` is an optimisation, but that's not really the point of it.
Actually the official term is a 2 dimensional array (2D). Comp sci 101 :p
Hacking With Swift is where I started learning with no prior knowledge or experience with Swift. It was also the first programming language I properly learned, so I was approaching it as a total newbie. Found it to be really good and understandable. Each lesson introduces you to new concepts and aspects of Swift, and does so in a way that means you learn by doing. You also build up a collection of Xcode projects that you can refer back to and build upon. Hacking With Swift also has its own subreddit, /r/hackingwithswift , so if you get stuck on anything, you can normally find your answer or help there. The guy that wrote Hacking With Swift, /u/twostraws, is also really active on Reddit and Twitter, so an answer to any problems is never far away Tl;DR Hacking With Swift is a great place to start!
Thank you – I'm glad the course was useful! I'm busy finishing up [Pro Swift](https://gum.co/proswift) right now, and hopefully it will be a good follow-on course :)
Thanks! :)
**TL DR; Wanted to figure out how to get the new objects in the main MOC without NSFetchedResultsController** Thanks for the comment. I was thinking of a scenario where I have to add the new objects to a view controller's array property, and then update UI. Maybe update tableview or maybe non-tableview UI. Yes, NSFetchedResultsController is the first thing I actually looked at. But I found [this post](http://stackoverflow.com/a/3216781/5299220). It seemed NSFetchedResultsController is not the 'best' way in some cases, and getting the notification is a lighter way. But I wasn't sure how to actually write the code without NSFetchedResultsController, so wondering if the way I wrote is thread safe and correct way to do it.
Thanks, I will try this.
Ah I see. That makes sense.
Fair enough, i usually go by the philosophy of refreshing the objects "managedObjectIDs" if I know I can't guarantee it's going to be accessed from the same object context. 
Yeah but that looks like a mess. I know this is a simple example and there may be times when defer may clean up code, but his reasoning is dumb. It is widely used. Benefits new programmers? I learned what ++i and i++ did in high school. It is really not a hard concept. What about programmers coming to Swift from another language? Seeing something so simple removed from a language is plain old retarded.
A lot of people in most other langauges. This is a dumb thing to remove.
I've been testing on two different iPhones, one with older iOS and one with 9.3. Haven't had any issues yet.
You could drop that to ten seconds or less if you put your project and your build folder on a ramdisk.
&gt; I don't have a strong attachment to their position, pre increment and post increment are two very different operations. There response actually has me wondering if they understand how the operators work in C. Re-read that last post. They are different only when used inline, and using them inline has always been a very dodgy thing to do. Using them on their own is clear, but in that case, they are identical.
Hey thanks for the response. Are you testing running your app via Xcode on your phones in debug mode?
Stop doing C-style for loops in Swift. Use fast enumeration or ranges. 
If you're new to programming and like the Codecademy style of doing lessons on your device, you might like Swifty from the AppStore. First few lessons are freed- you can then then decide whether you want to buy additional lessons. 
You can try Udacity's [Beginning iOS Nanodegree](https://www.udacity.com/course/beginning-ios-app-development-nanodegree--nd006) course – it designed specially for "no programming experience" cases. I've completed basic [iOS Nanodegree](https://www.udacity.com/course/ios-developer-nanodegree--nd003) and it's very good course to learn Swift. It will give you real tasks and you will complete 5 real projects to graduate. Basically, you can look for a Swift Junior job after such course. Also, they have a free course for [basic programming skills](https://www.udacity.com/course/intro-to-computer-science--cs101) (but with Python language)
for your examples you can: for i in 0.stride(to: 100, by: 3) { print(i) } for i in 1000.stride(through: 0, by: -7) { print(i) } 
for index in 0.stride(to: 99, by: 3) { print(index) } for index in 1000.stride(through: 0, by: -5) { print(index) } Edit: TIL stride(through:
The C-Style for loop got removed because often the intention isn't very clear, for more info see [here](https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md) The now recommended way of doing those kind of loops is with `stride`: // excluding 99 for i in 0.stride(to: 99, by: 3) { } // including 0 for i in 1000.stride(through: 0, by: -7) { }
I downloaded it; i didn't really like it. I think it's too childish. Thanks anyway!
Thanks! I think this is the best free resource out there, i'll do some courses to see if i like it. I didn't know about the subreddit, and that's an amazing feature! Love seeing /u/twostraws respond :D Thanks!
The simplest is: for i in 0 ... 10 { } the ... can be used as ..&lt;
Which seems odd to me. I ran perf tests on a for loop which had a mod operator so it did something every odd iteration. I did the same perf test with stride for the same result. The c style loop ran in 1/4 time.
I don't think Swift supports ..&gt; . Range must have start less than end.
yeah my bad lol...
Glad I could offer some useful advice! Good luck learning Swift! :)
In Swift, "[collection](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/CollectionTypes.html)" is a term for a few different objects with similar behaviour (Dictionaries, Arrays, Sets) that could relate to the loops above. So, you could have a dictionary with arrays as its value type, which someone might want to loop through in a similar way. 
Just a small note is that the 'Target' has to be an object that conforms to NSObject, so for instance a struct cannot be a target of a selector without adding additional stuff.
Convert NSDate to unix timestamp or iso8601 string and later when retrieving date you can convert it back to NSDate object using that string (use NSDateFormatter). For CLPlacemark, convert location property which is just lat long to string and save those. Later use can reconstruct the object from the string. If you want to save other attributes of CLPlacemark then convert all of the properties to primitive types and save those to dictionary and then save that to firebase. 
Not sure I understand your question. If you're saying you need to make the parse query available to multiple views then you have a few options. The easiest is to make the query a property on the Application class and access it that way. Not necessarily the best design/architecture approach, which would be making a data layer, but it works for small apps that don't need a lot of architecture. HTH
you likely forgot to compile with optimizations enabled
&gt; You're used to debugging on devices because the Android Emulator is poor. The iOS Simulator is excellent, and you should use it. I agree BUT don't use it exclusively. I've had some rare cases where a bug would only show up on a real device and worked fine on the simulator
You need a globally accessible resource i.e. a Class that is responsible for Parse that can be accessed by any other class in your app. The best way to do this is dependency injection checkout [Typhoon](http://typhoonframework.org) or [Swinject](https://github.com/Swinject/Swinject). You can achieve the same effect using the singleton design pattern but that is not necessarily the best practice.
The second dimension of a 2D array doesn't have to be the same length, where are you getting this from? For your C# reference, C# does called different lengths jagged arrays but its still a 2D array. https://msdn.microsoft.com/en-us/library/2yd9wwz4.aspx 
What would be the recommended way to hop back and forth? e.g. c-styled for var i = 0; i &lt; 10; i++ { let x = y[i] if x == z { i += 2 // jump ahead } }
 for i in 0...10 will loops 11 times, if you want 10 times, either use for in 1...10 or for in 0..&lt;10 
&gt; 11 times, if you want 10 times, either use Neither did I say you were wrong, just wanted to make it clear ;) 
For those, like me, who hate the look of calling functions on constants (`0.stride(to: 10, by: 1)`) you will be happy to know the `stride` free function is coming back in Swift 3: for i in stride(from: 0, to: 99, by: 3) { } 
How is this less clear? There are things I don't like about C/C++ but I've never found for loops confusing. In fact they are pretty straight forward and only take a few moments to grasp. &gt; for i in 0.stride(to: 99, by: 3) { This has more hurdles for the novice to grasp than the C approach. It certainly isn't any more readable. While it is something we can live with, I do think the justification for the language change is bogus. 
Me too for the lack of the detail, I decided to go with this guy. He is great. https://www.udemy.com/ios9-swift/
Participate on the [Swift Evolution](https://lists.swift.org/mailman/listinfo/swift-evolution) mailing list. Before you bring the topic up again, you will want to [read through the previous discussion on this idea](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160201/thread.html#8771) in the mailing list archives. It looks like the idea didn't really gain traction when it was introduced a month and a half ago and so never got accepted as an official proposal.
It depends upon the jobs that you are looking for. Some of the more interesting jobs for programmers will never be accessible without a formal degree. That is reality, but I also mentioned that many programmers do fine without a college education. The formal education is what rounds you out and gives you the background to handle a career where a degree is a requirement. 
I probably wouldn't use the exact same name. The confusion in the car param case lies in the consumer of the api possibly mistakenly thinking that the parameter could be modified inside the function, which is not the case, it would just be copied and modified for use within the function, unlike 'inout' which does the former. The change is all about being able to reason about the code with the least amount of grokking nuance possible.
A what?
TIL. No one has told me not to do that or maybe no one has cared enough, ha. Thanks for the tip!
Thanks, Tony!
TIL. I liked it cause the for loop is concise, but I completely see how it's not explicit. Thanks for the tip!
I feel like if someone learned `for i in stride` before the `for ; ;` they'd be writing the same thing, but reverse.
can you make a geisha?
Your current implementation is hasPrefix?
Are you currently using the built-in `hasPrefix`? That's likely to be pretty quick. I hate to say it, but if you're hanging the main thread on some computation-heavy method, you really should learn how to do it on a background thread. Grand Central Dispatch makes it very easy to quickly dispatch a task and receive a callback when your computation finishes. See: [https://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1](https://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1)
Stride is a great option for your examples, but just for reference you can do the standard loop through with an index using the enumerate method also, like so: for (index, item) in myList.enumerate() { // do something }
The decision was an extension of getting rid of ++ and -- from the language since both were a source of bugs (for people that confused pre and post increments). The fact is Swift offers better options for just about all the use cases that are safer and/or more readable. We can agree to disagree on "stride," though it's still arguable even if you brought the old for loop back he'd be better off using a while loop to make it clear the indexes are being changed inside the loop.
They just aren't very elegant and Swift provides elegant solutions that can easily replace them.
lol what ddid i read?
There are no numb questions. Don't be afraid to ask how you could write something in a "cleaner" way ! 
ps you can download a virtual machine like hackintosh to run xcode but i wouldn't recommend it.
Thanks a lot! I'll go ahead and look at a bunch of Swift with Xcode videos on youtube so that once I get ahold of my group-mate's computer I'll be familiar with it. And yes I did mean the launch screen! Also is it possible using "Storyboard" to import a picture or figure for the launch screen?
Yep, I'm using hasPrefix. I kinda expected it to be slower than what is possible, since it seems to account for mismatches in Unicode. This is for a keyboard, and making it parallel would make for some pretty involved logic for waiting for a result, to avoid reacting to old correction results, so I'd rather do something else. I'll just make the thing into a trie, I was gonna do that at some point anyway :)
Thanks for the reply. I saved the lat/long to doubles and it worked great. I converted the NSDate to a String and this also worked but going to also look into unix timestamp or iso8601.
Yeah, I've read about that it, but it would be a push with only 8GB of ram.
Phew, thank heavens.
Bumping your RAM up to 16 gigs would give you a massive improvement, too.
I personally use Sketch 3 for prototyping. I design all UI components in Sketch then I either export them as images or I export them to PaintCode to generate any useful drawing code. So yes Sketch 3 can be used for UI design but you'll often have to use another tools or write some (lot?) code before seeing anything moving on device.
Check this async helper: [duemunk/Async](https://github.com/duemunk/Async)
It's personal opinion but for `==` and `!=` comparisons with `Optional` in Swift, I always use `nil`. The sugar exists for a reason: it is two chars shorter while being semantically identical. An example would be where you want to construct something if it doesn't already exist: if x == nil { x = constructSomething() } The only time I personally use `.None` is when I'm actually treating the `Optional` as an `enum`. Theoretically this would be: if case .None = x { x = constructSomething() } although I'm really referring to this type of construct: switch (a, b) { case (.Some(let x), 5): x.something() case (.None, 7): somethingElse() default: break } 
The gist https://gist.github.com/netskink/7917e8013c767de6a8fe The test run https://youtu.be/0IwuEdxI9Gk
This is a better approach, IMO.
Yeah, `AutoreleasingUnsafeMutablePointer` is non-intuitive because you're not really supposed to use it yourself. You're supposed to rely on implicit conversion from Swift `inout` to handle the magic yourself. I've posted an answer that goes into more detail.
I by no means have a mastery of dense, low-level C. I think this is a stupid removal. I don't see the benefit beyond people new to programming. A simple google search would sort it out though as it is widely used in a ton of languages. This change has made me change a few lines of code into 2, and sometimes 3 lines. It is not that big of a deal -- But it is, in my opinion, an unnecessary change.
It's hard to see why you wouldn't design your API gateway's API as a (perhaps, class-only) protocol. Do you have an example that isn't just the result of your boxing yourself into a corner as a result of using a subset of the available design possibilities?
&gt; Some of the more interesting jobs for programmers will never be accessible without a formal degree All sane companies is looking for skills, not certificates.
Yes! I wish more people knew about this, as it's a great way to test your JSON parser. And to answer your question, /u/Beowolve, I'd use the approach above to pull the JSON into a *unit* test and then send the data into your JSON parsing code (which is hopefully not in your view controller but in some sort of JSONParser class). And if you want more detail on the steps for unit testing your JSON, you can find that here: http://roadfiresoftware.com/2015/12/how-to-test-your-json-parser/ Regarding the UI: if your UI only depends on model objects (and not on JSON directly), you can test it separately from your JSON parsing code and be better able to determine what's wrong if/when something breaks.
That's absolutely true, if you intend to use `x` as anything other than a boolean in the current scope. If you don't intend to use `x`, it's a different problem. Consider the following structure: var x: ErrorType? = nil for j in jobs { if x == nil { x = j.run() } else { j.abort() } } return x You can't use the `x ?? j.run()` approach since that doesn't allow the `else` – and we're not interested in the *contents* of the `ErrorType`, anyway, merely its existence.
But why did they do this? What did they hope to accomplish? Did they achieve their goals? What did they learn from having done this?
Here is another swift algorithm resource that I really like: [swift-algorithm-club](https://github.com/hollance/swift-algorithm-club/)
Ooo. I like this. Although I did like the hash solution... I copied the code and put it into playgrounds. It looked like O(n) as the author claimed. Do I not get O(n)? I thought it was just that the time was linear? EDIT: with the amount of data 
Yeah, I think that is a much better way to think about it. And yes, if you are always in the design chair and can make sure things are architected well then you probably won't have these issues. Not all of us have that luxury all the time though.
Thanks! I'll give it a shot. Using SwitfyJSON so less overhead for me to write.
Poor guy. Maybe he thought it was like Java?
The ability to do this, is a "feature" of introspection in Objc arising from it being "message-based". My understanding is that Swift doesn't have either and thus it's up to the compiler to be aware of protocol compliance but the language itself can't be "self-aware" (aka introspective) of these things. This is supposedly why you can't do unit test "mocking" as well. I could be wrong - I'm only learning about Swift at this point but that's what I understand that this point.
Do you have a mention of where to get an account anywhere in your metadata or even the login screen? I would suggest scrubbing all this info from the app and leave the app as a standalone where you need to already have an account in order to use the app (you mentioned that you don't expect much organic growth from App Store discovery). If you have already done that all I can suggest is either an appeal/communication in the notes field about accounts, or developer reject and try another upload of the build to attempt to get a different reviewer. 
The only time you will see `Type!` when ported from objc is when the nullability is not specified. When specifying `nonnull` it should just be `Type`
Oh boy... I'm not looking forward to this.
Probably best to remove old code now, as Xcode 7.3/Swift 2.2 makes them compiler warnings. You might find "[What's new in Swift 2.2?](https://www.hackingwithswift.com/swift2-2)" a useful read.
Thank God. Not only does a function on a constant seem really weird to me, but this is easier for me to understand (just a bit, but still easier).
My app, feeder.co, has a companion app for our paying subscribers. Getting the app onto the app store required that we removed aaaall mentions and links to our webpage where they can setup an account. It is possible, but super confusing for anyone who doesn't know about your product. For my app it's still the better alternative because as a lone developer I would not at all be able to support the setup flow required to create a subscription. It sucks, and I always feel so tiny and insignificant when dealing with the app store. 
Yeah, why can't we just drag our feet like the Python community? Everyone will be on Swift 5 before all the Python 2.x devs have moved to 3.x. 
The app I'm currently on has just a signin screen and no linking back to the web site. It's gotten through without a problem on 2 different bundle id/app submissions. You can't create an account and there is no outward contact or web link until you have successfully logged in. There must be something that is tweaking them to think you are attempting to drive users to sign up via a web page. You may want to try the appeal/notes approach. A couple of podcast episodes ago, the ReleaseNotes.tv guys talked about this challenge. I think it was in this episode: https://releasenotes.tv/145-do-si-do/
I kinda feel like it took you longer to write and test the regular expression than it would have taken you to manually adjust the code. Also, Xcode automatically suggests changing: i++ to i += 1 You just have to accept the suggestion.
Well this explains the sudden traffic from Reddit lol 
Yup, Definitely over complex I just havent had time to sit down to make a more elegant solution. But I like this! I'm going to utilize containsKey in my next attempt 
The point is you can apply it in one go... So all your i++ get changed to i += 1 without two clicks per instance. In a 20000 line project... I'd made my time back in the first 3 files! Let alone the for loop changes. 🙂 
I ain't mad at you. I love a programming challenge every now and then.
At first glance Auto Layout looks like voodoo. Because it is. Although not swift specific, as twostraws says don't skimp on learning this, otherwise you will spend DAYS trying to get things to line up. Particularly when you add UITraitCollection into the mix. Welcome to Swift. 
I have contacted them as part of the review process. You kind of just get canned comments back though. Here's the part where they talk about those other app's that allow outside payments. For those large companies (Adobe, MS, Google) I'm sure they are able to say "We aren't giving you 30% our subscription costs". &gt;On occasion, there may be apps on the App Store that don't appear to be in compliance with the App Store Review Guidelines. We work hard to ensure that the apps on the App Store are in compliance and we try to identify any apps currently on the App Store that may not be. It takes time to identify these occurrences but another app being out of compliance is not a reason for your app to be.
Cool I will check that out. I'm a bit worried that going through an appeal will take awhile. We want to get this app out soon so we can get users on it, so I'm hoping to not have to wait a few weeks.
🙄
Sure, no problem - glad you appreciate it. =) There was no optimizing of it, so it's likely not the fastest but hopefully makes up for that in simplicity - map and reduce have changed the way I look at transforming sets of data.
The C Programming Language by Kernighan &amp; Ritche is a good classic. Scott Stevenson (a significant name in early Cocoa-dev days) wrote "Learn C for Cocoa", which is kind of a quick overview for Obj-C devs. http://cocoadevcentral.com/articles/000081.php A little more unorthodox, but I posted some videos about a cross-platform 2D video game SDK a few weeks ago, which supports Swift. Swift on SteamOS (Linux), OS X, iOS, Raspberry Pi https://www.reddit.com/r/swift/comments/46i6rc/teaser_showing_crossplatform_workflow_for_2d/ Swift on Android: https://www.reddit.com/r/swift/comments/49z8l5/swift_on_android_demo/ Anyway, the SDK also supports C (and Lua and JavaScript). This means the example code gets rewritten in each language. This might be an interesting way to learn C by comparing the version side-by-side with the Swift version. The SDK is still in early-adopter/prelaunch phase, so if you are interesting in getting access, please feel free to PM me or any other Blurrr channels. 
Thanks for the reply. You make a valid point. `.None` is merely syntactic sugar when you pit it against `nil`. However encouraging the use of `.None` is to encourage the developer to switch to a more "Swifty" style in their programming. Much of Swift is enum-case based, like UIColor for example. `view.backgroundColor = .whiteColor()` is valid. So I think it's neither here nor there whether you use either (`nil` or `.None`), but again that's just personal.
Why put it in then take it back out???
Thank you so much =)
Ah that sounds very interesting. Can you tease this out more? I'm curious as to how exactly it changed your views (I'm curious if they changed like mine!) 
Godamnit... Can anyone explain why they would deprecate this?
There's a lesson here somewhere... don't use languages that make breaking changes with each release something something. My company used Kotlin while it was still in beta. What a painful experience. Swift /Xcode users have it extremely easy by comparison. The take away is use Swift for learning and hobby projects, not for commercial code you dolts. Wait until the language is hardened or you get derped. It's simple.
I'm sure Xcode will provide a migrator the moment Swift 3.0 is released.
&gt; LeftPad is available through CocoaPods. To troll, or not to troll
Needs more `O(n!)` func lpad(string s: String, padding p: Int) -&gt; String { if p &lt;= s.characters.count { return s } return lpad(string: s, padding: p-1) .characters .reduce(" ") { (a,e) in a + String(e) } }
That they are a bit obscure to newcomers not from C, that they are even more obscure when used "cutely" (difference between prefix and postfix in expressions), and that they are largely unnecessary since they can be rewritten as +=
&gt; for (int i = 0; i &lt; 10; i++) This is the same syntax across C, C++, Java, Python, Objective-C, and hundreds of other languages. Very basic CS concept right here.
Except Python doesn't have it.
That seems to have fixed it! Thanks! :)
if you really miss `++` `--` you can simply define them yourself, and for loops are just sugar for while loops anyway. for element in collection { }
It's painless as long as you don't have things like for( i = 0; i &lt; something; i+=2 ), that has to be turned into a stride() thing, and then it certainly doesn't become more readable. But hey, it's *more Swifty* so it must be good, right? Rrrrright... (Huge heard of downvotes thunderingly approaching from the horizon)
I don't know how they can argue for removing ++ and -- for being unclear when they leave in operators like ?, !, ..&lt; and ... that are equally unclear until you've read the documentation and studied the language.
That's not really a valid argument for it to be kept around. Goto used to be a very basic CS concept as well, and I don't see many people complaining that you can't do it in Java. 
That would have to be: newcomers not coming from C, C++, C#, Java, JavaScript and Objective C, and I'm sure others I don't know. I'm going to guess that a large majority of developers know at least one of those languages. This decision just strikes me as really dumb. 
Essentially I just mean that any time I see a loop, it can usually be made more expressive ( and simple ) by converting it to map / reduce / filter. For example, in a data service method where you get back an array of dictionaries, then need to convert those to actual models: struct Caching { static let None = "" static let Sample = "api:Sample" } typealias ServiceReturn = ( ( result: ServiceResult, status: ResponseStatus ) -&gt; () ) typealias SampleDataReturn = ( ( data: [TestModel], error: NSError? ) -&gt; () ) func getSomeData( type: Int, completion: SampleDataReturn ) { cacheKey = Caching.BrowseAll let myurl = SecureConfig.string( "baseUrl" ) + "/v1/sample?" let query = "type=\(type)" self.request( .GET, myurl + query, headers: self.requestHeaders( query ) ) { result, status in let myitems = result.data.map { TestModel( fromDictionary: $0 ) } completion( data: myitems, error: result.error ) } } There is some additional support code there so you can see the setup, but the actual method for making a call is getSomeData. The implementation is simple, which I desire for anything that is going to be implemented a lot. Another example would be if you have a list of names, and want to generate a version of that list grouped by an index representation ( like in contacts ). We can create a string extension, then boil the whole operation down very simply using reduce: typealias Catalog = ( String, [String] ) func createCatalog( names: [String] ) -&gt; [Catalog] { let letters = names.map { $0.indexRepresentation } let ret = letters.reduce( [Catalog]() ) { ( acc, val ) in let filtered = names.filter { $0.indexRepresentation == val } return acc + [ ( val, filtered ) ] } } extension String { /// Returns "#" if first character is numeric, else first character of the string. public var indexRepresentation : String { if let first = self.characters.first { if let _ = Int( String( first ) ) { return "#" } return String( first ).uppercaseString } return "" } } I'm sure there are some other things, but these are a couple that come to mind first. =) 
As an update, dispatch_async worked, but when put around the actual "cell.textlabel.text" code, not the reloadData() code, thanks for the tip!
Very good introduction with many details and historical perspective.
Why not advance? Look at python. 4 is breaking yet again. The community hasn't even had a chance to fully move to 3 and they already broke it again to move to 4. Swift isn't a bad language because it is currently doing breaking changes. It will be a bad language if they declare stability in the language and then break anyway. The problem with python isn't so much that it is breaking, it is that they are taking so much time in between breaking. Swift, on the other hand, has maintained that breaking changes will happen for a while yet, and those breaking changes have been coming frequently and with some consistency. Ultimately, it is up to the business to decide, but most shouldn't be actively working with languages that promise to not have stability. Swift does promise stability, just not quite yet (which makes sense for such a young language).
You could do something with a PHP call utilizing the mail function. Requires a server though lol 
Depending on the frequency, mixpanel has an option to send emails to users after certain conditions. Other than that sengrid or mandrill are probably your best options, I don't think you need a server for either. 
Yeah, the Xcode autofix results in a lot of WTF at times.
https://github.com/apple/swift-evolution/blob/master/proposals/0004-remove-pre-post-inc-decrement.md
For those of you wondering what the rationale for this is, check out the proposal: https://github.com/apple/swift-evolution/blob/master/proposals/0004-remove-pre-post-inc-decrement.md In fact, you should all closely follow this particular project, in order to see the sorts of changes that may be coming down the pipeline.
You still need a Mac in order to develop for Mac OS X and iOS. This isn't likely to change anytime soon. 
Yea personally I dislike Xcode quite a bit already, it doesn't help much. ASA Appcode gets good swift support, I'm jumping ship. 
Whoa that's awesome! I'd love to learn more.
I think it's better to - Disable the "." button when it's not able to be used. - i.e. when you enter a "." for the first time. - Enable the "." button when it's able to be used. - i.e. on clear, "=", etc... This way, you don't have to even worry about evaluating the ".".
Thanks! I just responded to your PM.
Agreed that Obj-C is better for integrating C and C++ code, and is a compelling reason why it will continue to be useful and probably a big reason I expect to still be using Obj-C in codebases for years to come. However, I'm reserving judgement on the numerical and matrix math stuff with Swift. The SIMD support added to Swift is potentially really compelling. http://www.russbishop.net/swift-2-simd I've done my small share of writing SSE2 and NEON intrinsics. Good optimized code requires you design your data layouts well in advance to take advantage of SIMD. This is really hard to change after the fact. If Swift can actually do this at a higher level where you do not need to do such rigorous planning or let you change things more easily down the road, while still getting all the benefits of SIMD, this is a big win. 
or..you know..use objc
Why? It was always like this, prefer composition iver inheritance. Now there is also this protocol oriented programming thing. 
+= 1
No, but I suppose you could load your regexes from a plist or plain text file.
if you put { in quotes, you would not need to escape it. What does your regex look like without all the escapes?
Thanks. Since I'm using it in a playground and it's the only preset regex pattern I guess I'll just keep it like this.
http://www.elementscompiler.com/elements/silver/
Doesn't UIBezierPath have a property "CGPath"?
Is this biology? 
And to add on for OP. This is apparent other places in UIKit. For instance, UIColor had a property "CGColor"
Id really take up the suggestion. String with contents of file... Would take less time than replying to this post
Wow. Thanks! I can't believe I missed something so obvious.
Did you consider using a protocol instead of (or perhaps in addition to) generics? Seems to me like any time you have to downcast a generic you are saying it really isn't generic at all? I would figure out what behaviour (functions and properties) i need inside the 'generic' code in order to deal with an event. Then I'd make a protocol containing those functions and properties. Then I'd make every event (no matter what the type) conform to the protocol; which implies I'd need to ensure the functions and properties of the protocol are implemented for that event type. Then in the 'generic' code, I would never refer to the type of the event, I would just say this thing here implements this protocol and as long as I only ever performed functions and properties in the protocol, the compiler would like my code; no casting needed.
you could also try using the unicode escape for some of the special characters. but I'm not sure which looks uglier. Or maybe define constants for some of the special characters or character sequences and then build up the full expression by concatenating? 
That is really cool! It does exactly what I'm looking for! Thank you so much for taking the trouble to really write it all out! **edit:** by the way, I see that you turned `MyDispatcher` into a struct. Now I've seen the talk at WWDC 2015 about using value types like structs, so I know that it's important to consider implementing stuff as value types. But in this case it doesn't make sense to me. To me an event dispatcher is something that has identity, not something that is a value. It's an agent burdened with the task to keep track of events and their listeners. Do you see that differently? I agree that `ErasedListener` should be a struct though, because that is nothing more than a container for another value type, namely the closure.
RTFM will take you far. It's dull at first but...
 Is it possible to make all kinds of apps with swift? From games via unity to reminder apps or gym freak apps etc etc , you know what I am talking about , take any app on the market now , can it be written in swift?
Yep. You'll interact with some libraries that have been written in ObjC but you won't care or likely even notice, and some of those libraries will be replaced over time with swift versions anyway. 
There's only one reason to use Objective-C for a new project now, and that's if you're providing an SDK to other developers who may be using Objective-C.
Probably Swift. ObjC is useful for legacy code and it's also better when integrating systems code and numerical code (both of which are usually in C or C++).
It's a design decision not a religious question. If something makes sense to do it on the client, then do it. My biggest pet peeve with iOS apps: those that can only run with a live internet connection and (same category but worse) those implemented as web apps (because they have shitty battery drain - I'm looking at you Quora!!)
No problem :). Regarding the struct thing, I totally agree. I'm just used to making almost everything a struct unless it's annoying and should be a class, but in this case it definitely makes sense for it to be a class. Further proof of this is that I had to initiate the dispatcher with `var` just to be able to call `listen`.
That's... uh... pretty nifty, actually. 
About 120 examples here: https://backendless.com/blog-a-feature-a-day-challenge/ About 30 examples here: https://github.com/Backendless/iOS-Samples/tree/master/samples/objective-c/backendlessDemos And 30 more here: https://github.com/Backendless/BlogFeatureDay-iOS There is virtually every single function covered. On top of this the examples are included into the API docs: https://backendless.com/documentation/users/ios/users_overview.htm
 I was looking into unity with C# for game making , what do you use for Swift? I don't think unity is compatable with Swift.
If you only target iOS or Mac, you can use Apple's SpriteKit. If you want to go beyond that, here are links on this subreddit about a new cross-platform 2D game SDK I've been developing which allows you to write in Swift. https://www.reddit.com/r/swift/comments/46i6rc/teaser_showing_crossplatform_workflow_for_2d/ https://www.reddit.com/r/swift/comments/49z8l5/swift_on_android_demo/ 
It's an integer overflow. Your sum variable starts at 10. Then, it gets multiplied by 1. Its new value is 10. Then, it becomes 20, and then 60, and then 240, and it grows rapidly after that. To fix this issue, you want to use an Unsigned Integer, which means it can never be negative. This eliminates the lower half of the integer's range and effectively doubles the maximum value of the integer. You can also force Swift to use a 64 bit integer, which allows for a higher maximum value. To fix this, redeclare sum as var sum: UInt64 = 10. This will force sum to be a 64 bit unsigned integer.
New programmers/those familiar with other languages will probably have an easier time learning Swift than Obj-C. If you're learning for immediate/a couple of years from now job potential, Obj-C will probably be the safer choice. The job openings for entry level Swift-only development where I am (NYC) outside of small startups/small contracts for personal apps usually still require ~1-2yr Obj-C experience (just look at the jobs section on natashatherobot's site or at the Swift jobs subreddit for an example). If you're aiming for beyond that only, then Swift may be the better choice. There's nothing stopping you from learning both, and it's very prudent to do so, but you have to remember that most of what you will do as an iOS developer is interacting with the Cocoa Touch libraries. It doesn't make too much sense to invest all of your effort into doing it from Swift only if a)The ABI isn't stable, and b)The syntax for interacting with Cocoa Touch from Swift looks pretty much like using Obj-C right now, but it will look completely different in a year. Job prospects could be different in other parts of the world though, you should do research specifically for where you're staying/want to stay.
I had tried this by declaring var number: UInt64 = 100 But then the compiler barks at me and says "Cannot convert value of type 'UInt64' to expected argument type 'inout Int'
Are you sure that sum, number, and i are all UInt64? The error is occurring because you're multiplying two numbers of two different types together. To fix this, make them all UInt64.
Hmmm...I have to specifiy i as UInt64 when doing range iteration? var number: UInt64 = 100 for var i in 1...100 { number *= i } The above barks at my on number about inout. If I change it to something like: var number: UInt64 = 100 var i: UInt64 = 100 while i &gt;= 0 { number *= i i -= 1 } This 2nd one gets me the crash again that I had at the start. 
I just wrote the code on my computer. The issue is that even with UInt64, number gets so high by the time you reach 20, it overflows the integer. The maximum value of UInt64 is 18446744073709551615. After 19 iterations, number is 12164510040883200000. When iteration number 20 occurs, it overflows number. In this case, try using Float or Double, they have even higher maximums.
Thanks, I'll fiddle some!
Very informative, thank you!
Because 20 is the smallest number n such that 10*n! &gt; 2^64, the size of an Int in Swift. Hence the sum variable is being overflowed. I believe Python allows arbitrarily large integers, so this wouldn't be a problem there.
Maybe he wants to hire a programmer himself without the investor? Maybe he already has an investor? 
You are correct, Unity does not use Swift. They are completely unrelated. Edit: I didn't answer your question really. XCode/Swift is generalized and allows you to create anything you want, including a game. Unity/C# is specific to games. It offers an interface and set of libraries to make game development very easy. Second, Swift will eventually replace Objective C, so it's not worth sending much time on.
And what the hell does 🌀 mean?
Also having fonts and colours injected after initialising from storyboards really isn't hard. Just use the didSet method. Have a read of [this](https://thatthinginswift.com/kill-your-viewdidload/).
mixed feelings... 
Don't do that if you want an exact result. Float and Double can represent very high numbers, but they can't represent integers at some point (which occurs at an even lower value than what is possible with Int64). It won't crash though, just be imprecise.
You can download Xcode 7.3 from Apple's website for developers and copy appropriate files from it to your Xcode 7.2.1. You should copy iOS 9.3 directory from Xcode7.3.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport to the same destination in your Xcode 7.2.1. It will make Xcode 7.2.1 recognize devices with iOS9.3
I greatly prefer Carthage. Cocoapods' implementation is very hacky and I don't like the mess my project turns into.
Typhoon. A [typhoon](https://en.wikipedia.org/wiki/Typhoon) is a mature tropical cyclone that develops in the western part of the North Pacific Ocean between 180° and 100°E. This region is referred to as the Northwestern Pacific Basin, and is the most active tropical cyclone basin on Earth, accounting for almost one-third of the world's annual tropical cyclones. 
Neither. And here's a good read on why: http://www.haneycodes.net/npm-left-pad-have-we-forgotten-how-to-program/
It sounds like you don't even understand what exactly that article is about.
honestly im gonna have to suggest that maybe its just a squiggly blue line. In which case it ends up as he `squiggly blue line`'s storyboards. i could be wrong^but^probably^not
I use neither. But most "Pods" I could write in a few hours anyway myself.
Try whichever one takes your fancy first, then see if you like it. Although CocoaPods has broader support, Carthage is becoming an increasingly common option, so you might only be causing yourself minor inconvenience choosing it over CocoaPods. I think the differences are very much personal taste things. For example the selling points of Carthage have no appeal to me and I'm happy with CocoaPods, but there's plenty of people who feel the complete opposite. 
As someone who has been running El Cap for a while now, I find it more stable then Yosemite and fully enjoy it. It's not a big jump change wise, and you get more security and stability. As with anything, It's always up to you. Also, it's good practice to go through your keychain and remove all expired certificates at least once a year (I usually plan to do it before WWDC before the betas are announced). This helps remove any expired or outdated certificates.
Swift. I originally learned Obj-C because there was no Swift yet. When I made the switch I hated swift for about 2 weeks or so. Now I wouldn't go back to Obj-C if you paid me. The only reason you should learn Obj-C now if is if you are working with legacy code. If you are just starting out, Swift is the way to go. 
Swift. Definitely, Swift.
Strictly the Apple guidelines specifically say: "Apps should have single purpose and if they don't, you are doing it wrong". From a UX point of view on a mobile device, this is absolutely correct. If your app as complexity problems, you have almost certainly architected or implemented in correctly - which is probably most of them. Storyboards work really well if you've thoughtfully designed your UI and researched clearly your user's usage **first**. Doing this is NOT programming BTW - it requires thinking about pretty much every but programming so just jumping into Xcode instead is Epic Fail. You are doing app/product design wrong if you do this.
I haven't used carthage yet, but I feel like using it because it doesn't edit the proj file. When team members aren't careful with cocoapods, like running pod update instead of install, and not telling anyone about it, you will have a really huge merge conflict in the proj file when trying to pull changes if you made your own changes that affect the proj file. Also had problems using cocoapods in unit tests, and it was hard to get working as some solutions simply don't work. They may change how cocoapods works again and may cause problems again. Also carthage is supported for anything that's on git. Cocoapods needs to be supported by someone. 
Picked the wrong subreddit to ask this question... Everyone here (including me) will tell you to use Swift. Maybe /r/iosprogramming will have some more diverse opinions.
So what about creating a class and having one of its properties be a closure? Then create an instance of the class, set the property to the closure, then stick that instance in the dictionary? That seems like it should work, but I have no idea if what you are planning is a good idea or not. I can see certain utility to it, but there's bound to be some kind of problems and the question is how big they are. Like, I'm sure the first person who ever said, 'Hey, we can just take the user input and execute it as an SQL command' probably saw the utility, but then the problems set in. So, have fun!
That's a pretty good idea, and I've actually had to do similar things elsewhere. I'm using the Freddy Json library, and it parses things out to structs, which also can't be casted to an AnyObject, but can be cast to Any (this goes for collection objects containing them as well). Looks like the other commenter tried it so I'll give that a shot, thanks!
As I mentioned elsewhere I had to do this for structs, and didn't even think of wrapping the closure, thanks for testing it. 
If only this worked well with Xcode =/ Currently you have to do a lot of manual setup to get an Xcode project working. More than with Carthage.
Thanks for you attempt to answer my question. I think I wasn't fully clear. I know about protocols and yet in this particular case that doesn't help me. Since the two types that I want this function to accept aren't two classes or structs. They are a String and a meta type of a protocol. And you can't make a meta-type inherit another protocol.
I'm with you. They don't want to hear this. Instead of programming, they "configure". Then when it breaks or doesn't survive an upgrade, they are stuck scratching their heads. "Hey, I need to parse some basic JSON. Better install a pod..."
If you're able to do it, its probably better to listen for the notification with a closure instead `addObserverForName:object:queue:usingBlock: ^(NSNotification * _Nonnull note){}` (sorry i pasted the signature from Obj-c but it still is valid in swift) and just define a top level function if you really want to you could probably even extend NSNotificationCenter to have a helper method that adds observer objects with your closure function
This looks very odd, like you need to rethink what you’re doing with `arr` and not put `cell.configureCell(arr[indexPath.row])` inside those loops.
Am I missing something? Isn't this a problem that can be solved without getting unnecessarily fancy? func doSomething (T: Event.Type) { // here 1 } func doSomething (T: String) { // here 2 } Then, if needed, you could abstract a portion of the code that they share.
Ah yeah I re-read your question and it's my bad. I was on my phone and tried to answer. Maybe you could create an enum that you pass into the function instead like this: enum MultipleTypes { case TypeOne(let typeOne), case TypeTwo(let typeTwo) } func functionThatTakesEnum(parameter:MultipleTypes) { switch parameter { case TypeOne(let typeOne): // handle type case TypeTwo(let typeTwo): // handle type } } functionThatTakesEnum(MultipleTypes.TypeOne(object)) 
This is exactly what I have now. The reason I want to put it into a single function is because the code for those two functions is nearly identical. Yet they are also just 1 or 2 lines long so making a third private function as another layer of abstraction also seems a bit overkill.
It says "there are currently no plans for a new offering on iTunes U at this time". I loved the iOS 8 one, last year, but, unfortunately, we are not going to get iOS 9 from the great Paul Hegarty.
Coming from using CocoaPods in several large projects with reasonably long and complex lists of dependencies, I haven't found CocoaPods to get in the way. There were earlier releases that had bugs that caused trouble at times, but it's stable and reliable now. As an example of the complexity you can manage simply with CocoaPods, in a previous team I worked in we had publicly published pods of some of our in-house libs, but we also had development branches of them with unreleased changes, and we also sometimes needed to work on local copies of them on the dev's laptop with uncommitted changes. These libs were also interdependent, and an unreleased dev branch might also depend on changes in another lib's unreleased dev branch. It was trivial to manage that with simply three lines in the Podfile for each lib, two of which would be commented out at any point in time. To switch between the public release, the dev branch with unreleased commits, and the local copy with uncommitted changes all we had to do was change which lines were commented out in the Podfile, do a `pod install`, and you were ready to go. It would also worked well for having different branches of the app on different dependencies. After changing branches (and thus getting a different Podfile specifying different dependencies) just do a `pod install` and it'd update the project to point to all the right things and be ready to compile. I don't think you can get that level of ease when managing complexity in Carthage. Though I might be wrong. Oh, here's an example of the three lines I'm talking about, in one of my personal projects: #pod 'MGEvents' #pod 'MGEvents', :git =&gt; 'git://github.com/sobri909/MGEvents.git', :commit =&gt; 'aa9086f' pod 'MGEvents', :path =&gt; 'LocalPods/MGEvents/' The first line would use the latest publicly published release. The second line would use an unreleased commit. The third line uses my local copy, with potentially uncommitted changes. I use the third line when I'm making and testing local changes. Then once the changes are good I commit them, push them, and switch back to the second line.
You want to use the builder pattern. You make a object that has all the fields you'll need at the end, create it for the first screen, and pass it to the second screen, and on the final screen you interpret it according to what you're looking for at the end.
Yeah but that's also what everyone says when asked about future products. The key part of the phrase is "at this time". They could release a new class tomorrow and the statement would still be correct.
~= is the pattern matching operator. It is similar to how switch statements work in matching patterns. So what this if 5…10 ~= aRound!.roundScore! is doing is: if aRound!.roundScore! matches the pattern (or in this case is in the arra) 5...10. If say the right hand is 7 this would be true because 7 is in the range 5 to 10. The pattern here is 5 to 10.
If they're just 1 or 2 lines long, I strongly recommend leaving them the way they are. There's no way to unify them without doubling the complexity, and the code for handling each of the two types will be just as complex as having a third private function.
It's great that we have classes now, but many programmers of my generation got a lot of learning done by dabbling. There's something about playing and exploring that seems to enhance the learning. Explore. Ask why something is done that way, or what happens if you change this thing here. I would hold off on Objective-C until you have your C class. ObjC is just C with some object-oriented message passing tacked on. Personally, I think it's still worth learning. Swift is pointer-free as Java is, so that's where I suggest you do some dabbling now. To write apps, you'll have to understand UIKit for iOS or AppKit for OSX. You probably want to get some classes or training so you know your way around. There are a few self-directed approaches: * [Apple's videos](https://developer.apple.com/videos/): Apple's talks are always well done. * [Developing iOS 8 Apps with Swift](https://itunes.apple.com/us/course/developing-ios-8-apps-swift/id961180099): This is an online course from Stanford University. I haven't viewed it, but I hear good things, and it's free. Also, get in touch with local programmer user groups like NSCoder or Cocoaheads. There may be meetings in your area. People are friendly and will help you find resources.
Thanks, I think what partly through me was the use of the phrase pattern matching. In my mind I associate this a lot more with text than with integers.
Okay I will
This isn't a future project. They would need to be filming now. If you watched the iOS 8 course, Paul was frequently referencing "the iTunes U folks."
start with xcode playgrounds, you can download some directly from apple, then check someone else code and then try to write something. That works out for me
1. If your data is small, use NSUserDefaults. Data is persisted on the device, and can be accessed using simple keys, 2. Dependency injection is another easy way to pass data between view controllers. Data can be passed on "prepareForSegue", or upon instantiation of the destination view controller, 3. Writing a file to disk. Using a .plist format and writing the file to disk can be another way to persist data for future use. It's the "more difficult" of the options, because it does require some knowledge of NSFileManager, or other disk utility classes. Hope this helps, good luck!
i totally agree!
TBH, I think a developer needs SOME music knowledge to make a DJ app... Otherwise "dropping the beat" might be a reference to mishandling a vegetable. 
swwweeeet 
I linked to that, I just can't build it.
did you add this to the path: export PATH=path/to/toolchain/usr/bin:$PATH?
If you have to ask, probably not.
There was some discussion on the swift-del mailing list about it. https://lists.swift.org/mailman/listinfo/swift-dev You might want to try asking there. Last post I found was in early December.
Have you reported the repo to github?
Diff of his and your file definitely looks like he "borrowed" your work and the fact he deletes your issues just confirms what kind of person he is. [Report him](https://github.com/contact?report=robipresotto).
From your software's license: &gt;Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including *without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so*, subject to the following conditions: &gt;The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. I'm not a lawyer, but I don't think he may have not done anything *legally* wrong here. In the future, you may want to consider [other software licenses](http://choosealicense.com/licenses/). I recommend BSD for your purposes. It forces other to include an attribution to the source of their code. Also, it may be fair to give this guy the benefit of the doubt. Perhaps he means to expand on your code, and needed a jumping off point. Send him a message and see what he says, but I don't think there's anything you can force him to do here. EDIT: After re-reading the license on both repos, it seems he is stealing from you. He edited the license to indicate himself as the author, which may not be legal, but is certainly immoral if the two are the same. I would follow the advice of the other posters and report him. 
And since he closed my issue and banned me I [trolled him again](http://imgur.com/g2QPGvj)
I highly recommend Treehouse. Treehouse is free the first 3 months. Thats a really good way to get into the very basic part of programming. And then you just have to practice, practice and practice. If you want to create Iphone apps, learn to program with Swift. If you want to create websites, start learning HTML. Its important that you only studying ONE language to begin with. 
Swift 2.2 doesn't include the package manager (since it isn't stable yet), this was mentioned in the announcement: https://swift.org/blog/swift-2-2-released/
I gave you a star too now. At the moment you have 833(!) stars compared to the other guy's lowly 50 stars. lol
Also gave a star, good luck!
Might also want to contact [cocoapods for a take down](http://cocoadocs.org/docsets/ImageColors/0.1.0/index.html) 
No I totally agree with everything you said, I only posted the question with the hopes that someone HAD come across the issue and had an answer! In this case the only things both issues had in common were the fact that they were both on the same project, and both happened at some indeterminate point after a push to github. Unfortunately not much to go on, that's why the lack of detail in my original question. No errors, I didn't move any folders or change any files... I didn't even add or remove any assets from the project. Just a push and then *POOF*. Anyway, thank you regardless for the detailed response. Learned the back up lesson after the first vanishing act!
First things first. I use your project in an app I am working on. Thank you, it works well, and I thoroughly enjoy it Second thing second. I'm going to try to out the guy also. What a scumbag. Edit: ok. I reported him also. 
Just curious, how did you find out someone was stealing your work?
Ok, so I'm going to be contrarian here and point out the fact that the newer one actually adds onto what you did and isn't just a straight copy: 1. He added a value that gives you all the colors and not just the primary ones. 2. His version is returning the results in a block rather than just as a struct, which may/may not be useful if he's planning to make it a background thread. 3. He's added a test project which yours didn't have. As far as open source goes, I don't think he's really doing anything wrong here. Now, could he have mentioned specifically if he used your code to start? Sure, but at the same time most of the hard work of extracting the colors came from Panic, so I'd probably mention them before you. Basically, this is kind of how open source works so I think you're overreacting and need to lose the pitch forks. Edit: I'll add that if you really don't want people using your code you probably shouldn't be using an MIT license. It's pretty liberal as far as what you can do with it.
Thank you very much!! It worked perfectly!!! I was going crazy, I uninstalled / reinstalled Xcode and was about to reinstall OSX.
Sorry, to be more clear: they were already in an asset catalog and they disappeared from THERE. There are random questions here and there from folks who have also experienced this but no real answers, just thought I'd run it up the flagpole here to see if it had happened to anyone else recently.
This is the right answer, assuming either party is in US. 
I didn't miss anything. Trying to start a Reddit lynch mob is still an overreaction. What he's doing is a little douchey, but not worth losing sleep over. Genuine question: does it really affect you how many internet points he gets off his variation? 
I merged your repo into his, and [submitted a PR](https://github.com/robipresotto/imageColors/pull/10), we'll see if it lasts. Either way, my fork should now show the full history of your repo when looking at the [fork network page](https://github.com/robipresotto/imageColors/network)!
No. Well, you could compile the open-source compiler, and you might be able to trick Xcode into using it, but it'd be a lot less effort to convince your boss to let you upgrade to El Cap.
I wouldn't need Xcode to use the new compiler. Upgrading isn't an option...I originally upgraded to EC and had to downgrade/restore because I simply couldn't get my work done.
Well, if you want to compile your own copy of the open source Swift compiler, it's up on github, go forth and conquer.
If you aren't working with StackViews already then you should be.
Did not go far. :) +1 for effort.
Have you tried with "Reset to suggested constraints"?
For simple UI do not use custom size classes. Use **wAny hAny** size class. Set constraints once and it will be ok on all devices.
reading the comments here I'm not sure whether to be delighted or to be disappointed. I really hope to see the iOS 9 ones from Paul Hegarty - the iOS 8 one was awesome - although i went under the water pretty soon (like 3rd lecture or so) - just like he had guessed one would if you're not a **strong** OOP programmer.
&gt; This is still how open source works. He removed attribution and put his own copyright notice on it. This is *not* how open source works. This is not how copyright works either. 
If they were committed to Git, then your Git history will show you which change deleted them. You can then either revert the change, or retrieve those files individually.
Do you know what the difference between a singleton and a class method? Singletons definitely have their place and are useful, but Global state shouldn't be abused. It really depends on what is being done. E.g Network Managers, Audio Players, etc... I view class methods as quick utility methods that have one small specific function that doesn't rely on anything else with the class. So long story short, it depends. More information on what you are actually doing would be helpful.
It sounds to me like your looking at an API layer ? Usually an API would be a singleton since it uses the NSURLSession singleton inside it and would usually have a ref to it, also so you can add calls to queue to cancel and stuff.
So weird... the assets are showing in the Github repo now, but they are not showing at a place in history that I know for a fact they were in the project. I'm going to chalk this one up to "screw it" since my binaries are all backed up outside of Git anyway. Thanks for the suggestion though, I hadn't thought to review the change history.
Each thing being voted on can have a record of all the user ID's that voted on it. Maybe an "upvotes" array and a "downvotes" array. Check to see that the user's ID isn't already in one of the arrays before changing the score.
While you are roughly right (it's not a nice move from him), what you did(panic did) is a bit trivial to file a takedown for ;-p, just handle this professionally, i.e. don't care! That project is not really valuable it's not world changing, it's not even worth mentioning (sry). if it were something where he makes money off of your work or you had any disadvantages from, then that would change a little. What is actually happening is you copying panic (while you say almost identical, they say all rights reserved ;-p) I'm not sure you follow the rules set by their licence: &gt; - Redistributions must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. their licence is btw not an MIT licence xD 
Have you found a solution/tutorial for this? I'm trying to do the same thing where I can pull up the user's contacts and add the selected information into some textfields
You're missing a closing curly brace before `func applicationDidBecomeActive`.
You are missing a "}" in the didFinishLaunching function.
It will take getting used to not using '++' and '--'.
Here is my code. Under the last bracket I get the error "expected declaration" I am about to cry. import UIKit @UIApplicationMain class AppDelegate: UIResponder, UIApplicationDelegate { var window: UIWindow? func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool { let oneSignal = OneSignal(launchOptions: launchOptions, appId: "05b1ff33-ed2d-4b51-a0a2-888e4e456b4c", handleNotification: nil) _ = OneSignal(launchOptions: launchOptions, appId: "05b1ff33-ed2d-4b51-a0a2-888e4e456b4c") { (message, additionalData, isActive) in NSLog("OneSignal Notification opened:\nMessage: %@", message) if additionalData != nil { NSLog("additionalData: %@", additionalData) // Check for and read any custom values you added to the notification // This done with the "Additonal Data" section the dashbaord. // OR setting the 'data' field on our REST API. if let customKey = additionalData["customKey"] as! String? { NSLog("customKey: %@", customKey) } } } func applicationDidBecomeActive(application: UIApplication) { // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface. } func applicationWillResignActive(application: UIApplication) { // Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state. // Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game. } func applicationDidEnterBackground(application: UIApplication) { // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later. // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits. } func applicationWillEnterForeground(application: UIApplication) { // Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background. } }
Here this should work: import UIKit @UIApplicationMain class AppDelegate: UIResponder, UIApplicationDelegate { var window: UIWindow? func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool { let oneSignal = OneSignal(launchOptions: launchOptions, appId: "05b1ff33-ed2d-4b51-a0a2-888e4e456b4c", handleNotification: nil) _ = OneSignal(launchOptions: launchOptions, appId: "05b1ff33-ed2d-4b51-a0a2-888e4e456b4c") { (message, additionalData, isActive) in NSLog("OneSignal Notification opened:\nMessage: %@", message) if additionalData != nil { NSLog("additionalData: %@", additionalData) // Check for and read any custom values you added to the notification // This done with the "Additonal Data" section the dashbaord. // OR setting the 'data' field on our REST API. if let customKey = additionalData["customKey"] as! String? { NSLog("customKey: %@", customKey) } } } } func applicationDidBecomeActive(application: UIApplication) { // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface. } func applicationWillResignActive(application: UIApplication) { // Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state. // Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game. } func applicationDidEnterBackground(application: UIApplication) { // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later. // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits. } func applicationWillEnterForeground(application: UIApplication) { // Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background. } } 
I think this is exactly what I'm looking for, I tried this before but it wasn't working, I didn't use the parentheses after Mon. Thanks a lot!
no they wont contain the same information, sorry misleading example.
Can't you always reimplement them as custom operators?
"p++" is just "p+=1", but "++p" is more difficult to implement.
Well I have the following problem, I have multiple image sets and based on a parameter I have to use certain sets (which will be constant). So for example when I get parameter "1", I want to use all constants from struct 1, when i get parameter "2", I want to use all constants from struct 2 etc. This way I only have to pass the parameter from view to view, and then each view knows which constants to use
ok your use case sounds like a perfect match for enum. This is the structure of the configuration of the images. Right now it has three different cases of the configuration, but notice that the different cases all **belong to the same enum**. Also notice that the different cases can have **different associated values**. enum ImageConfig { case TypeOne(param1: Int, param2: Bool) case TypeTwo(param3: Float) case TypeThree } Somewhere else you'd initialize the configuration like so. Now you have different configuration depending on your needs. let t = ImageConfig.TypeOne(param1: 3, param2: true) let g = ImageConfig.TypeTwo(param3: 3.3) When you pass the above initialized "ImageConfig" to a view controller, you'd put some like below in the "viewDidLoad" function: switch configuration { case let .TypeTwo(constant1): print(constant1) case let .TypeOne(constant1, constant2): ...... default: break } All configuration are the same type.
Yes, I'm rather glad they are gone. I used them in my own code extensively, but only because they were there to use. Definitely feels like a pointless speed bump for beginners.
The destination is a NSURL that saves to the Temp Folder. The frameProperties contains a delay (0.1 seconds). for time in timePoints { do { let imageRef = try generator.copyCGImageAtTime(time, actualTime: nil) CGImageDestinationAddImage(destination, imageRef, frameProperties as CFDictionaryRef) } catch let error as NSError { print("An error occurred: \(error)") } }
I'd make a general function to find a node of a certain type, then you can easily reuse it wherever necessary. Please note that this was written in-browser and I've never used SpriteKit myself (in particular I don't know what type "physicsCategory.enemy" is, but I think UInt32). func findNode(contact: SKPhysicsContact, type: UInt32) -&gt; SKSpriteNode? { if contact.bodyA.categoryBitMask == type { return contact.bodyA.node as! SKSpriteNode } if contact.bodyB.categoryBitMask == type { return contact.bodyB.node as! SKSpriteNode } return nil } ... if let enemy = findNode(contact, type: physicsCategory.enemy), let projectile = findNode(contact, type: physicsCategory.projectile) { enemyProjectileCollision(enemy, contactB: projectile) } Edit: fixed a typo
I guess both aren't that hard. can be implemented like so: func postAdd(inout x: Int) -&gt; Int { let current = x x += 1 return current } func preAdd(inout x: Int) -&gt; Int { x += 1 return x } var a = 3 var b = 9 postAdd(&amp;a) * b preAdd(&amp;a) * b
Again. You are my hero
I work for an agency that builds apps, sometimes for startups. In my experience people with app ideas and no programming skills vastly undervalue developers. Maybe this is not a case of that, but it smells that way to me.
True I was more referring to AFNetworking really and still a singleton is usually used to manage queues traditionally
Check the FAQ link to the right. In general, just start coding as much as you can. Don't just "read about" coding; actually start doing it and let yourself make mistakes - it's the only way to learn.
Singletons are meant to manage resources with single or limited instances (think a SQLite database or a connection pool) and you have to be careful about multithreading.
Try here: https://www.reddit.com/r/learnprogramming/ I would say that learning programming is not about syntax, as beginners always seem to assume (syntax = getting spelling and code formatting correct, knowing how to type code). Its about learning how to design in the framework (paradigm) a programming language provides (there are different frameworks and quite a few different languages for each framework). Its about learning how to solve problems through design. Its not about 'math' as most beginners think it is (algebra, differential equations and school math). The logic for programming and problem solving is very much connected to one particular field of math not taught in schools, because its halfway between math and computer science: Discrete Math.
Omg I can't wait to replace xcode with this!
I believe the answer is no... What I have done in the past is create a texture with the data I need in it (SKMutableTexture) but you do have to watch the format. 
I like AppCode but it is always two steps behind what Apple releases. I hope Apple purchases AppCode and makes that the new Xcode so we can commemorate getting rid of the crappy Xcode we have today, forever.
thank you!
UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil) Should be UIImageWriteToSavedPhotosAlbum(self.capturedImage, nil, nil, nil)
Depending on how you formulate, it is a hard task. I'm pretty sure that you won't find an app builder to do that for you without getting your hands (very) dirty. 
Reverse image search sounds like a very technically intensive feature. Somehow I don't think that would be part of a standard app builder feature set. Relevant XKCD: http://xkcd.com/1425/ 
Good idea about the stripping out for copy/paste and external keyboard. I hadn't thought of that (I'm still learning this Swift/iOS thing). I still like the UI of numbers-only, though, just so it's clear to the user what's expected. Also, it was good practice to just get it working.
They would never do that, it's the same IDE has android studio essentially :p
The enum type in Swift goes beyond C#. The 'if let' statement is cool also. Other than that I still like C# better. (Source: I am a C# and Swift developer)
It wouldn't hurt if you actually said what the problem was. You and u/nathanello have the same homework, maybe you can help each other...
Not homework, but any help would be appreciated. My issue is that the collision is not registered.
If you look at the thread the other guy posted on this same topic, I think you will see why: you are only testing for one of two possibilities. 
My app crashes and I get an error saying: fatal error: unexpectedly found nil while unwrapping an Optional value. UIImageWriteToSavedPhotosAlbum(self.capturedImage.image!, nil, nil, nil) 
why not? they simply remove that part. A little part of me dries every new release of Xcode.
I might have understood your question in the wrong way. If you want to use the character to be able to play with it in your game you have no other choice, at least I don't know of a better way, than to create a sprite for every possible combination. 
Nope, you understood it right the first time :). That's exactly what I needed. It's just a static image that can wear different items. Thanks!
&gt; Also, a source for the 4x figure regarding RAM usage of the garbage collector would be interesting. Here you go: http://www-cs.canisius.edu/~hertzm/gcmalloc-oopsla-2005.pdf 
Extension methods seem to be closer to Obj-C categories than Protocol extensions. First, remember that these are protocols (aka interfaces), not classes or structs, which allows sharing/reuse by classes/structs that are completely unrelated. Protocol extensions can be utilized to give very fine control over what specific things you want to define methods for in both structs and classes. Categories while interesting, had the problem that they applied globally and indiscriminately for everything in the class hierarchy. Protocol extensions seem to go in a different direction and added much more power to finely control access to what can use them. Mike Ash presents two examples here: https://mikeash.com/pyblog/friday-qa-2015-06-19-the-best-of-whats-new-in-swift.html One shows how to add an extension to CollectableTypes, but only if they also conform to Comparable types. The other shows an interesting case of static vs. dynamic dispatch. Anyway, the point is that this feature is both unusual and far reaching enough that it may result in Swift developers thinking about and implementing programs in very different ways than you would in other languages. That’s what I mean by semantics. 
You nailed it. Completely missing the mark on MVC. 
Just in case it's useful for future readers, here's the delegate method I used that limits the input to digits. // // Make sure only numbers can appear in text fields // func textField(textField: UITextField, shouldChangeCharactersInRange range: NSRange, replacementString string: String) -&gt; Bool { for c in string.characters { // The ~= operator (tilde and equals characters) tests to see if the range on the left contains the value on the right. if !("0"..."9" ~= c) { return false } } return true }
Force unwrapping is a big one. Not using the higher order SequenceType functions and writing complicated algorithms is also a big sign. The biggest thing I think is when a developer lets any single class get too unmanageable. ViewControllers are a big offender, but custom views, table view cells, and plenty of other classes can get out of control as well. I hate seeing complicated state machines inside views when you could just have multiple views. 
I'd say that most single-purpose UI pods are usually crap and you're better off just copying the code into your project in the case they do work well. But I'm not going to reinvent something like ObjectMapper and Alamofire, sorry. They just work, tested over and over by thousands of developers. Same goes for some other libraries.
What state do you have to maintain?
No, that seems pretty good. Coming from Haskell, we see stuff like that somewhat often. We prefer to use the State monad though. But Swift doesn't really have a good way to represent computations like this with a monad like State. struct State&lt;S, T&gt; { let runState: S -&gt; (T, S) } func getState&lt;S&gt;() -&gt; State&lt;S, S&gt; { return State&lt;S, S&gt; { s in (s, s) } } func putState&lt;S&gt;(s: S) -&gt; State&lt;S, ()&gt; { return State&lt;S, ()&gt; { _ in (s, ()) } extension State { func fmap&lt;U&gt;(f: T -&gt; U) -&gt; State&lt;S, U&gt; { return State&lt;S, U&gt; { s in let (newS, t) = self.runState(s) return (newS, f(t)) } } func apply&lt;U&gt;(fState: State&lt;S, T -&gt; U&gt;) -&gt; State&lt;S, U&gt; { return State&lt;S, U&gt; { s in let (newS, f) = fState.runState(s) return self.fmap(f).runState(newS) } } static func of&lt;S, T&gt;(t: T) -&gt; State&lt;S, T&gt; { return State&lt;S, T&gt; { s in (s, t) } } func flatMap&lt;U&gt;(k: T -&gt; State&lt;S, U&gt;) -&gt; State&lt;S, U&gt; { return State&lt;S, U&gt; { s in let (newS, t) = self.runState(s) return k(t).runState(newS) } } } So while we have a useful definition of state, it'll be pretty ugly to use, especially without `do` notation. In Haskell, we could write this function quite nicely, like so. reduceState :: a -&gt; (a -&gt; b -&gt; State s a) -&gt; [b] -&gt; State s a reduceState a f [] = return a reduceState a f (x:xs) = do newA &lt;- f a x reduceState newA f xs -- Use case (finalState, reduced) = runState (reduceState initialA f [1..10]) initialState where f a x = do s &lt;- get let (s', a') = doSomething s a x put s' return a' In Swift, it's going to look something like this. extension Array { func reduceState&lt;S, A&gt;(initial: A, f: (A, Generator.Element) -&gt; State&lt;S, A&gt;) -&gt; State&lt;S, A&gt; { var reduced: State&lt;S, A&gt; = State.of(initial) for elem in self { reduced = reduced.flatMap { a in return f(a, elem) } } return reduced } } -- Use case let (finalState, reduced) = [1..&lt;11].reduceState(initialA) { (a, elem) in return getState().flatMap { s in let (newS, newA) = doSomething(s, a, elem) return putState(newS).flatMap { _ in return State&lt;S, A&gt;.of(newA) } } }.runState(initialState) So while the actual implementation of `reduceState` doesn't look so bad, the use case looks absolutely awful in Swift. This isn't all that useful on its own anyway. Why use a State monad when we can just manually thread a state variable through the function? Well in Haskell, it's because we can make this function work with *any* monad, not just State. reduceM :: Monad m =&gt; a -&gt; (a -&gt; b -&gt; m a) -&gt; [b] -&gt; m a reduceM a f [] = return a reduceM a f (x:xs) = do newA &lt;- f a x reduceM newA f xs And now this would Just Work™ with the State monad, or any other. But in Swift, this isn't possible, because we don't have higher kinded types. So in Swift, we can only implement this as `reduceState`, and have it be confined to the `State` monad. Because it can't be more general, and because the use case code is so ugly, I'd recommend not using a `State` monad for this task. While it's very elegant and Monadic in theory, in practice Swift just doesn't support making monadic code easy to write or read. It's not worth the trouble if you can't generalize it to all Monads (which you can't). Conclusion being, your current implementation is probably the best you're gonna get
&gt; 'var' variables that are init to zero or empty ( "" or []) I'm not sure what you mean. Sometimes you want an empty array to add stuff to I guess? The empty string might be mitigated without actually making it empty.
Would anyone recommend a style guide resource to follow in regards to large apps to avoid some of the pitfalls mentioned?
What is force unwrapping and how do you properly handle unwrapping optionals?
To avoid force unwrap,IMO, you should do in order: - use optional.map {} - use if let - use guard
Some of the filter/reduce closures need to know what data has come before, so some of the filter/reduce closures need to save off that info. Sorry, I don't want to be too specific about what I'm doing. 
The "right" way is probably to use an optional declaration. An empty list is kosher IMO, but for other types, the optional is the way to go. E.g., var names: [String] = [] Likewise: var name: String? Swift gives us optionals as a tool. Use them over values which indicate "nil-ness". Since arrays are often used to be iterated over, declaring the entire array as optional is often unnecessary since it's an extra step that doesn't provide much type safety.
Awesome, thanks.
IMO `guard` should be preferred over `if let` in most situations. Really interested in how optional.map {} works. Could you give an example?
`var names = [String]()` preferred. 
By the way, you're not technically initializing that variable. You're assigning the variable a `nil` value, and in your context your compiler should be complaining already because you specified the variable as type `[String]`. An correct and equivalent way of writing what you wanted to write is: `var variable: [String]?` which has a default value of `nil` until it's been assigned elsewhere.
I've been using `if let` when I need to do something once with an optional, and `guard let/else` when I'm going to use it more than once over the length of a method. Is that an anti-pattern of some description?
It *seemed* the right way - the optional binding in `if let` is only in scope in the brackets, while `guard let` binding stays around, so I kind of inferred how to use them.
He always explains things super well. Maybe my pea brain will someday gain a better understanding of programming so that I can actually make use of these lessons and tips.
It is. It's kinda great though, starts semi-plausible, ends absurd. It'll never be useful with our current computation model.
For anyone wondering: the approach can't possibly work unfortunately. Using n bits for a seed of a number generator can create that same number of different sequences at most, you don't actually compress anything. You'll just have a lot of possible data that you can't compress because given some input data, it's (depending on the data size) very likely that the random number generator does not generate that data for any possible seed. Another easy way to think about this is to imagine that instead of a random number generator, we have a table with n rows, each row containing some data. Can we compress arbitrary data by looking up the row index of that data and sending that instead of the data itself? Of course not, the data we want to send is either very likely not in the table, or the index needs to be as large as the data itself. A random number generator is equivalent to such a table, just that the data in each row is given by an algorithm, and not stored directly. Edit: further reading for anyone interested in some hard math: https://en.wikipedia.org/wiki/Shannon%27s_source_coding_theorem Also a fun story related to compression (note that the guy who solved the problem did so using a loophole in the problem statement; without the loophole, it's mathematically impossible to do this): http://www.patrickcraig.co.uk/other/compression.php
I interned at a startup during the summer (Not for anything iOS related) and another intern made an app like this. Had a ton of fancy UI effects, but it had over *20* pods near the end..
It is an April fools prank, and a clever one. Technically what he's describing is not only possible, but provably true. The only problem is that the "seed" number used to generate the sequence is almost always going to be orders of magnitude larger than the sequence itself. So you're not saving any space by sending a seed number instead of sending the whole list. Another problem is that finding that seed number in the first place, even for relatively small lists, will take longer than the heat death of the universe. But, hey, it all happens in the cloud. If you're curious about how this stuff works, look up a similar scenario where the works of Shakespeare are thought to be encoded in Pi: https://www.youtube.com/watch?v=uXoh6vi6J5U
Over time, I think my rules for `guard` over `if let` settled to this rule: Always `guard` unless you need to continue execution of code even if the cast fails. `guard` should always be used because you always want to prefer a flat code hierarchy over a pyramid. 
For me, I think it's more clear to do it `[T]()` rather than `var names: [T] = []`, because in Swift, initialization and execution is always done with `()`. A lot of patterns follow this way, including obscure ones such as immediate executed closures that take the form of `{ /* code goes here*/ }()`.
Seconded. `[String] = []` is much more readable, to my eyes. To me it says "this is an array of strings, and its initial value is an empty array". Where as `[String]()` says "this is an array of strings, and it has been initialised". The former explains the intent more clearly in English. 
I think you're doing it right. If the property should always have a value, and an empty array is a valid value, it should be initialised as such. If you instead declare it as an optional then you needlessly complicate other code for no benefit. 
He's right, this is actually a question stemming from a Udemy course (so not homework) but the instructor isn't responsive so I tried posting here.
Thank you for responding to my question.
While you probably won't be able to get the full abstractions you might be looking for, you can get pretty close: struct StatefulStream&lt;S: SequenceType, Element, State&gt; { private let s: S private let f: (S.Generator.Element, State) -&gt; (Element, State)? func sFilter(p: (Element, State) -&gt; (Bool, State)) -&gt; StatefulStream { return StatefulStream(s: s) { (x,s) in if let (y,n) = self.f(x,s) { let (b,m) = p(y,n) if b { return (y,m) } } return nil } } func filter(p: Element -&gt; Bool) -&gt; StatefulStream { return StatefulStream(s: s) { (x,s) in if let (y,n) = self.f(x,s) where p(y) { return (y,n) } return nil } } func map&lt;A&gt;(t: Element -&gt; A) -&gt; StatefulStream&lt;S,A,State&gt; { return StatefulStream&lt;S,A,State&gt;(s: s) { (x,s) in self.f(x,s).map { (y,n) in (t(y),n) } } } func sMap&lt;A&gt;(t: (Element, State) -&gt; (A,State)) -&gt; StatefulStream&lt;S,A,State&gt; { return StatefulStream&lt;S,A,State&gt;(s: s) { (x,s) in self.f(x,s).map(t) } } func run(withState: State) -&gt; ([Element], State) { var g = s.generate() var a: [Element] = [] var r = withState while let e = g.next() { if let (x,n) = self.f(e,r) { r = n a.append(x) } } return (a,r) } func reduce&lt;A&gt;( initial: A, c: (accu: A, elem: Element) -&gt; A ) -&gt; State -&gt; (A, State) { return { state in var (g, a, r) = (self.s.generate(), initial, state) while let x = g.next() { if let (y,n) = self.f(x,r) { (a,r) = (c(accu: a, elem: y),n) } } return (a,r) } } func sReduce&lt;A&gt;( initial: A, c: (accu: A, elem: Element, state: State) -&gt; (A, State), withState: State ) -&gt; (A, State) { var (g, a, r) = (s.generate(), initial, withState) while let x = g.next() { if let (y,n) = self.f(x,r) { (a,r) = c(accu: a, elem: y, state: n) } } return (a,r) } } extension SequenceType { func sFilter&lt;State&gt;( p: (Generator.Element, State) -&gt; (Bool, State) ) -&gt; StatefulStream&lt;Self,Generator.Element,State&gt; { return StatefulStream(s: self) { (x,s) in let (b,n) = p(x,s) return b ? (x,n) : nil } } func sMap&lt;A,State&gt;( t: (Generator.Element, State) -&gt; (A,State) ) -&gt; StatefulStream&lt;Self,A,State&gt; { return StatefulStream(s: self) { (x,s) in t(x,s) } } func sReduce&lt;A,State&gt;( initial: A, c: (accu: A, elem: Generator.Element, state: State) -&gt; (A, State), withState: State ) -&gt; (A, State) { var (a,s) = (initial,withState) for element in self { (a,s) = c(accu: a, elem: element, state: s) } return (a,s) } } The above structure works lazily, also, which should give you some efficiency. You can use it like this: [1,4,3,5,2,3,6,7] // ([1, 4, 5, 6, 7], 7) .sFilter { (n,s) in (n &gt;= s, max(n,s)) } .run(0) That filters an array statefully, so that only numbers bigger than those that came before are present. You can chain those methods together: [1,4,3,5,2,3,6,7] // (["1", "4", "5", "6", "7"], 7) .sFilter { (n,s) in (n &gt;= s, max(n,s)) } .map { n in String(n) } .run(0) Both pure and impure, and only one array will ever be created.
I think learning programming is about 70% doing it, and 30% studying, so I would suggest starting to program over anything else. The Stanford course is great, but the best way to go trough it is to program alongside it (one of the advantages of an online course is the pause button), and maybe think of ways of doing things better than the professor etc.
[GUID](https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSUUID_Class/)
Maybe the author is talking about testing app-specific JSON parsing, as-in testing whether you get the actual structs/objects that you're looking for.
A third option would be to use protocol extensions. They're more testable.
Developers who justify their sloppy code. Messy Code = a Bug Magnet.
Are you serious? It completely changes the code hierarchy. Language shouldn't be a barrier for using one over the other. Hell, I doubt many non-native English speakers know what `stride` means, but still it is the preferred way over an alternative.
What math background do I need for category theory? I've been wondering about that. I've got undergrad math through complex analysis but nothing like topology etc. Also, my ultimate goal here is shipping something (OSX). Is that feasible with Haskell?
That's sort've what I figured would take way too long without a quantum computer to find the actual seed.
There is no "early exit strategy" when using `if let`. It's the difference between a pyramid of doom, and... no pyramid of doom. I get that there is place for both in an application, but it shouldn't depend on which one sounds better in English.
Yeah i tried OpenGL, i found these extensions: https://www.opengl.org/registry/specs/NVX/gpu_memory_info.txt Then i put this in a test Application: var videoMemory:GLint = 0 let GL_GPU_MEM_INFO_TOTAL_AVAILABLE_MEM_NVX:GLenum = 0x9049 glGetIntegerv(GL_GPU_MEM_INFO_TOTAL_AVAILABLE_MEM_NVX, &amp;videoMemory) dump(videoMemory) But unfortunately the variable "videoMemory" is empty... Do you know someone with OpenGL experience who could help me with that?
Not very convincing. 
Thanks for your help.
For a student project I would totally agree. We don't need developers that leave college with a degree in cut and paste. However it is a different story when it comes to professional development. Here you would expect that a developer would make an intelligent decision based on a libraries quality. I say cut and paste above knowing full well that including a library is a slightly different endeavor. My point here, is that students should be able to develop their own code. College shouldn't be teaching students how to tie a bunch of APIs together. 
I agree with your reasoning for `if let`. A little unclear for your `guard` reasoning though. I attribute `guard` with "Be cautious, if this fails, we're getting out of here!", or "These conditions SHOULD be true, but if it isn't, we're getting out of here". Clear usage of `if let` and `guard` makes for some really meaningful code in that sense. 
An app builder is the least of your problems. Your fist problem here is to define identical!!! Think about that for a minute. Consider this, I can put a camera on a tripod and take a picture every minute and never have identical frames. The only way you would have an identical image is to make a digital copy of a digital original. Now you could come up with software that ranks images based on similarity but that is a major effort that has virtually no relation ship to the app GUI framework. The app GUI would likely involve a few percent of the total development time, maybe not even one percent. What you are trying to create is exceedingly complicated to the point that asking about how to develop the GUI is ridiculous. 
I don't believe that extension is supported by OpenGL on OS X - it's an Nvidia proprietary extension that should only available with their closed source driver. Off the top of my head, you're pretty much SOL using Metal or OpenGL. I don't believe either OpenGL or Metal provide significant information in regards to amount of memory that is free. You should be able to query device memory size through OpenCL, but since the GPU is a shared resource I don't believe it can report back any information on how much is free. All of these APIs manage whether a buffer resides on the GPU itself or on the host memory, so they *generally* don't report it. With that said - Apple has a tool that reports this kind of information, so it is available - just not through those APIs. You might look at some of the low-level kernel debugging APIs, although I have no idea which one.
https://realm.io/news/gotocph-ash-furrow-best-practices-swift/
assume you have a type T? map takes a function from T to S and returns a value of type S? for example let i = computeOptionalInt(); return i.map { $0 * 4 } the equivalent code is if let a = i { return a * 4 } return nil and similarly with guard. Map is really useful to avoid if lets and guards when you want to extract and do something with a value or just do nothing if it's absent. And it really shines when you need to successively use different operation on an optional value with option.map(fn1).map(fn1).map(fn3) edit: I just realised some people might object that ?. does the same thing as map, and that's somewhat true. In some occasions they are equivalent, for example option.map {$0.method()} and option?.method() And it looks clear that the second option is better. But this only works in the case that the optional value has a method we want to call. if it's used as a function argument, I would argue map is best suited.
Doesn't matter, the Democrats will find a way around any system you implement. 
Thanks for your help! I found an Objective C-method that does exactly what i want: http://stackoverflow.com/questions/3783030/free-vram-on-os-x The API is "IOService" and with "IOServiceMatching" you can look for "kIOAcceleratorClassName" and get tons of information from your GPU: a Dictionary with 126 variables, ranging from GPU usage to VRAM properties! I have implemented the obj-c code via a bridging header and it works :-) Would be great to convert the obj-c to Swift, but i failed horribly trying to do that. 
&gt; NSFetchedResultsController I'd say wrap it up in a handler class which handles the conversion to your custom data type. Have it take in a completion handler that provides an array of that type in the callback block.
Yes returning Either is a good choice. There's proposal for Swift 3 to throw typed exception.
That's an excellent point about keyboards in general. Is this what you meant by being able to reposition the keyboard: http://learn-swift.info/images/moving-keypad.png The numbers are too big, but you get the idea. That'd be an interesting project.
Wow, that's really cool. My understanding before was that `map` was only a method available for stuff that adopt the `SequenceType` protocol. Thanks for the explanation for this little gem :] Can't wait to try it out!
Trying to follow the calling conventions of another language is going to result in weird-looking code that is not interoperable and which other programmers will balk at working with.
It all depends on how advanced you want to get with custom elements. You can change most UI elements programatically so a quick Google search for, as an example "customizing UITabBar color in swift" is going to bring up some good Stack Overflow examples of how to do that. There are also some tutorial sites that are really good, so if you find hackingwithswift.com or sweettutos.com coming up in your search results those are worth a look. You can also do some level of modifications at the storyboard level. I know some would disagree with me but if you can do the changes via the storyboard and avoid doing it programatically then that is an easier way to do it. There doesnt seem to be one definitive resource on the internet (yet, or at least that I have seen) that covers doing customizations in depth in Swift so you will probably have to piece things together from a few sources. As long as you focus on changing one element at a time and have a plan for how you want the end design to look you should be okay.
I've dealt enough curmudgeons who like to write everything themselves to know that they're also a problem. They'll spend weeks wasting money when they could have solved the problem with something already out there, even if it's not the "perfect" solution they envisioned. There's definitely a middle ground for this. The analogy I prefer to use is to compare it to electrical engineering. Sometimes it's better to use something off the shelf that's already been well tested by someone else. You should tread carefully though, understand the code, and know what baggage you're taking on when you use a 3rd party library, but some of them can literally save you weeks of time instead of having to reinvent the wheel. 
Yep. Any ELF binary with the dependencies resolved will run, in theory. In practice, they're inviting testers to throw any and everything at the wall to see what sticks and what doesn't.
Whatever you do other programmers will need to learn about it. That's one of the reasons I love Go. Everything has a single solution. Unfournetly swift is so dynamic everyone solves the same problem differently. People have extensions, typealiases, enum types etc. which is unique to the project. New coming developers should learn every single one of these.
Dunno, gcc works, so I expect a lot of interesting stuff thrown at the wall. :)
CoreData is sufficient. I'd recommend working on a background thread while searching. Also, read up on NSPredicate. It's extremely powerful, along with NSSortDescriptors. There is much to read about CD, start with learning the basics: naming, setup, use cases, etc. Hope this helps! Good luck
I second that. Core Data is not exactly easy to learn at first, but it is powerful, flexible and worth the effort in the long run.
Well my question wasn't about the GUI. I was asking if app builders could do more than GUI and actually help build things like this. By thankyou!
You basically want to share the result of an asynchronous operation among all cells and sebsequent download of images depend on it. I'd implement a view model and have most logic their. This view model is only for the view controller to consume; cells don't need their own view models. I assume you are getting the data of of the cells from network. You can look up how that's done in RxSwift's examples. For instance in the init function of my view model, collectionDataSource = businessRepository.findByCurrentLocation(input.fetchMoreTrigger) .catchError { return Observable.just([Business]()) } .map { $0.map { BusinessInfo(business: $0) } } The collectionDataSource is declared as a member of the view model. Then declare another request is started after the collection data source is fulfilled. I believe it should be a driver because it implicitly share 1 result among all subscribers. anotherAsyncRequest = collectionDataSource .flatMapLatest { _ in networkRequest() } .asDriver(onErrorJustReturn: []) On your view controller you'd bind the collection data source to the table as usual dataSource.configureCell = { _, tv, ip, info in let cell = tv.dequeueReusableCellWithIdentifier(UserCellIdentifier) as! UserCell cell.bindToCellData(info, another: self.viewmodel.anotherAsyncRequest) return cell } let loadNextPageTrigger = tableView.rx_contentOffset .flatMap { offset in SocialBusinessViewController.isNearTheBottomEdge(offset, tableView) ? Observable.just() : Observable.empty() } .startWith(()) viewmodel = inputViewModel(fetchMoreTrigger: loadNextPageTrigger) viewmodel.collectionDataSource .map { [SectionModel(model: "UserInfo", items: $0]) } .bindTo(tableView.rx_itemsWithDataSource(dataSource)) .addDisposableTo(disposeBag) Note the bindToCellData function which sets data for cells and also pass along anotherAsyncRequest. In that function you could have something like: func bindToCellData(info: UserInfo, request: Driver&lt;Something&gt;) { anotherAsyncRequest. .driveNext { _ in self.image.sd_setImageWithURL(info.imageURL) } .addDisposableTo(disposeBag) I'm using SDWebImage for downloading images. Makes life a lot easier. You could also consider PINRemoteImage. Take my suggestion with a grain of salt.
I'm afraid this is by design: as soon as the app gets backgrounded (even if the screen locks), broadcast terminates. If it's a device you control, disable the application idle timer so the device won't auto lock – it's not a big improvement, but it's better than nothing!
Personal opinion, having used CoreData on a couple projects now, and having used other orms like Hibernate, Nhibernate, Entity Framework, and others. I would only use CoreData at gun point.
Thanks for the tip, I added background information to the info.plist but it didn't seem to do the trick
It's literally just syntactic sugar for passing in a known number of arguments in a way that looks nice and behaves like an array. This code, fn(a, b, c, d, e) looks marginally better than this code. fn([a, b, c, d, e]) and doesn't require you to type an array literal when it should feel like just passing in several arguments.
Core Data uses it's own foreground/background thread if you use the correct NSManagedObjectContext type. You don't need to use GCD. 
Realm is nice but lack of sync support is deal breaker for me.
Right. But I think OP's point might be about the function call. Swift requires them to be statically typed, and does not allow these parameters to be functionally created. This usually leads me to then create a regular array-accepting function with the same logic (`function sum(integers: [Int]) -&gt; Int`) and my variadic functions to be simple wrappers around it. These wrappers then, imo, muck up the code and beg the question of "what's the point of swift variadic functions?" I typically like variadic function calls in other languages, and wrote my own ‘[Int].apply‘ helper function for collections, but it felt like I was fighting the system too much. 
I don't have anything right now since I'm on mobile, but almost every time I see correctly written functional programming code mainly using higher-order functions… I'm always amazed by how sleek it looks. Edit: While yes swift has some problems with tail recursion, I really just mean higher-order functions such as `map`, `filter`, `reduce`, etc.
This can save you money, but is not worth the trouble.
Sounds good! Thanks man!
As someone who is slightly intimidated by functional programming, anything specific I could look at to finally have it "click" for me and make sense in a real world application? I recently went through a tutorial completely unrelated but author happened to be a functional programming enthusiast and i'll agree that the code was very sleek/tight/whatever you want to call it. Was very impressive.
Oh, I see now. thank you. Yes, variadic parameters do have kind of narrow use case, most of the times you'd go for the array since it gives you more flexibility on the call site. Although I'd not like at all to use a `printf` like function passing an array literal instead of variadic parameters print("the number is %d", [5]) Just feels kinda weird to me I guess.
I used a 2010 mbp until very recently. It's super easy on the non-retinas because you can very easily and cheaply slot in an SSD and some more RAM.
I don't know how, but I'm quite certain that it has to be possible: There's this game called PKPKT which sends you a notification when you get in range of someone else having the app, even if the app is in the background on both devices. It also explicitly mentions using Bluetooth LE for that, so that pretty much screams "iBeacon in the background". 
If you intend to get a job in iOS then having CoreData as a skill set is a big benefit, it has a tough learning curve and some dodgy bugs in iOS 8 and below but is 100% worth the time and effort.
anything with an SSD will probably do really, but the more memory the merrier.
Why? I have many projects using core data and it works great.
Xcode doesn't seem to get less memory hungry (and you probably want to run other stuff beside it as well) so I would recommend something with 16GB of RAM. And definitely an SSD, this makes an enormous difference.
Variadic parameters are a benefit to the function creator, who doesn't know how many parameters you will be passing in. They're great for allowing lists of things to be passed in, with type checking at compile time. 
Sounds good, I think I'll start out with a Mac mini for now and then save up for an IMac or MBP in the future.
Yeah, I'm gonna disagree. a) You can do that now with tuples, but it causes confusing behavior (people accidentally calling print with a tuple instead of passing an argument, for example), and b) Structs aren't dictionaries, and python's function keyword arguments are dictionaries.
It is nice, but it makes it look like an `enum`. Which is fine, but it makes me wonder whether it wouldn't make more sense for `enum` cases to start with a lowercase letter.
That's actually happening in Swift 3, I think. There was a proposal for this and I believe it was accepted. Edit: [here's more about it (and more)](http://ericasadun.com/2016/03/03/swift-evolution-acceptances-the-big-three/). 
If you don't need the emulator and will build mostly on devices, just get any 2012-13 or higher Mac 
I love the simplicity of the Realm API, but in my performance tests I've found that it behaves poorly during any kind of query that involves relationships between multiple object types. This is enough of a deal-breaker that I generally stick with Core Data. I wanted to bring the simplicity of Realm to Core Data. I think the most painful parts of working with Core Data are: * Dealing with the managed object context hierarchy * Debugging cryptic exceptions that only occur when you attempt to save changes (rather than at the line you made the error). I've attempted to address both of those issues with Cadmium. Among its features: * Transaction blocks are clean and have no parameters; you will never have to reference a managed object context again. * Commits to the database are implicit after a transaction; you'll never have to deal with saving (though you can do it manually if a situation requires it). * Exceptions are raised immediately at the line of code you do something that would cause referential inconsistency (e.g. modifying a managed object outside of its context). * Object query chaining similar to Realm (supports most operations you can do with a fetch, including custom expressions and grouping). Here's an example that gives all of your Employee core data objects a raise (and saves to the database): Cd.transact { try! Cd.objects(Employee.self).fetch().forEach { $0.salary += 10000 } } Anyway, feel free to check it out. I've been using Cadmium in my latest production app and it makes a huge impact on code cleanliness. Note that Cadmium attempts to solve a lot of Core Data coding problems by hiding its complexity behind the framework. Since managed object contexts are hidden from you it won't be suitable for every application, especially if you do tons of heavy lifting and need to optimize your manage object contexts in a specific way. However, if you're just starting out with Core Data and making a relatively straight-forward application, Cadmium brings most of the simplicity of Realm interactions to Core Data.
i honestly liked error handling in swift before "exceptions" were added
Woah, I only once heard someone mention it; I didn't know it was actually proposed and definitely not that it was accepted. Thanks!
a) how? Doesn't doing it with tuples just put them in order, so if you change the order of the arguments it can silently break (if the types are the same)? b) sure, there are implementation details that are different, but that's not really relevant to the discussion
Honestly I'm trying to make an app with some friends of mine that I imagine will be moderately big because it's using maps API,DB on the backend, and WiFi interactions across iPhones. I also don't want to drop a ton of cash at the prospect of something since I'm not a seasoned IOS dev. Would it be reasonable to get a 8gb then upgrade if I see it be justified, or with my project do you think it would be getting bigger than I expect?
Try a date weekday picker and a time picker. Something like this perhaps https://github.com/skywinder/ActionSheetPicker-3.0
For me it didn't make a ton of sense until I started learning Haskell and for whatever reason it instantly made sense. Sometimes certain things just work or appear to make more sense in other languages. Now I try to use FP in nearly every language that supports it that I use because as you said, it's super sleek/tight.
Just declare a variable outside the scope of the block, and then within the block store the JSON in the variable. Then it will persist beyond the lifetime of the block. Of course, if you are doing something asynchronously, then you need to make sure you only attempt to use the data once it has been fetched. Meaning you need to alert the rest of your code that the data is ready at the end of the block.
As /u/l_____l_l_______l suggested, you can just do this: var x: JSON? = nil getJson { json in x = json } But this isn't really all that useful. On top of `x` being Optional when you really just want it to represent a future value, you still don't know *when* x is set to `json`. What you need is a way to be NOTIFIED of the occurrence of that value. One common solution is futures. let x: Future&lt;JSON&gt; = getJsonAsFuture() x.onComplete { json in ... } But here, we still have the same problem. You're bound to using the body of that on-complete block. We've just shifted from the block being in the `getJson` call to being in an `onComplete` call. But this is what futures are designed for. Now that you have `x` as a future, you can create other futures dependent on `x`. let x = getJsonAsFuture() let y = x.map { json in json["property"] } let z = y.flatMap { prop in getAnotherFuture(prop) } So you can see how you can build data dependent on future values this way. `y` and `z` are both created instantaneously just like `x`, `x` and `y` will become "completed" whenever JSON is returned, and `z` will become completed whenever an operation depending on that JSON completes. At this point, now that you can compose future values, it's just a matter of how you need to use those values. This is entirely application specific, so I can't help you much further without knowing exactly what you're trying to do. Futures aren't a part of the standard library. You'll need to use a library. [Bright Futures](https://github.com/Thomvis/BrightFutures) is probably the most popular, but I recently put my own library [Nifty](https://github.com/ElvishJerricco/Nifty) online.
 print("BEAUTIFUL")
"OK, I installed Cocoapods. Now what?"
You're thinking? The debugger will *tell* you. But anyway, there's no need for all that rigmarole for a singleton in Swift. Use: static let sharedInstance = Grade() and you're done.
Seriously? Downvote without explanation why I'm wrong? Way to go to make the swift community look like idiots. 
IMO raywenderlich.com has the best ios resources for the most of the topics.
Where have you looked so far?
It all starts at Apple’s developer site: https://developer.apple.com Sign up for an account. You don’t need to enroll in a paid programme right away as you’ll be able to develop and test your app on your own devices without one. These documents are good starting points for learning about iOS development: [Start Developing iOS Apps (Swift)](https://developer.apple.com/library/ios/referencelibrary/GettingStarted/DevelopiOSAppsSwift/index.html#//apple_ref/doc/uid/TP40015214) [App Programming Guide for iOS](https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072-CH1-SW1) [The Swift Programming Language](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097) For UI work, many people use [Sketch](https://www.sketchapp.com). It’s a vector based graphics tool like Illustrator, but works on a pixel grid. It supports batch exports of slices at the various resolutions needed for iOS. Do invest some time in learning it properly: [Learn Sketch](https://www.sketchapp.com/learn/) And last but not least, the fundamental iOS design guide: [iOS Human Interface Guidelines](https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/MobileHIG/index.html#//apple_ref/doc/uid/TP40006556) Good luck on your journey!
Thanks a lot for the information [RoadBikeDalek](https://www.reddit.com/user/RoadBikeDalek). [katawinaorafk](https://www.reddit.com/user/katawinaorafk) you can explore many important iOS Programming (HowTo)Tutorials along with Code Tips at http://goo.gl/pxCvIN
If you want videos, team treehouse is a rather good resource.
There's also an iTunes U course from Stanford that is great if you prefer that type of learning: https://itunes.apple.com/se/course/developing-ios-8-apps-swift/id961180099
I agree. This feels more like how objective C would handle errors and removes type safety that the compiler can enforce for you. The Result enum lets the compiler know that the value is *either* one or the other. You get no such help with the tuple. There is nothing stopping the tuple from containing a valid string and and error and relying on the programmer to do the right thing. Giving the compiler enough information to enforce these things for you removes a lot of possibilities for programmer error.
Hi, Sebastian, SwiftyBeaver founder, here. Thanks for mentioning! Any feedback is appreciated and I am here for comments or questions. Thanks again &amp; I'm looking forward to your feedback!
BEST ADVICE: you only fail if you quit
Thank you so much for posting this! Downloading now. Let's pray to app development on IOS for windows!
That's background location services, used by things like turn-by-turn map directions. 
Can you describe the incosistencies in more detail? At first glance, this expression appears to be accessing a global producer: ImageLoaderService.service.loadedImage .subscribeNext { ... } Can you show me where observeImageUpdates() is called? Perhaps in PersonCellViewModel.init() or in PersonCellViewModel.loadImage() ?
Swift is all the rage but there are still plenty of people who also develop in /r/ObjectiveC which is a shorter hop from what OP knows. But otherwise, ditto. You can mix-and-match between swift and objc.
What? Background location services don't broadcast anything. It's a completely different use case.
I like that.
This is the best resource I have found for learning to build iOS apps. It's a year out of date (the Swift 2/iOS 9 class is being taught right now and should be on iTunes later this year) but still very relevant.
I would pass the JSON back via a callback. func getJSONForUser(userId: Int, callback: JSON? -&gt; ()) { hitApi() { json in callback(json) } } getJSONForUserId(userId) { json in // Use the JSON here. } Error handling intentionally left out.
I inherited a project with 20 Pods, 44 warnings, 100s of auto layout constraint error messages upon navigating through the app. Storyboard's a mess, view controllers are sometimes empty as placeholders for 3rd party libraries but not in an intuitive way. 1 view controller has 30+ different segues pointing to and away from. The impression I got from that was that his strategy was to plug as much 3rd party libraries as he can to get the app to work. Needless to say this 3 month project is 8 months now, and is horribly bug ridden...
I use sketch to design UI, and I can export it to a storyboard(which I haven't tried). I suggest doing something basic like a table view, then you can learn how to implement other types of controllers. I know Parse is shutting down, but this tutorial taught me how to connect to backend (at least an MBAS), multiple pages app (with segues), buttons, tableviews, tablecells etc. Things that a lot of apps use. I started with this: https://www.youtube.com/watch?v=7sL47vpWTMU Then this: http://www.appcoda.com/instagram-app-parse-swift/ 1. I read swift's documentation, and gained a rudimentary understanding of Swift (I read up to functions, but you should at least understand variables, and constants) 2. Watch or read the tutorials, and just go on despite not understanding everything. Just try to grasp as much info as possible. Download the completed project, and just copy paste smaller parts like functions, class structures, and declarations etc. 3. If you're still stuck, research the subject. I used bits from multiple tutorials, to complete one tutorial. 4. Focus on understanding how implement a tableview. Then you can move on to other things. Don't be afraid to use available code if you don't understand it at first, just complete the tutorial and try to grasp what's going on. For example, if you don't know how to create a tableview, then find a tutorial about it, or if you don't know how to turn urls into photos, find a tutorial. If you can't, ask for help by using stackexchange, or /r/swift etc. Play around with it, and repeat the process until you do understand it. To me, what's more important is finding a way to implement something, than understanding it. I'll understand eventually, if I have to do that thing repeatedly, or if it's important. Again, I read Apple's swift documentation till the part about functions. I learned new, and relevant parts as I went along, either by going back to documentation or using articles online. For example, a subject I was curious about was arrays, I would read anything in Swift's docs about arrays or articles online. Use playground a lot too, when you're learning new concepts.
OP mentioned some Python experience, and Swift has a lot in common with Python, both syntax-wise and stylistically.
Try [this](https://www.youtube.com/watch?v=UhbdIvD14HE) video tutorial by Paul Hudson. It will show you the basics. Stack view is definitely worth knowing since it hugely simplifies creating grid like layouts. The only downside is that it is available for iOS9 upwards which means you won't be using it in production much since you probably still want to support iOS 8. But I am looking forward to the time when we can drop the support for iOS 8 and leave a happy life with stack view :) 
&gt; I do find RxSwift's abstraction to be better. Did you mean to say ReactiveCocoa here?
Did they actually confirm that that course is coming to iTunes U? Last I heard it wasn't going to be online at all.
Another question: I also have the instance going to another view controller and it works fine. Basically, I am reading in text in PostViewController, sending that text to grade.swift, and it is assigning that text a score. On the following view, GradeViewController, it shows the grade value and text, with the option to go back and edit. When I go back, I am able to change the text but the grade/score does not change. I am not really sure how to pass this value so that it will update.
Have you tried doing a clean and deleting ~/Library/Developer/Xcode/DerivedData?
Perhaps [this](https://www.natashatherobot.com/ios-pass-data-unwind-segue/) will help. If you're using this singleton just to pass data around more easily, that's a big code smell. Singletons have their uses, but (for many reasons) you should be careful about creating global state where it isn't necessary or sensible. (In particular here, is there only one Grade in your app ever?)
why the 15 over 13. just for the amount of windows I'll probably have open? I hope to hook it up to my monitors when I'm in my room coding.
The integrated GPU in the 15" is significantly better, which is important for driving external monitors and editing Storyboards.
I'm pretty sure sketch doesn't support exporting a tableview, or webview etc. to a storyboard. So far, I usually use sketch to design mockups, which only involves dragging and dropping shapes, nothing as complicated as boolean operations. I would suggest their documentation: https://www.sketchapp.com/learn/documentation/04-shapes/2-boolean-operations.html
I'm not exactly sure what's going on in your example, but I've put some code below. Mind you, my speculation might be weighed against whether or not we're on the same version of Swift (I'm running stock Xcode 7.3 for this). My primary guess is that the error may be misleading (since the `ServerTask_thread_bridge ` looks fine to me). `withUnsafePointer` produces an `UnsafeMutablePointer&lt;T&gt;`. I'm assuming that means you're creating an `UnsafeMutablePointer&lt;ServerTask&gt;` in your case. `pthread_create`, however, expects that its final argument will be an `UnsafeMutablePointer&lt;Void&gt;`. I don't think that there's a conversion between the two. Two things when working with pointers like this that may not be obvious but will make things much, much easier: 1. `withUnsafePointer` has a generic `Result` type. You can return *anything* from its closure argument. 2. `UnsafeMutablePointer&lt;T&gt;` has an init that takes another `UnsafeMutablePointer&lt;U&gt;` (or `UnsafePointer&lt;U&gt;`). You can readily cast one pointer to another with it. So, with that in mind, here's some code that I threw together in a Playground that might be illustrative of the above principles: import Darwin func callback(arg: UnsafeMutablePointer&lt;Void&gt;) -&gt; UnsafeMutablePointer&lt;Void&gt; { let convert = UnsafePointer&lt;Int&gt;(arg) print(convert.memory) return nil } var thread = UnsafeMutablePointer&lt;pthread_t&gt;.alloc(1) var value = 42 let pointer = withUnsafePointer(&amp;value) { UnsafeMutablePointer&lt;Void&gt;($0) } pthread_create(thread, nil, callback, pointer) sleep(1) print("Done") *** Finally, I'll stand on my soapbox for a moment and give my pet peeve: the phrase "or a literal closure" is fundamentally wrong. In this situation, there cannot be a closure. Swift cannot utilize closures when implementing callbacks from C APIs. A closure "encloses" around other variables and can capture information. What is provided to C APIs can be described as an inline, anonymous function. It cannot close around other information. It can only accept input (as defined by the API) and return data (again, as defined). Using consistent terminology may normally be a virtue, but it's usage is incorrect in these types of situations.
I do mean RxSwift is better.
I'll try this out. Thanks. Points 1 and 2 were indeed things I had never considered. AFA "literal closure" as distinct from "inline anonymous function", I know you weren't talking to me personally but I do understand what you mean. I'm a C programmer by trade and am probably 15 years behind the times AFA functional programming, closures, and the like. 
If you're still having problems, have you checked your framework search paths? If you've overridden them with some custom paths, make sure you also include "$(inherited)" so that the cocoapods paths get in there too.
I do have the right hardware and tried Transmac, Clover, the whole lot to no avail. It's not the worst investment to just get a Macbook
I was just confused because the sentence after that you seemed to be complimenting Reactive Cocoa. Could you maybe give an example of an abstraction that you like more in RxSwift? 
Can you navigate to your pod directory in your project and see if it contains `Firebase`? Last time I did experiment with firebase I had to make a bridging header, and import &lt;Firebase.h&gt; not sure if you need to do it with cocoapods though
I've never used Firebase but reading this should help you: https://www.firebase.com/docs/ios/guide/understanding-data.html
Instead of : `let something = snapshot.value.objectForKey["username"] as! String` Try: `let something = snapshot.value["username"] as! String`
Please file a bug report about a misleading diagnostic! The compiler team is super receptive, especially about error messages. 👍
Hm, seems like Apple does it's own thing and does not use iBeacon, so I guessed incorrectly (stupid of me, of course Apple doesn't use standards when it comes to Bluetooth :-P). So it's not iBeacons, but the App I mentioned still uses bluetooth, not background location services (which would be way to inaccurate/slow). From your own stack overflow link (following one link in there): "iOS does allow background advertising of Bluetooth Services, but only using a proprietary technique" I looked around the internet a bit like you said, this (https://github.com/Instrument/Vicinity) seems quite promising. Broadcasting iBeacon-like things in the background. So now it depends whether OP needs actual iBeacons, or whether he just wants two iOS devices to be able to detect each other via bluetooth when close by. The former does indeed not work, the latter does.
Thanks a ton! 😀
Thanks for your reply, I will be looking on everything you guys suggested me! Again, thanks!
How can I find the last years class? I don't see a link
replace the line: let currentUser = snapshot.value.objectForKey("username") as! String with the guard let value = snapshot.value() where snapshot.exists() else { return } /u/eviltofu posted above.
AFA 1 I took that code out to make what I presented in this thread simpler, so that problem doesn't exist in the actual code. AFA 2 Thanks! I'm pretty sure that's the answer. I realized last night that swift has no guarantee that the assigned closure doesn't capture any global state, so that was why it was failing. 
Actually in this case I'm not sure it's misleading. My (actual) job is getting in the way of making sure that my problem has to do with the compiler having no guarantee that the closure doesn't refer to any global state, which, if I understand cocoawithlove correctly, can be fixed with @convention(c).
Their video series on UIStackView is especially good.
If you are new to Swift, I recommend you quit using 3rd party frameworks to build your apps. You're only going to continually run into these types of scenarios. This has NOTHING to do with a view controller issue; it's a Firebase issue. For that I recommend the /r/Firebase/ or just reading their FAQs. 
So, I would: 1. Remove my cameraView subclass 2. Create a new class that subclasses NSViewController 3. Add a NSViewController to the nib file for my window 4. Make the view controller my custom subclass in the properties pane 5. Define the my custom types using the subclass constructor 6. Link the NSImageView to the subclass (?) 7. lastly, I assume at one point, there is a time where I will need to draw the NSImage and set the image property of the NSImageView (?) or would I set the value of the NSImageView in the init for my view controller?
To be perfectly honest, the last time I was a serious GUI Cocoa programmer (I still program in Cocoa but I have a weird job) was back before these new-fangled view controllers, so I'm not entirely sure if they're the right thing here, but your general idea sounds right. You could even use your own class that's just an NSObject subclass as a controller. The point is to have some object that owns the view and does the work, rather than having the view do everything itself. You'd do step 7 any time you wanted to update the image. Could do it in init, could do it in response to some event. Could do it asynchronously even, to avoid blocking your app while it renders. 
Doesn't let the project build at all.
Yes.
Is that a feature in development?
[Relevant discussion](https://github.com/PerfectlySoft/Perfect/issues/147)
That's weird. I mean I have that issue occasionally where it can't find a module if I do something with changing the project structure/re creating workspace or something. But nothing that doesn't resolve 
Fantastic! Thanks :D
Oh you are confusing RxCocoa with ReactiveCocoa. RxCocoa, which builds on top of RxSwift, is a UIBinding for RxSwift. ReactiveCocoa is a completely different framework, although it shares similar idea with RxSwift. 1. RxSwift (with RxCocoa and RxDataSources) provide an easy to use data bindings. The vanilla UIKit isn't really compatible with reactive programming because it mainly "pulls" data via delegates and data source. Reactive programming is about "push" data. There's definitely ways to interfacing with UIKit without RxCocoa and RxDataSources, but that's quite a lot of extra work before you actually doing something useful. 2. ReactiveCocoa's UI bindings is not as complete as RxCocoa and RxDataSources, and its mostly in Objective-C. The previous project I worked on, I spent quite some time writing UI bindings for ReactiveCocoa. You get these mostly free from RxSwift. 3. RxCocoa provides "Driver" for abstracting UI elements. This abstraction is powerful in that UI elements usually want to share their streams with all their subscribers. For example you have a button and two text fields subscribing to it. The values of the text fields are different but both depend on the button. If you are not careful, the two subscriptions could trigger the button twice. Instead you want the two subscriptions to SHARE the result of the button. "Driver" provides compiler assistant to make sure the common use case is correctly identified. There's more reason I believe RxSwift is better. You should take a look at the example folder in their github repository. It's a great source for study.
If you look at any of their source code, it's clear they haven't bothered to read the Swift Programming Language Beginner's Guide, let alone the Swift API Style Guide, Swift mailing lists, or language source code. Almost every line in their library is wildly out of line with the community standards and reminds me more of C++ than Swift. I don't know why a company that has no background in Swift products would randomly decide to create a Swift server. The only reason I can think is that they wanted to take advantage of Swift's boom in popularity lately (having been voted most loved language by Stack Overflow). Or rather, abuse it. The whole thing feels like a gimmick. Someone who does not understand Swift should NOT be making a framework for it. If you don't know how to drive a car, you probably shouldn't take one on the highway. You're going to hurt someone. In this case, no one is going to be physically injured, but the damage is still real. People come to me all the time complaining that they "gave up" after trying Perfect. It was "too complicated", "didn't compile", "didn't make sense". Swift on the web already has its lack of maturity to battle. Developers are so skeptical of changing a tried and true method for something new. Having their first taste of server-side Swift be Perfect's unweidly code-base is the last thing we need. Even worse, Perfect has money to spend. And they're using it to spam developer channels around the web to amass Twitter followers and GitHub stars. All of the little guys–the ones who truly understand Swift and are so passionate that they choose to spend their nights and weekends working on something open source and MIT licensed–are getting silenced in the noise. That sucks. Perfect is not good for end users, it's not good for the other frameworks, and it's not good for Swift as a language. The only entity Perfect is good for is itself. 
Wow, this is amazing. Thank you!
Yeah, your ViewController would be responsible for pushing the new NSImage to the NSImageView. You can place the NSImageView inside the ViewController's View (via Interface Builder), and make an IBOutlet for it and hook them together in the outlets tab. Alternately, you can also add the NSImageView programmatically, but I would recommend not adding it until viewDidLoad(). You will also need to set up it's constraints programmatically in this case as well.
No, it's recursive! Just call `performTask` once with index `0`, and it will keep calling itself until all tasks are completed.
I don't follow what you mean by "You can place the NSImageView inside the ViewController's View (via Interface Builder)", if I try to place the image view in there, [it doesn't seem to stick](https://imgur.com/a/B7KyT). EDIT: It's apparently a little finicky; [I was able to add it to my view controller](http://i.imgur.com/Oj6T6Bv.png), but now what? It's gone from the window, how can I expect it to draw anything? I did it as I described, I think. There's a coder initializer in my view controller, and added all the initializer code to it. and added my draw code to the `viewDidLoad()` but again this code does not get called. I think I did not quite add the view controller right. I'm not sure how to do that in IB. class MasterViewController: NSViewController { var scene = Scene(ambient: HDRColor.grayColor()) var camera = Camera() @IBOutlet weak var ImageView: NSImageView! required init?(coder: NSCoder) { scene.addLight(DirectLight(color: HDRColor.whiteColor(), direction: Vector3D(x: 1, y: 1, z: 1))) var colors = ColorData() colors.diffuse = HDRColor.blueColor() scene.addShape(Sphere(colors: colors, position: Vector3D(x: 10, y: 0, z: 0), radius: 9)!) //scene.addShape(Plane(colors: ColorData(), position: Vector3D(x: 20,y: 0,z: 0), normal: Vector3D(x: -1,y: 0,z: 0))) scene.shapes[0].colors.ambient = HDRColor.grayColor() super.init(coder: coder) } override func viewDidLoad() { super.viewDidLoad() let rect = ImageView.bounds ImageView.image = camera.capture(scene, resolution: (x: UInt(rect.width), y: UInt(rect.height)), SSAA: 4) } } EDIT2: Okay, adding it is good and all, and now `viewDidLoad()` gets called and so does my draw code, but there's nothing in my window. I tried to add the view controller in the window, [does this look right to you?](http://i.imgur.com/Oj6T6Bv.png)
I am thinking you may not have gotten the image view hooked up correctly. On the right pane, in the 6th tab ( (-&gt;) looking thing ), you drag from the outlet there to the view controller. I was looking at your repo, but I don't see the view controller there (or the nib)
I grabbed your project, and there's something mis-configured, the window doesn't show up, and I am seeing this in the console 2016-04-06 19:34:16.406 Trace[22954:5507030] [&lt;NSApplication 0x608000100b40&gt; valueForUndefinedKey:]: this class is not key value coding-compliant for the key cell.
What is there to hook up? I updated the repo just now.
Ok, grabbed the latest. There was a miscommunication, the ImageView should be in the Window. I haven't done much OSX programming since they introduced ViewControllers, I thought it would work the same way as it does in iOS, it seems that I was wrong. I moved the image view over to the window, just going to see why nothing is drawing now. It may be that your view controller has to be set up to control the window? Not sure... We'll figure this out.
Ok, submitted a PR for you to check out https://github.com/mld2443/Trace/pull/1 
Hey, don't know if you still need help with this - but I actually took this entire framework and made the onboarding process animated from screen to screen. I could help if you still are in need.
Cmd B doesn't work?
A HD swap on older machines is very easy. Plus SSD prices are very low now. 
Thanks a lot, I think that did it. Now to debug the ray tracer itself, the thing I was trying to do in the first place...
Swift extensions of @objc classes are literally categories. Extensions of non-@objc types are significantly dissimilar: for example, unlike ObjC categories, they only apply to code where they're lexically visible/imported.
I was reading the mailing list a while back, and I believe I saw some support for adding stored properties to non-@objc extensions, so it may happen in Swift 3. 
You mean other than obnoxious name? I find it to be of low quality, over engineered, over hyped, hard to use. They just trying to ride the language popularity. I feel the framework is made for the sake of making a framework rather than trying to make it easy to create servers in swift. The main goal of the framework is ... well secondary at best
No, that's not what's going on. There's no confusion of the enumerator involved (also no skipping). The only misunderstanding is that Swift creates a copy of the array when iterating over it, so you're not actually removing anything from the array you're iterating over. (Furthermore, `enumerate(someArray)` also creates a new array, so the result of that obviously doesn't change if you remove something from `someArray`, but the same thing would happen even without the `enumerate`). Let's think about a simple case, the following array: `["", "", "a"]`. Lets iterate over the array and remove all empty strings. - index 0: value is "" -&gt; remove index 0. Result is `["", "a"]`. - index 1: value is "" -&gt; remove index 1. Result is `[""]`. You've removed index 1, which is "a" in the new array, not the empty string though. It's just an empty string in the original array, not the modified new one. - index 2: value is "a" -&gt; do nothing. So the final result is: `[""]` (you first removed index 0, then index 1). There's no confusion going on here, you probably just didn't know that you always iterate over a copy of the array. Just fyi, a nice way to write this is `result = someArray.filter { $0 != "" }`.
Came here to ask this. This was a fun little gotcha that took far too long to debug for me.
Would this theoretically update the window when it's done drawing? or do I need to employ some fancy delegation for that?
Setting the image on an image view should call setNeedsDisplay internally, so it'll redraw.
Yes. Yet another reason to prefer value types to classes. Tail calls Just Work™ with values.
With other frameworks like vapor and kitura, I'm not really sure why I'd choose perfect. Perfect just feels, well, not perfect. /u/the_teet summed it up pretty well, so I won't repeat anything.
Firebase totally rules.
Awesome! It would be interesting to hear how the conversion from C++ to Swift went for this. Perhaps you can write up a blog post about it when it's all done!
You can still use Parse if you want. Instead of outright killing the product they've open sourced it so you can host it yourself. Product is called Parse Server: https://github.com/ParsePlatform/parse-server
Because properties need storage, adding properties would change the memory structure of the class. This would make serialization between classes with and without an extension problematic, as well as introduce a whole host of other issues in usability. Extensions are meant to augment behaviors, not fundamentally change a class. If you need to add additional properties to a class there's a perfectly good mechanism for that: subclass.
I do rather like the idea of defining classes as named collections of properties and methods that inherit their specification from their protocols and default implementation from protocol extensions. Swift objects don't need to be in an inheritance hierarchy to function, and in many cases direct inheritance just clutters things up anyway.
The impedance mismatch is still smaller having ObjC as an intermediary. Just saying.
As a former Parse user, I took off to Firebase right when they announced that they were closing. I just recently went back to Parse. Seems like their open source server is growing in popularity, with AWS and Azure supporting it now. 
he/she doesn't want to use Firebase https://www.reddit.com/r/iOSProgramming/comments/4dqykl/backend_for_ios_social_media_application/
Yes. Since it's compatible with objective-c, it's compatible with swift. But it might be easier to convert the CMSampleBufferRef to an OpenCV IplImage in C/Obj-C. You could use an objective-c extension for just the conversion. I'm speculating here, maybe it's just as easy in swift. 
As Swift expands to other platforms, ObjC won't always be available. And C is the lingua franca that can access the majority of libraries and features on every platform. One discussion I would like to see are techniques to make C bridging a little more Swifty, while not deviating from the original API so much that it becomes a confusing mess. (Example: Apple's original Java/Cocoa bridge was a confusing mess because they deviated from ObjC/Cocoa paradigms enough that Java/Cocoa people couldn't get help from the main Cocoa community and the Java/Cocoa paradigms still didn't really line up with mainstream Java either.) So for example, what are some good patterns for making bridged things work with ARC? A lot of C pointers that used to have actual types into COpaquePointer or UnsafeMutablePointer through the bridge losing type information; is there a good strategy for retaining the type information? As you start trying to make things more Swift-y, do you need to worry about name clashes with the direct C automatic bridging? 
Like if I were making an application with users, groups, and posts, and comments. Users are in multiple groups. Multiple posts belong to one group. Multiple comments belong to one post. 
Every link from that site will start with the site's domain, so yeah... check for the actual url you're looking for. And do it right using NSURLComponents like TaviRider says.
Yeah, that's how you get crashes. If lets are good, guard lets are also good (especially if you need the variable for more than a block). You can also have multiple things in one if let or guard let so like if let a = b, c = d { doSomething() } or guard let a = b, c = d else { doSomethingElse() }
Well it's not necessarily bad to use "!". For example, if you design interface in storyboard, IBActions are usually "!" because you know by the time "viewDidLoad" is launched, those values are not nil. Not using "?" makes code simpler as you longer have to deal with "nil" explicitly. Another example is in MVVM architecture where view model is injected to view controller before "viewDidLoad". You'd ensure the injection right after view controller is initialized but before it is put in view. You have to declare it "!" or "?" because the view controller is initialized by storyboard, you can't use "init" to initialize the property. View model, in this case, has to be initialized after view controller is already initialized. That being said, be mindful when to use "!". Don't use it everywhere. Another way to deal with optional is to use map and flatMap. If we have a function which transform an Integer to Boolean: func transform(value: Int) -&gt; Bool { .... } And we want to apply that transformation to an optional int. We can do like following: let a = Optional.Some(5) a.map(transform) Despite the fact that a is optional, it does not call the map function like so: a!.map(transform) or a?.map(transform) And the same idea goes for flatMap, although it takes in a slightly different closure. The above two functions are useful but there's a subtle piece missing. For example, if we have a function takes in multiple arguments: func example(a: A, b: B, c: C, d: D) -&gt; E { .... } How do we apply data that can be optional to the function? First make a curried version of the same function: func curriedExample(a: A) -&gt; B -&gt; C -&gt; D -&gt; E { .... } Apply value like so: a, b, c, d, are all optionals. a.map(curriedExample).flatMap { b.map($0) }.flatMap { c.map($0) }.flatMap { d.map($0) } Notice the repitition: flatMap { ###.map (***) }. This is a function called ap (apply). Now replace map function with \&lt;\^\&gt; and ap function with \&lt; * \&gt;, and you have something magical: curriedExample &lt;^&gt; a &lt;*&gt; b &lt;*&gt; c &lt;*&gt; d which resolves to optional e. Originally we have a function that takes a bunch of arguments that are **NOT** optionals. Then we apply optional values to the function and gets the final result in optional. And all of this is done without using "if let" and "guard let". The above technique is functor, applicative and monad.
Fascinating. Of course the API are completely different so it only buys you a tiny, tiny amount of value for cross-platform development.
"Tiny, tiny" is underselling it. There's *plenty* that goes into developing an app besides the parts that deal with UI libraries. And presumably, the core libraries like Foundation and those others being ported to Linux would exist on Android.
Yeah but google would have to recreate a lot of frameworks, and its not like we'd get UIKit or anything on android 
The big value that I see is that you don't need two different development teams for the android and ios apps. The same developers can work on both. And of course someone will eventually build a framework that abstracts away 90% of the differences between the two APIs 
I am new in programming. But I think: let someVar = (someDict["someString"] as? String)! equal to: let someVar = someDict["someString"] as! String as I know as? or try?, optional chaining with ? That all return optional type. var temp = something as? Int // temp is Int? var temp = something as! Int // temp is Int, but you have to guarantee something isn't nil. If you don't want to return optional, use ! To force unwrap. but if the optional types is nil. it would make the app crush. if you guarantee there is always a value inside, then, use implicit optional type var number: Int? = 22 // or var number: Int! = 22 let contain = number! // contain is Int now. optional function: let foo: (Int -&gt; Int)? = { return $0 * $0 } foo.dynamicType // Optional&lt;Int -&gt; Int&gt;.Type let temp1 = foo?(12) // temp1 is Int? let temp2 = foo!(2) // temp2 is Int let foo2: (Int -&gt; Int)! = { return $0 * $0 } // will cause same result, implicit optional type is still optional type. foo2.dynamicType // ImplicitlyUnwrappedOptional&lt;Int -&gt; Int&gt;.Type let temp3 = foo2?(12) // temp3 is Int? let temp4 = foo2!(2) // temp4 is Int let temp5 = foo2(6) // temp5 is Int, because it is implicit type, you can use it without unwrapping it. optional chaining: let temp = a?.b?.c // temp is optional type of sometime. let temp = a!.b!.c // temp is not optional type. let temp = a?.b!.c // temp is still optional type of something. so, you can think like "?" make anything become optional-type. but "!" make optional type or implicit optional type to be non-optional. Sorry, English is not my first language
using if let (optional binding), after = assignment operator, the expressions have to return optional type. optional binding is like unwrapping and test if it is nil at the same time. if let temp = something as? String { } // using as? will return a optional type. temp is non-optional type. if let temp = something as! String { } // error, because as! returns a non-optional type. so, optional binding can't unwrap the value. optional binding can only work with optional types. temp is non-optional type. I did try a lot of test of Behaviour of ? And ! 
If you only had Swift and NSURLSession, that alone would be enough to implement shared model and networking code in many applications. That's a ton of code that you could just reuse, and that's obviously not even close to all of the things you could reuse.
I kind of like this one: https://github.com/qutheory/vapor I should say that I haven't done much server side work with Swift yet though.
They actually have a great example about this on their website: https://www.firebase.com/docs/web/guide/structuring-data.html
Finally a comprehensive resource on UnsafePointer!
You still want separate development teams if your project is large enough to support it. They're drastically different APIs with different design philosophies and UX decisions. 
Quick question, are these going to change later in the app? If so you might want to consider putting them in using code, if not I do not see why UILabels would not be the solution. Hope that helps. 
As someone who has to do some Android development sometimes, that's great news. Java left a dirty taste in my mouth, that might be because I had to use it for years as part of my day job though
So to create each label you want to use a function like this: var label = UILabel(frame: CGRectMake(0, 0, 200, 21)) label.center = CGPointMake(160, 284) label.textAlignment = NSTextAlignment.Center label.text = "I'am a test label" self.view.addSubview(label) Where you are keeping count of the position, assuming it is a scrolling window. Also, pulling in the label.text value from the web. I am new to Swift as well, so my answer might not be the best. 
Go is practically a syntactically prettier C. In my (very limited) experience, I get the impression that it would he great for smaller applications. The lack of generics is quite a turn off, and the lack of OO in general
There is an interesting discussion at https://swiftx-io.slack.com/ about cross-platform standards in Swift
Actually the limited featureset makes it attractive for larger applications -- things remain simple and straightforward even with large teams and large codebases.
They didn't feel it had sufficient reason to be in. 
There's a pretty detailed explanation on [github](https://github.com/apple/swift-evolution/blob/master/proposals/0004-remove-pre-post-inc-decrement.md). It looks like the decision is these operators do not philosophically fit in Swift. Other operators already return void, these are inconsistent. The kinds of loops that benefit from the distinction aren't idiomatic. The order of evaluation can get really confusing when using tehse operators. And there's a philosophical statement that code reliant on one or the other of these operators is often "cute" rather than "expressive". Aside from last argument, it seems pretty straightforward. That one can trigger a lot of discussion. 
If it isn't helping, it's hurting. i += 1 is more flexible than i++ How? i += 2 i += 10 i += 2.5 i += k Even though ++ is simple, += is more powerful.
There are a number of downsides to the `++` operator (in both C and Swift): 1. It's redundant; `x++` is the same as `x += 1`. 2. It's a bit confusing. A lot of programmers don't really know or understand the difference between `++x` and `x++`. And really, each version is easily mimicked with the `+=` or `+` operator anyway. In short, it's a source of errors and is redundant with other operators anyway.
Main reason I read is because they want to get rid of the c style loop and with that loop, the increment and decrement operator was mostly used with it only. So if they're taking off the c style loop, why keep the operator? 
Removal of C style loops was in response to the removal of the ++ operator. The removal of the ++ operator was proposed by Apple, if they hadn't open sourced it, it would have been removed in time anyway
Do you use it in a production environment or as a hobby? I'd love to try it but I'd have to work pretty hard to shoehorn it into my regular work.
The most common place ++ is used is in C-style for loops. With those gone from the language (superseded by the "for i in 0...n" or "for i in 0.stride(to: n, by: 3)" syntax), the use case is heavily diminished. Even if used outside of a for loop, its intention is not always obvious, and mixing up ++x and x++ is a common source of errors. The Swift evolution document says that the "cute" code that ++x and x++ often lead to is more prone to errors and harder to debug. It also adds cruft for people new to programming in general. Swift was designed to prevent you from accidentally shooting yourself in the foot. It also is meant to be as easy as possible for others to read your code. Both of these philosophies led to the removal of ++.
With `switch` statements, simple conditionals, and (some) loops, Swift can infer that a variable will be definitely initialised after a block of code. So this will compile, for instance: let a: Int switch "foo" { case "bar": a = 1 case "foo": a = 2 default: a = 3 } print(a) Whereas this won't: let a: Int switch "foo" { case "bar": break case "foo": a = 2 default: a = 3 } print(a)
&gt; It's confusing to people who are not C programmers It's historically been confusing to people who _are_ C programmers as well
.... the guy is having problems with optionals. That's Swift 101. Do you really think he has a clue what map, flatMap, currying, monads and functors are? This is like a 5th grader asking for help with his times tables and attempting to explain it with differential topology. 
Agreed.
I dunno, I kind of don't see them being so concerned about that. But who knows. Xamarin is definitely pretty sweet though. I use them for all my apps, and I'm *really* excited that they're free now. I've mostly been using C# so far, but I started dipping my toes into the F# pond recently and I really love it.
Do you have any tips to improve Visual Studio support? I'm trying F# as well and it's like being thrown back into the stone ages in terms of auto sense and refactoring tools. Great language though
Sorry, I don't. I've been mostly using emacs for F#.
i havent made tons of stuff, but i know that if i was trying to learn programming and i decided to look at someones code and and try to figure out what it was doing, i might be able to guess the purposes of a lot of stuff, but it would take me a long time before i guessed that i++ meant i=i+1. just my two cents. of course, theyd eventually write something like print(i) right below i++, and quickly figure it out, but with i=i+1 its much less ambiguous. 
On top of all the answers below, Go has basically evolved into a network language. It's found its niche as something to do servers in.
You should take note that with UIStack I have run into issues getting it create that perfect equal spacing of the two elements when you have a Tab Bar since it doesn't seem to take into account the bottom layout guide (though it does take into account the top layout guide). In that instance I add a UIView to view controller, set its constraints so that it is taking both the top and bottom guide into account, and then I put my StackView in there, which allows the equal spacing to work correctly.
Noted. Putting these into a tab bar was next on the list, so this is really helpful. Thanks!
yeah I was given the green light to use it in a small app we implemented
I think I've already installed them. I don't think C# feels as "naked" without ReSharper as F# does. Can't really point out what's missing since I'm such a huge ReSharper user.
Wow this is cool!
Or, in a less-contrived but equally-confusing example: i = i++ Now, less obviously-problematic, imagine if the code is: j = k++ But j and k are reference types that point to the same object.
 let x = "foo" let y = "baz" let a = ["foo":1,"bar":2][x] ?? 3 let b = ["foo":1,"bar":2][y] ?? 3
Consider the following Java code: `int i=0; System.out.println(i++);` Running it would print `0`. The following version changes the position of the ++ operator. `int i=0; System.out.println(++i);` Running this would print `1`. Quite simple, really. Add 1 to the value either before or after the value is used, depending on the placement of the operator. Edit: The two code snippets are functionally equivalent to `int i=0; System.out.println(i); i=i+1;` and `int i=0; i=i+1; System.out.println(i);`, respectively. 
&gt; only very good What
When I need two views like that I just set them to equal heights then set all edge constraints to 0, that's it.
But it's not as easy to type, as all the keystrokes use the right hand. To type i++: - Use the right hand to type I - Use the right hand to press the numpad + key twice. To type the functionally equivalent i+=1: - Use the right hand to type I - Use the right hand to press the numpad + key - Use the right hand to type = - Use the right hand to press the numpad 1 key. A sequence of three keystrokes at two locations on the keyboard becomes four keystrokes at four locations. In other words, more and less efficient typing, especially where incrementing and decrementing are used frequently. 
I don't think that's a really compelling argument. `i++` and `i += 1` are both pretty easy to type and nearly as fast for an experienced typist, and when programming, you spend a lot more time reading and thinking than actually banging out lines of code anyway.
 i++ was used in C++ loops for brevity. Example: for(int i = 1; i &lt; 10; i++) { //Do something 10 times }
&gt; If it isn't helping, it's hurting. I think that's an important sentiment, it helps keep your languages, frameworks, apps clean and up to date. No one wants to go into a store and see cobwebs everywhere in all the corners because it's wasn't hurting anyone. I think that's also how we end up with some of the nightmare of C++. I'm glad they've taken such an approach, gives me hope.
Doh!!
I just thought it was hilarious and a nice example of why these sorts of things aren't always great in practice. I'm sure you actually know how to write these loops! 
I guess it's a hilarious example of a common mistake :D I've been programming since I was age 10, but I'm not immune to common mistakes.
...even though Java and C++ have had them for years without any issues.
How do you know it's been without any issues?
And this kind of loops is going away from Swift too :)
Not to mention the nuances with copy semantics in languages like C++. With the standard implementation of ++ on iterators (move to next and return) can have VASTLY different performance characteristics. it++ // return then increment, makes a copy of the contained element as the return value, then iterates. ++it // iterates, then returns a reference, potentially MUCH more efficient. That kind of subtlety is to be avoided in Swift.
c-style for loops are being removed as well, in favor of for-in loops.
Cocoa pods require admin access?
You might as well have just said "because reasons". While true, it didn't really address OP's question.
im familiar with this, im just saying that i can perceive how to meaning of everything else on that line could be figured out just by thinking about it. And sure, thats true for i++ too, but i wouldnt count on someone figuring out the meaning of that as soon as the meaning of say i&lt; 10 or i = 1.
This is one of the reasons I love the internet: you post something, and someone takes the time to post a hugely better solution. To be clear, I'm not being sarcastic. I really appreciate it.
That is an unfortunate random avatar. 
No need to censor you d***
Its clearly pixelated 🎶🎶
A static variable is a variable that can be accessed through the class without an object being instantiated. Example: public MyClass { static var temp = "Hello World." } To access the variable, you do not have to create a MyClass object (var MyClass = MyClass()), you can access it like this: print(MyClass.temp). Essentially it is a class variable and not an instance variable. Someone correct me if I'm missing something, but that's the gist of it!
It sounds like you need to spend more time with the first link you mentioned (The Swift Programming Language), which details the language's syntax and structure. For instance, your first question, about the underscore, is covered in Language Guide &gt; Methods &gt; Modifying External Parameter Name Behavior for Methods. Right now it sounds like you're trying to learn the API before learning the language itself. The latter is exactly what that book is for.
Get BNR's Swift book. 
/u/OcrMaster explained it well. I would add that you should use it when you want to store something that would conceptually belong to that class rather than be different for every object. For instance, if I had a class Circle and I wanted to store a constant PI, I should make it a static variable of Circle rather than an instance variable, because PI shouldn't change for every circle I make. I access it with Circle.PI Also, an easy way to make a singleton (an object that is only ever instantiated once for a class) is through a static variable: class NetworkManager { static let sharedInstance = NetworkManager() } Here, sharedInstance is an instance of NetworkManager. It's static: it's ever only created once. When I use NetworkManager I call NetworkManager.sharedInstance to get that "singleton" object. There is also the static functions (and class functions), which are conceptually similar to static variables (but of course are functions).
For hobby work, you might be able to implement this. It's kind of silly (like trying to put a Porsche engine in a Volkswagen). But that's what Arduinos are for. &gt; how I would go about sending data back from the phone to the arduino Sounds like you are unfamiliar with the HTTP protocol used by web servers. You'd normally send data with HTTP GET or POST commands (GET is easier but with data size/sophistication limits - JSON probably requires POST :-( ). These commands are how web forms normally pass data. Then you have a CGI handler on the web server that takes the GET or POST commands and processes them. Depending on how the CGI replies back to the browser/your client app, you get different results on the client side and you can use the data to set back-end effects (like preferences, commands, return of state, etc.) Edit: you'll have to do coding on the Arduino side as well. A vanilla web server will NOT do any of things you are seeking. Strictly I would NOT use JSON because it's needless complicated for the Arduino side of things. GET calls are far quicker and easier. It largely depends on the sophistication of the web stack on the Arduino. Like I said, Arduinos are toys so there's only so much you can do with them. Plus the HTTP protocol is both cumbersome and inefficient. We normally use raw TCP/UDP socket communications to deal with embedded device communication but we are also selling these devices for a profit.
The only question that matters: does it work and does it work with the performance you need. You don't need to ask Big Brother or Teacher for approval. They don't exist in the adult world - they are useful fictions for controlling children.
I'm not sure if we are looking at the same code. Perfect is amazing. The codebase is incredible, and looks Swifty to me. Are you a novice developer? It doesn't look like mobile app code - but it shouldn't. It's for mobile back end work. I'm using it incredibly successfully - and lots of people seem to be as well - it needs work, but its pretty damn good already. Reading your comment history, you seem more like a Vapor fanboy (or author?) looking to piss on another great project and get people to join your "kewl kids club". Vapor is even worse for jumping on a bandwagon. Heck, it's leveraging the popularity and brand of Laravel - when it even admits it's actually nothing to do with it! "Hi, I'm PHP inspired, and trying to convince people that Swift is cool". What a crock. As for "not knowing how to drive a car" - reading the Perfect threads - those guys seem to know more about server tech than the mobile guys who are now trying to write server stuff. You sure you know what you are talking about? I think you are just spreading horse manure, in hopes to damage Perfect's rep and get your own pet project noticed instead. Keep your high-school clique-making to yourself. Perfect doesn't suck for the Swift language, it's amazing for it, and for everyone using Swift.
lol, did you actually read this thread? It's like a bunch of butt-hurt high-school students ganging up on the smart kid.
Yeah it works fine. Just trying to make sure that my code is good enough if a Recruiter looks at it.
Wait - looking deeper at your history - you've basically posted nothing about anything but Vapor. Puppet accounted detected! How many puppet accounts do you control, anyway?
Im using a 2011 macbook pro 8gb i5 works like a charm 
I found Udacity's free swift course the best and explaining this, relatively speaking. The documentation is not very user friendly and unfortunately I have yet to find a good course/tutorial that teaches how to read it. If you are looking for live skype help, check out https://www.codementor.io/
Our Android application could gain a lot of features bringing it closer to being on par with our iOS app in 12 months instead of years. (our iOS app has existed a lot longer) We're slowly introducing a lot more Swift into our iOS and Mac projects. But if we could share the code across 3 platforms it would likely accelerate this process dramatically. The impact this could have for our backend code could seriously change things for us. 
Can you give me an example piece of code for HTTP POST? I definitely dived in over my head here, but I've got the GET side of things working at time moment. Hope this isn't too much trouble
There's an alternate way of installing fire base which is really easy. You just download fire base and click and drag the frameworks . And Import fire base into your swift files 
I've experienced similar problems playing commercial games. 
Emacs of course, the emacs files needed are in apple's swift repo
I think VIM has a plugin also? https://github.com/keith/swift.vim Though I never tried it :P
I tried LiClipse but I seems like it is a piece of garbage. Give atom a try later. I also tried clion with a swift plugin, feels right but I can't build currently. Maybe that's the way to go. It's a kind of joke by Apple. "Yes we released swift for Linux. It's cool isn't it ?" And than, your not able to create an easy console output program on Linux. 
Awesome! What's the status of the beta? Can anyone get it?
You can get a student license which is free 😊
Yep! Just go to Settings -&gt; Update and Security -&gt; Advanced -&gt; Get Insider Builds, and turn on "Fast Ring" on any Windows 10 PC. After a reboot and an update, turn on "Developer mode" in "For Developers" on the "Update &amp; Security" page. Then go to Control Panel -&gt; Program and Features -&gt; Turn Windows Features on or off -&gt; Windows SubSystem for Linux (Beta), and click OK. After a reboot, open Command Line and type in "bash". Then Windows will prompt to download Ubuntu image from the Windows Store, and once that's done, just install Swift as how you install it in Ubuntu. When unarchiving the tar.gz file, symbolic links will fail to create. Note down the few failures in bash, then go to Explorer, go to C:\Users\[Username]\AppData\Local\lxss\root, manually duplicate the relevant files + renaming them in Explorer. [Alternatively, you can cp them in bash as well]. After the setup, just go with ./swift [sourcefile].swift to compile and run it. Swift interactive shell does not yet work, but compilation of source file does work :) This is still quite rough and experimental, but have fun :)
Sure but vim is terrible for autocompletion with llvm. Good thing is emacs can emulate vim quite well
Try CLion https://www.jetbrains.com/clion/ it has swift support.
Is there a scenario where NetworkManager is deallocated and then initialised again later (in a single lifecycle of the app)? If so, I assume sharedInstance would also be deallocated? 
How did you manage to get that on there?
Just go to Settings -&gt; Update and Security -&gt; Advanced -&gt; Get Insider Builds, and turn on "Fast Ring" on any Windows 10 PC. After a reboot and an update, turn on "Developer mode" in "For Developers" on the "Update &amp; Security" page. Then go to Control Panel -&gt; Program and Features -&gt; Turn Windows Features on or off -&gt; Windows SubSystem for Linux (Beta), and click OK. After a reboot, open Command Line and type in "bash". Then Windows will prompt to download Ubuntu image from the Windows Store, and once that's done, just install Swift as how you install it in Ubuntu. When unarchiving the tar.gz file, symbolic links will fail to create. Note down the few failures in bash, then go to Explorer, go to C:\Users\[Username]\AppData\Local\lxss\root, manually duplicate the relevant files + renaming them in Explorer. [Alternatively, you can cp them in bash as well]. After the setup, just go with ./swift [sourcefile].swift to compile and run it. Swift interactive shell does not yet work, but compilation of source file does work :) This is still quite rough and experimental, but have fun :)
On mobile but, how about var str = "some really long long long string" let first = str.subscript(0) EDIT: misread the docs
I've had a problem like that, IIRC there's something about that on Apple's developer site, it had something to do with AppDelegate. Sorry for the broadest answer of all time but hopefully this can help you out. 
No need to convert the string to an array; just grab its starting index, typecast that as a string and then check it against an array of vowels. let str = "Hello, this a long string with lots of characters in it".lowercaseString let index = str.startIndex let firstLetter = String(str[index]) let vowels = ["a", "e", "i", "o", "u"] if vowels.contains(firstLetter) { print("First letter is a vowel") } else { print("First letter is a consonant") } 
To the best of my knowledge, the update to build 14316 might not be (immediately) available if you follow the above instructions. There are some 'fixes' but they don't work for all who have this problem. The problem might fixes itself if one waits a few hours/days. http://answers.microsoft.com/en-us/insider/forum/insider_wintp-insider_update/not-getting-build-14316-from-windows-update/6f5441fa-f95e-4bcb-8209-b380b31a1f42 http://www.askvg.com/new-update-build-of-windows-10-technical-preview-now-available-for-download/
You can do Swift. Any IDE will do for Swift-only development or learning. It's just another language. Strictly there's nothing stopping you from using vi/vim if you are a "real programmer". Hell, you could use 'cat' and 'sed' if you wanted to! However if you are planning to develop for iOS on another platform is like tying both hands behind your back and having a blindfold and earplugs - you are creating every disadvantage possible for yourself and if you are learning the language and API at the same time, that is an easy recipe for failure. Few people are smart enough and persistent enough to make this work. Also you must use a Mac to release iOS apps to the iTunes store.
Yeah, you'd want to do something like this let str = "Hello, this a long string with lots of characters in it".lowercaseString let words = str.componentsSeparatedByString(" ") let vowels = ["a", "e", "i", "o", "u"] for word in words { var index = word.startIndex var firstLetter = String(word[index]) if vowels.contains(firstLetter) { print("First letter is a vowel") } else { print("First letter is a consonant") } } Edit: Spelling
ok, bit of a mystery there: I've got a Swift playground (an iOS playground executing on the Mac) and I put this code in var i = 0 var outputURL: NSURL while i &lt; 5 { defer { i += 1 } let fullPathDocs = NSURL(fileURLWithPath: NSTemporaryDirectory()).URLByAppendingPathComponent("CreatedVideo-\(arc4random()).mov") outputURL = NSURL(fileURLWithPath: fullPathDocs.path!) print(outputURL) } And the output URLs are (after I've put some xxx over personal stuff): file:///xxx/Library/Developer/XCPGDevices/4E20EDC1-2589-4804-8D77-56FF15EEB4CD/data/Containers/Data/Application/F523758B-BFEC-45C7-828A-0C605431F57A/tmp/CreatedVideo-1830169502.mov file:///xxx/Library/Developer/XCPGDevices/4E20EDC1-2589-4804-8D77-56FF15EEB4CD/data/Containers/Data/Application/F523758B-BFEC-45C7-828A-0C605431F57A/tmp/CreatedVideo-3094403713.mov file:///xxx/Library/Developer/XCPGDevices/4E20EDC1-2589-4804-8D77-56FF15EEB4CD/data/Containers/Data/Application/F523758B-BFEC-45C7-828A-0C605431F57A/tmp/CreatedVideo-3426605040.mov file:///xxx/Library/Developer/XCPGDevices/4E20EDC1-2589-4804-8D77-56FF15EEB4CD/data/Containers/Data/Application/F523758B-BFEC-45C7-828A-0C605431F57A/tmp/CreatedVideo-1299312327.mov file:///xxx/Library/Developer/XCPGDevices/4E20EDC1-2589-4804-8D77-56FF15EEB4CD/data/Containers/Data/Application/F523758B-BFEC-45C7-828A-0C605431F57A/tmp/CreatedVideo-440583334.mov which look random and different to me. So, maybe the problem is further down when the file writing actually occurs? Maybe stepping through in lldb and examining some variables would help? I'm a little confused by the purpose of taking a file url in fullPathDocs then taking its path and then creating another (what to me seems like an equivalent) url in outputURL, but probably it has to do with some other code later on. You also might check out NSUUID().UUIDString rather than arc4random() to generate the changing part of the filename. It repeats less often, and has a regular format.
Well, the code you showed and the explanations you are giving are making sense. Rather than looking at something complicated like overlaying watermarks and what not, I'd first examine more prosaic things, like checking that you are using the right variable for the file url in the write statement. For example, although I haven't seen your write statement, I can imagine you've got a variable for the old filename and a variable for the filename, and what if you are writing to the old filename rather than the new? That would cause the problem you are seeing. But that is all speculation on my part without any data to back it up, and we all know what Sherlock Holmes thinks of people who do that! EDITING to add: I just realised I might be misunderstanding something: the code you gave above is just meant to be creating the file URL, right? It isn't actually doing any writing; the writing (i assume) is happening later? Maybe if it continues to be obstinate, you could post the actual statement(s) which are writing the file?
Is that build stable enough for every day use? I want to upgrade just for bash but I don't know if I should do it on my main machine.
&gt; But I would still need to loop through the string to make this count for every words first letter, correct? Your original question doesn't mention the first letter of every word in the string. You wrote: &gt;...best way to go through an extremely long string and find out what the first letter is be it a vowel or constant. I have a sneaking suspicion that you are going about this the wrong way. What problem are you trying to solve with this method?
First of all I'm not sure if anyone is interested in that kind of code. That's very basic beginner level stuff that is covered by thousands of tutorials. It's hard to introduce functional flaws in such basic code. Basic code like this only exposes when developers don't care much about established conventions. In your case: 1. Method names never start with a capital letter. Your `FindLocation(:)` does. 2. Don't add random whitespace (the empty lines) 3. Make your code formatting consistent. I don't care as much if you leave a whitespace in front of a `{`, but don't randomly switch between doing and not doing it. 4. Don't comment things that are obvious (though that might be remains from the tutorial). Outside of tutorials nobody needs `mapView = MKMapView() //create a map view` comments. ---- But let's take it to the fullest and assume that this is your best code and you send it to me to impress. I would ask why it contains code that is commented out. Generally such code should not be committed to your version control system. I also would expect that you use MKMapView's `public func setUserTrackingMode(mode: MKUserTrackingMode, animated: Bool)` instead of setting the region yourself. Makes it easier for you and the user. Bonus points for knowing `MKUserTrackingBarButtonItem`, which saves you a lot of code and adds a lot of convenience for the user. But it has to be added to a view that can take UIBarButtonItems (i.e. a toolbar or a navigation bar): self.navigationItem.rightBarButtonItem = MKUserTrackingBarButtonItem(mapView: mapView) More bonus points for putting a `fatalError()` in the `default:` case of the UISegmentedControl ValueChanged action function. Entering `default:` indicates developer error, i.e. you have added a fourth segment and didn't update the code. If you want to impress me, create a enum for the individual segments of the control. If you do that, the compiler will make sure that you don't forget to change code if you ever decide to add another option to your segmented control. Like this: enum DisplayMode: Int { case Standard, Hybrid, Satellite } segmentedControl.selectedSegmentIndex = DisplayMode.Standard.rawValue func mapTypeChanged(segControl: UISegmentedControl){ switch DisplayMode(rawValue: segControl.selectedSegmentIndex)! { case .Standard: mapView.mapType = .Standard case .Hybrid: mapView.mapType = .Hybrid case .Satellite: mapView.mapType = .Satellite } }
Oh right that's it!!
Also NSOperationQueue and NSOperation are part of Foundation, and libdispatch is also present of Linux for s long time. It's a great deal of programming to save, most of the controller code, for me... Naturally, there would be some library that would emulate UIKit, and translate .storyboard XML files to Android equivalents.
That's why PHP has such traction in large projects... not...
After Parse, I was anti-CloudKit ("it's not cross-platform" argument), but now love it! Definitely check it out. I would have never finished the Android version, anyways.
UI != Communitication between bash and Windows. To answer your other question, some people reported success on getting Xorg to run over Bash on Ubuntu on Windows.
What would you wish was different? I'd love to hear and learn. 
To be exact it will be lazy initiliazed and not at the app start
Check out objc.io's [Advanced Swift](https://www.objc.io/books/advanced-swift/) - it's got a chapter on collections, and how the various support classes work together to build them.
Foundation is not considered part of standard library. For higher ordered functions like map, filter, and reduce, there are a few really great blog posts that helped me get grounded into using them. Just google :) In terms of "official" and comprehensive coverage of the standard library, I think the Swift Apple docs are as good as it gets. You could try Advanced Swift like what @frodokun mentioned, and another good option is the Swift Apprentice by RayWenderlich. 
I don't have a solution but I am having this exact problem, if anyone knows the answer that would be great.
I use Xcode but for an OS X app. I don't think ST has deep/intelligent auto-complete for Swift.
I have a 2011 Mac mini with a 2.7 GHz i7 and 16 GB RAM with a custom-built Fusion Drive, and a 2015 Macbook, stock.
Good advice because I usually end up with the smaller laptops for portability 
What do I do with files that failed to create a symlink? Do I copy them to lxss/root or something?
My advice would be to save up and buy 1 computer instead of buying 2, a lesser computer now then the computer you want later. That's wasting money. If your current computer works, then continue to use it.
Could you review this? https://github.com/tinysun212/swift-windows/releases/tag/swift-msvc-20160412
I too have an older setup: Hackintosh with 2600k, 16GB Ram and a GTX 780 with 6GB VRAM, yet it is still faster than my 2011 iMac at work and all of the MacBooks i frequently use.
It might have been worth mentioning that I bought my rMBP last January. 
Let me know what you think.
Good job, I will try it out.
I think your core react inspired concept of simple functions describing output and diffing to produce a changeset are great ... and something I've been playing with at nights (I'm much earlier in my lib). "addSubview" and "removeFromSuperview" everywhere needs to (and can) go, so I love what you're working on here. I have criticisms over the types/methods of your implementation ..... but I'm also not far enough along to tell if doing better is possible, so take the following with a grain of salt: * [String : AnyObject] for your primary state construct is very soupy type wise. Sacrificing Swift's struct/enum approach to value types is a large price to pay. * Does inheriting from UIView really aid your cause over having some struct which always has a primary view as a property? * "override func render()", I'm just not a fan of () -&gt; () functions, this is opposite of pure. As soon as we have () -&gt; (), we're in an OO lock, where everything is hard to modify/extend/change, and it becomes an all or nothing approach. I believe I understand why you've done this, but you've put up significant barriers to adoption by taking this path. Render is really (state + props) -&gt; [ShadowViewElement] (or some array of a closed enum) in your case. I feel there's too much "magic". I strongly dislike RxSwift (and similar libraries) and agree with your design goals, but I feel your implementation has sacrificed much of Swift's strengths in making reliable software (equatable structs/enums for value based programming). This together with the OO heavy approach would keep me from using it.
Could you expand on why you dislike RxSwift (and other frp implementations)? I made myself familiar with them and like the concept but have yet to use it in a real world app.
the constraint, i did the same. but the method i can't figure. the method you did, it is too hard to me i can't understand. anyway, i would try to think how it works. thanks. 
I'm not against FRP in general though I must admit I've never used a non Reactive Extensions based FRP library in production. I'm against the Reactive Extensions brand of FRP (mutable inversion of control observables). I also have no problem with using it at a coarse level between different components of the app ... basically as channels, but I'm against using it to drive UIKit based interfaces. Disclaimer: I've used reactive extensions for a few months all up (some in Scala, some in Swift). In terms of my general opinions (not on Rx), I like functional functional programming when it fits (equatable structs/enums, pure functions when simple). However, I'm far from hardline and I don't think functional purity is a goal to aim for in Swift, especially not in conjunction with UIKit. RxSwift inverts control/timing. Instead of you calling functions with your state values to produce renderable things, the changes to the state reach out and calls functions. This is a blessing and a curse. It removes the need for a lot of code, and brings with it efficiency gains (if you're using "distinctUntilChanged()"), but your app is now held together by a bunch of invisible wires. These wires stretch across your app in the form of mutable observables and fire throughout your UI layer in response to external events, updating stuff. The flow of state through your application is not reflected in the call stack or in function type signatures. Orchestration can be awkward. In order to gain back finer control of timing you coarsen your observables or fuse them together, losing half of the efficiency/terseness gains you've made. I find it harder to debug about when used within an app, I can't see what's happening in my function signatures nor the order of things. The rules about observables are simple in isolation (and the merging of Iterable and Future is almost great), I find them far from simple when they're attached to a tree of stateful UI. This pattern/approach has been around in a dozen languages now, I attempted to adopt it in Scala, and was hesitant with it in Swift. It's certainly "neat" and provides short term gains but I find it comes at the cost of code clarity (accurate type signatures) and control (timing). There's a reason it's not adopted widely in the other languages despite existing for a while now. For the small circumstances I'd be happy to use it in, it's too heavy of a library. Your mileage may vary, and if you're happy with it then go for it. I've personally not found it worth the tradeoffs. Rx proponents could view this as simply "you're doing it wrong", the only way to find out is to try it for yourself, it's just far from a golden bullet. 
 &gt;I tried LiClipse but I seems like it is a piece of garbage. Give atom a try later. I also tried clion with a swift plugin, feels right but I can't build currently. Maybe that's the way to go. You do need to give developers time. Swift is completely new as such IDE support won't be instant, it can't be. &gt;It's a kind of joke by Apple. "Yes we released swift for Linux. It's cool isn't it ?" And than, your not able to create an easy console output program on Linux. Frankly you sound like an entitled idiot and I'm trying to be kind here. IBM has been working a very long time, well before Swift was released publicly, to get a Linux environment ready. They are still working on getting the infrastructure firmed up. For example they have done massive work on LibDispatch for Linux. If you look around you can even find a library for command line development in Swift so your comments are garbage. Take head of my first response Swift is under very heavy development on Linux and thus isn't ready for the entitled crowd. Literally everything is in a state of flux or heavy development. Until more stabilization happens there isn't a lot of incentive for developers to run in and support a moving target. Why you are criticizing a moving target like Swift is beyond me, if you can't handle the constant change stay away. That is the advice I've taken for myself for the most part, I'm learning a bit of Swift piece by piece but not rushing in especially knowing that the APIs are about to get a massive overhaul. 
Thanks for recommending the book! I just released [Pro Swift](https://gum.co/proswift/reddit) which is focused exclusively on Swift's standard library – no UIKit, Core Graphics, etc. Use that link to save $5 :)
Have you read this? https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853
Second this. It's a great book. And the collections chapter particularly so.
As a reference book yes, but not if you want to learn how to make apps as it shows many different parts rather than a straight flow.
refD, I think you've hit the nail on the head. My intuition is that the AnyObject in state and props is more helpful for more developers, simply by being more open. You could want to pass values from view to view one way, and me another way, and I don't see any reason our ways need to be aligned. I was considering as an alternative a struct that was wrapping a value that could be anything you want, but that felt like a funny way to do the same thing without adding any type benefit. At the least, Swift's if-lets and guard statements work overtime but keep code from crashing on a silly nil or type mismatch. I am curious about your thoughts about render() and inheriting from UIView. I made render to be () -&gt; () because that was what that function felt like to me. Like a survey or a pass over anything you'd like, with place() statements where you decided to make them. In practice it has been great to be able to compute quick values for things, like the background color in the frame example, and pass them as a prop or act on them in some other way without having to keep that value in props, state, or any property at all. I can see that render() could have the same freedom without being () -&gt; () though, so I am curious. Great to hear your thoughts. I have tried to use RxSwift and similar libraries many times and every time I try I am confident there's a much easier way to bring the same benefits. And if these libraries aren't intuitive for me to learn, they are many other developers who will feel the same. Funny you mention "magic" too. Somebody just wrote me yesterday suggesting the name change from "StateView" to "MagicView" because they were having fun using it.
Try AsyncDisplayKit, built by facebook as well. Not exactly the same, but the framework takes ideas from ComponentKit and it's in active development.
 Why the assumption that OP is trying to develop iOS on Linux? It sounds like OP wants to build Linux software with Swift instead.
I'm a huge fan of HWS, and pre-ordered pro as soon as it was announced. Thanks for your work.
I haven't had a chance to review this book yet, because I have not yet purchased it. So I can't speak to specifics. But, I have used Hacking With Swift extensively, especially in the early phases of learning Swift, and always recommend it when someone is looking for learning resources. Even now I still find myself going to the site when I am working out how to use an API for the first time, or working through something else new. High quality resources are not cheap to make and take an incredible amount of time. Pro Swift looks like a great value and if you are someone who has used hackingwithswift.com as much as I have I say buy the book as a way of saying thank you and showing your support, and consider all the content that comes with it a bonus.
Is the TOC in the link not sufficient? I'd be happy to post a PDF of the full TOC if you'd like to see the details. (Note: I really, really do need to work on my selling skills – I'm a coder who writes, not a marketer. Any advice is most welcome!)
Nice job, purchased. Came at a good time for me as I look to improve my Swift code! Since you mentioned wanting advice on marketing, you could take advantage of the buzz/announcement of your latest book by heavily discounting your previous. Authors that do this usually see a good uptick in the previous title due to impulse buying on the new one! With no discount people will usually just buy the current. My 2cents (from a marketer). Looking forward to reading! 
A number of people have requested a full table of contents. I intend to expand the book over the coming weeks, but the below is accurate as of today: * Welcome * Dedication * Acknowledgements * Get in touch * Copyright * Pattern matching * Matching calculated tuples * Loops * Matching optionals * Matching ranges * Matching enums and associated values * Matching types * Using the where keyword * Nil coalescing * Guard * Lazy loading * Lazy closures * Lazy functions * Lazy singletons * Lazy sequences * Destructuring * Labeled statements * Nested functions, classes and structs * Nesting with semantics * Nested functions * Returning nested functions * Documentation markup * Documentation keywords * Useful initializers * Repeating values * Converting to and from numbers * Unique arrays * Dictionary capacities * Enums * Raw values * Computed properties and methods * Arrays * Conforming to Comparable * Adding and removing items * Emptiness and capacity * Contiguous arrays * Sets * The basics * Arrays and sets * Set operations * NSCountedSet * Tuples * Tuples have types * Tuples and closures * Returning multiple values * Optional tuples * Comparing tuples * Typealias * Generics * Limiting generics * Creating a generic data type * Working with Cocoa types * What's the difference? * Closures are references * Why use structs? * Why use classes? * Choosing between structs and classes * Mixing classes and structs * Immutability * Variadic functions * Operator overloading * The basics of operators * Adding to an existing operator * Adding a new operator * Modifying an existing operator * Closures * Creating simple closures * Closure capturing * Closure shorthand syntax * Functions as closures * @noescape * @autoclosure * The ~= operator * Error fundamentals * Error propagation * Throwing functions as parameters * try vs try? vs try! * Assertions * Preconditions * What is functional programming? * map() * Examples * Optional map * forEach * flatMap() * Optional flat map * filter() * Examples * reduce() * Try it yourself * Reducing to a boolean * Reducing to find a value * Reducing a multi-dimensional array * sort() * Sorting complex data * Reverse sorting * Function composition * Functional building blocks * Lazy functions * Functors and monads * Object-oriented programming * Nouns first * Encapsulation * Inheritance * Super methods * Polymorphism * Final classes * Class properties and methods * is-a vs has-a * Protocol-oriented programming * Protocol extensions in detail * Thinking horizontally * POP in practice * Constrained extensions * POP vs OOP * MVC * Models * Views * Controllers * Fat controllers * Create delegate objects * Push rendering to your views * Push logic and formatting into your model * Switch to MVVM * Is MVC dying? * MVVM * View models * The role of view controllers * Benefits of MVVM * Disadvantages of MVVM * MVC vs MVVM
Thanks for the tip! I guess "my previous book" is a bit of a misnomer: I update Hacking with Swift regularly to add new chapters. There's one final extra project due in about six to eight weeks, plus a Swift 3.0 update due in June. Pro Swift doesn't make Hacking with Swift any less useful – they are completely complementary :) What I'd like to do (when Gumroad supports it!) is offer a bundle of both books at a discount. Hopefully soon!
Bought! Quick question: When you do your videos, are you typing live? Because if you are... damn, you type fast.
Will this book be updated when Swift 3.0 is released? And if we buy it now, will we have access to updated versions?
Yes, the book and videos will updated to Swift 3.0, and yes it will be a free update for all readers. [Hacking with Swift](https://gum.co/hws-book-pack) will also get a free Swift 3.0 update for all readers.
So they're trying to make it different for the sake of being different?
Not particularly. There was no sufficient reason to have them in beside "other languages have them", which isn't really a good reason to keep something in a language, I think. 
A type-safer design is something like this: protocol ReactiveComponent { associatedtype State: Equatable // or `Content` maybe // some method to update the state here, see below } On the one hand, this lets each view define its own, appropriate type for the "state". On the other hand, it makes things a lot more complicated and requires a lot of support infrastructure to get *close* to the ease-of-use of the "unsafe", weakly-typed approach you took. EG: you would also probably want this: /// A type-erasing struct to handle "pushing" state downstream from a parent /// component to child components. struct StatePropagator&lt;Component:ReactiveComponent&gt; : ReactiveComponent { typealias State = Component.State private let propagator: (Component.State) -&gt; Void // &lt;- not right type, can't do better init&lt;K:ReactiveComponent&gt;(target: K, extractor: (Component.State) -&gt; K.State) { self.propagator = { (parentState: Component.State) -&gt; Void in target.updateState(extractor(parentState)) // ^ or whatever the actual "update state" would be. } } // or whatever func updateState(state: State) { self.propagator(state) } } ...which is already clunk-city, but would at least let you keep your type-safety, and still be able to write something like this: class ReactiveCell : UITableViewCell, ReactiveComponent { typealias Content = CellContent private lazy var propagators: [StatePropagator&lt;ReactiveCell&gt;] = [ StatePropagator(self.titleLabel) { return $0.titleText }, StatePropagator(self.bodyLabel} { return $0.bodyText }, StatePropagator(self.thumbnailImageView) { return $0.thumbnailImage } ] // or whatever: func updateContent(content: Content) { // handle local updates here self.propagators.forEach() { $0.updateState(content) } } } For render itself, I think in the long run the right approach is to split it into a bunch of sub-steps, like so: 1. Given an "external state" (e.g. `State` or `Content`), be able to calculate a "target internal state" (`InternalState`) 2. Given a "current" and "target" `InternalState` values, be able to calculate an `InternalUpdate` value (that describes how to turn one into the other) 3. Be able to *apply* an `InternalUpdate` (this is the () -&gt; () part, really) 4. Bonus: be able to coalesce/consolidate those updates (so you can postpone applying them) ...with a complete "update" cycle actually looking something like this: let targetInternalState = self.targetInternalStateFor(content) let internalUpdate - self.internalUpdate(fromState: self.internalState, toState: targetInternalState) // simultaneously update state-and-content: self.applyUpdate(internalUpdate, forContent: content) ...which can generally be hidden inside convenience methods, but would make it much easier to coordinate multiple simultaneous reactions (and e.g. interoperate with the various UIKit coordinator apis). There's probably a happy medium between what you have and something that's this ridiculous.
Thanks! Sold.
That makes sense! I wrote you a text version because it includes the subheadings too – the main TOC (the PDF) just lists the the top groupings. Still, if you want to see page numbers, here you go: [PDF table of contents](https://www.dropbox.com/s/6pmj4ekp4csy30r/Pro%20Swift%20Contents.pdf?dl=0)
`setValue:forKey' is one of the big features of NSObject and depends on the ObjC-runtime. The objective C runtime has some crazy reflection features that are not available in Swift. See here for more info: https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/#//apple_ref/doc/uid/TP40001418-CH1g-184642 If you want to create a pure Swift class, it's pretty much certain that you should not have this kind of functionality. It breaks type safety and is just not a "Swifty" feature. If you want to have Objective-C like dynamic typing and key-value coding, subclass NSObject - it's the primary root object in Objective-C for a reason; it implements some pretty fundamental features pretty much synonymous with Objective-C (eg. key-value coding). Furthermore, I'm pretty certain that it is actually impossible to implement this for pure Swift objects, at least in the current version of Swift. This is because the "pure Swift" reflection features offer only APIs to read properties, not to write them. Finally, the method signature doesn't even make a lot of sense in Swift. How would you set a property that is a value type (e.g. a 'Int')? A value type is not a 'AnyObject', shouldn't it be 'Any'? Also, why would the value parameter be an optional? If the Swift property is non-optional, what would the new value be if 'setValue:forKey:' is called with a nil value? What about calling 'setValue:forKey:' for 'let' properties, would it just crash? None of these things are issues in Objective-C, but they are problematic in Swift.
Can I suggest my own two books? The first is Hacking with Swift, which you can [read online](https://www.hackingwithswift.com/) for free or [buy as a download edition](https://gum.co/hws-book-pack) (PDF, ePub, Mobi, and HTML). The second – released just yesterday – is called Pro Swift, and if you use this [Reddit link](https://gum.co/proswift/reddit) you'll save $5. Hacking with Swift is a massive (1300-page PDF!) tutorial series that teaches you iOS coding from scratch. It covers all UI, Core Data, Core Graphics, Core Image, GCD, and much, much more. Pro Swift is a book + video course that focuses on the pure Swift language, and is designed to help you write faster, more efficient Swift. If you're serious about Swift you'll read both, but you'll probably find Hacking with Swift is the best place to start. I come to /r/swift regularly, so don't be afraid to ask for help here or on Twitter – I'm @twostraws.
would this be a good option for beginners? 
No; Pro Swift requires at least some Swift knowledge, otherwise it won't be useful. At the very least you should have completed the introductory chapter in [Hacking with Swift](https://gum.co/hws-book-pack) before going near Pro Swift. Ideally, maybe complete the first few Hacking with Swift projects first – they teach you the fundamentals of Swift in the context of building real apps, which is a much easier way to learn. Note: the Reddit discount for Pro Swift is only valid this week. If you buy Hacking with Swift and are enjoying it, you might want to buy Pro Swift before the discount ends – you can always read it later, and there'll be a free update for Swift 3.0 when it comes out. If you have any problems following Hacking with Swift or Pro Swift, please do ask – I come by here several times each day!
Is this static JSON, that you have a file or string of, and want included in the app? And not pulled from a server? If so, you can either include a .json file in your app, open it, and parse it using something like SwifyJSON, or you can rewrite it to be a swift dictionary. However, you could also map it to objects using something like [Mapper](https://github.com/lyft/mapper) — this works really well especially if you're pulling content from servers. Let me know if you want more details on any of these options!
Any chance to see a sample chapter?
I too use a hackintosh. Extremely fast with very little issues. Basic specs are Xeon e3-1220, gtx 760, 16gb ram, 120gb ssd and 1tb hd. 
Well, XCTest shipped with the latest snapshot and is built into SPM, so I use that. It's quite annoying to set up, though, and it's structure seems to change every snapshot.
I was afraid of that. Thanks for letting me know.
Select the file and make sure it is added to one of your targets. Check right side on Xcode file inspector. You can also add the file by going to build phase and adding the file under copy bundle resources.
I had a look around but short of the git repository's history, there's no information. It's possible that's by design (it's claimed they're "automatically created from mainline development branches"). It would still be nice to have a "this week/month in Swift mainline" or something like that to accompany them.
iBeacon will be what you are looking for. I don't have any code handy, but hopefully that points you in the right direction to research.
You don't need a course for that. The basic pattern is very simple. You need to have a variable/constant for that, you need to specify the size of your element (CGSize) or coords (CGRect), you need to specify constraints and you have to add this element to your view. for example, let myLabel = UILabel() myLabel.frame = CGrect(here are your coords) self.view.addSubview your label is here. There are tons of recipes for this stuff on StackOverflow, just google "create [some class] programmatically".
Thanks for the reply. I see the file listed in both of these places. I'm guessing it should appear in the Document folder for the Core simulator app that Xcode creates. I've been looking for it there and doesn't appear. I've been getting the path with: NSFileManager.defaultManager().URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask)[0] Then appending the path. The path looks correct when I test it. If I navigate to this location on my computer the document directory is empty. 
Not iBeacon, but the tech that it uses. Bluetooth LE. Take a look at near lock. They use Bluetooth LE to estimate distance between your Mac and iPhone. Works reasonably well. Note that there isn't a super accurate way to do this. 
Yeah, you can use an iPhone as a Beacon. Here's one tutorial that may be helpful: https://www.raywenderlich.com/101891/ibeacons-tutorial-ios-swift Just a heads up I've not gone through it, but on the surface looks like it will help you.
There's not a reliable way. GPS and other Location Service technologies will do for &gt;10-20m. But there's a "dead zone" below that distance - it's a physics and technology limitation that everyone faces. The problem is radio-based distance finding is difficult at those distances (short of literally having radar which is a very particular radio design) or having cooperative techniques that "hack" (generally unreliably) existing radio technologies (BT, WiFi) that were never designed to provide distance ranging. You can roughly control limit range by dropping radio power but this parameters is automatically tuned in iOS device to maximize connectivity (and you'd lose internet reliability for yourself doing this). Otherwise you'd need to use a cooperative scheme (common software on each side) which could work with Location Services at the bottom end of its range. From an engineering point of view, that's dicey. There is [some research published recently to do exactly what you are talking about (pdf)](https://www.usenix.org/system/files/conference/nsdi16/nsdi16-paper-vasisht.pdf) BUT it requires customized access point firmware on certain existing WiFi chips to do it. Their goal was to enable better security with public WiFi access points by GeoFencing everyone who is connected to the AP at a link-level of the OSI stack and using some interesting DSP techniques to obtain &lt;10m distance measurement. However this is at least 2-5 years out as a commercially available service or feature of smart phones and ONLY IF it proves out and ONLY IF Apple decides to implement it on iOS. Apple is pretty conservative on things if usability or user experience could be compromised by poor or unreliable performance so they usually adopt post-bleeding-edge only.
Well you might try the Big Nerd Ranch iOS book (5th edition is Swift) they have 3 tiers of difficulty on the questions. Some are quite a challenge when learning the language. Hope this helps!
Look through [here](http://stackoverflow.com/questions/11633548/suggest-websites-to-practice-c-c-algorithms-puzzles) and just try them out with Swift 
You could use your app logic on more than one platform, of course you will have to redo the interface code.
LeetCode.com has challenges for many languages (including swift) as well.
You can actually do this in code. Below is an implementation I used in a music streaming app service. I'm sure a more robust version might work for you. func optimizeForDeviceSize() { // Adjust album size to fit iPhone 4s, 6s &amp; 6s+ let deviceHeight = self.view.bounds.height if deviceHeight == 480 { albumHeightConstraint.constant = 106 view.updateConstraints() } else if deviceHeight == 667 { albumHeightConstraint.constant = 230 view.updateConstraints() } else if deviceHeight &gt; 667 { albumHeightConstraint.constant = 260 view.updateConstraints() } }
After you build the app, where are you looking for the file? Xcode does not put it into the Document directory. Xcode puts it inside the app. If you open the .app package, it should be there along with stuff like Base.lproj and Info.plist. The way the file could end up in the Documents directory is if you write some code to access it inside the app and copy it into Documents (or some other runtime accessible directory).
I do this quite frequently when I have a simple UIView or UIViewController. Here are a couple things to point you in the right direction: 1. When creating a UIViewController programmatically, add all subviews to self.view in the loadView lifecycle function. 2. Before adding all the views in loadView, make sure to instantiate self.view like this: self.view = UIView(frame: UIScreen.mainScreen().applicationFrame) 3. When creating a subclass of UIView programmatically, I create a private function called commonInit and put my initialization logic in there. Call this function from init(frame:CGRect) and init?(coder aDecoder: NSCoder). DON"T CALL IT FROM init. init just calls init(frame:CGRect) and passes CGRectZero. 4. When creating a subclass of UITableViewCell, override init(style: UITableViewCellStyle, reuseIdentifier: String?) and init?(coder aDecoder: NSCoder) and call your commonInit function from both. Again, DO NOT CALL IT FROM init. 5. You need to consider whether you want subclasses of your views to be able to use XIB files or storyboards. If you want that flexibility, then override init?(coder aDecoder: NSCoder). Otherwise, you don't need it. 6. I use this project for laying out subviews using autolayout: https://github.com/jrturton/UIView-Autolayout. It makes things way easier. 7. Make sure you understand the difference between content hugging priority, content resistance priority, and constraint priorities. (There are plenty of Youtube videos out there on these topics.) 8. I also make a habit of creating properties for any subviews and lazy loading them. I also put any configuration logic (e.g. for a label I would put the font, color, default text, etc.) and then anything to do with the constraints of that label would be handled in the commonInit function. 9. When adding constraints to a view, make sure to set translateAutoresizingMasks to false or you will see lots of broken constraints. Good luck! I definitely feel like I learned way more about autolayout once I fully understood how to create programmatic views with constraints. Edit: Added comment about translateAutoresizingMasks.
I haven't done so personally, but try some of the challenges you see on /r/dailyprogrammer. 
At the moment you can't write GUI using Swift. Some significant amount of work on the Android side is required to support Swift as a first class citizen. I'd argue that usage of Swift for sharing business logic between apps is a bad choice right now because you would have to write a lot of "glue code" in Java.
This is interesting! Try completing my [Hacking with Swift](https://www.hackingwithswift.com) projects; each one ends with a set of challenges to try to take the projects further. You might also like my ["be the compiler" Swift tests](https://www.hackingwithswift.com/test).
This. You are and will never be a programmer or able-programming in any specific language by only 1) reading a book, 2) taking class, or 3) watching a video. The ONLY thing that works is possibly doing 1, 2 or 3 **AND** writing code - lots of it. What should you code? Book problems are a good start, but it can be anything and everything that can be aided by manipulating data, strings, numbers, files, etc. Which for any person is at least dozens of things a day and if you live a particularly self-aware, thoughtful life, easily hundreds of things. It's more of a problem to just pick one. The one you pick doesn't matter so so much when it comes to learning to program. It can be GUI-based but it really doesn't have to be - command line apps are actually easier and more effective as a newbie.
https://www.hackerrank.com
I would add that "Right now" is not even really a release. This is planned to be fully implemented in Swift 3.0 later this year, if you are trying to put any of the swift development branches into production you are asking for problems. 
Try Few.swift: https://github.com/joshaber/Few.swift (I'm the author of ComponentKit.)
Even without NSURLSession you could have a wrapper for it and in iOS inject the one wrapper and in android inject another. Then the majority of the networking code can still be shared. The part that says "give me this data from the url" is pretty small. 
Glad to hear this, I have both of them and I'm really enjoying them. Thanks Paul for your work.
["That's not how it works! That's not how any of this works!"](https://www.youtube.com/watch?v=Aq_1l316ow8)
Here are a few examples: https://github.com/melling/ios_topics 
Because Java is the fucking worst. I'd pick ObjC over it. 
And not only UI. For example app components like Android services are written in Java and you can't use NDK to implement them as far as I know.
[removed]
Wat?
There's very little app logic once you can't reuse the libraries. If you use a solution like Xamarin you'll get the full .Net library with it so all networking code can be reused. This is a big chunk of your code. 
are you trying to reverse engineer something? Is that what you are trying to do?
&gt; I find it hilarious that the first thing the people suggest you do is to install cocoapods then some github frameworks instead of using what's already in the stock Apple frameworks. Parsing JSON is not hard. 1000x agree. 
Honestly I disagree with that. Java has simpler semantics, a larger ecosystem, real package management, better build systems, better type system, etc. etc..... Java and ObjC are both nightmares, but at least Java is a more useful nightmare.
[This is Swift and iOS.](https://github.com/mplewis/AppRemoteSettings-iOS/blob/master/AppRemoteSettings%20Example/NSUserDefaults%2BAppRemoteSettings.swift) [This is Java and Android.](https://github.com/mplewis/AppRemoteSettings-Android/blob/master/app/src/main/java/com/kesdev/appremotesettingsexample/AppRemoteSettingsClient.java) No matter how many useful language features Java has over Swift, it won't let me escape the hell that is the verbose, developer-managed hell of terrible Stream, Buffer, and HTTP APIs. 
It is rumored that Google is exploring using Swift for Android as a first class language. If that happens, I would drop Java in a heartbeat.
Thank you guys!
1) The old String-based way was not checked by the compiler. If you had a typo ("onRegluarClick") you wouldn't know it; it would silently fail. The new way can catch that. It also allows you to reference the Swift form of the method name rather than the ObjC form (in cases where they are different). And lastly, it allows the compiler to do checks like the one which warned you your method was not exposed to ObjC. 2) You just figured out the proper way. 3) ObjC selectors require dynamic dispatch via the ObjC runtime. If you don't prefix your Swift method with @objc (or something that implies it, like @IBAction) then the method would not be exposed to the ObjC runtime and your selector wouldn't work. Though I would have thought inheriting from an NSObject-based class would expose everything by default. Been a while since I've tried.
Yeah, propagating releases takes about half a day on average and it seems to be getting worse all the time.
[Found another issue with the test....](http://i.imgur.com/2837rXF.png) import Foundation let data: [AnyObject?] = ["Bill", nil, 69, "Ted"] for datum in data where datum is String? { print("first loop") // print(datum) } for case let .Some(datum) in data where datum is String { print("second loop") // print(datum) } Output: first loop first loop first loop second loop second loop Point back, please?
I don't even..
Yes, this is the best way to do it. This way, Xcode can suggest autocompletions for the variable names, you don't have to deal with Optionals coming out of your Dictionary (and the compiler will tell you if you are trying to access a variable that doesn't exist), and your code is formatted more nicely.
Your target is self. Remove ViewController from the selector and just call the method. 
Just the fact that they're trying to sue Google for using java
Did not know there was another trial happening. Just read up on it now. Wow. 
Create a formatter for the textfield?
Every thing is normal! everything is as expected! What you are seeing is exactly what you should see: the file inside the .app package! Xcode does NOT put it into the Documents folder. YOU HAVE TO PUT IT INTO THE DOCUMENTS FOLDER ___AT RUN TIME___ (not at compile time), IF THAT IS WHERE YOU WANT IT. There is no such thing as the Documents folder at compile time (when Xcode is building your app), so it puts ALL resources, including, in this case, monster.json, into the .app - as you discovered). This is what happens with all resources in all apps. So, now you want to use NSBundle to get the path to the file, and then use NSString (or NSData if you want to parse the json...) to read it, or use NSFileManager to copy it to the Documents folder. OR, maybe just use monster.json from where it is? Unless you are going to modify the file, there's no need to put it in Documents. 
Completely agree: the help from Xcode/compiler is invaluable. Just thought I'd pop in one minor thing to consider: 'description' is a bit of a magic word in Foundation; the magic is if you do ''''NSLog("%@", someObject)''''' it will call someObject's description method. Similarly doing ''''po someObject'''' in lldb will call description. So, it is usually best to avoid the name description (as inviting as it is!) as a variable/method name unless you are intending to plug into this magic use of description.
I'm not familiar with Sketch and am not completely sure what you are trying to do, but I thought I'd mention this in case it is helpful: When you are editing in the storyboard, you can set the size of the view to something other than 600x600. Just select the view controller, and go to the attributes inspector. You should see a bunch of drop downs, the first one of which is: Size, and it is probably set to inferred. You can change that to lots of different device sizes, or you could choose freeform and set it to _anything_. Just one caution, whenever I do this, I frequently get beguiled by the lovely appearance of my layout within the chosen specific size, and I will forget to get all the constraints (or stack views or whatever) just right so that it looks equally good on all the _other_ device sizes.
Specifically, Xcode can create Swift Playground files, which are great for practice and testing things out.
Huh, well I feel rather silly. I could have sworn that was not working either. But thanks, that totally works.
[This is Swift and iOS.](https://github.com/mplewis/AppRemoteSettings-iOS/blob/master/AppRemoteSettings%20Example/NSUserDefaults%2BAppRemoteSettings.swift) [This is Java and Android.](https://github.com/mplewis/AppRemoteSettings-Android/blob/master/app/src/main/java/com/kesdev/appremotesettingsexample/AppRemoteSettingsClient.java) No matter how many useful language features Java has over Swift, it won't let me escape the hell that is the verbose, developer-managed hell of terrible Stream, Buffer, and HTTP APIs. 
var differences = [Int]() for i in 0..&lt;array1.count { differences.append(array1[i] - array2[i]) }
You shouldn't be exporting anything besides assets. But to more directly answer your question, the reason the 600 x 600 size class exists is to force you to think about how your view is going to scale based on device screen size. For example, if you have a table view cell that has a size of 375 x 60 in your design, what size should that be on the iPhone 5 screen? Or the 6S screen? Either the aspect ratio needs to change, or the height will stay the same and the width will grow. These are all determined by how you set up your constraints. Apple created size classes for this exact issue. Hardcoding your layout based on one screen size is a bad idea. Don't change the View controller settings, it's just going to cause trouble later on. Side note: If you want, you can try Zeplin, which is a plugin that helps organize your Sketch file in a way that makes it easy to implement in your app. https://zeplin.io/ 
More or less the solution I wrote. I used an if else instead of a guard. I like this one. 
I wasn't comparing Java to Swift. I agree, Swift is much nicer.
Best of luck! That's a crowded app sector though, how will you be differentiating your app from others in the same niche?
did you do anything differently when it worked? i am having this issue right now, 2 months after you were able to get through.
I got it, I just with to the Main StoryBoard and I made its class "ViewController" hopefully this can help somebody
Interesting. I don't know as I agree, but could you elaborate?
Thanks for enlightening me. I assumed, wrongly, that files would be put in Documents. I just used NSBundle, and everything started working! Thanks!
Well, that's actually a great question. There's no real single standard for this that I'm aware of, but a ViewModel is generally something that adapts a model (which should be general) to a view (which can be quite specific at times). I don't think there's any consensus on what would make something a ModelController (if there is such a thing), but it feels to me like it should be an object that governs the behaviour of a model object outside the basic business logic a model implements for itself - something like a model delegate, if you follow my meaning. Of course, if the `count` method in this code of yours is part of the model class, then it's just a method in the model.
It could be. Usually you have a Model Controller for something far more complex but if you separate a "View Model Objects" from your normal model objects, then it certainly is a Model Controller. For example if you pass an Array of Dictionaries to your view but that is merely a subset of your "real model" and that model is loaded, manipulated and maintained in a very different form, you essentially have the mirror of what view controllers do to isolate view operations. We use very explicitly separate Model Controllers because our models are generally far more complicated than even the custom Controls/Views we use so we wrap our model class under the control of Model Controllers which interact with event handlers not unlike the Responder chain to handle both Model "Engine" data flows but also external inputs that don't really fit into the "view" metaphor at all (e.g. networking and other IO activity that primary interacts with our models and engines - views are just an afterthought - could replace them with Web interfaces, Window/Linux front ends, remote network "heads", etc.).
Here's my approach to MVVM, if it's any use! Typically in MVVM you have a `Model`, a `View`, and a `View-model`. For iOS you can translate this as `Model`, `ViewController`, `ViewController-Model`. The `Model` manages the data- perhaps fetching it from network layer and storing it in some intermediate form in whatever form makes sense for the client-side data. The `ViewController-Model` takes this data and exposes an API which is designed to provide view-centric methods, such as `titleForPage:` or `numberOfPages`. It is the magic of MVVM and this is what keeps your controller small by removing all the nitty-gritty detail of data manipulation. The `ViewController` is then written extremely simply, asking the `ViewController-Model` for `numberOfPages` - note it is not calculating the number of pages based on the model. That's all done already! So it can focus entirely on views, colours, styling, and pull everything it needs from a simple API. I would even recommend writing the controller first and then you'll know exactly what your API on the `ViewController-Model` should look like. Now you have a small `ViewController` class, and testable `Model` and `ViewController-Model` API's. And the `ViewController` is easy to understand because it really only interacts with the `ViewController-Model` API which speaks a plain english language of the exact things it needs! 
It's even more crazy if you have multiple occurrences of the same variable in the same row. int z = y++ * ( ++y - --x) / x++;
What is the first element? The difference to zero? My code would be this: let numbers = [1,3,6,8] let differences = zip(numbers.dropFirst(), numbers.dropLast()).map(-) // [2, 3, 2] But this doesn't contain the first "1" and is only the pairwise differences. If you want the first difference, you can always insert a "0" in the array at the first index.
That's a good answer, and I hope I'm not hijacking OP's question, but have you got any references to documents which might elaborate on exactly what you've described here by giving a concrete example (preferably in Swift or at least Objective-C, but ok if in another language!). Thanks.
Thanks for your support! Let me know if there are new chapters you'd like me to add.
Interesting approach but not strictly MVVM... it's ViewModel not View Controller Model. Where the ViewModel is responsible for converting the contents of a Model so it is ready for the presentation layer (i.e. a View) to display it on screen.
You could try to use a plist file and write some convenience functions to access the data within.
If you replace 'presentation layer' in your description with 'view controller', which you can certainly argue is a presentation layer, then you described the same thing as me. Semantics ;)
It's about what your code tells to the reader: guard, as the name implies, is meant to protect the rest of the function from invalid inputs by checking preconditions, that's why it forces you to exit from the function, it's a way to formalize the “early returns” pattern. When I read your code guard tells me that 0 is an incorrect value, but that is not true, it's just the first step in the algorithm.
The point is the ViewModel does all the formatting ready for presentation with a View so you don't clutter your View Controller with it and with the double whammy of making it way more testable. What you described is abstracting out calls to the persistence/data layers from the View Controller, which arguably you should do in MVC anyway. I.e. a data controller (which you're calling a ViewController-Model, so I'd agree semantics there). So I'd actually have ViewModel(s) sitting on top of the ViewController-Model you describe, which all get initialised via the Model objects returned by the ViewController-Model.
`dropLast` is only O(n) if slicing the underlying sequence is O(n). For arrays, though, slices return an `ArraySlice`, which is just a view into the original array, so they're all O(1). [Here's the docs for array slices.](https://developer.apple.com/library/tvos/documentation/Swift/Reference/Swift_Array_Structure/index.html#//apple_ref/swift/structsub/Array/s:iSa9subscriptFGVs5RangeSi_GVs10ArraySlicex_)
The fact it's empty is perhaps telling! I'm going to take your advice in my planning for Swift 3.0 - and do nothing at all! LOL
Awesome reply thank you. Got any information on chaining functions that you can link?
You should absolutely start with Hacking with Swift, although feel free to skip the introduction – all the same material is taught in project 1 onwards, but it's taught in the context of a real app.
When updates go out you'll get an email from Gumroad, as long as you haven't unsubscribed. I don't have a changelog because it mostly doesn't matter – there's rarely a reason to go back and do the old projects again. Instead, I talk about what's new, e.g. new projects or material.
They're getting rid of the increment/decrement operator?!?!? Why? It's incredibly more efficient: `i++` vs `i = i + 1`. I really hope that's not true...
They're deprecating 'i++/i--' in favor of 'i+=1/i-=1' because it's redundant to have two implementations of the same function and the '+=/-=' operators are much more versatile ('I+=10', 'j-=7', etc.). I don't necessarily agree wth their reasoning, because I use i++ in combination with while loops all the time, but I understand the reasoning behind the decision.
The type system is trash. It's generics are only useful in the most basic sense, and are nowhere near the level of more modern languages. Verbosity.
https://github.com/Alamofire/Alamofire Alamofire has an incredible Readme! Scroll down to the ResponseHandling section
Efficient as in less typing? Or as machine code? For typing, saving one character isn't much in the grand scheme. Otherwise, +=1 is just compiled to be increment. It *is* a bummer that the ++i vs i++ interview question is going to be moot now.
Is it only an experiment or serious project?
This does not belong here as it has nothing to do with Swift directly
If you can't even spell the name of our IDE, gtfo.
Meh it seems they're just eliminating a few small things that the language already has other ways of doing (c style for loops, increment/decrement operators). Doesn't bother me personally
Serious project
Exactly. One of the criteria for developing the Swift language is something along the lines of "If no one knew about this, would we implement it?"
I think the info about currying functions here is slightly misleading. From what I understand, the syntax described will be deprecated, but you can still use curried functions.
The author missed the best part imho. Copy and pasting from https://github.com/apple/swift-evolution **Complete generics**: ... the ability to make a constrained extension conform to a new protocol (i.e., an array of Equatable elements is Equatable). This doesn't sound sexy/interesting, but it's a big deal. The current state of ==/Equatable is painfully inadequate and various permutations of arrays/tuples/optionals all require creating your own == function and basically copy and pasting the implementations (because it's trivial/identical). It's not just equality either, comparable (ordering) and hashable can follow the same path. Maybe if we're lucky the next step will be deriving. 
I will be brutally honest, that looks very disgusting on a small screen. Maybe it'll be effective on a 12-inch iPad, but in all reality, all we need there is Safari with multiple side-by-side instance support.
A few short points - I agree that bindings are a super nice tool. Apple has had those, also for a long time, on OS X. But they decided against bringing them to iOS. I think one of the reasons was performance (if done right, less abstraction just tends to be more efficient it seems, unfortunately). But it also makes it easier to tweak details, because you have the implementation right there (even if it's a mess), and not hidden behind as many layers of abstractions as you would have with say some xaml binding. I think that is part of the reason why iOS apps are more "fine-tuned". Also, you really have to cut auto layout some slack. It's hard to get into it at the beginning, and there are some legacy/performance reasons that can cause it to be a pain sometimes, but it's very powerful and elegant in the end. I haven't seen a layout engine that allows this degree of freedom anywhere else. The example in the article with the progress bar and buttons really only takes longer if you're new to auto layout. Finally, Visual Studio isn't perfect either. Just yesterday I tried "Go to definition" on some random "using xyz" statement, and Visual Studio told me "Cannot navigate to the symbol unter the caret", which is just complete bullshit. I haven't felt trolled this hard by Xcode in a long time (I just tried putting the caret somewhere else and right-clicking the symbol, but that puts the caret at the symbol before opening the context menu with "Go to Definition" again, so the message is just totally useless and seems maliciously misleading). But in the end, I'm sure that Visual Studio is a great IDE, it's just that I don't have a lot of experience with it yet and click random things that lead to random errors. With Xcode, I have had more time to learn about it, so I don't usually stumble across that type of error anymore. 
If the article is 'empty' that says more about the authors short-sightedness than it does about Swift. As others rightly point out; the growth of the cross-platform Frameworks, as well as enhancements to generics, are huge things to care about... not the syntactic fluff.
This UI is DEFINITELY not final. Anything below a six plus will just be a normal web browser that you can split in half... It really is meant for iPad
Yep, that's what I understand too. The formal declaration of a curried function will be gone, but you can still use currying (by calling directly a closure returned from a function for example).
I agree that Swift needs a strong core library, but at the same time, I'm not really happy with their decision to reimplement Foundation. Sure, they're making naming changes (swift 3 api design guidelines) and what not, but Foundation is still an Objective-C api with all of the reference types and clumsy api's that come with it. I know they want to keep the standard library thin, and I can see their point of view, but shipping Foundation _with_ Swift is the equivalent of a standard library and I think they can do much better than that.
you can google this, or ask on stack overflow as there are places that have guides on how to reverse engineer
I'd like this for iPad. It annoys me that I can't look at two websites at once even with split screen on my iPad Pro.
No offense but in that case I humbly suggest reassessing the viability on iPhones. On iPad it might still work but in example on the SE I'm typing from right now you would not see much anymore. Full screen Safari becomes a scrolling spree already too often.
&gt;if you are using var parameters to a function, you should stop now. Change it to inout, and make sure you understand what inout does. No, fuck, no! That's not what `inout` is for AT ALL.
Maybe you don't know as much as you think? Seriously. Either get a book on swift or read the swift language specification. These are very fundamental parts of the language and have direct analogs to, say, 10-20 other programming languages.
Put metrics in and see how many times people open in, close it, do nothing.
Seriousluy, if you need to post a question on those things instead of reading up on your own... Those are fundamental parts of many languages. 
I can't decide if I think the rush immediately after realizing everything is working as intended is the best, or the fuzzy feeling you get when you look back at something you wrote years ago that is still running well in production.
the swift-evolution thread implied we may see a nicer(possibly scala-like) syntax. Anything new on that?
Multitasking with more than two windows on the display. This is really meant for the iPad, but I only have an iPhone to test it on.
I find it's better to scan the xml of the storyboard and generate code for it. I started long ago to do it myself but got distracted when I switched to Android development, so I unpublished the code given I would not maintain it any more. Reading again through my notes I can give you a list of _potential competitors_ in this space. In no particular order: * https://github.com/krzyzanowskim/Natalie * https://github.com/kattrali/ovaltine * https://github.com/mrackwitz/xcres * https://github.com/puls/objc-codegenutils * https://github.com/indragiek/swiftrsrc Not all of them are comparable and have different target domains, but hopefully there's something useful for you there to generate strongly typed segues (and much more).
If I look back I could rewrite the code a few thousand times until I would think that it truly is awesome ( there's always room for improvement, new methods, new optimizations, better readability, better comments etc. etc.)
The code in this article is really weird. There's this snippet: ++i //becomes i = i + 1 Which isn't *incorrect*, but isn't at all idiomatic Swift: `i += 1` is much more normal. Then the article talks about curried functions, and how they're used to specialise functions. This example is given: func currySum(x:Int)(y:Int) -&gt; Int{ return x + y } For what it's worth, the Swift 3 equivalent of the above is just: func currySum(x: Int) -&gt; Int -&gt; Int { return { y in x + y } } However, the article says that the usefulness of currying is obfuscated by "inheritance and protocols". Maybe I don't understand what the author means, but I'm pretty sure currying is totally unrelated to both of those concepts. Then there's a bunch of strange uses of the `var` keyword. It's stuck into every `for...in` loop: for var i in 0..&lt;10{ print(i) } And, as /u/teddim pointed out, the article seems to imply that `var` before function parameters should be replaced by `inout`: &gt; if you are using var parameters to a function, you should stop now. Change it to inout, and make sure you understand what inout does. *This is terrible advice*. It really seems like the author doesn't understand the `var` keyword.
Indeed. The amount of praise this article gets on this subreddit also slightly worries me.
Or, conversely, looking back at your code when you first started iOS dev/Swift and seeing how shitty it is. An equally good feeling knowing that you've improved 
:'(
Thanks for the feedback. The main reason is for encapsulation and readability. The example is trivial, were it any smaller I would argue there would be absolutely no reason to proceed with #2 or #3, although it did look a bit more like this when I found it: func showBlockingOverlay(withMessage message: String = "Please wait...") { let alert = UIAlertController(title: nil, message: message, preferredStyle: .Alert) let loadingIndicator = UIActivityIndicatorView(frame: CGRectMake(10, 5, 50, 50)) alert.view.tintColor = UIColor.blackColor() loadingIndicator.hidesWhenStopped = true loadingIndicator.activityIndicatorViewStyle = UIActivityIndicatorViewStyle.Gray alert.view.addSubview(loadingIndicator) loadingIndicator.startAnimating() presentViewController(alert, animated: true, completion: nil) } Note how definition and property manipulation isn't nice and neat like the above first example. This tends to be the norm as more lines/functionality are added to the method. Now imagine an if/else statement around tintColor or an external method call or two, or someone moves those magic numbers in the CGRect into their own variables for debugging. As a bonus, 2/3 allow for easy promotion of scope (or refactor, say removal, of code or hunting down like bits). Lastly, there's always a lot of talk about keeping methods short and concise (one professor said 'no more than 10 lines of code, ever'). If you subscribe to this philosophy you generally don't realize how large the method is going to be until *after* the code is written. That's where the 'bonus' above kicks in. I've also been thinking a bit about the '10 lines of code' rule, especially when I'm debugging or code reviewing someone's work (including my own) and suddenly I'm hunting down functionality in two files, four methods and a private extension and they're all 2-5 liners (I call this a form of OOP abuse). I would argue #2/3 allow and forgive large methods but keep the abstractions 'local' where they're being used. Or, maybe it's a bunch of seasoned developers bored and looking to over architect something on a Friday afternoon. 
I will look into both of these, thankyou. Do both of these offer options to compile your own code? 
get the insider preview of windows 10 with the ubuntu subsystem or install linux directly, there you can play around with it creating things until you know swift, then buy a used mac from like 2011 or so and you'll be able to build apps and learn the frameworks etc.
I didn't find appropriate answer for this on Google and StackOverFlow. That is why. I wanted to edit exec files.
http://lmgtfy.com/?q=hackintosh
I checked. Plenty of apps have draggable views somewhere. This shouldn't be a problem
iTunes U courses are a collection of lecture videos
I'm really just getting into using extensions and protocol oriented design in general, but I *think* in that case you'd want to use a clause shared to both, maybe using a new protocol of the shared features and use it for the clause instead.
I've tried this already but wasn't able to successfully set it up. Do you know of any in-depth tutorials on how to set it up?
Those frameworks you're talking about have been cross platform for decades, and the enhancement to generics won't break your code. Syntax will. Talk about short sightedness...
https://developer.apple.com/app-store/review/guidelines/#user-interface &gt; 10.4 Apps that create alternate desktop/home screen environments or simulate multi-App widget experiences will be rejected
Yes it would. I've done it myself. Look up tonymacx86 for hackintosh guides.
I do it all the time. The Mac only holds your keys in the keychain so you can sign the build.
Plenty of apps have 'broken' this rule. If they reject it I don't really have a problem with it, since this was pretty easy to make.
This is very true. Luckily for myself my epiphany moments tend to come in the shower before going to work so my sleep remains uninterrupted. 
possible problems could arise if you aren't using an authentic mac. i'm not saying they will, you may be totally fine and problem free, but considering you can get a mac mini for 400-600 bucks it isn't worth the risk imo (unless your current computer is equipped to be a hackintosh)
If anyone is interested, I wrote a tutorial on how to use UIStackView to allow multiple web views to be visible side by side. The result is quite different, but you might find it interesting anyway. [Link](https://www.hackingwithswift.com/read/31/overview)
Or you can simply stay in LA.
Just a note, the 1st and 3rd paragraphs are the same.
it was around 4am the other night(morning) when i, out of a sound sleep woke up and told my gf, "it was the parachute" and then went back to sleep. i was struggling with an aspect of a game and that was the solution. fixed it the next morning :) 
Foundation isn't the standard library. The standard library is stuff like Array and Dictionary, Int and String. Foundation is just a swift project which aims to be a cross-platform subsystem - it provides stuff like NSURL and downloading, locale-aware number formatters and such; you don't have to use it and you might use some alternative. For now, the plan of the Foundation project is to implement their base functionality across all platforms, do some small cleaning up but otherwise not really change the API that much (nothing which can't be automatically migrated easily). That will allow code which has already been written for iOS to be ported over to Linux more smoothly. Once that happens and the cross-platform codebase swells, they'll introduce a more native swift-feeling API. The swift language itself is still developing. Some of the holes limit what might be possible with a truly-swift Foundation API at this time. It's better to get the big changes over with at once, instead of overhauling the API every few years as the language matures.
or i can take the flight AND complain all the way there with my crying toddler
I know that Foundation isn't the "standard library" per se. However, it _ships_ with the Swift language - doesn't get much more standard than that. All I'm trying to argue for here is: 1) if they want to keep the standard library small (they do), it doesn't make sense to ship _another_ library with the language 2) shipping Foundation as it is with Swift is a bad idea because Foundation is not meant to be a Swift api. Yes, it's true that they're going to make it 'swiftier' (and I'm happy that they are) but there's no way that they're going to get rid of the delegate pattern (which requires your objects to be reference types) for, say, NSURLSession. In the short term, it's healthy for the community to have Foundation since it will be easier to migrate. However, in the long term, it will only reduce the overall code quality and make it unclear what the best practices are.
Does your StarObject class implement the NSCoding protocol?
This is probably the problem. Plus I would suggest making your class conform to NSSecureCoding instead, which makes type safety much easier.
No, personally I find nested functions to rarely be useful. The notable exception is for function-wrappers (like decorators in Python). In your case, your initial code is fine and the changed code far more complex. There is such a thing as over-engineering. You could shorten it a bit with a where clause in your for-loop.
I don't understand what you're trying to say. You're arguing my point here. - Idiomatic Swift involves taking advantage of value types where possible. - Value types don't work with the delegate pattern. - Foundation heavily relies on the delegate pattern. - Therefore, using Foundation often means not using idiomatic Swift. I am well aware of the limitations of using value types in conjunction with asynchrony. This is why I'm a huge fan of [Venice](https://github.com/VeniceX/Venice) which allows you to use go-style (no callbacks) concurrency. It allows you to completely get rid of both the delegate and callback patterns, which means that its a perfect fit for idiomatic Swift. I'm not saying that Venice should replace Foundation by any means, but I just want to make it clear that the Swift community can do a lot better than Foundation. &gt;Foundation shipping with swift is a packaging decision. Right, I agree with what you're saying. I just disagree with this decision.
Since you mentioned linked list I would check out this book! http://waynewbishop.com/swift/ I bought this just for fun and it's really well done in terms of swift data structures. Other than that, I would try and build small applications, like hooking up to some API you're interested in and putting the data in a table view. small stuff like that. Dig through some open source swift libraries. some of my favorite ones written in swift: Alamofire (networking), BoltsSwift (asynchronous operations), the new GPUImage 2 (image processing), Pantry (struct based persisting to disk), SnapKit (autolayout helper) digging through those libraries have helped me learn some really cool swift techniques!
If you don't mind reading reading the source is also fun: https://github.com/apple/swift/tree/master/stdlib/public Not sure you have a machine running OS X, but Apple has some great resources: https://developer.apple.com/swift/resources/ 
This is great to see! I wish OpenFrameworks would be ported to Swift 2. I'm looking forward to new GPU-based computer vision possibilities with GPUImage 2!
The book Clean Code (in my opinion) follows a design philosophy of 'no function should exceed four-six lines in length'. I dont like that interpretation of good code design, not at all, even though anyone can write four-six line functions when needed. It was formulated, long ago, that 'one function should do one thing'. Sound advice, but the philosophy can be taken to extremes at either end, 'run this program' to 'run this single loop'. That is the problem. I think, stepping way out, you need to look at design flow and program structure. On the one hand you have the power to make a single function bug free (4-6 lines). But on the other it pushes bugs into design and you can lose sight of flow and dependencies. I think, in the quest for 'clean code' you run into a fundamental disconnect between management at micro Vs macro level, but the level you make that break at is very dependant on the size, complexity and nature of the program.
This getting started guide from the same guy that made that pull request might help you: https://github.com/apple/swift/blob/master/docs/Android.md
You can get a Mac Mini for around $500 last I heard.
Foundation has been moving away from the delegate pattern, or at least offering an alternative for many, many years. Take NSURLSession, for example. It has a session-level delegate because that makes sense for a session object. However, the [download methods also accept a completion handler](https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSURLSession_class/index.html#//apple_ref/occ/instm/NSURLSession/downloadTaskWithURL:completionHandler:) so you can add some code to be executed later without having to create a reference-counted wrapper type to serve as a delegate. "Value types don't work with the delegate pattern" is a useless thing to say. It's like saying "bananas are no good at riding bicycles". Values do not have state. They have no business getting callbacks about random stuff going on. If your value types need callbacks, you are misusing your value types and structuring your code poorly.
I implement it and used NSKeyedAchiver/NsKeyedUnarchiver and I was able to save it. Thanks!
***Analyzing MrMason007*** * comments per month: 10 * posts per month: 3.5 * favorite sub [jailbreak](http://NP.reddit.com/r/jailbreak) * favorite words: 0.7.25.3-3 APT, really, 0.7.25.3-3 APT * age 2 years 9 months * profanity score 0.3% *^Gosh ^darnet ^gee ^wiz* * trust score 25.1% *^Lies!! ^so ^many ^lies!* * Fun facts about MrMason007 * *"I'm a fucking idiot."* * *"I'm a photographer and I am constantly putting sd cards in my computer to transfer files."* * *"I am trying to do tasks?"* * *"I am scared about the lack of ports and capability to meet my needs."* * *"I am planning to make **lots** of Austin wallpapers (360 bridge, skyline, congress, ect.) Ha!"* * *"I am a avid jailbreaker also!"* * *"I am a photographer and I have taken a similar photo!"* * *"I've checked Ok.."* * *"I've never had a problem."* * *"I am a iPhone 5 on 8.2 b2 I have the same problem but I am a iPhone 5 on 8.2 b2."* * *"I am a 13 year old photographer and was looking for some thoughts on how to make my photos better."* 
Blur effect are very limited with UIBlurEffect, something like this might help you https://github.com/szk-atmosphere/SABlurImageView
This declares a function `cellFactory` that takes two parameters and returns an instance of `MySpecialCell`. It seems the function does exactly the same as an initializer on that same cell class, so I'm not sure why this function is needed. I'm guessing the function is used in some kind of functional composition somewhere else in the app. Because prior to Swift 1.3 (or maybe even earlier?) you couldn't use an initializer as a function reference. The following two are identical: let cell1 = cellFactory(.blackColor(), "foo") let cell2 = MySpecialCell(.blackColor(), "foo") Also the following are identical, but one one was legal earlier: let cells1 = colorsAndStrings.map(cellFactory) let cells2 = colorsAndStrings.map(MySpecialCell.init) I would just use the initializer directly everywhere, as the factory method doesn't add neither clarity not convenience. 
Here are some cool projects you could try and replicate :) https://github.com/allenwong/30DaysofSwift
Ive put together a collection of resources, including books, tutorials, online courses, videos, and reference sites. You can check out the main page here https://manitoba.ninja/2016/02/07/resources-for-learning-swift/ and see what is out there that might work for you. There are links to videos from a number of conferences here https://manitoba.ninja/2016/03/11/ios-developer-conference-video-resources/ . The topics covered are pretty varied but taking a look at the two Swift specific conferences might offer something interesting for you.
Keep in mind, the whole process is very subjective and it really depends on the reviewer. I submitted an app recently that got approved the first time but I needed to update screenshots so we submitted again. We got rejected because they thought we were trying to circumvent in-app purchase. I would suggest that you go through all these requirements as if you are an app review having a bad day so that you can be better prepared for a rejection.
You may want to consider presenting the next viewController modally when pressing on the tableViewCell. Presenting modally just places the next viewController on top and keeps the information of the objects on the previous viewController for unwinding purposes.
I'm using a shader that requires custom textures to be given as an input to create special effects and I'll likely need dozens of different texture arrangements for the full effect. 
That is big. Thanks for sharing
One more update, my other app went 4 days without the update appearing. It finally hit the store about 14 hours after I complained.
Did building Swift for Android on Mac really work (and produce usable binaries)? I've asked the maintainers about this before and I was told it is assumed that it doesn't (yet). Did you have to change anything in the build scripts to accomplish this. 
I don't get it the before version uses a syntax that shouldn't be allowed and the after version isn't currying but rather a function that returns a function of type (int) -&gt; int - The author even returned a closure.... At least to my understanding - Neither of them are like haskell. In haskell ALL functions are (implicitly) curried. Basically the haskell solution would consist of using standard function notation: threeMult (x: Int, y: Int, z: Int) -&gt; Int { return x*y*z } If the function gets called with only 1 or 2 instead of 3 parameters, it returns a function of type (int, int) -&gt; int or (int) -&gt; int that takes the missing y and/or z to compute threeMult. Maybe there is more to it besides the implementation of the author because I don't see why anyone would want to implement currying using explicit closures. Not only does it look inpractical/'ugly', you would also have to know beforehand whether it is usefull that the function supports currying. 
like @autoclosure?
swift is not a functional language though and the machine code isn't either, so while in haskell everything works somewhat (slow) in swift it tends to blow up the stack or cause other issues. Ofc just defining some Result type or other small things is pretty harmless.