Jira used to be the best pm software available. But they tried to become all things to all people and now it is a bloated mess. Very sad.
I'm currently aiming to get an internship at a specific company, that I know for sure uses WinForms. So I'm trying to learn as much as possible about WinForms and it's best coding practices. Unfortunately there doesn't seem to be a definite answer to my question. But again storing all of the logic behind the form seems ridiculous to me..
Thanks, I'll look into it! Do companies that develop WinForms applications use this design pattern?
We only had one experienced contractor working with WinForms and that is what he used. I am not sure how widely used the pattern is. Btw, You can also host WPF controls in WinForms. You could have a look into that as well.
You can implement MVVM with Winforms. Check ReactiveUI, it is a MVVM framework for Winforms, WPF and Xamarin.
The real benefits of separating those tiers comes in the web world where the presentation tier is a completely different person/group with graphic design and layout skills. Separating those is pretty rare in the enterprise where WinForms has it's foothold. As an intern you'll likely be given one of two types of tasks- to either work on changes to an existing legacy code base or given some standalone prototype/proof of concept effort that will then be adapted by a more senior engineer. For the former you just need to adapt to the coding/style conventions already in use by the team. For the latter it most likely won't matter what you do as long as the code is reasonably laid out and you get the task done in your internship window. You'll find a huge variation in process maturity in WinForm land. On the low end its mostly business/VB6 developers who morphed into C# programmers back when CB6 was deprecated and have essentially zero in the way of best practices. I'd focus on your hard CS skills, any prior work/open source/project experience for applying. No one is going to expect an intern to be an architect or to fully understand engineering best practices from the start. 
Thank you so much for your detailed answer! :)
I use Nswag to generate the documentation then use https://frhagn.github.io/Typewriter/ to generate TS definition.
Thanks, I'll look into it :)
My fantasy is to build this type of tool on top of Dgraph.io. 
For WinForms we used the model-view-presenter pattern specifically the passive view instead of supervising controller. Basically makes the view super dumb and allows for testing UI without interacting with the UI frameworks. Source: [Martin Fowler MVP Passive View](https://martinfowler.com/eaaDev/PassiveScreen.html)
I am using MVVM-C and thought I was the only crazy one. I hate when my view models contain all my command logic in relaycommands, and I hate having a bunch of independent commands which are one time use. Controllers seemed the obvious route. 
&gt; Btw, You can also host WPF controls in WinForms. Yeah, don't propose/do that as an intern :) If the place is a WinForm shop they're likely a WinForm shop by choice and won't want WPF stuff embedded in their apps.
This is the route we are trying to take. Any experience binding SSLs from the keyvault to a website?
IKVM is dead in the water after the author had a total fucking hissy fit on twitter with a whole bunch of the .NET team at Microsoft and then rage quitted.
Not sure if this is exactly what you want, but there's a blog post about deploying web app certificates in azure through keyvault. https://blogs.msdn.microsoft.com/appserviceteam/2016/05/24/deploying-azure-web-app-certificate-through-key-vault/
I did some smaller projects with a model view presenter pattern with passive views. Back than it was quite decent. Here is an example implementation: https://github.com/HofmeisterAn/mvp.passive.view.base2
I'd personally question why they're still using WebForms heading into 2019. Is WebForms the only thing they use, or is it for some legacy apps they can't/won't update?
 I like [Prism](http://prismlibrary.github.io/docs/). It's no longer a microsoft patterns and practices framework. It's open source and maintained by a core group of non- Microsoft developers now. I recommend using wpf, but there are strategies that let you use winforms.
Any example code?
They're using WinForms
This is really different than MVC? I have view models in my MVC app.
Don't wanna "me too" but exactly this. Though experience of somewhere like this as an intern will be interesting as a "legacy perspective", I'd be loathe to recommend it. Is there a specific reason you want to get in here as opposed to somewhere more up-to-date?
I get that, but WinForms is pretty antiquated in this day and age. Unless the reason they're using them is to support legacy apps that for some reason can't be updated, WinForms is just a really questionable choice to use at this point, especially if it's new development.
There's still a metric asston of WinForms code out in enterprise land and no particular justification to move off of it. Once the component vendors stop actively building out their WinForm suites I'll start believing its time to seriously looking at deprecating WinForms codebases.
Ugh, new dad brain. I read it as WebForms. My bad.
Yeah, my tired ass new dad brain read it wrong. Sorry!
Oh, there was never a good reason to do WebForms in the first place :) Kill it with fire.
Glad we agree on that. 🤣
They're the only ones around to offer a paid internship, I can't afford to go for unpaid one at the moment.
That's cool, didn't mean to make light :) how far though your studies are you and where are you based?
I have used it in several enterprise applications both Winforms and VB classic. I prefer MVVM and WPF these days but if and when I get a Winforms projects, MVP is the way to go.
I'm actually studying Robotics right now. That's not even slightly related to software development or computer science ha ha.. Got halfway through, took a programming class and realized that I want to be a software developer, so I'm pretty much all self-taught. I'm going to finish my degree regardless, but my career path will definitely be different :D
That's ace dude, sounds like the internship is ideal then!!
MVVM in Asp.net MVC are simple POCO, ViewModels in MVVM implement INotifyPropertyChanged interface and support two way databinding.
Of which?
Just to warn you, although the standard practice is to use MVP passive view, in reality a lot of winforms code will just be code in the view because of how easy it is to do. I've been slowly moving our ball of mud to mvp at work, but we've still got a 10k+ MainForm that gives me nightmares. The downside of maintenance =\\.
Of MVVM-C implementation
It's MVVM, but you're offloading logic which manipulates your models to controllers, and use smaller viewmodels and commands as a result.
Software is awesome, definitely a great direction. But don't undersell how much of robotics is programming!
Holy crap! That sounds terrific :O
That would be very nice, thank you :)
The thing that surprised me was how much of robotics was horribly horrible kinematic matrix equations :)
Check the NUNIT GUI. It uses MVP.
Exactly this.
I don't think I've ever seen a WinForms app that *didn't* have 5000 lines of business logic hidden behind every button click handler.
Yeah, I actually got my start in enterprise software because I took a robotics course in undergrad and had my first job in a factory automation group. All the kinematics stuff was handled by the robot vendors though- we mostly did the the supply chain, scheduling, and higher level stuff in house. And then Y2K hit and all the money was in ERP conversions and I shifted over to that.
If you are careful you can usually cleanly abstract the business logic. But separating the presentation tier in WinForms like the web world does is really hard.
Oh... I have... And you'd think, "Wow, that would be refreshingly pleasant to work with." It wasn't. It was complete insane hell. It was patterns, inside patterns, inside patterns, with lots of insane rules striving to hit perfect "clean code". It was a mess. Skilled developers would be hired, and then quit 6 months later.
_What experience do you have with ASP.NET Core development?_
After reading this, I don't think I'll be able to fall asleep tonight. Yikes! 
I nearly had to do this (I don't think I could have spent another day contributing to the technical debt of that awful winforms app without trying to do some abstraction for what UI I did add). ReactiveUI looked like a good solution. The observable pattern is a nice way to deal with data binding/data flow. Never did try implementing it though, jumped ship because I wanted to work on something else hat wasn't 15-20 years old.
Oh you'll be fine. The point of internships is to get 'real world' experience. I'm working with an intern. He's a smart kid, bright, knows a lot about code. What he really needs to learn is social - how companies work, why things happen the way they do (dumb things or good things), even how to do a proper hand shake...
Classic
"10+ years, I started when Android came out and used lots of XAML code."
Same stuff I used to ask before. How do you do authentication. How do you integrate an internal authentication provider. Docker? Integration with Node, especially real time data. How do you deal with real time where you can't miss an update? Backplanes? Pros and cons of react vs Angular. Some specific react and angular questions (we use React and Angular). How do you implement a web api in Core, how do you consume it in Node and client side. Proxies? Off the top of my head, sorry if it's a bit muddled.
I've seen clients using CLSA with Winforms with fairly reasonable code to go along with it. Start here if you want an architecture you can just drop in so you can just get to work on your actual application: https://cslanet.com/ In fact, if you look in the samples, you'll find a Winforms example, and even a Blazor one: https://github.com/MarimerLLC/csla/tree/master/Samples 
Aaand there's the door, don't call us, we'll call you.
Pluralsight
I first started my career working on a product with a 300k+ line MainForm.cs It was exactly as horrifying as you are imagining.
Robotics, electronics etc all need programs to interface with them and C# .NET is great framework to develop these in. Being able to write these kinds of programs has been a big plus for my elec engineering career. 
I wouldn't say you could just drop it in. You have to integrate it into your business classes. And documentation is usually $$$. Even if it is just buying that c# business objects book.
I worked for a shop that had an enterprise level Winforms application. We strove for something of an MVP-VM hybrid. Essentially, the Presenter would be responsible for event handling and interaction logic, and the ViewModel would, well, model the view. Unlike in MVVM (in the context of WPF), the ViewModels would usually just be where the view state was held, and rarely contained any logic. In more complex forms, we would utilize data bindings (yes Winforms has bindings) to bind to the VMs. In these cases, the VMs may have some logic to maintain their own state, especially if they modelrd complex/nested object structures.
Question could use some context. Are you hiring a full stack dev? Back end only? Senior level, mid level, junior? What kind of apps are you looking to build?
I copied a sample solution I found on the .NET core github repo under a recent issue. The basic idea is that you use c++ and a library to interface between your c#'s p/invoke call and java code. The cpp code will create the java vm. "The basic code for core CLR host; https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts/unixcoreruncommon For Java invoke C#: https://github.com/heartlocker/JavaCallCSharp For C# invoke Java: https://github.com/heartlocker/CSharpCallJava" Another user posted the link to the github issue I mentioned, I simply pasted the exact solution you needed found within the discussion. 
Pluralsight and check out open source project NopCommerce which is an ASP.NET eCommerce solution with clean architecture.
Woof. I'm pretty good at C#, but I'm still learning the intricacies of ASP.NET. I _kinda_ know how to integrate an internal auth provider. Definitely no Docker experience in this arena. What integration with Node are you referring to? Backplanes like the Redis state for SignalR? React vs Angular is a frontend question, no? Would I lose the job if I knew ASP but not those things? Web API is made by supporting JWT and serving up JSON/XML, yeah? What about proxies?
Probably more related to this person's area of work than ASP.net. With any job interview you are going to get to get questions leaning towards what that particular company does. Whether that be front-end work or whatever.
Is there a good reason you're using two backend and two front end frameworks?
\_Anxiously looks around\_: yes...
I've been a dev for 11 years now and almost none of those things matter because they can all be learned if the dev knows the more fundamental things, so I would ask questions about those fundamentals instead.
Wth are backplanes? Lol I've got experience with everything else you mentioned but doubt I could verbalize my knowledge in an impressive fashion. Would love for you to mention your favorable answers to things like creating a web api properly and using proxies in particular. I'm going on 3 years as a software engineer and just failed my first interview for a mid level engineering position. 
It's weird, were a fortune 500 and we have it as well. They determined it would be too slow to use angular for certain pieces of the website...I'm not saying its wrong or right, because i dont know, but we have a lot of other reasons why our stuff is too slow.
Are you an ASP.Net Core dev?
There literally is a book on it, sure, but that's a feature; not a bug. But barring that, there is MORE than enough material out there to get started with it for zero $0. For example, here is the fast start page: https://github.com/MarimerLLC/csla/tree/master/Samples/CslaFastStart It shows all the basics of getting started with it using Visual Studio, implementing a persistence class, etc. Or whatever... don't. Reinvent the wheel. Just trying to help.
Anything more than basic usage though is what i was meaning. It also has a books worth of learning curve. If you are willing to learn and implement the framework can help with certain problem domains.
I have never thought to use this one. So succinct.
https://github.com/dotnet-architecture/eShopOnContainers
I'm working one an enterprise WPF app with business logic baked into the code behind with 0 tests. My process is that when I fix a bug or add features I remove the business logic from the UI tier and create unit tests for said logic. Any tips on how I can better do this?
You mean you don't know everything about everything off the top of your head? Pathetic. 
Have a test environment that is a reasonable copy of production and make your users acceptance test :)
We once hired a guy who literally taught design pattern classes at the local learning annex. He abruptly quit after 3 months and when we looked at his code it was 10 layers of stubs with no actual implementalions. 
Not sure why you're being downvoted. The OP did not mention what level they are asking for. If you're being hired as a principal engineer or even most higher positions, I expect you to know your shit about the technology we are using. If you're a high level, companies are not going to wait to ramp you up in their technologies. I don't care how well you know the fundamentals of web programming, if you're applying for a security position, if you don't know the in and outs of the technologies being used - you aren't going to be hired. I figure most people in this sub are junior/mid level, or have never been a senior of a decent sized company (this isn't meant to be an insult, btw...), but that's just their experience to this date.
Very well said, I’m not a fan of Microsoft and very much remember the harm they did to the overall programming community a generation ago. That being said, they still have an influential position today and are contributing to us in a positive way with .NET Core. C# has always been a fantastic language and Core itself is a world class runtime, its openness has relieved a lot of tension and I appreciate the change MS has made. People still aren’t going to forget the past but it’s healthy for us to take advantage of these MIT licensed tools. 
What is the difference between .Net Framework/Core/Standard? When / why would you use them?
That's just a sign of bad interviewers. When I interview someone, I ask them about what *they've* done, not about what I've done.
&gt; Since the advent of docker, and how heavily we use it now. Serverside technologies become whatever does the best job for the task. You still have to maintain expertise in multiple backend stacks that basically do the same thing though right? There's nothing Node does that .Net doesn't and visa versa.
I've been using https://documentation.devexpress.com/WindowsForms/113955/Build-an-Application/WinForms-MVVM
This is a good one. What would be your answer? 
The same questions we always ask. *Interface vs abstract class *Internal vs Protected *How would you write unit tests for a controller *What are the SOLID principals Etc. Only .NET Core specific question we ask is if they know the difference between framework, core, and standard.
.NET core has major performance gains and is cross platform linux , mac and windows. If it's a new application that is web based or a cli then definitely asp.net core. However, there are frameworks which are only available on standard. For example ASP.NET webforms, WinForms, XAML. If the application is legacy or if it's targeting a desktop environment, .net core won't work. Even with .net core 3.0, the gui bits for desktop applications are still windows only. So the tl;dr. For new web applications, .net core. For legacy web apps or desktop applications, standard. It's worth noting that standard and core are not 100% on par in terms of the BCL. As time goes on they get closer, but there is still some namespaces in standard that will never make it into core.
That's hilarious. Someone who really doesn't code much asked me, "I don't get it. If they use clean code and patterns, why is it such a mess?" I said, "Pretend you are a plumber. Someone hires you to work on their bathroom sink. You haven't seen the sink, but you can reasonably assume that there is a sink on top of a cabinet. When you open the cabinet and look around under there, you'd figure you'd see a hot pipe, a cold pipe and some kind of drain pipe. MAYBE if you are lucky, the hot and cold pipes have their own shut off valve." "So imagine that when you get there and you open the cabinet what you see blows your mind. The space under there extends out like some doorway to Narnia, but filled with 500 miles of pipe, each with all kinds of twisty turns, pumps, valves... Pressure gauges... " "As crazy as it seems, it looks as if the water comes in, is transformed into 8 different sized pipes, and then set back into some kind of weird ballast thing to up the pressure it just lost, before going to the faucet. The cold does some loop-de-loop thing that seems totally fucking pointless, and then twists around for extra support to get back to normal. There's no visible drain that you can see, but you **know** the waste water is going somewhere, so there MUST be a drain, you just don't know where it is or how it works." "But everything is brass, or gold and just beautifully built." "Its going to take MONTHS of examining and playing around just to figure out how all this bullshit works. And its going to take a few more months just to make a minor change." She replied, "Jesus. Just tear it out, throw it away and install a normal sink." My reply, "I'm not allowed to. The owner likes this sink and isn't experienced enough to know how fucked up it is."
500.0 miles ≈ 804.7 kilometres ^(1 mile ≈ 1.6km) ^(I'm a bot. Downvote to remove.) _____ ^| ^[Info](https://www.reddit.com/user/Bot_Metric/comments/8lt7af/i_am_a_bot/) ^| ^[PM](https://www.reddit.com/message/compose?to=Ttime5) ^| ^[Stats](http://botmetric.pythonanywhere.com) ^| ^[Opt-out](https://www.reddit.com/message/compose?to=Bot_Metric&amp;subject=Don't%20reply%20to%20me&amp;message=If%20you%20send%20this%20message,%20I%20will%20no%20longer%20reply%20to%20your%20comments%20and%20posts.) ^| ^[v.4.4.6](https://www.reddit.com/user/Bot_Metric/comments/8o9vgz/updates/) ^|
Yup, that was more or less exactly what it was :)
You have Framework mixed up with Standard. Standard is something that Core and Framework both can use as libraries.
What would a good answer to the last question be? 
This is the only backplane I am aware of. https://docs.microsoft.com/en-us/aspnet/signalr/overview/performance/scaleout-with-redis
Once they make it to an on-site, I like to describe a problem I want solved that boils down to a simple CRUD API (to make sure they can identify and apply the patterns). Then I ask them to sit down in front of a computer and build it. What I'm looking for: * You can create a new ASP.NET Core project (or even ASP.NET - Core is teachable for a strong dev). * You'll identify that you can use most of the template and just add one method and modify one other (and most important here: you know what a controller is). * Some understanding of object lifetime within the DI pipeline, or at least understanding how a static object will work. * That you can demonstrate that your code works by using the API (through a browser, command line, I don't really care). There's usually enough there to identify a developer's skill, and it's a simple enough task that it's possible to complete within the interview time (assuming they'll meet our needs). We're usually looking for really strong backend developers though, with little need for frontend, so this might not be typical.
OP is being downvoted because OP asked laser-specific questions without knowing the scenario. What if the app has no need for authentication? Why must a .NET Core developer know AngularJS if the compaby doesn't use it? If the original OP's question was vauge, then ask for clarification.
Yep, that's how it should be done. I've had some interviewers express disdain "You've been a .net developer for this long and you don't know this!?" Me: Well, do you see that particular thing ANYWHERE on my resume?
The title says what questions do YOU ask, he answered exactly that :P, he didn't say what questions he should ask
This one got me really into c# and got me really excited to continue learning c#. Again Scott Hanselman :) [https://www.youtube.com/watch?v=g\_jiMxkLK7s](https://www.youtube.com/watch?v=g_jiMxkLK7s)
Cool! Will take a look for sure. It's hard to pick from so many awesome Hanselman talks ;)
Haha so true. The talk is not going specifically into a topic (recorded at xamarin evolve) but its a great overview of how much you can do with c# and how powerful the langue is/was in 2014.
Awesome. Watching it now.
I like the cut of your jib, but we only have a budget for a mid level developer...
I got this, .net framework sucks, core is fully sick, standard confuses me and never seems to work.
I ask them to write a function on the whiteboard that reverses a string. You'd be surprised how many people I interview that cannot do this. 
* Interfaces are annoying, this isnt java. Abstract classes make me look smart and confuse the jr developers. Protected is good, internal confuses jr developers. Can you unit test a controller, is that not an integration test? * I cant remember solid, im too busy writing abstract classes with internal methods to confuse the jr developers.
For a junior role you're absolutely right, I don't know why I assumed they were applying for something more senior :)
Funny, I get to write greenfields once every 2 years if im lucky, I dont remeber all that stuff. I could go to my github and pull an example to base it off though, but at that poont im not getting the job.
Sorry to hear that. Keep it up and you'll get there. Don't get disheartened, just try and figure out if you couldn't answer some questions and research them. Remember that there will be other candidates and that interviewers are basically people, so you might just have got a bad one :) [Here's a link to MS docs on backplanes](https://docs.microsoft.com/en-us/aspnet/signalr/overview/performance/scaleout-in-signalr) :)
Its slow, really slow even on a small project. The user interface isnt consistent. Trying to setup a scrum board sucks because its very restrictive. Basic stuff like searching closed tasks or bugs is a pain. Its email system is crap, so little customisation, I can either get spammed or no one gets messages... I could go on.
I assumed it was a more senior position so I'd spend 10 minutes on the basics before moving on to the more complicated questions if they showed enough knowledge. I'm not a huge fan of the "If I know how to lay bricks I can build a house" mentality. The fundamentals are important, but understanding how the fundamentals come together is a skill in itself. You don't learn the GoF patterns and immediately know how to write good OO software. So they're all questions I've asked in interviews. Authentication is big for us. Docker is new for us but is our container of choice. We use .net behind Node which serves the client and we load balance behind a proxy. On the client we have React and Angular (historical reasons) These are all things that are common in my industry and when I interview it's usual to expect that kind of experience.
After having seen it in action and the responses here, im going to stick with hangfire for a while.
Good reasons? Yes and No :) No to the front ends. It's historical and awful. There's some MVC in there too for added annoyance. On the back end we use .net for pretty much everything but use Node to serve the client. Honestly it's just easier to get Node to work for that purpose, far easier to find information if there's a problem or we need to do something new. A side effect is it's a handy separation between client services and server side. There are other projects which use one or the other. Again, it's historical :)
yeah, it's a lot of different tech, but it all fits together in our organisation. The thing is, if you interviewed here and didn't know all that stuff, it wouldn't mean you'd fail. I would at least want you to know that all the tech exists and what it does :) Things like authentication are really critical to us. In the past there was very little auth going on, these days everything, including internal service to service comms is secured. For the Node integration, simply having it communicate with our .net backend and handle auth and real time data. You win a cookie for the backplane answer, exactly right :) React and Angular are front end. Our asp.net layer is pretty thin, we mostly use Web API and that's it. All the client side stuff is React/Angular (yes I know, it's historical) and served by Node. Our team is full stack, so no one gets away with just doing client or server side :) Proxies, simply handling session behind a load balanced proxy. Understanding the concepts of scale out and potential problems :)
If you've got a GitHub with any substance you're ahead of most applicants. And especially so if you can demonstrate understanding of some of the fundamentals (what mvc is, rest API design, http basics, etc.). That said, this was used when searching for a strong backend engineer who could both build new microservices and maintain old services (from 1 to 15 years) across a wide catalog of products. It may not be applicable to all ASP.NET Core positions.
Do what works for you, I just think asking your questions increases the risk of overlooking a very good developer that just hasn't been exposed to all of your specific frameworks and technology.
I'm home ill at the moment, so apologies for the long reply, I'm bored. You're right. I ask a really huge mix of questions. No one knows the answers to all of them, the only reason I do is because I'm asking them. I wouldn't not hire someone if they hadn't used Docker, but I probably wouldn't hire them if they didn't know about Docker. My process is to pick a topic, start easy and incrementally push the candidate with harder and harder questions. Depending on how they come across I will help them figure out the solution if necessary. Once we reach their limit I switch to the next topic. An example might be: What's a thread, how many ways can you think of to start a thread, what's the threadpool, how many of the async patterns do you know going back to 1.1, difference between a task and a thread, what is async await, how does it work, what's an awaitable, when does it complete synchronously, list thread synchronisation constructs, difference between manualresetevent and manualreseteventslim, What's an execution context and a synchronisation context, is task a reference type or a value type, what is the new valuet type task, and so on for 40 more :) It actually works at all levels, so I don't have to have separate interviews for juniors and seniors for example, I just don't expect the juniors to get as far and I tend to nurture them more. As a cautionary note, if you interview, pretty much everything on my list is critical to enterprises now. Containerisation is huge, auth stuff is mandatory even for internal only services. API's for everything is big right now, etc etc. I'm sure you're good, you don't go a decade without learning a trick or two, so take my advice as it's intended; just a friendly hand which I hope benefits you. Also Psych is top notch and I've just watched Buffy season 6 Episode 7 (the musical one) for the eleventh time :) (I had a poke at your post history :) ). Did you see the Psych film? Came out last year I think as one last hurrah. 
Thanks!
I don't know the answers to most of those questions without looking them up. I've used the newer technology, but never had do dive deep into learning how it works, so I guess I don't find it very important for an interviewee to know. I've recently started using aspnet boilerplate with angular 6 to start my projects because it's a great starting point and already contains authentication, async web API controllers, and good programming patterns and practices. Been doing this since 2007, and I started with Webforms and an in-house CMS. I'm not sure what kinds of projects your working on today, but I've not had to deliver anything that required me to know the answers to all of your questions. However, since you asked them, I am curious what advantages I may gain by learning more about the details of async tasks. 
What do you glean from that? No really, you could simply ask them how to traverse a loop backwards and see if they know the concept. Whiteboarding is a thing of the past like Hungarian notation and abbreviated variables. I feel its just a way to fluff old time developer ego.
I would how routing is different in .net core MVC, but only if they said they had experience in .net core.
integration with node? why just node and not just other stack?
exactly, it seems extremely redundant
Everyone is different, so I get it. I picked async at random really and again I wouldn't necessarily expect anyone to know the answers to all the questions. I don't think I have ever needed to know what an execution context is :) My projects vary as we adapt to the new realities. Previously it was mostly real time client server stuff for a few hundred users. Over time we're exposing more of our data through APIs which is a scaling issue first with some security problems, and opening some of our data to external organisations which is both a scaling and security issue. On the async tasks question, it's really an evolution that abstracts away a lot of the complexities of parallelising code. We started with the APM in 1.1 which was a pita, 2 gave us the EAP which was still a pita but much better. Observer pattern in 3, then Tasks in 4 and async await in 4.5. So each iteration refined the way we approach parallelisation and asynchronicity. [Actually, here's a little link which describes it better than I can](https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/). async await allows you to skip all the boilerplate we used to add when we wanted to offload a bit of work to a thread and get the results back once it completes. It's actually smart than that. It doesn't need to use a thread, why start a thread if the result is already known? It handles all that for you. Cancellation is a huge benefit. You use a CancellationTokenSource, pass the token into a TaskFactory, let the TaskFactory build the task and you can cancel it easily. This is something else that used to be a pita and involved a lot of boilerplate. Now, once you've built a task you can go async all the way down. async await looks at your code and builds a state machine that plumbs in all the code needed to wait for operations to finish or fire and forget, but still give it a continuation to run once it's finished. It's insanely clever. It took me a while to get my head around it and then actually trust it. I imagine it's the same feeling you get going from a manual to an automatic car. perhaps not, I still want a manual :) If you haven't used RX, it's worth a poke. [Take a look at this page](http://introtorx.com/Content/v1.0.10621.0/15_SchedulingAndThreading.html) which goes through some of the scheduling cleverness. The real genius here is that you can replace a real scheduler with a TestScheduler in tests. Imagine you have a bit of code that fires off a timer every 10 seconds. In the old days you'd wait for 10 seconds for the event and then check the result was correct. Now you just ask the TestScheduler to advance forward in time 10 seconds and boom. It's not a direct answer to your question, but it shows how progress simplifies stuff we once found difficult or time consuming. And all this is built on top of the thread pool. The majesty of the thread pool is it knows, using voodoo, how many threads to run at once to give you the best performance. It's not all perfect, thread pool starvation is a thing, but generally it just knows more than us and gets on with it. Once again I've written loads. Is any of that helpful? It was a bit of a waffle. 
Is this on self-hosted? I've always used Jira cloud and never noticed it being slow.
Do you mean why use Node, or do you mean why did I ask about integrating with Node as opposed to integrating with MEAN or any other stack? Node for me is a great partner for .net. It's easier to find information on how Node serves React/Angular. It provides a fan out architecture where our .net apis feed Node and Node handles the clients. It provides a layer of separation between server and client. We API all the things. .net is just brilliant at server stuff. I find its integration with SPAs fiddly and poorly documented. In this specific case I was asking how you would connect a .net webapi with both the client app and with Node. It's quite specific because of the way we've designed stuff, but generic because who wouldn't want to know how to consume a web service? 
I meant just node and not python or some legacy stuff such as java/php. I have yet to see a business that doesn't have some legacy shit and node is less than what ... 10 years old? 
I always ask people to tell me 3 things that they like about technology X and 3 things they hate about it. IME if you worked with something you will know it's limitations and/or shitty things. 
"Do you expect a lawyer to know every single law in this country?" usually put these assholes in place.
Im going to guess : shitty management and bad leadership.
Jira cloud... tiny database, we are up to 3500 tasks / bugs.
I'm an experienced programmer and just gave it a go and found it more difficult than I thought! ``` function reverse(str) { for(var i = str.length; i &gt; 0; i--) { str = str.substr(1, i - 1) + str.substr(0, 1) + str.substr(i, str.length); } return str; } ```
https://en.m.wikipedia.org/wiki/SOLID This is on my standard list of questions. A senior applicant better at least have heard of it. A lead must be able to drill into one of them. Really, I think these should be even more prominent, but I adapt to reality.
**SOLID** In object-oriented computer programming, SOLID is a mnemonic acronym for five design principles intended to make software designs more understandable, flexible and maintainable. It is not related to the GRASP software design principles. The principles are a subset of many principles promoted by Robert C. Martin. Though they apply to any object-oriented design, the SOLID principles can also form a core philosophy for methodologies such as agile development or adaptive software development. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/dotnet/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
For C#, you get to see whether they know LINQ or whether they’ll go back in time 10 years and use a loop.
I didn't start using async operations in C# until 4.5, so I missed all the difficult stuff. :)
What personal project are you working on, currently? What book are you currently reading? What new tech has you curious or excited? What blogs do you follow? How do you like to build your apps? Traditional N layer/tier or onion/clean architecture? Why? I also have an evolving set of technical questions (currently outdated) that I don’t actually expect the candidate to be able to answer most of. I use them to gauge whether the candidate is familiar with some concepts or if they’re coasting on what was good enough five years ago.
Yeah we have a lot of really old tech, but I don't work with it. My team and the teams I interact with don't deal with it. There's some Sybase in there, I think that's the worst of it. Yep, Node will be 10 next year. It's kind of incredible to me. I did not know Node existed 5 or 6 years ago really if I'm honest. We actually have a lot of new Python stuff. Not in my vertical, I should probably spend some time getting at least a working knowledge of it at some point, but I don't really get the maths behind AI, so it might be futile.
With the free tier it's not intended for production (no custom domain etc). It's also worth remembering that your AppService resource is effectively your server so you can host multiple WebApps/resources on that. I usually have an AppService per environment, it saves me money.
"Did I pass?" "- We'll keep in touch.."
Yup I guess I fail :). I wrote that late. But yeah I was talking about .net framework. Standard is just a spec that both versions of core and framework implement. Writing to .net standard means it will work on both, 
I teach an interviewing workshop and that’s one question I tell people to NEVER ask. That along with ‘so how much do you make?’ And yes I would pass :) it was a minor labeling blip, but it would be obvious that I was talking about .net framework. 
hahaha, Narnia, I'm going to use that one - I definitely have argued with some Narnians who believe adding 500 levels of abstraction improves things. 
Yeah... Tell them It doesn't. 
Yip, I was confused as I read through that previous post, started questioning my own understanding. :-)
I glean that they can program. It has all the basics - variables, loops, functions, yet is simple enough that if you do code on a day to day basis you shouldn't have too much trouble with this. That is the only C# question I ask. 
In other words you are a freeloader and your loyalty is to whoever gives you stuff regards of the "harm" they have done. 
For me the biggest takeaway from asking someone to code is to look closely at how well they know their tools. Are they using mouse or short-cuts (where there is a choice)? If we ever get to a refactoring or change that affects several places in the code, will they change at each place or use whatever refactoring tools that may be available? Do I get a feeling that the tools that they say they know are used effortlessly? And so on.
I’m an engineer that uses the best tools available to finish a job, sometimes that’s .NET and sometimes it isn’t. If you have an issue with that mindset you should consider a different career. There is no loyalty here, are you just salty your comment got downvoted or are you actually an immature fanboy?
.NET Framework is the traditional versions of .NET developed by Microsoft as a managed framework similar in concept to Java, but only for Windows. Parts of it thinly wrap some Win32 APIs making it difficult to port. .NET Core was a from-the-ground-up attempt to make a better performant framework which can also run on multiple platforms. Starting with version 3 it is designed to be the next version of .NET Framework, including any Windows-only APIs present in .NET Framework that were missing in .NET Core 2.x. .NET Standard is a standard which allows code compiled for it to be run on any supported .NET framework, including THE Framework, Core, or support third-party .NET frameworks such as Mono and Xamarin. Specific versions of .NET Standard are supported by specific versions of frameworks. It also makes it easier to migrate code to .NET Core by allowing for libraries to target .NET Standard instead, so both Framework and Core projects can use them.
tbh if anyone can even pronounce Liskov substitution principle they are getting thru to the next round :)
Interfaces are everywhere in ASP.NET Core. It's useful to know why. Answer: It allows for decoupling of dependencies. Code using a class only needs to know about the interface, and cab run against other implementations of the interface instead of a specific class. Libraries implementing an interface don't need to pull in the entire ASP.NET Core dependencies, just the one with the interfaces.
They will. The performance gains lie in the runtime and standard lib, not the compiler. That said, there are some things like Span&lt;&gt; that are only in Core that would require targeting Core if you're using them. Same goes for upcoming c# 8 features.
There are some edge cases to consider :D (Not my work!) http://faithlife.codes/blog/2008/10/how_to_reverse_a_unicode_string_in_c/
I have an unhealthy obsession with LINQ and extensions so I'd probably end up with: using System.Linq; public static class StringExtensions { public static string Reverse(this string value) =&gt; new string(value.ToCharArray().Reverse().ToArray()); } If you wanted something with performance, l'd probably replace the .Reverse() LINQ call with a loop over the char array to swap characters around.
Hey dude, I also recently changed from a job where I was tasked to migrate our entire existing published and maintained apps to net standard and Package reference. I spent the probably worst 4 months of my professional career on migrating these Xamarin Projects to be able to profit from newer tooling. If there is anything I can help you with in form of advice I'd be glad to help a fellow who is in a similar predicament :) just pm me if you need anything :)
The one caveat to my coding question is no using of a built in Reverse() method. Use anything else though. 
&gt; if there is any reason to make shared libraries and nugget packages .Net Core instead of standard. No, there is not.
I scoffed at this, tried to do it in notepad and then had to look up what ToCharArray() was called. Autocomplete has ruined me.
(Gaining understanding of Core here) - is that because .NET Core compiles down to .NET native, and doesn't use the CLR?
Same here. &amp;#x200B; I needed to make a form based on a table in DB, which had 200 columns. Scaffolded it with some data annotations, and it is good enough.
Sure LINQ is great, but if you want the most performant answer to this question you wouldn't use it. For example, this: `string testStr = "1234567";` `var arr = testStr.ToCharArray();` `var newArr = new List&lt;char&gt;();` `for(int o = arr.Length - 1; o &gt;= 0; o--) {` `newArr.Add(arr[o]);` `}` `Console.WriteLine(new string(newArr.ToArray()));` &amp;#x200B; Runs exponentially faster than this: `string testStr = "1234567";` `Console.WriteLine(new string(testStr.ToCharArray().Reverse().ToArray()));` &amp;#x200B;
[removed]
Can you be more specific about which course ? Since there is alot of different ones on Pluarlsight.
Which course on Pluralsight would you recommand ?
Truth.
That's a good topic for conversation. I think it's good to know how to optimize code, but I also think too many folks still act like apps are running on a mainframe. Premature optimization is a thing. But... So is performance. I tend to aim for a balance between maintainability and performance unless there are nonfunctional requirements driving a different approach.
Agreed, there is definitely a balance between fast development, user friendliness, and chasing tiny performance increases. That said, there are optimizations you can make that barely make a difference in development, but make a huge difference at scale. Also if you're living in legacy government software world like I am, sometimes you actually do have to run applications on a mainframe(we still have a couple running OS/390).
wow, that's nothing
Net core also has a clr. They both eventually jit compile to native. The performance gains in net core are mostly because they were to completely rewrite with the knowledge of about 10 years of full framework development.
My thought would be to use `Enumerable.Repeat` IList&lt;MyObject&gt; myList = Enumerable.Repeat(() =&gt; new MyObject(), numberNeeded).Select(f =&gt; f()).ToList();
Really all you need to do is look at the website, and search for what you are looking for. 
codewars.com has examples I like that I use just to keep multiple languages in my mind and for a bit of brain training.
Great idea! As a matter of fact I already did that. Found around 90 courses which were all beginner to intermediate level. 
I have used pluralsight many times...sorry that I didn’t specify that. 
What a low-effort shitpost, seriously. It frequently changes how .NET Core is written and the English is lacking as well. &gt; Mac &amp; Linux users waited so long but after .Net Core launch we can Develop &amp; Run .Net Core Applications using Mac or Linux. .NET Core applications could **always** be run on Mac OS X and Linux. &gt; With ASP.NET Core, MVC and Web API have been merged together. So now MVC can also return JSON Data. ASP.NET MVC 5 controller could return JSON data just fine as well. &gt; A dependency is an object required by another object. Uhh... no shit. &gt; It is the preferred way that things like logging contexts, database contexts, and other things are passed into your MVC controllers. ASP.NET MVC supported dependency injection already. Good thing is that support got expanded to other parts of the framework. &gt; .Net Core comes with latest Angular &amp; React SPA Templates. Those templates are additional components, they don't come with .NET Core. And that is really a top feature for you? &gt; you can change this Project.json file The project.json file doesn't exist for at least a year anymore. Where have you been? &gt; Tags are easy to remember and generate the equivalent HTML at the end. If tag helpers would generate "equivalent" HTML at the end, then they'd be mostly pointless. They're much more useful and don't have to generate HTML at all if it's not needed. &gt; Swagger is used to automatically generate Documentation for API. It makes easier for API developers to expose documentation for Front-End Developer. Swagger is not part of .NET Core. It's provided by external libraries which have been available for ASP.NET Web API as well.
Coverlet is great. It was incredibly easy to add coverlet.msbuild and get coverage reports out to Jenkins. Long live OSS!
RequestPipeline is just a behavior for MediatR. MediatR is really great for splitting up your code and focusing on the request / response for each action. I love it. Simple MediatR pattern: class CreateProduct { class Request { public string Name { get; set; } } class Validator : AbstractValidator&lt;Request&gt; { ... RuleFor(x =&gt; x.Name).NotEmpty().MaxLength(30); } class Response { public int Id { get; set; } public string Name { get; set; } } public async Task&lt;IRequestHandler&lt;Request, Response&gt;&gt;(IRequest&lt;Request&gt; request) { _context.Add(request) await _context.SaveChangesAsync(); } }
I think it's something more like this: var temp = "hello" temp = temp.toCharArray(); temp.reverse(); temp.toString();
uh... not dotnet related in any way...
Completely loving the new .net. Phones may have failed 😞 but this makes up for it big time. 
From a dev hiring manager at a .NET shop: "[The Hard Thing About Hiring Software Engineers](https://www.softwareexecutivemag.com/doc/the-hard-thing-about-hiring-software-engineers-0001)"
What about [Exago BI](https://exagoinc.com/)? It's web-based, built for embedding into SaaS apps, and native to .NET.
[Exago BI](https://exagoinc.com/) plays nicely with ASP MVC applications.
[removed]
Agree. This is good stuff! 
Agree. This is good stuff! 
I don't know if there's a performance difference, but you can access a string's characters by index without converting ToCharArray(), e.g.: var sb = new StringBuilder(str.Length); for (int i = str.Length - 1; i &gt;= 0; i--) { sb.Append(str[i]); } return sb.ToString();
Yes, that is why I am looking for an existing framework or open source project which I can customize or build onto. 
I remember when we pushed out Silverlight with dynamic run time (python etc) and it was at that point Scott Gu was hinting about the importance of Open Source... we felt the full wrath of the windows team for some of that rehetoric back then (back when devdiv vs windows org was a territorial pissing contest). With the introduction of new blood and leaders in the .NET team pushing the "its still not good enough" the entire tech stack as rebounded in a positive way. Quite frankly the path they were on in 2010 to now is night and day ...
Are you still learning it and what do you think. Anyone who goes a different path is lying to themselves and interviews are about the candidate not the interviewers academic brilliance. 
There is none.. two different approaches to the way you code. MVVM was a pattern we created at the time to explain how binding &lt;-&gt; xaml &lt;-&gt; design could play itself out while not causing dev/design teams to tear each other apart. It really is a pattern that has no home being applied outside a layer set such as this. The best you'll probably get close to is PRISM from P&amp;P team back then.. as they were trying to find ways to make enterprise teams break large code bases up into modular form factors... it later mutated into another science experiement but that was the original itent anyway. WinForms works much like Unity3D kind of today but without the brilliance of IoC... you bind directly to the control and create the view as someone a disposable componentised layer..and try and build a buffer between you and the business end of the app. 
nswag is for those of you who loved the ye olde "Service Reference -&gt; Code Gen" and be done with having to write broker/agent/clients between your code base and the end point. Swashbuckle is for those of you who still like to touch your end point metal. I'm always cautious around .NET code with code-gen after market approaches... Entity Framework.... Service References (generics + contracts)...these all have ended badly in large scale projects... 
You have to look at the two problems ... first one was build a framework for devs to use to accelerate solution delivery = .NET Framework as you see it today. Then the IoC wave hit and people started to realise that if you can break the framework down to a level of "use what you need" combine that with multi-platform / cross-compile etc you end up with the .NET Core.. As you move closer to the IoT world you start to realise that less is more ..so if you can put a large framework like .NET into a diet, .NET Core is your result and can give you more performance gains if everything is isolated to a must-have instead of a nice-to-have. Makes multi platform targeting way easier..and upside is you get performance gains over time.
Pomelo rocks! I use it all the time. 
There is if you want to use .NET Core only features such as Span.
&gt; What personal project are you working on, currently? Is this really a fair one to ask? Not everyone has the time to do any personal projects, I don't really see how it gauges the competency of a developer.
Would love your input to your favorite talks in the comments. Looking for something to watch on my second screen :D
Hah.. i remember sitting in the hallway of building 17 and Damien Edwards (now in PM Manager for .NEt was visiting at the time (not yet at MSFT) as an MVP and he asked this same question. The answer hasn't changed. WebForms brought the VB crowed across over into the world of .NET... we made our peace with that success. MVC was originally for the "alt .net crowd" to begin with but it was simply the right next step. WebForms sole priority was to give you folks a way to jump over the learning curve and get into productivity... MVC however was to bring it back to the event metal per say, give folks the ability to shape their URL / deep linking futures. Nothing in Microsoft can be deleted for up to 20 years *due to govt contracts etc* so WebForms will always be around for a decade or two, but that doesn't mean it should be used either. To answer the "why move". We wanted to shift more into academic schools, as Universities etc wouldn't touch webforms because of the server/client-side seperation issues (how do you teach a kid OOP with webforms..messy). It also didn't scale well with large teams, too many folks bumping into one another in the view / model layers. Design logistics also becomes a problem, we found a lot of agencies wouldn't touch it because the "html/css/js" labour force couldn't separate themselves from the herd without having to learn all of .NET or asp... so it became an adoption hinderance. In short.. it just didn't age well enough to take .NET into the future. NOTE: check out a framework called Mach-II from coldfusion... a lot of ideas was **borrowed** from it ;) hehe 
Until .NET Standard 2.1 is released 
This question (or similar) comes up pretty often in this subreddit, so I've put a together a [blog post detailing my thoughts on the best options for hosting ASP.NET Core projects](https://mking.net/blog/cheap-and-easy-aspnet-core-hosting) - *cheaply* and *easily*. But if you don't feel like clicking the link, here's the gist: Azure is your best bet - it's easy to use, and has the full weight of Microsoft behind it. Deploying can be as simple as a `git push`. There is a [free tier](https://azure.microsoft.com/free/) for 12 months. After that, you can get 'free forever' Azure App Service instances that have a few minor drawbacks (shared hosting, no custom domains, etc.), or you could pay for some of the cheaper shared instances. If you want more functionality, moving up to the other paid plans is definitely worth it, there are some great features there. Scott Hanselman has a great post - [Penny Pinching in the Cloud](https://www.hanselman.com/blog/PennyPinchingInTheCloudRunningAndManagingLOTSOfWebAppsOnASingleAzureAppService.aspx) - that covers the best way to get a good bang-for-your-buck from Azure App Service hosting. The next best bet is to host on a [DigitalOcean VM](https://www.digitalocean.com/). You can use [Dokku](https://github.com/dokku/dokku) to get your own mini-Heroku PaaS, or manage the VM yourself ([following Microsoft's documentation](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/linux-nginx?view=aspnetcore-2.1)). You can get anywhere from $10 to $100 in credit from a [referral link](https://m.do.co/c/aac4e1b54a04) - this will last you a year and a half with a small VM. There is also [Now](https://zeit.co/now), which is a very interesting product that makes deployment an absolute breeze. I haven't used it recently, but when I did, it was very easy and cost-effective to get an ASP.NET Core app up and running - just follow any of the blog posts [here](https://mking.net/blog/hosting-and-deploying-aspnet-core-apps-with-zeit-now), [here](https://www.hanselman.com/blog/ZEITNowDeploymentsOfOpenSourceASPNETCoreWebAppsWithDocker.aspx), or [here](https://www.hanselman.com/blog/ImprovementsOnASPNETCoreDeploymentsOnZeitsNowshAndMakingSmallContainerImages.aspx). 
Also u can use heroku.com with this buildpack https://github.com/jincod/dotnetcore-buildpack
Yeah, that's a solid option. I'll add that to my post for next time, too. Thanks.
Cheapest thing I’ve found so far is https://www.smarterasp.net and you get the first two or three months free. Note that if you need to use a DB it’s best to use SQL Server 2014 or earlier. Had issues when trying to use my 2016-17 instances. 
But the credit that you get are 200$ and they expire after 30 days, is there a way to pay upfront for hosting and database and use that credit?
https://www.vultr.com/ is only 2.5 a month and it doesn't look like a scam site.
MVVM Light works in WinForms.
I've used SmarterASP, and they were decent. Switched to A2 and Vultr, though. 
I recently switched from Digital Ocean to Vultr. Pretty similar services, but I like Vultr a little better for non-relevant reasons. If you don't want to manage VMs at all, I'd recommend A2 shared hosting. I'm still using it until I take the time to move all my apps to Core, but I've been really impressed with their service (for shared hosting, anyway). 
Found th emost helpful docuemntation... [https://docs.microsoft.com/en-us/previous-versions/f3st0d45(v=vs.140)](https://docs.microsoft.com/en-us/previous-versions/f3st0d45(v=vs.140))
Thank for this really helpful answer. I‘ll check out your blog post.
Yeah, I thought it was sketchy when I first stumbled across it but it's legit. 
I'll try out Vultr, sounds interesting. 
What is the difference in folder structure between older asp and core
Windows Phone failing may have been a blessing - would the new MS openness have come into play if they weren't compelled to deal with platforms outside their control?
The problem with VULTR is that you'll still have to manage the linux server with updates, etc. If you know how to do all these things, great. If not, shit gets confusing fast. VULTR is great though - my wife uses it to host a wordpress site on it.
I thought Christmas was on the 25th?
So exited for this shit
Major Game changer I reckon. Always was on the cons side Vs Java while talking about Desktop Applications. Glad to see this one coming! 
Indexing and slicing will be so nice to have. Also, does anyone know if there are plans to move WCF to .net core?
They open-sourced WPF?! And the other UIs? I didn't see that one coming.
I'm going to give this one a go without Resharper. It's been so slow recently I'm sort of looking for a reason to ditch it. I've no idea if I can even use VS without Resharper, It's so ingrained in my muscle memory :)
Not all of it. We currently only have client side of WCF.
It's still an open issue on the GitHub repo if I recall, so it's still not a sealed deal for server-side WCF, though it will take quite some time I'd bet before any consensus is done.
Amazing! 😃
&gt; .NET Core applications are now built with executables. This is new for applications that use a globally installed version of .NET Core. Until now, only self-contained applications had executables. This is actually so nice!
TL;DR Major stuff: - WPF, WinForms, WinUI, UWP(?), WinUI Library through XAML Islands - WPF, Winforms, WinUI will be **open sourced** - Local dotnet tools, allow project specific tools to be installed on a per-project basis through a *dotnet-tools.json* file - System.Text.Json.Utf8JsonReader, uses `Span&lt;T&gt;` and UTF8 instead of UTF16, is supposedly twice as fast as [JSON.Net](https://JSON.Net) in reading, but has less features than JSON.Net. - Added Index type, that can be used for indexes and ranging, `var slice = a\[i1..i2\];` - `IAsyncEnumerable&lt;T&gt;`, asynchronous IEnumerable&lt;T&gt; - In C# 8.0 we let you provide a body for an interface member TL;DR2 Also major, but less major stuff: - System.Buffers.SequenceReader. Seems very cool, and I definitely need one, but I have no idea what it does. - Internet of things support: GPIO, PWM, SPI and I2C - Serial Port APIs, TLS 1.3 and OpenSSL 1.1.1 now Supported on Linux - Cryptographic Key Import/Export (seems to be openssl compatible), also AES-GCM and AES-CCM ciphers, implemented via System.Security.Cryptography - AMD64 Suport - Fitter, happier and more productive because all this Span&lt;T&gt; stuff is going on in much more places than before.
WinUI is UWP. Essential all MS's UI frameworks have been open sourced which is a huge announcement that no one could have expected.
I personally like StackExchange.Redis, it's well tested and supported.
Ah, check, I did not use this one before, but the open source ui is huge. I'm very curious if this could mean that cross platform portability might be possible.
Note that they aren't cross-platform still, that may change but JavaFX still has the lead here.
Note that they aren't cross-platform still, that may change but JavaFX still has the lead here. 
Indeed I'm sure Avalonia and other XAML based repos would love to give feedback and contribute for this as they already have the experience with XAML in general. One more exciting part here is that they're also planning to open source the XAML designer for UWP and WPF though still in plans (you can see it on their GitHub roadmap for WinUI and WPF). They're planning to decouple it from VS from what I can see which is also exciting since it's one of the best designers out there for visual creation of UI.
Yes, also the "other" UIs * https://github.com/dotnet/wpf * https://github.com/dotnet/winforms * https://github.com/Microsoft/microsoft-ui-xaml
Only some part of the WPF code is open-sourced atm. The rest will come later.
&gt;AMD64 Suport ARM64\*
&gt; StackExchange.Redis This is the way to go. v2 supports .Net Standard 2.0 I will say, though, that I recently tried to upgrade an existing, full-framework targeting (4.7.1) production app from v1.2.6 to v2.0.513 and it caused deadlocks under load that I haven't been able to sort out yet - no changes other than the package version.
VS just feels so bloated nowadays, it has hundreds of features that I never use that I wish I could just turn off/not install.
If you have to keep a serverless function warm, it's a good sign you probably shouldn't be using a serverless function. Service providers are relying on being able to shut down serverless processes in order to reach profitable service densities. This whole ping-to-keep-warm notion is an ugly hack that's going to be a source of regret for people in the future. 
Is WinUI all of UWP or just a couple of UWP APIs?
So far from the repo description it seems to be just a couple from the looks of it. Maybe this is related to XAML islands? Not too sure myself, though I'm definitely sure it's UWP related at least.
Hey /u/vastico, I'm the product marketing manager for Visual Studio. You can absolutely choose to install just what you need in the installer. We have workloads that group together the tools you want for common tasks (for example .NET desktop development or Node.js development). You can also go in and fine-tune what you install by selecting the individual components you want.
Could you reconsider turning the blue theme purple and just add your new purple theme instead?
You need to put two line breaks between your bullet points
Faster, faster and faster 
Formatted this: TL;DR Major stuff: * WPF, WinForms, WinUI, UWP(?), WinUI Library through XAML Islands * WPF, Winforms, WinUI will be open sourced * Local dotnet tools, allow project specific tools to be installed on a per-project basis through a dotnet-tools.json file - System.Text.Json.Utf8JsonReader, uses Span&lt;T&gt; and UTF8 instead of UTF16, is supposedly twice as fast as JSON.Net in reading, but has less features than JSON.Net. - Added Index type, that can be used for indexes and ranging, var slice = a\[i1..i2\]; - IAsyncEnumerable&lt;T&gt;, asynchronous IEnumerable&lt;T&gt; - In C# 8.0 we let you provide a body for an interface member TL;DR2 Also major, but less major stuff: - System.Buffers.SequenceReader. Seems very cool, and I definitely need one, but I have no idea what it does. - Internet of things support: GPIO, PWM, SPI and I2C - Serial Port APIs, TLS 1.3 and OpenSSL 1.1.1 now Supported on Linux - Cryptographic Key Import/Export (seems to be openssl compatible), also AES-GCM and AES-CCM ciphers, implemented via System.Security.Cryptography - ARM64 Support - Fitter, happier and more productive because all this Span&lt;T&gt; stuff is going on in much more places than before.
Per [this github issue](https://github.com/dotnet/wpf/issues/48) - &gt; **Make WPF cross-platform (MacOS and Linux support)** &gt; Just like @dotMorten says, we are not taking cross-platform implementations, per our Contributor Guide. &gt; We look forward to many contributions to WPF. This request is out of scope for the project. From a technical standpoint, WPF depends on multiple Windows components: D3D (DirectX), DWrite, User32, GDI+, WISP (Touch), and several others (including Windows Runtime dependencies). The interaction with these components is complex, critical and not architected with cross-platform in mind. As a result, our focus is on completing open source of WPF and bringing it to parity with .NET Framework. &gt; I am closing this issue as a result.
Thanks, somehow on desktop and mobile it showed fine for me, is this better?
The least i can do is take a look at it. Can you add these as issues to the repo I linked for tracking? I am still a full time dev so I have to make sure that I don't forget anyone.
&gt; We look forward to many contributions to WPF. &gt; .. &gt; As a result, our focus is on completing open source of WPF and bringing it to parity with .NET Framework. I read: They're not going to do it on the short term, but they're not against others giving it a go. 
I read it more as they aren't going use Microsoft resources to do it short term, long term, or ever. Being open source anyone can of course create a form and provide their own manpower to give it a shot. As mentioned though, recreating these things would make it particularly challenging: &gt; D3D (DirectX), DWrite, User32, GDI+, WISP (Touch), and several others (including Windows Runtime dependencies)
Are you on the redesign? I'm on the old reddit (It looks better now BTW)
&gt; that may change I think it's unlikely. MS has been saying for a while that direct port of WPF or WinForms to other OSes would not be a good solution. And the new repos explicitly say they will not accept contributions that attempt to do that. (But people are of course free to port them in their own fork.)
That limit is only in the free version of ServiceStack, you'll need to buy it.
I like the ability to run a single unit test like resharper has, easily; Right click run. CTRL-T to search is also nice. If visual studio changed their test runner and class search for the better. I would drop resharper.
I'm quit exited as well!
Yeah, I'm thinking WPF going cross-platform is indeed pie in the sky - though having things like System.XAML opened up would benefit other things like Avalona and Xamarin.Forms if nothing else.
You will probably never achieve anything as clean as you can with WPF + MVVM or ASP.NET MVC - but you can absolutely implement a ViewModel/Controller pattern in WinForms. Really the *most critical* aspect is to not have your application state embedded in control states. You should have some kind of model that handles states, and your controls bind to the model. Anything else beyond that (commanding, routing, controllers, etc) is gravy and arguably of diminishing returns.
Hi /u/RajenK I want to send you a list of features that seem to be slowing me down, and if you could point me in the direction to turn them off, that would be much appreciated. Would this be possible? Also, I'm not sure if you're the person to speak with about this but are there any plans to make the theming &amp; fonts for Visual Studio match that of VS Code? It's one of the main drawbacks I have that it doesn't look &amp; feel as smooth as some of the newer programs out there. Thanks
[removed]
Bloated? Care to elaborate what's the bloat supposed to be?
Absolutely, feel free to send me a PM or e-mail me at rajenki\[at\]microsoft.com. For the fonts, there are quite a few options under Tools -&gt; Options -&gt; Environment -&gt; Fonts and Colors for you to customize Visual Studio. There are also extensions like the \[Color Theme Editor for Visual Studio\]([https://marketplace.visualstudio.com/items?itemName=VisualStudioPlatformTeam.VisualStudio2017ColorThemeEditor](https://marketplace.visualstudio.com/items?itemName=VisualStudioPlatformTeam.VisualStudio2017ColorThemeEditor)) that enable you to further customize the colors of the IDE.
Just installed 2.2-preview couple hours ago on our dev machines and build server. #fml Guess I know what I can do tomorrow :D
God I can't live without CTRL-T. Well that's that idea blown :)
Thanks, I will send it over to you when I next have access to VS :) I suppose the main thing with customisation I'm trying to do is get something like this working in Visual Studio, but in Visual Studio you can't have italic font styles so the font doesn't work nearly half as well as it does in VS Code. https://marketplace.visualstudio.com/items?itemName=sdras.night-owl&amp;WT.mc_id=twitter-social-sdras https://dank.sh/ Also doesn't help whenever you're searching for anything Visual Studio it comes up with a VS code result (but that's an entirely different point lol)
Yes, it is common to seperate out your presentation layer, your api, your business logic and your models / entities / data layer and your tests. Dont do what your thinking of doing, dont put them together into one big project. It is very bad.
Is that the new blue theme shown in the video? Can't say I really care for the purple colors, sorry.
This should all be possible. Even a limited implementation of these/related alternative technologies would make multiplatform WPF useful already. I'm thinking Microsoft doesn't want to go that way, there have been requests for it for years with many, many votes. Presumably Microsoft is afraid of people fleeing Windows? However this framework is at least one step in the right direction.
The what now??
Yes, there are very loyal advocates of WPF that want it to go on as long and far as possible (I've used it and thought it was great at the time). However, it does not make sense to exert the time/money/manpower required to make a 12 year old UI framework cross-plat, which would require re-writing/adapting several large &amp; complicated parts of the Windows OS to work on other platforms. This while also working on the latest native UI (WinUI), existing cross-plat solution (Xamarin), supporting &amp; ushering in Electron as a part of Microsoft (maintained by Github), and acknowledging/supporting the much more widespread adoption of web apps &amp; PWAs. 
ALSO VS 2019 preview was released - https://visualstudio.microsoft.com/vs/preview/
But if you think about it, why not? It doesn’t make them money or is a competitive factor in any way. It simply makes no difference. 
How is it a game changer at all?
Great! Ive added it to the list
&gt; They're planning to decouple it from VS So they won't have the XAML designer for WPF anymore in Visual Studio? :(
Yeah, I'm on the redesign
Thanks for list. I am aware of some books you mentioned above. In talk with colleges almost everyone recommended me "Clean Code" but didn't have time to start reading it. It seems so, patience is key if you want to understand something.
What does that do?
The thing is - I am well aware of code and what it does, I understand concepts behind it, but I don't feel like I could plan something like that myself. I could continute writing app that already has good fondation or fondation of some kind even if it's not so good. But it seems I am lacking arhitectural approach. 
I just started with. NET this year. It just takes a lot of looking at others code and watching videos and talks. I suggest watching architecture videos on Youtube
[removed]
[removed]
Check the method, too. Is the working one a POST while the broken one a GET?
Has the EF team yet implemented any type of bulk operations (INSERT/UPDATE/DELETE)? I know you can use raw SQL/stored procedures, but having that built in seems like it would solve some performance issues.
Health checks!
No that's unlikely. What's gonna happen though is that instead of a component directly coupled to VS only it's gonna be something that you can embed on other apps since they're gonna make it out process . We'll still have VS XAML designer but it means other apps can also have it if they want (e.g. VSCode for instance).
I thought /u/Skarsnik101 's comment was just a joke
People need to chill. Huge percentage of line of biz apps will stay on framework for at least another decade.
Lol. No thanks.
Thanks! This works perfectly, even easier to implement than service stack! 
As an analigy, you can view .NET standard as an interface and .NET Core as an implementation. So targeting .NET standard means it can run on any runtime "implementing" it. What matters in the end is on what runtime the application will run. There's no reason to target .NET Core since everything it implements is declared in .NET Standard 
What? Christmas? Me too!
Some nice additions there.
On both instances, the method is GET 
Have you tried the suggestion in the error itself?
Cool!
While I'm glad to see WPF/WinForms and WinUI open sourced, that bit of news is probably the most important in my mind. It opens a lot of possibilities for the future of the .net platform and ecosystem.
I did not but I was trying to avoid that since the code is identical, just not working in that one instance within Azure. I found the issue though; stupid mistake on my part. There was a syntax error within the Web.CONFIG, machineKey decryption="AS" instead of machineKey decryption="AES" &amp;#x200B; Sorry to take up your time, appreciate your input though :) 
It is literally massively important for enterprise. That's basically a guarantee that they won't be stuck without the source code. If other people want to do something with it, they technically could too. Can't wait to see what comes out of it.
Ohh good, Doesn't look like there is an XAML designer with now with .Net Core 3 WPF, Or am I missing something?
From the repo roadmap page it's still on planning phase it seems, since it's gonna involve quiet a bit of work to do.
Thanks for the info!
I too wonder this, until there is VS Studio on Linux , you still stuck "easily" developing on windows to deploy to Linux.... or using their code ide that frankly sucks.
I’m not sure what to make of all this. I love, love WPF, even though I don’t do desktop development anymore. I’ve since moved on to ASP Core and find that a great platform as well. The ability to start a new WPF project that targets .NET Core sounds great for those still doing desktop development. But is there anything cool to look forward too if I’ve moved on to the web? Im assuming the open sourcing will mean that WPF will be kept alive by the community even if Microsoft prioritizes elsewhere. I love this tech, and there’s a lot of buzz about it today, but I’m not sure how much this will affect things in the next few years, or if there is more to be excited about that I’m missing. 
I haven't cared about MS in almost 20 years. And I still hate / refuse to use windows. &amp;#x200B; But man, C# on Linux is looking pretty nice. That TLS 1.3 example looks so sweet because 1) async, 2) exceptions. (Errors must not pass silently - cough cough Golang). Good to see real competition for Java.
This. Wake me up when the major component vendors move their flagship WinForms/WPF controls over to .Net Core with feature parity. Until then there is zero incentive to move off of .Net Framework Classic on the desktop.
A bit closer to the dream of write-once-run-everywhere GUI applications that don't require a web browser stack.
You are selecting a collection of records with Where(), and then projecting them to a collection of strings with the Select(). If you want ONE record, you need to use something like First() or FirstOrDefault() with a null check. CreateMap&lt;Customer, CustomerDTO&gt;() .ForMember(d =&gt; d.SalespersonForClass1Name, o =&gt; o.MapFrom(s =&gt; s.CustomerSalespersons.FirstOrDefault(x =&gt; x.ClassId == 1)?.SalespersonName) .ForMember(d =&gt; d.SalespersonForClass2Name, o =&gt; o.MapFrom(s =&gt; s.CustomerSalespersons.FirstOrDefault(x =&gt; x.ClassId == 2)?.SalespersonName);
Yes. Let's be smart about all this. 
C# is run by a Scandinavian mafia
Blazor
I don't like the scaffolding in identity
I don't like the scaffolding in identity
Not really. All three of these technologies rely heavily on components of the core Windows operating system which are not open source. That's why they are remaining Windows only. 
[removed]
I'm not so sure about that. None of the things you mention are good alternatives. Winui is not cross platform. Xamarin is more app oriented and doesn't have Linux support. Electron uses js and is inefficient. Web apps cannot communicate with hardware attached to a PC such as serial devices (which is a common requirement in my industry), are relatively slow and do not have RAD. So for standalone software that has to communicate with hardware we're stuck to the Windows platform unless we use non-Microsoft products like QT or Java. 
[removed]
It is now open sourced so in the medium term I wouldn’t say zero incentive - as we have seen with the rest of .NET Core we are likely to see a significant number of contributions from the open source community.
Somebody let me know when a port to other platforms goes underway
WCF and full WS-* protocols support? No interest until basic business features are supported.
&gt; When we announced planning for ASP.NET Core 2.2, we mentioned a number of features that aren’t detailed above, including API Authorization with IdentityServer4, Open API (Swagger) driven client code generation, and the HTTP REPL command line tool. These features are still being worked on and aren’t quite ready for release, however we expect to make them available as add-ons in the coming months. That's a shame, I've been waiting for that. At least they haven't forgotten
I think it's automatically added when you add an EF Core package to your project (you will be able to see it under Analyzers). It should just work from there.
VS Go To All is pretty close to Resharper. At least close enough for me to uninstall it without really missing anything. https://tutorials.visualstudio.com/vs-get-started/navigating-code
What's the current state of blazor?
So where‘s the news? It‘s been announced quite some time ago that they‘ll be implemented in Core 3.0, and since core is open source, well ... Most people seem to confuse these news with cross platform compatibility for Forms/WPF, which is not there and specifically not planned by MS at this point
How about mixed assemblies? Without going through pinvoke annoyance?
Experimental
I really like the switch expression.
If you only host simple [asp.net](https://asp.net) site, then you just need to go with shared hosting, there is no need to purchase VPS. Azure is free but since you are using SQL database, it will very costly for you. I would recommend you to take a look at other option, like [asphostportal.com](https://asphostportal.com). They do support latest .net and SQL server with affordable price. 
Not only that: wake me up when the majority of Windows install base has .NET Core 3.0 installed.
The whole point of .NET Core is that you bundle it alongside the app.
Agreed, just look at ODP.NET. Their managed driver only offers a subset of the native one features. So anyone using Oracle UDT or distributed transactions, won't be moving to .NET Core anytime soon.
And then my 6 MB utility grows to... I don't know, 50-100 MB? I'll better stay with the old .NET Framework for a while.
I don't know what the difference is as I have never used it without resharper. That might sound odd, but I've been using VS since there was a VS and back then it had barely functionality. I'm going to download the VS '19 preview. Apparently they've got side by side working now, so that's a total bonus.
It‘s a nice feature, but if you think that‘s „the whole point“...
Well, at least they have a linker now.
Not so sure about what? That making Win32/GDI/User32/DirectX work perfectly on Linux and MacOS would be incredibly expensive, take a long time, and result in a poorly optimized 15 year old cross-plat UI framework by the time it would would be in beta? Or that investing in WinUI (better optimized &amp; faster), Xamarin (existing), Blazor (promising/exiting), a web framework (much more widely adopted), or something brand new dedicated to cross-plat would be a better alternative? Also, [Xamarin Forms now runs on Linux](https://docs.microsoft.com/en-us/xamarin/xamarin-forms/platform/gtk?tabs=windows).
I now it has more to offer than that, but for our kind of projects that is the whole point. Our UNIX customers are not going to move away from Java based projects, so for us .NET remains a Windows stack only platform. Fact is that even with .NET Core 3.0 around the corner, many .NET library vendors still haven't bothered to support the other platforms, so I get to port code from .NET to Java instead of just trying to make it run on Linux distributions. 
[https://www.youtube.com/watch?v=WBpLs21AzXQ](https://www.youtube.com/watch?v=WBpLs21AzXQ)
Well, that‘s the difference in something being „the whole point“ of a whole project, or for a single team. ;)
IMHO its a good question. You want dev's that have personal projects to some degree, even if they haven't picked them up for 6 months. If they feel they are missing out on new technology they will be trying lots of new stuff. If they are just exhausted from their current job their answer should be a good insight either way. That said the best programmer I ever met generally doesn't do side projects. But if you pushed him he would start talking how 6 years ago he played with a pid controller and got his coffee machine to balance it's temps. And if you were smart you would hire him on the spot. 
I like these questions, they would start some good discussions with the candidate.
That just sounds like an argument to avoid major component vendors... &amp;#x200B;
Waiting for Windows Workflow Foundation to join in. &lt;3
Sorry, what I should have asked was, what's it like to use? Do you like Blazor? Has it helped you with anything?
Not yet and a request has been backlogged for years: [https://github.com/aspnet/EntityFrameworkCore/issues/795](https://github.com/aspnet/EntityFrameworkCore/issues/795) Someone made an extension to support it: [https://github.com/borisdj/EFCore.BulkExtensions](https://github.com/borisdj/EFCore.BulkExtensions) so there's that in the meantime.
Implementation of separation of concerns by create separate DLL is common in .NET but is should be done with caution. Too much granularity is not good either. I recommend [https://herbertograca.com/2017/11/16/explicit-architecture-01-ddd-hexagonal-onion-clean-cqrs-how-i-put-it-all-together/](https://herbertograca.com/2017/11/16/explicit-architecture-01-ddd-hexagonal-onion-clean-cqrs-how-i-put-it-all-together/) post, it is good summary of common architectures in .NET applications.
Sure but if it's open source then there's nothing to stop someone from making a pull request to get WPF etc working on other platforms.
They are not stopping anyone, that‘s right. But a lot of people forget, how much windows infrastructure WPF is relying on.
I have not touched it. It's way too rough for usage. I don't think it has the hot reload feature available yet. 
Really love where they are going with C# and .NET and with projects like Blazor and [Bridge.NET](https://Bridge.NET) I can use it fullstack.
&gt; Bridge.NET Are you alright love?
It's a joke that nobody appreciate. Anders Hejlsberg created the language and now it's lead by Mads Torgersen.
You just made me aware that this kind of search functionality exists. It's so easy to navigate now!
Ah, so *you're* the guy 
I know right? Ctrl+T is one of the top 3 key combos I use :)
Why is not initializing `MiddleName` a warning instead of a compile error? I know you can change it to a compiler error if you want to, but the default is the most important setting. Nice addition the little ^ to get items from the end in a range. Switch expressions are really great. Apart from the shorter syntax it also forces a value into a variable where regular switch / case statements don't.
Is there anyone who seriously use the .NET Core on a critical production (banking etc) system? 
It is a lousy workaround of the NuGet hell. The package/library version compatibility went out of control so instead of "old" global (GAC-ed) .NET assemblies for everyone, each application is supposed to install its own private .NET environment. Terrible.
&gt; I don't think it has the hot reload feature available yet. Nor does ASP.NET. That didn't stop anyone from using it.
Wake me when I can map stores procedures 
I understand your point of view, but web based applications are not applicable in my line of work. I just need the tools to develop stable and fast non-mobile standalone applications that interact with their environment and can run for years at a time. Right now, this is either Windows only or outside of the possibilities offered by Microsoft. I am not married to WPF but Microsoft leaves a hole here as it doesn't offer any alternative to Winforms/WPF/etc on other platforms. I personally don't care much about backward compatibility in this matter as long as its based on .NET.
It's hard to tell if it's a joke or not. It certainly isn't funny.
If they made it a compiler error then existing code bases wouldn't compile. I wish they would, since I see those code bases as flawed. But I get it. 
I am a windows user, keep this in mind as I say the following. If MS really wants Core to replace framework quickly , it's time for Linux to get real Visual Studio, new developers will naturally go to core base, and old developers who wish to run linux would move to using core and do cross platform. And this isnt' about ms preserving the desktop, they don't care about that now, chromium based browser to replace edge , if they could they would go linux kernel MS badged distro in a heart beat if they could.. save money and make money.... MS is service based company, and they will thrive and survive.
How does go let errors pass silently? in go you have to handle the `x, err := MyErrorFn()` if you don't, well either you *know* it can not error out, or you made a mistake.
No thanks.
But won't .net core 3.0's support for EF6 make ODP.NET fully compatible? I know Oracle's managed driver isn't working for EF Core yet.
It's a good start though!
I mean, its only one of the vendors, but didn't Telerik commit to zero day .NET Core 3.0 support for their desktop controls?
Yeah it’s all WINAPI under the hood which will go open source around the same time Windows itself does. 
your *basic buisness features* are "buisnesses are lazy, so let's support them not using newer technology that works better in most scenarios, because that's the reason they exist" &amp;#x200B; **Why** should all software be compatible with pre 2000 era, or netfx 3.5 era, when they clearly already are dead from a buisness side, because they are not maintained or supported anymore (yes, i know, netfx 3.5 sp1 has extended support until 2028, but seriously?)
At this point it would be easier to add the missing tooling to VSCode. They already have syntax, SCM, intellisense, intellicode, git lens, and add ins for azure devops (VSTS), azure services management. What are they missing? A few scaffolding tools and WSYWIG/RAD editors? All they would lose permanently (which would stop many users) would be the loss of countless legacy VS extensions and add-ins.
It's not though. Open sourcing these platforms is a good thing, it gives them a certain degree of certainty in regards to their future. Making them cross platform however is incredibly difficult and Microsoft has been very clear they're not doing it and won't accept changes in line with that goal. This is a hard nut to crack even for platforms designed for it, and moving these platforms to Linux is totally impractical. Even if you could stub out required components no one is going to install that much software infrastructure just to run your app. 
Bit early to hype Blazor. It's very far from viable at the moment and it's going to need to overcome some serious challenges to prove its worth. I'm not too optimistic.
Even if I'm not not using the major component vendors in a project I look to them as an indicator to see if a given Microsoft technology/framework is ready for investment. If I see the vendors announcing full parity in their controls- or better yet new features that are implemented on .Net Core but not on .Net classic. Then I will know it is time to more seriously consider moving. These vendors have excellent ties to Microsoft and the benefit of being able to watch which technologies their user base are using. Feature parity is key as all of the vendors will throw some controls out for every new technology Microsoft produces just to show they are on top of the latest stuff. FWIW, it took many years for the vendor's WPF controls to catch up with WinForms and it was only relatively recently (last 5 years or so) where you started seeing features added to the WPF side that hadn't yet made it to WinForms. Silverlight, for another example, never reached anything close to feature parity before it died on the vine. 
If MS really wants fore to replace framework quickly they need to make it a seamless upgrade for enterprise customers and give them some compelling reason to make the move. The biggest gating factor to this move will be enterprise desktop- and enterprise desktop cares not one bit about Linux. The *do* care about upgrade costs/effort, full feature parity, etc.
True, I guess it might not reach full maturity, I included it to cover more traditional web app development. Probably should have included some IL to ASM magic in the list too. &amp;#x200B;
I don't work at a bank, but .NET Core powers our critical system that has to be up 24/7.
I am just going to politely disagree in that creating a more comprehensive X like system needs to see how other systems work.
You can still lean on a central install of .NET Core. The private install is nice, though. Getting every customer to the latest version of Framework is unrealistic where I work.
In one of the other talks, Scott Hunter said "We'll ship a .NET Core 3.0 some time in the July-August 2019 timeframe I would hope" Microsoft also shipped .NET core 2.2 yesterday and hardly mentioned it. There have been a new .NET Core build very month or two all year, I guess this cadence is routine now?
Nevermind that it took Oracle an embarrassingly long time to even get the driver out. Literally every other major vendor had zero day drivers available when .Net Core 2.0 was released. Not Oracle. They, IMHO, are massively shooting themselves in the foot by not providing a premium experience for the premium price tag attached to their products. 
I would expect a .NET developer with 1 year experience to already know that.
No, it requires new providers. https://blogs.msdn.microsoft.com/dotnet/2018/12/04/announcing-entity-framework-core-2-2/
I haven't been that excited about a C# language release since the C# 5 days.
Most likely, but how much does it matter if they don't? Framework knowledge != skills.
So I'm a PHP developer currently trying to get up to speed in C#/.net, and with even minimal experience learning the language, I was aware of this.
I would say that someone who has used .NET for 5+ years \_should\_ know this, but it in itself wouldn't be a show stopper for hiring someone. If this is phrased as trivially as you suggest and they get it wrong, but everything/most other things correct, then it's a quick correction and you can probably move forwards.
And Oracle historically takes *years* to adopt Microsoft technologies and generally doesn't even start development until the GA releases are out. You never see zero day Oracle drivers. 
Yes. Anything else is a fundamental misunderstanding of a fundamental type that you would be using *all* the time.
I have a 10 year very stable WCF based communication stack and see no particular reason to touch it. No WCF (or no clean path forward from WCF to something more modern) and .Core is a nonstarter for me. There's simply no way I'm going to get budget to do a technology driven port unless there is some compelling driver for it. At the moment that doesn't exist.
I wouldn't expect them to. I just use it as a O(1) lookup for objects, and internal un/ordering has never entered my mind because I use other structures if I want ordered data.
Absolutely they should know this.
Pretty much but if they could have googled it and still got it wrong than I would be very concerned.
Stop hiring recruiters, they know NOTHING and are completely worthless. Of course they want you do dumb down your tests, they want to place ANYONE, regardless of their abilities. &amp;#x200B; See /r/recruitinghell
People who say yes, they should: 5 People who say no, they might not: 4 Me: from m in dict order by m.Key select m;
Halting the recruitment process for a given candidate just because they were not aware Dictionary is not ordered is not seeing the woods for the trees, imo.
My answer is going to entirely depend on the way you've phrased the question. If the question is a simple "Is Dictionary&lt;TKey, TValue&gt; sorted or not?" and you're expecting a yes or no answer, then I'd argue it's not a particularly useful question for winnowing out bad candidates. Firstly because it's the sort of thing that anyone with rudimentary Google-fu can answer correctly (okay, so maybe it's useful for excluding people who can't get answers from Google - which is honestly a very important and underappreciated skill), and secondly: how often do you have the need for a Dictionary that's sorted or not? 99% of the time you use a Dictionary, it's because you need something to store a strongly-typed collection of key-value pairs; ordering doesn't come into it. (The other 1% of the time you either put "Sorted" in front of "Dictionary" and see that that class exists in the BCL, or you Google "c# sorted dictionary" and the first entry that comes up is the MSDN page for `SortedDictionary`.) On the other hand, if the question is "Based on this scenario: &lt;scenario&gt; what is the most appropriate collection to use?", or "Here is some code that doesn't work, suggest how to change it to fix it" and one of the fixes is changing Dictionary to SortedDictionary, then yes I would expect the candidate to get that right. With all of that said, I'm a C# dev coming up on 12 years of experience (been doing this shit since .NET 1.1 days), and if you asked me whether Dictionary is sorted or not, I'd definitely have to think about it for a moment. FWIW, I can't remember the last time I had a use-case for SortedDictionary either.
Two rules I live by: All guns are assumed to be loaded. All lists are assumed to be unordered.
Yes. Focus your questions on two areas. One being the things you want them to know to get up and running sooner rather than later. The second being more general tech questions in your area. Some people don't get the memo about things that others take for granted, so you want enough questions to figure out if they know stuff, or don't. Also mix up the questions. If your candidates come from agencies, the agencies will pass on what the previous candidate was asked to the next candidate.
Honestly, it just seems like a gotcha question. There's no real reason to care whether a Dictionary is ordered or unordered internally. If they are trying to use a Dictionary like it was an ordered list would be a red-flag but as an interviewee I'd be wondering if your question was some sort of trick if you just asked straight whether a Dictionary was ordered. 
What is the exact question? If it can be implied that the question is about whether or not the internal array structs that are used in a dictionary have a stable order or not, then that question might even confuse some senior .NET devs if they thought it was meant to be a tricky question.
Not to detract from your point, but in this instance the OP would want an `OrderedDictionary` in this instance. Not trying to be a pedant, but it's a fun illustration on how minor semantics can affect behaviour.
To be honest it depends on so many other things. Two big ones.. First is their experience. I was developing ASP.NET apps for a year and a half before I have a need for the Dictionary type. I just happened to have never needed it. Also it will partly depend on the rest of their team and their coding standards. Our coding standards basically say don't use arrays unless it's really necessary, since the compiler does some cracking optimisation work. Second is how they respond. If they are honest and say they don't know, or take a guess but say they're not sure, then when it is explained to them they are receptive and interested and quickly understand, then that's good enough for me. If they seem confused, I would try and explore their understanding of constructs and sorted data sets to check their understanding. Last one is how they do in the rest of the interview. A lot of devs go for jobs where they don't have experience in 100% of the tech stack or language or framework features. If they're solid on other things, I wouldn't hold this one thing against them. I wouldn't be able to answer many questions on different types of streams, but I would be able to briefly read the docs and get an initial understanding of them, have a crack at coding with them and give some feedback.
It is something I would expect someone who has never touched .NET to know. It's a fundamental property of the hashtable\dictionary data structure and is typically covered in the first year of a CS degree. But I wouldn't ask it as a yes\no question. Instead I would ask a problem that could use various data structures (array, linked list, dictionary, queue, etc.) and ask them to discuss the trade-offs between them. It doesn't even require .NET knowledge.
Yeah they should know this but it's not a big deal if they don't. This is one of those things that is trivial, and somebody who ran into a problem because of it while working could quickly fix the problem and never need to bring it up.
Code isn't an IDE though
I'm confused, identity server 4 just works off of JWT, of which already can be handled by .net core. Do they mean like an easier set up process for identity server or?
Too rough for production usage certainly but I have a fairly large side project built with it. The debugging experience isnt the greatest but its possible to do. Personally I've really enjoyed working with it. I love being able to share c# view models across the client and web layer. I also like not having to write nearly as much js. Just my 2 cents
It's actually quite polished for an Experimental and the dev experience so far is good if you'd avoid using 3rd party libs for now since Interop is kinda finicky at the moment at times. Though I'm using server side blazor for now since it has full debugger support. I'ved already ported a small portion of our enterprise admin portal to it which was using MVC + jQuery in my free time and it was pretty easy with zero need for NodeJS and webpack or any bundler. Though I won't deny that there's still a lot of rough edges particularly on routing and 3rd party lib integration (mainly due to the fact it has to interop to JS if you'd want UI libs to work properly or create wrappers for now). Thankfully there's quite some community work for creating native or wrappers for this as a nuget package so you won't have to get down and dirty with interop that much.
They said that they won’t accept such pull requests. 
What new technology works better than SOAP and WSDL that allows to generate **strongly-typed** client in two seconds? REST/JSON based shit that requires one month work on the client to do all the try-and-fail experiments because there is no service metadata description (no, nobody provides WADL as it isn't standardized yet).
How's the development experience? Do you have to F5 to see your changes and does it keep the state or do you start from the beginning?
So much this. Judging people on their reference material knowledge is counter-productive, in my opinion. It is my belief that great creative minds might have a tendency to forget, like, everything, all the time. It's better to discuss things, which you can't look up in five seconds. Like, how would you compose your classes given a task like this? How do you usually look for bottlenecks? How's your multithreading game? How do you decide which columns to cover with indexes, and how do you choose index type? You know, that type of thing. And the closer your questions and hypotheticals are to your actual project, the better.
I still use .NET Remoting in some scenarios because it is better than stateless HTTP based web services. It is 100% reliable technology.
Depends what they've been doing. I have been coding specifically in asp.net mvc/web api for the last 5 years and **have yet to use a dictionary once**.
This is one of those things that are covered in the introductory texts which would be fresh in a beginner's mind, but someone with lots of experience might forget about because 1) dictionaries aren't used that often and 2) in 99% of scenarios you're just using it as a key value lookup and you don't care if it's sorted.
I wouldn't have a clue if the items are somehow sorted by key or not. Can't think of a usecase where I would even care. I find these sort of questions completely useless.
What kind of bullshit company allows recruiters to dictate what goes on in a technical interview? Every company I've worked for to this day has recruiters to do just a couple of simple things: find a person by a set of given keywords, make contact, verify their CV isn't full of shit, talk to them about their past experience and verify they can speak at least rudimentary English. Done. Devs (or QA) do the technical interview however they see fit and have final say in whether the person gets the job or not.
F5 to see changes works (triggers a recompilation of any source files used by the view)
&gt; fail the test based on that Are you saying 1 question wrong fails the test or that you have multiple questions regarding dictionary order?
I usually break it down by type of test. Models, DTOs, validotors, helper functions, anything that can be unit tested on layer one. DALs, repositories, service clients, and other things that need to be tested with dependencies in layer 2. The third layer has the "UI", whatever that means for the project. Besides making the code easier to understand, newbies can't shove database calls into places where they don't belong. 
I'm obviously not asking point blank "is a dictionary ordered?". They have to write a program, which involves using a dictionary, and these candidates use the dictionary as if it was preserving insertion order.
Depends what they've been doing. They probably learned it on day 1 or 2 when introduced to C#, but then never came across it again. Seems more of a "gotcha" question. Why don't you just stick to relevant questions to what you guys actually do?
Yes. You should know that. Not knowing it wouldn't be a showstopper- but it would imply that you have no idea that it essentially is a Hashtable internally and that Hashtables are not ordered. This is some pretty basic datastructure stuff that would strongly point to a developer who learned the APIs/syntax w/o necessarily understanding the basic CS algorithms/data structures behind it. Missing one or two of that type of question shouldn't rule someone out- but it would prompt further questioning to see where the candidate was at w/ their sophomore level CS theory. Back 20 years ago when most low level development was in C, I used to ask folks to implement the standard string library strcmp (String Compare) function as an interview question. I was always simply shocked with the number of people that either couldn't or wouldn't do it.
IMO if needing to consume 50-100mb more disk space is a serious problem for the environment your app is running in, it's time for a disk upgrade.
That 6 MB utility is a program that I develop and sell online.
I don't think it's too early at all, considering they are releasing server side Blazor with .NET Core 3.0 early next year.
It's not about knowing the framework, it's about knowing when you don't know. Instead of writing code that assumes it's ordered, they should have stopped and googled it.
yeah but aren't the managed data providers from oracle still in beta?
There are lower bounds to this. OP's question isn't an obscure framework implementation question. It is a first year computer science data structure question that anyone with 5 years of work in the platform should know in heartbeat. Now if you were, for example, asking something along the lines of explaining the boxing differences between a Hashtable and a Dictionary- then *that* is minutiae that has no place in an interview.
If you're talking about how, when iterating through the dictionary kvps, **it often returns the keys in the order they were added, but sometimes does not**: then I would say no. It's interesting when you discover it, but I suspect most devs do not discover it. I've definitely seen it cause bugs for otherwise good developers. If you're talking about how, when iterating through the dictionary kvps, **if they expect it to be sorted by the key...** yeah that's a minus point, they should know it doesn't work like that. The whole point of a dictionary is that it uses hashing for quick lookups instead of using sorting. BUT it would definitely not be a dealbreaker! There are a lot of codebases out there and a lot of coding styles, more than you would think. I could easily see a .net dev with 5 years of experience simply rarely using Dictionaries. Remember, you're not trying to hire people who know exactly what you know! Appreciate divergent experiences.
So if someone has successfully delivered dozens of applications with maintainable code and happy users, but they can't remember whether a dictionary is sorted or not (because honestly who uses a dictionary that way anyway??) you'd cancel the interview?
Then it will be forked.
I should also mention it's possible to make a build of your app that would bundle .NET Core, and a build that would require it already installed. If you want that flexibility it's there. Personally I think 50-100mb usage to remove a potential point of failure is not a big price to pay.
&gt; but someone with lots of experience might forget about. Naah, this is something that is so ingrained in day to day coding that it should be absolute second nature. Lists, Arrays, and Dictionaries are the 3 most fundamentally used collection classes and anyone programming should have a basic understanding of the collection characteristics of the platform they are using.
..and yet SO many recruiters can't even do these simple things. It took me a little while, but I convinced my wife's office to stop using recruiters and in the last decade it has saved them over $250,000 and massive amounts of aggravation. Recruiters are just so worthless. Have a great day
Ok, let me ask you this. 99% of the time when you're using a dictionary do you care if it's ordered or not?
I agree with you completely. Just couldn't help myself after seeing " Framework knowledge != skills" part, it's so true.
~40 yrs here. And I agree.
Yeah, I hate interviews by trivial questions. But there's a difference between fundamentals and trivia :)
Ooh, you're talking about, like, recruiting agencies and stuff? Yeah, those are trash. I was thinking about in-house recruiters, who sit in a room next door in the office. Have a great one too.
Without getting too much in the details, they have to write a program that returns the first non-repeated word in a string. Generally they count the words using a Dictionary, but then enumerate the dictionary and return the first entry with a count of 1. Obviously that doesn't work given Dictionary isn't guaranteed to preserve insertion order.
I would want to know how the interviewer managed an ordered Hashtable with constant time access so I could go write a paper on it :)
Without getting too much in the details, they have to write a program that returns the first non-repeated word in a string. They count the words using a Dictionary, and then enumerate the dictionary and return the first entry with a count of 1. Obviously that doesn't work given Dictionary isn't guaranteed to preserve insertion order. 
The server-side of Blazor is not where the challenges are nor where the hype is. People want C# to WebAssembly and .NET in the browser. There are some serious pitfalls in that idea that are yet to be overcome in the foreseeable future.
ah, yea in house can be better. However, I have a friend who I have known since 1981 (yea yea, I know, I'm OLD) and she has been an in house recruiter for Adobe, MS and currently at Amazon and she doesn't know a thing about tech, so she can't ask or respond to the questions. So, effectively she is of no value. The items on your list that should be checked out can easily be done by the manager who needs the tech, and they SHOULD be... after all a recruiter may remove someone who doesn't have the X-years but does have other experience that the team may need. Recruiters add a layer that CAN be helpful, but in my nearly 30 years in IT I have NEVER seen a SINGLE instance where a recruiter, in house or otherwise, give value to the process. However, I will say that just because **I** haven't seen it (or known ANYONE who has seen value from a recruiter) does not give enough data points to prove my point. Obviously I could be wrong
Yeah saw that :-(
The only thing that is windows specific for WPF is it uses directx for its rendering, the rest is cross platform. There is nothing stopping someone from going and rewriting the rendering engine to support say open go/vulkan instead, which would make it truly cross platform.
It is built on top of direct x, not winapi. You just need to rewrite the entire rendering engine to support a different graphics library.
This has nothing to do with framework knowledge. A dictionary is a data structure.
Heard of all that Electron hate? The .NET Core bundle for desktop creates a similar problem: memory hungry programs that do not share any common DLL libraries. Also having two separate downloads creates more support problems than it solves, in my experience. Using an old an .NET framework is not a potential point of failure, they are time tested and omnipresent. I personally prefer to use the old good .NET 4.5 for my programs run on all current Windows versions. And I don't miss any new C#/F# features, the latest compiler runs fine on it. 
I mean it's a .NET interview so basically 99% of the time, you're going to be either manipulating some god-awful XML data in a legacy system, or trucking data between an Angular / React front end and a database / web service. If you're really unlucky you'll be maintaining a legacy VB WebForms application.
A better question might be, does order logically apply to a dictionary?
Yea, good interview questions try to reveal knowledge gaps that would take a long time to fill.
You keep saying "I'm obviously not asking a yes/no question" which comes off kinda rude. If people assume you ask a yes/no question in the interview, it's because you phrased it your question wrong in your post.
Then this question is exceptionally misleading. Let them make the implementation, if they choose a dictionary for it, then it's their choice to handle the problems with it. If they use a hashset, then the concept of ordered might not be relevant anymore
Have an upvote
Do they claim to have a college degree? Because 5 years + CS degree should damn well know that a Dictionary is a Hashtable which is not sorted. You can give them a hint question. "What's the Big-O lookup time of a Dictionary implemented as a hashtable?"
You don't need a ordered collection for that. 1 pass through the string doing word counts via the dictionary. 2nd pass through the string looking for the 1st item with a count of 1. The input string gives you the ordering, no need for the collection to do it.
And how does that Dictionary provide O(1) lookup, then? I would expect a developer with a CS degree and 0 years of experience to know this.
OK, given how saturated the job market is, you have to sift through thousands of applications looking for ones, which actually match the requirements. That's a ton of dull work. Depending on how important a position is, as a recruiter you would sometimes have a script, similar to what tech support people have, which has all the common questions and answers. Not only that, but (at least where I live) recruiters not only filter incoming job applications, they also actively hunt people to find promising candidates, who might be interested in a job, but haven't made their mind yet. Or try to persuade a person from a different company to join, because the opening is hot and needs to be closed ASAP. If you set aside an actual manager or, even worse, a developer to do these things, then you'd be wasting that person's potential. I mean, I know how to operate a rag and cleaning solution, but I doubt my superior will put me in charge of toilet cleaning, because janitors are overrated.
No dumb ass, this is why, if you read the whole answer you would have read: &gt; Some people don't get the memo about things that others take for granted, so you want enough questions to figure out if they know stuff, or don't. You ask lots of questions in an interview and assess a bunch of technical and non-technical aspects across a dozen applicants who are eating into 12 hours of your week. We do it because we want good people and it's worth it when we do. This doesn't mean your bad attitude is acceptable. I get tired of this "You should assume I can do it" crap. You sell yourself, just like everyone else does. You express your abilities, your communication skills, your ability to work in a team. I want to see team fit, and yes, an understanding or at least interest in learning the minutiae. If you don't care, don't think it's worth knowing, then you're not going to progress. This stuff is useful to know. Not knowing it perpetuates the cycle of ignorance. The very least I'd expect is for you to Google the answer if you couldn't answer it in an interview so you could answer it in the next one. So yes, you should know it. If you didn't, *you* do now because you've read this thread. That is the initiative I give marks for. See how it works? Also, sorry for calling you a dumb ass. You're just an ass. Also sorry for calling you an ass. I do a lot of interviews and I get my time wasted way too many times to be generous on this matter. 
oh, I hear you, and you are ABSOLUTELY right about having a developer do it is not of value... It's just that the recruiter cannot know what the manager wants/needs more than the manager does. It's effectively a game of Telephone. If the manager does not properly tell the recruiter what they want/don't want, then the recruiter cannot do their job, and the manager simply cannot tell the recruiter EVERYTHING they think/feel/need. It's simply a process that cannot properly work. 
Technically, a Dictionary is just a collection that provides indexed-by-other-than-int lookup to a value. If they'd never touched DotNet, I'd hint them that it's O(1) lookup and insertion^1, which should clue them in. ^1 Technically, it's O(&lt;hashing&gt;), which is usually trivial, but can be foiled by an expensive `GetHashCode` implementation.
I'm somewhat baffled that folks think basic understanding of a Hashtable's runtime characteristics are somehow a "Gotcha" or trivia question. This is a first year CS data structures question covered in the first semester of any CS program.
&gt; Me: from m in dict order by m.Key select m; Fine for small amounts of data, but terrible for large amounts of data.
Did you really think this is worthy of a tutorial?
I'd say that they should know it, but I wouldn't call it a disqualifying mistake. Seems like the kind of thing that would make for a good conversation starter (aka pointing out that something might not work and seeing if they can work out that the dictionary isn't ordered, then talk about how to change the code to handle that.) I'm assuming by the fact that you mentioned a recruiter that this might be a take home problem, though? If that's the case and you're having that much trouble, I'd say either rephrase the question to make it a little more heading, or scrap it entirely.
To be honest, at this stage, it seems that Java competes C# not the other way around. Java is outdated and the only major good niches are that UI is crossplatform and that will change soon by the .NET projects. 
&gt; but someone with lots of experience might forget about. The Big-O of basic datastructures is something you should never forget to remember. You may forget what the Big-O for a certain operation is, but you should always remember that it's significant and know to look it up if you're using it and forgotten it. Dictionary provides "magic" fast access to items indexed by strings (or any T). How does that magic work? It comes at a cost. If you're facing a programming challenge to come up with an efficient way to do something, then you should know the cost! Using the wrong data structure for a task is a great way to tank performance, often in ways that work fine in small tests and fail spectacularly in production on high workloads.
Ugh... Don't do random trivia questions for dev interviews. It shows nothing about the developers ability except that he knows a random piece of trivia.
Ya, I'd say this is actually a "trick" question of sorts. Dictionaries are used for searching when you have access to a key, which avoids having to loop through a collection in order to find a specific element, Whether they are unordered or ordered is irrelevant since they are specifically not designed for iterating over (although **you can**)
I could cut a non-DotNet programmer some slack for not knowing that a Dictionary is implemented as a Hashtable. One of the hardest transitions between Java and .NET is the fact that the data structures are all named differently, and sometimes similar names have different implementations. They might be coming from a language where a Dictionary is by default a sorted map implemented as a tree, while a hashmap is called out explicitly.
Agreed. I don't think it's a good interview question because it feels more like a carefully laid trap than a measure of someone's ability to write an algorithm using good data structures. If the candidate chose to use a Dictionary despite knowing that the problem needed a sort order, then I'd raise the issue during the interview. Being forced to use the wrong data structure is odd unless you expect the candidate to object and recommend something different. Most candidates would try to comply with the odd request due to time restraints and the urge to please the interviewer. A better interview question would be to ask if a Dictionary would be a good fit for the problem and why. If they can't identify the problem then it shows their ignorance.
This is how I managed to do it, but does anyone has a different, cleaner approach?
Sorry, if you are calling yourself a .Net developer and have 5 years of experience this is something you should know. This isn't asking the balancing differences between various tree implementations- Arrays, Lists, and Dictionaries are far and away the most used collections in the language. 
It really depends on whether or not they've ever needed an ordered dictionary. I've been doing .net for a long time and I have rarely come across the need for an ordered dictionary (maybe once).
That's another aspect - so many of these "typical" CS-type problems can be trivially solved with LINQ, no awareness of data structures is needed.
It is reasonable to expect them to know that, it isn't reasonable to fail the test for and discount their application for not knowing that. Yeah, its a fundamental part of comp sci theory but when you're applying to 5-10 jobs that all have pretty much the same questions except backwards, forwards, upside down, etc. eventually your brain is gonna make some mistakes. "Find the first double occurrence of a string in a string" hash map works great "Find the first repetitive number in a string" hash map works great Insert more string lookup questions "Find the first non re-occuring in a string" well hash map worked for all this other string shit very well, lets try it, hmm seems to be okay &amp;#x200B; It's good to be able to think of the correct answer on the fly. Let be real, everyone of us has made a mistake with something "fundamental". These applicants were able to think of problems of similar nature and apply solutions that don't quite make it. Some who answer it correctly might not know a Dictionary is unsorted either. They might have just seen this question on a youtube whiteboard walk through and already had the solution. You passed up a programmer with decent ability to relate similar problems for one who may just be regurgitate info. This should be the smallest dockage of points. 
yes
? Without looking at the .net internals, I would imagine it uses the key value as an input to a hashing function, then stores the result and corresponding value. Then when you provide that key again, it uses that resulting value to look up the stored value in a hash table. Hashing functions were one of the first things we did in Algorithms back in college.
That's completely different. I have trouble imagining a scenario where you'd use a dictionary and care about insertion order. I would agree that someone using a dictionary in that way would certainly make me question their experience level. 
I have heard of the hate, but I don't share it. Electron is an awesome way to take an existing cross-platform standard (HTML/CSS/JS) and bring it to the desktop. I run Twitch, Discord, and Visual Studio Code which I believe are all Electron-based with no problems. When I said a potential point of failure I meant the chance that the user will not have the version of .NET required and will have to take some action other than just installing your app to run it to get it working. For example .NET 2.x/3.x apps won't run on modern Windows out of the box... you have to enable that version of .NET in Windows Features. Compare to a native app which doesn't have to worry about that. Bundling .NET Core gives the same user experience. Who knows if .NET 4.x will eventually be deprecated in the same way, causing today's .NET Framework apps to have that manual step needed to enable them. Of course by then if you are still maintaining your app you will likely have migrated it to .NET Core. But like I was saying you may choose to not bundle .NET Core with your app and keep it small, or you may change your mind and decide to avoid potential support problems by bundling it. Look my whole point was that storage is cheap. 10mb vs 100mb shouldn't be that big of a deal.
Someone claiming 5 years of experience in .NET should absolutely know this, 100%. Someone with 5 years of experience who hasn't done .NET recently? Easy to forget things like that. As someone interviewing at the moment, I'm just a little more prone to being lenient about interview jitters. I would prompt something like, "so what's the Big-O on that?". Not explicitly telling them exactly "dictionary isn't sorted", but giving them the opportunity to think about it and fix their mistake themselves.
your answer is why I dislike such questions. because most of the time you can only guess, because it's too language dependent and if you NEVER cared about dictionary order (basically I never relied on the dictionary order at all) than you probably will fail, just because a simple questions that could've been googled. a better question would be, look at msdn SortedDictionary and look at msdn OrderedDictionary and tell me the difference.
As I've posted elsewhere in this thread- any single question shouldn't rule one out of an interview. But this would be a red flag and a trigger to dig deeper into that candidate's data structure fundamentals.
I dont hate Electron too and love VS Code. Cheers!
&gt; The default answer is No because that's not how hash tables work. That's the point. A 5-year developer shouldn't be treating data structures as magic. If they're using a Dictionary for O(1) lookup, they should understand that means hashing and hashing means unordered. There is no data structure that provides O(1) lookup, O(1) insert, and ordered iteration. At best, you can get 2/3.
That is... incredibly solid.
Without reading the comments, absolutely! A dictionary is a data structure that is essentially a hash-indexed array, which means that in order to access your data, you have it to calculate an index and then that accesses the array and returns your data. It could be considered sorted, just not sorted in the traditional meaning, it's sorted by hash values.
Yeah, I’d say so. By which I take it to mean: that enumeration is not in any particular order. 
It would apply to enumeration of the dictionary. 
Dictionaries are only O(1) lookup on average, not worst case. 
You never wanted a key/value pair ordered before? Any website that uses paging would have something like that somewhere.
Yes. I've interviewed around 300 people in the last three years. I ask people what the differences are between a dictionary and an array. If they don't know that a dictionary is unordered, that's a definite red flag. I don't know that I'd fail them just based on this question. But if they get this one wrong, they're likely to get a lot of other questions wrong also.
Well yes of course, that's the correct answer, and any candidate that comes up with that solution will pass the test. The problem is that 2 in 3 candidate don't think of that. So I'm wondering if that is too much to expect.
I think they should know it as general knowledge since in computer theory a Dictionary or Lookup Table is not ordered since it uses a hash function(or equivalent mechanism) to access the contents in O(1). It's not a deal breaker though. 
“Is a dictionary ordered” in this context always means “are dictionaries guaranteed to be ordered, when iterating through it”.
That can be quite useful, but you usually just maintain a separate list for that purpose. 
With that type of question I'm generally ok with functionally correct but non optimal solutions. IMHO, if the candidate proposed a solution that assumed that the Dictionary was ordered that would be a red flag.
This is pretty important information to include in your post lol.
You could just check to see if the word is in the Dictionary, if it isn't add it, if it is then that's the word you're looking for. This doesn't require multiple passes through the string at all.
He didn't talk about a SortedDictionary, just a Dictionary. \&gt; I'm a C# dev coming up on 12 years of experience ... , and if you asked me whether Dictionary is sorted or not, I'd definitely have to think about it for a moment. I'd burn you in an interview for not knowing this instantly. I've been using C# and .net as long as you have. After 12 years with C#, it should be automatic.
[removed]
Fair point! Hence the edit on my first post. The question as-is would be strange to me because I would expect some qualifier, but yeah, I would expect a 5-year dev to have at least passing knowledge of the underlying mechanisms of what they use day to day.
&gt; Should I expect the candidates to know that the Dictionary class is unordered? Is that knowledge useful for the job? I expect just about any developer that's getting a paycheck to know that associative arrays are unordered, but I wouldn't penalize a candidate for not knowing it because it's really not that useful to know for the work I do as a full-stack web developer.
A separate list works or make a class that records the insertion order and acts as a dictionary. Not sure if that's the best description but either way you shouldn't expect the Dictionary class to do it for you. 
https://github.com/dotnet/cli/issues/9481
You won't have the list of repeats vs. no repeats until you complete the first pass through the string. To avoid a second pass through the string you would need to keep some form of ordered list of words that you could drop members out of as they are shown to repeat. Haven't dug into this in detail but I'm thinking the second pass through the string would be faster or at least more elegant than trying to track that ordered list.
I short, absolutely! They are not sorted. Entries are not stored in the order you added them. AND technically, dictionary enumeration is not guaranteed to be deterministic. The keys are hashed to speed up lookup times. O(1) vs an array search which is O(n). Those are the reasons they should know about dictionaries.
It's absolutely fair. I very much recognize that there are time constraints -- I only get to work on my own projects one or two evenings a month. As with a lot of the questions I ask, it isn't looking for a "right" answer. I'm looking at the mindset of the developer. I'll take it at face value that they don't have time to really do a pet project, but I want to know that there's something they wish they had time for. Do they have a mindset for intentional learning or are they just kind of static? Sometimes, the position warrants static. I don't want to hire a rockstar who builds compilers in his spare time to staff a help desk. But, I do (maybe) want that guy as a lead on a new application. I can train anyone to write code. It's just another skill, much like changing a tire or cooking an omelet. I have a much harder time teaching someone how to own their tools. Also, the sort of conversations that come out of questions like this tend to cut through the BS around check-the-box technical questions.
I find that one of the main goals of an interview is to weed out people who are simply lying about their skills and experience. If you ask questions like "What is REST?", you'll get a memorized boilerplate response that sound great. I usually ask people to describe to me everything they know about REST. Then based on what they include or leave out, I ask further questions looking for holes. 90% of the people I interview fit a certain demographic that seems to love brute-force memorization while not really understanding anything. Your questions need to flush out this kind of person.
I'm not following. Why exactly do you need an ordered dictionary for pagination?
That's the answer I would expect from a more senior developer; I'd expect juniors to say no because it's a hash table but they may not have used them enough in practice to have come across a scenario where you'd want to iterate over one instead of grab keys.
If I were given that question you would end up with something like this: LinkedList&lt;string&gt; Words = new LinkedList&lt;string&gt;(); List&lt;LinkedListNode&lt;string&gt;&gt; Nodes = new List&lt;LinkedListNode&lt;string&gt;&gt;(); var BrokenSentence = Sentence.Split(' ', '.', ','); for (int x = 0; x &lt; BrokenSentence.Length; ++x) { var TempNode = Nodes.FirstOrDefault(y =&gt; string.Equals(y.Value, BrokenSentence[x], StringComparison.InvariantCultureIgnoreCase)); if (TempNode == null) { Nodes.Add(Words.AddLast(BrokenSentence[x])); } else if (TempNode.List != null) { Words.Remove(TempNode); } } Console.WriteLine(Words.First.Value); Console.ReadKey(); Not because I don't know about OrderedDictionary but because I would be bored. That said, do you deal with ordering dictionaries a lot at work? If so, good question. If not, bad question. Or at least a question that doesn't really tell you much about the person's abilities other than whether or not they've messed with Dictionary&lt;,&gt; a bunch.
It's pretty common to iterate over the keys in a dictionary so that you can do something to each entry. If a developer just assumes that the key list is ordered, an easy assumption for a junior developer, this can obviously lead to problems.
Seems like a sub-optimal solution...
Why would that take 2 passes? Why not just stop on the first pass when you got a word that already exists as a key in the dictionary?
[removed]
I disagree. If you don't understand the semantics of the tools in the framework, you'll end up designing bugs into the code. It's one thing to not remember exactly what goes in a parameter list. That's what Intellisense is for. But to not know how a data structure is working behind the scenes, it's strengths and weaknesses, that's a more serious issue.
The requirement is to find the first non-duplicate, not the first duplicate. You are describing the latter. (And yes you don't need the 2nd pass in that case)
Why would I need to use a Dictionary? Aren't there better ways to do things than use the Dictionary class?
Ah yeah, totally missed that.
Because it is very primitive.
I get iterating over the keys in the dictionary. Assuming the keys are in insertion order would be just as problematic as assuming they are alphabetical. I'm more surprised anybody would make the assumption. 
SAP doesn't have ADO.NET drivers for ASE yet for .NET Core.
&gt; Is there anyone who seriously &gt; use the .NET Core on a critical production 24/7 (banking etc) system? For some new things, yes. It got good in the 2.1 release. 
First I was about to say that this is a useless question, but then realized it's actually really great. The fact if they know it or not is secondary. I don't think it's important to know how Dictionary works. There are so many things, you could assume to be "standard knowledge" but if it's framework specific implementation, then I don't think it will filter good from bad developers. What I like about the question, is that you can filter out devs which give an answer, although they have no clue (given you said they are allowed to google). You can observe this quite often even on reddit - people saying "it's _definitely_ like this", although it's completely the other way. If someone is exaggerating too much, gives wrong assurances, then it's impossible to build trust in a team. 
Stating that "`Dictionary&lt;TKey, TValue&gt;` is not ordered" is wrong, it's ordering is just undefined. From the [documentation](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=netframework-4.7.2#remarks): &gt; The order in which the items are returned is undefined.
Our web paging has always been done against the database, returning one page at a time. 
Not to say you're wrong, but "I'm X years in this job" is not a good reason to accept opinions
I use dictionaries *all the time*. Any time there's a name-value pair collection, it goes in the dictionary. If you find yourself looping through a list looking for a specific element, most likely, you should have used a dictionary.
I agree, on the face of it, yes. But it's a lot easier than detailing why I agree, I suppose. 
I just looked for SortedDictionary in my company's bitbucket repo and across almost our entirely .net based system we only have a total of 18 files with matches for SortedDictionary. Searching for "Dictionary" found hits in over 10k files. Although many of those are likely ResourceDictionary and things like that. 
2+ years here. This is something you should have learned during your studies and I think this a very fundamental knowledge about programming in general (how the different kind of collections work: array, linked list and dictionaries ) 
.Net developer of 15 years here. Yes, a .Net developer of 5 yesterday should know this, and I wouldn't hire one who didn't. 1 year maybe.
The problem with expecting a developer with a CS degree and 0 years of experience to know this is it isn't something that will likely click right off that bat. They might know that a Dictionary is a hash table and they might know that hash tables are unordered due to the nature of how they work but the question of "are Dictionaries sorted" may not make even the best make those logical jumps without experience. 
Oh that sounds easy then. /s
&gt; Why don't you just stick to relevant questions to what you guys actually do? Well that's the thing. Dictionaries are one of the most fundamental data structure developers will be using on a regular basis.
OP should find a tool to show him the command line of the dotnet processes so he can identify what they are doing. They could be part of the build process as mentioned or something else; the command line can help identify them.
&gt; Let them make the implementation, if they choose a dictionary for it, then it's their choice to handle the problems with it. Well that's the idea, isn't it. They make the implementation, I'm not forcing them to use anything. To be honest they can even solve it with LINQ in 8 lines of code. I'm not sure what you find misleading.
40 years of c#, or does it just seem like it?
Experience. Not c#, duh. 
This is already a pretty clean approach IMO. What bothers you about it?
I beg to differ. I haven't used a Dictionary type in 7+ years because we have ICollection types combined with Linq.
I don't see it being that hard, there are plenty of games that have changed rendering engines, it's just making sure everything draws correctly (unless they completely tangled the code with directx, which is still possible, but much more annoying)
&gt; No dumb ass If you can't behave with basic civility, I would say you should be excluded from the interview process AND from this forum.
Usually when I say something is "hard" in programming I just mean it takes a lot of time or trial and error, not necessarily coming up with something completely new. 
I think I just misunderstood the question, I thought it was looking for the first word that has already been seen, not the first word that is also used later. So if the string is "blue red red blue", the second red would be the first repeated word. In that case you can just check to see if the word is already in the list before you add it.
I don't think it's unreasonable to state that most 5+ year experienced developers should know that hash tables aren't ordered. That said, in no way does my previous statement mean that it's a good idea to ask candidates this question directly in a yes or no form and automatically fail them if they get the answer wrong. Interviews shouldn't be about rote memorization, and they shouldn't be designed to intentionally trip up candidates with weird questions that create an environment where a qualified candidate doubts their own abilities simply because they're uncomfortable. Interviews should be the opposite of both of those things. You, as the interviewer, should be able to ascertain what pieces of knowledge a candidate has or doesn't have from watching them work through an exercise. And your exercise should be structured to put a candidate at ease, rather than making them uncomfortable. This particular question is a bit of both, but it's borderline on both, so I'm not surprised to see differing opinions here. It falls slightly into the "rote memorization" category and the "trick question" category purely because it *looks* like a CS fundamentals question on the surface, but it's not a positive affirmation question in which you're asking a candidate to confirm something true that they've explicitly learned, but rather it's a negation in which you're asking the candidate whether or not they know something isn't true that they probably never explicitly learned *because* it's not true. That is to say, I would definitely expect an experienced dev to be able to talk about the advantages of a hash table, but to be perfectly honest, I find it hard to justify faulting somebody enough to fail the interview simply because they're not as comfortable refuting false statements about hash tables. I would expect most experienced devs simply haven't even *considered* a hash table as being possibly ordered, so while yes, I'd expect them to come to the conclusion that they're not ordered given time to think, I would also expect that question to be much more uncomfortable to answer in general, because it's a question that causes you to doubt things by its very nature. If you absolutely must use a yes/no question as a pass/fail filter for candidates, at least make the question about something that isn't such a fringe use-case, like the look up time.
It's more than just DirectX. See https://github.com/dotnet/wpf/issues/48#issuecomment-444198305 &gt; From a technical standpoint, WPF depends on multiple Windows components: D3D (DirectX), DWrite, User32, GDI+, WISP (Touch), and several others (including Windows Runtime dependencies). The interaction with these components is complex, critical and not architected with cross-platform in mind. As a result, our focus is on completing open source of WPF and bringing it to parity with .NET Framework.
It's misleading because the question is wrong. It's just completely wrong on so many levels. It sounds like they have to implement a method that takes a string and returns the first non repeated word in the string. The implementation is up to them and need not involve a dictionary at all. The only thing you should be concerned about is if it returns the correct results and if the code is readable. You shouldn't be dictating certain data structures inside of the method. If you must, you can ask how it could be more efficient, but unless it needs to handle that kind of volume it probably doesn't matter. Whether a dictionary is sortable or not *has nothing to do with this task* unless the candidate chooses to use a dictionary and can't figure out why the code isn't working.
&gt; Dictionaries are one of the most fundamental data structure developers will be using on a regular basis. I completely disagree. IList's (combined with Linq) are used in 99% of use cases, not Dictionary types.
One is sorted and the other is ordered 😜
Yeah and I hate to say this, but in the .NET world "optimal algorithm" problems seldom matter. Say your string parsing method is a little inefficient and it's slowing things down. Is that really the bottleneck, or is it that you're fetching 100,000 records from a service when you only need 25? I feel like a lot of people are optimizing in the wrong place.
You would had failed OP's test, because I don't think he knows the difference between a hash table and array... but even then, arrays are sorted by indexes!
In that context, yes, a developer with 5 years of experience should definitely know they can't use a Dictionary that way.
&gt; The implementation need not use a dictionary at all, unless you're specifying that they have to use a dictionary. In that case: why??? Exactly. Why the fuck would you ever need to solve this use case in the real world? This is why hiring managers are idiots. Just give a candidate a real problem with the expectations of it being solved with real code.
I would think of it as being one of those things you would quickly discover if it was important. I already know that there is OrderedDictionary but it has a performance cost. Unless I explicitly needed that functionality I wouldn't have known that except when it came up on the Intellisence.
A Dictionary isn't even the right data structure here. Iterate through the list of words, add each word to the set. If the HashSet.Add(word) returns false, there's your word. Counting is less efficient, and suffers from loss of insertion order.
"Should I expect the candidates to know that the Dictionary class is unordered?" This is the misleading bit. It seems that you expect them to use a Dictionary.
i dont think its a show stopper, and its a bad filter for a candidate. get someone to reverse a string without linq with some code on a whiteboard, now thats a great filter. the amount of people who cant do it, its mind boggling.
ah, fair, thought you meant hard as in so complicated it wouldn't be worth it. I agree it would probably take way more time than any one person would want to dedicate to it
Wouldn’t surprise me if a recruiter somewhere has asked for 40yrs of it though
I don't expect them to use a Dictionary. But most of them do, and when they do, a lot of the candidates assume it's preserving insertion order.
Enumerating the dictionary? I’m sorry but you’re misusing the dictionary if you’re enumerating it. You look stuff up in a dictionary, you don’t iterate through it. Wrong data type for the job.
It's in the comment. Don't bring civility into it. You were not civil you were self deprecating and demanding. I just bring that to the boil. You've brought nothing to this discussion. You don't deserve civility but you'll do well with some counselling. 
Hashtables aren’t sorted either; I thought a .Net Dictionary is a type-safe hashTable, whereas a hashTable is thread-safe...?
Well of course they don't have to use a Dictionary, but that's the most obvious way to solve this, so unsurprisingly most candidates use a Dictionary. 
Leave the optimizations to Moore's law, pls. /s
Maybe you should tell golang.org to update their web page, which has been ignoring errors from Println in their homepage example for literally 8 years.
Fair enough. That is a solution as well.
There is more then one way to skin a cat but one way is to use a ordered dictionary. I wouldn't say you *need* it. Just that it is used commonly.
Java has better profiling and debugging tools on Linux, and is more battle tested. Good to see .Net 3.0 adding stuff there regarding tracing though.
So reading through the comments I think the answer is no, but, if you're giving them a coding test where they're able to compile and test their code they should be able to determine there's a sorting issue and resolve the issue on their own (barring time constraints).
Haha yeah! Don't forget the obligatory bachelor's degree too. 
I'm trying to imagine why you're using all these key-value pairs. Where do they come from? If I'm getting a set of objects from the database, I'm either going to filter them before I get them with SQL or Linq before I pull them into memory or I'm going to filter them ad-hoc in memory with Linq, so that's 95% of my collections which don't need a key value pair. Then there are config files, web session and the like which use something like a key value pair in the background, but it's not really a dictionary. Probably Linq is more resource intensive but when you add in the overhead of creating the dictionary in the first place I doubt it's a huge gain except in the most resource intensive of scenarios.
FWIW I think the fact that dicts are sorted in php ("associative arrays") skews people's perception of how a dictionary should behave when they come to C# from php.
I think the fact that dicts are sorted in php ("associative arrays") skews people's perception of how a dictionary should behave when they come to C# from php. Good on you for not expecting this.
Dictionaries are probably the most used data structure after Arrays and Lists. What are you using to store Key/Value pairs if not a Dictionary?
I responded to CuttingEdgeRetro with more, but basically, what are you guys using all these key value pairs for?
It's perfectly fine to use an array's index over a typed key/value pair for paging.
When you don't need to iterate. Dumb structures like string, bool. Am I ever going to foreach or sort this thing? If no, use a Dict. That's what they're for. All I care about is the key and it's value. Anything else is YAGNI. 
FWIW I'm a .net dev with 5 years of OO experience (did only SQL previously). I'd have string.split . Then list.where(x =&gt; x.toupper() = item.toupper).count and said if count = 1 you win. (On phone ignore bad syntax) To really answer your question in general dictionaries to me have always been a "use if a value needs a descriptive key" aka dictionary&lt;name,weight&gt;. Otherwise use a list. I'd be more worried with the fact the candidates trying to do a one size fits all with dictionaries than anything.
With 5+ years of experience, they should DEFINITELY know this. Otherwise, they're going to use it wrong and put bugs in YOUR code.
Why is a dictionary the most obvious way to solve this? I in fact think it's the wrong way to solve this and if it's the obvious way I'm just an idiot I guess.
To be clear, this isn't a yes/no trivia question. This is part of a programming exercise which candidates generally solve using a Dictionary. But an alarming number of candidates "forget" that Dictionary doesn't preserve insertion order, and because of this, write an incorrect solution. So I'm wondering if I should either fail them based or that, or consider it's fair for them not to know.
Yes it's a coding test, and they do test their code, but the tricky part is that with small data sets Dictionary does actually conserve insertion order, which could make you think the code is correct. The problem is it's not *guaranteed* to conserve it in the general case (MSDN explicitly tells you that BTW). So generally the tests pass, but the code is actually incorrect.
If you use a List for this, you have to call `Contains` for every element of the input, which makes the solution quadratic. That's definitely a fail, especially candidates are told the "production" data set could contain billions of words.
What's the right way to solve this then?
This. Knowing some very specific piece of knowledge and failing them on that = you have failed as an interviewer. Everyone’s experience is different, core knowledge of the big things like this is what is important - some implementation detail - Google it.
Literally lost 3 hours to debugging / rewriting my code because of this. Realized i had about 11 dotnet processes running. Switching it off and on again did the trick but afterwards did what you did and just killed the processes manually. Bit of a bummer. 
It’s getting really annoying. I only notice when my MacBook starts getting loud!
I would, problem is this is a take home test.
So that makes this a little bit different. Sorry if I misinterpreted what you were saying. I'm curious though, did you actually compile and run any of these Dictionary solutions? Because as it turns out, while it's not officially supported as a feature of Dictionary, and it's certainly not a behavior that can be relied upon for production workloads, and nobody should ever *expect* this to happen, but... Dictionary actually *does* maintain insertion order because of the way it works under the hood, at least in the current version of .NET with basic algorithms where you're just adding and iterating items without deleting anything. Again, I'm not saying this is the right way to solve your problem, and it's certainly not something I'd ever want someone to rely on intentionally, because it only works by pure coincidence of the way Dictionary is implemented in .NET for the time being, but if these candidates are running their code and observing that it does in fact work as expected, it's hard to fault them for that. I thought the person claiming that on StackOverflow must have been crazy, so I tested it for myself and sure enough... class Program { static void Main(string\[\] args) { var foo = new Dictionary&lt;int, int&gt;(); &amp;#x200B; for (var i = 1; i &lt;= 20; i++) { foo.Add(i, i); } &amp;#x200B; foreach (var bar in foo) { Console.WriteLine($"Key: {bar.Key}, Value: {bar.Value}"); // wat } } } So then, I guess I'm not sure what to make of all of this. Yes, I would absolutely expect a 5+ year experienced dev to know that you shouldn't rely on this implementation detail that nobody should even expect in the first place. I'm curious why these candidates would even pick Dictionary in the first place if ordering is a concern, because as an experienced dev myself I know that Dictionary is good for fast lookups, but this data type wouldn't even occur to me for use in applications where preserving order is necessary. It wouldn't have even occurred to me to test this behavior if I hadn't seen somebody claim it on StackOverflow being met with downvotes despite the fact that it's easily repeatable. If you don't mind, can you PM me what the question is these candidates are responding to? Now I'm just plain curious why you might be getting so many dictionary implementations. &amp;#x200B;
Well you left out the billions of records part. Which if its smaller sets of data I'd argue readability and ease of understanding over performance since performance is negligeable. But yes if that is the case then a dictionary is the better option
Haha I've always blamed Omnisharp for that but after today I think I know what's causing it to fly around my room. Had quite a struggle as I was hooking up a Hangfire task to Rabbitmq and was pretty sure the code worked yesterday to find out it was this weird dotnet issue causing it to just not subscribe at all. 
I think that goes back to the question of whether or not knowing this info is really important, without any other context.
Love the speed that they are iterating on this, it's a very helpful framework.
Will investigate! Thanks
See I thought about this but it seems to be one process per “run” - will investigate more. 
In any case, I guess the dotnet/cli repository is a much better place for asking this question.
Cheers - will do - thanks for pointing me in that direction
Right, its more about knowing the characteristics of a hash table instead of whether the .NET implementation of `Dictionary&lt;T&gt;` is ordered. I'd take a candidate that could talk intelligently about the former over one that had the framework memorized.
Yes this is exactly it. Their unit tests pass because Dictionary in practice preserves insertion order, but the documentation says the order of enumeration is undefined. I posted the question [here](https://www.reddit.com/r/dotnet/comments/a3cy4y/should_a_net_developer_with_5_years_of_experience/eb5bnp7/).
Polished? No.
I think it depends on what you expect from the candidate on the position, how complicated the job is. If there's no rocket science, it probably doesn't matter. However if I need a really strong developer I will make sure they know the difference between the hash map and the binary tree.
Seriously. Half of this guy's responses are saying 'obviously' and 'of course'. Seems like it would be a real uncomfortable interview situation
I hope you're not responsible for interviewing candidates
And again, the code this calls is not open source. This isn't going to let you build or port direct, even if that was something anyone actually wanted to do. 
&gt; There is none.. You are wrong, there are at least two MVVM frameworks for winforms.
There is a free version: https://github.com/DevExpress/DevExpress.Mvvm.Free
If you're guiding them to use a dictionary, it's kind of a tricky or trivia question, if they're choosing the data structure, it would seem fair to me (if they're not sure about a dictionary, they should use something they're more comfortable with like a list). I don't think it should be a disqualification, but it's fair to use it as a data point when comparing candidates. Personally I don't use Dictionary too often so I might think to look up more details or I might assume you wouldn't lead me astray and go with it to save time (if it's a timed test).
And lists of guns? 
Mobile here so you get an idea without precise code. Split the string. Create an empty hashset of string. Foreach s in split, var isnew = set.Add(s). If ! Isnew return s. 
Eh? i said there is none in context of equivalent...("equal in value, amount, function, meaning, etc.")... Whether there is home grown frameworks to give you the pragmatic lense of MVVM in a technology never designed to adhere to the pattern is entirely different thing. MVVM was born BECAUSE of XAML... MVVM is born in WinForms because of the want/desire to adhere to the same same of MVVM in XAML... round peg, square hole + blow torn doesn't mean it was fit for purpose :) 
It would also be a huge amount of work and it won't be going into Microsoft's repo so whoever does it will have to maintain it on their own. That's excluding the fact that it won't look the same between those engines which defeats the purpose of doing it in the first place. Cross platform WPF is possible, but it's non trivial and of seriously dubious benefit. 
&gt; Eh? i said there is none in context of equivalent...("equal in value, amount, function, meaning, etc.")... MVVM is a design pattern, it is agnostic to the view technology. There are implementations for XAML platforms, but it is not a "only for XAML" thing. &gt;Whether there is home grown frameworks to give you the pragmatic lense of MVVM in a technology never designed to adhere to the pattern is entirely different thing. You can implement practically any design pattern in Winforms, WPF, or web (there are some MVVM frameworks for the web). All MVVM implementations for XAML (WPF, UWP, etc) are "home grown" frameworks too. &gt; MVVM was born BECAUSE of XAML... MVVM is born in WinForms because of the want/desire to adhere to the same same of MVVM in XAML... round peg, square hole + blow torch doesn't mean it was fit for purpose :) And MVC was born BECAUSE Smalltalk-76... :)
I find it a little ridiculous that to get c# support with IntelliCode, you can't use the VS Code extension and must use full Visual Studio. Anyone know why that is?
Let me send your comment to the team. Please be aware that this is still a preview. 
You're right, it is still a preview. Thanks for the response!
Are you saying that in regards to what your company does, specifically, or just in general? Because I rarely ever use Dictionary.
Overall it's easy. It's possible to program effectively without knowing anything about data structures or algorithms. To somebody who doesn't have classic education, dictionaries may not look like anything special, often instead just appearing as arrays indexed by a string or object instead of a number--no big deal! Being competent without figuring it out along the way wouldn't be too common though. Unfortunately recruiting isn't about finding a fair way to let in everyone who deserves it, it's about finding a certain way to exclude the people who must be excluded... some innocent victims(false negatives) will occur. It is possible to overthink the question though and get it wrong, without a definition of 'Ordered.' For example, let's choose a ill-defined word "Organized." Are Dictionaries organized? Yeah. Well if 'Ordered' doesn't have pre-defined meaning to somebody, they could get it wrong. Not to mention, if you squint hard enough, and you'll see it IS ordered. AFAIK .NET Dictionaries don't use randomized data structures (though those do exist--see skip lists,) therefore the internal order of a Dictionary is predictably determined according to the keys and the sequence of their insertion/deletion, as projected through multiple complex functions.
&gt; MVVM is a design pattern, it is agnostic to the view technology. There are implementations for XAML platforms, but it is not a "only for XAML" thing. No ..god no... https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel i remember its creation... (Product Manager on .NET team) &gt; You can implement practically any design pattern in Winforms, WPF, or web (there are some MVVM frameworks for the web). Any MVVM implementation for XAML (WPF, UWP, etc) is "home grown" framework too. and again..not arguing "can" it be done in other languages i argued the equivalency.. very important word the OP used in the title.. We're also talking about WinForms . pivoting away from this is moot (its like you're debating the existence of MVVM?) &gt; And MVC was born BECAUSE Smalltalk-76... :) &gt; &gt; I don't know if you know ReactiveUI (it is not the only one MVVM framework with winforms support), but it fits perfectly on winforms. It is one of the most used MVVM framework (Winforms, WPF, UWP, XamiOS, XamAndroid, XamForms, etc) and the binding is created in code behind, not in XAML. Implementation... equivalent ... *the state or fact of being equivalent; equality in value, force, significance, etc.* .. XAML natively born to adhere to MVVM out of the box... WinForm.. after market additional work? what's not landing here? You're arguing the wrong context here mate.. its not "is MVVM applicable to other languages with additional work" ..the argument is what is the MVVM equivalent ...to which there are none.. **UNLESS** you go about architecting an entirely new framework to make the "pattern" work. It's worth mentioning the architects behind the implementation did so out of the need to demonstrate and articulate a shift in pattern behaviour to adhere to closer to the principles found in HTML/JS development at the time. Bare in mind, Sparkle UI etc were created as a way to bridge the gaps between Web Development and Desktop Development by re-architecting WinForms away from itself and instead adopt a more XML focused strategy that warms more towards HTML. The very existence of XAML nullifies your points... as it was developed to MOVE away from WinForms not towards it...ergo.. MVVM was that penicillin shot. 
**Model–view–viewmodel** Model–view–viewmodel (MVVM) is a software architectural pattern. MVVM facilitates a separation of development of the graphical user interface – be it via a markup language or GUI code – from development of the business logic or back-end logic (the data model). The view model of MVVM is a value converter, meaning the view model is responsible for exposing (converting) the data objects from the model in such a way that objects are easily managed and presented. In this respect, the view model is more model than view, and handles most if not all of the view's display logic. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/dotnet/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I like IntelliCode but do worry that it is one of the causes of what I call "micro-judder." Essentially second ish freezes when you're loading or reviewing code that seems to be caused by extensions generally. It is an on-going problem that the Visual Studio team seems unable to address (the "an addon caused an X second freeze" UI warning is at best a band-aid). 
Problem with tests, they may be really good at a section you are not. What if they had to use someone's CSLA retarded business objects at the start of their career. The ecosystem is huge. I find the best questions, is simple things like "what's your most used collection class, and why?" Find out how many fires they been through. Technical people show their knowledge if you let them. Written tests are good for wiping your ass.
In general. Look into any open source .NET project on GitHub. You will find that Dictionary is the second most used data structure not far behind List, irrespective of the kind of project.
If you have moved to the web, then desktop tooling won't be much benefit to you. However, if want to build a rich desktop application (WPF), or use RAD (Winforms), or build a windows 10 app (WinUI), then this is great news! .NET framework has always been a pain point in desktop deployment flows. Having the ability to deploy self-contained .net core desktop applications removes a major dependency requirement of the target OS. &amp;#x200B; The fact that it's now open source opens the discussion to millions of developers, freely able to fork and flavour their vision of the future of desktop. Perhaps someone would make a direct port of desktop to linux, unix and mac. &amp;#x200B; Who knows (and the is blue-sky thinking), a future version of Office would be built on .NET Core, selling to linux and mac markets. &amp;#x200B;
I would love to meet the team behind Intellicode one day. These folks deserve a round.
If peoe are failing your interview based on a trivia question then you are going about the whole thing wrong. 
Getting it to be work is a bit ugly with the VS install. I’m sure there is a better way, but you’d have to manually identify the tools. Linux is a bit better since it just relies on LLVM.
A developer w/ 5 years of experience should absolutely know this. A first year dev? Maybe not. Should getting this one question wrong automatically disqualify them? I don't think so, but it might make me ask more questions or ask them to explain their rationale.
 I know this is a long time ago, but does imagesharp offer a way to adjust the quality of the image to further minimize file size? If so I can't find it. but I may have missed it.
Well, one thing I am not a fan of is that I have to instantiate ConfigurationBuilder even though I might have configuration already set in my Startup. It is kind a duplication of code. I guess I can take configuration out of the startup and use the same instance in UseConfiguration
Great, thank you for the suggestions and the URL
unsorted and loaded
I imagine different developers work on each, and VS Code has a different userbase than VS so the priorities are different.
I chuckled.
Start by making it at least a little bit smarter. In the presentation it suggested the `Add()` method returning `void` as a suggested method to call when writing an assignment. That would have resulted in a compilation error. https://www.youtube.com/watch?v=SpP3Fwpvx9Q#t=2h11m 
If a person comes from computer science background and still remembers how hash table works, then he or she definitely knows that neither hash table nor dictionary guarantees the order of collection. 
**General remark about "programming questions"** The problem with that kind of question is that whether the candidate answers it right or not is beyond the point. If your interview for a 5+ years experimented developers is about such dry questions, then you are not doing the interview correctly. A better way to introduce the subject of collections is to give concrete minimal problems to solve, let the candidate propose a solution and then depending on the type of collection used do some follow-up questions. Especially, when his/her solution differs from the one you expected, is when you will see the real skills of that developer. Communication skill, human skill, basic ability to explain a technical choice, will to accept a mistake (in case the solution is obviously wrong) and to adapt to make a better version. Of course, it requires more involvement from the interviewer and also means you can't just sent a list of yes-no questions to a HR people. **Back to your original question** An experienced developers, as others pointed out, should know at least the add/insert or find/search complexity of most basic collection types. That said, candidates can fail for number of reasons (stress, not remembering that since dictionary are rarely iterated through completely) so would not consider it a critical failure. I would use a "mix-score-system" to treat that kind of home assignment: have a scoring based on the correctness of the solutions (i.e do they implement a working solution or not) + eventually extra points for using clear code (naming, comments). Then have a minimum threshold that candidate must pass, that is not too high but enough to skip the very bad apples. During the face-to-face interview, come back to the assignment with follow-up questions and eventually guide the candidate to fix the problems that were incorrect or sub-optimal. **Closing note** The importance of good interview is often underestimated by companies and/or recruiters. But if you don't screen your candidates correctly and hire people that either don't have the technical knowledge or human/communication skills, then you are at best wasting money and at worst jeopardising your projects. (reminds me that I have a candidate to interview tomorrow, so I should prepare) Good luck!
GRPC
ie. The order if the collection has not been defined and so it has no order... It is unordered 
Excellent. I've installed the 2019 preview now and will have a play around :D
That's faulty logic. The order being undefined *only* means you are not *guaranteed* that it is ordered, not that's always unordered. It's not the same. It could be ordered: * by coincidence, if the dictionary can be in any order, the ordered sequence is one of them. * the implementation changed.
A junior should know this.
\+1 for GRPC, great technology for efficient strongly typed RPC / Communication
&gt;Do they mean like an easier set up process for identity server or? Yes, today configuring identity server on simple webapi is way too complicated. And most configurations of it are similar, so it makes sense to automate generation of it for people who don't really care about details and want it to "just work".
Sometimes I think we are the only company around that doesn't do theater like that when interviewing. 
What are those pitfalls? I think blazor right now works pretty sweet already, am actually making a proof of concept application with it now and im impressed with what it can accomplish already.
Bundling the whole of .NET in the application. Everyone's shitting on SPAs today because of their size so shipping the whole of .NET with your app is a really hard sell and does not make any sense.
When I check my network tab it says the mono.wasm file is 1.83 mb and mscorelib + System.core are like 1.8 mb total as well. That is not that big right with everyone having pretty fast internet these days. If i remember correctly full angular is like 3mb or something.
So that's a really big bundle even in these early stages. Angular gets a lot of hate for its bundle sizes. Why should we be going backwards and making things slower? It's what .NET devs are hating Electron for and now we're contributing to that same mentality. Also, the whole argument for reducing bundle sizes was the exact opposite, that not everyone has fast internet and those that do don't have it at all times.
[removed]
Parameters are passed to a view components using an anonymous type, but on the received on the InvokeAsync method just like a normal function. It sounds to me that the navbar itself should be a view component, or at least the part rendering the list of Pokémon should be. Remember that part of the bonus of view components is that there is server-side code that goes along with them, which mean you can inject and access other services. If the three Pokémon being rendered are only for the current authenticated user, then can obtain that information and query your database inside the view component itself without needing to pass in any data. However if all your view component is rendering data it receives as parameters, then you would be better off just using a partial view.
Well, for starters, " Design a background service which will call a Rest api to download the data. It can be deployed to cloud." is not a user story. It doesn't even mention a user, let alone what they need the system to do. I'd say look up UML for information on design diagram standards, but it's hard to see why you would need UML to describe a process that calls a REST service.
Good point
I agree with /u/Mr_cochese that this is not a user story, but I'd probably ignore UML. It's overly complicated and comes from an era that you really don't want to revisit. That said, it's industry specific, so ymmv. Keep it simple. You don't need to diagram all the steps here, you're talking to developers not Rhesus monkeys. So take the steps first. * A background service (please define background) * Calls a REST API (please define which API, do we understand the data returned? Do we need to transform the data we send?) * Cloud deployment options? That's all you need. Each time you find a question, add the question. What is a background service in your parlance? Scheduled, a Windows service, a Unix Cron job? Some poor intern sat at the back who has to hit "query" once a second? Do you understand the API? Do you know what you have to send and what you get back? Which clouds do you support? Do you already have a deployment pipeline which will get your service into that cloud? For moderately complicated user stories I still use flow charts. Every business process can be defined as a set of steps with conditions along the way. As the story evolves you keep the diagram updated. If someone asks "what happens if...?", if it's not on the diagram you have to answer the question in a way it can be added. UML has a bunch of diagrams for OO, parallelisation and half a dozen others. Most of them are deprecated. Three problems. First, no one looks at the documentation, It's easier to figure out what's going on from the code, or asking someone. Second, no one keeps the documentation up to date. After a few changes the diagrams are deprecated. Third, they come from an era where some consultant suggested you could have one grand architect who would diagram everything and a bunch of code monkeys would turn it into software. If your user story doesn't fit into an A4 (Letter if you're US) diagram then you have more than one user story. If you have several user stories, that's a higher level diagram. But as mentioned above, post implementation it is really rare that they will ever be upgraded. The nice thing about flow charts is that the business will understand them. The business will not understand UML diagrams unless you explain it to them, and they will hate that. 
This is why hiring is busted. This is not that important and a quick msdn search shows the answer. Try using the Star method to determine their actual experience not just what a person can memorize 
WoOoOooow, so as a developer this is a very good news. But at the same time i don’t know now what platform to use ! Xamarin, WPF, WinUI ??? Any plans to make one unified platform to develop windows, mac, linux, iOS, android, and even Web (using webAssembly) ?
What platforms are you trying to cross? &amp;#x200B; If you know C#, [Xamarin Forms](https://docs.microsoft.com/en-us/xamarin/xamarin-forms/) currently does Android, iOS, and UWP. If your app is simple enough, over 90% of the code will be shared in the Xamarin Forms project with very-little platform specific code in each of your Android, iOS, and UWP apps. &amp;#x200B; If you know HTML/CSS/JS, you could also try building an [Electron](https://electronjs.org/), PhoneGap/Apache Cordova, Ionic, React Native, etc. app, which are basically different ways to make a web app that's packaged as an app for each platform. 
I'm already familiar with Xamarin Forms and have worked with it a bit. I was curious on the technical reasons why someone might suggest UWP be easier to migrate to something like linux than WPF would be.
You might try downloading something [Enterprise Architect](www.sparxsystems.com) or at least try looking at their documentation website. I tried this product not too long ago and found it confusing and cumbersome. In fairness I really did not put a lot of effort into it. I know there are many loyal users. Perhaps someone will post alternative products. I don't know of any BTW I don't know of too many companies who generate a lot of formal documentation anymore. Everyone is agile. 
XamForms supports Mac and even Linux.
https://stackoverflow.com/questions/8464677/why-is-jsonrequestbehavior-needed
Lots of really good tips here. Bravo.
Have you actually written C# before? Because this response tells everyone you haven't.
Glad you liked!
Breakpoint conditions are lovely, but really slow to evaluate. I always end up hard coding what I care about and then using `Debugger.Launch();`. A bit more work, but highly efficient. 
It always depends on what you are hiring for. If its a basic web app, EF, SQL server, ask questions related to those to understand how deep their technical knowledge is. For instance, in an environment that deals with a lot of datetime work for contacts, transactions, etc, an appropriate open ended question can be. Can a datetime be null? A) Yes (but how?) B) No (buyt why?) C) It's a value type, and those can't be null, so its default value is Datetime.MinValue when first created. If they answer something like A, I'm suspect, if B, they know about it, but can't, or won't, explain it. If C, they know some C#, or read wikipedia. &amp;#x200B; ALWAYS base your questions on real-life needs of your company and job(s). If you ever have to prove why a candidate was turned down, and your questions were not based on the needs of that job (you don't use an ordered dictionary often, or none at all), that could cause problems for you later down the road. (I am not a lawyer, this was taught to me as part of my degree program which included a class on HR) 
I like the title. Calling it *opinionated* sets the right tone for open discussion. I feel like with point #1 (use the CLI) it never really got to the "why?" I mean it showed that you can, and gave a basic example or two but doesn't do well in justify the value-add over e.g. Visual Studio which can accomplish many of the same tasks. I'm not even saying I disagree, just felt point #2 started before point #1 was made. Point #5 (startup errors) almost makes point #1 better than point #1 did. Point #3 was correct and I agree. I would have included a contrast with anonymous objects since they're extremely akin to a ValueTuple&lt;&gt; from a use perspective. In particular as you took the time to criticize single use Dto/return objects (which is good/I agree), just felt like a natural way to lead into talking about anonymous and their downsides (e.g. cross assembly boundaries, performance, etc). Love point #4. Great tip! Thanks. Overall very good blog post. Would read more. 
Do you have more information about App Insights? I have a hard time finding it useful. Great article! :-)
Same here, re: title. Too many people go ape-shit bananas over code. Although I'm sometimes one of those people, a purist, I try not to wax religious about code. But i cannot help myself. I think i need a code-psychiatrist sometimes but I have a few hard-core buds who help.
I turned on source decompilation because it seems like an amazing feature. I tried it on `List&lt;T&gt;.Contains()` and `Convert.ToBase64String()` and both of them produce files full of empty implementations, or `throw null` at the most. What am I doing wrong?
Please feel free to shoot me a message here or on my blog. I am always happy to talk about app Insights
Those are both framework assemblies so it might just be there is no metadata for them. For me, the true value is avoiding having to go to GitHub to look at someone else's code
Thanks and these comments are more than fair. I guess I tried to sell cli as "it is way faster to create and manage projects than vs" but failed on the value add. I can look to give more clear cut example. Good point as well on anon types. I was never a huge fan of them so TBH I just forget they exist sometimes.
I'm working on a .net core project, and I thought the architecture was such that the standard library was just made out of regular nuget packages. In any case, most of the time I'm going to nuget to look up source code, it's for an assembly inside the standard library. Oh well.
This doesn't really explain how the React .NET Core template works under the hood. It's literally "create new project, select the React template, OK see ya!"
.. and half of it is about webdev. There's other .Net developers you know. There's dozens of us! Dozzeeenss!
You're hired!
Just curious, how would you implement the question being asked?
I would say, except under rare conditions, Tuples should not be used past `protected` and sometimes `internal`. Never for `public` unless the idea of a `Tuple` really is what you want. There's so much shorthand for creating types these days, it really doesn't save much typing to use a `Tuple`.
I get that bar all the time but that's only because my workplace requires me to run McAfee anti-virus. It slows down everything massively while it scans. And then there's the McAfee bug that makes the "Attach to Process" dialog hang for like 10 minutes after opening before I can use it. Fun.
A whole lot of trouble just to save me having to type a few extra characters in a method name because the one I don't want is alphabetically higher and matches the first 4-5 characters. Was it worth it? I say yes. :D Looking forward to this.
Microsoft. Saving you from carpal tunnel one highly advanced AI model at a time. We don't know who you are. We don't know what you want. But we'll find you and save those hands. 😂 I could come up with more cheesy memes but I'm on Reddit. I don't think I should be doing this alone. 😂
I certainly learned something new. Reminds me that it's worth spending some time getting to know your tools in depth. &amp;#x200B; A question about tuples: What exactly is the difference between using a tuple and using out variables functionally speaking? &amp;#x200B; For example public static (int Min, int Max) ReturnMinAndMax(IEnumerable&lt;int&gt; numbers) &amp;#x200B; versus public static ReturnMinAndMax(IEnumerable&lt;int&gt; numbers, out int min, out int max)
Are you talking about Tuples, ValueTuples, or both? Regular Tuples were always an anti-pattern (.Item1, .Item2, etc wtf), so I'd go as far as they shouldn't be used *at all*. But ValueTuples where you can actually name stuff seem superior to anonymous objects, and save you from creating single-use return objects with just two or three properties within them. But as the blog post quite correctly says: Anything can be overused, and ValueTuples are no exception. When you start doing ValueTuple&lt;ValueTuple&lt;&gt;, ValueTuple&lt;&gt;&gt; you should re-evaluate, or when you go beyond three-ish returned items. I will say that it is definitely a stylistic choice. Some people really like unique objects for every single method call return, and I say more power to them. Just ain't for me. 
You're right. I was thinking old-school `Item1` Tuples. If you can name the fields, that takes away most of my complaints.
It only kinda works. It doesn't really seem to understand inheritance very well, and will take you to the wrong definition for the object. Right now you have three choices: - Commercial extensions (work all the time, but $$$). - ILSpy (works all the time, outside of Visual Studio, but free). - Source Decompilation preview (works-ish, but free, and built in). I think it is worth turning on, because *when* it works it is a time saver over ILSpy. But when it doesn't work you're no worse off than you would have been otherwise. Hopefully it gets improved. 
I learned by searching on Medium.com and checking out https://github.com/JasonGT/NorthwindTraders
&gt; No ..god no... https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel i remember its creation... (Product Manager on .NET team) "Model–view–viewmodel (MVVM) is a software architectural pattern." software architectural pattern = design pattern. &gt; and again..not arguing "can" it be done in other languages i argued the equivalency.. very important word the OP used in the title.. We're also talking about WinForms . pivoting away from this is moot (its like you're debating the existence of MVVM?) The MVVM equivalent for WinForms is MVVM.
\&gt; I guess I tried to sell cli as "it is way faster to create and manage projects than vs" but failed on the value add. The value add for me was easier build and publish scripts. Writing "dotnet build" in a folder is so much easier than trying to use msbuild.
Only one of the tips is geared towards web developers, the one about Application Insights.
Trying to automate build processes (back in the day) to automate builds was WAY easier if you knew the cli tooling. So, I would count that still as valuable knowledge because you never know when you might need it. It might be good to include that reasoning in the article.
Technically speaking? Nothing. I mean historically "out" used to suck because the syntax was painful but between the addition in-line variable definitions, and _ support, it isn't too bad now. "Out" is also faster than regular Tuple, but isn't faster than ValueTuple&lt;&gt; (roughly same speed). But I'd give the *syntax* edge to ValueTuple. As programmers we naturally get into the "Inputs on the right, outputs on the left" mode of thinking. ValueTuple plays into that, whereas "out" is kind of oddball as you're mixing in/out params on the right. I think "out" is easier to misread. So overall I'd say stylistic choice, with no "wrong" answer, but I'd have a slight bias towards ValueTuple&lt;&gt; due to the syntax. 
Thanks. Yeah I saw one of this talks on Mediatr and his github project. I looked through it and Jimmy's Contoso example. This client still hasn't made the move to core here but still wouldn't be too difficult to do the same thing with MVC 5. Most of the dev's here are still writing webforms applications with stored procedures :/ 
&gt; Regular Tuples were always an anti-pattern (.Item1, .Item2, etc wtf), so I'd go as far as they shouldn't be used at all . You can simulate named Tuples using extensions methods and anonymous objects: var tuple = SomeMethodReturningTupleOf2() .Map((item1, item2) =&gt; new { Name = item1, Age = item2}); if (!string.IsNullOrEmpty(tuple.Name) &amp;&amp; tuple.Ave &gt; 20) { // code } 
I learned MediatR about 3 weeks ago and I'm loving it. I keep my Controllers lean in my API project and put all my Biz Logic, DTOs, and Validation in the same Command or Query class in the Application project. It's the perfect separation for me.
By using a list and linq GROUPBY.
ReSharper navigates to decompiled source and does it well
Anyone seen any docs for this? Does it add the option to the adding identity screens or is it somewhere else? Can't see to find anything from Microsoft part from the announcement. 
probably to split the string into an array, and compare all values looking for a repeat in another index until you match the 1st one.
Thanks mate, good one. Would love more on application insights without azure - I always thought it was azure only. 
I tend to find people that favour CLI want to be seen as some kind of _real_ programmer. I grew up building ASM then C on Amiga and then later PC. I'd happily never use another CLI in my life if I can help it. I find it is just more stuff to learn that gets on the way of actually writing code rather than being getting out of the way (as it is usually sold). But whatever floats your boat.
They both use Json. This has been resolved; error in Web.CONFIG. Thanks for your feedback. 
There are some instances where they may differ &gt;You can't use the in, ref, and out keywords for the following kinds of methods: &gt; &gt; &gt; &gt;Async methods, which you define by using the [async](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/async) modifier. &gt; &gt;Iterator methods, which include a [yield return](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/yield) or yield break statement. &amp;#x200B; You can use tuples or valuetuples in these situations &amp;#x200B;
Exactly this. I can't believe it wasn't mentioned. All these CI/CD pipelines are basically just script runners under the hood. If you speak the language of the CLI, you basically know exactly what's happening inside your magic black box of a CI/CD pipeline. If your pipeline's pre-defined steps don't do exactly what you need, you know exactly how to build your own steps instead. When VSTS first came out it wasn't even hiding the fact that it was just a front-end for queueing up Powershell scripts, although nowadays it's far more polished and almost all the community made stuff is a first-party integration now.
GTK (linux) and Mac support are alpha level. There's beta-y support for WPF too, if you want to use that instead of UWP.
Thanks! I guess I've never tried to async an out or ref, but it makes sense that it would break since multiple instances could try and update the same variable. 
If you are asking about the feature that we discuss, then: it doesn't exist yet ;)
/u/TimeRemove mentioned all the points I wanted to mention. Good post, thank you!
this is so true
There is no "should". Every diagram should have purpose. System analyst can draw diagram (for example conceptual model) because in this way it can be easier to explain the business domain. Software architect can draw component or deployment diagram for developers that each of them will have higher level knowledge about system overall. UML is powerful but sometimes it is badly used - models are too big, too detailed and difficult to understand. Good diagram should be simple, has only important information and be easy to understand by target audience. In my opinion the most useful diagrams are: \- class diagram (conceptual model) \- component diagram (system architecture, logical view) \- deployment diagram (system architecture, physical view) \- activity diagram (for use cases, algorithms) \- sequence diagram (interaction between components) &amp;#x200B; There is special model for software architecture too - see [https://c4model.com/](https://c4model.com/) &amp;#x200B;
CLI can be automated far more easily than GUIs. Shell scripts to do A, B, C rather than writing brittle macros.
[removed]
Try using MimeKit and MailKit versions 2.0.7. Some people have reported a bug in the new (2.1.0.x) Connect/ConnectAsync logic that I'm working on a fix for.
The Connect/ConnectAsync code in 2.1.0.x is new and apparently has some kinks that need to be worked out in some situations. Try downgrading to MimeKit and MailKit 2.0.7 to see if that fixes things for you.
Yeah you’re on this loop so No gains here .. :face_palm:
I tend to find old-schoolers think GUIs are a godsend and think CLI is "just wanting to be geeky" despite the obvious fact that typing is faster than moving a mouse.
&gt;beta WPF, WinForms and UWP don't run on Linux and probably never will. You got bad advice.
Hello! I believe I've walked the same path you're walking at the moment, that is going from the repository patterns etc. to the using Mediator instead (and I couldn't be happier!). I've also done a simple BBS introducing the concepts to my colleagues and you can download it from [here](https://drive.google.com/open?id=1g0NJ3GJtXU8d9lanhW8_wY3PIgFaS--9). I defaced it in order to hide the details, like logos, so it looks rather ugly. And it also might be hard to understand without well.. the presenter, but I believe it got some valuable points that you can look upon in order to understand how to use it and why. I also advise you to look at the blog posts from Steven (dotnetjunkie) from [Part 1](https://cuttingedge.it/blogs/steven/pivot/entry.php?id=91), and [Part 2](https://cuttingedge.it/blogs/steven/pivot/entry.php?id=92) which in my case was what got me started with CQS. And just to finish it up, there are some remarks that I believe should be pointed out: * The Onion Architecture still applies since it's basically the layers/boundaries of your application, don't confuse this, you must avoid entangle them. * MediatR by itself is just a library that facilitates the usage of certain concepts, one of those concepts is **CQS** (Command Query Separation), if you understand this well then you're good to go. * Leveraging CQS with MediatR for me as an end result simplified dependency management, simplified the introduction of cross-cutting concerns, modularity of the developed system and a overall better understanding of the intent of the application by the team as a whole. If you've some other question in the meantime feel free to ask :) **TL;DR**: Search and understand **CQS** and you'll understand MediatR.
We're at the early stages of microservice work, but I really like the idea of a meta repo that can checkout and build and start all the services in different repos. It's a pretty cool alternative to having a monorepo. Will a future video go into the order mechanism? Eg. "Reserving" an item until the order is completed? This seems like a quite common and interesting problem to solve with distributed services, and I'm curious how it's done either transactionally or event based.
Ok how about you address that question?
They're different products so they would have different teams. Also, Visual Studio is written in C++ and C# while Visual Studio Code is in TypeScript.
Hey, in one of the future videos, we'll talk about distributed transactions using Saga/Process Manager. You can find the project created by Darek here: [https://github.com/chronicle-stack/Chronicle](https://github.com/chronicle-stack/Chronicle) and we're using it for example here: [https://github.com/devmentors/DNC-DShop.Services.Operations/tree/master/src/DShop.Services.Operations/Sagas](https://github.com/devmentors/DNC-DShop.Services.Operations/tree/master/src/DShop.Services.Operations/Sagas) &amp;#x200B; That would be a sort of "message router" (or more sophisticated structure, cause it can have it's internal state if needed), that will subscribe to particular messages and depending on the message it, it might publish a new message to the bus, call a complete() method or reject() (this is a global rollback implemented via compensate()).
Me too, I find the queries to get what I want in azure hard to write due to lack of documtation
One of the best articles I've read on here, nice work.
Nice, looking forward to it. I'm interested to see how the problem of overselling is covered with the eventual consistency model, so you don't sell more stock than you have on hand if two customers checkout the last item while messages are still being processed
Sure here is more information on app insights running on iis. https://docs.microsoft.com/en-us/azure/application-insights/app-insights-monitor-performance-live-website-now#monitor-a-live-iis-web-app
VS Code is pretty capable - [this extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode.csharp) will give you most of VS's debugging functionality with breakpoints/logpoints (conditionals too!), F5/F9/F10/F11 whatnot, the refactorings, blah blah i ramble, it's all there in the link :) Its intellisense isn't *quite* as good as full VS, but then i don't know how that compares to VS for Mac - and this will be changing when C# IntelliCode comes to VS Code. Give it a shot. Can't help with the VS for Mac issue unfortunately. :[
Those are in reference assemblies, so they really have no implementation. .net replacecs them with actual implementation in runtime
I use VB.NET at work as backend. Will this extension still work even though it says C#?
argh, now i feel like a twit ! Surprisingly there is no VB.NET extension i am aware of yet :[
oh well :/
&gt;dotnetjunkie Thanks for the post I'll read up some more tomorrow. &amp;#x200B; I did actually find something that is step by step but it doesn't replace any of your points about understanding why you are doing what you're doing. I need a firm understanding of this architecture before I attempt to explain it to anyone else :) &amp;#x200B; &amp;#x200B;
Closest I've found but not sure about some of the project structure. I know its just a small sample size for tutorial. &amp;#x200B; [https://thefreezeteam.azurewebsites.net/2015/08/10/building-mvc-jimmy-style/](https://thefreezeteam.azurewebsites.net/2015/08/10/building-mvc-jimmy-style/)
Two things: 1. What kind of telemetry do you get? Can you see hotspots and stuff like that? 2. I have seen the debug actions before but never knew what they did. Super cool!
I've experienced so many memorization candidates. I do my code question in person and as soon as they're about to start typing I stop them and ask "How are you thinking you'll solve this problem?" 1.) It let's me see if they're the type that thinks about the problem or if they just start coding straight away. 2.) Did they underatand the question? My advice to OP - write a unit test that presents the problem. Make a test case fail if you rely on a dictionary being ordered. If they fail the tests - it's more important that they can identify the problem and correct it (it is their code afterall). I don't care if you've memorized every nuance and method in the .net framework - if you can't use it to solve a problem - you're of no use to me. I'm interviewing candidates at 15+ years of experience and can't solve very basic coding tasks. Then they'll compliment me on how fun the test was and how much they enjoyed it.
I care
With app insights you get the following telemetry out of the box * Requests * Trace * Session * Performance * Page views * Exceptions * Dependencies There are others but those are the main ones
Yeah, considering it's opt-in, I personally think a compiler error would be more appropriate than a warning for the default setting.
The team has plans to look for matching implementation assemblies if it finds a reference assembly, and to find the real source for things that have sourcelink info (which would include the .NET Core stuff), they just haven’t got to it yet. 
Makes sense.
C4 model looks great. I was using flowchart to communicate my design for a user story. I was asked to present an architecture diagram. When someone asks for Architecutre diagram does that mean we need to show all of these diagrams or component diagram?
I didn’t even know about the Tuples in 7.0. That will be super useful. 
i use .net core in critical security systems. not sure why you’d expect the runtime to be less reliable than .net framework, since it’s built by the same people from the same codebase...
Well that would make more sense from not been able to find it! Thanks /u/piotrek1
That is undeniably true, what shell scripts do you use?
It's pretty much based on events, here's the basic sample: [https://github.com/devmentors/DNC-DShop.Services.Operations/blob/master/src/DShop.Services.Operations/Sagas/ApproveOrderSaga.cs](https://github.com/devmentors/DNC-DShop.Services.Operations/blob/master/src/DShop.Services.Operations/Sagas/ApproveOrderSaga.cs) &amp;#x200B; For example, when the Saga receives "ReserveProductsRejected" message coming from a Products Service, that wasn't able to handle "ReserveProducts" message (that was the first step), it means that a process has to be rejected, so it executes "Compensate()" and "RevokeOrder" command is being published.
Great work!
Been looking through mediatr recently as well. Found this really helpful: https://codeopinion.com/fat-controller-cqrs-diet/ Takes you through each step using the ASP.NET MusicStore sample application. 
It depends because formal "architecture diagram" definition doesn't exist. You have to ask what exactly someone need. I can only suppose that he needs see High Level Design of system - [https://en.wikipedia.org/wiki/High-level\_design](https://en.wikipedia.org/wiki/High-level_design). You can create component diagram with all main components, interfaces and relations between them and this will be big picture of your architecture. If it will be not enough, you can go deeper and create more detailed diagrams - for example Low Level Design - [https://en.wikipedia.org/wiki/Low-level\_design](https://en.wikipedia.org/wiki/Low-level_design). &amp;#x200B; But as I mention it depends what you want to show and what someone need to see.
**High-level design** High-level design (HLD) explains the architecture that would be used for developing a software product. The architecture diagram provides an overview of an entire system, identifying the main components that would be developed for the product and their interfaces. The HLD uses possibly nontechnical to mildly technical terms that should be understandable to the administrators of the system. In contrast, low-level design further exposes the logical detailed design of each of these elements for programmers. *** **Low-level design** Low-level design (LLD) is a component-level design process that follows a step-by-step refinement process. This process can be used for designing data structures, required software architecture, source code and ultimately, performance algorithms. Overall, the data organization may be defined during requirement analysis and then refined during data design work. Post-build, each component is specified in detail.The LLD phase is the stage where the actual software components are designed. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/dotnet/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I think [this example](https://github.com/jbogard/ContosoUniversity) of Jimmy's approach to Contoso uses MVC 5 and MediatR. I am all in with the feature folders/MediatR approach. There's so much less friction when you need to work on a specific feature and can easily find the relevant code (without hunting through layer upon layer upon layer!)
Nancy should work. actually, [here's a tutorial](https://github.com/NancyFx/Nancy/wiki/Hosting-Nancy-with-Nginx-on-Ubuntu)
Why Mono over .NET Core?
It is kinda harder to install in offline environments.
Because of nuget ?once your project is set up you boy need to be online to pull in dependencies. Other that that you don’t need to be online from my experience.
My thoughts exactly - i dont know what dev environment you are using (i use VS2017 on Windows and its great for local .net core support, and deploying on Linux). Im not sure mono has a lot of future now .net core is here - isnt that the future?
I don't have to create projects often enough to want/need to speed up this process. Are there other commands I should know for my day to day? 
EF Core 2.2 becoming more and more DDD-friendly. Excellent!
Yeah, it is great to see those improvements. 
wait for Valve to perfect Steam Play... 
I've just released 2.1.0.3 that will hopefully fix the last of these Connect/ConnectAsync issues (verified with another person who reported another Connect bug). I'd be interested in knowing if that version solves your issue as well. (Note: may take up to an hour to show up on nuget.org).
Hi, I'm not sure if your project can run on Mac. If I remember correctly, System.Web.DataVisualization is an assembly from full (Windows-only) .NET Framework, and isn't available in .NET Core or Mono on non-Windows platforms, because it has an underlying dependency on IIS.
From fellow redditor /u/kiteason You can also read it online at https://www.safaribooksonline.com/library/view/stylish-f-crafting/9781484240007/ (free 10-day trial available without credit card required) I have no affiliation with the author, just happy to see good F# books come out...
I have used just about every migration tool out there (for the .Net / SQL Server ecosystem) after 15+ years and there is only two I'd consider worth spending any time (or $$$) on. RedGate's migrator (which I haven't used in 5+ years so it could be crap now) or SQL Server Database projects (part of the SSDT tools in Visual Studio). They make ups AND DOWNS so much easier as they run a point in time diff and generate a script on the fly to adjust state as needed. Deploying DACPACs from Octopus or just about anything else is a breeze. They don't run into the same issues that most sequential migration tools run into, particularly if you're doing blue green deployments, so on and so forth.
I went to blazor.net to see what Blazor even is, and I got a 503.
I'm very interested in this as our team is talking about changes to our database deployment process. So are you saying you keep the database in a DB Project, but then also manually write the alter scripts that will be run with DbUp? As opposed to using the DB Project to generate publish scripts for you?
RedGate is working well for us for compares against source control as we had issues with the performance of the built in VS SSDT compares. We started using RedGate for automated deployments recently. The only complaint is you have to buy the entire toolbelt of tools when we really only want a few.
Had a feeling this would be the answer. Oh well.
No doubt, and good to hear that Redgate is still on top of their game. If I could quantify in money the amount of time the teams I've led including myself have spent wrangling EF migrations it would pay for RedGate licenses the rest of my life many times over, lol.
Great work, it's nice to see developers start building things with Blazor. It drives that even though it's still experimental, it is usable now. The link OP provided to BlazorFiddle provides the easiest way for someone to start experimenting with Blazor, before even installing anything in Visual Studio.
For those of you who haven't heard of Blazor yet, it's "a single-page web app framework built on .NET that runs in the browser with WebAssembly." It promises a brighter future in which we can write client-side code for our apps in C# instead of JavaScript. 
What's the difference between HasMany and OwnsMany?
Here is how it works for me: If my project is old 'db first' then I use DbUp and either write the migrations manually or use Visual Studio 2017's database diff'ing/merge utility. Otherwise if my project is 'code first' then I'm already using EF and will use it's migrations. I created a nice wrapper around DbUp so you can run it easily from the command line and pass in your SQL connection strings (same way you would use osql) and it works great.
Yes, keep database project in DB Project and manually write migration scripts with DbUp. Why not publishing just from DB Project generated script? \- sometimes it is impossible - for example adding new not null column without default value \- sometimes part of publishing is processing data (create, update, delete) \- with migrations you know which script was executed, you have kind of journal. \- publishing from DbUp is faster (there is no need to compare db project vs target db) \- SSDT works only with VisualStudio so you cannot use it on other platforms (Linux, Mac)
I just checked and it's working for me at least. As for what it is, it's "a single-page web app framework built on .NET that runs in the browser with WebAssembly." 
Did you attempt to make RedGate working with Web Deploy? Not possible (without manually script concatenation).
HasMany requires classes with an id property while ownsmany EF tracks the relationship using shadow properties. Which means you don't need to create a DbSet for owned types.
Thanks! Those are some good reasons to keep in mind.
Same here, I've been using VS Code on Linux since they announced dotnetcore version 1 and never looked back. As far as I can see mono is practically dead and it's only a matter of time before some madman patches WPF to run on linux and then there really is no need for mono anymore.
Yes, I showed how to implement simple console application which use DbUp in linked article. Paremeters for this application are path to scripts folder and connection string. But I still think that having db project also is very useful - you have some compile-time checks, IDE support (Intellisense), whole object history in source control in one file and so on.
My enterprise adopted DbUp for our International and other "cheap" divisions that aren't keen on licensing a vendor product due to perceived funding constraints. However, leveraging the marketplace for this isn't necessarily more expensive. RedGate's DB Automation (previously DLM) has been a robust solution that dwarfs the value of handwriting and maintaining DbUp &amp; SQL Projects. Coupled with Octopus Deploy, it's been an amazing transformation I wouldn't hesitate to evangelize to even the most cash strapped organization.
Thanks for your opinion. About Database project - sometimes is needed to modify some data during publish, add new not null column without default value, change columns types, rename columns. How you do it with DB Project? Is it possible and easy to implement? I mean in automated process.
Yeah, I didn't read your articles until now. Great minds think alike. I use WithTransaction() in my builder so that in the event of an error the script is rolled back.
https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/wcf-discovery
DBA here. I don't like fancy tools to generate and deploy SQL. Even the best of the bunch I have used (RedGate SQL compare) fails with some things and is not guaranteed to put your database into the correct state. Figuring out a bug in a load of generated SQL because it could not handle some weird situation is very time consuming and painful - especially if you are using the tool due to a lack of DB knowledge rather than just convenience (corner cutting). You should do your database changes in the tool built to do them - SSMS in SQL Server world. Creating a SQL agent job with the upgrade steps and scripting that out and putting it into source control will work fine for allowing each dev to run the full upgrade script on their own instance as and when they need to. You could automate the pushing out of the SQL jobs to each instance with a powershell script if you wanted. You could even bundle in the restore job so that you restore the lower version and perform the upgrade each day, this is great cause its thoroughly testing both your changes and upgrade path. Also don't use EF unless you are a very good C#.Net developer who is skilled enough at SQL to be a DBA. Thats unless performance is not an issue for you (which rules out any web app). EF is to databases as front page was to HTML a decade or two back. Appreciate its not a popular opinion on .Net orientated subs but you will struggle to find any SQL DBA who thinks highly of EF and does not have horror stories about the weird crap it decides to do. Bottom line in my mind is that if keeping track of what developers are changing in the database is an issue then you need to educate and deal with the lack of attention to the changes. You track and check in your .Net changes - do the same for SQL. If a new column is added, don't just add it via the GUI then hope your fancy tool can script it up later, that's a very cowboy approach and will catch you out sooner or later. One issue that I sometimes hear about is devs checking in alters when it needs to be a create so the script fails as its trying to alter an object that does not exist. In a newer version of SQL (2016 or 20178 cant remember, google if you care) there is the CREATE OR ALTER that is pretty nifty. But for those on earlier versions (like some of my instances unfortunately - product limitations) a nifty trick is to use the following pattern at the top your script: IF NOT EXISTS(SELECT 1 FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_NAME = 'PROCNAME' AND SPECIFIC_SCHEMA = 'SCHEMANAME') BEGIN EXEC('CREATE PROCEDURE SCHEMANAME.PROCNAME AS SET NOCOUNT ON;') END then your regular ALTER PROCEDURE statement, this makes it so your script will not fail on an instance where only half the new procs have been deployed. And make sure you test your deployment process end to end - you never want to be 3/4 the way through a upgrade to find you don't have the script for doing task XYZ ready and need to go write it.
Do you know if this only works on WCF services that are first setup to be discoverable? The first paragraph implies that. I have never setup a WFC to be discoverable as I didn't know that was needed. I thought there might be a way to get the list of available endpoints without making any code changes to the service? Maybe not.
Check your GAC if the assembly is in there. C:\Windows\assembly If it's there, look at its version and make sure your projects targets the same one.
&gt; Also don't use EF unless you are a very good C#.Net developer who is skilled enough at SQL to be a DBA. We employ CQRS in our apps, so we use EF only for write operations, which are always very simple operations. For reads we use dapper and write our own T-SQL. This way we get the best of both worlds.
Thanks for the words of experience! We are pretty heavily database-based with a great DBA team (I'm not one of them) and we actually follow this method almost exactly. Some people are asking about moving everything to SSDT, but like you, many others have their doubts.
You're able to drop to using a raw sql script at anytime for complex scenarios. However, we leveraged our pre and post deployment scripts for 98% of these scenarios successfully. With "new not null column without default value" there is an option to turn on "smart defaults".
It's the default setting.
It can be used in a good manner but you really really need to know what you are doing. The difference in skill levels between the entry point and being able to use it effectively is vast and its so easy to cause major issues. 
The first will be an entity that can be referenced elsewhere, the second not and is functionally part of the containing entity.
ServiceStack runs on Mono, although they also recommend using the .NET Core version if possible: https://docs.servicestack.net/mono
So they are discoverable by default?? Great! I'll give this a go. Thank you!
Thanks for your comment. Is there somewhere link to article where is described your approach with SQL jobs automation? I agree that EF should be used with caution. This is why I am using CQRS approach - microORM Dapper for reads (executing raw SQLs) and EF to writes (with DDD approach). As /u/jaynoj mention, we can use both methods effectively. 
Thank you. I updated to [2.1.0.3](https://2.1.0.3) and it did indeed fix the problem. I figured originally I was using the wrong settings or something like that which is why I didn't post it as a bug on GitHub. Thank you very much for following up with me!
I'm currently using Linq2Sql and I've finally started a migration to Linq2Db and I wrote a library that reads the .dbml file that Linq2Sql uses and it creates from scratch or updates an existing database to match the dbml file. It does it in two stages adding all the new columns, tables etc... in the first stage. Then in the middle I can write an custom scripts and then the final stage it makes columns not null, deletes or drops tables or columns or adds constraints.
GitHub has loads, although you will have to clone and run each repo you want to checkout
I hoped for something a little more centralized and organized. Do you, perhaps, now of any good repo to explore? I’m new to WPF and I wanted to see what nice things people are doing with it.
&gt;CREATE OR ALTER Whaaaaat. Didn't know! At a previous workplace, we would call a stored proc like \`dbo.EnsureExistence 'dbo.mystoredproc\` which would create an empty stored proc with dynamic SQL if the stored proc didn't already exist. Then we would always just use ALTER. &amp;#x200B; It would get complicated with functions, because you have to create the right placeholder function type (ie: scalar function, TVF, etc.), so we had to use another parameter to indicate that like \`dbo.EnsureExistence \`dbo.mytfv\`, \`TVF\` This is much better!
This: [https://github.com/bbougot/Popcorn](https://github.com/bbougot/Popcorn)
As .NET dev who frequently uses Entity Framework I have to make a comment; As the only developer on many projects EF suits me perfectly. It has up and downwards migrations and the average SQL output totally suits my needs. Usually making a migration and deployment takes me less time than reading your if not exits query. There are however a few catches: - Be sure to check your schema migrations. Not doing so had led me to truncating a table with +- 300M records. - Preferably only use C# to interact with the database. It'll keep your life simple. - Only optimize when you need to. As the only developer I only have so much time on my hand. I try to write fairly efficient queries in EF, however, I also got to know the limitations. In those instances I tend to pass some raw SQL through EF. - Do not inherit a legacy code base. This one is important. You can generate EF models from an existing database, but it will make your life more difficult if said database scheme is subject to change. Of course EF generated queries can be optimized in complex cases, but the tradeoff in execution time vs user experience decrease and development time increase is simply not worth it for me. I would argue most small to medium size applications would benefit from the decreased development time Entity Framework could bring. Besides that EF has the possibility to automatically run migrations! This is amazing if you have a local database to test on, but most of the time I also get away with adding a few fields to a production database, even if there are still instances of other versions running. This older version, as long as no fields this older instance queries are removed, everything will keep running just fine. Last but not least, do NOT hesitate to add an additional index if one of your queries requires so. You can do so both in EF migrations, as well as on the database directly. 
Excuse my ignorance, but can you explain DDD to me? I've heard it before and done some light reading on it but I still don't "get it"
No problem and sorry for the bad release!
It's a technique that aims to best represent a problem's domain in code. It tries to design code that reflects best the business problem it attempts to solve. In the context of EF, you want code that reflects business processes (i.e. add book to author) and not code that reflects the plumbing of DB schemas and your ORM of choice. The expected result is code where the business is as obvious as possible. There's a DDD mini book you can find on Infoq.com that is more approachable than Eric Evan's book but it's no small or simple subject. It impacts how you analyse, architecture and implement your app. But it's a great concept that may inspire you approach problems from directions you may not have concidered before. For example if you make a large store. You want to take care of recording orders (1 domain). In a small, simple app, if you are asked to add a reporting screen showing stats on sales (a different domain from the first!), traditionaly you would just query the tables you where inserting before. In a big app this may not work so well as millions of orders are made and need to scale. Plus changing how orders are made will impact your reporting and changing your reporting may need changing your ordering system. If you treat those 2 things as separate domains, you record your order on one domain with its own thing, you raise an event that an order was executed, listen to that in the other domain and store that in a way that's optimum for reporting. Yes its a but more complex in a way but in another, since they don't depend on each other as closely, it's more flexible and down the line may end up easier to understand and the code.
I think we can say the same for pretty much any framework out there worth using. That applies to Entity Framework, WPF, Web API, etc. 
All true. Some of the best technical interview questions are about the pitfalls of ORMs. ;)
I'm glad EF doesn't suck so bad that someone like you can be happy with migrations, etc. and all the other EF features that I will never actually use on a large customer app. But I gotta tell you, you do anything like that within a large, visible organization (think "enterprisey") and it's quite likely you would not be employed very long. I know this seems extreme, and you may very well be the very careful type who can prevent most of the problems that EF could create for you, but I don't want anyone to think that you can absolutely trust EF (like you said actually). Migrations and the like should be nothing more than a suggestion about what code you might like to run in a schema upgrade in production, for example. In reality, that schema change could be so time consuming to execute, that you may need your actual DBAs to get involved to ensure that it runs at exactly the right time and with the appropriate recovery measures in place to make sure the thing comes back online on time and with correct data, indexes, etc. There's a reason DBAs exist guys. If you're a developer who's serving as a part-time DBA, that's fine, but just know that your efforts only scale so far.
Actually, it was very unpopular in the late 90s, because it was released in 2002.
WPF is dead
Good to know. So, how am I going to write a more customizable UI except for WinForms? 
I don't think so, people are using it right now. As we have now lot of open source client side frameworks. Read more points: * Undefined Application Architecture with lack of Separation of Concerns (SoC) * Complex Pages with Performance issues * Lack of abstraction with least control over HTML * Limited support for testing and SEO * Lack of Reusability and minimal parallel Development * Learning Difficulties
/ 10
https://github.com/MahApps/MahApps.Metro/tree/develop/src/MahApps.Metro.Samples/MahApps.Metro.Demo https://github.com/MaterialDesignInXAML/MaterialDesignInXamlToolkit/tree/master/MainDemo.Wpf
Take a look at UWP - Universal Windows Platform. However, anyway, who needs a desktop app now? All is about web.
If you have some programming background, this tutorial from AngelSix is quite good. Goes into very deep detail on building an app. https://youtu.be/Vjldip84CXQ
Steven McConnell has an [article](https://blog.codinghorror.com/get-your-database-under-version-control/) related this, he mentions a Scott Allen [article](https://odetocode.com/blogs/scott/archive/2008/01/30/three-rules-for-database-work.aspx) that has three rules for db design: **1. Never use a shared database server for development work.** **2. Always Have a Single, Authoritative Source For Your Schema** **3. Always Version Your Database**
 ⚠ __VIEWSTATE exceeded max request length.
Honest question: Why would you use RHEL over Aspen for a Docker base image?
Let's define terms: - **ASP.NET**: An application framework . It still exists and still highly popular. Used by: - **ASP.NET MVC**: Still exists. Still highly popular. - **ASP.NET Web API**: Still exists. Kinda popular. - **ASP.NET Web Forms**: Still exists, fallen out of popularity. So when you're asking why something fell out of popularity I am *assuming* you mean Web Forms. Web Forms became popular for a short while because at the time you had a lot of desktop application developers who wanted an easy and natural path to web development. Web Forms allowed them to drag/drop components onto the web page, tie events without writing JavaScript, and even supported consistent state (which is odd, since the web itself is meant to be stateless). Essentially it was web development with minimum usage of the big three (HTML, CSS, and JS). Web Forms essentially offered "magic" but that magical abstraction was held together by silly string and good intentions. As projects grew developers would have to introduce more and more hacks just to keep things working, until eventually they would have been better off just embracing actual web primitives. Browser updates broke it *often*. Components as black boxes would break and you couldn't fix them. Page state caused performance issues. Single Page Applications weren't really compatible with the concept, and gaining traction. And once IE6 was replaced in 2006, even more stuff broke (particularly third party components). Contrast that with MVC, MVC largely embraces the big three. Instead of trying to subvert how the web works and hide it from the developer, they take advantage of it. MVC allows you to generate server side HTML but that's it. There's no "magic" plumbing. The JavaScript libraries that ship with it (e.g. validation) are completely optional, and don't change how the web works or tie you into MVC specifics. And even the server side HTML generation is extremely flexible, many choose not to use the helpers (e.g. Html.ListBox()) and instead just write raw HTML (which could easily be migrated to another framework). MVC core takes all of the good ideas from MVC (and Web API) updates everything for 2016+, improves performance substantially, and completely drops outdated concepts like Web Forms. 
PowerShell kinda fixes that ambiguity by the naming convention. Still a bit of discovery to be done but discovery is made real easy now.
Usually people use RHEL for support. Almost everything you can get with RHEL is available elsewhere but they provide additional support that is valuable to someone running Linux in the Enterprise. 
I might be in the minority but I kind of enjoy learning the various js frameworks. For me, once I understood javascript well, it was pretty easy to pick up the various frameworks I've delved into (react and angular 2+ although I do hate working with angularJS). That being said, I love working with blazor so far and very much hope it gets official support from microsoft more so than being an experimental project. For production at an enterprise, id probably always just stick with jquery anyway unless I'm building a SPA or have some other special need for a full js framework. Just my 2 cents!
I hate giving this advice but, only way is just by doing. All the resources out there are garbage and haven't improved for a while. All the developers on my team have gone through the same song and dance. I don't know why, WPF/XAML is just a huge pain in the ass and most resources for learning it are antiquated (run away when you see anything talking about DependencyProperty). Make some small things that don't require much code (e.g. a calculator) and just google what you can't work out. Hopefully someone can prove me wrong and provide something that is well done and educational.
[.NET reference source](https://referencesource.microsoft.com/) has a really neat overview with easy navigation.
Considering what you said would you advise someone like me with just a moderate amount of experience with WinForms to stick with it or is there something better that WPF I should be on the lookout for?
I completely agree. I spent two years writing angular 2, 4 &amp; 5 apps with a dot net web api 2 backend only to struggle most days writing so much boilerplate code. We recently within the last 2 months made a switch to mvc asp net core and the whole team couldn't be happier. We develop enterprise level applications much quicker in just two months we've managed to write a very complex system that I would not have enjoyed writing in angular. A side note... Angular build times due to npm install on our build server we're outrageously high. I'm not saying angular is bad becsuse it has its place, I just don't think it's suitable for large enterprise level apps, but this just may be because we were doing it all wrong 
Good rant and agree that not ALL tech should be studied, learned. Some stuff gets popular for whatever reason but that doesn't mean it's right for all. Agreed, it IS difficult to keep up with all the latest junk but have to have the wisdom/ability to pick which ones will stick around. 
Did you not look at Vue?
No, WinForms is hot garbage and was deprecated forever ago for good reason. Learning WPF will at least give you foundations on how doing layouts with XAML should work which also lets you easily transition in to the UWP since it's the same things but with less convoluted control names. If you plan on making any desktop application of worth you'll want to learn WPF/XAML. I would suggest using Caliburn.Micro since it does a lot of magic for you when it comes to binding up a view to a viewmodel so you can worry less about learning that stuff and focus more on the XAML/design side of things. Unlike WinForms, WPF/UWP give you a lot more flexibility in making sure that your views (controls) are separated from the actual data side of it.
Thanks!
Have you removed Ajax/one page loading all together, or just replaced it with standard web methods loading partial views where needed? We're planning on building an application and I'm heading to just do core MVC and dapper, but since the data graph is so deep in some places we figure to do a lot of Ajax to load sub lists as rendered partial views. And sometimes my mind is thinking: this would be easier in angular/react
I'm all for not using dead tech, but WPF isn't one of those. Developers vastly prefer WPF over UWP. There *is* a grain of truth, that Windows developers migrate to web, but desktop apps is a business necessity. 
The truth is, angular put us off any client side frameworks 
We use standard navigation between main pages but use ajax heavily for loading in partials, it gives the site a much nicer feel 
My gawd, WHY? 
Because it’s common to take inspiration from the work of other, often more talented people?
I understand that for the hosting platform, like the machines running the OpenShift Kunernetes cluster itself, but within a single docker container I don't see going so far as to pull in that level of support.
Agreed but... r/woooosh 
I think the main advice I can give you is; don't feel too forced to manually write out every little thing, the designer window can get you far when it comes to layout, similar to how you'd make a WinForms app. Brian Noyes on pluralsight have some nice tips on how to use make xaml UI efficiently using Visual Studio Blend.
At my work, we never used Angular to begin with. We have evaluated it a few times but found SPA apps added too much complexity and ceremony for little benefit. Browsers have gotten so good, MVC apps are only slightly slower. We have adopted TypeScript because it is awesome sauce but no need for a full front end framework. Especially when all the devs are full stack. Keep it simple.
What are you using for front end JS instead?
Blazor will be the SPA framework of choice in the future for C# devs. I don't thinks SPAs are the right choice for a lot of applications, though, even if some companies are trying to shoehorn them. Give me a well architected MVC app over the latest JS cluster any day.
Angular has that problem. Look at Vue and see.
wpf isn't dead at all.
wpf is not as hard as people said. If you want, you can develop wpf apps like in Winforms, using the designer and events.
I've used Redgate: Ready Roll recently so can say it has been the best I've ever used. Especially with large teams. Integrates with Visual Studio very nicely. Has a lot of flexibility. I have not used the SSDT tools in a long time but since they are free I may try them. Have they gotten a lot better over the years? I haven't used them in a long time. 
What makes you prefer MVC over SPA so strongly?
The entire Microsoft ecosystem is an undulating, ever changing, seething hot mess full of traps and holes. Winforms doesn't get a lot of love but does work if you have something that lends itself to it. XAML/MVVM works OK but is essentially a bucket of parts that mostly fit, not an actual, polished technology. Think shopping at a flea market vs shopping at Amazon. Once you add in Universal Windows, a huge chunk of the API simply vanishes so you'll spend endless hours trying to figure out how to turn this-kind-of-thing into that-kind-of-thing because one object only works with "this-kind-of-thing" but another object you need only works with "this-kind-of-thing". I don't have any good recommendations for the Microsoft-world. I gave up and now use C, C++ and PHP.
I know JavaScript pretty well, made a lot with Angularjs (which I actually love haha), currently learning asp.net core, have made a bunch of sites with Python / Django. I can't for the life of me figure out the node ecosystem for react / Vue / angular. I guess I don't understand what runs where. Is it on the server? Or are packages just managed there? How do I create a backend in asp.net core and interface with it in react? Always seems like I have to install a bunch of extra JavaScript packages and I'm not used to that, having just loaded things via &lt;script&gt; tags for most frontend stuff. 
I couldn't agree more that it can be a pain to set up new clients with these frameworks (and I'll actually include .net core in that as well as I'd had way more issues with dependencies there than .net framework) however in my experience the vast majority of the headache goes away after standing up an operational skeleton for the project
I agree with 2 and 3 but #1 really depends on how likely it is developers will work in the same area. Devs with local databases may have to frequently do compares to keep it up to date when they get latest code. With a large database compares can be non-trivial as well as periodically refreshing the entire thing. This isn't a blanket statement again... it really depends. 
Well that's reassuring because I've spent a good 3 days (hobby project not work related) trying to follow different tutorials to set up an environment to build my .net core react site. So if anyone has any recommendations I'm about to give up. 
I've been pretty happy with Vue coming from MVC. Hot reload makes up a good bit for SPA overhead in my opinion.
&gt; UWP is dead in the water I haven't paid attention, what's going on with UWP?
(from a fan of both Mono and Core): * The binaries can be downloaded and kept local rather than using the package manager (if that's an issue): https://dotnet.microsoft.com/download/dotnet-core/2.2 * In order to `build`/`run` offline, you can use `--no-restore` to prevent attempts at pulling down nuget packages if you already have them locally. that's all that comes to mind regarding offline work. asp.net core is worth a (another?) shot.
My recommendation would be to build the react said that fetches data via a no parameter needed get request. Then get an operational controller going to support that one endpoint that maybe just returns "hello world". Then build out from there. Sorry for my poor advice if that's what you're trying already. Always helps me to break things into functional pieces 
Hurrah, something i have wondered deep in the night when others arn't around.Is it OK to skip Angular? I am using Core 2.1 and just some Jquery. Although I would like more client sided tools, and might get into React one day the MVC Scaffolding still turns out the pages I can work with easily.
No that's really helpful. I'd rather do it in an API way like you said. That's what I'm most familiar with doing in front end. Even my Django sites I'm moving to django rest framework. So I'll try this approach. Thanks!
Not much, which is kinda the point. I'm passing on third-hand information, so if you care about it, you should verify my claims 1. Not much developer traction. 2. Hostile app distribution. They want to distribute exclusively form Microsoft Store. Sure, *currently* you can distribute freely with Side-Loaded apps, but that's a concession to get more developer traction 3. Product-death. Developers are skeptical, because they've been stung from Silverlight and WPF. And so soon after WPF, they announce UWP? This is a big reason why develops move to web. 4. Xaml-yucks. People *tolerate* xaml. There's something weird about UWP's XAML, but someone else can talk about that better. Maybe it's related to Microsoft's own inconsistent use of Fluent Design?
I've used SSDT and actually liked it. Except you're tied to mssql right? I tried redgate trial and didn't like it. I think you can accomplish 87% of needs with something like DbUp (i've made PRs to their mysql implementation). In the end, just about anything CAN work if you allow it. DOWN scripts never work so I just don't bother with them.
Literally every single migration tool I know of can generate SQL for you to examine if that's a problem. You can always run it manually.
How is the development experience with Vue? Angular 6 + VS + Typescript + Webpack works.... but is cumbersome and slow. Is Vue any better?
Noooooooooooo. Throw your dbml in the trash and never speak of it again.
If devs are frequently doing compares, then someone REALLY screwed up or you app is literally just data. There is no reason you can't populate the data you need and reset it frequently from the migration scripts.
I really wish I had the energy to put into this thread.
All the thing Zeptobook said plus to many application with because RAD was used without understanding or concern Button1.Click += new System.EventHandler(Button1\_Click); Button2.Click += new System.EventHandler(Button2\_Click); &amp;#x200B; Insane amounts of viewstate and postback on every single control rather need or not. &amp;#x200B; Its unfortunate the harder and more aggravating or More code you have to write yourself the less shitting custom apps end up being developed
Yes much much better. Vue CLI sets up all the webpack and babel stuff.
Perhaps you're confusing Classic ASP with ASP.Net. ASP.Net didn't exist before 2002.
This is what I'm starting to move towards, I finally figured out it's much cleaner to use partials with ajax rather than generate html with javascript. It feels more in tune with the system as a whole. I almost wonder if it's faster for the end user, but don't really know how to effectively test it. Using Razor Pages, just figured out unobtrusive ajax with tag helpers. It feels pretty solid, especially for POSTs. I want to kick myself for using as much jQuery as I have in my last big project.
All of the SPA frameworks depend on Node packages, right? My friend who's working on an angular project created an empty project shell - it had 68,069 files in it. It was just a basic template with almost no actual business code in it. That is just nuts. From what I understand, most JS SPA frameworks are the same. I have another friend who does VUE development. When they first started they had a heck of a time because one of their webpack files kept getting messed up and it took them hours to days to get things straightened out. Just stuff like that. Especially though the dependence on all of those JS file that you have no idea who wrote them, what they contain, and what will happen if - GOD FORBID - someone pulls one from github and breaks the dependency chain. Or, like more recently happened, someone added malicious code to one that is used my millions of projects around the world
I never really understood what was so terribly wrong with MVC and jQuery that we had this immense shift to all these SPA frameworks.
Using Vue with vue-cli is about as easy as it gets. I am just using ES6 and my decent size project takes about 6 seconds to start up initially (npm run serve) and then on subsequent hot recompiles take 1 second or so. I'm using Vscode and there is some work to do setting up necessary plugins like eslint, vetur etc. but really only need to do that once.
Skip anything but Angular. I have 10 years of experience in JavaScript development. It’s marvelous compared to other frameworks. The only one that gets close to Angular is Vue. React is an overhyped “easy to learn trap” of frontend framework that is miss understood by frontend developers thinking they are doing more with less. Don’t fall for that trap! The advice I give to junior developers is to start learning Angular so that one day they can easily transition to full-stack development because of robustness of the framework and the thinking it requires you to apply makes you more closer to on overall full-stack engineer rather than frontend coder.
No, often the licensing isn't that strict. We had a virtual cluster on RHEL. They all pretty much clone out from a master. At that level there's no individual configuration other than changing the IP and hostname. It keeps things uniform more than "I need another Linux, let's pick a distro" and have Debian,Ubuntu,Centos,ect to run just a single server/app". That's the only reason. We actually dropped RedHat though due to them never following through with support and us supporting ourselves. It was good to have their name to make our customers feel like we had a support system larger than our selves. I have no ill feelings to RedHat though, we we're using RHEL in a way that was very new to them at the time. Today it's a different story.
You can drop jquery. If you use any libraries that depend on it, you can probably ditch them for something comparable that doesn't.
As someone that's worked with websites ranging from webforms, mvc, php, angularjs, jquery-only...etc Blazor is giving me a 'webforms' vibe, and webforms is a god damn nightmare of black boxes and hidden logic. Is it going to be different?
Do you mean AngularJS or Angular? AngularJS was amazing, and Vue is a 10/10 successor. But Angular is definitely not worth it unless you're working on absolutely massive applications.
I think the big challenge for JS right now is all these deeply terrible module systems. You spend way too much effort writing code and configuration to tell the system how to do its job.
People keep talking about Blazor like its magic and CSS/HTML/JavaScript won't be needed ever again. &amp;#x200B; But how in the hell do you style your components? Or client side interaction like modifying the DOM? &amp;#x200B; Someone get me up to speed.
I disagree...while it has a huge learning curve compared to 1.7, the architecture is great once you get used to it. Typescript is awesome as well as the cli...I find building components to be pretty fun and super quick, than juggling services controllers and directives. After a couple months, it hurts going back to js.
Whats the real life problem with the amount of files? Do you know how many files/classes get referenced when you run a .net application? Just because you don't see them, doesn't mean they are not there.
FWIW, for some projects I've added just vue.js (no templates) and I like it a LOT better than jQuery. I've had much success just adding vue.js to my standard .net stack. Just using it for binding json client side and it is MUCH better than using jQuery imho. You can have the best of both worlds...
Don't forget the original Active Server Pages (now called "Classic ASP") from the 90's: https://en.wikipedia.org/wiki/Active_Server_Pages 
**Active Server Pages** Active Server Pages (ASP), later known as Classic ASP or ASP Classic, is Microsoft's first server-side script engine for dynamically generated web pages. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/dotnet/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
If its any consolation, I've had that same issue. So have many other people I know.
&gt; miss understood My favorite pageant, tbh.
It's not just the number of files, it's the lack of a standard library.
Have you ever been to a spa? They're awesome.
You run the javascript using c#. So now not only do you need to learn javascript but you also need to learn blazers c# wrappers around javascript. Color me not impressed.
Are you trying to say spaghetti?
When someone says this all I hear is “I am done with JavaScript. I want to focus on Silverlight!”
http://i.imgur.com/afbrac1.gif
Agreed. On top of the obvious performance and UX benefits of Angular, it's also a a great way to "force apply" SOC to your frontend.
The build toolchains seem to be what you take issue with, not the notion of a SPA. 
I have nothing against the concept of a SPA per se, as long as the business case makes sense. It's the implementation of the current frameworks that I don't like. Plus the seemingly ever-changing landscape means that no SPA application will have a useful life cycle beyond a few years. Maybe fine for some things, but entetprise apps need to last a long time. How many orphan angular.js apps are out there, and who wants to work on them? No, let's upgrade them to angular whatever so they will be up to date. Money wasted because you aren't adding value, just updating the code.
I am now.
Ultimately, it's a massive maintainability improvement for me. All the Webforms legacy I've worked with looks like it started out ok, then turned to an indecipherable mess over time as more and more developers' with varying levels of expertise and philosophies work on it. It's hard to see where the frontend ends and the backend begins (and vice versa). Business logic ends up scattered throughout the application. MVC only solved this in part with Razor, but the JS-parts can still get sketchy pretty quickly. Also it doesn't solve your colleagues randomly putting logic everywhere and stuffing everything in the viewbag. Angular forces you to completely separate front and backend, which prevents a lot of fuckery in the long run. Also there's a lot of obvious performance and UX-benefits. That said, I'm not a fan of node and npm, which seem to randomly turn into the ninth circle of hell if you change anything fundamental about your app. Mostly because configuring stuff is arcane to start with and seems to change with every major update. Also Karma and Jasmine are an attrocious way to test anything.
I also know that the libraries have been fully vetted by Microsoft and the asp.net community. That doesn't mean they are bug free but I don't have to worry about some developer getting tired of supporting a library that he's never going to get a dime for but is being used by millions of devs around the world.
I can't see anything remotely similar between blazor and webforms.
I read like 5 sentences of their site. From that it looks like a plugin-free solution. It appears to render web standards css, html, and js. So no prompts to install it on millions of people's computers. Change my mind.
I won’t try to change your mind OP, but it’s a good discussion starter. Silverlight was tied to XAML which never gained substantial mindshare. WPF/XAML is successful on the desktop but that market is a sliver of what it used to be. If Blazor ties itself to that technology, it’s only being setup to the take advantage of that segment of developers. Some may think that XAML is good enough to bring webdevs along and create a movement like Angular/React/Vue did. After all, TypeScript pulled it off, and wasn’t Reactive out of Microsoft too? I hope it doesn’t go that way.
MVC is a pattern. Not a structure. Web forms was using a mvc pattern if you can understand the fundamentals. It was just not ready-made structure by ms for you. You had to create some classes on your own. Code behind is here in both. If you call a c# method an event or a controller it doesn't real change what is the purpose of this method or how you can use it.
I don't know why we need MVC either, web-api with Jquery and underscore can do it.
SPAs frameworks usually solve a different problem than most people use them for. If your app is nothing more than CRUD with simple forms. Then yes, you might want to use a MVC pattern, since its a much faster way to develop. However, with SPAs, it is easier to build maintainable complex responsive UIs (desktop app experience) for web applications, where you focus on the client side. I don't want a front-end developer to run the whole .NET MVC project with Visual Studio, that instantly consumes all 16Gb of RAM just too edit some views. That said, SPAs do add boilerplate, they introduce a whole new problem like state management across the app. I think many people do overuse them for projects, where they could just generate CRUD app with MVC framework and have a working product. Also, if you build an app with SPA, there's a high chance, you can reuse most of the same components/code to create desktop app (with Electron.js) or a mobile app (React-native for example). You have a dedicated client-side developer in this case and a developer who builds a cross-client compatible API server, since MVC would only work for the web app, but if you wanted a desktop or mobile client, you would have to totally redo the server side.
&gt; Before anyone tries to suggest... We're not missing the point, that IS the point. Sure, the objective is the same, but the approach matters, and this approach is more likely to succeed.
Jquery + other libs like moment
Yeah, this. You can't decline to install the plugin or block it because there isn't one. Also, Silverlight had really shitty text rendering. Like really, really shitty.
Is angular the default for .net developers? I am just getting into .net(main stack is ruby on rails) . Our client apps are in reactjs. Angular I found too complex plus it's a language on its own. Reactjs had smaller surface and we are familiar with js easier to learn and use.
Thanks to TypeScript, I enjoy doing front-end more as well to be honest. Yes, things can be a hassle to set up. But it is totally worth it in the end. 
.net core webapi for backend and create-react-app for front-end client. Use axios/fetch to call your webapi url. Say from App.js(or .tsx) componentDidMount just to get started.
I found a place using telerik kendo UI and have since migrated to a couple other places also using it. .net helpers on the pages and jQuery and JavaScript for the rest. It wasn't that great 6 years ago but it's gotten much better and the documentation is pretty good and easily organized as well. I wanna do angular but after the 2.0 fiasco I pretty much lost interest in learning.
Those are the worst dependencies to bring into a project AMIR? I have had so many developers pull in weird GitHub packages that we have to try and support for years.
This is why I'm afraid to jump on the angular band wagon after the 2.0 release.
I feel like wpf has also been neglected and won't be supported for me longer. How would they ever bring that to .net core?
MVC + vuejs as MPA is godsent. No need to manage app states of SPA apps which can get complex. And no need to manually construct HTML syntax using jQuery.
They already have and it's now open source. https://blogs.msdn.microsoft.com/dotnet/2018/12/04/announcing-net-core-3-preview-1-and-open-sourcing-windows-desktop-frameworks/
I had the exact same feeling, that blazor will be like webforms in that it will detour you from learning the standards and lock you in custom MS solution than will be outdated oneday. &amp;#x200B; No, I prefer sticking with what is globally standard nowadays (react/angular/vue etc.) and evolve with them, so that I can be ready when the next wave of web technologies comes in. &amp;#x200B;
It's scary the amount of .NET devs that are terrible with front-end. Is everyone here back-end only? That's what it feels like. I'm seeing some comments hailing jQuery and backbone.js over the modern SPA frameworks, yikes.
I think the biggest difference is that Blazor is open-source and built on open standards. Silverlight existed in a world where closed-source plugins were the only way to bring alternative languages and runtimes to the browser. Just like Mono it's interesting tech and there will always be individual developers enthusiasts and hobbyists willing to work on it even if it never gets very wide adoption.
I bailed on being full stack when the javascript wars began thinking I'd return to it when the dust settled and focussed purely on the back-end stuff (C#, EF , webAPI etc.) and while Blazor does look tempting I'm still not convinced that it's going to rule the world and make all the SPA frameworks obsolete. It's an exciting technology and definitely tempting for someone like me but like someone else points out down below it still has a hint of the Silverlights about it to me and I don't want to hitch my wagon to another experimental tech that shows a lot of promise but ultimately ends up in landfill. I'm going to keep an eye on it and play with it in my spare time but until it gets out of this experimental stage I'm not going to jump on it just yet. I spent far too much time learning windows mobile and universal to trust again so soon. I think I'm going to spend some time figuring out which of the javascript frameworks survived the last decade and learn those instead - if nothing else I think it would put me in a better position to incorporate Blazor in a few years if it does come out the other side by having a better understanding of what it's trying to replace.
&gt; I just don't think it's suitable for large enterprise level apps, What about jquery do you find more suitable to large enterprise apps than angular? Every large project I've worked on with jquery has been a confusing mess. I find the benefit of Angular to be the module/component/state pattern scales quite well on large projects.
 I had the exact same feeling, that blazor will be like webforms in that it will detour you from learning the standards and lock you in a custom MS solution than gonna be outdated oneday. ​ No, I prefer sticking with what is globally standard nowadays (react/angular/vue etc.) and evolve with them, so that I can be ready when the next wave of web technologies comes in.
Alpine?
Can you elaborate on the obvious performance and UX benefits? I mean I understand the client side rendering of html, but besides that? I never felt that MVC with Ajax was slow. Certainly it might be in some edge cases, but for 99% of what's out there, it seems perfect. 
Yeah I mean for hosting docker, the dotnet Alpine images are way smaller so they startup faster and use less memory and image size.
No, dont be writing that stuff when there are so many good js frameworks to pick.
Ive done mvc, razor, knockout, Angular 2+, react and played with vue. Ill take a frontend framework any day of the week, even react. Suck it up, learn some stuff and get in there, once you have done one they are all pretty much the same. Angular 2+ is good for a young team because it provides a framework, just suck up the boiler plate. React can turn sideways quickly. Vue, I hope I get to use it in a professional setting soon.
How is DependencyProperty antiquated? What is the alternative?
&gt; The entire Microsoft ecosystem is an undulating, ever changing, seething hot mess full of traps and holes. Wow that pretty much covers all the bases! Actually compared to the javascript world Microsoft is a walk in the park. Sure, things change and evolve but that is the dynamic nature of the business. What do you suggest as an alternative? 
I like sql, html5, jquery, css &amp; php. 
“Build a Web UI with C#”. Why why why?
I don't think the expectation is that CSS and HTML won't be needed. Components are actually written in Razor HTML. And they modify the DOM by re-rendering it in response to your events.
AngelSix's videos are absolutely fantastic. Skips no details, but somehow you don't feel overloaded with information.
Isn't backbone a good enough framework?
If you're used to loading JS with script tags, I can see why it would be confusing. Basically, instead of manually including a bunch of stuff with script tags you use a tool (webpack) that bundles everything into one (or a few) files to deploy. Script tags work well enough for the odd library, but it's a pain to maintain when you've got 10, 20 dependencies. It also means you have to take the whole package, even if you are only using s part of it. They also include all their dependencies - which means if they have common dependencies you're sending the same code multiple times. With webpack you can package up just the code you're using into a single deployment bundle. You can also minify it etc. The cost? Well, it takes 45 minutes to set up. If you're knocking out something quick it makes no sense. However, most the projects I work on last years, might have thousands of hours invested in them. What's 45 minutes in the grand scheme of things? If it saves 5 min of managing dependencies manually every week it pays off.
I've worked on plenty of out of date Windows Forms apps too though.
With MVC they're probably doing so little DOM manipulation, and all of it local and self contained it's probably not too bad. Angular would be a terrible choice because it's designed for SPAs. 
It's great for a full SPA, but it's not a rendering library like Vue or React. It's a full MVC style fronted framework. I.e. don't use it if it's going to be fighting with server rendering, you'll have a bad time.
Okey, so how do I download the packages by hand and where do I put them locally to make dotnet to find them? Can I store packages in the project folder? How can I initialize a project from some template when I'm developing on offline computer?
Nothing wrong with sticking to asp.net core mvc. For me it's far too early to consider blazor. Maybe in a couple of years.
I use react and angular, both with typescript. To me the differences are pretty negligible except my angular production size is generally larger. I enjoy them both. I don't know what you're trying to say about doing more with less really.
&gt; I'm seeing some comments hailing jQuery and backbone.js over the modern SPA frameworks, yikes. Depends on the scope of the page. Frameworks like Angular, Vue, etc are great because they track page state and allow state changes to auto-magically flow down the page, but pages built with them also perform really poorly, particularly with a large amount of tracked DOM. For example if you still support IE11 (which is anyone who writes software for government or large corps) you're often avoiding particularly Angular since the whole browser window will lock up when the page loads and Angular inefficiently calls circular events. jQuery gets a bad rep these days for no specific reason (except it is old?) and instead people just call npm, download one package with 10,000 tiny dependency libraries, and claim they're creating a modern website (with 1 MB of JavaScript and high CPU load/battery usage every time a letter is typed). Obligatory Netflix article about using Rust on a static page with no dynamic content: https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9 
yes because blazer is webassmebly in c#. other languages can do the same thing c# is doing, so you could have java or python or whatever that would end up working the same way. WebAssembly/Blazor will be the future for sure and it will kill the need for front end libraries like angular. but I think it will takes years to get there. Hell, I still have to support IE8...
The job market isn’t always going to cater to what we consider cool or fun technologies or even good ones for that matter. Putting all your eggs in the basket of a tech that isn’t even released yet and is likely years away from use in any professional setting just seems like a poor choice to me. 
Awesome! That's what I was looking for.
The -parallel option only says whether or not to use parallel build. There is no option to use parallelism in a single compile. https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/listed-alphabetically https://softwareengineering.stackexchange.com/questions/330026/is-there-something-that-prevents-a-multithreaded-c-compiler-implementation
Yes! I think the single most exciting option that becomes available is the ability to define a single interface, and then produce separate implementations for the client and server side. Shared model contracts, between the two, compile time checks, and even the opportunity to use shared serialization / deserialization implementations.
Gotcha. This makes a lot of sense. Can I bundle something with webpack then deploy it to a front end (think ftp or something) without access to server / node / CLI? 
Exactly my experience. And also we need to mention that AngularJS was buggy and had more memory leaks.
This is the correct answer. It would have been nice to have known this up front when I started.
I work on the front end and backend separate. I use vs for the .net core stuff and in a separate directory I use vs code for the front end and then I run them separately. If you're using create-react-app it creates your build and you just serve that from the .net core app in production. 
Sure, I've been a developer since the early 90s and I've done web development since the late 90s. I've worked on just about everything - mainframe cobol, ibm minicomputers with file based databases, desktop development, and web dev with CGI, asp classic, asp+, asp.net, and every version of JavaScript. We we're doing ajax back when it was still called XMLHttpRequest in 2000 and 2001. I'm right in the middle of converting a massive winforns enterprise app to MVC. One reason for the conversion, out of many, is the hard time they have finding good devs willing to work on it. With MVC we can slowly replace it piece by piece and not have any downtime.
Hahaha gotta love when there’s no errors and nothing is happening at all, and you just watch it digest away.
Not sure how you took my comment but I wasn't encouraging people to use front-end frameworks for everything. The example that I made was people suggesting jQuery is a more reasonable alternative for a SPA than a modern framework, which is insane. Just because the build chain is more complicated does not make jQuery an alternative. Of course if you need a few simple AJAX calls then jQuery is enough but that's not the use case for a SPA. I know simple libraries are a bad idea for a SPA as I worked with Durandal for a long time and I can not describe the horrors of attempting to mush a few libraries into a SPA to anyone that hasn't experienced it first hand. I haven't seen people hate on jQuery unless they've worked on a project when someone took it upon themselves to write the whole of Angular using jQuery, and those people have every right to hate on it.
What version of .net is this for?
Don’t forget - many .NET devs were monolith builders because the frameworks used to dictate that. By abstracting things like state (viewstate!), etc. ASP.NET made frontend development work like backend development. So, a lot of folks never learned, or are currently learning, the newer frameworks.
[removed]
Not sure exactly what you are asking. You can bundle something with webpack and deploy it to the front end - but you deploy it just like you would your "hand made" JS script file. In the end it just creates a javascript file just for you to include in your HTML file with a script tag - but instead of linking to all the dependencies (from various CDNs etc) *and* your own JS code in multiple script tags, you just get one "bundle.js". So, your HTML looks like: &lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://ajax.googleapis.com/someotherstuff.js"&gt;&lt;/script&gt; &lt;script src="https://ajax.googleapis.com/usefulLibrary.js"&gt;&lt;/script&gt; &lt;script src="js/script.js"&gt;&lt;/script&gt; Where you've got your custom code in `scripts.js`. It means the visitor to your site has to download a bunch of files from all different places - these CDNs better not change/go down or your stuff wont work etc. Though you could host them yourself if you wanted. With webpack, you have all your dependencies in a `node_modules` folder on your development machine, and your JS files `include` or `require` what bits you need. It goes through, works out what you included and compiles it all into a single: &lt;script src="bundle.js"&gt;&lt;/script&gt; It can also 'transpile' your JS files from more modern languages like ES6 to code more browsers will understand. Or typescript, which is great.
[removed]
Been watching his videos for a while now and can confirm! 
I don't think it's a great idea to have your api key on the front end. Any way to move that somewhere else?
While I don't care about the downvotes, I feel like their coming from people who haven't lived though a whole bunch of cycles of Microsoft promoting something as "The Unstoppable Wave of the Future" and then dropping it without a word a few years later. I'm just tired of it. 
I'm not sure what the -parallel option accepted by csc.exe does, but as far as I'm aware the only way to get parallel builds is via using MSBuild. What happens if you call the same csc.exe commandline but with -parallel+ appended? But I'd say that instead of spending your time buggering around with unknown options, you could be spending that time on fixing why your build fails with MSBuild parallelism...
That's just not true. There are plenty of (business) cases where a local standalone app is preferred. Desktop apps have much better performance than browser apps, can work offline and have the ability to communicate with connected hardware. Furthermore desktop apps are faster to implement. You can create a practical GUI complete with event handing in 10 minutes, and you don't have to worry about request handing, browser compatibility, or authorizarion, you can just focus on the functionality right away.
It's possible to use an arbitrary folder as a package source when you restore/build/run. You'd download whatever dependencies you need, put them in the folder, and then instead of doing a `--no-restore`, give it a `--source=wherever` A more "correct" way of setting things up would be a [nuget.config](https://docs.microsoft.com/en-us/nuget/reference/nuget-config-file#package-source-sections) file with a packageSource pointing at a local folder with your dependencies in it, then using `dotnet add package` but i was getting "no such host" errors when doing this offline. Initializing projects from templates offline isn't an issue as they're global like the SDK itself. Here's an example - the only thing i did online here was [download xunit](https://www.nuget.org/packages/xunit/) and put it in `c:\nuget` (my arbitrary folder for this) then disconnect wifi: https://i.imgur.com/UMJ8up1.png So: * Download your dependencies and put them in `whatever folder` * add a `PackageReference` for each dependency to your .csproj * use --source=`whatever folder` when you restore/build --- .NET Core is a bit of an adjustment, but it's worth it.
Antiquated probably wasn't the right word. I was trying to say it's one of those things that's a pain in the ass and generally you don't need to think about it for a long time. A lot of tutorials out there introduce the concept of it too quickly IMO and go way too far in depth when personally I think it's one of those things that come _much_ later in learning WPF and is a side note if you're just trying to use WPF to make your UI pretty. Especially in a world where there are libraries like MahApps.Metro that give you all the views you'd ever need, in my opinion all one should really learn about to get started in WPF is layout work, abstracting out a reusable view (say, maybe a pretty button) that you've made and placing that in the layout of an existing view. If I knew how to stop rambling, sometimes I feel like I should just go out there and make a "Please stop using WinForms: The starting guide to WPF" tutorial.
I feel you, it is a pain in the ass. While I guess it's a far too late and they've burned so many developers like yourself, the current MS appears to be getting their shit together and actually *groan* "empowering developers" and try to stick with a handful of good things and make them good. If they can't, open source that shit. I think a lot of the downvotes are because this post is just about trying to provide learning resources and you've used it as a platform to voice your displeasure with all of it but, at least for me, think it's important to see why someone refuses to use any of it anymore. No reason to push away those who have been fucked over and have an axe to grind, plenty to information to reflect on and use to help make the whole ecosystem better and get people's heads out of their asses. A lot of the things in all the standard library and WPF could really use culling, I guess that's what WinUI (UWP) is supposed to be but they really fucked up by making it all special magical sandbox land only. If reddit had a decent chat platform in it, I'd love to hear more about some of your experiences e.g. what was the last straw, what type of work you were doing, etc.
Yeah but you mostly end up staying away from that stuff. Using StackPanels/Grid and whatnot is pretty much all you need to do in terms of layout, the designer isn't really as nice as WinForms but WinForms also just works on the idea of "this control is anchored at pixel coords 420,69" and that's it.
The UX benefit is probably more obvious, and really - performance-wise - the difference isn't that significant. If you're comparing singular ajax requests from a static page there's no performance benefit at all, as that's the same as what Angular is doing. I do think sharing data between views, combining it with new backend data and manipulating it, all without ever loading a page is something special and in itself a performance enhancement (since pageloads will always be slower then active JS execution). So it's more the complete picture that feels faster and more reaponsive. Idk what to make of Blazor yet, but JS has been due for replacement for a good while so I'll give it a shot when it stabilizes.
Incredibuild, I guess? I have plenty of very stupid large codebases but compile times (thanks to incremental building) are still in the &lt;5s range. 9s if clean so, there might be some other things than looking in to parallel compilation. https://marketplace.visualstudio.com/items?itemName=pragmatrix.BuildOnSave You can use stuff like this so it's always constantly building in the background and hopefully isn't noticeable so you can iterate faster. Buuut, like /u/jonjonbee said, try and fix the fact it fails first.
Yeah? When was the last update? When were the last records in their blogs regarding WPF? The new UWP is developing only.
Honestly this was also my experience up to Angular 4 version in some cases, luckily from version 6 Angular could be considered mature enough, but the cherry on top is Angular 7 with Ivy engine which is the point Angular becomes without doubt the best frontend framework out there.
Agree WPF has been neglected for a very long time. Very long. However in .net framework releases after ~ 4.6 you see many improvements. OK *some* improvements. The visual tree in Visual Studio 2017 is marginally useful. And realtime XAML editing sometimes works! 
I wish you were joking, but it really does work occasionally.
I understand why you would feel this way. I invested a lot of time in Silverlight and it just vanished in a cloud of smoke. The other side of the coin is that we work in technology which changes day by day. Its just part of the world we live in. I also invested a fair amount of time in Angular. Like Silverlight it vanished also. I knew going into it that javascript frameworks are pretty much "flavor of the day" but the point is all technologies are subject to obsolescence, not just Microsoft's.
The solution builds it's projects in parallel if it can. It cannot build in parallel if you have 50 projects all depending on each other. Only when your dependency hierarchy allows for two or more subtrees. Most of the time long build times come from bad project isolation, not from the compiler bottlenecking.
With WebAssembly natively available in browsers (no plugin to install), anything Microsoft backs for .Net targeting WebAssembly is going to gain a decent bit of traction.
-maxcpucount doesn't work? Feel like I'm taking crazy pills suggesting it with all the other suggestions saying you can't but this has always worked for me
No version of the .net framework ever dictated monolithic apps. Developers built monoliths because they did not know how to factor out their business logic and write n-tier.
&gt; If reddit had a decent chat platform in it, I'd love to hear more about some of your experiences e.g. what was the last straw, what type of work you were doing, etc. The "last straw" was when I realized that I was around the 8th developer to be put on a particular MVVM/UW project (the others quit or were fired) and that it was just a giant sack of events and magic fudge factors that made it look like a tablet application, but in reality there weren't any humans that actually understood how the whole thing worked. Then I thought to myself "I'm getting too old for this shit, I should get out of here." Then I realized that I'd been saving for retirement for the past 35 years and that I actually *could* leave. So I walked into my boss's office, told him that I wasn't having a good time being beaten for not fixing his crap fast enough and that I was leaving. I picked up my keyboard and walked out the door. It was freaking awesome. Now I do consulting when I feel like it and take the dog out for hikes in the woods every day.
There actually IS a new Silverlight - it's called JavaScript. Blazor may not be the thing that replaces JavaScript. But the thing that replaces Blazor will. 
You have over complicated it. As a developer, you make what you yourself would be proud of and what your requirements are. Let marketing take the lead in reckless UI requests on their own.
If you want user experience guidelines, don’t look for what everyone else is doing, as following the crowd will make it tough for you to stand out from the crowd. Instead, flip that script and take a close look at what *doesn’t* work, and avoid that. One of the best guides to what doesn’t work (the bad bits of usability and UI/UX) comes out of the [Nielsen Norman Group](https://www.nngroup.com/). While the occasional article can indeed be subjective, and it’s principles be violated unter certain conditions, the vast majority of what they post as advice is bang on the mark and should be absorbed and processed as probably the best reference work on the subject that you’ll probably ever find.
Yes. True. But still am waiting for Xamarin videos that he is gonaa post? 
Yes, of course. But this is just demo how to create applications in Blazor. You can implement your own back-end that will proxys yout request.
Look at getbootstrap.com for some examples of the basics. 
You are at the mercy of what some middle manager read on a blog written by another out of work middle manager who wrote a shitty article about the obnoxious shit he sees on websites because he assumes it is an effective messaging tool that leads to revenue based on nothing. You don't want to do it, but you will be paid to do it.
The state management for me is the key. Whilst the Elm / Redux architecture is OK, it adds an insane amount of boilerplate and when you need to do complicated things with it I find it tends to become a massive pain. I'm slowly coming round to the idea that for frontend I'd rather use Razor (especially the stuff coming out in 3.0) with React components.