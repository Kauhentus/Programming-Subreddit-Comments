No. If you know ObjC, use it! I'm still using it because quite honestly Swift is not mature or stable enough IMO (I've only been programming for 40 years). If you are linking to C/C++ libraries or if there isn't yet a Swift native API, you still will get involved in ObjC. The former is why we are still using ObjC - there really isn't a lot of justification to switch yet - basically it's only a small part of UI in our Apps but the entire model is still ObjC/C++/C (because of legacy and complexity - doing numerical methods and/or custom IO makes no sense in Swift).
I don't run into to them that often but you have to code defensively to avoid problems. Because Obj-C will not blow up like many other languages when trying to call a method on null, you can have a harder time finding where something has gone wrong. Since the syntax changes seemed to be your concern, I just thought the first time you had a bug like that, you'd have gotten your time back. When having to code defensively, the time you forget a check is what comes back to bite you. With Swift you declare if something is optional and you are forced by the compiler to deal with that possibility wherever you use anything optional. I think this leads to better code. Swift's enum type is very powerful and has no Obj-C/C/C++ equivalent. Swift's C interoperability is fine but not C++. Really, Swift is a new language with some nice features that can help you write good clean code. Objective-C is a stable language and you can write good clean code there too. I think both will be available for long time to come. Some reading on enums https://appventure.me/2015/10/17/advanced-practical-enum-examples/ Good luck with your first app whichever direction you go.
No idea why you were downvoted. The majority of major companies still have their apps written in Objective-C, but Swift is being quickly adopted. My company wrote a decent sized app in Swift 1.2 and the migration tool (1.2 to 2.0) absolutely destroyed it. 
I wrote some socket (unix) server and client code using only swift. It was kind of a pain but it is possible. I was doing it to see if I could, so that's not a very business-oriented reason. 
Something that is acknowledged by Apple but perhaps not common knowledge: most of Apple's core products (OS X and iOS) are Objective-C. There are definitely legitimate technical reasons for this, but it's good to note that Swift is a very young language. The ABI is not stable yet, let alone the API. People that want to try something new and exciting may adopt Swift and it's a language that can stand on its own in many cases, but ObjC is still the king of Apple platforms. You can be pretty sure that a project you start in ObjC will be supportable for a very long time to come. Personally, I really like Swift but have no objection at all to using ObjC where it makes sense. Even if Apple re-runs the Cocoa/Carbon playbook, ObjC has plenty of time left. It was ~six years after Cocoa's introduction before Carbon started losing support, and existing Carbon apps work even to this day in most cases.
Hee hee, I helped some interns today: "You mean we're not supposed to put the '!' everywhere?" No, no child...
I didn't like it at first, and preferred Swift when I first started out iOS development but now I actually prefer it to Swift. There is a learning curve and it is rough around the edges, but it is flexible much more than Swift.
Agreed. ObjC syntax is cleaner and easier to understand than C++. C++ does seem like a collection of disjoint languages.
Apple is a much larger company than it was back than. They will move quickly to deprecate Objective-C. While it'll take time for their internal code to transition, with the community's help it won't take long - foundation has already ported with Swift 3. I think by Swift 4 ObjC deprecation may be real possibility. Swift was in dev 4 years prior to Swift 1 launching, so 4 years after launch is almost a decade of time for it to have matured.
Larger == Slower, I think just about everyone can agree with this. It's the reason we've seen so much disruption from companies like Netflix. Apple will move Swift forward, and it'll definitely be a major player in the future, but Obj-C isn't going anywhere, for a long time. Because of Apples size it's going to take a lot of time to move their apps over to Swift. From what I've heard they've only ported a very select few apps (i.e. WWDC app) to swift so far and even fewer of them are 100% Swift.
I've never understood the semantic distinction between "send a message" and "call a method". [Wikipedia's article](https://en.wikipedia.org/wiki/Method_\(computer_programming\)) seems to indicate that they're synonyms. AFAICT, this is just another case of Obj-C using Smalltalk derived terminology, and most other languages using C++ (Simula?) derived terminology. We say protocols, they say interfaces -- exactly the same thing. Is "send a message" versus "call a method" supposed to have some external linguistic difference that I should have picked up somewhere, that this semantic nit is useful to pick? 
Any reason to break the naming scheme? Also, consider doing it like ObjFW with a category on NSString which provides -[JSONValue] - much more convenient to use.
Unfortunately I only realised that the naming convention was wrong recently. However I do have plans to fix that in a future release with more features like prettyJSONString which is much more helpful for debugging. The methods are provided as categories (https://github.com/elliotchance/CollectionFactory/blob/master/CollectionFactory/NSString%2BCollectionFactory.h) is that what you mean?
What I meant is having a -[JSONValue] on NSString that returns an NSObject, like done in ObjFW.
I'm still not clear on what -[JSONValue] would actually return? I can't see any tests for it, can you provide some examples?
It just interprets the string as JSON and returns whatever object appropriate (array, dictionary, …)
I see, the method in CollectionFactory is [NSObject objectWithJsonString:] which returns a array, dictionary, etc based on the JSON value.
Nice, looks cool.
Thank you 😀
Awesome!
Looks good but would be much better if implemented as a pop over view controller. 
This was our first real project and we started it when Peter Borg abandoned [Smultron](https://www.peterborgapps.com/smultron/) for a while. We missed a small and fast text editor with syntax coloring. Later we decided to concentrate on [Wokabulary](https://wokabulary.com) and dropped support for it but we still get emails from time to time asking if we will release an update eventually. Now we decided to open source it, even if the code looks like it was written by some students without any clue. I still like what we did back then and I think we learned a lot about writing and releasing software. So many parts are probably more of an example how to not write code but whenever I find the time I want to clean up the messy parts, fix bugs and release new free versions.
I did not know about Fragaria, I will check that out, especially the file handling. We didn't use the Smultron/Fraise code but wrote our own line numbering, syntax soloring and we even subclassed NSTextStorage which suddenly stopped working with 10.7. So we didn't want to bother with fixing Smultron bugs and ended up with our own. Still the look and features of Tincta are heavily inspired by Smultron 3.5 (one could say, almost ripped of...) and a lot of stuff probably is handled the same way. Let me know what you think and thanks for the Fragaria tip!
For [Wokabulary](https://wokabulary.com) we used the Bridging Header approach. For iCloud syncing we had good tested code that works, so we wrote a wrapper with Swift around it and from there built everything up with Swift. This helped us a lot since it made the usage of the syncing code easier in the rest of the application and now, since we have with the wrapper a good API, we can replace the remaining Objective-C code slowly with type-safe Swift. It was definitely a nice experience and I would recommend this approach instead of a complete rewrite.
This is only interesting if it also contains macOS, tvOS and watchOS support. And it doesn't. So I'm not going to invest in getting to know a new SDK.
I know there are many other options, some more correct than others, but this one struck me as a really creative option, and I was unaware of the ability to use `(...)` and `@[__VA_ARGS__]` for a bunch of args. I was mostly looking for a nice way to do this because I have been doing a lot of OAuth stuff lately and sometimes I have to concatenate things, but in most cases I do use a `stringWithFormat` because I know I just need, for example, 3 different parts of the URL to POST to. Just thought I would share this since it seems like a really creative answer.
poor form to overload comma as it has a clear meaning in subexpressions. 
Where to begin. I don't mean to sound harsh but this code illustrates a lot of incorrect approaches and defines "how not to do this." 1. You need to implement this with model-view-controller. What this object should be is a controller and then have a view to display the interface components. As another poster wrote then it can be run as a popover correctly and you also don't have to worry about your background and all of this other stuff you implemented from first principles. 2. As a view, you don't use "init" as the initializer. You use initWithFrame: to set up your subclass. You'll have a starting frame to work with then. It's the controller that should be doing things like measuring screen size if necessary in order to set up your view, like if you needed it for whatever reason to cover the whole screen. Which you don't really because this should just be a modal type popover alert box. 3. There is no need to do things like call to get the main screen size within a drawing loop. You asked for that during initialization and the iPad is not going to change size while running. But inside drawRect: you should not be concerned with this anyway, you should be concerned with drawing the rectangle you've been asked to draw. 4. there is no need to implement hit detection like this is windows or something... you should be using the responder chain and gesture recognizers, but counting touches is not really necessary for a dialog box with a couple of buttons and then tap-outside the box to clear it. 5. I gasped in shock when I saw this going on in your drawRect: alertViewContents = [[UIView alloc] initWithFrame:alertViewFrame]; [self addSubview:alertViewContents]; And then about a thousand lines of buildup code. Why are you using drawRect to essentially build your whole user interface? This is for your init code. Furthermore you don't do layout in drawRect: ... you can override layoutSubviews and then do specific layout there. The current "correct" way to do this anyway is by setting up constraints, and you can do that in your init. if you don't want to do constraints, you can use autoresizing easily enough for this. If you don't want to do that then override layoutSubviews and lay your view out there. Without going any further... This is as an implementation, in fact "completely wrong." Your view really looks beautiful but what you're doing here is not code that should be shared with other people so as not to give them ideas on how to implement so poorly. This is a hackjob that maybe shows what you want it to do on the surface but is not going to play nicely with anything and has bombs waiting to blow up on people. As a beginning for you to fix this and do it right: 1. Split into controller and view, your view should be responsible for laying itself out and drawing itself. The controller should be responsible for managing the whole thing. Users will not use your view directly but will use it via the controller, so that is your point to put the external use API in. 2. Your view needs to have its tasks properly sorted out and put in the right places. Add all your subviews and blur effect or anything else you want to use should be in your init and get everything sorted out there. Decide what layout approach you will use, and configure everything in the init to be set up to lay out properly. 3. Don't depend on "iPad or else it's an iPhone" for determining space anywhere. You're supposed to use size classes. But at the very least do not switch on idiom to decide how big things should be. 4. drawRect: needs to be short, smart, tight and fast. Not filled with 90% of the baggage of your implementation. As a side note things like this are just bad bad bad code: NSClassFromString(@"UIVisualEffectView") != nil The purpose of this function is to load a class object that you are not aware of at compile time. So you can get a string from any input and then check to see if it's a class or create instances of that class and so on. Whatever code this was borrowed from looks to me like something someone intended to be portable between iOS6 and iOS7 and was cleverly trying to test what he was running on before he made decisions about using the class. The rest of this is not iOS6 safe I don't think so there is no point in checking this, the function is going to return a class every time. This code will not in fact even compile if the test were to fail, since it uses the exact class name at compile time after testing it dynamically to exist in the runtime. if (_blurBackground &amp;&amp; NSClassFromString(@"UIVisualEffectView") != nil) { UIVisualEffect *blurEffect = [UIBlurEffect effectWithStyle:UIBlurEffectStyleLight]; backgroundVisualEffectView = [[UIVisualEffectView alloc] initWithEffect:blurEffect]; Basically if you can type the class name in, and Xcode lets you compile it, then NSClassFromString is going to return a valid class. So this is completely pointless as a test. What it is doing though is just burning resources, it has to take a class name as a NS string, convert that into a C string, hit a hash table and look up the class at runtime then return it to you. For a test that literally never fails, it is just waste. So, with respect, you need to go back to the drawing board and study how to implement before giving your code out like this. 
I don't think I could live with one day of casting floats to ints in Swift. Deal with someone else's code with mixed floats and ints and try to extend it or fix it is absolute hell. In my experience this has always been religion-driven ("but this is correct!") and doesn't line up with practical reality very well. A lot of Swift seems like this to me. I read someone write "Swift solves entire classes of problems that I never had and doesn't solve the ones I do have" and that's how it feels to me. The only things I can see things like this really helping, is that Swift is going to allow people who are too stupid or too uneducated to code in ObjC or C or any of that other stuff, to get some reasonable minor things done. Ultimately though the language cannot make someone code properly and I think it's futile to be so microscopically pendantic on things that have not been problems for other people. Number of bugs in the last 25 years I've had converting int and double: 0. 
Objective-C is not verbose. This is a myth. What is verbose is Apple, and they are verbose because they inherited OpenStep and people followed its naming conventions to very bad results. The original AppKit, you would write something like this: id list = [List new]; [list add:[List new]]; id otherList = [list objectAt:0]; This became: NSMutableArray *mutableArray = [[[NSMutableArray alloc] init] autorelease]; [mutableArray addObject:[[[NSMutableArray alloc] init] autorelease]]; NSMutableArray *otherMutableArray = [mutableArray objectAtIndex:0]; So... it's not the language, it's the conventions they established about using them. One of which was to embed too much information about the parameters and what you wanted to do into the method names. The original things like "add:" or "insert:" were meant to be polymorphic. NSArray with these monstrosities like putting the word index in every time you have an index and continuing to hammer home that yes, the contents are objects by putting the word "object" in every method, this is what kills it and makes it hell. The reasons they did that when they made Foundation were to avoid overlapping with the original AppKit and also to enforce some things that were "new concepts" like you couldn't just stick a pointer into a List anymore. Not to mention the mutability/immutability. There is actually no need to insert a parameter name or a type into an ObjC method, this is a perfectly valid method declaration: - method:firstParam :secondParam :thirdParam; This returns an object and takes three object parameters. You would call this like this: [object method:p1 :p2 :p3]; It's completely concise. That things got so very, very bad in terms of the verbosity is *not the fault of ObjectiveC* but it is the fault of *bad conventions being imposed inside apple and then onto us.* They imposed so many bad conventions that they made a huge mess of things to the point that they believed they needed a new language to sort it all out. Some of those conventions then got embedded into the language. Some just now they are finally dealing with, like maybe it's a good idea to not continually repeat the fact that this is an index or this parameter takes an object? Some of us never adopted their stupid conventions so never had an issue inside our own code about it becoming illegible because it was overly verbose. 
"MVC stands for M(Mode),V( View),C(Controller)." It's "M(Model)", not "M(Mode)". A typo right at the start doesn't build confidence.
&gt; My understanding is that "send a message" makes use of a runtime, while call a method is set at compile time. Any language with late binding is going to resolve some method calls at runtime. In C++, for example, method calls on virtual classes are resolved at runtime, using vtables. Vtables aren't really that much different than the tables used to map Objective-C "messages" to function implementations. I went into more detail [here](https://www.reddit.com/r/ObjectiveC/comments/4f3f97/objectivec_id_data_type/d7xvcox), but Objective-C's "message passing" is basically just method calling under a different name (for historical reasons).
I added iOS10 compatibility and had to use the new openURL: method, I need to look at thr code to see what exactly I did. I think I just passed nil for what I don't need. Did you try that? Edit: I used empty dictionary for options and nil for completion handler.
[UIApplication openURL:] is not used for app network requests. It's used for inter-app communication. It explicitly takes the user outside of the app. For example, if I want to open an App Store page externally and don't want to use SKStoreProductViewController, or if I want to open a URL in Safari with system cookies (though SFSafariViewController is usually a better idea on iOS 9+). You're also confusing NSURL with the older NSURLConnection. This is not really relevant to what OP is talking about and that's why you're getting downvoted.
Hey there, I appreciate that you actually took the time to go through the code and lay everything out in this post. Just to keep things simple I'm going to make 2 clear points: 1. As long as it works, it doesn't matter how you made it or if it's perfect or not, my very first computer science teacher always used to tell that to us. To put that into context, FCAlertView was born for me to use it in my own apps, and it is functional after all which is **what matters**. You can go in depth as to how poorly it's written, but I didn't write the code for people to learn from it or for it to work flawlessly, in fact I'm not even an "expert coder", I'm an expert designer. 2. I open sourced FCAlertView because I knew others would enjoy a beautiful alert, which so far, hundreds of people have and I've received lots of positive feedback, not to say that your constructive criticism of how I should write my libraries is a negative feedback, that's not what I'm trying to get at. My point here is that if you believe you can write better code, please go ahead and contribute, that's why it's on GitHub the first place. With that said, I'm going to improve the code, as I have already based on feedback, however, my goal is to have as many people use this alertview, that simple. Thanks for using FCAlertView, Cheers!
&gt; As long as it works, it doesn't matter how you made it or if it's perfect or not, my very first computer science teacher always used to tell that to us. Your first computer science teacher was an idiot. Hate to break that to you. But you shouldn't spend the rest of your career emulating an idiot who says something as stupid as this. Because it "works" is a loose definition. You can multiply 10 digit primes by counting on your fingers and toes and that "works" too put it's not a good approach. In this case though: YOU ARE VIOLATING USE RULES You are improperly using the API. It is broken. It doesn't "work" because you popped up a window. All your code is doing is illustrating a vast and empty hole where there should be knowledge. I cannot communicate that to you any more than you can communicate the color yellow to someone who has black and white vision. I am telling you as someone with 27 years of ObjC experience and who has written a million lines of code, that this is not a correct implementation and shows a vast misunderstanding ... rather a vast lack of understanding of EVERYTHING that is going on under the hood. Your code does not need improvement, it needs to be deleted and written from scratch correctly. I do not exist to convert my billable hours into a line by line scrapping and rewrite of your code. You should be happy though that someone who knows how to do it right has at least flagged to you that you did it completely wrong. You should then be opening books and looking at example code from Apple and reading tutorials and improving your knowledge. Then *you* should be the one to go and fix your monster and make it correct. I've pointed out to you several paths you need to pursue and what you came back with "hrmpf if you feel you can do better then go do it." I'm sorry I have a 350,000 line project of my own I'm working on and no time to fix your views. Lastly: if people who know less than you give you positive feedback all that is doing is telling you that people less knowledgeable than you are less knowledgeable than you. The visual design is beautiful. If I took a piece of dog crap and smeared it all over my wall and called it a masterpiece, with your sense of aesthetics you would say I have made a huge mistake. Me without any sense of aesthetics would call you an elitist jerk. You would tell me you're trying to alert me that there is a world of aesthetics out there I'm not aware of and that trying to paint by house my smearing it with dogshit is not the correct way to go about doing it and will have bad consequences later on. That is free knowledge to be had. If you're stupid you can keep your nose in the air and pretend that you're coding awesome out of the box here. But when you violate almost every directive that Apple is handing down in the correct use of their API, the evidence stands on its own just as much as 2+2 = 6 on a math test does, then the student wants to argue with the teacher and ask the teacher to prove he can do better. The teacher is staring at 2+2 = 6 and the challenge to do better and just turns around and assigns more homework. If you cannot even perceive at this point how clearly it can be improved to function correctly you have no business coding at all. You don't know what you're doing, and you will serve yourself best by reading and training and at the very least framing this around some example code. If you want more people to use your code then you should not be dropping shitbombs of broken improperly written stuff onto them. Learn to code it right so that your coding correctness matches your excellent sense of aesthetics. I apologize about the tone but your generation has received so many pats on the head and A for effort and idiot teachers saying "as long as it works, everyone is a winner" and it's not the case at all in the real world. Your code needs major work. If you want to be good at this, it's your project, to study, to learn, and to get better at. It's not for me or someone else to come to Yet Another Github Filled With Broken Crap and fix it. I'm already fixing the small amount of public domain stuff I absorbed into my real world project on a constant basis because of guys who know about 10x as much as you, but still don't know enough to make things work correctly. 
I'm confused as to what you are expecting. An Archive creates an .xcarchive bundle underneath a folder with the current date in the default location for Archives. "Release" is a build type, like AdHoc or Debug and is irrespective of whether you create an archive or not. What is it exactly that you are trying to accomplish?
I didn't explain myself properly; when doing a "Build" (not an Archive) I was under the impression a Release-iosphones folder would be created in the directory that's listed in Build Settings =&gt; Build Locations; it does and has always created a Debug-iosphones folder. 
Can't tell if joking or if unaware... Assuming unaware, check out NSMutableArray ;)
Dunno, but I'll let you know after I figure out NSMutableDictionary.
Android isn't that hard. Android Studio is actually nice too. If you're going to rewrite just make a native Android version in Java.
&gt; I do not believe in cross-platform solutions, they tend to introduce an extra abstraction layer that will have it's own bugs. I agree this is a bad idea but it's work. This is absolutely true. I'd seen this kind of thing create either crash-and-burn or generally poor quality products. Our solution is to spend extra time on design and make the parts of MVC better and separable. Especially the model (if it's particularly complex). Having this makes for better code-reuse either by reuse of actual code (e.g. C++ models) or by simply having a better worked-out MVC design which can facilitate cross-porting in multiple GUI systems. Since the GUI is what the user sees, not using the native environment is a recipe for fail. Of course, getting the design right before you code is still a rarity.
You are right, off-course it will be c# I learn.
Thanks for everyone's input.
my experience with Xamarin has not been very smooth. Its exciting to start off with a cross-platform solution but you eventually hit road blocks when working with lower level frameworks. 
Thank you for that, However, I'm very happy with the way I'm doing things. 
Well the best sources are Stanford lectures on iTunes U and BNR books. Like you said they are both at iOS 7 iirc. I don't believe you can find an entire iOS 10 tutorial with Objective-C but you can find solutions to your problems when you start developing. At least that's how it turned out for me.
I wouldn't. I have build an app in Xamarin before, but never could get used to the keyboard short cuts and the way code completion works inside Xamarin. I went back to Xcode as soon as the assignment was over. In my opinion Xamarin is a good tool if you're coming from C# and .NET development inside Visual Studio. In any other case don't use it.
The biggest issue with GNU in the past has been that it didn't keep up with ObjectiveC 2.0 standards nor the Cocoa upgrades. The first is just syntactic sugar (but very sweet sugar). The latter is often a deal-breaker in terms of porting and writing concise code. Don't know the situation with this version but I'm intrigued.
NICE! As a huge fan of Objective-C, and not one of Swift at all, its great to see this project. Hopefully this will keep it alive at least on Linux for a long time. 
ObjFW and GNUstep have been keeping it alive on non-Mac systems for several years now ;). It's not going anywhere, even Apple said that :)
Just FYI, the [new GNUStep runtime](https://github.com/gnustep/libobjc2) is MIT licensed. It also supports the Apple "modern runtime" features like non-fragile ivars, blocks, synthesized properties, &amp; ARC. David Chisnall, who is a Objective-C superstar and did a bunch of the early Objective-C work in Clang, actively maintains it (last commit was 3 days ago).
NSURLComponents is not what you're showing here. The components object is how you should concat the elements of a url not NSString. 
http://theocacao.com/document.page/194 NSString * path = @"/Developer/About Xcode Tools.pdf"; NSURL * fileURL = [NSURL fileURLWithPath: path]; NSWorkspace * ws = [NSWorkspace sharedWorkspace]; [ws openFile:[fileURL path] withApplication:@"Safari"]; You can leave off the 'withApplication:' to open it with the default application.
https://www.youtube.com/watch?v=WVBmPwAzARI&amp;list=PLFX_L6ozCM6cgKjBMEEfjawYM-8ugEIlE
IMO, businesses are looking to cut costs. Code bases on both platforms increases the cost of one of the most expensive parts. However, this can lead to a race to the bottom. At least two sides control this market and it we cut the number of devs needed by very much with all the new devs coming onto the market, we're only shooting ourselves in the foot. Look at what happened with indie devs and the app store. Devs shot them selves in the foot as fast and as many times as they could. An indie now has a VERY hard time to make things work. Indies are down to cheap ads and stiff competition as the market is past flooded. Most Indies would be better off with a reg dev job and that floods the very market that we should be owning. Devs screwed themselves by not holding a standard concerning price. If we remove Indie as a viable option, then remove dual platform and given the rush of people getting onto 'coding' ... pretty soon supply and demand will kick in and we'll be the shut out of the good market. On the upside, if you ever want to do Unity or some .Net, C# would be very handy. BTW, is this a Northern CA job?
I can't say I did exactly this, but my Objective-C was very rusty when I decided to pick up Swift. I think learning Objective-C is probably unavoidable to some degree. I found Big Nerd Ranch's "Cocoa Programming for OS X" to be a good introduction to Swift (I think there's an IOS version too). It really hits some of the big stumbling blocks. That said, it does treat Swift like an Obj-C alternative (maybe later editions don't suffer from this...?) For thinking about Swift divorced from Obj-C, try "Advanced Swift" by Chris Eidhoff and Airspeed Velocity(?) [edited for clarity]
I'd say check out some popular frameworks and look at their code for style guidelines. A few big ones are: * use camel case * Prefix classes with three letter identifier (not a must for personal stuff but good practice). For example, ```TMWMyClass``` vs ```MyClass``` * Proper verb tensing in method names (e.g., ```[someObj didReceiveRequest] // of type BOOL```)
No, is a Dutch company only in the Netherlands. 
Thank you all for your comments. It gave me the much needed insights and confirmed my own suspicions. 
WinObjC is nominally under development still. Plus it's specifically just for iOS. The best ObjC learning/coding strategy is to develop/compile under Mac/XCode and then port to projects like this once it's working 100%. That way you don't have two separate problems to solve: your code and the development environment code but only the former.
No, am a iOS Developer with over 7 years of Objective-C experience and been a Apple Consultant for over 20 years, with extensive *Nix server experiences.. For me personally I find it more worth to learn and use Swift and increase depth in the field of iOS native development then learning c# and using Xamarin. I do see a increasing need for automation in build and test environments. More in line of DevOps. And since I do have over 20 years experience in that field , for me at least, the more logical step to do.
My comp doesn't support Mac due to the motherboard
What the actual fuck?
Maybe the website's back end is written in Objective C? 
This has been up for 8 hours. Mods, do you need help?
Reported, it's obviously got sod all to do with Objective-C.
Anyone know, what's the plan for them to convert from ObjC++ ~&gt; Swift? 
&gt; But for the next 10-20 years, they will remain. And that will still keep job places for "not-hipster" developers. As I see, all my friends jump directly to Swift, calling C-based languages old-dated.
Often Apple comes out with great new technologies at WWDC, but sometimes they proudly announce a half-baked stinker like OpenDoc, Quickdraw GX, Quickdraw 3D, Newton, Dylan, Obj C Garbage Collection, etc. Sometimes the bad idea is gone by the next WWDC, sometimes these projects limp on for another year or two. Anybody who took the risk of adopting the stinker is out of luck, maybe out of business, depending on their level of committment. I have a pretty good track record of spotting the bad ones, and Swift has always smelled bad to me. It's half-baked, it's awkward, it's constantly changing syntax for no good reason. I broke my own rule of steering clear of the bad stuff and wrote an app in it, and everything was more work than it would have been in Obj C. I'm going to keep my Swift up to date just for resumé reasons, but I still don't believe in Swift and I still half-expect Apple to drop it at WWDC 2017 (or 2018).
What everyone keeps missing is that Swift isn't competing with Objective C, it is competing with C# and .NET. Microsoft is investing heavily in .NET for everything, *including for iOS/macOS app development!* It isn't about being superior, but about attracting developers to develop applications for their platform. Objective C has failed to gain any traction outside of app development, and with Microsoft's acquisition of Xamarin then Objective C does not even have a monopoly on that. Swift is nowhere near as good and mature as C# right now. But Apple will not ditch Swift because it is an important strategic asset in competing for developer mindshare.
This is a good point. Objective C was the language that everyone treated as ugly and one dimensional when I started writing it. There was no reason to learn it except for Apple. 
the same companies that still hire perl, pascal and other language devs because their century old code bases don't have anyone that understands and or rewrites them ;-p
Not before they switched it over to a shitty Java framework. It still lives in in some fashion in the GNUStep project, but it's woefully incomplete in comparison to WO 4.5 (the last Obj-C release) - I'm really hoping the rust ecosystem continues to evolve here, I'd love another close-to-the-metal web framework that doesn't sacrifice productivity.
Oddly I know quite a lot about this. QuickDraw3D had terrible performance problems in the persistent 3D object graph code. You could do a decent demo that just moved the camera around a static set of objects (e.g. a 1st person rollercoaster simulator, or "spinning" a complicated model) but if you tried to have the set of objects itself change from frame to frame the way they would in a game (e.g. a bunch of cars independently moving around), things would grind to a halt. During development they thought the bad frame rate was down to rendering speed, but when they got the hardware renderer working and the frame rate was still awful, they realised that they had problems.
&gt; Swift isn't competing with Objective C, it is competing with C# and .NET That may or may not have been Apple's intention with Swift, but it is most certainly competing with Objective-C. I'm guessing you're not an iOS or Mac developer, or you'd see quite clearly how Swift is taking mindshare from Objective-C in that group. More and more people are talking about it, releasing apps using Swift and releasing OSS libraries in Swift (and conversely, not doing those things in Objective-C).
Perfect sub for this. &lt;/s&gt; If only there were a sub that's more appropriate.
From the article: &gt; Objective-C is still a thing, though it’s slowly being deprecated by developers, anyway. Because ABI stability hasn’t yet been achieved within Swift, Objective-C will remain the language du jour for libraries and frameworks. Le sigh. That also means another year before Apple develop anything in Swift ¯\_(ツ)_/¯ Pushing tools they don't use themselves is strange. 
apple used swift the day it came out, e.g. the wwdc ios app is swift
More than strange - its incredibly irritating because clients are all demanding new development be done in Swift despite me telling them they'd be better off waiting. Still mucking about with the Strings api? Holy cow. I work in Swift every day. I hate it. I much prefer Objective C...which could use some love around making the collections more block friendly. I ended up writing categories to put the usual Smalltalk iteration methods on them and I use those all the time - but that should be in the standard library.
In the recent Chris Lattner interview on Accidental Tech, a lot of internal teams are chomping at the bit to use swift, but can't because the tooling support isn't there yet.
I'm curious as well ... /u/phuges, please elaborate. Xcode has become somewhat of a retarded sibling of itself since *&lt;insert a reasonable amount of time here&gt;*, so if there's a viable alternative out there, I will be happy to give it a try.
I have a lot of respect for the vim/emacs ninjas, but I'm *shocked* that Apple doesn't have a better IDE. I've only recently been trying my hand at Objective C, and boy do I miss Visual Studio+Resharper. At least there is AppCode.
Actually according to various WWDC talks, Apple IS developing/re-writing a lot of mainstream Apple apps and macOS programs in Swift. But the low level will never be in Swift - device drivers in IOKit are still C-based and/or lite-C++-based and I don't see that ever changing. 
Well, they can demand but it can become like "herding cats" if the performance and leadership isn't there. We still use ObjC for all new development because of these issues. We had to translate much of the new tutorials to ObjC from Swift to maintain "Modern macOS functionality". We make no apologies and don't take any guff from Apple employees about of apps: "Make Swift good enough to use and we'll switch; you aren't there yet. Period." Apple isn't helping but I don't expect them to - they are a large corporation and all act the same way as they are like oil tankers in terms of changing direction (which is a "feature" of hierarchies when you need it).
I don't believe that one.
What don't you like about Swift? I only work in Swift now and I'm generally very happy with it.
Its not Smalltalk? OK, that's my bias but Objective C is based on Smalltalk and Smalltalk is my favorite language ever. I would rather they spend time getting us [closer to Smalltalk](http://objective.st/Examples/), not farther away and closer to C++. Optionals are a PITA and now my code is littered with pointless unwrapping and tests tests tests tests tests and casts everywhere. If they really wanted to do something about nil - maybe they should make nil a global object that you can set and when it gets messaged you can decide how to handle the error (or ignore it). Leaves things in the hands of the programmer. Which, BTW, is also what Smalltalk does. Satisfying the type systems now takes most of my cognitive energy. I'm partial to dynamic typing. No introspection in Swift - still relying on the Objective C runtime to do anything clever. I came up with C++, I learned Java, I studied XML schema - I've concluded that elaborate type systems are basically intractable and cost more than they provide. So philosophically - I don't care for Swift's "viewpoint" and find working in it to be the opposite of enjoyable. I'm not nuts about the over abundance of punctuation (operators) either. I could go on but basically lets leave it at I like dynamic languages like ruby, python, php, smalltalk, json, and Objective C and I dislike the ones that are heavy on typing like C++, Java, XML, and Swift (which is taking typing to a crazy new level). Also, I understand that the idea is to create one language that can be effective for low level highly efficient code as well as high level more dynamic code. To me this makes as much sense as trying to build a flying submarine. If you want to be truly amazed - spend some time on the Swift Evolution email list and watch people argue about the correct type of an array index and shouldn't an index into an Array of Foo be a different type than an index into an Array of Bar or some crazy composed type notion. Architecture astronauts arguing about arcane type theory at a level of complexity that I can only grasp a fraction of it and I'm flippin engineer by training.
One guy made a [script](http://blog.timac.org/?p=1398) that loops through all the files of folder and prints the paths of all binaries found that use Swift for macOS 10.12.1 and iOS 10.1 filesystem O_o
You know that there are command line tools to do almost everything that xcode does except edit storyboards, yes? 
As a developer who loved working with GTK in the past, this is great! Too bad this is a wrapper to GTK 3 which became a mess compared to GTK 2.
There actually is a version of CoreGTK that targets GTK+ 2 if you're looking for that :)
Yep, you're right. Seen that after I posted the comment. I'll give it a try later today, until now I used PyGTK but I always wanted to go a little low-level from there.
 NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:url_string]]; NSMutableArray *json = [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:&amp;error]; 
i mean the code that goes into the class 
https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/DefiningClasses/DefiningClasses.html
Yes some classes are laid out differently based upon their subclass. For example a class that subclasses **UIViewController**, you will see something like *(void)viewDidLoad*. That is because it overrides the *viewDidLoad* method of the **UIViewController** class and XCode has placed that and other basic methods of the **UIViewController** class in for you. Now another class that subclasses **UIView**, you may see something like *(id) initWithFrame:(CGRect)frame* That is because it overrides the "initWithFrame" method of the *UIView* class. Suffice it to say, yes, many different classes are laid out differently. Most of the time when you create a new class that is sub-classing another class, it will pre-populate most of the methods (code) for you to fill in.
thanks 
WOW. That's so much less than would have thought!
Exactly. The developer community is moving towards Swift full speed ahead, much to my chagrin. There have been points of contention here and there (Brent Simmons and the dynamism discussion), but for the most part very few concerns. But seeing how little Apple uses Swift makes me question the end goal.
If you're going to do any real development this way I would (selfishly) recommend my project CoreGTK which wraps a lot of this for you in a nicer to use API. http://coregtk.org
It is...in that clients are demanding Swift even though they wouldn't know an int from a pickle. But I've done 3 Swift projects now and many more Objective C ones. Swift blows. The builds are slow. Over 1.5 minutes per code change to build and load onto a device. Objective C builds onto a device are maybe a dozen seconds. The debugger is slow. po swiftDictionary is nearly 10 seconds vs po nsDictionary at about a second. I can't work with that. Swift is a bad fit. The method call syntax is ass. Y didn't they just keep Smalltalk style message sending? I can work about 10x faster in Objective C than Swift and I won't have to waste a month a year updating my projects. From a purely economic standpoint - Swift is totally a non-starter. I've had enough of Swift. I won't start a new project in it and I'm porting anything Swifty back to Objective C that comes my way or simply turning down the gig.
Compare to [awesome-ios](https://github.com/vsouza/awesome-ios), `ioslinks.info` is really clunky and very closed sourced ecosystem. For example, why do I need a get started video to use the damn thing?!
Thank you for the feedback. You no longer need to watch the video. Just read the introductory paragraph. Awesome iOS is excellent. I use their data. But it is not an ontology. Let us compare [the Awesome iOS database category](https://github.com/vsouza/awesome-ios/blob/master/README.md#database) with the [iOSLinks Database Category](https://ioslinks.info/ios-database-libraries) Awesome iOS has 29 items in a single flat list. It took me quite a while to wrap my head around all of those libraries. In contrast iOS Links is a tree of categories, with no more than 7 items in any single list. It will very quickly make sense to you. And sure Awesome iOS will get better at managing their categories, but how many categories can they have on a single web page? Here is [one page](https://pythonlinks.info/zerodb-at-mit-gdc) from the more mature PythonLinks.info. It is 8 levels deep. And it includes a video. Can Awesome iOS do that? The great thing about having smaller categories is that we can add content to them. If you recommend any interesting articles, YouTube videos, or blog postings, I invite you to add them to the appropriate category on iOS Links. As the categories overflow, they will be further subdivided. Thanks again for the excellent feedback. Any other comments before I post this to the larger iOS and Swift subreddits? Chris
Oh, I know that for sure. I just have a love of retrocomputing as a hobby. "The path not taken," as it were.
I'm very interested in this too. If you find anything, please post it publicly. I do have a complete (paper) set of NeXTStep 1.0 books, but that's not really directly related to the ICPak libraries.
Minicode is too old Dude I think you need to install the library in the first error and the second one is a clang error idk why it is happening 
Dose anything work in this app I mean did you made an app using it or it keep showing errors 
Everything works except I get those 2 errors every time I try to compile my projects
Mantle &lt;3
close, but no cigar
Nice.
Cool video! It's pretty long in its unedited form, but for those looking for the Obj-C origin story, it starts at about the 30 minute mark.
Seems like an kind, affable fellow. Hard to believe he's the one who foisted such human misery upon us.
WTF are you talking about? This isn't Bjarne Stroustrup.
;)
On the other side, the didReceive will get a block that YOU must call as if it were an ordinary function, passing it an appropriate dictionary. Once you do, and it is sent back over the air to the other guy, his replyHandler will get called with a copy of that 'appropriate dictionary'. It is a contract - the communication channel will stall unless you call back. 
Good stuff. It would be good if you covered ARC and memory mgmt. It is something that AFAIK is unique to Objc. 
What would you want to see that's not covered in https://clang.llvm.org/docs/AutomaticReferenceCounting.html ?
&gt; https://clang.llvm.org/docs/AutomaticReferenceCounting.html Actual ARM assembly showing calls and something that isn't 25 pages of dense text.
Perhaps checking for unicode ranges (via `NSCharacterSet`) that has the Chinese characters in them could work.
Take a look at UITextInputMode. Have you thought about how you'd handle input with both Chinese and Latin characters?
https://stackoverflow.com/questions/4726593/objective-c-how-to-get-unicode-character https://stackoverflow.com/questions/6088241/is-there-a-way-to-check-whether-unicode-text-is-in-a-certain-language#6123254 https://stackoverflow.com/questions/34629460/how-to-detect-chinese-character-with-punctuation-in-regex
Thanks for sharing! Was looking for something like this last week. Ended up with a script generating the boilerplate .m files for Mantle classes from the header. I will provide some feedback when back from vacation :)
Nice that it might be useful to you. I covered only sufficiently for my use case, so I appreciate feedbacks and improvements 
First off, this is an awesome project, and thanks for your work on it! One question: a while ago I was messing with using ObjFW on Linux, and I wanted to use `OFRunloop` but was having trouble. I had to read the source to realize that `+[OFRunloop mainRunLoop]` will always return nil unless you're also using `OFApplication`. Any particular reason this works this way, instead of having the `mainRunLoop` method create the runloop itself if needed?
Thanks! :) Yes, this was intentional, as you cannot just create the run loop when mainRunLoop is called: It is by definition the run loop on the main thread. If you spawn a new thread and run it there, it will not be on the main thread. If you create it in the current thread, you will a.) never return as the run loops is blocking and b.) you still are not guaranteed it will run on the main thread as the call could have been from another than the main thread. May I ask why you want to avoid OFApplication? Many things assume one is in place. But everything OFApplication does could also be done manually.
I was trying to roll my own UI framework, and wanted to implement my own "application" class: my idea was to treat ObjFW like Foundation, and only use it for non-UI stuff, and I guess in my head I consider the "application" object to be a UI thing (the way `UIApplication` is part of UIKit, for example)
That is certainly possible: Just have your UIApplication (or whatever) create the OFApplication and set the OFApplication's delegate to the UIApplication. :) Rolling your own UI framework sounds like a very interesting project. I know that many people are interested in a UI framework for ObjFW. Is there already something published somewhere that you could point to, or is it still in the planning stages?
I honestly hadn't planned on publishing it, it's definitely still in the "just screwing around" phase, haha. I'll post something on Reddit if I ever have anything to show!
Please do! And don't forget linking to it in the Wiki! Many people are very interested :). There have been several GUI projects for ObjFW before, unfortunately none came very far. Including my own ObjQt (mostly due to being too busy with ObjFW itself).
If you don’t let the compiler implicitly create the ivars for the properties, you need to explicitly synthesize, e.g. @synthesize myProperty = _myIVar; in the @implementation.
When you declare a property simply, it just works. When you want to start using setters and getters, though, you need to either synthesize the ivars, or declare your own, so that you can manage the storage. If you were to synthesize `_assets`, you'd have a non-mutable array, and that might work in your case. However if you want to be able to do things such as add to or delete from the array, then you need a mutable array, and by declaring the ivar yourself -- without `synthesize` -- you can ensure the backing ivar is mutable. This means that what your user sees as a non-mutable array, but internally, within the class, you can use `_assets` as a mutable array. 
You don't generally need to explicitly declare the property var with Obj 2.0 (which is 10 years old now). Just @property and @synthesize. But if you skip the latter, you can see what's going on: you can access the property with a prepended '_' on the same.
https://youtu.be/rh8ZGBYvOxY
I don't feel like people are answering your question really. The '@property' part declares that your object has a method that will return a reference to an object of type 'NSArray' - note that it's not mutable. In ObjC, auto-generated properties will use the property name with an underscore as the local variable name to actually store that data. Normally, since the property was declared to be an NSArray, that is what objc would make for you. However, in this case, it's being explicitly created as 'NSMutableArray' This is valid because NSMutableArray is a subclass of NSArray. Put another way, it's an NSArray that can do additional things. Specifically, it can be rearranged and modified. This is useful within your BNREmployee class so that it can rearrange things within the array, but to the outside client classes, they will still only expect a plain NSArray.
C++ interop would be nice, but as you can include ObjectiveC in your Swift project it doesn't seem that big a deal to me. The others...most those things you should be doing much anyway.
I'm finally getting my feet wet with Swift by working with a pure C library. Swift syntax is fairly nice so far, except for interfacing with C. All of the circles that I have to run around to accomplish something that's otherwise trivial is quite frustrating. I use KVO quite extensively in Objective-C. It's quite nice. 
Suppose you have classes A and B, where B is a child class of A. In A, you might want to observe properties X and Y, whereas in B, you might want to also observe property Z. Since B inherits from A, overriding the observe method will cause A to no longer be able to observe X and Y. Therefore, you must use contexts to detect which value is being observed by who, and call the super class if necessary.
I'd like to add that you may not have the source to A so you don't know what properties it is observing. If you don't call super you're going to get a crash or unexpected behavior.
But since B only wants to observe Z, and not X, Y, then why would the X, Y be sent to B? Shouldn't it just be sent to A? 
B still has to forward X and Y to its superclass (A). Otherwise, since B's implementation of the method overrides A's implementation (as B is a subclass of A), X and Y will never be sent to A without using the `context` variable.
ahh thanks!
#6 write in a syntactically great language.
:)
Always remember to think about instances. A or B doesn't observe or get called, the instance of A or B do. So your instance of B, subclass of A, observes X Y and Z. The B code only handles Z and needs to call super to handle X and Y. Usually you call super for any observe calls your class doesn't handle itself. That way the superclass can me modified and add more observations and subclasses don't need to know. In theory, yes you could also pick a special context value, but for knowing to call super. What's tricky is when both A and B want to observe X! Better to switch to observation blocks. Use the system API if you don't mind keeping an observer object around. Alternately use a library which gives you some more convenience _(plug: like my cocoapod Panopticon)_
Fuck your tiny grey text. Use black text. I’m old. 
&gt; I’m old. Hi, my fellow Objective-C developer. I'm not being sarcastic; we obviously both subscribe to this sub! ;-) 
Well. I've been bitchy about the same issues in the past. Then I decide to take another look (after the last update and with the dual rev features, etc.). My conclusion is that the delta on ABI changes is clearly smaller this time - asymptotic? Maybe. Small enough of a leap? For more people, probably yes. For everyone - well there's still a list of features still needed some of which may or may not ever make it from ObjC to Swift. But who knows. I started to convert some of my old code to and write some new apps in Swift. Mostly it's been positive - as long as you properly plan and isolate bits in legacy code the right way. New code is actually pretty nice. One thing: the more you play with Swift avoiding Cocoa/Touch, the more you'll probably like it and then be willing to make the leap. Code size is definitely a plus - stuff that was several pages plus .h reduced to a bit over one page in most cases. It's definitely more concise as a language and having functional bits as 1st class helps that. Things like KVO are a mess as are linking between legacy frameworks and such. It's better but still messy. I still run into issues with Cocoa objects that are 1) not well documented between ObjC/Swift and 2) are not toll-free bridged. But this time around it's not as irritating. Swift may not be there completely for everyone but it's is definitely getting closer. I'll almost love ObjC even if I switch over mostly. Basically give a few baby programs a try in Swift if you are a hardcore ObjC programmer each time they rev and revisit the readiness question.
&gt; However, we currently use Swift to write some of our UI and unit tests. So much for “can’t anytime soon”. 
Most likely either `item.attachments` or `self.extensionContext.inputItems` is empty, causing `item.attachments.firstObject` to return `nil`.
thanks! so it sounds like the syntax for inserting `itemProvider` into my NSDictionary is valid? More broadly I doubt `self.extensionContext.inputItems` is ever empty as it is only invoked when I am trying to share something from another app into MyApp (eg a page's URL from the Safari App into my app). is this a mistaken assumption? did i have to set up something else for this to happen? Edit: [this](https://hackernoon.com/how-to-build-an-ios-share-extension-in-swift-4a2019935b2e) says I need to edit `info.plist` to run a javascript snippet in NSExtensionJavaScriptPreprocessingFile, does that sound about right?
Not sure why itemProvider is nil, but it might help you to convert your older `objects:forKeys` syntax with the newer [dictionary literal](https://developer.apple.com/documentation/foundation/nsdictionary?language=objc). NSDictionary *initialProps = [NSDictionary dictionaryWithObjects:@[[NSNumber numberWithBool: TRUE], itemProvider] forKeys:@[@"isActionExtension",@"key2"]]; with: NSDictionary *initialProps = @{ @"isActionExtension": @YES, @"key2": itemProvider }; It's much more readable this way, and prevents you from making positioning mistakes like can happen with the older syntax.
You will need to start by learning objective c and then if you have specific questions to ask we may be able to answer and help you. 
I am learning, I can do that with numbers...it's the strings I have an issue with, I tried scanf() but in vain 
What platform, codebase, target etc... are you writing pure objective c or using Xcode or... ?
I'm using Xcode 
I'm using Xcode 
What are you developing for? iOS macOS ?
A practice project for macOS command line tool...wait, I thought one can use the same functions for both macOS and iOS anyway, isn't it? 
This is a pretty simple problem. Here is my solution, although not efficient: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #import &lt;Foundation/Foundation.h&gt; @implementation NSMutableArray (Shuffle) -shuffle { int i, len = [self count], r1, r2; for(i=0; i&lt;len; i++) { r1 = random() % len; r2 = random() % len; [self exchangeObjectAtIndex: r1 withObjectAtIndex: r2]; } return self; } @end int main(int argc, char *argv[]) { id pool, array; char name[64]; srandom(time(NULL)); pool = [[NSAutoreleasePool alloc] init]; array = [[NSMutableArray alloc] init]; printf("Enter names, one per line. End input with Ctrl-D.\n"); while(fgets(name, 64, stdin) != NULL) { [array addObject: [NSString stringWithCString: name]]; } printf("\nRandomizing...\n\n"); [array shuffle]; printf("%s\n", [[array componentsJoinedByString: @""] cString] ); [array release]; [pool release]; return 0; } [Here is a demo.](https://imgur.com/FKZLE0j)
TL;DR: They ship a closed-source SDK, and Swift isn't ABI-stable yet.
I really have no interest in writing in Swift. I absolutely hate the syntax, and that’ll never change. Coming from a beautiful syntax like ObjC I don’t see a reason to switch. 
A lot of reasons they make are the same for me. Steve Troughton-Smith has a lot of great answers. My biggest is I love the syntax of Objective-C, and despise the syntax of Swift. 
Optional are terrible. All that guard/let syntax. Ugh.
I agree. I've tried several times to work with Swift and find its syntax overly complicated. 
[Steve Troughton-Smith's full answer](https://twitter.com/stroughtonsmith/status/915934914331201536) is also a great read. Each of his points resonates with me (and explains why my company doesn't allow Swift code in our products). I write most of my code in a scripting language inspired by Obj-C, I'm always dismayed that Apple didn't go a similar route and instead decided to make Swift a highly-complicated and complex language. *Edit: removed two duplicate words.*
Objc is a lot more complicated though
Well try to check all pointers and you get the same ugliness in c objc c++ you can also just use ! To force unwrap and hope they are never nil ;-p The point is that people do not seem to understand pointers and so introduce bugs in their code.
I suspect we may have different definitions of complicated. I was referring to the syntax of the language itself, as in: how hard is it to write a parser or tool which can read source code files? A complex language doesn't mean a language is bad. C++ is complex, but it's very useful in certain scenarios. (Likewise, I'm sure you and others find Swift to be useful.) Conversely, Lua and Forth are both tiny and simple languages, but I've only used them in a few jobs. From a syntax perspective, C is fairly simple, and Obj-C 1.0 was a small layer on top of that. It's grown in complexity over the years (2.0, ARC, nullability, covariants, etc.), but I still believe it simpler to programmatically parse than any version of Swift.
Selecting both to and from randomly results is a bad shuffle, items have a increased probability of remaining in their start location. To fix just use `r1 = i;`. Now every single item definitely gets a turn to be shuffled. 
This is the dumbest thing I've ever heard.
Except its not dumb at all. Syntax of Swift is absolutely horrid. 
Except Swift's syntax is modern and easy to understand, and encourages safer, more bug-free code. And it doesn't have all them damn brackets.
Except that's not true. Swift is HARD to read. First, the variable declarations are backwards. Second there are the worthless var/let/func compiler hints. Third there is the terrible dots and question mark syntax. I disagree that it encourages safer, more bug-free code than Objective-C. What it does encourage is harder to read code, because it lets developers be too clever. And brackets are great. 
... and here I thought I was the only one who hates the Swift syntax. 
I thought I was too, but we are not alone!
&gt;the variable definitions are backwards. Only by C standards. Lots and *lots* of languages display the type as a suffix. Swift, Haskell, and Go are 3 modern languages that do this, just off the top. &gt;there are the worthless var/let/func compiler hints. They're not useless. At least not 'var' and 'let'. You're vastly underestimating how useful it is for you *and* the compiler to both know the mutability of your data. Very useful for multithreaded programming, but also just really useful in general. I'm not going to address your third point, because I agree it's ugly, but code isn't supposed to be aesthetically pleasing, it's supposed to communicate intent and prevent stupid bugs, and built-in optionals definitely help. &gt;I disagree that it encourages safer, more bug-free code than Objective-C. You're free to your opinion, but the vast majority of anyone who's done actual development in both languages or who's at least familiar with both languages will tell you that this is just bullshit.
&gt; Not really. It's pretty easy to read. Functions typically read like English sentences, for starters. Actually quite really. Functions in Objective-C typically read like English sentences, but in Swift they are much more compressed. And Swift encourages "clever" coding, which actually makes it harder to read (see things like ?) &gt; Especially easier than Objective-C. I mean, you do realize that the most stated reason why people dislike ObjC is because it's hard to read. And they are actually wrong, because Swift is harder to read because of the above. Objective C is easier to read because its more verbose. &gt; Only by C standards. Lots and lots of languages use the suffix-style type. Swift, Haskell, and Go are 3 modern languages that do this, just off the top. And they are wrong. Its the way it was in C because instead of having to process where in the middle the variable name is, you just look at the end. &gt; They're not useless. At least not 'var' and 'let'. You're vastly underestimating how useful it is for you and the compiler to both know the mutability of your data. Very useful for multithreaded programming, but also just really useful in general. Also, "func" is useless? Seems like a really dumb reason to dislike a language. They are very useless. First, *let* is equivalent to *const*. So just use that, because that is clearly and easier to read and understand than *let*, which is arbitrary. *var* is completely useless, because there is already the type declaration, such as *String*. Its a duplication. *func* is similarly useless, because its clear from the structure that its a function. Its extra typing and useless information for both compiler and user. &gt; I'm not going to address your third point, because I agree it's ugly, but code isn't supposed to be aesthetically pleasing, it's supposed to communicate intent and prevent stupid bugs, and built-in optionals definitely help. I agree with your statement that *aesthetically pleasing, it's supposed to communicate intent and prevent stupid bugs*, which is what Swift fails at. Built-in optionals in Swift are terrible, especially the syntax. &gt; You're free to your opinion, but the vast majority of anyone who's done actual development in both languages or who's at least familiar with both languages will tell you that this is just bullshit. And they are wrong. Its not an opinion. Its a fact. &gt; I think you're just being a hipster. Nope, I'm trying to be the most efficient and best programming I can be. Swift doesn't help me to do that. Objective-C does.
You're telling me you actually believe ObjC code has less dumb bugs, *on average*, than Swift? You're full of shit.
What it comes down to is that an expert ObjC programmer will be better than an expert Swift programmer, because programming in Swift is like riding a bike with training wheels. Swift is the equivalent of Java, its purpose is to make the average, mediocre programmer more productive, at the expense of the expert programmer. Yes, Swift is safer, but expert programmers don't really need type safety. Using a safe language doesn't prevent any bugs for the expert programmer, only for the average programmer.
I always love when people insult me while making an argument. It shows the strength of their argument, or shall I say lack there of. &gt; You're telling me you actually believe ObjC code has less dumb bugs, on average, than Swift? You're full of shit. You really have no idea what safety is. Yes I do. Now, it may be in different areas, because of the way each language is structured. But I think Swift solves a problem that doesn't really need solving. &gt; So you're agreeing that it's not supposed to be aesthetically pleasing, but rather clear in intent. You obviously understand what they mean and therefore you understand the intent. Your vague complaint that they are "terrible" just reinforces the idea that you just don't think they're "pretty". You contradicted yourself. Not at all. Its not about being "pretty" but being readable and clear in intent. Swift's syntax has neither of those. &gt; Stop being a fanboy for a minute and take a look at any article comparing the languages. I've read them. I've read Apple's Swift book. I just read that article, which is full of errors (i.e. 1. Swift is actually harder to read. 2. Swift is actually harder to maintain. etc). Its not about being a "fanboy" (another insult that shows the lack of strength of your position), its about choosing the best language for me. &gt; But when you claim things like ObjC is safer, or more clear in intent, you're full of shit. More insults. Sorry, but you are wrong. &gt; Just keep in mind that these are two reason why Swift was invented in the first place. Just because that's the reasons Swift was invented doesn't mean it actually succeeded in those goals. &gt; And while I see you disagree, it's like you're disagreeing that the sky is blue, when I think we all agree the sky is blue. Not at all, and another insult showing the lack of strength in your position. YOU see it as obvious, when it actually isn't. You like Swift and find it great for you, that's fine. But don't believe that its completely obvious or that it doesn't have flaws, or that it isn't a valid argument to say Objective-C is worse. 
You know, saying you're full of shit doesn't have to be taken as an insult...it just means what you're saying is bullshit. No need to get offended. It's just true.
Oh I’m not offended. Because I know only someone with a weak argument would use that phrase (especially when it’s not true). I feel sorry for you. 
That is a very simple and yet useful construct! Nice!
Seriously, this is pretty ridiculous. I'm curious hw much time Swift developers waste upgrading their projects and retesting everything with each new Swift version each year? And for what? No header files? Optionals? Using the hot new thing? Get off my Objective-lawn Swift!
Does it at least indicate what doesn't compile?
 Nope, gives an error about swift compiler version and fails. 
Not that big of a deal, migrate it forward and fix it up where necessary. Honestly shouldn't take you very long, especially if you wrote good tests. The changes are well documented and Xcode does a lot of the work for you. I'm no fan of Swift either (Obj-C is NOT dead, long live Obj-C!), but it's a new and rapidly evolving language. You kinda have to expect API-breaking changes if you're going to adopt it.
Frustrating. Apparently you *can* get [older Xcode images here](https://developer.apple.com/download/more/). Well this was why I only recently started to play with Swift - the leaps between versions were uncomfortably large and it seemed you'd have to refactor too much to make it worthwhile. Not stable enough to commit yet. With the 3-4 compatibility and smaller changes I've finally started to write things in it and get some familiarity. On one hand - it's definitely terser and more succinct. That makes the code clearer which I like. But Cocoa usage are still thin and poorly debugged in Xcode. I pretty routinely write custom views and the process of doing the same in Swift is a little obscure and poorly documented. Most of the docs about this are still ObjC, and the Swift docs, while pretty good, COMPLETELY stop at the Cocoa border. I can only assume it's because things are still changing on that front and Apple isn't even willing to commit docs for that yet. So I may get bitten on this eventually. :-(
Just a hassle to download and install Xcode 8 just to converge. Wish they at least left the converter in Xcode 9 at a minimum.
Swift is shit. I don’t get the fandom. It’s ugly, bug ridden, lacks dynamic features and introspection, it’s basically C++ all over again and I didn’t enjoy that the first time I did it. Fuck swift.
Apple was incredibly clear about this when Swift came out and with every release - source compatibility is not guaranteed, so keep your source code current. So, if you didn't want to do that, yes, you should have stuck with Objective-C. Getting and installing Xcode 8 is trivially easy. If you don't care about staying modern with your project then there should be nothing wrong with using Xcode 8 to continue working on it.
It does not lack anything you listed ;-p
I look forward to your code sample showing how to enumerate the properties on a pure swift object that does not inherit from NSObject.
use Mirror?, extent RawRepresentable for enums? lots of options xD also swift works just fine with the objc runtime ;-p
To help migration, change `SWIFT_VERSION` (**Swift Language Version**) in your config to a Swift 4. It won't migrate your project for you, but at least it will stop that annoying message and give you a chance to fix your syntax errors. I'm dipping my toes in. Now that there's supposed ABI stability we can write static libraries that include Swift code. The biggest issue for me is that writing command line tools that use Swift is a major pain in the ass so far. Simple things that don't require libraries are okay, but as soon as you introduce a Swift library, linking goes to hell. There are workarounds, but it results in different built framework versions for different types of applications. I suppose anything not-iPhone is second thought to Apple these days, though. 
Every time I see something like this I’m glad to be an objective c developer. Swift just doesn’t offer compelling advantages for me, and it brings a raft of disadvantages to boot.
I spent many years developing in C++ and I can tell you Swift is in no way C++.
I did too. Swift is more c++ than Smalltalk/objective c and with uglier syntax. I think it’s useful to look at c++ vs erlang. Similar kind of design trade offs. Erlang is highly dynamic, runs on a vm, has messaging, can do hot swappable code and has proven to be as efficient but more reliable in the area of writing telephone switches (both targeted the same domain initially). I think the swift/c++ model of static code generation has been shown to be pretty brittle over time relative to the more dynamic languages. That’s my take after 30 years of doing this stuff on all kinds of languages and platforms.
Agreed. Apple was extremely clear about what Swift was. It's fine to be upset that you code doesn't compile but you can't be upset with Swift/Apple about it. Swift 1 -&gt; 2 -&gt; 3 had a large amount of changes and took time to fix. But 3 -&gt; 4 was extremely easy. As the language matures the less work you'll have to do.
Yeah you should have stuck with obj-c. Swift is still not finished 2 years later.
Nope. If you're doing arithmetic with floats or doubles, or assigning a value to a float or double, then `0` will just be treated as a `0.0f` or `0.0`.
The compiler automatically converts it to the right format
So there's no runtime performance penalty for using 0? Any reason why you *would* use 0.0f or 0.0?
To a another developer (or your future self) casually scanning the source code with your eyes, the decimal characters make it immediately obvious that you’re looking at floating point arithmetic. You should almost always optimize for readable source code. 
&gt; So there's no runtime performance penalty for using 0? All of your examples don't occur in runtime; they occur during compile time. While I don't know how the parser/lexer works, I would imagine that if the loop terminates at `;` instead of continuing to `.f;` then one might argue that it compiles _faster_! That's theoretical, though, because it'd take a million instances of that for you to ever notice the speed increase. During runtime, there _can't_ be a penalty, because everything is already compiled to the types it's supposed to be. The time penalty you are likely to notice, though, is when you're reviewing your source code in six months. Is that an integer or a float? I better check the variable declaration. You'll've wasted all that time checking, versus the consistency of writing `0` for ints and `0.0` for floats. 
Most do not do any testing
&gt; So there's no runtime performance penalty for using 0? &gt; No. The compiler will emit the zero representation and word size for the type needed in the expression. It does not place an explicit integer at compile-time and then convert it to another type when it is evaluated in statement. 
*Not that big of a deal*, seamlessly integrates with Apple's 'just works' philosophy. /s
I’ll volunteer that I was pretty productive with this unfinished language for over a year at my last job. And that’s including the Swift 2 to 3 migration which took a few days. 2 iOS apps, 10s of thousands lines of code, originally written by idiots, but after solving their couple of bugs in the first month, I had zero tricky crashes. After a while it just seemed like variant Cocoa syntax, I didn’t miss dynamicism (if that’s a word) at all.
I feel like I’m doing programming in Objective-C. In Swift, I feel like I’m writing.
I stay away from this, the project descriptions are fairly thin, there is added unpaid communication overhead where you need to get intel about a project and also there is the risk that you don't get paid bc the customer is unsatisfied. Nah, not for me.
For anyone that's into jailbreaking there's r/tweakbounty aswell
They are pretty unrealistic in costs, $50 to integrate barcodes, I have done this, it’s at least a full day job. $50 for a full day? 
hm, some quality Indian spam...
The entire article seems to be Swift. I don’t really understand why it’s in this sub.
I've used Swift as an example, but afaik SwiftMonkey can be used with Objective-C (even if not, you have the option to just create a corresponding target), and for Property Based Testing there is an extra library mentioned. So the concepts can be applied to Objective-C projects as well.
Love it.
Thanks that's so nice to hear
It’s better to use GCD. dispatch_queue_t queue = dispatch_queue_create(“myQueue”, DISPATCH_QUEUE_SERIAL); dispatch_async(queue, ^{ [((newLayerController *)self-&gt;_sheetTest) drawShape: currentPoint lastPoint:_lastPoint]; }); Most asynchronous code on iOS these days is written using GCD, not raw threads. It’s actually pretty easy to use so you should definitely look into it. 
I agree with /u/adamkemp that GCD is a better alternative nowadays. Anyway, if you really want to use *performSelectorInBackground:withObject:*, the called method must accept at most 1 parameter. In your case, *drawShape:lastPoint:* accepts 2, so it can't be called as it is. Supposing you can change the signature of the method into something like: [((newLayerController *)_sheetTest) drawShape:shape]; you would call it in background in the following way: [self performSelectorInBackground:@selector(drawShape:) withObject:shape]; One last thing: if this code changes something in the UI, recall UI code must always be called from the main thread. Hope this helps. 
Hi, I am interested in iOS remote jobs. Thanks :)
There's a great list of remote iOS jobs here https://iosjobs.io/?location=Remote
Good idea. Any chance you can post macOS too if you find any?
I’m an Obj C app developer and I’ve been working with AVFoundation for a long time. This looks like a $200k+ project with cost overruns bringing it well into $300k territory. Is your budget per week?
If you have a half-finished app and no developer, you have a 0%-finished app. In my experience taking over incomplete apps, it is rare that the codebase is in a good enough place to get you across the finish line. YMMV, of course, but set your expectations that you may need to do a complete re-write. In which case... why not try and do it yourself? There are a ton of good resources available for free all over the web. Good luck!
Seconding this. Also an experienced ObjC developer (12 years) with extensive media experience including using AVFoundation. OP’s budget is off by orders of magnitude.
You are looking at $50k+ for that amount of work and features 
I’ll do the settings screen for $4k
Yep I do post MacOS too
Given the still relative immaturity of Swift, I'd bet that the majority of quality iOS apps are still written in Objective-C. I'm not sure that there's a good way to tell, though. 
Last I checked there was no project to bring GNUstep to Wayland. Many Linux distros are rushing headlong into supporting Wayland. If GNUstep hopes to stay relevant, it should include Wayland support as quickly as possible.
It would be great if some of this swift momentum will end up with the uikit libraries implemented cross platform. 
I’d love this to be true, but can you imagine porting CoreAnimation to Linux? So much wizbottery! And GPU dependency. Seems like it’d be pretty hard.
I’d love it GNUstep was up to the challenge, but its not. The community is still stuck in the past. They resist any change of the UI. They resist any attempt to make it better or fit into Linux. There is no movement to improve upon it. Anybody who tries is shot down. Hell, even one of the maintainers has basically given up hope of trying because he knows its fruitless. What would they need to do? First, junk the old NEXTstep UI. Build gnustep-ui with a link into modern Linux UIs. (But this will NEVER happen.) Second, integrate preferences and settings better into the Linux model. Right now they are all in weird places nobody knows. Third, compile ProjectCenter and Gorm with the new UI, and improve upon it so development is easy. I’ve tried writing apps with them, and its hell. Fourth, make it real easy to install and use on Ubuntu, Fedora, and CentOS. Right now its a pain in the ass, and buggy as hell, even when building from source. That’s just off the top of my head. I absolutely love Objective-C, and this would be GNUstep’s time to shine. But they’ve already squandered the past three years. And I see none of that changing. 
I know, but it’s be sooo great. I’d take a crack at it. I wonder what happened to Chameleon. Also that UXKit reference in photos!
I always liked The Big Nerd Ranch Objective-C books, but visiting their website makes it look like they don't like Objective-C anymore. Might still be able to pick it up on Amazon, though. 
Apple has been pretty successful at getting people to switch to Swift. Swift isn't half bad (source code is smaller compared to the same implementation in ObjC, it has nicer Functional Programming features, etc.) but it's also not-C-like (no semicolons, syntax differences, etc.) BNR and similar are the primary resources. Apple still has API documentation in ObjC plus Swift. Some of the newest macOS/iOS features often have only Swift examples in online references (and sometimes even Apple examples). I've had to translate them to ObjC to use them. It's doable.
But some jobs requirement still asking for Obj-C :[ I'm still looking for a way to enter Obj-C
Start with TutorialPoint. The tut on Obj-C ain't half bad. At least it gives you a platform from which to build. Good luck!
I used their iOS book, when it was Objective-C, but whatever's in their Objective-C book would get you more that just "How to build an App", so I'd recommend that. Any changes to Objective-C would probably just result in 'deprecated' warnings.
I like the head first development books 
I would recommend learning Swift instead of Objective-C.
Already know Swift fairly well, but I’ve had a few friends/developers mention that knowing Obj-c will help me become a more well rounded developer. Always looking to learn 🤓
no
It does seem like an ignorant question, but that's not a good reason for misinformation. XCode, the Apple-supplied IDE, supports Objective C, Swift, C++ and C. I believe that python is installed by default. Probably most every other language you can think of has an installer for MacOS (not sure about MS-specific ones like C#). I myself have learned Java and Perl and am learning Haskell on a Mac.
Ya thanks bro
DotNet Core works fine on macOS. Ruby is also installed by default. I've done Elixir and Erlang, as well. LISP, Clojure (technically Java, I suppose), Scheme. Oh, hell, I've done Prolog too (I recommend everyone dabble a bit in Prolog).
I write and run C# on my Mac all the time.
Yeah, all the languages, pretty much. Don't call a Mac a PC though. 
[removed]
yes, but you should not use them to build apps, they are fine for prototyping and other niche use cases though.
A Mac is, in fact, a personal computer. 
This is a waste. 
Thanks for this list!
Why is this posted here? Troll?
Strings to numbers: NSInteger newInteger = [stringNumber integerValue]; float newFloat = [stringNumber floatValue]; double newDouble = [stringNumber doubleValue]; Numbers to strings: NSString newString = [NSString stringWithFormat:@"%f", number];
I'm interested in learning Objective C from scratch..no knowledge no skills never did CS in college am just an absolute beginner with just interest... please advice me where I can have my starting point. 
I would suggest grabbing a book about Objective-C first. The books on the list are more general and are important to every programmer - not just a specific language. But I think you can wait until you have some more experience.
Is it hard? Is it a language you'd recommend to me? I'd want to develop Windows Apps and Games and abit of Android
C or C++ any difference 
Not the same thing 
[quicktype](https://app.quicktype.io#l=objc) infers types from JSON data, then outputs Swift, Objective-C, and code in other languages for reading that data. You can also input JSON Schema and GraphQL queries using our CLI. We just added Objective-C output support today, and we're looking for feedback. We already have [some improvements in mind](https://github.com/quicktype/quicktype/issues/434) but we'd also love any feedback on the generated code, or what we could improve. Thank you!
Swift is partially written in C++ yet can’t call into C++ code without it being wrapped in C or ObjC. I still find it funny.
This is surprisingly useful, solves a problem for me, saves time in making boilerplate. Nice.
Carbon UI may not be around much longer. Rumors are that next macOS will be last one to support 32-bit apps. But I think ObjectiveC will be here for a long time. Apple had too much code written in it.
Carbon UI was never made 64bit but other parts such as ApplicationServices and HIToolBox are 64bit and will still be with us.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/macprogramming] [X-Post from r\/ObjectiveC: I recently "discovered" a simpler way of method swizzling in Obj-C and would love some feedback](https://www.reddit.com/r/macprogramming/comments/7s02od/xpost_from_robjectivec_i_recently_discovered_a/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Swift is not C++ but the source code for Swift -available on GitHub- is part C++.
I've removed the global functions when not needed!
I've been working for a couple of weeks on this Xcode extension, and I'm getting pretty happy with its Objective-C support. Here's a tweet with a gif demo: https://twitter.com/quicktypeio/status/955651101029625856 I'd love any feedback or suggestions for how to improve! Thank you.
Really like this and is the best of its kind that I've seen. Thank you for making it. I am however still struggling a bit to figure out how to approach using it to generate code that replaces my existing handwritten brittle data model. I have two few questions that might help: 1. Considering that the code generated is good, but will require some manual changes on my part, do you have any workflow suggestions when it comes time to add new bits to the data model? I want to avoid throwing away the work I did on top of the code generated each time I add a new field and I am curious for your thoughts. 2.Do you have suggestions about how to provide hints to get improve class names? The guesses are not always great. Like in one case I'm seeing the class name chosen is a unique string that is used to identify a particular instance of a class instead of the class type. Instead of "Class Car" it's "Class XYZ" where XYZ is the Vin number of a specific car. And finally a syntax nitpick. There isn't always a space between the "+" or "-" and the method that follows. I noticed this is the case for code generated for "+(NSDictionary&lt;NSString *, NSString *&gt; *)properties" and "-(void)setValue:(nullable id)value forKey:(NSString *)key" totally minor thing, but It bothers me and I can't imagine it's hard to fix. Thanks again!
Thank you for your feedback! 1. We are [tracking an issue](https://github.com/quicktype/quicktype/issues/223) to allow some customization of the generated code. It would help us a lot if you could share your use case there. 2. We recommend that you infer a JSON Schema from your sample data, then use that to actually generate your models. You have complete control in the schema over class names. 3. Please [file an issue](https://github.com/quicktype/quicktype/issues/new) or better yet [send a PR with the code change](https://github.com/quicktype/quicktype/blob/master/src/Language/Objective-C.ts#L690) – you can even send us these edits right from github.com without cloning the repo. Thanks again for the feedback, and please click the chat bubble on our website if you'd like to talk in real-time.
Thank you! 1. K. Will post something once I have a more defined use case after I've tried the schema. 2. Will spend some time on the schema tomorrow, but I suspect that will fix most of my issues. 3. Will do Note: If I were to guess I'd say my top issue now would be date handling. Will update you tomorrow after a few rounds of schema edits.
Cool. Date handling is already present in our internal API but it's not yet supported by our Objective-C renderer yet. If this is a pressing requirement for you, please contribute or help us find a contributor! It should be straightforward to implement but we are a bit busy. We also offer paid support in case your company is in a position to pay, in which case we could prioritize this: https://quicktype.io/#pricing
Also, we'd love to hear what you're working on and how quicktype is helping you. We actually haven't talked in detail to any Objective-C users yet.
Got it, thanks. Will take a look at contributing, but not sure you want me touching any code that is not Objective-C or Python. Not at all opposed to paying when my project I'm using this for is a little further along. 
Been doing Obj-c on and off since '05 so I'd like to think I'm not a total bozo and can give you some possibly useful context.
EDIT: there's an option "Exclude Pattern" (advanced), set it to: .*language=(objc|swift) 
Interesting article but seems to rely on a third-party framework to do the job. Sadly that’s not an easy thing to incorporate at my job. But good advice for a testing tool to use in your personal app.
I worked on apps for iOS 8 - 11, those developed in Objective C saw little need to change. The biggest change that I recall was to the notification APIs, which was a day’s worth of coding and testing. Those that were written in Swift , especially version 1, required an extensive update, almost a rewrite. 
I love it already 
&gt; There is no movement to improve upon it. Anybody who tries is shot down. Hell, even one of the maintainers has basically given up hope of trying because he knows its fruitless. I've been using Linux for years and honestly this is the same for a lot of projects. The community is full of stubborn ideologues. The best way to see any progress is to start drama by forking a project and then throw shade at the original project. &gt; First, junk the old NEXTstep UI. Build gnustep-ui with a link into modern Linux UIs. (But this will NEVER happen.) [CoreGTK](https://www.tylerburton.ca/projects/coregtk/) is probably going to be everyone's best bet. GTK, Qt and JavaFX are probably the best solutions available on Linux and that's probably not going to change for a long time.
can barely hear you. Are you ok?
Along these lines the really smart &amp; talented folks at PSPDFKit have posted these: https://pspdfkit.com/blog/2016/swifty-objective-c/ https://pspdfkit.com/blog/2017/even-swiftier-objective-c/
This seems to be just an ObjC wrapper for other code (a Cordova framework I'm guessing) There's a backButton action and it's apparently attached to "close()" on line 624 with the close() source defined at line 63. It's taking a "Cordova command" as an argument and passing it to Cordova. In close() it simply closes the browser. That doesn't sound like "back" in any case. 
You're right, it doesn't go "back" to the previous page, it just mimic it. I believe this backButton should close the plugin, but this is the problem, the button is dead. Perhaps there's a subview above it? Or maybe something crashing the whole toolbar. Another thing that sucks is that the console dont give me any good error description.
First step is to find out if the close method is actually being called. Put a log statement in the first line of that method e.g: - (void)close:(CDVInvokedUrlCommand*)command { NSLog(@"IAB.close() called"); if (self.inAppBrowserViewController == nil) { NSLog(@"IAB.close() called but it was already closed."); return; } // Things are cleaned up in browserExit. [self.inAppBrowserViewController close]; } 
Oh and there is always the chance you need to update the plugin. This may be what you need: https://github.com/apache/cordova-plugin-inappbrowser/commit/32d867f8e45c2b14580b64c48d8f963b6b1d594f#diff-85b38839978458a226b3234fe51797b9
Thanks for the response, i did that, no success(Nothing is displayed), i think when the plugin loads something crash the toolbar and the buttons stop working. Or maybe the link between the front and login part are broken. 
Oh this is NICE
The sort answer: iOS apps are generally simple enough that Swift is enough. macOS still benefits from ObjC because the APIs are more complex and there is more legacy and C/C++ back-end you may be interacting with. Also Swift for macOS is less mature - you often MUST fall back on referencing ObjC just to get things done and you won't find as much documentation on newer features.
Objective-C, because you can make use of C++ STL which embarrasses Swift’s, it gives you everything Swift gives you and much more with the added benefit of trusting your code will work 10 years from now.
If you have a framework, it's a bundle that includes header/include files - they are in the framework; leave them there. They can't not be there - otherwise the framework simply won't work even in the original app. You have to install and reference the framework in Xcode and it should "just work" for the most part in ObjC or Switch. You may or may not have to wrap C++ interfaces to get to it if you are using C++. I've never gone down that path. Your only real question is where to put the framework bundle - in your app's bundle is likely the correct answer so that you don't have a separate installation step. 
ok then. I will NOT mess with the framework. But I would still have to say #include&lt;biometrickit/biometrickit.h&gt;, right? and where DO i put the framework file? I've tried dragging it into my project, I've tried putting it in xcode's sdk framework files, I've tried everything. It doesn't want to budge. 
I'm not sure what just dragging it into Xcode does. Can you see the Headers a directory underneath the .framework directory? At least, that's the first step. As for linking and deploying, I haven't done this for a while, but you'll have to reference it in "Link with" and "import", I thinking. (Meaning, search for these things in your project's build settings.) Then you'll have to copy it into your app's Frameworks directory.
Could it be that it is a private framework and you should not mess with it. The biometrics is tightly coupled with the Security framework and the Secure Enclave of the iPhone. And as you say, you are a novice, best not to start with messing with private frameworks. You will never get an app approved when you use/rely on private frameworks. Best is not to use them. 
as far as I understood you didn't get a distributed framework, but rather extracted one from an iOS firmware, right? If this is the case, it might be the case, that the framework has Apple's DRM. Then you have no chance with the current version. You would have to actually jailbreak a device, ssh onto it, decrypt the framework on the device, copy it to your computer, dump the header files, add them to the framework and THEN you will we able to import it into your project. If it's not encrypted, you could try dumping the header files, add them to the framework and check if that helps.
that's actually the point, to interface with the secure enclave. I don't want this app approved. it is for jailbroken devices.
Then including a non-existent header isn't going compile. If you didn't get the headers from the framework, you'll have to create your own from the symbols.
I'm surprised that let you install High Sierra
RAM requirements. Other than that... I highly doubt they blacklisted CPU’s. Just crack open your device and install some more ram, and you’re good to go. Also I seriously recommend a brand new battery, or one that hasn’t been depleted yet. Makes a hell of a difference. Apple isn’t kidding in the iphone situation (really the “batterygate” is a problem every battery powered device suffers from)- voltage difference is huge in terms of how fast it runs..
I think you're supposed to pay Reddit for promoted posts.
Yup
And my perfectly functioning Mac Pro 2006 is not supported anymore.
[removed]
Objective C (Q&amp;A guide 2018)
spamful
[removed]
[removed]
[removed]
this is pretty cool. 
&gt;we need a compiler. No compiler modern enough to support exceptions in Objective-C was released for the Amiga itself, as there was never any GCC 4 for Amiga. How is this a thing? Compilers aren't designed for a specific OS. They're designed for a CPU architecture, and an executable format. GCC has support for Amiga's HUNK format, and there are [tools to convert GCC's object files to HUNK](http://aminet.net/package/dev/gcc/sobja). [Modern GCC (7.2.0) for Amiga](https://github.com/endofexclusive/asdf), but he's also converting ELF to HUNK. This shouldn't be too painful to handle in the Makefile. Another possibility might be to wedge [vasm](https://github.com/mbitsnbites/vasm) in place of GCC's assembler, assuming they speak the same format. There might be switches to make them meet, or a converter you can pipe through. I recall there being an ELF loader for the Amiga as well, although that's a little hacky.
Compilers are specific for an OS as in that they need to support the object format (HUNK for AmigaOS) and calling convention. GCC officially dropped support for AmigaOS a very, very long time ago, so GCC could not target AmigaOS anymore. And ELF2HUNK had many problems with ABI incompatibilities - just look at what the AROS people had to go through. But with amiga-gcc, this all works beautifully now :).
why's this on objective-c lol
C# doesn’t belong on the list
It does.
It is not derived from C, though. It is closer to Java. More so, C, C++ and Objective-C can be mixed in the same source file, supported by Clang, GCC and MSVC, C# can’t be mixed with any of them.
I tought you meant as in there is not a text channel in the discord server for C#. Also, thanks for the facts, I haven't really touched C#
I just use this account. I have another account :P
The location inside of the ipsw that you wrote contains only localization files. The binary file of the framework is contained in a cache to improve the performance. The cache is called dyld_shared_cache and you can find it in the IPSW. There are many ways to extract the framework from there and they are listed in this wiki: http://iphonedevwiki.net/index.php/Dyld_shared_cache This post also explain more informations: https://stackoverflow.com/questions/43962260/how-to-import-a-private-framework-in-xcode-8-3-without-getting-undefined-symbol
lol thank you so much! I can't believe you replied to a post this old to help me out! thank you!
I hate swift. There. I said it. 
I once had the misfortune of working with some Objective-C++ code. It’s a godawful illegible nightmare that shoves together two distinct and lengthy syntaxes and incompatible object models. It’s make-you-want-to-quit-your-career bad. The best thing I did to it was get rid of all the C++ and just turn into straight Objective-C.
Not my experience, but mostly because I wrote ObjC++ carefully and only when it was better than pure C++ or pure ObjC
Nice 👌
These are interesting but sadly I don't see further development on ObjC happening - it's all about Swift now and most of those features ARE in Swift in some form.
Regarding nullability checks, the clang static analyzer is pretty good at finding nullability violations now. It’s not a compile time error but it’s something. Also, I strongly disagree that captured references in blocks should be weak by default. Not even swift does this. And not every use of a block needs the “weak/strong dance”. With iOS 12 Apple has started annotating their objc headers with the NO_ESCAPE attribute on the appropriate blocks. So, at least with their APIs, it should be easier to tell where you you do and do not need to capture weak references.
This is an interesting post, but also kind of a weird one to write with no mention of Swift. Swift has almost all of the things you mention in one way or another. Also unless I misunderstand you, your pie-in-the-sky wish for custom generic classes already came true. You can indeed create custom classes that use generics in ObjC as of a few years ago. They’re “lightweight” in that they’re purely for the compiler with no generic type information preserved at runtime, but they’re there.
Any info about running nullability checks in clang static analyzer? Is it the same as "Analyze" in Xcode? &gt; captured references in blocks should be weak by default Yes, except "self" IMO. Capturing a local variable is often just fine, but capturing "self" is often problematic. On a control vs safety compromise for an iOS app language I'd choose safety first, and then you can still have control with special keywords, modifiers etc. Totally agree about NO_ESCAPE, I mention it in the post. I'm biased in some wording, because majority of blocks in my code now are async, i.e. "escaping". 
Any info link about custom generic types in ObjC? That would be awesome. I always thought that only builtin types can support this (NSArray, NSDictionary), but not your own types (classes and blocks). &gt; no mention of Swift Thanks for mentioning it :) I just took for granted that everybody has some familiarity Swift in the ObjC programmers community. Next time I'll try to mention Swift among other languages for reference. 
I disagree, if only because Apple uses so much ObjC internally. It'll probably be like WebObjects…officially deprecated, but still being maintained years after the fact.
I’d like to mention that both generics and the additional warnings on non-declared selectors is actually a bad idea. Previously I would have agreed, but I’ve come to realize that id-based programming is a better way to utilize the power of the language. Also, it’s important that the language is used the way it was intended: C-level code with ObjC working as a glue. I’ve seen many new ObjC programmers use it like java or C++ where the problem is split into fine grained classes that each have a very limited responsibility. Not so for ObjC. An ObjC class should typically encapsulate much more code. I especially recommend Marcel Weiher’s writings on the subject.
I like Marcel's Objective Smalltalk project - I'd rather have gotten that than Swift. 
Make Objective-C Great Again ✊
👊✊
I agree.
I have a feeling that sort of opinion isn’t very popular anymore. Too bad I love the language actually. But today’s band wagon goes the swift way 🤷🏻‍♂️
I bet SWIFT was made to dominate the world and knock out JAVA in long term. 
Ugh it’s alreadt great. We need to make Swift not exist (or at least not what the cool kids are doing) again.
Hopefully I get the Objc runtime engineer position at Apple and I can 😎
👍👌
Excellent 
Ugh, so many comments to upvote
&gt; Yes, except "self" IMO. Capturing a local variable is often just fine, but capturing "self" is often problematic. No, capturing `self` is *rarely* problematic. If the block is stored as a property by `self` or an object `self` owns, it *may* be problematic. Using `weak` to break a retain cycle that does not actually exist shortens the lifetimes of the objects involved. Don't assume a retain cycle exists. Prove it using the tools before you "fix" it.
https://www.reddit.com/r/swift/comments/9ceygd/obj_c_4_ever/?st=JLLBBZQY&amp;sh=011b1b80
For me a typical case of using blocks are an async APIs, where one of the parameters is a "completion" block. You call that API, and that block is retained somewhere deep in that API. The block is stored until the async call finishes. If you retain "self" in that block, it means that your self-object starts to have a lifetime dictated by that API. The self-object owner can't control its lifetime (in the RAII sense), because the API client "owns" that object temporarily too. This is problem 1. Problem 2 is: who actually owns that API client? If you create and own the API client right there in the self-object, you get a retain cycle right there. No tools needed, it is just logic. This is illustrated with this example: { NSOperationQueue *_q; // ivar } - (id)init { _q = ... } - (void)start { [_q addOperationWithBlock:^{ [self run ]; }]; } - (void)run { ... } This is a classic retain cycle with self in a block. Replace NSOperationQueue with any other async API client, and you get a kind of code that is possible to find in any codebase. I prefer to assume that a retain cycle exists to be on a safe side, rather than spending a lot of time later on with instruments, debugging and resolving those cycles. 
Objective-C and Swift use reference counting as a memory management technique. When an object is instantiated it ha a retain count of 1, indicating it is owned by the called. Each call to `retain` on a reference counted object increments the retain count while a call to `release` decrements it. The object can be deallocated when the retain count reaches 0. A retain cycle is a specific memory condition in reference-counted memory management. Instance A retains Instance B. Instance B retains Instance A. Each of these instances depends on the other, creating the cycle. The instances will not be deallocated because their reference counts will never reach zero. Instance A can't be released until B is released. Instance B can't be released until A is released. The cycle can't be broken without a change to how the memory is managed. Apple covers this [here](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmPractical.html#//apple_ref/doc/uid/TP40004447-1000810) and [here](https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html), as well as WWDC sessions such as [2013](https://asciiwwdc.com/2013/sessions/410), [another from 2013](https://asciiwwdc.com/2013/sessions/404), [2010](https://asciiwwdc.com/2010/sessions/311), etc. Each year this is covered in at least one WWDC session. Most of the sessions cover how to find these cycles using Instruments. Now that we're clear on what a retain or reference cycle is... &gt; For me a typical case of using blocks are an async APIs, where one of the parameters is a "completion" block. You call that API, and that block is retained somewhere deep in that API. The block is stored until the async call finishes. And that, by definition, is not a reference cycle. The block is released when the operation is completed - there is no cycle. Any API that takes a completion block should do this by design and in fact most block-based APIs behave this way. Queues, networking, etc. all behave this way (which is easy to see with Instruments) &gt; This is a classic retain cycle with self in a block. Replace NSOperationQueue with any other async API client, and you get a kind of code that is possible to find in any codebase. No, it is not. The block and the captured reference are released when the queue is done with it.
&gt; Imagine a UI where you have a cancel button to cancel a long running or expensive operation. Yes, and in your network request and NSOperation examples cancelling will invoke the block and release it. There is no cycle. &gt; P.S. Let's call your definition a "classic retain cycle", and my definition is a "temporary retain cycle", so that we are not arguing on definitions So your "temporary retain cycle" is... retain until released. Umm... OK then.
&gt; Objective-C Crash Course for Swift Developers Maybe post this over at r/Swift? 
You can do so, I don't mind. Don't want to be pushy, I've shared the promo with some groups already
I happen to be an ObjC fanboy but I wouldn't read anything into this! I'm guessing this is dealing with legacy code on macOS/iOS which is predominantly ObjC. Some of that may be staying ObjC and some may be converted to Swift or augmented with Swift but you can't possible know from these statistics. 
Once you get past the brackets—which I long since have—it's a simple and beautiful language. I hope I never have to stop coding in it.
Does this mean I don’t need to learn swift?
I’m guessing some of the jump is also due to the rise in popularity of React Native, which uses Objective C for its iOS implementation. Because of this the community also tends to favor Objective C for any libraries that need native iOS functionality.
It compiles sooooo fast!!! I just started a game and went with obj-c because I am writing my state machine in C89 to port to old vintage OSes.
Yes, OBJ C is VERY fast 👍
It all depends on your goals. If you want to get hired by a company making apps for the Apple platform then it would be an advantage for you you to know both languages (Obj C - Swift). There is no reason to abandon one over the other since you can mix the languages. **My best advice is to never get depended in any company echo-system.** For newbie programmers i would recommend to start with C/C++/Java/HTML since they are all mature and platform independed. 
I just love the brackets. :) It was super easy to get the grasp of messaging. Not to mention the auto-complete that is godlike, compared to Swift's. I also love Swift for what it is, though. :)
Does that mean by removing all the nullable/generic/etc annotations that got added for Swoft interop? If so, I would like to subscribe to your newsletter and wear your baseball cap 😁
`AVMetadataFaceObject` has roll and yaw angles, and you could use the yaw angle to decide whether the face is looking at the screen (unless somebody is giving their phone side-eye, of course).
Oh, that was atrocious. 
Yeah, I could sort of guess at what the interviewer meant, but most of the questions reveal to me that the interviewer doesn't know their subject matter. 
If an interviewee gave answers like these to me, they would not get hired. 
These are just like ... my opinion man (Lebowski reference) 1. Namespaces: Classes are your namespaces, everything else is overkill 2. enums with strings: doesn't the preprocessor do this for you with # already ? 3. public get, private set: don't use a property just use instance variables and accessor methods. How often does this happen ? 4. autogenerated constructors: this leads to code bloat and a lot of code bloat ! 5. nullability: nullability is a stupid and even bad idea with respect to Objective-C I think the number one topic to reduce code in ObjC would be to merge @interface and @implementation into something like this: &amp;#x200B; `@class Foo : NSObject` &amp;#x200B; `+ (id) init` `{` `...` `}` `@end` &amp;#x200B; that can be parsed as both a header and a source file. (I will eventually get around to do that). &amp;#x200B;
I excruciated with this for years but have well come to rest. I did computing science, know oo, and enjoy objective-c. Being a passion programmer, it is so much more important to be able to READ what is going on when i come back to source rather than having to remember mountains of automatic stuff done by the compiler. I really enjoy verbose code for its elegance, and enjoy objective-c. I just don't like terse languages. The fact that swift is both terse and at least at the beginning aspired to read like natural language means its been fighting itself ever since. I fully admit its valuable to web designers who started from html scripting.. but not for me. 
Hi fellow developers! Let's just say it — there are a lot of apps that require calendars. I think it was our 3rd or 4th calendar from the scratch when we realized we could (and shall) spend much less time on it. It inspired us to develop a universal solution and create an open source library "Crispy Calendar". We've put a lot of efforts to make it as easy as possible in all ways — usage, integration, customization. It's written on Swift but fully supports Objective-C. Please feel free to use it in your next app :) And feedback is always welcome! 
I haven't pulled it to test it out yet, but is there a way to quickly switch years?
Not for now, probably we'll add it in the upcoming updates. thanks for the question :) 
Objective C is a remarkably good language given that it predates nearly every other language on the list, only C is older than it. Every other language on the list is newer and actively being developed, if only Apple put half the effort they are putting into Swift into Objective C... Objective C when used with C++ standard library (algorithms, containers, optionals, smart pointers, templates and so on), has more modern features than Swift.
Been doing a lot of Swift work lately, and my god, do I miss being able to use Objective-C for everything. I mean, I'm not imagining that Objective-C is just a much more productive language than Swift, am I?
I've never used Objective-C with the C++ standard library, but it sounds interesting. Do you have any links to some good examples demonstrating this?
https://medium.com/@husain.amri/objective-c-deliver-us-from-swift-3a44d3ac00e7 https://pspdfkit.com/blog/2016/swifty-objective-c/ 
Thanks!
This is from the “DOOM Game Engine Black Book”. I thought you might appreciate the quote! 
I just tan across Cox's book on Object Oriented programming from 1986/7. It looked interesting but I'm kinda only into C and Pascal for vintage programming.
&gt; "NS" stands for the alliance between NeXT and Sun Microsystems 🤯 🤯 🤯 🤯 All this time I thought it was NeXTStep!!!
Still not ObjC fast. I think we're several years away from that.
I'm pretty sure that is inaccurate. OpenStep was the name of that alliance. NS predates it. On the original topic, though, it's interesting to me that this difference in philosophies lives on today in the different design priorities of Rust and Swift. They're very similar in many regards, but this Brad Cox quote captures the spirit of where they diverge.
NS was introduced in NeXTSTEP 4, the release used for the OpenSTEP specification. I can’t confirm the Sun relationship but the prefix does not predate the alliance.
Thank you, I guess I was thinking of NX. Sorry, y’all.
NeXT, Sun, and Apple were all pretty vague about what the "NS" stands for, and it pretty much depends on who you ask. At the time that the OpenStep initiative was announced, I heard from different people that it stood for "NeXTSTEP", "NeXT-Sun", and "Neat Stuff". There was never any official statement on the matter.
FWIW, the first time Stroustrup presented C++ (I forget which conference it was), he emphasised that C++ was *not* "object-oriented", because he wanted to distinguish it from Smalltalk and Simula. C++ didn't really have messaging as we understood it in Smalltalk. I remember when I first evaluated it, I came away with the conclusion that it didn't offer much more than typedef, at the cost of far too much complexity.
IIRC, NeXTStep 4 was just called OpenStep. Or at least OpenStep for Mach.
Bingo
C++ is a steaming pile of needless complexity. It causes brain damage that convinces mediocre programmers that memorizing the minutia of this steaming pile is tantamount to engineering skill.
This is the kind of charm Apple had before Timmy took over and made it all toneri and tonesity.
Reminds me of this [gem](https://www.youtube.com/watch?v=_DvEpWR66_8) from the IE6 era.
This is all new to me. What targets does the compiler target? Is it agnostic to CPU architecture? What about OS? Can it be used for embedded?
The compiler is a "clang with modifications" to support mulle-objc. So all targets supported by \*clang\* are also supported by \*mulle-clang\*. Cross-compile support is part of the compiler, but not yet in the \*mulle-sde\* toolset (currently working on it). So cross-compilation is not very comfortable yet. On the OS side, if the OS can run bash and you can compile \*mulle-clang\* there (you need some gigs RAM) then yes. Embedded ? Depends on RAM available. I don't think Objective-C makes much sense if you don't have at least 1MB of memory, because of the class/runtime overhead.
&gt; I don't think Objective-C makes much sense if you don't have at least 1MB of memory, because of the class/runtime overhead. Agreed. I'm thinking of ARM systems that are capable of running Linux which have between 32M and 1G of RAM. It sounds like as long as I'm compiling on the target itself, it's fairly straight forward?
I think the major obstacle will be to get the compiler built, because the link stage uses up so much RAM. The actual process of building the compiler apart from being time-consuming should be very simple, since a [build script](https://github.com/Codeon-GmbH/mulle-clang/blob/mulle_objclang_70/BUILD_MULLE_CLANG.md) is supposed to do everything. I would be very interested in hearing your experiences as I haven't done that yet. Also it may be possible to build the mulle-clang binary on a x86\_64 linux for an arm linux, but I haven't done that yet either.
How is this different than Cocotron or GNUStep? I am interested in cross platform ObjC development but can’t get Cocotron and GNUStep configured correctly. I would love to give this a try. RemindMe! 12 hours 
I will be messaging you on [**2019-02-13 14:22:45 UTC**](http://www.wolframalpha.com/input/?i=2019-02-13 14:22:45 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/ObjectiveC/comments/akyo5g/crossplatform_objectivec_mulleobjc_014_released/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/ObjectiveC/comments/akyo5g/crossplatform_objectivec_mulleobjc_014_released/]%0A%0ARemindMe! 12 hours ) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
[https://mulle-objc.github.io/]() should give a good overview and [https://mulle-kybernetik.com/mulle-objc]() is more technical. A full explanation how mulle-objc is different to Cocotron or GNUstep would probably fill a book. The major philosophical difference is that Cocotron and GNUstep both play feature-catch-up with Apple but mulle-objc tries to be better than Apple :) Also the scope though is different, Cocotron or GNUstep provides AppKit compatibility whereas mulle-objc provides Foundation compatibility only. Though a UIKit based on mulle-objc is under development, compatibility with Apple UIKit is only a minor concern. 
I even spoke to a NeXT/Apple engineer at WWDC a while back who joked that it stood for "NameSpace" :)
I don’t know but probably old books about objc can be useful 
I almost bought the 1987 version of Brad Cox's object oriented programming book a few days ago. I know that it was in gcc so maybe you may want to look through old release notes. I know that Objective-C 2.0 was a pretty big deal and actually wasn't too long ago, maybe 2010? I can't think of many changes after that. Well object literals. Maybe that came with LLVM (sometimes called clang). You should maybe get Brad Cox's old book and familiarize yourself with Smalltalk.
What kind of version history are you looking for? The wikipedia page has a ton of info, but it's not in a nice timeline so you'll need to read through things a bit [https://en.wikipedia.org/wiki/Objective-C](https://en.wikipedia.org/wiki/Objective-C)
**Objective-C** Objective-C is a general-purpose, object-oriented programming language that adds Smalltalk-style messaging to the C programming language. It was the main programming language supported by Apple for the macOS and iOS operating systems, and their respective application programming interfaces (APIs) Cocoa and Cocoa Touch until the introduction of Swift. The programming language Objective-C was originally developed in the early 1980s. It was selected as the main language used by NeXT for its NeXTSTEP operating system, from which macOS and iOS are derived. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ObjectiveC/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Objective-C 2.0 was released in 2007 as part of Mac OS X 10.5 Leopard. There have actually been quite a number of changes since then, including (off the top of my head): - Object literals - Automatic property synthesis - Blocks - ARC - Object subscripting - Nullability annotations - Lightweight generics - Designated initializer enforcement
I believe its possible to build the compiler in an ARM VM, but man is it slow. See: [Build mulle-clang on a virtual ARM machine on QEMU/Ubuntu](https://www.mulle-kybernetik.com/weblog/2019/arm_qemu_ubuntu.html)
This [Objective-C Quick Guide](https://www.tutorialspoint.com/objective_c/objective_c_quick_guide.htm) should get you started, I think.
Thanks for your reply. I’m gonna see it!
Another source: https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html Don't be afraid of the bracket message-calling syntax, it is merely syntax, that's all. With time you will understand the genius behind it.
ohh thanks for the reply! I will take your advices.
 Thanks for your reply. I’m gonna see it! 
You can make command line apps easily enough, but GUI apps are going to require access to the includes for the various system frameworks. Pretty sure those come bundled with Xcode. You may have to install it, but I don't think there's anything forcing you to use it. The compilers are open source. You can either use Apple's packages, or install a package manager like MacPorts, Brew, or Fink. Those should also have ObjectiveC compilers. Also, take a look at [GnuStep](http://www.gnustep.org/), which is an open source, mostly compatible reimplementation of NeXT's OpenStep (Cocoa) if you want to side step Apple's GUI libraries. GnuStep does a lot, but much ofMac OS's functionality is contained in frameworks beyond Cocoa. Let us know how it all turns out.
Thanks a bunch for the info! I think I've got everything I need installed at this point, but unfortunately for me, basically everything I want to be doing via Objective-C will be related to GUI and the menu bar. The good news is that after some hours of searching, I managed to find a small bit of functional code that launches a window via a .m file. I was able to compile it with clang, which gives me hope that I can figure this out! So the biggest obstacle at this point will be trying to figure out how to call the right things within Objective-C to get the parts of the UI that I need. It seems to be this information in particular that is most obscured, as virtually all of the available resources I've found use Xcode drag and drop methods to do these things. I'll keep wrestling with the code I've got until I can get something figured out. Thanks again for the reply!
Yeah, I don't think there's much documentation on the .nib file. That's one thing you may still need Xcode for, although I'm sure GNUStep has a similar tool.
https://www.tutorialspoint.com/compile_objective-c_online.php You can run Objective-C here without installing anything.
Nib files were used as far back as 1988 when the NeXT cube first shipped so I don't know what you mean by doing it "old school".
You don't need interface building if you use xib (nib) files. UIKit is pretty well-documented generally. You could look at the headers in the framework files jf you wanted. Also there is documentation on Foundation and UIKit generally that may be useful.
I know this isn't what you're after, but xcode is a true joy to use. Don't worry about swift if you don't care for it (i dont), objective-c is very much there. The beauty of code completion is it allows you write very elegant code that reads almost like pseudocode if you enjoy style like that. I know vim has some level of code completion, but i doubt you can connect to the frameworks?
Any text editor + objc compiler can be used, but everything in the language is implemented with developers using xcode in mind. You are shooting yourself in the foot by not using it.
To be clear, I'm mostly referring to the modern nib files, which I believe have changed since they were originally introduced. But by, "old school", I'm referring to the time when coding was less about abstractions and more about having a solid, thorough understanding of hardware. Back when things like interface builder were considered a nuisance to deal with, because it was buggy and most developers already knew how to build the UI without it, and its limitations. To this day, you can write and compile Mac applications on Mojave in pure C--that is, with no Objective-C, Swift, .m files, etc.--but few know how to do it, and it takes like 100 lines of boilerplate code anyway. I'm not looking for anything that intense, though; I'd just like to write Objective-C code without all of the abstractions that come with extra files and dragging and dropping things in place without understanding what's going on at the code level.
Darek Banas made a vid on YouTube about it
[Imgur album](https://imgur.com/a/XNfZzj5) with the same graphic for other programming languages - for comparison! | If you want more information on how these were created, it can be found [here](https://www.globalapptesting.com/blog/picking-apart-stackoverflow-what-bugs-developers-the-most)
##r/DataArt --------------------------------------------- ^(For mobile and non-RES users) ^| [^(More info)](https://np.reddit.com/r/botwatch/comments/6xrrvh/clickablelinkbot_info/) ^| ^(-1 to Remove) ^| [^(Ignore Sub)](https://np.reddit.com/r/ClickableLinkBot/comments/9wy10w/ignore_list/)
Thank you for the suggestion. Contrary to how it might seem from my post, I don't mind Xcode. I have nothing against it, other than the fact that it is making the non-Xcode methods harder to come by. My brain just doesn't deal well with abstractions. Or at least, I don't find them interesting enough to want to learn. I generally like to go as low level as I can tolerate, so I'm really just interested in developing applications with a simple text editor and a terminal window. It just feels nicer that way to me. Honestly, once I learn the lower level methods, I could see myself moving to Xcode. I just want to get the foundations down first is all, really. And I'm okay if that means extra frustrations at first. It's fun to learn! \^.^
Wow, that's really cool! Thanks for sharing!
I am, and I'm not. It's harder, absolutely no doubt about that. But I also think that this method leads to a more thorough understanding of the code and APIs that can only come from removing unnecessary abstractions (or years and years of fighting against them)
There may have been time like that on the old Mac OS (6,7,8,9) but not for the NeXT based OS (OS X). NeXT always had Nibs and abstractions. As a NeXT developer you were crazy if you didn't use IB for your UI.
Xcode doesn't have any abstractions like eclipse. You can treat it like a text editor with code completion if you want. There's nothing else you have to do with it if all you want is your header and implementation file. I used to in distant past think that terminal based things were elegant like that. For code, its not. But i know first hand we have to do what we have to do, so all i can say is expect to enjoy yourself, specifically with xcode, once you're done. Are you comfortable with objective-c? The best tutorials for macos development seem to be here: https://www.raywenderlich.com/macos. They are a little bit stale, and written in swift so often you'll have to rewrite a demo project in objective-c (great learning itself to do this) but probably the most comprehensive source there is.
Hand rolling ui simply isn't valid anymore. I've done both over the decades, and from comparing both approaches source code ui appears very foul. Its just not right any more. When i write code today, i have a preference to put as much as possible in the storyboard, essentially promoting it to a top tier component along side source, not just a resource. Storyboards are magnificent. They will take a good 1/2 dozen small projects to master, its impossible to teach or get understanding from any tutorials, but when you can use it on command, and in both directions (ie, start from the code or start from the storyboard, you only get taught storyboard first generally) its great. You know you're there with it when theres zero wiring up code, probably the stuff you want to do, in your code :) EDIT: Just in case this helps, story boards aren't exactly a code generator. They're more xml that represents user interface with its own lifecycle / processing. Im not certain that it holds things that are only capable in that context, but there are definitely things that are only *practical* from there.
Thanks for the tips (and for the site you linked earlier)! Yeah, I'm not as anti-Xcode as my unintentionally implied in my post, I'm just trying to do things with .h and .m only. I am actually using Xcode to write the code, and once I can figure out how to get everything else out of the way, I'll also be using it to compile. Right now I've been using terminal to build, as Xcode doesn't seem happy when I delete the plist file that it doesn't need But yeah, I think the big thing is just going to be figuring out how to interface with the AppKit UI elements. I don't mind using storyboards and stuff if I also learn the code way, the problem is just that I can't seem to find _anything_ explaining how to translate those drag and drop motions into programmatic code... At least, not for MacOS applications
Hello again. Assuming you're building a macos application, while you may not need Info.plist, macos does! If you rightclick on any application and 'Show package contents' into the files, there is one for every app! Second, that's because its NOT programmatic code. From early java that's how it worked, but the storyboard files (and im guessing nib/xib files) aren't just editor assets waiting to be compiled, they're real assets used by the program and the code OS. Im pretty sure theres probably a specification for them somewhere, but it sounds like you may not be putting enough weight onto what these things actually are. They are the interface... There's no magical interim step that makes an objective-c file with view addsubview that gets compiled.... EDIT: What about this? https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/LoadingResources/CocoaNibs/CocoaNibs.html#//apple_ref/doc/uid/10000051i-CH4
Huh, interesting about the plist thing; I did not realize it was required by the OS. Since I've been compiling in terminal, I guess it has just been using Terminal's plist. So thanks for that correction! But based on the link you gave, I think maybe I didn't explain myself very well, although I did learn a lot from reading that. Basically here it says this: &gt; With nib files, you create and manipulate your user interfaces graphically, using Xcode, instead of programmatically. I'm essentially saying just that. Nib files aren't programmatic, so instead of using nib files, I _do_ want to do it programmatically. But the exact semantics that I chose to explain that, I think did reveal a fundamental misunderstanding of Nib files. I did not realize that Nib files are literally the interface. So, to be clear, are you saying that the information from the Nib files doesn't exist at the assembly level? Like how, when you write `a = 10;` in C code, that `a` doesn't exist at the hardware level--only the number 10 does EDIT: Thanks again, by the way. Information like this is essentially why I made this thread, so I really appreciate you sharing your knowledge!
Glad you're having fun, its great stuff. Well i learn't a few things from skimming though that link too. My previous understanding of nibs was from the excellent stanford courses for ios development, including back when they covered objective-c (macos is essentially the same now except you use appkit instead of uikit). My prior point could have been wrong, but to the topic of why you wouldn't do it, its right there in that link: "Note: Although you can create an Objective-C application without using nib files, doing so is very rare and not recommended. Depending on your application, avoiding nib files might require you to replace large amounts of framework behavior to achieve the same results you would get using a nib file." What's much better than what i explained was further down in the "nib object lifecycle" section, the explain at a high level whats going on. All that stuff you'll have to implement by hand to get anything working.. where right now its being done by the nib loading framework. Its not trivial at all. Also i personally would have no idea where you would find the object model for things like the object graph they referred to.. ive never seen that exposed (but haven't looked admittedly). But hey, its all about having fun with it, so good luck. I'll end again saying xcode is a joy to use. It makes you happy when you work with it. If you're completely fresh to it (and want to go through the hoops of getting and ios device and itunes u OR downloading an older version of itunes somehow :).. The stanford courses are the best content available for learning. Its full on oo though, if you're not confident with oo in general it will go over your head. The first few lectures id definitely recommend though. the mvc pattern is core for mac os too... basically macos is the same as ios except in name of the frameworks and the detail for a few of the built in controls (and the concept of a window). https://itunes.apple.com/au/course/developing-ios-7-apps-for-iphone-and-ipad/id733644550 They have up to date classes with swift (yuck) if you're interested in the latest. Xcode is significantly different today as well, but not in terms of using the storyboard.
Carbon is the classic Mac OS C API, but it only allows you to build 32-bit apps and Apple is removing it with macOS 10.15. It wasn’t available for NeXT but Apple ported it to Mac OS X.
I still find it a nuisance and I don't use it. You can use Xcode without bothering with interface builder. InterfaceBuilder.app back in the day would actually instantiate your objects and you dealt with a live UI inside the app. When you saved a NIB file it was an archive of the objects. What you get now is similar, it's an archive of the objects. Either way you're just writing out and reading in a bunch of configuration details that are possible to do in code. 
IB was a great way to learn how all the interface objects worked together... but it was certainly not required. It has always been a tradeoff and in my opinion it's become a bigger mess over time. In my past experience, becoming proficient with the coding aspect means that you don't need to IB to handhold you through UI design. But it is certainly a tool in the toolbox. I prefer to not deal with storyboards and all of that cruft though. 
&gt; Hand rolling ui simply isn't valid anymore That is simply not true whatsoever. 
&gt; Note: Although you can create an Objective-C application without using nib files, doing so is very rare and not recommended &gt; Depending on your application, avoiding nib files might require you to replace large amounts of framework behavior to achieve the same results you would get using a nib file lol no. IB is a tradeoff. You get visuals and it comes also with weirdness and pain, trying to track down behaviors that are buried behind checkboxes and pulldown menus. If you have a very complicated UI it can help you visualize and assemble it but if you can visualize it in your head, there is no huge overhead in this. But there is a really big benefit in coding it direct, because you can read code and you can understand changes version to version a lot better when comparing side by side in a source code repository. All IB is, is a visualization tool that saves what is essentially a configuration file. Depending on your skillset, it is more efficient to use it in some cases, and less in other cases. It also introduces weird behaviors from inadvertent changes that are a lot less likely when you instantiate and configure interface elements directly. I use third party code and write my own, and don't have to turn to IB at all and it's not even anything I think about. 
The brackets make it beautiful. They only look weird to you because C++ wanted to look like C to get people to adopt it, and then Java wanted to look like C++ to get people to adopt it, and then Javascript wanted to look like Java to get people to adopt it, and then a bunch of other languages were influenced by a generation of people who learned from those three as templates. 
Objective C is not any more "verbose" than any other language. The old pre-Foundation kit objects were pretty clean and terse. This: id list = [List new]; ... [list add:anotherObject] [list at:index] Got replaced with: NSMutableArray *array = [[NSMutableArray alloc] init]; [array addObject:anotherObject]; [array objectAtIndex:index]; There are reasons for some of this which are good, and there is a factor involved where things have gotten out of hand (code like objectAtIndex:index reads very redundantly and is cruft that gets in the way of understanding the code). Taken to it's extreme we have some methods and classes that have simply insane names, and that in turn generated a need for code completion because nobody can remember exactly what words are to be used. It got like this because of successive generations of programmers, and Swift did a good thing in terms of pruning the cruft down, but that's not Swift so much as simply some bad implementation decisions in the Objective C kits. The language itself allows you to make a method like this: - doSomething: :arg1 :arg2 :arg3; And it's perfectly valid. Just becomes harder to type check, which is what lead us down the road of NSOverlyVerboseClassNameCruft having to get inserted everywhere. You don't *have* to do that though. The idea behind the language was intensively polymorphic and dynamic so you were not supposed to care so much about what you were talking to. I personally don't find Swift to read very naturally either. It seems to be like a clusterfuck. Example: @objc open func animate(xAxisDuration: TimeInterval, yAxisDuration: TimeInterval, easingX: ChartEasingFunctionBlock?, easingY: ChartEasingFunctionBlock?) { _animator.animate(xAxisDuration: xAxisDuration, yAxisDuration: yAxisDuration, easingX: easingX, easingY: easingY) } That is none of clean, elegant or terse. That is just ugly and it shows that design choices in implementations ultimately decide how things are perceived as being crufty or being clean. 
There's not a whole lot of people getting jobs as MacOS programmers. I for one hope it means that a lot of people have flirted with Swift initially and decided to continue their projects in ObjC. 
There's a niche in use and demographic for every language sure. I think the offensive part was apple promoting this terse language as *easier* to use, and insanely suggesting it for children or non geek types to learn how to code on. The fundamental difference between stuff you type (code complete) is when you type less, you have to *remember* more to use it, where the opposite is a few more letters and tabs, but you don't have to remember as much, because its "redundantly" written there in the syntax. Swift has some dumbness, probably from having to following objective-c so closely, but the main killer in my opinion is inferred types. Its a great area, but you end up with syntax that is nothing but a sequence of words. This fine for really basic stuff, trying in a playground, even os scripting, perfect stuff. But when you start to involve os frameworks and the like in your code, its just sub optimal. Unless you have specifically memorised the api and its object model, there's always an extra 1/2 step or step to find out what you're doing with it. The feature of hiding stuff actually makes things more difficult if you havent rote learned what you're doing. Which is just nuts. I hate it. The major truncation of control structures and the free stuff also makes it unduly cryptic, but im not sure if that's standard or not in terse languages and im only used to more traditional ones. What i like about the syntax you don't like is.. well in my personal travels, its the closest code that reads like pseudocode. I think its elegant for that. I get real satisfaction out of english sentence code. Of course you don't type it out its all completed so theres zero headwinds on getting it on the page.
I pasted that directly from apples documentation. Its not my quote. No its not. All you're describing there is what you know vs what you don't. Assuming you had full understanding about how to use the storyboard give it another go. None of the problems of variable or unstable behaviour occur if you get the concepts behind what you're doing. There is some truth there that it is a graphical representation, so unless some frame also behaves variably when you call it by code its just a matter of learning it. I won't try and say you haven't had bad experiences with xcode, but we must be doing different things because its fine for me. That's fair.
I agree, and they've long stopped looking weird to me. Dot-notation, as they say, ain't all that. When I write Objective-C, I almost never mix dots and brackets. For me, it's: [[self view] setNeedsUpdateConstraints]; and not: [self.view setNeedsUpdateConstraints]; 
Stop trying to push Swift. No one wants it. It is losing to Objective-C as more people wisen up and realize how broken it is https://www.tiobe.com/tiobe-index/
It looks like you've copied part of line 66 from the `itemsDownloaded` method above. In the `itemsDownloaded` method signature `items` are declared as an `NSArray`. In your header file (or the class extension at the top of this file) you'll see that `\_feedItems` is also declared as an `NSArray`. `_feedItems *items = …` is in the form of a declaration. Unfortunately `_feedItems` is not a type, so the compiler is showing you the error. Since both `\_feedItems` and `items` refer to an _instance_ of `NSArray your declaration doesn't make sense. What you need to do is find out what _type_ `\_feedItems' contains and replace the beginning of the line with that. You will probably also have to cast the value to that when you assign it. Let's say that your feedItems array contains items of type `MyType`. `MyType *item = (MyType*)_feedItems[indexPath.row];` would solve your problem.
ohh ty veru much appreciate it &amp;#x200B;
&gt;feedItems array can i ask you something again ?
&gt;It looks like you've copied part of line 66 im following this tutorial maybe that clears it up a bit [https://codewithchris.com/make-a-iphone-app-for-your-wordpress-site/](https://codewithchris.com/make-a-iphone-app-for-your-wordpress-site/)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/learnobjectivec] [hey guys just a noob asking a question](https://www.reddit.com/r/learnobjectivec/comments/b0mecg/hey_guys_just_a_noob_asking_a_question/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Restart the simulator. If that doesn't work restart Xcode. If that doesn't work restart your computer. The simulator gets mucked up occasionally. ¯\\_(ツ)\_/¯ There's no way to automatically fix warnings (unless it's a fix-it warning, the one with the white dot inside the circle.) As a rule you want to keep your code warning free, it's worth it. I've found that if you're converting types it's often easiest to cast to `id`. ``` if ([object isKindOfClass:[MyModel class]]) { MyModel *model = (id)object; // Do stuff. } ``` I don't know what kind of warnings you're getting, so I can't help you beyond that. &gt; my errorlog is empty what do I do Make sure that your debug console (lower right) has the output set to "All Output" not "Debugger Output" or "Target Output".
There is an option to reset the simulator, which will delete all settings and files on it, did you try that?
No not yet i am just done with work ill try that tomorrow and let you know 
Thank you i fixed the errror of that the debug is not showing any error but the problem is i followed a tutorial where im getting data from an website using an rss feed so the code is a bit outdated and i dont know how to find the correct code tomorrow i will post a screenshot of the warnings 
&gt;I don't know what kind of warnings you're getting, so I can't help you beyond that. let me add a screenshot of the warnings im getting
&gt; https://i.redd.it/0oqxf9k9m8m21.png &gt; `UILineBreakModeWordWrap id deprecated` 'Deprecated' means it's no longer allowed, but was once considered correct. The next warning tells you you should use `NSLineBreakMode` instead. In Objective-C enums are used to designate a group of choices. They tend to be fairly verbose, but I find that helpful. Generally their options are of the form `[Enum name][option name]`. In this example `UILineBreakMode` is the name of the enum, and `WordWrap` is the name of the option. In iOS 6 the UIKit and AppKit versions of the line break mode enum were combined, with the old UIKit version being deprecated. What you need to do here is replace `UILineBreakModeWordWrap` with its `NSLineBreakMode` counterpart. If you were to Command-click on the `UILineBreakModeWordWrap` in Xcode it would show you the definition of the enum and all of its other options. It may even be nearby its replacement, `NSLineBreakMode`. The other warnings are similar. The method `sizeWithFont:constrainedToSize:withLineBreakMode:` has been replaced with a similar, but slightly different method. Clinking on that warning will probably tell you what to replace it with. The most difficult one is the one on the bottom. `UIAlertView` was replaced with `UIAlertController`. UIAlertController works differently because it's a UIViewController, not a UIView. With UIAlertController you'll need to create the controller and then present it from a UIViewController.
oh damn dude thanks i will try and fix the warnings and make an controller (i guess thats the problem with following an old tutorial) but i couldnt find one witch was so on par with what i have to do but thanks tho !!!
do you maybe know where i can fix this error : Terminating app due to uncaught exception 'NSUnknownKeyException', reason: '[&lt;ViewController 0x7f977861e2f0&gt; setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key TableViewHome.' i dont know where to find the line of code where the error is 
It looks like you have a xib or storyboard file with an outdated connection to an IBOutlet. Find the storyboard with `ViewController` inside. Right click on the view controller object. Look for an outlet with a yellow 'x' badge and disconnect it. 
i will do that thanks &amp;#x200B;
How was it ?
I just checked it out..he stopped after 4 videos because he got too many requests to do a Java series. But I do appreciate this comment because what he did provide was a good primer. 
You're welcome
Biggest reason is that Objective-C is C with enhancements, and plain C is the fourth most dreaded language. So the real question is really why it's even higher than C. My opinion: like Visual Basic (the most dreaded language) it's applicability is narrow. Unless you're only writing Objective-C, you have to re-learn its quirks and idioms when you've done your other work.
Cause everyone is used to C style languages, while objc is different. It took me almost 2 days to really understand how to pass a second parameter and that method names can contain spaces. People dread what they don't understand or aren't used to.
I think sigh w objc it might be the @s and []s
Sometimes when there is a perfect replacement, the language become more dreaded. Obj-c is \*not bad, just that Swift can almost (not yet for some case) replace it. why obj-c is \*not bad, consider calling a method this: ``` // in c/c++ myLuckToday(13,13,4,19,13,13); // in obj-c [ myLuckToday age: 13 day: 12 month: 4 year: 19 hour: 13 mintue: 13 ]; // in swift myLuckToday( age: 13 day: 12 month: 4 year: 19 hour: 13 mintue: 13 ) // &lt;--- no semicolon here :) ``` Of course swift behaviors similarly
Java has @s
At the moment the preferred way for macOS apps is to use Cocoa (AKA AppKit). Cocoa is Objective-C (or Swift, which offers good interop with Objective-C). So there's no easy way to avoid learning Cocoa for a macOS app (for being native and old-school). The nice thing is that Objective-C has a great interop with C, so that you can put any C code into your .m files as well. If you want to go really-really old school, and write pure C from the ground, you can use Carbon (that's a C API emulating "classic", pre 200x macOS), but that is ancient, and can't be seriously recommended other than for pure interest/fun/archaeology. If you want to jump from .m to pure .c land, it is doable as well, but you have to write your own wrappers for Objective-C classes and delegate interfaces (AKA protocols). Calling a C function from .m is no problem. If you want to do a reverse, you can make a C function inside .m that calls your object. For the protocols you might succeed with callbacks, i.e. pass function pointers from .m to .c, such that when you call it from .c, it calls a desired protocol method. Usually "self" is wrapped in some form of opaque struct type, and C calls pass this as the first argument.
Consider rewriting your method. Six parameters is a code smell.
I mean to demonstrate one is smellier than another. I could do better.
People who freak on minor bits of unfamiliar syntax are incompetent pussies and snowflakes.
I do not miss manual reference counting.
Why? Putting them in a struct or a class and passing them isn’t any better.
ObjC syntax is art
This is the brilliance in ObjC. It introduced new programming paradigms without breaking existing C code, unlike C++ `int* class = malloc(sizeof(int));` Is legal C and ObjC, not legal C++
Here's the class @interface just incase you wanna look at that `#import &lt;Foundation/Foundation.h&gt;` &amp;#x200B; `@class XYPoint;` `@interface Rectangle : NSObject` `{` `int width;` `int height;` `XYPoint *origin;` `}` &amp;#x200B; `@property int width, height;` &amp;#x200B; `- (XYPoint *)origin;` `- (void)setOrigin:(XYPoint *)pt;` `- (void)setWidth:(int)w andHeight:(int)h;` `- (void)translate:(XYPoint *)vector;` `- (int)area;` `- (int)perimeter;` `- (void)draw;` `- (void)drawLineAtColumn:(int)beginColumn To:(int)endColumn;` `- (void)dealloc;` `@end`
The *SwiftUI* framework seems like a great leap forward over UIKit and AppKit. As someone who loves working in Objective-C, the sad thing for me is that it seems like my favorite language is getting no love. These features would have been great in Objective-C, but it seems like it's not going to be offered. It will be exclusive to Swift. Anyone know anything different?
&gt; great leap forward over UIKit and AppKit How do you override drawRect from SwiftUI? For that matter, how do you even associate animations with the layout?
&gt; great leap forward over UIKit and AppKit How do you override drawRect from SwiftUI? For that matter, how do you even associate animations with the layout?
Objective-C isn’t quite dead yet, but Apple just took it behind the woodshed and is telling it about a beautiful farm upstate.
I think that's a fair characterization. When Microsoft came out with .NET, they pushed C#, but they didn't stand in the way of VB programmers. (Sure, there was some pain for those who didn't want to get onboard with the VB.NET paradigm, but it was essentially the same language.) But, Apple is a strange bird. It's almost as if for one to live, the other has to die. If they come out with an advanced UI framework and don't offer it to Objective-C, they've effectively killed it. And the sad thing is, Objective-C is a dynamic language. Whatever the UI framework is doing, it could have been—perhaps even better—on Objective-C.
I must be an outlier, but the introduction of SwiftUI is concerning to me. I really liked the strong crisp separation between view and controller that nibs/storyboards afforded. I don't want positional UI stuff in my main code class. But TBH I really don't love Swift either so maybe I am Crusty.
Hmm I mean it’s almost like apple couldn’t give af about developers. They’ll do anything we want for a shot at that sweet sweet App Store money! Welcome to the programming dystopia.
I did not even think that far into it, but you’re right :-(
Yeah, another Crusty guy here.
Someone please make ObjectiveCUI.
Considering it’s entirely written in Swift, as opposed to a UIKit wrapper, I highly doubt there will be obj c support
Only if they remove the non swiftui ui frameworks? Should be a while until that happens.. in the distant future its probably going to happen. The hipsters in swift are so excited about it, but to me its the other hand of apples planned obsolescence engine.
It's not just syntax. I *hate* the optionals straight jacket.
Hey i actively enjoy objective-c :( I look at every line i write and i like how it looks... swift is a bunch of random words and i hate short term memory tests (or editor lookups). Yeah after this i've come to the conclusion to just take a stamp and maintain different eras of apple. Too much change for changes sake without maintaining compatibility.. its all by choice too if you dig into it. Im formally putting the anchor down and keeping what i like.
From reading around, i get the impression they're copying popular frameworks from other ecosystems. I quite like storyboards and expressive code.. More classic than a hacked up html hipster sure.
&gt; its all by choice too if you dig into it. I think if you ask, "What problem is Swift trying to solve?" the answer is roping in JavaScript programmers scared off by square brackets and the "threat" of pointers. For all practical purposes, the Cocoa/Cocoa-Touch frameworks don't ask the programmer to deal with pointers, except in the most cursory way. No one is asking you to make your own data structures, or to reverse a linked list, or to perform some kind of tricks to squeeze some functionality into 640K of memory. Swift is the hip new thing with dot-notation. That was the priority set. I don't even care that Apple decided to make a new language. I was actually excited when I watched the keynote, 5 years ago. But "Objective-C without the C" really meant C++ without the C. Swift is a big clunky language with awkward constraints on the programmer and a good deal of line noise. This was not the language to make.
&gt; I think if you ask, "What problem is Swift trying to solve?" the answer is roping in JavaScript programmers scared off by square brackets and the "threat" of pointers. Yeah that's my instinctive reaction too. Over the years ive come to admit theres a valid role in that... so long as its optional. Its just if they turn stuff off, or completely not support new function that will be a problem. It does feel like the floors going after another year of dramatic change for the sake of it. I guess swift people are used to nothing being stable. Its nice sitting on stable old objective-c, but wow the rest of the house feels every year more and more torn up as apple try to push the obsolescence bubble forward.
No, it's possible indicator that all Swift frameworks are not going to adhere to MVC.
I disagree about the most dreaded language. I think the most dreaded language trophy goes to Assembly.
Apple did introduce a few frameworks that were ObjC only. So while ObjC isn’t dead, Apple does seem to be relegating it to low-level frameworks.
I haven't caught with the WWDC yet. Thanks!
Optional isn’t bad when used with primitives. With objects though it is a bit of an overkill and it doesn’t add anything that ObjC couldn’t do
This is off-topic for /r/ObjectiveC.
It doesn't have anything to do with Objective-C directly, but in the bigger picture I believe it does. Spamming the group is my absolute last intention as I genuinely care about each and every response. I just wanted to broaden the conversation to everyone that has their hand in the development process. However, if I keep seeing the same comments/responses, I'll remove the post. Thanks for voicing your concern.
Not aprops!! 2nded!
Will do! I'll take it down now.
Which framework is that?
You can see the new frameworks here https://developer.apple.com/documentation/
I couldn't find Objective-C only framework. I could see couple of Swift only frameworks like SwiftUI, Combine, RealityKit. Could you please provide the name of the framework?
DriverKit is one framework
Unless I'm missing something, DriverKit framework(s) are C++ frameworks, not particularly Objective C. IIRC this is due to some aspects of Swift still not being great for the task.
I missed it is a C++ framework. The documentation had the language in the drop-down as Objective-C.
I followed your same path around 2011, moving to Obj-C from a Java background. At that time I wrote a 10-pages essay about language similarities and differences. I still have it, but unfortunately it is in my native language (Italian), and translating it would take too much time. Try taking a look at [this article](https://blog.codecentric.de/en/2011/04/short-introduction-to-ios-for-java-developers-objective-c/) from Codecentric, it should point you in the right direction. The two languages share a whole lot of principles, you'll find yourself at home in Obj-C after learning its somewhat bizarre (but elegant, IMO) syntax. They are so similar, in fact, that there's a software called [J2ObjC](https://developers.google.com/j2objc/) that "transpiles" Java code into *working* Obj-C code. If you have to develop an iOS app around existing Java code, consider using it to transpile the existing code and limit your new Obj-C coding to the UI part. I do it regularly in a company I work for, and it works beautifully. Hope this helps.
Thanks a lot, checking your suggestions! :)
Learn C first, check out some serious projects (I'd recommend MRI - the ruby interpreter, it's code is beautiful). Objective-C is a very thin layer on top. Learn to say protocol instead of interface, and message sending instead of calling a member. I would not say this will be a quick transition especially if you only know java (and eg. haven't done any JNI). They are wildly different languages. If I were you I'd try very hard to go to swift instead, a lot of the issues with C are because it's very old, it doesn't do modules and such very well, the whole header file system is text-based hacks around that.
Well, I think that Java and ARC Obj-C is quite comparable. You will need mostly adjustments regarding to some aspects of syntax : calling member methods NSObject\* result = \[myobject mymethod: firstArgValue name\_of\_second\_arg: secondArgValue\] pointers, loops through collections (NSSet, NSDictionary) (but in todays version that's also for loop , so that's also similar to Java). I encourage you to start some project and try to find building blocks from tutorials 1. [https://www.tutorialspoint.com/objective\_c/index.htm](https://www.tutorialspoint.com/objective_c/index.htm), 2. [https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html) &amp;#x200B; I more that certain you will want to learn Cocoa and that's where you'll spend more time than just Objc. Then look into Ray Wenderlich courses: [https://www.raywenderlich.com/library?q=objective%20c&amp;sort\_order=relevance](https://www.raywenderlich.com/library?q=objective%20c&amp;sort_order=relevance) &amp;#x200B; Good luck
Awesome, thanks a lot! :)
Thanks! I will work with an existing project, so choosing swift is not an option for now. Later maybe, but now I have to contribute to an existing code base.
Would you mind sharing your 10-page essay even if it’s in Italian? That would be great!
Sure, will do it tomorrow.
If you're still interested, PM me and I will send it privately.
If you can code already the offical apple document linked in another reply is probably the best. You'll need itunes-u, but https://itunes.apple.com/au/course/developing-ios-7-apps-for-iphone-and-ipad/id733644550 Lecture 3 and its slides are also pretty good. That entire class is amazing so for the fun of it worth running though. Most of it is still current.
🍺
I like Big Nerd Ranch books generally BUT both their ObjC and Mac programming books are completely out of date (years! many OS revs!) - they've 100% jumped onto the Swift and iOS bandwagon and pretty much abandoned the ObjC and Mac markets. Strictly they are only following Apple's lead but a lot of people still use both and there are still advantages to both.
+1 for the Kochan book. I used it to teach myself Objective-C (and to program in general) many years ago and always recommend it when people ask.
The `Podfile.lock` addresses the problems with repeatable builds &amp; state. https://guides.cocoapods.org/using/using-cocoapods.html I prefer gitignoring the Pods directory to keep my clone &amp; fetch times lower &amp; keep my diffs cleaner when I upgrade 3rd party libs. Doing a `pod install` on switching branches has become second nature to me and I barely notice it in my workflow.
And just to add, be sure not to \`pod update\` as part of the normal workflow. It will ignore the Podfile.lock and attempt to pull in the latest (untested) versions of the pods.
You probably want to look up Rich Text Editors. Something like this: [https://github.com/Deadpikle/macOS-Rich-Text-Editor](https://github.com/Deadpikle/macOS-Rich-Text-Editor)
If you’re using IB, there’s a checkbox with the option to use the Inspector Bar. If you’re doing it programmatically, there’s a book value usesInspectorBar that you need to set to true. What you won’t be able to do is do any customization to it. At least not easily.
Didn't know that the inspector bar existed. Worked perfectly! Thanks!
This was my go-to for this http://fuckingblocksyntax.com/ Or the SFW url: http://goshdarnblocksyntax.com/
You would pass the block as a function/method argument. The trickiest bit is figuring out the variable declaration and invocation IMO. I always have to look it up. You can also invoke it without ever seeing it via the standard methods like delegates or notifications. It depends on whether the source and the invoking method share and/or which provides the block and which is invoking it.