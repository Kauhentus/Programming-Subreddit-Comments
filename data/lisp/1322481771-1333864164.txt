are these available for download anywhere? i'd like to see if i can clean up the audio a bit...
&gt; "Rewrites considered harmful", right? Try near project-suicidal
Vsevolod Dyomkin is the person to ask.
Yes, the audio is really terrible, you could download all the videos with [keepvid](http://www.keepvid.com). Hope that helps. edit: link
I would like to add that the slideshow to Zach Beane's talk about Quicklisp in ECLM 2011 can be found on this [blog entry](http://xach.livejournal.com/298815.html) 
There's RESTAS and Weblocks. I would assume that Weblocks is active (got that whole Lisp Alien logo thing going on), I don't really know about RESTAS though. EDIT: Also Parenscript for Javascript stuff, there're lots of smaller utilities available.
[Allegro webactions](http://www.franz.com/support/documentation/current/doc/webactions.html) 
It still builds, so if it breaks, it's somewhere at runtime. It's still available in Quicklisp and will remain there until it breaks for good.
thanks.
that works, thanks.
http://lisper.ru is written and maintained by the developer of RESTAS (archimag) and uses RESTAS. The source is somewhere on github. archimag also writes cl-closure-templates which is supposed to be compatible to google-closure-templates but output CL code instead of Java. I've written a website using [cl-closure-templates](http://code.google.com/p/cl-closure-template/), [RESTAS](http://restas.lisper.ru/en/) and [bknr.datastore](https://github.com/hanshuebner/bknr-datastore) (for database, docs in src/*/tutorial.lisp). You can install everything with quicklisp. The only problem was google-closure-templates's very limited template language which made me consider Peter Seibel's [FOO](https://github.com/gigamonkey/monkeylib-foo) a few times. And bknr.datastore is a great db but only if your data fits into RAM. Otherwise you should probably use mongodb with [mongo-cl-driver](https://github.com/archimag/mongo-cl-driver) or PostgreSQL with [Postmodern](http://marijnhaverbeke.nl/postmodern/).
UCW doesn't use hunchentoot luckily ;)
ucw-core is indeed alive and usable. It's not particularly active -- the the core library is pretty solid and ucw-standard gets the job done. I've mostly been hacking on lisp-on-lines level stuff for the last long while...
Yes, because it's useful, and built-in. Stick to situations where it is terse and clear. If it gets hairy, break up and rethink the problem. http://l1sp.org/cl/6.1 would be a better link.
Reddit and Firefox are two major counter-examples. Spolsky might have been wrong on that one.
When I began learning Common Lisp I vowed never to use the LOOP abomination. But not long into writing my first nontrivial program I began to use it happily. It captures some common operations quite well -- stepping through multiple sequences at once, destructuring, collecting, step intervals, and more. My queasiness about LOOP fully went away when I looked at the macro expansion of some simple examples. It's mostly mundane stuff such as holding a reference to the tail of a list for efficient collecting. When you have a general idea of what's happening behind the scenes, it becomes completely non-scary. Once in a while I write a non-LOOP version of some random LOOP form, and the LOOP version almost always wins in clarity. I never got into ITERATE because I try not to write LOOPs complex enough to justify ITERATE.
I'm just looking something that provides functionality beyond what hunchentoot + cl-who provide.
I read the source code to the libraries. There's not much there. How is the blows-the-doors-off functionality surfaced *via Lisp* if it's not in the libraries?
&gt; Try near project-suicidal The website isn't that complicated, and I can move to Lisp in a piecemeal fashion. (This is a 1-man show with LOC measured only in the small tens of thousands - not Netscape Navigator.) There are other benefits I hope to gain, but "it's written in PHP" is pithy, and I'd like to focus on available web frameworks rather than my motivations.
&gt; I've mostly been hacking on lisp-on-lines level stuff for the last long while... Hacking on l-o-l itself or hacking on things at a comparable level of the web stack?
Well, watch me spreading FUD about a nice piece of software. :( I misremembered. I fixed my post.
In my view, frameworks are (well, should be) the result of factoring out common patterns shared by websites. I think there's at least some mileage that can be gained, even though some amount of functionality will always need to be hand-coded, no matter the framework.
So is the product I work on (MusicBrainz). I didn't say guaranteed, I just said near :)
Not strictly lisp, but there's a [Try Clojure](http://tryclj.com) for clojure.
&gt; In my view, frameworks are (well, should be) the result of factoring out common patterns shared by websites. Look, I'm doing web programming in Lisp since 2004, both using heavy-weight frameworks (UCW) and a couple of my own small frameworks, and my opinion so far is that Hunchentoot is almost as common as it gets (i.e. extra functionality probably won't be common). Well, almost. I've made a very generic and lightweight layer on top of Hunchentoot which, essentially, implements hierarchical request routing and some goodies. But even though I tried to make it as general as possible, I recognize that it implies certain application-writing style, and sometimes it just adds unnecessary complexity -- e.g. if you don't need hierarchy you can just use `hunchentoot:define-easy-handler`. &gt; I think there's at least some mileage that can be gained Sure, framework always gives you something, but at same time it makes it harder to implement things in your way and it adds some complexity (= steeper learning curve). Cost/benefit depends on application. In some circumstances it makes sense, e.g. when your application is very well aligned with framework's design OR you don't have necessary experience to make app from low level components. But you didn't mention what application you're doing, and all I can say in general -- Hunchentoot is your friend. BTW if you're interested in a minimalist framework I was talking about above I can share it with you. (Well, it doesn't sound like you're interested in something minimalistic, but still.) It's not yet open source, but we were planning to release it anyway 'some time soon'. Obviously, it's not very well tested as it was used only internally, but on the bright side I can provide all required support. To give you some idea how it looks like: (with-web-node (make-instance 'template-directory-web-node :parent *root-node* :name "example" :template-dir (merge-pathnames #p"example-templates/")) ;; defines handler for /example/foo ;; using template in #p"example-templates/foo.tpl" (def-template-web-node foo () ;; code which generates parameters to fill HTML templates goes here `(:random ,(random 100) :name ,*name*)) ;; /example/bar?quux=$1 uses $1 as a template parameter (def-template-web-node bar () (with-params (quux) `(:quux ,quux))) ;; returns raw text, without templating (def-dynamic-web-node baz () (princ-to-string (random 100)))) I believe this is close to absolute minimum of code you need if you have hierarchical URLs and you use templating, but it is also simple to plug in something unusual (e.g. def-dynamic-web-node). There are also goodies which let you to implement centralized authorization/authentication handling, for example.
&gt; I never got into ITERATE because I try not to write LOOPs complex enough to justify ITERATE. The point of ITERATE isn't just that it can do more complex things than LOOP, but also that it can do the things LOOP do with a cleaner and more Lisp-like syntax. I've never been able to make Emacs indent LOOP forms properly, and this by itself is sufficient reason for me to prefer ITERATE. On the other hand, a disadvantage of using ITERATE compared to LOOP is that it sometimes compiles to less efficient code, at least with some Lisp implementations.
This was also posted here today, it's worth a look although not strictly what you are after: [The Common Schemer in Lisp](http://www.streichholzschächtelchen.de/rcl/part2.html)
I am not able to open the link. It has some special characters in it. Googling did not help either.
Thank you.
Yes. Properly written code using loop is likely to be clear. When you read code written with loop, it should say exactly what it will do. It is the epitome of proper lisp coding style, because it has takes something that can be quite hairy and transforms it into something simple and easy to read.
[Practical Common Lisp](http://gigamonkeys.com/book/) is a book rather than a tutorial, but is a very good introduction. It is available online in the link supplied as well as on paper.
I too am interested in good Lisp tutorials. After programming in a hobbyist fashion for the past 31 years (two of which were spent in study for a B.Sc. in Computing Science, while junior high and high school I pretty much did whatever I wanted as I (*cough*) knew more than my teachers did at the time), and after a few weeks now I understand the basic concepts of Lisp and am actively seeking more thorough material for self-instruction; I devoured *Land of Lisp* in a little under a week. This language has always captivated my imagination and now I have time to indulge, even if it amounts to nothing more than a personal achievement that only I will know of. Or I can always transition back to Forth for shits and giggles. 
Thanks! :)
I think the link was edited. Here is the original link I caught this morning: [The Common Schemer in Lisp](http://www.streichholzschächtelchen.de/rcl/intro.html) Oh hmm. In Firefox, if I open it in a new tab, HTML encoded characters are inserted, and it does not work no matter what I do. If I just click on the link, it does not take me there either (can't find it), but I can then highlight the URL, hit ENTER, and bam, I am there. When I copy-pasted the link, it worked fine for me. So if you are using Firefox, click the parent's link, and then do the highlight-ENTER trick. It works for me that way.
On LoL itself -- the main change in the pipeline is fancy ajax support at some point (I have months old patches that need to be dusted off when the mysterious project-using-lol is caught up enough for me to get back to fancy feature hacking). Also lots of stuff for interaction between call/cc and normal code (descriptions activated in call/cc code may eventually carry over to normal code...), a rewrite of the html-description to work way better, etc. Still no tolerable docs however :(
Well, since part of my income relies on ucw-core continuing to work hopefully that's a ways out!
You can always go back to working versions with Quicklisp's time-traveling library setup!
Do you have an example of things that ITERATE generates less efficient code than LESS?
Unfortunately, I don't have an example at the moment, and of course, it is implementation-dependent. I have observed it mostly with SBCL, which emits copious amounts of performance-related warnings when compiling code with high optimization settings. I vaguely remember getting lots of type inference related performance warnings various places where I used ITERATE, and these warnings often disappeared when I replaced with equivalent LOOP forms. This happened in code with lots of type declarations, compiled with high optimization settings. I guess it would have been possible to solve this problem by adding various type annotations inside the ITERATE forms, but that would make using ITERATE harder than using LOOP, which defeats the purpose. I haven't found this to be a common problem, though. I use ITERATE almost all the time, and only fall back to LOOP or DO in the occasional performance-critical low-level functions where ITERATE generates slower code.
&gt; I have not used Lisp, but I have used Scheme ... Oh, *do* shut up.
&gt; Still no tolerable docs however :( Is this everything that's available in the docs department: https://github.com/drewc/lisp-on-lines/tree/master/doc ? I've been wanting to try my hand at documentation writing. If I get into l-o-l, I'll definitely get in touch.
If you've ever been curious about Paul Graham's Arc, it's very easy to try it out here without having to install anything. Hope you enjoy.
A nice clean Lisp. Most of it looks like it could be achieved with a few macros. The additions I saw were the element subscripting syntax and the composition : operator, both of which are quite nice. But it doesn't solve any real problems. I would have liked to see a solution to packages, for instance. CL packages have nickname and namespace conflicts, and are difficult to share. This really holds the language back. On top of that... where are the libraries? After all the press, Arc is little more than a nice Lisp101 project. Oh well, I guess PG has more important things to do, doesn't he? :) 
Damn. I just copied the web page name into my comment. It appears to have some strange characters in the name. I'm at work now, I'll check back when I get home and post a better link for you.
When I tried iterate the things I liked had little to do with writing complex loops: 1. Iterate clauses can be used within arbitrary lisp forms. 2. The (finding x maximizing y) clause is clearer than the loop equivalents. 3. No DO. It just does. 4. The live documentation via (iterate:display-iterate-clauses) is nice. 5. Extensibility makes me feel all warm and fuzzy. 6. I have come to prefer editing s-exps to editing loop style code. That said I don't think I will be sticking with it, due to the cost of carrying around an extra dependency, use of prime symbol real-estate, extra burden on human readers of the code, and the compiler efficiency warnings which LoyaltyToThe mentioned. Edit: Deleted examples because reddit refused to preserve their formatting.
I've failed to open the link. It looks like the reason is umlaut in it. 
It should map to one without an umlaut: http://www.xn--streichholzschchtelchen-87b.de/rcl/intro.html
Yet the sites in .рф zone open just fine. I wonder how does FF decide which non-ASCII characters need to be encoded and which don't.
CL packages have the potential for namespace conflicts, but in practice, it is not a widespread problem. Packages are in fact easy to share. Persistent misinformation is more of a problem for Common Lisp than the package system.
&gt; Persistent misinformation is more of a problem for Common Lisp than the package system. I agree, but CL _feels_ crufty to me too - I think it is the size of the hyperspec and the less than uniform style of naming for symbols therein. Abbreviations and hyphens don't seem to be deployed with uniformity over the names in the hyperspec, so you end up with weird things like `fmakunbound` for removing the function definition from an environment, but `make-hash-table` for creating hash tables. Common Lisp is undeniably the most appropriate Lisp for heavy duty programming, and I think much of the other negative feelings about it come from wanting it to be something it isn't (something more like Python), but I don't think that CL is the apex of Lisp either. 
WTF? S-expressions aren't a data structure. The underlying data structure is linked lists (or cons cells, if you want to go a little lower). S-expressions are just *syntax* for representing linked lists, and they're not "the most powerful data structure available", which doesn't even really make sense. I think the guy who wrote this doesn't know much about lisp...
Has arc seen any 'official' development in the last year or two? The install page still recommends arc3, which I think was released in 2009. I don't know what happened to it, but it's clear that it's not even being maintained at this point. I can't recommend it and I'm not going to invest in learning it (well, more than I already have) or using it. 
It's possible to have short, unique names. Nicknames are not practically guaranteed to conflict; that you've run into conflicts is a bummer, but not a tragedy.
&gt; CL packages have the potential for namespace conflicts, but in practice, it is not a widespread problem. Lisp is brilliant, but CL's package system is poorly designed for distributed programming. Modern languages offer hierarchical package names and file-level namespaces for a reason: they enable programmers to develop libraries without worrying about causing conflicts. CL presents a double edged sword: if you make the package name unique, it becomes unwieldy (com-mycompany-mypackage:symbol), if you make it too short, you're on the road to creating conflicts. When you're writing a library for drawing graphs, what do you call it? How about a library for graph algorithms? Is yours going to be the only one? And nicknames are practically guaranteed to conflict at some point. I know I've come across this at least a couple times when I was using CL. It's designed so poorly, and the solution is so obvious - why not allow the reader to assign the nickname? Another place where a file level namespace would be useful. Franz, Inc (#1 commercial Lisp, for those who don't know) recognized the problem, and extended the package system with hierarchical names: http://www.franz.com/support/documentation/8.2/doc/packages.htm#hier-packs-1 This follows the lead of modern languages (Java, Python, Ruby). Unfortunately, it's probably going to be impossible to hack file level namespaces into CL (actually, I did at one point, but it was messy), which is why it's a great design feature to be addressed in "the-next-great-Lisp-like-language".
My point was, if you're designing a new Lisp, this is one of the places to improve. Arcs changes are cute, but relatively superficial. 
Ha, I knew there was a reason my blog stats went crazy.
`(foo . bar)` is a s-exp that isn't a list, but is a cons.
I would say that s-exps are one of the most general data structure available, insofar as you can use them to represent pretty much anything, and you can build more complex data structures on top of them. For a given task, however, there are certainly better data structures available that are arguably more "powerful". But if you want to equate power with generality, then sure. 
&gt; Arcs changes are cute, but relatively superficial. I actually think it's worse than that, because Arc uses the same symbol to mean very different things from other Lisps; `=` for assignment, `let` for single binding, `with` for multiple binding (reversing the two) and the semantics of `if` with more than three arguments becoming `cond`-like (kinda sorta). I think Arc has some neat ideas (and neat people like catdancer and Ken Shirriff) , but you are 100% correct in noting the superficiality of many of the changes. 
I think [Anarki](https://github.com/nex3/arc) and [Rainbow](https://github.com/conanite/rainbow) have overtaken the official release for quite some time now and both seem pretty lively. Arc is probably going to be similar to scheme: no real official implementation, lots of little ones, some more feature rich than others, with the difference being that Arc's specification is a simple text file and Scheme's is a pretty well-read document. It is pretty hard to want to spend time on something that seems to have the same problems as Scheme (many many implementations) with none of the benefits (maturity, papers written, community involvement, niche interpreter for your platform, &amp;c.). 
I used loop quite a bit before deciding I prefer iterate. Now I tend to use iterate almost exclusive to other iteration schemes. Obviously I recurse when something is better expressed recursively. I have occasionally run into the type annotation problems mentioned by LoyalToTheGroupOf17 but they tend to be somewhat easy to resolve. I like iterate more because * Better, less ambiguous syntax for the same things * I like the iterate manual and can almost always find what I am looking for quickly * Uniformity in iteration constructs helps me and my coworkers read the code I've written with less confusion (eg mixing lots of do's, maps, loops, and iterates tends to lead to more ambiguity of semantics than just using iterate (or loop, or do)). I still use the others if there is a compelling reason, but tend to use iterate almost everywhere. 
You don't need hierarchal package names to avoid conflicts. You can name your package as "com.example.foo.mypackage" without hierarchal packages, or you can use URI's. `|http://www.reddit.com/r/lisp/|`as in XML There is also library for hierarcial package names for CL. Lisp is programmable programming language. You don't need to create new language if feature you want does not exist. 
Yeah, i mentioned cons cells, but 99% of the time the cons cells are forming a linked list.
&gt; #1 commercial Lisp, for those who don't know I'm curious, how exactly do you know that it's No 1, and not No 2 behind, say, LispWorks?
&gt; I don't know what happened to it, PG lacked the time and/or motivation to work on it. &gt; but it's clear that it's not even being maintained at this point. What did you expect from somebody's unimportant part time project? PG somewhere even stated that all of his objections to CL are basically solved with Scheme, but that his main excuse for wasting his time with Arc and not going directly with Scheme was that he "doesnt like the scheme community". So he went on to create something that basically walks and talks like a Scheme, but is not a Scheme, solely to get rid of Scheme users. And oh, it's implemented as a set of macros on top of (you'll guess it) MzScheme.
I'm glad you brought this up. arc3.1 was actually released quite some time ago (also in 2009, I think) but the official install page wasn't updated to reflect this. That's a shame, because arc3.1 is much easier to install, since it runs on the latest versions of Racket. Here is the link to download arc3.1: http://ycombinator.com/arc/arc3.1.tar
It is the most expensive.
Yes, it is fair to call Arc's changes superficial. However, since most of its changes are to core operators, they do have an impact on everyday programming. I like how Arc uses fewer parentheses than CL, and how the names of its operators are less cryptic. Here is a snippet to illustrate: ; CL ; Arc (cond ((= x 1) (setq y 1)) (if (is x 1) (= y 1) ((= x 2) (setq y 2)) (is x 2) (= y 2) (t (setq y 3))) (= y 3)) But as you point out, breaking away from the standard names makes it hard for other lispers to read your code. And if you prefer any of Arc's operators, you can probably implement them for yourself in CL using macros.
Switch "powerful" with "expressive" and I'm on board, with one caveat: s-expression references aren't very pretty, #0=(1 2 3 . #0#) 
The invocation needs to be: (screamer:one-value (stone-split 40)) . Nice solution though.
Hierarchical namespaces is, IMO, a failing of Common Lisp. I haven't invested the time I would need to design a solution though, so I can't holler too much. I *hate* file-level namespaces ala Python/Java/Ruby. Linking the *file* to a code-level namespace is a mindblowingly bad idea that should have been recognized as such the moment it came into being.
I personally like Lispworks much better, but I know the former CEO of Franz and was in semi regular contact w the Lispworks guys. It was kind of a generally acknowledged thing. Franz is also a much bigger group - 30+ people still. Lispworks was only about 6. All the folks I know at Stanford/SRI used Allegro too. I tended to be the only Lispworks guy of the folks I interacted with.
Why?
Right, but my point is that "[t]he underlying data structure" is the cons cell, not the list. Whatever, I'm just being annoyingly pedantic. 
Fixed. Are you the one who commented?
&gt; Yes, it is fair to call Arc's changes superficial. However, since most of its changes are to core operators, they do have an impact on everyday programming. I don't think *all* of the changes are superficial, but many seem to be. The short hand syntax for lambdas &amp; composition of functions are pretty neat, for instance, as are application of data structures (which Lush had quite some time ago!). &gt; I like how Arc uses fewer parentheses than CL, and how the names of its operators are less cryptic. As a Scheme programmer, I find most of Arc's names are more cryptic than they're CL counter-parts, because they're not only unfamiliar, they have different semantics (like `if`, and `let`/`with` do the opposite of their normal roles) and they're not descriptive at all (`pr`/`prn`, `=` for setq/define). &gt; Here is a snippet to illustrate: See, Arc's `if` looks like it would be really easy to miss something to me, and it looses the ability to treat the right hand side of `cond` as an implicit `PROGN` to boot. I agree with you that less parens are indeed a positive point, but I use: (cond (= x 1) (set! y 1) (= x 2) (set! y 2) else (set! y 3)) Which has less parens than CL/Scheme normally **and** alleviates accidentally treating something as an else that you really meant as a condition. &gt; But as you point out, breaking away from the standard names makes it hard for other lispers to read your code. And if you prefer any of Arc's operators, you can probably implement it for yourself in CL with a macro. That's exactly the problem; Clojure is very different for a Lisp dialect, in some regards, but it brings definite benefits. Arc brings some neat things to the table, but overall falls somewhat flat. Having said all that, I *really* like the idea of exploratory programming that has a central focus in Arc, I really like some of the things the community is doing (how long did it take for simple C/JS/Java compilers &amp; implementations to appear?), and the general *idea* of Arc, but the system that came out (and the hype that surrounded it) just didn't really resonate with me personally. Oh, and by the way, I assume that this is your site; very nice job btw,the site looks quite polished and works as I would expect.
&gt; I assume that this is your site; very nice job btw,the site looks quite polished and works as I would expect. Yes it is. Thank you for the kind feedback. :-)
Yup.
Why what? I will assume you are speaking of paragraph #2. In the "real world", you don't always have the ability to organize your code into what your language asks of you. Further, you may not even have files. Coupling the namespace layout and the filesystem layout has given me grief time after time after time in my Real World Job (tm). I'm sure if you buy into the Way of the language, and have the time to invest in formatting your code organization the Right Way, things work right... until something changes. 
Defining A-SUBSET makes it expressible even more directly. https://gist.github.com/1411365#file_broken_weight.lisp
Or using screamer's backtracking search to check that each weight can be expressed, instead of unrolling a backtracking search by hand.
"actually, it's not a Lisp at all" Yes it doesn't read as or feel like a Lisp. "Clojure gives up on all these principles if not altogether, than substantially: many of the features are there and the new ones arrived, but the backend is missing" I couldn''t get past the square brackets.
Great thinking from Tobias, as always. Too bad that startups suck so much time out of sharing such thoughts…
I'm not on my dev machine, but it looks like the problem is [here](https://bitbucket.org/S11001001/weblocks-dev/src/786584157376/src/server.lisp) at line 149. There were some earlier commits on the dev branch for hunchentoot compatibility so this is probably the branch to fix it on. What replaces the default handler in the new hunchentoot, btw, does anybody know? I've not used it yet.
it would appear the answer to my question is [here](http://lists.common-lisp.net/pipermail/tbnl-devel/2011-October/005649.html) in the thread on the 1.2 release
☮ ☘ ☁ ❄ ☃ ✈ ☳ ☠ ✝ ✡ ☯ ☥ ♁ ♛ ⚅ ⚛ ⌚ ☄ ䷊ 
☮ ☘ ☁ ❄ ☃ ✈ ☳ ☠ ✝ ✡ ☯ ☥ ♁ ♛ ⚅ ⚛ ⌚ ☄ ䷊ 
I've upvoted, not because I agree or disagree, but because I think it deserves thinking about. I did find the discussion on "what makes a lisp" a bit disingenuous. That whole discussion seems to be be used in whatever context the writer feels that it would add/detract to the argument.
Is your submission title accurate or sarcastic? Since you posted gibberish I'm not sure now.
Whimsical! 
Anyone know if multi-threaded Hunchentoot is functional on Windows?
Not yet unless you use akovalenko's tree from github, think there are binaries available. David Lichteblau is in the process of getting that merged into master in the coming months.
&gt; minor incompatible changes: &gt; RENAME-FILE on a symbolic links used to rename the linked-to file instead of the link. &gt; DELETE-DIRECTORY on symbolic link to a directory used to delete the directory, but now signal an error instead. I would think they are Major
I'm starting my sixth week of a three month gig building an app for the iPad using Objective-C and Xcode. It's been a while since I've used an IDE but I really hope Xcode isn't the state of the art. Coming from developing Common Lisp on Emacs/Slime and Unix I'm severely underwhelmed by Xcode: - It crashes about every other day, sometimes more often and I haven't been able to nail down why (although it has recovered nicely so far); - Undoing some actions in Interface Builder messes up the interface; - The auto-completion list is much too large half the time with all kind of useless entries; - Auto-insertion of square brackets is wrong half the time (like you wrote: I guess I haven't fully adapted my way of working to the IDE yet); - lots more which I don't care to recall right now... This is using the most recent Xcode on OS X Lion. The way I develop software I spend most of my time navigating around, duplicating lines (and changing them), moving code around and of course inserting. Emacs and Vim are unmatched in this regard. I also tend to work cross platform for my own projects and obviously Xcode isn't very supportive for that either. 
For others who are curious (like I was) what akovalenko's tree is, see http://akovalenko.livejournal.com/35889.html 
Last week I saw the German version at a local bookstore: Lehmanns in Hamburg. http://www.lehmanns.de/shop/mathematik-informatik/20121536-9783826691638-land-of-lisp
great stuff! Those guys were so ahead of their time!
Nice. I'm still waiting for a list of quicklisp packages with single line descriptions like [this](http://cran.r-project.org/web/packages/available_packages_by_name.html) Perhaps a manifest (or a static dump) of a fully loaded lisp image (running on quicklisp.org) would be a good place to do this.
I'm working on something like that, preliminary output is here: http://www.quicklisp.org/beta/UNOFFICIAL/docs/
This looks really nice. It'd be cool if you could add/edit documentation right from the browser as well.
 ;;; Apples to apples... (defun sum-below (x) (loop for i from 0 below x sum i)) 
I should stop reading articles about Lisp, it just makes me feel smug and superior.
Better to read (and write) Lisp code.
I program in Lisp and found the article intro (I'm about to read the rest, just came to see the comments after that weird intro) a little bit *too* smug. The "crème the la crème"? Really? I call BS.
Why do authors always integrate the goddamn REPL for whatever game they're showing people? In any other language demonstration, you'd make your own prompt and read a string in for your input. Using the REPL makes CL look lame and clunky in comparison.
DO NOT LEARN LISP!!!!! It will ruin your programming life, since you will want to use it all the time, but be forced by other non-believers into inferior languages. It is like spending a week at a restaurant of the gods: all other food will seem bland and boring afterwards.
Considering some of the drawbacks of Lisp (limited editors, low number of users, less internet help, hard to find a job etc.... ) why use it unless you think it is the "crème the la crème"?
You call it drawbacks. I call it an exclusive club!
The other parts. http://www.linuxforu.com/2011/07/lisp-tears-of-joy-part-2/ http://www.linuxforu.com/2011/08/lisp-tears-of-joy-part-3/ http://www.linuxforu.com/2011/09/lisp-tears-of-joy-part-4/ http://www.linuxforu.com/2011/10/lisp-tears-of-joy-part-5/ http://www.linuxforu.com/2011/11/lisp-tears-of-joy-part-6/ 
Why go through the effort of implementing your own prompt, deal with parsing arguments, connecting things up to functions, etc, when you already have a fully functional REPL that gives you access to absolutely everything?
To help people with understanding some basics. It depends on what material you want to cover first. With Lisp, it is just easy to jump into its manipulation features since it already supports a kind of user input. Conrad Barski's book -- from which this article obtained its graphics and examples -- moves on from the basic REPL to explain how to make real, interactive prompts via *standard-output* and *standard-input*. He applies the interactive prompt to one of the games that started out as a basic Lisp-provided REPL game, integrating it with minimal changes. He covers various warnings with regards to security and the user's input. By the time you get to it in the book, it makes sense.
I've noticed how common it is for people I meet at Lisp conferences to tell me that they wish they could program in Lisp but are required by their employers to use another language. I feel privileged to be able to use Lisp in my own business, which is a natural food supermarket. I have a key employee who worries that we won't find someone to maintain the programs I write if I become unavailable. (I'm currently contemplating doing a point-of-sale system.) I tell her that the Lisp community is pretty small, but it's exceptionally talented and interested in having opportunities to use Lisp.
&gt; Considering some of the drawbacks of Lisp (limited editors You dont need more than one. &gt; why use it Because I enjoy it. &gt; unless you think it is the crème the la crème Which is mostly irrelevant.
You see, I do believe Lisp is, at least conceptually, the "crème de la crème". What I do see a problem with is with the notion the author tries to claim that Lisp Programmers are the "crème de la crème", "the top percentile". A little bit too arrogant to my taste. The language doesn't make the programmer.
Nowadays most Lisp looks to me like Haskell code but with more parenthesis. :-)
thanks.
There is no part of that that isn't awesome. :-) 
Thanks for having shared that :)
Rob, we're actually looking for some old code that you'd written if you'd like to drop by sometime and talk to Hannes or I.
Thanks, this link works
I'm glad. This problem is only going to get worse over time of course.
I agree, why not show a command parser and maybe a defmacro for game commands. You would get a lot more mileage and be able to show people how it actually works... reading lines and using a hash-table and creating macros.
To me, all code looks like lisp with either more or fewer parenthesis, and sometimes different types of parenthesis...
If you email me ( rob at robmyers dot org ) and let me know what the code is I can have a look? I should have just about everything on CD or zip disk.
My biggest complaint about examples that make heavy use of the REPL is repeatability. That is, yesterday I might have gotten halfway through an example but had to stop for whatever reason. If I come back to it today, a lot of context has been lost, and if CLISP has exited for some reason, you have to re-type all the parts you'd already done.
1. [Set up Emacs + SLIME](http://www.reddit.com/r/lisp/comments/fcpr1/common_lisp_quicklisp_slime_howtos_for_windows/) 2. Do everything in a file, and just hit C-c C-c to send the expressions over to CLISP rather than typing them directly into the REPL. There you go, repeatability.
Really happy to see progress here. Thank you guys for bringing cliki in 2011 :)
Ok.... so I read this a couple days ago, but this part has been bugging me: &gt; And if you’d shown people Ruby in 1975 and described it as a dialect of Lisp with syntax, no one would have argued with you. If that's true, then shouldn't it be relatively easy to write a better version of Ruby with Lisp? Coupled with the power of CL, it seems like that would be a better Ruby than Matz's Ruby implementation. Obviously it wouldn't be source compatible with Rails et al, but it could put a more friendly syntax on top of CL, which is a pretty big benefit in its own way for the allergic-to-parens set. Just a thought....
Get over it.
Why is it JSON-based? (I'm not even sure if the following is true, it's just a wild guess) Oh and I don't think there's anything you could do about that without going into some kind of extreme hacking which would only lead to incompatibilities.
or live in cl-user.
This helps. I was more just wondering if there's something I was missing the past few years I've been playing with lisp (like the ability to inline a file). Putting (in-package ...) at the top isn't a dealbreaker though, so I think I'll stick with consensus for the time being. Thanks!
True, this is how non-namespaced languages do it essentially. Never even thought of doing it this way (been in package land for a while now). Thanks!
Sorry, I didn't clarify: it's JSON-based because it's going to be a web api.
Don't do this. Implementations import all sorts of things into cl-user, which can lead to symbol conflicts.
Yes, there's and it's called LOAD, but you shouldn't really use bare LOAD for organizing your code loading (use ASDF).
I read the first one, which of course wasn't a "post" but a technical correspondence, and the author of the article didn't even write the headline that is now all too famous.
Package land does have the advantage that instead of restarting all of Lisp in order to reload all your symbols, you can just drop the package and recompile the code in your files. Others have suggested to me in the past that one should start with all the code in a single file and then organize later as needed, grouping things of similar behavior together. Organization is a form of premature optimization.
The thing to keep in mind is that you need to think not in terms of individual files, but in terms of your entire Lisp image. The fact that you can store Lisp code in a file is just an implementation detail: what matters is what is loaded into your image. Within the image, you use packages to keep your namespaces isolated.
It might be worth noting that other languages such as Java have a convention/requirement of documenting the package name at the top of the file, even when in that case it's also a requirement to organize source files according to package. So there's a benefit in the case other developers who might be less familiar with Common Lisp or your project come on board and are trying to find their way around. In addition your project might be simple now but many projects as they grow end up having multiple packages. At that point it's helpful to know at a glance by looking at the file what package the code ends up in. Finally, an IN-PACKAGE form at the beginning of the file should only be the start of the boilerplate, I'd think. I hope you at least have a comment saying what the code in that particular file does, and that your files are broken down on somewhat functional lines.
Shortened link goes to http://alfredodinapoli.wordpress.com/2011/12/17/lisp-development-in-modern-times/ 
The purpose is to make you aware that I've ported a cool TM bundles in TM2, and I'm constantly improving it. It's a way to inform who possess a Mac OS X computer that he has another alternative to choose from, and I think this is a good thing. I can't explain all this downvotes, honestly. All I wanted was to share with you my enthusiasm..
Misleading title.
sorry, but is the original blog title.
&gt; not close to the cool look and feel and speed of Cocoa Native Applications. Yes, it doesn't. Good thing about Emacs is that it has its own style. It works more-or-less the same pretty much on all platforms one could imagine, both in graphic and in text mode. So it can be the last editor you'll ever need. You can use Emacs on remote server over SSH, can you do this stuff with Textmate?
Inaccurate title. You're implying that it's modern to use textmate2 on Mac OS X, and thus people using, say, latest version of Emacs on Ubuntu are somehow not 'modern' enough. Some people might find it insulting, you know. If you mentioned that it's about textmate2 + sbcl bundle on mac os x, people who are not interested in mac os x or textmate would just ignore. But you've lured more people into reading the article and got downvotes for wasting their time.
From TM2, yes :) I'm not arguing that TM is better, I love Emacs and Vim too, I don't want to start an editor-flame-war :) 
Well, I didn't want to insult anyone, though. I've already beg a pardon for the inaccurate title, but I think that all this stuff about wasting time etc etc is a bit outrageous, but I'll change the title, just to make things clear. I'm a bit disappointed btw: I though Lisp Reddit communities was more warm and less rude.
Insulting? How can someone insult other by having strong opinions about their choice of editor? I'm an Emacs fan also... but did you ever tough that Lispers that use TM or any other editor may find it insulting all this flame around emacs as the "one editor to rule them all" ? Lets all be nice ... 
And they are! but...it seems sometimes some persons get carried away... I'm an Emacs/Slime user but but always like to look at other options and technologies, so nice work! It's always great seeing someone with enthusiasm doing something about lisp! ITs good for lisp, its good for us! Thanks! I will take a look!
i think it's implying that only Textmate-based development environment is modern.
Thank you, I got really discouraged yesterday :) I'll never mislead a title! I promise!! :D
Sorry, wasn't my intention! I've also changed the blog title, but this link was already submitted, so I can't change it anymore. 
nice! I like the hash-get utility. I haven't released any cl code, only used it for myself, so i'm not an authority to give criticism, but i like the intent. :)
What is the purpose of cl-sym? You can hash on symbols directly. Also it would be nice to be able to pick the together of hash table (eql vs equal vs equalp). I like the interface and think it adds value to CL.
Good point on cl-sym, I actually hadn't thought about hashing on symbol since most of the hashing I do is based off of JSON at the moment. Thanks for bringing this up, removing it will simplify the code too. I guess the only real problem would be if you hashed based on number it's going to assume it's a list/array you're trying to access when you're really trying to get into a hash table. I guess in that case you'd just have to do your own gethash ;). I'll add in a keyword for the :test of the hash to (hash), defaulting on #'equal (for string matching). Thanks for your feedback. EDIT: would adding a :test parameter to (hash) even be possible? I remember reading somewhere that you can't effectively use &amp;rest and &amp;key together, and it would be nice to not have to wrap everything in one more list, eg: (hash ("name" "sparky") ("friends" 0)) vs (hash (("name" "sparky") ("friends" 0)) :test #'eql) Thoughts?
Generally you use macros wrong and there is a strange mix of processing during macro expansion and runtime. * it is unclear what CLSYM is doing and its name does not give a clue. * your macros do processing at macro expansion time. Which leads to inconsistent behavior. For example (hash-get 3 ...) works different than (let ((foo 3)) (hash-get foo ...)). * why do you use macros at all? In Common Lisp the existing GETHASH is a function. Your HASH-GET is not? Why? * If you write a macro, you might want to look at the created code. * For example in HASH you walk over a list at macro expansion time, but the new list is constructed at runtime. 
This is great feedback, although I have to admit I don't understand some of it. * cl-sym has been removed (and the reference to it). I removed it earlier in the github repo but forgot to update this post. * This is one of the points I don't quite understand, but if you look at the macroexpand for this (assuming "obj" is a populated hash table): `(let ((key "name")) (hash-get obj (key)))` will expand to `(let ((key "name")) (gethash key obj))` and `key` will be evaluated to "name". * I use macros because a function would not be setf-able (as far as my knowledge goes, anyway). Instead of creating a custom setf handler for hash-get as a function, I can piggyback onto CL's gethash. * I did, over many many examples ;) * This point I'd like you to elaborate on...I really don't understand. If you're asking why it's a macro instead of a function, really the only reason is a bit more forgiving syntax. With a macro, you don't have to escape every single pair being passed in whereas with a function, each pair has to be escaped: `(hash '("name" "omg") '("location" ...))`. I guess it makes more sense to just wrap everything in a list, which would also allow for the :test keyword. My goal was to do this with the least amount of syntax possible. Thanks for commenting, and please forgive me if I seem ignorant. 
It is possible to define setf-able functions using defsetf, or simply defining a function (defun (setf access-fn) (value arg-1 arg-2 arg-3 ...) ;; forms to set value ) http://www.lispworks.com/documentation/HyperSpec/Body/05_ab.htm How about you write the hash and get-hash utilities as functions, and then define a macro system as a shorthand?
If you do (hash-get *h1* ("interests" 1)) and you do (let ((a 1)) (hash-get *h1* ("interests" a)))) you get two different things. At macro expansion time you are looking if the thing is a number. This is generally unknown if there is a variable. In a compiled Lisp, only at runtime the variable will have a value. Quoting list structured data is nothing unusual. Writing functions as the implementation is the usual approach. Functions can have a clearly defined interface, their invocation is easy to understand. Macro manipulate code - this is much more difficult. You should want to have a function which constructs a hash-table from some list input. (create-hash-table :data '( ...) :test #'equal ...) A macro would allow you to create a hash-table at macro expansion time (for example when the compiler runs it), if there is fixed literal data. This could also be achieved in Common Lisp with a 'compiler macro', while preserving the functional interface. If you want to have a s-expression syntax for hash-tables, then you would write a read-macro and then you can just use the JSON format and have it expanded at read-time. 
First, I think you are right about mixing rest and key params. Don't do that. Your options are basically: 1. What you wrote (IMO the best solution). Alexandria has a method of building hash tables from alists (but lacks your way of doing nested hash tables) and it uses this method of specifying the comparison function. 2. Put an "options" form right after hash like: (hash (:test #'equal) ("location" "city")) This is usually reserved for macros that define an environment. 3. Or, a less satisfying solution, just define HASH-EQ, HASH-EQL, HASH-EQUAL, and HASH-EQUALP since Common Lisp hashes can only make hash tables that use one of those equality functions. HASH could just use EQL as a default. There is a more general hash table library out there where user defined comparison functions can be used, so if you supported this library, this would fall apart. I looked over the interface a bit more and realized that you are doing a bit more than I thought. For instance, using a number to proved a shorthand to a particular element in the value stored in the hash table is a little off, to me. Also, having the hash resolution go left to right as opposed to the normal Lisp right to left is a bit weird too: (get-hash myhash ("location" "city")) instead of something like (get-hash myhash ("city" "location")) It goes against the normal Lisp flow of data (from inside out, from right to left). That said, I can see that it might be more convenient to provide this kind of access, but it should probably be a syntactic sugar on top of a "normal" interface. Also, you have a macro as the main interface. This could be written as functions albeit with a more annoying syntax. The best method, IMO, is to write a function based interface for both the hash building and hash access which is hopefully exposed to via the API. Then, write a light-weight macro wrapper that makes it more convenient to use. Anyway, good luck.
Are you its author? I haven't able to google anything using the query "scorecleaner" lispworks. In any case, looks terrific, and if you're the author, I'd love to see a blogpost or something about the innerings :)
I'm not the author. But at least one of the authors posts to the LispWorks mailing list: Sven Emtell: sven.emtell &lt;at&gt; doremir. com . If you look at the acknowledgements, you can see that the software uses: Alexandria, Babel, CFFI, CL-FAD, cl-18n, CL-PPCRE, CL-STORE, Midishare and trivial-features. Looking at the application, one can see that it is created by LispWorks 6.0.1.
Nice. Now to find a MIDI interface for my ukulele . . .
This is inline with what others are saying: write functions to do the work, write macros to make the syntax better. This is great input. The reason I did the reversed syntax is coming from most other languages with has support, my brain is used to drilling down into the object going left to right. I understand this is different for lispers, so maybe adding a :direction keyword would suffice. Do you have a suggestion on doing number literal access? I agree it's kind of muddy, but I can't really think of an easy way to do it. The goal of hash-util is to make JSON easy to create, and decoded JSON easy to traverse and update, which is why I included the number for traversing lists/arrays since a lot of the JSON I deal with contains arrays.
This seems to be the general consensus: don't write macros to do what functions could. Write the function, then add macros for syntax improvement. Thanks for the link on defining setf-able functions. I knew it could be done, but the last time I looked the process seemed really daunting and complicated (ie I didn't understand it). That was about 6 months ago, maybe I'll grok it better now.
Ok, now I get what you're saying about the number/bound variable. This is a really good point, and another great reason to write this as a function instead of a macro. Thanks for explaining this, I never would have caught it. Really good point about JSON syntax with a reader macro too. Out of curiousity...I understand that this can be done, but is it considered bad form to have non-sexp littered throughout the code?
There is a reason why Common Lisp provides this machinery: it is a programmable programming language. It allows you to adapt the language to your task. s-expressions in Common Lisp is not a fixed syntax. It is implemented by a programmable reader. So you can implement new external syntax for data structures. The book CLtL2 comes with an extended example: Xappings. http://www.ida.liu.se/imported/cltl/clm/node192.html You will see that this is actually similar to JSON hash tables, but on an early massively parallel computer (the Connection Machine) running Lisp...
You might want to look at my [access library](https://github.com/AccelerationNet/access) which is basically an expansion of your hash-get (and includes a setf-able version). There are some differences (such as not dereferencing flat lists for you) but overall seems to have a similar goal and might help you understand setf functions etc.
I'll check out your library. At the moment, I'm particularly interested in making hash-get setf-able (which I don't yet know how to do), so I'll pick apart your code and see if I can get it working. Thanks!
&gt; One thing I would like is to NOT have to do (in-package :www-api) on the top of EVERY file in the project. Why? 
I am on the ScoreCleaner team. If you are interested in anything specific you could post in the spanking new DoReMIR - ScoreCleaner Forums that went up today :-) http://doremir.com/forum
It is also availiable for Windows!
Interestingly, if you search "clozure" in the App Store app, you get no results.
Finally something I actually care about is available in the app store!
It takes a while for initial releases to start showing up in search results. edit: It shows up now
Is the source for the card program (depicted in the screenshot) available anywhere? I didn't find it in ccl-1.6 and I don't have an Apple device.
Cool. Thanks, I missed that. It was probably my blindness as a Mac user. 
will this overlap with Madeira?
Nikodemus wrote "Another way to describe Madeira would be to say that it should cover most everything that I keep having to #+sbcl when writing portable code." So, no overlap.
And all I could think was "Holy fuck, they're Swedish". EDIT: I know nothing about musical notation but that looks really cool.
Sorry, should have mentioned this: the document linked assumes some knowledge of the game rules, which can be found at http://aichallenge.org/problem_description.php and http://aichallenge.org/specification.php .
This request could not be completed. Is this limited regionally?
Given this definition, perhaps Xecto could be eventually madeirized and become portable
that's great news! Installing while typing this!
I'd like to belabor his last point... In your original: *(defmacro hash (&amp;rest pairs) (let ((hash (gensym))) `(let ((,hash (make-hash-table :test #'equal))) (dolist (pair (list ,@(loop for p in pairs collect `(list ,(nth 0 p) ,(nth 1 p))))) (setf (gethash (nth 0 pair) ,hash) (nth 1 pair))) ,hash))) this macroexpands to something like: * (macroexpand-1 '(hash ('a 'b) ('c 'd))) (LET ((#:G755 (MAKE-HASH-TABLE :TEST #'EQUAL))) (DOLIST (PAIR (LIST (LIST 'A 'B) (LIST 'C 'D))) (SETF (GETHASH (NTH 0 PAIR) #:G755) (NTH 1 PAIR))) #:G755) * If you have a macro, you don't have to construct the intermediate list and then iterate through it. It is redundant. Instead, you can simply construct the (setf (gethash thing #:G755) thing) parts. Revised might be: * (defmacro hash (&amp;rest pairs) (let ((hash (gensym "hash"))) `(let ((,hash (make-hash-table :test #'equal))) ,@(loop for p in pairs collect `(setf (gethash ,(nth 0 p) ,hash) ,(nth 1 p))) ,hash))) this macroexpands to something like: * (macroexpand-1 '(hash ('a 'b) ('c 'd))) (LET ((#:|hash748| (MAKE-HASH-TABLE :TEST #'EQUAL))) (SETF (GETHASH 'A #:|hash748|) 'B) (SETF (GETHASH 'C #:|hash748|) 'D) #:|hash748|) * You can save the computer a lot of work by having it only do exactly what you want it to do.
Ahh yes that makes much more sense than constructing a loop. Thanks!
&gt; LispWorks... mainly that you can only use for up to 5 hours a day Incorrect.
The LispWorks Personal Edition is also not 'free' in the sense of 'free software'. It just costs nothing.
Fixed, apologies.
I've disambiguated this, but to be honest I thought it was fairly clear from "free version" which implies there is a "cost version".
And that you can only use it for up to 5 hours a day is... Incorrect.
Yes. It just quits after five hours. You can restart it then.
'free' has especially in the Lisp community a 'special' meaning. See the 'Free Software Foundation' of Richard Stallman (who worked for a long time on Lisp). http://www.fsf.org/about/what-is-free-software If you ask some Lisp users who support these ideas, they will say that tools like LispWorks or Allegro CL are not 'free' (because of their licenses, etc.). 
Right. FWIW, for those following along, according to http://www.lispworks.com/downloads/index.html , these are the limitations of LispWorks 6.0.1 Personal Edition: * There is a heap size limit which, if exceeded, causes the image to exit. A warning is provided when the limit is approached. * There is a time limit of 5 hours for each session, after which LispWorks Personal exits, possibly without saving your work or performing cleanups such as removing temporary files. You are warned after 4 hours of use. * The functions save-image, deliver, and load-all-patches are not available. Initialization files are not loaded. * Layered products that are part of LispWorks Professional and Enterprise Editions (CLIM, KnowledgeWorks, Common SQL and LispWorks ORB) are not included. The product matrix available at http://www.lispworks.com/products/features.html details additional limitations / omissions. (I'm also pretty sure that 64-bit versions of the Personal Edition aren't available for some / all architectures, but I didn't find a URL to confirm that directly.)
You could say "gratis" version so people don't think it's a version that respects their liberty.
I am fully aware of the FSF meaning of free. I merely meant that I felt it was already fairly clear from the context which meaning of free I was employing. Anyway, it should it be entirely clear now.
I think the personal editions are only 32bit. The 64bit version is only available as Enterprise Edition, IIRC. Which is a bit unfortunate, since the 64bit version is much faster - at least on my Mac.
I would say: anything I write that could be helped by adding type declarations. ITERATE (IIRC) uses standard CL type declarations. LOOP has its own funky style that's completely different from everything else in CL, which I never bothered to learn.
Here's a one-liner from the README in the github repo: &gt; The goal is to be able to search all of the online documentation of a running lisp system effectively. (That made it click for me, more so than the blog post.)
I really dislike this style of macro where variables become bound without any explicit binding form. At least when you provide the variable name with an explicit binding form, it's easy to interpolate the variable name into the macroexpansion, avoiding any issue with symbol equality down the road. But, that aside, in this case, you have to make sure that MYMAC::ARG is EQ to MYAPP::ARG. One way to do that is to also export ARG from MYMAC. Another way is to import ARG into MYAPP.
It seems you want the argument to be named ARG. So, your macro expander has to intern a symbol named ARG in the current package. Something like the following should work: (defmacro mymac (name &amp;body body) `(defun ,name (&amp;key ,(intern "ARG")) ,@body)) 
I'm the author of just such a package, called [SNARF.](http://cs.gmu.edu/~sean/lisp/snarf.lisp) Which package were you looking at?
Well, I guess you could include Screamer?
These wouldn't be lisp-specific, but I recall reading about people doing context-oriented (and aspect-oriented) programming in CL.
I don't really like having implicit variables either, it feels dirty. The alternative is for every form that uses the macro to have `&amp;key rawdata metadata` added by hand to an otherwise empty argument list, which is more "correct" but also very expressive. I'll think through what I'm doing and come up with a better way to do this. Thanks for the answer and also the style input.
Dataflow programming: http://common-lisp.net/project/cells
I've been exploring using method-chaining to separate concerns in a lisp-like language: http://github.com/akkartik/wart See, for example, how I start with a simple assignment operator (analogous to *setq*) and [extend it](https://github.com/akkartik/wart/blob/bb9b97be6b/037assign.wart) to support assigning to new types (list index, hash key, etc.), new keywords (*rplaca*, etc.), and to support assigning multiple variables at once.
Interesting question. I've been thinking about it for the past two weeks, as I've been studying some Statically typed languages' frameworks and I always ask myself what Lisp would need for some of the checks I see to be performed at compile time. I can't say I have an answer to those yet, but I'll love to follow the discussion here.
lambdas
This works (noting that "ARG" is case-sensitive)! Thanks for the tip here.
I'm not sure that's any more complex than names in general. I'm not a compiler developer, but I have *really* highly developed personal incredulity skills. :-)
Sorry, but FSF doesn't have copyright/trademark on word free, so one can still use its regular meaning of free instead of FSF version of free. If one wants to specifically use free in FSF meaning of word, it should say something like "Free(tm FSF)(c FSF)"
Better type inference algorithms before you can do any static analysis. Then there's [Qi language](https://en.wikipedia.org/wiki/Qi_%28programming_language%29)
When you say "symbol macros", do you mean [symbol macros](http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/mac_define-symbol-macro.html) or do you mean [macro characters](http://clhs.lisp.se/Body/f_set_ma.htm) (e.g. mapping `'X` to `(QUOTE X)`), *or* do you mean [macros](http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/mac_defmacro.html)? What's a tool-feature that you're thinking about?
Lisp indention rules don't apply to atoms, but to lists, so as a result they don't have any effect on symbol-macros (which are atoms). Same goes for syntax highlighting. Additionally: I don't think of highlighting and indention when I think of "static analysis", and I doubt anyone else here does either.
Are you implying that it would be easy to write static analysis tools for something like Typed Scheme?
Umm... The algorithms for highlighting and indentation really are very simple forms of static analysis. (and reader macros can do much more than just return atoms) That said, most static analysis tools belong after READ, but their messages do benefit from a framework that can associate a form with its source location. Duane Rettig at Franz has some good work on this for CL, and many Schemes (esp. Racket) have useful frameworks.
Those are macro-characters, not symbol-macros, hence, why I asked.
Reader-macros are not symbol-macros. Squirrel_of_doom insists he is talking about symbol-macros. Symbol-macros are not "much more" than atoms.
Please elaborate: static analysis for which purposes?
Before anyone else, even. Kiczales' original paper on AOP is basically a case study of a CL application.
Stronger static guarantees is all that's needed. Currently CL is very much late bound by design, making static analysis of many codebases hard and/or useless. Sealing function signatures. (So redefinitions which alter the signature are not allowed.) Sealing function definitions. (So redefinitions are not allowed.) Sealing generic functions. (So methods cannot be added or removed.) Sealing superclass inheritance. (So class cannot be redefined with new superclasses.) Sealing subclass inheritance. (So class not gain new subclasses.) Sealing slot definititions. (So subclasses slot type cannot change, and subclasses aren't allowed to change it either -- not via explicit :TYPE and not by inheriting from two superclasses that defined the same slot with different types.) 
Unless you're already familiar with existing interactive fiction engines, you will want to take a look at how they handle world-modeling. (Inform and TADS being the two big ones in the field currently, with very different approaches as to how things are done.)
Kind of related : [Creating Languages in Racket](http://queue.acm.org/detail.cfm?id=2068896).
This is just what I'm looking for. Thank you!
Hah, well... Is the game supposed to dynamically generate that kind of combat text? That's gonna be hard, not even Dwarf Fortress has such elaborate descriptions! 
"Paradigms of Artificial Intelligence Programming" will definitely help. There are chapters that go over both decision engines and English syntax parsing.
I think it'd be awesome to at least be able to model some basic anatomy and reactions to attacks directed at specific body parts. Getting down to the level of "shove burning tobacco under toenail of left big toe" might be a little too specific, but it'd also be super fun. Something more practical might be impairing mobility when legs are damaged or crippled and impairing attacks when arms are damaged or crippled. Some other things I'd like to handle include: * blindness * getting stunned, for example from blows to the head or to already-injured body parts * becoming enraged * becoming terrified * bleeding * tripping and falling I'm not sure how to do that. The two options I'm seeing are to a) program in every scenario with maybe a little bit of combinatorial mechanics or b) provide detailed models of the hobbit and giant and dynamically handle the combat I'm pulling all this stuff out of my ass because I haven't done it before. My thinking, though, is that if I keep it focused on just two characters, I'll be able to make it very detailed.
Cool! That makes me feel more comfortable with picking that book to go through next.
LIFP looks like an attempt to port Inform to CL. According to the [LIFP](http://common-lisp.net/project/lifp/) project page: &gt; a Common Lisp extension that inplements world model, parser and other features of IF games and allows a programmer to use constructs, borrowed from Inform
This looks helpful, thanks
"shove burning tobacco under toenail of left big toe" Is simply: verb noun location Wouldn't be too hard to generate, depending what the character actually chooses to do :). This is such a typical Roguelike that I'm just gonna point you to this. http://roguebasin.roguelikedevelopment.org/index.php/Common_Lisp For bodyparts you could either use structs, regular lists (with some function that recurses over trees) or classes. Going the OO approach and have a superclass called bodypart may be the simplest way to do this, as I'm rather sure that Land of Lisp only introduces the reader to generic functions my advice to you is to read the object reorientation chapters of Practical Common Lisp (google it)!
Thanks for the advice. It would be interesting to model various body parts and how they behave at various stages of degradation, and how the entire system thus behaves.
In *Land of LISP*, there is a exercise where you create a text-based game like the one you're describing.
If you decide to go with a class, nice (and very simple) macro: http://paste.lisp.org/display/126767 EDIT: Just realised that there's a slight bug in my macro, the :initargs becomes symbols instead of keywords, something which is truly a shame :( EDIT (again): http://paste.lisp.org/display/126776 *shrug*
[Ha](https://developer.mozilla.org/en/JavaScript/Reference/Operators/Special_Operators/function_Operator) [ha](http://ruby-doc.org/core-1.9.3/Kernel.html#method-i-lambda) [ha](http://docs.python.org/reference/expressions.html#grammar-token-old_lambda_form).
I'm serious. Most languages and their followers have yet to wake up to the power of anonymous functions. Fark Java, OO can be implemented in FP and Smalltalk does it better anyway.
I can think of one way to find out.
There's been a few simple Lisp machines built. Here's a link I found to a guy building a Lisp machine from a Spartan-3 FPGA. http://www.aviduratas.de/lisp/lispmfpga/
No need. Lisp is self hosting.
Its a little underpowered though, because the combat physics (which is the actual hard part) and other stuff aren't implemented.
What was lispers.org?
Just a nice page with [quotes about Lisp](http://pablo.rauzy.name/dev/lispers/index.html) and public domain [Lisp logos](http://pablo.rauzy.name/dev/lispers/logo.html). I like to have it as homepage on public computers (instead of about:blank or HN).
Well, it is just a learning exercise in a book designed to introduce people to LISP :)
There is a text adventure packaged with emacs, written in emacs lisp.
It really depends on what you consider to be *Scheme*, and what level of performance you want. Do you want something that is at least minimally compliant with R5RS (i.e. implements all the mandatory features)? All of the features? The full numeric tower, or just enough to be compliant? If only the minimal numeric tower, do you want it to perform fixnum arithmetic quickly, or can you use Peano numbers instead of having an ALU and a fixnum representation for integers? The [Symbolics Ivory apparently had about 390,000 transistors](http://en.wikipedia.org/wiki/Symbolics#Ivory_and_Open_Genera), and it was pretty speedy for the time, so you can take that as an easy upper-bound. Section 11 of [Design of a LISP-Based Microprocessor](http://www.scribd.com/doc/938809/Design-of-a-LISPBased-Microprocessor) talks about a minimal implementation of Scheme. I couldn't find a gate-count, but I get the impression it was pretty low, given the technology available at the time. I'm pretty sure I have seen a gate count for that processor or a later incarnation of it elsewhere. I think that this book: &gt; Batali, John, Neil Mayle, Howard Shrobe, Gerald Jay Sussman, and Daniel Weise. 1982. The Scheme-81 architecture -- System and chip. In Proceedings of the MIT Conference on Advanced Research in VLSI, edited by Paul Penfield, Jr. Dedham, MA: Artech House. Probably contains all the details you really want.
Sweet! I had no idea. Thanks.
I [mirror](http://www.yellosoft.us/logos) some of the logos for the various CL's.
It looks like the Lisp alien logos live here: http://www.lisperati.com/logo.html
Looks like it's back up now.
If you haven't already, download and install [Quicklisp](http://www.quicklisp.org/). It makes library installation and management trivial. If you need to know what libraries exist for a certain subject, start by searching [CLiki](http://www.cliki.net/index). 
I love how just about every mention of Clojure is downvoted in this subreddit. Actually, no, I hate it. It goes to show that this Lisp community is petty and dogmatic. Nevertheless, 4clojure seems like an interesting concept, but the OP may want something a bit more guided. The first three chapters of SICP could be worthwhile if s/he is weak on functional programming as well, otherwise it will be a bit of a bore.
/r/lisp is about Common Lisp. When someone asks for ressources about Common Lisp, and you give him a link to a Clojure site, this is perceived as unasked-for advertising, aka spam. The same would apply if somebody asks for a Clojure book in /r/clojure, and you tell him to check out some Common Lisp site. There is a reason /r/lisp, /r/scheme and /r/clojure are not one, but three different subreddits, even though all three historically are "Lisp dialects": to prevent overzealous language evangelists from each camp spamming each other into oblivion and turning the subreddit into a proselytization war zone. 
&gt;/r/lisp is about Common Lisp. The sidebar contradicts this: &gt;A subreddit for the Lisp familiy of programming languages. Clojure is *a* Lisp, the same way that Common Lisp is *a* Lisp.
haha. So true. I found On Lisp hard to follow. I like Paul Graham when he writes about topics not related to Lisp. Hackers and Painters is a lot more fun.
Yup... downvoted for giving advice. Classy!
&gt; I got on lisp a while ago From where? Copies on Amazon start at ~$140.
*On Lisp* is available as a free download at Paul Graham's website.
A motorola 68k used about 40000 transistors in 1979. I'm sure you could do something significant in that range.
My mistake. I was writing from work, not from home, and confused the titles. It was ANSI Common Lisp, not on lisp. Still, I just looked it up on Amazon, and it's much more than I paid for it.
I have no idea about your question. Out of curiosity, what is wrong with cl-routes? 
Documentation-wise, I have relied on restas for that information (http://www.cliki.net/RESTAS).
Thanks for the link, and interesting project similar to one that has crossed my (and I'm sure other people's) mind.
Wow, thanks for the 99 problems link. I have never seen that one before.
99 problems but a Lisp ain't one?
These are great for when you want to do something but don't know what to do...and you want to program.
No luck, email bounced. I found the original Prolog site but the data files seem to be missing from there as well. Oh well, I guess this is as good as we get.
It's a good idea, but the code here is pretty lousy. You'd be much better off reading the source code for your Lisp compiler, which has many of these, and is much better implemented.
You must be a very happy person. :)
Isn't `(and 'new 'commonlisp 'grammar)` invariantly true? You should maybe have that looked at by a doctor..
Thanks for writing up the document associated with SMUG - it is really helpful when people provide explanations of _how_ things work along with documentation of what a library does. 
I am glad that you liked SMUG, that is what matters to me. Did you read the "Monadic parser combinators" paper that I referenced? I found that to be quite helpful. I use SMUG for parsing, but really it was the paper that inspired it. Learning the monadic parser approach means appreciating monads! Did you look at https://github.com/drewc/ftw/blob/master/dispatcher/monads.lisp as well? I use monads for call/cc, and I implemented them for that here. 
I looked at the paper back when I first encountered your implementation - subsequently I've become completely down with monads. I implemented [this](http://planet.plt-scheme.org/package-source/toups/functional.plt/1/1/planet-docs/better-monads-guide/index.html) library for Racket which provides a rich syntax for Lispy monad usage. However, I'm interested in game development, and it appears that monads are a somewhat poor fit for purely functional game development, and so its on my back burner to implement an set of arrow syntax and combinators therefor for a functional-reactive Lisp library. Arrow syntax is apparently [not so easy to compile](http://www.reddit.com/r/haskell/comments/nellt/arrow_notation_how_does_it_work/c38l4y5), however, so for the moment I'm stymied.
Well, arrow syntax can't be formulated as a regular `let*`. At the very least one would need a form which has the following structure: (arrow-let* arrow ((var1 arrow1 value1) (var2 arrow2 value2) ...) body ...) Note that each binding form in this expression has three components rather than two. In Haskell with arrows, these forms are written `val &lt;- arrow -&lt; expr`, but there isn't any a priori reason that the literal, lexical arrows themselves need to be in the notation except for visual clarity. I think there might be some confusion here about arrows the type class and the little `&lt;-` textual arrows that Haskell do notation and my monad libraries use to indicate a binding expression. As I said above, it is entirely a matter of taste, but I prefer to use the form `(var &lt;- value)` in monadic expressions because it saves a lot of parentheses while emphasizing that a monadic form isn't _only_ about binding - it is also about sequencing. It is useful to write something like (parser (=&gt;string "a") (=&gt;string "b") (=&gt;string "c")) without ever binding anything at all. Yet with a `let*` like syntax, one must write the somewhat more bulky: (=let* ((_ (=&gt;string "a")) (_ (=&gt;string "b"))) (=&gt;string "c")) Which, in addition to having a lot more parentheses also breaks the uniformity of the expressions - `(=&gt;string "c")` is treated differently than the forms in the RHS of the binders, even though its meaning is roughly the same (except its return value is the return value of the whole expression). I spent a few months writing parsers every single day using a port of SMUG to emacs lisp that I wrote, and I eventually adopted this streamlined `&lt;-` syntax because at least 40% of my sub-parsers were just throwing away their outputs. I found a similar need in a purely functional game project I was using which relied on the state monad. Many monadic values and functions in the state monad are used strictly for their "side-effects" and have no meaningful monadic return value. It seems inappropriate to force the user to specify a name for that value, even `_`, if it is `&lt;void&gt;` anyway. I began that project with a `let*` like monad syntax and eventually adopted Haskell style for almost the same reason. Since the parser monad (as implemented in these libraries) is just the non-deterministic state monad, I guess that isn't too surprising. I guess one does pay a small price for using `&lt;-` when it comes to macro writing, but I sort of see do notation as a more formal way of escaping a lot of macro writing anyway. Adding monadic binding expressions to a language gives you a whole family of domain specific languages which you don't need any new macros to use. It seems to balance out for me, but it really is just a matter of taste. 
`parser` is different in this way: if we wish to write a parser that returns only the second item being parsed, it would be: (parser (=&gt;string "a") (result &lt;- =some-parser) (=&gt;string "b") (=&gt; result)) ;; edited for correctness In general, in a `parser` form, or in the body of a `defparser`, we can bind as many or as few variables as we'd like using `(var &lt;- =parser)` syntax, and then finally use `parser-return` to construct the return value. `(var &lt;- val)` is still an s-expression, it just lacks the property that its meaning is dependent on the head of the list. Macros which build parsers can do so easily with backquote, like any other s-expression. Eg: (let ((var (gensym))) `(,var &lt;- =parser)) The whole point of using `&lt;-` as a sigil is that it allows you to simply write `=parser` when you _don't_ want to bind. I found binding was rare enough that it was wrong to make it the default, like a `let*` expression does. For instance, to parser a directory you'd write in my library: (parser =slash (d1 &lt;- =one-or-more-alphanumeric) =slash (d2 &lt;- =one-or-more-alphanumeric) =slash (d3 &lt;- =one-or-more-alphanumeric) (=&gt; (list d1 d2 d3))) When we write `=slash` we say : "parse a slash character, but throw away the result." If you use a `let*` style, this is: (=let* ((_ =slash) (d1 =one-or-more-alpha) (_ =slash) (d2 =one-or-more-alpha) (_ =slash) (d3 =one-or-more-alpha)) (=&gt; d1 d2 d3)) If you are doing lots of commands like `=slash`, as you might using the state monad, it gets ugly to always have to name the output `_`. Letting the user indicate a binding as a _special case_ really cuts down on verbosity. I'm really more of a Schemer than a lisper, and that might inform our two perspectives. When writing a `syntax-rules` or `syntax-case` macro, it is just as natural to match against the head of a list as it is to match against some inner element of that list. I really started using the monadic binding form with `(var &lt;- val)` in Scheme first, where it is a relatively natural way of doing things. It is less obvious when writing a `defmacro` style macro. In any case, there are lots of arguments against doing it my way, which you've enumerated. I definitely don't think one is objectively better.
I still think that using =LET* in the way you have outlined is not what I would do. I would use =AND again. In the case you outlined above , would do : (flet ((f () (=and (=slash) (=one-or-more-alpha)))) (=let* ((d1 (f)) (d2 (f)) (d3 (f))) (result (list d1 d2 d3)) Or using SYMBOL-MACROLET if I cared about such things. I don't, I prefer functions when I can. In CL, SECOND exists, and &lt;- would not be hard. Again, it is just not something that I like. We definitely have a difference on opinions there. Here is a macro that will implement the above PARSER using =LET* : (defmacro parser (&amp;body body) `(=let* ,(loop :for form :in (butlast body) :if (and (listp form) (eql (second form) '&lt;-)) :collect `(,(car form) ,@(cddr form)) :else :collect `(_ ,form)) ,(car (last body)))) It is not that difficult to do, but again, not something I would use. Objectivism is not what I am about, just making sure that I code in the language I use. In this case, it is CL. My Gofer is a lot different! edit: I did not do the 'return the second item' thing. I would use =PROG2 for the one you mentioned, but that is not a solution to the problem you are mentioning, just what I would do :)
Quite arguably, your preference is _more functional_ than mine. You've convinced me to add a `parser-let*` form back into the library (there used to be one, but I took it out.)
Genera is the operating system. It's still for sale from http://www.symbolics-dks.com/
I had the idea to plot functions, data etc. using McCLIM. This would facilitate plotting to a screen and to a (postscript) document. I got into a problem, though, because I'd like to have my original (slime) repl, while displaying the graph in a window via McCLIM. I haven't had time yet to look into it, but making a new thread for the graph doesn't really work; how are you supposed to interact with the graph and data in the graph from the repl? I also didn't want to make a separate interactor pane, because 1. it should be able to read sexps and 2. you should be able to use slime if you want.
I find the use of the word "persistent" confusing. It is often used to mean something like "stored on disk" but here it actually seems to mean the same as "immutable" in the context of other languages. Is this use of "persistent" common?
Yes. Look up "persistent data structure" on Wikipedia. 
Tell me about it - chalk it up to CL being a horrible nightmare committee language. I guess there is efficiency to consider - there would be an indirection penalty if every single function was a method.
No, only double colons. Single colon will result in a reader condition. The idea is that :: is (sort of) equivalent to binding `*package*`.
It boils down to a combination of efficiency, implementability, and legacy. Implementability is important: most Lisp implementations are self-hosting. If you can overload or re-define `CL:CAR` then whole bunches of the runtime itself that depend on it can get hosed. Efficiency comes about by making pervasive assumptions at runtime: `CL:CAR` can be a simple address-plus-offset de-reference, because a `CONS` cell is implemented a certain way. You tell the compiler to omit the typecheck for `CAR`'s argument, and you get fast code. On the other hand, you've hard-coded this very low-level detail that defines `CL:CAR` as a couple machine instructions. You can't overload machine instructions. That said, if you want, you can define `YOUR-PACKAGE:CAR` and call it `CAR` for all of *your own* code (and by users of your code) by shadowing the symbol `CL:CAR`.
Both are pretty great. They differ in ways that might not matter to you much just yet. ClozureCL is the open-source product of a company that pays a few people to work on the project. SBCL is a volunteer effort; key contributors come and go, with varying degrees of availability at any particular time. SBCL produces faster compiled code. The compiled code speed matters to me, because I produce thousands of PNGs per day, but it might not matter to you. Clozure CL has a faster compiler. The compiler speed made a difference to ITA, where there are very large CL codebases, but it might not matter to you. I checked Quicklisp usage logs, and 65% of downloads were via SBCL, 18% were via ClozureCL. Everything else was 10% or less.
Actually, this statistics is very important. Since most of the users are using SBCL, any thirdparty library is probably going to work on SBCL, and be developed with SBCL as primary development platform, so you'll encounter the least library breakages and headaches by using SBCL.
It's important, but I don't know about very important. As a library developer, I work hard to make sure my projects work on all implementations. I'd rather see diversity encouraged where it makes sense and let the bug reports (and fixes) flow.
Maybe!
If you decide to go with slime it's quite easy to try them both out. It gives a common interface to the debugger and a common repl, so it is mentally easy to swap from one implementation to the other. If you go this route, you can start with one implementation, and easily try out the other when your curiosity gets the best of you. If the natural way to build your program is with a mix of ANSI CL and compatibility libraries, using no implementation specific extensions, you might even find it beneficial to keep your program tested on multiple implementations; this has a few benefits: * The different performance profiles might be useful to you in the future * Getting the program to work in multiple implementations can reveal previously hidden bugs * Sometimes one implementation will give a clearer error message than the other * You might eventually want to deploy in an environment where other implementations are more stable
My memory is a bit hazy, but didn't SBCL have some iffiness related multi-threading in Mac OS X ?
This is my rationale for using SBCL. If it's an open source library, it's *probably* developed and tested with SBCL, and therefore most likely to work. That really leaves other distros out in the code, but, well, I like my code to work. :-/ 
Thanks for this info. I see that there's a [whole section](http://ccl.clozure.com/ccl-documentation.html#The-Objective-C-Bridge) on interfacing with Objective-C in the Clozure manual, while searching on this topic for SBCL turns up…crickets. I already know that I want to tie into Cocoa libraries to perform image and metadata manipulation, so that makes this a rather simple choice provided that the Lisp plugins don't crash &amp; burn.
For what it's worth, I was able to create Lisp bindings to a custom-built Objective-C framework using their automated process. I know I wrote a tutorial page on the Clozure Trac, because the process was a little bit involved, but I've forgotten the URL (\*blushes\*).
Quicklisp and CL-WHO set up easily enough in Clozure CL. My current plan is to write the code for generating static HTML to display a few hundred images. Using the Objective-C bridge from Clozure CL to access the OS X Image I/O library looks like a good option for creating thumbnails, extracting metadata, etc. The other option would be to use ImageMagick.
Wtf is logo doing up there? Also, yay for R (and of course CL) being awesome. 
I have not found any sources about differences to the version published 2005. It is still counted as edition 1, so probably just a reprint.
I hear it's a reprint.
Emacs Lisp version [here](https://github.com/VincentToups/emacs-utils/blob/master/shadchen.el). If you've used Racket's matching, it is more similar to that than to `cl-match`. I wrote shadchen last night, so it probably still has bugs. Some of the tests fail in SBCL, but that is because of discrepancies in what kinds of errors are generated between SBCL and Franz lisp, which I wrote the first implementation on. 
[cl-match is also on github](https://github.com/Drakken/cl-match). [(CL.net page)](http://common-lisp.net/project/cl-match/) [(user's manual)](http://common-lisp.net/project/cl-match/doc/clmatch-api.htm) Supports lists, arrays, structures, objects, multiple values, names for subpatterns, and user-defined patterns. 
My favorite (not only) matching library has always been [cl-unification](http://common-lisp.net/project/cl-unification/).
cl-unification is amazing. So amazing that I got intimidated by it. [EDIT: I got downvoted for being intimidated by cl-unification? What gives?]
Peter Norvig has a good breakdown in [Design Patterns in Dynamic Languages](http://norvig.com/design-patterns/).
It's like they made that presentation specifically in reference to that passage.
There is [The Art of the Metaobject Protocol](http://www.amazon.com/Art-Metaobject-Protocol-Gregor-Kiczales/dp/0262610744). It is specific to CLOS, but could of course be applied to anything as flexible. Maybe ruby is getting close to CLOS. 
c2 depth seems to be infinite, I always end up learning nice ideas there.. far more often than any other website, even if I already spent copious amount of time wandering on it. thanks for the link
I wish I could claim that the design was my own, but its really based on Racket's match implementation (i've updated since posting, adding a few more features in that direction). I'm glad its useful for you.
Also, awesome user name.
It is an elegant design, which leads me to believe that the Racket guys spent a lot of time thinking about it. It makes sense to stand on their shoulders. (It seems alexandria is missing a pattern matcher *wink* *wink*)
He makes a very good point too. I think they're both right; it's just different facets of the topic. Over the years some people have misquoted Norvig to have said "design patterns are unnecessary in Lisp", but the above quote doesn't say anything like that -- "invisible or simpler" could be taken to just mean that Lisp facilitates many design patterns that are harder to achieve in some other languages.
Perl's Moose uses MOP to implement additional features that are not provided in default CLOS -- laziness, roles, attribute delegation, and attribute traits (pretty much it?). As I understand it, CLOS can be extended (the API is available) to have these additional features as well, and it was expected that people would do that. Similarly, one can use Class::MOP to extend Moose.
Without source, I can not help you in meaningful ways.
For those that don't know what to do with this, put it in your ~/.stumpwmrc. It will bind Prefix-- and Prefix-+ to fskip and funskip. Much better window cycling if you have any output only windows that never require focus.
That depends, IMO. `(when foo 42)` is only the right answer if NIL represents "don't care". If the NIL is meant to represent boolean false, it should be `(and foo 42)`, and if it represents the empty list, I'ld prefer `(if foo 42 ())`.
Pretty neat, I might try it out. I also enjoy your use of the arc forum as a personal page. One trick I've found that makes stumpwm a lot nicer to use is to bind the most common commands to key combos with the home modifier key, without requiring a prefix key. http://paste.lisp.org/display/125743
Ah, ok. I would never think of using the home key, much too out of the way for my liking, but if it works for you...
You two seem to imply that adhering to style doesn't have concrete advantages. The advantage is that it decreases the mental effort required for a human to parse and understand the code. In this case, if adhered to, every IF you see will always have an else clause. You can count on it. Ignore this style and every time you see an IF you wont know until you read further in the code. A definite advantage and valuable. 
Agreed.
[Whoever downvoted this, I'd love an explanation.] But is `when` itself code smell? You'd only ever use `when`, I'd argue, if you are interested in side-effects because you specifically indicate with it that you don't care what the return value is, which you would if you were calculating a value rather than performing an action. I'm kind of suspicious of `nil` used as anything other than the empty list and I think most uses of booleans (in Common Lisp this unfortunately includes `nil`) [should be replaced with more clear and rich types](http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/). This whole discussion points right at the question of nil and type punning, which I think has some problems in Common Lisp. `nil` is super weird, for instance: (symbolp nil) - T (listp nil) - T but (consp nil) - nil Even though: (car nil) -&gt; nil (not an error) (cdr nil) -&gt; nil (not an error) Each of these things makes sense, individually, but altogether they are somewhat confusing or sub-optimal. Maybe it should be an error to use the result of a `when` expression as a value. Someone remind me, does cl have a `void` value which it is an error to use in any way?
&gt;But is when itself code smell? &gt;You'd only ever use when, I'd argue, if you are interested in side-effects because you specifically indicate with it that you don't care what the return value is, which you would if you were calculating a value rather than performing an action. Are you saying that 'side effects' are bad? Really, when you say side effects, I think what you mean is 'mutability'. How would you use an object system without mutability? Or really any mutable data structure... I'll have to disagree for purely practical purposes if this is what you are saying. &gt;This whole discussion points right at the question of nil and type punning, which I think has some problems in Common Lisp. nil is super weird... Not really... NIL is an empty list. It is also the symbol that you point to when you want to branch in a certain way, specified by constructs like 'if','and', 'or', 'when'. We call this the 'boolean' type in lisp (consisting of t and nil'), but really, anything that isn't nil is assumed to be not branching in that way (called a 'generalized boolean'; which is everything... technically). A proper list is a series of conses terminated by an empty list. (Compare this to an improper list, which is just a series of conses). NIL is not a cons, because an empty list has no conses in it. Getting the first thing in an empty list is an empty list, getting the rest of an empty list results in an empty list. You might be right that this is not optimal, but I don't find this particularly confusing. There is no 'void'. Every expression has to return something.
&gt; Are you saying that 'side effects' are bad? I'm not saying side-effects are bad, but I am a proponent of the idea that side-effecting expressions should be in some way distinct from other kinds of things - hence the suggestion that `when` result in an unusable value. That way the programming language helps you avoid using a return value when you didn't mean to return one. Incidentally, I've created a multiple dispatch object system with immutable objects. I never really used it except in a purely functional roguelike engine I was working on - it seemed, in that context, to be usable, but I can't speak to its utility at large. Objects were implemented as immutable dictionaries and methods which updated the object had to be threaded through a monad. It was usable for me. I like purity. &gt; There is no 'void'. Every expression has to return something. I might have a problem with this. Don't know. 
It's not just style if you consider that people might use a single-legged `if` by mistake when they meant to use a two-legged `if`. Forcing the use of `when` prevents that mistake. It also looks nicer to boot.
gethash returns a second value indicating whether there is a value (which might be nil) at the given key.
`M-x ispell-comments-and-strings` 
Out of curiosity, I checked to see if one can `cons` onto the result of `values`, which one can. It is too bad. I was hoping there was a value which was an error to use under any circumstances, which would then be an appropriate return value for `when`. If anything, this is even worse, because `(eq nil (values))` is yet another bizarre relation between `nil` and other types of things. 
*shrug* I still think it's misleading to call it a relation between NIL and VALUES, since it's not really a property of NIL -- but just once specific way NIL is used by other parts of the language. 
So in a larger sense, I agree with your sentiment to shrug about this - after all, people have made a living programming large systems in Common Lisp and continue to do so (I program in CL for a living, in fact). Obviously NIL is not overburdened from a strictly pragmatic point of view, because Common Lisp is working. That said, I've never been one to embrace the status quo as benign merely because it is. It is useful to consider issues like this because languages are not static and having ideas about how they might be improved informs the creation of new languages and the modification of hoary old standbys like Common Lisp. From this point of view, I think its reasonable to call NIL's role in CL sub-optimal and lots of folks [agree with me](http://www.nhplace.com/kent/PS/EQUAL.html), although being in the company of Xah Lee might give some pause. I program in Emacs Lisp and kind of love it, and its a much more terrible mess than CL, so none of this is meant as a damning critique - just commentary. I think I'm just being so insistent about it because my initial post received what I think was a pretty spurious downvote without any explanation. 
I was a naysayer, but now I'm a hopeful. Go go Tom!
Download http://racket-lang.org/ and evaluate this http://www.cs.uni.edu/~wallingf/blog-images/code/jmc-lisp.scm . You might have to put it in pretty big mode.
Always interesting, but of course that's not Lisp 1.5.
&gt; elisp-to-CL translator I respectfully disagree. There's is so much elisp out there, it seems hopeless that one could get it all translated. Instead, I think having an elisp interpreter/compiler in CL seems less risky. 
This lisp is based on 1.5 IIRC: http://www.aviduratas.de/lisp/prolisp.html
Admirably abtruse! [Some explanation.](http://josephoswald.nfshost.com/circuit-sim/summary.html)
&gt; elisp-to-CL translator and then implement the rest incrementally. I don't understand how your strategy is better: say you translate the elisp to CL. Now what? You can't run it because nobody has rewritten the parts of Emacs written in C (which is actually quite a bit) to run your freshly generated CL. If you can't run it, how do you know your translation works? I agree this guy's idea seems a little nutty, but at least if it works (a big if), then you have something to run real elisp on, and you can replace the translated-to-CL bits with sane CL code with something to compare to. EDIT: and, furthermore, I'm guessing there are a lot more people contributing to the elisp (in addition to people's private stashes of elisp) than to the C parts of Emacs. If you have to keep translating the new Elisp with your translator, that is a lot more work than keeping up with translating changes of the C portion.
For the 48-character business, I was going off the 1.5 Manual. That was almost assuredly something that changed in the various ports to other systems. All of those ports probably had their own warts.
&gt; say you translate the elisp to CL. Now what? You implement the rest incrementally. You can't run it because it's your job to implement it. Incrementally. In small steps. Write stubs for the missing functionality. Start by implementing the most primitive operations. Work your way up. It will take some time, but you can get there, and you'll have a nice codebase to show for it. I think you misunderstood what I meant by "translate". I just meant compiling elisp in CL. I don't understand what you mean by "keeping up". If there's a new file then you need to load the new file, just as you do in regular non-CL emacs.
&gt;understand FEXPRs in the historic context For this I strongly recommend John Allen's classic "The Anatomy of Lisp" (1978 IIRC). Probably available in most university libraries.
Big fan. Only issue ive read into was with a server that would only return gzipped content. Couldn't ungzip it, had to run it through a separate library. Maybe not a huge deal, but would have been nice if handled transparently. 
Drakma is excellent, I used it in a project that needed to pull content from Flickr and a couple of other APIs. I wouldn't hesitate to use it again or to recommend that others use it.
Rule of thumb: if it's "ediware" (i.e. written by Edi Weitz) then it's good.
Hmmm shouldn't be too hard to do, I'll do that this weekend. Thanks for the link
&gt; At a time when other people are giving away their development tools Tell me who is giving away a CL IDE that lets me write and distribute a GUI application with minimal effort across Linux, Windows and OS X. I am very much for free software, but I can appreciate the need for someone to make a living off of a solid product that fits peoples needs. No one is forcing you to consider LW. The business model for those other firms (and open source) is nothing like LispWorks and the markets are probably not very similar either. &gt; Their license says I cannot use their Personal Edition to do anything that may become commercial; I can only use the commercial edition for that. Well, yeah. It's a commercial edition. I understand the desire to upgrade if and only if you are ready to release something, but then you're basically riding on their tools for free for the duration of the development cycle. How is that fair to them? I understand the frustration, I was very hesitant to commit my money to something I was used to getting for free. That said, I have two licenses for myself, and we have some at work and I have no regrets.
Treating 64-bit like a premium "enterprise" feature is pure anachronism.
No complaints so far. 
You can always contact them and ask them for different terms. Maybe you can negotiate something that works better for you.
As long as free CL implementations do not provide the functionality and the support LW provides, LW has a reason to exist. Having a long-standing company/product as LW is an enrichment to the overall CL ecosystem. The fact that they are a company able to make a living by selling Lisp is an absolutely good thing. It would help nobody if they one day (may it never come) couldnt sell LW any more and had to go bankrupt or had to open source it to survive. 
&gt; The business model of LispWorks is basically the same as that of many other tool vendors. Borland wants money. IBM offers commercial tools. Smalltalk/X. VisualWorks. Sicstus Prolog. Dont forget the elephant in the room, Microsoft. They certainly dont give away VS Pro for free.
Microsoft can scale, LW probably cant. I dont have an LW Pro licence, I was just commenting that "give a basic version away for free, charge for pro versions" isnt a business model as uncommon as the OP painted it. Basically every commercial tool provider does that. LW isnt the cheapest tool provider around, but hey, they're alive, theyre making a living selling Lisp, thats a laudable goal in itself. Even though I cant afford a pro LW licence just for toying around with Lisp, I'm glad they exist. If I had money lying around, I would buy a licence or two just to support them.
&gt; We peons toiling in the SBCL ghetto just don't know what we're missing. Oh, fuck off. You're smarter than that argument. SBCL _is_ a ghetto on Windows. I came from an SBCL/Linux background to an environment that required Windows support. SBCL is basically a no-go there at present. And yes, ~4500USD in tools can very inexpensive for your average commercial product.
I'm a single developer and I was able to afford it. &gt; You treat this as if LispWorks only need to compete with other Common Lisp implementations. I know what they have to compete with: People like me who use (and pay for, as applicable) Stata, Matlab (Guess how much those two cost!), R, Python, Visual Studio. But realistically, people who look to LW have already made the decision that they are going to use CL for something. These aren't corporate Java developers who are deciding to tinker in something different because they are bored. &gt; An example from the shop I work at: I can get Microsoft Visual Studio 2010 Professional for $550 retail. I can get a version that gets support through MSDN for $800. I can use that to develop in a safe subset of .Net that runs across Mac/Linux/Windows with .Net with wonderful GUI support. I'm well aware of the Microsoft model. I work in a hybrid .NET/Lisp shop. (So I've paid for both!) &gt; The license doesn't work that way though, so I couldn't do that even if I thought it was fair to them. Here is an excerpt from their license agreement for their Personal Edition: I know. My point was to justify their wording. &gt; There's no reason it has to be this way. If I develop the software using their Personal Edition then I should have to upgrade to the Commercial version if I decide to sell a product. Now they have just sold a license, and a license they would have sold anyway had I bought the product up front so there is no money lost. No. You paid them nothing from when they started until when you were ready to publish. How long is that? A month? Two months? Under the current terms, this amounts to 0% financing. If over a year, you've now got that loan plus a free upgrade support contract. &gt; $1,500 for 6.0 (32-bit Linux) in 2010, and now, another $1,500 for 6.1 (32-bit Linux) in 2012 = $3,000 spent over two years for an environment that I, as a hobbyist, may never produce anything I sell from. If I wanted 64-bit, it would be $9,000 ($4,500 + $4,500). Are you a hobbyist or a commercial developer? Do you intend to sell what you are building or not? You don't sound like their target audience. &gt; So I'm paying $1,225 each year, at least, for my tools. &gt; How is that affordable for a single developer? One who is producing and selling software? I would say very affordable. I did it and know of others. It clearly seems to be working for them. Other than that, they are very approachable. Why not call or email them and ask for different terms?
You keep saying this like it is news. Yeah, we get it. It costs money. So what? Use something else or contact them directly to see if you can work out some deal. What are you trying to convince us of? I've purchased and maintain existing licenses with them for my sole use and have made more than I deserve on the deal. It was hard to swallow at first, sure, but I have no regrets.
What commercial project are you looking to develop for that this is a non-starter? Are you looking for financial backing in it?
I am using LW 32-bit on OS X since 2009. My work is powered with CL and I made the decision for LW because it runs extremely solid, it never failed for me. It's good to know that there's native ui support when I need it and that it's backed by a company which is supposed to improve the product and help. The price and the yearly maintainance fee may seem huge but if I wouldn't spend money on this product I would definitely donate it to some free implementation. The main selling point though is that it supports Cocoa and OpenGL without any noteworthy issues. Before I bought the license, i worked with clozure CL which also a great implementation. I couldn't get used to the objc bridge, though and at that time it was rather unstable. Things surely have changed by now..
It's basically a month-worth of salary per developer (or 2-3, depending on country your developers are in). It makes a difference for startups, especially under-funded web startups which maybe need only a month worth of work anyway, so you can either make a web app or buy lispworks. Besides that, there are high-quality open-source implementations. Would Lispworks features save you a month worth of work? I doubt it.
&gt; It makes a difference for startups, especially under-funded web startups which maybe need only a month worth of work anyway, so you can either make a web app or buy lispworks. I know people have done it with LW, but in that scenario I'd be using SBCL or CCL on Linux. &gt; It's basically a month-worth of salary per developer (or 2-3, depending on country your developers are in). What if your developer makes 80-120k? That's very common in the Northeast/NY. Now it's 2-3 weeks of time. How much does health insurance cost? Your computer? Your other software? The IT guys? The servers you deploy to? The SAN share your files are sitting on? This argument works for "mass" technologies like .NET. I don't think it holds up as well for the types of shops where I've seen more exotic technologies like CL. I don't think CL has ever really been about competing with lowest common denominator (which is not to say that .NET is stupid, it is certainly clever). If you're using CL, you probably have a different sort of problem that you're looking to solve. &gt; Besides that, there are high-quality open-source implementations. Would Lispworks features save you a month worth of work? I doubt it. On Linux? Probably not. I'm far less convinced about LW on Linux. On Windows? It definitely did for me. Being able to build a DLL, support for insane Windows things like DDE. What if I don't want to have to worry about dealing with the dramatically varying quality of open source libraries and wrappers? It costs money to evaluate them and there is the risk that whichever one I select falls victim to bit rot. What if I want an IDE other than Emacs? What if I want a clear channel and rate to be able to pay for immediate feature requests for my development environment?
'Serious money' might be just a couple of thousands bucks per month. Let's say $3000. That's a good money for developer in Russia or India, and even in 'richer' countries like US it might be ok. If you pay $3k per year to upgrade Lispworks, you essentially work one month out of 12 just to pay for tools. It might be a better idea to spend that time on improving open source tools. Let's put it straight, Lispworks isn't really for individual developers but more like for established companies which have already invested in Lisp and don't have that much problem with paying for upgrades as they can write it off as expenses. Individual developer might buy it too, but most likely that would be a contractor in a 'rich' country which makes tonne of $$$ at companies I mentioned above.
Regarding pricing: Bluntly, if I want to kick off a startup in Lisp, I would not be able to use LW without some VC/investment capital. I would definitely have to use a less expensive version (SBCL) until I had enough money to invest in tools. (64 bit is normal these days, so 4.5K for a dev license is "ow"). At that point, it would be problematic to switch over, since I would have begun heavily investing in the SBCL ecosystem, quite probably based on Linux. However! I work in a tools group in an enterprise, and these sorts of prices are par for the course in enterprise software. Probably about average. If we invested in Lisp, we'd expect to be spending this sort of cost - likely we'd send our crack negotiating team to talk to LW's crack negotiating team, but as an upfront cost, it's 100% par. It would be handy to have a "Limited Pro" price/features variant for the small &amp; hobbist developer, *in my personal opinion*. Best of luck to LW. 
&gt; You can't run it because it's your job to implement it. Uh, I'm really not understanding you. In the article's approach, his script generates an implementation: a CL program. You can compile that CL program, test it at the REPL, or try loading elisp into it and running that. If you are writing an Emacs implementation by yourself in CL, how does having translated elisp help? You have a million lines of CL filled with undefined functions and variables: that is just a broken pile of code. I really can't see how that helps. Here is a simple line of elisp from my .emacs: (global-set-key [delete] 'delete-char) Say I translate that to (cl-emacs:global-set-key (cl-emacs:key-sym "delete") #'cl-emacs:delete-char) OK, how does this help? In theory, I wrote a bunch of code to parse the elisp, translate the various Elisp syntax sugar, and if I compile this, what happens? Absolutely nothing except a bunch of undefined function complaints. I can't run it, it will immediately crash. OK, you say I have to implement the CL equivalents for `global-set-key`, describing keysyms, and `delete-char`. But I knew that without even developing a translator, or having the Elisp code. I can just read the Emacs Lisp manual. As for "keeping up", there seem to be two alternatives: the article suggests taking the C code in the GNU Emacs branch, translating it into some CL. When the C code in the GNU Emacs changes, he has to run his translator again, then maybe he needs to upgrade his translator because the Emacs maintainers did something novel. In your case, you start with the Elisp code in the GNU Emacs distribution, translated it into some CL. Now, whenever anybody comes up with new Elisp, you have to run your translator again. I was guessing that there are many more people developing elisp, and a lot more lines of elisp in existence, than there are people developing the C portion or lines of C in Emacs.
You just can't say 'no' can you? (kidding) (edited.. said 'now'.. stupid mistake) Returning nil is the exactly how you can use it when still doing things functionally. `(if cond if-true nil) is more verbose.. Sideeffects can be a convenient way to program. If they're contained in a function, the worst they can do is make a buggy function, if they get out, they get to make a whole program buggy. Of course, often the program really has a state. I think it is then best to really avoid using the returned value(s) of state-changing functions too much. For instance: (or (some-function) (state-changing-function)) Will only call the latter if the first is `nil`, possibly catching the user by surprise.
Of course almost all non-trivial programs have state, and as a consequence it cannot be the purpose of functional programming to avoid it. The purpose of functional programming is to develop (and enable) idioms which facilitate reasoning about that state. I would argue that Common Lisp has a blind spot in this arena, a blind spot exactly evidenced by the fact that using `when` and `unless` in places where a value is expected is allowed. If we say "nil" is a meaningful value for `when`'s whose predicates are false, then we show a weakness in the overuse of nil to represent various kinds of things. If we take the alternative that `when`'s value should never be used, we see that there is no enforcement or warning for breaking this rule. Either result, while completely usable, is not very modern.
I have chosen to pay for two licenses (Mac OS X and Windows) because I needed a sturdy tool that would allow me to develop cross-platform GUI applications. So far I am very happy, and the guys at LispWorks do provide excellent support and documentation. If there was a stable, well designed cross-platform native GUI tookit in the free software world, and on top of that implemented in CL, I would have surely used my money to support it. Unfortunately no such toolkit has ever given me satisfaction, and who knows how many of those I've tried. My first prototype was written in C++ and I have lost a lot of time with this language. I could have used Mono, but the GUI layer is not portable. Today we have the choice between several high-quality free and non-free Lisp implementations. I don't understand exactly what is the problem of those who argue on LW's price, after all it's ones decision wether you prefer to spend money or time. 
I don't get it. Explain.
It gives you a function to organize software, and generate .asd files. Which can be extended to also run autodocumentation or arbitrary other things, maybe a snarky commenter on automatically identifiable silly code.(unfortunately haven't added a *good* autodocumentation-tool-`also` yet..) Underneath that is a 'code scanner' that gathers data about code. This can be used to generate autodocumentations with information like what-dependency-depends-on-what. Underneath that is a 'expression hook' which is what the 'code scanner' uses. If a package is already loaded, it can read the files and macroexpand all the stuff in there, giving a function you put in `*expression-hook*` a look at *every* step. Found `*macroexpand-hook*` to have deficiencies, [and i am not alone](http://john.freml.in/macroexpand-dammit), however, `macroexpand-dammit` didn't have a data-gatherer, but i couldn't use it/continue with it because it had a nasty `eval`.
Actually the compiler of LispWorks and its runtime performance is pretty good.
&gt; Ok, it might be relatively affordable for companies in NY which simply cannot exist without lots of $$$, and not quite affordable in other cases. Or any major city on the planet. Or any company that has a decent revenue per employee. There are at least hundreds if not thousands of companies like that. &gt; I'm in no way qualified to answer this question, but just as one data point, there is a price point at which I would have considered buying Lispworks. Like a couple hundreds of bucks. I've struggled with picking a CL implementation which just works about 5 years ago, and if Lispworks was affordable at that time and would work for me, I'd have bought it. But now I've picked SBCL and it works fine for me, so Lispworks lost me as a potential customer forever. As another data point, Corman Lisp, although Windows only, did fit your niche price point. As I understand it, it never provided significant income to the developer(s?) and is basically dead now. &gt; I rarely program for Windows nowadays, but when I needed a program with GUI frontend and rather complex logic, I made a front end in Delphi and a command line app in CCL. Getting them work together was fairly easy. Yeah, you can do that with any languages. Again, I needed to build a DLL and needed things like DDE support. I also needed RDNZL which was AFAIK developed by Edi on LW and only supported reliably otherwise by CLISP, which isn't really viable. I also wanted to deploy across Windows and OS X (and at one point Linux). If I am being paid by my employer or are independently employed, it definitely costs money to have me killing time on deciding what works where and how. There is also a significant use case for lots of small tools across platforms. Dealing with a non-trivial build chain (Visual Studio for a GUI on Windows, Mono or some Obj-C bridge on Mac plus LW) eats up time. Is it a lot of time? That depends on the project. Either way it is dead weight. &gt; IIRC Microsoft offers some free IDE for C#, so it could as well be 100% free. Yes, the express edition allows commercial use of at least C# and VB without paying a cent. &gt; And if you can do relatively simple things with free tools, Lispworks seem to be targeted at some obscure niches, like not just Windows programming in general, but cases where you can't use command-line + front end combo. Betting on some niches is probably not a great business ideas. I think they are better equipped to tell us what is and isn't a good idea. And I'd say that medium to large-scale commercial development is hardly a niche. Once again, having commercial support can be a significant hurdle in adoption at a medium-sized or larger company and over time I've begun to appreciate it. I cannot say that that makes a significant portion of LW's sales, but I see that it fits that model very well. That's how a lot of business-to-business software works. If they saw a rapid decline in renewals or new registrations, I'd expect they would restructure their offerings. They seem to be doing just fine so far. I think you make a lot of good points, but I have to believe that the people at LispWorks are clever enough to know or have discussed at length all of them. I think all of the arguments come down to: * *I* can't afford it. * It would be great for CL if it were more widespread. * They might make more revenue if they had a better structure or less expensive starting point. * I don't see what value I get for $X. #1 and #2 are basically irrelevant on their own (though #3 may be a function of #1) and I find it very difficult to believe that the folks at LW haven't put a lot of thought into #3. Maybe that is unfortunate for the CL community as a whole, but that doesn't make it an inappropriate business decision. As for #4, maybe it doesn't make sense for you. That doesn't mean that it makes sense for no one. Do you argue with MS over the pricing of a Professional edition of VS because otherwise you cannot integrate F#? There are a ton of tool
Pure functional programming is actually simpler to think about in at least one way: there is no state for the student to keep in his or her head. A snippet of code does exactly what it looks like it does, and no more or less. At most, a student may have to track down the value of variables closed over in order to calculate, by hand, a value. Compare that to programming with state, where the meaning of many pieces of code can only be partially specified because they depend on state wherein any value might be lurking. I'd argue procedural programming is properly a _more advanced_ discipline, closer to the machine, and exploitable in situations and by users advanced enough to want to putz around with memory, and with the wherewithal to do so meaningfully. Most new programmers don't care about optimizing a hash table lookup, which might require destructive programming. They care about the algorithm, which is much cleaner in a pure setting.
Like I said, I'm just not understanding you. &gt; Do you understand that an elisp file can be loaded directly? Into an Elisp interpreter like Emacs, yes. Into a CL implementation? No. Elisp is not CL. It has different syntax, different semantics, different primitive objects, and relies on tons of C-implemented functions for everything. That's kind of the point of these discussions. `CL:LOAD` does not work with Elisp. You have to write some other function, let's call it `CL-EMACS:LOAD`, which calls other functions like `CL-EMACS:READ`. Let's say you do write those functions. Now you have a bunch of Elisp forms sitting in your CL implementation's memory in some form (like what I write in my example). Now, you want to execute these Elisp forms: oops, most of the primitive functions don't exist. You have to write bunches of CL code implementing things like buffers, points, Emacs keymaps, modes, re-display, UI elements, I/O, and other stuff I haven't thought of yet. How is this simpler or easier than machine-generating a CL codebase from the GNU Emacs C source? 
how can one uppercase LISP in 2012 and pretend to be taken seriously?
Minor typo: the two code samples don't print the same thing. The CL should really be at least `(write-line "Hello World!")` too.
"Bad" meaning "good" apparently.
So you don't understand how one could load an elisp file into CL without writing an elisp interpreter?
Y'know, how Michael Jackson was bad.
I have to assume that Java will pick up C#'s IDisposable interface for this: using (var x = GetSomeResource()) { ... } Which should guarantee that even in the event of an exception, x will be disposed of properly. I agree with you for general every day syntax issues, however. That isn't to mention that you have to wait for the language designers to catch up with a use case to introduce new syntax.
This is fixed somewhat in Java 7 by: try (bis = new BufferedInp utStream(new FileInputSt ream(pfile))) { // Do stuff with file. }
And to be fair, Java has REPLs too (but to continue the phone analogy, it's like using a phone menu with speech recognition...something that should've been a great idea but wasn't). PS: What's the justification for having `write-string` and `write-line` given the presence of `princ` and `format`?
They all do different things...
The only difference between `write-string` and `princ` that I can deduce is that one throws an error on receiving a non-string, and the other doesn't.
&gt; The analogy isn't perfect, but try this: Just as in English a noun may be used as a verb -- "I Googled your name" -- LISP programmers are free to create their own verbs, called functions, and apply them to data with great flexibility. Seems rather far from analogy to me, and unexperienced/bad programmers will go 'i have functions too'.
Good. It's still annoying that: * It took them until Java 7 to do this * I'm a daily Java user, and didn't know about it until now * The statement above may not be 100% correct. All the other examples I've seen do the declaration like this: try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(pfile))) Java redundant declarations FTW, again. 
Yes, it's the version of "bad" that actually means "good." The article, on the other hand, is the traditional kind of bad: just bad.
Also note that running all elisp through an interpreter in CL would defeat the purpose of implementing Emacs in CL. As I mentioned above, an interpreter might be useful for source-level debugging of elisp, but that is a lot of work for little payoff. You already have source-level debugging of the generated CL using the full-featured debugger from the CL implementation. An elisp interpreter is not the first thing to write, at least.
With CL, if you don't like the defaults, you can at least write your own one-liner macro and automate it away. I believe the preferred method in Javaland is to put a boilerplate-expander in your IDE, thus keeping the Lines Of Code all-important productivity measure high.
True, but then you want to try avoid everyone having their own bunch of little packages with extra things they felt they needed.([like mine](https://github.com/o-jasper/j-basic)) Alexandria fixes some of it, but not doesn't quite fill every role.. (Nor should it.)
 0xbfa5f688 0xbfa5f64c 0x8048300 edit: You might like to place a [link](https://github.com/kennytilton/qooxlisp/wiki/) in your post so people can see what you're talking about.
This is why you should write docstrings, and possibly `:documentation` in `defclass`. Can we also get a simple standard for writing longer documentation outside the source file.(Mixing very long comments and code is annoying) I know that you can use `setf documentation`, but what i also want is the possibility of a docstring for each argument, for instance for when there are many keyword arguments. Or maybe even doing the same for examples. It would give autodocumentation more context. This is the sort of thing i wrote [expression-hook](https://github.com/o-jasper/Expression-hook), though it re-expands everything and really looks at everything, so if you're not using all that information, it is probably not worth it. Noticed that it didn't scan `defsystem` properly because when scanning the .asd files, it wasn't in a package with access to it, btw.. Oh yeah i use a little markdown in comments, i see other people are doing it too, maybe we'll want to allow specifying such thing too.. That said, not everyone might agree on which markup system to use.
I think r/clojure would be a better place for this. [Edit] Oh, its already there.
Why? Clojure is also a lisp dialect.
Not saying its wrong to put it here, just that there's a more specific place. lispm finds a lot of great sites and that's good to see.
I would be glad if you update your qooxlisp or make it quicklisp-loadable. :)
All I get is: Please install Flash player. And to that I say, no, no I wont.
Yes, I thought about it whether to post it here. It seemed relevant because a 'mainstream' site had some somehow general Lisp content...
/r/lisp is usually common lisp centric, since other lisps have their own subredits, /r/clojure and /r/scheme. Common Lisp is nowadays *the* Lisp, whether this is historically accurate or not. It has taken over the generic name, whether you like that or not. Things change.
This is a nice idea! How does it compare to before/after methods? 
Thanks. I'm not entirely familiar with before/after methods so I'm not so sure how this compares, but I think that this library could do some really useful and interesting things if you take it into consideration with your program design. 
I do not often find myself praising perl, but I have long thought its [tied variables](http://www.ibm.com/developerworks/linux/library/l-cptied/index.html) very clever and useful. This is a nice example of the same idea.
I'm not sure I understand. Could you explain more?
Apparently yuiohjkl has already explained it more.
I like the minimalism of the old design but I like the lack of spam and the extra tools (i.e. version diffs) in the new one.
If Clojure is his model, then...
The spam will come; I just stopped cleaning the old site once the transfer became apparent. Props to Vladimir Sedach for all the new features.
&gt; ...but too many ( ) Welp. I guess holding off for 1 minute 35 seconds is pretty good.
I am glad to see work being done on newer variants of Lisp. But I think that parens really just aren't that big of a deal...
I suspect that those who believe Lisp has a too-many-parens problem do not know about [paredit](http://www.emacswiki.org/emacs/ParEdit) or never became accustomed to it. I've programmed in many different languages, and paredit-based editing is by far my favorite way to write code. [gif demonstration](http://img8.imageshack.us/img8/9479/openparen.gif) Many indentation-to-parens translators have been written, but this one must be the craziest. Just skipping around the video I saw this example at 16:38 {foo a b c} ; parsing error {foo a b c ; proper I had to listen to the audio to be sure it wasn't a typo, but indeed this is the design: you're not allowed to close the brace.
Can reader macros affect ';'?
Reader macros can do anything - at least on some Lisps. But use with care when touching characters attached to existing reader functions. 
Yes.
Man, why? That's ugly..
Here are some in [Emacs Lisp](http://dorophone.blogspot.com/2011/04/emacs-lisp-curios-some-useful-some.html), that I wrote. My favorite is the stack language one, which lets you write: (||| lisp-val: (list 1 2 3 4) { 1 + } map { 2 &gt; } filter ) which produces '(3 4 5) It is a stack based concatenative language like [Factor](http://factorcode.org/).
Cool, yes. Useless, no. Interlisp-D / Xerox Common Lisp / Medley had reader macros for comments, so they could go through the structure editor intact. ; Here is a comment ;; Here is another one ;;; And yet another comment would be read as: (|;| "Here is a comment") (|;;| "Here is another one") (|;;;| "And yet another comment") The visual structure editor would show lists structured like that as appropriately indented comments - one semi on the same line, two at the current indent level, three and four at the left margin. Source code containing these had to go through a reader that stripped the comments before evaluation or compilation, of course.
One of my favorite macros is deflex, which I load in my init files and alias to lex. It creates a global lexical variable -- so instead of : (defparameter *X* (testing-stuff-at-repl)) I write (lex x (testing-stuff-at-repl)) to my great relief. I use Rob Warnock's implementation: http://rpw3.org/hacks/lisp/deflex.lisp I was toying around the other day and made a macro for creating hash tables which seems like it might come in handy (it seems familiar -- I might have read about this somewhere): (defmacro hash ((&amp;rest arguments) &amp;body k-v-plist) "Make the hash table. Use no delimiter between keys/vals. (hash (:test #'eq) :key1 val1 :key2 val2)" (let ((htable (make-symbol "HASH-TABLE"))) (labels ((gethash-expand (plist table) (when plist (cons `(setf (gethash ,(car plist) ,table) ,(cadr plist)) (gethash-expand (cddr plist) table))))) `(let ((,htable (make-hash-table ,@arguments))) ,@(gethash-expand k-v-plist htable) ,htable))))
Who said it was a reason to ignore the video entirely? It's just misguided and oh so typical.
It wouldn't be useless you could do docstring tests like in python but for lisp.
I see. Once I find a copy of paip, I will use that. I really don't like Shen's syntax (/. as lambda is bad enough...), so I wouldn't use it standalone.
Note that there it exists wrapped as a library: http://cl-user.net/asp/libs/paiprolog 
Thanks for the tips, especially that loop idiom. I was looking for something like that, but missed it. I'm usually a user of GENSYM. I decided to try MAKE-SYMBOL after reading a discussion pointing out that it is more readable when \*PRINT-CIRCLE\* is true. HASH is a macro for the syntax. 
It's funny to see how many people think of the idea of giving Lisp an ALGOL-like syntax, and then fail miserably. If only there was a way of keeping track.
I'm sorry to hear that. Paredit does that work for you.
The MAKE-HASH-TABLE options besides test are seldom used, in my experience. So I would make it (hash 'eq ...) and (hash* '(:test 'equalp :size 1000) ...). If a function suffices then you almost always want a function instead of a macro. The use of &amp;body is meant for passing a progn body. Using it for list data is bound to confuse people.
I wrote DSL like macros to parse binary files, mostly for learning purposes. I'm not sure whether it's useful or not but it was certainly fun! Macros: https://gist.github.com/1704351 Sample usage: https://gist.github.com/1706229 Btw, I'm open to all criticism to improve my lisp skills.
Agreed, there's some semantic transformations he does which I think might be interesting, but he spent a lot of time banging on syntactical issues. Although I thought his comment on functional vs. imperative indentation affecting readability bears consideration.
I use this one quite a bit. It's fun, interesting, and useful, but not short. (defmacro deferror (error-name report-format &amp;rest slot-names) "Defines error conditions. Condition slot-names are passed as format arguments to the report-format string when printing the condition, in order." (with-gensyms (condition stream) (flet ((catsyms (&amp;rest symbols) (intern (format nil "~{~S~^-~}" symbols))) (keywordify (sym) (intern (string sym) :keyword))) `(define-condition ,error-name (error) ,(loop for slot-name in slot-names collect (list slot-name :initarg (keywordify slot-name) :initform nil ; default value if no initarg :accessor (catsyms error-name slot-name))) (:report (lambda (,condition ,stream) (format ,stream ,report-format ,@(loop for slot-name in slot-names collect (list (catsyms error-name slot-name) condition))))))))) You use it to define error conditions that inherit only from `error`, in one line, including a report function so they print nicely. I have a strong dislike for CLOS, got pissed off at define-condition boilerplate, and had too much time on my hands. Here's an example use of deferror from some OpenGL code: (deferror shader-program-error "Program ~A failed.~%Program output: ~A" action output) Then, you just pass the name of your new error type to `error` and `cerror`, along with keyword arguments for the slot values, like for any condition type. Like this: .... (when (not (gl:get-program p :validate-status)) (error 'shader-program-error :action "linking" :output (gl:get-program-info-log p))) .... 
No it wouldn't. What if you wrote a system which wrapped defun, defmacro, etc and would save your various versions in a file automatically while creating hooks to create auto-magical documentation. Hook up several developers and you could auto-update each of them as soon as you "check-in" some code.
Fatal error: fatal flex scanner internal error--end of buffer missed in /home/bobbysmith007/russ.unwashedmeme.com/blog/wp-includes/functions.php on line 2016 :(
great walkthrough in quicklisp!
Violates terms of service: http://interfacelift.com/website/terms_of_service.php
The major fallacy in your argument is that because you were able to afford it, everyone else should. This is patently wrong. I've played with the LispWorks Personal Edition, and it really is a great CL IDE. I'm more likely to reccomend SBCL or Clozure to someone, however. It's simply too costly to purchase / maintain support for a LW license for many people.
Thanks for notifying me! Edit: Sweet like half my dreamhost account got wanged... Basically every php file got rewritten to be crap
I have rarely seen styles such as: (defpackage InterfaceLift ; PascalCase (or UpperCamelCase) or T) ; capitalized t except when from newer CL people from a Java/C# background. Are these more common than I thought?
I like it when people isolate "patterns" in macro usage: that's generally a good indicator of things that should *not* be macros. Macros are an extremely powerful, and for this reason extremely dangerous and ill-behaved feature. Each time you isolate a subclass of things that you use macros for, you can think harder about what it's doing, and find a language feature that is less powerful (and therefore better behaved) than macros that allow it, and support this use in a better way. In this example, macros are used instead of higher-order functions and (some form of) parametrization over types. If the language support them, using macros for this example is arguably not a very good idea. To put it in a different way, "design patterns" are usually a good indicator, for language designers, of what should be improved in the language.
I agree. It has too many parentheses.
Thank you.
Thank you. I'm glad that people like it.
I think you were misreading my message. I did not say that macro *in general* are bad; indeed, macro are usually the most flexible (and, for that reason, the least structured) way to express a programmer's attempt at abstraction. No language being perfect, you will always find a part where what you want to express cannot be captured in a satisfying way other than syntactic abstraction. When you reach that point, it is indeed a very good thing that you have macros -- otherwise you just can't do what you want. So macros are good for the lots of little uses that weren't thought of upfront by the language designers. But when you begin to use some macros to do something again and again, following a common pattern, then it is time to think about what those patterns have in common, and how to adequately capture them in a strong abstraction. If this abstraction can be expressed through facilities of the language that go beyond syntactic abstraction (here, higher-order functions), that's excellent. If not, you may find yourself wishing the language was extended to support it. It can also be in the form of syntactic abstraction, but using a controlled implementation, standard across different programmers, a common extensibility point. In most cases there is something better, and that is my point, that separately reimplementing similar-looking macros.
Agreed. We really shouldn't change our languages to capture new patterns. We should have kept to gotos, not [functions, if statements, or while loops](http://david.tribble.com/text/goto.html). /s
How does a well implemented macro differ from extending the language. 
Error reporting, optimizations, static checking, standardization around different programmers... Those are all grey areas, you can achieve good results using macros only (for example you *can* standardize macro usage around different programmers, or the Racket people have done a good job of enabling consistent syntactic error messages in macros), but it's usually much more difficult with macros alone. Or those macros are implemented by some specialized providers, you only reuse them, and they've become effectively indistinguishable from a "language feature" that you use -- instead of implementing macros for this on your side. Why do you have a concept of "function" if you could use macros all other the place? The same arguments would apply to other program abstractions.
There is a contradiction in your message. You claim that there is nothing ever wrong with macros, but that the author should still have used a different, specialized feature of the language. Why? Why is your solution better than the macro used in the original post? If it is better, then is it not true that macros have downsides? I may have used too bold a language; "ill-behaved" is a strong word and I was being a bit categoric. It's still strange how people react by just downvoting my posts and burying their head in the sand.
Of course, and I think you're right, we agree on much. However, there are times in which call/cc is too much power, but other language primitives are too much power. You seem to imply that macros aren't first class, and I'd agree for those implementations I've seen (Common Lisp, Scheme, etc.). Would you view the situation differently if macros had a stronger foothold in the language? E.g. Kernel.
I should have known what I was dealing with when you didn't even bother to put in enough effort to formulate a logical fallacy argument correctly. I was arguing against the statement that a single developer could not afford it and provided several examples of how and where this works. I was quite impressed at how you reasoned that I was arguing that everyone else must therefore be able to also afford it. It was such a reasonable extrapolation from my limited remarks, not to mention my explicit indication in several places that it is not right for everyone. &gt; The entire tone of your posts here have been "Well, I can afford it, and every company and user should be able to so stop your whining." Oh, what an argument. Using how wildly you elect to interpret my posts against me. You take the entire tone of the several paragraphs I have written here from three sentences? All of which are out of context? But you're correct about the last part. Stop your whining. If something is too expensive, don't buy it. Or contact the vendor directly and attempt to negotiate. This is a business. And the entire tone? Certainly you must be referring to points I've made even to you such as: &gt; I've argued that many people are able to and that LispWorks seems to be successful. I've also stated that many people here don't sound like their target audience and in many (most?) cases I, too, would recommend an open source CL. I'm clearly a LispWorks zealot. Any tone I have taken is with respect to each individual discussion that has taken place here. Almost all of which consist of arguing with the self-entitled sort like yourself. &gt; What you find affordable for yourself and at your employer is not necessarily what the rest of us find affordable. *So what?* How does it matter what you personally find affordable? Don't buy it. Am I to interpret the tone of your posts to be that you are in some way entitled to being able to afford LispWorks and thus that it **should** be less expensive? Is that your point? If not, what is it? That many people cannot afford it? How is that even relevant? Yes, I can afford LispWorks. LispWorks continues to exist just fine without the money that you don't want to spend. &gt; Did you just walk into this thread to shill for LispWorks? No. I walked into this thread to dispel these childish notions that just because you want something it should be priced at exactly the point *you, personally,* want to pay. In what way am I a shill? I've stated (even in the comments you elected to ignore in my previous response) that I don't think it is generally a valuable proposition on Linux, and a limited one on OS X. One of the three sentences you selected of mine stated that it was a difficult decision to make. I'm such a shill.
&gt; There is a contradiction in your message. You claim that there is nothing ever wrong with macros, but that the author should still have used a different, specialized feature of the language. Why? Why is your solution better than the macro used in the original post? If it is better, then is it not true that macros have downsides? Yes, and you are correct, the downside is complication. But complication is not 'ill behavior.' Macros are just programs and will always behave how the programmer programs them. My solution is better because I took &lt; 5 minutes to write an average function and pop in a single type declaration and a few compiler declaims, and I was done. I don't know why you are down-voted? Perhaps tone? I think people took offense to 'ill behaved' Reddit is kind of a fickle mistress in that way. You actually make an okay point, and I didn't personally downvote, I just disagree with parts of what you said.
And on the other hand that is a fairly polite request from the author of the site, and courtesy is the glue that binds society. That said I do think that the script is at least attempting to abide by the policy by not downloading everything all at once. (Note it never says that you shouldn't access the site by a script, only that it was not the intention of the authors that you do so, and that the authors want to keep the site up and responsive for all their users).
Actually, 'What I think I do' should probably be the wizard as well. Lisp is some powerful magicks.
What other programmers think you do: )())(()) (()( )()) ( ())) )
That's a surprisingly high ranking. 80% of it is probably Emacs Lisp, though. It does nevertheless offer a gleam of hope.
In other news, Fortran is the 9th most popular language in Wheezy.
Pretty much. My job's in C#, but I code Lisp when I wake up, and often in the evening as well. It keeps me sane.
Use both! Helper tools! RDNZL! DLLs! IronScheme! ClojureCLR!
What I think I do should be the wizard, but "what society thinks I do" and "what my boss thinks I do" should be a generic cube-farm person, unfortunately
Btw, here is the [snapshot](http://imgur.com/NpleA) of lispforum.com
&gt; Point taken that what you describe in the article is not literally the application that you are intending that for, but there is on my end concern that the naive reader will read through this and assume that this is the appropriate way to optimized a function in common lisp. It is not, it is an anti-pattern that indicates that you don't yet understand either type declarations or compiler macros. Probably both :) It was not my intention to give this an example of how to optimize a Lisp function, otherwise I would have say that. But like I said before, I realize now I was not clear and a reader might just read that. I need to be more careful next time. Anyway, that does not change the fact that I am not versed in compiler-macros (I've never used them) and this is a good opportunity to go back, read again about them but more important, use them. But I am not sure they can be useful to the main idea I had for this post (which was not type optimization) but that's something I need to explore first. &gt; I'm sorry if this comes off as harsh, and I don't mean to indicate that what you have done is a cardinal sin or anything like that. I've certainly done similar things trying to get things to run fast. The point is not that you are wrong, the point is that there is a better pattern for achieving the same result, and I want you to understand it. No, you didn't sound harsh or anything and thanks for making these useful comments! It's the only way to keep learning :) 
Its up for me
It's up for me now. Deleting the post now. :)
Those are on the top two monitors, the actual code is on the lower two. It's an Emacs feature.
They think that's what all programmers do.
Not actually CL but scheme, but I always link a scheme as an extension language the C programs I'm paid to develop. If nothing more it saves me a parser/serializer, reading/writing s-expressions instead whenever some datas must be exposed in a file. I use Guile, but in the past I used ecl which also fits this need quite well.
&gt; I used ecl which also fits this need quite well ECL is very underrated. It is one of the only two embeddable languages (I know of) that can work well in native multithreaded C applications. Other one is Lua.
Re: #2: [More Fun With Log Files Stored As Lisp](http://irreal.org/blog/?p=391)
&gt; (just an idea) With some of our tools that are written in C or C++, instead of writing out plain text output files containing data, etc, I could write them in lisp format. After the program finishes, I could run these files through a CL written tool that interprets the output file (lisp code) and does various things with it. Has anyone ever done this? Any tips or tricks? I can really recommend putting your data in s-expression form. It has a low data and processing overhead compared even to json. This C library comes highly recommended in both speed and ease of use: http://sexpr.sourceforge.net/ I use s-sexpressions to shovel quantum simulator data around in lisp, C99, C++ and a few scripts in python and bash. &gt; I saw that there is an interface to gnuplot written in CL. I plan on checking this out soon. There is, but most lispers use a foreign-function interface to directly access gnuplot. 
I guess part of me can understand attempting ALGOL-like syntax (took me a while to get in the Lisp mindset after a decade of programming) but when you then go a step further and implement required spacing (multiples of 4?!?! thats 2 too many) and then removing all parenthesis in grouping such as used in let...the craziness just continues.
You can get away with CL in Java-only environments with two Java-based CL implementations: * [Armed Bear Common Lisp](http://common-lisp.net/project/armedbear/) * [Clozure CL](http://www.clozure.com/)
My mistake. I do know the difference between Clozure and Clojure, I think it was a bunch of Java-related files in the Clozure Mac distribution that made me think it was written in Java.
I worked at AOL for a year not long ago (built the Editions back-end along with my brother). The main back-end is written in C# and I was getting really into CL at the time. I snuck a lot of lisp tools in here and there. For the most part, it was throwaway stuff: a program that given the name of a company does its best to find the company's twitter account (had about 95% accuracy, worked by searching bing's API (via drakma) for "[company] twitter" and taking the first twitter.com/ result. This little app also did some interaction w/ mongodb via cl-mongo, which seemed to work fairly well. We also worked on a fairly large queuing system (C#), and much to my protest, the higher-ups decided not to load test anything until a few weeks before our hard launch. I wrote a lot of load-testing code in lisp for that. I wanted to start using lisp for some of the server administration as well (I was the main SA for all Editions' servers as well as 1/2 of the back-end team, ha) but wound up writing a bunch of bash scripts instead. I got some funny looks when I told people I used lisp at AOL. The only people who knew what it was thought it was completely antiquated. I held back the angry nerd inside and shrugged it off. Would definitely pick lisp over C# in a second. I'm currently working at a smaller company, and we're eventually going to need some sort of queuing system for the app we're building. I'm going to try to get everyone on board with lisp &amp; ZeroMQ or redis...we'll see if that flies since I'm the only one with lisp experience.
I am disappointed by his ideas on Clojure and CL. He still thinks like a non-Lisper, which makes him a valuable voice of criticism towards the community, but is crippling.
No, I don't mind. I commented here because I don't like posting contrary (or "inflammatory") views on personal blogs where they can be deleted.
elance is a great place to go to practice programming for free (learn to program with the odd possibility of getting paid from time to time)... ...and while I find the guy's reasoning funny, it's also highly dysfunctional.
I understand that this post is one person's personal perspective/experience as it pertains to Common Lisp. So please indulge me as I express my own opinion rambling/raging response. &gt; First of all, I find that Common Lisp is bloated. How is Common Lisp's 'bloat' different from: * .NET library * Java's library * Perl's library * Python's library You might have an argument if you are comparing against C/C++ which have very minimalistic base libraries but how much are you going to get done without threading, networking or UI libraries these days? &gt; There are usually about 6 different ways to do something. Please show me a programming language that doesn't have multiple ways of doing something. In C/C++ you use fprintf, printf, vprintf, fputs, puts, fread or cout for writing a string? In Java you can use: * a SAX parser or a DOM parser * the java.io or java.nio package * An Enumerator, Iterator or a conventional looping construct In just about any curly brace/semi-colon language you could use: * an if or case statement * a while, when or for statement &gt; And, in many cases, some of the options seem to be now-unused holdovers that persist from earlier days in Lisp's development. So eventually you learn which ones you can ignore. But it all makes Common Lisp rather tedious to learn. Like the java.awt package in Java? Like Windows Forms being replaced by XAML. Man you'd think that Lisp was the only language under the sun which has some legacy code/functions/objects. &gt; My next stumbling block is the formatting. Here we have the crux of a large part of the post. The OP doesn't like how Lisps are formatted. Lisp isn't formatted like curly brace/semi-colon languages. You can't apply what you have learned reading curly brace/semi-colon languages to reading Lisp and this makes it harder to learn than another curly brace/semi-colon language. Spanish isn't English the only way to learn it is to buckle down and work at it. You want to know that isn't going to help? Belly-aching that the one isn't the other. &gt; One of them that irks me is that your editor will help you. So are you one of those people who don't use autocomplete? Jump to definition? Find all references? Refactor? If you do then you are a hypocrite for complaining about using the editor to read code. If you don't you're a lousy coder who doesn't know how to use your tools properly. &gt; First of all, you're not always reading code in an editor. Sure, but if you are reading code outside of your editor what are you doing that requires you figure out which parens match? &gt; A third argument is that you can ignore the parentheses because the indenting should show you the structure. But the indenting is not what actually determines the code structure--the parenthesis do! In curly brace languages indenting is not what actually determines the code structure--the curly braces do! I still hate people who don't indent properly and it still makes it harder to read. &gt; So I need to be able to quickly spot when the parentheses are wrong even though the indenting is correct. If this is so important why aren't you in your code editor again? &gt; if Lisp is so wonderful, how come we're not all using it? It all depends on what you are talking about doesn't it? Market demands influence what people learn. Un*x is based on C, C++ derives from C. Microsoft backed C/C++ and Visual Basic then C# and the other .NET languages. Windows and Un*x becoming the dominant platforms created a much larger demand for developers for the tools that had the most support. Java was a product of Sun which was a major Un*x vendor. Is it really any surprise that most people back the languages that have the most tools/vendor support for their platform? Lisp isn't for everyone but when I read a rant like the OP's it really makes me wonder how much they have reflected upon their own languages and biases before critiqing someone else's.
There's a fair amount of learning, tooling, and customization required to comfortably edit and read lisp code. The beginner's translation of those facts is often "you can't comfortably edit and read lisp code", the expert's translation is often "there is no problem". 
The one thing I enjoy about using Lisp is that its different. Programming for the last decade or more, using C/C++/Perl/Python/etc I found that using a language that is completely different has opened up my mind to new ways of doing things. I find it a little funny when programmers get all hung up on syntax...isn't the whole reason you learn new languages to teach yourself new ways of doing things? If you get hung up on formatting you are never going to get anywhere new or exciting.
As another beginner, I can tell you this is bunk. The only hurdle I had with reading Lisp was divorcing myself from infix notation. And it's easier; I do not have to memorize quirks of operator precedence when it comes to using operators like "OR". Editing is just as easy, but I admit to using a crutch: vim gives me matching ()s highlighting. I don't count ()s; I just spam ")" until the toplevel "(" for my block is highlighted. Super easy -- easier than trying to match )]}. There is generally just the one symbol to worry about. 
In other news, C-based languages damage the ability to understand languages outside of their paradigm. :-( I think Dijikstra said something similar about BASIC.
That's great that it was easy for you. 
Thanks for the replies everyone! I'm going through the comments to see if I can get some more ideas. I'll come back a compile a list later tonight or tomorrow night.
Because r/Lisp was too active?
No, because r/Lisp was judged to be about the Lisp family, not about CL. *shrug*
Apparently the easiest is to just generate gnuplot source code.
There's picolisp, emacs lisp and the ever controversial newlisp to name a few. Given how easy it is to create new dialects of lisp, it seems sensible to have an overall subreddit for the genre and one specifically for CL. That said, I just hope the great content keeps coming.
Thanks, I would love to have some other options. I found Gary King's solution, but even it only produces scripts that gnuplot can execute to produce plots.
And CL isn't in the Lisp family? What would go to [/r/lisp](/r/lisp) if we send CL related things to r/CL and Scheme related things in [/r/scheme](/r/scheme) and so on? Nothing? comp.lang.lisp works in a similar way: it is mostly about Common Lisp, but discussion of other dialects are fine too. So you can start discussing advantages of CL macros, then NewLisp guy will say something about FEXPRs, and then Kent Pitman will give us an overview of similar features in old dialects. It's awesome that everything happens within a single information space rather than over numerous isolated newsgroups.
&gt; They are not significant enough to take their interests into account. Do you realize that it sounds pretty arrogant? &gt; Emacs lisp doesnt even want to be a general purpose language outside of the scope of a single text editor. So? Many lisps are embedded, that doesn't mean they aren't useful. It's one of advantages of lisp-the-language-design that it is easy to make an interpreter for your needs. &gt; For me it doesnt. Having no language actually called "Lisp" although countless publications reference it only as Lisp is super confusing. That's not true, original language McCarthy has designed was called LISP. Then there was LISP 1.5 and so on.
&gt; John McCarthy said that he wants What he wants may not be what other people want? &gt; it isn't a "historical naming baggage". It is in the context of "Common Lisp needs its own subreddit because /r/lisp represents the whole family".
&gt; How about paying a little respect to language inventor? Not by doing something that doesnt really make sense any more, i.e. by dragging "Common" along. &gt; Now if you'll say that discussion of other dialects isn't welcome in /r/lisp (or comp.lang.lisp for that matter), I'll kill you. At least in /r/lisp, it isn't. At least the few times I've personally submitted news about other Lisps, they've been downvoted to oblivion in order to remove them from the front page. If a majority wants this subreddit to be about Lisp only, and the name Lisp to be Common Lisp only, I'm fine with that.
Makes sense
&gt; Not by doing something that doesnt really make sense any more, i.e. by dragging "Common" along. Removing "Common" will make your speech ambiguous. You cannot just decide to remove it one day because there is a lot of existing text which uses Lisp as a more general term. &gt; At least in /r/lisp, it isn't. At least the few times I've personally submitted news about other Lisps, they've been downvoted to oblivion in order to remove them from the front page. That's not true. I guess material you've posted was too boring for general population. Right now majority of front page is about CL, but there are some non-CL posts: 1. One () to Rule them All -- about Clojure (as far as I understand) 7 upvotes, 2 downvotes 2. Different Zach, Different Opinion -- first impressions of person who doesn't like CL and wants to consider Clojure and newLisp -- 4 up, 3 down 3. LoC by language in Debian Wheezy, Lisp is the 8th language by popularity. -- isn't CL-specific, 7 up 1 down 4. Difficulties of elisp -- (both about CL and elisp) 30 up, 0 down 5. LISP Is Back, and It's Baaaaad! -- general article about many dialect, mentions Clojure a lot -- 19 up, 11 down 6. What People Think I Do: Lisp Programmer -- general -- 99 up, 42 down 7. Animvs, a new kind of Lisp - 9 up 9 down (comments show it's downvoted because it lacks quality, not because it's not CL) So it's not true that it's only about CL. Maybe there is some bias, but it's only because of popularity -- if I know CL articles about CL are more interesting to me.
&gt; Yes, but requiring every little implementation author's OK to rename Common Lisp to Lisp doesnt seem realistic. It isn't realistic in any case. &gt; Meaning that Emacs Lisp, AutoLisp, and other embedded Lisps do not lay any claims to the generic name Lisp. It has nothing to do with these lisps being embedded. Just "lisp" is a name of a family. 
Odd, comp.lang.lisp used to be full of nothing but CL holy warriors plus the occasional lost soul. Sounds like it's mellowed with age. That makes me happy.
The fact that Lisp is a family of languages isn't just historic bullshit and shouldn't be denied. I agree CL dominates, but it won't do so forever and when one day it is fading behind some new dialect, it will still be true that Lisp is a family of languages.
I had a similar problem with graphviz. In the end, dot is such a simple and regular language that it's trivial enough to roll your own graph-to-dot function. 
C-like speed, high-level, simple syntax, and metaprogramming = Common Lisp. As I see it, if you want complex syntax, why don't you write it on the top of Common Lisp? This is what Ross Ihaka (one of the guys behind R-language had in mind in 2008): https://groups.google.com/group/comp.lang.lisp/msg/a520a6e0c270da1a &gt;We started work on R in the early '90s. At the time decent Lisp implementations required much more resources than our target machines had. We therefore wrote a small scheme-like interpreter and implemented over that. &gt;Being rank amateurs we didn't do a great job of the implementation and the semantics of the S language which we borrowed also don't lead to efficiency (there is a lot of copying of big objects). &gt;R is now being applied to much bigger problems than we ever anticipated and efficiency is a real issue. What we're looking at now is implementing a thin syntax over Common Lisp. The reason for this is that while Lisp is great for programming it is not good for carrying out interactive data analysis. That requires a mindset better expressed by standard math notation. We do plan to make the syntax thin enough that it is possible to still work at the Lisp level. (I believe that the use of Lisp syntax was partially responsible for why XLispStat failed to gain a large user community). &gt;The payoff (we hope) will be much greater flexibility and a big boost in performance (we are working with SBCL so we gain from compilation). For some simple calculations we are seeing orders of magnitude increases in performance over R, and quite big gains over Python. &gt;There is lots to do. We're experimenting with syntax and making a start on assembling quality numerics libraries. Creating a fully-featured system will require buy-in from the statistical specialists who can contribute implementations of their methodology, so we also thinking about issues associated with community building (eg. licensing). 
no windows package ? :-( sometime in the future ?
[It's just you.](http://www.downforeveryoneorjustme.com/http://cl-cookbook.sourceforge.net/) You might also consider searching for "Common Lisp" at Rosetta Code.
It's just that Not Invented Here mentality. We just create everything from scratch and after 10 years our implementation is halfway where Common Lisp was and it has collected more warts. Common Lisp has beautiful core of ~25 basic operators you can build on, rest is libraries (they are all in same package for historical reasons) and it is still nice language after all these years. The fact that it survives tells me that it has some lasting quality in it. Python, Perl, Ruby, R, you name it, they have no less "warts" in language semantics over Common Lisp after being revised few times. Forget my pessimism but I don't see it going better this time. Computer engineering as discipline does not have institutional memory. Lessons learned 30 years ago, are forgotten today. Maybe it's because we must study and use whole implementations where different ideas work together to really see what good there is in them. 
This bit also sounds *very* good: &gt; [Julia has a “no boilerplate” philosophy: functions can be called directly from Julia without any “glue” code, code generation, or compilation — even from the interactive prompt.](http://julialang.org/manual/calling-c-and-fortran-code/) Hopefully that works well! No more looking for the boilerplate projects. At best some extra wrapping if some extra macros/functions would be nice. And they call stuff 'standard library', which is also nicer than 'batteries included', or 'framework'/'environment'. Also like the lua-like code, which looks... better than C-type. Apparently it has fully-fledged macros, but that is going to take some getting used to, i think! Edit: bit of a bad side, but probably temporary [no namespaces yet](https://github.com/JuliaLang/julia/issues/57), i prefer directory-style nestable namespaces when subdirectories have meanings [like this](https://github.com/o-jasper/Expression-hook), and any dependencies must be specified, or the user must write `dependencies: "this is actually not a serious project yet"` or `dependencies: "oh dear do i have a complication that i cant do this?"`, and preferably stuff gets automatically checked that there are no 'hidden' dependencies. Edit: [did a little feature request](https://github.com/JuliaLang/julia/issues/385)
This looks really nice. Hopefully it doesn't go to the Dark Side--claiming it's the do-all, end-all solution for everything, optimizing for big businesses, and becoming....JuliavaBOL++.
If you mean the operating system, get dual install. If you mean gui programs, check my other comment. C gui programs can be used.
If you're using vim, I assume you're using slimv. How is it coming along?
I don't know if vim has something like this, but emacs has something called "paredit", which assures that parentheses always appear and disappear in pairs, and provides a bunch of shortcuts for navigating around nested parentheses. You should look into [slimv](http://www.vim.org/scripts/script.php?script_id=2531), it looks like it provides a lot of the same features.
Meh. READ is just a way to get code into an image. Every language can be read into an AST and the AST can be represented as a "list of atoms". Its not particularly easier to programatically manipulate lisp code vs code for any other language. The nice thing about Lisp macros is that they are linguistic (rather than metalinguistic) objects; in CL, an operator can be a macro operator and a form can be a macro form. In particular, macros have dynamic semantics rather than existing only in a preprocessing phase.
&gt;So what are macros? All they are is read packaged up nicely into formal system. Common Lisp has reader macros that do what this person is describing. Actual macros don't have anything to do with reader. There is no need for having phase where code has textual representation (and using reader) with macros. Describing Common Lisp macro system using compiler terminology: 1. **reader macros**: the front end. Reader macros provide programmable lexer&amp;parser and the result is parse tree. 2. **macros**: the middle end. Macros operate with intermediate representation and can do code analysis and modifications, like adding new symbols into symbol table :) Because macro language of CL is full CL, you can run web server at macro expansion time if you want to. 3. **compiler macros**: the back end. Optimizing passes before compiling into binary. And of course you can skip the #1 in runtime and give data structures directly to compiler: `(compile nil '(lambda (x) (+ x x 42)))` 
Yeah I was a little surprised that the title made "reader" separate, since I am used to seeing both mentioned here.
&gt;Python, Perl, Ruby, R, you name it, they have no less "warts" in language semantics over Common Lisp after being revised few times. If anything they have *more* warts, weird syntax, more than one way to do things, a lack of documentation, a lack of proper design, etc. etc.
So... They're rewriting it?
Does anyone have any idea on how to actually use this code? The doc/ directory is a bit sparse (and mostly in Japanese).
Naughty Dog wrote the Jak and Daxter games for the Playstation 2 using their custom tools and their custom Lisp (written using Allegro CL). It was also very much customized to the Playstation 2 hardware. For the tenth anniversary of publishing the game they gave the company 'Mass Media' the task to port it to the Playstation 3 (which has a very different hardware) in HD quality. Looks like Mass Media ported the software (or just parts of it?) by translating it to C.
There is a video about it : http://www.youtube.com/watch?v=BoHmf1YXI3k in japanese
Reminds me of what happened with Yahoo! Stores and Viaweb....and Reddit Pattern: something amazing comes out using lisp. People making it give control to others, or fade, or update. When it's updated, it's written in a different language in order to make sure others can understand it.
Porting it in GOAL would have meant writing a completely new compiler as well. Plus, one of GOALs advantages was that it would let you write VU assembly inline with the rest of your code. I remember a thread about it on sweng-gamedev awhile back: most performance critical code was still written as assembly s-expressions. Given that all the performance stuff would need to be rewritten for Cell anyway, and that the core GOAL compiler would need to be retargeted to PowerPC, it makes sense to just translate to C instead. edit: typo
http://blog.reddit.com/2005/12/on-lisp.html Reddit didn't get a rewrite to make it easy for others to work on, it got a rewrite because the environment they were working in made development more difficult than it needed to be, and the available libraries in 2005 were lacking in maturity and documentation. The advantages Paul Graham had with Lisp during the Viaweb times are largely gone nowadays for web applications.
According to the very end of the "GOAL" wikipedia article posted above. The guy who developed/maintained the Lisp is no longer available to them. I guess that settles it.
It is indeed strange that they chose to differentiate between value and list nodes. I guess it is more efficient, storage-wise.
I'm looking forward to the finished product :) Are you releasing your lispy morphic seperately like you did CLON?
This is a terrible poll, probably chosen by beginners. There's no other reason php would have that many votes. 
The article doesn't seem to contain a single intrinsic statement about Lisp or Common Lisp. 
ITA software is looking for a Software Engineer/Computer Scientist; in the job description it says that lisp knowledge is a big plus: http://www.google.com/jobs/itasoftware/eng/ita-software-software-engineer-computer-scientist-cambridge-ita/index.html
I see job listings come across the Clojure LinkedIn group once in a while: it may be worth giving it a look and tapping into that community.
You already said you'd work for free. Use Lisp enough at a Lisp-hostile workplace and you can eventually work for free.
Yes.
Hah, I can see that: "Boss, this is my two weeks, not two weeks notice but two weeks until I start coding in Lisp...same thing probably"
&gt;C++ is essentially the same as C with a few additions (e.g., classes). &gt;&gt; Real programmers use C It's either comments like these, or people saying they are starting to learn some basic programming.
Dang. Why didn't I think of that? Actually, I'd prefer to do the Lisp myself if someone would just do this C++ stuff.
I'm working on a startup in the Bay area. I would love to make it Lisp-based, but haven't been able to find any Lisp programmers willing to join. So at the moment it's all Python, which is a lot easier to find programmers for (though not as easy as Ruby). But it's not yet too late to change it.
Yes, I know most Ruby developers aren't developers. That's why I'm using Python and not Ruby. Lisp would be terrific, but Python is adequate. Given a choice between doing it in Lisp and working alone and doing it in Python and being able to more easily hire help I'll (reluctantly) choose the latter.
Unless you find another Lisper. Out of curiosity, no need to name names, but what does the startup do?
Don't say that. I made a number of clojure snippets for testing our server technology, that is java based, just for my own sake. It is easier than doing it in java and interactice. I checked these in, and before I knew they were part of the server monitoring. That I had something working was important, not that it was in a language my colleagues had not heard of. You get away with almost anything if it works well. In this case even unintentionally so. 
That is mind-expandingly wonderful.
Those are not accepted forms! Who is teach you such perfidy?!?
nope, the game objects are fully integrated with my morphic clone.
[Relevance](http://thinkrelevance.com/) does a lot of Clojure development, both helping build the language and deploy web apps. The other language they specialize in is Ruby. A pretty decent choice. Somewhere on quora is a list of companies using Clojure in prod.
It's a sad shop where a developer has to ask their boss what libraries they can use. Probably have to ask to use the bathroom at that kind of place too.
Indeed, I left out a restructuring of the function where I did just this. I couldn't find a problem where the anti-cons was truly the right solution (read: a better answer to the problem than even just keeping the messy original call). I liked the thought though, found it fun, wanted to present it.
Fair enough, I wonder if it might also be possible to extend this further to anti-nil so that you could do (divide polynomial 0 anti-nil) Instead of having to cons the anti-cons.
DAE think it's harder to read with the blocks than with plain old parens?
I think the blocks are not so good. What I'd like is an editor using tall parens bracketing multiline lists from top to bottom. I've done some mockups and it looks nice and readable (assuming you take some care for your typography). Haven't written it yet though.
I think it's a neat idea... then again, I always hated the common convention of indenting without "out-denting" leaving all your parenthesis at the end of the innermost child. I've always gravitated toward bracketed languages because of that. I like seeing blocks of code and this actually looks cool to me.
Most code visualizations are pretty bad. This is better than many. I'm not sure how it'd play out as an editor, but I think it's a decent program visualizer.
Can we see some mockup scans? That sounds really interesting!
Tbh 'in a web browser' itself seems like going backwards..
Sure, I've done two. Replacing parens around multiline lists with [big parens](http://postimage.org/image/4iu01kamb/) and replacing all parens with [square brackets](http://postimage.org/image/yripmf6bx/). I still haven't found quite the right style for the big parens. I think the curved portion needs tweaking (you can see on the right of the "setq browse-url-generic-program" line that I've messed with it. I don't like the way the small paren there seems to curve away from the big one, but it may be inevitable. It makes me lean toward the square bracket style, or toward using parens for single-line lists and brackets for longer ones (although I think to mix square and round you'd need a larger paren as used in mathematical typesetting). Edit: I think it's important that the tips of all parens on the same line, big or little, line up. It's easier to look at, but it also makes it less confusing to know which parens go with which line, which is the whole point of using big parens.
&gt; I always hated the common convention of indenting without "out-denting" That is actually a feature. Not a bug :-) Putting end parens on their own lines (like 'C' is closing brace) will take up too much screen estate without giving much in return. Thinking in terms of lines is another algol-like affectation that doesn't translate well for lisp editing. For example, I can never copy a few lines of lisp code and paste is somewhere else easily because usually there are more end parens than I want. Manipulating sexp's (emacs has great support for that) is the way to go. Manipulating lines is painful and frustrating in lisp editors.
while it's maybe not how i would prefer to program, given the larger trend of more and more happening with the web browser as the user interface to remote content, it's hard for me to agree with you that this is a step backward. A step to the side, maybe. Honestly, I can think of some pretty cool applications for this, along the lines of remote collaborative code editing by multiple parties. Google docs for lisp, if you will.
This reminds me a lot of the [Code Bubbles](http://www.andrewbragdon.com/codebubbles_site.asp) UI, but for lisp instead of Java. You should take a look at that, as there are definitely some great ideas about code expansion, organization, and movement around your code. It would be pretty fascinating to integrate a semantic model of the code, perhaps to have UI-level function/macro expansion without affecting the actual code. Interesting work, though :)
I think this is a neat idea, and is probably useful for someone learning Lisp. But I honestly found the blocks much harder to understand than the straight-up plain text version. The author is doing some cool stuff, I just don't see the point. It seems that there are two types of Lisp programmers: * Those that have been programming in it for years, are not bothered by the syntax, who love the power of structured s-exp editing and can see through the parens, and * Those that are learning the language and just can't get past the parens, so they go out and invent a new notation or write a cool tool like this to work around their unfamiliarity with the syntax. I know that sounds like an "us vs. them" ad-homonym dismissal, but it really does seem that way. 
I didn't think this would be about parens, actually. My biggest problem with Lisp, I think, is that the all-lowercase-with-hyphens naming convention makes none of the names stand out at a glance.
Indeed, the browser is merely a compatibility layer, and things like the chromebook have gone so far as to replace the standard gui stack with a glorified browser, so I guess it could go either way. But in terms of current availability and adoption, browsers are universal, so this seems like an interesting design choice that has some drawbacks as well as advantages.
I dislike the OP, but really like the big-parens mockup. For this idea to work in a dynamic editor, you should consider making it behave like a structure editor - you want to disallow unbalanced parens, ever: * typing '(' inserts "()" into the buffer and puts the cursor between them * typing ')' when cursor is to the left of ")" moves cursor past ")" * deleting "(" also deletes the closing ")" * deleting ")" also deletes the opening "(" Wrapping () around existing structure is tricky. If you have "a b c" and you want to make "(a b c)", how about: Put cursor before "a", type '(': (|) a b c (cursor represented by '|') And then there's a keystroke that moves the ")" ahead one s-expression: (a|) b c (a b|) c (a b c|) Do pursue this - I'd love to try it!
My hope is that I can use images in Emacs for the big parens (not sure yet if they can float over text), making paredit usable as usual.
I like it: the indentation conveys the information anyway. Still, even if you don't like it, I don't see why it would put you off Lisp: if you want to close parens on their own line so much, just do it. It's unconventional, but not really a big deal.
Also there will be no bubbles inside other bubbles. A bubble can contain only atoms. A bubble has now a dent and two pimples, CDR and CAR. You can push the pimple into the dent of other bubble. CDR-pimple is on opposite side of the dent, CAR is on the side. (lamdba (x y) (+ 1 2)) is a three bubble string with (x y)-string and (+ 1 2)-string sticking sideways from that. Symbols are inside the bubbles. The name of the string "PLUS" is written on the first bubble. Looks nice.
Yes. It obstructs the code too much. Having the parameter offset from "&amp;optional" is particularly egregious. Possibly a more subtle implementation of the idea would be okay.
This is really pretty cool. Though I'll probably still use Emacs, I'll definitely look at this
Did you use the actual Unicode big parens, as in the following? ;;; Org-mode ⎛add-to-list 'auto-mode-alist ⎞ ⎜ '⎛"\\.org$" . ⎛lambda () ⎞⎞⎜ ⎜ ⎜ (org-mode) ⎜⎜⎜ ⎜ ⎜ (auto-fill-mode) ⎜⎜⎜ ⎝ ⎝ (setq truncate-lines nil)⎠⎠⎠ (global-set-key "\C-cl" 'org-store-link) (global-set-key "\C-ca" 'org-agenda) This looked really messed up in Firefox on Windows, though there should be the correct number of spaces when viewed in monospace. Unfortunately, gvim on Windows doesn't like the brackets, so I only see a bunch of ?s in there. I'll have to check this out again at home on Linux 64-bit. Everything always looks perfect in there.
Nope. It's worth a shot though.
Maybe you could borrow some ideas from http://www.gnu.org/software/auctex/ ?
Neat experiment, good effort, but let's be real; code represented in that way is eyeball rupturingly ugly. The parentheses are more appealing by far. Really keeping with the Emacs aesthetic, though--"slime", paredit's "barf", and so on. The green background does that blobby mess no justice.
Nice work! I'd definitely prefer this to matching bunches of normal parens.
With paredit you'd use C-M-u until you'd ascended to where you wanted then type C-M-k to kill the sexp at the point.
You get used to the parens, and come to love them, you really do. Now when I look at other languages, I'm "What's with the wacky irregular syntax?". Every Lisp newbie tries to do two things 1. Get rid of the parens. 2. Do arithmetic expressions with infix notation. Don't waste your time. Instead try and build up a personal library of useful functions and macros. Paul Graham's "On Lisp" would give you a good start. 
Very cool. Is it possible do the same mode for emacs without javascript, hunchentoot and others layers? I suppose it will be usefull tool. I like emacs.
I wouldn't say every newbie does this (I didn't), but it is annoyingly common, and reflects a common anti-pattern of approaching new languages expecting them to be like familiar languages with minor differences. Then when something too weird comes up, like Lisp's parens or Python's significant whitespace, it's considered to be a dealbreaker. 
Looks really interesting. It's a bit of a pity that it's closed source (and has poor support for open platforms).
Nice, thanks.
Clojure has a huge head start here, just by being a JVM language and having Clojurescript coming down the pipe. I'm delighted about this, because I like Clojure, but I also have some misgivings about its design. For the most part, Clojure looks a lot like an eager language, but there is a heavy emphasis on lazy lists which I think results in an impedance mismatch of sorts which one pays for in the complexity of maintaining sequence laziness, the breaking of which can often be implicit. And while I love the persistent data structures, I think the support for really pure functional programming is a little weak - it can be unwieldy to write complex code without dropping down to the transient interface, again paying in complexity. I don't know what the solution is, really - maybe I just need to program in Clojure more to get used to it. But Clojure feels significantly less clean and elegant than Scheme, which I find kind of disappointing. 
I have a non-working version of it for the Lisp Machine. It does not work with a newer OS version.
Very cool project! Just please make it for Firefox too ;) It is excellent tool for learning LISP-like languages and I will gladly recommend it to anyone struggling with the syntax.
I've never read "Land of Lisp," so I might be incorrect, but I was of the understanding that it was pretty well written, and I haven't heard many complaints. Of course, everyone learns differently, so I don't think you should take this as any personal indictment (it's most likely neither Land of Lisp nor yourself that are the "problem" per se, just that you don't see eye to eye). Luckily, there are quite a few books on the topic; there are the Little Xer books (Little Lisper, Little Schemer, Little MLer), there is How To Design Programs (and How To Design Worlds), as well as a bevy of other books for other languages ("ML for the working programmer" comes to mind, as well as Haskell School of Expression and Real World Haskell). Also, although I don't have a copy of Land of Lisp, feel free to PM me if you have questions (or if you end up getting something other than Land of Lisp, like the Little Schemer book). *edit*: oh, and there is "Teach yourself Scheme in fixnum days," which I've heard good things about.
&gt; That's always how it goes when somebody's walking you through solving a problem, isn't it? To some extent, yes, but that can be reduced by explaining not only what every bit of the code (that's non-obvious, i. e. not explained how it's used before) does, but also why it's done like that. As for the Hyperspec, that does indeed seem useful for when I don't understand what one function does, but unfortunately not overall very useful for understanding a whole program. &gt; You can always ask here or on comp.lang.lisp. If I just had one or two questions now or then, that would be fine. But when I can't understand an entire chapter I get the feeling that I'm reading the wrong book. Thanks overall for the advice, I'll look into Practical Common Lisp.
[Practical Common Lisp](http://www.gigamonkeys.com/book/) is available online for free. Sometimes I even still use it as a reference over the hyperspec.
There's lots, (defun tweak-text (lst caps lit) (when lst (let ((item (car lst)) (rest (cdr lst))) (cond ((eql item #\space) (cons item (tweak-text rest caps lit))) ((member item '(#\! #\? #\.)) (cons item (tweak-text rest t lit))) ((eql item #\") (tweak-text rest caps (not lit))) (lit (cons item (tweak-text rest nil lit))) ((or caps lit) (cons (char-upcase item) (tweak-text rest nil lit))) (t (cons (char-downcase item) (tweak-text rest nil nil))))))) (defun game-print (lst) (princ (coerce (tweak-text (coerce (string-trim "() " (prin1-to-string lst)) 'list) t nil) 'string)) (fresh-line)) That's one of them, didn't even understand it until I found it commented on a forum (and I'm still not sure I quite understand it all). Pretty much all the functions in http://landoflisp.com/wumpus.lisp upto and including connect-all-islands (I didn't yet get further than that), excluding the first few perhaps. There are more, smaller things (such as 1 or 2 lines), those are just a few of the bigger blocks of code. Edit: Formatting. Edit 2: One of the major reasons of me feeling that way is probably that I don't quite understand parts of it completely. That feeling of not being able to think up something such as that would probably wouldn't as strong if each part of the code was explained step-by-step (as opposed to just giving a general overview of what the code accomplishes). 
Yeah, that code just sucks. Ditch this book. Try _Practical Common Lisp_, like another commenter said.
Yes, and you make it a good deal more clear as to the distinction between the books I mentioned (learning functional programming vs. learning a Lisp), which is an excellent point; although Lisp systems are functional, the focus of the student is most important. &gt; BTW: TSPL uses `syntax-case` and not syntactic closures, just FYI. Woops, yes, this was my mistake, and good catch!
&gt; I looked into the Little Xer books, and it seems that The Little LISPer's fourth edition is actually The Little Schemer. How To Design Programs seems to be readable for free on it's website (which is a plus for me) and also appears to be in Scheme. That is correct, the last version of the Little Lisper became the Little Schemer series (and the other two books, the Seasoned &amp; The Reasoned Schemers are under-appreciated). I have personally only glanced at HtDP/HtDW, but they have an excellent reputation as well as excellent authors. &gt; Now comes the question as to whether or not I should stick with lisp or learn Scheme. Well, I originally started with CL, and switched to Scheme for a few reasons (one of which was that the Alpha system I was using only had UMB Scheme), but they both have their place. CL is excellent for many Enterprise applications, and Scheme is great for smaller programs (though many scheme systems improve this situation, as does R6RS &amp; R7RS, by including modules, libraries &amp;c. Gauche, Gambit, Chicken &amp; PLT/Racket are really excellent about providing practical Scheme experiences). &gt;From what I've been able to determine from a little googling, the difference lies in the details mostly (and Syntax, but that doesn't really matter all too much). Well, CL includes quite a bit more than Scheme does, and code you write in one CL system is more likely to be usable in another CL system than Scheme code is, due to the fact that R5RS is so minimal and implementing things like modules is so easy, everyone has their own. Things like SNOW! were attempts at fixing this situation, as were R6RS &amp; R7RS, but you generally have to rely on something like SLIB &amp; abstracted front ends if you want real scheme portablility. Of course, most people tend to choose *one* Scheme system and use that one only (I happen to use a custom one that I myself wrote for most of my consulting work). &gt; The thing is though, while I do have issues understanding Land of Lisp I would love to return to it at some later stage as I find it highly interesting (only complicated). Well, CL &amp; Scheme are different; Scheme tends to use descriptive-yet-long names, where as CL tends to use historical-but-short names for things (if to say nothing about the Lisp-1/Lisp-2 dichotomy and many other things), and Scheme tends to use continuations &amp; recursion much more than CL does, but I think that once you get over the initial weirdness of Lisp in general, you tend to pick up other dialects quickly (it's similar to C; once you know a C family member, you tend to sort out the idiomatic ways of doing something in another family member, rather than having to relearn the ways of programming all over again). &gt; Thanks for the advice though and happy reddit birthday! Of course, glad to be of help, and I meant what I said about PM'ing if you get really stuck! Your "Happy reddit birthday" caught me off guard, as my real birthday was yesterday, and I was wondering how you could have possibly known (that's when I saw the little piece of cake next to my name...).
Everything you've heard of Lisp being cool for, a good Scheme implementation will be just as cool for. Scheme _is_ Lisp, and much better designed than Common Lisp for a person interested in learning the essence of the Lisp family. I recommend Racket.
In a recent interview he gave, the author of LoL explained that if it was his decision, the book would have gone even much faster and focused even more on advanced parts because that is where he thinks Lisp has an advantage over other languages. But he then was forced by his publisher to make more and more introductory chapters and to explain more and more details making the book bigger and bigger. His intent never was to write an introductory level textbook, it often just looks like one, maybe because of the comics. Land Of Lisp also has its own [Google Goup](https://groups.google.com/forum/?fromgroups#!forum/land-of-lisp). You can also ask on the [Lisp Forum](http://www.lispforum.com/viewforum.php?f=2&amp;sid=1f8e26952f63508fd31d22f525a8b8d7). If you solve some problem and think that it should have been better explained in the book, please write it up and post it so other people can benefit from your effort.
Care to tell how it could be done better?
Looking good
I wanted to submit this here in part to share a ruby guy's (limited) perspective on lisp but mostly in hopes that y'all will correct any dumb stuff I say
Yeah I'm finding the same thing. When I was going through Land of Lisp there were many instances where I was able to relate what was going on to something similar in Ruby or Javascript. I expect it would have been a lot tougher going if I hadn't already been introduced to the concepts. What resources have you found useful?
It'll be neat if they can match the old MCL.
Very nice. cool.
*Higher Order Perl* was very helpful to me when I started. I already knew Perl fairly well, so it explained a lot of functional concepts in a language I was more familiar with. [This article](http://www.defmacro.org/ramblings/lisp.html) was also helpful to me early on, because it explained some things about the nature of Lisp that I was starting to understand, but couldn't yet articulate. [Common Lisp, The Lanaguage](http://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html) is a good reference. [On Lisp](http://www.paulgraham.com/onlisp.html) has been popular. 
Who the hell voted you down? You rock!
"For some reason, what I know well and like looks prettier to me than what I know poorly and dislike."
Why didn't he just write: (defun time-to-move (from-pos to-pos) "Calculates the total time to move between two positions, assuming rotation and ascension can occur simultaneously." (max (time-to-rotate (azimuth from-pos) (azimuth to-az)) (time-to-ascend (elevation from-pos) (elevation to-pos))))
I can't read Smalltalk, but do those pieces of code even do the same thing? Is there an antenna parameter lurking somewhere in the Haskell version?
| The relevant code has been folded into another routine, not shown. That's usually what I'm thinking when I read any Haskell code. 
Yeah, I don't really see what AntennaSimulator is supposed to be. Still, it'd be nice if the order of the parameters (and names) were the same between the versions.
That's pretty much all I got out of this article as well. To be fair, I didn't really understand the Lisp (I don't know what with-accessor does), but I was at least able to parse it out. Haskell continues to look less like code and more like wind-talking to me.
The top shittiest working page on an Android browser. Saved for later.
From this sample typography seems to have peaked in 2004-5.
Running in emacs for scheme should be: M-x run-scheme.
Very nice! I've been learning scheme and this is actually really helpful. 
Android Ice Cream Sandwich also will not run on RPi. The minimum requirement is for Cortex A8. There are other ARM SBCs such as the Beagleboard/Beaglebone or Pandaboard which can run ClozureCL. 
Surely ECL, and or clisp should be compilable to ARM. (And SBCL?)
I liked hearing about the different ways he uses CL to do perform tasks at work. It gave me some ideas for how to use it at my job. Great interview!
Yeah, that stuff's obnoxious. But judging programming languages with objective metrics is fundamentally wrong. Programmers aren't objective! And they're not all the same either. Trying to evaluate a language without having fitness for a specific purpose and team in mind is folly. Any concerns beyond "we like it" and "it serves our need" are a sign you've veered off from problem solving into theology.
I'm getting really sick of people like you tramping into Lisp communities, trolling the residents to "convince you" that Lisp is superior to language "foo" or language "bar". Nobody cares if you use it or not. If code concision is your only metric, there are more concise languages out there. Go ahead and use those languages if they tickle you. What you are doing right now is useless and inflammatory--some might say "antisocial". &gt; semi-literate Java monkeys Is this high school?
&gt;I'm getting really sick of people like you tramping into Lisp communities, trolling the residents to "convince you" that Lisp is superior to language "foo" or language "bar". It's really more pointing out that Lisp / Lispers tend to be all talk and no walk.
&gt;AFAICT, the "mystical" attitude towards Lisp, waxing about elegance and homoiconicity and zen, is mostly taken by "outsiders" I'm not entirely sure about that.
&gt;Maybe Lisp programmers are "prickly and antisocial" because they're sick of having people march into their backyards with the same tired "evidence" instead of actually tinkering and taking a look. I distinctly remember using clisp in middle school. Since then, I haven't been terribly impressed by Lisp. &gt;You really think taking some trivial set of problem is a good way to compare programming languages? The algorithms in question are in no sense trivial. &gt;Are the neat, self-contained programs you wrote in school like those you encounter out in the world? You're saying this like there is in fact much evidence for Lisp's practical efficacy. That's doubtful given the really sorry state of third-party libraries. Compare this for example: http://common-lisp.net/project/cl-machine-learning/ &gt;As of summer 2009, the project is barebones. We have a support vector machines library (cl-svm). Dormant for over three years and barely functional, to this: http://pybrain.org/ ...actively developed, supports SVM, and PSO, and CMAES, and backprop, and... &gt;Here is an example of a case where the Java solution doesn't stack up. I fully recognize that Java sucks.
That's your opinion. And it's an opinion which, I'm sure, would fly over much better in a '(Python Ruby Etc.) community than in a community for people who use Lisp. What are you anyhow? Some kind of a missionary, setting out to convert us Lisp heathens? You serve no purpose here. How about you "walk the walk" and revitalize an old neglected Lisp library, or go find a community where you *can* be useful.
This person is a troll who likes to [rile people up](http://www.reddit.com/r/haskell/comments/qqacn/distribution_of_hackage_packages_over_categories/).
&gt;Using Lisp years ago in middle school hardly makes you experienced. Perhaps not, but using more useful languages does. &gt;Identifying an underdeveloped library, or five, or ten, or one hundred states nothing about "practical efficacy." All I'm asking is that Lispers walk the walk, rather than just talk the talk.
In all fairness to Haskell, its community is nowhere near as full of braggadocio as the Lisp community.
&gt;If you're not a troll, use Python to solve the problem I linked to. Python doesn't have macros. So anything I'd give you would be dissatisfactory by your standards anyway. And in any case that macro is one hell of an ugly way to support metaclasses.
If a language were elite, wouldn't it need less third-party code? But seriously, your argument is that Lisp isn't popular? *Gasp!*
Obviously I'm not sure either, but it seems an odd post to make. If you think someone severely over inflates the power of Lisp would it not make more sense to challenge _them_ rather than the Lisp community in the abstract? Did you post about lisp rather than another HLL because you have the impression that lisper's in general have too high an opinion of lisp relative to the users of other languages?
Several of the Clojure entries are wrong, or possibly misleading.
http://c2.com/cgi/wiki?SmugLispWeenie
I don't really feel like doing work for you but at first glance that looks like something that Python's very powerful, standard regular expression would be able to handle quite easily, and with greater legibility: http://docs.python.org/library/re.html (Too bad Lisp doesn't have anything as good as that.) But if you press me any further, I *will* implement it.
Of all the things you could pick, CL has something like that, including benchmarks against Perl's C regex engine: [cl-ppcre](http://weitz.de/cl-ppcre/). You should probably know that I've been using (and have been fairly content with) Python for over a decade now. You're going to use regular expressions to read fixed-length data? **Wow.** &gt; I'm going to begin by running through a very simple example of language oriented programming and the kind of situation that leads to it. Imagine we have a system that reads files and needs to create objects based on these files. The file format is one object per line. Each line can map to a different class, the class is indicated by a four character code at the beginning of the line. The rest of the line contains the data for the fields of the class, these vary depending on what class we are talking about. The fields are indicated by position rather than delimiter. So a customer ID number might run from characters 4-8.
&gt;what kind of response do you want? "I'm sorry I use lisp because there are smug lisp weenies?" No. Just acknowledgement that Lisp has few real (other than largely historical) achievements.
&gt; (Too bad Lisp doesn't have anything as good as that.) Wow. Today I learned that Lisp doesn't have regular expressions. I must have just imagined that I was using them. Thanks emporsteigend. I am now convinced that I should stop using Lisp and start using Perl. Hey everyone, look at emporsteigend. He's *using science* to prove that our choice of programming language is wrong.
&gt;If a language were elite, wouldn't it need less third-party code? Unless it's piss-easy to code anything not specified in the Byzantine 1,000+ page long specification (apparently not, if we look at common-lisp.net projects), no. &gt;But seriously, your argument is that Lisp isn't popular? No. OCaml isn't very popular either. It's also a lot better.
He doesn't have an argument. He's trolling. Seriously, how is this not obvious?
Downvoted for telling you I'd give you an answer soon. Classy.
According to the package page, it's incomplete.
I don't vote on comments.
You realize that you're talking about a language that was standardized in 1994, right? It's been almost 20 years since the core of the language froze in time. That is not a bad thing. The language can change itself, and thus evolve, but at the same time libraries such as Dr. Wietze's excellent cl-ppcre benefit from a stable, unchanging base. There is no "standard library", nor need there be. How much documentation do you really need for something with "Perl compatible" in its name?
Anecdotal evidence.
SBCL does not have an ARM port. There was some work started - http://www.lisphacker.com/projects/sbcl-arm/port-log.txt, but nothing concrete. ECL and CLisp work on ARM. For ECL you will need to have gcc running natively, which isn't going to be great on an ARM-11 device.
I see that you're sticking to your initial claim of: &gt; I would prefer a more scientific, even quantitative approach.
I don't really want to adopt some abandonware right now.
Do you have some kind of a twisted orangered paraphilia? What is motivating you to continue this "argument"? I'll have you know that your nonsense has given me a good laugh. If that was your intended reaction, troll, then congratulations. Ha!
&gt;and nobody else is going to see these posts Quite a few have already seen them, as measured by downvoting.
Have a look at Ron Garret's study, titled [“Lisp as an Alternative to Java.”](http://www.flownet.com/gat/papers/lisp-java.pdf) &gt; Our results show that Lisp’s performance is comparable to or better than C++ in execution speed; it also has significantly lower variability, which translates into reduced project risk. Furthermore, development time is significantly lower and less variable than either C++ or Java. Memory consump- tion is comparable to Java. Lisp thus presents a viable alternative to Java for dynamic applications where performance is important.
Java and C++ are both terrible, admittedly. That doesn't make Lisp #1.
* ''' for string delimiters? * there is a nested hashtable, why not write it as such? * lots of FORs, the poor man's LOOP * then you need to print it, data is not self-printing? * lots of assignments, the code is imperative. Looks like BASIC. If that's your example for a good programming style, then you should stay away from any functional/object-oriented/logic/... programming language as far as possible. Lisp is on the opposite end from your style. Stay with BASIC or Python.
Thanks for the thoughtful reply. 
Also: insults aren't *argumenta ad hominem*. Get it straight. &gt;See lispm's response in code, which does what yours does. And is far less readable.
And your quantitative metric for this is?
Congratulations. You've managed to achieve write-only code.
Stay away from Lisp and Functional Programming. Use Python.
Since you don't know much about Functional Programming, OCaml or Common Lisp, your opinion is worthless. Your knowledge of Python also seems not to be that good, otherwise you wouldn't claim that Python is 'functional/object-oriented'. http://python-history.blogspot.com/2009/04/origins-of-pythons-functional-features.html &gt; I have never considered Python to be heavily influenced by functional languages, no matter what people say or think. Said Guido van Rossum.
It is much easier to understand, since it follows a simple data flow model using a mapping operator. No side effects. It's only difficult to understand, if you haven't been using Functional Programming. Your code is based on nested FOR loops, loops to enter into hash tables, assignments in FOR loops, ... Your code is also especially **dumb**, since it iterates over the contents of a hash table (a dictionary in Python) - which shows that you even don't understand the purpose of a dictionary. The first 4 characters are already the key into the dictionary. No need to get the dictionary items and use a FOR loop with an IF over them. In my Lisp code the *assoc* function does that look-up using a list-based dictionary. Looks more like *zurückgeblieben*, not so much *emporsteigend*. Even the use of the hash-table is much easier in Common Lisp: (defparameter *example-text* "SVCLFOWLER 10101MS0120050313......................... SVCLHOHPE 10201DX0320050315........................ SVCLTWO X10301MRP220050329.............................. USGE10301TWO X50214..7050329") (defparameter *mappings* '#3{("svcl" ((name 4 19) (id 19 24) (call-type-code 24 28) (date-of-call 28 36))) ("usge" ((id 4 9) (name 9 23) (cycle 30 31) (read-date 31 36)))}) (defun parse-log-lines-example (text mappings) (mapcar (lambda (line &amp;aux (name (subseq line 0 4))) (cons name (mapcar (lambda (fields) (list (car fields) (subseq line (cadr fields) (caddr fields)))) (gethash name mappings)))) (split-sequence '(#\newline) text))) CL-USER &gt; (pprint (parse-log-lines-example *example-text* *mappings*)) (("SVCL" (NAME "FOWLER ") (ID "10101") (CALL-TYPE-CODE "MS01") (DATE-OF-CALL "20050313")) ("SVCL" (NAME "HOHPE ") (ID "10201") (CALL-TYPE-CODE "DX03") (DATE-OF-CALL "20050315")) ("SVCL" (NAME "TWO X") (ID "10301") (CALL-TYPE-CODE "MRP2") (DATE-OF-CALL "20050329")) ("USGE" (ID "10301") (NAME "TWO X") (CYCLE "7") (READ-DATE "05032"))) 
&gt;&gt; I'm glad that after several hours &gt; Uh no. That you ever suggested it as a solution was idiotic. &gt; The reason that I want to create an entire class/metaclass system just for this is...? You entirely skipped solving the stated problem. Excellent work. I'm convinced that Python is the right tool for the job. I mean, just look at the re module documentation. How could I argue with that? You really went out of your way to walk the walk on this one.
Your argument hasn't been attacked with insults has it?
&gt;That you ever suggested it as a solution was idiotic. Eh. &gt;You entirely skipped solving the stated problem. Which was?
&gt;Said Guido van Rossum. He can say what he wants: list comps and the functools library are still standard.
I'll wait while you actually read the text I posted.
&gt;It's only difficult to understand, if you haven't been using Functional Programming. Or don't like throwbacks to 50s computer architecture like "caddr". &gt;Your code is based on nested FOR loops, loops to enter into hash tables, assignments in FOR loops, ... Which is problematic because? &gt;Your code is also especially dumb, since it iterates over the contents of a hash table (a dictionary in Python) .keys(), .values(), .items() are made explicitly for this purpose, you retard.
&gt; I'm not concerned with looking as 31337 (and dense) as possible. The very metric you proposed in your initial post was: &gt; Incidentally, these measure the length of code in gzip bytes, which seems like a more fundamental consideration than LOC.
Well, that too. I was talking about the Wikipedia snippet that I posted. I can tell from the lack of depth of your knowledge in every topic we've covered (Python, OCaml, basic algorithms, Common Lisp) that you find *lots* of things to be "stupid". Good luck.
 # If only we could take line[0:3].upper() and reach directly into mappings.. SVC and USGE aren't of equal length. **DERP** &gt;entry-level computer science How is being clear "entry-level"?
THE KEYS ARE NOT OF EQUAL LENGTH, RETARD.
It doesn't betray "lack of basic algorithms" to fail to use line[0:3] when "SVC" is only three characters long but "USGE" is four. Did you ride the short bus to school?
I wrote a program shorter than yours as measured by gzip. U JELLY?
Nope, still longer (as measured by information entropy) than mine.
Sounds like U ASSMAD.
More like excessively inefficient and excessively lacking a solution to the problem statement. Incorrectly identfying regular expressions as being within a hundred miles of necessary for this problem, incorrectly looping over a dictionary as well as not introducing a true solution makes this "entry-level".
Yep, he mad.
&gt;I prefer nicely structured code over dumb code like yours any day. Mine was perfectly well structured. And shorter too.
Oh, nice try. Just admit to your mistake and move on. Alternatively, go back to school and come back when you're ready to walk the walk. You can't really use the optimization argument because the version using direct look up is shorter and more clear. I linked to the statement at the top level. You clearly didn't get too far in reading it. I suppose the same happened on your introduction to hash tables.
It wasn't. It was using the wrong constructs all over the place.
&gt;USING THE HASH-TABLE WITH THE KEY LOOKUP IS THE EASIEST AND MOST DIRECT THING. Only if the keys are all of equal length. I didn't make that assumption, and my code was ***still*** shorter than years. Suck on it!
Fixed it bro: greml1n_is_a_dolt = '''SVCLFOWLER 10101MS0120050313......................... SVCLHOHPE 10201DX0320050315........................ SVCLTWO x10301MRP220050329.............................. USGE10301TWO x50214..7050329''' mappings = {} mappings['svcl'] = { 'name': (4, 19), 'id': (19, 24), 'call type code': (24, 28), 'date of call': (28, 36) } mappings['usge'] = { 'id': (4, 9), 'name': (9, 23), 'cycle': (30, 31), 'read date': (31, 36) } fields = [] for line in greml1n_is_a_dolt.split('\n'): field = {} field['type'] = line[:4] for k, v in mappings[line[:4]] start, end = v field[k] = line[start:end] fields.append(field) for field in fields: print field Now it's even smaller. U MAD?
What flags did you use for compression, Rainer? That's not what I got.
I did that and got 472 for Lisp. Did you compress the entire code?
Sure. We can get that even shorter, since Lisp is not line oriented. (LET ((TEXT "SVCLFOWLER 10101MS0120050313......................... SVCLHOHPE 10201DX0320050315........................ SVCLTWO X10301MRP220050329.............................. USGE10301TWO X50214..7050329") (MAPPINGS (QUOTE ((SVCL (NAME 4 19) (ID 19 24) (CALL-TYPE-CODE 24 28) (DATE-OF-CALL 28 36)) (USGE (ID 4 9) (NAME 9 23) (CYCLE 30 31) (READ-DATE 31 36)))))) (MAPCAR (LAMBDA (LINE &amp;AUX (NAME (SUBSEQ LINE 0 4))) (CONS NAME (MAPCAR (LAMBDA (FIELDS) (LIST (CAR FIELDS) (SUBSEQ LINE (CADR FIELDS) (CADDR FIELDS)))) (CDR (ASSOC NAME MAPPINGS :TEST (FUNCTION STRING=)))))) (SPLIT-SEQUENCE (QUOTE (#\Newline)) TEXT))) -rw-r--r-- 1 lispm wheel 352 12 Mär 05:03 c2.text.gz 
That is unreadable.
You might call that "pretty-printing" but it's only "pretty" by Lisp standards. (Fingernail clippings in a bowl of oatmeal + ALL CAPS SHOUTING.)
I won. Actually if I would make the layout a bit better, I would use GRIND on the Lisp Machine, that's the code autoformatter.
Can't even see what the original is.
You getting mad for being called out earlier on your noob code, bro? &gt; It could have something to do with the fact that I never really gave a shit about your toy example No, it was a practical example where no libraries were needed so you could actually compare code. Of course your infantile mind comes back with a very specific Python library that for a challenge where your code involves making use of something where someone else did all of the heavy lifting. **HAHAHAHAHAHA**. That's pretty *real* code, bro. Where's the OCaml PSO? I guess OCaml sucks too! &gt; because Lisp is 13370000000x better than anything else. You're the only one who I have seen make a claim anything like this. I've repeatedly said that I use both Python and Lisp in the "real world." Implement the equivalent of this one in Python: (read-from-string "(defconstant *emporsteigend-iq* (- 200 150))") When you're done, implement this one: (defmacro aif (test-form then-form &amp;optional else-form) `(let ((it ,test-form)) (if it ,then-form ,else-form))) It's short and practical in just about any program. Lastly, implement: mp:process-kill some-thread Hint: Thread.stop is not an acceptable kill-thread It should be easy with all of your libraries.
I played with it a while back, but I experienced problems with it, where my pipe would be disconnected. That could just be my own systems. Vim fan that I am, it also did not compare to what slime does, including (1) letting you know what parameters are next in a user-declared function as you are typing it and (2) single-stepping through Lisp code. I am hopeful that future updates (or even the current version) can do these things.
No tail cail optimization, no pattern matching, even partial function application has to be imported, reduce was removed from builtins in 3.0, and map/filter were planned too. Python is not a functional programming language, only few of its features were inspired such as list comprehensions and generators. Compare with Haskell, Lisp, Ocaml, F# or Scala.
&gt;Ocaml I am aware of OCaml, having recently gotten Batteries up and running for myself, etc. Point is Python has some modicum of functional features.
Ah, I begin to see why they consider you a troll. &gt; No, six. Heheh. :) Now I know you are messing around. &gt; Really? Go on common-lisp.net and try proving your hypothesis. Go to cliki.net, and try to prove yours first. In my entire experience with Lisp, I never used that older site. Even the ASDF system uses cliki.net. Oh, I knew about it, but I could not understand why anyone would want to use it when the same packages and much more are available at cliki.net. &gt; Macros are a shitty form of encapsulation. This statement makes a lot of interesting assumptions. Macros are intended to be a form of encapsulation? Encapsulation is desirable in every language construct? Encapsulation is statistically linked to some form of success? Tools can be misused in any fool's hand. Macros, when used to abstract (not their only use), can make code much easier to read or much harder to read. We can as easily cry about C pointers and Java's leaky garbage collection. &gt; I'm aware of that, because I have this: Knowing names and knowing features/functions = two different things. You would not have made the ignorant statement about Java if you understood MOP. MOP is not only used in Lisp; it would help your knowledge a lot to research it. Do you have this book? -- http://www.amazon.com/The-Metaobject-Protocol-Gregor-Kiczales/dp/0262610744 &gt; What a ~~bloated~~ elegant language. Show me your objective measures of "bloated" and "elegant". Walk the walk. Measuring number of pages is as useless as measuring lines of code. Edit: Ah, ninja-editing. I must have struck a chord. &gt; Great, that's really useful to me. I could say that about any random library I see anywhere. I tend to start with a problem and then work to solve it, grabbing what libraries are useful for it. I have noticed that rarely does armchair theorizing actually help me (or others) understand anything. In truth, there are a great many useful packages in the Lisp ecosystem. Here is a nice list of them: http://www.cliki.net/Current%20recommended%20libraries And better yet, you may want to consider installing QuickLisp and seeing what packages it supports. Inactive and outdated things are actively removed from its list. 
&gt;Macros are intended to be a form of encapsulation? Essentially, yes. &gt;Knowing names and knowing features/functions = two different things. You would not have made the ignorant statement about Java if you understood MOP. My point that was Java is verbose as hell and that Lisp doesn't do much better in that regard. I was not defending Java, rather, mocking it. &gt;Show me your objective measures of "bloated" and "elegant". I would consider elegance to be the ratio of constructs that something can implement easily to the size of its syntax. Smalltalk, for example, is very elegant in this regard. Lisp is not. Just look at the godawful LOOP macro. &gt;I could say that about any random library I see anywhere. I tend to start with a problem and then work to solve it, grabbing what libraries are useful for it. I have noticed that rarely does armchair theorizing actually help me (or others) understand anything. Here's an example of not armchair theorizing: I want to solve large OR problems with metaheuristics. I notice that all the Lisp libraries that would be suitable for my purposes are incomplete abandonware. I use Python instead. Most people do something similar in that situation. &gt;http://www.cliki.net/Current%20recommended%20libraries So a bunch of stuff that's mostly in the Python standard library? Really?
&gt; Essentially, yes. I didn't see that in the CLHS. News to me. &gt; I would consider elegance to be the ratio of constructs that &gt; something can implement easily to the size of its syntax. That had what to do with number of pages? &gt; Just look at the godawful LOOP macro. What's wrong with it? It looks to me like a DSL for looping. Some people claim that the [ITERATE](http://www.cliki.net/ITERATE) package feels better for complex loops, but I have never justified installing the extra dependency. Granted, it is nice that people can easily extend Lisp to have constructs that they prefer. &gt; I want to solve large OR problems with metaheuristics. I notice that all &gt; the Lisp libraries that would suitable for my purposes are incomplete &gt; abandonware. I use Python instead. How does cl-smogames help you with that? Are you pulling my leg? Have you tried asking around about available packages? It isn't my interest, so I cannot help you, personally. &gt; So a bunch of stuff that's mostly in the Python standard library? Really? Ha! We must not be looking at the same list. ;) And it is a completely separate debate as to what should be part of a core language and up to the community to provide. This response and others in these threads give me the impression that you have a python axe to grind. That really is not useful here. Besides, I want nothing to do with a language whose creator turns an intentional blind eye towards tail recursion and whose only takeaway from [SICP](http://www.amazon.com/Structure-Interpretation-Computer-Programs-Edition/dp/0070004846) was that it was a book that advertised Lisp. ;)
Using PSO to solve the knapsack problem is novel, interesting or impressive in this context? Maybe in a sophomore class. Non-arguments and nonsensical arguments. I'll wait for your implementations.
&gt;I figured. They require thought. They're toy problems.
&gt;Then they should be trivial to implement. Which is why I don't care to implement them to begin with. I prefer to solve useful problems which is why I don't use Lisp.
That's a pretty unreasonable abductive inference, bro, considering I can solve *real* problems just fine. I'm just not interested in the problem domains of Lisp programmers i.e. toy problems. See also: http://en.wikipedia.org/wiki/Shakey_the_robot Lisp's formalist AI background has apparently permanently steeped it in uninteresting toy problems.
Non-argument. I refuse to learn about this, therefore it is useless. What an impressive debate technique. Enjoy looping over hash tables.
&gt;Non-argument. The burden of proof was never on me to begin with. &gt;Enjoy looping over hash tables. My programs run fast enough for me, so I guess I will. And get real work done.
&gt;Solving toy knapsack problems. Bzzt. See here, buddy: http://miplib.zib.de/ And keep trying to shift focus away from Lisp's total lack of recent achievements, it's totally working.
I see that work has a non-existent user group. It must be useless. I also like how you link to something that has had one update in 9 years. Abandonware, by your own criteria.
&gt;I've seen Lisp (as well as C, C++, Java, OCaml and C#) in automated trading systems. I cannot say the same for Python, aside from toy retail (read: hobby) solutions. Maybe not: http://scholar.google.com/scholar?q=python+automated+trading But then I can't really comment because I consider finance as a field to be largely pseudoscientific. U MAD?
&gt; So tackling substantial integer programming problems is useless? You not are the good at the reading the comments the very the good are you? By your own statements, a small user group leads to the conclusion that something is a toy, or useless, problem. Thus, your link is to a useless library. I bet more people use Lisp than that. Therefore, it is less useful than Lisp. Have I written my sentences out explicitly enough for you? &gt; Which was what? Got reading comprehension? The only link in your post. &gt; MIPLIB 2010 &gt; Again, more than 7 years have past since the last update of the MIPLIB Cutting edge shit, bro.
News: &gt;Mar 2012 - First feasible solution found for ns1663818, infeasibility of lrsa120 proven. I don't know. Looks like they're keeping things up to date.
&gt;&gt; What's wrong with it? &gt; "Creeping featuritis". The standard was settled over two decades ago. Again, it is a separate debate of what should be core, what is in "standard libraries we always install", and what should be in "community libraries". I am unaware of any objective analysis on the right answer for that. I can say that commercial versions of Lisp have clean standard libraries, but I cannot judge how much that would help my productivity. I tend to like batteries-included except where it causes undue increases in memory and image sizes. &gt;&gt; Have you tried asking around about available packages? &gt; Google should have turned up what I needed. Hubris and a falsehood, at that. Not all knowledge is easily accessible by google, much less by the Internet at large; and sometimes it takes asking the right question. What interests me is that when google and an older site do not give you the answers you want, your reaction is to blame the community and make claims about the language, as opposed to asking for help. Interesting...and wasteful for the both of us. &gt; Recursion and in particular tail recursion are probably a teensy bit overrated. Is your favorite language expressive enough to add this feature that it does not have and others find useful? We come back to the Lisp Advantage. &gt; SICP is widely considered to be a terrible book. That is blatantly false, given that it is always recommended by multiple communities in a top 10 list of reading material for computer science people, a list that also includes such gems as the Dragon book and Knuth's algorithms. 
&gt;The standard was settled over two decades ago. Yeah, looks like the creeping featuritis took place before that. &gt;Hubris and a falsehood, at that. Not all knowledge is easily accessible by google, much less by the Internet at large; and sometimes it takes asking the right question. Lispers usually don't like being asked questions. &gt;That is blatantly false, given that it is always recommended by multiple communities in a top 10 list of reading material for computer science people Many Amazon reviewers disagree and can tell you why they disagree. Popularity doesn't settle the issue, as shitburgers like Gödel Escher Bach are highly recommended by intelligent people as well.
&gt;Then they should really update their front page and documentation. That news is from their front page, you retard.
But it should be the top announcement, not something about a release 2 years ago. That is elementary presentation. I mean, just look at the [re](http://docs.python.org/library/re.html) module!
&gt;But it should be the top announcement, not something about a release 2 years ago. MIPLIB 2010 is the latest major release. Incidentally, I don't see the point in comparing a large set of problems, many still unsolved, to buggy, incomplete abandonware. The files themselves are correctly formatted and everything, so it's not like we can call them bug-ridden.
I thought we were just ignoring each other and shouting about inane points that bother us but don't actually contribute to a meaningful exchange of ideas? At least, I've been following your example after you refused to acknowledge things Lisp could do that Python could not (when I was ready to concede the opposite - a point which I realized long ago while using both for *real* work). And you shouldn't be so harsh on finance. Without a former employer of mine backing it up, OCaml would be sorely supported.
&gt;At least, I've been following your example after you refused to acknowledge things Lisp could do that Python could not The only practical limitation AFAIC is performance. I could give two shits about being able to implement a DSL with ugly macros.
Just compare: * The Zen mystique in the **C** community. * The Zen mystique in the **C++** community. * The Zen mystique in the **C#** community. * The Zen mystique in the **Perl** community. * The Zen mystique in the **Java** community. * The Zen mystique in the **Python** community. * The Zen mystique in the **Ruby** community. * The Zen mystique in the **JavaScript** community. * The Zen mystique in the **Haskell** community. * The Zen mystique in the **Lisp** community. Got it?
You just compared Python to Lisp in your performance remark. Are we talking about Python or OCaml, now? Lisp still appears to win, CPU-wise in that chart, not that I'd consider that any victory. I use F# as well (actually on a predominantly Lisp project). It is slick. However, it's syntax modification is very limited. What about all the other features I listed?
The [try it out](http://philosurfical.open.ac.uk/try.html) page says "Just click on the image to start an instance", but the only image is the "Christmas Bonus" version, which is something different.
Holy cow, you're monitizing language wars! Waitwait, I have another one: emacs versus vi. And throw in TextMate, because Apple users have money and are willing to spend it, and because it'd really rile up the emacs/vi users. $1 a vote. We're gonna be rich!
* localtime is a decent datetime manager. * I'd recommend CFFI for your C code, just because debugged code &gt; non-debugged code.... but if it's small and not sophisticated, I'd rewrite.
Common Lisp can seek to file locations ([file-position](http://l1sp.org/cl/file-position)) and lots of bit-fiddling functions (e.g. [logand](http://l1sp.org/cl/logand]) and [write-byte](http://l1sp.org/cl/write-byte) and [write-sequence](http://l1sp.org/cl/write-sequence) are used to write binary data. What kind of stuff does the C library do over &amp; above the normal libc or unix API stuff?
Writing structs out to disk is a pretty fragile way to store data.
Decide what you want the declaration to look like, then write a macro to produce it. Since you can do anything, you should have a clear idea what you want. You probably don't want to have a slot for each of these values though, and making classes for weapons will probably bite you particularly soon. Playing with this data will be a big part of your effort, so you want it to be as painless as possible. Better to make every weapon an instance of the same class, or perhaps even every item. You could reasonably make ranged weapons and melee weapons different types, but you'd lose the opportunity as a designer to make hybrid weapons usable for ranged or melee combat. Storing this information in a spreadsheet then exporting it to your game would be a very reasonable choice.
&gt;Lisp still appears to win, CPU-wise in that chart At the expense of more memory. Thrashing is a lot worse than just being slow.
Thanks for the tips. In particular, I hadn't thought of making hybrid weapons. Are there any libraries out there for handling CSV's or other delimited data?
It [looks like](http://www.quicklisp.org/beta/releases.html) there's at least one CSV library in Quicklisp.
I came up with the following in case I decide to ignore paul-donnelly's advice: (defmacro defattrclass (attr-name &amp;body class-options) `(defclass ,(symb attr-name '-attr) () ((,attr-name ,@class-options)))) (defmacro defattrclasses (attr-names &amp;body class-options) `(loop for attr-name in ',attr-names do (eval (append (list 'defattrclass attr-name) '(,@class-options))))) (defmacro defattrclasses (attr-names &amp;body class-options) `(progn ,@(loop for attr-name in attr-names collect `(defattrclass ,attr-name ,@class-options))))
When reading academic programming language theory papers, you see a lot of inductive proofs using judgements and derivations. I think the tool of choice for working like that is a theorem prover like Twelf or Coq. So I see a nice career path for young Lisp-fans: study language theory in school, write some type-system proofs, then go on to make a living designing more secure protocols--and thereby protect basic human freedoms. Edit: An aside: Lisp systems are notorious for doing Turing-complete computation in parsing stages so maybe don't carry that habit into security-conscious designs! :)
Surely you would enjoy a CLOS store library made by Mr. Weitz. (hints from the last question of the interview + the comment by J. Hickner)
I have been experimenting with an alternative to using macros to define repetitive things. My rationale is that I do not intend to use the macros more than once, so why not just immediately eval? (dolist (damage-type '(slice blunt pierce)) (eval `(defun ,(intern (string-upcase (format nil "~a-damage-dealt" damage-type))) (attacker) (format nil "~a did damage of type ~a~%" attacker ',damage-type)))) Is this approach a bad idea? Note that I needed the string-upcase to indicate to intern that this was not a |case-sensitive-symbol|.
You've still **avoided** all my previous statements. Another non-argument. Me: "X is greater than Y." You: "Y is more important than X in all domains." How intellectual of you. Are you a retarded "scientist"? Do you even program? I'm not convinced you've written done more than the most trivial of exercises in the domain.
regarding string-upcase, the following (from paul graham's On Lisp) are useful: (defun mkstr (&amp;rest args) (with-output-to-string (s) (dolist (a args) (princ a s)))) (defun symb (&amp;rest args) (values (intern (apply #'mkstr args)))) ;; I made this one for the times when I use a downcased string (defun symb-up (&amp;rest args) (values (intern (string-upcase (apply #'mkstr args))))) As for eval, I can't say one way or the other as I'm pretty new to lisp. I know in most languages people try to avoid eval.
&gt; Automatic trading isn't real work unless financial theory has much predictive success. It doesn't. Stop commenting on domains that you clearly don't understand. Your idiocy is showing. &gt; If it meets certain demarcation criteria, then yeah, it is. What criteria?
I would macro-up. I hate repetitive code. In my own code, I have a macro over defclass that acts fairly similar to defstruct, but allows inheritance. I actually wrote it before I knew about defstruct, but I wound up building something almost identical. 
Yes, but how do you measure the performance of text editors / IDEs? And yeah, I keep all the money! Just kidding, I keep 10% and the rest is the prize for first place, doled out yearly.
You need to use a back-quoted form in order to delay the evaluation of the DEFCLASS form, allowing the NAME&lt;NUM&gt; symbols to be evaluated first. (defmacro generate-classes (&amp;rest names) `(progn ,@(loop for name in names collect `(defclass ,name () ())))) (generate-classes foo bar baz) (make-instance 'foo) =&gt; #&lt;STANDARD-CLASS FOO&gt; ...
Doesn't this leave me in the same predicament though? For generate classes, I still need to specify the symbols explicitly. Would it be possible to do the following? (setq classnames '(foo bar baz)) (generate-classes classnames)
I have a feeling you want to use arrays. If you find yourself creating complex data-structures at runtime, there is a good chance you're hammering a square peg into a round-hole. Remember, arrays can have any object for a value. 
Use a function instead of a macro then. (defun make-class (name) (eval `(defclass ,name () ()))) (defvar names '(foo bar baz)) (mapcar #'make-class names)
This is good advice. If you need to define data structures at run time, you'd probably be better served by using sort of collection like a vector. If you really want to define classes at run time, there's good library for that: [dynamic-classes](http://common-lisp.net/project/dynamic-classes/) . If this an intellectual exercise, then I'm curious for more details on what the functionality you're looking for is. I'm still a newbie in Lisp, so this is an interesting question for me.
 ;;;; Damage is a vector space. Makes you wonder what norm to use. (defstruct (damage (:type list)) (slice 0) (blunt 0) (pierce 0) (explosive 0) (magical 0) (psychological 0)) (defun total-damage (d) ; Manhattan distance. (reduce #'+ d)) (defun add-damage (x y) (mapcar #'+ x y)) (defun multiply-damage (s d) (mapcar (lambda (x) (* s x)) d)) (defun add-damages (&amp;rest damages) (reduce #'add-damage damages :initial-value (make-damage))) (defun random* (n) (if (&gt; n 0) (random n) 0)) (defclass weapon () ()) (defclass simple-weapon () ((base-damage :initarg :base-damage :reader base-damage-of :initform (make-damage)) (random-damage :initarg :random-damage :reader random-damage-of :initform (make-damage)))) (defgeneric attack-damage (weapon attacker victim) (:documentation "Compute damage for an attack.")) (defmethod attack-damage ((weapon simple-weapon) attacker target) (add-damages (base-damage-of weapon) (mapcar #'random* (random-damage-of weapon)))) ;;;; Some fun: (defclass animal () ()) (defclass human (animal) ()) (defclass orc (animal) ()) (defclass sword (simple-weapon) () (:default-initargs :random-damage (make-damage :slice 6))) (defclass orcslayer (sword) ()) (defmethod attack-damage :around ((weapon orcslayer) attacker (target orc)) (multiply-damage 2 (call-next-method))) (defclass pirate (human) ()) (defmethod attack-damage :around (weapon (attacker pirate) (target human)) (print "You fight like a dairy farmer.") (add-damages (make-damage :psychological 1) (call-next-method))) ;;; Please, think of the half-orcs! (defgeneric humanity (thing) (:method ((a human)) 1.0) #+BLADERUNNER (:method ((a replicant)) 1.1) (:method (anything-else) 0.0)) (defgeneric orcocity (thing) (:method ((an orc)) 1.0) (:method (anything-else) 0.0)) (defclass half-orc (human orc) ()) ; Oh, fine. (defmethod humanity ((a half-orc)) 0.5) (defmethod orcocity ((a half-orc)) 0.5) (defclass rational-orcslayer (sword) ()) (defmethod attack-damage :around ((weapon rational-orcslayer) attacker target) (multiply-damage (1+ (orcocity target)) (call-next-method))) 
 (defmethod attack-damage :around (weapon (attacker pirate) (target pirate)) (let ((d (call-next-method))) (unless (zerop (shiftf (damage-psychological d) 0)) (print "How appropriate. You fight like a cow.")) d)) I promise I'll stop now.
Thanks, that's helpful. I was trying to find documentation on how to "dig deeper" into classes without success. This is useful though. Would you happen to know if it's possible to modify the slots of a class by using the slot object?
Thanks. I was trying to avoid eval but it seems like it might be necessary.
I agree. The code is about 14 years old. The structs haven't changed much over those years, which makes it a little better. We've had a few problems with newer versions reading files produced with older versions, but it hasn't been too bad. The code isn't trivial, so no one has been brave enough to clean it up.
Thanks, I'll try and figure that out. I've been doing ruby for a long time so I'm trying to handle things the way I most likely would in ruby, so it's interesting seeing where that does and doesn't work.
[Warp Speed Introduction to CLOS](http://eval.apply.googlepages.com/guide.html) - ftfy
Possibly, but it's probably not simple. CLOS guarantees that something similar to what you request can happen behind the scenes. Evaluating two different (defclass foo ...) forms guarantees that any objects instantiated under the first definition get updated to the second definition at least on first access.
See: http://xach.livejournal.com/112151.html for a pointer to Joe Marshall's new site. The guide is on a download link at the following url. http://sites.google.com/site/evalapply/guide.html?attredirects=0 
From Peter Seibel's _Practical Common Lisp_: http://www.gigamonkeys.com/book/object-reorientation-generic-functions.html http://www.gigamonkeys.com/book/object-reorientation-classes.html The warp speed guide mentions Sonya Keene's book. I've been using it and I wouldn't recommend paying for it unless you're new to OOP, as it spends a lot of time explaining that instead of getting into the details of CLOS.
http://www.dreamsongs.com/Files/clos-overview.pdf http://www.dreamsongs.com/Files/ECOOP.pdf http://www.dreamsongs.com/Files/clos-cacm.pdf http://www.dreamsongs.com/Files/clos-book.pdf 
Personally I find that the most difficult thing of CLOS is learning to think appropriately. We've been conditioned by the class-centered approach of Java, and the greatest part of OO literature seems to assume it. CLOS instead seems to favour a design approach that starts from generic functions. That feels a bit alien. Reading Keene and Seibel helps, but still...
It's possible to do it with help of EVAL or ensure-class MOP stuff, but if you need something like that, chances are that you haven't thought out the problem. Where class names come from? File? In this case you can as well use macro or read-time evaluation to paste class names. From REPL? Then instead of symbols put into a variable you could use macro directly from REPL. Network? Well, then it's a valid use, but do you really have an application where classes are defined by somebody over network? This is why things like EVAL are frowned upon: they are needed only in rare, complex cases, and people who actually need them won't ask newbie questions. So if newbie asks about EVAL, chance are that he misunderstood something. In case you need a flexible data structure which doesn't even need to be defined use lists (plist, alist) or hash tables, or maybe vectors. E.g.: (defun make-frob (a b c) (list :a a :b b :c c)) (defun use-frob (frob) (destructuring-bind (&amp;key a b c) frob (format t "a: ~a, b: ~a, c: ~a~%" a b c)) (setf (getf frob :a) 5) (print (getf frob :a))) (use-frob (make-frob 1 2 3)) Lists can be easily written to file, sent over network and so on, without a need to define list structure or its type. Another possibility is to use struct of type list. It would be just a list under the hood, but defstruct will create all nice accessors so you don't have to resort to getf and destructuring-bind. Also you can print/save/send it as a plain list, and you don't need structure to be defined to use it.
Well, there's a bug in the SBCL bug repository. https://bugs.launchpad.net/sbcl/+bug/936304 Sadly, it doesn't get much attention - but probably it has the simple workaround of enlarging the default dynamic space size (besides the obvious one of manually calling gc from time to time).
Yeah, It's sadly to see: **Heap exhausted, game over.**
Seems like a great resource to get up and running with CLOS, but he says "The more complex parts of CLOS can be safely ignored", and those are precisely the parts I'm curious about!
Interesting papers. I'll be sure to read them. Thanks!
WTF SBCL people. I'm so close to getting my boss to use CL for a big project, and this sort of bug exists in the most popular open source distribution!?!??! Do you really think this is okay behavior? I can't recommend SBCL now in good faith. I just don't get it. This language is fucking awesome, and you publish shit like this? Who the fuck cares about speed if stability is ranked so lowly. This post has 7 up votes and 8 down votes for a serious problem with a mainstream up-to-date distribution. Are people actually trying to hide this issue? Or do you guys actually think that it doesn't matter?
&gt;Stop commenting on domains that you clearly don't understand. Benoît Mandelbrot might agree with me on this one. &gt;What criteria? Myself, I like Paul Thagard's view on demarcation: http://en.wikipedia.org/wiki/Paul_Thagard#Philosophy_of_science Have fun with your financial pseudoscience.
So you've been busy solving solved problems.
OCaml affords nothing close to the power of lisp "syntax mongling." This is boring.
&gt;Appeal to authority. In what sense?
&gt;OCaml affords nothing close to the power of lisp "syntax mongling." Can you make Lisp not ugly with its macro system?
Code "beauty". How scientific.
Your solutions are neither novel nor interesting. Not science.
You neither know which problems I've solved nor how I'm doing them.
You could probably operationalize it.
Appeal to authority.
You're really good at misapplying fallacies.
Yeah, I used Quicklisp to download and install Hunchentoot. Thanks for the link; I'll read it later tonight when I get home.
You consistently change your criteria for "that which is science". If inclusion in arxiv.org makes something science, I guess [Quantitative Finance](http://arxiv.org/list/q-fin/new) is science, too! Oops!
The consistent failure of financial modeling based on the assumption that fluctuations in stock prices are distributed according to a bell curve rather than power law distribution should be good enough. Also: http://www.skepdic.com/economicforecasting.html &gt;Does the fact that the scientific evidence shows that technical analysis is no better than chance in predicting the price of stocks mean that nobody ever makes any money buying and selling stocks following the advice of a technical analyst? Of course not. By chance alone many brokers are going to make recommendations that make money for their clients. The illusion is in thinking that technical analysis provides a magic formula that will continue to bring success forever and ever. No, in the long run, there will be some big winners and some big losers, but the average among most of the investors will be no better than what you would get if you let a monkey throw darts at a list of all the stocks listed on the New York Stock Exchange. Hahaha, fuggen rain dancing.
It's non-standard financial theory and if you actually look at any of those papers you'll notice that.
Oh, I get it. You assume that everyone in the market is making investments based upon technical analysis. How scientific of you! Oops, you're skipping the other 50% of investment theory. Fundamental analysis.
What can I say: congratulations on being a glorified RNG.
It does no better than guessing. You're welcome to review the peer-reviewed literature on the subject. You're a fucking rain dancer dude. Proud of yourself?
I'm well aware of arxiv, bro.
Another appeal to authority. You assume: 1) This is the bulk of research on the topic 2) a general survey over a group is representative of the individuals Also: &gt; In short, there's no scientific evidence that professionally managed funds, as a group, perform any better than a randomly selected group of stocks This is hardly evidence to back up your claims. I've read Malkiel, and you're twisting the findings.
&gt;I've read Malkiel, and you're twisting the findings. How so.
You could (and should) check out RESTAS, it's built upon Hunchentoot.
I haven't downvoted this comment, but I did seriously consider it. Do you honestly expect that in a volunteer-based project of this magnitude that there will never be bugs introduced or regressions made?
You're a faggoty roodypoo who has absolutely nothing to show for himself. Complain about my code or what problems I like attacking but I can actually show that I can do that shit. Unlike you.
http://restas.lisper.ru/en/overview.html could help in answering your questions, also routes are really nice.
The insecurities of yours that are bleeding into this add a unique and revealing twist to your otherwise routine level of insanity.
Quicklisp.
Have you seen this: http://clacklisp.org/ ?
ps does CL have anything as cool as functors?
If you are interested in using fastcgi, you can look at either one of the existing fastcgi implementations or at my code. It wraps libfcgi from fastcgi.com: https://github.com/Neronus/fastcgi It should work with any lisp supporting gray streams and cffi (pretty much every CL out there). You can use lighttpd as a server and lisp for the dynamic content. If you have questions, then feel free to drop a message here. I can also send an unfinished blogpost about how to use it to you :) The post is complete, but still rough around the edges regarding wording and other didactic stuff. EDIT: I forgot to mention that I practise dogfeeding. This library is running my blog.
awesome dude ... That Troll boggers wasted my time while searching Lexical Environment in Defstruct. I was afraid. Kill these trollers ....
FWIW, Xah Lee, at least on G+, has been a pretty cool guy when I've talked to him. I even joined his emacs hangout for a couple hours one time. 
Jon Harrop used to kill me, although he's been less active recently. Never actually posted anything of any use, just telling people how much better it would be in Microsoft / F# land. But the amount of time he must have put into his posts beggars belief.
SBCL is a higher power because it doesn't often have regressions like this, it produces fast code, it's very standards compliant, and it's free. All of those, in my opinion, should earn it some slack. "Shit like this" is a no-slack-whatsoever stance. 
I'm not on comp.lang.lisp, and I don't know any of these personas, but it's not very nice to single them out like this, whether deserved or not.
Xah has a lot of interesting things to say about emacs. On Common Lisp, less things.
For those who don't know it, there is a mailing list for actual **users of Common Lisp**. http://lists.common-lisp.net/mailman/listinfo/pro
R.I.P Erik Naggum
&gt; Back in the day there only one real troll on CLL. His name was Erik Naggum. At the time I used to think he was shockingly stupid and rude. -- Paul Graham
I still read Erik's posts with reverence, perhaps because I discovered them when they already were history, so I had no chance of getting personally incinerated by them. I don't know if he was a "troll" as Graham says. Certainly not in the current, depressingly serial meaning of the word. Whatever black art of eloquence Erik practiced, it had an extreme, abrasive beauty. Rudeness apart, he wrote very intelligent things.
Now with blog post: http://christian.ftwca.de:8080/post/common-lisp-and-fastcgi-yet-another-binding
It's an artefact of the copying garbage collection scheme. SBCL could artificially waste half the dynamic space you specify to make sure there's enough temporary space for major collections. Would that satisfy you? I don't see why you jump to the conclusion that stability isn't a highly-ranked objective. Have you considered that the issue might not have been fixed yet because there are usually simple workarounds, and the difficulty:prevalence ratio isn't that interesting? If the current GC is a serious issue for you or your business, there are people willing to take contracts to improve the GC.
Is it available on GMANE?
Practical Common Lisp, and Land Of Lisp are good beginners books (LOL is more humorous and whimsical). PCL is available for free online (check the sidebar). I really like ANSI Common Lisp by Paul Graham, but there is some controversy over his Lisp style.
I'd argue that he does belong on the list, not because he was a troll (he'd wind people up for sport, no question, but only if they'd given him cause, as he saw it), but because he could, at times, be a single-issue obsessive (or at least act like one). But I'd say he fits in there mostly for the same reason Tim is in there, and because (I imagine I'm not alone in thinking this) he was a vital and very visible part of the cll landscape. 
And finally, you say USENET is dead and 'antiquated'. Ok, let's see how it compares to a modern thing which is reddit. I'm on reddit for 5 years, I have 21k comment karma, 'charter member' badge (I was among first who paid for reddit gold) and verified email. I rarely post links, so I've got only 241 link karma so far. But when I post something it matters to me. Recently I've posted a link to article I just wrote (http://blo.udoidio.info/2012/03/impure-world-resurrection-implicit.html) to r/programming. I expected some lively discussion (that happened with my previous posts which happened ~4 years ago), but it was ignored. As it turns out, it got into spam filter for some reason (which I don't understand: I post rarely, have no ads on blog, and have all kind of signs that I'm a serious user), and there is nothing I could do. I tried messaging moderators, but they seem to ignore me. When I posted same thing to c.l.l (although it is barely lisp-related) I quickly got a reply. And, in general, when you use a web forum you're at mercy of admins who choose software and how/where it runs, moderators who decide on what is appropriate. If you don't like user interface or you want to filter out certain person there is nothing you can do. It is a huge step backward from USENET which is distributed, robust and where you can use your own client software. USENET is a bit harder to setup for pitiful morons who only know how to launch browser, but why is that relevant to programming discussions? Those people shouldn't be programming anything in the first place. And, crucially, USENET's format promotes in-depth, lengthy discussions (which you often see on c.l.l). On the other hand, on reddit it only makes to post comments in first 12 hours or so. After that only person you're replying to will see them, the rest have already moved on to different topics. This is discouraging. OTOH web forums which have length threads often have them in a flat format, so you end up with monolithic 100 pages of discussion. Who is going to read that?
Yes, gmane.lisp.cl-pro
&gt; Thats a lot of ifs. That's a lot of FUD. Installing newsreader is trivial, and often it is already installed (e.g. Outlook Express in Windows). So is finding public server (aioe.org). It takes at most five minutes to set up the thing. About as much time as registering on a forum. The rest is a bonus: you can switch to something else if you develop a taste for it, but you don't have to. You can't do that with a forum. &gt;&gt; Those people shouldn't be programming anything in the first place. &gt; Classy. You think that people who can't install software should be programming? Do you enjoy software which crashes? &gt; You put a lot of effort and wrote much text, but in the end you achieved just the opposite of what you intended, you inadvertedly proved the article title correct. On contrary: I demonstrated that a person can be an asshole on any forum/communication medium. I'm on reddit for 5 years, so I'm no more c.l.l'er than I'm a redditor. You'll find assholes everywhere. You can't escape. (BTW, I personally think that a phrase like "go fuck yourself" doesn't make one an asshole, but badmouthing c.l.l does. Why? "Go fuck yourself" is just an expression of emotions (or sometimes it just doesn't mean anything). It usually has no effect whatsoever. OTOH spreading FUD has real effects, usually negative. But that's like, my personal opinion.)
He certainly was a troll. He would throw insults out and see who reacted.
I didn't quite get the point, but I've seen a JavaScript object system implemented in Parenscript. Which works pretty much like CLOS on the surface: you define class with defpsclass, then define methods with defpsmethod. Then all this crap is assembled into a large JS file. It worked pretty well. Particularly, inheritance and multiple-inheritance wasn't PITA as it usually is with plain JS object systems. So I made a lot of mix-ins, and it generally felt as if I was programming CLOS.
Very cool, thank you :) I really don't know a thing about quicklisp and what it means to be "quicklisp installable", so I guess I'll have to find out.
Do you remember where you saw that?
&gt; Nothing in my university's library with 'lisp' in the title was published after about 1985 Mine neither! The only Lisp text we have is *LISPcraft* which documents Franz Lisp--an extinct dialect. Since you already have some programming background, I would highly recommend *Practical Common Lisp* as a starting point. It's free online and you'll learn not only the basics but how to build programs with a "real world" flavor in idiomatic Lisp. Paul Graham's *On Lisp* is also available free online (check the side bar of this subreddit) and is a good next step into more advanced techniques. I'm also a huge fan of *Paradigms of Artificial Intelligence Programming* which is less about AI programming than it is about learning intermediate-level Common Lisp by building some simple AI programs. You'll not only learn Lisp but how implement pattern matching, your own object system (in addition to learning about CLOS), efficiency concerns, a simple chat bot, knowledge representation, and computational algebra. It's a thick book worth studying, but it's not cheap and its idioms and methodologies are not as "modern" as *Practical Common Lisp* . In terms of Scheme, try Racket (which isn't necessarily Scheme anymore) which has amazing documentation, a beginners guide, a sizable collection of libraries, a nice development environment, easy to use web programming tools, and a very friendly mailing list. I still prefer Common Lisp though.
Yes. It was a part of a proprietary project, so source code is not available to public. There is a number of other OO extensions for Parenscript. For example, Parenscript project page mentions PSOS: https://github.com/gonzojive/paren-psos I don't have any experience with it, though. IIRC there were other projects too, try asking in Parenscript's mailing list. There is a chance that that part of a proprietary project will be released as open source. But first I need to check whether it makes sense, i.e. if it does something better than PSOS.
All of that seems to work, but when I do #4, then try to go to http://site.mine/yo, I get a "Content not found" error page.
If you've created an acceptor as above, it should be "http://127.0.0.1:4242/yo", not "http://site.mine/yo".
Sorry, I was just removing the actual URL of my site. Since I've got the domain name registered and set up (with the demo running, I can go to "http://site.mine:4242" and get the default page), I'm just using that instead of the IP.
Thanks!
I would recommend "[The Little Schemer](http://www.amazon.com/Little-Schemer-Daniel-P-Friedman/dp/0262560992)".
&gt; The major new feature in Allegro CL 9.0 is Symmetric MultiProcessing (SMP). This allows separate Lisp threads to run on separate hardware processors, potentially significantly reducing execution time on multiprocessor machines. Did Allergro CL really not support OS native threads before this?
I took a double-take on that too. I thought except for CLisp and CMUCL every other lisp had native threads.
It comes from AI circles.
And?
I mostly use Clozure and SBCL. Clozure has them across all supported platforms, SBCL has them fully supported on Linux and experimental on the other platforms.
Well, that's surely an oversimplification, because those "AI circles" had very good reasons for using Lisp over, say, Fortran. Even now that dynamically-typed, garbage-collected languages are a dime a dozen and Lisp isn't the only language that can do "symbolic processing", I would argue that Lisp's unique features still make it the most appropriate language for neat AI.
This is true. Lisp's power, particularly with respect to AI, is largely derived from its homoiconicity.
They've had [this detailed FAQ section about it](http://www.franz.com/support/faq/#s-mp) for a very long time. This bit was the issue, and provoked a bit of a flame-war with the SBCL developers, as I recall: &gt;Lastly, we often hear "SBCL has done it, so why can't you?" To quote the SBCL documentation: &gt;&gt; Large amounts of the SBCL library have not been inspected for thread-safety. Some of the obviously unsafe areas have large locks around them, so compilation and fasl loading, for example, cannot be parallelized. Work is ongoing in this area. &gt; What SBCL has done is #1 above with a little of #2. As of December 2007 they have big locks around the compiler, fasl loader, and foreign loader. They must single-thread those because they cannot otherwise ensure their use won't cause crashes or (even worse) less obvious failures. As we stated above, we do not believe this is a good strategy for Allegro CL. We will release an SMP Lisp when it works completely. Also, we believe that when they finish making their libraries thread-safe, they will find significant performance issues that need to be solved. That's obviously quite ancient (2007), but the quoted passage still appears in the [latest SBCL documentation](http://www.sbcl.org/manual/#Threading). (I'm really not looking to reignite this flame-war. I was just hoping the people in the know on this matter would update us on the status quo.)
Or the wrong time, as it turned out.
And so it was used often for AI projects.
I know some Lisp. I was being completely serious.
Is that compatible with the current version of Hunchentoot?
As others pointed out, it's firstly a historical association. McCarthy invented Lisp, and also the term AI. But I argue Lisp is a great language for any kind of difficult, exploratory development. Why would Lisp be a good language for AI? 1. The REPL provides a great environment for interactive debugging and exploratory programming. 2. Lisp provides a vast array of functions and data structures out of the box. 3. Functions as first class data items make it easy to create flexible and adaptable code. 4. Versus C/C++ you will write about 1 line of code per 3 lines of C/C++. So you can get stuff done faster. 5. You have GC so no time wasted keeping track of memory and no need to use "smart pointers" that almost work. 6. Strong (dynamic) data types and memory / bounds checking so it is really hard overwrite memory or cause other horrible bugs. 7. You can have as much static typing / bondage and discipline as you want, with structs, CLOS and "declare type". 8. You can make the code as fast as you need to with declarations, generally getting close to or better than C++ speeds. However you have the choice about this. It is it not worth the bother you do not have to optimize the code. Unlike, say, Ruby, you can optimize the code, and unlike, say, C++, you do not have to do all the declarations if you don't need to. 8. Macros in Lisp are powerful (you have access to the whole language) and easy to write, so you can create powerful DSLs at various levels and end up with something that is easy to follow and runs optimally fast. TL;DR: Fast robust development and fast robust runtime. Best of both worlds. 
I see, but reflect: if intelligence would be measurable by any means, it already wouldn't be Intelligence anymore (since anything measurable is limited to its measure). Got nearer now? 
You may as well ask for all discourse to be conducted in sexps. Yes, I know you'd love that. Freak. ;)
 ((Lisp doesn't just help - it has already solved the problem) (Lisp is not scared of code &amp; data commingling (it is designed into the syntax)) (it is a feature) (all data is assumed to be code) (unless it is specifically identified as 'data and not code))
That's one shitty article, author probable has no idea about what Lisp is, aside from that it has parentheses. Compare to one about C++: &gt; C=C+1 (IPA:/si 'eqwəls si pləs wan/) is an alleged programming language derived from C by programming language algebra. It is one of the most successful conspiracies hatched/practical jokes ever played on nerds who take ideas like OOP seriously. It was also a pioneer of the technique of catching people out by introducing new features every five years or so that are too hard for the compilers to get right first time, and that, even when they do get it right, are incompatible with the old language in surprising and unpredictable ways. It is humor, but it refers to things which indeed worry C++ programmers. (I.e. new features and compilers not implementing them right is actually a problem.)
I've read better lisp humor than this. The author doesn't even mention lisp is practically ancient and that 'no one actually uses it.' But whatever, it's not serious. 
Is it just one of those things, or is it some kind of cosmic synchronicity that I sold all my old film cameras right as this is being announced. Sorry Franz I'm not feelin the love over here. Talk to me when you have a licensing scheme that makes sense in 2012 instead of 1837. Talk to me when you can afford to hire a fricken tech writer to update your documentation that you haven't even looked at for at least 5 years. Talk to me when you figure out that the difference in price between your 32-bit system and 64-bit system is based mainly on hubris. Talk to me when you have the resources to pay attention to ACL full time as opposed to your favorite cash cow, AllegroGraph (which by the way in the last 5 years you apparently still can't even get it running on anything other than Linux). ACL 9? Please. There is no technological advantage anymore, and frankly hun, it's just too little too late. SMP is the major new feature? Are you kidding me? What year is it again, and *how long* has it been since the last release...? C'mon, tell everyone how long this one has been in the oven. ACL 9? WHO FUCKING CARES. Franz, I'm finally gonna say it: You need to either shit or get off the pot. 
What you're looking for is: [An Introduction to Programming in Emacs Lisp](http://www.gnu.org/software/emacs/emacs-lisp-intro/) by Robert Chassell.
It will certainly help you understand how lisp is formatted, and some lisp idioms, but elisp has a great many emacs-specific functions and it will do nothing to help you there.
This is also available directly inside Emacs, which will make the process of learning and testing and experimenting even more streamlined.
Given the current number of people working on ABCL and it's current status, is there an estimate as to when it will be ready to use in a production setting? Is anyone already using it in this fashion? What percentage of CL (in terms of the 1000, or so, functions) have been implemented?
Ugh... The PDF doesn't have navigation links and the HTML version centers all of the text.
I learned CL first. I can now also write elisp. Learning CL first certainly made understanding elisp easier. But beware of the differences :)
defvar defines a global variable, and in this case, you're only using the variable in the context of bob, so use a let statement instead. let defines variables which only exist in the scope of that statement. This, however, stems from the larger problem, which is that you're still thinking imperatively. This is understandable, since this is your first lisp program; it takes some time to start thinking in lisp. Here's how I would've written the function: (defun bob (max) (if (= max 3) 3 (+ (if (tester max) max 0) (bob (- max 1))))) In your code, you create a temporary list, iterate from 1 to max to populate that list with only multiples of 3 and 5, then iterate over the list to add it up. In my example, I recurse downward from max and add only the multiples of 3 and 5 to the total, without defining any temporary variables or using an iterative structure like loop. It's hard when first moving from a more imperative language to lisp, but some good guidelines are to avoid defining variables unless absolutely necessary, use functional style (your tester function does this,) and prefer recursion to iteration. Eventually, you'll get it, and you'll love it. Good luck and happy lisping! 
I found Land of Lisp to be a great book for understanding the concepts not typically found in the most common languages. Its a great way to get a grasp of things like higher order functions, macros, DSL, etc. If anything you'll come away with a better understanding of how extremely different [Common] Lisp is from the other languages you use daily.
using loop: (loop for i below 1000 when (tester i) sum i) [worth reading](http://www.gigamonkeys.com/book/macros-standard-control-constructs.html)
Interesting. In that link: &gt; This counts the number of vowels in a string: (loop for x across "the quick brown fox jumps over the lazy dog" counting (find x "aeiou")) ==&gt; 11 Find the mistake in that code.
The first thing I noticed is that you are looping through every number from 1 upto 1000. I'd suggest that you instead loop less times by only checking numbers that are multiples of 3 or 5. To get those numbers we just make our loop generate our multiplier we use with 3 and 5. (defun bob (max) (labels ((sum-of-3-and-5-multiples (i) (+ (* i 3) (if (and (&lt;= (* i 5) max) (not (zerop (mod (* i 5) 3)))) (* i 5) 0)))) (loop for i from 1 until (&gt; (* i 3) max) sum (sum-of-3-and-5-multiples i)))) Running your version on my laptop took 6,540,024 processor cycles to complete. My modified version took 40,020 cycles (yours used 163 times more cycles). If you didn't know, you can run your code using (time (bob 1000)) to see how efficient you get with each iteration.
Simple. Understandable. Useful for other problems. I vote this as my favorite so far.
In lisp, variables, except global variables, are almost always introduced with a `let` expression. Eg: (defun bob (max) (defvar *thing* nil) (loop for i from 1 to max do (if (tester i) (push i *thing*))) (print (apply #'+ *thing*))) Should be: (defun bob (max) (let ((thing nil)) (loop for i from 1 to max do (if (tester i) (push i thing))) (print (apply #'+ thing)))) Also, putting `**` around your variables, aka "earmuffs" in Lisper parlance, usually indicates a _special_ variable, a category globals fall into, generally (all the time?). See the hyperspec on specials, but basically they are dynamically scoped, rather than lexically scoped. 
Don't prefer recursion.
The only other thing that I would mention that hasn't already been said is that (zerop expr) test whether an expression is equal to zero and may be preferable to (= 0 expr). And, I second IncredibleElmo on the "Welcome to Lisp!"
I don't think using :: is especially clunky for something that is meant to test the internals of another package. Here are some options, anyway. You can import any symbol from one package into another; from there, when the importing package is the value of `*package*`, you can refer to the symbols with no package prefix. If you wanted to use a prefix but still use : rather than ::, you could define a third package, say FOO-IMPL, that imports the internal symbols and then exports them for the test suite to reference. So if FOO had a symbol UNSAFE-FROB that was not exported, you could do something like this: (defpackage #:foo-impl (:documentation "For testing only, not for external use.") (:import-from #:foo #:unsafe-frob) (:export #:unsafe-frob)) Then you could refer to FOO-IMPL:UNSAFE-FROB, which is the same symbol as FOO::UNSAFE-FROB.
You win!
Does this differ semantically from: (let ((*package* (find-package "pkg"))) (run-function something (somethingelse 5))) ?
What about defining a macro WITH-PACKAGE (defmacro with-package (pkg &amp;body body) `(rmap (lambda (sym) (symbol-append ',pkg :: sym)) ,body)) Where RMAP is a recursive map over nested lists (rmap #'1+ '(1 2 (3 4) (5 (6)))) =&gt; (2 3 (4 5) (6 (7))) And SYMBOL-APPEND concatenates multiple symbols into a single one (symbol-append 'foo '- 'bar) =&gt; FOO-BAR I'm on campus without my laptop, so I can't test this yet. Just an idea. 
There's actually little need to use loops in this problem. If you look at how the problem is set up, you have two cases to sum. n = k * 5 (where k is from 1 to floor(1000/5) and m = j * 3 (where j is from 1 to floor(1000/3)), minus the overlap-- o = i * 15 (i from 1 to floor(1000/15)). Since the three sums are multiplied by a constant, you can pull the constant out of the sum, and then sum 1 to 1000/5, 1 to 1000/3 and 1 to 1000/15, which has a simple solution, often attributed to Gauss (and sometimes Euler himself). (sum of n consecutive numbers is (n*(n+1)) / 2. This can be done on paper, and since my lisp is far more rusty than I would like to admit, I won't attempt to show a programmed solution. Just thought it was an interesting relationship.
Unless you're trying to write code portable to implementations without tail-call optimization, why not use tail recursion? Just idiom/style or does it actually generate slower code? Perhaps I should do a dissembly and profiling when I get home...
I said not to *prefer* it, not to disprefer it.
I've been flipping through it over the last few days. It's interesting material. I've been implementing some of the cannonical design patterns in CLOS to try and get a hands-on feel for how OOP in C++/Java differs from CLOS. I'm considering polishing up some of the examples and posting them.
No. A symbol that prints as FOO::BAR does not have "::" as part of its name; it is named "BAR" and has a home package named "FOO".
It's there to be used, isn't it?
That just goes to show how well I understand the package system. Thanks for clearing that up. :)
There is a bad-tempered flamewar about loop/dolist vs functional style into its *n*th year on comp.lang.lisp. Most lispers seems to be pragmatic about it, but if you're coming from a background in an imperative language you will probably tend to use imperative constructs a lot. Despite the fact that you're using a multi-paradigm language, appreciating functional style (in which avoiding side-effects more generally is one reason to favour recursion over iteration) can really help you to expand your toolbox of abstractions available to solve a given problem. It might be useful to check out [SICP](http://mitpress.mit.edu/sicp/) if you haven't already, as it has a lot of functional-flavour solutions (it uses scheme not CL but don't worry about that).
Using DOLIST is not a sign of doing it wrong. Sure, you can use it -- and lists -- it places where you really should not, but there's nothing *wrong* with it having it crop up in many places. It depends on the context. Maybe you are doing it wrong, maybe you're doing it right. There's not enough information here to tell.
Oh no. He's got --- **THE INSANITY!** Seriously though, I'm happy for you. You're skills with the other languages will improve as well.
"Why make everything so hard?" is my continual feeling using most other programming languages. That said, I found C# with Mono not to be as bad as I thought.
For this particular problem, the solution is so trivial as to be easy to google even without mentioning the specifics of the Project Euler problem, and considering this is a thread made by someone who has already solved it, I thought it pertinent to mention the efficient solution, solely for informative purposes. If it were a more challenging thing to find on your own, I would be inclined to agree with you. If many others disagree, I'm more than happy to edit my comment, or delete it. 
The punctuation point is well formulated, and on point.
I work on a personal project that involves a lot of PHP and Lisp. Can you imagine the pain. *Can you??*
I'm just going to come out and say it. You're doing it wrong...if you think you are doing it wrong. Why were you counting the number of dolists in your programs? Is there a reason you feel that the number is odd? I come from a C background where stepping through a list is done by moving a pointer, so no concept of true "list iteration." It took me a while to get the hang of being functional so a lot of my code was filled with dolists. But I eventually started doing it functionally the more I read others' code. I never really thought that I was doing it "wrong", just not to convention. Code still worked and relatively efficient. What are your thoughts on why you feel you are doing it wrong?
Development time inversely proportional.
C seems to be the golden mean when it comes to speed. It's faster than most of the assembler I could write, and I can write C faster.
The same thing happens when you learn a good static type system, and then try to go back to any of the dynamically typed languages. You'd like the compiler/interpreter to refuse your code immediately if you try to put your pants on your head, but instead it just optimistically pretends like it never will happen.
Yea, verily (just to be different from saying "yes").
Thanks, that's the kind of advice I was looking for.
Check out [Atomo][] as well. More lispy than Io, implemented in Haskell, and it provides powerful modern OO facilities like multimethods as like CLOS does. [Atomo]: http://atomo-lang.org/
I've been going back and re-teaching myself Lisp (I bought "Let Over Lambda" and "Planet of Lisp"), and after a bit of fumbling, I'm definitely realizing things the college me didn't understand. It definitely makes work (I'm on the C#/XQuery team) code weird to read.
Not everybody feels that way. I know I often write and run CL code knowing that some parts are a minefield. Strict typing often requires me to "tend to housekeeping" before I even get the place built. Also CLOS-stype "methods outside the class" adds great flexibility and somewhat limits the "fail at compile time" paradigm.
and CLOS is a set of macros that add OOP to CL...
I'm of the opinion that if you write Correct and Good™ code, you shouldn't be able to tell a dynamically typed language apart from a statically typed, and you should always strive to write correct code. Also, I think you should be able to force compilation through the type warnings, with the compiler just replacing the offending lines with something throwing a TypeError exception or whatnot. Although I have to admit I can't envision a scenario when I would like to force the compilation in spite of the warnings. I can't see when and why I would think something like, "What I need right now is some code that will crash if it hits this point in the execution. That would really make things simpler and more clear." It's simpler and more clear to just fix the type error so that the program works even when it hits the spot where there previously was an error. I understand you wanting to post-pone the bugfixing and whatnot, but every type error I've had have been due to a logic error in my mind. Something that have broken the algorithm or whatever I'm trying to do. Something that really shouldn't be in the program, and makes the program do the wrong things for the right input. I could run the program, take note of the wonky result and then try to figure out what went wrong, or I could simply iron out the type errors directly. Your last point is valid however. And as far as I've gathered, Lisps macros would be really hard to statically typecheck. So there sure are benefits you can get in a dynamically typed language, but I still feel there's something missing when my compiler doesn't tell me something's wrong when it clearly is.
Yup. :)
Full disclosure: I provide the binary packages.
Well, I've programmed in Haskell for some time, went back to CL and I can't say I miss static type system. SBCL's compiler already implements type inference and is able to catch dumb errors. I don't care whether it won't detect more complex issues -- I'm going to test code anyway. However, when I was programming in Haskell I missed a possibility to write program incrementally and experimenting in process. Yes, I used ghci, but it requires a recompilation cycle when I change a program, and data isn't preserved. Static vs dynamic seems to be a matter of personal preferences -- some people can't stand when their code is 'messy' w.r.t. types, others don't give a fuck.
the macros are just a thin layer over the top. it's mostly functions. AMOP is kind of CLOS-in-CLOS = CLOS
I cannot wait to get home so I can watch this. I believe this talks about the REPL that was used on the remote probe (that was near Jupiter or something) to diagnose, debug , and fix a bug.
and your point is? Many (most?) complicated macros are just a thin layers over functions. Its easier to develop and debug that way. Without the macros, how would you invoke the functions? The macros allow for the customized evaluation so essential to this application. That they use functions is an implementation detail.
Really cool stuff. Somehow I feel Ron comes off better in person than on usenet. (Not that he's a bad poster, just that his body conveys emotion that disambiguate his words for people who don't know him.)
This was a really interesting talk, insofar as it covers the history and politics behind the project Ron worked on. Unfortunately the technical content was virtually non existent which was really disappointing given the title. For example, the fact that the attempted rewrite of the Lisp component in C++ failed is given a bullet point and a brief statement about C++ not being ready was a let down. I'm glad I watched it, but the paper he wrote is better from a Lisper's perspective. 
*The Little Schemer* is a great book. Another good book you could try is [*How to Design Programs*](http://www.htdp.org/) (also see the incomplete [2nd edition](http://www.ccs.neu.edu/home/matthias/HtDP2e/)). Less for beginners, but these are also good: [*Practical Common Lisp*](http://www.gigamonkeys.com/book/) and [*The Scheme Programming Language*](http://www.scheme.com/tspl4/).
run it here: http://alex.nisnevich.com/ecmachine/
Are there any (ex-) Googlers who can reveal what he is referring to, when he mentions a Lisp related episode(1:09:38) at Goggle, that if it had gone differently, would have made the World a better place?
*Schweeeeeeet!!!* 
Does not seem to work in mobile Safari. Keyboard not showing.
The question of CL completeness doesn't tell the whole story about an implementation. ABCL has consistently beaten SBCL in ANSI test suite coverage over the past several years, but we don't go around claiming to be a better ANSI Lisp than SBCL. 
I respectfully disagree with most people on /r/lisp about Land of Lisp. I actually used Land of Lisp to learn Lisp over winter break, and I was able to write decent (functional-in-the-'it-works'-sense, if not stunningly beautiful) applications before even finishing the entire book. I was already an experienced programmer in several other languages (Python, Java, etc.), which may be the reason, but I'd never used a functional language like Lisp, so it did feel very bizarre at first, but I found I took to it well, and I didn't find anything in the book too confusing. Which is why I'm actually surprised when I hear people complain about Land of Lisp, because I found it to be perfect for me. Questions for anybody who dislikes it (not just OP): What's your background? What specifically do you find confusing? Have you used recursion in other languages before? Do you have a background in mathematical computer science theory, or just computer programming?
The speaker mentioned that a more lisp-centris talk was given somewhere else in the past. Does anyone have any info on this? I googled around for a bit, but couldnt find anything. Slides or video would be awesome!
A poor tradesman always blames his tools. A poor student always blames his books .... and teachers, and hyperspec, and ide ... I really don't see the problem. The book is fun, the examples are fun, programming is presented as something fun once again. The book has been hugely successful in sparking my interest in programming and I get the feeling it has for a bunch of other people too. If you combine it with all of the other free books available out there, how can you actually complain? 
Looks fixed to me as well.
Agreed, I'm still going to read this book. I just don't think it's the best book for beginners to start out with which was the point I was trying to make. Rereading my post I can see how it reads more as 'LoL sucks' as opposed to 'LoL sucks for beginners' :P 
It's not significant. Scheme uses the "name-in" placement to indicate functions so you don't have to type (define foo (lambda (args) ...)) everywhere. CL, being a Lisp-2, just has different calls for defining functions and variables. &gt; 'defun' would have to be a macro so that the interpreter/compiler doesn't try to call a function with the same name as the first function argument. Or a built-in special form. And of course if it weren't, you'd have to quote the body too.
Very nice, although it could possibly be improved by taking the current package into consideration when locating symbols. With the current implementation, if a symbol is available in the current package but is also exported from a listed foreign one, the *using* macro will use the foreign one, which is potentially confusing when reading the code, e.g. (defpackage :foreign (:use :cl) (:export :a-function)) (in-package :foreign) (defun a-function () "foreign") (in-package :cl-user) (defun a-function () "local") (using (foreign) (a-function)) ;; evaluates to "foreign"
The bottom value in Haskell is named `undefined` and it's meant for incremental development just like you describe. It conforms to any type signature, it throws an exception if execution ever hits that point, and well, it's precisely what you want and fully compatible with a static type system. You just have to return `undefined` and the rest takes care of itself.
Well crap, This is substantially clearer than my solution. Sorry for the delay, but I had to figure stuff out. Mine drilled down to a multiple of 15, then used a formula. (looking at my actual code, this may take more than 7 iterations. I'm garbling my own clues. I imagined getting ride of these iterations entirely, but never tried) My formula:(apologies for formatting and style) (* (1+ (* (floor n 15) 7)) (* (floor n 15) 15) 1/2) The idea here is to do the triangular number formula on 15-wide blocks of 3/5 factors (7 factors in each block, each block being 15 'high') I adapted your geosum so I could do away with my iterations: (defun geosum (max a) (* a (floor max a) (1+ (floor max a)) 1/2)) (defun eulerchunk (n) (+ (- (geosum n 5) (geosum (* 15 (floor n 15)) 5)) (- (geosum n 3) (geosum (* 15 (floor n 15)) 3)) (* (1+ (* (floor n 15) 7)) (* (floor n 15) 15) 1/2) ) ) What blew my mind was that your solution and my solution should be algebraically equivalent, but where does the 7 come from? I think I got it.
Visitors were a common pattern in Smalltalk to get multiple-dispatch behavior. So yeah, it is completely useless when you are talking about an OO system that supports multiple dispatch.
Multiple dispatch is like multiple inheritance - you don't need it often, but when you do, you need it bad. Multiple dispatch precedence is unclear only if you're unfamiliar with the precedence rules. Like all power tools, generic methods can save you time and grief (system extension without Visitor), and can be used to drill yourself in the foot (overriding methods without warning). If you need the discipline and reassurance of static type checking, use [Qi/Shen](http://www.shenlanguage.org/). That may bend your profs' brains a bit less than CLOS.
About type-checking: different implementations of CL treat type declarations differently. Some treat them simply as optimization hints, but some treat them as assertions too (e.g. SBCL). In that case, what you really have is a "gradual type system"---the compiler infers anything that's missing, but you may specify as much as you want to and the compiler will do its best to check and enforce it. Because Lisp is by its nature so dynamic, it may never catch as much at compile-time as Java would, for example, but it can still do really well.
You should look into [MultiJava](http://multijava.sourceforge.net/), which adds statically type-checked multiple &amp; external dispatch to Java in a backwards-compatible way. Also, there are plenty of other solutions to the so-called Expression Problem involving visitors, first-class modules, and so on that you can look up.
Thanks for the pointer. I am familiar with that passage, but assumed that he was referring to some other event or at least intended to provide some more details, since he wanted to on,y disclose it off camera. I wonder who was the tool VP of Engineering at Google at the time?
I wrote the article. Yes I admit I did take a jab at (some) Python users at the end. And I have uselessly complained about Python in previous articles. I am actually ashamed that I chose somewhat bad examples. The first main Python example can be (dirtily) solved with a ternary `if`. The second main example is actually a non-issue (but could be made into an issue by choosing less trivial lambdas). However, the underlying concept still is the same: Python lambdas aren't full-fledged functions in the Python-sense, nor are they full-fledged closures (which I didn't touch on). While somewhat obscured by the Python rambling, the point of the article is actually about how in a language like Lisp, deficiencies in the language can be corrected with the language itself. *If* Lisp had the same problem as Python, it could be fixed. Same thing with things like `case` not existing. The solution is within reach of the programmer, not the language dictator(s).
It's just that Python has many corners, like this lambda thing, that seem plain badly thought out. There's no real reason to implement lambdas this way. [Here](http://www.quora.com/What-are-the-main-weaknesses-of-Python-as-a-programming-language) is a discussion about other aspects of Python that could be done better, but just aren't because it's "unPythonic".
I can vouch for that. There have been a number of occasions where #lisp (and #lispgames) has helped me through a problem. Even you personally. (Thanks again, btw) I'll never be the GREATEST PROGRAMMER EVER but I've learned a lot by reading what others say in #lisp.
That puzzled me at first too.. although, I'm sometimes a bit toxic myself. There's a particular scenario I can envision though, of someone new to the language coming into #lisp and sharing his unsolicited, underinformed opinions with the channel (about, say, the difference between types and classes, uses of symbol property lists, or certain names and conventions). He'll be right on some points, wrong on others, but it's unlikely someone new is going to have much novel to add about things that were discussed to death years ago. If his tone as seen as complaining, it's only a matter of time before one of the ~400 people in the room ask him to kindly fuck off. I don't know that this was his experience, but it's one that plays out repeatedly, and the community portion of his post does come across as something of a butthurt rant after someone was rude to him on IRC. An ingrained defensiveness coupled with #lisp's unusual emphasis on signal-to-noise ratio might make for a newbie unfriendly atmosphere at times, but I don't know how to fix that to satisfaction of all parties involved. I'm glad the poster looked closely enough at Lisp to appreciate the virtues of Slime, CLOS, and the advantages of Lisp's approach to compilers and interactive development.
I think on of #lisp's issues is trying to fix confusion resulting in typical newbie questions instead of answering the questions "as is". You know, someone asks "How do I use EVAL in my macro at runtime?", and we pile on the poor newbie for being confused and doing it wrong... EDIT: maybe we need a #lisp FAQ about "Stuff that's been discussed to death and might get a sharp response." 
We have a name for "lisp without parentheses": [the Universe!](http://xkcd.com/224/)
I dont think that when he says "The Lisp community" he means all of it, I think he specifically means cll. Obviously cll is still by far the most highly visible entry point to the Lisp community for a newbie, and obviously that awful first impression lasts pretty long, even if they later find out that there is more than cll.
Lisp without macros or s-expressions is hardly lisp.
Hmm... I found his Ambienome project pretty interesting. Best of luck!
"Hundreds and hundreds and hundreds of years of ignorance. How in motherfucking hell does this happen? It was you." Even with the ending having this in /r/lisp is a stretch but all is forgiven because that utterly killed me. Still laughing.
Boredom got the better of me an I forked out the $7 for this. I have to say that it is almost worse than trying to tap out scheme code the normal way on the iPad. If you want to format your sexps nicely you can forget it. The editor has a mind of its own in that regard. Also you end up with a placeholder at the end of each sexp. By the time you have a few closing parens stacked up it begins to look terribly cluttered. A "pretty" view that doesn't render the placeholders would be a welcome addition. I am not convinced that it is properly handling tail calls either. I managed to crash it with a simple recursive definition of the Fibonacci sequence. Save your money
&gt;Of course, Ruby has some weird bits of syntax ... but no more so than most languages, including CL Wait, what's Lisp's 'weird syntax'? Lisp doesn't have *no* syntax, the way some people claim, but it's got... well, *almost* no syntax....
Is it really? CLL traffic seems to have had a major slowdown lately. I don't even filter some of the usual suspects.
This is a nifty concept that, imo, deserves a thoughtful exploration by both the author and the users, but since I don't have an iPad, I can't experiment with it. 
Thats adorable!
#lisp on freenode has some intensely knowledgeable and helpful people there. Some of those people do not tolerate fools or newbs gladly. Lisp style and design at the function level is pretty much cast iron, and the person who deviates from it is given a fair amount of grief. Usually the #lisp advise is based on large scale systems and Doing It Better. Most of the time, newbs want to Do it Worse so they can do their wee little program and learn something. This really bothers me. There needs to be a gentler road to doing it right that takes the nuanced and pragmatic approach. I've thought about working on a book for pragmatic souls and CL, but I'm not sure offhand what I'd put in it.
&gt; So, in Lisp, you write funcions that evaluate to some value. So do you in C. &gt; But in order to have a "normal" program, there must be something else other than the read-eval-print loop In a C environment you can interactively call only main(), from the shell, then C calls the other functions. The Lisp REPL just makes it possible to interactively call those other functions one by one and check their outputs. What the functions do is still up to you, like in C. You dont have to use the REPL, you just can. It is an additional, optional feature. You perfectly can write your whole lisp program in a file, compile and call it from the shell, as if it were C, and your user wouldnt see a difference. &gt; can't understand how you would create a useful application with a purely functional language. Lisp is not a functional language. It can be used in that way, it doesnt have to. Again, it is an additional feature. &gt; What am I missing? I think youre not missing anything. You seem to think that Lisp is more different than it actually is. It is just another language with another compiler. Only the syntax looks differnt. You can perfectly use the write-compile-run workflow you're used from other languages. And then only if you want, there's the interactive mode, but it is not in any way mandatory.
I see. I myself noticed that testing a function is so convenient if you put it into a file, load it with (load 'file.lsp) and then just call it interactively.
Paul Graham loves Lisp and hates Common Lisp. That makes for what I think is a poor treatment of the really nice features of Common Lisp that are not also present in some ideal Lisp (which does not exist). For a book that does not mistreat Common Lisp, try Practical Common Lisp.
Just write your program in a function named main and call it: ; SLIME 2012-01-06 cl-user&gt; (defun fibonacci (x) (case x (0 0) (1 1) (2 1) (otherwise (+ (fibonacci (- x 1)) (fibonacci (- x 2)))))) fibonacci cl-user&gt; (defun main () (format t "~%Hello, this is the fibonacci program!~%") (loop (format *query-io* "What integer (type quit to quit)? ") (let ((n (read *query-io*))) (cond ((integerp n) (format t "~&amp;(fibonacci ~A) = ~A~%" n (fibonacci n))) ((eq n 'quit) (return)) (t (format t "~~&amp;This is not an integer: ~A~%" n)))))) main cl-user&gt; (main) Hello, this is the fibonacci program! What integer (type quit to quit)? 10 (fibonacci 10) = 55 What integer (type quit to quit)? 11 (fibonacci 11) = 89 What integer (type quit to quit)? quit nil cl-user&gt; Your program can also use a different type of user interface (GUI, Web, whatever, using libraries). Now if your question was about deployment, you can deploy lisp code in different forms. * as source code in a script, add a: #!/usr/bin/clisp -ansi line in front of your file and chmod +x it. * as a stand alone executable. This is done with an implementation specific function to save an "executable image". Eg. in clisp: (ext:saveinitmem "mypgm" :norc t :init-function #'main :executable t) and there may be other ways to deploy lisp applications or programs. Read http://cliki.net/ and the manual of your implementation. 
Can't wait to show this to my node.js fanboy coworker :)
Can I buy you a beer?
My favourite part is from 54:15 to 54:50.
Ironically, he then goes on: &gt; Lisp is no harder to understand than other languages. So if you have never learned to program, and you want to start, start with Lisp. If you learn to edit with Emacs, you can learn Lisp by writing editing commands for Emacs. You can use the Introduction to Programming in Emacs Lisp to learn with: it is free as in freedom, and you can order printed copies from the FSF. Lisp is a powerful programming language family, but Emacs Lisp is one of the most crappy Lisps currently in use. I wouldn't trust any programming advice that includes recommending learning to program with Emacs Lisp.
I'm with the Schemers / Rubyists on this one actually. I love the terminal question mark as indicator of a predicate.
Is it so wrong to recommend that people using a lisp based editor use it to help them learn lisp? I'd say it's more practical than reading a book and using an interpreter separately since if oppurtunities to use lisp are constasntly shoved in your face your going to learn better than if your only method was to get into your 'Ok I'm going to sit down and read through this tutorial for a bit' mode. Languages are learned better imo by just using them. Being able to apply usage to something you use everyday makes a lot of sense. You might have a point if he had said to start using Emacs to learn it but for people already using it the advantage is clear.
I'll take crappy (easy to get) emacs lisp over java, vbscript, etc.
I have some issues with Stallman, but I also find his sheer magnitude of beardiness, perfectly on display here, kind of endearing. *"The programming languages I use are Lisp and C. They are also my favorite languages."* I'm also highly amused at how this, like his travel rules, is on one level a list of issues he's had. Which means that when he says - *"I do not post on 4chan. Occasionally I have answered questions for interviews for 4chan, but any account there that says it is me is an impostor. "* You gotta wonder what happened.
/g/ often sends e-mails to him.
This is kind of a silly idea - I'd rather write code in Emacs Lisp than in Python, Java, C, C++, Lua, etc. Emacs Lisp is kind of the El Camino of Lisps, but the El Camino of Lisps is a hell of a lot better than the Lamborghini of some other language. 
I'm a total Lisp partisan, but I think this is an outmoded idea. Languages like Haskell or Prolog or even Joy or Factor offer alternative computational models which are, in some senses "more powerful than," or at least powerful in a different way, than Lisp. You _can_ of course, build these types of systems in Lisp - but you can also simulate Lisp in many of these systems. Lisp is one location in the space of programming languages, but its hard to argue its actually the apex.
I agree. Homoiconicity is fundamental to Lisp. But there is certain feeling you get from certain dynamic languages. It's hard to describe, but you get the feeling that some pervert has written front end that hides the real Lisp below. You search and search, but you never find the Lisp because it's not there. 
I didn't know that, thank you. 
I guess I'll ask this here: Anyone know of a canonical example of a problem that can be solved better with macros than first class functions? 
I think what has basically happened is that, in the lifetime of some of these old hackers, the programming community dragged itself up from the salt mines of FORTRAN and COBOL, to the flower-meadows of equal power, and they still remember the one flower that stood in the light as they reached the exit, and that was LISP.
I would ask more concretely: show me something I can write in lisp that I cannot write easily in python.
I read through this earlier tonight, very nice. Would like to know how to get started with setting up slime though. I gave up and downloaded lispworks PE in the end :(
Not canonical, but here's a small example from [Practical Common Lisp](http://www.gigamonkeys.com/book/) (a great book): [Practical: Parsing Binary Files](http://www.gigamonkeys.com/book/practical-parsing-binary-files.html)
Canonical? No. But here's a concrete example. Its something I banged out today to help with my tax returns. Now a (print-let* ((a 4) (b (+ a 2)))) shows a trace and returns the value of b. (defmacro print-let* (bindings) `(let* ,bindings ,@(loop for b in bindings :collecting (let ((sym (car b))) `(format t "~A: ~A~%= ~A~%~%" ,(symbol-name sym) ',(cadr b) ,sym))) ,(car (car (last bindings))))) For some reason, I always find myself writing code that needs to know the printable representation of the code as well as the value it evaluates to. In most languages, this requires macros. 
elisp has one of the best string manipulation libraries known to mankind, and I hear that its CL interface is adequate for many tasks.
&gt; Have you ever worked in a large Lisp code base for an extended period of time? I spend a lot of time with Scheme and ELisp, not so much with Common Lisp. You can only enforce things in Lisp or Scheme if your programmers follow some style guide. If they don't, then everybody can invent his own little object system, a new looping construct, a domain specific language or whatever whenever he pleases. Lisp just has a little to much flexibility for my taste. 
Nicely put.
The objected oriented system of common lisp was first written as macros. Can you write your own object system in python, or do you have to stick with what is already there?
Haskell has two ways of working with monads: one that is based on combining first-class functions and another that uses a macro called "do". The macro is integrated into the compilers but it's still a macro. Using Lisp means you don't have to modify the compiler to do that kind of thing. Whether Haskell's "do" is "better" than the first-class function solution is subjective but it is at least true that "do" is widely used despite availability of an alternative.
I would have thought I could do eventually; it may require quite a lot of code though. But that's something you can say about any language. (Python is all written in C so is C more powerful than Lisp?) So the issue is really: why is it much easier to write something like CLOS in Lisp than in Python. Lots of people tell me things like &gt; If you don't know Lisp (or its variant, Scheme), you don't appreciate what a powerful language is. So either: 1) Despite having made some effort to learn Lisp there is still something substantial I am not understanding about it because I am yet to see something where it's relatively easy to program in Lisp but very hard in my preferred language (Python). 2) These people are mistaken in claiming Lisp is much more powerful than other languages. If the reason is the first then I genuinely want to learn more about it (I am not sure why mycl doubted my sincerity). I do not want to assume the second yet but that still seems like an option to me.
It wasn't? I thought portable common loops was macro based.
What did the functions in Portable Common Loops do then? The classes? Methods?
&gt; I would have thought I could do eventually; it may require quite a lot of code though. Yes, we call that "Turing completeness". Every language can do everything any other language can; that's what a compiler is for, since eventually everything becomes machine code. Macros let you write shorter, clearer code, and modify the language to suit your needs. I, for one, see that as very powerful.
Don't they use both? I mean how can you implement defmethod without using a macro?
If it used both, how can you say it was macro-based? That's the programmer API on top of the functional interface, which is implemented by a meta-circular object system.
&gt;If it used both, how can you say it was macro-based? Because it requires macros, and can't be done in a language that doesn't support them. And this combination of functions and macros is classic good macro programming style. For example, if you look at the back of the second edition of Guy Steele's Common Lisp spec book, it covers either the iterator or screamer macros (I can't remember which) which uses the same combination of macros for syntax, and functions to do the work, and recommends this as a strategy for large macro systems. 
That's funny. I say the same thing about C++ and Java. I understand the need some times, but many people develop too deep of class hierarchies with intricate coupling for my taste (with or without templates). The resulting patterns are roughly just as flexible as CL, but much harder to work with. Macros and CLOS allow for much shorter, clearer code.
Yes it was and still is. Macros are the public interface, the essence that allows seamless interop (instead of needing wonky funcalls everywhere). The internal functions are an implementation detail; but it is nice that MOP exposes some of them.
defmethod yes, but not methods themselves (I do not know for sure of course, but point is that your reasoning is faulty).
Yeah, the implementation is a detail. Sure. The functional interface is documented and exposed, btw..
&gt; Macros and CLOS allow for much shorter, clearer code. True, C++ and Java are however not all that pretty to begin with, I am thinking more of Python or Ruby. Part of my problem with Lisp is also not directly with Common Lisp itself, but with the fact that Lisp never settled into a single language. Yeah, you have an ANSI standard somewhere, but Emacs doesn't use it, Guile doesn't use it and DrScheme, Clojure doesn't use it, Gimp doesn't use it, Abuse doesn't use it and so on. There are tons and tons of things that use some variation of a Lisp- or Scheme-like languages, but hardly anything that uses actual Common Lisp, everybody seems to reinvent the wheel and roll it's own interpreter that then works slightly different then everybody else. And even when you have two Scheme implementation, they almost certainly will use their own invention of a module system that of course is incompatible to everybody elses. With C, C++, Java, Python, Ruby and Co. you have one language that gets updates every few year and that's it. There exist a few variations like IronPython or JRuby, but it never approaches the level of Lisp where everybody makes his own variation of the same thing. 
Yea this is actually the exact question I wanted to ask.
This is true. I absolutely love Perl and it's incredible flexibility. However, working on a project with half a dozen other developers and no real coherent coding guidelines turns flexibility into a liability. This is probably part of the reason for the popularity of Java and C#.