This was part of a rewrite I did a long time ago. I quit before finishing the rewrite, but the C version is still active. http://github.com/TempusMUD/cl-tempus
Oh wow, that's awesome... c:
This book has some MuD-like game as example: https://www.nostarch.com/lisp.htm
Would this be pertaining? http://a-nickels-worth.blogspot.com/2007/06/cl-rogue.html
I have to agree. After programming/hacking computers together for 20 years I learned more from Lisp than I did from most other languages. And it has surprised me how long it took some great ideas in Lisp to find their way into more modern programming languages like Python, ruby, etc. Though I suspect that ruby was designed with some of these ideas from the start.
I can search, browse the categories, view the projects and their API references.
Wonder why I'm getting an under maintenance page then. Just cleared my cache, opened a new browser instance and same thing. Well thanks for the report.
There are some libraries that show the under a maintenance message for me too
Are you on Firefox? I've been having some problems with Firefox and Woo-based applications. I'm certain it's on fast-http.
People try to do sicp in other lisps but it doesn't work as well.
:-) 
"Better" can be hard to define. It generally depends on context, including purpose. Often it's a matter of personal opinion or taste. For many students the concept of better is easiest to grasp by offering concrete examples, from which the student may derive his or her own abstraction. So, for example, Scheme is better than Python. Scheme is also better than Java. Scheme is better than Ruby. Scheme is better than C++. Is that beginning to make sense? ; - )
Great, now, if only they did a face-lift to the site to make it look like a web-site of a contemporary software development platform...
yes, it is nice, but it is not attractive for newcomers. Just compare how a web-site for [Julia language](http://julialang.org/) looks like or the [Ruby](https://www.ruby-lang.org/en/) or even [Python](https://www.python.org/). I understand that visual appearance is kind of a dogs and whistles thing that has no influence on how great the language/system is, but it is very important in attracting newcomers and making the community around it viable and vibrant.
It would be interesting (in a toy, learning exercise, non-production code sense) to implement a trampolining state machine by returning the new class and rest args to apply to CHANGE-CLASS. Seems like a bad idea, but I wonder how bad?
Gotta get in on the ground floor: https://github.com/eudoxia0/docparser#readme https://github.com/CommonDoc/common-doc#readme
Maybe it's designed to keep away the wrong people?
&gt; but it is not attractive for newcomers. Bitching about website optics is not attractive to non-newbies, so why are you doing it? &gt; but it is very important in attracting newcomers and making the community around it viable and vibrant. Making the community full of annoying nonsense spread by people attracted to a programming language by the color scheme of its landing page. Minimalism and focus on essentials are a purposeful filter to get *rid* of "oh shiny!" people. Attracting them is counter productive to any endeavor other than making money.
CLML looks really nice. However, it seems that the K-means clustering algorithm is not complete (please correct me if I'm wrong), which is a shame since I'm also looking for an implementation of K-means in Common Lisp. Are there any on going works to finish the K-means implementation?
When I was a Lisp newbie, I stumbled upon the SBCL's home page and instantly fall in love at how minimal and no-nonsense it is. No pointless fluffs or marketing bullshits, just straight to the point concise summary and relevant links to more information, which is a very appropriate design for a reliable tool, IMHO. So what I'm trying to say is not every newbie will be turned off by the current home page. Also, I don't think a compiler's website is an appropriate place to evangelize newbies anyway; that should be a job of common-lisp.net or similar websites.
I think the site looks great - it's one of my favorites, actually. Clean and uncluttered.
&gt;lynx/eww-compatible This is 2015.
peaked in for ARM treads ... not yet... keep hoping!
Does SBCL project need donations and additional funding to be able to dedicate more resources to improvements and bug fixing? I am not saying that the site must look like a shining blinking page with lots of adware. But providing an occasional visitor with basic information why Lisp is great, what it looks like, why should he make his next project in Lisp using SBCL and not Python or whatever else would be a reasonable modification to that page. 
Ok, look what Clozure CL web site looks like: http://ccl.clozure.com/ and the company that maintains it: http://clozure.com/index.html is it really so difficult or against their religion to put a couple of screenshots with the CCL code editor/development environment? Or, since they emphasize their decent integration with MacOS, is it really unreasonable not to post a screenshot of a simple "Hello World" of GUI applications developed in CCL?
Hehe, even their docs is free of images, it seems they really only like text. Maybe shoot them an email proposing improvements. As I said I don't think it matters. Maybe a few talks and articles about 'modern' CL dev with quicklisp and such. In my mind to really grok lisp you have to have a pretty deep view of programming, top down from eDSL to bytecode / assembly, and then what you need is not a better website.
&gt; But providing an occasional visitor with basic information Youre suddenly changing your tune here. You started your concern troll by criticizing the design, colors and layout of a compiler webpage, the visual appearance, not the lack of content. So what is it now? I guess if you volunteer to write a beginners introduction to using SBCL, the maintainers wont refuse to link to it. Are you taking the job?
And this is not the end of the story (as mentioned in the article); it will get even faster! So, it basically started out slower than the ECL compiler, and is already faster than it (at least in this case, which uses already optimized functions).
Clasp looks cool, but I haven't been able to play with it (source files seemed to take over 10G in space and I hear compiling takes 5+ hours on a decent machine, probably closer to 20 on my old rig). Guess I'll have to wait for binaries.
I think that's why my woo based apps were failing horribly (had to restart them all under hunchentoot) in the last couple weeks.
SBCL is still being used to power [Google Flight Search](http://google.com/flights).
A finished build with sources takes up 5GB. And it's now down to 4 hours of compilation.
I would love to see the project continues. Searching for Common Lisp topics on Google still brings up various links to the cookbook, so there are definitely values in keeping the cookbook alive. 
One way to do it could be to create a "cl-cookbook" github account, and open a public repository there, so that people can contribute to it more easily.
That would be even better.
lisp returns the value of the last statement, in this case the loop and that returns nil. You can add a finally (return c) in the loop to make it return c. Or rewrite it to a recursive function which uses an accumulator, then you test for n to be 1 and if so return the accumulator. Recursive functions are more lispy but since it's not garanteed it does tail call optimization a loop is also a good choice. e: an example for a recursive fib function is this; (defun fib (n &amp;optional (a 0) (b 1)) (if (= n 1) b (fib (1- n) b (+ a b)))) 
Thanks a lot! Please explain then, why it returns the output just fine, when I am running it directly from the interpreter?
ah i see i think you missed the format statement in the code you pasted above, you have one in the screenshot. This is actually a better way if you just want to print them upto a certain number. e: when i add that i get the same output in 'plain' sbcl started from the terminal btw.
Now I feel like a complete tool. Thank you very much for pointing that out for me! I had indeed forgotten to include the format statement in the source file. So, you are saying this is a better choice? Wouldn't tail recursion be a better way of doing it, if say, I needed to find fib to the nth of some ridiculous amount?
You need to return the right value. (defun fib (n) (let ((a 1) (b 0) (c 0) (x 0)) (loop while (&lt; x n) do (setq c (+ a b)) (setq b a) (setq a c) (setq x (+ x 1))) b)) Here a version in 'pure' LOOP: (defun fib (n) (loop for c = 0 then (+ a b) for b = 0 then a for a = 1 then c repeat n finally (return b))) Example: CL-USER 75 &gt; (loop for i from 1 upto 10 collect (fib i)) (1 1 2 3 5 8 13 21 34 55) 
Hi, I would like to help. Count me in 
The first line of the article states: &gt; People keep asking me about the choice of programming language in 61A. 
Check out the LispCookbook org on github!
Done!
loop is not very Lispy, nor is using assignment (set) where you could use binding (let). Here's an iterative Common Lisp Fibbonacci implementation that looks nicer to me: (defun fib (n) (let ((fib-of-i-1 1) (fib-of-i 1)) (dotimes (counter (- n 2)) (let ((fib-of-i+1 (+ fib-of-i-1 fib-of-i))) (shiftf fib-of-i-1 fib-of-i fib-of-i+1))) fib-of-i))
There are some, not unreasonable persons, who don't consider scheme to be part of the Lisp familt. See [this](https://groups.google.com/forum/#!msg/comp.lang.lisp/Bj8Hx6mZEYI/6AWmNEwQR5YJ) post by Kent Pitman Disclaimer: I consider scheme and racket part of lisp Or it may be because the author does not consider Racket a Scheme?
&gt; not unreasonable persons The major reason being that Scheme people voluntarily decided to not be "a Lisp" by not calling their language "XYZ Lisp", like members of a family do. They purposefully branched off and tried to not be a Lisp any more, but something better. Instead, you get "X Scheme", "Y Scheme", which means that schemers consider Scheme itself a family of languages. And now racket people think that their former MzScheme is sufficiently different that they should not even be part of the Scheme family any more. Keeping calling scheme "a Lisp" is IMHO purposeful trolling, born out of the jelaousy for Lisps success, that the Scheme know-it-alls were convicted was destined for Scheme, but never materialized because of the merciless religious fundamentalism with which they eliminated the last bits of practicality from Scheme, so that every end user ran away screaming. Had Scheme "won", like they hoped when they branched off from Lisp, they would be proud to not be a Lisp, but to be better than Lisp. The only reason they want to be "a Lisp" again is because they lost and fear completely disappearing into irrelevance. 
I was following you up until the last paragraph. Not everyone who calls Scheme a Lisp is a "purposeful troll", it could be simple ignorance that someone isn't aware of the differences.
I added two links to the sidebar as a fork: * [The Common Lisp Cookbook](http://cl-cookbook.sourceforge.net) ([Fork](https://lispcookbook.github.io/cl-cookbook/) / [Source](https://github.com/LispCookbook))
What makes Scheme not a Lisp? I enjoy both, and I see no reason not to call Scheme a Lisp. 
+1 I would like this, as long as each individual Q+A could be grouped and listed also as one page. I also think that way would facilitate adding more content (ie more Q&amp;A units) without creating friction, like deciding priority in page, grouping with sub-categories, , etc, and it would also be easier to refer to from possible tickets or pull requests.
&gt; it could be simple ignorance That someone also wouldnt call Java "a C" just because of superficial similarities. Of the major languages and their predecessors and descendants, it is (to my knowlege) only Scheme people that so desperately annoy the members of another language community by pretending to be "one of them" while at the very same time claiming superiority and denigrating the language of the trolled community. You dont have Java people trolling C while at the same time claiming to be a C, you dont have Ruby people trolling Perl or Python while claiming to be a Perl or Python, etc. In the whole space of programming languages, it only Scheme people are for some psychological reason (my guess is a superiority complex + real-life failure) doing this (trying to denigrate another language after failing to supersede it), and it is actually quite fascinating. Even if you do not like it, my last paragraph is actually the core of the argument. We're dealing with psychological conditions like jealousy and often borderline hate of Lisp here, and there is no way to talk about those observations without calling things by name.
I'm not objecting to any use of setq, just the use of it instead of binding. Really, I think loop is terrible. "Nicer to me", I know it's an opinion. Not trolling. I may have gone overboard by using shiftf instead of setf twice, but it comes up so rarely I couldn't resist.
Can't we just let bygones be bygones? I've read about the troubled history of Lisp standardization process and the Lisp vs. Scheme rivalry, but not everyone, and especially most new bloods who have just recently discovered (Common) Lisp &amp; Scheme, are aware of the blood feud between Scheme and Lisp folks. Also, while I kinda agree with your analogy of "you wouldn't call Java a C" (but then again that's why people call Scheme a Lisp dialect), you more or less ruined your entire point with all those needless disparaging remarks against the Scheme community. Not to mention that the whole debate is pointless anyway, it doesn't matter who get the Lisp "brand". In the end, all of us are better off having both Scheme and Common Lisp (as well as their descendants such as Racket and Clojure) around. Disclaimer: I like both languages equally, and want to see both of them succeed.
Wow. Speaking as someone who fancies CCL, I hope this will get better.
This kind of looping is something I'd probably use a DO loop for.
I read that as insurrection. You had me at insurrection. Not that the noble authors deserve to be cast in a negative light!
Don't listen to the people telling you not to use LOOP but some other kind of construct. You'll get into a weird territory where you'll make programming harder on yourself because of some weird definition of "purity" that's different for everyone. Use whatever is easiest for you, whether it be LOOP or DO or whatever. (Personally, I almost always use LOOP for iteration in Common Lisp since it covers so many bases.)
Yeah, this is a very nice project indeed. Hope it pans out, since there are a lot of interesting ideas in Clojure. Also, this reminds me of Fukamachi's [CL21](http://cl21.org/).
A lot of the work for this has already be been done for [self-hosting ClojureScript](https://swannodette.github.io/2015/07/29/clojurescript-17/) as well. :)
Oh sweet! I'll definitely be looking at this
and with [Planck](http://blog.fikesfarm.com/posts/2015-08-01-planck-scripting.html) it's actually pretty nice for shell scripting as well, only OS X for now though.
Thank you a lot. I keep twisting my mind, trying to figure out if the job I am trying to do can be done with recursion, or otherwise, but I always end up using a loop instead. I am not sure if this is bad practice, slower, or messier.
Latexmk tries to guess from the log file what it should do next. With arara, you tell it the steps of what to do (with a very simplified calling syntax; see [the README](https://github.com/cereda/arara#basic-use)). Latexmk's only feature over arara is doing 'only what's necessary' to stablize your document. Arara 4.0 (which is just waiting for the manual to be finished) will introduce some log searching to cut down on work that's done. Latexmk isn't good for much else besides your basic pdflatex/bibtex sequence. No automatic tool can be as smart as you are. Latexmk can get caught in cycles and hang if references never stabilize -- a not-so-uncommon problem if you have a lot of figures. You can avoid this problem entirely in arara by just using the standard directives. Arara is completely extensible using a simple DSL and readable configuration files. I can run Make targets from arara if I wanted to. etc.
Yes, these are issues. The SF HTML was directly plopped into git.
Response on an actual desktop, not a phone - Yes, the SF bugs should be ported over to GitHub. Do you feel up to doing the copypasting there? :-)
setvar doesnt seem like cl. it should be some extension
SBCL + SLIME + quicklisp for environment/IDE For web stuff, Hunchentoot (and anything else by Edi Weitz for that matter). Also look at Caveman2 by Eitaro Fukamachi, it's a fuller web stack with templating, etc. I've not used it much, but from what I saw is very comprehensive and well documented.
Pretty cool and easy to understand article. Thanks!
It's just like CL according to guides.
Checkout: http://www.adamtornhill.com/articles/lispweb.htm https://leanpub.com/lispwebtales 
So in the general sense of "unfamiliarity with github", I advise you to look here: https://guides.github.com/activities/hello-world/ . For the cookbook, you'd do something like this: 1. fork repo (only needs to happen once) 2. clone repo locally (optionally - make branch) 3. find issue, make changes, commit. 4. push changes to github (the git remote would be your fork). 5. make a pull request on github, referencing the issue # if there is one. 6. eudoxia or I looks at it, then we'll (likely) +1 it and merge it. The other option is that maybe we ask for a change, in which case you'd make it, commit, then do a git push. 
what guide are you following
Good article. I believe the author meant try/catch instead of throw/catch. Throw is usually used in these sort of languages to force throw an error and try is used as the general purpose start to catch any error in a block of code.
where do you see setvar described in this book? Or who is telling you about setvar's behavior?
Hm. I'll have to look after work. Do you know a better guide?
"CATCH and THROW are another pair of special operators that can force the stack to unwind. […] They definitely shouldn't be confused with try/catch and try/except constructs from languages such as Java and Python." [[Practical Common Lisp: Special Operators](http://gigamonkeys.com/book/the-special-operators.html)]
I think by `throw` he's referring to the mechanism used to raise the exception. It would be called somewhere in the dynamic scope of the `try` block -- e.g. if the `try` block calls `open(f)`, then `throw` is what `open` does if it can't open the file. I think he was lumping the `try` and the `catch` together and calling it `catch`. Lisp mechanisms comparable to a `try`/`catch` are written within a single operator, with the `try` and `catch` portions distinguished syntactically without using a keyword. (This applies to whichever of Lisps constructs you are comparing with the other language's `try`/`catch`.)
Disclaimer: I know almost nothing about autolisp except is _nothing_ like CL or Scheme. It is all dynamically scoped and has no let for example. From [this tutorial](http://www.afralisp.net/archive/lispa/lisp14.htm), you are looking for (findfile "Z:/...") Also it appears that you have to use either / or \\ to separate directories.
thanks for linking to lispwebtales. looks awesome
So I'm a bit too tired to be thinking clearly about this, but I take it that this is accomplishing a program flow that is a bit like writing a procedure that accepts an error-handling function or callback set in the calling scope to handle errors instead of throwing an error up to the calling scope? Of course, this is lisp, and it's implemented by macros, so I assume that instead of using function call semantics, it's using macros so that the error handling code runs in the lexical scope where the error is created, not in the scope where the restart is defined? Would this be something you could implement with call/cc in scheme instead of using macros, or is that implausible for some reason?
Sure, the family consists of Common Lisp, Emacs Lisp, ISLisp, Autolisp and several others. Not family members are ML, Dylan, Clojure, Racket, JavaScript, R, ... for any practical purpose. Those are incompatible derived/influenced languages with their own family. Calling them Lisp just creates confusion and creates an expectation of a joint community, compatibility, ... which simply does not exist. There are a few features which R, Common Lisp and Racket share, but it's not the general syntax, semantics and pragmatics for any useful definition of those.
IIRC Lisp in Small Pieces demonstrates implementing this with continuations.
Not the downvoter, but Go is a pretty low-level language. There is a ton of code duplication even within a package. There is a lot of room for macros. That's one reason (among many) I am not /just/ going to stick with Go. Though, yes, I will continue to use it as well.
I am definitely familiar with Racket. I studied it in university and wrote a few web apps with it. However, the sheer size of the libraries and language extensions was a major turn-off. Most of the time, I'm really looking for the simplest tool to get the job down. Extensibility and macros are the addition I'm looking for coming from Go though.
What are you doing in /r/lisp anyway?
&gt; Common lispers are the main reason why all lisp people (including clojure, scheme and racket) have a bad reputation. Really? I did not know that. People like Steele, Gabriel, Pitman, Fahlman, Moon, Weitz, Seibel, Xach, ... have a bad reputation? Interesting. &gt; Your "only my way is the right way" attitude, is the perfect example. Being a member of the Lisp family of languages has nothing to do with 'right' or 'wrong'. What you propose makes 'Lisp family' meaningless, a marketing slogan. 
Call/cc provides you with the general control-flow mechanism for implementing things like Common Lisp's THROW and RETURN. But there are certainly other mechanisms that would come into play if you wanted to do a Scheme condition system. One important thing to consider in the context of Common Lisp's condition system is how it interacts with dynamic scope. Being able to invoke a restart means not only that you can avoid all the effects that would happen in finally clauses (see also UNWIND-PROTECT) if you were to unwind from the error, but also that the code implementing the restart has access to the dynamic scope at the point where the condition arises. In Scheme, dynamic scope is (as I understand) synonymous with "fluid binding". So a condition system in Scheme would want to be able to get access to the appropriate fluid bindings in the same way that Common Lisp restarts have access to dynamic scope bindings ("special" variables). Somewhat off-topic: in terms of control-flow, Scheme actually feels like a more low-level language than Common Lisp. I feel that, perhaps, if you want to program with something like a condition system in Scheme, you should actually use Scheme to implement a restricted language in which call/cc were not available to the user but instead there were control-flow operators defined in terms of call/cc and which provide a more restrained conceptual framework (like you find in Common Lisp).
&gt; Macros are overrated I strongly disagree.
Lisp's `catch` and `throw` are not mentioned in the article.
These posts are amazing, keep it up. 
I think you mean top levels like (in-package foo) for all your different packages. You seem quite confused. ASDF is one of many package systems you can use. What you actually have is: Some core system (CL-USER package) that includes 2 other packages that interface with SQLite3 and Allegro Serve. This core system (CL-USER) loads the 2 packages to create one namespace that can access all functions in the 2 packages and your core package. The 2 separate top levels you refer to are the separate namespaces of each package you are using. Go read about ASDF in order to understand what a "package" and a "system" are. In general a package is a collection of code that does some task. A system is a collection of packages that fills some need or solves some problem. In general you should have ONE main package that loads all of your other packages inside it, then you can access and build software using all the packages your project needs inside a single namespace. For example: I have a web scrapper called scrap-o-matic that depends on cl-user to provide base Common Lisp functions, drakma to scrape data and cl-cffi-gtk to build the gui interface. I would have a main package called scrap-o-matic that loads Common Lisp base package (CL-USER) and drakma and cl-cffi-gtk into it's namespace so I can make a gui and then scrap data and populate the gui with the data. I would have ONE toplevel called scrap-o-matic that can call the functions that are inside CL-USER and drakma package and cl-cffi-gtk package. **(and by toplevel we mean that you have ran (in-package scrap-o-matic) the REPL is now able to access the scrap-o-matic namespace and everything that scrap-o-matic package can access.)** my core package scrap-o-matic + cl-user + drakma + cl-cffi-gtk provide a web scrapper program that is called a system in ASDF. A system is a collection of packages or other systems. 
`try` is not mentioned in the blog post. `throw` and `catch` are. `try` is just a way to indicate in Algol-family languages where lexically the `catch` is meant to apply. CL does it for `throw` by having `catch` as the special operator in the CAR of the entire body it covers.
You are a hero among men. I love StumpWM lol!
Maybe I wasn't clear. The operators described by the quote I responded to are not mentioned in the article. Not even in passing. The author introduces `handler-case ` as analogous to other language's `catch` and wisely chooses not to bring up `cl:catch`.
The same way Clojure also strives not to be everything JavaScript and Java are. The whole point is to take advantage of nice mature platforms. It's typically the CL folk that tend to worry a lot about having turtles all the way down. :)
Install a readtable with every single character as a dispatch character, so that I can replace the reader with a slightly different reader: https://github.com/jasom/spm-reader 
An abstraction is a terrible thing to waste.
I want that too! It would be awesome. 
Sorry for the nitpick, but "abusive" is really not the word you mean to use here. When asked for a definition, Google suggests either &gt; extremely offensive and insulting or &gt; engaging in or characterized by habitual violence and cruelty Each time I looked at my reddit main page today, I was puzzled/startled by the occurrence of this word among the titles, not in a good way. Next time, consider using "far-fetched" or "creative" or "tricky" or "hackish" or "surprising" instead.
Yeah, you're right it's adjective, not an adverb.
I don't have a firm reference other than my experience. I see this use of "abuse" as different from "abuse of notation/language" as used in math, though similar in a sense. It's just a common colloquial usage of the word that I see often and find no reason to discourage. It's common to say "I abused macros to ..." etc. and it just means that you used them in a way other than intended (often unexpectedly or subversively). Regardless, I don't think linguistic stricture or prescriptivism are constructive or helpful, especially in this forum.
&gt; Of course, this is lisp, and it's implemented by macros, so I assume that instead of using function call semantics, it's using macros so that the error handling code runs in the lexical scope where the error is created, not in the scope where the restart is defined? Not really. Basically there's a list of active restarts. If there's no handler for an error then a debugger pops up and the user can choose from the list of restarts. Otherwise the handler function can call INVOKE-RESTART to pick one. When a restart is chosen execution transfers to the place the restart was set up. There's no weirdness with scope.
From the "that probably wasn't the best way to do that" files, here's a [`with-file-datastructure`](https://github.com/m-n/much-todo/blob/9ab4a607c590cc828fb0bfae499ccdd2129e7c4c/utils.lisp#L5-L37) macro I wrote. It reads from a file, sets the given variable to the read value, then when leaving the lexical scope it writes whatever is in that variable back to the file. (This might be a little off what you are asking for. In my actual use case I pass in my own function to read the object instead of `cl:read`.) I've also played around with setting most characters in a readtable to my own function so that I can change parts of the reader that aren't easily customizable. One thing I added was the ability to place underscores in numbers without changing how they are read, e.g. `1_000_000`, `#B1010_1110`. https://github.com/m-n/lazy-susan In the reader macro department, one of my favorites that I haven't seen widely used is a syntax for running an external program which just treats the rest of the line as the entire call to the external program. This is a very convenient syntax for calling programs at the repl. I like to bind it to `#\# #\Space`, so that I can do things like `CL-USER&gt; # git status`. https://github.com/m-n/dishes 
What scoping rules does the restart follow? Dynamic at the point of error, lexical at the place of definition, or as-if lexical at the point of error?
&gt; Unfortunately I cannot change the title once the post is created. You should just ignore your inner grammar nazi.:( And honestly I have an english degree and I do not care wether I am using the correct words or not. 
A format that seems very useable (one page per recipe): http://docstore.mik.ua/orelly/perl/cookbook/ch07_11.htm
I think it is a good idea to have a discussion after the solution is presented. Thanks for the link.
Where can I learn more about angularJS + parenscript, perhaps see some examples? TIA
Lexical at the place of definition, I guess it would be. Signaling an error says "this happened", establishing restarts says "here are ways to deal with it", and invoking a restart says "use this one". There's no kind of privileged access to the point of the error, although handlers do have basically the same dynamic environment as the signaler.
Thanks very much if you can! Hope that you can post a link on reddit/r/clojure or planet clojure when you do. 
Ah right. Maybe it's related?
Yes I would be posting it there probably. 
Thank you for Turtl, and making its source available! Another informative page I appreciated is this one: https://turtl.it/docs/server/running By the way, I love the name, and the logo. Thanks.
"A while ago when I was looking into creating a Defender Game Remake I came across a great tutorial on parallax scrolling. Unfortunately the tutorial was for Flash, so I ported it over to Common Lisp. The port is a simplified version of the tutorial using structs instead of classes." [source code](https://github.com/sebity/parallax-demo) / [original tutorial](http://code.tutsplus.com/tutorials/add-depth-to-your-game-with-parallax-scrolling--active-2134)
Good work. The video could use a bit of CL interactive power, to show the benefits, imho. Speaking of games and CL: I did a partial rip off , of "Chambers of the Prelude" from Notch, which is located here: https://github.com/paines/cl-crawler.
You sound like fun.
You're right. I had not read the post, only that comment, and immediately thought of that chapter.
Two Common Lisp books are reviewed: [Practical Common Lisp](http://www.gigamonkeys.com/book/) and [On Lisp](http://www.paulgraham.com/onlisp.html).
Update: apparently there's an obscure feature that already does this in some implementations: http://lispblog.xach.com/post/126287122718/syntax-for-reading-a-form-in-a-package
wow, I combed through the comp.lang.lisp archives and just like xach said it seems this has been a feature in some compilers forever, lol.
&gt; Regardless, I don't think linguistic stricture or prescriptivism are constructive or helpful, especially in this forum. Well, the point, admittedly minor, is that I found this word usage *disturbing*. (I mean, unpleasant.) This is not prescriptivism, it is "please don't do a series of submissions on abusive programming, I would find it annoying and unsubscribe from r/lisp". Of course everyone is free to ignore this, but I'm a bit surprised to see the defensive reaction in this thread.
I really do think the functionality that I am looking for is a SYSTEM issue rather than a PACKAGE issue. I have no trouble with the PACKAGE problems here. I have a package for the DB-INTERFACE which defines the interface that my application expects the database to do: "OPEN-DATABASE", "STORE-POST", "ADD-TAG-TO-POST", "MARK-POST-AS-PUBLISHED", "LIST-ALL-POSTS-PUBLISHED-AFTER-X", etc. I'm using Robert Smith's INTERFACE library, but for the purposes of this post, it'd be find if those operations were just generic functions (except maybe the one factory-function to bootstrap the whole thing). So, what I need is for one to be able to specify at runtime (as an option to start my application either from the command-line or from the REPL) which implementation of that plugin to load. I could punt and have that specification be: "here's a system to load and a package + function to call to get an instance to use with these generic functions". But, other systems do fancier things. I was trying to explore what those fancier things were.
Right... I guess I was trying to see what other people have used for the "read a config file" step... and in particular, "read a config file" that may not have been deployed by the same author or at the same time as the rest of the application.
If you expand that Google suggestion, you will see the 3rd common sense of "abusive", the one used here: &gt; 3 involving injustice or illegality. &gt; "the abusive and predatory practices of businesses"
Thanks guys perhaps I was the confused one. I'm only an amateur lisper and I appreciate the explanations.
I agree - merge missing libraries into cliki. After that you won't have to deal with it anymore and you'll be contributing.
Just PM'ed you. I think the awesome-lists are great contributions to the community, especially CL. I'd be happy to maintain it for you. As the others mentioned, adding libraries to Cliki is a good idea too - though I think keeping both available has a positive effect.
I'll disagree with the other commenters. Don't add it to Cliki. Who reads Cliki? A page on GitHub is infinitely more accessible -- and better looking -- than a page on Cliki.
&gt; Who reads Cliki? A good portion of the traffic to my CL lib websites comes from Cliki (about as much as all of github generally) so I'm inclined to think it's somewhat popular. That doesn't mean awesome-cl isn't, well, awesome. Both resources are viable contributions to the community.
Ugh, sexy is a really uncomfortable name for a language to use or even talk about at work :(
I've mused about that, given that some programmers live (or work) in places far more uptight than I do. I suggest they rename the binary to "square", and change all the file extensions from .sex to .sq. \^_^
Depends on what your goals are. If you'd like a great learning experience, I would suggest keeping option three in mind (but I would call it a self-hosting compiler). You wouldn't have to do it all at once. Just add some yak bits and pieces when you feel like it. Just for fun, write, say, a Lispy assembler for x86. Handling a usable subset of the instruction set isn't too painful. E.g. [one in less than 300 lines](https://github.com/larsbrinkhoff/lbForth/blob/master/targets/x86/asm.fth). Then you can toy with small assembly subrotines. A few years from now you may feel like looking into garbage collection. It's not that hard to do a simple one. I'm going this route myself (but with Forth). Started with a compiler written in Lisp, targeting C. Rewrote the compiler in Forth, still targeting C. Wrote an assembler. Rewrote the kernel primitives in assebly language. Next step, make the compiler use the assembler. If you consider option two, it will probably not make you a better Lisp programmer, but a better programmer in the low-level language.
It might a great piece of code but unfortunately its implementation lacks any signs of documentation. And by reading the sources it is not so easy to understand what is going on there and how this whole thing works.
True, hopefully it will be added in the near future. As an absolute Lisp beginner, I find Fukamachi-san's code brilliant, instructive if not even inspirative. He has been writing really good libraries. I just wanted to share one of the less known ones.
I wrote the library. It's used in [fast-http](https://github.com/fukamachi/fast-http) and [jonathan](https://github.com/Rudolph-Miller/jonathan), that's why those libraries are pretty fast. A noteworthy thing is that the size of [jonathan's JSON decoder](https://github.com/Rudolph-Miller/jonathan/blob/master/src/decode.lisp) is only 242 lines, though [jsown's](https://github.com/madnificent/jsown/blob/master/reader.lisp) is 553 lines. I think it's useful only for who is willing to write some sequence parser, so I never thought its special documentations or tutorials are particularly needed. FYI, it's also used in cl-cookie for parsing cookie dates. It might be good for understanding how to use it as its simplicity. https://github.com/fukamachi/cl-cookie/blob/master/src/cl-cookie.lisp#L163-L235
Nice, I did not know about jonathan. Thank you for sharing so many excellent libraries.
It's not just a word, it's an entire topic of conversation people who could be objects of desire are usually uninterested to get into at work because office politics can lead to them not stopping things where they are comfortable, and instead getting bothered or even harassed, if not literally pressured into dates and even sex If you were an attractive young straight man in an office full of sometimes misbehaving gay men who were physically larger than you, easily able to impact your career, who were otherwise on their good behavior, would you want the topics brought that could bring up creepy actions, getting cornered, getting propositioned, getting your physical attributes talked about? Most straight men would say no. Women are in a similar position to this scenario. While some many welcome discussion of sex, many are cajoled and harassed and want the topic kept far from the workplace casual mentions as possible 
Yes. I would s/sexy/&lt;otherword&gt;/ across the codebase &amp; docs. Calling your language "Sexy" is really kind of.... ehhhhhhh. Not really what you want to deal with in any kind of mixed company. Broadly and rudely: if you giggle at the name and think people should lighten up - leave the basement and interact with a wide range of people. 
No way, that's a huge stretch. You're saying that the use of three characters in an identifier is going to induce someone to commit an activity which is likely against everyone's workplace policies, so we need to make sure we don't induce them. Right? First of all, if this were true, we will also need to make sure there's no instances of "war" (java .war files, etc), "fire", "trigger", "master/slave", "kill", "touch", "tail" and so on forever, if we're looking for coincidences between computers and meatspace. What if a chef reads a recipe that requires "chicken breast", is that a problem? What if the chef also needs a "pot", that one might be illegal. If someone is going to be motivated into criminal or fireable behavior by a common word, then the word is not the problem. 
You presume too much. Not everyone comes from an uptight culture where sexuality is considered taboo, cabrón. My wife thinks the name is funny, particularly with the tagline "real programs have curves". The fact we find it amusing doesn't make us basement-dwelling trolls.
Aaaaand that percentage of the population will use conversations about this language to makes jokes and such in order to make the work environment whatever floats their boat Without a sex language name, those jokes can be far more easily called out as inappropriate You know they'll do it...why do you act like they won't?
Of course harassment happens. There are always going to be idiots: in most workplaces, they get fired for inappropriate behavior. If there is no harassment policy, then that company will get sued and they'll come up with one pronto for the next idiot. Anyway, the point remains, a word can't cause a behavior and a word is not responsible for anyone's behavior. The idiot alone is responsible. As a side note, this sounds like someone has a sensitivity here. Maybe their employer needs to be notified?
&gt; The operator opt gives you access to keyword args, while rest gives you access to the rest of the story What about hygiene? opt and rest are global toplevel identifiers? Why not make proper lambda-lists rather than dealing with all the issues contained? In other words, (defun foo () (lambda () opt.y)) ..... but I want the y keyword from the foo, not the lambda. OR: I want a macro that may expand to wrapping a lambda ... why should I have to change all my code just to introduce a lambda? 
Man, I am not going to walk in fear of political correctness. This world has become far too uptight - everyone is afraid of everything. I try not to give or take offense too easily. Too many are too quick to do both - often at the same time! But I'm not about to censor myself, or limit my sense of humor, just because this world contains insensitive assholes and hypersensitive histrionics. I'm not responsible for the actions of predators; I am not one of them. Sorry you don't like the name.
Note that I disagree with gammafactor6's aggressive tone and over the top conclusion. But in particular quicklisp-client code could use more docstrings and a comment at the beginning of the file, or at least in the defpackage, explaining the general idea of what the code below does and how the pieces fit together. To not end in an overly negative manner, a shout-out to /u/orthecreedence. I find [wookie](https://github.com/orthecreedence/wookie/blob/master/hook.lisp) easy to understand (and well documented *in* the code and outside).
Thank you! I try to work very hard on creating understandable documentation, although lately I have to admit I've fallen behind. Many of the docs on my projects are not as up to date as I'd like them to be (I have a list in Trello about a mile long telling me what I need to update). Documentation is a pain in the ass, but I've found that once I actually set my mind on actually doing it, it starts writing itself. 
Weel done!
Me experiences with Clojure in production are very good. Your mileage may vary. Write down some requirements and i can give you feedback. :)
The question on its own is impossible to answer by itself. There are too many variables, and often it's not the technical arguments that are the ones that finally forces the decision. I can only speak from my own experience with a web application we've been building (team collaboration chat system, will be opensourced soon, let me know if you want to see it) where the server side is written in CL (on SBCL) while the client part is in Clojurescript. This has worked quite well, and the fact that SBCL is so much faster than Clojure helps when it comes to server costs if you have to pay per CPU/hour.
Glad you asked. PAIP should be right up there, if not at the top. The clarity of his code is out of this world, ZEN status. More down to earth: https://github.com/nikodemus (sb-cga, sb-vector-io, esrap) Nikodemus writes code in a **very** straightforward and clear manner, and even though he doesn't document **everything**, he documents more than enough. The clarity of his code would let him get away with not documenting as much but he still does it. This is the opposite of quicklisp, the code is not clear at all in what it does and how it does it, there are spaghetti hierarchies almost everywhere and there is minimal documentation. By documentation, I mostly mean **docstrings** since they mesh well with the interactive nature of CL. Somebody also mentioned https://github.com/orthecreedence which again takes the time to document and clarify the code. 
What did the penne say to the macaroni? Hey! Watch your elbow.
I woud love to see the source. You use SBCL on server side only because of speed? or any other reasons?
Thanks for all the answers! What experiences and advices do you have about deployment?
Unfortunately not an open source project. For this project speed is not so much a consideration,its more maturity. All of the libraries I might use work well with SBCL and we have some experience deploying it in AWS. I did consider Clojure on the server side, but decided on CL in the end. I concur with the analysis given below by "notunlikethe waves" and would add that unless you really need the java interop and are comfortable in the JVM Clojure does not buy you that much over CL, IMHO. Not dissing Clojure, which I think is a great language, but like almost any technology choice gets down to learning curve, comfort/confidence and expected benefit from deployment. Disclaimer: After years in the Java world, I am happy to be out of it, so my opinion might well be biased. 
Thanks for this explanation I also go with more mature system if I can. Have you used any libraries frameworks for SBCL?
For quick prototyping, Ruby/Rails hands down. For production stuff... it depends. The batteries included nature of Rails is hard to give up. Everything is really polished, from installation to deployment. I don't like writing code that feels unnecessary. Clojure just feels more stable in production. I feel like I have to be more focussed when I'm writing Clojure. While it feels like more work up front, you make it up by not having to hunt down as many bugs. Ruby feels like shooting the shit with your beer buddies. They'll let you say almost anything you want (even if you wouldn't say it sober). Clojure feels more like writing an essay. It doesn't flow as easily, but your ideas are articulated much better. I hope that doesn't cast Clojure in too harsh a light, because I really do enjoy working with it every day. There are a lot of really brilliant folks in the Clojure world writing some amazing stuff, and it is a joy to see what they're coming up with. 
thanks a lot! I have the same feeling with node, I can write something quick but it doesn't feel like a real server and I think about rewriting it in C. Or maybe I am old...
No. The main reason for choosing Common Lisp was not speed, but rather that since this project was started from scratch and only for ourselves, we were able to experiment with any technology that we were interested in. In other words, the most important feature was that we had a pleasurable development environment. In my experience, the interactive type of development that you do in CL is perfectly suited for web development. Since you can recompile functions on the fly, you can alter the behaviour of the web application by simply pressing a single button, for example by compiling a new web handler function or modify some behaviour. You can also use the REPL or the SLIME inspector to look at the state of the application in real time, and you can even do this on the production server if you want to debug an issue that you can't reproduce on a test system. I couldn't even imagine doing web development any other way anymore. Of course, I'm sure you could have a similar experience with Clojure, but I simply prefer CL as a language. It's more mature, more pragmatic (since it allows all kinds of programming styles) and the implementations are much faster. The drawback of using CL for this project has been that in some cases there was no mature library available to do some specific thing and I've had to develop it from scratch. On the bright side, this has benefitted the CL community since there are now some new libraries for others to use. A couple of examples for this is [cl-rabbit](https://github.com/lokedhs/cl-rabbit) (RabbitMQ client library) and [cl-markup](https://github.com/lokedhs/cl-markup) (simple text markup processor). We're also using a fast template language that I implemented because I didn't like the existing solutions in CL: https://github.com/lokedhs/lofn
Personally, I am grateful for very instructive code, such as [Fukamachi's](https://github.com/fukamachi), [Xach's](https://github.com/xach), [Lyon's](https://github.com/orthecreedence), [Borretti's](https://github.com/eudoxia0) and [yours](https://github.com/PuercoPop) among others. 
Thanks for your reply, I've looked at cl-launch and is now using, with a minimal system (see https://github.com/ralt/github-backup/blob/master/github-backup.asd)
Hi, Thanks, I now know for sure all the ways that I can use. I was hoping for a better way -- quicklisp is not *that* well integrated. Installing it on debian unfortunately requires more hoops than I'd like.
I like the implementation of Quicklisp's client! It's actually one I would suggest people look at. They should pay attention to the modularization into packages with small exported interfaces; the style of using CL directly instead of thin wrappers over the standard; and clear naming. Usability wise the blog posts, animated demonstrations, and especially the combination installation instructions/tutorial from the website are also worthy of emulation. As a criticism, last time I looked at Quicklisp, beyond the basic usage it wasn't obvious what the rest of the interface provided. 
I can run it perfectly. How are you running it? $&gt; sbcl This is SBCL 1.2.9, an implementation of ANSI Common Lisp. More information about SBCL is available at &lt;http://www.sbcl.org/&gt;. SBCL is free software, provided as is, with absolutely no warranty. It is mostly in the public domain; some portions are provided under BSD-style licenses. See the CREDITS and COPYING files in the distribution for more information. * (defvar *db* nil) (defun make-cd(title artist rating ripped) (list :title title :artist artist :rating rating :ripped ripped)) (defun add-record(cd) (push cd *db*)) (defun dump-db() (dolist (cd *db*) (format t "~{~a:~10t~a~%~}~%" cd))) (defun prompt-read(prompt) (format *query-io* "~a: " prompt) (force-output *query-io*) (read-line *query-io*)) (defun prompt-for-cd() (make-cd (prompt-read "Title") (prompt-read "Artist") (or (parse-integer (prompt-read "Rating") :junk-allowed t)0) (y-or-n-p "Ripped [y/n]"))) (defun add-cds() (loop (add-record (prompt-for-cd)) (if (not (y-or-n-p "Another? [y/n]: ")) (return)))) *DB* * MAKE-CD * ADD-RECORD * DUMP-DB * PROMPT-READ * PROMPT-FOR-CD * ADD-CDS * (add-cds) Title: Best of Origa Artist: Origa Rating: 5 Ripped [y/n] (y or n) n Another? [y/n]: (y or n) n NIL
That's pretty cool! I think this might be the first time I've seen the ability to save a core separate from the rest of the runtime taken advantage of in a sensible way. (The script files declare their dependencies on the first line as arguments to `sbcl-wrap`; `sbcl-wrap` caches a core with those dependencies loaded, and runs the script using that core. The readme shows ~6s to build a core with alexandria and puri; ~0.05 secs to use the core on subsequent executions -- the core appears to be reused for all scripts with the same dependencies listed in the same order, so editing / tweaking / rerunning the script should be a fast cycle.)
THe lands of lisp book goes through a lot of principles and applications in a fun way Not a horrible start, and is very entertaining
I was running it in Slime, I honestly hadn't thought about using Clisp to try it. I am now trying to figure out why Slime refuses to acknowledge my functions. Thanks for the reply tho, at least I know my code works.
Check the Common Lisp subreddit's sidebar and the sidebar in this subreddit.
How are you running it in slime? I'm pretty sure it works through slime as well. Do you C-c C-l to load the entire file?
Good job using SLIME though :) For something cool, read this: http://malisper.me/2015/07/07/debugging-lisp-part-1-recompilation/
I personally learned CL trough [Common Lisp: A Gentle Introduction to Symbolic Computation](https://www.cs.cmu.edu/~dst/LispBook/) really like it because of all the exersices in it. I also have a copy of [Land of Lisp](http://landoflisp.com/) which I mostly use as a referance guide for quick lookups(mostly for the awesome loop table). Also used [The Little Schemer](http://www.amazon.com/The-Little-Schemer-4th-Edition/dp/0262560992) in the begining to learn how to code in lisp. Not sure which of the two books ( gentle introduction or little schemer) that really made lisp "click" for me, might've been a combination of both.
This name is a no-go in any environment not run by brogrammers. Not even gonna click the link.
If you want to work on the Erlang VM but want a lispy experience you might want to try LFE: https://lfe.io
GOOD. \^_^ https://www.youtube.com/watch?v=jZVk6nn6PuU
Docstrings are strings. Lisp programs are built out of Lisp data structures: symbols, lists, numbers, strings, ... CL-USER 29 &gt; (defun foo () "this is a foo" nil) FOO CL-USER 30 &gt; (type-of (documentation #'foo 'function)) SIMPLE-BASE-STRING Your language renamed a lot of traditional Lisp stuff just because you find them 'ugly'. 'bool' -&gt; that's an ugly name. I'd call it boolean. CL-USER 31 &gt; (typep t 'boolean) T 'rune' a unicode character. Why not just 'character'? Literal is $A. In Lisp it's #\a. Not much progress, just renaming. $space is #\space in Lisp. Lisp's cons is renamed 'pair* 'record' is a new name for a assoc list, or hash-table. Lambda is renamed to 'fn'. 'defun' is renamed to 'fun'. macros are now called 'operators'. streams are now called ports. Basically your language is just a renamed Scheme with objects, which already. 
I suspect that a Clojure long-running process on the Oracle Java Virtual Machine (JVM) benefiting from Hotspot, Just-In-Time optimizations, etc... is similar in speed to SBCL but at the cost of much more memory usage because of the nature of the JVM. But otherwise I agree with your points.
There is [core.typed](https://github.com/clojure/core.typed) that works with both Clojure and ClojureScript. People are using it in production.
I maintain a micro-framework for Clojure, and I have some documentation on deployment [here](http://www.luminusweb.net/docs/deployment.md).
&gt; I would much prefer common lisp to be the lingua franca than JavaScript but we may have already lost that one. i think there's no "may" about it. :-) And i would expect languages like Lua or Python to become a new lingua franca well ahead of CL. (Not that i'm an active proponent of Lua, Python or JavaScript - i'm just going on my subjective experiences of what programmers in the Web space are likely to be into.)
As far as I know llvm already has a draft for WebAssembly backend. Christian Schafmeister is developing CLASP - common lisp implementation that uses llvm, so, maybe in the future, it would be possible to extend it's code generation capabilities for the WebAssembly too. Maybe it is theoretically possible to use Common Lisp in the browser right now by using CLASP with emscripten?
I've thought about how parenscript might be retargeted to webassembly, that's probably simpler to achieve but also more limited in capability than the full clasp-&gt;llvm-&gt;webassembly idea. The problem with "application X, only in a browser!" is that many keyboard shortcuts and mouse actions are unavailable, threading sucks, the networking is limited etc. The way to get it all back (except the threads?) is to not run inside a webpage, but package your app as the controller of an embedded browser with something like [electron](http://electron.atom.io/). That said, integration between a parenscript/clojurescript driven browser client and a CL HTTP backend is a well trodden path that can deliver some of the best (and worst) of both worlds.
&gt; many keyboard shortcuts and mouse actions are unavailable, threading sucks, the networking is limited etc. I definitely see your point here. Do you have any experience with electron? I have toyed around with Atom since its 1.0, it choked on some medium size files but I wasn't sure if that had to do with electron or the fact that most of Atom is written in javascript (iojs). &gt; tegration between a parenscript/clojurescript driven browser client and a CL HTTP backend is a well trodden path that can deliver some of the best (and worst) of both worlds. Could you elaborate?
&gt; happy with Emacs I am right there with you. Every once in a while I take some time to try out some other editor for some section of my daily typing and I always come back to emacs. One of the stranger things I personally love about emacs is how it won't let you press tab too many times on non-whitespace delimited languages. &gt; When it works well you almost forget it's there, when there are problems it often involves differences in semantics between the two languages, like truth/falsity or ambiguity mapping nested lists to JSON. I prototyped an inventory management system that used JSON RPC served by CL but have since transitioned to [couchDB](http://couchdb.apache.org/)+[pouchDB](http://pouchdb.com/) for the model layer and [handlebars](http://handlebarsjs.com/) for the view. Finally just vanilla JS for the business logic, couch views, and all the rest. I miss parenthesis but the work flow in a web browser definitely has its moments that remind me of working in emacs. 
thats cool!
I enjoyed the whole series quite a bit. Another cool detail about Slime's jump to definition is that `C-.` and `C-,` interact via a stack; you can jump a few definitions deep and jump back out one at a time.
Part of it, anyway! I don't necessarily want to try to crowdfund it all, at least not all at once. I'd like to pick an important part and then see how well it goes, and get more ambitious if the experience is positive. 
You also could publish a whole list of planned tasks and their corresponding price tags and let the donors vote with their wallets.
The first actually interactive Lisp REPL was done by L. Peter Deutsch in 1963/1964. Peter implemented LISP and the interactive REPL for the PDP-1 when he was a kid - he was 17. http://www.computerhistory.org/pdp-1/media/document/DEC.pdp_1.1964.102650371.pdf Page 14: &gt; input comes from the typewriter if sense switch 5 is up... &gt; each S-expression typed in will be evaluated and its value printed out. 
I've gotten support via email recently. It's still an ongoing project as far as I can tell.
Good info, thanks. By the way, what are you using it for, if I may ask?
i would also like to see if there's a way any of us can contribute by knocking out bugs or features, in addition to anyone who wants to contribute dollars. I honestly haven't done much looking to see if you already have this going on somewhere (Github issue tracker?), but I'd definitely be open to spending some time on documentation, issues, or bugs.
Slowly the world works its way back around to the Smalltalk experience or what was present in Symbolics. There is great power indeed in a really good language directly driving and being used through good GUI in a relatively seamless manner. That said, a web browser severely restricts what code can do for a variety of security reasons. For instance, you can forget about any access direct access to the local file system. You can also forget about free form networking many an OS supplied (usually) functionality. That is a very large price to pay. An idle fantasy of mine is to have something more powerful than current browsers for GUI purposes that is the same on all machines (within limits of the machine) and has a standard simple language interface. Thus any language or backend whatsoever can cause things to be rendered in it by talking to the ??? (gui language processor/driver) on the target machine that drives the nice GUI. Conversely the user/owner of the machine decides which things to allow to talk to that GUI. This imho would be loads better than mucking about in browsers. 
So you have a handful of monthly donors? That's the first clue I had that you took donations! Went to the quicklisp page...nope. Web search found https://www.quicklisp.org/donations.html yay! As a first step, you might consider linking that from the beta page. I bet there are others like me who don't realize that you take donations.
Regarding process monitors, I recommend daemontools from djb; it's excellent. I never tried using daemontools with detachtty, though, and that might not work, but if you specified your main function when dumping the binary and have no repl, then there would be no need to use detachtty if you're monitoring the process with daemontools.
I use rsync to push the code to the server. That's both the code for the application, and any Lisp libraries I need to shadow (because of bug fixes that haven't made it into Quicklisp yet) or libraries that aren't in Quicklisp. Then I connect via SSH, and build and save an image on the server. The Lisp process is managed by Upstart, so to update the running code, I just restart with initcl. The big advantage of using an image is startup speed: if Lisp should crash, it's back up again almost instantly, in a state which is *known* to be good. If you really want your server to be robust, though, there are two other contingencies, beside the Lisp process crashing, that you need to consider: (1) Lisp may *hang* without crashing; and (2) it is possible (if you are using threads as background workers) for one thread in the Lisp image to crash *by itself*, so you need some way to monitor the individual threads from within Lisp.
Thanks for that. I've got some familiarity with Vagrant and Ansible, so I spent a few hours today trying to use them as you mentioned. It seems to be working now! In case you weren't aware, there's an Ansible module `synchronize`, that uses rsync behind the scenes, that I used to move my local code to the server/dev box
Oh, the KPAX screencast, okay. I have both parts. I don't remember if Episode 2 had sound or not. (I'd check but the videos are on a USB drive at another location.) If anyone is looking for the missing first part, I can put it online somewhere. And I can see if I have a better copy of Episode 2...
I use ec2. I use filezilla and sftp in sync mode to update the system. I use [sb-daemon](https://github.com/nikodemus/sb-daemon) to launch. $ sbcl --load daemon.lisp --noinform daemon.lisp: (require 'sb-daemon) (require 'swank) (require 'mysite) (progn (defparameter *running* nil) (defun launch-app (argv) (declare (ignore argv)) (sb-daemon:daemonize :output "/tmp/mysite.output" :error "/tmp/mysite.error" :pidfile "/tmp/mysite.pid" :exit-parent t :sigterm (lambda (sig) (declare (ignore sig)) (setf *running* nil))) (swank:create-server :port 4006 :dont-close t) (setf *running* t) (mysite:start-app) (loop while *running* do (sleep 10)) (mysite:stop-app) (sb-ext:exit)) (launch-app nil)) 
I know some people have done it, but I'm not sure what they do to make it work. It's not really how Quicklisp is designed. It expects to be able to fetch metadata files and software archives in a writable directory on demand.
Running `sudo ql-quickload foo` is a reasonable way to install global components, this is exactly what other package managers require. Hm... I guess I could write such a script and see how quicklisp plays with asdf's registry...
&gt; this is exactly what other package managers require. God, please don't. One of the best things about Quicklisp is how everything is user-local. Having to deal with npm's bullshit 'gib sudo pls :\^)' has made me appreciate QL even more.
For global packages. Whether it's apt, pip, gem, or npm, global modules/packages require root powers.
&gt; It loads fine on my system but that's as far as I've gone. That's farther than I've ever gotten. Someday I'll see what it's all about. Someday...
Can't complain, you've made installing CL libraries so much smoother than it was.
I'm glad to help, there's so much more to be done though.
I gave McCLIM a try once. It is interesting at the design level, but the implementation is currently a bit lacking and it is seems there's no body maintaining it any more. Last time I tried it it had some issues with display refresh. You would scroll a list, and the list would not get redrawn appropriately. I tried to fix that bug, but I couldn't, and gave up in the end. It is a pity that McCLIM is not maintained anymore; I don't think it is as bloated as some people claim and I thought it had potential for developing Lisp tools ala Smalltalk, among other things (taking advantage that it is completly written in Lisp). 
&gt; I don't think it is as bloated as some people claim Which kind of "bloated" do people say it is? Overly resource hungry, slow, over-engineered, or contains features they don't use?
For what its worth: I installed it to /usr/lib/quicklisp, added a group 'quicklisp' and chown'ed/chmod'ed the directory recursively to be group read and writable. Worked well for me so far.
That's a pretty big assumption isn't it? There is no reason why hotspot would be able to optimise clojure functions well compared to java ones which it shines at. I'd like to test this out in practice..
If being in memory and nothing particularly special besides that is all you need, sqlite defaults to being in memory. You can pass ":memory:" as the path to cl-sqlite and nothing will be written to disk. (Which is the default)
You could try https://common-lisp.net/project/elephant/, with sql-lite backend. It says it has a prototype query language. It doesn't look like a good option, though (Elephant looks unmaintained and I have doubts about the query language) 
regarding your rebuild step, are you saying that you both build a new binary and sync the updated code, so that the running image on the server can be live updated, but if you have to restart then the binary is already in place?
Yes, exactly.
Not an OO database but a document store on top of postgres which may fit your usecase: https://github.com/gtod/postgres-json Another thing that may work adequately is using [manard db](https://github.com/ilitirit/manardb)* and [optima](https://github.com/m2ym/optima)/[trivia](https://github.com/guicho271828/trivia) as a query front end. There is also [Vivace Graph](https://github.com/kraison/vivace-graph-v3/blob/master/example.lisp), a graph database implemented in Lisp. Looks promising. It is rather thin on the documentation but the [example](https://github.com/kraison/vivace-graph-v3/blob/master/example.lisp) makes things pretty clear (There are other examples in the code but not in properly highlighted as such, ie in their own folder). Other things to check out: - [cl-linq](https://github.com/pnathan/cl-linq/), which attempted to provide a uniform querying interface to multiple data sources but the authors seem to have stop working on it. - [data-table](https://github.com/AccelerationNet/data-table/), a simple abstraction over csv and database results, - [planks](https://github.com/drewc/planks) which provides persistent Clos objects and uses a btree internally. \* Check Dan Lentz's fork of manardb as well.
[clsql](http://clsql.b9.com/) supports using sqlite as the backend, has some ORM features and you can use SQL.
As the originator of cl-linq, I stopped working on it. cl-linq will be fine for quite small N, (say, under 100 rows). This is entirely adequate for certain kinds of queries, but for other ones, entirely useless. I transitioned to working on a New! Improved! Better! system, which I am considering turning into a product.
Thank you for the update. Does the new system have a public facing repository yet?
Perhaps a little assertive, but that's all right, it cuts to the chase and it is thought-provoking, if not inspiring. Also, it clarified quite a few things for me. Very nice. Exciting times for Common Lisp, once again. Thank you.
Obviously a lot of effort!
Parenscript is *not* primarily a compiler for a subset of common-lisp into javascript. It is much closer to a s-expression frontend for javascript with some shims for making a restricted subset of common-lisp compatible.
for types: https://bitbucket.org/tarballs_are_good/cl-algebraic-data-type
Very informative, and a very beautiful web site too! Also, I've been playing with Parenscript recently, and found it to be quite impressive. It can compile my entire compact genetic algorithm code with various loop macros, which in total is quite complex, into a Javascript file, all without any need for me to modify the original source code.
Thanks!
On markup languages: There is still some disagreement on *how* json should be serializaed/deserialized, which is part of the reason why there are so many json libraries. Also, while plump, as a lenient parser, is a good choice for xml-ish markup languages, something like cxml is much better if you actually are using some of XMLs features that aren't duplicated in json/yaml/&amp;ct.
Interestingly is working for me with iceweasel on debian testing. I have emacs key shortcuts though (So hitting C-s).
You can use the resource like bountysource to do this(crowdfund some parts), I'll definitely participate. Just advertise it better for the community to know.
Mainly it gives you macros, which I always loved.
cl-json is not bijective for primitive values in that NIL on the lisp side corresponds to null, false and an empty array on the json side. Going from lisp to json, NIL becomes null. Empty array becomes empty array, but that breaks the convenience of mapping lists to arrays. Not sure how to get false. Going the other way, you get a NIL, was it a null, false or an empty array? Its worse when it comes to nested cons-based lisp data structures which can be interpreted in different ways. Then there's name mangling. I think cl-json could do a better job of untangling all this, but the two formats have semantic differences that make it tricky.
I use yason with decoding JS arrays to lisp arrays, JS objects to hash-tables and JS null to :null this is bijective.
Yes, st-json and yason were close, but I was not completely happy with it. It is true that the parsing is bijective with that configuration but, I think it was not used for encoding. Is it true? In that case, a library with that mapping by default for encoding/decoding would be nice. 
Algebraic Data Types (ADTs), and in particular the implementation from tarballs_are_good, are quite useful and are orthogonal to CLOS. Consider a complex type (i.e. with sub-types). Code to handle the type involves some mechanism to invoke different code depending upon the sub-type. Common mechanisms include case statements and/or specialized methods on generic functions. It is sometimes easy to forget one or more sub-types when writing a given handler. Case statements and/or generic methods don't know about the complex type, it exists "only in the programmer's head", and can't help identify missing sub-types. ADTs offer the benefit of compile-time errors for missing sub-types within a handler. Thus, a large class of potential bugs can be found at compile time, where previously that was impossible. 
&gt; Why is GPL seen as a bad thing? (The "sadly..makes it GPL" comment) The GPL is hostile to the processes of capital accumulation and concentration of power. This naturally inspires hatred in capitalists (Microsoft, Apple, Oracle, et al) and sycophants (wannabe startup CEOs and their lackeys).
The first line should've summarized what Sly is, for those of us who were not familiar with it.
The tarballs_are_good ADT library has syntax allowing what you describe. 
Does Slynk retain Swank's wire protocol? I'm asking because I wrote [a client](https://github.com/eudoxia0/lime) for Swank. 
Ah OK, that makes sense, too. Look at my other project, [snooze](https://github.com/capitaomorte/snooze) for writing functional REST APIs (also quite beta hehe).
I was about to reply that WS wouldn't offer much of an improvement, then realized -- of course I have to use WebSockets, Slynk will write text to the output streams asynchronously and I have to send that to the client as it arrives. I've played with [hunchensocket](https://github.com/capitaomorte/hunchensocket) in the past, and will probably be using that.
Off the top of my head, yes everything there works in Sly. However, if I would recommend it over slime for a newbie depends on the emacs proficiency of said user. Setting up slime after installing quicklisp has an easy to follow way. (ql:quickload :slime-helper) and follow the instructions. For sly you have to copy the repo to a directory in your emacs path so you can M-x sly. The easiest way to do that would be adding (add-to-list 'load-path "/path/to/sly") to your init.el The improved REPL interaction, C-r for recursive history search and ELI-history would help a newbie in the REPL imho.
Might be worthwhile to mention (from the contributor page): &gt; SLY can be loaded alongside SLIME both in the same Emacs or Lisp image. As well. I'm significantly more likely to try it out than I would be if I thought it would conflict with my my swank/slime installation. 
informatimago uses [AGPL](https://www.gnu.org/licenses/agpl-3.0.html) which is even stronger (if you use it in on a web-server, you need to release your code). It is pretty clear the affect of GPL on lisp code. See [Why CLisp is under GPL.](http://clisp.cvs.sourceforge.net/viewvc/clisp/clisp/doc/Why-CLISP-is-under-GPL) It has even been argues that LGPL has the same effect because lisp libraries are not statically linked. Hence LLGPL exists. CLisp itself added to its copyright notice the ability to code your program without being subject to GPL (see COPYRIGHT file of CLisp).
I did as the last headline, but you are right that I should have probably put more emphasis on that.
You've uncovered a bug, thanks :-) Pressing the Enter key should do the default action for that butotn. But I never press Enter itself, I use C-m to send `RET`. ~~I'll fix this~~. EDIT: fixed Meanwhile I can also suggest you use "backreferences" in the REPL. These aren't documented anywhere yet sorry, but type CL-USER&gt; (values 1 2 3 4 5) 1 2 3 4 5 CL-USER&gt; (values "bla" 3 'foo) "bla" 3 FOO CL-USER&gt; #v7:2 in the REPL. #7:2 is a stable backreference to `FOO` in this example. These backreferences are also produced automatically when you return calls to functions (not just function args) from the SLY-DB debugger or from the Trace Dialog. You do that with M-S-RET.
It am still developing it. Most support tends to happen over email rather than the issue tracker. If you have any questions feel free to reach out.
Very cool!
&gt; The easiest way to do that would be adding (add-to-list 'load-path "/path/to/sly") to your init.el Another easy way is via [el-get](https://github.com/dimitri/el-get)`(el-get-bundle capitaomorte/sly)` or via package.el (http://melpa.org/#/sly)
Too bad the book is in Russian. Looks like a very interesting book.
Nicely done, ECL team! I'm so glad this project is back on track.
Teclo is still going, jsnell has blogged about it very recently - https://www.snellman.net/blog/archive/2015-08-25-tcp-optimization-in-mobile-networks/
HotSpot optimizes JVM bytecode and not Java functions. The bytecode output by Clojure is optimized exactly the same way as one output by Java. This is also why any benchmarks done for Clojure have to be run multiple times to get proper results in order for HotSpot to warm up.
My original `timer` library was sbcl-only because I didn't want to port the threading part of it. I (you?) might be able to adapt it to bordeaux-threads without too much hassle, to make it portable.
I wish my knowledge of CL would be that advanced, it would be an honour to work on one of your libraries. I have found [cl-cron](https://bitbucket.org/mackram/cl-cron/src) uses bordeaux-threads. Would that be enough for portability? The code does not have many comments.
Very nice, I could build on that. Thank you for the pointer.
It's just code, nothing all that advanced. cl-cron sounds promising.
Yeah, he seems pretty into the snabb project. Twitter account: @lukego Snabb Switch designer and open-source networking guy. Grindelwald, Switzerland snabb.co ps: his webpage says he's and Australian, now Swedish living in Switzerland aka an ...
Track master
Thanks. I tried sly maybe 6 months ago but not for long; it seemed buggy but perhaps it was some interaction with my slime specific settings. I've just loaded it up from master and was asked: [sly] SLIME detected in `lisp-mode-hook', which causes keybinding conflicts. I can see why this would be the case, but I've a bunch of other more-or-less slime specific things on that hook which it didn't remove. I could write a command to switch a lisp buffer between sly and slime, but given that automatic instrumentation of lisp buffers is so nice, is there some best practice to switching between slime and sly with ease?
A different take on the same subject: http://lisp-univ-etc.blogspot.com/2013/01/real-list-comprehensions-in-lisp.html
Nested loop comprehensions should probably use NCONC rather than APPEND.
mapcan uses nconc, not append. 
I'll add a remark about `mappend` (which, strictly speaking is a generalization), thanks.
It has deprecated sb-thread:destroy-thread in favor of sb-thread:terminate-thread. sb-thread:terminate-thread was created for this purpose 10 years ago, so there's been time to adapt, but some programs still use the old function. http://report.quicklisp.org/2015-09-01/failure-report.html has a list of Quicklisp project failures, some of which are related to this issue, some of which are different.
Great, good to know!
Okay. I went to look for the files but apparently the relevant USB drive and my Macbook aren't on speaking terms. So in the interim while I debug that shitstorm, do you happen to know of a good site to host streaming versions on? (I have webspace where I can host non-streaming versions...) vimeo.com has the highest quality that I'm aware of, so seems like it would be good for screencasts...
Maybe you will be interested too: http://cirru.org/ S-expression with fewer parentheses.
TBH, I am not very proficient in the specifics of hosting videos...
http://weitz.de/lisp.html
I really like the code for [cl-ppcre](http://weitz.de/cl-ppcre/). The code in PAIP is also nice. Same with Practical Common Lisp.
Up as of Friday September 4, 2015 @ 7:01 AM UTC. (12:01 AM Pacific.)
Using npm makes it really easy to install and most webdevs use npm so I figured it was a good choice for easy delivery. It uses quicklisp for the build dependencies, which you can see in the short build script: https://github.com/burtonsamograd/sigil/blob/master/build.sh 
Thanks! If you ever get the urge to write up your process, please do. There's always room for more good common lisp articles online :)
It happens that the code in [SICL](https://github.com/robert-strandh/SICL) is written in a rather outstanding quality. It even features a portable Lisp compiler named [Cleavir](http://metamodular.com/cleavir.pdf).
What do you think about Hy, the lispy python, and Elixir ? Elixir is FP and allows lisp macros.
Definitely [cl-ppcre](http://weitz.de/cl-ppcre/) and [vecto](http://www.xach.com/lisp/vecto/) are a pleasure to look at.
What I've seen in `lparallel` I've liked quite a bit. The good: * Consistent style * Surprising things are commented / documented * Top level forms kept to modest size * Exported things have docstrings * [Webpage](http://lparallel.org/) as blog / users guide / manual * Edge cases are thought through and discussed * Code sectioned with ;;;; comments I'm less happy with some of the wrappers around built in functionality (for example a `defslots` abstraction that can be either a class or a struct). That's not to say it's wrong -- these sorts of things can be useful for maintaining some of the goals I mentioned above, such as the modestly sized top level forms -- IMO they are usually a trade-off between doing exactly what you want succinctly and adding overhead for readers (they have to learn the new abstraction). `lparallel` manages to be more tasteful than most libraries who use a similar wrapper style -- for example `unwind-protect/ext` may be more likely to make you wish it was the version in the standard than to confuse you. I also like xach's code. I recently [recommended](https://www.reddit.com/r/lisp/comments/3gtpkf/procparse_a_stringoctets_parser_library_for/cu42t5u) `quicklisp-client` as a good example of lisp code, although others had the opposite opinion. You wouldn't go wrong to check his github account and if he has a library that you find interesting read it.
Is this for real? I've never though of LISP as a replacement for the typical LAMP stack, but why the heck not! I would totally run a full LLLL stack.
Will this book be completed? Unlike the previous one?
Which previous one? 
So from curiosity, what do you use for SSL termination ? As this is something I am about to do I am interested :) 
http://lispwebtales.ppenev.com/
I'm the wrong one to ask, since I'm a maintainer of mongrel2, that's what I use. A lot of people use nginx from what I can tell.
Will buy on general principles
The web site appears to be down.
There is apparently a second 2007 edition (in French.) http://paracamplus.com/spip/?page=livre&amp;isbn=978-2-916466-03-3 I don't read French, so I can't say much about it.
I use this one https://github.com/jasom/mymongrel2 and a clack backend I wrote that I need to post to github (I'm out of town right now, maybe Monday?). However, galdor's code looked solid last time I looked at it.
You don't like current ORMs ? Like Integral http://eudoxia.me/article/common-lisp-sotu-2015/#databases (Just asking for my information)
What's `linear-fractional-transform` ? The implementation isn't in the blog post. Is it part of Common Lisp?
I use postmodern or cl-redis. Either way the database is not written in common lisp.
Great, another TCL/TK abomination, just what CL needs. You'll drive more people away from CL with this than ltk, cl-gtk2 and mcclim combined. It's 2015 people, get your act together, if you can't do it properly, don't do it at all. 
inb4 we don't need good looking IDEs, because the Worthy don't care about such trivialities
hey tks. Nginx was certainly on the radar. though I am now looking at mongrel2. Cheers
A UI is better than no UI, and it appears to allow him to move forward quickly. Later the UI can be replaced. The only tk app I've ever used was aMSN. and it didn't look pretty even in the spartan OpenBox I used at the time.
so what would be "properly"?
Never used ltc/tk myself but I guess if he used gtk3 it would give the user more user themes to customize the look. Would be kind of cool if cl had it's own cross platform GUI framework like lambdanative.
Does GTK3 offer cross-platform experience compared to GTK2? Qt seems to be a better way to go. However, common-qt does not support the latest Qt release yet.
&gt;Later the UI can be replaced. The Swank client is written in Tcl. I very much doubt the UI will be replaced.
Well, perhaps this is "not proper" and based on an "abomination", I don't know. But I still applaud at this effort, or any other CL effort, misguided or not. The author – whoever s/he is – may certainly benefit from knowledgeable suggestions, but s/he does not deserve all the negativity of this thread.
You could try ECL! I've used it to build small(ish) executables before. It compiles CL to portable C, which can then be compiled on most platforms. It can be linked against ecl.(dll/so/etc) which on my Windows machine (mingw-compiled) comes in at a whopping 6mb. ECL runs just about anything that CCL/SBCL run, although if I remember correctly I reported an issue a while back where in Windows it was using the wrong calling convention (`stdcall` vs `cdecl`) when calling CFFI. Not sure it ever got fixed, or just lost in the shuffle when they moved the project. Definitely worth a shot for your use-cases.
Racket! 
Can someone explain what this is going on about? CL is not unix, so does not have the $HOME environment variable nor the #\\~ based syntax for it. The only thing I can think of is the ~ based format string args, but that is nonsense here. This has 7 points, and is not really about lisp *per se*. Am I missing something? Is USER-HOMEDIR-PATHNAME not the correct way to determine "the pathname that corresponds to the user's home directory" I need some coffee, maybe that will help my mind work :)
ECL on Windows works best with MSVC compilers, since they are native (resulting also in smaller executables and less DLL dependencies).
Here's what I use, though it depends on two things that aren't in quicklisp (my mongrel2 handler implementation, and the tnetstring implementation) https://github.com/jasom/clack-handler-mongrel2
I'm guessing then that you've dismissed [cl-launch](http://cliki.net/cl-launch) and things like it which require very little in the way of a baseline environment set-up? Certainly not much more than Python or Java....
I agree that the community could be more positive in general, but it helps to remember that the adjectives are referring to software, not the authors.
 $ cat hello.c #include &lt;stdio.h&gt; int main() { puts("hello"); return 0; } $ make hello cc hello.c -o hello $ ./hello hello $ alias la='ls -la' $ la hello -rwxr-xr-x 1 xxx xxx 8500 Sep 7 12:57 hello 
Lispworks. I know, it's not free - quite the opposite, actually. Yet... Last month I developed a calculator that edits 32-bit values, different bases, single bits and bitfields, with a simple GUI. No rocket science, but much more code than in a "hello world". Delivered as a 6MB standalone executable, thanks to tree shaking.
Is Qi the original name of Shen?
It's "positive" comments about somebody else's effort that have led us to this mess. Sometimes, what's gotta be said needs to be said. If one can't take legit criticism to heart and use it to become better one shouldn't be seeking it in public forums. 
You may find it helful to know how ASDF and Quicklisp can help you build executables, which is particularly handy for GUI programs: if you have `smokeqt` libraries installed, running `(asdf:oos 'asdf:build-op :qtools-helloworld)` in a new instance of SBCL or CCL builds a new GUI application.
I'm glad I'm not the only one who thought so. I really liked how quicklisp built on top of ASDF that way.
I am a lisp fan, not a lisp expert. On the other hand, I am a C expert, but not a fan of C. So, Python has PyPy. So doesn't lisp have LispLisp? I am sure I've heard stories of Lisp compilers from back in the day. Not just a Lisp to C, or Lisp to Java, or Lisp to JavaScript, Lisp to LLVM, but a full-on Lisp compiler, generated and optimized by Lisp to assembly code. And, are not a lot of the key parts of GCC written in Lisp? I'd like to go from writing your Lisp code to compiling to your assembly code. And in the process, ditch my C code altogether. :)
Hey, I'm the author. Thanks for posting! Just as a heads up this is still heavily a work in progress (and it may not even work completely yet). The goal is to be able to target versioned dependencies from remote sources or the [Qi Manifest](https://github.com/CodyReichert/qi/blob/master/manifest/manifest.lisp), on a per project basis. It will work alongside Quicklisp (and thanks /u/xach, the Quicklisp client source was a big help), but it's is not required to have Quicklisp installed. Anyone can make their library available (just send a PR). Anyway - there's still a lot of kinks work out and a [big list of things](https://github.com/CodyReichert/qi/blob/master/docs/TODO.org) I want to do, but any feedback, PR's, or issues would be greatly appreciated.
This is something I'm definitely wanting to make better. Writing out your dependencies twice is not great. Extending the ASDF configuration would be ideal. Does anyone know of good resources for doing so?
it contains lots of local copy of libraries... I kinda feel like saying "pseudo standalone". For library versioning, there is (qlot)[https://github.com/fukamachi/qlot], a Bundler of Ruby or Carton of Perl. It is also roswell-compatible --- It provides useful command line interface from the shell, which can be installed via roswell.
The experience of Ron Garret at JPL and Google is a good counterpoint to unalloyed Lisp advocacy. Lisp may be a local maxima; the debate among those who understand this is about the lay of the land around it and where other maxima are to be found. http://www.flownet.com/gat/jpl-lisp.html
This is what CCL and SBCL do, they generate native code. 
There's a *predecessor* which is also worth reading: Anatomy of LISP, by John Allen. 
The title's changed, but the table of contents seems to be much the same as my copy of Lisp In Small Pieces, which was originally published in French as *Les Langages Lisp*. 
Interesting, thanks!
&gt; And, are not a lot of the key parts of GCC written in Lisp I do believe GCC uses a lisp like language to describe machine targets https://gcc.gnu.org/onlinedocs/gccint/Machine-Desc.html
&gt; Anatomy of LISP, by John Allen Oh I didn't know it was. Thanks for the tip ! ps: of course, many are mentioned on c2 http://c2.com/cgi/wiki?ImplementingLispDiscussion 
Of course criticism is important too, but ever heard of something called "encouragement"? I think that posting to CL forums should not be like throwing oneself into the holy fire that purifies from technical sin. Because otherwise, the real "mess" we should worry about, in my opinion, is lack of users, not UI toolkits. [this was part of my lifelong campaign for the promotion of Common Lisp Friendliness, sorry for the inconvenience]
&gt; The Worthy are using Emacs and the newbies should be doing the same I agree, just learn the basic emacs commands (open, save file, cut/copy/paste, ...), get slime, sbcl and quicklisp running, and you're good to go. In fact, I feel that a pre-built binary with this setup is more useful than any windowed IDE
You seriously named your package manager after another dialect of lisp? What's next, a package manager named elisp? Smart.
I think you got the concern backwards. The OP is completely happy making users install a runtime, so long as that means they can distribute tiny executables.
1 year is really not that old in the common lisp + emacs landscape. Common lisp(edit: "Lisp" not common lisp. As /u/drewc says, Common Lisp is from 1984) has been around since ~1950s and emacs since 1976. I'd say anything updated in the last 3-4 years probably still works in modern emacs. Common lisp i'd argue more like 10 or more years but I don't have the experience to say for sure. Edit: Correct that to say "anything simple (like most refactoring tools) made in the last 3-4 years probably still works in modern emacs". There are some underlying emacs changes lately, but I think a variety of code doesn't care about them.
&gt; Common lisp has been around since ~1950s No, 1984. Common Lisp (CL) is a dialect of the Lisp programming language. In 1958 there were no dialects, there were no compilers or interpreters and it was not used as a programming language *per se*. It only existing in paper form, "Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I".
Thanks, lispy looks interesting. Much more comprehensive than smartparens and paredit
Not a problem, consider it a compiler "style warning". If I am DECLAIM'd a major pedantic optimisation, you are wrong here as well. "Lisp" is a very modern term. In 1958 'till around 1970 or so it was all capitalized as "LISP". A lot of older literature refers to Common LISP, though ANSI Common Lisp goes ahead and lowercased it, standardized. CLtL1, CLtL2 and ANSI CL are different dialects of Lisp as well... though they do have one thing in "Common". :P (just having my first cup of coffee, so really just being pedantic to use up my newfound brainwaves. Hope it was as fun for you as it was for me)
A lot of programming languages have a method that will expand pathname symbols like ~. See http://ruby-doc.org/core-1.9.3/File.html#method-c-expand_path for an example. I imagine the person wants a method like this and is confused as to why it doesn't exist.
Sorry I should've said "harsh", not sarcastic. I might've had a wrong impression but it sounded somewhat harsh to me.
Ah, that makes sense. /u/bitwiggler : http://xach.livejournal.com/179622.html is one way.
So, what you are saying is that the descendent of Lisp 1.5 is Maclisp, and the descendant of Maclisp is Common Lisp, correct? I have a father, and did not magically appear in 1978 (giving away my age here). That said, I was not around in 1977. My Papa was ... So, like the lineage of plants, animals, ideas, and programming languages themselves, there are times when they are 'created' ... and then, begat betgat begat begets something in "common" with the backstory. I do not think that procreation or generation is magical *per se*, but I do believe that it happens. 
Is there a reason to prefer python style for-loops over lisp-style LOOPs?
If you want extensible loops, look at iterate (https://common-lisp.net/project/iterate/)
Python iterators aren't in my brain cache and I haven't used djula so I may be worse than the "rubber duck". I think you don't need syntax for range or zip; functions should work fine for them. For the loop I would be tempted to go with syntax analogous to `dolist` if that's powerful enough for your case. (I like to mimic built in macros in syntax and naming when possible because it helps me remember what they do and how to write them. It could simplify what you are doing if you don't need parallel stepping of multiple iterators. Your form does have the benefit of mimicking the template, though, if I am following.) I think lines 21 (iteratorp), 127 (iteratorp), and 141 (stopping on `do-not-stop`?) of the draft have typos, but I didn't run it. I'm playing around with the ideas for handling both iterators and forms that could become iterators. I think you might want to create some sort of `ensure-iterator` function, and arrange for it to be called once on the `cdr` of each `parsed-clause`, and re-use that result (probably bound to a `gensym`) in each `m-v-c` in your `for` macro. My intuition is that `ensure-iterator` should be called at run-time because the object has to exist, and that if you want an error for non-iterables it could be signaled by a default method on `iterator`. If you take this path, you won't need `eval`. After reading your code I rewrote a generator I had on hand, here's what I'm thinking: (defgeneric next (iter) (:documentation "Return the next element from iter or signal iterator-finished")) (defgeneric iterator (o) (:documentation "Create an iterator over the object. Iterators must have an applicable `next` method.")) (defun ensure-iterator (o) ;; does this always work? (if (compute-applicable-methods #'next (list o)) o (iterator o))) (define-condition iterator-finished () () (:documentation "Conditioned signalled by a iterator when it is finished.")) (defmacro do-iterator ((sym iterator &amp;optional ret) &amp;body body) "Like dolist but for iterators" (let ((gensym (gensym))) `(let ((,gensym (ensure-iterator ,iterator)) ,sym) (handler-case (do () (()) (setq ,sym (next ,gensym)) ,@body) (iterator-finished () ,ret))))) example: (defstruct vec-iter vec (current 0)) (defmethod next ((o vec-iter)) (if (&lt; (vec-iter-current o) (length (vec-iter-vec o))) (prog1 (aref (vec-iter-vec o) (vec-iter-current o)) (incf (vec-iter-current o))) (signal 'iterator-finished))) (defmethod iterator ((o vector)) (make-vec-iter :vec o)) (do-iterator (s #(#b1 #b10 #b11) 4) (print s)) edit: hmm, the above ignore the possibility of the `reversed` argument. 
This might actually be a nice introduction, but using a high-level-language like Racket, I do not really consider it surprising that it is possible to implement a lambda calculus with a few additional features. It would be, in my opinion, more interesting to try to start from pure assembly, and then slowly develop more abstract languages. Still, no offence. It is a nice post. +1
Awesome. CCL is great on Raspberry Pi (for fast compilation speed).
Looking at the first response I got, and my reply to that, I have to ask a question. What precisely did I do wrong? I asked what the question was going on about, and if I was missing something. It turns out I was, so I pointed the OP to something whereby the CL pathname system is patched to use ~ in SBCL. So, I was the first to respond and ended up answering the question as best I could once I was given the actual task. Is this improper? I would very much like more people to learn lisp, and apparently I am the problem, so if you could please tell me why that would be appreciated. 
The point is the lack of consistency between implementations on both some variables.
Ah, ok! Well, those differences are somewhat consistent, if that makes any sense. What you actually desire is somewhat impossible, but at the same time [ASDF](https://common-lisp.net/project/asdf/asdf.html) is kinda/sorta what is generally used, portably. If you want the ANSI standard version, you are stuck with [systems](http://clhs.lisp.se/Body/c_system.htm) as defined in CLHS. As luck would have it, the portable version of LOAD is [REQUIRE](http://www.lispworks.com/documentation/lw70/CLHS/Body/f_provid.htm). I know that SBCL uses ASDF for REQUIRE, hence my pointer to that comes first. **TLDR:** ASDF:LOAD-SYSTEM 
To be clear, I didn't write this blog post. Thanks for the links though, nanolisp looks very interesting!
Related prior work: https://common-lisp.net/project/sequence-iterators/
Qi is the original name of the shen programming language
Oh, what the h.. was I thinking. I mistook you for /u/CodyReichert .. sorry.
You're just part of the problem.
what a beautiful idea. An improvement would be stop world only on memory full.
This looks really cool. I'm going to have to play with it on my raspberry PI. Edit: Sorry for the useless comment but I just wanted to show my interest. At work, so don't have time to read through everything yet :).
That might pick people's curiosity to read the thread so no problem ;)
I don't think there are many practical implications. It's just neat that it's possible.
Given that gnu make already supports [guile integration](https://www.gnu.org/software/make/manual/html_node/Guile-Integration.html) any real life example would be better off using guile instead.
The point ? what about this https://news.ycombinator.com/item?id=10221515
Neat. But I'm curious. What's the advantage of this over C-x C-f foo.lisp?
Quicklisp project source info is recorded in files like `&lt;base&gt;/quicklisp-projects/projects/vecto/source.txt`. I'm going to use this hook to do (ed (source-file 'vecto)) in the repl instead of trying to enter the whole path in emacs.
Functions aren't evaluated at compile time but macros are expanded at compile time. Because of this, the functions you define aren't loaded when *define-class* is expanded. You need to wrap the function definitions of *make-standard-slot* and *symbol-&gt;keyword* with *eval-when*: (eval-when (:compile-toplevel :load-toplevel :execute) (defun symbol-&gt;keyword (symbol) (intern (symbol-name symbol) :keyword)) (defun make-standard-slot (spec) `(,(car spec) :initarg ,(symbol-&gt;keyword (car spec)) ,@(when (not (or (member :accessor spec) (member :reader spec) (member :writer spec))) `(:accessor ,(car spec))) ,@(cdr spec))))
btw, your report is deficient. You talk about "the above code" not working but it does not include a top-level usage of define-class nor a macroexpand thereof. We are guessing at what you really did from the error, but macrology (you are learning) is intense enough at first that you do not want to make sloppy reports. The details are vital. hth.
I used to think that that was the case, but it is not. If you have a fileB which depends on fileA, ASDF will compile A, **load A**, and then compile B and load B. I think it is necessary because the standard does not ensure that macro definitions spans multiple files: &gt; If a defmacro form appears as a top level form, the compiler must store the macro definition at compile time, so that occurrences of the macro **later on in the file** can be expanded correctly. Users must ensure that the body of the macro can be evaluated at compile time **if it is referenced within the file being compiled**. It is not the case in SBCL, where compile-time macro definitions affect to the environment globally, but it seems to be the case in other implementations (CCL maybe?) 
If you always have the same options for all slots in all classes, you're not using CLOS very effectively.
The trick is nice but you could have defined a function in Emacs for that or something similar too.
Ha, this is a Trojan too? :-)
[7 reasons to buy Symbolics Genera](http://kremlin.enterprises/image/129586823735)
[25 ones!!](http://www.symbolics-dks.com/Genera-why-1.htm)
See an updated image [here](http://imgur.com/85wX44R), fixed thanks to comments here that said something was wrong. (1) draw a tree (2) use abreviated symbols for built-in functions (3) use text height to indicate nestedness I've mixed and matched these three ideas in the drawings. Note that (1) and (3) are mutually incompatible. [X-posted](https://redd.it/3lwnly) at /r/conlangs and /r/ProgrammingLanguages
It use cl-collider(supercollider client for CL), and cl-opengl, cocoa(with ccl). I try all graphics functions port to web base(use parenscript, clws) for run on more wide platform,environments. so currently I study to glsl with varjo,CEPL. Already exist which many tool for media artist(Max/MSP, Ofx, Processing etc) but least to me CL is best weapon for all my works. 
Don't post this to any Python-related forum. They'll either get it and hate it, or get it and implement an editor that requires it. Either way would be bad.
I asked because I remember that Perl's POSIX module does not even implement scanf; the documentation says to use regexps instead.
Does the third even require the parens? :o
I think CL version of scanf should have similar syntax to FORMAT control strings. A fun exercise is to support as many format directives as possible.
oh boy, here we go again. New guys reinventing Lisp inspired by a Lisp wannabe.
Yea I do a lot of coding for this kind of thing, but I'm scoping out Lisp tools because I want to learn Lisp within a graphical environment.
Christophe Rhodes has the tongue-in-cheek (setf (format ...) ...) implementation here: http://jcsu.jesus.cam.ac.uk/~csr21/format-setf.lisp
What is RDz interview COBOL?
What dialect of Lisp is that? In Common Lisp, you cannot have an unquoted atom unless it is "t".
It is easier to use and easier to understand. Sometimes it might even work faster.
Thank you, I'll look at that.
What does this do?
Additionally, some kind of symbol that always occurs wherever the line height changes is useful for readability. To see how, consider if we removed the parens. It is harder to see the height of a single line, because doing so requires familiarity with the font.
Yeah, that would make implementation portable and easy to learn to edit. Part of the problem with Smalltalk-72 and APL is that their text actually incorporates non-askii symbols, making them less portable and less easy to learn to edit than modern askii-only programming languages.
I don't think an editor can require this, because the underlying text is the same; the only thing that is different is how the text is displayed. I do get that you were joking, but just clarifying anyway. Edit: If we remove the parens, then it is no longer just a matter of display, and the text height becomes syntactic.
&gt; In Common Lisp, you cannot have an unquoted atom unless it is "t". All those programs programs have unquoted atoms. There is also keywords which are self-evaluating. You are 'correcting' defaultxr with incorrect facts.
Thank you for those links. I need to stick to CL. Also, I would love to keep GUI development in CL, not using Xcode or Android frameworks, to design GUI only once.
Also, don't take my straight answer as harsh (though I see that it could be taken as such); this is a great exercise and a good idea, and I'm only trying to show you how to fix the mistake in it.
Why use delta for lambda?
No, if you look closely you'll see that the cons operation is nested now.
Big caveat on that page: it only generates 32-bit code on iOS. Which means you can't stick anything built with it on the app store; any submissions in the last year+ must be 64-bit.
i don't see how they can justify these prices, are these ppl living in their own fantasy lalaland? Lispworks professional 64bit on osx costs 2400euros + 800euros for this mobile IOS "addon" == 3200 euros (+ 1600euros per year after the 1st if you want support and updates or 1000euros per year to keep using the ios thing). This is crazy-land. This is the same Lispworks that up until Lispworks 6 had a global lock and couldn't take advantage of multiple cores (From wikipedia: 6 January 2010, LispWorks Ltd Lispworks 6.0, with symmetric multiprocessing). This is 2010 people, SBCL, CMUCL and CCL had that stuff ready for years if not decades. What does that tell you? I don't see why Joswig starts masturbating the moment Lispworks gets mentioned, it looks like cheap overpriced garbage aimed at suckers who don't know better to me. The much lauded UI looks atrocious and SLIME blows it out the water any day of the week. Sure hope ClozureCL comes up with an alternative and blow these clowns away. 
I can buy all the CL support I need from nikodemus or clozure associates without feeling like someone fucked me in the ass after.
Unfortunately ECL-android has its [problems too](https://github.com/ageneau/ecl-android/issues/11).
I'm waiting for the day there will be an ANSI compliant compiler to JS (i.e. I take existing lisp code and it works in node). Or does it already exist?
All the alternatives are free, if your time is not worth anything. Which clearly from the history of yammafactors6 posts would seem to indicate. 
(oddp genes)
`(cons 'a 'b)` is not valid syntax in the version of Lisp I am using. (`cons` can only take an S-expression as its second argument.) I am only using the subset of common Lisp that corresponds 1-1 with what McCarthy wrote in the original paper. Also, I don't understand what `(a . b)` means, what it would be useful for.
Not for Common Lisp to my knowledge, but Clojure has ClojureScript. https://github.com/clojure/clojurescript
Except that atoms **are** an s-expression. Also (cons 'a 'b) is a valid expression in McCarthy's [original paper](http://www-formal.stanford.edu/jmc/recursive.pdf) as well. And in any Lisp[0] I know. And McCarthy's paper use the dot notation that you seem unaware of and 'mysteriously' incapable of comprehend despite the numerous explanations. And you keep switching between 'McCarthy's Original Lisp' and Common Lisp for no reason. At this point it is abundantly clear that you are either an elaborate troll or a person with the utmost reluctance to admit their mistakes. As Tordek said, the tree idea is cool. I think to recall that McCLIM had some tree visualizations for syntax. The line idea would run into problems when the expression is too long. One can't break the arguments of a function call each into its own line for example. [0]: This would exclude Clojure, which demands a seq as the second argument, similar to your intent.
&gt; Your comments mention Common Lisp, but it is not exactly compatible with that syntax. For one, CL does support (a . b) (try it in a REPL near you). Right; what I did was look up the CL equivalents of the primitives in McCarthy's paper (which are provided, along with the main contents of the paper, [here](http://www.paulgraham.com/rootsoflisp.html)). I didn't look at what else CL does. Based on what you've just said, my notation is not powerful enough to represent any CL program. &gt; So, now that this is properly established... yes, your notation is correct, since you're using a convention where "the last element to the right is actually the singleton list". This works, but I'd argue it's slightly awkward, since you're effectively representing... &gt; (cons 'a (cons 'b (cons 'c '(d)))) &gt; So you're making the last element special. I don't know what you mean about a singleton list, but your code is certainly what I'm representing. Though, there is no good reason for me to make the last element of a list a right child instead of a left child like all the others are. I made a new notation today that seems more consistent to me: [Here it is.](http://imgur.com/XmcJVEN) Does this new notation support the addition of `(a . b)` without introduction of ambiguity?
It's definitely outdated. It's about a year or so old, and the current version is 1.2.15. I'd recommend downloading SBCL directly from the official web site. That way you can make sure you're always using the current version.
I'm still using 1.2.8 I installed half a year ago for no obvious reason but the effort of downloading &amp; upgrade. and there seems no problem with it. 1.2.4 is fine. It's better than 1.0.56 in ubuntu :)
Hi, I tried this yesterday. I get this error: `#&lt;DRAKMA:PARAMETER-ERROR "Don't know what to do with name/value pair (~S . ~S) in multipart/form-data body." {D210021}&gt;.`. Here is how I modified the second function: (defun upload-image-from-file (path) (let ((binary (alexandria:read-file-into-byte-vector path))) (drakma:http-request *imgur-url* :method :post :parameters (list (cons "image" binary) (cons "type" "file")) :additional-headers (list (cons "Authorization" (concatenate 'string "Client-ID " *client-id*))))))
&gt; Is that too outdated to use? To use for what? For learning basic language features and toying around, it certainly is not. But have in mind that the overall Lisp ecosystem is not actually a part of "Linux", like other languages, libraries and programs are. Historically, Lisp was not just a language, but a whole operating system competitor to Unix, and Unix won, and later windows won. Even if Lisp has been forced by its defeat to even provide binaries for the competing system, the evolution of its whole ecosystem still happens outside and independent of Linux or Windows. So whatever debian provides there, has nothing to do with the Lisp ecosystem. From the point of view of the Lisp ecosystem, debian is irrelevant, and from the point of view of debian, so is Lisp. So in order to be able to boast to have a gazillion packages, they just blindly package *something* and then provide that something to unknown users, not caring what it actually is or how it works or fits with the other tools or who actually needs it. So if after toying around with SBCL you decide that Lisp is so awesome that you want to track the developments of the ecosystem more closely, you will *want* to use the official binaries and sources and ignore whatever the debians are doing there. Installing the official binaries or building them from source is [incredibly easy](http://sbcl.org/getting.html).
For me, readability. Similarly, in Python one would use "".format not "".join for this case.
Thx for the input. I ended up installing sbcl from the repo and using that to compile the newest version from source and installing that. Now I have slime up and running and I'm eager to get started.
Fortunately it's followed by the nicest ones. ) ) )
Google the author, he compiled and wrote a lot about lisp. ps: found about him here : https://news.ycombinator.com/item?id=10279266
Why would you determine what the quickest prototyping language by reading articles and thinking deeply, as opposed to trying out each of the languages? Python has much better library support (numpy, scipy, PANDAS, scikit, etc.). than CL and Racket, for instance.
Well, I am thinking longer term than just the short period I would be trying something out - that is, Lisp seems like a much deeper language than Python and to get competent at it would take a longer commitment than it did to get competent at Python. So it makes sense to ask more knowledgeable people than myself to steer me, to improve the probability I take the correct starting path instead of having to switch dialects later on. Agree that Python has good stats support, perhaps it is better in certain situations.
If you already use Emacs, and you don't like Clojure because it's too functional, you would probably prefer Common Lisp to Racket.
CL: great performance if tuned. Racket: easy to learn and use, I'm unsure if it can beat tuned CL. Clojure: less performance control, interesting concurrency options, dovetails nicely with your current Java chops. 
I am helping snmsts and a bit working on feature comparison of roswell vs others (CIM, buildapp, cl-launch...). Also the documentation. Matter of a week to complete, I guess. 
It's not an answer to your question, but I would recommend to take a look (if you haven't already) at the [Julia Language](http://julialang.org/). It is not a Lisp, but it's parser is implemented in Lisp (femtolisp) and it is homonoical, which makes metaprogramming almost as easy as in most other Lisps. It is certainly influenced by Lisps, but I am missing s-expressions a little bit (you can use them, but it is too verbose to be used in regular coded except in macros). But if you are from a python background, the syntax will look familiar to you. And even though it is intended to be a general-purpuse programming language, Julias's main purpose is high-performance numerical work. The community is very active and there are libraries for most numerical needs (including machine learning). You can easily execute fortran and C code from julia and python modules can be also called with the PyCall module. However, Julia is still very young and still has a many rough corners. New libraries are appearing all the time, but it is still little to what you have available in python for example. Well, if you want a "real" Lisp for number-crunching I would use Common Lisp. I recently got into data analysis in particle physics and I was surprised when I learned that "The Higgs Boson Machine Learning Challenge" was won by a [program](https://github.com/melisgl/higgsml) written in Common Lisp and this challenge was 2014.
Look into Hy if you want invisibly little VM warmup* and access to all existing Python libraries. It's got reader macros and reads pretty much like Python as s-expressions. However, that a language is too functional shouldn't be the blocker here. With (most) Lisp(s) being fundamentally imperative, you can still write things in a procedural style. So what I'm trying to say with that is that I'd still recommend Clojure in part for its concurrency features and Java interop, but also for the friendly and huge community. With that rambling out of the way, I'll say this: Lisps are like podcasts: Whichever one you fall in love with, it strengthens the greater ecosystem. \*as little as Python itself, so very fit for scripting stuff
I like Friedman ok. I think the italics mark variables, special forms are bold roman, and judging by the #f, literals are non-bold roman. I think code set in a variable-width font is attractive and regret that editors aren't designed to deal with it. I also like using italics and so forth for syntax marking rather than rainbow colors. Murata &amp; Ida may be better, but neither picture is exactly crisp, for whatever reason, so it's hard to tell.
Used MATLAB long ago.. never again my friend, lol. Would rather use Python for that sort of thing. I guess I like the idea of DSLs for prototyping - e.g. you could create a macro to have the same matrix type syntax as Matlab. Or if you have a different problem domain try something else.
(A B) is (A . (B . NIL)), not (A . B)
It's taken a while, but this is gradually being developed for more specific uses, for example the latest version is in this android app: https://play.google.com/store/apps/details?id=foam.uavtoolkit&amp;hl=en
The steelcase keyboard folks have one too (a lisp on go). It is what all the kb scripting is written with
TL;DR: your notation is fine (as long as you clarify that the last element is always the singleton list). Improper lists are lists where the last element of the last `cons` is not a `nil`.
&gt;The last element is not always the singleton list; the last element is in fact whatever is put there. Sorry, I was talking about your original notation. If you clarify, in that one, that improper lists cannot exist, then the arguments we had originally are invalid, since you had no reason to be able to implement improper lists. I do prefer this newer notation, however, since the only special case is "don't draw `nil` to the right". --- By the way, you don't need to limit yourself to binary trees; you can express a list like `(1 2 3)` as o / | \ 1 2 3 (If, again, improper lists are impossible), or o / | | \ 1 2 3 nil . A boon of this is that your second notation is that tree with the branches hidden :).
I think you could/should further divide the "impure" category into two parts, as noted in PCL: 1. Recycling operations: Forms that destroy their arguments, like `NCONC` and friends. 2. For-side-effect operations: Forms like `SETF` that you use specifically for their side effects.
Thanks, that's interesting. I'm musing over the idea of also having a package purely for the exception related forms so you could (:use :cl-pure :cl-pure-flow :cl-exceptions). Thoughts?
&gt; Sorry, I was talking about your original notation. I was too, actually. I think that n-ary trees are more readable for small lists, but become impractical to draw when the lists become longer.
The speeds are in different populations - we have 3 speeds times 4 replicate populations to make the science part work, half the replicates for mice players, the other for touchscreens.
I liked the honesty of the author in admitting that what he created isn't particularly novel, and that he created it for historical personal reasons, but that other people might find it useful anyway. Too much software is overhyped as being completely novel.
The difficulty in this is, for me, moving the cursor to the right spot before the bug turns around. I don't have a problem distinguishing the bugs at all. It seems a bit... useless to me, but perhaps I'm missing the point? I also tried it on my phone, but while moving my finger to the right spot is a bit easier, the bugs are simply too small for me to touch them properly.
Did you consider whalesong?
No.
So you think Lisp isn't a good language for it? Why isn't it?
Dude, just make it in whatever lang you feel more comfortable in. Macros would probably be good for you, but if Smalltalk is your thing, just roll with it. Smalltalk happens to be one of the few languages out there which don't suck.
What does that mean?
It's the version of Java you should use.
You probably know there is no "best" language. Lisp and Smalltalk both have their strengths but Smalltalk was designed 30 years after Lisp and it's just more modern overall. If you write it in Pharo, you're going to be debugging it in a nice graphical debugger. If you write it in Lisp, you're probably going to be debugging it in Emacs+SLIME (i.e., text-based). And Common Lisp tracebacks look like they beamed in from 1960. This can be an advantage for server apps, since remote debugging is a little easier, but debugging Smalltalk is just vastly superior in general. Another way to look at it: Smalltalk is objects all the way down. Lisp has an optional CLOS facility and an optional type system. Very different beasts. With Lisp, be prepared for a somewhat steep learning curve working through Practical Common Lisp and the Hyperspec and learning the various parts of Common Lisp to use. Common Lisp is very messy, being so old. There's lots of stuff that no one uses and it can be [challenging](http://eudoxia.me/article/common-lisp-sotu-2015/) to figure out the [best libraries](https://www.quicklisp.org/beta/) for the job. Since you already know Smalltalk, I'd stick with it.
&gt; I wondered if the language would be clearer if the two functions had the same name but if were in separate packages. IMHO, no. Packages are very contextual, and you essentially have the same problem as with C++ operator overloading: impossibility to tell WTH is that without maintaining a huge mental context.
Do you think Lisp is suited to this problem?
Hi, guys Sorry about the really poor release notes. In my haste to publish, I just assumed people would skip that and go to the README &amp; wiki for more info. In hindsight, that was not a bright idea. Here's the updated release notes, so you can better grasp what's new: * Several bug fixes. * New Leiningen plugin for Lux. * Support for Java generics. * Can now use both Java libraries &amp; Lux libraries in .jar format. * Much better interop with the JVM. * Expanded standard library (see https://github.com/LuxLang/stdlib) * File &amp; line information added to generated .class files for easier debugging. * Text interpolation: e.g. (println (&lt;&gt; "Hello, #{name}#!")) * Improved syntax for working with data-types.
I would be interested to read more about monadic macros. Care to write a blog post about macros in Lux? It would be very much appreciated!
I'm implementing a directed graph based visual programming language, [Full Metal Jacket](http://web.onetel.com/~hibou/fmj/FMJ.html) in my own dialect of Lisp. Graphs are constructed from objects, and the 2d graphics primitives used to display the graphs are built into the virtual machine on top of X11. So you certainly could do what you want to in Lisp. The advantage of Smalltalk is that you have all you need to get started within the one system. Both languages are good. Each influenced the other. I'll let Smalltalk's creator, Alan Kay, have the last word. In [Daddy, Are We There Yet?](http://www.openp2p.com/pub/a/p2p/2003/04/03/alan_kay.html), he said that Lisp is the "greatest single programming language ever designed." Hope that helps. 
Wow, your writing on Full Metal Jacket is very well done IMO. Just earlier today, I [was thinking](https://redd.it/3n63g0) about what Lisp, Smalltalk, Prolog, and Forth did in their respective domains, and realized that I couldn't think of a language that did the same in the data-flow paradigm. It looks like I may have found it. Regarding implementing my project in Lisp: that all sounds good, except for one thing: do you think I'll have a hard time implementing real-time multi-user editing over the web? I know reddit switched from Lisp to Python because of lack of good web functionality in Lisp, so I'm a bit worried. Maybe Lisp has since overcome these difficulties?
Reddit switched from Lisp to Python almost **10 years ago**. See http://www.redditblog.com/2005/12/on-lisp.html TLDR: The web server ran FreeBSD and Cmucl. When off-line, the principal programmer used a mac with OpenMCL (later renamed Clozure CL) with too many incompatibilities (threads). Also lisp libraries were few and incomplete. An unmentioned additional reason was a [new founder was added](http://www.redditblog.com/2006/02/infogami.html). He was experienced python web developer. None of these reasons are really valid today nor have been valid for at least 5 years. Cmucl (\*nix only) is no longer considered a principal implementation choice. SBCL and CCL now run on all major server platforms (\*nix, mswin, osx). Quicklisp has made libraries plentiful, most are rather complete and fairly documented. 
There's a lot of tricky and pragmatic ideas in pixies, I thought it was `yet another lisp` but it really place itself in a nice intermediate high and low level.
You still think it's immature ? the guy behind it seem very very knowledgeable. It doesn't bring you a free field testing but it cast a nice glow of confidence on it.
Can you explain why someone might choose to use CMUCL over SBCL?
Not really, no. You'd have to ask someone who already made that choice. (I chose SBCL a long time ago because its slime support was better than CMUCL's at the time, and never looked back.)
My understanding is that it's less concerned with ANSI compliance, and more concerned with performance. Type inference is more aggressive (at least by default) and it has a number of nice shortcuts for optimization like constant-function declarations and block compilation.
Hi, i'm very new to Lisp. That project is set to work on fluxus, right? I'm looking for this type of editor but to use rather with Overtone and Quil. Is there such a thing?
As much as i think i'd soon get familiar with lisp syntax, i'm a visual thinker: this type of UI would go a long way. It's also particularly handy for livecoding too.
&gt;Smalltalk was designed 30 years after Lisp and it's just more modern overall &gt;Common Lisp tracebacks look like they beamed in from 1960 &gt;Common Lisp is very messy, being so old. *looks at post history* *schemer* Should have known.
I'm sorry--I have no idea! Hopefully someone else here sees your question and knows the answer. If not, maybe you could make a new question-post to this sub.
Here is Common Lisp. (________________________________________________) Here is Scheme. (_) Here is Scheme and SLIB. (____) Here is Scheme, SLIB, and the random SRFI's a Scheme implementation decides to include. (_______03278) Here is Scheme, SLIB, the random SRFIs, and the implementation specific features you get with your particular Scheme. (__________03278%$+-!@#%\^&amp;) Here is Scheme, SLIB, the random SRFIs, the implementation specific features, and geiser. (__________03278%$+-!@#%\^&amp;--)
I look forward to trying out your language. BTW, did you see my PM? I just sent you another one as well regarding the name of FMJ.
What are your underscores symbolic of?
You still need an editor though.
this is a careless hijacking of a "trivial-\*" naming convention. for one there's no semi portable scanf available across implementations, that need a portable api for it (which is what trivial-* is for), so the name is misleading. there's also nothing "trivial" about this implementation, since it depends on a dozen of packages :alexandria :iterate :proc-parse :parse-float :babel.
Similar issue for me. I see them just fine, but the movement means I miss tap, and quick taps zoom the screen on my phone which takes a couple seconds to undo, etc. 
This seems to be the next version of stumpwm https://github.com/stumpwm/paulownia
Without heavy customization, stumpwm and ratpoison are nearly equivalent (ratpoison being the predecessor). You could always try that out since it's in lots of package managers. I mostly use stumpwm sans-tiling in this 1024x768 setup I'm using right now, but rather use it's easy window navigation to flop around my open windows.
It's like having Emacs everywhere.
Wow, thank you for pointing this out! I'm excited now.
Thanks for the hint. It is still not too late to rename it "simple-scanf" or the like. Is this naming convention described somewhere?
indeed, once emacs is running, the underlying system is irrelevant. Hopefully, someone will rewrite stumpwm in elisp.
Well there's also this : https://github.com/ch11ng/exwm... I should really investigate how it is to have a dynamic repl-able WM to see what it brings to the table. Most of it (except overlapping) can be ported to emacs but maybe there are some other ideas.
One of the most inspiring things I have seen recently. Thx for sharing.
Common Lisp? If you're doing GUI intensive things on the desktop, probably not. Not unless you're willing to lay down ~$1500 for one of the commercial implementations that have decent GUI libraries, like Lispworks. Racket is pretty complete in some of those respects. It may work. Then again, so might Pharo. I don't know enough about your problem.
Thanks :). I've been trying to remember the name of NixOS. I heard about it a bit ago and could not remember it's name. Going to look into that as well... looks awesome. Have you played with it at all yet?
Ok, thanks for your input. I'll keep Racket in mind.
I'm using StumpWM on NixOS. NixOS pretty much eliminates dependency hell and you can configure the entire system from one file, but it's still got a few rough edges. They're mostly minor things that you can fix by looking up the problem on Google or asking on the nix IRC channel though. I think that getting StumpWM to talk to an open swank connection with NixOS might be more involved, but I haven't tried yet. I keep a list random fixes and tweaks I've made to it [here](http://danshapero.github.io/nix/2015/08/29/nix-fixes.html).
Pretty much any Scheme implementation will let you run programs from the command line. There are a bunch of options for getting vim to work with (again) pretty much any Scheme. To answer your question directly, I'd probably point you in the direction of: * http://usevim.com/2014/08/27/vim-sicp/ * http://crash.net.nz/posts/2014/08/configuring-vim-for-sicp/ They recommend Racket, but you don't need to use the DrRacket GUI, you can certainly use vi or your editor of choice.
If you do use Racket you'll almost certainly want to use the [SICP language](http://www.neilvandyke.org/racket-sicp/), which makes the book exercises much easier.
Yeah it's my go-to package manager. And my next OS will be NixOS, right now I'm on Linux mint. I'll switch sometime over the holidays when I have time. 
No big dialect giveaways that I saw. It just had strings and nil. It had dangling close parens. Ick. 
Yes, internally groaned at the dangling parens, but that did make it easier to spot in the quick shot of the code. Did you catch any of the other languages? Looked like there were a few non-lisps, but I wasn't quick enough to get a good read.
The non-lisp stuff looked kind of like json to me, but not quite. It didn't look like control structures, it looked more like a data dump. But it flashed by pretty quickly. The Lisp stuff looked like data, too.
I noticed it but it looked like gibberish.
Compare [Allegro](http://franz.com/products/licensing/commercial.lhtml) and [LispWorks](http://www.lispworks.com/support/faq.html#S1Q6) commercial licensing terms. If you distribute an application, LW seems to make it simpler to know what it will cost you (provided you don't need COMPILE-FILE and a few other bits and bobs that are excluded from a "delivered" app).
I could live with developing in a commercial Lisp and building the result with Clozure CL (my go-to Lisp implementation) where it's possible. However, it seems that there is no way to compare both (Allegro and LW) without buying them? Or has anyone done a comparison yet? 
Well I for one am excited to try AllegroCache -- Transparent persistence! Will probably be choosing between that and Gemstone Smalltalk for my next project.
 &gt;Did you catch any of the other languages? Looked like there were a few non-lisps, but I wasn't quick enough to get a good read. Maybe Prolog, I saw some colons. 
Yes! I even mentioned it in the mega-thread (see one of my previous comments) but no one cared! I think it was on the Hermes, just before the crew learns that Watney is still alive.
the .fasl is the compiled lisp which you can load. You can make an executable by saving the complete lisp environment with the save-lisp-and-die function. This is called '[saving the core](http://www.sbcl.org/1.0/manual/Saving-a-Core-Image.html)' but it's not commonly done for small play programs, for that you just load the fasl file or compile/load it in one step. e: oh i see you already did that, i can't read sorry. Maybe specify a path to your home directory instead of the cwd of lisp instead? You can see the current directory with sb-posix:getcwd i believe, the executable should be there. e2: i should add, lisp is indeed different then other languages. The usual way is to do everything from the repl instead of making executables like you would in c/c++. Even when you save a core image you'll get a repl but with all the stuff you loaded into it (well, unless you specify a start function which exits when it's done). Think about it like it's a [lisp machine](https://en.wikipedia.org/wiki/Lisp_machine), the 'command prompt' on such machines was a lisp function and the os was lisp.
Thank you, I'll just forget about Allegro then and save some money for LW. :) Slightly OT: How can you compress cores? UPX fails for me.
The compress feature of sbcl for save lisp and die.
Ah, understood. I've found out how to run the fasl file, and the executable (which is almost 50mb). So I guess I'll be running everything in my emacs then. Do you know how to change the working file directory for REPL? edit: wait, found it [here](http://stackoverflow.com/questions/7735677/how-to-change-sbcls-current-directory). Thanks for the above though, that clarified alot.
Yes the executables are quite big indeed, it's the complete lisp system. There should be a lot of functions in sb-posix for file/dir operations. I think its sb-posix:chdir If you want to change it for each time you run sbcl you can set it in ~/.sbclrc.
If you want to generate an elf or shared library you may be interested in [Embedded Common Lisp](https://common-lisp.net/project/ecl/) 
Okay, so [here is what leaked out today](http://i.imgur.com/pCTYxoE.jpg).
in my .emacs I have: (eval-after-load "slime" '(progn ;... (setq default-directory "/my/projects/dir/") ;... )) Probably through some slime-magic it sets the current working directory of sbcl. this help with open file in emacs and (load file) in the repl.
In slime REPL, a comma begins commands. You can change directory with the command cd there.
Not yet: [Current Status](http://web.onetel.com/~hibou/fmj/Status.html). 
there is no `run` function in common lisp, so I do not intend to give any concrete example, but in terms of *rewriting* a function, it does not actually rewrite a function. It instead creates a compiled machine-code of the function on a heap, then change the pointer in the symbol (*symbol-function*) to the new function. the old machine-code is garbage-collected later.
You probably already know this, but John R. Koza's book *Genetic Programming* used Lisp.
You probably should think of it more as worker thread/functions that are rewritten and a manager that is not. I wrote a genetic programming package long ago for a compilers class project. It was one of the earliest things I wrote in common lisp, but the idea was we had a grid world with energy in it and we were trying to evolve creatures to effectively harvest that energy by randomly generating the "creatures" behavior function, then would mutate those slowly over time by selectively replacing subtrees of the program according to the grammar we had setup. We evolved some fairly effective algaes before the class was over and the next project beckoned. I just put my old class project up on github. I expect it to be next to worthless, but it might inspire some ideas down the way. https://github.com/bobbysmith007/rEvolver/
Be aware that Koza's Lisp code is not very efficient. For a discussion see Kenneth Anderson's 1994 paper *[Courage in profiling](ftp://ftp.cs.bham.ac.uk/pub/authors/W.B.Langdon/biblio/gp-html/anderson_1994_profile.html)*.
&gt; BTW, sometimes the majority is wrong (many examples in history). You mean like when everybody thought animals had always been the way they are today? Just saying. Or were you thinking more of how they used to think the Earth was in the center of the universe, far from the heavens?
Oh good way of putting it. I just wrote a comment that essentially says the same thing before reading yours. It would be a lot easier to have a supervisor that at least runs the forms (even if they are allowed to self-modify) than the have only a form that modifies itself.
Ok. You are correct. I should have been more careful with that one. :) I shouldn't say that the common lisp documentation is bad. It's not -- the documentation for the language itself is quite good. What I should have said is that documentation for the big things you rely on in common lisp that are not part of the core language *can often be* more sparse and generally assumes a higher level of coding expertise. Now before I get shot down hear me out... Take for example talking to a postgresql server. In python this is usually done with something like [psycopg2](http://initd.org/psycopg/). [Here's](http://initd.org/psycopg/docs/) their set of documentation. If I were in lisp I'd reach for something like [Postmodern](http://marijnhaverbeke.nl/postmodern/). I would argue that psycopg's docs are: * targeted more for people who are just starting out. (That's not to say they don't hit all the details for the advanced users -- just that the documentation is easier for the new guys.) * updated more frequently * a bit more polished To be fair I think the last two points are side effects of being generated using sphinx so maybe they don't count. I could also be that I'm just biased. I don't know... The lispy implementation is usually more flexible (so maybe that makes it harder to document comprehensively since you can do more??) and the docs for the python implementation are usually quicker to read. Taking it a step further: If I were in emacs and using elisp then I'd grab for [pg.el](https://github.com/cbbrowne/pg.el) in which case the "docs" are actually in the source and from a newbie's point of view -- pretty skimpy. So let me try again and amend my original statement: *The rule seems to be that with the lispy stuff you get more bang for your buck and the implementation you get is flexible as hell in the hands of an experienced coder but the price you pay is the resulting docs tend to be skimpier and targeted at a more experienced user base.* 
Same here.... My guess is that it's a CL vs. scheme thing but I'm not positive and I think to really explain my feelings on the matter would require a level of understanding that I just don't have yet. On the positive side it seems like the more I try and port stuff back and forth between guile and CL the more I feel like I'm zeroing in on it. 
Do you have the code from your first couple of paragraphs posted anywhere? Sounds cool, I'd be interested to see your solution.
https://gist.github.com/orthecreedence/5629d528db3560321b8f Mind the dust, this is an old project, and I may or may not have followed good coding conventions =]. At least I had the sense to comment some of it.
Some information on Nock: http://urbit.org/home/tree/pub/doc/nock
While not a lisp, Julia is really fantastic and has great metaprogramming support, foreign function interface, async/parallel programming, and it is homoiconic. It is my favorite language for numerical computing problems, and I don't have to write the programs twice (once prototyping, once in C/C++/Fortran). I much prefer it to Octave or Matlab for those reasons. I don't have to waste time vectorizing code or thinking about how the compiler is going to compile the code as two advantages. It is an extremely productive language. I hope more universities will adopt it in the numerical context and drop Matlab. And I don't have to consider multiple byte code implementations like I do with Python. There is also ijulia for writing notebooks in Julia code like one can with ipython. I really love Common Lisp as well (slime is fucking amazingly fun) and if I had to take one language with me on a CS island it is what I would choose. It is extremely annoying that none of the programming competitions will let me you either. 
After you pay the upfront cost it is worthwhile because you are able to write your problem solutions at the same level of abstraction as what the programmer is thinking in. That is why metaprogramming is a must have feature in any language. C has really suffered because of this compared to Rust and C++'s templating can quickly lead to unmaintanable code, even for the original implementor coming back at a later date. 
There are few reasons to use the interpreter, but its there: * (setf sb-ext:*evaluator-mode* :compile) :COMPILE * (lambda (x) (+ x 1)) #&lt;FUNCTION (LAMBDA (X)) {1005E3EE6B}&gt; * (setf sb-ext:*evaluator-mode* :interpret) :INTERPRET * (lambda (x) (+ x 1)) #&lt;INTERPRETED-FUNCTION NIL {1005E53EEB}&gt; On LispWorks, I once ran into a snag: an interpreted closure can't give a compiled lexical variable indefinite extent, and vice versa.
Exactly.
Oh interesting solution, thanks for following up.
Guile is good.
Interesting idea. The coding bootcamps I'm aware of seem to be motivated primarily toward ~~getting jobs~~ filling industry needs. And while Lisp is awesome, I think most people interested it are interested for personal reasons. Lisp jobs are after all, rarer than hen's teeth on Mars. Fortunately, we now have a way to gauge interest in a project/product where people put their money where their mouth is: the kickstarter campaign. Maybe somebody will pick up the ball and run with it. *(though I for one, like my* ***secret*** *sauce being* ***secret*** *alien technology)*
Aww, there there! :)
(still OT, sorry) Exactly, and evidence for evolution is zero (or more exactly: negative!), and evidence for Creation and the Universal Flood is overwhelming. Of course you need to un-brainwash your memory in order to be able to not automatically refuse the hard facts of real science. And you need a good teacher, in order to really educate your un-brainwashed memories... This all implies much time and good will, but it's possible. I'm personally a living example of it!
Don't worry, some of us have caught the bug.
Things like that, yes, and many many others (like the basic error of thinking that electrons were "positive", or the exact opposite naming of "oxygen" and "hydrogen"). We are, in the end, all just guessing, and guessing wrong many times, until we finally, finally get it. We are basically like now mutilated, once perfect human Persons. See also my [other comment](https://www.reddit.com/r/lisp/comments/3nxfmi/new_to_lisp_possible_to_completely_selfmodify/cvutoft)
I started working on a Lisp-based intro to programming taking a "middle-out" approach rather than top-down or bottom-up. I didn't get very far, but you can see the beginnings here: https://github.com/rongarret/BWFP Some day I'll take this up again. If there's expressed interest I'll do it sooner rather than later.
It's called [Else Heart.Break()](http://elseheartbreak.com/) :)
Wow, that looks like my idea of heaven! :O
We did those in the early 1980's. They were usually called "Intro to Artificial Intelligence", and they were aimed at getting people up to speed on expert systems. I was a teaching assistant in classes like that when I was a grad student.
Haskell gets plenty of love too.
&gt; Well, I don't like the idea of bootcamps. We can't learn architectural engineering in a month why is our discipline so different? I would like to take a trade approche. Journeyman and master and all that. I agree that that would be the best approach, but it's not always possible for people who don't live in areas where there are experienced Lisp hackers willing to take on an apprentice. People who live in small towns in the 3rd world, for example. An online, 3-6 month structured curriculum with mentors would go a long way to helping people like these go beyond the usual introductory level and expose them to design, development and testing methodologies, not to mention hard core Lisp skills. I've been hacking in Lisp for almost 4 years for example, but wasn't aware of some of the functionality of the debugger before reading [this](http://malisper.me/). This is because I've had 0 exposure to mentors and other Lisp hackers, my only way of evolving was to hope that someone on #lisp would help me out and critique some code I wrote, or answer my questions. 
&gt; nteresting idea. The coding bootcamps I'm aware of seem to be motivated primarily toward getting jobs filling industry needs. &gt; &gt; And while Lisp is awesome, I think most people interested it are interested for personal reasons. Lisp jobs are after all, rarer than hen's teeth on Mars. I agree, it would be for people who just want to deep-dive (emphasis on **deep**) into Lisp and really learn how to build rock-solid systems with it. I'd still pay for it even though there aren't any job prospects, though it would be a dream to work in a Lisp shop.
Kickstarter is not a bad idea. I'm not really doing it for the money though. I'm much more interested in having people actually read it, use the code, and give me feedback. 
I'd love a condensed 2 year computer science degree conducted entirely online (or maybe do a University of London style program where the student has to show up and pay for finals every year for testing). I've actually been looking at University of London to get my Bachelor's and am a little dismayed that their primary stack seems to be Java (ugh) and Prolog (interesting... I've heard that EU and JP research labs went the Prolog route vs Lisp in North America). Anyway, from my previous computer science classes I don't recall anything that couldn't be taught via Hangouts/Youtube recorded lectures, textbook study/exercises, forum participation, and competency testing and certainly for much less money than what a typical undergraduate degree costs. Heck, I imagine someone clever could figure out a way to do a common_lisp_koans style testing environment to integrate into the curriculum. Anyway, if U of L can offer a full bachelor's (12 courses) for ~$7500, there's gotta be a way to get some of the old school Lispers involved in teaching the next generation. As for jobs, well, as many have said, the things we learn using lisp are applicable everywhere, but you also realize that many of these lispers will "grow up", graduate, and eventually create their own startups, or get put in charge of project planning and hiring. I know for a fact that I'd be highly interested in a lisp based job even at a nice reduction in pay because the work that seems to attract lispers seems more interesting than the stuff I've been doing in .NET. Hey, startup guys, get on this. :) (hell, there's nothing on udemy for lisp (some clojure, I believe), either. You know what would be a great little course? Learning Lisp with Emacs covering: how to get around Emacs, how to customize emacs (which files, how to use the help system, how to edit a basic file, modes, etc) moving into how to set up Emacs for use in lisp development (setting up slime, common lisp, etc), how to actually do development in Emacs (repl workflow), how to debug, how to deploy. Connecting to a running REPL locally and remotely (an interesting discussion about debugging and fixing that NASA satellite would be a great way to introduce this) and how to leverage that into the debugging workflow. And then even a course on actually modifying Emacs as a development platform would be very beneficial. I know I'd be willing to pay for such a thing. And then we can get into lisp itself. IIRC SICP lectures are available on MIT's site, but there's nothing stopping us from making updated versions of this if we wanted, right? 
Oh, don't worry, there's a (very much hated) guy around, who did all the work already, together with many really wonderful scientists. You know, majority is often behind, mostly because of all the stupid indoctrination in our current school system. But even majority will get it, someday... I'm patient!
What about an online bootcamp? This would ease access which would then make it easier to get off the ground. The problem with in-house bootcamps (I really don't like that word) is that people have to travel and really put their life on hold for the duration (I'm thinking 3 - 6 month program). It also represents greater start-up costs for the organizers/teachers, which might prevent it from even starting. The issue I see with online programs is the lack of the learning environment that can only be found sharing the same space as the teacher and other students, which is quite a big drawback, but I think it would be much easier to get off the ground than a resident program, at least in the beginning. Once there is enough interest generated by the online course, a resident program can be offered. Thoughts?
The reason behind the idea that biology is the genesis of information is because life has this way of going against entropy. Look up "negentropy" and related terms for examples. But of course these are all just ideas. I'm just playing around and seeing what sticks, so I could be way off, who knows :)
Do not lie, this language was made/named purely for the loliCons function.
I did see the link. The "wat" was related to the content.
I think cultural differences are something we need to accept in free software. In our culture, we post a work and it stands by itself on its own merit. In that culture, apparently there's a drive to personalize a work as a larger statement. They're basically asking us to take them both as a package when we'd rather just deal with one or the other.
Ah, ok! I really thought you couldn't see the link for whatever reason since it didn't appear in your quote.
Why not [ClojureScript](http://clojure.org/clojurescript)? It's probably the most production worth implementation of lisp in a browser.
you know what? I really hate cloj. May I call it that? it sounds like a perfect match for all of its dumb halfassed function names and language inconsistency for syntatic sugar.
Absolutely. I find myself much more interested in seeing a translation to javascript than I am in seeing an evaluation result. Maybe that will change but that's where I'm at currently.
Cool. I am mostly using sigil as such a compiler -- from a Makefile. Want to take a shot at a comparison?
in emacs with slime, you can load js-expander.el and that enables c-c j to show the javascript translation of a parenscript form (assuming the cursor is at the end of the form).
Rob Pike has a good line: "Making columns line up is a job for machines not humans." His and Dennis Ritchie's programming environments use proportional fonts by default. I use fixed-width, but I like looking at proportional lisp code. https://twitter.com/rob_pike/status/567476552187641856
[**@rob\_pike**](https://twitter.com/rob_pike/) &gt; [2015-02-17 00:12 UTC](https://twitter.com/rob_pike/status/567476552187641856) &gt; @matryer No. Why would I? I don't use a fixed width font for anything else. Making columns line up is a job for machines not humans. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
I actually was talking about serifs, not proportional. Two orthogonal categories. Anyway, as the authority says: «Typi non habent claritatem insitam; est usus legentis in iis qui facit eorum claritatem. Investigationes demonstraverunt lectores legere me lius quod ii legunt saepius. Claritas est etiam processus dynamicus, qui sequitur mutationem consuetudium lectorum. Mirum est notare quam littera gothica, quam nunc putamus parum claram, anteposuerit litterarum formas humanitatis per seacula quarta decima et quinta decima. Eodem modo typi, qui nunc nobis videntur parum clari, fiant sollemnes in futurum.» (From Adobe's *Lorem Ipsum*, itself a pseudo Rudy VanderLans) 
This is a provocative piece. It has been an implicit assumption in the programming community that we are not to concern ourselves with politics. The author of this repository argues otherwise. His view is that, as programming plays a key role in the modern world, it is within our reponsibility to argue for the principles of equality of opportunity and of care for everyone in society. In light of the recent court case where the accused man requested the right to inspect the source code of the software used to build evidence indicting him in the crime, that he may determine whether it was following the correct procedures of genetic forensics, I think that this repository's author raises a very important question for us.
ah, these fp commies. They can only dream on as the wealth of nations is constructed on C++ and the always imperative capital C
Great, because I needed another reason for people to think I'm batshit crazy when I bring up FP.
Why the hell do you keep reposting this? This is the third subedit I personally have seen this and in all of them it got no attention. To be honest it comes across as obsessed and crazy. What the hell does functional programming have to do with socialism and why should we care? Especially why should we care about some random flag some guy on the internet made? You say that it brings up questions but it doesn't. The piece isn't provocative as you claim, its confusing. What is this trying to say beyond socialism is great and so is functional programming? Why are they related? Finally, even if I was a socialist, functional programmer I would still not care about this random flag. I know this comes across as me ranting at you, which I guess I am. I just don't understand why you keep reposting this.
Nothing is disconnected from the world at large -- so what?
Have you looked into https://mitpress.mit.edu/sicp/ ?
just started getting into it having my first play round to night but definitely want to pick up a language over the summer to learn that will advance me for my major. I am just about to install linux as my home os, from windows 7, this journey is gona be fun
Cons cells are just a simple data type. Once upon a time everything in Lisp was made with cons cells, but nowadays we have arrays, hash tables etc. in Lisp as well. Cons cells are still useful for quick exploratory coding, and also because Lisp code itself is made of lists (so, conses). But there's nothing scary with them. Lisp syntax (or rather almost lack thereof) is liberating. Don't be afraid of parentheses, parentheses are an infamous obsession for non-lispers only. Lisp is not really about parentheses.
&gt; however the syntax A syntax is a matter of habit. Chinese seems scary too (at least to me), but little chinese children dont seem to have a problem with it. &gt; idea of con-cells seem scary You have to dinstinguish between "hard" and "unfamiliar". If you know how to make a singly linked list in C, and you probably know since this is 1st yr material, you already know *everything* there is to know about a cons cell. In the C/java universe, they are just not called that way, but are a basic data structure anyway.
try clojure just to play around with something lispy and convenient without leaving the java world
Because it's so powerful? :)
It only seems scary to somebody inside years of habit in other languages. There is absolutely nothing inherently scary about it. If history went differently, it could well be the standard way of writing code.
I regularly wish Javascript had sexp. JSON is ugly and verbose. 
It's not scary. The problem is it's too simple. Everything just blends together and looks the same. A certain amount of syntax is beneficial because it provides visual cues for the human brain. A language just needs to strike the right balance.. too much syntax is overwhelming. Lisp is a meta-language that can be used to create other, more syntactic languages. It's real value is that it serves as a model for computation. You *never* need to worry if a particular feature, technique, or paradigm is possible. Anything and everything in any programming language that you can ever think of can be accomplished, and can be done so using the same simple model of computation. Compare this to C++ for example. It's so hard to figure out if something is even possible, let alone how much template metaprogramming and preprocessor hackery is needed to accomplish it. That's 3 complex and entirely different models of computation, compared to just 1 simple one.
C uses the same syntax for function calls and macros as well.
It's a reason, but I wouldn't call it a major one; the C preprocessor has so many design decisions that all collaborate to make things harder to get right than even a generic text preprocessor like m4.
When I first saw JS in the Netscape browser, the first thought I had was: "Why isn't this Scheme?".
Nothing. People who dread the syntax fear the monotony of having to shuffle parens around by hand. Not one of those people knows what a structural editor is.
C was (perhaps) the first cross-platform, "high-level" systems language to go mainstream. Is it good enough, too?
I am reminded of [Taste for the Web](http://www.xach.com/lisp/taste-for-the-web.html). 
C isn't a lambda language. Closures are kind of a big deal.
But it's a far cry from Scheme. Sure, JavaScript has first-class functions and lexical scope, but there's huge, glaring issues such as 'if' not being an expression, '+' and friends being operators instead of functions, no tail call semantics (ES6 will fix this, thankfully), no built-in persistent data type like the cons cell, no syntactic abstraction, no keyword arguments, no symbols (ES6 introduces the Symbol type but its just not the same), no quote/quasiquote, no 'let' prior to ES6 (in ES5 and below, you have to write out longhand what a macro expander could do) and so on.
WebAssembly will supposedly have an sexp text representation.
Source?
The moment you grab rainbow parens, suddenly Lisp begins making much, much more sense. http://i.imgur.com/TjqTid8.png
What's that emacs theme? 
I didn't say C has closures; I was contrasting the notion that a language's good features, somehow make it "good enough". https://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html What is "good enough" in language design? 
lavender-theme
Of course it's not Scheme. (I've known and loved Scheme ever since meeting it as 'T' in the 1980s.) But **nobody** is claiming that JS is Scheme other than the straw man in Blog Boy's head. I find it tautological going on masturbatory to pretend that anybody actually thinks that it is Scheme. Ugly as it is, JS has the lambda-nature: given that we're stuck with it, I'm quite grateful for that. If only it supported TCO.
I was scared at the beginning, too. The earlier you start, the better for you. Really. Just begin writing Lisp stuff and reading along the way. Be sure to find some time to hack your emacs to your needs; treat it as an usual text editor first, be sure to use the CUA mode to get your ctrl+Z/X/C/V keys in place. Write your defuns, write your basic algorithms, ask around on #lisp on freenode for the basics and less-basics. Just keep on going. You can do it.
https://github.com/WebAssembly/design/blob/master/TextFormat.md
Aw thanks! This looks rather sweet actually. ([Here's](https://github.com/WebAssembly/sexpr-wasm-prototype) the direct link.)
&gt;If Lisp is Radiohead, Scheme is Kraftwerk. Great line, even if he goes on to later prove JavaScript is closer to Nickelback.
Mind you, my link mentions that those are prototypes, and it may even happen that a sexp isn't used at all.
I was just wondering about this yesterday. A friend of mine mentioned EMCA6's support for TCO, which took me as somewhat of a surprise, but I looked it up and sure enough it's one of the marquee features of the new spec. I assume this means it's coming to JS in the near future, but to be honest, I don't really know what it means. What does it mean for JS users, optimistically?
https://en.wikipedia.org/wiki/Tail_call.
I live, think, and love TCO. It's EMCA's relationship to Javascript I'm unclear on.
There isn't any.
I think the problem with investing resources into language is that you need a critical mass of users. Critical mass is achieved easier if you dress it up as something more known. It's money that drives mainstream, not academia. That being said, "good-enough" in language design is the maximal set of features you'd like to borrow from your ideal language without making it too hard to dress it up in modern-day dress and without scaring away mainstream developers.
i found [this ticket](https://github.com/babel/babel/issues/256) for babel (an es6 transpiler), which links to [this chart](http://kangax.github.io/compat-table/es6/#proper_tail_calls_%28tail_call_optimisation%29) It looks like TCO is partially supported in bable.
Oh, dear. I'm afraid I'm vastly more confused now than before. I knew that browsers had a complicated relationship with standards, but I didn't realize it went this deep. So something that runs perfectly fine in Babel could very well blow Closure's stack. That I get. But if *even one browser* fails to implement TCO, then the only way to ensure your code doesn't flood some of your users with a bunch of garbage stack calls is to inject a Babel dependency (or some other transpiler that implements the protocol)? No wonder people call Javascript a target language for compilers.
So i just installed arch-linux and i have been trying to get LispEdit + Geany to work but it wont? What is the best way to write lisp on linux?
I second this comment.
Parenscript originally was a lispish version of javascript that more or less translated lisp to js (like cl-who is for html). see Parenscript-classic. Vladimir Sedach did a lot of work making it more like common lisp adding things like functions returning multiple values, having *let* function like it does in CL. You want *when-let*? load alexandria and import the *when-let* macro to parenscript. I cringe everytime I use *chain* or *@* but with libraries like jquery it is a necessary evil.
It wouldn't be hard. Scheme is an easy language to implement and to integrate to the C API like Tinyscheme. It would be cool if Mozzila tried it, add an scheme interpreter to the Browser, however with limited capabilities like JS and without access to the file system. Javascript sucks, its own name is misleading "Javascript", the right name is ECMAScript, the name javascript itself is a Sun Microsystem trademark (now Oracle). [Reference - JavaScript is a trademark owned by Oracle (uspto.gov)](https://news.ycombinator.com/item?id=8344049). Another reason is that JS is full of design flaws. 
Wow this is very nice thank you &lt;3
Nock is interesting, but why would someone want to program in it?
You don't generally want to program in it. It's meant to be a compile target for Hoon, the high level language that Urbit is written in. I wrote the compiler to see how fast I could make Nock go; this implementation is about 10-12x faster than the C based interpreter that they use in the core of Urbit, mostly due to the fact that you can compile to machine code using macros in Common Lisp.
Cheap Goldenrod is quite good. I like it too.
Oooh this brings back memories. I wonder how the mainstream will react to this.
One day someone will reveal the hidden secret behind curly braces, there must be some reason. I'm currently running in circles between python, es6, and other languages (haskell derivatives) and every time I end up thinking about scheme. It's small yet formal. Makes you think functionally, let's you focus on logic, without pushing you into Functors territory.
It's good enough if people use it. 
What kind of problems do you have? As far as I remember you only need to install slime package inside emacs (M-x package-install RET slime RET) and add one line to .emacs config file. EDIT: https://common-lisp.net/project/slime/doc/html/Installation.html#Installation
Here's a shell script (run as non-root) that will automatically configure emacs, quicklisp, and slime for the user that runs it: https://gist.github.com/anonymous/268fdbe5d7d56e9a2c72 It defaults to using sbcl, but should work with ccl or clisp as well if you just set $LISP to your lisp executable If it prints out "EMACS appears configured for slime, no modifying .emacs" then remove any lines that refer to slime from your emacs config file and re-run.
Good lord. You have just killed any enthusiasm I may have secretly harbored for Javascript. Bravo.
Any `(α β)` is a shorthand for `(α . (β . NIL))`, so to get `'(D 2 4)` from your `X` you have to take not just `(CDR X)`—which evaluates to '((D 2 4)) ≡ '((D 2 4) . NIL)—but `(CAR (CDR X))`. Since it's a very common operation, there's a shorthand function for `CAR · CDR`, called `CADR`. (Some other combinations of `CAR` and `CDR` also have shorthand functions.)
They are nice because they compose nicely like "caddar" that is pronounceable. 
hey i ran it but i dont have a ~/.emacs directory only a ~/.emacs.d and apparently i need to edit something in ~/.emac To use, add this to your ~/.emacs: (load (expand-file-name "~/quicklisp/slime-helper.el")) ;; Replace "sbcl" with the path to your implementation (setq inferior-lisp-program "sbcl") help please
You should be able to ignore that, that's output from quicklisp installing slime; the shell script should automatically adjust your configuration files to load slime. Try starting emacs and doing M-x slime RET (or in non-emacs speak, press Alt-x, type "slime" (without the quotes) then hit enter).
In that case add those lines to a file named ~/.emacs.d/init.el (load (expand-file-name "~/quicklisp/slime-helper.el")) ;; Replace "sbcl" with the path to your implementation (setq inferior-lisp-program "sbcl") 
Well I can answer the later one: quicklisp is installed in ~/quicklisp As a side note, I would imagine arch is a bit rough to use as your first linux distro...
Hahah it sure is i threw myself in the deep end for sure. I have used linux and am familiar with the command line, from doing a semester on c programming where we where using raspberry pis however using linux just for writing c code compared to now when i am trying to do everything on it is a bit different. Hardest thing is setting up these programs and daemons to work properly. I have all my main software functioning now, mozilla, steam, music, but i think i need to further my knowledge in scripting and how linux actually installs and uses/runs programs. Can i just write a lisp file say with nano text editor and then run/load it with sbcl. What is the build path for a lisp program? Sorry if these are the wrong questions to ask
which file is this?
Put these in it (and delete anything you put in from slime's page) (load (expand-file-name "~/quicklisp/slime-helper.el")) ;; Replace "sbcl" with the path to your implementation (setq inferior-lisp-program "sbcl")
The slime repl is like sbcl waiting for you to type in a function, but it's much more featureful (e.g. you can use the left and right arrow keys). As for why your function call failed: (1) is treated as a call to a function named by the number 1, so (test(1)) tries to call test with the results of calling the function named by the number 1, which is illegal. You probably meant (test 1) I would suggest either Practical Common Lisp http://www.gigamonkeys.com/book/ if you would call yourself good at programming in at least one other language. And Touretzky's book (https://www.cs.cmu.edu/~dst/LispBook/book.pdf) otherwise. Don't be fooled by how basic Touretzky's book starts out: it goes deeper quickly.
See also this for a library reference (It's actually a full language reference, but the parts describing the language are fairly dense): http://www.lispworks.com/documentation/HyperSpec/Front/Contents.htm
But it's forth and C? Admittedly didn't look that deeply, but that is what it seems on the surface. Still cool!
Yes, it's an excellent book for learning Common Lisp. That's a good price - I recently paid about that much on ebay for another copy.
The good thing with Lisp is that you won't have to adapt new standards every year. So yes, it is. 
Yes
I've been doing little projects with Python for about 5 years, plus some JavaScript. Would that count? Plus at one time I got about 3/4 of the way through the Little Schemer before my brain exploded.
It's a self-hosting Forth implementation, but it's using Lisp and C to bootstrap.
CL-FAD, the updated version of his filesystem sanity library can now be found as part of UIOP, I believe. His discussion of package distribution was written before quicklisp. Nowadays, to get common lisp libraries, just use quicklisp. The basic common lisp knowledge is still relevant, yes. However the entire text of the book is available online on the author's web site, so it might not be worth your money just to have a paper copy. 
Don't forget you can read it online at http://www.gigamonkeys.com/book/ if you want to make sure you like the style/content/etc
still good, and still practical.
UIOP is a library of utilities for ASDF including filesystem functionality. It should be used instead of cl-fad because it is more complete and is included with most implementations. It is not complete but here is a conversion table: | fad | uiop | |-------------------------------+------------------------------------| | directory-exists-p | directory-exists-p | | directory-pathname-p | directory-pathname-p | | file-exists-p | file-exists-p | | pathname-absolute-p | absolute-pathname-p | | pathname-equal | pathname-equal | | pathname-relative-p | relative-pathname-p | | pathname-root-p | | | canonical-pathname | | | merge-pathnames-as-directory | | | merge-pathnames-as-file | | | pathname-as-directory | | | pathname-as-file | | | pathname-directory-pathname | pathname-directory-pathname | | pathname-parent-directory | pathname-parent-directory-pathname | | list-directory | directory-files | | walk-directory | | | open-temporary | | | with-output-to-temporary-file | | | with-open-temporary-file | with-temporary-file | | copy-file | copy-file | | copy-stream | copy-stream-to-stream | | delete-directory-and-files | delete-directory-tree | 
The paper referred to in the video is here: http://www.flownet.com/ron/lambda-calculus.html 
You hit the nail on the head... Clojure is where it's at, regarding Lisp web development these days.
You can use Common Lisp, Scheme/Racket or Clojure for web apps and all three will work fine. Common Lisp is the most stable of the three and the most "multi-paradigm" i.e. will do pretty much whatever you want if you know what it is. Clojure is in fashion (will it last?) but you have to enjoy working with the JVM, it imposes more constraints in terms of (functional) programming style (which may be helpful for larger teams, perhaps less so for small ones or individual efforts), it is changing a fair amount and is run by a BDFL. Racket has a really nice community and some innovation around it like typed Racket if you're interested in that. I would personally choose the language first with a view to the long term, because they are all capable of doing web apps and have sufficient libraries. A few links to check out for Common Lisp: http://blog.jeaye.com/2015/09/27/parenscript-ajax, http://eudoxia.me/article/common-lisp-sotu-2015, https://www.quicklisp.org/beta and the free e-book "Lisp for the Web" by Adam Tornhill: https://leanpub.com/lispweb. 
Here is a use case that I found in my sources. ;;; Library function with bunch of parameters ;;; that I don't want to change or even don't have sources for (defun library-foo (a b &amp;key param1 param2 param3 #| maybe zillion other |#) (list a b param1 param2 param3)) ;;; I want to use it with my flavor, say, add my1, my2 keywords ;;; to have some special processing of B required parameter ;;; And I dont want to repeat definition of whatever parameters are to ;;; library-foo, not to mention their correct defaults (defun my-foo (a &amp;rest args) (destructuring-bind (&amp;key my1 my2 &amp;allow-other-keys) args (apply #'library-foo a (process my1 my2) :allow-other-keys t args))) (defun process (my1 my2) (list my1 my2)) (my-foo 'a :my1 1 :my2 2 :param1 'param1) ; =&gt; (A (1 2) PARAM1 NIL NIL) Without :allow-other-keys it won't work. 
Yes. Don't let your age dictate what you think you can do.
Hasn't it been like available online for free for yonks now? http://www.gigamonkeys.com/book/
My money is on Clojure as usual. The tooling really eases a lot of the pains normally associated with webdev. And having front and back end covered in the same project is helpful.
Well, I prefer reading books on paper (it's easier on my eyes). Plus, more screen real estate for Lisp hacking :)
That's possible. You need to define your own method combination using define-method-combination.
Awesome, thanks. Actually if I had just kept on reading the documentation for DEFINE-METHOD-COMBINATION I would have found an example of exactly this.
As the example illustrates, it allows you to go from a more general set of keyword parameters to a more specific set, normally used with `apply`. A more contrived, sketchy example is, say you have a property list that describes an API request: (labels ((validate-user (&amp;key user) ...) (check-authz (&amp;key role action) ...) (perform-action (&amp;key action args) ...)) (let ((request '(:user "Zardoz" :role god :action say :args "The gun is good!"))) (apply #'validate-user :allow-other-keys t request) (apply #'check-authz :allow-other-keys t request) (apply #'perform-action :allow-other-keys t request))) Later, you add some more properties to the API requests, or decide `check-authz` should mention the user in its error message. None of these function calls need to be changed. A downside to the complementary feature, `&amp;allow-other-keys`, is that your lisp environment won't be able to tell what keyword arguments are expected by the function. This is usually in conjunction with &amp;rest to obtain a property list to pass on to other things. Its a good idea to explain what's going on in the function docstring, to say which functions to look at to obtain the set of keywords that could be useful in such a call.
 (reduce (lambda (old new) (if (&gt; (priority old) (priority new)) old new)) methods :initial-value (first methods)) for the max priority
Good thinking. Although I think the REMOVE call is the bigger problem. No sense going over the list twice. I should be storing the cons cell whose cdr contains the cons cell whose car is the highest-priority method, then after the loop taking that item out directly. Not going to mess with it until it becomes a problem though.
Just sort all the methods by their priorities, and CALL-METHOD with the highest priority method as its first argument and the rest as its second.
Clojure/Clojurescript without question.
It's great until you want to add virtual hosts and realize how insanely complex that is under the existing freeware frameworks.
Well, beside the fact that Parenscript has its own problems, the reason we went with Clojurescript had more to do with React than the language itself. The fact that Clojurescript provides a better development environment than Javascript in this case was just a bonus.
In what way is is complex? Granted, this application is written fairly close to Hunchentoot, and the framework being used is something I developed myself. That said, if I want to support virtual hosts, I'd do it with haproxy and ngnix on top of the application itself.
I was just trying to list all Lisp PoC. - Yale Hask - pre-Objective Caml - IIRC ML and Smalltalk were prototyped in lisp too. Any others ?
Of course, how could I forget this one.
It's worth noting that the JVM is not tied to Oracle in any way. OpenJDK is completely open and unencumbered. It's also worth noting that Clojure isn't really tied to the JVM in principle. Clojure 1.7 introduced [reader conditionals](http://dev.clojure.org/display/design/Reader+Conditionals) for targetting different platforms such as CLR and ClojureScript. A lot of Clojure libraries cross-compile to ClojureScript nowadays. My personal preference is for focused languages, so I see having one person giving direction as a big plus. Clojure has been fairly conservative with adding features and there's generally one idiomatic way to do things. The big benefit there is that it makes it much easier to work with code from others. I can open up a library and easily understand what's going on there. On the other hand, languages designed by a committee tend to get complex, and every project is written as a unique snowflake with its own style. There are tradeoffs for each approach obviously, and if you don't agree with the vision of the language then an opinionated language will not be enjoyable to work with. I think what big companies are doing is relevant from the perspective of support for the language. If a big company invests in a language they now have a stake in this language going forward. A lot of these companies end up releasing open source libraries and fixes into the wild. The more companies are actively using the language the more tested and mature solutions are available for it. 
This one is a surprise. Thanks.
Oh, nice.
I think you need to consider another approach as well. You have two different choices: 1) your current one, where each method can decide whether to call the next method in the chain or to stop the chain, 2) a different choice, where your method combination calls all your methods (one by one from the highest priority to the lowest) without giving that flexibility to your methods. I don't think you need that kind of flexibility. In that case, your define-method-combination will CALL-METHOD for each of your method and your methods don't have to call CALL-NEXT-METHOD.
&gt; 2) a different choice, where your method combination calls all your methods (one by one from the highest priority to the lowest) without giving that flexibility to your methods. No, part of being a higher-priority handler is the ability to prevent lower-priority handlers from running. It's important because of the way game rules are layered on top of one another. Game rulebooks (I'm thinking of board games, pen and paper games, and especially trading card games) are full of exceptions to old rules. I envision coming up with a new item or mechanic to add to the game, and writing new handlers to implement the rules for it without touching the existing code. That's why I need the ability to say "don't run the old code", or to decide on a case-by-case basis whether to run it. There's actually another choice too, which is `and` or `or` method combination, plus the requirement that my handler methods return `t` or `nil` to signal whether to continue, but I think that's less good than an explicit `call-next-method` because it would be easy to forget to adhere to the protocol since it would be somewhat invisible.
I see. Then why don't you use the standard method combination together with a class hierarchy? A new rule inherits from an old rule. Then the method specialized for the new rule will be called first, and it can decide whether to call the method for the old rule.
This is so cliche.
[SBCL (Steel Bank Common Lisp)](http://www.sbcl.org/) is a great choice. SBCL compiles to efficient native code. It's also how you run the code. For packaging your code as a library, you can have a look at ASDF and quickproject. ASDF is a system definition facility for Common Lisp, and quickproject creates asdf templates automatically. Generally I only deal with ASDF through quicklisp (mentioned below). For packaging your code into a binary executable, have a look at [buildapp](http://www.xach.com/lisp/buildapp/). For threading, SBCL has a cross-platform threading API (you have to enable it when installing SBCL on Windows/OSX). In addition, you'll want [quicklisp](https://www.quicklisp.org/beta/), which will fetch libraries from an online database. All of the libraries mentioned can be found in the database. Finally, I don't know of an integration layer for Lisp in Atom, since it's a relatively new editor, but if you get desperate you can load [Swank](https://github.com/slime/slime/blob/master/swank.lisp) in an instance of lisp, and that will allow Atom to communicate with it via a port; if you are ambitious, you could make Atom into a really solid lisp editor! HTH
Sorry I think I misunderstood. I thought the handlers would be dispatched on rule objects. Now I re-read your comment above, it looks like the handlers are actually part of the game rule implementations. In that case, your original scheme with the prioritized method combination seems a good choice.
In counter to SBCL, I reccommend CCL. Its threading support is enabled on all supported platforms. The only issue I've run into so far is with buildapp, which is lightly supported on CCL at this time. This will only be a real hurdle if you're trying to use a package that depends on it, otherwise making a standalone image with ccl is as easy as with sbcl, and isn't something I consider to be a limiting factor. The thing you're going to miss with using Atom is a live interaction with your running lisp image. If you've used python before, the IDLE editor is similar in behavior, so thats what you'll be lacking (unless Atom supports slime now, I could be wrong). Not to stop you, just something to think about as your proficiency with the language grows, just something to look forward to.
BTW "hook" is a more idiomatic Lisp term than "event". And you may want to define some macros like DEFINE-HOOK and ADD-HOOK for better readability, which wrap your method combination.
Yeah, in a sense they are hooks, but "event" is really better in this case since there's an actual queue of events scheduled by time.
Common Lisp is great on Windows. I use Emacs from Cygwin, and Clozure CL's Windows binaries. I develop on Windows and Linux and deploy to Linux. Mixing Windows and Cygwin is usually pretty hairy, but luckily SLIME has some great variables that solve this: (when (string-equal system-type "cygwin") (setq slime-from-lisp-filename-function 'na/cygpath-windows-to-unix slime-to-lisp-filename-function 'na/cygpath-unix-to-windows)) (defun na/cygpath-windows-to-unix (winpath) "Converts a Windows-style path to cygwin-style Unix paths." (with-temp-buffer (apply #'call-process "cygpath" nil t nil (list winpath)) (buffer-substring-no-properties 1 (buffer-size)))) (defun na/cygpath-unix-to-windows (unixpath) "Converts Cygwin's Unix-style paths to Windows style." (with-temp-buffer (apply #'call-process "cygpath" nil t nil (list "-w" unixpath)) (buffer-substring-no-properties 1 (buffer-size)))) 
So I thought this was really cool. As a super TLDR, with Gambit Scheme(implemented on top of multiple languages including Java and JS) they've managed to make a system to pass continuations between disparate devices to allow different devices to continue a computation without losing state. I had previously pretty much dismissed the possibility of doing something like this as too difficult. 
One thing I learned while doing things like this is that you want to have a fairly stable VM design before you go and implement it in multiple languages. Replicating VM changes in even just two different languages was pretty annoying. It's interesting that they require dynamic code generation *in the target language*, which isn't so easy if the target is C or Go, for example. I guess that's kind of analogous to using microcode like early Smalltalk VMs did.
T
Slime and emacs when I'm on windows, and the clisp repl when I'm running a Linux vm
SLIME I use it despite being a life-long vi user, as it's just that good. I used to use SLIME as just a REPL/debugger, but with evil-mode I can use emacs as my editor as well.
For me it's either ne (Nice Editor)+ECL (Embeddable Common Lisp) or Atom with SLIME installed, since I find either of those combinations much easier to use than EMACS. However, ne does have it's quirks (like the backwards way it handles deletion). I'd love to use ABCL, since it runs on the JVM, but I can't get it to install on my computer &gt;:-(
When I'm really writing CL, SLIME. If I'm just pulling up a REPL to try something out, or as a calculator, Clozure CL's Mac app. It starts a ton faster than Emacs + SLIME does.
[Link to actual PDF](http://www.iro.umontreal.ca/~gambit/migrate-dls15-talk.pdf).
I think I saw something about them limiting the closures to what was actually needed by the functions or something, but not sure.
Why is this necessary when you can just sent the data state and updates between all devices in play. Especially using something like websockets. The protocol is not limited to browser to server only. It doesn't matter what the "data" synced up is. It could be a sexpr of continuation state if you like. But it seems to be adding legs to the proverbial snake.
You can find its full contents as PDF and also in HTML online. When online I find the later invaluable as I don't care my hardcover around and links aren't active in the PDF. As I have bought both the hardcover and the Kindle version I don't feel bad recommending the free to use one. 
You will find that lisp syntax is much much simpler and far more flexible than C and java. Remember that MIT first year CS class was in scheme for a very very long time. The full course is still online for free and highly recommended. Use Racket while you are learning it. Then go on to "Essentials of Programming Languages" also using scheme. By then you will understand very very well why the syntax and cons cells and very wonderful and that worries about the same are really irrelevant to the magic that is lisp. Do you know about a single linked list? Then what is the problem with a cons that is sort of like a generic node in such a list? 
&gt; Why is this necessary when you can just sent the data state and updates between all devices in play Packaging up the data state and updates into a data structure? Great idea! Then you could just 'call-with-current-state-and-updates' and get on with it (though someone should really come up with a better name).
Yeah. The strong clojurescript&lt;-&gt;react work (OM and others) is one thing that makes me tempted to deal with at least this part of the clojure world. They also did a good job (I hear) of having source references easing debugging of the generated javascript. I don't know enough parenscript to know if anything of the kind is there or how much work it would be to come close to clojurescript parity from that starting point. 
I've been meaning to check out Sly for a while - does it still play nicely with Slime-based things like ac-slime?
&gt; the GC prototype was was written in Common Lisp first and I wrote a translator to convert it to C++ Ewwwww. Guess it makes sense, though - Microsoft have many more people used to working with C++ codebases.
I think the main thing to recommend this approach is that it's minimal and simple to understand. I can picture having a more structured set of rules, but it would take more work to implement and I'm not sure I'd get much out of it compared to numerical priority. But we'll see. I like the idea of having named rules and specifying an ordering for them, but I'm not going to spend time on it until I actually encounter the need. The thing I didn't like about my previous version was that it felt like I was reimplementing something that was already provided by the Lisp system.
Evil-mode will change your life
Yes, Joao supports ac-slime and [sly-company](https://github.com/capitaomorte/sly-company). Also with the help of Joao, I've ported [slime-repl-color to sly](https://github.com/PuercoPop/sly-repl-ansi-color) to be able to use [prove](https://github.com/fukamachi/prove)'s Colorized output. If you know of any other extension that does not work with Sly it should not be too hard to port.
As a counterpoint, interesting to read your new rant about Clojure: http://blog.mishkovskyi.net/posts/2015/Oct/29/clojure-numbers-despair. At the end of the day, Clojure is Java. Depending on your perspective, that's great or... not so ;)
It's a hosted language and it exposes some of the quirks of the underlying platform. As the replies in the article point out, overall the decisions provide a good balance in most cases. There's also a discussion in [/r/clojure](https://www.reddit.com/r/Clojure/comments/3qwuzr/some_interesting_points_on_numerics_in_clojure/) if you're interested. The main points I agree are that the namespaces for numerics could be organized better, and that documentation is not great. However, as ClojureScript and ClojureCLR clearly demonstrate Clojure is very clearly not Java. It simply chooses to be pragmatic about the hosted platform.
You're right, I was under the impression at the time that the code would be run multiple times so we'd get them in the right order, but now I know it runs once so they need to be fully sorted.
Part from the file in sbcl's src/interpreter/README http://sourceforge.net/p/sbcl/sbcl/ci/master/tree/src/interpreter/README Performance =========== Having been tested extensively on the CL-bench suite of tests, the performance can be characterized as anywhere from a 10x to 100x (or more) improvement over the sb-eval interpreter. Consing is also usually decreased by a factor of 5 to 10. However (as called out in Known Bugs) there is possibly a problem with garbage retention. That said, the interpreter sees daily use in a production setting with no problems.
Thanks, I'll try something like that. What about the limits on compute cycles and memory?
Use runit. 
Can you elaborate on the production setting?
I don't know I just pasted part from the README that seemed relevant to the performance update. Important to note that the new interpreter is not used by default.
Can I run sbcl on android now?
You could for some time now.
You're probably not going to get the AI to come up with anything interesting if you give it such a limited set of primitives. If most of the programs they generate are malformed (I.e. cannot be executed), then there is very little chance of them finding anything interesting. You can constrain the search space by supplying useful primitives like addition and so on, and by making sure that the AI cannot generate complete "gibberish", otherwise the search space is simply too large. All of this is assuming you want to implement a system similar to genetic programming.
How do I install sbcl on android then?
Use a chroot. There's little point in having a native android sbcl, although it is supported too, there's no binary, you'll have to cross-build it.
The search space is huge and high dimensional. My plan is to define opcodes in the shapes of conses. These opcodes will control the creation, size, training, and running of neuralnets, and which vectors they are trained and predict about. The boltzmann kind of symmetric neuralnet can do small amounts of general computing, so the AIs should learn to learn better about combinations of conses and neuralnets.
What about running your lisp in a docker? This way you could impose a CPU quota.
Everything has a cost. In order to execute the semantics in less time, something has to give. That time is taken from safety, flexibility (of e.g. redefinition), comprehensibility, and other useful and desirable places. It's not great to give up those things for a general sense of "this is now faster," but can be worth it in specific places when it means "this is now fast enough to provide a specific benefit." It's always nice to have a concrete purpose for making something go faster. For example, if you can save money by running your program on fewer computers, or in fewer billed CPU hours, or to save electricity, or improve throughput. But if it's done in a vacuum it's hard to ever be satisfied that the result is good enough, or worth the cost.
SBCL only: 1. Do not use `(safety 0)` in production unless you have to; I often benchmark with default safety (1) and `(safety 0)` to *confirm* that the difference is marginal. In fact, do not sprinkle `(speed 3)` everywhere either. I'll do it to get compiler notes, and then go back to defaults in all but the most performance sensitive parts. 2. Declare types to get unboxed structs and arrays; sadly, SBCL boxes class fields, so you have to give up multiple inheritance (until crhodes commits his hack). If you have really large data sets, using the C heap and FFI might be worth the programming overhead, especially if you can use `mmap` to load data. Think about data layout, and not just in a "pointer elimination" mindset; pointers in a few key places can be helpful. 3. Use the highest level of abstraction that your implementation supports well. For me, that means `map nil` and `map-into` when I can, because the compiler knows how to compile them to avoid bound checking, etc. It also means no `reduce` because SBCL still doesn't know how to handle it usefully… but I'd just fix it if that becomes an issue. 4. Create your own abstract "bulk" operations. Making individual (complicated) loop bodies faster is a hard task. I'd much rather figure out what my building blocks are, and focus on each one in isolation. That will also inform data layout (converting an array of structs to a struct of arrays), which incidentally is a great equaliser with C: SBCL supports unboxed arrays very well, and Lisp is flexible enough to let you create better tooling for transposed data. The only part that I really miss is support for arrays of small inline structs; if that really matters, the only solutions are bit packing and/or using the FFI for data access (which compiles down to reasonable code!). [But think about data layout again! It might make sense to have bulk operations that work on small subsets of your data, pipeline them, and apply the pipeline to the whole data set.] 5. Avoid full function calls for small operations, especially for numerics. The overhead of converting from/to a generic representation can be large. Do use (dynamic extent) local functions instead. SBCL will generate specialised calling conventions for local functions, and will even point inside stack frames instead of creating an explicit closure when it's clearly safe to do so. Alternative: figure out what it means for a toplevel function to have a specialised calling convention in SBCL. If you want keyword and optional arguments in performance sensitive code, it might make sense to inline a convenience wrapper that itself calls an out of line function with only positional arguments. Also, multiple value returns are surprisingly efficient in terms of not boxing (and of compiler transparency for inlining)… as long as each position has a "nice" static type. 6. Beware inlining and microbenchmarks. The instruction cache doesn't degrade gracefully; when a highly superscalar processor has to hit main memory to decode instructions, the decoder becomes your bottleneck, not the 4+ execution units that now sit idle. That's not an effect you'll expose by looking at microbenchmarks that exercise &lt; 1% of your application's instruction footprint.
Cool stuff. It would be nice to be able to get away from CUDA. Re `Implementing Deep NN in lisp is one ambitious goal`, the MGL library (https://github.com/melisgl/mgl) supports quite a few neural network types (no convolutions, currently) and is able to work with or without CUDA. In this sense it has two backends already, adding a third should be possible.
Racket has really good support for creating alternate languages and subset languages. Create one and generate an executable. And you would have racket environment to test/debug it in and iterate. 
I have a work in progress called [clicl](https://github.com/aarvid/clicl) (common lisp in common lisp). Unfortunately, I have not been able to work on it for about 4 months and it is not finished nor well-tested nor well documented. Also I have only run it on SBCL but the code should be portable. I do not expect to get back to work on it till next year. Basically using a separate packaging system, reader and printer, it allows multiple separate script environments to run sandboxed CL code within a CL image. What functions/symbols of the package CL are accessible by the script environment is configurable. IIRC, the printer part is not done. And the rest needs better testing. The system takes ideas from [cl-eval-bot)(https://github.com/tlikonen/cl-eval-bot), code and ideas from [Xach's zpackage](https://github.com/xach/zpackage), [Pascal J. Bourguignon's lisp-reader package system](http://www.informatimago.com/develop/lisp/doc/com.informatimago.common-lisp.lisp-reader.package.html) ([git](https://gitlab.com/com-informatimago/com-informatimago/tree/master/common-lisp/lisp-reader)) and [SICL](https://github.com/robert-strandh/SICL).
Same questions as about docker? "generate an executable" sounds like its not a purely memory process.
Thank you! I'd been wanting to try and implement something like this myself, but haven't had the time to take it on. I had played around with cl-opencl-3b on OSX and had a surprising degree of success with it, at least until a Yosemite upgrade made some change to Apple's OpenCL interface. 
When the interpreter was introduced to SBCL I thought "that's nice I guess", but haven't had occasion to really use it. On Lispworks I have at least once run into difficulty because of interpreter/compiler differences in lexical bindings, so that gives me pause when it comes to trying it out on SBCL. Given SBCL has worked so well for so long with just a compiler, what uses do people have for the interpreter?
Do not optimize until you have functionality working. Then only optimize from profiling the code to find where it is actually effective. Don't optimize where it gives only marginal improvement. This is true in most languages not just lisp. Often a better selection of algorithm or pushing more into macros and thus compile time and a bit of selective inlining will accomplish as much or more. But personally I would optimize loops across basic numeric values and such fairly early. 
First let me state that this project, which I've briefly followed before, looks immensely interesting. But unfortunately, the gist of the screencasts is very oriented towards explaining concepts and abstractions that, in my opinion, say very little about what it can do for a (lisp-friendly) programmer. I gather it is a programmable editor in cl, has a repl, and kind of looks like emacs-done-right, which is great. At the risk of sounding lazy (which I strive to be, as a [good programmer should be](http://blogoscoped.com/archive/2005-08-24-n14.html)), can I ask you to make a quicker video that touches on "projections" and "lazy reactive editing" as little as possible, and demonstrates how to write a couple of "hello world" programs in a couple of programming languages supported by the current version of the editor? Then I'll commit to learning all those new concepts. Bonus points if the editor's installation is also included in the video :-)
Is this editor, in it's current state, usable for general purpose CL development? From reading the wiki I gather it's not quite there, but maybe the wiki is out of date.
Has anyone used one of these and can provide a mini-review? I'm primarily interested in using one with PicoLisp.
I think it's a mistake to consider SBCL and CCL "clear winners" in the CL world. They're quite popular, but there are still good reasons to choose other implementations, depending on your needs. It's nice that so many options are available.
Any response is going to be biased. There are a lot of amazing Scheme implementations. [Andy Wingo](http://wingolog.org/) wrote up ["An opinionated guide to scheme implementations"](http://wingolog.org/archives/2013/01/07/an-opinionated-guide-to-scheme-implementations), and of course it's opinionated, since he's a Guile maintainer, but nonetheless displays many of the nice feature of each. However, if I were you, I'd pick one of two Schemes: if you're an emacs user already, choose Guile. If you aren't, and aren't interested in becoming one, choose Racket. The reason being: Guile is amazing with Emacs with Geiser (better, for reasons having to do with the toplevel, than Racket IMO), and Racket has an impressive independent editor with DrRacket. But they both have great communities. The most important thing you can do is: just pick one and learn things! You can always dip your toe into another one later.
If you go the common lisp route, Depending on how much functionality you want, you can get JSCL(https://github.com/davazp/jscl) or parenscript for javascript if you're willing to hack around the incompleteness. ECL can get all the other systems you are looking for. 
The main thing about Guile is that it started out with the explicit intent of being the scripting and extension language for GNU. Now, that didn't really pan out, but Guile remains a great choice if you want to embed a Lisp into a C project. Since Andy Wingo took Guile over (however many years ago that is now, feels like it must be more than a decade) there's been big strides forwards. It's probably true that Racket or Chicken is more pragmatic in terms of their libraries and documentation, but I retain a soft spot for Guile, and have a lot of admiration for Andy Wingo - especially as I saw him once at GUADEC in Birmingham, England, and he was sporting the most amazing set of mutton-chop sideburns I've ever had the pleasure to see.
Still no windows binaries. :(
Didn't debug why, but yes it deadlocks. EDIT: OK. I looked into a somewhat. I don't really understand what you're trying to do with the semaphores. Why do you have those? The chanl already is thread-safe and allows writes into the chanl from multiple threads. What is the purpose? Removing the semaphores works: (ql:quickload :chanl) (ql:quickload :bordeaux-threads) (ql:quickload :sb-concurrency) (defun test-chanl (n) (loop for i from 0 below n do (format t "~&amp;Test: ~a~%" i) (let* ((size 1024) (test-repeat 4) (chanl (make-instance 'chanl:unbounded-channel))) (loop repeat test-repeat do (bt:make-thread (lambda () (loop repeat size do (chanl:send chanl 1))))) (loop repeat (* size test-repeat) for i from 0 do (chanl:recv chanl)))) (format t "~&amp;done.~%")) 
What this guy said. This would mean I could use LISP (my only programming language) for both my college project, and the unit on Microcontrollers. EDIT: I bought one, and I'll give you all a review when I have it, bare in mind though I have not done a review before for anything other than a film on Netflix, I'm a novice Lisper and I have very little experience with microcontrollers But I'll give it my best shot.
Did you build sbcl with native thread support? On OS X, it's not default.
&gt; floats were renamed as reals because a type's name should reflect it's meaning, rather than it's implementation .... except that if a value something of type 'real' is nevertheless an IEEE754 'float' underneath, then [those values are not going to behave like mathematical reals](https://stackoverflow.com/questions/588004/is-floating-point-math-broken). (Cf. e.g. [Perl6, where Rat and Num 'do' the Real role](http://design.perl6.org/S02.html#Numeric_Types).)
Ints are not real integers either, as they're bounded and integers are infinite. But I understand your point.
Good point! Still, i feel the issue is more of a concern for reals than integers, because i would guess that (particularly on 64-bit systems) people will more rapidly run into inexactness issues with floats than overflowing or underflowing ints.
Well, in Common Lisp you have fixnums, which are machine words, and integers, which are arbitrarily long. Granted, memory is finite, but there's a vast difference between a machine word and a process' memory.
Having to depend on a library like that for my Int &amp; Real types is out of the question, as I plan on having a JS, a BEAM (Erlang) and an LLVM compiler further down the line, and I doubt I can have a solution that I can apply on all places. There's also the problem of the overhead it would cause on numeric computations. An option like that library should be available to Lux programmers that need it, but shouldn't be the default. &gt; Yes. I'm a fan of your work :)
A portable Lux implementation would be preferable and highly feasible. &gt; Certainly, but this is a trade-off you accept in exchange for these features. I'm not sure I can accept that trade-off. Bad performance could end up becoming a turn-off for potential adopters (yeah, I know there are folks out there using Python, Ruby and JS without complaint, but deliberately making slow languages doesn't sound like such a nice idea to me). There is one way, though... There is already a signature named Number for numeric operations. There are implementations for both Int &amp; Real in the standard library. All that's needed is implementing the arbitrary precision numbers and adding suitable Number implementations. The moment you actually need the extra juice, you just switch to the other Number implementation. And if you write your numeric processing code relying on arbitrary Number implementations, all your code will become reusable under the new arbitrary precision numbers. ------------------------------------------------------------------------- I'm proposing that idea because using tagging and magical number casting is a bit antithetical to my goals with Lux (Lux is a language that rejects "magic" in language design and things happening behind the programmer's back).
You could have something like this: (def (make-vector number n) (All [a] (-&gt; (Number a) Int (Vector a))) ...) Lux structures are first-class, so you just need to give the Number implementation you want your vector to use.
For some reference on how you implement Number, here's a module from the Lux standard library: https://github.com/LuxLang/lux-stdlib/blob/master/source/lux/data/number.lux I'm sorry for the heavy use of ```do-template```, but I didn't want to repeat so much redundant code for ints &amp; reals.
I never heard about it... from the webpage looks very interesting, I should take a deeper look at what it does.
&gt; common lisp Are all CL implementations compatible among them or I will have to deal with several different codebases for a really crossplatform project? 
To me its purely about guilemacs - scheme is a better language in just about every way, except I do prefer a lisp-2. What I hope for with guilemacs is extending emacs in scheme.
There is so much legacy code, most of it will never be translated to scheme and having two languages for extending Emacs plus all the resulting interoperability issues doesn't sound very attractive to me. Elisp is not really hindering progress in the Emacs world and for that reasons I don't understand why it needs to be replaced.
Yeah elisp will be around at least as long as emacs, but I do think it holds us back. It's slow, with no JIT compiler on the horizon, no FFI, poor namespace and modularity features, lexical bindings an afterthought with regrettable means of enabling it (and only at file granularity), no multiples values, no restarts or continuations, no TCO, no customizable reader, no threads. Amazing what we've done and will do with it in spite of all this, but I think we can also do better and adding scheme is worth the price - so long as our legacy elisp keeps working.
To avoid misunderstandings, when I say Elisp, I mean the language not the interpreter. If basing Elisp on Guile brings benefits that is of course fantastic and I have nothing against it. I agree that it would be great to overcome the current limitations of Elisp, but does that require that we switch to scheme? I suppose things like FFI and threading could also be added to Elisp. For example, what's stopping us from using threads is not so much Elisp itself but rather that most of the code written in Elisp is not thread-safe. Scheme doesn't really help here.
Well shit. How am i supposed to not buy this.
Note that this release broke some packages for me, I don't remember which ones, but the problem is related to this: http://trac.clozure.com/ccl/ticket/1292. I had to go back to 1.10.
You might find more resources in /r/gamedev 
That's less than half my points addressed or dismissed, and lets be polite. There's also the availability of a lot of scheme libraries that guilemacs could make available to us. Elisp and its interpreter aren't perfect, neither is Guile, but it does bring capabilities to the table for a price I think is worth it. Feel free to not share my opinion.
The Lisp version is very well-commented compared to the C version. Without the comments, the length is similar; they are both pretty compact. The Haskell version is pretty short, too.
There is a small community of lisp game devs centred around #lispgames on freenode, and the wiki http://www.lispgames.org/ you might ask there
I've been wondering why everyone insert millions of `(the fixnum [form])` instead of one `(declare (ftype (function (fixnum) fixnum) 1+))`. It has a package-lock issue, but it can be easily avoided. ;; tested on SBCL 1.2.16 (defun test0 (a b) (declare (optimize (speed 3) (safety 0) (debug 0))) (+ (1+ a) (1+ b))) ;; 7 notes (defun test1 (a b) (declare (optimize (speed 3) (safety 0) (debug 0))) (declare (fixnum a b)) (+ (1+ a) (1+ b))) ;; still 3 notes (defun test-ugly (a b) (declare (optimize (speed 3) (safety 0) (debug 0))) (declare (fixnum a b)) (the fixnum (+ (the fixnum (1+ a)) (the fixnum (1+ b))))) ;; 0 notes but messy. Also unmanageable in larger functions. ;; this is clean, but causes package lock violations (defun test2 (a b) (declare (optimize (speed 3) (safety 0) (debug 0))) (declare (ftype (function (fixnum) fixnum) 1+)) (declare (ftype (function (&amp;rest fixnum) fixnum) +)) (+ (1+ a) (1+ b))) (defun test3 (a b) (declare (optimize (speed 3) (safety 0) (debug 0))) (declare (sb-ext:disable-package-locks 1+ +)) (locally ; &lt;-- required (declare (ftype (function (fixnum) fixnum) 1+)) (declare (ftype (function (&amp;rest fixnum) fixnum) +)) (+ (1+ a) (1+ b)))) I think its ok to make `proclaim` or `declaim` such a violation, but local, bounded declarations should be considered safe and not be handled as such. 
The restriction comes from the language spec, http://clhs.lisp.se/Body/11_abab.htm
Chanl is very useful and its maintainers are very bright and conscientious. I'm sure they will take care of the above problem soon. Adlai has already assigned the bug to himself. I'm sure he'll fix it thoroughly and quickly.
To be fair, you can make something super simple that can be used as a base for a more complex sims game. Rather than implementing something completely unrelated like a puzzle game. See the response from /u/baggers_, they go into more detail with the same idea.
I like the idea of having a lisp editor with a more shallow learning curve, but having to manually indent lisp code so that parens are inferred does not seem like a good idea to me. This technique is not necessary for a lot of the examples (inserting/deleting/commenting a line without re-arranging parens and automatic indentation). Even the "basic paredit without hotkeys" can be done without the need for manual indentation it seems to me. I posted examples of the same functionality without the need for manual indentation [here] (https://www.reddit.com/r/emacs/comments/3sfmkz/could_this_be_a_pareditsmartparens_killer/cwwthds). So I'm not sure I really see any significant benefits to this method (feel free to give me an example or correct me here) and the manual indentation seems a lot more tedious to me.
Seems to me that if the choice is between manually ensuring your sexps are well-formed, this is a huge step up. Beginners aren't generally up for learning paredit right away, but maybe you could give them an autobalancing editor right off the bat. If you're investing more time then paredit will probably save you effort, although this thing seems smarter about scooting parens up to the previous line, which could save some manual formatting. But IMO a mouse-driven structure editor would be nicer than either.
Sounds interesting. Maybe you could also double click on a paren or something to be able to barf/slurp with it by dragging. &gt; mouse selection to snap to whole forms Maybe you could have something like expand-region except for s-expressions by double clicking.
A couple of related, interesting comments from hackernews &gt; ruricolist 1 day ago &gt; A more direct comparison for Emacs would be `adjust-parens`: https://elpa.gnu.org/packages/adjust-parens.html &gt; alphapapa 1 day ago &gt; Wow! This is fantastic! This seems to do just what Parinfer does. Why isn't this mode more well-known? &gt; This makes it even better: (defun my/lisp-dedent-adjust-parens () (interactive) (save-excursion (x4-smarter-beginning-of-line) (call-interactively 'lisp-dedent-adjust-parens))) (defun my/lisp-indent-adjust-parens () (interactive) (save-excursion (x4-smarter-beginning-of-line) (call-interactively 'lisp-indent-adjust-parens))) (local-set-key (kbd "&lt;M-left&gt;") 'my/lisp-dedent-adjust-parens) (local-set-key (kbd "&lt;M-right&gt;") 'my/lisp-indent-adjust-parens) &gt; Now you can just M-left and M-right to adjust the indentation of any line, regardless of where the point is, and adjust-parens fixes the parens for you. 
Edit: I got it working! I'd love to get CEPL working! I'll try it out on windows, but my main setup is on linux. My graphics card is a little old, and I can't get examples to run. I've gotten some demo code for cl-opengl and cl-glfw to work. I can use \#version 330 core but not \#version 330 Even after changing varjo to use \#version 330 core I still have trouble running cepl examples. I suspect the bugs I'm running into are not too deep, but I am unfamiliar with the codebase and unsure how to proceed. 
I know you probably want to get the grid working, I also had a go using calls analogous to those reported to work in other languages, but no luck. This seems to work with the pack layout manager though: (defun test () (with-ltk () (let* ((f (make-instance 'frame :padding 10)) (e (make-instance 'entry :master f :width 20))) (pack f :fill :x) (pack e :fill :x)))) Perhaps it would be worth bringing this mystery up on the ltk mailing list
Very nice. I was looking through tutorials and in tcl they referenced the top level with a dot, that doesn't seem to work in ltk. I thought that it's NIL because when you create a widget and it has no master you pass NIL as well. Anyways as you pointed out it's *tk*. Thanks. 
is there a paredit version of the last feature, "Preserve Indentation"?
glad to hear you got it working :)
Looking at the lisp.vim syntax file, it seems like vim skips over '|'-characters inside s-expressions for some reason, so multiline comment highlighting will only work outside of them.
Just use postgres. Aside from very niche uses, relational databases are strictly superior to nosql. [Postmodern](http://marijnhaverbeke.nl/postmodern/) is a pretty good CL interface to postgres.
I wasn't trying to imply anything I was just looking at what github said for when the last commit was. This is really good to know though. I might have to consider using redis.
ITA came to mind, but I couldn't remember its name. Looking, I found this: http://pchristensen.com/blog/lisp-companies/ 
Also Greenberg's Emacs on Multics, written (almost?) entirely in Multics Maclisp.
You could also use SLOCcount; it skips comments and empty lines.
Thanks for your post. Interesting to read it!
AllegroGraph
JFYI, your Intel CPU, although designed in Verilog, is heavily verified with HOL. There is also a lot of hardware verified with ACL2.
I only use emacs, but I imagine http://www.daansystems.com/lispide/ or https://www.common-lisp.net/project/able/ might work. AFAIK pretty much vim with slimv or equivalent and emacs are the only ones still actively maintained, but I haven't really researched since I prefer emacs anyway.
It's early days but [Atom](https://atom.io/) and [atom-slime](https://atom.io/packages/atom-slime) are worth keeping an eye on (or contributing to!). I honestly believe that when atom-slime stabilizes, they + [paredit for atom](https://atom.io/packages/paredit) are going to be the easiest environment to use to introduce new people to common lisp. May not fulfil your lightweight requirement though :)
Parenscript is pretty good. If you want something that implements more of the common lisp standard, you can use JSCL https://github.com/davazp/jscl 
What about Emacs isn't "light" enough? You don't *need* to use all the features it has to offer.
I've been working on "learning" common lisp for the past 3 months. I've still yet to get it working with emacs because the learning curve is astounding (downloaded lisp-in-a-box, for example, and it still hasn't helped me much). What I want is something like DrRacket for Common Lisp. Box to write code, REPL to test code, save/load/etc. I've just been loading sbcl and going from there. With emacs, it's easy to get lost in all the "other" stuff emacs has to offer when I just want a turn-key common lisp coding environment. 
No but even with minimal configuration, the startup is too slow for the amount of one shot edits I do, and the distribution is quite large.
When I remove my init.el, my emacs starts (on the cli) instantaneously. You can speed up your emacs startup by profiling things until it's snappy. I would encourage you to use multiple emacs configurations (one for the heavy server "live in emacs" mode, one for quick cli edits, one copied to hosts you ssh to a lot, etc). The only reason I would encourage you to not look much past emacs is that emacs is like the sun in the sky. It blocks out all other editors to the point where they basically don't exist. There are no other successful "lispy" editors that I am aware of.
Vim does rainbow parentheses...
https://github.com/part-cw/lambdanative Or ClojureScript via react native seems to work (use natal to set it up). Actual Clojure on iOS requires the expensive robovm, and again, no trial. Clojure on android is a painful startup time Mocl looks like it may work but they have no try before you buy 
Why not Clojurescript? It has a terrific community around it, many excellent tools and frameworks, and it's decidedly a Lisp. I'm not sure what the ABCL:Clojure analogy is supposed to mean in an interpreted, JIT environment.
The most popular approach is via ClojureScript and React Native.
Ok, just making sure you knew your options with Emacs. Personally, if I were you I'd start hacking a terminal editor in my favorite Lisp. Simpler than vi but with highlighting and rainbow parens is a few weekends away.
FWIW, from what I can read and understand about the Emacs C core, it is not the kind of C you find elsewhere; there is a clear Lispy bent to the C written there. I liked that.
You do have [react-native-tableview](https://github.com/aksonov/react-native-tableview) [React-CollectionView](https://github.com/davidmfreese/React-CollectionView) that seem to work fine no?
[2 easy little known steps to speed up Emacs start up time](/r/emacs/comments/3kqt6e/2_easy_little_known_steps_to_speed_up_emacs_start/) HTH
I think the React Native approach is actually a bit less risky than the alternatives. All React Native does is wrap the native widgets. When the widgets change or aren't supported out of the box you can always easily write custom wrappers as seen with the above examples. The majority of the code is completely isolated from the underlying platform though, and I think that's a big plus. I also find that the React model is far superior to anything else available on mobile, and the instant feedback you get with the REPL is a really fantastic way to work.
ABCL is common lisp that runs on jvm ala Clojure, I was looking for anothe CL that runs on javascript ala clojurescript
Hey, happy to help you get started. I recommend installing quicklisp first of all. I don't know about lisp-in-a-box, I recommend a plain but recent emacs. Once quicklisp is installed, in your console lisp repl run `(ql:quickload "quicklisp-slime-helper")` and follow the instructions.
Announcing Clasp 0.4 – a new release that incorporates a brand new compiler – capable of generating 200x faster code than previously, many bug fixes, a more complete Common Lisp implementation, and improved C++ interoperation. The better URL is: https://github.com/drmeister/clasp
Very cool! Do you think you will give a talk on these changes at the next els? 
So many good computational chemistry programs out there are written in Fortran, it would be awesome if there was a Fortran version of this. Excellent and impressive work!
why not functions?
At first I was like: Robert Smith from The Cure? then I was like: Oh, that's probably a very common name.
On SBCL 1.3.0 I get: (defvar z 'x) -&gt; Z (defvar x 3) -&gt; X ``,,z -&gt; `,X On CLISP 2.49 and ECL 16.0.0: (defvar z 'x) -&gt; Z (defvar x 3) -&gt; X ``,,z -&gt; X All that is happening is the recognition that (eq `,x x) -&gt; T
This has nothing to do with backquote: you defined the symbol-value of Z as the quoted symbol X (not the value of X). So, evaluating Z gives X, and evaluating X gives 3. If you want the value of X, you need to do: (symbol-value Z), which will give 3. ``,,z is the same as `````,,,,,z is the same as z (it doesn't magically evaluate multiple times)
&gt; All that is happening is the recognition that &gt; (eq `,x x) -&amp;gt; T Right, I see it now. Thanks :-), I completely missed it.
The printing threw me off, as I expected `,X and not X. Problem solved. :-)
Aside from various mathematical and statistical features, this library (cl-ana, that is) also has a very extensive and easy to extend plotting functionality (via Gnuplot).
This talk introduced me to the power of conditional restarts, and I ended up using them heavily in my Clojure data analysis system at work. Not quite as powerful as the CL version because it's not built into the compiler, but it's gets you most of the way there. Still I dream of the day I get to work in Common Lisp.
Fortran 2003 includes a new feature called iso-c-binding; it's a C FFI for Fortran. Writing C-compatible wrappers for Fortran 90/2003 code is mostly boilerplate; you just have to work around how arrays are passed. It's even possible to pass Fortran objects if you wrap them in an opaque pointer. You can then compile the wrapper code to a shared library, which looks like an ordinary C library so far as the outside world is concerned; then you can then call into the wrapper code using the Common Lisp C FFI. I've done this before to get Python libraries to call Fortran code.
Read up on common lisp, especially the SBCL implementation. No particular reason, but it is often mentioned in lists of lisps.
Most lisps have windows and unix support. For common lisp I would use SBCL but if you want your LLVM support you might want to try https://github.com/drmeister/clasp. Racket has a bunch of grammar generators and also programming language tools to analyze programming languages http://redex.racket-lang.org/ (redex). 
Read up on Common Lisp, especially the Clozure CL implementation. Once you understand how it works, you'll have an easy time with other dialects like Guile. 
Most Common Lisp implementations, including sbcl can compile lisp code to native code at runtime, so if you don't need to cross-compile, you may be able to eschew using something like llvm. As far as parsers, I tend to use esrap, but there are plenty of others out there. If you do decide to use llvm, clasp is really the only sane choice, as it has llvm bindings. Be aware that it is still a work-in-progress, so you may find some rough edges. If you haven't read through PCL, I highly recommend it for people who are new to lisp, but not new to programming: http://www.gigamonkeys.com/book/
I like Picolisp's simplicity (even more elegant than Scheme, IMHO), but it doesn't have a big community or lots of third party libraries, though.
Gambit and Larceny are good alternative Schemes also worth considering. Although they don't have the community or pre-packaged modules of Chicken and Racket, they do provide excellent runtime performance with powerful optimizing compilers. Gambit's excuse for the relative lack of modules is that it has an interesting FFI which lets you directly inline C code, making "official" bindings less necessary than in other compilers. ([Packaged modules do exist](http://www.schemespheres.org/), but the number is smaller than for Chicken.)
Thanks for the suggestions! I don't really need C code integration AFAIK, though. Gambit does have a nice looking website though :P 
Yeah the thing is I'm a minimalist, so I feel the urgent need to customize it and remove all the clutter I don't need. That's why I use Vim over Emacs I think :p
The tagbody and block functions(block is an operator) is what made me realise how evaluation was allowed in such complex ways. 
"What kind of bear is best?" https://www.youtube.com/watch?v=ctTVcKNx8Rk
The project page at the Gitlab link you posted seems to be quite active (the last commit was just 6 months ago), why don't you try and submit a bug report there?
Go ahead and do it. Then after several years of (not paid) work you might start to realize why there is no such thing and stop asking stupid questions.
Commonqt+qtools
I've tried several times to get that working and have always given up. But, then, I have a Lispworks license. Maybe my patience for common QT would last longer if I didn't. 
I'm quite new to Lisp and setting up CommonQt seemed a lot less stressful than I expected, I just followed the quicklisp method here: https://common-lisp.net/project/commonqt/ Does Lispworks deal with things differently? 
To be fair, in much of the open source world 6 months isn't really considered active. Also, you have to email the admins of gitlab.common-lisp.net in order to make an account so you can make an issue. I'd recommend everyone do this, there are a lot of core common lisp libraries on that gitlab and you will want an account if you want to do a pull request or issue. Edit: Created issue here https://gitlab.common-lisp.net/qitab/cl-protobufs/issues/1
Not that I know of. I haven't tried setting it up with Lispworks; I've only tried it with CCL and SBCL. Each time I've attempted to follow the instructions something has failed somewhere. Since I have a working solution in the form of Lispworks, I may give up too easily.
An armed bear obviously ;-)
Oh, what is Nanopass exactly? Is it a framework for writing compilers?
Licensing could be an issue. Depending upon where you read, Clojure's Eclipse Public License may make using it in GPL or LGPL products difficult or impossible.
Interesting. I hadn't considered that, but that's a very reasonable concern.
In fact it's the most practical approach possible. The smaller your passes are, the easier it is to write and maintain them.
Bear beats battlestar Galactica
Looks great! Can we get an Enligsh translation?
In memory means it doesnt save a file and call an external compiler. It instead can run this process millions of times per second if the logic is small.
Quite a lot of CL applications are on GitHub.
Most of the software is distributed through quicklisp. You can browse the quicklisp catalog at [quickdocs](http://quickdocs.org/) Besides github, and an a few outliers on [bitbucket](https://bitbucket.org/tarballs_are_good/), there is [common-lisp's gitlab](https://gitlab.common-lisp.net/explore/projects?group=&amp;scope=&amp;sort=updated_desc&amp;tag=&amp;visibility_level=)
Do you know about [quicklisp](https://www.quicklisp.org/beta/)?
Closest thing to what you seem to be looking for is the clml machine learning library, available via quicklisp: (ql:quickload "clml") Documentation here: http://mmaul.github.io/clml/
Take a look at the book/pdf Land of Lisp, a good introduction to Lisp with a focus on gaming...which makes each task especially interesting: https://www.nostarch.com/lisp.htm. Most of this is CLISP. 
Sounds like a job for [ichi.moe](http://ichi.moe/) ;)
You can Google blackboard common lisp and neither upvote nor downvote :-) I'm on my phone or I would do it, but there is only one and you'll know it when you see it and you can get it via quicklisp
the lambda and cons parts
That is somewhat nonsensical. In most lisps, a CONS cell is mutable. You might be mistaken. What lisp dialect are you referring to that has immutable cons cells, and what exactly do you mean when you refer to a "purely functional" in the lisp dialect sense?
There are scaling problems when combining functions made by many people whose names overlap, like some of them think a certain function should work different ways or sometimes by accidental choice of the same name. In a purely functional language, you would just receive the relevant function from some other function and use it without these name collision problems. Making it "illegal to redefine" a function by those colliding names will give you an event about the error (which is good to know so you can fix it) but its still an error when names collide, and they will collide many times eventually.
Even in academia, there are few languages that eschew a global namespace for functions.
a few comments/questions: 1. It seems it's not full code snippet: no definition of FACT (or it rather should be F). 2. You defined Y-combinator directly as a procedure in Scheme (I presume), which uses applicative order of evaluation. I might be wrong, but you might need to put a few delays, otherwise your evaluation will never finish. 3. (n = 0) should read (= n 0)
Read his profile page, he's a confused intellectual
You're right, this made working with it considerably simpler. I also misread ARM64 as AMD64, so I guess I could multithread all along. 
I should have done that first. Asperger rears its head.
&gt; Where are most of the commonlisp opensource programs? Earth.
I can see pitching this to my friends now. "*Learn a language you don't understand, in another language you don't understand!*" It's pretty cute though..!
note: This 'Python' is not the programming language with the same name. The native compiler inside CMU CL is called so.
Unfortunately bordeaux-threads supports only the intersection of thread features between various implementations, while sb-threads supports some extra features that are quite useful.
There was a $1000 bounty for SBCL + Threads for ARM. read more: http://www.stylewarning.com/blog/bounties. Anyone know if it was collected? 
https://wukix.com/mocl
Did you use it? Did it do UITableview Cells fast enough?
I just read the other day that there are commercial GCs for Java. Might be worth looking into? I think it was in the Reddit thread on the differences between the JVM and the beam vm b
I wasn't aware that the memory management in SBCL was so poor, although I'm not surprised that it only works in serial given the status of parallelism in CL in general. Could you elaborate on this? I googled around and found a few instances of people having to switch from SBCL to CCL for long-running applications due to memory leaks but nothing recent. I've seen cases where an application allocates so quickly that memory is exhausted when trying to copy data over from one generation heap to another, but that can be ameliorated by lowering the number of allocations that occur before a collection.
&gt; The commercial Lisp GCs are even worse. BS. &gt; AFAIK there is no parallel GC for any Common Lisp, free or commercial. ABCL runs on the JVM... Allegro CL 10.0 has a parallel GC: http://franz.com/support/documentation/10.0/doc/gc.htm#multi-threading-2
We're using parallel now. We tried G1, but it didn't help much. I think the problem is that the code wasn't developed with minimizing garbage in mind. 
Still sooo full of misinformation. How do we flag these BS artists?
It runs in the JVM, so... yes?
It appears to do perpetual gc. If you do anything that allocates any amount of memory and dirties pages, it can consume a lot of cpu compared to equivalents.
SBCL uses different collectors on different platforms. So YMMV. Benchmark and see for yourself if it's going to be ok or not. If not, CCL will certainly be better in terms of leaks (none) and GC performance (better).
There is [Azul's Zing](https://www.azul.com/products/zing/) which is one of the most talked commercial version. However, from what I could find, it requires a bit of RAM to shine, so be prepared to start with at least 32GB.
Isn't this really an issue in how the application was written? Relying on the gc heavily in a high performance application is a no-no. In fact, really, allocating memory dynamically is kind of a problem. (You just want to allocate a block and manage it yourself). Most common lisps you can do that sort of manual memory management. It is tricky so for an average application it's not worth it. But really, most applications are not "high performance," they're just touted as such for ego reasons. Just look at your data structures /memory profiler and see if you are creating a particular new object frequently. If you are, see if you can find a way to reuse that object instead of creating new ones frequently. (If you are creating new objects enough to cause significant gc pressure, you probably have a mistake like this somewhere). It should be easy to fix without a huge rewrite or platform change. Anyway, the loop is profile -&gt; change -&gt; profile.
A common issue in lisp programs that exemplifies this is the newbie who writes his entire program using lists instead of other more robust datastructures. (It is LISP after all!) He gets finished writing it and it works but is dog slow, upon inspection he (or his mentor who has the wisdom to use a profiler), discovers that the application is spending all of its time creating and destroying cons cells that make up lists. A simple swapping of a few lists for arrays and hash tables provides a miracle 100x (or more) speed up.
I love strong opinions. Care to expand on it?
Quoting 'gammafactor6': &gt; The commercial Lisp GCs are even worse and &gt; I've never used it. LOL 
Perhaps it's not clear, but that is for 32-bit ARM, where it has some more practical value. I also have not been contacted regarding any work being done on it. Last I heard, there's not much interest, and there's a register shortage. 
See this article for a very different GC strategy than everyone else is mentioning: https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html Languages like Elixir that run on the BEAM/Erlang VM with the Phoenix web framework often report *microsecond* response times. Whether interested in Erlang or not, it pays to understand the BEAM VM (Erlang's VM) if people really want to see the future of language scheduling and memory management for highly-concurrent, low-latency languages. While Erlang is not intended to be as CPU efficient as Java, it's strategies for I/O and threading and memory management make way more sense to me than Java. From the article: "[...] this is where we can understand one of the main reasons that makes Erlang a soft realtime platform from its garbage collection point of view. This is because each [internal VM managed, not OS managed] process has its own private heap and its own GC, so each time GC occurs inside a process it just stops the Erlang process which is being collected, *but doesn't stop other processes*, and this is what a soft realtime system needs." Emphasis mine. Simply put, this is *not* a stop the world collector. Or rather, applications are made of thousands of tiny "worlds" rather than one big one. Considering that the BEAM VM routinely can run thousands (up to millions, with some effort) of internal lightweight processes that compose a running application, it's easy to see why GC has so little an impact on latency. When I say internal VM process (not OS process), I'm referring to processes that start as only 309 words of memory in size: http://www.erlang.org/doc/efficiency_guide/processes.html
Long-lived garbage, I assume. Short-lived garbage should be perfectly fine.
&gt; but every other collector that I'm aware of is, at some point, stop-the-world. Go did some nice progress recently on that front... But I have no idea how it compares with contemporary Java.
I don't play favorites... I like all lisps! Maybe I'll get to work in Shen someday. That would be awesome. The ML-ishness combined with s-expressions makes it really fun to hack on, I can only imagine what it would be like to write a large system in it
&gt; Isn't this really an issue in how the application was written? Relying on the gc heavily in a high performance application is a no-no. In fact, really, allocating memory dynamically is kind of a problem. That is the root of the problem, yes. 
From what I've seen, it is behind. Go recently implemented what is synonymous with Java's CMS collector. That being said, Go does push more more GC control to the programmer. Where in java it is the wrong thing to ever do a System.gc(). In go it is practically encouraged where you need it. In fact, I believe it even offers the ability to disable and enable the collector.
Eh. I prefer lisp myself, but Clojure has rabid adherents for some reason.
Thanks for this. This definitely makes more sense then. Erlang is definitely a well designed language, I've used it once or twice. It definitely makes the actor model very attractive.
ABCL performance vs clojure? You should actually test these before you drop more uninformed opinions.
You should follow your own advice.
This is not how I'd do it. Quicklisp automatically loads dependencies and isn't the central registry something from ASDF2 and not relevant in ASDF3?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/badmathematics] [You are a lambda represented by the secureHash of your real name in the future...](https://np.reddit.com/r/badmathematics/comments/3vkv5m/you_are_a_lambda_represented_by_the_securehash_of/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
It isn't too hard to write code that is heap friendly in java, but it isn't really as transparent like it is in Go or C#. Java's escape analysis does a good job of pushing more memory allocations onto the stack and off of the heap. But the bad thing is that it is hard to tell if that will happen or not and easy to accidentally tweak the code in a way that makes that not happen.
Good read for beginners, but the page is not appealing. Doesn't look modern at all, but it's not even the worst lisp article I've seen. I find it typical of the lisp world and I find it too bad :/
AIUI the issue is that the registers and stack on x86 in SBCL can sometimes contain non-Lisp values but the run time system doesn't have the ability to keep track. Therefore, the GC must sometimes assume something that resembles a Lisp object reference is valid, and that can mean an arbitrary amount of memory is not collected because the assumption was wrong.
Could you expand on Point 5 about avoiding full function calls? Maybe with a couple of examples?
Probably not, nobody ever pipes up to claim they've read and understood it when this question is asked... Tiny bit more information [here](http://stackoverflow.com/questions/23309082/global-type-inference-in-the-scheme-compiler-stalin) and [here](http://cstheory.stackexchange.com/questions/9765/the-stalin-compiler-brutally-optimizes-but-how) though. That second one mentions that [MLton](http://mlton.org/) is designed with similar basic principles in mind (or at least, that it also uses whole-program optimization). MLton is for SML, so it's statically typed, but since Stalin also uses type inference anyway, this difference probably doesn't hurt too much. Unlike Stalin, MLton is very well documented and [actively](https://github.com/MLton/mlton/commits/master) maintained, so it might be better for learning from even if it turns out not to be quite as powerful.
Some time after Stalin, Pearlmutter and Siskind used it as a basis for Stalin∇ (pronounced Stalingrad), which they used to research automatic differentiation. Not sure about Pearlmutter, but after Stalin∇, Siskind seems to have lost interest in compiler techniques. As far as I know, its most recent offshoot is DVL, found at: https://github.com/axch/dysvunctional-language
While helping another user, I found out that cl-project and hence caveman2 will load the quicklisp library version of UIOP (actually the first in the registry) instead of the asdf version built-in SBCL. See https://github.com/fukamachi/caveman/issues/73#issuecomment-149878032 ; notice the change when cl-project is loaded. 
I've never used flair. How does it work?
Thanks!
So wait a second, just to be perfectly clear, the implementation that person was talking about includes encryption, but not decryption? Edit: Sorry for the snarky tone.
No `ccl` flair? :(
Agree.
this code is useless for you. let it go. 
Very nice indeed! I look forward to playing &amp; using it. 
I will take a look at this.
Looks nice. It's terrible on mobile though :-)
[Gambit](http://gambitscheme.org/wiki/index.php/Main_Page) supports iOS apps. The source of the official repl app is included as an example in the distribution. Has an [Objective-C bridge](https://github.com/maitria/gambit-objc) which is pretty cool (modifies the reader to turn square bracket expressions into Objective-C method calls). And of course allows direct inlining of C code for lower-level stuff.
This is probably too wide, but can we get some symbolics flair? [Imgur](http://i.imgur.com/apD2pQv.png?1)
added. actually 70 pixels isn't too bad. 
[The pattern transformation rule](https://github.com/guicho271828/trivia.balland2006#patterns-transformation-rules) in balland2006 optimizer of Trivia automatically do [something similar](https://github.com/guicho271828/trivia/wiki/Benchmarking-Results#actual-log--optimization-trace) to this, not only for strings but also for any kinds of destructable constructs, e.g. structures, class slots, vectors and lists. Something missing in balland2006 is the part "finding the best split" in the link, which I suppose is equivalent to "how to reorder subpatterns", and also, in the terminology of Ordered BDD, it would be "finding the optimal variable ordering". I have an [incomplete code](https://github.com/guicho271828/trivia.balland2006/blob/master/src/column-swapping.lisp) for this optimization, but it is not integrated to the optimizer yet. Another point is the clever idea converting `(and (char= ....) ...)` into `(zerop (logior (numeric-char= ...)...))`. Is this even possible for a standard compiler-macro?? I guess no. I also like how he fluently speak VOPs for sbcl. I've never had a chance to optimize the core code to this level, but I definitely want to do this in the future. 
I know other subs do it, like /r/CFB. Maybe you could ask them for their recipe?
Thanks for posting the update.
hurray!
There's a lot of this that's on stackoverflow. For example, in the section re. Quicklisp project directories: (pushnew (truename "/my/projects") ql:*local-project-directories* ) (ql:register-local-projects) ;; I think that's the name - going off of memory. I was looking for that just last night to get away from the symlinks I had set up. It's not my intention to be negative - I'm not evangelist, but there's a ton of information out there and CL information has an extremely long shelf life compared to a lot of other languages. That said, I just can't help but comment on this part: &gt; Many trivial tasks took significant development time due to a combination of my inexperience with the frameworks and the libraries’ documentation which don’t compare to those of Rails and Django. So you knew CL already and that wasn't part of the problem? 
Thanks for the comment. I tried not to write about solutions which are already available. The posts are about things that made life difficult for me and for which I did not find the answer somewhere else. This is not groundbreaking work. It is just pieces of information which would have saved me a lot of time if I found them as presented here. The Quicklisp post you mention: I was not aware of (ql:register-local-projects). As the post says 'There is room for improvement...' but the concept in there remains the same. &gt; So you knew CL already and that wasn't part of the problem? I have been using CL for 2 years now. That is part of the problem but people starting out with lisp may have the same problem. I hope these posts help some of them. 
 (defmacro cons* (x y) `(cons ',x ',y)) edit: of course this was trivial to make up. The real question is: which one is more universal??
 (defmacro car* (c) `(eval (car ,c))) It would definitely play differently with special variables.
How do you like http://articulate-lisp.com/? I've been helping with it lately, and we could use more contributors.
Can we please turn off the flairs? I think it was a good idea and the test was useful. I support the general concept of making things more 'fun / interesting'. I think you guys should keep on trying out more of this sort of thing as well. Testing is good. However, it just doesn't look good at all. It just manages to add unnecessary noise to the forum and it screws up the uniformity of the layout. It already isn't fun or interesting either. Reading the sub now feels like having ice picks shoved into my sockets. Can we try to turn off the flairs for a little while and see how things feel when we go back to the way it was? I am betting everyone will find that much easier on the eyes.
This is a very helpful resource, well done ! I found my way easily and learned what I was looking for. I'll come back to it, for sure.
Assuming you are using the browser and not a phone application, simply uncheck "Use subreddit style" in the sidebar. The only styling this subreddit appears to do is the flairs so that's the only thing that will change I think.
It might be a more powerful construct but surely less efficient.
If you set up a 150 dollar (or so) kick starter for some prize money then I'll be sure to donate :)
Maybe we could do that next time when we see how it goes. This time it's not ranked and just for fun :)
"wizardry, a.k.a. dynamic variables" – /u/tarballs_are_good
The recording is [here](https://www.youtube.com/playlist?list=PLjHa38CO26-PWcJXE1G8XYlwmV4zdjbr9). Overall, I thought it was a bit drawn out and boring. Again, all coding is completely unprepared, just how I'd usually code on a typical Saturday afternoon. Unfortunately, a lot of mistakes were made, but I did learn a few things along the way. Thanks to all who could join. **EDIT**: For those who are interested in seeing the actual commits, the big ones are: * [group protocol](https://bitbucket.org/tarballs_are_good/cl-permutation/commits/db608ee0ffa23ccefaa788b3e769d2568ad37f3d) * [free groups](https://bitbucket.org/tarballs_are_good/cl-permutation/commits/e18b5c751d3ef82b7d35f5b824f97b382ae8e085) * [straight line programs](https://bitbucket.org/tarballs_are_good/cl-permutation/commits/aaf4440a3819cbd5438d0f368baec134fc8b294e) * (big one) [generator decomposition](https://bitbucket.org/tarballs_are_good/cl-permutation/commits/7884ba5d2570c9f2b81b7d621ca4f3e753c973b1) 
I'm glad you got this one recorded. I'm enjoying it now.
&gt; This was a good decision. I wouldn’t have finished if I tried to use Common Lisp — I’d probably still be struggling with whatever its Curses library is. I library I help maintain for high-level curses in Lisp is [CL-CHARMS](https://github.com/HiTECNOLOGYs/cl-charms). 
And, of course, you can trivially write a macro if you want the list to be flat, but then you'll have to include explicit nil's for those variables that you don't want to initialise (if you don't do something fancy) 
Hi, I wrote this. If you want to try the game but don't want to download and run a sketchy jar file you can use telnet: telnet silt.stevelosh.com The server can be a bit slow when a bunch of people are on. **EDIT:** I have resized the server to a beefy 8gb instance, so it should be a bit less fucked now.
The examples look similar to what I used for this... is there some more documentation I can look at to learn more? One thing that's nice about Lanterna is that you can use a Swing-based "terminal" so non-techy people can still play it. I wouldn't expect a curses library to provide that, but it was really nice to have for this jam.
I guess that's why I see : $ telnet silt.stevelosh.com Trying 139.162.222.182... Connected to silt.stevelosh.com. Escape character is '^]'. Debian GNU/Linux 8
I'd be curious what your reasons for leaving Clojure and choosing CL over it. 
Yeah the server is not having a very good time at the moment -- the JVM is a hungry beast and I didn't spring for a ton of RAM. There's always the .jar :)
Sorry, that was just my telnet noobness showing, and since then I had the pleasure to see a bit of action.
For some reason when I tried Clojure I expected the tracebacks to be much better (the JVM having had millennia of man-hours of work behind it), but damn. You may need a team of NSA cryptanalysts to decipher SBCL tracebacks, but Clojure's are not an improvement. EDIT: I have been toying with the idea of inserting better/more debugging calls by hooking into macroexpansion, the way [docparser](https://github.com/eudoxia0/docparser) does it.
Nah, I should really add a "Loading, please wait..." to stdout so it doesn't just look broken. 
But they are not "the first class citizens". 
It would be nice if the project said more directly about what is stored and how efficiently it can be queried or not. The examples I saw looks like it just a sequential bunch of stuff the lisp reader can handle. 
You can read the author's blog. He has written about fact-base. For example http://langnostic.inaimathi.ca/posts/querying-fact-bases From what I gather, it is an exploratory prototype. Same as his web server house. I like the define-handler API.
It's less efficient in some ways, but more in others. In fact, you can terminate programs with it that would loop endlessly with a strict cons. :\^)
Rainer Joswig has answered pretty much every single question I've had about lisp on stack overflow, he's knows his lisp.
At some point in time I made an attempt to create a Graph DB, I called it [ProtoGraph](https://github.com/maufdez/ProtoGraph), the link will take you to github, where it is hosted. I was between jobs at the time, so I had some time, and I was learning lisp so it is likely not very good code, but I think I will re-write it at some point.
My condolences 
I think that is a Marvin Minsky quote, originally. As I heard it, he would open up his CS 101 class at MIT with that.
&gt; Why do people think that bashing the most popular language AND its users is a good way to advertise theirs? That is a good point. But I think most people would take this quip as more like good-natured ribbing.
It's true though. If you know Java you'll probably have a lot of internal friction with things that don't work the way you expect. Probably true the other way around too. It's also a very good statement to make since people often think Lisp is hard, when it's actually the case that they have a lot of expertise in another language that's at least making them feel impotent, if not slowing them down.
The language may be fine, but the environment most people seem to want you to write it in is terrible and asking for an alternative is treated like sacrilege. 
Good idea / implementation, but that syntax looks horrid to me (although I guess the html mixed with js is a react thing). I prefer having the dom set up and modifying the inner html or values via the js rather than mushing it altogether.
This has been more pleasurable to use than Om.
Once nice thing is that, since it's lisp, you can make it look/feel however you like. https://gist.github.com/cmoore/a34033658d691785c5a2 
Thanks for the kind words. Yes, it's a very thin wrapper, aiming just to Lispfiy idiomatic React components and JSX. That done, I now have a translation target for generating and driving React from server-side CLOS-based components.
That's actually really nice. I'd be interested in better benchmarks than empirical tests. If I understand correctly, this is like using virtual dispatch in development mode while switching to static dispatch in production mode. Really nice.
&gt; Why do people think that bashing the most popular language How are you supposed to sell product A if youre not allowed to tell a user of product B that A is better? &gt; AND its users is a good way to advertise theirs? Because MPAI, and youre trying to get those who arent, because they tell everybody else what to use. &gt; stay away from your oh so fancy full of buzzwords language Stay away at your peril. &gt; don't make fashion statements. Lisp is an underdog, fighting an uphill battle against the "standard compatible corporate market leader MPAI solution everybody else uses" cant be won without loud, bold claims.
Agreed. Of course, there's a difference between pre-figwheel manipulation of the DOM from a REPL and figwheel's on-the-fly code loading. Figwheel makes the experience a bit more like programming with Common Lisp, Smalltalk, or Erlang. However, Javascript's reload-the-page-and-go falls far short of those three systems' capabilities, and Figwheel must leverage Clojurescript's immutable data structures along with programmer discipline to make this work.
&gt; How are you supposed to sell product A if youre not allowed to tell a user of product B that A is better? Like every other ethical advertisement, use positive marketing. Show has fast your language can do A, show how nice and clean the code is for doing B,.. Others will automatically compare it to what they use and will notice the difference. Making snarky/degrading remarks at your target consumers is never a good idea.
That reminds me a bit of what beach is trying to do with SICL's CLOS.
&gt; Like every other ethical advertisement So youre not claiming that its inefficient advertising, but that youre merely trying to enforce your particular understanding of ethics? &gt; Making snarky/degrading remarks at your target consumers But they arent *all* target customers. You denigrate the one half to sell to the other half. Lisp's selling point is that its better than "blub", and that by not using "blub" like your average cubicle drone corporate competitor, you can outcompete him and he wont even understand how. "Dont mention java, by the name of god dont mention java" is just dancing around the bush. Badmouthing competitors *works* in advertising, and it works so well that it is often perceived as unfair and harsh and has to be banned for "ethics violations".
&gt; blow out your cache I guess you mean here about L1 or L2 cache of the CPUs. Yes, inlining might blow out the cache in the worst case. However, if the cache mishit occurs (I guess it would be rare,) you can just switch back to the normal GF since there is no new language syntax. Also note that if the surrounding environment contains type information, most branches of the dispatch tree (in `ematch`) can be safely detected unreachable by the compiler like SBCL. For example, the compilation result of the code below does not contain dispatching actually. (defun func-using-inlined-plus-and-type-added (a b) "Thanks to the nature of inlining, smart compilers like sbcl can detect certain branches are not reachable, thus removing the checks and reducing the code size. In this example, the code for dispatching DOUBLE-FLOAT is removed. ; disassembly for FUNC-USING-INLINED-PLUS-AND-TYPE-ADDED ; Size: 29 bytes. Origin: #x10031E7788 ; 88: 4801F9 ADD RCX, RDI ; no-arg-parsing entry point ; 8B: 488BD1 MOV RDX, RCX ; 8E: 48D1E2 SHL RDX, 1 ; 91: 710C JNO L0 ; 93: 488BD1 MOV RDX, RCX ; 96: 41BB70060020 MOV R11D, 536872560 ; ALLOC-SIGNED-BIGNUM-IN-RDX ; 9C: 41FFD3 CALL R11 ; 9F: L0: 488BE5 MOV RSP, RBP ; A2: F8 CLC ; A3: 5D POP RBP ; A4: C3 RET " (declare (inline plus)) (declare (optimize (speed 3) (safety 0))) (declare (type fixnum a b)) ;; &lt;&lt;--- new here (plus a b)) &gt; some Lisps need to "warm up" their method caches This is a different question, right? yes, I recognize this. In order to sort out every effects of cachy things, in the experiment I ran the benchmark 1000 times, GC, then ran once, then use the last result only. &gt; ordering the code respects the argument precedence order of GF. but I found a bug here, the arguments to `ematch*` is not reordered. 
I find the irc channel #lisp on freenode very welcoming and a good community. I don't generally use mailing lists so can't help you there. Also, based on your username, you may like #lispgames. We talk about game development with the lisp family of languages (not just common lisp)
Thanks :)
Ooh..! While inline documentation is nice, most CL documentation sites aren't very pretty. I wouldn't mind seeing more projects use this. (That said, it has some issues on mobile.)
Wouldn't it be an idea to have the geographical location on the page too?
I don't understand what this is. Is it a social group? A single event? A hackerspace? A teleconference?
Similar: String "autocomplete" with tries. [CL-STRING-COMPLETE](https://bitbucket.org/tarballs_are_good/cl-string-complete)
Nice. I'm curious why you tend to prefer structs, is it because you can type slots?
You do see options records in Haskell occasionally. One notable example is Options in Wreq (http://hackage.haskell.org/package/wreq-0.4.0.0/docs/Network-Wreq.html#t:Options), although the suggested usage there is to construct the record instance using lenses.
This is true. I think reading through his Stack Overflow answers probably taught me more about how Common Lisp is used in the wild than anything else. If nothing else, it taught me just how deeply the spec is A Good Thing.
If you want to do a bunch of function composition, Lisp let's you "build the language up" using macros to meet that task. Some posters already added some examples of how to do that. I'm less sure about Haskell in that regard.
Is this just a chat app? "Delicious conversations platform" isn't very descriptive.
This is a table at the [32C3 conference](https://events.ccc.de/congress/2015/wiki/Main_Page) in Hamburg, Germany.
look for google koans in lisp
 (defn average (x, y) (/ 2 (+ x y) ) ) Aaagh my eyes! What did those poor parens ever do to deserve such horrible abuse‽ Edit: http://dept-info.labri.u-bordeaux.fr/~strandh/Teaching/MTP/Common/Strandh-Tutorial/indentation.html
And why is this average function written as (/ 2 (+ x y)) and not (/ (+ x y) 2)
Google Foam is kind of this sort of thing.
Shouldn't average take a list and average all members instead of only two?
Sure. But taking the average of two numbers is fine, and it's for demonstration purposes. Saying it's the average, when it's actually the inverse is really confusing unless the author has decided that the argument order for division is just going to be obtuse for no reason.
I think it's a great demonstration. I'm glad it exists. Sorry for my pedantry. Thank you for taking the time to explicate it. Well done, and Merry Christmas!
Your link syntax is broken because you didn't specify http://
Always interesting to read such an approach on transpilers, thanks for sharing. What do you think about this one: http://epsilonwiki.free.fr/alphawiki_2/?view=foo ?
Our company uses Haskell and CL almost exclusively, and for me at least, building the language to meet the problem is one of the largest benefits of CL. That said, you can do it in Haskell as well, though it's not near as flexible. You can define EDSLs, and manipulate syntax a bit with infixr and template haskell, but it definitely lacks CL's fluidity. 
I wonder if JIT compilers couldn't be doing this implicitly.
Have you seen http://adventofcode.com/ ? I'm using it to take off the training wheels and write Racket code without a tutorial myself, it's been quite fun.
The site is down.
https://bitbucket.org/ktg/lispscript
The object layer IS quite nice and is why I continue to use it despite its size and age. As you say, though if you are just firing off a few queries, the object layer and learning curve are going to be off putting. If you do end up looking at clsql, be sure you checkout clsql-helper and clsql-orm as well. These are two libraries that I maintain to make working with clsql better. CLSQL's orm by default is intended to be code first (ie: write classes that are mirrored into a db structure created for you). The clsql-orm project provides a DB first approach (ie: I already have a functional database, I want to generate clsql-objects that are based on the table structure). Clsql-helper just provides a bunch of "useful to me" shortcuts. With relatively little work, you could probably patch clsql-orm to generate custom objects intead of clsql objects (just change `gen-view-class` to output a different class structure).
It is wildly different. LOOP is an entire language which extends beyond the list-monadic operations provided by Haskell's comprehensions. 
I meant that there's no difference philosophically speaking, not in terms of actual functionality. The article claims that Haskell does everything through simple function composition, while CL provides situation specific constructs. However, clearly Haskell does that as well with its list comprehensions so the whole argument is a bit of a straw man to begin with.
Ah, I see, I misunderstood. You're correct. 
Clicking on the link tries to download some .ps a file. It is no wonder Lisp has the reputation of being archaic. Could the guy who posted the link create a text post and link it ar tar.gz of the file and add some explanation?
See also [quotes](http://weitz.de/cl-recipes/) on author's website.
Nice. Thanks for the heads up, OP. I've just purchased the eBook version from the Apress's website, and the quality of the eBook is superb. I'm going to enjoy reading this tonight.
Thanks for the heads up. Been checking this every couple of days with no updates. Purchased ebook and am impressed it's multi-implementation.
Just download the [code](http://weitz.de/cl-recipes/code.zip) and work through the examples (as described on the top of each file). I think this way you'll get a pretty good idea of the book's contents.
Very excited for a new lisp book...does he cover connecting to SQL databases like Oracle?
There is a section devoted to accessing and working with relational databases using the CLSQL library, and while the example in the book uses SQLite, it shouldn't be too difficult to modify it to work with other databases.
I'm in the same boat as you. I feel penalized for pre-ordering
&gt; The cons cell is the only SI data structure still based on a physical object. Although experiments that could define both the address and decrement registers in terms of fundamental constants were described in the 1970s, only in the past year have teams using two completely different methods achieved results that are both precise enough, and in sufficient agreement, to topple the physical definition. &gt; … &gt; The relationship between NIL, chassis ground and Earth ground will continue to be a subject of ongoing debate. T was redefined by Jonathan Rees and Kent Pitman to be based on the [fine structure constant](https://en.wikipedia.org/wiki/Fine-structure_constant) since anything [T](https://en.wikipedia.org/wiki/T_(programming_language\)) is fine, of course. This redefinition caught on due to Pitman’s (and Steele’s) influence in X3J13 and became part of the Common Lisp standard, so that both Scheme and CL use the same value of T despite slightly different representations. The old platinum-iridium T is kept around at the MIT CS and AI Lab (CSAIL) mostly for nostalgia’s sake. It is occasionally necessary to compare it against the modern T standard when porting old Maclisp or Zetalisp code. Interlisp had different physical standards for T depending on whether the implementation was on a PDP-10 or a Xerox machine. The original standard Interlisp T was actually kept at BBN in Cambridge, Massachusetts, but Xerox found this inconvenient because they’d have to fly from San Francisco to test against it so they eventually produced their own T at PARC. Rumour has it that this still exists in some basement at Stanford. LISP 1.5 was actually very far ahead of its time with T defined on the basis of the speed of light in a vacuum. This became inconvenient however when most computers shifted to transistors instead of vacuum tubes, meaning that special tube-based hardware was required to implement T. That’s when using the physical standard became common, because you could just copy the measured value of the physical T and hardcode it in your compiler.
Give check-it a try (https://github.com/DalekBaldwin/check-it). It already has shrinking. 
Looks nice, I definitely will try it out!
Have you given CCL a try? From what I heard it works quite well on windows.