Common Lisp programs aren't strings. They are Lisp lists, symbols, strings, numbers, etc. The semantics of Common Lisp are defined on the Lisp data structures, not on the strings. Tcl gets this right, too.
Lisp isn't unique in being converted to a different data structure through parsing. I still don't see how to discern whether or not a language is homoiconic. Is there an objective test that can be run or applied to a language which shows that it is homoiconic?
lisp exposes a three step execution model, (loop (print (eval (read)))). when you read a stream of lisp code, you get back a lisp data structure. `(+ 2 3)` is a list of a symbol +, a number 2, a number 3. you can then send the result into the evaluator, which will produce 5, and the printer prints `5`. after read phase you can modify the list using standard lisp operations, e.g. (setf (car list) '*) will get you (* 2 3). sending it to evaluator will produce 6. homoiconicity is the fact that (* 2 3) can stand for both code and list. you have lisp's (DEFCLASS FOO NIL ((A :INITFORM 1 :INITARG :A))) which defines class "foo" with one slot "a", with default value 1. equivalent java code would be: class foo { Object a; foo(Object a) { this.a = a; } foo() { this.a = 1; }}. in lisp i can read the defclass above into value, and then say (setf (first (first (fourth value))) 'b), so now the name of slot "a" becomes "b". (DEFCLASS FOO NIL ((B :INITFORM 1 :INITARG :A))) this happens during compilation phase, i.e. evaluator is still going to compile (defclass ...) into internal class object representation. homoiconicity is the fact that both (defclass ...) above are simultaneously valid lisp code, and a valid lisp nested list structure.
It worked. As you said, the solution was to bind swank::*emacs-connection* and then wrap swank::with-connection around the call to eval-in-emacs. Thanks for your help!
The two main steps involved in compiling or interpreting a lisp program are 'read' and 'evaluate'. Before 'reading', the program is text, nothing special, like you noticed. The 'read' step turns the text into lists and atoms (data). If your program is syntactically correct, everything becomes one of these two very simple-to-manipulate types of data. Also, this data is arranged identically to how it looks as text. (+ 3 3 ) becomes a list of the symbol +, 3 and 3. That's the special type of homoiconicity lispers talk about. The data to be produced by 'read' is clear to the programmer and of a kind that is very easy to manipulate in Lisp itself. 'Evaluate' does what you'd expect with the data produced by 'read' based on whether you're interpreting or compiling. In lisp, you can manipulate the data produced by 'read' using macros. You can define new manipulations by defining new macros. This is greatly simplified in Lisp for the reasons I mention above. You are essentially modifying the Lisp compiler using Lisp. The changes can range from adding a handy special form (I only have 'if' but I also want 'cond', 'case' etc) to writing the specs for an entire DSL. 
Lisp expresses everything as a list of s-expressions. Every line of code is a data structure of expressions. The data is code and the code is data. This means a lisp program can actually change itself at runtime. How many languages can do that? 
[Python](https://docs.python.org/3/library/functions.html#compile), to name just one off the top of my head.
Python has very lispy attributes, but it isn't quite the same. Peter Norvig has written about it quite a bit. 
It's always been a bit unclear to me what lispers mean when they say this, but as far as I can tell what they really mean is that the syntax of the language is simple enough that it is easy to see the AST just by looking at a LISP program, and more importantly this makes the AST easy to manipulate using macros. By contrast, a Java syntax tree is more complicated. I suspect that it also helps a lot that LISP is a dynamically typed language as well because this means that macros can cut and paste things in the AST willy-nilly without having to ensure that these operations are soundly-typed.
Thanks, I’ll keep that in mind. You are right, it does seem great and provides “instant gratification” by tweaking Emacs. :)
Thanks, they’re on my list!
I agree that they are different, but I think my point still stands that if we had a box labeled "programming languages that can compile code at runtime" then LISP would not be the only language in that box, though maybe in LISP it would be easier to build the AST to be compiled than in Python in some or even most cases.
I know that this is off-topic and I am prepared to be downvoted for asking this, but is there some context I am missing for why /u/Godd2 is getting so many downvotes just for asking what appear to me to be genuine questions?
Not sure about Common Lisp implementations but Picolisp has ] which does exactly that. 
the second point is not necessarily true. type system is orthogonal to macros, since macro transformation happens before compilation phase. you can do arbitrary macro transforms, and once you're done you'll hit the compiler, and if you had a proper type system, you'd just get earlier notifications of making a mistake. in fact at least sbcl/cmucl has a gracefully degrading type system: a type sound code is going to have the benefits of inference for the purposes of optimizations. when things are inconsistent the system warns you, and upgrades the relevant code paths to a more general type. (it's still an adhoc system though.) at the end of the day, there isn't really willy nilly involved: you can't produce "invalid" code, where "invalid" is whatever the next phase considers it to be.
It was a mandatory part of my CS curriculum and emacs.
our lady discordia ASKED me to get a PEPPERONI PIZZA but i thought she wanted me TO LEARN LISP instead. hail eris!
Lisp has an interface to run programs: the function EVAL. The input to EVAL is Lisp data, not a string. Thus we can compute programs with Lisp data operations, not string operations. This representation is similar to a hierarchical tokenizer output - but here it is exposed to the user, such that the programs have a textual representation that can be read by such a tokenizer, which Lisp calls READ. In Java programs are not written in a data format and the programmer does not interact with it.
it's possibly because both you and Godd2 are aggressively refusing to work towards understanding a complicated point. homoiconicity of lisp is a non-trivial aspect of the language, something that people, when they grok it, often find enlightening. to understand it, you have to actually work with the person you're asking the question from. it's both self-defeating and annoying to adopt an adversarial position in a case like that. are you actually trying to understand something, or just convince people that already do, that they are wrong? no, python is not homoiconic. no, it's not just about "simple syntax". no, it's not because both are strings.
Lisp code as data is not an AST. It does not carry syntactical information. Lisp code is hierarchical data structure usually made of lists, symbols, numbers, strings and some others.
Here you can find an interesting discussion on the concept: http://wiki.c2.com/?HomoiconicLanguages
The text you store is an external representation of s-expressions. Nobody forces you to do that. You could also compose your programs with Lisp operators and save the program as a memory dump. You can type (+ 1 2) and run it with by calling the reader and evaluating it. You can also type (eval '(+ 1 2)) or even (eval (list '+ 1 2)) 
That's an AST object and requires parsing. The Lisp reader is not a Lisp parser, but reading exteralized s-expressions into an internal data format.
'compile at runtime' is something else - initially you were asking about 'homoiconicity', which is a different concept and means for Lisp that programs are store in a data format - both in text and possibly also internally - a data format other than trivial strings.
Java programmers usually don't interact with an AST. Lisp programmers interact with s-expressions, which is a data format - textually and internally.
&gt; If your program is syntactically correct, s-expressions themselves only have a syntax on s-expression level. A valid s-expression is not necessarily a syntactically correct Lisp program. READ thus only reads s-expressions, not Lisp programs. For example (LET (sin a) ((a 10))) is not a valid Lisp program, since the syntax of LET requires the bindings as the second element and not later. The reader will read that program just fine, but the compiler and interpreter will complain about the syntax.
Hi, OP here. I didn't want to insult Quicklisp either, it's the best system manager I've ever seen. I read the instructions the way joked about which confused me at first, which inspired me to make the impatient joke portrayed.
&gt; If this is true, then I don't understand something. Yes, yes that's true. Consider this piece of Ruby: [3, 4, 5].map(&amp;inc) That isn't a data structure on Ruby, you couldn't write a program in Ruby that could work on that other than as a string. The equivalent in Lisp (map inc '(1 2 3)) is both a piece of code and a data structure. And you can use Lisp to parse it: i.e. you would use list, not string, operations to add an element to '(1 2 3) or to replace the "map" with "mapcan" or delete all even numbers from the list '(1 2 3). You can't do that in Ruby because at best it's just a string and you'd have to do all the painful and very fragile parsing yourself.
I came because of its regularity, I stayed because of its usefulness.
Every language that can do `eval()` will be similar to Lisp in some aspects. The difference is that in Lisp everything is a s-expression. So for example when you do a decorator in Python, you'll be limited to putting code around the function. In Lisp on the other side if you do the same thing with a macro you get full access to the underlying s-expression. This means you can not only manipulate the behaviour of existing code, but can build custom languages inside lisp as long as they are valid s-expressions. So in practical terms this means that when you want to play around with new programming concepts, you can implemented them straight in Lisp itself. For example object oriented programming in Lisp can simply done with a bunch of macros, no need to reinvent a new language, you can just implement that functionality in Lisp itself. The strength of Lisp is however also it's downside, having everything be s-expressions doesn't lead to the most readable code, but it does make it very easy to invent new programming concepts that would be impossible to do in most other languages. 
You could theoretically do it with macros if you override the reader macro `#\# #\(`. I consider this to be a wrong idea though because it cripples editing capabilities, such as simple paren-matching and S-expression jumping. In case you have code like `(foo (bar (baz)))` when your cursor is at the beginning of `(BAR`, you can no longer jump to the end of this S-expression to quickly type something like `(quux)` so the resulting code is `(foo (bar (baz)) (quux))` because, all of a sudden, you have `(foo (bar (baz}`.
If you're annoyed by the parenthesis, I suggest to have a look to some editor plugins (for emacs): http://wikemacs.org/wiki/Lisp_editing My favourite, after a dubitative period, is lispy-mode now. It allows structured editing and movements.
I'm coming from Python and JS, I write web apps and I am frustrated by lots of things, I had appreciated a lisp and a live environment with Emacs Lisp so I had the intuition CL could help. Of course I was hooked by the old fame. After a harsh initial period, which hopefully should be easier now with some better doc (CL cookbook, awesome-cl, etc) and new projects (Portacle), it delivers. First thing firsts, I am tired of Python (the language) limitations. For example, context managers are cool, but I can't do what I want, and I often wanted to do more. It's also a special construct, with its own class, constructor, rules, etc. There is space for better refactoring constructs. This is naturally fixed by Lisp macros, which are a simple element of the language. Python's code is clear, but editing it is boring, and the language and the indentation make good tooling difficult. I spent time implementing an emacs package to navigate more easily through indentation, I searched for packages to navigate more intelligently (go to beginning of defun, go to next statement,…), but I realized this is fighting against the language. This is all natural in lisp (specially after I learned lispy-mode). I am bored switching between a terminal and my editor to run a python repl or run my tests. I couldn't do all this inside emacs, and anyway a local webserver is typically run in a terminal and it restarts at each code change. This has always been better with a Lisp REPL. I can run the unit tests I am in right away (C-c C-c, with Prove), when I contributed a little bit of code to Elpy which didn't work anymore some months later. Python the platform… it is slow and I feel it even on my little projects. SBCL compiles to machine code. We can't even build an executable O_o Let alone one of a web project… we can build self-contained executables of a web app in CL, it will contain the production server and even an interpreter and the debugger (which other lisps do not do). I can rsync the binary to my VPS and run it. That simple. I can ship software to non-programmer clients. Well, the joys of a compiled language, with more stuff. Let's speak about the ecosystem. I hadn't realize before but it is way saner and it allows to do more with less. About deployment, in Python you use the django dev server, then what do you peak between apache's mod_wsgi, mod_python, gunicorn, uwsgi, also whitenoise, rednoise, etc ? In CL you development with a the production webserver, you compile your app with it, you deploy with it, it runs and is accessible right away. Then pip seems to be nice, but for deployment, given there is no standard way to package all the dependencies (maybe platter ? But who speaks about it ?), everybody uses pip install on production, then you can get dependencies mismatch and installation errors *even if you pinned your dependencies*, if a dependency didn't pin its owns well enough you're screwed. And Python and its libraries are not stable. You need work to upgrade to python 3, to upgrade django and all the rest. If you don't you can have dependencies problems. And the thing is I don't want to do that in my personal projects, I have application code to write thank you very much. The JS ecosystem is all worse, the JS frameworks again worse. What does CL offer for the web ? Well, hard question. I didn't try Parenscript or JSCL and I don't plan to, I'm betting on web frameworks that don't rely on JS: https://github.com/vindarel/awesome-no-js-web-frameworks Ocaml's Eliom (a pain to install, compile and deploy AFAITried), Haskell's Haste and others (no thanks), Nim's Karax (yeah, excited about that one, but it's all very very much alpha), Clojure and ClojureScript (no thanks ! They're relying on the JS ecosystem too much and well, this lisp can't do as much as CL so I'd rather learn more), a couple others, and CL's Weblocks, which is being worked on here: https://github.com/40ants/weblocks/blob/reblocks/docs/source/quickstart.rst I'v got it working, but I'm not advanced enough to really judge its limitations. 
Duplicate of https://www.reddit.com/r/lisp/comments/8jy866/lisp_the_quantum_programmers_choice_computerphile/
Thanks a lot for this. I figured it was a bad idea I just wanted to see if it was possible. 
&gt;why did you decide to learn Lisp? Ok, serious answer now. After about 22 years of programming, having used most mainstream languages, I had some warning signs. First one was, years ago, reading the greenspun quote: "Any sufficiently complicated C or Fortran program contains an ad-hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp." I didn't understand the reasons why, but I took note. I always was interested in different languages, having tried a bit of Forth and Prolog in the past. Prolog blew my mind off, so I was eager for repeating such an enlightening experience. Years later, I found a post announcing the Land of Lisp book, whose website [has a fascinating comic](http://landoflisp.com) which motivated me to dig more into Lisp. I wasn't new to a "dynamic" programming language, being already quite experienced in Python. However, after reading the Wikipedia articles on Lisp and Common Lisp, and the famous Paul Graham article, and the first chapters of "Practical Common Lisp", it was very clear to me that this was potentially the most powerful and flexible programming language i've ever found. First, i was totally convinced by metaprogramming as implemented on CL. The benefits and usefulness were obvious to me immediately. Second, the conditions-restart system. It was the obviously elegant way to handle exceptions. The Land of Lisp comic was right: "*Back in the eighties, we showed you how to program without ANY bugs!*" But in particular, reading about CLOS blew my mind, and after understanding multimethods and method combinations, it became completely clear how wrong was the typical (i.e. Java) approach to OOP, and how CLOS was the salvation, the purification of prior sins. Thus, I had to set myself on the task of learning Common Lisp, no matter how hard it could be. This was the programming language for me. 
Sure, but function pointers aren't closures. For example, you can't write a C function that takes a string `s` and then returns a function that compares its argument for equality with `s`. Function objects in C++ (instances of classes with overloaded `operator()`) were always capable of simulating closures, but the amount of boilerplate required was painful. To contrast, here is some modern C++ code: auto f(const std::string&amp; s) { return [s](const std::string&amp; t) { return s == t; } } And here is some modern Java code: public static Predicate&lt;String&gt; f(String s) { return t -&gt; s.equals(t); } Again, quite noisy compared to LISP, but still a considerable improvement over previous versions.
For me, Eric S. Raymond is at fault. First, he is sometimes quoted saying that learing Lisp will make one a better programmer, even if one does not use it much. This being due to an enlightenment when one finally gets it. Second, I read a bit of The Art of UNIX Programming. It features a case study on Emacs (and thus, Emacs Lisp). All of this sounded very interesting to me (a staunch vim user at the time). So I gave Emacs a try and used it as a good excuse to learn some (Emacs) Lisp. It was all fun and games, but elisp does have its limitations, especially when it comes to using it outside of Emacs (hint: don’t!). One thing then led to another (some CL, some Clojure, very little Scheme), and here I am now, writing Common Lisp code for a living and loving it. PS: Yes, there were all sorts of reasons to get into Lisp, but I guess everyone gives them, so I’ll not bother you with the usual suspects. 
Lisp syntax is more like JSON. Much like JSON is made of a small set of data structures (numbers, strings, booleans, arrays, objects and a few other things), Lisp syntax is also made of a small set of data structures (numbers, strings, symbols, lists, and a few other things). Just like you can parse JSON into a nested data structure in memory even without knowing beforehand what this data means, you can do the same with Lisp syntax: you don't have to know the meaning of individual language constructions to be able to parse it into a structured data format. Imagine you had a programming language whose syntax was defined in terms of JSON. So, for example, the definition of a function `sum` to add two numbers could look like this: ``` ["define", ["sum", ["x", "y"]], ["+", "x", "y"]] ``` If you had a programming language like this, you would be able to read a program into memory as structured data and manipulate it much more easily than if you had to parse a plain string with a variety of different syntactic constructions. Lisp is like that, except S-expressions are a bit more lightweight than JSON (you don't need to quote everything, separate with commas, etc.). Basically in Lisp the process of _reading_ a program into memory and the process of giving it _meaning_ are separate steps, and the language provides mechanisms (macros) which enable you to intervene between those steps, allowing you to perform transformations upon the read data structure before it is given meaning / interpreted by the language. I hope this clarifies things a bit.
&gt; it's possibly because both you and Godd2 are aggressively refusing to work towards understanding a complicated point. I just don't understand how you could think that, though; I've been putting a lot of thought into trying to understand. Anyway, we are clearly not welcome here so I will just leave and save everyone the trouble. Good bye.
This is an obsolete approach called the "superbracket" which was featured in some Lisp dialects in the 1960's. The superbracket had to match with its mate. So that is to say, `]` would close everything back to the closest outstanding `[`, like this: `[defun foo () (... (... (... ]`. Today, you aren't working with punched cards; you can just hold down `)` so that it autorepeats, then stop when the editor indicates balance. If you overshoot by a few parens, backspace until the editor shows balance. 
Worst excuse ever, by my estimation.
Implementing a closing `}` superbrace that works without an opening `{` is unnecessary complicated and worse. You cannot control what is closed. An important property of the superbracket is that you can do this: (defun bigf-fun () [imperative-section-1 (... (... (... ] [imperative-section-2 (... (... ( ) .. ( ( )... ] ...) With your approach, the first occurrence of `]` will close the function and it's game over. 
In undergrad I worked in a lab doing biostatistics and machine learning in R. After undergrad I was looking for ways to step my game up for grad school. I heard that R was partly inspired by Scheme and that I could write better R if I knew Scheme. So I got SICP and started doing that. At the same time, I was also trying to improve my machine learning skills and got really interested in good old-fashioned AI accidentally through that. Then I saw that most of the best textbooks on gofai used Common Lisp. So I started working through Norvig's PAIP. Now I'm hooked. The process of creating things in lisp is so enjoyable and I don't want to go back to stat scripting in R again. In undergrad I thought I knew exactly what kind of research I wanted to do but now I am consumed with uncertainty. Thanks lisp.
You were right that wasn't the best excuse. What do you think is a good excuse? 
Write a macro...
I learned it out of spite. My older brother suggested I try it, based on the fact that I'm a mathematician, which in his eyes makes me some kind of space alien. (I always tell him that I'm the normal one, he's just an idiot. He agrees about the second part.) I was hoping that it would suck and then I could rub it in his hipster face. I could make fun of him at family gatherings for years with this! So I checked out the Little Schemer from my uni library and I haven't been the same since.
Agreed, but I view build, provisioning, deployment as part of a single process: there are interdependencies between the infrastructure, system package installation, configuration, and application service layers that should be explicit. I am interested in how tools could be made to reflect this point of view. These notions are admittedly still fuzzy in my head. In regards to ASDF-awareness, I am imagining the ability to state that a particular service is provided from an image built from some ASDF system, and should be present and running on hosts providing that service. Think something like guix or nixops taken to their logical conclusion.
Huge number of closing parens is a strong code smell. It hints there is a need to decompose the form further. Plugging it with superbracket is like using a perfume to hide the stench.
Woops, got carried away, my apologies. That doesn't answer your question, but beware :)
Lisp had been at the back of my mind for many years as I'd heard so many respected tech people talk about how good it is, but I never got round to learning it. What really motivated me was finding out about Lisp Machines. After I actually had a go on Symbolics Genera and was blown away by it I knew I had to learn Lisp properly. I wanted to make things that were like Genera.
No worries, lots of people have answer it already. I wasn't really thinking of using the } symbol, just wanted to see if it could be done. But the code smell part is something I need to keep in mind. 
Given the time users of this subreddit invested in answering to your questions, don't you think that concluding "we are clearly not welcome here" is a bit exaggerated?
Paul Graham's writings. I was also just getting into Emacs, so that helped -- I assume.
An excellent excuse is that you read the [FAQ](https://software-lab.de/doc/faq.html) and it resonates with you.
&gt; Given the time users of this subreddit invested in answering to your questions, don't you think that concluding "we are clearly not welcome here" is a bit exaggerated? If you could be confident that asking a question on a given subreddit would result in it being downvoted, would you be inclined to ask questions on that subreddit?
Every couple of years I look for a programming language to learn, the requirement is that it has to be different, so I can learn something from it, about 6 years ago (I think) I started studying options for a language to learn, I found Lisp in an article when I was investigating Python, and it sounded so cool that I decided to learn that instead. I'm glad I did, I learned more from Lisp than from any other language. Citing myself ["There are two types of persons, lispers and the rest, since the rest is cdr then lispers are the car."](https://twitter.com/MauricioFdezF/status/514070362795950080)
The word Lisp appears several times in a special period of my learning programming processing. So I thought, why not try to learn it, maybe it is fun. And, yes. It is fun for me.
&gt; The text you store is an external representation of s-expressions. Nobody forces you to do that. Is it not the case that a language is a set of strings over an alphabet with some grammar? If so, does this mean that Lisp is not a language?
DING DING! Me exactly \- I like the fact that the syntax was set waaay back then. And I find sexps easy to grok.
It's the structure after parsing which matters. Lisp programs are (linked) lists, not strings, and Lisp is has functions which operate on lists. Java programs aren't strings either, they're a tree structure generated by the parser. Java programmers don't have access to the Java parser or its output, unlike Lisp programmers who have access to the Lisp parser (read) and its output (lists). 
That's a different list, which can also be written as `(quote (+ 1 2))`. It's also a valid program.
Yeah, cuz like, I can't wrap my head around WTF the `vtable` would even look like, y'know? And, man, let's not even talk about pointer-to-member and multiple base classes with and without `virtual`. By the way, steam, still? When I quit C++, at that time, internal combustion was supposedly just around the corner.
&gt; for completelness sake, i'd like to add that the person above, user /u/gcross, have provided multiple invalid answers to questions and engaged multiple experienced professionals into a debate about the validity of his responses. I had and have no desire to have a "debate" rather than a discussion, and honestly it is *really* strange to me that the people here seemed to think that I did. The answers I was getting didn't make sense to me, so I pointed out where they weren't making sense to me. I also wrote down my tentative understanding of some things. Somehow, though, people seemed to think that I was trying to pick a fight, which is strange to me and not how people act in most subreddits. &gt; he then went and deleted his answers, only leaving the polemic in this thread. Yes, because all of my comments were being downvoted like crazy and this made me sick of the whole discussion. If you want someone to blame, blame the downvoters. &gt; the downvotes he had received strongly reflect his behavior, that he's now attempting to hide. Given that I was getting so many downvotes, this would seem to indicate that people thought my comments were a negative contribution to the discussion, so doesn't it make the most sense for me to remove them so that they are no longer getting in the way? &gt; i can not in any good faith interpret his actions as anything but malicious. Sure, whatever, if you say so...
Yes, but I don't see the advantage of doing it. Editors count parentheses for you. They also indent your code, so if it doesn't like up properly you can tell that something's wrong. 
&gt; Lisp programs are (linked) lists, not strings &gt; Java programs aren't strings either I don't understand. A language is a set of strings over an alphabet with a grammar. &gt; It's the structure after parsing which matters. This is at odds with the description of [homoiconicity on wikipedia](https://en.wikipedia.org/wiki/Homoiconicity): "If a language is homoiconic, it means that the language text has the same structure as its abstract syntax tree (AST) (i.e. the AST and the syntax are isomorphic)". Does "language text" not mean the source code?
I just wanted to know if it was possible tbh. 
I think you may have misunderstood me. `class X { }` is a string. A language is a set of strings, and that is a string of characters in the language "Java". `(+ 1 2)` is also a string. It is a string in the language "Lisp". In both examples, we can represent the code as a data structure within the respective language. If "being able to represent code (i.e. source text) as a data structure within a language" is homoiconicity, then both Lisp and Java seem to pass the test.
The problem with most Lisp newbies is that they're not really a newbie programmer and they're trying to impose what they understand from C, Python or Java (the ALGOL family) to a very different family of languages called Lisp, which makes learning Lisp more complicated. The worst thing is when they are really knowledgeable in other languages and they are **fast to conclude** Lisp is not so special because of so and so by just connecting their experiences from other languages and not by actually grokking Lisp first. Lets suppose that you are an expert with C++. Then trying to learn Java or Python (or any language from the ALGOL family) will be a breeze and trying to act knowledgeable in Java and Python is accepted. But Lisp is different, being a newbie in Lisp means your knowledge from C++ will make things more complicated because you have to force yourself to relearn a very different concept and become a newbie again (the investment principle). You see, trying to understand the whole concept of Lisp without grokking the basics of Lisp is an error. It is only when you grok the basics of Lisp that you will come to realize the beauty of this powerful language. And I'm still grokking Lisp to this day! The secret of what anything means to us depends on how we've connected it to all the other things we know. That's why it's almost always wrong to seek the "real meaning" of anything. A thing with just one meaning has scarcely any meaning at all. - Marvin Minsky
One can have a lot defintions of 'language' - choose the one you need.
Hunchentoot is good for running the server, CL-WHO for generating HTML and Parenscript for any JS generation is good. Iirc these recommendations and some usage examples came from a book called *Lisp on the Web* and is available free (if you provide an e-mail address to the publisher).
"Road to Lisp" thread, cool! I have an amazing story of how I got here, involving a bizarre convergence of coincidences and natural progressions. We have to begin at around 1999. Everything can be roughly summarized as: 1. Natural predilection toward liking parentheses. In 1999, suddenly XML was starting to appear all over the place. My reaction to XML was that it's complete garbage **that would be better replaced by something with simple nested parentheses or braces** instead of these silly verbose tags and whatnot. 2. In 1999 I wrote a textual macro preprocessor called MPP. This contained a lot of "Greenspunned" ideas. For instance, it had programmable read tables. I didn't get the idea from Lisp: I stole it from Knuth's TeX! The read tables assigned characters to "categories" like in TeX. The preprocessor used nested lists internally for everything. But, *alas!*, doubly linked ones, with explicit memory management; yikes. 3. I was paying my bills as a C++ developer on some multi-threaded middleware and such. I was becoming dissatisfied with the limitations of C++: how it didn't live up to its hype for me. I was really ready to get into something completely different. 4. I wasn't familiar with dynamic typing, but I independently invented it a number of years before that. Specifically in the context of math. It hit me one day: look, if we divide two integers and they are not even, why not just return an object that is tagged as a rational number instead of these damned declarations. Or a complex, if a square root of a negative real is taken. **I didn't know of and consequently had never used any languages which did this, and so dynamic typing is my idea, basically. Since it's my idea, I like it better than the horrible alternatives, and that's that.** Then, one fine day, I came into possession of the *Common Lisp: An Interactive Approach* by Stuart Shapiro and it all clicked into place. 
If you're from Clojure, I'd suggest [Spinneret](https://github.com/ruricolist/spinneret) over CL-WHO. It is closer to Hiccup, for e.g, to define id/class using selector syntax.
That's fair enough. Thank you for a non-hostile reply. :-)
Caveman2 [https://github.com/fukamachi/caveman](https://github.com/fukamachi/caveman)
Definitely, that or Ningle \([https://github.com/fukamachi/ningle](https://github.com/fukamachi/ningle)\) if you are looking for something lighter \(by the same author\)
if one appears to maintain too many closing parens, perhaps one should consider refactoring.
I'd recommend the Ningle/Clack/Hunchentoot stack, CL-WHO and perhaps Parenscript.
&gt; there is an internal AST representation, Python's standard library does expose the (subject-to-change) AST repr to work with programmatically, has done so for a while now. I'm *not* saying it's equivalent to Lisp, but you can do *some* funky stuff with it in a documented fashion (and of course, like lisp macros, most of the time you probably shouldn't, you probably just need a function...). Yeah, it's all less elegant that Lisp. I know that, you know that... * https://greentreesnakes.readthedocs.io/en/latest/tofrom.html * https://docs.python.org/3/library/ast.html 
In the section on the [implementation in Lisp](https://en.wikipedia.org/wiki/Homoiconicity#In_Lisp), the example they give can also be done in Ruby. # (setf expression (list '* (list 'sin 1.1) (list 'cos 2.03)) ) # -&gt; (* (SIN 1.1) (COS 2.03)) ; Lisp returns and prints the result # (third expression) ; the third element of the expression # -&gt; (COS 2.03) expression = "Math.sin(1.1) * Math.cos(2.03)" expression.split[2] # (setf (first (third expression)) 'SIN) # The expression is now (* (SIN 1.1) (SIN 2.03)). expression[21..23] = "sin" # Evaluate the expression # (eval expression) # -&gt; 0.7988834 eval(expression) But Ruby is not considered homoiconic. And representing Ruby as a string doesn't seem like that big of a sin, given that I can select/produce malformed sublists in Lisp. (setf expression (list '* (list 'sin 1.1) (list 'cos 2.03)) ) (eval (cdr expression)) So either A) there's something else more fundamental I'm still missing, or B) this doesn't show that a language is homoiconic.
My own path was Hunchentoot, realizing I was hand rolling a lot of code to load modules and make my app modular, which led me to wookie, which led me to Radiance as a full web app framework. I don’t regret it, but my needs were quite complex. And I wouldn’t understand Radiance as much without having been through these steps. 
&gt; I hate to see why it had such a reputation. I didn't understand this line. English is not my first language.
I mean to say had, my bad
I learned that Mirai was written in Lisp and that took me down a rabbit hole of Lisp and 3D graphics history. 
In Ruby you're dealing with a string and have to resort to counting bytes to extract and modify substrings. If you get it wrong, you could easily end up with substrings like "th.sin(". In Lisp you're dealing with a list, not a string, and can extract and modify subexpressions easily. You can only extract atoms and lists from Lisp expressions. You cannot produce malformed sublists. ((SIN 1.1) (COS 2.03)) isn't malformed, even if it does produce an error when you try to evaluate it. It's still meaningful as a data object. Before you say "th.sin(" isn't a malformed string that's perfectly correct, and neither is "(SIN ". If that *still* doesn't help, ask yourself what the Ruby equivalent of read is, and what its output is. 
Note that working with an AST usually means that the program needs to be first parsed into an AST - which usually means that the program needs to conform to the defined syntax - which severely limits the utility - unless you feed the parser new rules and syntax definitions. Since Lisp macros don't work over an AST, the input can be an s-expression which may use a significantly different syntax - as long it is an s-expression.
I believe the idea is that CLOS couldn't know what kind of API you want for creating your instances, using keyword arguments for all slots isn't much of an improvement over `make-instance`. I'd recommend adding whatever constructors you want with custom parameter lists and mapping that to make-instance. Just make sure that you keep them clean of any initialization logic besides parameter mapping, that kind of code is better to kept in `initialize-instance` methods since it allows user code to drop down to using `make-instance` if needed.
btw. (apply 'foo (cons a b)) is just (apply 'foo a b)
Oh wow, thank you
I should make a pitch for Ninglex (https://github.com/defunkydrummer/ninglex) which is Ningle with just a little extra added to be easier to use. The readme should get you going. This (as well as Ningle &amp; caveman2) is built over the Clack/Lack library which means you can have your choice of which lisp web server to use. 
Lisp in Ansible? That would make it fly. I hope. Probably being naive.
It does free up your mind to think about the problem eh, rather than using your mind to fight with the language and the lates comonad transformer pattern to use to re solve the problem more elegantly... yeah I’m a bit bitter lol
I like woo for cl, paired with other common libs like yason, cl-who, cl-mysql, parenscript, whatever!
there's probably no particular reason why things are done this way. the convention goes back to lisp machine "flavors", which predates CLOS. there you would do `(setq inst (make-instance 'myclass ':my-param-1 "foo"))`, and at some point you'd do `(funcall inst ':my-param-1)` to get the value out. i think at some point flavors wouldn't define any additional functions for you, though on a symbolics at least you can pass parameters to flavor definition to auto produce accessor functions. (my history is shaky here.) i suspect initially the whole thing was self contained, i.e. it wouldn't spit new functions into namespace, and gradually it grew with helpful functionality. but there's a bit of a good reason why make-instance is still a thing: it's actually a generic function, with a non-trivial protocol. `(make-instance 'foo)` works, but so does `(make-instance (find-class 'foo))` and that follows normal generic function behavior (so you can add customizations). there's very little you gain on top of this by poluting the namespace with `myclass` function. the convention, like basic-gongfu mentioned, is to defun your own by-order-of-arguments wrapper for make-instance. there's no particular reason why a richer, [defstruct style constructor definition](http://www.lispworks.com/documentation/HyperSpec/Body/03_df.htm) couldn't be added to clos class arguments, but it was not done.
There is another useful library — LASS. It is a CSS generator. 
`(:div#wrapper (:div.section ...)) ≡ (:div :id "wrapper" (:div :class "section" ...))` Huh. I might have to think seriously about replacing cl\-who.
I desperately wanted to use CL for a recent project, but I couldn't find a library that combined both threading and asynchronous (libev/libuv) approaches... Couldn't figure out whether I [woo](http://wookie.lyonbros.com) or [caveman](https://github.com/fukamachi/caveman) (though caveman has more things in it) was better.
For Clojure use luminus and head to /r/clojure it's author answers questions there and has written a book.
Checkout Racket's sublanguage: [web-server/insta](https://docs.racket-lang.org/continue/index.html?q=web%20applications) 
Wow, thank you for pointing out so many options! A long rainy week end is coming and now I know how to invest some of this free time :) Lately at work I have been using Flask and I like the micro framework approach so I think I will use Ningle(x) over Woo web server (no CPU intensive project so libev based event handling is enough) After evaluating what to use to handle web requests I will have to investigate: - testing - what to use for persistence: I am thinking about a document based db like mongodb, are there libraries which are non blocking and that play well with event based systems? - packaging and deployment: lately I have been using Docker and compose and I like this approach but I am open to more "lispy" solutions - CI/CD - logging and monitoring I think I will have a good week end :D Thanks again!
It's not so much a bad idea, more that it isn't really a problem if you use an appropriately set up editor: let it worry about parantheses. You'll usually be concentrating on the indenting and worrying if the editor indented in a way you didn't expect.
I'm biased, but I like [Radiance](https://shirakumo.github.io/radiance-homepage/) for the backend. I prefer to keep my frontend logic as minimal as possible, so I just write plain JS for that.
Writing plain JS is not keeping the logic minimal, leveraging some existing lib would reduce the amount of logic in the JS you write.
I keep the logic minimal. And thus, because I keep it minimal, I feel like I don't need to use any kind of library or framework, because using those would in turn increase the complexity without significant gain.
talking about JS libs, is there anything like reagent/reframe (or rum/cider) for parenscript? I'd like to not have too many languages in my stack but if there's not something like the mentioned libraries for CL I could just use clojurescript...or try at building a react wrapper for CL, which could be super interesting but a bit out of scope for my little experimental proejct. 
The [Keene book](https://www.amazon.com/Object-Oriented-Programming-COMMON-LISP-Programmers/dp/0201175894) advises to write such "constructor" functions, and at that time this conservative advice made sense. If you want to expose a traditional looking interface, that hides the fact that you're using CLOS internally, then it's a good idea to define a `make-foo` function. Nowadays, CLOS is widely supported and accepted. Therefore, you may want to expose the fact that you're using it to the user, which in turn may want to do things like subclass or define new methods. Then, it's better to just expose the class's name and let the user instantiate objects using `make-instance`. Of course, in certain cases you may want to provide convenience syntax to create instances, but that is another matter.
AFAIK caveman is based on clack for which you can specify which web server to use, woo included. I am intrigued to build my small app on woo but probably I will end up creating a small framework on top of it so probably it is better to use a small framework like ningle.
Can you elaborate on the "terrible idea" bit? As I understand it there are mainstream Scheme implementations that worked this way. I could see that I could be missing the serious flaws, but all I could come up with is. 1. Mild complication of the standard reader logic; they have to keep track of paren depth from top level, and handle \`\]\` specially. 2. Editor operations to cut and paste s\-expressions have to be a bit more intelligent to do things like split or merge the delimiter, generating or absorbing \`\)\` from or into the \`\]\`. 3. Loss of \`\]\` as an available bracket for user customization of the reader. Those seem like enough reasons to me to prefer the status quo, which is "if you really want to, customize your editor to change the \`\]\` keystroke to insert multiple parentheses". But they don't seem to reach the level of "terrible".
A curated and opinionated set of web frameworks and other libraries: https://github.com/CodyReichert/awesome-cl#web-frameworks I quickly tried Caveman and Ningle, I find them clunky and inconsistent (like how to get query parameters), then Lucerne seems sanier but less developped. They all need additional packages to ease debugging (clack plugins like clack-errors). I quickly tried Snooze and it felt better. Declaring routes and parameters is like regular functions, so there is less ceremony than in Caveman. It has built-in debugging parameters, it doesn't need clack-errors. But they are "only" backends, I'd love to write a dynamic web app all in Lisp, without separating back and front. Here comes Weblocks, which is being updated here: https://github.com/40ants/weblocks/blob/reblocks/docs/source/quickstart.rst This quickstart works very well, I have two little apps working on it. It's (also) very alpha, but full of promises :)
this is really interesting but I am more focused on experimenting with lisp in the backend; anyway this can be helpful in the future :)
[removed]
If you are searching for something easy and well integrated go with \[Racket \(Scheme\)\]\([https://racket\-lang.org/](https://racket-lang.org/)\) and DrRacket as IDE \- this is the easy route. A typical Common Lisp setup would be: \[SBCL\]\([http://www.sbcl.org/](http://www.sbcl.org/)\) Lisp \[Emacs\]\([https://www.gnu.org/software/emacs/](https://www.gnu.org/software/emacs/)\) as Editor \(\[Here\]\([https://github.com/caisah/emacs.dz](https://github.com/caisah/emacs.dz)\) some exaples of Emacs config files\) With the \[Melpa\]\([https://melpa.org/#/getting\-started](https://melpa.org/#/getting-started)\) package manager And the \[SLIME\]\([https://melpa.org/#/slime](https://melpa.org/#/slime)\) package for Common Lisp Plus the \[Spartparens\]\([https://melpa.org/#/smartparens](https://melpa.org/#/smartparens)\) package And \[Quickload\]\([https://www.quicklisp.org/beta/](https://www.quicklisp.org/beta/)\) as Lisp package manager The learning curve is quite high. You will learn a lot, it might often be frustrating. Maybe there are easier ways, but something like the above list is what most people use.
Thank you I will look into that
Thanks, i think im gunna try that racket thing
Just disregard the "lispbox" that is mentioned in the book. It hasn't been maintained in many years and likely won't work. [Portacle](https://portacle.github.io) is a much improved replacement for it.
Ok I will
Even if you go with Racket you should check out Emacs. The Editor is written in big parts in Lisp \(the lowlevel parts are in C\) and configured soly by Lisp code \- it is possible to configre almost anything/add whatever feature you want by writing often only a few lines of Lisp.
Original game author here; happy to answer any questions.
So I mean... this has nothing to do with quantum computing? Kinda disappointing.
thank you for sharing your experience with the mentioned solutions, I will have a look at Weblocks even if it very alpha :)
&gt; Or should I just learn a more modern language like C or C++? Lisp is as modern as they are. Use a combo of Portacle and Practical Common Lisp, as mentioned by other people. If you run into trouble, fire up an IRC client and go to `#lisp` or `#clnoobs` on the Freenode network.
You can write a constructor in form of (defun make-foo (bar baz quux) (make-instance 'foo :bar bar :baz baz :quux quux)) Such things are pretty often used in Lisp whenever you do not want to use the standard MAKE-INSTANCE functionality.
Alright, thanks. I wasnt sure if lisp was outdated because of how old most of the tutorials were online.
**AmazonSmile Link:** [Object-Oriented Programming in COMMON LISP: A Programmer's Guide to CLOS 1st Edition](https://smile.amazon.com/Object-Oriented-Programming-COMMON-LISP-Programmers/dp/0201175894) ^Use&amp;nbsp;AmazonSmile&amp;nbsp;to&amp;nbsp;donate&amp;nbsp;0.5%&amp;nbsp;of&amp;nbsp;your&amp;nbsp;purchase&amp;nbsp;price&amp;nbsp;to&amp;nbsp;a&amp;nbsp;charity&amp;nbsp;of&amp;nbsp;your&amp;nbsp;choice&amp;nbsp;at&amp;nbsp;no&amp;nbsp;extra&amp;nbsp;cost&amp;nbsp;to&amp;nbsp;you.
Lisp is old, that's true. The language first appeared in 1982 and its standard was finalized in 1994. That doesn't mean the language is outdated; new features are constantly being added because the language was designed to be easily modifiable and extendable. Use PCL as your learning book. In case it's going to fast for you, read Touretzky's "Common Lisp: A Gentle Introduction...".
Those dates are for Common Lisp. LISP is from 1958. I assume you know that, but other readers might not. 
As a Java programmer you are already familiar with programming in general. In such situation I recommend you Peter’s book - Practical Common Lisp. It’s available for free online. You may think about buying a dead-tree version or making a donate if Peter’s work will help you. http://www.gigamonkeys.com/book/ If you want play around with Lisp (MIT Scheme) while learning programming in general give SICP a try. Available for free. https://mitpress.mit.edu/sites/default/files/sicp/index.html
Another recommendation for Practical Common Lisp. Also: &gt;But very interested in Functional Programming Note that Lisp is multi-paradigm, not centered on functional programming. 
&gt; SBCL Lisp &gt; Emacs as Editor, here some examples of Emacs config files &gt; With the Melpa package manager &gt; And the SLIME package for Common Lisp &gt; Plus the Smartparens package &gt; And Quickload as Lisp package manager All of this is installed automatically by installing Portacle.
Bear in mind that functional programming and "most traditional" Lisp are different goals. The design of Lisp has always had its functional aspects, to be sure, but it has never had any pretense of being a pure functional language. For a more purely functional language with Lispy syntax, I recommend Clojure, which also lets you take advantage of Java libraries you may be familiar with. Or if you want to stick even closer to classical Lisp syntax (PARENTHESES AND NOTHING BUT!), Scheme/Racket might be the way to go. You could also look at Scala (to stay on the JVM) or Haskell for some grounding in pure functional programming that's not Lispy. 
There were a few gaffes. The for-loop expansion was close but wrong. The Lisp pseudosyntax for the macroexpansion isn’t valid. The term “variable” was used instead of “symbol” sometimes. Overall I found it very difficult to on-the-fly explain these concepts in sub-10 minutes to a very general audience. But I hope this video was at least more substantive than the last. They’re concepts I definitely wish were a little more well known. :) Feedback welcome!
It doesn’t talk about all the nitty gritty details of how Lisp is used in quantum computing. But we did write about that for ELS 2018! Check out the proceedings. :)
http://articulate-lisp.com/
That’s actually an advantage. In most newer languages, if you find resources older than a couple of years (e.g. the oft recommended “Learn You A Haskell” book) it will be frustrating because the examples won’t compile due to language changes. Lisp is a lot more stable. Helps free your mind and focus on the problem at hand rather than try to figure out what changed. As such, I heartily recommend Portacle and Practical Common Lisp as well. Why? PCL will gradually show you how to use emacs (portacle) as you read it, at least the bare minimum necessary to get started coding, loading files and so on. 
&gt; Python the platform… it is slow and I feel it even on my little projects. SBCL compiles to machine code. We can't even build an executable Hi /u/dzecniv, How interesting, i also was very much into Python immediately before trying Common Lisp. I initially thought Python was awesome (it was my first 'serious' dynamically typed language, after years of using statically-typed languages only, except for Javascript which I immediately found flawed). Yet then I found mostly the same problems as you: - having the global interpreter lock get in the way of doing interesting stuff - slow execution speed - no executable delivery There were other questionable design choices such as the "magic" member names (like __str__, __repr__, etc; but those weren't show stoppers. 
&gt;I've found book "Land of Lisp" by Conrad Barski M.D. but probably this is wrong way Hi /u/akhambir, now I have more time to reply. This is a very beautiful book that is very motivating to learn Lisp. I actually got the final motivation for learning Lisp by looking at some of the comics there. I think Conrad Barski must be one of the nicest people in the world. However, I think Practical Common Lisp is much more efficient (i.e. gets you there in less time), and easy to understand. &gt;But very interested in Functional Programming You can do functional programming in lisp, but the real fun and the real power is in that Common Lisp is perhaps the most "multi-paradigm" of all languages. Yes, functions are first-class objects in CL, you have map, reduce, apply, etc. However, IMO if you are really a fan of functional programming, perhaps you might want to explore the latest trend/fashion, which is functional programming of pure functions (side effects constrained) coupled with a very powerful type system coupled with type inference, coupled with powerful static-time type checking. That is, the Haskell language. Note that Lisp and Haskell are polar opposites -- the idea in Haskell (&amp; similar languages) is that a program is closer to a mathematical proof, and that everything should be laid down on source first, then verified, and only afterwards converted into an executable, then run. If there are errors at runtime, you're screwed and need to start all over again (write-&gt;compile-&gt;execute). While Lisp, is for "creating living organisms", like the Alan Perlis quote. That means your program, while running, can be evolving, be modified, etc. There isn't a strong separation between creating, modifying, and executing the code. Another difference is that, for a Lisper, a program should ideally be expressed on the most natural, direct way. Rather than doing the workarounds needed to implement the desired program P in language X, you modify language "Lisp" so the desired program is the closest as possible as the language in which program P would be ideally expressed. Think of this, for it is a very powerful concept. 
I believe you are old lisper. Because the last University that stick with Common Lisp * I think * is University of Bordeaux, inria labs. where Robert Strandh (the author of McClim) teach there. Other university are moving towards python and java. I feel sad for the java part. Cause I think this language doesn't suit for beginner/teaching. 
The first time I know Lisp, is from RMS article "How I do my computing". I know that Stallman is a smart person (even bit controversial). Because of his cleverness I start wondering why such smart person love lisp ( at that time I had no idea what is lisp). I start searching "Lisp" in search engine. I landed in Common Lisp Foundation website, which doesn't contain so much thing. That day I go with PCL for week and stopped at chapter 2. because I don't really get it (I think because that time I still have very basic understanding of programming). Some months past. I wondering again. In what language my time should be invested. I want to learn very deep to it's internal. So I really need the language that I love to keep me motivated. I remember Stallman compliments about lisp. I took a time to learn what is lisp. Then I find lisp article from ESR and PG. They are really smart hacker. So I decide to go with lisp. I suspend all my learning in Operating System. Then I jump deep to programming languages. At first, I take Common lisp with PCL as a guide. Then I move to Scheme. I stop learning lisp that month cause I had lot university task (which was in Java). Jump again to guile. Then I think I want to make big project with Lisp. I find many big project use Common Lisp so I pick Common Lisp and stick with it until now. I do all my university project at my fifth semester with Common Lisp. :) Now I am learning Python. Because I don't find any startup/company here (Indonesia) using Common Lisp. I felt hard at first to leave Common Lisp and start learning python. But it's okay. Both of them are just a tool to put in your toolboox. Even if you work with other tool. You have to learn the *best* possible tool you can use. even you don't use it at work. It's give you other view and understanding of thing you never get with basic tool. *Before jumping into Common Lisp. I asked many advice and opinions from present Lisp hackers. Thanks for their patient and kindness to response me. They are very kind*
My feedback: - I think it was a way of explaining that i wouldn't have thought of^1, and in a very simple way at 3:09 the mystery was unfolded -- the "code is data". Boom, mind is blown!. However, perhaps people won't understand the `quote` vs `eval` easily. It's a powerful concept isn't it? Powerful concepts aren't so easy to grasp, anyways. - I don't know why, but tarballs are good. - Style warning at 0:00: Warm (circa 3200°K) lighting on the foreground, while background lit by cool daylight (circa 6000-7000°K). *Note 1*: For what it's worth, when I usually explain lisp metaprogramming by telling non-lisping colleagues as follows: &gt;Programming languages have data structures such as vectors, arrays, lists, integers, etc; and can manipulate them. Lisp has a lot of functions and features to manipulate lists. And lisp programs themselves are lists. Thus, Lisp has a lot of functions and features to manipulate programs. Thus, writing lisp programs that manipulate lisp programs is trivial. 
I took time to reply since you posted your answer. I enjoyed the feeling of finding great materials. I have mixed feeling. very sad, "why I don't find this textbook long time ago". In other hand, very happy to find such a great material. http://composingprograms.com/ You must be grateful to have such talented people around you. Thank you so much. You made my day. I really want to complete composing program book. I love reading books very much. Sometimes I spent my free time to compare book reviews. But why I don't find this great book mentioned here and there. Once again thank you for sharing. &gt; (although probably way too basic for you). No, this great material. I have to read and do the exercise. I still sit in fifth semester. Maybe one day I want to discuss about "teaching technique and syllabus" that used in your university. I want to teach and share to my fellow here. 
I usually start with a ( :-) but seriously : * Portacle to get a system running fast and * find a small project to do by yourself in order to drive your motivation and get into practical issues .. could be different for others but for me it helped a lot. 
Racket.
&gt; Berkeley's all CS materials are public, Wow. Such a great thing. &gt; because of national regulations (Berkeley is a public school). So it's mean restricted only with local regional IP ? or ?
No, it's not regional, everything online is public (e.g. [this](https://cs162.eecs.berkeley.edu/) is the OS class, which is another class you should check!) but you cannot access webcasts (i.e. lecture videos) and there is no list of resources linking to everything you need to make your own research. Unlike MIT, which does these. This is because there is a regulation in US that all public lecture materials should have certain quality which is very hard and expensive to meet (i.e. it needs to be accessible to blind and deaf people etc...) and that's why Berkeley cannot release their webcasts, they're only accessible to students (and alumni).
You can use CLISP directly. Run CLISP and you get an interactive listener with editing and history recall. You can edit files outside of that using whatever editor you like, in another window. From CLISP, you can load a file using the `load` function, like this: `(load "myfile.lisp")`. If you edit the file, you can load it again using the same command. Tip: in CLISP, if you get entangled in some error exception, perhaps a nested one, just use `:a` to abort to the top level again Don't worry about compiling; you don't have to compile functions or files in order to learn Lisp. Compiling is just for faster loading of larger programs, faster execution, and, above all, for turning programs into reverse-engineer-resistant gobbledygook to make nice, proprietary code so you can get paid.
Programming languages don't exactly work like Top Forty music. Usually those languages get outdated which are very tied to particular computers or operating systems, or work with very particular data formats or have other such limitations. Good programming languages are like math. They don't get outdated any more than L'Hopital's Rule or the Pythagorean Theorem. Would we avoid using the Pythagorean Theorem to calculate a distance, because it dates back to the ancient Greeks? Computer scientists figured out more than fifty years ago how to design languages so that they are abstract and "future proof". They simply had to look toward mathematic and logic, which are a rich field of ideal objects whose properties can be emulated in software. Not all designers got the message equally well. Therefore, a relatively new language can be a hodge-podge of cruft that will be outlived by some much older languages.
I feel like understanding CLOS is my next big hurdle for really making use of CL in some other projects. I've started to get a grasp on it as far as syntax goes, but examples of it showing off its flexibility over traditional OOP tools eludes me. Do you know of any resources I could hit up to help? 
&gt; (which is pretty easy, just google "XYZ Berkeley CS"). okay. thank you :) &gt; This is because there is a regulation in US that all public lecture materials should have certain quality which is very hard and expensive to meet (i.e. it needs to be accessible to blind and deaf people etc...) and that's why Berkeley cannot release their webcasts, they're only accessible to students (and alumni). I think MIT OpenCourse videos also doesn't meet this criteria. Why they can publish those video ? Sometimes I and my friends always wondering. What is like to learn directly from talented people. BSD OS born at your faculty. I can't imagine how great learning CS there. 
PCL is a boorish book; I'd easily recommend, oh, Wirchenko's *Common LISPCraft* from 1986 over it. PCL doesn't even teach newbies that hash quote on lambda is unnecessary. Neither does *Common LISPCraft*, but that was written before the *lambda* macro was introduced, soi A good tutorial book is [*Common Lisp: An Interactive Approach*](https://www.cse.buffalo.edu/~shapiro/Commonlisp/commonLisp.pdf) 
Try [Common Lisp: An Interactive Approach](https://www.cse.buffalo.edu/~shapiro/Commonlisp/commonLisp.pdf) Very nice book. It was the better part of a decade old when I started learning from it in around 2000. At that time, it was printed only. Some years later, Shapiro made the above PDF available. This book goes from the ground up. It starts with the basics: then has a big section on "Pure Lisp" programming (the functional stuff), another section on "Imperative Lisp" and also covers object-oriented programming with CLOS. This book introduces packages early on, and has a good coverage of some details of read syntax and how different spellings of the same symbol can correspond to the same one, and what "interning" is and such. 
&gt; Why they can publish those video ? Because MIT is a private university and I don't think they have to conform this particular regulation. &gt; Sometimes I and my friends always wondering. What is like to learn directly from talented people. BSD OS born at your faculty. I can't imagine how great learning CS there. It's very exciting actually. In Berkeley professors and most students are really passionate about what they study. Most of the time professor teaching the course is one of the "giants" of that discipline in academic literature which means that person dedicated a serious porsion of their life, maybe 10 years, to studying that particular material which makes them very passionate explaining concepts to you. It also introduces quiete a bit of rigor since they won't let you pass without doing crazy amount of work which puts tremendous amount of stress to students. Professors likewise expect passion from their students, you cannot just succeed in Berkeley for studying CS to make money. You need to intellectually and critically engage in the material no matter what you're studying either CS or sociology or whatever. Most upperdiv classes aim to make students be able to read papers e.g. [CS 189](https://www.eecs189.org/) is very mathematically deep and prepares students to be active learners after they graduate which means preparing them to be able to read textbooks/papers. It was definitely a fun experience. As a recent grad I must say I miss Berkeley :-(
&gt; but examples of it showing off its flexibility over traditional OOP tools eludes me. Do you know of any resources I could hit up to help? I think chapters 16 and 17 of [Practical Common Lisp](http://www.gigamonkeys.com/book/) do a pretty good job, and you can click the link to read online for free, no registrations or anything required. Flexibility and superiority over traditional OOP were for me easy to grasp after having to use Java/C#/C++ for years on a professional context and thus having to work around the limitations of those OOP systems; the cure^1 was usually through applying some design patterns that made the code even more verbose and distanced from the problem domain. After learning CLOS the ludicrousness of having to apply some specific design patterns just as a workaround for the silly limitations of other OOP systems becomes self-evident. Thus you realize that the hate against OOP not necessarily needs to be addressed by abandoning OOP, but by simply using a better-designed OOP system in the first place. But Common Lisp is more generous: - it never forces you to use OOP, unlike Java's sadism - methods and functions combine seamlessly - custom data types and classes can combine. *Note 1:* Here "the cure" refers to the solution to a problem, not to the great '80s new wave group. 
Thank you for your clarification and for pointing out UCW :)
I have considered LFE in the past, which advantages does it offer which are not Beam and OTP related? Never heard about clojerl before, thank you for suggesting it :)
Because Lisp has a minimal syntax and is at the same time maximal powerful. This trait combination is always special. We love and seek for it in art, relations, writing, math – it is a characteristic of true things, and Lisp has it too. It's not really possible to remove some syntax of Lisp without loosing a major strength. At the same time adding more syntax wouldn't gain the programmer anything.
Thanks! lots of useful links :)
I cobbed together a "meat and potatoes" OOP system for a Lisp dialect: single dispatch, single inheritance, methods in classes, a bit of dot syntax for accessing slots **and** calling method. Part of it was that I was curious about how well that would work. Turns out is still vastly better than working in a language like Java or C++. Don't blame the OOP system; it really is the language that sucks.
A complete series of short youtube videos about all these great andfancy lisp-concepts would be great ! ... 😃
Install Emacs if you haven't already. Try using it and learn a few of the keyboard cords, this might take a few weeks to get used to... Emacs has a dialect of lisp builtin but is different than Common Lisp. However you mostly don't need to use that other dialect. See if your Emacs has "slime-mode" pre-installed. If not you will want to instal it yourself. When editing files with a .lisp file extension a default emacs installation will do some automatic indentation but slime's indentation is nicer. Press `M-x` (ESC then x) then type in "slime", press ENTER/RETURN. If that doesn't work then do the following: Press `C-x b` and type in *scratch* or otherwise find the scratch buffer. Copy &amp; paste the following into *scratch*. ;;Add this to your emacs init: ;; load emacs 24's package system. Add MELPA repository. ;; Added by Package.el. This must come before configurations of ;; installed packages. Don't delete this line. If you don't want it, ;; just comment it out by adding a semicolon to the start of the line. ;; You may delete these explanatory comments. (package-initialize) (when (&gt;= emacs-major-version 24) (require 'package) (add-to-list 'package-archives ;; '("melpa" . "http://stable.melpa.org/packages/") ; many packages won't show if using stable '("melpa" . "http://melpa.milkbox.net/packages/") t)) (custom-set-variables ;; custom-set-variables was added by Custom. ;; If you edit it by hand, you could mess it up, so be careful. ;; Your init file should contain only one such instance. ;; If there is more than one, they won't work right. '(package-selected-packages (quote (sml-mode slime)))) (custom-set-faces ;; custom-set-faces was added by Custom. ;; If you edit it by hand, you could mess it up, so be careful. ;; Your init file should contain only one such instance. ;; If there is more than one, they won't work right. ) Then press `C-j` with the cursor after the pasted part. You might need to add that code snippet to one of the emacs init files (i.e. $HOME/.emacs a file not the directory .emacs.d/ create file if not there). You might have to exit all emacs windows/tabs/etc and restart... Actually this part is tricky... My installation ignores that that file... Anyways after activating that snippet in *scratch* and before logging out! Try `M-x` "package-install" then enter "slime". This might be wrong and take some stumbling around and reading guides on the internet, but keep trying! That may or may not be how I did it. Maybe not... Another thing to try is download https://beta.quicklisp.org/quicklisp.lisp and load file with your lisp compiler/interpreter (i.e. clisp, ecl, sbcl) outside of emacs. Some instructions should come up and a few lisp commands will need to be typed in.
`make-instance` is a method. By passing the `myclass` symbol to it, you're calling its `symbol` specialization. That specialization calls `(find-class 'myclass)` to fetch a class object: an instance of a *metaclass* and then recurses: it calls `make-instance` on the object returned by `find-class`. In other words, the class you defined is itself represented by an object: an instance of a *metaclass*. That object supports the `make-instance` method for creating instances of the class that it represents. 
Hey everyone! SHCL is my first real lisp project. It’s not ready for real use, but I thought I’d share it with you all any way. Enjoy!
Repeatedly read your reply. It was my dream to ask "what is like to learn at foo/bar university. learning directly from most talented people in that particular subject". Suddenly, I got this answer. &gt; It also introduces quiete a bit of rigor since they won't let you pass without doing crazy amount of work which puts tremendous amount of stress to students. Professors likewise expect passion from their students, you cannot just succeed in Berkeley for studying CS to make money. You need to intellectually and critically engage in the material no matter what you're studying either CS or sociology or whatever. I am very happy. You told about this. This is the *risk* that we get when we thought by active and passionate lecture. Most of the time. if the class didn't pressure the student. It's likely hard and rare to find student that have inner spirit to learn, except only those who enlightened. &gt; Most upperdiv classes aim to make students be able to read papers e.g. CS 189 is very mathematically deep and prepares students to be active learners after they graduate which means preparing them to be able to read textbooks/papers From your first paragraph until this. Now I realize why some graduate student from foo and bar are different. It's not about how expensive it was. But how much pressure from their class to make them shaped. I learn so much thing from your reply. Especially about pressure that will likely make student stressed. I think to achieve a level of mastery. determination and grit is must. I have to apply it to my habit. Once again thank you. Maybe I will send you a DM one day. Thank you.
Neat! I was recently looking for something like this before deciding to write my own, and came across a similar project: Lish https://github.com/nibbula/lish which has some similar features. Perhaps the best features of both could be merged, or at least some ideas exchanged. 
Of the open issues in shcl's HACKING.org, Lish has tab completion, job control, and prompt customization. Shcl definitely has a more complete test suite, and seems to use more "standard" systems (ie on quicklisp).
it's certainly a hyperbole, and a subjective one at that. i lump all past deviations from balanced sexps into a terrible idea bucket, they were tried, they were found lacking, dealing with that code is now a bit of a pain (granted almost nobody does, but that might also be a reason why these ideas spring up fresh, like picolisp above). scheme doesn't have this feature: you can use () and [] interchangibly, but both have to be balanced. historically scheme proponents were the ones to argue against tricky syntax: ai memo 349 which describes the pure core of scheme has no syntax at all beyond balanced list, symbol and quote. the only environment that had that feature exactly as describe is interlisp, and interlisp is infamous for being editor heavy, and hard to port. in "evolution of lisp" steele and gabriel suggest that this particular editor reliance is the reason why interlisp's features didn't survive into present. maclisp had another approach: when the reader encountered an opening paren in column zero, it would close all the pending parens before, so if your code is reasonably indented, you don't even have to put any closing paren at the end of the top level form. also didn't survive past lisp machine, because of the obviously hacky nature. i think my point is that the implications of the list above are significant: new editor behavior, loss of custom [] readers, readability, compatability with other lisps (riastradh wrote paredit for scheme, but it still works great for common lisp). i don't know how much picolisp relies on ] for internal code, but when i read large chunks of lisp machine code, my existing high comfort level with reading lisp doesn't help me, brain sees "incomplete forms" all over the place. certainly you can adapt to it, but you don't get it out of the box. you're also missing one point on your list, modifications to the printer: presumably when you have a *print-pretty* on you'd also have to make sure that the closing parenthesis are replaced with ]. 
Have you already had a look at [CLaSH: Clisp As a Shell](https://clisp.sourceforge.io/clash.html)?
I want to add to this and say the tooling is better for lisp than haskell. Get yourself Emacs + SLIME, and you can have a very fun day exploring libraries, learning CL, and creating cool interactive systems. Unlike with Haskell, you can start _today_ on whatever project you want to make, be it a game, a text editor, a photo viewer, or a console application. No prior planning will be required -- the program will grow naturally, and the programming environment will assist you with docstrings, autocomplete, type hints, a repl etc. *Warning -- Extreme bias* The point of Haskell is to make a compiler or parser for a language that is better than Haskell. Hopefully soon [Idris](https://www.idris-lang.org/) will become self hosting and Haskell can be abandoned for the lazy, incomprehensible language it is.
Oh awesome, thank you for the clarification! I’ll take a look at dexador code for some examples!
Have you ever tried [Fish](https://fishshell.com/)? It's not a lisp, but it has a similar feel to it due to certain design decisions and a deliberate abandonment of POSIX compliance. Part of what gives it that feeling to me is the use of `(foo ...)` for command substitution, and because it has a preference toward using system utilities and builtins instead of adding more syntax. For example, instead of custom syntax of `foo &lt;(cmd ...)` some shells used for process substitution, fish has a `psub` builtin, allowing you to do things like `diff (sort a.txt | psub) (sort b.txt | psub)` (from the Fish documentation). Composability is a strength of both lisps and interactive shells, and its focus on built-ins, functions, and system commands over adding custom syntax feels more natural (in my opinion) than the piles of kludgy syntax shells like bash have grafted onto Bourne Shell over time. It's not as lisp-y as using something like [closh](https://github.com/dundalek/closh) as your interactive shell, and [Gauche](https://practical-scheme.net/gauche/index.html) is probably a better choice for shell scripting due to being a scripting-focused Scheme, but it's mature and makes a nice compromise between standard shell syntax and something better. 
Land of Lisp is a \*really\* bad book for a beginner to use. There are two families of "traditional" Lisp: Scheme and Common Lisp. The differences are a bit esoteric so pick one and go with it. The most modern incarnation of Scheme is Racket, see /r/Racket If you're interested in Scheme I suggest How to Design Programs or if you are comfortable with a more advanced texts then there's the classic Structure and Interpretation of Computer Programs: not strictly a Scheme book but one of the authors is a Lisp pioneer and they chose Scheme as the language for the book. If you're interested in Common Lisp I suggest Practical Common Lisp \(PCL\) by Peter Siebel or, if you have any interest in early/simple AI, Paradigms of Artificial Intelligence Programming \(PAIP\) by Peter Norvig. Given you're background with Java and interest in functional programming \(neither Scheme nor CL support functional programming particualry well\) then consider Clojure: a modern Lisp that runs on the JVM and interoperates with Java, e.g. you can use Swing from a Clojure program. It is a functional programming language \(you have no choice \-it's less general paradigm than Scheme or, especially Common Lisp\) and has funcitonal data structures sewn into it's fabric.
Don't do that. Just install portacle.
In simple case, it is just (dex:get "http://lisp.org")
Did you look at the classic [Scheme Shell SCSH](https://scsh.net/about/about.html) by Olin Shivers et. al.? "Scsh has two main components: a process notation for running programs and setting up pipelines and redirections, and a complete syscall library for low-level access to the operating system, i.e. to POSIX, the least common denominator of more or less all Unices, plus widely supported extensions such as symbolic links and BSD sockets. Moreover, scsh provides an awk facility for pattern-directed computation over streams of records, a rich facility for matching regular-expression patterns in strings, event-based interrupt handling, user-level threads, a futuristic module system, and an interactive environment." I've been on the lookout for a Common Lisp version of SCSH for a long time.
Author here. Please let me know if anyhing in the README is underexplained or could be worded better!
Thank you! I think the current build is in fail status according to the github page (I couldn’t get it working using quicklisp - might be something I’m doing wrong) but this looks amazing! I’ll try to clone the repo and start poking/playing around. 
Hi, I liked your readme very much, it is very well written (at least I think so), I have some curiosity. How would Interim handle closures?
Closures aren't implemented yet, and I've thought about this less than about other features, but my intuition is: if a closure closes over a set of pointers `{v_0, v_1, ..., v_n}`, to regions `{r_0, r_1, ..., r_n}`, then the type of the closure would have include those regions. Less formally: a closure belongs to all the regions its captured pointers belong to. This is necessary to prevent dangling pointer errors were the closure to escape a region after its been freed.
Very interesting. I look forward to seeing where this heads. 
There's a lisp with similar goals called [carp](https://github.com/carp-lang/Carp).
Would love some feedback on this from longtime lisp-type people. I'm purposefully NOT following some of the lisp orthodoxy with this thing, the goal is to be something like "python with s-expressions and macros" more than yet another scheme clone.
That's the first time I see a statically typed Lisp. Impressive work! 
&gt; "python with s-expressions and macros" That's pretty much how I feel about Racket. It's a well-supported, well-documented, popular, batteries included Lisp with a decent beginner's IDE. Aside from that my only critique is the use of (=) as an assignment operator, which is a bit confusing because generally in Lisps (=) is the equality operator. On the other hand, if you are just trying to make the most Python-like Lisp possible, then I guess I can't fault you. Awesome project! Also, in main.c &gt; printf("BearLang Version 0.WHATEVER\n\n"); // TODO: add versioning Ha. 10 points to Hufflepuff. May I ask why you chose C as your implementation language?
The 2 languages I'm most familiar with are Python and C and I wanted decent performance. I suppose I could change = to something like "set" but I prefer the single character.
good bot
&gt; I suppose I could change = to something like "set" but I prefer the single character. Makes sense to me. One more minor thing. It's been many years since I did any serious work in C, so maybe I''m way off here, but I was looking at the following snippet in main.c &gt; char* errmsg = ""; &gt; ... // code code code &gt; errmsg = bl_errmsg(result); What is the point of setting errmsg to "" if you are just going to set it to the result of bl_errmsg(result) a few lines later? Also, when you set a char pointer to a string like that, it statically allocates that in memory. Which may seem fine since the string is empty, but recall that strings are null terminated. So every time you run through that loop you are statically allocating one byte (the size of a single null char) and not freeing it. Note that static allocation is NOT akin to automatic allocation (such as variables placed on the stack). Is this not a memory leak? I feel like I'm wrong and look forward to hearing back.
Nice catch! There was a reason for this at some point, I'll fix it.
So the region could persist after the letregion is closed, ok, and then you would have to release the memory manually when you no longer need the closure. I am assuming that currently the memory is released automatically, perhaps I am assuming too much.
They could, but then they would be writing unidiomatic code. Programming is social. A great deal of code is created via cooperation, and even solo programming usually entails working with a great deal of other people's code. As a fellow Python programmer, I would rather follow the consensus (even if I have a minor disagreement with that consensus) than write unidiomatic code that will create unnecessary confusion for others later down the road. I think that attitude is something that differentiates the Lisp and Python communities to some degree. Python very loudly calls for idiomatic conformity, whereas Lisps very fundamentally encourage rebuilding the language you are using to suite your tastes. This phenomenon is called the [Lisp Curse](http://www.winestockwebdesign.com/Essays/Lisp_Curse.html).
TXR Lisp has a standard macro like this: [`build`](http://nongnu.org/txr/txr-manpage.html#N-02ACB8CE). 
&gt;This is the key to preventing dangling pointer errors: pointers are tagged with the region they belong to. A pointer cannot escape its lifetime, to a higher-up region or to a global variable, because the types won't match. So a Rust-like lisp but simpler to use. Very simple and very interesting, my fellow southamerican lisper! 
&gt;This is the key to preventing dangling pointer errors: pointers are tagged with the region they belong to. A pointer cannot escape its lifetime, to a higher-up region or to a global variable, because the types won't match. So a Rust-like lisp but simpler to use. Very simple and very interesting, my fellow southamerican lisper! 
https://github.com/GarethNelson/BearLang/commit/087498fdc3e9fd14b5a457c08733c87339a08002
I ended up reading one of [the Cyclone papers](http://www.cs.umd.edu/~mwh/papers/cyclone-cuj.pdf). But it's not clear to me what operations are harder with region-based allocation. Do you have any examples that actually exercise the allocator itself? Say involving linked lists or trees (since this is a Lisp)?
What if Interim becomes eternal? Would it then have eternal interimity? 
The easiest way to do this is to add a reversal route that forces the port to 443: (define-route force-port :reversal (uri) (setf (port uri) 443)) To be clear about what the `:port` configuration value does: when Radiance computes the [reversal domain](https://github.com/Shirakumo/radiance/blob/master/defaults.lisp#L185), it will try to match the incoming request's values and only falls back to using the configured value if there is no request around. The ideal way to do this if you want to keep the ability to serve both http and https links would be to set an additional header in nginx that passes the protocol on to Radiance, and then use that in `uri-to-url` transformations. I don't currently see a convenient angle on that aside from overwriting `uri-to-url` itself however, so perhaps a change in Radiance is necessary. I'll think about it. Either way, for your purposes the above route should do the trick.
Very interesting indeed. I have thought about this a bit. GC doesn't seem to take benefit of request-response pattern in a lot of software today. Regions (as pools where you can allocate memory) seems common in non garbage collected languages. Bringing those into the language itself sounds very promising. Great job! I will follow the progress of this. 
Thank you very much for the write up and Fennel itself. I toyed around with Urn lately and came up with a cheap solution of what your much more sophisticated code live reloading solution does. Speaking of it: what is your opinion about Urn and how would you distinct Urn and Fennel. 
&gt; what operations are harder Getting space complexity right, because deallocation is whole-region or nothing. 
Hi Shinmera, thanks for the quick reply! I appreciate the suggestion and have tried it, and it worked well for pages and static assets -- but had unintended consequences for the api routes. Let me repost this to GitHub as well as my additional findings after trying the new force-port reversal route. https://github.com/Shirakumo/radiance/issues/25 Thanks!
Reddit's notification system told me about your response. Thanks, and yes, "Let over Lambda" is on my list. It's said to be very advanced (and slightly crazy), so I'll save that for later.
Essentially this. In this case, making memory management safe doesn't mean you can just stop thinking about it, you still have to choose where to allocate things, and there's a tradeoff between size and speed (allocating all in a single region which grows monotonically over program lifetime vs. creating lots of regions which implies lots of allocations).
Just to summarize the latest update thanks to Shinmera’s quick action, the uri-to-url function will now check for the X-Forwarded-Proto header as well when deciding which port to set. 
love all your work....you have a knack for making things simple for others, this game is just another example of that!
Also [clesh](https://github.com/Neronus/clesh) ? (a continuation of [shelisp](http://dan.corlan.net/shelisp/)) It provides essentially a `!` bang syntax to type in any shell command, and various ways to mix Lisp in.
Well, I really have no objections, I just find this interesting and I was imagining how this scheme could function in several scenarios, and closures were one of them, but I guess you'll cross that bridge when you get to it, if you decide to implement closures.
Urn is a really interesting language, and I was actually using it for a while and trying to integrate it into a game I'm making. I really like the ideas they are pursuing, and trying to bring a bit more static-analyzable properties to the Lua runtime is a good idea. But for me personally I can't work without the ability to live-reload and interact with the program as it runs. This property is not necessarily mutually-exclusive with static analysis, but harmonizing the two is very difficult, and if I had to pick one, I would pick the interactivity. The authors of Fennel and Urn both answered this question here if you're interested: https://news.ycombinator.com/item?id=16567763
I suppose building one's own language (like I'm doing) is the ultimate example of this phenomenon.
Very cool! I know very very little about manual memory management so it would be neat to learn it in the context of a lisp.
Thank you! &gt;Just a question, why did you choose Standard ML instead of CL? Is it easier on SML? I found it to be much easier to build the compiler using SML, compared to my previous attempts at compiler development using Common Lisp. I've written a bit about it [here](http://borretti.me/article/inheritance-disjunctions).
What do you plan on implementing next?
Quite a few things come to mind: - Macros - Disjunctions/union types - Declaring functions before defining them - Type aliases I think that's really all that's holding it back from being a truly usable language.
Is the only way to move data from one region to another to copy it? Rust is more complicated at least partly because lifetimes can be promoted implicitly; it seems in Interim that any function that returns a heap\-allocated value would have to take a region as a parameter?
In common lisp, dynamic\-extent declarations offer this to a much more limited degree.
&gt;Is the only way to move data from one region to another to copy it? Yes. &gt;it seems in Interim that any function that returns a heap-allocated value would have to take a region as a parameter? Precisely, any function that intends to allocate, and return its result, has to take a region as an explicit parameter.
I find that in real life, it's more likely to be: } ] }); }); } These are the languages that really need a superbracket.
I will investigate and see if your techniques you used for the live reloading can be adapted to Urn. Thanks for your answer and sharing your singhts and knowledge you gathered during the lisp game jam.
For me, as a complete beginner the following was the path of least resistance: * Download [Common Lisp: Interactive Approach](https://github.com/rigidus/lisp-doc/blob/master/Shapiro-Common-Lisp-An-interactive-approach.pdf) * Download [CLISP](https://clisp.sourceforge.io/) for your OS. * Fire Up CLISP and go through every exercise one by one from chapter one. It starts with extremely simple concepts (e.g., it introduces Lists in chapter 8!) but it is important that you do not skip anything. Read the preface (you really should.) Stay away from emacs if you can, it will frustrate the shit out of you if you haven't used it before and distract from the purpose of learning Lisp. Play with the language, you will enjoy the process and feel confident with every single simple exercise. At least I loved it when I was trying to play around with Lisp. You can move on to Practical Common Lisp after that. Once you feel comfortable, you can download Portacle or SBCL or what have you and go nuts. Good luck! 
The ML language family is indeed terrific for building compilers. Your post can be summed up to the lack of native sum types in CL but one can use and perform exhaustive matching on those just fine. This is one of those libraries I can't live without https://github.com/tarballs-are-good/cl-algebraic-data-type
I think racket also has a statically typed version
Hi fellow Lisp newbie! I don't know if you're dead set on Common Lisp or not. If not, I had a great time starting out with Structures and Interpretations of Computer Programs (SICP) using the Racket language (a lisp dialect) and the Dr Racket IDE. SICP uses Scheme but it's no problem at all to get it to work with Racket. I chose Racket because DrRacket made it really easy to get started with minimal hassle. I think there's a lot of carryover as a beginner from learning any lisp dialect if you want to move onto another dialect later. Also, I think SICP was just one of the best texts on programming I had ever read. I'm learning Common Lisp now and I appreciate learning the fundamental skills in a more minimal language before moving on to the awesome behemoth that is Common Lisp. But if you're set on Common Lisp I second all the recommendations for Practical Common Lisp. It's a great overview of the language. Although it does lack exercises in case your looking for a book that you work through rather than read.
Wow he's bitter. And apparently he even has a couple of acolytes willing to spread his bitterness. Overall and give what we all owe him, I'm willing to give RMS the benefit of the doubt,
Thanks, I have been trying racket, and I think I will try SICP or PCL once I get the hang of racket.
100% true. I've been trying to work on Dart bindings... But it's impossible to practically do anything other than run pre-trained graphs. Gradients+optimizers are the basis of everything high-level in Tensorflow, and so that's a real wall. There ARE gradient descent ops, but virtually none of the 500+ ops provided in Tensorflow have any documentation at all. Hooray.
Is there some meme I'm missing? I don't get the reference here and it's clearly not Armed Bear Common Lisp. Or is this just holds-up-spork territory? &gt;&gt; Why bears? &gt; &gt; BOW!!!! &gt;
Can you `ln -s /usr/lib64/sbcl/ /usr/lib/sbcl/`? Might need to `mkdir -p /usr/lib` also.
Try: export SBCL\_HOME=/usr/lib64/sbcl before running sbcl
You have to set SBCL_HOME. We could tweak the build process to accommodate slackbuild, but the slackbuild people need to contact us to ensure it's actually incorporated into the slackbuild. 
Any reason to choose Standard ML over Ocaml ? Thanks in advance
It's for bears, what's not to understand?
Well, that. Do bears go "bow!" in your culture like dogs go "woof!" and so the answer to the question is in bearish? Do you think you are a bear? Or is to do with "bear" apparently being slang for the large hairy kind of gay man? I'm pretty confident bears as a species cannot program in the first place, while many large gay men presumably can (not that there's anything wrong with being a large gay man who programs). I've now spent too much time on this. Maybe that was your true goal.
I could also have called it OrangeLang for similar reasons.
Changing the name over the gay thing would come across as horrendously homophobic. I'm not gay but I've got some gay friends who crucify me for that and rightly so.
No doubt. &gt;&gt; Why Orange? &gt; OOK!
What's going on is that the post here is two months old. I added the VM and bytecode compiler over a couple of weeks around that time. It's been through a few releases and appears to be reliable. Everything I throw at it works. I'm doing a few things to it for TXR 197. I just finished a simple optimization to prune away unused local functions. I'm looking to implement more efficient treatment of global lexical variables and possibly also specials.
LOL, wow, you are fast! :) BTW, the manual/man page is very well written. I'm really impressed. Looking forward to trying out TXR for a project soon.
&gt;Java &gt;has first class functions &gt;no Weren't lambda expressions added in Java 8?
Lisp and Java shouldn't even be put in the same sentence. And Java has lambda functions from version 8. As Linus Torvalds said, "Java, what a horrible language". 
Technically yes, but it's a very gimped one with many limitations/restrictions and terrible syntax.
Can you elaborate please?
Werent't that lambdas more or less a glorified version of implementing anonymous classes? I actually don't know whether it's basically syntatic sugar or something fundamentally new, but then I don't care enough to actually look it up :D
To be fair, most of Java's problems comes from the average programmer that uses it, and not the language itself.
But it certainly works and makes writing java a lot more enjoyable. I agree that there are a lot of limitations, and I'll still never going to use Java for my own projects, but at work it's a great addition. 
Are you sure that's fair?
lol. this is awesome. it's amazing what sibling intellectual rivalries will do for motivation. do you use it at your job by any chance?
Yes? The language has a lot of good features and is fairly consistent. It has be complimented by notable people. But the language tends to attract proverbial architecture astronauts and many of the common jokes (AbtractBeanFactory, enterprise grade FizzBuzz) mock the programmers rather than the language. As far as languages go, Java is one of better languages to work with, compared to, say, PHP or MUMPS. Of course, Lisp is generally superior, but that doesn't make all other languages crap. I didn't realize that this subreddit was such a huge echo chamber.
I haven't watched the video, but I was in attendance and remember Pierre de Lacaze's _[Metaprogramming, Metaclasses &amp; Metaobject Protocools](https://vimeo.com/154498317)_ talk at LispNYC being very good.
I think Java can be considered good only when compared to PHP. Haha.
Not exactly. In bytecode (invokedynamic) and JVM (LambdaMethod) they're very different from anonymous classes.
Of course a language with a streams API, generics and co is superior to one where ~80% of my LOC are if err != nil { panic(err); }
What is co, loc, and can you explain what you mean by c and gos abstraction capabilities? 
* and "co", means "and others", it’s the english equivalent to the latin "et cetera" aka etc. In this context I meant that there are many other features of Java that make it superior to Go. * LOC means "lines of code". In this context I meant that a significant part of my code – in fact, most code – is spent on handling errors, or casting values, because Go does not have the necessary abstraction capabilities for this purpose. * The abstraction capabilities of C and Go. C does not have any generics, neither does Go. C has no real object-oriented or functional programming, and neither does Go. Go at least has a sane form of functions defined on structs and a sane form of passing lambdas, in C you only have function pointers or have to dynamically generate your functions.
Really interesting. Thanks for sharing
sorry, had the pic hosted on my own server as I didn't know where else to host brotli compressed svgs, but a storm came and my UPS battery is dead, and turned the server off but forgot I was still hosting this.
Sorry, had the pic hosted on my own server as I didn't know where else to upload brotli compressed svgs, but a storm came and my UPS battery is dead, so I turned the server off but forgot I was still hosting this. (this was around 9 pm where I was at) 
In case my server ends up going down again https://svgshare.com/i/6pg.svg this file is about 1/3 bigger than the one on my site though as this site uses gzip instead of brotli
&gt; Lisp and Java shouldn't even be put in the same sentence This, basically. 
should be up now
Been using Allegro CL so long, I forget that other languages have come and gone.
Ah, coincidentally I was just installing SBCL on a new slackware system. The uses above are correct: Slackware is "multilib\-ready" by default, and so installs 64\-bit things to `/usr/lib64`, but SBCL will look for it's core image and other info unde`r /usr/lib/sb`cl. Exporting the proper environment variable will work, but the slackbuild also adds a file to `/etc/profile.d` that exports the proper `SBCL_HOME`, which I believe is sourced upon login, so you might just need to reboot/logout.
Yes, that is the exact use-case for that. It's BSD-style and public domain, so no need to provide source code.
hah never heard of save-lisp-and-die, I love it
You also need to use the same processor architecture. Linux ARM 64bit won't run on Linux x86 64bit. Especially since SBCL usually compiles to native code.
Also, beware any mismatch between versions of foreign libs loaded. That one has bitten me more than once.
While we're here, allow me to ask the opposite question. Can I `save-lisp` on a Linus distro and then run that image on windows?
No. You can try to run Windows SBCL with WINE and build an image through that, though.
http://www.sbcl.org/manual/#Saving-a-Core-Image I don\t see how performance would improve, SBCL already compiles to native code.
I see fixes like this and wonder... Are some people using this language at a level way above me? Likely yes!
well, stating the obvious, start-up time would improve
I have lost entire afternoons because I casually glanced at the commit log and then started pouring through the source to understand a change.
I once saw a guy using Common Lisp to power the whole factory machines operations for a company. That's really not a normal software where you just put on some cloud hosting like every other software these days.
There have been a few occasions where I have thought that a custom method combination may be the best way to solve a problem, but I have always reverted back to more simple solutions.
I always thought it sounds very dramatic, almost heroic, "save the world and die in the attempt", thankfully nobody dies when you save the image and kill the lisp instance. ;)
Depending on "which lisp". If you have Java background you can try Crojure and its IDE https://cursive-ide.com/ For Common Lisp Portacle was already mentioned, as an alternative for learning purposes you can try to download LispWorks Personal Edition http://www.lispworks.com/downloads/index.html
Do you have more information? Where was it? What did the machines do? What did the software control? Curious!!
An excellent way to lose time. And also, lisp is "one of the most intelligent ways to misuse a computer" as Dijkstra? said. 
To add to this, [Practical Common Lisp](http://gigamonkeys.com/book/) is a good resource for learning Common Lisp if you're not a beginner programmer.
For beginners: DrRacket for Racket and its various Schemes, Cursive for Clojure, Portacle for Common Lisp.
I also want to know!
Get Clozure CL. It has its own editor (which is basically Emacs) and you won't have to mess with slime or anything else. (https://ccl.clozure.com/)
Thank you, ABCL developers.
Isn't it only for Mac ? Only found instructions to build the cocoa interface: https://ccl.clozure.com/docs/ccl.html#introduction_in_the-clozure-cl-ide
`_.thanks()`
&gt; Get Clozure CL. It has its own editor (which is basically Emacs) and you won't have to mess with slime I understood the editor is mac-only. I am a satisfied user of Clozure (CCL) with SLIME, so i guess I like to mess with that viscous SLIME and its faithful sidekick, swank.
Corman Common Lisp is a reasonable choice and free.
6pm UTC happens when this comment is 19 hours and 26 minutes old. You can find the live countdown here: https://countle.com/OG200334fi --- I'm a bot, if you want to send feedback, please comment below or send a PM.
Emacs. why not ?! it is written by lisp and has it is own lisp (emacsLisp), also, it is the best IDE over all IDEs.
Racket's DrRacket is a pretty nice up and going experience. https://racket-lang.org/
I can't imagine what would make me say "yes" to a Java job, except if they pay literally thrice as much as companies using other languages.
Hmmm... Don't know about the editor in the Windows version -- I just assumed it would be the same as in the Mac version. Where did you get that information?
I got like 2 likes into this post before I had to check the name. Fancy seeing you here.
&gt; I got like 2 lines into this post before I had to check the name. Fancy seeing you here. Thanks for the kindness and welcome to heaven, PCJ comrade.
Interlisp used "&gt;" (in the years around 1980). This turned out to be not very practical, because only beginners used it, and they fucked up more with "&gt;" than ")))))". 
Yes, I downloaded CCL for linux. But then, where his the editor ? I found build instructions only for mac.
JShell is a REPL, available for Java 9. 
Generally I would agree. When I'm finished with university I definitely want to do something with another language that's more to my liking (any lisp) and as far away from the web as I can manage. For now I'm happy working for a firm that teaches me how to program in a work environment, that is close to my university.
Originally O3 is intended for interaction of system components in local networks of enterprises. I chose LZ4 because it gives best a compression and decompression speed. Zstd would be better solution for a slow network where a compression ratio has more weight.
[https://scholar.google.com/scholar?cluster=9401075773831565841&amp;hl=en](https://scholar.google.com/scholar?cluster=9401075773831565841&amp;hl=en&amp;as_sdt=0,33&amp;as_vis=1) shows many links for Postscript versions of the document.
Awesome!
Thank you very much.
&gt;I was taught Java at university and would like to learn lisp. Note: If switching from Java to (Common) Lisp, these will be the biggest differences to learn/overcome: - Metaprogramming and homoiconicity. The usefulness of it will slowly become more and more obvious. - In Lisp, everything is an expression. - On Java, things are compiled, then run. You write code that is read on compile-time, compiled, then excecuted. On Lisp, you can write code that executes either on read-time, compile-time, or runtime. - Java runtime has limited functionality. The Lisp runtime includes the Lisp compiler itself, which is transparently available at runtime. - Java is strictly OOP in a style close to C++. Lisp is multi-paradigm, so you'll first write code in procedural imperative style, then perhaps in functional style. - Lisp's OOP ("CLOS") is based on multiple dispatch and method combinations. It is startlingly different to Java OOP and very exciting to learn. - Lisp is dynamic all the way. This means that it was intentionally designed for doing things like redefining functions or redefining classes while the code is running. - Lisp functions support multiple return values natively. - In general, there is no type erasure at runtime with Lisp. Types stay there at runtime. - In some cases, Lisp is even more strongly typed than Java. - Some tutorials give the impression that we do everything using lists. On Lisp, there are arrays, hashes, vectors, and everything, so don't feel like everything has to done with lists. And also, regarding lists you'll find there are different usages of lists - alists (association lists), plists (property lists), trees, etc. 
Thank you, Little Bits of Lisp is a delightful series, on eof my absolute favourites in programming field. You have a knack to deliver complex concepts in a straightforward, inspiring and instructive way. Thanks.
Yeah but in the form of web pages, whereas what I was after was a book.
Thanks for Mentioning Portacle. Unlike others that I tried this was very easy to install.
Also here: [ftp://ftp.franz.com/pub/clim/clim\-spec/](ftp://ftp.franz.com/pub/clim/clim-spec/)
Common Lisp is an image-based language, like Smalltalk. This means that applications carry around a whole Lisp image. But - AFAIR, if you want to, you can install ECL system-wide, use it as a library, and create executables that depend on libecl.so. Maybe jackdaniel from `#ecl` on Freenode will be able to provide you with more information.
LispWorks has a tree-shaker which allows to strip down unused code from the delivered binary.
There are some compilers which do that. For example the commercial mocl compiler, based on the no-longer maintained CLICC compiler. https://wukix.com/mocl There are some others, including non-published inhouse compilers.
There are a bunch of other (subset) CL compilers which are not image based: mocl, CLICC, Thinlisp, L (probably), Lisp-to-C Translator (bought by Oracle long ago), [Eclipse CL](https://04514733008881444716.googlegroups.com/attach/3141f46c5f0d3a94/beta-announce.text?part=0&amp;view=1&amp;vt=ANaJVrG2M8uqp5M_uJEMH_YmfyIqn6-J3wjBhL3v429u9-7lEoXSe8kql_nkGPUpcM1_F8H0w8Gu7bAzHW9zcXvxz16nkA04WCzZmFEp4jk6NnLbRuS1jE0), ... See also WCL...
Do you know how small a Hello World can get with tree shaking?
12M at shaker level 2 and above.
On Mac OS, using CAPi (ie native dialog box) I have 12Mb with default settings.
SBCL is able to generate (compressed) binary about 14M.
 This is the TXR Lisp interactive listener of TXR 197. Quit with :quit or Ctrl-D on empty line. Ctrl-X ? for cheatsheet. 1&gt; (defun walk-tree (tree) (labels ((rec (tree) (if (atom tree) (yield-from walk-tree tree) [mapcar rec tree]) :done)) (rec tree))) walk-tree 2&gt; (obtain (walk-tree '(1 (2 3) 4))) #&lt;vm fun: 0 param + 1 optional&gt; 3&gt; [*2] 1 4&gt; [*2] 2 5&gt; [*2] 3 6&gt; [*2] 4 7&gt; [*2] :done 8&gt; [*2] :done 9&gt; [*2] :done 
Ich habe noch nie nen älteren Acc gesehen
For SBCL, which is the implementation used - Common Lisp is a language with zillions of implementations and different ways to create executable.
It should not be hard to port this makefile to Roswell which should make it cross-implementation enough.
Yeah, sorry that I didn't emphasis enough that the Makefile only supports SBCL (because that's the implementation that I'm most familiar with).
That sounds useful.
Nice idea. I'll take a look how to do it.
Wow, I didn't know that the WebAssembly text format (.wast file) syntax looks so similar to s-expressions. 
Why use external tools when you can just make ASDF do all of this? Just add the following lines to your system's ASD ``` :build-operation "program-op" :build-pathname "my-executable-name" :entry-point "my-package:my-start-function" ``` And then `(asdf:make :my-system)` from a fresh instance. Works for CLISP, CCL, CMUCL, LW, SBCL, and SCL out of the box.
Wow, very enlightening stuff. I've been reading a lot more and more about computing history lately and it seems that we're in a terrible quandary today largely because of an ignorance of history. Or because of a misrepresentation thereof. Very valuable post, once again. Thank you.
Hard to say for sure without context, even a time or place. But I would point out that Common Lisp was a case of various parties, including rival implementators, coming together under some pressure from defense funding agencies to hammer out a standard normalizing variations in exisring behavior without necessarily innovating or improving things very much. Aesthetics were explicitly a criterion in decision making, but not the primary one.
For modelling there are some free tools that are quite interesting for low budget users. Here is a small list with their equivalents: And I of course will miss some and do not cover CFD,FEM applications. Free| commercial | example application :--|:--:|--: Scilab, Octave, NumPy | Matlab | matrix algebra and related task in control, .... Scilab-Xcos | Matlab-Simulink, ... | block diagram like simulation and some physical port like simulation OpenModelica | AMESim, Dymola,SimulationX, ... Maxima, Sympy |Maple, Mathematica ,... 
It was the end of innovation in the Lisp world. According to Uncle Joe.
Thanks for sharing. I learned that ASDF allows to build an image in this subreddit too and this is how I do: https://lispcookbook.github.io/cl-cookbook/scripting.html#with-asdf
Project linked in the article: https://github.com/mck-/Open-VRP "Vehicle Routing Problems". And fun: - https://kuomarc.wordpress.com/2012/01/27/why-i-love-common-lisp-and-hate-java/ - https://kuomarc.wordpress.com/2012/02/02/why-i-love-common-lisp-and-hate-java-part-ii-code-examples/ - https://kuomarc.wordpress.com/2012/02/13/why-i-love-common-lisp-and-hate-java-part-iii-macros/
Since it's done differently on every implementation, don't use the word "common" at all. 
What he meant was: "I'm a fucking primadonna and I'm exercising my option to throw a hissy fit." What is art, particularly in the context of engineering? Art occurs when the engineer, and engineer alone, controls all of the requirements. He or she thinks, "it would be beautiful if the system was this way", and proceeds to make it that way. Common Lisp pissed off people who fancied themselves artists, and suddenly had to work with and integrate other people's requirements, like actual engineers. Phooey, other people and their requirements! Don't you understand that I am an *artiste*? 
I've googled something that seems like a full context: https://gist.github.com/agumonkey/777c2a289aa3afc2d814b38adbf5da9b &gt; I'm sure each of us could design a better language than Common Lisp is turning out to be, and that each of those languages would be different. My taste is close to RPG's, I think: in general, I like primitives that I can build with better than generalizations that I can specialize. However, Common Lisp is politics, not art. If we can come up with a single language that we can all live with and use for real work, then we will have accomplished a lot more than if we had individually gone off an implemented N perfect Lisp systems. The paragraph seems pretty self-explanatory.
This sounds like pure 100% rectified nonsense. Did you actually search for context of that quote?
It *is* using s-expressions, but since WASM is a stack machine, .wast files are more like s-expression Forth than anything lisp-y.
Amazing! Yesterday I decided to write a Makefile for a small command-line utility I've made at work. But after reading your post I've refactored my own Makefile to be more generic and published it on the GitHub as a template: https://github.com/40ants/command-line-template It is highly opionated and uses Roswell for binary building and Qlot for pinning dependencies. Also, when using my Makefile, you don't need to edit it – just put another my-script.ros file into the directory and run `make`.
The author compares "Programming OR approach" and "Modelling OR approach" and claims that going former is more suitable for Lisp (or whatever). I have a contrary opinion. OR is not only about domain-specific solvers ("software packages"). It provides solvers for a very generic framework, such as SAT or Integer Programming, which many problems can be converted into. They are mostly NP-complete so there are polynomical reductions between them. Furthermore, it is easy to add additional constraints in generic solvers so that the problem suits your needs. This greatly reduces the implementation time. I believe the problem with OR is that its accessibility is still low. Not many people would choose OR as the first choice for solving the problem at hand. At the same time OR is a domain specific language and lisp is good at making it. Why not provide a wrapper? So my answers are these libraries... https://github.com/guicho271828/cl-sat https://github.com/guicho271828/cl-smt https://github.com/guicho271828/cl-prolog2 More ideas to follow are IP solvers and MiniZinc interface.
That makes sense - thank you. 
Thank you for that - that's a good point. 
Lisp\+Forth sounds like a pretty fun combination to me. I'll have to check wasm out
&gt;Would macros still be possible? Compile-time macros would work just fine. The problem is that you will be killing a significant part of the power and fun in Lisp. &gt;hello world is almost always well over 1MB If you want extremely small "hello world" programs, use assembly. For real-world, complex applications, i'd hazard a guess that most CL implementations will produce an acceptable executable size. In any case, if you use the commercial LispWorks^TM implementation, it includes a tree shaker to bring down the image/executable size. [Documentation](http://www.lispworks.com/documentation/lw50/DV/html/deluser-50.htm). 
Use a treeshaker, or just avoid CL, and use any of the lisps that target C 
&gt; *Would macros still be possible?* A0: Yes they would because macros are compiled code in your program, not requiring compilation or interpretation. A1: No, because they would be meaningless. The purpose of a macro is to parse an input form and generate code, which requires interpretation or compilation. If you took out the interpreter or compiler, the macros have no back end to handle the code they are writing. 
&gt; hand it over to the operating system output routines. What, and hand the important task of I/O to some reams of bloated OS code??? No, the tiny executable must start up directly from the boot sector, and not even rely on BIOS (or other firmware) calls. 
Similar question: https://www.reddit.com/r/lisp/comments/8nt95a/small_executables_in_lisp/ &gt; It seems like every lisp compiler out there creates standalone massive executable files Besides the compilers which do not, like mocl. Which are rarely used. https://wukix.com/mocl &gt; Does this already exist? Yes, there are probably around 5-10 Lisp compilers developed since '82, which can do that. There purpose was memory efficient application delivery. For that compromises were made - often the language is only a subset of CL - large enough for some implementations - sometimes it was an inhouse compiler for just one major application - sometimes. An example for an inhouse system is the Gensym G2 application. http://www.gensym.com/platforms/g2-standard/ It's actually written in a Common Lisp subset and uses an inhouse Lisp to C compiler. Since the market is very small and the purpose is mostly 'delivery of applications', they remained exotic.
Have you lost the plot? Why would we make a huge generalized Turing machine??? We would be far better off designing a standalone IC dedicated to outputting our IO.
Maybe we could just write "Hello, world!" on a piece of paper and call it a day?
Thanks!
&gt; Executable size should be a few bytes. I found that the executable header dominates the size of these programs. But there is some optimisation to be had there: [ELF](https://archive.is/BcbHc) &amp; [PE](http://archive.is/w01DO#selection-35.3-35.20)
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://archive.is/BcbHc) - Previous text "ELF" [Here is link number 2](http://archive.is/w01DO#selection-35.3-35.20) - Previous text "PE" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
Man wouldn't it be nice if phones came with some way to enlarge text _and have it not be blocked by websites_.
I don't know what counts a a 'Lisp' for you, but a hello world in Chicken Scheme is 28kB on my system. It dynamically links with libchicken, though.
Yeah I've used chicken quite a bit but I wouldn't count it because it does link to libchicken
 ~$ ros run -L sbcl * (defun hello () (format t "Hello, world!~%")) HELLO * (sb-ext:save-lisp-and-die "hello" :toplevel #'hello :executable t :compression t) ~$ ls -l hello .rwxr-xr-x 12M meh 4 Jun 12:01 hello ~$ time ./hello Hello, world! real 0m0.168s user 0m0.140s sys 0m0.021s It's already pretty small with a Lisp that includes eval though. In the age of Electron, your users will love it!
Gerbil Scheme makes nice "smallish" binaries. bw|bw\-15mbp|2.1.10:\~\&gt; more test.ss \(export main\) \(def \(main\) \(println "hello world"\)\) bw|bw\-15mbp|2.1.10:\~\&gt; gxc \-exe \-static test.ss bw|bw\-15mbp|2.1.10:\~\&gt; ls \-lhd test \-rwxr\-xr\-x 1 bw \_developer 5.3M Jun 4 10:18 test bw|bw\-15mbp|2.1.10:\~\&gt; strip test bw|bw\-15mbp|2.1.10:\~\&gt; ls \-lhd test \-rwxr\-xr\-x 1 bw \_developer 4.7M Jun 4 10:19 test bw|bw\-15mbp|2.1.10:\~\&gt; ./test hello world
&gt; In the age of Electron, your users will love it This has a bit of truth...
Did you check guile scheme? One of its main design goals is cooperation with C.
Stick with Lua which is designed for embedding. Nothing in Lisp-land compares.
Welcome dear lurker :) As you mentioned Lua, there's a farily recent Lisp that translates to lua called [fennel](https://github.com/bakpakin/Fennel). It's very new, and not standard or anything, but maybe you can give it a shot. For embedding you can try [ECL](https://common-lisp.net/project/ecl/) (never tried it) or [Gnu Guile](https://www.gnu.org/software/guile/) depending on your CL/Scheme taste. I'm sure there are many more options, but I'd say these ones are viable solutions for your needs. 
How is something you've never tried a "viable" solution for his needs? I wish people would be more critical with their advice. ECL is a mess in every possible way. Guile is orders of magnitude more complex than Lua, has serious issues on non-Linux platforms and pretty much nobody is using it. Lua is minimal, simple, robust, widely used and has proven itself many times over.
Not really because I just relaxed the license issue. Seems like it's the best bet, though, thank you for pointing me back to it. 
Been there ?
Thanks for fennel, I'll have a look, this is an interesting approach. ECL is too hard to port because of Common Lisp standard surface, but I'll have a look at Guile to see if it's easier to run on my devices.
I have read good things about Chibi Scheme. It's intended use is embedding and is presented as a library without dependencies to make it easy to use. http://synthcode.com/scheme/chibi
Yes, and I'm grateful that Lua exists. It's not a Lisp but it's nowhere near as bad as Python and Ruby, and for embedding I've found nothing that's even remotely close.
I worked on a console game with an embedded CPython. I still hate Python \(language and reference implementation\) to this day, so I can relate. Lua does what it does. But expressivity is cool, though :\)
Guile is my favourite Scheme! I would definitely recommend it, as well!
Guile Scheme compares favourably. The GC isn't optimal, but the speed is pretty good unless you are comparing to luajit. Good threading libraries (with proper parallelism) with a nice stdlib and a good repl.
Chibi is nice, but pretty slow. 
Thank you, this looks promising !
How is a reply that doesn't explain anything an argument? I wish people would be more self-reflecting with their advice. Snark aside, please explain how ECL is "a mess in every possible way." Posting something so baseless without any further explanation is nothing more than trolling.
Read this: https://common-lisp.net/project/ecl/static/ecldoc/Extensions.html Bask in the tendril-like complexity of such simple concepts as FFI. Compare with Lua. Finally, keep in mind that pretty much everything mentioned in this page is broken is some way. 
/u/understanding23, viable meaning that apparently matches the requirements, but I thought mentioning that I have not tried it in those exact circumstances means that "there be dragons", but maybe it's a pointer worth following. I wsih you all the best of luck with your search
I was going to suggest Guile too :)
What about [PicoLisp](https://picolisp.com/wiki/?interfacing)? * Integrated database * C / Java interop. Call C functions directly from Lisp code, manipulate C data structures in memory, and even call Lisp functions from C, all this available interactively at the REPL. * Really simple * MIT/X11 License 
I was under the impression that the semantics of Picolisp are quite foreign both from CL and Scheme, so i'm not willing to invest knowledge \(and share it with other people on the team\) in an so exotic Lisp. I just checked the [FAQ](http://www.software-lab.de/doc/faq.html) again and, for instance, "We believe that arrays are usually overrated. Textbook wisdom tells that they have a constant access time O\(1\) when the index is known. Many other operations like splits or insertions are rather expensive. Access with a known \(numeric\) index is not really typical for Lisp, and even then the advantage of an array is significant only if it is relatively long. Holding lots of data in long arrays, however, smells quite like a program design error, and we suspect that often more structured representations like trees or interconnected objects would be better." Seriously guys ? I understand not having arrays in a femtolisp but I'm a bit too ingrained with "textbook wisdom" :\)
Have you looked at these? * [Chez Scheme](https://scheme.com/) (Now open source) * [Chicken Scheme](https://www.call-cc.org/) * [FemtoLisp](https://github.com/JeffBezanson/femtolisp) 
In addition to Fennel, there's also a lisp-&gt;Lua that's been around longer, called [Urn](https://urn-lang.com/). It feels like a weird hybrid of Common Lisp, Clojure, and Racket grafted on top of Lua. I like Lua fine as a language, but there's a lot of "reinventing the wheel" in every project if you want any sort of programming niceties. Rather than constantly reimplement `map`, `fold`, etc. it's nice to have a lisp-y, batteries-included option that compiles down to usable Lua. Not sure about Fennel, but one thing that makes Urn attractive is it plays nicely with externally created functions, like those provided to embedded Lua interpreters in games and other software. You declare a symbol as coming from an external source with `define-native` and it sort of passes it through during compile, meaning you can `define-native` any API-provided function names and write code using it without the compiler barfing on them being undefined symbols. That, combined with the way it strips down its runtime to *only* the Urn functions you use, means you get a nice standalone Lua file you can use in just about any Lua context. If you can feed Lua code to something, you can write it in Urn first. This is what I wanted out of Hy (a Python-based lisp) but its dependence on its own external runtime made it a pain in the ass in comparison to the convenience of Urn. I think either one (Urn or Fennel) makes a good compromise: since it's still Lua underneath, you can use Lua as the "lowest common denominator" while providing a more powerful alternative. If this is something you make available to others, you could provide documentation describing how to use one (Urn or Fennel) with the software while still allowing use of Lua for the masochists that like rewriting everything. There are a lot of people that know Lua, and its similarities to JavaScript mean it's approachable to even more, so it doesn't hurt to have it available for them. If it turns out this doesn't work for some reason, or you just *really* want to avoid Lua in all forms, [Chibi Scheme](https://github.com/ashinn/chibi-scheme) is a Scheme dialect specifically made for embedding. Not quite what you're asking about, but you might also find [Ferret](https://ferret-lang.org/) interesting. It's a Clojure-like lisp dialect that compiles down to C++11 code with the intent of being usable in embedded systems, so you have control over [memory management](https://ferret-lang.org/#sec-4-2) and can [embed C or C++ code](https://ferret-lang.org/#sec-4-8) for FFI. That means if you're enough of a madman you could probably write a program in one lisp (Ferret) and embed another (Chibi Scheme) for use as a scripting language. :)
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://urn-lang.com/) - Previous text "Urn" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
99% of the time when I'm accessing elements of an array, I'm accessing them in a loop, not at random. So O(1) random access time is not useful for me. The only time I'm doing anything like that is when I'm using a hashtable.
Other people have mentioned reasonably good things, but consider also librep, which was/is a bit of a toy, but supports the sawfish window manager, so does get regular use. It has some configure options to minimize it, but I do not know what the cross\-compilation story is \(which would help with porting\). It comes with a header file to allow implementing lisp fuctions directly in C, and also has an FFI for interacting directly with C. It's no speed demon, so would \(like lua or python\) be used for glue code.
I have different usage patterns :) And memory contiguity is very important for performance, isn't it ?
Thanks. I have to admit that having Lua as the lowest common denominator and then having a Lisp on top of that is a good idea to ease adoption. I'll have a look at Urn and Fennel.
Only Chicken Scheme, thank you for the links !
Yep, plus you get Lua's strengths as an embedded language to boot. Plus, with Urn at least, you can even use LuaJIT if you need for performance purposes. Fennel may also be usable with LuaJIT, I didn't see anything listing Lua versions for support though. A thought, though: if you go that route, make sure to document the process of using Urn|Fennel for scripting to keep the barrier to entry low for potential users. Otherwise everyone will just use Lua out of sheer laziness. Urn's pretty well documented overall, but an overview of how to use it to compile Lua files for your software, plus some example code specific to your codebase and API, would help make it easier to pick up. On that note, the licenses for Urn and Fennel are BSD and MIT, respectively. Maybe bundling one of them *with* the software in some form would make it even more appealing to use over bare-bones Lua, plus it would provide a stable version to support, so that changes in the language upstream won't affect end users. 
&gt; As Linus Torvalds said, "Java, what a horrible language". You have to remember Torvalds only has a very narrow view of languages: writing kernels. You'd have to be insane to write a kernel in Java, but you'd be equally insane to write any business application in C.
That's right. GC might help with that, but arrays are just safer and it's bizarre to leave them out. 
You should probably check out Scopes. Docs: http://scopes.readthedocs.io/en/latest/ Screencast demos: https://www.youtube.com/watch?v=v4waNsi5Urg&amp;list=PLWVpbdR2y12c3q_sjbFx3ptSyjEqus4ec The syntax is primarily indentation based, but it's a sugar for s-exprs. It's sort of the inverse of what you're asking. Less of a thing you embed, and more of a primary language. But it's designed to interop well with C libs (you can import headers directly). It doesn't emit C code, rather it emits llvm IR and JITs it. The guy who makes it is a demoscener, hence the screencast about shader programming. May not ultimately be what you're looking for, but if you like Lisp and PLT and graphics you'll find a lot there to appreciate.
Thanks, not what I need but interesting read though :)
&gt; The syntax is primarily indentation based &gt; &gt; Whitespace controls scoping in the SLN format. Therefore, to avoid possible ambiguities, SLN files must always use spaces, and one indentation level equals four spaces. Nope ... bad language design. &gt;[ When you're worried about satisfying the compiler or interpreter, you have to follow arbitrary rules. When you're worried about making your code readable to humans, whether that's yourself or others, you should follow certain principles and feel free to deviate from them when necessary. That's because computers are stupid and humans are smart. Computer readability is blunt and inflexible, while human readability is not.](http://wiki.c2.com/?PythonWhiteSpaceDiscussion) 
me too. It is exactly what OP is looking for.
You don't find any benefit from memory locality? Lists can have their elements allocated anywhere on the heap, but you know arrays will be contiguous and if the values are embedded in the array, the prefetcher will reduce the memory bandwidth.
GNU/Guile is great if you are on Linux/Unix, but it fails OP's "easy to port" requirement. I remember I got GNU/Guile 2.0.9 and 2.0.11 cross-compiled for Windows after around 2 weeks of labour and fighting with its dependencies and build system when those versions were recent. GNU/Guile 2.2.x versions are broken as far as Windows is concerned. Unless they somehow have fixed it during the last 5 months or so. They rewrote their binary format from scratch in 2.2.x, which now is based on ELF.
True, but practically all (non .net) programming is (at least more) painful in windows.
Do you have any resources on femtolisp available? There's not much docs
I'm genuinely curious what you find so complex about ECL's FFI interface. To me, it looks pretty simple and boring. As for the claim that it all things mentioned there are broken, have you actually tried it? For me, everything worked fine.
&gt; Bask in the tendril-like complexity of such simple concepts as FFI. I find nothing strange on doing FFI using ECL. Just use CFFI (examples provided on the link you posted), which is very easy to use. 
The last time I tested statically linking "Hello World" with Chicken Scheme was about 600KB using musl libc.
K
Not sure what you mean. I've programmed with Windows at a target platform for the last 15 years without problems. All my libraries and software are portable between Windows (MinGW, Visual Studio) and Linux (GNU make). It's not that hard if you put in a little bit of effort. I was also referring to portability/cross-builds. How easy Windows is to develop *in*, is kind of irrelevant.
Do you work with Common Lisp ? (I'm interested to fill up https://github.com/azzamsa/awesome-lisp-companies) ps: &gt; Even though you will not find LISP among popular, mainstream languages, To be positive (and self-realizing?), we might recall not so bad figures: - "Lisp", whatever is under this name, and I believe it is mostly CL, is 21 on the Tiobe index, above D, Erlang, Clojure, Scheme, Lua, Julia, Haskell,…
How can it be a "tribute to Lisp" if there isn't a single code example written in Lisp, be it the original Lisp or a compatible dialect like Common Lisp. All examples are in either Scheme (which has significant differences with the original Lisp) or Clojure (which is very distanced from lisp AND scheme). 
Would you need libchicken installed for that to run? 
I don't see how Common Lisp is closer to the original Lisp than Scheme. Could you elaborate?
&gt; Do you have any resources on femtolisp available? There's not much docs No, I am aware of it only because it's used in the parser for the [Julia language](https://julialang.org/). I'd reach out to the author, https://twitter.com/JeffBezanson. Julia may be of interest to the OP as it can be embedded or used to drive C/C++.
&gt; I don't see how Common Lisp is closer to the original Lisp than Scheme. Could you elaborate? Yes, the line of ancestors, simplified, is like this: Lisp (1959) ---&gt; direct descendant Lisp 1.5 (1960s) Lisp 1.5 ---&gt; direct descendant MACLISP MACLISP --&gt; intended successor: NIL (70s) MACLISP --&gt; direct descendant ZetaLisp (70s) MACLISP, NIL, ZetaLisp --&gt; Common Lisp (1984), an amalgamation to create a succesor to MACLISP So Common Lisp is largely compatible with the original Lisp, not to mention many dialects. Now, where is Scheme? Scheme appears in 1975 as a new dialect totally divergent from the prior Lisp dialects; different keywords, constants, different application of functions, intentionally geared to recursion, etc. Scheme code is not compatible with Lisp, but can be rewritten (or translated) for the most part. 
Thanks for your explanation :)
Common Lisp is mostly backwards compatible with the old Lisps and has much of the same functions and special operators. It is in many ways the same old Lisp, but modernized and enhanced. Scheme was developed as new experimental language and implemented on top of Maclisp. Thus the original Scheme inherited some of the old stuff, too. But the language was originally influenced by the Actors paradigm (message sending objects with high concurrency) and kinds of lambda calculus - trying to understand how a Lisp language with lexical binding everywhere would look like. Over time Scheme was developed further as a) a language for education and b) as a language for research of computer science (CS) concepts, c) as an extension language and slightly less for d) application development. Generally I would think that Scheme evolved more around CS concepts and something like Common Lisp evolved more around the original goal of symbolic AI programming. It's not exclusive - more like a general trend. Racket for example is more the product of a branch of computer science research (for example in macro systems, ...) and research in computer science education. Thus there was a movement to make Scheme slightly more static (eval as an underspecified library procedure, fixed syntax, less interactive development favoring more reproducable programming approaches, ...). In the earlier days some code could be shared, emulated or running on top of the other - but that ended probably 90s. Like a CL implementation on top of Scheme, Scheme implementations on top of CL, or compatibility layers to run code written originally in Lisp in Scheme or vice versa.
Being a Vim user, I found out using [Spacemacs](http://spacemacs.org/) has pretty great default support for Common Lisp. Just install SBCL (or any other implementation) and that's it. It takes some time to get used to it but once you get to know Spacemacs it's almost better than Vim, if only it wasn't so slow!
The example given of metaprogramming is just the use of first class functions.
Have you looked into [**Embeddable Common Lisp**](https://common-lisp.net/project/ecl/) or [**Racket**](http://racket-lang.org/)?
The reference is filled with examples of a language that looks like Pascal, with `BEGIN` and `END` blocks and `:=` assignments and whatnot, but with C-like declaration syntax like `DOUBLE X, Y;`, and even labels like `FOO:` with `GO TO FOO;`. Yet it makes frequent references to Lisp: Lisp data types and conses and such.
Another great explanation ! Thank you :)
If you have something tangible in mind (regarding brokeness) please report an issue. I won't address other concerns because they don't make much sense (just fear, uncertain and despair spreading).
&gt; Basically the two main dialects of Lisp are basically "Lisp" and "Scheme", each one with its own dialects or variants. Where does ELisp fit in?
Elisp is a descendent of MACLISP, so sort of like a sibling of Common Lisp.
&gt;Where does ELisp fit in? ELisp is part of the traditional Lisp family, and came out before Common Lisp and after Scheme. It did not incorporate Scheme's lexical bindings, because Stallman wanted something that could be simple to implement and fast on the target hardware. I never liked elisp, to be honest. I'd rather use CL, Scheme or Clojure. 
We use Scheme to teach students and employees the basics of functional programming. What I meant is that the language is not widely used at commercial projects as far as know.
Hi there, I’ve been embedding newLISP in various apps for the past few years with excellent results. Tiny DLL/C-lib (300kb), very fast and very very lispy (more so than Racket, CL and Scheme), FFI, excellent standard lib. Author is very responsive. Highly recommended.
Dammit life! 
Actually ELisp/Gnu Emacs development started in 1984 and released in 1985 after CLtL1 which started in 1981 and was published in 1984. Stallman was involved in CLtL1. IIRC, Stallman thought lexical bindings and namespaces as unnecessary.
&gt;Stallman was involved in CLtL1 Are you totally sure? I've read some texts by Richard P Gabriel doing recollections of the commitee and decisions and didn't recall RMS there.
Hey, defunkydrummer, just a quick heads-up: **commitee** is actually spelled **committee**. You can remember it by **double m, double t, double e**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hope all is well, keep being awesome!
ok, thanks. &gt; What I meant is that the language is not widely used at commercial projects as far as know. You may be right, for sure we are not overwhelmed by propaganda of Lisp companies. Still, we could say this: Common Lisp is still being adopted by big companies today, particularly in high demanding fields (don't know how to say better). For example: Emotiq (the blockchain), Rigetti (quantum computing), D-Wave systems (quantum computing), Ravenpack (big data analytics for financial services), Secure Outcome (finger printing systems for military),… Not to cite the well known Franz (graph database), Grammatech, Irobot, Grammarly, 3E (real time alerting of sustainable energy systems), Siscog (underground and transportation planning),… plus it is adopted by researchers in bioinformatics. IMO the CL foundation is not playing its role by not doing this list.
See mailing list archives https://cl-su-ai.cddddr.org/threads.html or common.msg files at https://www.saildart.org/[COM,LSP]/ Stallman is very involved especially around '81 and '82
thanks man!!
Note that the ANSI CL standards committee X3J13 started work in 1986, roughly five years after the Common Lisp effort was started. 
danke schön, lisper-meister. 
foreign-alloc / foreign-free ? https://common-lisp.net/project/cffi/manual/html_node/foreign_002dfree.html
Thank you again, yes, especially for `(foreign-free)` ,I have thought about that but the inputs of foreign-alloc are something like : ` (foreign-alloc :char :count 20) ` Here the input is a type :char and indeed an integer (corresponding to size_t) What the callback function is expecting are two integers. I am currently testing to create my own library with myown clone functions mycalloc and myfree with an include &lt;libstd.h&gt;, but I'd like to be as portable as possible and let cffi get it from the system. Thank you !!
I don't understand your use case then. calloc and free aren't callbacks in C they're just stdlib functions. foreign-alloc and foreign-free are CL wrappers for calloc and free, respectively. Having a callback from C to CL just to call back to C to always call calloc or free seems a bit strange.
(cffi:foreign-symbol-pointer "free") (cffi:foreign-symbol-pointer "calloc")
https://en.m.wikipedia.org/wiki/LISP_2
Non-Mobile link: https://en.wikipedia.org/wiki/LISP_2 *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^190155
GTL doesn't seem to have "largely Lisp-like semantics and Algol 60-like syntax".
Sometimes C libraries specify a callback interface for memory allocation, which you can default to `malloc` and `free`. In this situation, if you're working in Lisp, and these defaults are fine, you ideally want a way to pass those pointers into that library, so that it directly calls those functions, rather than to generate FFI callbacks which allocate foreign memory.
Bad bot
Thank you, jaybee, for voting on CommonMisspellingBot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
details: [https://groups.google.com/forum/#!topic/dylan\-lang/WCRu714YBHQ](https://groups.google.com/forum/#!topic/dylan-lang/WCRu714YBHQ)
'(cffi:foreign-symbol-pointer "free")' Thank you !! So if I understand well this command will return a pointer to the function and if the C code is expecting a pointer ... I'll just need to pass it. Going around I then have noticed that `(cffi:defcfun ("calloc" my-calloc) :pointer (n :int) (m :int))` will also produce a function that I can use in the REPL. The RTFM part is that I should have read that the standard C library is loaded by default by the cffi package. I then have to check if I should pass this last function or the previous pointer as the callback function reference. THank you again !!
Yes this is exactly the case. Thank you. 
I could replace the callback but I don't want to touch the library, that can come from others or create a side library. These callback functions are also part of a C structure that I also cannot touch. So I need to build a structure in cl that matched the C structure with components that are these callback functions (or their pointer, I need to check) defined in cl as well . Thank you 
I created this from bhyde's excellent https://github.com/bhyde/heroku-buildpack-ccl64, extending it to use Roswell. That way it should support any Roswell-supported Common Lisp implementation; I've tested CCL and SBCL. Feedback very welcome; I'm still learning my way around Common Lisp.
Thank you ! Gonna be much helpful.
Well, turns out that the numerical tower of Chibi for 64bit platforms relies on uint128\_t arithmetic, so it would need a bit of work for MSVC 64 bit (one of my platforms), so I'll try another one. Too bad, it looked cool, but I don't have time to replace lots of \+ by function calls (in C\+\+ or Lisp, it would have been easier \^\^)
First Class functions in Java: Yes. Closures as we know them: No. 
Java's GC is tightly integrated with its JIT compiler. Ignoring the Java to JVM bytecode compiler, there are two compilers (C1 and C2) inside the JVM runtime. First your platform-neutral bytecode is rapidly compiled (C1) into poorly optimized code, and that same function is scheduled to soon be slowly compiled (C2) into highly optimized code -- targeted at the *specific* hardware you are actually running on, and its instruction set extensions. The C2 compiler is highly aggressive at inlining. C2 compiled code is fast. If a class is dynamically reloaded, then all functions in that class immediately change back to being interpreted bytecode once again. No native code. Continuous dynamic performance profiling will (or may) once again reveal that your function is indeed a hot-spot (getting more of the CPU) and thus will be rescheduled to be recompiled by C1, then C2. Now suppose MY function X is inlined by YOUR function Y when Y gets compiled to native code by C2. Next, my class containing X gets dynamically reloaded. Now YOUR function Y has a stale inlined copy of my function X. The JVM runtime not only makes my dynamically reloaded class deoptimized back to bytecode interpretation, it also affects anyone else's inlined functions from my class. So your function Y no longer has a stale inlined copy of my function X. Continuous dynamic profiling of execution performance will reveal if any interpreted function is getting a lot of CPU time which instantly makes that function a candidate for compilation by C1, then later C2. Once a function is compiled, the overall dynamic performance profile of the overall program changes, and a new CPU hotspot is revealed, triggering more native compilation, etc. A large Java program seems to start up, and then take several minutes to "warm up" to where it is running fast. JVM offers a choice of Garbage Collectors for you to choose from. Each has numerous knobs and dials for tuning. Runtime performance can be monitored by various tools. GC logs can be analyzed using more tools. Java already has GCs that handle dozens or even hundreds of GB of RAM. Red Hat's new Shenandoah GC, and another experimental GC effort (ZGC I think it's called) both target active heaps of 10 TB. Yes, you read that right. Complain if you want. But the JVM (not the Java language) is actually a fantastic industrial strength runtime platform. Open Sourced. There are other experimental implementations (IBM's Open J9, Graal VM) with more improvements. There has been decades of research done into JVM's GCs and Compilers. C2 is possibly one of the most sophisticated compilers alive. 
My favorite Java pattern to construct an instance of class Foobar is the FoobarFactoryFactoryFactory. How this comes about. There are a lot of knobs and controls to set before constructing a Foobar. (Because there are actually a lot of alternate implementations of Foobar hiding behind it that you don't see.) So enter the FoobarFactory. You construct a FoobarFactory and set the FoobarFactory with parameters you like. Now it neatly constructs optimized and somewhat preconfigured instances of a Foobar for you. But . . . it is too complicated to initialize the parameters of a FoobarFactory, so let's have a FoobarFactoryFactory. The FoobarFactoryFactory is a factory that will construct FoobarFactories. You can see where I'm going with this. Obviously I know some Java. :-)
I'm glad :) Let me know how you get on. Very happy to receive issue reports and pull requests :)
Chez seems rather easy to embed but I find it sad that you can (unless I missed something major) only have one interpreter state at a time. Especially for an R6RS implementation, that sounds like a major oversight.
Thanks for interesting info. ABCL developper? I agree that their GC and compilers are sophisticated. I didn't know about C1 and C2, but yes, I was sensing that something like those should exist. I know some ppl developing Open J9. They joke they make JVM but don't know how to write Java :) I didn't mention compiler in the post, but that's not the only point I say hell no.
Doh? The Usenet group `comp.lang.dylan` exists. https://groups.google.com/forum/#!forum/comp.lang.dylan 
I was thinking that Dylan programming language is pretty much dead, isn't it?
There's a port of clojure to .NET
&gt; &gt; (defun sly (&amp;optional command coding-system interactive) &gt; "Start a Lisp implementation and connect to it. &gt; COMMAND designates a the Lisp implementation to start as an &gt; \"inferior\" process to the Emacs process. It is either a &gt; pathname string pathname to a lisp executable, a list (EXECUTABLE &gt; ARGS...), or a symbol indexing &gt; `sly-lisp-implementations'. CODING-SYSTEM is a symbol overriding &gt; `sly-net-coding-system'. &gt; Interactively, both COMMAND and CODING-SYSTEM are nil and the &gt; prefix argument controls the precise behaviour: &gt; - With no prefix arg, try to automatically find a Lisp. First &gt; lookup `sly-lisp-implementations', using `sly-default-lisp' as &gt; a default strategy. Then try `inferior-lisp-program' if it &gt; looks like it points to a valid lisp. Failing that, guess the &gt; location of a lisp implementation. &gt; - With a positive prefix arg (one C-u), prompt for a command &gt; string that starts a Lisp implementation. &gt; - With a negative prefix arg (M-- M-x sly, for example) prompt &gt; for a symbol indexing one of the entries in Pass the string as the first argument to the function.
Thanks. That's actually what I (unsuccessfully) tried first: `(sly "/usr/local/bin/ccl64")` Does it work for you (with the correct path for your system)?
https://github.com/joaotavora/sly/blob/master/sly.el#L1026 I reckon it takes the then-path, can you check? I don't use sly.
Pedantry incoming: not a port, an [implementation](https://clojure.org/about/clojureclr)
My bad. In my defense, I may be hungover from my bachelor's party
And by may be I mean am
Congrats!
Thanks!!
I have not looked at this personally, but Bigloo is a Scheme compiler than can apparently compile to C or CLR/JVM bytecode: http://www-sop.inria.fr/mimosa/fp/Bigloo/ There was a release in Jan 2018, which is more promising than these things usually are :) 
There is [IronScheme](https://github.com/leppie/IronScheme/blob/master/README.md).
I see your pedantry and raise you :) It looks like ClojureCLR makes use of the Dynamic Runtime Library, which sits on top of the CLR and allows for dynamic typing [e.g. for IronPython]. It's not just the CLR with some C# libraries, there's new C++ going in to it. I don't think this will matter to OP but it's a fairly substantial difference under-the-hood. I imagine ClojureCLR has its own robust type system, but under-the-hood you're losing a lot of the type/compiler safety that maybe made the CLR an attractive option in the first place. I have not looked in to this too much, but I think it would be impossible to fully implement Clojure using only the CLR, even if you didn't care about C#/F# interop. The problem is that in .NET you simply cannot define static method constraints on runtime generics, which makes even the CLOS difficult to implement in full, and anything like Haskell's typeclasses almost impossible. F# can fake it using statically resolved type parameters, but that's a trick which disappears at compile time. F#'s approach has advantages over LISP/Haskell from an object programming perspective, but otherwise it's a major limitation in .NET's type system. You're limited to 1) using the DLR, which is probably the best option but might have some drawbacks, and is almost certainly more prone to compiler errors 2) Using MSIL/C++ to extend the CLR a bit so that you retain "most" of the type safety without blowing the whole door open. This would wreck .NET interop. 3) At compile time build a whole bunch of classes that implement the same functions for different types (say every primitive numeric + a few custom types with a static member Add), and sacrifice the ability to call those functions at runtime with new types that implement Add so you retain .NET interop. Not to hawk Bigloo again - I only discovered it today and have been reading about it off-and-on - but it looks like they took option 2 and 3...at least in 2004. http://www.jot.fm/issues/issue_2004_10/article4/index.html I am not sure what your needs are - or what Bigloo has done in the 14 years since that paper was released :) - but these are things that might be worth considering. There are different things to consider vis a vis integrating with F#/C# assemblies vs. simply compiling to .NET bytecode that runs.
&gt; I see your pedantry and raise you **no string bets, please!** --- _^(I'm a pointless bot. "I see your X and raise you Y" is a) ^[string](https://en.wiktionary.org/wiki/string_bet) ^[bet,](https://en.wiktionary.org/wiki/string_bet) ^(and is not allowed at most serious poker games.)_
Conclusion: So I decided to go with Chibi Scheme despite its little portability problem, Which I fixed myself (one afternoon of multiword arithmetic implementation, I love using C libs, not writing C!), and now I'm going to try integrating it to my projects. Already found a bug but my scripting is not mission\-critical, so I'll go with it.
Have you tried using sly-default-lisp instead of prefix-arg? (defun ccl () (interactive) (let ((sly-default-lisp "/usr/local/bin/ccl64")) (sly)))
Nice swagger parser in there.
That's exactly how I start CCL with Sly: ``` (defun ccl () (interactive) (sly "~/bin/ccl")) ```
Truthfully, Javascript as it is so moldable under a good eye.
I used cl-opengl in my last GL-in-Lisp project. I'm still pretty n00b at GL though, so YMMV. [Here's a link to it, in case you're imterested at all.](https://gitlab.com/RobertCochran/shadowvard-engine)
Ruby. I think I will enjoy programming in Nim once they get rid of that "copy all composite objects" stupidity.
CEPL is a very cool project utilizing modern OpenGL in a very Lispy way. Check out https://github.com/cbaggers/cepl . Author is also a very kind person who is eager to help (he streams videos about the engine [and other lisp-related things]).
APL(particularly Dyalog APL), as a mind-blowing intellectual experience; c++ for total control and performance while still having abstractions (classes and templates)
C, I like small languages. 
Perl and Ruby. And Lua...sort of. Underneath the syntax difference, Lua has a Scheme-y feel to it that I like, but I get frustrated at having to implement even the most basic FP stuff from scratch to use it how I want. Plus the lack of macros means you can't add features to it outside of changing the language itself, and the language developers only care about OOP syntactic sugar. I still like the language well enough, but that taints it a bit because I find myself either copy/pasting boilerplate or reinventing the FP wheel whenever I use it. 
Perl5.
Rust! Its standard library is incredibly well designed, and the memory guarantees means I've never felt as confident in my code as I do with Rust
- [Pushing Pixels with Lisp \(playlist\)](https://www.youtube.com/watch?v=82o5NeyZtvw&amp;list=PL2VAYZE_4wRITJBv6saaKouj4sWSG1FcS) - [CEPL \(playlist\)](https://www.youtube.com/watch?v=a2tTpjGOhjw&amp;list=PL2VAYZE_4wRKKr5pJzfYD1w4tKCXARs5y&amp;index=5) By /u/baggers_ 
Apart from the undefined variables like `u:\*home\*`, can confirm this works fine in SLY, just replace `slime` with `sly` Here's a simpler version without said variables: (setq-default sly-lisp-implementations `((sbcl ("sbcl") :coding-system utf-8-unix) (ccl ("~/Downloads/2018-06/ccl/lx86cl64") :coding-system utf-8-unix))) (defmacro define-sly-lisp (name) `(defun ,name () (interactive) (let ((sly-default-lisp ',name)) (sly)))) (define-sly-lisp sbcl) (define-sly-lisp ccl)
haskell is cool, types are cool.
Idris
Elm and C !
Erlang is very fun to program in, with its Smalltalkesque object system and swarms of tiny processes. Other than that - Java, as much of a pain it tends to be. It's surprisingly fun to bring ideas from Lisp back into Java, even if they are 10x-50x bigger in size as a result.
I'm assuming since it's a layered FFI, OPENGL- VERSION is behind? Is FFI / grovel capable of updating GL-UNIMPLIMENTED-FUNCTIONS during development or forking
cl-opengl is the bindings library to GL. It supports all the latest GL calls and is everything you need to directly interact with GL. You'll still need a library to handle the window and context creation for you, but there's plenty to choose from there like cl-glfw3 and cl-sdl2.
I don't enjoy Python any more, the Lisp syndrome hit me :( I'm tired of the language and its ecosystem. I'm lurking into [Nim](http://nim-lang.org/). 
Ruby, and increasingly Go (for the sorts of things Go seems to be good for). And C + Z80 Assembly when I have the time to indulge my retro-programming habit.
JavaScript seconded. 
Yup! Idris is very nice.
Nim is very interesting in terms of it's metaprogramming features, I'm just a bit tired of Araq and other Nim compiler developers not hitting 1.0 version. 
Recently I've took a look at F#, which is basically OCaml on .NET framework with some interesting pipe like operators.
Prolog. enjoy yes. any good at? maybe not so much. Was just reminded of its existence recently as a startup was just [advertising a prolog job](/r/prolog/comments/8n72rr/software_engineer_database_job_data_chemist_ltd/) in my home town, which is ...unusual. I'm not qualified, but it made me fire up swipl to have a play. Yes I know you can embed a toy prolog in lisp (and vice-versa) relatively easily. But it's different enough from lisp in character, and there are real non-toy implementations like there are real non-toy common lisps / schemes. 
Prolog too. I've actually discovered Prolog through Mercury. I learned some Prolog long ago, in my study days, but didn't remember much of it. When Mercury came along, I tried writing something in it, but then I realized that in order to understand it, Prolog is a necessary reference material. I couldn't incorporate Mercury anywhere in my daily life, but Prolog: it was really easy to write one-off parsers in it. So I wrote a few. I could even combine this with my day job because those were small self-contained projects, which didn't require much code sharing. I was then hoping that some of the fancy graph databases would adopt Prolog as their query language, so that I could find a job in a language I like, but it seems like the trend isn't catching on...
I don't know video tutorials other than some of the Common Lisp streams that Baggers and Shinmera and other people tend to post around here or /r/Common_Lisp sometimes. They aren't really tutorials, but more like livecoding videos. For books, you could use http://www.gigamonkeys.com/book/ - it's an awesome book that will get posted here sooner or later anyway.
I enjoy C, if it is related to Lisp internals. Other than that, all non-Lisp is fucking garbage.
[Little Bits of Lisp](https://www.youtube.com/watch?v=m0TsdytmGhc&amp;list=PL2VAYZE_4wRJi_vgpjsH75kMhN4KsuzR_) isn't a course but its a good video series intro to Lisp.
Smalltalk. Like Lisp, it is image based, supports interactive development, has a very simple and uniform syntax. Its integration with graphical tools and GUI in general is great too.
This [MIT OpenCourseWare](https://www.youtube.com/watch?v=2Op3QLzMgSY&amp;t=106s) is a monumental option... 
I'm surprised it took so long for someone to say smalltalk
Udemy has one: https://www.udemy.com/lisp-programming-language/
SICP lectures! I missed these ones. As much as SICP is about teaching Scheme and not (Common) Lisp, I consider these lectures to be amazing and a very good choice. If anything, I'd begin with them to get a solid basis of what the basics of both Scheme and Lisp are about, and then make a choice of which language(s) you'd like to get to know better.
Elixir. Its AST-access feels almost Clojuresque, and the qualities inherited from Erlang are just pure gold.
Agreed! Pharo on the desktop, CL on the server is so much fun.
I used to truly enjoy Python, but I haven't used it since I switched to Common Lisp. All through my life i've enjoyed C: it puts you in control and runs fast. 
Your best bet seems to be IronScheme. Clojure's ecosystem depends directly or indirectly on many JRE/J2SE classes, thus is not fully available on ClojureCLR, thus code written for ClojureCLR will thus be bound to that platform and viceversa. Unless you're perfectly fine with that, of course. IronScheme is R6RS conforming so it's based on a firm standard. 
I work with Ruby (and Rails) and it's just great. The only downside is that you have to deal with people not knowing how to properly use a dynamic object-oriented language, given Ruby is very permissive, but it's still worth it. Things like rubocops and styleguides make it better at least.
second apl
If you're interested in Prolog, you might be interested in Lisp libraries like Screamer, Lisa, and GBBopen. They're interesting each on their own, but combined, they should be able to do backward and forward chaining, as well as event\-driven programming. For example, you might structure a complex problem domain as a blackboard with GBBopen, and let Screamer and Lisa code act as separate Knowledge Sources (KS) controlled by the Control Shell (a.k.a. "agenda shell"). If you want flexibility/adaptability, then with the Control Shell you combine the knowledge of all KS's to solve the problem. If instead you want fault\-tolerance, then you could implement a voting/quorum system between all the KS's where they all (or the majority) should come to the same conclusion. Etc. I've never made a system like this myself, but it's always been on my TODO list of things to try in Lisp once I found out about these libraries.
This guy posts good stuff to youtube. https://www.youtube.com/channel/UCMV8p6Lb-bd6UZtTc_QD4zA 
That's the best one. The first lecture converted me to the LISP guy.
Simply the best, and still relevant today. It’s a shame MIT discontinued these courses!
Thank you, this looks very nice!
You’re right. Thank you. I’ll try the suggestion in the other answer. 
Thank you
Thank you, I will try that. 
Thank you, I will try that. 
It works for me, too, thanks.
JavaScript and RamdaScript
Interesting. Does Ramda have a major mode for emacs? Or is it just lisp-mode with a side of js2? 
Those ones?: https://nikodemus.github.io/screamer/ http://lisa.sourceforge.net http://gbbopen.org I found this introduction to Screamer quite interesting, and there are a couple more articles about it on the same site: https://chriskohlhepp.wordpress.com/reasoning-systems/specification-driven-programming-in-common-lisp/
I like this one, it's a good show case of the guy developing [Potato](https://github.com/cicakhq/potato), a Slack-like software, in Common Lisp and ClojureScript. He demonstrates what he likes about the stack, pretty good. https://www.youtube.com/watch?v=bl8jQ2wRh6k
I recently bookmarked these, but had no time to actually watch them: https://www.youtube.com/channel/UCYg6qFXDE5SGT_YXhuJPU0A/videos
Ugh, the course looks pretty useless. Introduction to the language that ends on vectors and 50 minutes for \~10$? That looks bad.
RamdaScript is just a lisp-to-js. I'm making a vscode extension that should be public soon.
When I started learning lisps I wanted videos too, and unfortunately other than talks given on lisps, there aren't really a whole ton. The good news is I think because of lisps I figured out videos are a really inefficient way to learn. Find a good lisp book of your choosing, open a repl, read through and toy with the examples yourself. Best way to go by far. (Imo)
Smalltalk (Squeak)
I love this man's accent!!
Third APL - and an extra point for J when considering code golfing. 
Once again thank you for your previous answer. I am also very curious of the sb-alien:alien-funcall specific. Do you have any ideas about how to call "calloc" with it ? ... I am intensely RTFM the sbcl manual for it the cffi:pointer equivalent of (void *) is somehow obscure to me :-).
Forth! Especially on small, embedded systems, the instant feedback makes iterative development a real joy
I prefer K.
I prefer K to J and APL as well. You may want to try Klong out http://t3x.org/klong/
Yes, and alien-funcall would be: (sb-alien:alien-funcall (sb-alien:extern-alien "calloc" (function (* t) sb-alien:size-t sb-alien:size-t)) 1 2)
Read a book, it's a much more efficient way to use you time. Look at the sidebar of this page.
6pm UTC happens when this comment is 19 hours and 35 minutes old. You can find the live countdown here: https://countle.com/S206997HoB --- I'm a bot, if you want to send feedback, please comment below or send a PM.
I need to get better at announcing these sooner again :p
Thank you. I so far have collected the following. Sorry to bother you with this specific ... this should be in a TIL :-) ` ;; ********************* SAP and ALIENS ***** WHAT ABOUT CFFI *************** ;; The memory of the PC is mapped with addresses that are SB-SYS:INT-SAP ;; The following test0-alien is a alien value pointing to an alien:integer (defparameter test-alien (sb-alien:make-alien sb-alien:integer)) ;;--&gt;TEST-ALIEN test-alien ;;--&gt;#&lt;SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #XB64006D0 :TYPE (* (SB-ALIEN:SIGNED 32))&gt; (sb-alien:alien-sap test-alien) ;; #.(SB-SYS:INT-SAP #XB64006D0) test-alien ;;--&gt;#&lt;SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #XB64006D0 :TYPE (* (SB-ALIEN:SIGNED 32))&gt; (sb-alien:deref test-alien) ;;--&gt; 0 (setf (sb-alien:deref test-alien) 1001) ;;--&gt; 1001 (sb-alien:deref test-alien) ;;--&gt;1001 ;; On the side of cffi the corresponding command is as follows ;; The object we produce is however different from the previous function (sb-alien:define-alien-routine ("calloc" alien-calloc) (sb-alien:* t) (n sb-alien:size-t) (m sb-alien:size-t)) (cffi:defcfun ("calloc" calloc-cffi) :pointer (n :int) (m :int)) (cffi:defcfun ("free" free-cffi) :void (p :pointer)) (defparameter test-cffi (calloc-cffi 1 1)) test-cffi ;;--&gt; #.(SB-SYS:INT-SAP #XB6400678) (so same sort of output of alien-sap) (type-of test-cffi) ;; can we read the alien-sap of an alien with cffi:mem-ref ? (cffi:mem-ref (sb-alien:alien-sap test-alien) :int) ;;--&gt; 1001 (setf (cffi:mem-ref (sb-alien:alien-sap test-alien) :int) 2002) ;;--&gt; 2002 (sb-alien:deref test-alien) ;;--&gt; 2002 (free-cffi (sb-alien:alien-sap test-alien)) ;;--&gt; No value (sb-alien:deref test-alien) ;;--&gt; -1262484376 (non-sense) (cffi:mem-ref (sb-alien:alien-sap test-alien) :int) ;;--&gt; -1262484376 (same non-sense) `
Thank you. I so far have collected the following. Sorry to bother you with this specific ... this should be in a TIL :-) `;; ********************* SAP and ALIENS ***** WHAT ABOUT CFFI *************** ` `;; The memory of the PC is mapped with addresses that are SB-SYS:INT-SAP ` `;; The following test0-alien is a alien value pointing to an alien:integer ` `(defparameter test-alien (sb-alien:make-alien sb-alien:integer))` `;;--&gt;TEST-ALIEN ` `test-alien ` `;;--&gt;#&lt;SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #XB64006D0 :TYPE (* (SB-ALIEN:SIGNED 32))&gt;` `(sb-alien:alien-sap test-alien) ` `;; #.(SB-SYS:INT-SAP #XB64006D0) ` `test-alien ` `;;--&gt;#&lt;SB-ALIEN-INTERNALS:ALIEN-VALUE :SAP #XB64006D0 :TYPE (* (SB-ALIEN:SIGNED 32))&gt; ` `(sb-alien:deref test-alien)` `;;--&gt; 0 ` `(setf (sb-alien:deref test-alien) 1001) ` `;;--&gt; 1001 ` `(sb-alien:deref test-alien)` `;;--&gt;1001 ` `;; On the side of cffi the corresponding command is as follows ` `;; The object we produce is however different from the previous function ` `(sb-alien:define-alien-routine ("calloc" alien-calloc) (sb-alien:* t) ` ` (n sb-alien:size-t) ` ` (m sb-alien:size-t)) ` `(cffi:defcfun ("calloc" calloc-cffi) :pointer (n :int) (m :int))` `(cffi:defcfun ("free" free-cffi) :void (p :pointer))` `(defparameter test-cffi (calloc-cffi 1 1))` `test-cffi ` `;;--&gt; #.(SB-SYS:INT-SAP #XB6400678) (so same sort of output of alien-sap)` `(type-of test-cffi) ` `;; can we read the alien-sap of an alien with cffi:mem-ref ?` `(cffi:mem-ref (sb-alien:alien-sap test-alien) :int) ` `;;--&gt; 1001 ` `(setf (cffi:mem-ref (sb-alien:alien-sap test-alien) :int) 2002) ` `;;--&gt; 2002 ` `(sb-alien:deref test-alien)` `;;--&gt; 2002 ` `(free-cffi (sb-alien:alien-sap test-alien))` `;;--&gt; No value ` `(sb-alien:deref test-alien) ` `;;--&gt; -1262484376 (non-sense) ` `(cffi:mem-ref (sb-alien:alien-sap test-alien) :int) ` `;;--&gt; -1262484376 (same non-sense) `
Maybe give try CrystalLang if you haven't already.
episode starts at 10:50
Just wanna say that I love your videos and really appreciate your work for the lisp community :D
Having extensively used ClojureCLR in several Arcadia projects (Clojure &amp; Unity 3d) as well as from the REPL, I can say I have never had any of the above hypothesized problems. I have a bunch of mixed Clojure/C# projects which call back and forth without problems, and ClojureCLR’s interop with C# is actually quite good with a few small corner cases (usually caused by fundamental differences in the ClojureJVM’s assumptions). Some here may not recall that Clojure was first implemented in CLR, before going to JVM, and then again to CLR and also JS with ClojureScript. It was designed to be a hosted language. It is true that many Clojure libraries have dependencies on the JVM, but most that work on both JVM and JS are easy to translate. 
Thank you !! Couldn't attend it ... wrong time zone. I am right now studying cffi and sb-alien. I am stuck with some functions (maybe pointer of function or callback functions ?) that I should give back to a c code). It is so far interesting to see the difference between : the cffi definitions that seems to limit the declaration of :pointer type to the minimum , leaving the hard work of memory allocation to the foreign-function-calls and the sb-alien definitions of alien objects that mix first the :pointer and the :type first (as in C) to later ease the use during the calling sequence. 
Thanks! And bigger love to the folks who are really doing the hard work on the libraries and implementations we use every day.
I would advise sticking to cffi unless there is a specific need to use sb-alien (cffi is using it behind the scenes anyway). I'm not following the issue though, sorry, could you post the signature of the function you are trying to wrap? Good point on the callbacks though, I should go through those in another video.
Yes I have realized that sb-alien is quite specific and that cffi seems to fit quite well. But it helped me understand what was expected by the C code. I have found the solution to my little problem and will send you the result a little bit later if you don't mind. Thank you again for your nice videos ... all of them !!
Excellent episode, a lot of useful information for someone starting with CFFI. One interesting thing you can do with CFFI is to load [assembly code and run it](https://stackoverflow.com/a/18941269/4500302), which could be useful, of course it would be completely dependent on your processor type, but I think it is a nice trick.
wow, thats really interesting. Do you need to be concerned about alignment or marking the memory executable?
Great to hear, and thankyou for the comments.
Sorry for the delay , here is what I have found. The C code is about two instantiation functions that need a specific allocation function that is provided by the calling environment. C code : `// type of the calloc function passed to the structure` `// or directly by the environment` `typedef void* (*caalme) (size_t, size_t);` `// structure passed to the instantiation functio` `typedef struct{` ` caalme alme;` `} cabafu;` `// passing functions in a structure definition` `int* instantiate_with_struct (cabafu* definition) {` ` int * object;` ` object = (definition-&gt;alme (1, 1));` ` *object = 42;` ` return model;` `}` `// passing the function directly (done first )` `int* instantiate_with_fun (caalme function) {` ` int * model;` ` object = function (1,1);` ` *object = 21;` ` return object;` `}` 
I have not tried this myself, but in general in assembly memory is just memory, it is segmented so the address must be in the Code Segment, but I guess the funcall takes care of that, maybe I'll do some experiments. I was researching this to do some stuff you typically do in C, without having to write anything in C.
There is no function named `FUNCTION` in Common Lisp. If anything, there is a special operator named `FUNCTION`[1]. Its purpose is to translate from Lisp data into function objects, that is, objects of class `FUNCTION`[2]. Evaluating the form `(function car)`, which is, calling this operator with a single argument that is a symbol name, returns the function object associated with that symbol in the global environment. That object is not readable and prints out as `#&lt;FUNCTION CAR&gt;` on most implementations. Evaluating the form `(function (lambda () 42))`, which is, calling this operator with a lambda form[3], returns the anonymous function object associated with that lambda form. That object is not readable and prints out as `#&lt;FUNCTION (LAMBDA ()) {1001935FDB}&gt;` on my implementation. Because the `FUNCTION` operator is used so commonly, there is a special macro created for it to be a shorthand. Instead of writing `(function car)`, you can write `#'car`, and instead of writing `(function (lambda () 42))`, you can write `#'(lambda () 42)`. A slightly different but related trick is the macro called `LAMBDA`[4], thanks to which you can also write `(lambda () 42)` - it expands right into `#'(lambda () 42)`. * [1] http://clhs.lisp.se/Body/s_fn.htm * [2] http://clhs.lisp.se/Body/t_fn.htm * [3] http://clhs.lisp.se/Body/s_lambda.htm * [4] http://clhs.lisp.se/Body/m_lambda.htm
Comman Lisp is a Lisp-II. This means that functions and values do not share the same scope. It is hence possible to have a function and a variable of the same name. cl&gt; (defun f (x) x) cl&gt; (defvar f 5) cl&gt; (+ f 1) 6 cl&gt; (f (+ 2 2)) 4 You see if we use f as a function it uses the defun definition and if we use f as a variable we get the associated value of 5. But what if we want to use the f function as a value to be passed to a higher order function? Well then we have to use the FUNCTION macro to explicitly mark that. cl&gt; (mapcar f '(1 2 3)) Error: f is 5 and not the function f cl&gt; (mapcar (function f) '(1 2 3)) (1 2 3) cl&gt; (mapcar #'f '(1 2 3)) ;; sharpquote sugar (1 2 3)
Ohhh.... OK. Thank you for the explanation!!
&gt; Evaluating the form (function car), which is, calling this operator with a single argument that is a symbol name, returns the function object associated with that symbol in the global environment. Wrong. It return the function from the *lexical environment*, which is something `symbol-function` and `fdefinition` cannot do. (defun foo ()) (flet ((foo ())) (values (function foo) (fdefinition 'foo))) ; =&gt; #&lt;FUNCTION (FLET FOO)&gt; #&lt;FUNCTION FOO&gt;
Thanks for the correction! I edited the original post.
Do you know why #' was picked btw ? I've been reading lisp for ages but just right now it feels like bad ergonomics to have 2 characters for something so often used.
I've been digging into ocaml myself. I like static typing.
Aside the quoting stuff ('`,) all reader macros in common use start with a sharp. For example the standard #' (kinda "quoting" a function) or the non-standard #I infix reader macro.
aight thanks
Still wrong: it looks up lexically and falls back on the global environment if the function isn't found there.
[Factor](http://factorcode.org/) - unfortunately the community around factor seems to stall...
Also worth noting that if you're just going to FUNCALL the object, you can pass a symbol, and passing symbols can be more reload friendly. ``` cl&gt; (defvar x 'f) cl&gt; (funcall x 5) 5 ```
That only works if f is global.
# is kind of the default character for syntax extensions (#p pathnames, #c complex numbers, #* bit vectors, #( vectors/arrays, #\ character, ...) http://www.lispworks.com/documentation/lw51/CLHS/Body/02_dh.htm 
can someone explain what it refers to ? 
http://www.lispworks.com/documentation/lw70/CLHS/Body/f_upda_1.htm
yeah I read the doc but what it is exactly ? It looks like a relatively low level CLOS function, what makes it special enough to put on a shirt ?
Does any other OO language explicitly allow old objects to be updated to match a changed class definition? CLOS has had that for ... 20+ years?
but what makes it interesting? clever? why should I want to wear this shirt?
This title is terrible. You should really consider deleting this submission and making a new one with a better title.
Please consider using named-readtables. It's pretty easy to use and makes managing custom readtables much nicer for the maintainer and user.
oh I got it. Indeed when you think about it it's pretty amazing
If you see this message a lot, it means you are using CLOS for one of its design goals - dynamic mid-flight updating of data models. You can define a bunch of classes and create a bunch of objects in those classes. You can then say, "crap - class X needs a new slot Y", go edit the definition of class X adding that slot, and evaluate that class definition. Doing this does **NOT** break all the objects of type X in your current image. When you next touch any X object, CLOS will notice it and update it to match the new class definition, printing the T-shirt message as it does so. It's like Lisp macros - you may not *need* them that often, but when you do they're invaluable.
Smalltalk 
I second that. It allows reader macros to be composed and customized.
Look at the work of this guy https://github.com/fukamachi 
Hmm, it seems like Clack is the most popular?
Compaed to the python world, Clack is probably closest to uwsgi in its place in the stack; that is to say lower level than flask and considerably lower level than rails or django. Roughly speaking ningle is at the level of flask and caveman at the level of django. I've not used either though. If I were to pick up a web framework today I would likely start with [radiance], as the other tools I've used that the author has written are solid, and it looks to be at least somehat documented. [radiance]: https://shirakumo.github.io/radiance/
I needed to look up several of those projects. Hope you don't mind that I've linkified your comment. &gt; Compaed to the python world, [Clack](https://github.com/fukamachi/clack) is probably closest to [uwsgi](https://github.com/unbit/uwsgi) in its place in the stack; that is to say lower level than [flask](https://github.com/pallets/flask) and considerably lower level than rails or django. &gt; &gt; Roughly speaking [ningle](https://github.com/fukamachi/ningle) is at the level of flask and caveman at the level of [django](https://github.com/fukamachi/caveman). I've not used either though. If I were to pick up a web framework today I would likely start with [radiance](https://shirakumo.github.io/radiance/), as the other tools I've used that the author has written are solid, and it looks to be at least somehat documented. 
In my experience, Radiance was the best fit because it offered out of the box a lot of the facilities I was looking for, and that I was hand-rolling on my own when I was using other servers. (Namely modules each containing their own routes, which I could map onto full URLs, as well as some admin/db/etc interfaces that are shared by all modules). BTW Radiance runs on top of other web servers (Hunchentoot, Wookie or woo, if I remember), so it's more of a framework than a server. It's extensively documented and yet I feel like there's something missing in between their tutorial and actually building something. I was considering a write-up of my experience with it at some point. It takes a bit of getting used to but I found it answered all my needs, and that one time it didn't, the author was quick to fix it (less than a day, in fact).
IMO you can't be wrong with Hunchentoot. Some notes on the state of web development, discussing libraries and other areas (how to deploy, etc): - https://github.com/LispCookbook/cl-cookbook/issues/105 - https://stackoverflow.com/questions/1275547/how-can-i-do-web-programming-with-lisp-or-scheme/42838145 - https://lisp-journey.gitlab.io/web-dev/ I quickly tried Caveman and found it frustrating (trivial things are tedious), and had a good little experience with [Snooze](https://github.com/joaotavora/snooze) (by the author of Sly, Yasnippet and all). I still dream of writing a dynamic web app in a good environment, without javascript, and it's becoming true with the ongoing work on [Weblocks](http://40ants.com/weblocks/quickstart.html) (a new quickstart with widgets upcoming). I have a couple web apps working, but that's still very alpha. Anyway, it's a joy to write web apps in CL, so much more than in Python. 
I'd love to see a write-up! The tutorial I wrote was mostly a documentation of my thoughts and process writing an app, but I can definitely see how that might not explain things entirely for new people. I don't really know how others have a go at this kind of thing.
Noted, well I guess I’ll have to get started on it sooner rather than later. Besides I need to do it before the inevitable memory loss that comes a few months after not looking at a codebase...
Haskell. Clojure. Modern C# is pretty decent for OO languages. Rails/Ruby for quick proofs of concept. Python for BI/Analytics. Learning Rust and Julia at some point. 
Yeah, that's the canonical answer to "who else does OO right?" Smalltalk would have to do that, since the running image **IS** the world.
Caveman2 is miles above and beyond Radiance. I speak after having tried both.
Can you explain why?
If you quickly read the readme of both projects, you'll see why: https://github.com/fukamachi/caveman caveman fits my idea of what a web framework should be a lot more than radiance does.
What the fresh hell are you talking about "closed-in"? It only adds a few libraries to the standard Quicklisp distribution, and all of them can also be gotten through manual clones if so desired.
Probably he meant that Radiance is more opinionated than the Caveman. 
You have your own quicklisp dist. Your programs are all built with your own libraries on top of each other. It is very clearly a "Shinmera system". Caveman advertises much more flexibility, is available on quicklisp without a new dist, among a slew of other things. It feels to me that Fukamachi is operating as part of a greater lisp eco-system whereas you are just in your own world. There is nothing wrong with that, it just isn't for me.
This is more or less what I meant, yes
6pm UTC happens when this comment is 20 hours and 8 minutes old. You can find the live countdown here: https://countle.com/-qy210450Q --- I'm a bot, if you want to send feedback, please comment below or send a PM.
good bot
What's the story with the [State of the Common Lisp Ecosystem, 2015](http://borretti.me/article/common-lisp-sotu-2015) link in the side bar? It starts out with a section on web development. I wonder what the state is 3 years later. Maybe the we should delete the link in the side bar if it is outdated?
In this case, Radiance is very close to the Rails and Django. 
mmh seems a bit harsh to me. A clear advantage I see in distributing one own's dist is to be the master of the libraries' state, to ensure they are working together, and to be able to upgrade them without upgrading the whole Quicklisp dist. This seems nice for the end user.
You're not forced or required to use any of my other libraries besides Radiance to use Radiance though. How is that a lock-in in any way? Radiance was specifically designed to be a structural framework into which anything could be plugged into. That's about as anti-lock-in as possible. The sole reason Radiance is in its own dist instead of Quicklisp is because it has a startup behaviour that, without other setup, causes the debugger to open. This makes it not possible to include in the standard QL dist because of Xach's build requirements. If it were not for that, and believe you me I have debated this a long time, there would not be any extra dist. Your claims about Radiance being a "lock in" could just as easily be made about Caveman, which makes heavy use of a lot of Fukamachi's software. In fact if you look at Caveman's dependencies, they're almost exclusively Fukamachi's own stuff.
I don't understand that. How is a framework that makes less choices for you more opinionated?
Do you have a staring order/instructions ? Like just grab cepl from qicklisp and start with the second playlist? 
Yes, that should be a good start.
I did Perl5 for a long time and found it quite beautiful in some ways. Perl6 has a number of those characteristics as well, and more of them.
Hey! Common Lisper here. &gt; A stable, active, healthy, (large?) community `#lisp` on Freenode, also a Lisp Discord server. &gt; smooth (linux) tooling for web, server, mobile-native What exactly do you mean by tooling? AFAIK Common Lisp is not strong on the mobile platforms, though there has been some successful work to port Embeddable Common Lisp + Qt5 to Android. &gt; single-source, multiple targets (for the targets above) If I understand you correctly, Common Lisp can provide you with that. The whole fact that standard code works on all conforming implementations, no matter if it's SBCL, CCL, ECL on weird CPU architectures or OSes or ABCL on JVM, is a pretty big feat of CL. &gt; figwheel-like interactivity D'oh. Lisps are where the interactivity actually started. (: Common Lisp is a very good example of that - you write your program incrementally, function by funciton. &gt; immutable data In Common Lisp at least, data is mutable because the programmer should be able to mutate it if he considers it a good choice and also not to mutate it if he considers it a good choice. Hence, simply don't use mutating operators, and your data is now considered immutable. &gt; non-JVM A lot of Common Lisp and Scheme implementations are **not** based on the JVM. &gt; static types Lisps are usually dynamic, but [Carp](https://github.com/carp-lang/Carp) is an exception. Additionally, you can write statically typed chunks of code in Common Lisp - you simply add type declarations everywhere possible and let your compiler deduce the rest.
Take a look at: https://github.com/rongarret/BWFP It's the beginning of a textbook I was writing a while back. It's far from complete, but it does have step-by-step instructions for how to get an interactive CL-based web development environment up and running.
Hi, converted Common Lisper here. &gt; A stable, active, healthy, (large?) community CL is very stable, and that's a relief. As a consequence libraries are stable. Browsing around, you might find strange that a given library wasn't updated in three years, doesn't have bug reports and has less than 100 commits. But that library may be one of the most downloaded of Quicklisp, and just works. The package management system is stable and sane too. It seems strange at first that Quicklisp gets updated once a month. Thinking about it as Debian's apt rather than npm helps seeing the point. We don't upgrade *one* library, but a system, that was built against a given set of libraries to check if they work together. I'm only thinking of a Haskell package manager that does that. It's also straightforward to work with another version of a library if needed, and there are more tools. I find the community healthy, active and large. I like (and like to advertise) the [Awesome-cl](https://github.com/CodyReichert/awesome-cl) list and the [Cookbook](https://lispcookbook.github.io/cl-cookbook/). They should help a newcomer. Don't miss [Quickdocs](http://quickdocs.org/) too. &gt; smooth (linux) tooling for web, server, mobile-native Discussion on libraries for the web: https://www.reddit.com/r/lisp/comments/8s5q7x/what_common_lisp_web_library_should_i_use/ We didn't mention CL to JS compilers. But if you dream of building a dynamic webapp in a good Lisp environment, without JS, go check the ongoing work on Weblocks :) &gt; figwheel-like interactivity So if you're talking about interactivity when building a webapp, Weblocks might be somewhere there. When I refresh the page after a code change, I don't loose my data. We're in a running Lisp image after all. Also some notes on [skewer and trident-mode for emacs](https://lisp-journey.gitlab.io/blog/is-there-something-like-figwheel-for-common-lisp/), that may be building blocks towards figwheel. &gt; non-JVM no JVM, and possibly no npm (unlike clojure[script]). &gt; static types CL is dynamic, but does a lot more type inference that other popular dynamic languages. It either catches errors, or prints warnings. Continuously compiling functions (it's a `C-c C-c` away) and trying out code quickly is also a bug catcher. CLOS's method dispatch helps too. --- Vim experience is said to be good. You have choice of database libraries (clsql for you ?).
Here is some feedback on your reply; I appreciate your time =) 1. By tooling I mean something like those tools that help take care of non-programming tasks (like leiningen for clojure, npm/yarn for node, psql for postgres, etc.) 2. Cool. I'm currently checking out mocl for CL on mobile. Looks promising. 3. The "conforming implementations" statement is helpful, thanks. 4. The "don't use mutating operators" is the Right mindset; thanks for illuminating. 5. Ok, I'll think on the static typing thing. It's not essential, but is a consideration for me. Thanks!
Thanks!
You bet. If you decide to use this and need help with anything please don't hesitate to ask. Also, comments and suggestions are much appreciated.
Just to add my piece, if you’re coming from vim I’d definitely check out spacemacs. It basically configures everything for you and most vanilla vim bindings and a lot of simpler ex commands just work, and you can very easily enable support for tons of emacs packages through the configuration layers system. As a side note, apart from your dislike of the JVM what’s you’re issue with ClojureScript being too attached to Clojure?
For immutable data, you can look at [FSet](https://github.com/slburson/fset).
With respect to Racket: * A stable, active, healthy, (large?) community * Maybe one useful metric for how active and large a community is can be judged based on how large their package ecosystem is. You can take a look at Racket's [package ecosystem](https://pkgs.racket-lang.org/) and maybe see if what you think you may need is covered. * smooth (linux) tooling for web, server, mobile-native * I have not attempted to do web development in Racket. However, it seems to be supported and [documented](https://docs.racket-lang.org/continue/index.html). With regards to mobile native, I think Racket at least [supports Android](https://www.infoq.com/news/2016/10/racket-67-android-apps)? I have not tried to use it. * single-source, multiple targets (for the targets above) * At least for the development I have done (console and GUI programming for desktops), Racket has this covered. Same source and is able to run on Linux, MacOS, and Windows with no need to reconfigure anything * figwheel-like interactivity * Racket has a REPL that will let you interact with running programs. From my understanding, it is not as nice as Common Lisp's. * immutable data * Immutability is largely the default for Racket data structures. * non-JVM * Check, although I personally love the JVM and am baffled why that's an issue. * static types * There's an entire language called typed/racket that offers static typing
LambdaNative would be the only thing to meet them all perhaps.
1. Slime is a very good and powerful tool that allows you to interactively edit, debug and inspect your Lisp image. It is an emacs plugin. 2. Oh right - mocl is also doing well on the mobile market. It is a proprietary tool.
There are also libraries that provide persistent vectors and hash maps. For static typing typed racket is your best bet.
Honestly, I find that if you have fairly strong typing in a language (and Common Lisp is pretty strongly typed), I tend not to find static typing a big deal. Something to think about.
It's not used that often. If you know the name of the function to call it, you just call it `(f arg1 arg2 ...)`. You can funcall lambdas without #': `(funcall (lambda (x) (+ x 1)) 2)` You can funcall global-scope functions with just ': `(funcall '+ 1 2)`. So #' is only really useful for local scope named functions. And how often do you really use those?
I started with Emacs Lisp because it’s so easy to get started with. Good debuggers, repl, docs, all you need integrated and right out of the box in Emacs. It’s easy to evaluate stuff as you type too. But ClojureScript and PicoLisp are great too, and why not give Racket go?
Common Lisp or possibly Racket. Any time you are plugging together existing components you'll have dependencies, but using asdf/quicklisp these are pretty transparent. I'd worry more about anti-dependencies (you cannot use systems FOO and BAR at the time time because they step on each other in some global namespace), of which there are occasionally some in quicklisp.
In addition to adding type declarations, you can get something like argument types by using generic functions. The methods for these automatically come with argument type specifiers (sort of). (defgeneric foo (x y)) (defmethod foo ((x integer) (y symbol)) ;; body of method here ) 
Also interesting to watch: http://shenlanguage.org/ - optional lazy evaluation - static type checking based on sequent calculus, one of the most powerful systems for typing in functional programming - optional type checking - pattern matching - built-in prolog - runs under CLisp, SBCL, Clojure, Scheme, Ruby, Python, the JVM, Haskell and Javascript - reported to [run on Android](https://chatolab.wordpress.com/2017/12/26/shen-programming-language-for-android/).
Thanks!
Practical Common Lisp is really good, and Paradigms of AI Programming is deep and dense and good stuff.
There is a sister subreddit called r/learnlisp But [Practical Common Lisp](http://www.gigamonkeys.com/book/) is the go to for first timers
This is the third post in a row that suggest Practical Common Lisp. Really, it's a **very** good book. As for an environment, [Portacle](https://portacle.github.io/).
when you get to writing scripts: from what I have heard, you will want to check out [cl-launch](https://www.cliki.net/CL-Launch) and/or [roswell](https://github.com/roswell/roswell). Sorry to say I haven't used much of either of these, but but Roswell seems similar to how Ruby or Python work, so it might make you feel more at home.
I recommend to not miss the [CL Cookbook](https://lispcookbook.github.io/cl-cookbook/), but it doesn't really teach the basics. It's more on getting started (setting up an environment, knowing the package manager), and recipes. Very nice video series: [little bits of lisp](https://lispcookbook.github.io/cl-cookbook/). And more: https://github.com/CodyReichert/awesome-cl#learning-and-tutorials
If you want something like a scripting language, [Newlisp](http://www.newlisp.org/) seems pretty good, though it is its own lisp dialect, not a Scheme or a Common Lisp implementation. If you want a Scheme, [Guile](https://www.gnu.org/software/guile/) may be one to look into, since I believe it's meant for scripting as well. And Racket is probably good for scripting-type stuff too, I would imagine. Common Lisp seems better suited for longer-running programs rather than what scripts are typically used for, but it is possible to compile a Lisp program as a binary, I believe, in which case it should start up and run much faster. But I don't have any experience doing that myself yet, so I can't say much about it.
I've read three books, all very good. [Land of Lisp](https://nostarch.com/lisp.htm) is a well-written and engaging introduction to the language and concepts via writing games. [Practical Common Lisp](http://www.gigamonkeys.com/book/) is an excellent technical reference, it's my go-to when I need a refresher on `loop` and `format`, plus the practical exercises are actually practical. The macro section is also very good. [Paradigms of AI Programming](https://www.amazon.com/Paradigms-Artificial-Intelligence-Programming-Studies/dp/1558601910) gets into all the sorts of things you can do by manipulating symbols, which could have some carry-over into your Ruby work. Among other things.
LispWorks has the KnowledgeWorks inference engine with prolog compatibility, and [the docs are pretty good](http://www.lispworks.com/products/knowledgeworks.html).
I doubt many people are actually doing that. I see approximately zero reasons to use prolog from within lisp (or prolog at all, for that matter). 
You can read the relevant chapters in [Paradigms of Artificial Intelligence Programming](https://github.com/norvig/paip-lisp).
I think SICStus Prolog has a major investment into constraint programming, so that'd be a reason (if you were curious)
Hmm... thanks. I think I have typically thought of *static* typing as a type-safety mechanism, but hadn't really gotten clarity about the type-safety implications of strongly typed vs statically typed. I think you might be right about what that means for my interests here; thanks.
Huh, that's helpful. Thanks =)
Are you saying CL is the JVM of yesteryear?
&gt;it is possible to compile a Lisp program as a binary, I believe, in which case it should start up and run much faster. For anyone looking to produce binaries or production Lisp applications, I recommend [Common Lisp in the Wild](https://www.darkchestnut.com/book-common-lisp-application-deployment/).
CL would be sort of the opposite end from scripting imho. Something that compiles directly to a small binary, for scripts that are self contained, would chose something like Gerbil [https://cons.io](https://cons.io), or Racket [https://racket-lang.org](https://racket-lang.org)
[The Reasoned Schemer](https://mitpress.mit.edu/books/reasoned-schemer)
Wow, I've been fairly surprised at the number of people advocating for Common Lisp. Honestly, I hadn't looked closely at it for reasons I don't clearly understand (some kind of bias I can't identify). Its turned out to be a dark horse that I'm now seriously considering. Thanks for the feedback and especially for the resource links!
If you like Clojure already but you want something for scripting, give ClojureScript a try. [Planck](http://planck-repl.org) on Linux or macOS will give you an instant start-up ClojureScript repl, run scripts, etc.
The only thing holding Clojure back for scripting is the startup time. But you say &gt; Ruby is just much simpler and readable and suitable for this case. Simpler? I don't think so. Readable? You'll get used to it, and Common Lisp is not much different. Suitable? Yeah, the startup time is bad. &gt; I heard that CL is more "general-purpose" so I will be able to completely replace ruby with it (except my work of course, hehe). Clojure is general-purpose too.
I was talking in context of scripting. If lisp was any simple for scripting, perl wouldnt be popular and ruby wouldnt even be born. "General-purpose" inside quotes. Feel it?:)
&gt; I was talking in context of scripting. If lisp was any simple for scripting, perl wouldnt be popular and ruby wouldnt even be born. I don't understand what you mean. If Clojure had quick startup time, I would use it for everything. The code is almost always shorter than Python. I don't see what he problem is (except the startup time). And by the way the fact that Perl and Ruby exists does not mean that there is anything wrong with Lisp. Most people don't like Lisp. 
Let's just take a silly example. Problem: write a `tac` utility that does the same thing as `cat` but each line should be reversed. What is your solution with clojure? here's my ruby one: #!/usr/bin/env ruby $&lt;.each_line { |s| puts s.chomp.reverse } Or even without script at all: `ruby -nle 'puts $_.reverse'`
Thanks! I will look into it
Thanks! This is interesting
Thanks! I will check this out:)
It's a pretty common misconception IMO, especially given how most statically typed languages tend to be fairly strongly typed anyways, because it then often makes no sense to have looser strength rules when your variables are typed. Here's how I like to think of it: type discipline has two axises - static vs dynamic and weak vs strong As far as I've ever seen, static vs dynamic boils down to 'do storage locations (variables) care about the type of their value?'. If the answer is yes, then you have static typing, otherwise you have dynamic typing. Type strength isn't really a binary, and is more of a spectrum of how willing the language is to automatically convert between types for you. The extreme end of the scale gets us languages like PHP and JavaScript, that have some type coercion rules that make no reasonable sense in *any* context. Some languages, like Lua, have only few type coercion rules, and they are reasonable and don't do crazy things. Strings that can be read as numbers (`"12345"`) and proper numeric types are for the most part interchangable in Lua, but it's still an error to try and do things like add booleans together or to concatenate functions and strings together. Then you have things along the spectrum of Common Lisp, where all type conversions must be done explicitly. This helps me make sense of things, at any rate. Hope this helps.
Yea...it's going to be a little more verbose in Common Lisp (for example, SBCL implementation): echo -e 'hello\nworld' | sbcl --noinform --eval "(loop for line = (read-line *standard-input* nil 'eof) until (eq 'eof line) do (format t \"~a~%\" (reverse line)))" --non-interactive Common Lisp shines as an iteratively worked on language in a REPL (you make some changes, test them out per function call, compile them into your running image etc.).
&gt;For scripts you will catch yourself having to write a lot of stuff like this, just to exit. Anything that needs to talk to Posix/Unix/Linux/OS world is going to be the same way The amount of FUD (Fear, Uncertainty and Doubt) in this post is appaling. We have a lot of compatibility libraries to completely avoid having to type a different line for each implenentation. And for a script, you don't need any magic to exit the script, just call your implementation executable with the "-script" option (or similar), which is present on CCL, SBCL, CLISP... you name it. 
Note my above comment.
you just have to go download additional software. Having to use external libraries to achieve portability is the exact smell I'm pointing out. More layers for a script. How many bash scripts do you write that need a non-system package manager to make it portable?
This isn't bash, this is a fully fledged programming language. &gt;you just have to go download additional software. Having to use external libraries to achieve portability is the exact smell I'm pointing out. The libraries are downloaded automaticallty simply by mentioning them in the .asdf file that describes your system. Or, just by adding one (1, una, eine, uno) line to your code. Which will automaticallty download it compile it, and load it. More FUD... 
And where is the ASDF maintainer going?
[removed]
&gt;And where is the ASDF maintainer going? What is the point of this question? ASDF has years of non-stop evolution. What is your point, anyways? You like Racket or Scheme? Fine, i think Scheme is great. But don't try to "support" them by oosting baseless claims about Common Lisp. 
I provided example code. And I've yet to hear you say how it is incorrect or fun. Recommending ASDF, and using --script instead of #! highlight the issues I'm pointing out. How fast is your hello world? How big is it? The reason to bring up the ASDF maintainer they laid out the problem with trying to use CL for these very issues. They seem to be in a position to decide that more than you or I. Again, where is this example code is there fabrication?
Answering to your deleted post: &gt;I provided example code. And I've yet to hear you say how it is incorrect or fun. You don't understand my reply. **No one** would do it as in your "code* , since there are already libs that take care of the differences, presenting a uniform interface. &gt;Recommending ASDF, and 99% of the people who use Common Lisp nowadays use ASDF. &gt;using --script instead of #! highlight the issues what issue? Is using a simple command-line option an isssue? &gt;The reason to bring up the ASDF maintainer they laid out the problem with trying to use CL for these very issues. They seem to be in a position to decide that more than you or I. Pointless. 
&gt;n fact if you look at Caveman's dependencies, they're almost exclusively Fukamachi's own stuff. ... which are among the least documented and commented libraries on the CL world (sorry Eitaro, I adnire you and Clack/Lack is a great project, but I do suffer with this problem.)
We have a lot of libs. If you just want to use a web server directly, take a look at Clack and Lack which provide an API over some Lisp web servers. If you want frameworks, take a look at: Caveman2 from Eitaro Radiance from Shinmera Lucerne from Fernando Borreti (eudoxia0) Reblocks (rewrite of weblocks) Uncommon Web (UCW) These last two are continuation-based. IIRC there's nothing like that outside the Lisp/Scheme world.. If you want a bare-bones framework take a look at Ningle from Eitaro. I have added a tiny bit of functions to Ningle to make it easier to use, you can find it under the name of "Ninglex". 
Wow. I really like Racket's focus on creating new languages. That really, really appeals to me. I'm going to have to consider this very strongly. Thanks!
Thanks-- I have heard of spacemacs before; I'll look into it. Re: ClojureScript &amp; Clojure; first, a wall of text to serve as disclaimer and to undermine my issues with it. I actually think Clojure is pretty neat. Most of my lisp experience is through it. I like Rich Hickey and I've met a number of the Cognitect people in their offices. They all seem like great people, I have no objections to any of them, lots of positive vibes and what not. Most importantly, I haven't thought through my reservations enough to have \*clarity\*, so it's likely I've got unreasonable biases, because all my mind stuff is mediate through my meat stuff. That said ... A lot of the Clojure people I know (who, I say sincerely, are all nice people, etc.) like Clojure in the way that people seem to me to like Star Wars and Apple and a few other things in that vein. Something like, "their enthusiasm for it seems (to me) to be a bit disproportionate to the quality of the thing." It's less obvious to me with Clojure; it may actually be just that fantastic. But they seem to have some of the same mannerisms as the people who like those other things (sometimes called "fanboys"). I don't object to them being super enthusiastic about, say, Star Wars, it's just not a great fit for my personality, or maybe my time of life or something. Like I said, maybe the people who seem to be behaving this way towards Clojure are having an enthusiasm for it that is *proportional* to its exceeding quality, but that's not obvious to me yet. So what's my objection? I find that that kind of thing has some dangers that I've been bitten by before. Getting invested in a project and the project ending up going in a weird, idiomatic direction and everyone being sort of *wildly* supportive of it and then a train wreck ensues. I'm not saying I think that's happening with Clojure (at all!), but I could mitigate that risk with ClojureScript if it is an independent project. I think this perception may have been created (or exacerbated?) by my early exposure to Clojure-- that the tooling community was a little weird and there seemed to be some tension between leiningen and ... someone? the Clojure community? or something. It (maybe incorrectly) felt to me like a "The Ruby Way" or "The Python Way" sort of mindset and I prefer the TIMTOWTDI mindset. That's the main thing aside from my general dislike of the "heaviness" of the JVM (to my perception). In conclusion, I like Clojure; I like Cognitect; I like Clojure people. I have no objections to them, but would be encouraged about the "openness" of the clojure ecosystem if there was a good relationship between clojure and clojurescript *and* they are projects with independent direction/leadership. P.S. More disclaimers to say I'm not saying anything strong or even negative about Clojure =) Lots of language to make sure this is all couched as my (perhaps faulty) perception at some intuitive level.
Thanks; I started the tutorial (I need to pick up some lingo to move through it further), and it looks interesting and helpful! The [FSet/CL link](https://common-lisp.net/project/fset/Site/FSet-CL.html) was helpful too.
Wow, that really *is* a good read. I'm going to have to go through it again and do some ancillary research. The CL/Racket/Gerbil is well articulated. Thanks.
Hmm... the portability of it is interesting. I'll investigate it at an aesthetic level as well. Thanks =)
Those two seem very well esteemed, it appears. Thanks!
Fyi, [Lumo](https://github.com/anmonteiro/lumo) is gaining traction in clojure land, particularly for scripting, lightweight, quick start use cases.
Yeah, thanks. I understand that double-dichotomy (strong/weak ; static/dynamic). I've never really used an IDE (in 35 years of programming); I've used vim ever since I upgraded to it from pico. But I'm considering emacs as a part of my planned migration, and it seems like the ability to do some "compile-time" checking of stuff will be more readily available in that route. But you're right that I was needlessly correlating that capability with *static* typing rather than seeing that it can be accomplished with *strong* typing as well.
Lumo cli [example 1]( http://benzaporzan.me/blog/2018/3/26/lumo_brightening_the_horizons_for_clojurescripting/) [example 2](https://itnext.io/command-line-scripting-with-clojurescript-5e5567367713) 
Tooling wise, I think CL has a good ecosystem. I think quicklisp is great (comparable to dependency management like lein), there's asdf for projects / builds, and lots of libraries for deployment (cl launch). If you're dying for static typing, typed racket exists (different ecosystem than CL, although I would be surprised if a similar idea didn't exist in CL somewhere). Shen takes that idea even further. Based on the bulk of your criteria, [lumo](https://github.com/anmonteiro/lumo) may be viable, particularly if you're interested in leveraging npm ecosystem. Cljs is developed hand in hand with clojure (cognitect stewards both). Vast preponderance of clojure code is portable (across jvm, is, clr .net implementations), so you can leverage many generic clojure libs for cljs and vice versa. Recent inroads have been made to make interop with js stuff easier (direct npm dependencies, integrating webpack). 
There are a bunch of Prolog implementations and the commercial Lisps Allegro CL and LispWorks both offer one. Originally Prolog was added to Lisp for two main reasons: so called Expert System shells often included logical reasoning and often based on Prolog. It got combined with Frames, Rules, ... and other paradigms. The other reason was to use Prolog in Natural Langauge Programming , especially in parsers and reasoners for that. Newer reasons were to have it as a component in the semantic web for query and reasoning. Franz also has it to be used with their graph database.
is not about Prolog...
For Prolog itself there were some applications mentioned here: https://stackoverflow.com/questions/130097/real-world-prolog-usage
The Land of Lisp is a great beginners guide to Common Lisp, most of it should transfer pretty well to Closure. It teaches the basics and a little beyond by teaching you how to program games. It starts with a simple Guess the Number game and moves into more complicated games, the main one being a Text Adventure. http://landoflisp.com/
Hi! Yeah, this is looking actually good
Hey! Thanks! I am glad to hear this. Maybe you can provide some small snippet for us to see it in action? Very curious.
Weblocks' reblocks ditched continuations for now, they may be included back later on. Do you know if UCW is still used and maintained ? Its homepage is… old, every documentation link is dead or "out of date".
That link doesn't work. Well, if you have Prolog then you surely can find ways to use it. But if you have a particular problem I doubt the decision would be "I'll learn Prolog, it'll be easier to solve and the resulting solution will be faster and more robust". Maybe if you are augmenting Assembly or C, but we're talking about Common Lisp here.
Among people writing parsers for natural langauge applications, many preferred to write those in Prolog, compared to Common Lisp. See for example the NLP component of IBM Watson for a prominent usage of Prolog.
Is the rest of Watson written in Common Lisp?
Watson has no Common Lisp components, AFAIK. 
So it's just "people who know and like prolog write in prolog".
or is it Prolog is better for some NLP parser/grammar applications than Lisp, so people use that instead?
I think people use Java instead.
Here not, the rest of Watson is written in Java.
There is (WAM_cl)[https://github.com/TeamSPoon/wam_common_lisp] in case you are interested.
What examples do you want ? There's material here: https://lispcookbook.github.io/cl-cookbook/scripting.html
when you want to try: https://lispcookbook.github.io/cl-cookbook/scripting.html#building-a-self-contained-executable it isn't difficult :)
They are not necessary, we can build an executable binary without them ([tutorial](https://lispcookbook.github.io/cl-cookbook/scripting.html#building-a-self-contained-executable)). 
(just to say that cl-launch and roswell are not necessary bits, we can build a binary without them)
These two will get you quite far, second is written with explicit goal of supplementing PCL. http://www.gigamonkeys.com/book/ commonly known as PCL. http://weitz.de/cl-recipes/ Good CL programming style and general programming mastery: https://www.amazon.com/Paradigms-Artificial-Intelligence-Programming-Studies/dp/1558601910 usually referred to as PAIP If you like OO, I would definitely check out: https://www.amazon.com/Object-Oriented-Programming-COMMON-LISP-Programmers/dp/0201175894
If you have serious interest in how cross-implementation stuff is done, look at any of popular compatibility libraries, f.e. https://github.com/sionescu/bordeaux-threads If you want problem-&gt;solution kind of examples check out Common Lisp Recipes.
PicoLisp has buildin PiLog as part of engine. https://software-lab.de/doc/tut.html#pilog
https://github.com/guicho271828/cl-prolog2 is an lisp-implementation-independent, and also prolog-implementation-independent library for using Prolog from lisp. 
Just a possibility, perhaps you could use Screamer to implement an inference engine without doing a lot of the low-level drudge? Or read PAIP as suggested. Hell, read PAIP in any case. There's also CL-UNIFICATION you could perhaps use.
Or in [On Lisp](http://www.paulgraham.com/onlisp.html)
Prolog can be used as query language for graph databases. All going alternatives kind of suck, so it would make a lot of sense to use it rather than, say, Cypher or Gremlin. There actually is one graph database written in Common Lisp: AllegroGraph, and it offers Prolog as a query language.
Who was the commenter?
the name started with "bit" 
CL is more lightweight than Clojure? Why do you think that?
Racket's good for a beginner, and it comes with a much friendlier development environment than the default for CL.
$30 for an 80 page pamphlet doesn't sound like great value for money. And that's not even printed.
&gt; Clojure is general-purpose too. Depends on the sense. General-purpose in the sense of the type of programmes you can write with it, yes. General-purpose in the sense that it supports multiple programming paradigms, which CL does, then no Clojure is highly-opinionated and definately not multi-paradigm.
Hey, waspishly\_simple, just a quick heads-up: **definately** is actually spelled **definitely**. You can remember it by **-ite- not –ate-**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
delete
\*shrug\* Just to be clear, it's not my book. Don't disagree with you, though, and IIRC, it was cheaper than that when I originally bought it.
redefined class: Unlike, say C++ or Java, in Common Lisp you can change the definition for a class in a running system. update instance: And have an exisiting instance be updated to conform to the new definition. And you can define code to make the conversion work they way you want it to. If you've experience of using pretty much any other class or type system this is miraculous.
Still: the problems you solve with kanren are the same problems that prologue shines at, even though prolog is more general. If the AI book doesn't click for you, maybe the reasoned schemer will.
Weblocks is a web framework, created circa 2007, that allows to write dynamic web applications in full Lisp, without a line of Javascript. It is based on so called widgets, that are rendered server-side and updated on the client, and it was also based on continuations (they were removed in this branch, at least for now). It was quietly being forgotten but it is being fixed, refactored, documented and simplified by /u/svetlyak40wt since a year or so. The old Weblocks website: https://common-lisp.net/project/cl-weblocks/ 
Other isomorphic web frameworks I know are Haskell's [Haste](https://haste-lang.org/docs/), Nim's [Karax](https://github.com/pragmagic/karax), Ocaml's [Heliom](http://ocsigen.org/eliom/), Python's [Nagare](http://www.nagare.org/), of course Smalltalk's [Seaside](http://seaside.st/) and [a couple more](https://github.com/vindarel/awesome-no-js-web-frameworks).
It's also not 'general purpose' in the sense that the main implementations are hosted - one always needs the basics of Java and JavaScript - which even influences basics of the language implementation. Thus its a blend of a hosting implementation and some kind of language on top.
Thank you for the links. I wasn't aware of Nagare.
&gt; more verbose in Common Lisp a small library of things like iterating over files and streams will make it shorter...
By the way, if somebody wants to try this tutorial and don't want to manually setup all dependencies, he/she may eval this in the REPL: (ql-dist:install-dist "http://dist.ultralisp.org/")
I know of Weblocks since its inception, although never tried. I wonder what is lost while disabling continuations, in respect to features and fiunctionality?
I did that, and then did ``` (ql:quickload '(:weblocks :weblocks-ui :find-port)) ``` per the first line of the tutorial. I eventually got an error ``` System "weblocks/app" not found [Condition of type QUICKLISP-CLIENT:SYSTEM-NOT-FOUND] ``` Am I doing something wrong? Also, going to that link and searching around I couldn't find the (Github?) dev page where I should report this. Going from http://40ants.com/weblocks/contributing.html to https://trac.common-lisp.net/cl-weblocks/wiki/WeblocksDevelopment I ended up in https://github.com/skypher/weblocks, which seems to be the old repository. Other than that, the tutorial "sounds" really good. Have you considered changing the name of the project to avoid confusion with the old Weblocks? 
What does (ql:where-is-system :weblocks) shows?
Only core functionality was keeped in the weblocks system. Now core of the Weblocks supports building websites from the widgets. Working with databases, ready for use libraries of widgets (like datagrids, forms, etc), multistep wizards based on continuations should be implemented as separate systems, because there are many databases or frontend frameworks (Bootstrap, Foundation, etc) you want to use.
Thank you.
How is this nicer than the sexpression itself?
Looking at the [code](https://gitlab.com/joolean/gzochi), I'd guess the project is autotools based. So you'll need to run autogen.sh first. Then you can run configure as that should be created by autogen.sh and **then** you can run make to build it.
This could be an interesting didactical tool to show that “code is data” and how cons cells works.
``` CL-USER&gt; (ql:where-is-system :weblocks) #P"/home/capitaomorte/quicklisp/dists/ultralisp/software/40ants-weblocks-20180623225048/" ``` Can we do this on weblocks issue tracker maybe (if there is one)? 
For CL and text representation: https://github.com/cbaggers/draw-cons-tree
Here it is: https://github.com/40ants/weblocks/
This is the representation used for cons cells in SICP, actually.
Yes, I know it. But This one draws them automatically:)
It's not "nicer", it's just a way to visualize expressions.
Very neat! I wish more tools existed like this for other data-structured languages.
As a personal preference, I also find Lisp expressions to be a visually concise denotation of nested lists.
Here's something similar I made a while back: https://bagnalla.github.io/sexp-trees/ It's web based and interactive (try mousing over a node or click-dragging the image) but doesn't support single quote characters like in the OP's example.
 (ql:quickload "consix") (consix:game) Visualizes conses of a degenerate form :)
Don't see to know about cons cells.
I just downloaded gzochi and there ***is*** a configure file. So I just did the usual configure/make sequence and it compiled ok. It will ask you for a couple of libraries which you should install beforehand. BTW it wanted a SDL library. I had SDL2 installed but it was no good, it wanted SDL1. I didn't test yet, though. It seems to work only with GNU guile, which is a Scheme variant. I have seen no references to other language interfaces in the manual. I'm a linux user. I have no idea about how to compile and run this on a Mac :-( Tom
&gt; Have you considered changing the name of the project to avoid confusion with the old Weblocks? To answer readers: &gt; I've talked to the last maintainer of the Weblocks and he blessed my refactoring and wishes that somebody take over the project maintaining. I hope someday my branch reblocks will become a major version of the Weblocks. https://github.com/40ants/weblocks/issues/15#issuecomment-400375686
6pm UTC happens when this comment is 19 hours and 5 minutes old. You can find the live countdown here: https://countle.com/knCY213893 --- I'm a bot, if you want to send feedback, please comment below or send a PM.
I think a good mindset is to try and be the best programmer there ever was. Which means using appropriate tools for each job. Python is chosen as a beginner language in numerous universities, and the webdev scene is humongous. So expect to have a smooth sailing and a million stackoverflow posts for the tiniest problems. People using lisps are either romantic or have learned some kind of lisp in an academic environment. So expect a lot of edges to be the opposite of smooth, as these people have no problem dealing with them.
I understand. I would at least use it on Emacs, though.
Working with lists and trees, of data and code.
* In Lisps the difference between data and code is blurred, which is different from other languages such as Python * Less syntax rules * Lower barrier to write simpler programs, eg. no `System.out.println` just to print something to the screen
Thank you for doing these!
A month? Try the first few chapters of SICP: https://sarabander.github.io/sicp/
If you're already comfortable with Emacs you will have no problems with any Lisp.
I'm surprised no-one else had said this. For a beginner it's consistency (and a simple syntax).
I found templating using [CL-WHO](https://edicl.github.io/cl-who/) a great experience. I wanted a similar tool in Python before I learnt Lisp, and being able to intertwine (Lisp) code and HTML was a dream come true. Before that, I used jinja2 which required you put `{% blocks %}` in your HTML which meant I had to learn that specific language, which was quite ugly. CL-WHO even compiles the HTML generation to Lisp, making it incredibly fast. Here's a quick example of a HTML/CL-WHO macro: (defmacro card (title &amp;body body) `(htm ;; Flip the macro expander back into HTML "mode". (:div :class "card" ;; In this specific context, .card creates a "card" on screen. (:h3 (esc title)) ;; Put the escaped string `title` in a &lt;h3&gt;. ,@body))) ;; Splice the rest of the card in.
The code-as-data experience makes a real difference. This enables Lisp interpreters, Lisp compilers, macros for incremental code generation, interactive programming, ...
I don't really understand Emacs, I'm just going through the motions trying to configure this beast with a lot of help from reddit, IRC, Github etc!
~210$ full price to modern money, not that expensive actually!
That's something you only realize once you understand it, I guess? Before I started working with scheme for a uni project I'd make jokes about the parens, and thought it to be horrible. Pretty stupid opinion in hindsight of course. But I may not be the only idiot out there, so I think that the syntax is more of a hindrance at first. Once you know one typical language you only have to learn the specifics and in case of python it's very, very easy (or it was to me and I am still an idiot). I'd advise learning a lisp, since that helps a lot with problem solving. Or at best, I'd do both
Ouch. Well if you want to use it to work with Common Lisp then download Portacle, which is Emacs pre-configured for CL.
I meant no disrespect, I really like Emacs. It does make sense, but it takes a while for it to make sense :P
I don’t think the Coco counted as a TRS-80. The TRS-80 was a Z-80 based machine whereas the Coco was an entirely new computer that was built around the 6809.
Oh I agree with you. "I had a problem: I want to learn Common Lisp. They told me I have to learn Emacs. So now I have two problems." There are four options: 1. Invest lots of time in Emacs and become a maestro. 2. Invest the minimum you need to work with CL, my approach. 3. Learn Racket instead, it comes with a beginner friendly environment. 4. Use Clojure instead, and use IntelliJ with a Clojure add-in.
Allegro Prolog is included in the free downloadable "Express" version of Allegro CL. The thing a Prolog engine brings to a procedural language like Lisp is not a database. It would be silly to use Prolog to write a program that has a zillion rules associating employees with their phone numbers -- real databases do that better. Rather, good Prolog programming style is definitional programming. Prolog rules often have the intention that a frob is a this and that, and execution of the program proceeds by searching through a tree of possible matches until it finds a complete solution. For example, a mathematical system might define a rule for identifying and parsing quadratic equations as: (&lt;-- (quadratic $equation ?x ?a ?b ?c) (= $equation (= (+ (* ?a (^ ?x 2)) (* ?b ?x) ?c) 0))) The elegance of this rule (ignoring the obvious requirements of canonical ordering of the equation) is that it can be invoked and succeed with variousof the 5 variables bound, or partially bound, and variables still unbound or themselves having unbound components can be unified later in the search, with the relational requirement propagated backwards. This rule (here unfamiliarly expressed in prefix) is definitional, that a quadratic equation is this thing with these parts satisfying these relations, much more compactly and readably expressed than a pile of nested if-then-else procedural mashup. 
What do you use Common Lisp for?
Did you try [spinneret](https://github.com/ruricolist/spinneret/) ? It has a few more features (can transform markdown, warns on malformed html, automatic headers,…) and it was "less akward" but I don't remember why :p
mmh I'd say the image-based, REPL-based experience. When I discovered the ipython repl I was hooked, and a Lisp repl is way superior (specially in Common Lisp). You can write a function, compile it (that's right, compile one function, with `C-c C-c` in Emacs&amp;Slime), have a feedback (a warning, or a debugger that pops up), and then try it in the REPL. Whereas in Python, you first need more tooling (flycheckers etc), you must have a way to run your code (a main function if it isn't a script), add a breakpoint if you want to stop in the middle of your program, and re-run it when you change the code. When an error occurs in Python, search for it manually, or improve your tooling (compilation mode in Emacs,…). In Slime, press `v` in the debugger and you get dropped on the line. It's faster and less boring to develop in Lisp :)
May I answer ? I used it successfully to build a command line and readline app to search for torrents on popular trackers: [cl-torrents](https://github.com/vindarel/cl-torrents). Doing the same for database-based programs, and learning web frameworks. ps: don't miss the [Cookbook](https://lispcookbook.github.io/cl-cookbook/) :)
For commercial development no. But most people interested in a LISP on a CoCo would be hobbyists just interested in learning what LISP is. We really live in a great time today where most development tools are open source and even most documentation is freely available.
This is a large part of why I came to love Lisp. The consistency (especially of Scheme) helps my brain spend less time worrying about syntax and more time with whatever problem I'm trying to solve. Once I grokked it, it suddenly felt comfortable in a way other languages don't, even when I wasn't as familiar with the language itself. People talk about the parens disappearing. This has been my experience as well, but not until I used an editor that helps handle them and proper indentation.
True, just saying "TRS-80" makes you think of the Models I/II/III/IV that were (at least partially) compatible with each other. But to be fair, Radio Shack themselves called their CoCo the "TRS-80 Color Computer", their programmable calculators were "TRS-80 Pocket Computers", and their early notebook computer was the "TRS-80 Model 100" even though all of these were their own systems incompatible with each other and the Models I-IV.
Paired with [Parenscript](https://common-lisp.net/project/parenscript/) and [cl-css](https://github.com/Inaimathi/cl-css) you don't have to leave Lisp to write full, interactive webpages. It's all the convenience of PHP's approach, without having to change syntax or deal with PHP. Anyone who's bought into MVC tends to have alarm bells go off in their head at this, but this is just another design pattern. I find it much more comfortable to have all related code for things grouped into functions together, rather than scattered across several files.
Oh, for fun. I either take some interesting piece of code, for example Norvig's Othello AI programme and translate it into Clojure. Or I might just try out some cool "trick". Or occassionally I write a program to scratch an itch, at the moment it's an app to manage risks in a way that isn't bat-shit insane. I started professionally as a programmer (asm, c, c++, java) but I haven't done any in 20 years (professionally) but I consider it an important skill to maintain and I enjoy it. Been hobby programming since the days of the Commodore Pet.
Well, back in the day it was also much easier to copy disks and share them with friends. So, two people (or more) could've, hypothetically split the cost. The problem is finding friends who also want to build programs in lisp. Anyone know what the implementation language would've been for this?
Did it ever ship? Back then, I was anxiously waiting for some TRS-80 Color Computer software (I think it was an OS and assembler) that never shipped.
Were you a Scheme beginner or a programming beginner? I'm guessing that this question is about programming beginners.
Not available thru Radio Shack. Now there is a shocker! 
I think you're right, but without adding any information, people that don't already know a lisp aren't going to understand or appreciate that. When you already know a language you tend to ignore all the complexities and oddities of its syntax, either because you're accustomed to them or you've learned habits that hide some of the weirdness, but for a beginner that stuff is all front-and-centre, and it's a distraction from learning *programming concepts*. Instead of learning fundamentals, other languages force you to to focus on things like operator precedence, strange equality rules, boilerplate (Java), indentation (Python), etc. Crap that we shouldn't have to focus on, and that a beginner doesn't care about. It all gets in the way of what's important: programming as a form of problem solving. A lisp, on the other hand, has very little of this stuff to learn. Anybody that has learned basic arithmetic should understand the use of parentheses for grouping and nesting. If the beginner has any algebra exposure, functions and variables are already mostly covered as well, though even if not, they're easy enough concepts to teach. The biggest hurdle is explaining that you use `(f x)` instead of `f(x)` for consistency. I think it also helps that lisps have some of the best interactive, REPL-driven programming available. The instant feedback and easy experimentation is a beautiful thing when you're new and just want to see something happen. Mainstream languages have been improving here, but still don't compare. These things are why I usually recommend Racket and *How to Design Programs* for beginners. The DrRacket environment makes setup nonexistent for beginners: a basic IDE, integrated REPL, a good batteries-included library bundle, instant feedback in the REPL and good feedback in the editor side. Combine that with HtDP, which teaches programming principles instead of language oddities, and you have what I think is a great beginner environment for someone with little or no programming exposure. Instead of learning how to use a specific language, you learn things that you can use in any language you pick up later. 
I had a TRS-80 CoCo when I was a kid, I think my grandfather got it cheap when the local Radio Shack was clearing out some old stock to make way for newer versions. Anyway, the two things I still remember strongly about it: 1) the keyboard was awful, and 2) It had some form of BASIC on its ROM, listed as version 1.0, and I will remember my hatred of it forever. It wasn't any particular issue with the language itself, really, it was hate for the line editor, which was awful. I forget if it was a lack of backspace or no way to move the cursor, but I remember that any time I made a mistake anywhere in the line, I had to start over, re-typing the entire thing. It was super frustrating and took away a lot of my desire to experiment with the language. Later on I got access to a Commodore 128, which had line editing, and it made a huge difference; I was on that thing constantly making terrible spaghetti-code programs and enjoying every moment of it. Anyway, point is, I wonder if this lisp had a better editing environment? If so, it might have been really appealing to me as a kid if it did. I wanted to learn and do so much with that computer but it felt like it was fighting me at every turn. 
&gt; What do you use Common Lisp for? I use it for critical extract-verify-transform-load of financial data. 
&gt; I don't really understand Emacs, I'm just going through the motions trying to configure this beast with a lot of help from reddit, IRC and Github people! If you download Portacle, you don't need to configure anything, just use Emacs. And you only need to know the bare minimum of key combinations, only cut (Control-W), paste (control Y), copy (alt W). Also, know that "Meta" is no other than the "Alt" key. "Alt- w" combination would be spelled "M-w" in emacs slang. Then you need to know the difference between an emacs "buffer" and an emacs "window". It is really simple. As for using Common Lisp under Portacle, the most useful key combinations would be Control-X Control-K ("C-x C-k"), for compiling the current file, and "C-c C-c", for compiling the function under cursor. The rest you can learn in simple Emacs tutorial. It took me some hours to get used to.
&gt;I'm starting as an undergrad in Web Development in a month, and I was wondering on how to spend my time until then. I already use Emacs, so Lisp is an obvious choice. But I looked into other options, especially Python. So I must ask: what specialty of Lisp differentiates it from other languages, especially from a beginner point of view? (defparameter *lisp* common-lisp) ; please assume Common Lisp when reading "Lisp" here. You asked "what makes it easier for a beginner to learn", and I'd say that Lisp isn't particularly easier than other languages to learn, mainly because it is also massively more powerful than many other languages. Now, it does have some important pluses for easier learning: - *Everything* is an expression. The grammar doesn't depend of a context (except for when using the LOOP macro). - The syntax is exemplary uniform. - It is thoroughly documented (see the Common Lisp Hyperspec) - There are many well-written tutorials and books - It is a truly interactive system, you can add compiled functions to the "live" system on the go, and thus build your system as you write it. - The thing "just works" without having to know and install a plethora of tools. Perhaps the only tools you'll need to know are Quicklisp and ASDF -- both of which already come installed in Portacle and in some Lisp distributions. And they are a piece of cake to use. &gt;what specialty of Lisp differentiates it from other languages, especially from a beginner point of view? Lisp source code is also data, thus Lisp code can easily manipulate lisp code at runtime, compile time, or even read time. This makes metaprogramming trivial, instead of a cumbersome operation (as in other languages that do support metaprogramming). Having easy/trivial metaprogramming opens a lot of new doors. Many of the "functions" in Lisp's "standard library" are actually macros. In other words, many operations in the Lisp language are built on metaprogramming, and thus, also using metaprogramming, you can extend the language in many directions. Thus, this allows you to produce concise and/or maintanable source code, since you can adapt the programming language to your needs. 
There was a an implementation for Commodore64 called ComLisp. I played with it a little, it was OK for experimenting with the language. 
&gt; ike Clojure in the way that people seem to me to like Star Wars and Apple and a few other things in that vein. Something like, "their enthusiasm for it seems (to me) to be a bit disproportionate to the quality of the thing." You have seen the light. Well done.
(s)he's already coding in emacs, so I assumed some experience. 
No lisp code is public yet, sorry. You may know me from the "Comfy lisp coding" video I posted here once. :) [http://dailyprog.org/\~kenster/](http://dailyprog.org/~kenster/) Please donate (CC or paypal): [https://streamlabs.com/kingherring](https://streamlabs.com/kingherring) TinyCDN github: [https://github.com/kennymalac/tinycdn](https://github.com/kennymalac/tinycdn)
im blanking on the name, but theres a style of programming thats driven.by specifications. If you dont find another solution you could try that.
For folks already hardwired to use windows/mac/xwindows CUA copy/cut/paste shortcuts, there's a [cua-mode](https://www.emacswiki.org/emacs/CuaMode) in emacs that makes adoption even easier. It feels more like messing in a text editor, less like retraining to use foreign mnemonic shortcuts. Everything else can be learned through accretion, on an as-needed basis IME.
For folks already hardwired to use windows/mac/xwindows CUA copy/cut/paste shortcuts, there's a [cua-mode](https://www.emacswiki.org/emacs/CuaMode) in emacs that makes adoption even easier. It feels more like messing in a text editor, less like retraining to use foreign mnemonic shortcuts. Everything else can be learned through accretion, on an as-needed basis IME.
Our computer teacher would copy LogoWriter for us if we brought in a floppy disk to her. I don't think that implementation of Logo had macros ([Berkeley Logo](https://people.eecs.berkeley.edu/~bh/logo.html) does, btw) so it wasn't a full-fledged Lisp\* but it did have all the usual list processing primitives. I used it to write a simple adventure game on my C=64. \* In the sense of being a member of the Lisp family, like Dylan. Obviously syntactically they're very different.
Thankyou for watching :)
For the first few hours the episode will be at https://youtu.be/Zv_0U5kVIf8?t=9m34s
Thank you very much. I get along fine with the Emacs/Evil way of editing text. The problem is making it work precisely the way I want it to :)
First time seeing all your content. Mind summarizing what this is about?
Okay I tried writing this macro for a couple hours after the stream and I still haven't gotten it right. Anyone have any advice? I just want to be able to do something like (upload-session-ccall self "new" ...args). Obviously I know I'm doing something terribly wrong! haha. [https://paste2.org/OPWBxKHH](https://paste2.org/OPWBxKHH) I can't apply a list of arguments to foreign-funcall because it's a macro. I want to have (upload-session-ccall self "new") translate into (foreign-funcall "FileUploadingSession\_new")
I'm trying to write a tiny content delivery network, like Amazon S3. I plan to have it be more "user facing" so a user can upload public and private content, etc. Instead of it being User -&gt; App -&gt; App's CDN bucket I want it to be User -&gt; App -&gt; User's Bucket.
The music and the light effects ... let's party !!! :-) thank you
Tyvm for the links.
Screamer: https://nikodemus.github.io/screamer/ https://chriskohlhepp.wordpress.com/reasoning-systems/specification-driven-programming-in-common-lisp/
hypothetically
I don't yet have time to watch your back catalogue but it looks intriguing. Can you also briefly discuss the interplay between lisp and c++17?
Thanks!
I don't blame you, there is a lot of backlog. I suggest just scrobbling through the videos if you want to catch up, lol. The interplay is pretty simple, I want to keep "session state". In principle: the user requests an upload session, and then the lisp code grants them. The begin uploading, and the lisp code saves the file chunks to /tmp. (side note: Wookie's with-chunking macro is really nice). Then afterwards, it will tell the C++ code that the file is on /tmp, and the C++ code moves it from /tmp into the internal storage system (which saves certain meta data, such as simple string tags and so on). The idea is later on instead of storing to /tmp, the lisp code will pipe it to a networking layer, which pipes it into a "storage node's" /tmp, etc.
Ah so no ffi involved. Sounds neat? Yes I will have to check out your videos!
I happened to have the problem recently and after some tinkering managed to produce statically linked executables with SBCL. I'm posting my solution here in case others have the same issue. The trick is to compile SBCL with the following flags: sh make.sh --prefix=SOMEWHERE --fancy --with-sb-linkable-runtime --with-sb-dynamic-core Afterwards, ASDF's :static-program-op should work just fine. For more elaborate use cases (like choosing a particular compiler and linker) you can check how I did things in [cl-mpi](https://github.com/marcoheisig/cl-mpi).
For anyone still interested in this there is a part 3 I'm doing today [https://youtu.be/-JWVx-W0rmA](https://youtu.be/-JWVx-W0rmA) or [https://www.twitch.tv/kingherring](https://www.twitch.tv/kingherring)
Could someone elaborate on this? &gt; enhancement: SB-COVER instrumentation for x86[-64] has signficantly less overhead. The performance penalty for 64-bit code has been measured at around 30% slower than uninstrumented code as contrasted with slowdowns in excess of 100% previously. 
Elaborate on what part?
Can someone elaborate on the macOS fixes, what was the issue and how it was solved? I'm assuming these bugs are relevant: https://github.com/lispgames/cl-sdl2/issues/105 https://github.com/borodust/trivial-gamekit/issues/24 stassats commented on the first bug report: (let ((pthread (sb-sys:int-sap (sb-thread::thread-os-thread sb- thread:*current-thread*)))) (setf (sb-sys:sap-ref-lispobj pthread #xb0) sb-vm:*control-stack-end* (sb-sys:sap-ref-lispobj pthread (+ #xb0 8)) (- sb-vm:*control-stack-end* sb-vm:*control-stack-start*))) it's not clear what the issue is just from this? macOS expects certain values to be present in a thread's stack?
https://github.com/sbcl/sbcl/commit/baf58692075ef273e9363663550dcdbb53d67a4a
I’m pretty new to Lisp, recently I installed SBCL and seems that Windows is second class citizen. Is there any explanation for this? Should I Maybe choose some other compiler?
Because nobody uses Windows as their primary system, and because its API is distinct from Unix, and because of some questionable design choices of some past windows porters. But it should still suit your needs.
SB-COVER is a builtin coverage facility. You can compile code with coverage enabled, and it records which parts are executed. You could, for example, run a test suite, then check whether any of your code wasn't exercise by the test suite. There's a portable coverage package called COVER (written decades ago by Waters) that provides the same thing in a somewhat different way.
Thanks, sounds neat!
10am PDT happens when this comment is 16 hours and 47 minutes old. You can find the live countdown here: https://countle.com/kub215504j --- I'm a bot, if you want to send feedback, please comment below or send a PM.
Alternatively: [https://www.twitch.tv/events/Yh7I84GuTSKRNZ6oKg1g3Q](https://www.twitch.tv/events/Yh7I84GuTSKRNZ6oKg1g3Q)
You should consider changing your OS. Windows It is second class citizen, SBCL just makes it explicitly.
Changing OS just to try new language? No way :)
You are that bound to Windows... I'm sorry. :)
I have never worked with autotools before, so that was new for me - thank you! However, running ./autogen.sh gives the following output: ``` Generating top-level build files. Generating build files for libgzochi-common helper library. Generating build files for gzochid. Generating build files for libgzochi-glib reference client library. Generating build files for gzochi Guile reference client library. Generating build files for AberMUD example game. Generating build files for AberMUD example game client. glibtoolize: putting macros in AC_CONFIG_MACRO_DIRS, 'm4'. glibtoolize: error: linking '/usr/local/Cellar/libtool/2.4.6_1/share/aclocal/libtool.m4' to 'm4/' failed glibtoolize: error: linking '/usr/local/Cellar/libtool/2.4.6_1/share/aclocal/ltoptions.m4' to 'm4/' failed glibtoolize: error: linking '/usr/local/Cellar/libtool/2.4.6_1/share/aclocal/ltsugar.m4' to 'm4/' failed glibtoolize: error: linking '/usr/local/Cellar/libtool/2.4.6_1/share/aclocal/ltversion.m4' to 'm4/' failed glibtoolize: error: linking '/usr/local/Cellar/libtool/2.4.6_1/share/aclocal/lt~obsolete.m4' to 'm4/' failed ```
Nah, in reality it’s the only multi purpose OS. I know it has flaws and is far from perfect but it’s great for both my hobbies and work, which isn’t the case for OS X and Linux. I really don’t get why people treat such choices in religious categories and feel “sorry”. No one forced me :D 
Thank you! I tried compiling again and got the following error: &gt;./configure: line 12000: syntax error near unexpected token `2.2' &gt;./configure: line 12000: `GUILE_PKG(2.2 2.0)' &gt;configure: error: ./configure failed for gzochi-server do you see this on linux?
Is the first episode available anywhere? 
Historically, SBCL forked from CMUCL in 1999. CMUCL to this day is principally a unix/linux/bsd only implementation. I usually use CCL on windows and osx but principally program with SBCL on linux.
Yes, watching isn't absolutely required but you'll get a better idea of what I'm doing. :) [https://www.youtube.com/watch?v=TylgU3tUSE8](https://www.youtube.com/watch?v=TylgU3tUSE8)
CCP stands for Clozure Common Lisp? Thanks for hint :)
I use a VM with ubuntu for trying new things. Linux makes installing things very easy since most packages have found their way into the package manager :)
Unless you really need a video course, you should read Practical Common Lisp for a good introduction. 
*it’s the only multi purpose OS* sounds religious as well. I use linux for both hobby and work, and it has worked fine for me. Depends on what your hobbies or work are I guess. I only use windows for games, so if you hobby is *gaming* then I agree. However all three major OSes have their use, and depending on what work you do, one will be better suited than the other.
My hobby *is* gaming. And for that, Windows is the only platform.
*"Programming languages have data structures such as vectors, arrays, lists, integers, etc; and can manipulate them. Scripting languages have a lot of functions and features to manipulate text including `eval`/`exec`. And scripting programs themselves are Text. Thus, Scripts have a lot of functions and features to manipulate programs. Thus, writing script programs that manipulate script programs is trivial. "* 
Can you just wake up?
What were those questionable design choices?
safepoints in particular. Which aren't inherently bad, but they weren't fully baked and had a lot of race conditions. Which isn't inherently bad either, but the original authors who know what's going on have disappeared.
I would be forever grateful if this podcast were on castbox. 
Everybody reading their blog.
Fair point.
Source code: https://github.com/reddit-archive/reddit1.0 On their transition from Lisp to Python: https://redditblog.com/2005/12/05/on-lisp/
but we can't whine with wine :-)
Re-added because of a HN discussion at https://news.ycombinator.com/item?id=17439171
Keyword here is "drivers".
sure that drivers and wine are not a good match :-)
Their site says they are 'the best way to listen to spoken audio'. Im not sure it makes sense to put it on there as without video these streams wouldnt make any sense, especially given the amount of time it's just me confused poking at things and looking at what happens. I wonder if youtube can give an rss feed of the playlist, then more podcast clients would work with it.
updated code base for SBCL and some doc: https://github.com/tamurashingo/reddit1.0/
I have no understanding for the top comment. I have yet to find a project that uses macros in such a way that I don't understand the source. Coming from scheme, the most complex CL macro I have seen is still the loop macro...
Cool, I was looking for something just like this!
You may look at CL-PPCRE, OPTIMA and TRIVIA for examples of actually complex macro facilities.
PCRE is a DSL in every language known to man, so that doesn't really count considering the critique, and pattern matchers aren't really that complex,and are arguably also DSLs in all languages. :) The things I found the hardest to grook just eyeing through optimas source were the 35-line long loop statements :) Pattern matching and regular expressions are so common, even in CL, that I wouldn't consider them a problem of the kind the comment author describes.
I think it's safe to say that they didn't know what they were doing re: Common Lisp. It should be obvious to anyone that reads the code. The reason they went with CL is probably PG rather than experience and familiarity with the language. 
I think it's safe to say that they didn't know what they were doing re: Common Lisp. It should be obvious to anyone that reads the code. The reason they went with CL is probably PG rather than previous experience and familiarity with the language. 
filthy casual
PG?
Paul Graham
On the other hand, back then people actually could live from selling software tools. Nowadays they will get lucky if they manage some enterprise shops to pay for them.
I'm primarily a Windows user, and have been using SBCL for some time, admittedly only on small projects as I learn the language and figure out how to do things. I'm into indie game dev and graphics where Windows is probably the least troublesome and most economic platform. I haven't had any problems with SBCL apart from a couple of things: * Graphics and GUI programs are a pain because they need to be forced to run on the main thread. I'd like to understand this issue better (I'm trying to write some bindings to the [BGFX](https://github.com/bkaradzic/bgfx) graphics library and have moved to CCL for now, which doesn't seem to have this problem.) * 3rd party libraries that use the CFFI groveller are a pain because this requires a whole GCC/MSYS toolchain which doesn't exist as standard on Windows. In getting some Lisp libraries to work I spend a lot of time wrestling with C build tools which is something I came to Lisp to avoid :) - of course this is a general Lisp on Windows issue, not SBCL specific. A lot of my day-to-day lisp projects are small python-esque utilities for web scraping, looking after a database etc. which all run with no problems. Eventually I want to work on some games and graphics tools.
Hey there! I'm the author of gzochi. Thanks for trying it out; sorry you're having trouble. gzochi depends on Guile 2.x and a few other things - see the README files in the distribution. The easiest way to install those things on a Mac is probably to use Homebrew: [https://brew.sh/](https://brew.sh/) Once you've got Homebrew installed, you should be able to run: brew install guile ...then you can try doing ./configure make make install again. Send me a private message if you're still stuck after doing that or if you've got more questions.
Hi! Thank you for your work on gzochi. * You forgot to list `sudo ./autogen.sh` as the first step. I would have never guessed that by myself. * I get the following error on running `make` &gt; Making all in client &gt; Making all in src &gt; CCLD abermud &gt; ld: library not found for -lgzochi-glib &gt; clang: error: linker command failed with exit code 1 (use -v to see invocation) &gt; make[2]: *** [abermud] Error 1 &gt; make[1]: *** [all-recursive] Error 1 &gt; make: *** [all-recursive] Error 1
Recursion. You could say the same about most languages that use linked lists pervasively. It's just really natural to eat a list with a recursive function and it helped me really *get it*, where previously (my prior experience having been a not-very-good Java class in high school) I had only a sort of tenuous grasp.
That is quiet true. It is very discouraing to be presentend with a rule, only to learn later it has 18 exceptions.
Now that’s a quality, valuable assessment. Thanks!
Anyone that call himself a lipser or schemer and doesn't use macros is a poser.
You might want to check a rough overview yourself: http://www.lispworks.com/products/features.html
thank you :)
I don't use either but I have looked several times (hundreds of pounds for a crippled hobbyist license is a bit shit). The reasons I would pay, but not that much and not for crippleware are: the IDE (although it is a bit clunky), a supported x-platform CLIM, stable libraries. But none of those are worth the price to me as a hobbyist. If my living depended on it I might pay.
&gt; crippled hobbyist license The HobbyistDV license isn't particular crippled. The license forbids commercial deployment. &gt; a supported x-platform CLIM In real life CLIM is long gone and outdated. Use a newer toolkit for actual stuff. &gt; JetBrain's IDEA Which has no support for Common Lisp and isn't written in Common Lisp, which kind defeats is purpose as a Lisp IDE. Niche tools (see the commercial Lisps, Smalltalks, Mathematica, etc.) are in a small market and are usually expensive. The next best (and in many ways a good) choice is SLIME/GNU Emacs + SBCL or CCL (with a basic IDE on a Mac). 
Substantially worse performance and lack of features that matter (Lispworks and Allegro got native threads years after SBCL) .
SLIME/Emacs is not "the next best, or as good", it's substantially better. The Lispworks IDE is a joke compared to Emacs. 
The Allegro hobby licence is crippled in that it has a heap limit that is very easy to go over. Completely turned me off. The integrated awesome object database seems very cool, but fundamentally I dont understand the market they are trying to serve that this point. But they seem to be profitable, so clearly there is something going on :) 
I found the Lispworks hobbyist license worth paying for, since it is a serious hobby. It’s sort of a step up from Slime/Sly, most of the payoff is in better debugging and introspection. As for the price, I think people pay far more for a guitar hobby, or for a biking or skateboarding hobby, etc)
Support. Some applications can't wait for the open source fairy to fix bugs or performance problems. I have no experience with LispWorks, but if you are a paying customer of Allegro, and you submit a complaint about anything: * your issue goes to the head of the line * you will likely receive a patch within days * the fix will be in the next release There are a few software companies whose support is worth paying for. In my experience (\~10 years ago, unfortunately), Allegro is one of them. My only connection to them is as a former customer.
Funny, I was just thinking of issues like this. Generally speaking you would expect professionally made proprietary software to be superior because they could steal from open source and add private enhancements. It might not work out that way in every case in the real world, and much open source is copyleft... A large enough open source project can have the manpower to do big things but that could be stolen too... It won't always be that easy, what if the archetecture is difficult to integrate with? And why should there even be Open Source, as we know it that is?
This doesn't answer my question.
Once I had a dream that I had perpetual LispWorks enterprise license. It was very nice dream. The documentation even came in paper books.
I'm not a big fan of a non-object-oriented, dynamically bound, non-multithreaded, byte-compiled Lisp as a base for an IDE. Emacs Lisp and the LispWorks Common Lisp are far from 'close'. The usabilty of LispWorks is quite a bit higher than GNU Emacs and the components used to develop the LispWorks IDE are actually implemented in CLOS and are nicely reusable in my own application. Generally GNU Emacs is usability nightmare. SLIME has to use it as a base and thus it's clunky. LispWorks is coming from the end 80s, where GUIs and objects were used. GNU Emacs model is based on stuff from the mid 70s - TECO, text terminals, layered language implementation, single threaded implementation, weak integration between the actual Lisp and the Editor, ...
LispWorks got native threads in 1997. SBCL didn't even exist then.
Common Lisp is pretty top-notch when it comes to error handling. Unlike most languages, including Clojure, thrown exceptions ("conditions" in lisp-terminology) do not unwind the call stack. The [handler-bind](http://clhs.lisp.se/Body/m_handle.htm) macro allows the program to recover from an error at the stack level where the error is thrown. By contrast, a static error handling system like C++, Java, or Lisp's [handler-case] (http://clhs.lisp.se/Body/m_hand_1.htm#handler-case), which unwinds the stack to the nearest try-catch clause in scope. This is particularly useful when live coding with a repl or Emacs, where a thrown condition brings up an interactive debugger that lets you fix the error and continue program execution without losing the stack frame.
If you only look at error messages check [DrRacket](https://racket-lang.org/). Otherwise, I second Common Lisp, but it cannot be implemented on JVM without a performance hit (check ANSI-compliant [ABCL](https://racket-lang.org/)).
Common Lisp has *exemplary* error handling, not just among the Lisp-family languages, but among programming languages in general. Take a look at the "conditions and restarts" chapter of the "Practical Common Lisp" book (available online for free) and judge by yourself. 
As the other commenters have mentioned, Common Lisp is probably your best bet. The Common Lisp Condition System has, as far as I can tell, the best thought out "error handling" system currently available. For a nice introduction, check out the [chapter about it in Practical Common Lisp](http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html) -- and the [Common Lisp Cookbook](https://lispcookbook.github.io/cl-cookbook/error_handling.html).
This is incorrect if by native threads one means the full monty and not a crippled implementation. From http://www.lispworks.com/documentation/lw70/LW/html/lw-145.htm: """ 19.12.1 Native threads on Windows, Mac OS X, Linux, x86/x64 Solaris and FreeBSD Each Lisp mp:process has a separate native thread and in LispWorks 6.0 and later versions these threads can run simultaneously. Note: In LispWorks 5.1 and earlier versions, you can have many runnable mp:process objects/native threads, but Lisp code can only run in one thread at a time and a lock is used to enforce this. This can limit performance on a computer with multiple CPU cores. When a foreign function is called using the FLI, the lock is released until the function returns. This allows other Lisp threads to run, for instance while waiting for a database query to execute. """ Meaning, Lispworks had a GIL for years while SBCL was blasting ahead and allowing you to take advantage of multiple processors in the same process.
This is incorrect if by native threads one means the full monty and not a crippled implementation. Since I commented on how Lispworks has worse performance than SBCL, of course I meant native threads that allow you to take advantage of multiple cores and not crippled by a GIL. From http://www.lispworks.com/documentation/lw70/LW/html/lw-145.htm: """ 19.12.1 Native threads on Windows, Mac OS X, Linux, x86/x64 Solaris and FreeBSD Each Lisp mp:process has a separate native thread and in LispWorks 6.0 and later versions these threads can run simultaneously. Note: In LispWorks 5.1 and earlier versions, you can have many runnable mp:process objects/native threads, but Lisp code can only run in one thread at a time and a lock is used to enforce this. This can limit performance on a computer with multiple CPU cores. When a foreign function is called using the FLI, the lock is released until the function returns. This allows other Lisp threads to run, for instance while waiting for a database query to execute. """ TL;DR Lispworks had a GIL for years while SBCL was blasting ahead and allowing you to take advantage of multiple processor cores via native multithreading. I edited my original post to reflect this.
&gt; with its nested syntactical consistency, must make writing a Lisp environment that meets either Elm or Hejlberg's standards nightmarishly hard. Macro writers are in a position to sabotage the error message quality. Very important to realize that as you write a macro, even if bad input will get caught by the compiler later, you have the power to make errors clearly reported or not.
It sounds like you're asking for a language with good error reporting in the standard library, not good error handling in a language. I haven't encountered a Lisp with exemplary error reporting (compared to, say, Python tracebacks or LLVM compiler messages), but the Common Lisp language has very powerful error handling. Error handling is part of the language, error reporting is part of the implementation.
I'd recommend downloading portacle, firing it up, and entering something like (nth 10 :a) Into the repl. That'll toss an error at you. The error frame that pops up is interactive, and you can dig down into previous frames, look at locals, etc., and choose an restart if you'd like. CL + slime (and the bevy of tooling portacle bundles) places CL pretty damn high on the list of "any" languages and error handling.
I suspected that you were not understanding the topic and purpose of native threads in Lisp and I'm not surprised that you know edited your post. If you were actually meant concurrent native threads, then SBCL had it mostly on Linux, with a relatively primitive implementation. SBCL never really thought out the various consequences of this and what this means for the Lisp language. Additionally the only platform which was claimed 'reliable' was Intel/Linux. Concurrent native threads is actually a quite complex issue and no implementation of Common Lisp currently has a good story for that. Mostly it was a fake issue for years, since only very specialized Lisp applications needed it and very demanding Lisp applications that ran on top of Allegro CL and LispWorks - often stuff which never ran on SBCL - were not depending on it. Allegro CL currently is the only native Common Lisp implementation which also sports a parallel GC mode, IIRC. 
http://zeniv.linux.org.uk/~ober/report.html Can you provide benchmarks showing "substantially worse"? Also, I've got threads on amd64 with both Lispworks and Allegro. Additionally the runtime characteristics for GC are night and day nicer than my experience with sbcl. ymmv
Like taking shortcuts for performance? Never had either Allegro or Lispworks segfault on me, or introduce me to the ldb prompt due to something pushing the optimizations.
"long ago..."
Allegro and Lispworks both are primarily used by many through Slime/Emacs. So you may pop that balloon. 
Now, I know comparing scheme and CL macros is a quick road to a shitfest, but this is something that scheme does right,that racket does even better: syntax-case (the low level macro facility of r6rs that allows you to break hygiene) can propagate line numbers with it's syntax objects. Implementing defmacro using syntax case (which is simple, btw), sadly strips all syntax information. 
Regarding the concerns in that article about Clojure's runtime error messages being poor, normal Lisp implementations are better. Types and preconditions are generally checked (unless you specifically `(declare (optimize (safety 0)))`). You wouldn't expect to see an OS exception due to a bug in your program. The messages tend to be useful, and as a bonus, as others have pointed out, Common Lisp error handling is really useful, there are often restarts that allow you to hack past the problem and continue. Stack traces tend to be quite useful, since you'd be seeing the state at the level of your program, not the underlying implementation (although variables may have been optimized out, of course). In the best environments (Genera, LispWorks, probably others), the objects listed in the trace can be picked up, inspected and modified. Compile-time error reporting varies more, I think. It really depends on much trouble has been spent in the compiler implementation to check and report problems in source code terms.
Some implementations also can nicely locate the source code. For example LispWorks highlights the subexpression currently executed in a function in the editor. LispWorks also has a source stepper, using its interpreter. SBCL / CMUCL particular have extensive output from the compiler for various things like type problems, optimization opportunities, etc.
&gt; weak integration between the actual Lisp and the Editor A GNU Emacs command is the very Lisp symbol naming the function that implements it. LW Emacs commands are strings, looked up in some table. Lisp just happens to be the language the thing is implemented in; could have been anything else. 
PGPG, a.k.a. Paul Graham's Parental Guidance.
Function names in Emacs are also looked up somehow. This just happens to be some other data structure - it could be anything. But I was talking between GNU Emacs / SLIME and the Common Lisp system.
All those CL answers didn't understand the original post and only read its title.
DrRacket generally has very good error reporting, generally it allows you to click through the whole call chain and all modules involved. I wouldn't call it excellent yet, though, because it sometimes hits a sort of "barrier". 
It really is a shame that that's the case... the source position is wonderful to have, but i find the syntax-case style macros just too complicated to read and write. I've looked at racket source code and it scared me.
The racket source code scares everyone :) for.rkt (the list comprehensions) is 2k lines of extremely dense code of macros outputting macros outputting macros. It gives the loop definer a lot of flexibility, but it is pretty hard to follow since it almost completely lacks comments. The loop macro is quite straightforward in comparison, but doesn't give people the same flexibility of defining their own looping constructs. A lot of things could be done to help writing hygienic defmacro style macros using syntax-(un)quote. As it is now you almost always have to explicitly deconstruct objects using pattern matching, but that shouldn't really be the case. Some things are just easier to write that way (like the famous nest macro, at least most people seem to think that). 
&gt; Generally GNU Emacs is usability nightmare. I don't think you put this into perspective. I didn't use commercial tools for CL development, so, maybe, they are as good as you say they are, but I used many different editors. And, Emacs is absolutely not the worst one I used. I also think that you are mistaken about what things matter to a code editor. So, for example, you say that ELisp isn't multi-threaded (actually, as of version 26 it sort of is, well, in the same way as Python or JavaScript or Ruby etc. are) But, what I really want to say is that not being multithreaded isn't a big problem for an editor, especially since it can start other processes asynchronously. The fact that ELisp is byte-compiled (and, you can absolutely add to it: is slow), isn't, again, a big problem. It used to be the case that editors shipped with their own tools to do the parsing, error checking etc. But, this idea didn't hold water... the way to go about it today is to run your compiler / interpreter as a server and to get all of that information from it instead of implementing it in the editor. So, the heavy-lifting isn't actually done in ELisp, and, however slow it is, it doesn't really matter. Not being object-oriented is not a vice in itself, there are a lot of good languages which aren't. Neither being object-oriented is a virtue for a similar reason. I don't like that ELisp is dynamically bound, but, I think, since Emacs 24 it's been going in the direction of lexical bindings, and, I think, eventually, dynamic bindings will either completely disappear or will be severely constrained. ---- But, you totally ignored some good parts of ELisp: it is far more popular than CL or Scheme, or both, who knows, maybe even still more popular than Clojure. It evolves. Unlike CL, which hadn't seen any major change since forever. Look, for example, at PHP and JavaScript: these languages started as a complete garbage, but they significantly improved over several iterations. Far from perfect, but the progress is substantial. ELisp is actually improving. Over the years there were multiple attempts to replace ELisp interpreter with something better, LLVM JIT, or Guile Scheme etc. Perhaps, one day, it will be something entirely different. What is good about Emacs in terms of usability is that _once you know it well_, you can be a lot more productive than someone who, says, knows Eclipse well. This is because Emacs allows thinking about things that you do in the editor in a way where a lot of that thinking is delegated to the "muscle memory", which leaves more room to thinking about the end goal. I used to do photo editing professionally for a daily newspaper. This involved processing couple dozens photographs a day, beside my other daily duties in a newspaper. Photoshop has "regular mode" and "expert mode". The expert mode removes all the menus and other visually distracting things from the screen. In this mode you rely only on your memory of hotkeys and being able to understand the picture on the screen rather than seeing the numbers which describe it. If you compare Eclipse or IDEA to Emacs, then Emacs would be this kind of expert mode. My belief is reinforced every day because, in my company, (since, obviously, I use Emacs), I solve other programmers' problems with VCS, code style, locating parts of the program etc. even though some people having those problems have been working with the company's codebase for many more years than I did. I also know for a fact, that I can rearrange / refactor the code much faster and with less errors than people using other editors even though Emacs might not always offer an automatic refactoring functionality, simply because the speed of working with text is so much greater / there are more ways to check oneself / the search is much better than any other editor.
&gt; ELisp: it is far more popular than CL or Scheme not in real life. There is much more code written in CL or Scheme than in Emacs Lisp. Emacs Lisp comes with one or two Mlines of code. There are larger code bases for other Lisp applications. Zillions of students have learned Scheme. There are 20-50 times more books on Scheme or Lisp than on Emacs Lisp. &gt; It evolves. Unlike CL, which hadn't seen any major change since forever You confuse Emacs Lisp the implementation with Common Lisp the standard definition. These are two entirely different things. Common Lisp has already evolved far beyond Emacs Lisp- from the start. Far beyond. Emacs Lisp just introduced lexical binding, which CL has since the beginning. CL implementations have evolved far beyond the Emacs Lisp implementation. Emacs Lisp is originally a language of the early 70s - a small scaled-down variant of Maclisp. It ignored everything from mid 70s onwards: lexical binding, fast compilers, better compilers, threading, object-orientation, namespaces, better argument lists, better error handling, ... basically because Stallman disliked it or thought it would not be necessary. Some stuff was added later, but much failed to get general use. At the end one had a large code base in a language which was not designed for that. Zmacs was implemented with that stuff in the end 70s - minus lexical binding. Stallman knew it, but decided to start with a much smaller Lisp and unfortunately Emacs Lisp wasn't upgraded for a long time... There were other Emacs editors written in better Lisp dialects: Multics Emacs in Maclisp, Edwin in MIT Scheme, Zmacs in ZetaLisp, Hemlock in Common Lisp, ... It's not that it is not possible, but the GNU Emacs community wasn't able to improve the language for a long time - thinking/working long time to move the implementation of Emacs Lisp to the Guile Scheme runtime, contemplating about lexical bindings and threads. Introducing those into the old code base is really hard - though all that stuff could have been added decades ago. &gt; then Emacs would be this kind of expert Just that the hotkey layout is horrible. SLIME: c-x c-e for evaluation, c-m-x for defun evaluation, c-c : for interactive eval. c-c c-c compile defun What is the logic behind that? Was it designed to generate confusion? 
https://www.xach.com/misc/lambda.html
Swiping right.
&gt; not in real life Well, look here: http://githut.info/ Scheme and CL don't even register in this table, while ELisp is even more popular than Haskell. All those students who learned Scheme in the uni... yeah, most of them only help spread FUD about Lisp, only a 0.0001% contributed anything valuable to the language / ecosystem. No, I don't confuse ELisp and CL. Those are two different languages. One evolves, another one is, unfortunately, basically dead. I really, really wish the situation was different, and CL would be the one making progress, having new releases, new features added old features removed... but this is not the case.
The github numbers say nothing. &gt; All those students who learned Scheme in the uni... yeah, most of them only help spread FUD about Lisp, only a 0.0001% contributed anything valuable to the language / ecosystem. Nobody learns Emacs Lisp in education. &gt; No, I don't confuse ELisp and CL Sure you do. You think Common Lisp is just the standard, where in real life Common Lisp is actually implementations, too. The implementations of Common Lisp have new releases. SBCL has monthly new releases. Emacs Lisp OTOH is tied to a code base written in a 70s version of Lisp. 
And those of us who were around at the beginning. (My first account predated even comments, I think.)
And I was wondering what tattoo should I have next...
Be aware that the lambda can also be a queer thing... I got it for lisp but when people ask I usually do a whole spiel about loving the classics (Greek/Latin) plus the queer thing. It's hard explaining anonymous functions to strangers in passing without their eyes glazing over. :P
should have gone for the y-combinator tattoo http://blogs.discovermagazine.com/loom/2008/02/17/y-combinator/
Wa-wa-wa-wait, hold your horses. GitHub statistics mean nothing, but you... have a better quantitative proof, as in, your personal opinion? I mean, obviously, GitHub doesn't fairly represent the overall state of programming. There's for instance a lot of COBOL code being out there, still written and maintained, which nobody thinks of open-sourcing. But... you know, you can find some other statistic to show that. You just didn't apply yourself at all to making a convincing argument. Nobody learns ELisp in university? That's right! Very few learn JavaScript too! Not to mention, say, Ruby or PHP. This doesn't prevent these languages from being far more popular than, say, Scheme, which is taught in universities. The _mechanism_ of popularity is not what you think it is. People who studied CS don't form alliances with programming languages when they study. Workplace dictates the choice. The tools you use, as a grownup dictate the choice. Unless you went to Ivy-league school, 90% of what you learned in college is total garbage anyways, something nobody pays attention to. It's purpose is what they call "signaling", it's just to tell your prospective employer you are willing to jump the hoop. Very little else. On anachronism in CS and how ELisp is outdated: that's right! No argument about that. But, Java, Python, Ruby, JavaScript, C#, C++ - all these were anachronisms even before they were born. And yet, there's very little in their way of happy development and flourishing. Think about it as Fayum portraits. Artists who drew them were the remains of a much more advanced culture, and were still much more skilled craftsmen than anyone in the area. But, they made no progress, and, unfortunately, their culture eventually died, succumbing to wars and religious fanaticism. This is while other, more primitive forms of art developed at the same time. They didn't reach the same level of craftsmanship until many centuries after Fayum was completely forgotten, and yet... ELisp is making progress. It has grounds for making progress. I'm not saying it is as good as Scheme, or CL, but if things will keep going as they do now, it, eventually, will get there, and eventually, will become better. Because it's evolving while others don't.
There are literally zillions of courses on JavaScript. &gt; ELisp is making progress. Where? &gt; Because it is evolving You keep repeating it without providing any sign of it.
Well, I thought it was kind of trivial to find out how ELisp is evolving, just read the changelog / release notes. For example this part about threads: https://github.com/emacs-mirror/emacs/blob/master/etc/NEWS.26#L233 Zillions courses on JavaScript? Not in universities there aren't. Very few and far in between. Universities typically teach Java, C as required subjects and Scheme / Prolog as electives. More modern ones replace Java with Python. Some sellouts use C# instead of Java. I've not heard of a university which had JavaScript in its required program. Maybe electives. There are zillions of so-called boot camps, MOOCs, Linda-style courses, continued education etc. Academics? Nah, they don't really like this language. Maaaaybe they'll teach it as part of web-design, but not in CS / EE and the likes.
&gt; For example this part about threads Nice, 'mostly cooperative' threads - another feature from the 70/80s. I used cooperative threads in Lisp thirty years ago. It's a bit sad that this is what you mean by 'evolving' - catching up to Lisp from 30 years ago. &gt; Not in universities there aren't. http://www.cs.unm.edu/~joel/cs105/cs105.html http://web.stanford.edu/class/cs98si/courseinfo.html The zillion other ones you might be able to find yourself. 
This threads reada more like /r/trees than /r/lisp.
Well, I do check SBCL, actually very often. But, it's not changing _the language_, it adds more vendor-specific stuff. Which is also good, but is different. Maybe, if SBCL was the only or, at least the most popular by far implementation, then they could have taken upon themselves to change the language. Right now, even though SBCL has threads, Common Lisp doesn't. Not to be mistaken, the same is true for C, for example, even though POSIX pthreads had existed since forever, and they are part and parcel of every program compiled on Linux with GCC, or CLang or ICC etc... they are not in C standard. Essentially C standard is oblivious to the fact that code may run in parallel. Very similar is the situation in CL. The language itself doesn't make progress. In C, they add things, like, `_Generic` macro, for example, or variable scoping etc. Just not the threads. In CL there wasn't anything to the best of my knowledge since the... 80s?
While there might be incompatible implementations, I think you could call bordeaux-threads a de-facto standard. Whether it is part of the specification doesn't really seem to matter: one of the nice things about Lisp is the fact you can grow the language without needing a new specification.
Elisp in Emacs Lisp is a single vendor language with a single implementation and no standard. So you try to sell us any change to the implementation as a 'language change'. Common Lisp OTOH is a standard with lots of room for interpretation and extension - while the standard covers only parts of a typical Lisp implementation: there is nothing about command line arguments, garbage collection, threads and their semantics, locks, atomic operations, networking, extended hash-tables, foreign function interfaces, timed execution, character sets, virtual machines, interfaces to C++ and Java, the Meta-Object Protocol, LOOP extensions, compiler extensions, async IO, extensions for sequences, .... To be a real Lisp implementation, the various implementations will need to provide various parts of the above, too. These things will usually have consequences for the core language. When one adds multi-threading, then one needs to look at hash-tables and how to get some atomic behavior. When we have a more advanced garbage collector which moves objects around, we need to see what to do with hash-tables, too. If we look for example at your threading example. Emacs Lisp now does 'mostly cooperative threads'. That was popular in some Lisp systems in the 80s. CMUCL had 'green threads', MCL used cooperative threads, ... Various implementations then used native threads to be able to interface to foreign function code more efficiently and multi-threaded. For example a database in Lisp could have been multi-threaded then (with only one Lisp thread at any one time), but move the IO to multi-threaded foreign function interfaces. Corman Common Lisp in the 90s was a new language implementation. I had an email conversation with Roger Corman at that time and we were talking about implementation strategies. I proposed to use native threads and concurrent execution - multiple Lisp threads running concurrently. He thought about it and integrated it into the language. So his Corman Common Lisp was the first Lisp on Windows which was fully concurrent. Mid 90s. Other Lisp followed with concurrent threads: Scieneer CL, SBCL, CCL, LispWorks, Allegro CL (and probably others). Thus in 2010 the most important implementations had concurrent threads running on multi-core machines. LispWorks had looked into the language and documented which operations were atomic, provided a bunch of extensions: atomic operations, dealing with native concurrent threads, mailboxes, barriers, semaphores, ... Allegro CL was then the first to come up with a parallel global GC. Java VMs already provide concurrent GCs - something which might be available in JVM-based implementation of Common Lisp: ABCL. Emacs Lisp OTOH is at the start of the language evolution w.r.t. threading. That's also why GNU Emacs is not a 'Lisp Machine'. The actual Lisp Machines had multi-threading in the end 70s. Zmacs had multiple windows - each Zmacs window was already its own preemptively scheduled thread. 
I don't think it answers any question.
Perhaps you've been schmoking too much of the good stuff to understand it.
If the body doesn't match the title then that's the OP's fault.
&gt; writing a Lisp environment that meets either Elm or Hejlberg's standards nightmarishly hard. Doesn't that assume that problems addressed exist in Lisp as well? If they don't then they don't need solving, do they?
Ooh, I'm curious what the queer thing is! Care to explain?
[Let me Google that for you](http://lmgtfy.com/?q=lambda+symbol+and+queer+culture)
Nice to see my blog there, I actually published 13 parts, I've had some problems with my computer but I plan on continuing with the series, until I have a compliant RiveScript interpreter. I hope more people get to my blog thanks to this publication, it is currently followed steadily by only about 40 people, which means it could be more engaging.
This is a pretty good macrology example. It's probably good to note that [Alexandria] implements these macros already though, as not everyone will know that. [Alexandria]: https://common-lisp.net/project/alexandria/draft/alexandria.html#Macro-if_002dlet
write a program that takes what you say and their responses as output and can figure out what to say and what not to say until you start getting paid to speak about anonymous functions as the opening act for top 40's musical artists
And now opening for JayZ, it's LAMBDA CALCULUS (and the crowd goes miiiild)
&gt; As the ambitions of RDF and XML have expanded to include things like the Semantic Web, the limitations of this lightweight schema language have become evident. Accordingly, a group set out to develop a more expressive schema language, DARPA Agent Markup Language (DAML). Although DAML is not a W3C initiative, several familiar faces from the W3C, including Tim Berners-Lee, participated in its development. and I can see no Lisp.
The Alexandria versions seem to lack short-circuit evaluation with `if-let` and `when-let`. YMMV, but I wouldn't use those. 
It makes sense when you compare the design of `when-let` and `when-let*` with `let` and `let*`
In Scheme, `let` doesn't specify evaluation order, so you'd either have undefined order for short-circuiting (bad) or fixed evaluation order (inconsistent). But since this isn't Scheme, what difference between `let` and `let*` would motivate inconsistent behavior wrt short-circuiting?
Yeah I see what you're saying, since the evaluation order is specified in CL it could short-circuit earlier. I meant more from the standpoint where `let*` is like nested `let`, and likewise `when-let*` is like nested `when-let`.
They also don't handle declarations.
I'm pretty sure SBCL was sort of called CMUCL in 1997.
SBCL was derived from CMUCL in 1999 (as was LispWorks in the late 80s, sort of): http://www-jcsu.jesus.cam.ac.uk/~csr21/sbcl-0.0 In 1997 CMUCL did not support native concurrent threads. Threads were added to Linux SBCL in 2002/2003: https://www.ukuug.org/events/linux2003/papers/barlow.pdf
original post was on /r/common_lisp from lispm. I thought some folks on the general lisp reddit might be interested in it as well.
Wow, you sure are cantankerous. 
zzzZZZZZ Too much talking about crap that doesn't matter. The presenter should assume that his audience are not idiots and do the demo accordingly. Anything else and the only people he'll attract will be idiots. 
from time to time, a reminder doesn't hurt :)
Don't want to listen? Read the documentation instead. No need to be rude, some people prefer an audio format.
FYI documentation can be found inside the tarball: [https://sourceforge.net/projects/series/files/series/series-2.2.11/series-2.2.11.tar.gz/download](https://sourceforge.net/projects/series/files/series/series-2.2.11/series-2.2.11.tar.gz/download)
&gt; Because nobody uses Windows as their primary system The company I work for is primarily a microsoft-biased company. Windows is thus our first choice for deployments. We can't be "nobodies" since said company has over 700 offices in more than 120 countries. 
&gt; You should consider changing your OS Or changing implementation to CCL / etc.
&gt; But, you totally ignored some good parts of ELisp: it is far more popular than CL or Scheme, or both, who knows, maybe even still more popular than Clojure. It evolves. **Unlike CL, which hadn't seen any major change since forever.** Typical FUD. Lately Clojurians like to spread this argument. CL is an extensible language, almost a meta-language. It doesn't need a specification to change to evolve. It has evolved *a lot* from 1994 (ANSI spec) to the present day. 
&gt;Right now, even though SBCL has threads, Common Lisp doesn't. Meaningless. All modern CL implementations support threads. And all of them offer exactly the same uniform interface to used, by simply including a compatibility library, like the "de facto" standard, bordeaux-threads. Thus, adding threads *to the standard* is not necessary at all. &gt;The language itself doesn't make progress. The people make progress, the language allows this progress to be incorporated into projects, without having to change the base language. This isn't **Java** where to get a new feature, one needs to beg Sun/Oracle/OpenJDK to review it, approve it, implement it, and add it... a process that takes years. 
When is your company starting to work on SBCL?
&gt; When is your company starting to work on SBCL? Why should it? And also, why SBCL? Why not CCL? 
&gt; Why should it? Because none of the SBCL developers are using Windows and you are boasting how great your company is at using Windows.
&gt;you are boasting how great your company is at using Windows. No, i didn't. &gt;Because none of the SBCL developers are using Windows Non sequitur. Read my last post again.
Seriously? And you wouldn't want the standard to change to, for example, make `length` a generic function? Because... you like manipulating the `cl` package in your own packages, by shadowing some symbols and crossing your fingers that nothing deep inside of other packages will not break? This is just an example of an early mistake that could have been fixed ages ago by some sort of a decree. CL standard library was great... in the 70s. Today you expect a standard library to provide a lot more than that. More containers, OS-interaction, all kinds of encoding / formats, perhaps database drivers, perhaps networking basics, what about cryptography? Hell, at least regular expressions! And, speaking about CL, I would expect standard library come with a bunch of macros for pattern matching, for resource management, for iteration over all those containers there will be in that imaginary standard library...
Finally a slime version compatible with Emacs 26?
yes, seems to fix the conflict with emacs 26 and slime-autodoc contrib
&gt; Seriously? And you wouldn't want the standard to change to, for example, make length a generic function? length already operates with sequences, which are many data types. &gt;Today you expect a standard library to provide a lot more than that. More containers, OS-interaction, all kinds of encoding / formats, perhaps database drivers, perhaps networking basics, what about cryptography? We're confusing "language standard" with "standard library". Perhaps you like the Python approach where the language comes with a stdlib that includes everything but the kitchen sink. Incorporating things like encoding/formats, database drivers, and networkings API *inside the Common Lisp standard*, IMO, would be a bad idea, since these technologies change in implementation over time, and better APIs for using such technologies appear over time. As for encodings, new encodings appear over time. Thus, they should all be implemented as **libraries**. Having those stuff inside the CL standard would mean that the standard would be rendered obsolete every few years (see: Java). &gt;And, speaking about CL, I would expect standard library come with a bunch of macros for pattern matching 'Quickload' desired lib &gt;for iteration over all those containers 'Quickload' desired lib &gt; there will be in that imaginary standard library Imagine it, implement it, name it and then... ... 'Quickload' lib. 
If \*todo-list\* isn't exported by the TODO package and not used by the current package, then you'll have to prefix the package name.
I don't understand what's going on based on your description. Is your code published anywhere?
Thanks. Prefixing produced the expected result.
You also don't need (declare (special ..)) if the variable is defined using defvar/defparameter.
Just stop using packages; put everything in CL-USER and be happy. Or else, use *just one package* for all your stuff. Are you working in a large team? Or redistributing an API for wide re-use? 
Suggestion: If you already have an object called "package", why don't you keep the todo-list inside it? I don't see the reason for a special variable.
"todo-list" will be understood as the todo-list that is on the current package. This is the expected behavior.
glad to hear you fixed your issue. A possible gotcha: the use of `make-instance 'todo` may (will?) bring problems if used from another package than the one defining the `todo` class. I suggest to define and export a constructor function: (defun make-todo (description &amp;key priority etc) (make-instance 'todo …)) 
That is expected behaviour for you. Expectation is a subjective experience and therefore context must be taken into account. The subject in the lexical binding of "expected behavior" is me. 
Downvote all you want; I'm putting my credentials behind this answer. Don't make one package for every little module in your program; this is not C++ classes or Java. You're just littering the code with package-related administrivia. 
You know, I replied without looking who was the OP. Had i seen it was you, I wouldn't have bothered to reply. Bye, save lisp and... 
He has a long story of various annoying behavior.
Agree with you Kaz. 
Nice joke. I just reported you to the mods. I know how much you like to edit your comments so I screen capped it as well.
There's nothing to report, stop making a soap opera out of nowhere. 
&gt; And you wouldn't want the standard to change to, for example, make length a generic function Not really. Common Lisp provides low-level operators, to allow programs to be written at that level. That's different from Python, where the low-level is C. In Common Lisp the low-level is Common Lisp itself. Common Lisp is the target language for its code generation via macros and for other higher-level language features. Features like 'goto' in Common Lisp are not there because we expect that user code with use it directly, but because it can be used in generated code. If I would want a generic level in Lisp, then I want a) a way to program at a lower level in Lisp, b) atleast somehow a way to recover some speed. CLOS is such an example. It's convenient, extensible and flexible. But it is relatively slow (compared to using structures) and it is only partially possible to recover speed. Doing so would require to make CLOS programs more static and/or use certain compilation technologies (see the Julia language).
Or see the recent discussion in Python where the BDFL retires from his job, because he is exhausted of a language syntax discussion about assignments. A discussion on that level would be different in Common Lisp. Users would come up with macros helping to express the desired intent - there would be no discussion with a BDFL about a future language change necessary.
This could be useful in some cases, but here you are only introducing another level of indirection. Simply export the `todo` symbol. 
Totally agree, this one-package-per-file business is irritating.
Jesus OP get a grip. This is expected behaviour = this is how symbols work. It's a bit annoying, but understandable. Either don't use multiple packages, use keyword arguments, or make it available by some other means ( like store it in a closure and provide functions to operate on it without exposing the to do list). If you aren't sure what subop means just ask, don't get defensive, we're here to help (mostly). 
You are missing the point of what I'm saying. It was a rhetorical question, not really asking for input. Yes, of course you want `length` to be a generic function, because the alternative is not to be able to implement any container with a `length` method. Look at the struggle in `cl-containers` for example. Or, you would need to give up CLOS (this is not a hypothetical, maybe it's actually a good idea), and just go about creating containers differently. But, the way it is today is a mistake, a lack of foresight, which could have been easily remedied if there was any sort of standardization process going on and new versions of the language were eventually achieved. ---- On meta- part: Lisp is uniquely positioned in terms of meta-programming. It is still much better than competitors in this space, but it doesn't advance. I think that the ultimate killer feature is read-tables. But, in order to grow the language, this mechanism needs to be further researched. Perhaps building grammars on top of read-tables, something like meta (OMeta) parsers on top of it. Researching what happens when combining read-tables in different ways would have produced a new and more powerful language... but this research doesn't happen... and, who knows, maybe in 50, maybe in 500 years from now some PHP-derivative will eventually do this. Simply because they make progress, and CL doesn't. :(
I didn't think [https://toggl.com/blog/build-horse-programming/](https://toggl.com/blog/build-horse-programming/) was very funny. ^(TL/DR: the pleb observer: "hahaha (((((((((((((((( i'm funny!!") The dragon thing was from another bad comic, which didn't have Lisp. I hope I covered all the big dialects with this.
*Moderator here* I am leaving this comment thread here as an example as what is not appropriate in this subreddit. Please do not make smuglispweenie comments. The original comment is borderline. Maybe, maybe not but easily construed as such. Please do not personalize discussions. Please do not make ill-wishes or threats (implied or direct) to another user. Repeated behavior will result in a ban. A yellow card for both users.
I loved the man declaring ` (optimize (safety 0))` next to the rocket...
That would actually be quite funny. A time travelling Schemer, like how Land of Lisp described them. My joke about purity has nothing on that, hah.
&gt;You are that bound to Windows... I'm sorry. :) Back in 1997-1998 I was a Linux fan and was prominent on my local Linux user group. Years later I briefly worked as Linux sysadmin. However, now I can see its flaws. So yes, Windows is proprietary and everything, but the popular alternative (linux) isn't really a fantastic super-duper replacement. I think a great feature of CL is flexibility. This includes being able to run your system on many OSs and CPUs. Again, it's fine if SBCL is developed with Linux in mind, as long as there are also other options that are intended to work just fine in Windows, such as CCL, which is a very good implementation, or the commercial lisps. 
&gt;A time travelling Schemer, like how Land of Lisp described them. That one was one of the finest comics i've read btw. 
The fork seems far ahead of the original repository. See also [about page](https://sirherrbatka.github.io/cl-data-structures/l_1.html#3489153149077281077).
...and now I want to see the original comic.
u/crabbone isn't wrong. It's also not FUD spread by some Clojure cabal. Common Lispers [were arguing about this](https://groups.google.com/forum/#!msg/comp.lang.lisp/9mAdBJiW1gM/a17QXlAq0m4J) before Clojure was a gleam in anyone's eye. That's just an example from (almost) a decade ago. Similar arguments echo throughout the decades between spec refreshes. We're almost at the 25 year mark for any change to the spec.
https://toggl.com/blog/kill-dragon-comic/
I think this is already in the sidebar.
The github link yes, now it has its own domain.
I'm assuming that this domain is preferred over the github repo, so I'm going to update the sidebar. If that's not the case let me know.
The domain is down with a 404 at the moment.
Seems OK to me now. Perhaps it was a temporary problem.
C and Lisp is all you need my dude.
I wonder how it compares to [Bondi](https://bondi.it.uts.edu.au/).
Previous discussion: https://www.reddit.com/r/lisp/comments/8bshzw/lisp_jazz_aikido_three_expressions_of_a_single/
Sorry, I did not mean to post this again. I should have double-checked that it had not been submitted before.
Nah, it's fine. It's been three months since the last repost - perhaps someone hadn't seen it back then and/or has new insight.
I'm one of the Anarki contributors, although I haven't done much with/in it recently. My pitch for Arc is "for what it does, it's very well designed." This may seem like damning with faint praise, but it's really impressive how many things make the language pleasant for the programmer. AMA, I guess, keeping in mind I didn't create this language -- my biggest contribution is writing a unit test framework for it that, as much as possible, doesn't suck.
If someone asks you "what is Anarki/Ark missing?", what comes tp your mind?
I'm a Common Lisp person and never touched Arc. How do these two languages compare?
A module system. Obviously, you can `load` a library, but there's no namespacing or `require` statements -- nothing like quicklisp or ASDF. That is probably the biggest thing, other than the semi-joking answer of "Paul Graham".
(Warning: not a Lisp historian) Arc is in some ways similar to Common Lisp: its macro system is lifted pretty directly (unhygenic macros). Some things are less verbose and more obvious: instead of `remove-if` and `remove-if-not`, Arc has `rem` and `keep`. Arc combines `if` and `cond` in a way that removes parens and makes things more readable. Common Lisp's `(cond ((&lt; age 18) 'cant-vote) ((&lt; age 21) 'cant-drink) (t 'go-for-it))` is, in Arc, `(if (&lt; age 18) 'cant-vote (&lt; age 21) 'cant-drink 'go-for-it)`. I like not having all the extra parens, and being able to go from a single-condition `if` statement to a multi-condition statement easily; changing from `if` to `cond` is needless. Similarly, Arc has two ways of binding variables: `let` works for only one variables `(let var val body)`; `with` (or `withs`) works for multiple, and doesn't require parens around each `var val` pair: `(with (food "ice cream" topping "hot sauce") (prn "Yum, " food " with " topping))`. It's a Lisp-1, so this works: `(let fun + (fun 1 2))`
No namespacing and CL style macros seems like a really bad combination.
Just prefix all your symbols with pkg$ or something.
When package names collide in CL, there's a way around it: you just need to rename the package (which usually amounts to 1-3 edits in asd file + package.lisp). If you need to rename all symbols in another package... that's a different story.
You also have to rename all occurences of packages symbols in other packages. If other.lisp still references newname:x as oldname:x this has to be changed too (as it is the case in Arc). As for renaming a "package" in an Arc-like Lisp, it's usually one :%s/old\$/new$/g or something along the lines of that.
Well, that's if you want to rename the package that's already in use :) But... why would you do that instead of renaming the package you are adding (which has the name of the package already in use)? There is no way you were already using two packages with the same name and not ran into the name conflict, unless you are in some kind of conundrum where you are merging two different projects developed by different people or something like that. Not impossible, but a really inventive way to screw oneself over.
&gt; Arc is in some ways similar to Common Lisp: its macro system is lifted pretty directly (unhygenic macros). &gt; [...] It's a Lisp-1, Maybe more accurately compared to early Scheme implementations, which also combined Lisp-1 with defmacro. After that design took *decades* of hygienic macro research to fix, I'll probably never understand why Arc went back there. &gt; I like not having all the extra parens I think those even/odd count-the-forms designs only look good in the small. &gt; being able to go from a single-condition if statement to a multi-condition statement Valid. Of course CL'ers can just use cond everywhere and get the same benefit. 
And to get some style of Arc into CL, there's https://github.com/malisper/Clamp &gt; Arc is an amazing programming language because of its brevity and succinctness, but at the same time, it lacks some of the most basic features of a programming language. It has neither a debugger nor a module system. Common Lisp on the other hand has many of the fundamentals that Arc lacks and much more (restarts, reader macros, etc), but lacks the conciseness of Arc. Clamp is an attempt to bring the powerful, but verbose, language of Common Lisp up to the terseness of Arc.
Did you try [Clamp](https://github.com/malisper/Clamp), so than you'd have Arc style in CL's world ?
&gt; I like not having all the extra parens, and being able to go from a single-condition if statement to a multi-condition statement easily; changing from if to cond is needless. Cond seems a lot more readable to me personally. I don't know how `if` is indented in arc, but even if the conditions are indented at a different level, it doesn't seem intuitive to me to break the even-odd pattern for the fallback condition (especially when it saves only two characters). The extra parentheses in cond also arguably make structural editing/navigation of a cond statement easier (see [lispy](https://github.com/abo-abo/lispy)). I feel the same way about `let`. I don't think using fewer parentheses does anything to help with readability. I don't think the difference matters that much, but I don't think either style is clearly better. As for being able to switch between `if` and `cond`, that can be done with a keybinding automatically (e.g. with a something like lispy), so it's at least not difficult to switch between the two.
Can't say I dived too much onto it, but I'm a little careful when it comes to use a Lisp-like language with so many extra tokens. I can see Clojure references there, but the `&lt;`, `&gt;` and `$` symbols remind me too much of C++ and PHP.