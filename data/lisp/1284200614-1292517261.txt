I wrote a Lisp program to do it (duh). You can make your own poster with my Lisp program at http://wigflip.com/automotivator/
Does it contain the missing figures? It would be nice to have them in the printed copy...
Are real hard copies that hard to find now? I picked up mine only about 2 or 3 years ago and I don't remember a (used) source being that difficult to find then.
While I still don't trust Apple very much, its good to know that I can get this game off of my hard drive and into the app store now.
While I still don't trust Apple very much, its good to know that I can get this game off of my hard drive and into the app store now.
*On Lisp* usually sells for hundreds of US dollars. The cheapest of 2 copies available on Amazon is $269.69. Where did you find your copy? How much did you pay?
Have you written anywhere about the technical details of your website? e.g. web framework used, etc.
I bought mine for around $80, which as I said was about 3 years ago or so. Wow, I had no idea they were going for so much now, I may seriously have to consider selling :)
Paper is nice, but having onlisp.pdf available on my Android phone is quite readable and usable too. (..just thought I'd mention that in case someone hadn't thought of it..)
Where did you find your copy?
I talked a little bit about it at ILC: http://xach.livejournal.com/214801.html It's TBNL (predecessor to Hunchentoot) with some of my libraries from http://xach.com/lisp/ and some convenience functions for page and template definition.
Thanks!
Damned [comment thread](http://www.reddit.com/r/programming/comments/dd0jc/the_world_of_programming_pic/) didn't work so i vented here. I guess it isn't all their fault, why can't we get people to use the CL compilers to compile Python/Ruby and such, the idea is that transcending the whole language debat equals winning it. (But i have enough trouble parsing the things..) Edit: probably such an image is pretty much bound to cut too many corners in explaining history
Sorry it took so long to get to this. It's now here: http://franzdownload.com/onlisp.pdf (I'll let you publicize it on the original thread.) I'm not sure where we will put the link, but somewhere on franz.com. Would you like credit? If so, tell me what you'd like me to say. 
Adding a compiler does not make a slow language fast.
Hahaha credit? Give credit where it is due: to Mr. Graham. Thanks for thinking of me though ;)
Well, you did something to include the fonts. (I'm not an expert on this, so I have no idea how hard that was.) 
&gt; why can't we get people to use the CL compilers to compile &gt; Python/Ruby and such There is CL-Python, and E has a CL-based system as well. I've always thought that the best system would be an *ecology* of languages on a VM, something similar to VMS's CLR. It would allow people to use whichever language fit the problem best. Of course, this is mitigated by Lisp-based languages having macros (or syntax) and DSLs being the norm, but I still think it would be interesting (esp. if you had a modern LispM: fairly Generic JIT'd VM + decent support for other languages would be great). 
Yeah that is cool. I was working on a C parser with the idea of being able to 'scan it' like i scan CL code, aswel as auto-cffi. It worked on a subset of C(worked on some of my project files), but still had a bug somewhere in figuring binary functions. Got my study now, and got rather sidetracked.. as ever.. Anyway kindah stupid to make a C parser.. *aught* to be library to parse it into something s-expressionlike(parser tree?) somewhere, but i can't find any conveniently enough used... Eh i probably said this before, but anyway, i think that asdf/ or dependency/tracking/getting systems are important in getting them used. So that if there is some .lua, .py, .c file there, and the user has something that interprets/compiles that stuff, it will. And it'd need a convention on these languages on how stuff CFFIs to eachother of course.
Well, something SWIG-like could help with the protocols, but if the languages compiled to the same VM (or system binary, as with VMS), that would be enough. Add to it an ASDF/XCVB-like system &amp; you'd be golden.
They included McCarthy, but left out Church.
Eh, I'll wait for the article on the afterbirth.
Well, it's Shlomi Fish, so probably not much will come out of it.
http://en.wikipedia.org/wiki/SPARK_(programming_language) 
Screw you guys, I think it sounds neat.
[SPARK](http://en.wikipedia.org/wiki/SPARK_%28programming_language%29) Don't forget [Spark-Scheme](http://vmathew.in/spark/index.html) (taken from the other reddit thread in programming where I saw this post).
Never heard of that. I'll check it out, thanks.
Between this and angavrilov's SSE work, there seems to be some interesting -- if not awesome -- code-bombs waiting in the wings for SBCL ...
Not to mention Jonathan Smith's [Peephole Optimizer](http://thread.gmane.org/gmane.lisp.steel-bank.devel/15207) and, even though it's quite long term and even then might only be noticed by people working on the internals, Gonzojive/Red Daly's [Cold Init CLOS](http://github.com/gonzojive/sbcl). It's on sbcl-devel as [Cross-Compiling PCL](http://thread.gmane.org/gmane.lisp.steel-bank.devel/15154). Not to mention Xach's [Quicklisp](http://www.quicklisp.org/) work, the [revival of lispbox](http://common-lisp.net/project/lispbox/) with another release coming as soon as Quicklisp is made public and the [CCL ARM port](http://thread.gmane.org/gmane.lisp.openmcl.devel/6105/focus=6109). Talk about an active lisp scene! :)
If he announces it on cll, we might witness a happy miscarriage.
Dipshit blogger remembers to acknowledge pioneer scientist, news at 11.
It just looks like Perl with parentheses to me.
Looks like the book will be published before christmas. Nice!
Ok, I'm sold. 
This guy is awesome. This is art.
damn. I daresay I know enough CL to not need this book, but I'm so gonna buy it.
How is this any different than SRFI-49 or various other "sweet expression" styles? 
Read more about the book and check out the TOC here: http://nostarch.com/lisp.htm
read and see? (yes, it is quite interesting; yes, it is different (both in its general approach (minimal and quite tasteful, even though I'm not sure whether I find the result to be a notable improvement over the normal sexp syntax) and specifically in its treatment of indentation (which is _right_)); no, it is not a long read; yes, it is easy to understand and summarize)
&gt; read and see? thanks, I never would have thought of that on my own. It was a rhetorical question per: &gt; yes, it is quite interesting; I'm not sure, for the exact reason you list: &gt; even though I'm not sure whether I find the result to be a notable &gt;improvement over the normal sexp syntax Which was exactly my point: we've had these things for a while and they almost never catch on, save for in certain domains (like SKILL). My point wasn't "gee, could someone come along and summarize this for my lazy ass?", it was "why are we trying this *again*, when we've known for sometime that it just doesn't work." Sure, there's value in trying, but I'm not certain of anything beyond that. 
&gt; "why are we trying this again, when we've known for sometime that it just doesn't work." when a well-respected professor judges something to be valuable for beginners, I'm inclined to at least not disbelief him, because I'm neither a beginner nor a professor. also, this is plain good stuff; I enjoyed reading the text regardless of its practicality (hell, I don't even use Racket, so what?). finally, I think the described approach to indentation is brilliant, and by itself makes the text worth reading.
&gt; when a well-respected professor judges something to be valuable for &gt;beginners, I'm inclined to at least not disbelief him, because I'm neither &gt;a beginner nor a professor. Well, I'm quite different then; I don't really care *who* said it, I think it's always up for inquiry. For instance, should we abandon Lisp &amp; Scheme because Phillip Wadler informs us that "Calculating is better than Scheming?" He is, in fact, a well-repsected professor; that doesn't mean I have to agree, even though I am neither a calculator nor a Professor (let alone a respected one). &gt; also, this is plain good stuff; I enjoyed reading the text regardless of &gt; its practicality (hell, I don't even use Racket, so what?). Yes, the text would be an excellent start for implementing indentation-sensitive languages. I'm still unsure if it's a great map for Scheme/Racket's features. &gt; finally, I think the described approach to indentation is brilliant, and &gt; by itself makes the text worth reading. Again, the approach is interesting, and the text well-written, but that does not mean I have to concede that this is a worth while goal for a language that already has a useful syntax.
Another resource: Yesterday [A Common Lisp Webdev Primer, Part 1](http://redlinernotes.com/blog/?p=1232) was posted to /r/lisp [here](http://www.reddit.com/r/lisp/comments/dg1u0/a_common_lisp_webdev_primer_part_1/) (no discussion at the moment.) It gets into the lower-level server configuration details, but I don't have the sysadminning chops to evaluate it. Also note that there's no part 2 as of yet.
nginx alone (without haproxy) can be used as load balancer as well -- you can specify multiple backends for proxy, and if one fails it will use other ones. haproxy has more configuration options, though. Another reverse proxy worth mentioning is Varnish. Its primary function is cache. While nginx can do caching too, Varnish does it much better, and it also has interesting load balancer features. 
It took a while to get Common Lisp support on the official game server but we finally got things working and there's now two starter packages that have been tested to work on the Planet Wars server.
I really don't know why a Lisp *web* server would be better than an apache server, if serving static content is the goal. If it is *not* the goal, if this web server acts more as an application server, is it not better to built a basic web infrastructure with something more 'traditional' such as python, rails or j2ee, and then, connect the back-end to Lisp via either Clojure or some other mechanism. I think that the web frameworks for traditional approaches are richer! So why not pick the best of the breed: http request -&gt; 'traditional APIs, j2ee, rails etc' -&gt; Native connect to a Lisp engine for 'heavy lifting'. 
This looks like the solution proposed above: there is a webserver (balancing the load!) serving static pages, and whenever the needed page is 'dynamic', it asks the lisp server to create it. Good+Better=Fantastic
Depends on how complex the web stuff really needs to be - I think that a majority of strictly web stuff, can be done much faster in some other web-centric framework - here is an example. Let's say you want to write an application that will be used for linear-programming type optimization, for distribution of survival material to a disaster area, such as the floods in Pakistan. You have a limited number of helicopters, and you have needs all over the place - some places need more medical aid, some places need more food etc... You write a web app, where "data entry" happens, people enter location and technical needs, and puts them in a database. This obviously does not need a Lisp engine, *BUT* the actual calculation of scheduling of helicopters and trucks SHOULD be done by a Lisp engine. So, your "rails/j2ee" app sucks up all the data from the database, and passes that data on to a Lisp engine, which calculates the schedule, and passes it on back to the web framework. This way, you have the best of all worlds.. I hope that this explains my approach... 
Indeed, thanks for clarifying it!
Because those technologies you call 'best of breed' are shite, and lisp can do what they do, only better. 
My article (or part 1 at least) is more about running lisp services alongside more traditional content (wordpress, etc), making them run as daemons and getting a decent development environment setup on your server. These caching and load-balancing links are wonderful though and I'll have to try to remember to mention them in the next part. Funnily enough, I stumbled across the Hans Hubner post independently a few days ago.
Divide and conquer :-)
Perhaps the only tool you have is a hammer, so every problem looks like a nail...
EDIT: Deleted original grumpy response for better thought out one. I've been programming web applications professionally for over 15 years now, and have used many languages to do so over the course of my career : C, C++, Java, Perl, Python, asp, PHP, javascript, bash, scheme and Common Lisp. I've also done toy apps in Clojure, scala, Haskell and Ocaml. Out of all those tools in my toolbox, i've chosen CL for the majority of web related work because i consider it the best tool for the job. Why should i chose tools i've used and found lacking?
A valid question (so have an upvote), but one that kind of misses the point of the OP. To my mind throwing RoR/Django/PHP/JSP/whatever into the mix just complicates matters: if your development team is already comfortable with Common Lisp then introducing another technology into your stack does not make sense. So the question being asked is this: if you *are* going to deploy a Common Lisp based webapp what is the best infrastructure to use?
Python envy.
Fair enough. I don't know how robust the CL web libraries are -- and how active the development is in that area.. If they can indeed be better and faster, then I am all for it... Is there a JSP equivalent (or similar) in CL web framework?? Session management? Connection to databases (Oracle, MySql etc..?)? How about SOAP web services? With tools like MyEclipseIDE, you can right click a Java class, and generate Soap stub, clients etc.. This is VERY FAST development... &lt;rant&gt; What is always disappointing is when you look for something really truly unique in a framework, you check SF.NET, only to find out that the development has ceased 3 years ago, or the product has never moved beyond version 0.1.. Very disappointing at times.. &lt;/rant&gt; 
Actually, in my opinion it simplifies the matter, because you can really separate the development -- (I am talking about non-trivial enterprise web apps). You have one group develop the whole web interface, and have them work with stubs to emulate returns from a Lisp engine. Have another group work on the Lisp engine, with stubs as inputs, and when both are done, integrate (provided you have figured out an integration mechanism between the two). One mechanism would be SOAP web services, the other (if using java or C), connect to the Lisp engine via some kind of native libraries. Once you have the link between the two, your life is really simplified.. Everyone works from the same stub spec, so there are no misunderstandings... 
&gt; Is there a JSP equivalent (or similar) in CL web framework? Sure, though that style of development is generally considered a bad idea, and better alternatives exist. &gt; Session management? Are you kidding? Of course there's session management. Frameworks like UCW and Weblocks go even further and have frame-level management.. each hit to a page is considered a frame. Using this concept allows full continuation support, as web 'frames' are similar to stack frames. &gt; Connection to databases (Oracle, MySql etc..?)? Yes, of course. With full support for the SQL language in a lisp-based syntax. &gt; How about SOAP web services? Yes. &gt; With tools like MyEclipseIDE, you can right click a Java class, and generate Soap stub, clients etc.. This is VERY FAST development... It's even faster when your compiler can generate code automatically from wsdl descriptions, or from anything. DEFMACRO and friends are a significantly better solution then edit-time code generation. Compared to lisp, web development in Java is baroque, painful and requires an incredible amount of boilerplate, configuration, and of course, requires using Java... which in itself is a good reason to look for alternatives. 
Well there needs to be a mechanism to deliver a lot of complex HTML quickly, with a little bit of logic (I do not embed Java code in my JSPs, only jsp tags). The rest of it the way you describe it sounds pretty good! I am a freelance software developer, so I tend to do it the way my clients want it done - mostly it involves Java for enterprise apps, however, I have been dying to try to embed Lisp via CLOJURE somewhere innocuous and harmless... I learned Lisp first time in 1984, and since have mostly forgotten it, because nobody does it in Canada (in Toronto anyway). I have been kind of itching to learn it again, and I have been reading some books, and I have downloaded trial versions of LispWorks etc.. The reason I am re-learning it is because, I believe that only now, I have the "software maturity" to understand and appreciate Lisp, in all it's simplicity, from which grow amazing complex things.. Please don't mis-understand me, I am NOT anti-lisp, it's just that I am questioning the deployment of large-scale software web apps, using only Lisp... 
If you have a large development organization (or, I suppose, a small one where you want to hire a hipster RoR developer to do your UI, or are in "the enterprise") where you need the separation of concerns, then what you propose makes sense (and describes how companies like ITA (roughly) do things: some deep magick in Lisp, (most) everything else in another language). But if you and your two best friends are doing the Next Great Thing and are doing it in Common Lisp, you want to address the OP question. 
&gt; Well there needs to be a mechanism to deliver a lot of complex HTML quickly, with a little bit of logic (I do not embed Java code in my JSPs, only jsp tags). Templating mechanisms abound, but must of us prefer HTML generators with a lisp syntax when we don't have to interact with designers or other HTML users. &gt; because nobody does it in Canada (in Toronto anyway) I've lived in Canada my whole life, and was the the inaugural Toronto Lisp Meeting. I am also a freelance developer/consultant. I don't let my clients choose which tools i should use... you don't tell your chef which knives to use, or your plumber which wrench to buy ;). My clients want code written, and they want it written by me and my team. The rest is in our hands, and we can do it cheaper/faster/better in common lisp. &gt; it's just that I am questioning the deployment of large-scale software web apps, using only Lisp... Why? you know that facebook is written in PHP right? Twitter in Ruby? Do you really think the quality of those implementations surpasses a decent common lisp compiler? My lisp images for website deployment often have uptime measured in years. I think your cup might be too full. 
I am totally amazed that you are able to freelance Lisp in Canada!! Royal Bank, CIBC, Manulife, BMO and all the other large companies in Canada NEVER want/need Lisp. If you know of companies that do Lisp in Canada, I would love to know who they are. A cursory search of Workopolis reveals only this: http://www.workopolis.com/EN/job/11675964
&gt; Royal Bank, CIBC, Manulife, BMO and all the other large companies in Canada NEVER want/need Lisp So why would i want to work for them? &gt; If you know of companies that do Lisp in Canada Most of my clients are not in Canada, and those that are wouldn't appreciate me posting their names all over public forums. &gt; A cursory search of Workopolis reveals only this: My clients generally find me, i haven't had to actively seek out work in years now. People looking for lispers know where to look, and it's generally not workopolis :)
&gt;So why would i want to work for them? Well, they pay money.... &gt;Most of my clients are not in Canada, and those that are wouldn't appreciate me posting their names all over public forums. See, most Lisp software development clients are **NOT** in Canada... I understand the need for privacy regarding the client's names - it is enough to know, that most Canadian firms would not touch Lisp - I had a strong suspicion about this. &gt;My clients generally find me, i haven't had to actively seek out work in years now. People looking for lispers know where to look, and it's generally not workopolis :) I was being facetious regarding workopolis :-) I believe that the Canadian software marketplace has a gutless, knee-jerk reaction to anything that is out-of-the-norm for computer languages.... Most of them have knee-jerk reactions and are looking for a software approach that they can eventually outsource off-shore for maintenance.. A short-sighted, gutless approach IMHO... 
Why are you losing so much now :(
&gt; Well, they pay money.... So do people who use lisp. Lots of jobs pay money. That doesn't mean i want to do them. If making money programming Java is what you want to do, why are we talking about lisp? &gt; See, most Lisp software development clients are NOT in Canada... That's not what i said, i said most of _my_ clients are not in Canada. Still, yes, more companies want a replaceable Java monkey. I choose not to work for them, regardless of location. &gt; I believe that the Canadian software marketplace has a gutless, knee-jerk reaction to anything that is out-of-the-norm for computer languages.... So, why work for those types of clients? It's your choice who you work for after all. Ever heard of the internet? It's amazing... you can work from home for clients anywhere in the world! &gt; Most of them have knee-jerk reactions and are looking for a software approach that they can eventually outsource off-shore for maintenance.. A short-sighted, gutless approach IMHO... I don't work for or with people who make poor technical decisions based on misinformation and false economy. You seem to want to work for those people because they have money, or you think these are the only possible clients. That is as short-sighted and gutless as your example, IMO. If your ambition for work doesn't go beyond working for whomever is Canadian and pays you money, there's not much Lisp is going to do for you.. after all, getting the work done faster and with less problems means less billable hours. I like it that way, means i can spend more time on my sailboat, and less time coding ;)
I don't want to do Java much any more, that is my whole point. I would like to learn enough Lisp to be fast and efficient in coding.. A bit of a catch-22 here.. Meanwhile, I guess, I am one of those "monkeys" you are talking about.. Thanks for that...
&gt; I don't want to do Java much any more, that is my whole point. Then why do you post examples of companies that use java as the companies you want to work for? &gt; I would like to learn enough Lisp to be fast and efficient in coding.. A bit of a catch-22 here.. What's the catch-22? You either want to learn lisp and you do it, or you don't. It's entirely up to you. It's not going to get you a job, so ignore that angle.. doing things because they will get you a job is rarely the path to doing what you want to do. &gt; Meanwhile, I guess, I am one of those "monkeys" you are talking about.. Thanks for that... Don't thank me, it is your decision to work in Java for large faceless corporations who desire trivially replaceable programmers rather than talented software engineers! 
I think we're far enough off-topic now... It would be great if Drew made a blog post or started a new discussion somewhere outlining the web tools he likes/uses. Other than that, let's grab a virtual coffee and leave this thread alone?
How about a thread on how a self defeating attitude and fear of the unknown is what prevents many intelligent people from pursuing the work which actually interests them, and not the corporations they choose to work for? :P Coffee is a good idea though, i can abide by that. 
I think that separation of concerns is often a sort of holy grail idea imposed by management, which seeks to carefully lay out how everything will work and interact ahead of time. But as anyone who has ever implemented a specification knows, there are often uncovered edge-cases. More often, in my experience, "enterprise-level" applications begin as smaller, less ambitious applications that grow. Many of these are written in languages that either don't scale well or require some real thought to scale well. This is, I think, where a language like CL really shines: organic application growth. If you start a small project in CL and it becomes a big project, you'll be able to grow it pretty sanely (which is much more difficult in languages like Perl or Ruby, for example, although not impossible.) In an organic growth scenario the UI/backend separation is probably not going to be strictly enforced and so having everything in one language makes a lot of sense. Once the project is large, the kinks worked out, the unforseen problems documented and addressed, then perhaps a careful rewrite, with everything cleanly separated, can be attempted. Often this is motivated by corporate desire to have things in a more "mainstream" or buzzword-worthy language than CL. The python rewrite of reddit comes to mind here.
It's a really basic bot and I'm actually surprised it won at all :-)
I believe that the method described is both a) incorrect and b) non-standard. Can someone with more experience weigh in? (a: If the symlinks are in `links`, doesn't that directory need to be added to `asdf:*central-registry*` rather than `libs`? b: Isn't it customary to put the symlinks in what these instructions call the `libs` directory?)
That's an odd dialect there. I can't see any good reason to have &lt;&gt; instead of (), but inconsistently, the odd ,GLOBAL and .LOCAL syntax, as well as the lack of LET and using "AUX" (string in a lambda list? Wtf?) declarations.
Yes, this is non-standard, the better method is using the asdf-install. You I think it should be correct, because it works for me.
&gt; it works for me. If the *.asd symlinks are in `links` but you push `libs` to `asdf:*central-registry*`, then I don't understand how it could work.
A place where I can try Quicklisp without emailing you.
Hop on freenode #quicklisp.
Awesome work, Xach! How far away from a public release do you estimate you are?
And of course I found this link helpful: http://stackoverflow.com/questions/398579/whats-the-best-way-to-learn-lisp
The 'On Lisp' book - for advanced Common Lisp programming For Emacs Lisp - 'An Introduction to Emacs Lisp', that is provided together with Emacs, and 'Emacs Lisp Manual', also provided with Emacs
If you want to learn how to customize Emacs, read Emacs Lisp material. Learning about Common Lisp is worthwhile but won't advance you toward the goal of writing Emacs Lisp very directly. Common Lisp, Emacs Lisp, and Clojure are all deep and different enough to be worthy of sustained direct focus instead of dabbling around.
Not far, I hope. Hard to say. Two Weeks?
You're spreading yourself too thin trying to learn elisp, CL, and clojure. You need to pick one, and dive deep enough for it to click. Then decide whether you want to learn any of the others. The one with the most resources available would be CL. Many good books have been written about it, and there are mountains of existing code from which to learn.
This may help: http://www.delicious.com/search?p=common+lisp
[Structure and Interpretation of Computer Programming lectures](http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/) [Common Lisp Hyper-Spec](http://www.lispworks.com/documentation/lw50/CLHS/Front/Contents.htm)
Note that Structure and Interpretation of Computer Program*s* ("SICP") uses Scheme, another dialect of Lisp.
Ok, thanks, i was thinking that all Lisp dialects share pretty much and I can easily switch between them and learn only about specific features (e. g. emacs api). 
Emacs Lisp is my favorite Lisp, and it is the Lisp I write the most code in, by far, and the lisp I get the most mileage out of. Unless you have a specific project you want to work on in CL or Clojure or whatever, focus on Elisp. Emacs will MAKE YOU A BETTER PERSON.
I'm in the same upboat. This looks to be a fun read!
You might care for [Common Lisp: A gentle Introduction](http://www.cs.cmu.edu/~dst/LispBook) Might I ask which other languages you know ?
It also, incidentally, cures herpes.
&gt; You also can't just pass functions around because anything not at the car of a list is assumed to be a variable, so instead of (apply (lambda (foo) bar) baz), you need to use (apply #'(lambda (foo) bar) baz) . Oh, really? Think again.
Maybe he looked at CLtL1, but not CLtL2?
Just because CL does distributed development doesn't mean it can't be easier for newbies. Sounds like CL needs distros, like they do for Linux. (Btw, the title doesn't mean Yegge's literally dead, does it?)
I don't understand the title of this post at all.
At one point there was a blogger by the name of Steve Yegge who wrote a bunch of thought provoking stuff. I think he stopped blogging for good now... Anyways, he used to write about lisp and emacs and at one point wrote an article comparing three different lisp dialects: Common Lisp, Scheme and Emacs Lisp. The essence was that Scheme was the neatest lisp for education but not good enough for production, while, Common Lisp was less elegant but much more powerful. I guess a number of schemers took exception to this point. The writer of this article seems to have now independently arrived at the same conclusion. Hence, "Yegge strikes back." That was the relationship that I took from the title. Did I miss anything?
That's a good summary. Yegge was guilty of writing all kind of long-winded stuff. He was also known to sometimes mention Lisp, but I never had the impression that he did much programming in Lisp. IIRC, he was also promoting the idea that Ruby was some kind more 'real' Lisp, than existing Lisp dialects/implementations.
A cl distro, you mean something like quicklisp?
quicklisp isn't a "distro", its more of a package manager. 
He announced that he would stop blogging. He certainly doesn't seem to blog as much these days.
Yegge's dead, baby. Yegge's dead.
so what is a "cl distro"?
I suspect a "cl distro" is something like [Lispbox](http://common-lisp.net/project/lispbox/) where you get everything you need to start working in Common Lisp in one "easy to install" package. Hence the allusion to a Linux distro, which is a complete OS solution which includes not only the kernel, but drivers and applications. 
&gt; IIRC, he was also promoting the idea that Ruby was some kind more &gt;'real' Lisp, than existing Lisp dialects/implementations. I think his argument was something along the lines of: * 'Lisp' (all lisps, not just CL) is supposed to do X, Y &amp; Z practical things * Most 'Lisp' incarnations suck at X, some suck at Y and most miss Z * Ruby, however, does many of the same things, and I can get X, Y and Z easily. There for Ruby is an acceptable Lisp. He's certainly not 100% anti-Lisp; look at his write up on [symbols &amp; ruby](http://www.oreillynet.com/ruby/blog/2005/12/digging_into_ruby_symbols_1.html). He mentions several things he'd like from Lisp. Also, I believe he did quite a bit with elisp, but that might not flavour a person's perceptions of lisp in a nice way :D *edit*: "he" -&gt; "his"
Reading things from the past, he was more argueing that no Lisp is an acceptable Lisp, while some other guy argued Ruby is an acceptable Lisp. I've never read any Lisp code from him, he said that he 'dabbled' with Lisp - so I fear his writings are opinions from somebody who has a very superficial knowledge of Lisp. I'm not sure that he said in his article that he likes those things from Lisp, he just mentions that those are actually easy and natural.
GBBopen is missing.
&gt;Reading things from the past, he was more argueing that no Lisp is an &gt;acceptable Lisp, while some other guy argued Ruby is an acceptable &gt;Lisp. Well, yes, the explicit notion of "Ruby is an Acceptable Lisp" was someone else's; from my reading of his posts, it seems that he felt things like JS &amp; Ruby fit the bill. &gt;I've never read any Lisp code from him, he said that he 'dabbled' with &gt;Lisp - so I fear his writings are opinions from somebody who has a &gt;very superficial knowledge of Lisp. Everything I've seen has been elisp and not much else. &gt;I'm not sure that he said in his article that he likes those things from &gt;Lisp, he just mentions that those are actually easy and natural. Well, I took it as "if Ruby only had these things" to mean that they were *good* (why else would the be easy &amp; natural). Still, your point stands: he never *explicitly* said he liked those features from Lisp.
I know C++ and Python, also a bit of Java (I wrote few projects in it), C# and Perl (which i usually choose for scrippting).
I half agree - Common Lisp is the superior implementation for getting things done. I'm not so sure I'd agree that scheme is superior.
Dumber than that actually. I initially (this was years ago) read that you have to pass functions around using sharp-quote because of the two namespaces [as in (mapcar #'double '(1 2 3 4))], and just got used to it. I did the same thing with lambdas for consistency, and honestly forgot that you didn't need to. Corrected now, but my face is pretty red about it.
Pretty much, yeah. The post was meant to show the opinion of a newb in the middle of the learning process, and highlight the things that tempted me away from Common Lisp in the beginning/are tempting me back now. An official distro (along with a single, sufficiently complete source of information/addons and a shiny GUI) would address most of the speed-bumps I hit. Yegge's, still kicking AFAIK, but he took a year or so off blogging, and hasn't written anything serious tech-wise since (just a "hey, I'm back" post a few months ago followed by another Java satire shortly thereafter).
If you want to read some of his lisp code (well, Elisp, anyway), check out js2-mode http://code.google.com/p/js2-mode/
I think it is not that problematic. I sometimes think #'(lambda ...) is more consistent or that (function (lambda ...) ...) is more lispy. But with (lambda ...) my Scheme education shows... Just use what you like, but know that there is a LAMBDA macro that expands into the (function (lambda ...)) form.
(setq Clojure (1+ Clojure))
Bah. `(incf Clojure)`
Why can't the types be inferred in the unspecified-types example? ala Haskell?
I'm assuming (I know little of clojure) it's because numbers will normally change type as they get larger 'ala' common lisp i.e fib 1 the argument will be type bit and fib 1000000 the type will be (INTEGER 0 1152921504606846975) or whatever the clojure equivalent is.
In Haskell, there's "Int" for fixed-size integers (e.g: "long") and "Integer" for integers that can grow. "Integer" will use the "Int" representation internally for efficiency when it can, and will grow its representation (without changing its type) when it needs to. In Haskell, the types would infer to "Integer" by default, if any integral type would work.
This is pretty much what I thought. Lython? Or perhaps Pysp? Neither of those sounds attractive.
This would not even be close to clojure code. [EDIT: Well, maybe kind of _close_. But it wouldn't run.]
Am I assuming correctly that there is some decrease in performance for using Integer as opposed to Int. There would be in common lisp.
I don't like clojure. It's a cool toy for Java developers.
&gt; It's a cool toy for Java developers. Do you think the same thing about Kawa, ABCL &amp; SISC?
Well, those are implementations of language standards on a new platform. That's not really the same thing since you can take a scheme program or a CL program and expect a port to be fairly straightforward. I'm not really fussed however X number of languages are implemented on the JVM. Clojure is a new lisp on the java platform though and I'm not really keen on it. It's really the syntax and the fact that it just feels like a scripting extension for the JDK that turns me off. Not saying it's a bad thing, but it's not for me.
&gt; Well, those are implementations of language standards on a new &gt;platform. That's not really the same thing since you can take a scheme &gt;program or a CL program and expect a port to be fairly straightforward. Well, I think those systems target two groups: * people who need to use the JVM, but want to use a lisp * people who need to tinker with Java libraries, but don't want to use Java. I think clojure fits nicely in the second category (as you mention with "feels like a scripting ..."). I was simply curious if it was JVM hatred or an actual dislike of Clojure. 
Thats simple to answer. Clojure cant be staticly analised like Haskell or other static languages. All the dynamic languages have to do this as far as I know nobody thought of something better.
Ok, tell me whats better about CL or Scheme then Clojure? a) clojure as it is b) clojure if it had a nativ implementation (or on a CL runtime) Lets not talk librarys and speed just language. P.S. whats bad about the syntax I think its cleaner then CL. The [], {} ... are a nice addition. You can still to (hash-map ....) or (vec ...) if you dont like suger. What feels like a Scripting language? There are allready a lot of wrappers for the importend stuff. Writing java interop feels like lisp not the other way around
(inc Clojure)
&gt; The fact that Paul was creating his own Lisp didn’t reflect positively on CL either, I mean if CL was the end of the line why was he putting effort into something new? I used to think the same, once, when I was a fresh lisper and Arc was a mystical messianic secret yet to be revealed to the world. Now I use CL and I'm very satisfied. 
Tell me why something has to be better in order for me to prefer it. I don't like the change in syntax, basically, from the language point of view. Tell me how much I'm missing out, if you must. I probably wouldn't use clojure if it had a native implementation. &lt;pedantic&gt; "than" is comparative; "then" is used for consequence or denoting a past event. Your entire statement could use a grammatical tidy up.&lt;/pedantic&gt;
This fact only reflects on Paul, not CL.
With Haskell's support for type-classes and existential types, you do have "dynamic types" in Haskell (That's basically an existentially-quantified type with a set of operations defined that you can use). After seeing that, I am wondering what's to be gained by dynamic types by default, except maybe less of a learning curve.
Yeah, there is.
There are many things that make CL better than Clojure but in my opinion, it is the fact that CL is a true multi-paradigm language while Clojure is not. For me, the nature of Lisp is to be able to adapt the language to the problem at hand and not the other way around. In this regard, I think Clojure is the least successful Lisp since it imposes much more a certain way of thinking/programming than CL or even Scheme. 
his js2-mode is 10k lines of elisp with builtin on-the-fly parser for js. Same i think for his abandoned ejacs js interpreter in elisp. I think his's elisp know how is even better than many emacs dev. Writing a rl working parser just isn't trivial, not for me. he also did write a puzzle/logic game using several langs on jvm, one of the include Scheme implementation... all on his blog. Not sure what he done in CL.
I'd even say he realized this himself by now and is just letting Arc silently go away, without embarrassment. One day he also will silently rewrite HN in CL or Racket, turn off the Arc forum and website, and since there is nothing more to Arc than these two, this will be it. Its just a matter of time.
Im not saying you have to use it. I'm saying you should not bash it because of the little syntax changes and you should look at it because some ot Clojure stuff would be handy in other lisps too but the allways have the additude that they don't need to learn from other people. And that why the Lisp community has such a bad reputation. The unification of the seq library is pretty cool. (http://clojure.org/sequences) Everything works with it from files to java arrays. Even records (like classes) can be treaded just like any hash-map. http://clojure.org/protocols The multimethodes are a little bit more powerfull because you can provide you own dispatch function and you can build ad hoc Hierarchies. http://clojure.org/multimethods Alot of the seq functions are lazy witch comes in handy often. Rich made a system for Metadata witch is open in its use. It solves a lot of problems like type hinting, it provides information to the compiler and constraint programming. But you can invent somthing yourself. http://clojure.org/metadata The STM and the Agent system are extremly cool and easy to use. Everything is threadsave. http://clojure.org/concurrent_programming Clojure has really cool data strucures. Not as fast as mutible once but still very fast. http://clojure.org/data_structures Clojure supports abstract structural binding, often called destructuring. Look at this blog post: http://blog.jayfields.com/2010/07/clojure-destructuring.html It has a really clean design. Everything is programmed against abstrations. If you don't like something rip it out and provide something yourself. I'm not a nativ english speaker. Thx for the correction.
Your right but I think its good to incurage people to use FP. People are to fast to jump to imerative if the have the change. I just think CL is to big and unclean. (I'm working threw some books that work with CL and I find Clojure to be cleaner and often shorter to write) P.S. I'm not really good with CL. What do you think makes it better? 
Maybe it's time to revisit my real-time FM synthesizer. Fiddling bits and bytes using native Java arrays and mutation to gain performance is so disappointing from a functional programming perspective.
I would think it would be really hard to implement to but I have no idea how that works. What would be the benefit of a Language how you descripe it? 
Static typing by default with type inference gives better performance and better and earlier error detection. When you still "need" it, you can get dynamic typing. I think the Haskell experience is that almost noone chooses to use the dynamic typing support. I think the reason is that when your type inference and type system is powerful enough, you stop missing dynamic typing.
This is my objection to Clojure. If I wanted to program in Java, I'd just use Java. :-(
Note too that they've recovered www.cmucl.org for the CMUCL project.
Nowadays I don't think pushing a certain paradigm is a good thing (e.g., functional, logic, etc). Paradigm is an "example" of how a problem can be soveld and it's by using different paradigms that you gain the most. Because of this, CL is the best Lisp and the best language IMHO. Obviously it's not perfect and has its own share of problems but all languages do. I feel more confortable in CL than any other language (and I just love to explore programming languages) mostly because it CL's adaptability. In a very short way, CL is better because it has CLOS, a very good condition system, it's a Lisp-2 (well, N), maturity and other small things. And if you need something, you can implement it (e.g., STM, call/cc, etc). CL takes time to learn and appreciate it. If you don't do some serious coding with CL for 2 years, most likely some of the strengths of CL will not be evident. PS: Sorry for the short reply but I am on the middle of a trip.
Who did it belong to before they recovered it?
Did you get your copy? How did it work out?
After reading this, I've just taken a look again at Arc. I still don't understand the point. It doesn't seems different enough from other lisps to merit being considered anything different from "a bunch of macros over mzscheme" (as it has been called). Am I missing something? This is a honest question, I don't want to be sarcastic.
Apparently squatters had it.
Arc is closer to picolisp than CL and pretty far away from Scheme. One way to think of this is to plot the languages on a dynamic/static axis. Scheme is extremely static, to the point of necessitating/wanting relatively restrictive macro systems. In a way, this is to ensure efficient and/or unambiguous compilation. CL is also pretty static, but you can use the macro system to do dynamic sorts of things. The language is still lexically scoped, and has a loosy goosy (and powerful) macro system, but still wants to be efficiently compilable. Arc is somewhat more dynamic than CL (I think, I don't really know Arc that well), but it has a greater focus on making macros powerful without worrying about efficiency. This moves it towards supporting things like FEXPRS (functions which take arguments which are not evaluated before being passed in). I don't _think_ it actually supports these, but you could write them, I believe. Picolisp is hyperdynamic. It doesn't even want to be compiled, data is code to the point that lamda is just quote. Scope is dynamic. You get f-expressions directly in the language. Really, the lisps are pretty different except for s-expressions. This is consistent with my theory that the real win in lisp is in s-expressions, not other features. Just my opinion, though. DISCLAIMER: I really only know CL, Scheme and EL,so I might be _totally off_.
I did. It's not bad, but the text is somewhat small (smaller than news print, I'd say). My eyes are still good enough that it's not a problem for me at least. Also, as predicted by the "print ready" pdf that lulu shows you before you purchase, there is a lot of room on the top and sides of the text on every page. Personally this doesn't bother me, and in fact, I like having the room to take notes. But I could see how non-centered text might annoy other readers.
I think to have a language this open is good if you work for yourself but if you have a team of people and not everybody is a Lisp fan people will just use the stuff they shouldn't but I can see your point. The best Object system I used was in Dylan and CLOS is pretty simular so if objects then in the CLOS style. It better then the single dispatch systems. I agree about the condition system I hope there will be one in Clojure. For me Lisp-2 is somewhat bad. Look at the videos of Rich Hicky on http://clojure.blip.tv/ (the one for lispers) he makes good points why Lisp-1 is better and how you can make it work. Could you really implement an STM and Agent System that works everywhere (as long as there are threads)? I think it would be great if there would be a new commity working on a non backward compadible CL2. 
Why should I prefer it to SBCL? SBCL has started as a CMUCL port and seems to be way more active and has a larger community.
I suspect most of the people who use it and hack on it these days do so because they started using it when it was the only game in town and they got very comfortable working with it.
Who down-votes this? CMUCL fans, I guess?
Interesting, but seems kinda klunky. At first glance, it looks like (Termite Scheme + XML) / 2 
I'm a newbie to Lisp, and mostly new to functional programming in general, but I love the directness and simplicity of the meta-programming that PicoLisp seems to have. We'll see if I still feel that way when I try to actually make something with it shortly here... :)
Because it has features/ports that SBCL does not have?
Bots.
That is a very generic argument. What features does it have that SBCL doesn't?
Also (How to Write a ((Better) Lisp) Interpreter (in Python)) : http://norvig.com/lispy2.html
Note, FUNCALL and APPLY accept [function designators](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_f.htm#function_designator), so you don't have to pass functions with #', unless it's a local function: (mapcar 'double '(1 2 3 4))
That's true. I have asked that question at some point in time, too. I was traveling yesterday and thus unable to look up the answer I got from some CMUCL guy. I'm not sure if I can find it, but I'll try later.
Almost a full day and only 2 comments? For shame. Lispers need to represent on reddit better...
I think 2 comments represents that Lispers on Reddit don't give a shit about toy Lisps in Python. Or maybe that's just me.
Denouncing soiling the language by implementing it in python would also count as representing... 
I'm only commenting to state that I *do* care about toy Lisps, in pretty much any language. It's interesting to see the techniques used to implement what as Alan Kay is quoted as calling *the Maxwell's equations of software* on a given platform with its own unique set of features. Especially one written to be concise and which has had a lot of thought put into it by someone like Peter Norvig. I'm working on my own implementation of a subset of Scheme (just for learning purposes), and seeing some of the techniques someone like Norvig uses is useful, and it's always interesting to see his style. I didn't comment on this before because I thought nothing needed to be said.
See also http://twitter.com/quicklisp/status/26168068127
Looking forward to next Saturday! :) Are there any plans how the community could be involved in helping? Also, will the client/bootstrap-file also be included in some implementations? F.e. sbcl,...
I think that will become clearer as people try it and let me know what they want and need. I don't know how bootstrapping bundled into implementations will work at the moment.
Anybody know anything about this? Does it actually run on iOS? Will a small-screen version for iPhone/iPod Touch be forthcoming?
Again, sorry for the late reply... Well, I don't agree with you on the Lisp-n point. The debate is old and at some point is a matter of preference. For example, I do really like to be able to use "list" as a variable name (among others) and Lisp-1 restricts me on this. I prefer this because it increases the readbility of the code and the situations like (list list) very rarely appear. Furthermore, if you read the book "Lisp in Small Pieces" the technical aspects of the Lisp-n debate are very clear. And from that presentation, I don't think a Lisp-2 is bad. Quite the opposite. Yes, you can implement STM in CL: check http://common-lisp.net/project/cl-stm/. Erlang style too. Finally, from a programming languague point of view, CL is clearly a better languague than Clojure although Clojure has some nice things too (the seq abstraction for example). From a sociological point of view, Clojure has the upper hand because of the Java connection. Buth then again, for some people that is not an advantage. In the end, I believe using a Lisp languague is better than not using a Lisp at all. CL, Scheme, Clojure, or even some other dialect, is better than any other languagues out there :-) 
That is a pretty good price for a great book. Maybe the real Lispers didn't notice it? Next time, try a #lisp tweet!
Actually, I was thinking of how both bidders waited until the last possible second to make their bids.
That's the pretty standard way for anyone to win at eBay. http://www.kenrockwell.com/tech/ebay/how-to-bid.htm for example.
Yes, that is indeed the "smart" way to do it, and it's the way I bid on things. But there's almost always someone who makes an early bid. Out of all the auctions I've placed on ebay, this is the only one where the *only* bids happened with less than 30 seconds left in the auction.
My guess is that Lispers didn't find your auction.
More amusing, to me at least, is that the winning bidder "westbks-2009" is probably a used-book seller who is going to try and resell it on Amazon for twice what they paid for it.
I bought Artificial Intelligence: A modern approach second hand for twelve pounds. Then I decided that Paradigms was the book to read first, but I couldn't find a cheap second hand copy. I concluded that it must be the better of the two books and good enough that every-one holds on to their copy, so I coughed up full price for a new copy.
No kidding... looking at the sticker on the back, i paid $75 US for mine at the MIT coop. 
That has to be the lowest price I've ever seen PAIP go for. Screaming deal for someone.
'A Lisp programmer knows the value of everything, but the cost of nothing.' (Alan Perlis)
I like this variation: &gt; A Prolog programmer knows the cost of everything but the value of nothing. 
The Lisp part has been a pattern for the whole last 50 years: Somebody finds out about Lisp and functional programming, gets excited, writes cool looking code, the code performs badly, the person gets disappointed, leaves Lisp behind, Lisp is forgotten, somebody finds out about Lisp and functional programming, ...
I don't see it in the app store so I assume you still need to load it via Xcode or some such thing. M
'Chruch'?
The place where athreists don't go.
http://quicklisp.org/beta/releases.html has a list of stuff you can install.
I realize this is probably a large project in itself... but has any thought be given to adding (perhaps optional to start with?) descriptions for projects?
Yes, lots of thought but not much time. I'd like to add much more info about each project, something like what cl-user.net provides, e.g. http://www.cl-user.net/asp/libs/skippy or http://www.cl-user.net/asp/libs/s-xml. I'd also like to add automatic testing so you can get an idea if a library is likely to work on your favorite combination of operating system and CL implementation. All in good time, hopefully...
and a listing of those projects not included and why =)
Right now the primary reason a given project isn't included is one of "I don't know about it" or "I couldn't get it to build."
I have here LispWorks 6 64bit Enterprise on a Mac. How do I know which of these release I can load into my LispWorks?
during quickloading it prints something like [package interface]........................ I find that confusing. Is that a CL package? Probably not...
http://en.wikipedia.org/wiki/Church_encoding
Yes, it is a CL package.
At the moment, the only way is to try it and see.
i.e. you skipped the hard parts of libcl. ;) Seriously though, please take a look at the libcl metadata (in http://gitorious.com/libcl/world). It might be beneficial to both projects if we could find a common format.
Oh, and feel free to file github issues against http://github.com/quicklisp/quicklisp-projects for things you want to see added! That will help me keep track of things.
Great! Sort of a solve one problem find another situation ;-) Quicklisp seems pretty awesome so far...
why would it print packages?
I couldn't figure out how to print more appropriate things, and packages seemed useful and easy enough.
I understand what an epic effort Quicklisp must have been so far. Congratulations on the beta!
Okay, a R6RS scheme interpreter officially approved. Now we need the CCL ARM port in the Appstore.
sorry for spelling mistake
Just from the perspective of Java, mentioning Gosling but leaving out Steele is nearly criminal. Gosling may have created Java, but Steele *enabled* it (something he did for Common Lisp as well). And that leaves out the fact that he was co-creator of what may be the most elegant Lisp dialect to date. 
It used to be )))))))))))))))))) now it's ]])}))})}}]])}]]) Is this what people call progress? 
Who chose those colors? I don't think I can think with that kitty staring me down...
looks pretty interesting, unfortunately I can't find the project source / download. 
&gt; CLforJava differs from other CL implementations that run on the Java Virtual Machine in that it is intertwined with the Java language. It's major goals are that a CL user can access any Java library via CLOS with no Foreign Function Interface needed and a Java programmer can access CL as a Java library. I wonder how they plan to achieve that goal. Or how it will be different from writing a set of macro on top of ABCL.
Indeed ABCL with with better (clojure like) java integration would be great.
that _is_ the source
Yeah, I've looked at this before, but it's still not fully developed enough to do any real work in yet.
See also http://ifdb.tads.org/viewgame?id=zj3ie12ewi1mrj1t for the Z-Code source
A little disappointed that he didn't post age/location data. It would be nice to know how many other programmers in their mid-twenties are going down the LISP road, and whether there are lisp-metropolises out there.
If I could upvote more than once, I would.
Very nice. Shame it doesn't work in conkeror (I had to run Firefox to play), but I guess I'm not surprised given its popularity.
Yeah, I never got that. I mean, my editor has paren-highlight on, so there isn't much trouble either way, but I always thought that "counting out the parens' was easier than "counting out and matching up parens, braces and brackets". It reminds me of a shirt I saw. Something like {[ :( ]} ( :) )
[On the author’s homepage](http://www.eblong.com/zarf/if.html#lists).
I have age &amp; country data up for my SBCL User Survey: http://random-state.net/sbcl-survey-2010-results.html
Web development is the current hot thing, and tutorials for Lisp + the web are small in number. I'd suggest maximizing time spent on topics related to Getting Started ... Getting a Web Page Up ... Getting a Web Page Up That's Backed By a Database. Not to say that pictures, numbers, and text encoding aren't important... The answer to your question depends on your interests and goals. If your goal is to maximize applicability to the (identity unknown) programmer eying Lisp, then I'd wager the web. If your goal is to maximize applicability specifically to the CL programmer who has had issues with libraries in the past and for whom Quicklisp represents a change in the status quo, then I wouldn't know where to put my money.
Nice
Just FYI http://www.adampetersen.se/articles/lispweb.htm Aged, but still somewhat useful.
Indeed! That's one of the ~5ish tutorials for Lisp + the web. As you say: it's aged. It's written for long-gone versions of the libraries it employs, and no longer works at all. Another (possibly) good starting point is Postabon's [A Simple Lisp Webapp for beginners](http://postabon.posterous.com/a-simple-lisp-webapp-for-beginners). But even that was written in December of 2009, so god only knows if it's any help at all. EDIT: Another good one is Eric Normand's "LispCast" series. It's also outdated to the point of non-functioning.
Looks good, but since we have an easy way of installing libraries, I'd like to see the usage of libraries like alexandria included. 
Windows GUI
Wait, I don't get it. I should cut and paste the definitions of RESULT, FAIL, ITEM, BIND, and anything starting with an = into a source file?
super fun!
[RDNZL](http://weitz.de/rdnzl/) offers CL &lt;-&gt; .net interop. You can use it to build WinForms or even WPF applications in Common Lisp.
I agree, but since there are a number intro tutorials, I'd like to see a few that take the next step. Ie. How can I integrate memcached? How can I get setup on EC2? Just things that someone using lisp for a webapp might encounter.
I was about to say the same as xach. You can be ahead a large sums of money for days, but don't feel too confident until the very last tick of the auction timer. I swear I've even gotten outbid *after* times has run out. That is a great price for a fantastic book. It's over $90 on Amazon, and since Bookpool is no more, that's probably the cheapest non-student discounted price you'll find. 
I would **LOVE** a cl-pdf and cl-typesetting tutorial. I've been trying to get an alternative for LaTeX for *years*. I always thought this was a big chance for Lisp to go mainstream. Actually, I would just be happy to get cl-typesetting to work much at all. 
I love Edi's names: &gt; It was pretty clear to me from the beginning that the name of the library should be "RDNZL." However, I'm not sure what this acronym exactly stands for. Edit: btw, this is just another examples of how much we need metadata about libraries somewhere...
I'd kind of like a tutorial showing the capabilities of matlisp / lisplab / femlisp and specifically whether or not they are viable matlab / scipy alternatives.
Ffi and working with libraries
Searching for ischeme in the app store returns nothing
Yes. YES. DO IT.
Awesome article thanks. I did all of the examples in Slime, and it is a blast to see the output of functions like describe, time, and room. Thanks a lot. 
[This](http://news.ycombinator.com/item?id=1792537) suggests that is true. There is a comment in there by Dr. Barski himself. I am too am looking forward to some Grand Theft Wumpus.
Cool! Looking forward to the book and the new site.
&gt; this is just another examples of how much we need metadata about libraries somewhere... http://www.cl-user.net/asp/libs/RDNZL
Reminds me of http://norvig.com/21-days.html
sounds great.
Showing how to use libraries is one of the major points of these tutorials -- and since I'm both writing the tutorials and maintainer of Alexandria, you can be sure it will be mentioned. :)
Yup, that's true! It's at the printers right now, and we're expecting it to be in stock and ready to ship out toward the end of next week. Amazon shipping dates may vary, but not by much.
I ordered it as soon as I became aware of it. They still hasn't shipped my order, but when I inquired about the delay, Amazon said I should get it on Oct. 25. Not sure how that works, as Land of Lisp's new release date is Oct. 29th. Oh well, it will give me a chance to finish Paul Graham's Ansi Common Lisp, which I am throughly enjoying. But I'm ready for some wacky illustrations, and lots of cool Lisp code. 
I met Dr. Barski last night and saw the book. Yes, it is real :-) 
+1 for interest. I'll keep an eye on this, though I get the feeling my professional work will continue being in SBCL.
Why, oh why? ECL is a healthy project under active development, and Juan, main maintainer, is very responsive and open to all ideas and suggestions that will make ECL better. I'm 100% sure he would be glad to welcome another contributor and co-maintainer to ECL. So, the main question is why fork? Why not just improve ECL itself? I can't see what has been added there that couldn't be added to original ECL. Has MKCL author tried to talk to Juan to see if those improvements could be added to ECL itself. Although I follow ecl-devel mailing list I haven't seen MKCL author posting anything there. In case there is no clear answer to this questions I hope this project will fall back into oblivion where it belongs, and that it will not succeed in further fragmentation of the CL implementation space.
This can't be good. There are more Lisp compilers than Lisp companies! 
That's exactly what I was thinking; nothing that the author proposed is incompatible with ECL in general, so why fork instead of committing those changes back to ECL? It seems somewhat short sighted, given that you'll be splitting the people who use &amp; commit to ECL; Besides, as the second poster asks in the FTA, what is *actually* different about ManKai, in practical terms? 
*not to hijack the thread but:* I've always been curious if it would be useful to treat modern x86 machines in a manner similar to the low-level microcode that ran LispMs. * use a nano- or exo-kernel to paravirtualize the machine * design a fixed-set VM that implemented instructions as a fixed set of x86 instructions * allow the services that make up the OS to snap shot VMs &amp; check point them * use the underlying nano- or exo-kernel to allow multiple VM systems to run at the same time, like L4Linux or the like. You could build in nice primitives like W7 or the like and have a decently secure VM-based OS that could generically run most languages that share similar semantics out of the box (like, say if you used something akin to SECD). I've been playing with something like this using nasm, Linux &amp; now a custom kernel, but it's slow progress. Still, I'd **love** to have a modern, secure, multiuser LispM styled on the old systems but made faster, more secure &amp; updated to use current standards. 
Not to mention that this Jean-Claude guy is not an expert in thread-safety (while being definitely enthusiastic about it). He have asked a couple of question on comp.lang.lisp, and it seems that for him thread safety is just locking stuff down in right places. People tried to explain that it is more complex than that but I think it did not work. Well, simplistic approach of locking stuff does work, but it would be nicer if person who have decided to make the best multi-threaded implementation would understand how it works on low level up to hardware level so he could make it with least overhead.
Yep. This is a normal phase of the smug lisp weenie transformation process. [Movitz](http://common-lisp.net/project/movitz/) was (is?) one such project. And searching for 'sbcl os' on google will also turn up a project by one of the sbcl hackers. But, like you said, it's a slow process... made harder if it's only one man or woman trying to fulfill their Lisp Utopia
Yeah. I never really got that. It would be pretty cool to have a LISP system from the chips up, but for my day-to-day purposes, running Emacs + Conkeror with StumpWM under Crunchbang linux is close enough.
Definitely, although I would hope to have a range of languages available; I've other things running atop the current VM, and I wouldn't be unhappy with something like [es](http://code.google.com/p/es-operating-system/): JS, Lisp, Haskell, &amp;c &amp;c. :D
I think it's fairly obvious why he's chosen to fork it. He wants multi-threaded operation, and he's using it on two windows systems. ECL has gone through a period over the last 12-18 months where MingW support has languished due to the new garbage-collection, with people being told 'well, don't use windows then' or 'compile it without multi-thread support' as 'viable' solutions for the MingW builds not working. Given that this has gone on so long I'm not surprised it's ended up being forked. Presumably Juan isn't entirely open to fixing THAT problem. (The issue affected me initially, but I use an ECL built against VC++ and using a different build of the garbage collector that does built - even VC++ builds failed for a long time , so it's more a case of understanding where Jean-Claude may be coming from)
&gt; I think it's fairly obvious why he's chosen to fork it. He wants multi-threaded operation, and he's using it on two windows systems. Well, it certainly wasn't made clear in the initial posting. &gt; ECL has gone through a period over the last 12-18 months where &gt;MingW support has languished due to the new garbage-collection, &gt;with people being told 'well, don't use windows then' or 'compile it &gt;without multi-thread support' as 'viable' solutions for the MingW builds &gt;not working. Well, that would have been useful to know; I don't think it's too much trouble to list. Still, I haven't seen the issue, but then again I rarely use Ming. &gt; Given that this has gone on so long I'm not surprised it's ended up &gt;being forked. Presumably Juan isn't entirely open to fixing THAT &gt;problem. Or, he's, you know, working on other things that he deems more important. It's open source; unless there is an explicit rejection, I can't make or accept any claims about Juan's state. &gt;(The issue affected me initially, but I use an ECL built against VC++ &gt;and using a different build of the garbage collector that does built - &gt;even VC++ builds failed for a long time , so it's more a case of &gt;understanding where Jean-Claude may be coming from) Well, that's interesting. Did you post this anywhere that other people could use?
Close enough compared to being able to introspect, read and alter any and all part of the running OS and applications?
I'm on my phone currently so I won't be providing links but there's instructions on the mailinglist, perhaps even on the wiki, on how to get a multi-threaded ECL going on MinGW. IIRC it comes down to using a recent version of the Boehm GC. I've done it recently, with C++ support, and submitted patches. Browse the issue tracker if interested.
This can't be good. There are more candy bar kinds than candy bar companies!
Not a good analogy. A better analogy would be if there were more candy factories than people who eat candy. Having more Lisp implementations is not necessarily a good thing; at the very least, it's another #+impl to keep track of. You either force a good chunk of the community to expend mental muscle, or they give up, and resign to just supporting their favorite implementation .. I really wish he would keep it an experimental branch of ECL, with plans to merge later. Go wild, write "10 years" on a board, maintain #+ECL feature compatibility, work hard on the threads and let JuanJo port-back whatever he feels is stable. You focus on the parts that you wanna fix, and keep pulling the rest from upstream. No one needs to know it's a fork. More libraries, less implementations! 
Well, yeah. Conkeror's not there because it uses Javascript, and doesn't quite open everything up to you, but both Emacs and StumpWM are true LISP machines in the sense that you can reflect on, edit and recompile pieces without restarting them. There are also very few tasks in my day-to-day that require that kind of in-depth interaction with any part of the OS, so the fact that I might occasionally need to log out and log back in (a process that takes ~10 seconds) is acceptable.
There's what, a dozen at most lisp implementations? This subreddit has over 3k readers. I think we're ok. EDIT: Not saying this fork is a good idea or not tho.
&gt;you can reflect on, edit and recompile pieces without restarting them. (insert _M-x find-function_ &gt;Emacs C source dir: ~/ ? Doh!
There used to be a TI Explorer Nubus card for the Mac that I used to lust after, as a regular Lisp machine was waaay out of reach.
Hey, I didn't say "This is a perfect replacement for a pure, complete LISP machine in all situations", I said "[F]or my day-to-day purposes ... [it's] close enough". I'm aware that large parts of Emacs are written in C, but it hasn't bitten me in practice. Except for in this thread, I guess.
ECL fails at embedding itself in C programs, with callbacks to c functions. What I would have thought to be its main use-case. It's also poorly documented.
The glory days of 1985.
&gt; But even that was written in December of 2009, so god only knows if it's any help at all. Aside from Quicklisp, what has changed in the CL world in the last 10 months? 
The question is more, "What has changed in the libraries used by that tutorial in the last 10 months?"
How does one keep up on current developments in CL libraries? 
I should note that I was being way over the top when I said &gt; god only knows if it's any help at all. That tutorial is *certainly* of tremendous help. I don't think any of the libraries have undergone significant changes since it was published. If it doesn't run in its current state, it would probably fairly easy to update it. &gt; How does one keep up on current developments in CL libraries? Really the only way is to subscribe to the mailing list for each individual library.
Perl's CPAN has various ways to view recent arrivals, including [a recent arrivals page](http://search.cpan.org/recent). Python's PyPI lists most recent packages on their [front page](http://pypi.python.org/pypi). Does CL have anything like that? 
&gt; Does CL have anything like that? Nope. There are 2 sites in the CL community that would be good fits for that functionality, but it doesn't exist at present. http://common-lisp.net/ - hosts more CL projects than anywhere else http://www.cl-user.net/ - de facto catalog of CL libraries
Perhaps the folks working on Quicklisp will implement a simple central online directory that keeps track of available package/project metadata? 
Based on what I've read about Quicklisp, I get the impression that it only includes libraries (and specific versions of those libraries) that Zach has "blessed". (That's just my impression: I can't back it up with links. Also, it's still pre-1.0 software, and I don't know the post-1.0 plans.) I don't know whether Zach's goal is to have a central repository for *every* (or close to every) CL library available.
That looks so cool...
Here is a video demoing the tablet surface attached to the Lisp Machine. http://www.open-video.org/details.php?videoid=8076
just pre-ordered a copy on amazon and the expected delivery was nov 2
cruel!
The content looks great, the typesetting is dreadful. You should use courier or some fixed-width font to highlight keywords and acronyms, e.g.: "Using the Stealth Conditionals and and or" just looks terrible as is.
Hmm, studies providing, I may enter. Maybe run with Chicken Scheme to do something interesting.
lispdoc is great. I have this function bound to a key in my .emacs: (defun search-in-lispdoc () "Searches lispdoc.com for symbol under point." (interactive) (let* ((symbol-at-point (symbol-at-point)) (thing (symbol-name symbol-at-point))) (browse-url (concat "http://lispdoc.com?q=" thing "&amp;search=basic+search")))) (define-key lisp-mode-map "\C-cd" 'search-in-lispdoc)
The link is broken. Does it work for anyone else?
Wall-of-text'ed.
`#lisp` on freenode
"Garnet supports gesture recognition..." "...demo applications contain a complete graphics drawing program." "...allows entirely new widgets to be created without programming." So I know this is basically a sales video, and they're doing their best not to showcase faults/bugs and highlight their favorite features, but I'm interested. It looks pretty advanced for a toolkit put together in the mid-ninties. Has anyone done work with it? The project page says it's "no longer supported", but there's a sourceforge project. Anyone know what license it's released under?
How many people actually **use** ISLISP? I've used it a bit via OpenLisp, but I've never actually met or read about other people using it (other than things like thxmoo &amp; some other projects). It's a shame, since I think it fits fills the gap between Scheme &amp; CL.
Posting this as a follow up to the previous discussion, since the OP in that thread had asked for more info.
I can't find legal documentation for Garnet mentioned anywhere in its documentation. The FSF Directory lists it as Public Domain. http://directory.fsf.org/project/garnet/
Why is 64-bit considered an "enterprise-only" feature? In 2010?!
think of the world "enterprise" here as "we don't think this belongs in a trial edition", not "big and serious".
Thoughts thus far (having used it for all of 10 minutes): * loads faster than the previous PE on my machine * sweet, imports the "Recent Files" from the previous version * new icons * default font is still a bit ugly, but acceptable I like it. Plus, iirc, the previous PE had a four hour limit, and 6 has a five hour limit. Thanks again LW! 
I have to agree with you. Especially the 64-bit version is generally almost twice as fast on my MacBook Pro compared to the 32bit version. This should be true for all systems with Intel processor. One really wants to have the speed of the 64bit version as a default.
I could agree if the limitation was only on the trial edition, but the problem is, there are *three* editions: the "professional" one costs 1200€ and it is only available in 32bit. If you want 64bit, add another 2400€ for the "enterprise". "Professional" and "32bit" do not mix too well imho.
Because in this world of ubiquitous computing power, Lisp vendors have find new ways to stay irrelevant: the kind of power available in your average desktop machine is already far too high for numerous Lisp implementations to lag on, there is a risk that Lisps become an actual development option one of these days.
&gt; but the problem is, there are three editions 4 actually, Enterprise/32 and Enterprise/64 are separate editions, if you have to work on both 32 and 64 you have to pay twice.
Additional libraries for installing on Fedora 13 64-bit. su -c 'yum install gtk2-2.20.1-1.fc13.i686' su -c 'yum install gtk2-engines-2.20.1-1.fc13.i686' su -c 'yum install libcanberra-gtk2-0.24-1.fc13.i686' su -c 'yum install PackageKit-gtk-module-0.6.6-2.fc13.i686' 
If somebody has it running with a GTK+ interface, how about posting some screenshots? I would be interested to see how it looks on Linux/FreeBSD. Thanks.
&gt; if you have to work on both 32 and 64 you have to pay twice. Now multiply times number of developers then number of operating systems. I introduced LW to my workplace but I can see in environments with tighter budgets where these costs are harder to justify, especially where CL is being introduced amidst other well-established languages with history at the company.
Then negotiate with the sales guys from LispWorks. They have for example site licenses. The website says: ---- &gt; Volume discounts are available on request to lisp-sales @ lispworks.com . &gt; &gt; Site Licenses &gt; &gt; Contact us at lisp-sales @ lispworks.com for site license terms. Let us know your requirements: &gt; &gt; Number of seats, &gt; Number of installations, &gt; Locations, &gt; Platforms, &gt; Whether you prefer: &gt; annually renewable license with free upgrades (same fee each year) or &gt; permanent license with optional maintenance to cover future upgrades (higher fee in year 1) ---- 
http://img264.imageshack.us/img264/499/lispworks6gtk.png
http://lispm.dyndns.org/lisp/pics/lispworks-6-cocoa.png
http://nisbeth.dk/niklas/lisp.png Free software :) Interface :( _edit - I'm so sad I forget spaces when I lisp, leading to errors and :pop_
ftp://ftp.lispworks.com/pub/software_tools/downloads/lwper601/x86-freebsd/
Aye - x86, not amd64? Or am I missing something? Is it possible if I compile a bunch of 32 bit libraries?
You should be able to run 32 bit binaries on 64 bit FreeBSD. You just need 32-bit versions of the libraries that Lispworks depends on. I would be really surprised if there wasn't a compatability port or package for most of them.
Wow, very nice. One of the founders of this company was my professor in college. In Portugal. Nice to see us in the news for something that is not related to drugs liberalization. 
Using CCL without Slime triggers my gag reflex. :)
The point is that you have to be invested enough in the decision to apply CL at a large enough scale from the start in order to have that conversation and start seeing discounts. At the initial stages, something like CCL or SBCL looks dramatically more appealing (any platforms, any use, any number of developers). At that point, you probably find yourself making due and with enough familiarity with one of those systems that a commercial one becomes even less enticing. While I don't disagree with the general idea behind the Allegro or LW models, I think commercial CLs in general have not caught up with the times in terms of developer expectations. I have nothing against spending thousands on development tools. I think completely splitting 32-bit and 64-bit support is nuts. I think not allowing single-user discounts for multi-platform is just as destructive, especially when you're developing on one platform and deploying on another. (Like you, I'm a paying customer - I have my own personal licenses as well as at work).
Heh - initially looking at the title - I thought it was a single line of Lisp
Yes, I thought somebody had finally discovered the elusive writemeaprogram function.
I feel like I've been to a Phisp concert.
I would post screenshots, but they are so ugly I will better refrain. (My guess is that the ugliness comes from the fact that I had to install 32-bit GTK libs just to be able to run the thing, and it does not pick up my desktop theme; maybe the 32-bit compatibility libs suck, I don't know. But the ugliness goes beyond the default GTK theme). I also think Lispworks Ltd. are crippling their sales with this "64-bit enterprise" thing.
In general I agree with you, though I have personally no idea what kind of other pricing structure would let them continue their business. I'm not saying that there aren't other possible ones, I'm just saying that I have no idea what these are and what the various business advantages/disadvantages are.
Yeah, I figure that they know what they're doing in terms of surviving. I'd love to know more about why they haven't tried out these other licensing options/discounts.
Cannot connect to the server but ordered the book and pdf combo off of No Starch's website. This could be the coolest CL book I've ever seen. It's worth it for the first few illustrations alone.
I bought the combo (print+pdf) and from the first chapters, this book is amazing! It's very nice, funny and easy to read. The cartoons are top-quality. I think this book is a perfect companion to Seibel's PCL for a beginner. You won't need more to start learning and using Common Lisp.
It sounds like I'm still sticking to Emacs + SLIME and not regretting it for a second.
dreamhost, my provider, just had a random outage for an hour, but is back up again- it's fine now -Conrad
Hi Reddit- I'm Conrad the author. (aka drcode) The eBook version of LOL is out today and the paper books are starting to trickle out from the presses. I'd like to thank Reddit for all the buzz you've helped build around my book. (See coupon below) I'll be lurking in this thread today and tomorrow answer any questions about the book, or about Lisp in general. I'll even do my best to leave my "Smug Lisp Weenie" hat at home :-) The Coupon Code: 76738380768586 (ASCII for LISPLUV) This code gives a 35% discount on the Book+eBook combo on the No Starch Press site (http://nostarch.com/lisp.htm). It expires 11/3. This is the only discount code right now and I'm only posting it on Reddit and Hacker News. (FYI- If you just want the eBook, No Starch already has a 50% off sale right now across the board. If you only want the print copy, Amazon has a heavily discounted price already, for reasons that are mysterious to me. Oh, and if you've already pre-ordered, just cancel and reorder to get the discount.) 
I also bought the combo, but I've only had 15 minutes or so to peruse the ebook, on my lunch break. It certainly seems like a very approachable and fun to read book. If only [Siebels book](http://www.gigamonkeys.com/book/) had equally awesome illustrations... :-)
I am buying this book purely because I want to learn how to balance weasels on a rake. 
Thank you for taking the time to write this, I'll be buying a copy. Best of luck!
I heard an anecdote from a friend of a friend about Dreamhost from a few years back. Dreamhost would buy used, out-of-warranty NetApp hardware, then complain about its unreliability. When a drive would fault, they would take it out, *blow on it*, and put it back in, like a recalcitrant NES cartridge. Maybe they're better, now, but nobody I know who has used them has had an entirely positive experience with reliability.
I couldn't help but pre-order off Amazon. Hope your colorful programming book gets people into Lisp in the same manner why's (Poignant) Guide to Ruby got so many into Ruby. Beginning programming books are inviting when written in this colorful rhetoric. OReilly follows suit with their Klutz-esque Head First series. My question is this: I'm a CS major, but the concepts were implemented in Java. I would like to know where Lisp fits in my education (I remember there was a well known book that taught CS concepts in a Lisp like language (Scheme I think (parenthesis ACTION!!!))). Also, please don't mysteriously disappear off the internet.
Wish you posted this an hour earlier =p
Grab Practical Common Lisp (free on-line) and this book, and walk through a few chapters. No matter what, you should have exposure to more than just Java, whether or not you choose a Lisp. Once you can use the language and start to think in it, you'll be able to answer a lot of your own questions. Also... [The features of Common Lisp](http://abhishek.geek.nz/docs/features-of-common-lisp) [Reddit - Is Lisp a good language to learn first?](http://www.reddit.com/r/lisp/comments/cqctz/is_lisp_a_good_language_to_learn_first/c0uhok3) [The Nature of Lisp](http://www.defmacro.org/ramblings/lisp.html) [A Java XML solution versus a CL one from another redditor](http://bc.tech.coop/blog/050704.html)
Oh I thought you had been slashdotted/reddited/HNed :P
I found this post extremely compelling. Seibel must truly have nerves of steel to give that talk to that crowd, but it takes such a man to make a difference. I look forward to hearing the audio for this. As an outsider to the Common Lisp community it has always appeared that the language is stifled by internal affairs completely divorced from external influences like users, vendors, authors, etc. I am probably way off base, so I hope someone more knowledgeable will correct me.
I'm afraid that may be a bit of misleading advertising :P -Conrad
I actually suggested collaborating on a Lisp book right after PCL came out. He liked the idea, but made it clear that he wasn't interested in writing another book in the near future. I know *exactly* how he felt, now :-)
I've only had good experiences for many years and two hours after my first big website launch they have a major outage.
jpanest does a great job listing the relevant resources already, but I would recommend reading the comic at the very bottom of landoflisp.com to see what makes Lisp different from C#, Java, etc.
Well I wasn't into Java to begin with, so even a comic is enough to convince me to use a particular language :P
Well I'm not looking for language comparison. C#, Java, C are all in the same class of languages. I'm talking about the purely theoretical realm. Where does Lisp fit in all this ([also I think it was the book I mentioned earlier](http://mitpress.mit.edu/sicp/full-text/book/book.html))? Let me frame my question this way. The major theme in CS that I notice is this: take a mathematical concept and express that in a computable form. This expression should be understandable in a von Neumann architecture. There are many different notations ( FORTAN, C, JAVA, LISP) that you can use, but of course when you use a particular notation you subscribe to their way of implementing mathematical concepts. Lisp is based on functional programming (of which I'm still not clear on) and linked lists. However there are all these other concepts you speak of in the comic of which I am completely new to: macro, hot script, DSL, etc. These concepts seem completely detached from what I've been learning in CS, but that possibly can't be because programming is an abstraction of whatever they teach you in CS. Anyways, I hope in my rambling you can understand my new found awe for LISP and hopeful you can bring it down to earth for me and see how it relates to my teachings. Edit: Actually let me frame it better. Programming languages are something Software Engineers deal with and I just read No Silver Bullet by Brooks. Does those things that make Lisp special (DSL, macros, whatnot) simply tools that deal with accidental complexity or are they themselves an essential complexity inherent in computer science? Or is my understanding of CS and software fucked up and I should just take up whaling?
Programming languages is a legitimate field of research in CS and not just a software engineering matter. I think you may have an easier time thinking about this if you don't take the concept of a Von Neumann architecture (or a machine model like that) as primitive and look into the mathematical bases of languages. You should read up on the lambda calculus and its use as a foundation for programming (e.g. Peter Landin's "The Next 700 Programming Languages" paper for example). It turns out that you can develop a theoretical semantic foundation for a language (e.g. Landin's ISWIM) and derive an efficient machine for evaluating from that, which means there is a very deep connection between language features, machines, and logics. Since you've already found SICP, I also suggest reading a book that focuses on programming languages. I recommend reading [PLAI](http://www.cs.brown.edu/~sk/Publications/Books/ProgLangs/) (full text online) and see if that interests you.
I'm just not sure about this part: &gt;After lunch Peter Seibel gave a talk ("Common Lisp Standardization: The Good, the Bad, and the Ugly") about the context and history of Common Lisp's emergence as a standard. He talked about the pressure on the American Lisp community to not only consolidate their dialects to keep DARPA money flowing, but to beat the European Lisp community in the standardization process, enlisting Dick Gabriel and (indirectly) John McCarthy to subtly stall the European progress on what would become ISLisp so ANSI Common Lisp could be finished earlier. Wouldn't they have been stalling EuLisp, and not ISLisp?
Why do you prefer Emacs + SLIME over LispWorks?
&gt; what kind of other pricing structure would let them continue their business. That's exactly the problem; they're selling some that most people nowadays take as a sort of commodity: language &amp; development environment. The problem is that even the poorest, most shallow language &amp; development environment take time &amp; money to implement. What I *think* companies should do is be more like Franz: offer more services &amp; products other than the Lisp system. I've never in my working life heard more about Franz &amp; Allegro than I do now. I've had three clients ask if I've worked with various Allegro-branded products before, and people seem **really** interested in the company as a whole. The clincher for me receiving my last contract was the fact that I've worked with CL, Scheme, Prolog &amp; Allegro Graph before. That's a bit of a problem though, since it means that companies have to *invest* time &amp; money into doing this, and it's difficult to manage such a feat with limited cash reserves. LispWorks has KnowledgeWorks, so hopefully they'll start pushing that as some sort of competitor to Franz's stuff. Would be good for the market and good for the companies. My $0.02. :D
Awesome work! But is it really fair to call Common Lisp "minimal and sleek?" I think of it as about as messy as Java or C++, though much more pleasant to use.
I think that's a different approach. But LispWorks came from a larger company that had many products and which did consulting: Harlequin. They got into trouble, were taken over and were split up into several companies that could be sold/survive alone. One of the things was the LispWorks business, which looked like it could survive and be profitable. There was also the business of some tools ('Watson', ...) written in LispWorks. That was able to survive, too. Others died, like DylanWorks or MLWorks. So LispWorks comes originally from a position where Franz currently is and where Franz has been for many years - though the Harlequin business was more diverse and not all parts had a Lisp connection. Though there was some technology/expertise sharing for example in the various language implementations (a big part was the Postscript engine they were selling). Franz has been doing consulting for a long time, though I think the Semantic Web stuff is not that old - most of that is in Lisp. I have no idea how profitable the semantic web stuff + consulting is - Franz knows better, but I find their approach makes a lot of sense. Personally I would prefer to see the LispWorks guys being able to focus on their development environment, improve it and make it more accessible to more people. One thing I would think about is to have LispWorks be able to run on or build applications for the increasingly powerful mobile computers (everything from smartphones, to tablet computers, ARM based appliances, ARM based netbooks, ...). That might include more attractive prices, but that would only be one aspect. The other things: build a community of LispWorks users sharing libraries, have cool demo applications, have more libraries, sell libraries individually, have more more material for learning (tutorials, ...). Franz has more in some areas. LispWorks is a bit behind, though I personally prefer the LispWorks development system - especially because it runs native on the Mac and I'm a Mac user. Personally I would prefer if LispWorks would not add a side topic, but focusses on creating the best development tool for Lisp.
That's a lot to try to reply to... The short answer is that you seem to be interested in composability, which is a fundamental mathematical property of certain types of programs. In Java/C/etc composability is achieved through objects and encapsulation. However, there are lots of problems with this (the problems that the "Gang of Four" book tries to address.) Composability in Lisps (and related languages like ML, Haskell) is achieved via functional programming, which I would say is a much better way to compose different chunks of code together. Additionally Clojure lisp has "Software Transactional Memory", which goes quite a ways towards offering a new model for composition for multi-threaded code. 
Hard to argue with someone with your user name :) I'm talking of the core of Lisp, as envisioned by the 50-line evaluator created by McCarthy. This still exists in CL, and if you limit yourself only to non-destructive list operations, CL code is still very sleek, IMHO.
von Neumann's fundamental contribution was that "data is code is data". Fortran/Algol languages distinguish sharply between the two and induce a "harvard" architectural approach to software. Lisp takes that idea and runs with it. It would probably be most illuminative to cut programming languages into two segments: those that can handle higher-order functions without resorting to assembly or arcane hacks and those that can not. Lisp, haskell, f#/ocaml, etc all fall into to the first category; C &amp; Java fall into the second category, and C++ is doing its living best to make the transition. I suspect C# is in the first category as well. In general, I would categorize Lisp as a approach to handle complexity overall. Richard Gabriel has insightful essays regarding Lisp and large system software engineering.
That's a pretty epic music video. I have to say, I've never seen a music video for a book before. I'm going to remember it.
That was my thinking- The first time is always most memorable :)
&gt; But LispWorks came from a larger company that had many products and which did consulting: Harlequin. They got into trouble, were taken over and were split up into several companies that could be sold/survive alone. One of the things was the LispWorks business, which looked like it could survive and be profitable. There was also the business of some tools ('Watson', ...) written in LispWorks. That was able to survive, too. Others died, like DylanWorks or MLWorks. So LispWorks comes originally from a position where Franz currently is and where Franz has been for many years - though the Harlequin business was more diverse and not all parts had a Lisp connection. Though there was some technology/expertise sharing for example in the various language implementations (a big part was the Postscript engine they were selling). Didn't Harlequin kind of over reach though? I mean, the some of the stuff they were working on was kind of outside their general purview; Franz's stuff &amp; LW's KnowledgeWorks is *exactly* the "sweet spot" for Lispers, because it's something lispers have been doing for quite some time, but "everything old is new again": people are finding out what lispers have done since time immemorial, and now it's cool. That's at least why I think Franz &amp; LW can survive for some time. &gt; Franz has been doing consulting for a long time, though I think the Semantic Web stuff is not that old - most of that is in Lisp. I have no idea how profitable the semantic web stuff + consulting is - Franz knows better, but I find their approach makes a lot of sense. I don't know either, but I think it could be a very interested area to work in. "Document DBs", Graph &amp; Triple stores are finally coming into their own, and Franz leveraging their existing tech to fit into this is very neat to see. It's certainly exciting from my point of view. &gt; Personally I would prefer to see the LispWorks guys being able to focus on their development environment, improve it and make it more accessible to more people. One thing I would think about is to have LispWorks be able to run on or build applications for the increasingly powerful mobile computers (everything from smartphones, to tablet computers, ARM based appliances, ARM based netbooks, ...). Yes, this would be nice; Arm, Atom, &amp;c., &amp;c. are the "future" in many ways (look at the new experiments with Arm &amp; Atom servers, for instance), and it would be nice to see interesting work done there. I just don't think you can, for long term, hope to make money solely off of development environments; there has to be some other buy in. Now, what you mention here could be a very useful niche: develop multi-core ready apps in a nice language with a portable &amp; efficient run time. That would be a useful &amp; interesting niche for LW to focus on too, just like Franz &amp; it's focus on Semantics &amp; data storage (atop their existing tech). &gt; That might include more attractive prices, but that would only be one aspect. The other things: build a community of LispWorks users sharing libraries, have cool demo applications, have more libraries, sell libraries individually, have more more material for learning (tutorials, ...). Franz has more in some areas. LispWorks is a bit behind, though I personally prefer the LispWorks development system - especially because it runs native on the Mac and I'm a Mac user. I like LispWorks better on Windows, though I attempt to avoid Windows as much as possible; first, it was the first "heavy duty" CL implementation I used on windows, but I also like the style of the editor buffers, "find symbols", &amp;c. better too: more emacs-y, and less surprising than Allegro CL Express. &gt; Personally I would prefer if LispWorks would not add a side topic, but focusses on creating the best development tool for Lisp. Well, they already have a side focus; it's not as if KnowledgeWorks wasn't already in the picture. I just think they should "beef up" the marketing about it; it could add needed revenue, which would help improve the development environment too. Dunno though; I'd still like to see a "more modern" approach from LispWorks, as I think they could really pull it together. I think if LW &amp; the others (such as Scieneer) started working on *other* revenue streams, I think they could be just as successful at it as Franz is now.
Actually, I've never written a big program in Common Lisp. I mostly do scientific programming in a mixture of C and Matlab, with a huge amount of Emacs Lisp code gluing lots of things together. I did some consulting/contractor style work in what was called PLT Scheme while back (now called Racket), and I've written a few toys in Clojure. At the end of the day (and I know this is weird), I really prefer Emacs Lisp for pragmatic reasons. It is really easy to install anywhere (just install emacs) and, for the things I do most of the time, it is very well suited. Despite its clunky reputation, its still a fully equipped lisp, and I've built a lot of interesting things in it, like [full support for Clojure style destructuring bind](http://github.com/VincentToups/emacs-utils/blob/master/README.md), [an embedded stack language](http://github.com/VincentToups/emacs-utils/blob/master/with-stack.md), and [monads a la clojure](http://github.com/VincentToups/emacs-utils/blob/master/README.md), [including monadic-parser combinators](http://github.com/VincentToups/emacs-utils/blob/master/monad-parse.md). Anyway, my point is that Emacs Lisp isn't exactly elegant or sleek either. You are right that its all about how you use the language.
I don't know where EuLisp comes in, but Peter was describing the ISO Lisp standardization process, which culminated (a few years after ANSI CL) in ISLisp. One of Gabriel's successful stalling tactics was to trigger a debate over what it should be named. It took two years to settle on ISLisp.
Well, considering that both [CL &amp; EuLisp are influences on ISLISP](http://en.wikipedia.org/wiki/ISLISP), they both had to come before ISLISP was ratified (or at least been started in the case of CL). Per the Software Preservation Society's [History of Lisp](http://www.softwarepreservation.org/projects/LISP/), EuLisp started in 1985, and ISLISP was somewhat later. That's not to say that they are mutually exclusive; EuLisp &amp; ISLISP could have been worked on at the same time, much like how Guy Steele has worked on Scheme &amp; CL committees. 
I don't know if it will come through in the audio, but you could tell from Peter's body language that he wasn't really interested in getting audience participation right in the middle of his talk.
Harlequin had several main businesses, the PDF stuff was very important. It thought that the company was supposed to be a leader in programming language technology (not just Lisp, but Dylan, ML, PostScript, GC, ...) and leverage that. But they did some interesting Lisp stuff and employed well known Lispers for some time. For example LispWorks provided the Lisp for the NASA experiment with space craft autonomy. LispWorks also provided the Lisp for AT&amp;T ATM switching nodes. One of the reason for that was the LispWorks had a soft-real-time GC and it also had a port to QNX (which was used by NASA). I would guess that the KnowledgeWorks stuff comes from the AT&amp;T/Lucent project or from some other project. I doubt that it is widely used currently. I would think of more practical improvements/libraries/tools. For example make it possible to use the IDE to work with remote applications or develop a touch variant of CAPI. Make it compatible with the upcoming AppStore for the Mac, or whatever other Appstores there might be in the future. How important would be a concurrent/parallel GC? Maybe that would be important when the multi-multicore machines get common - like 256 cores or more on the desktop. Add a library for distributed CL. 
One reason would be that a lot of extensions don't exist for LispWorks and porting from Emacs to LispWorks' Hemlock-derived Emacsalike is a not-entirely-trivial undertaking. I wasn't impressed enough with previous versions of LW to make writing my own version of Paredit for LW seem remotely worth it.
&gt; Harlequin had several main businesses, the PDF stuff was very important. It thought that the company was supposed to be a leader in programming language technology (not just Lisp, but Dylan, ML, PostScript, GC, ...) and leverage that. Yep, I used Functional Object's OpenDylan for some time. I think this is the same problem though; it's tough to rely on sales of languages &amp; development environments. &gt; But they did some interesting Lisp stuff and employed well known Lispers for some time. For example LispWorks provided the Lisp for the NASA experiment with space craft autonomy. LispWorks also provided the Lisp for AT&amp;T ATM switching nodes. One of the reason for that was the LispWorks had a soft-real-time GC and it also had a port to QNX (which was used by NASA). Yeah, I've seen that before; that's what I said I agreed with in your previous comment: if LispWorks worked on *this* niche (improved environmental usage of LispWorks CL), that's another area of potential growth. It's totally possible. &gt; I would guess that the KnowledgeWorks stuff comes from the AT&amp;T/Lucent project or from some other project. I doubt that it is widely used currently. I don't know either; it'd be interesting to see though. &gt; I would think of more practical improvements/libraries/tools. For example make it possible to use the IDE to work with remote applications or develop a touch variant of CAPI. Make it compatible with the upcoming AppStore for the Mac, or whatever other Appstores there might be in the future. How important would be a concurrent/parallel GC? Maybe that would be important when the multi-multicore machines get common - like 256 cores or more on the desktop. Add a library for distributed CL. Definitely agreed; this is another niche where Lisp would fit nicely, and LW already has a reach. I was just pointing out one (KW) and you, another (extended niche dev tools). Therefore, we've already come up with *other* ways for LW to survive &amp; better serve "the lisp community".
Gonna buy it as soon as it's up on adlibris(a swedish online bookseller like amazon and they usally start to sell the book as soon it's available any where else), they have allready listed it on their webpages. Call me cheap but I don't have the money to order it overseas.
Don't you mean a Phi.... wait never mind.
I wrote a LispWorks wishlist sometime ago: http://lispm.dyndns.org/news?ID=NEWS-2005-01-07-3 maybe there are some things that should be added. What is your wish about KW? What should be improved?
You're cheap! :)
I haven't had a chance to use it as much as I have used Franz's tools, so for one, I wish there was at least a demo version (I've had customers buy it, but I would only maintain minimal influence over that code, unfortunately). That list pretty much hits everything I think about LW though; Have you sent it to davef?
Makes sense. Do you know how the inspection and debugging capabilities of Emacs + SLIME compare to LispWorks?
Not in depth; I never really familiarized myself with the debugger in LW, and I rarely use even SLIME's inspector. However, I did find the SLIME debugger interface with SBCL to be both fairly pleasant and very useful. 
I think I did that. Plus I was sending them this: http://lispm.dyndns.org/news?ID=NEWS-2005-04-30-2
I just bought the combo. I own two more lisp books, but this book has the most approachable first chapter. I hope to (after many false starts..) learn LISP programming with LoL :)
Wow, that's a good list. Of course, I'm not surprised that *you* of all people have a decent list of improvements to be made to Lisp implementations atop **any** OS. Also, the ILC presentation linked at the bottom of the page is pretty neat too. 
Garnet sources all contain the following on top of each file: This code was written as part of the Garnet project at Carnegie Mellon University, and has been placed in the public domain. If you are using this code or any part of Garnet, please contact garnet@cs.cmu.edu to be put on the mailing list. 
Hey, apologies for the late reply - haven't checked my reddit account in some time! Yes its Edward, is that Arjan? I'm very well thanks! How are you doing? I'm currently working at Erlang Solutions on a logging / testing tool. I remember discussing this briefly with you when I was in NL in fact - logging solutions in CL. The reason I asked the previous questions was mostly to find out how far things had progressed - its always interesting to know. :) Indeed I think that the generic function solution that you were using at the time was more than adequate for dispatching (i.e not requiring the use of filtered functions) - and as for Closer I'm not sure if that was being used at the time, from what I saw of BitAds I couldn't really tell. How is it going nowadays anyway? 
Actually, the ebook+print combo, plus the coupon and international shipping (I'm Swedish too) comes in at around 310 SEK, which is 13 SEK less than what Bokus lists just the print book for, and 16 SEK less than the Adlibris ditto. If you want to be cheap, don't buy it from Adlibris. :-) Besides, if you buy it now, YOU CAN READ THE EBOOK RIGHT NOW! Do you realize how awesome that is?! You're just minutes away from an awesome experience.
&gt; resurrected Bosco [No. No. Nonononnonononononoooo....](http://www.youtube.com/watch?v=31WScpBrz1E) 
Just brought mine with the discount.
&gt; and if you limit yourself only to non-destructive list operations, CL code is still very sleek, IMHO. Do you limit yourself to these in Land of Lisp? 
Argh! I've been wanting to learn Scheme first, but this book looks far too strange and wonderful to pass up. In general, how difficult is it to switch between CL and Scheme? How different are they syntax-/semantics-wise?
They're relatively similar. From a syntax standpoint here's an alright comparison between the two: http://www.cs.utexas.edu/~novak/schemevscl.html Semantics gets a littler hairier, but I think http://c2.com/cgi/wiki?LispSchemeDifferences sums it up somewhat nicely. Overall a lot of the concepts between the two are similar, and knowing one will help you understand the other. I also know that Land of Lisp attempts to teach not only concepts important behind Common Lisp and Scheme, but other Lisp dialects such as Clojure, Emacs Lisp, and Arc as well.
In my opinion, you should learn both because there are absolutely wonderful books that use these languages extensively. For example, How to Design Programs (htdp.org), Structure and Interpretation of Computer Programs, Essentials of Programming Languages, Programming Languages Application and Interpretation require Scheme while Paradigms of Artificial Intelligence Programming, Winston's AI and Lisp, Building Problem Solvers, On Lisp require Common Lisp. I've been using Scheme for around 3 years now, and Common Lisp for around a year and a half and I haven't had a problem "context switching". Both languages are really wonderful, and I don't think it'd be fair to pick just one :).
damnit, i didn't read the comments in time.
sweet!
Actually both of them are professors at IST. It's always good to see news from Portugal on reddit.
Gabriel has the talent to publish useful ideas at exact the wrong times.
Care to expand?
For example in 1984 the book Common Lisp the Language was published. It was the result of several people working for one or two years on the new language - including RPG. One could see this paper as bad marketing. Then he worked as CEO of Lucid, who sold the CL compiler that Brooks and others were working on. Generally it is not bad to publish a critique on something where one was working on, but it is probably not the best marketing when one comes out with a new language and is looking for mindshare. Generally the whole topic (of a new Lisp dialect) was highly controversial - there were many diverging interests. Older dialects were rendered obsolete (Franz Lisp, Lisp Machine Lisp, Interlisp, ...) and there were people who had invested into those...
This is exactly how *not* to do a critique. The basic questions to ask of any artifact are * Is the problem it tries to solve worth solving? * Does it manage to solve it? * Does it redeem itself with accidental benefits? Lisp had been invented/discovered in 1960 and the previous 24 years had seen much good work, developing practical dialects, writing big systems, feeding that experience back to motivate further language developments and getting ambitious on the back of having powerful language features. By 1980 it was clear that the divergence of dialects had served the purpose of its time. The Lisp language design space had been explored and there had been significant convergence on what worked and what didn't work. Which meant that there were various versions of Lisp doing roughly the same thing in needlessly different ways. It was time to reunify the various threads into a single, common Lisp. Back in, was it 1995?, I was trying to learn C++ and asked a friend how to do complex numbers. The good news was that complex number libraries existed. The bad news was that their were three to chose from. Presumably this is all sorted and there is a canonical way to do complex numbers in C++, but I lost interest. There is a language life cycle * new - the designers leave out complex numbers because they are in a hurry to release the first version * evolving - complex numbers get added in various difference ways * mature - a single way becomes canonical, perhaps because it is the best way, of perhaps because it gained most traction during the evolutionary phase, perhaps by being simple to understand even if somewhat unsatisfactory. The problem that Common Lisp was trying to solve was the problem of taking the step from *evolving* to *mature*. Gabriel briefly criticises the effort put in to specifying the branch cuts of transcendental functions of complex numbers. Elsewhere he is more explicit in denouncing this. He should have paused for thought. What happens if a specification, intended to create a mature language, leaves the branch cuts as implementation specific? Along comes Alice, who is trying to write portable code which uses transcendental functions of complex numbers. Version one trusts to luck on the branch cuts and has mysterious and subtle portability problems. Version two is a great deal more work. Alice has to write his own transcendental function library to ensure that the branch cuts are always in the same place. Now there are three libraries. Bob has the same problem. Now there are four libraries. What makes this worse is that Alice and Bob would be quite happy with any sensible choice of branch cut. They would look it up in the *specification* and write their code to work with it. Lacking that they independently duplicate the work of carefully specifying where the branch cuts go, without adding any value over just looking it up in the specification. One of the problems that loomed very large in the early eighties was bare pointers. Yes, pointers made C a useful and practical language, but it did involve poking holes in the type system and running off the ends of arrays. On the other hand the cure could be worse than the disease. Original PASCAL, with fixed size arrays, checked array bounds at compile time and avoided run time overhead at the cost of being unusable. From one angle, the Common Lisp array model looks insanely complicated. Not only is there the :displaced-to argument to make-array, but this interacts with adjust-array (which also lets you change the number of dimensions) and the interaction is carefully specified. However there is another angle on the matter. If you have done assembler or hairy C, you are well aware of the tricks that you can play with blocks of RAM. The same twelve location might be access as an two-dimensional array 4 x 3 at one place in your code, and as a three-dimensional array 2 x 3 x 2 at a different place. The problem that Common Lisp tries to solve here is best understood as a dilemma. Outlaw pointer arithmetic and people will prefer to use C so that they can use clever tricks to write really efficient code. Permit pointer arithmetic and the DoD will scream "No more fucking array bounds errors." and insist that you code in ADA. The Common Lisp solution is to provide a little domain specific language for telling the compiler the various ways in which you wish to understand a block of RAM as being an array. This is the magic key for understanding make-array and adjust-array. Common Lisp understands that an array is really just a layer of address arithmetic on top of a block of RAM and lets you tell it about the clever stuff you want to do. I'm not sure it is completely successful. I've not worked out how to tell the compiler "That adjustable array, I'm not actually going to adjust it within this dynamic scope, so please compile efficient code." But it does make sense. Most of his critique involves complaining that Common Lisp solves the problems that it sets out to solve, oblivious to the fact that these are real problems that need solving.
good comment
3600€ or 5,000 USD for 64 bit Lispworks "Enterprise" Edition? Wow. I'll stick to my CCL64 and Slime (with the excellent paredit, ido, cldoc) not to mention prolog-mode, erlang-mode, ruby-mode. And if LispWorks does things completely impossible to achieve with Emacs, that's fine because the other modes that are available on Emacs make is more valuable to me. 
Oh yes, you've made my day and stolen my weekend. I hope my Kindle does your cartoons (and my brain the ideas) justice. Thanks Conrad :D
to all those who upvoted this: could you please explain what the heck "Embedded Qt Lisp" is? I don't get it. the homepage (such as it is) says: "Embedded Qt Lisp: an ECL embedded Qt4 binding". what's embedded in what, and to what end? the wiki (such as it is) has more similarly unilluminating bullet points: &gt; overriding virtual methods does EQL contain some overriding virtual methods of whatever? or does it give the user a way to override Qt virtual methods? why is it important? &gt; no GC (but local Qt objects) what? &gt; no CLOS _what_?
[This might be useful](http://www.benzedrine.cx/planetwars/) for conveniently testing against bots you're actually playing against.
I don't know why this was submitted here (since it interests only ECL users). Qt bindings for Common Lisp are an exciting thing to have. Currently we already have good bindings, see CommonQt and cl-smoke. This one is embedded in ECL, and takes an overall quite direct way of doing things. Yes, there is no garbage collection for Qt objects (all of GUI objects in Qt live in an object hierarchy, and deleting e.g. a main widget deletes all child objects). For local Qt objects (mostly non-GUI), you can use a simple macro "qlet", similar to let, which deletes all objects at the end of its body. No CLOS: yes, Qt objects are not wrapped automatically, but you can easily override any virtual C++ method from Qt, using a simple Lisp funtion. Additionally you can add (fast) generic event filters. There are a few examples included, namely "Colliding Mice" (a ported Qt example), which demonstrate that EQL is quite fast, and could probably be run on mobile devices (since I don't own one myself, I didn't test this). All in all, it's not big, it's not slow (including startup time), and it has no external dependencies (the parser to generate the binding is quite simple and included). Any other questions? I'm happy to answer them (author here). [edit] oh sorry, you asked *upvoters*, and I'm not among them... :-)
&gt; Currently working on: (long-term!) - alternative editor (interactive, syntax highlighting, auto indent, paren-matching, auto completion, eval...) Don't do this, it will kill your project trying to beat Emacs and Slime ;)
thank you, at least now I understand what this is all about!
Erik Huelsmann is working on it.
Is there a concerted effort to improve the cliki software in general?
Seems like it's back up and running, with all of the changes preserved up to yesterday evening.
Not sure there's anything other than maintenance going on at the moment. The source code is all up at http://ww.telent.net/cclan/cliki.tar.gz though, so improvements are certainly possible if not probable.
For sure!! Being serious: a huge toolkit like Qt can't be used efficiently without a powerful completer (here: for QNEW, QFUN, QCONNECT, QOVERRIDE). Doing this using EQL is not difficult, for both Qt and Lisp offering sometimes even trivially easy solutions.
Quoting drewc (Aug 2010): &gt; cliki is horrible dead end code. I have a replacement in the works, but havne't had time to think about it, let alone work on it lately. Also, I use a GreaseMonkey userscript to make cliki.net look slightly prettier and fix some minor annoyances: http://abhishek.geek.nz/code/slicker-cliki/ *edit: link points to informative page with usable links instead of code repo that confuses browsers*
&gt; Also, I use a GreaseMonkey userscript Cool. &gt; fix some minor annoyances Which are those?
Changes include: * Bigger edit textarea by default * External links indicator * Truncate excessively long rows of pagination numbers * Aesthetics and accessibility — colors, borders, spacing Obviously there's a subjective element to it all, and I continue to experiment with the script. There is still a dozen more issues I want to address, too.
Are you being sarcastic bitch?
"You will need to provide a license agreement for your application which meets the requirements of both LispWorks Ltd (as in our EULA) and Apple Inc." Not sure what their requirements would be, but a priori, it seems like a bad idea to have an additional gatekeeper between me and my audience. Is LispWork's commercial agreement anything like Franz Inc's byzantine maze of targeted licenses?
&gt; Is LispWork's commercial agreement anything like Franz Inc's byzantine maze of targeted licenses? Not really, the only thing that could be considered byzantine regarding LispWorks is the notion that 64-bit is a enterprise license level feature.
Thank you! Ordering my copy right now.
&gt; Also, I use a GreaseMonkey userscript to make cliki.net look slightly prettier and fix some minor annoyances: http://gitorious.org/slicker-cliki/ I tried it, and it doesn't seem to do much of anything in Chromium.
Ah, wait, it seems that Chromium is overly eager at interpreting things as userscripts when in fact they aren't. As in, it will happily assume http://gitorious.org/slicker-cliki/slicker-cliki/blobs/master/slicker_cliki.user.js to be a script, even though it's HTML.
No comments...
a book
When my book arrives I will download them (context and all that). October 29th has come and gone and Land of Lisp is still not shipping. 
I have my digital copy though! NoStarch says Nov 3... 
Browsers get confused by the source view in Gitorious, and try to install the HTML page as a script. The direct link to the raw blob is: http://gitorious.org/slicker-cliki/slicker-cliki/blobs/raw/master/slicker_cliki.user.js Alternatively, clone the git repo and load the user.js file locally. I'll put up a better web page with that link and info soon.
I ordered mine today (11/2, day before the release). Do you know what the approximate shippings times are (I'm in South Florida, if that helps with the distance)? I'm dying to get my hands on a physical copy of this book. I'm only a chapter and a half in, but I already love the approach you're taking.
The script didn't change anything for me. Tried on both Firefox and Chrome. Strange.
Try this direct link to the raw blob: http://gitorious.org/slicker-cliki/slicker-cliki/blobs/raw/master/slicker_cliki.user.js Browsers mistakenly interpret the user.js source view page in Gitorious as the script itself. Use the link above, or clone the git repo and load the script locally. [More info](http://abhishek.geek.nz/code/slicker-cliki/).
&gt; Browsers mistakenly interpret the user.js source view page in Gitorious as the script itself. That was it. Works now. Thanks! BTW: Re. the character you use to display external links: It looks like stock Windows XP installations don't have a font installed that can display that character.
&gt; BTW: Re. the character you use to display external links: It looks like stock Windows XP installations don't have a font installed that can display that character. I wanted to use U+29C9 (two joined squares, ⧉) or U+2299 (vector pointing out of the page, ⊙), but I expected U+2B00 (northeast white arrow, ⬀) would be more portable. If you can suggest a suitable, portable indicator, I'll consider it. I'd rather not embed images or use even more colors for links.
Amazon says November 3 - 5 as the *delivery* estimate, but it hasn't shipped yet. Good luck with that one, Amazon!
&gt; If you can suggest a suitable, portable indicator, I'll consider it. Sorry, that's completely out of my area of expertise. :) If it's any help, [here is a screenshot of your comment](http://i.imgur.com/wpHS9.png) in both FF 3.6.12 and Chrome 7.0.517.41 on Windows XP.
Thanks for the screenshot. I've updated it to use U+2299, since that seems to work for you and every other machine I can test on.
Currently playing with it on omap 3. Quicklisp and slime work (slime was a bit rough). Loading and compiling stuff with quicklisp is a charm. Also, having a repl with a good FFI on the thing is great for doing embedded work.
I just downloaded the PDF -- the book is indeed great! Now waiting for the dead-tree version... :-) 
Interesting. Are you using a Beagleboard? 
No, a TAO3530. I wrote a driver in C and now interface with CFFI. Works pretty nice for a first attempt. It's a bit tricky that CCL does its own memory management. I map /dev/mem in the driver, and by stupid mistake, hit some virtual memory owned by CCL, which sent everything to hell.
I bought an electronic version of the book (didn't want to wait for shipping), and it's really fun. I'm up to chapter 8 (wumpus game), but I got sidetracked because I wanted to optimize the game (primarily using hash tables in appropriate locations as hinted at in the next chapter), make the output better (add colors, different shapes, show possible next states), refactor the code (remove the graph portions from core game, support arbitrary 'annotatations' on graph nodes like wumpus, blood, sirens), and to hook it up to hunchentoot to make this a web game (right now you need to refresh the png each time). I think it's a great sign when the book has cool projects that you can't help but keep tinkering on. (Practical Common Lisp had the same virtue).
cl-fad is incompatible with CCL 1.6, which causes a number of things to stop working: http://xach.com/tmp/cl-fad-fail.png I opened http://trac.clozure.com/ccl/ticket/771 for the issue, though it should probably be fixed on the cl-fad side.
They sent me email saying my pre-order was moved to early Dec. - I guess they just haven't updated their page.
Sorry about that- The books are at a No Starch warehouse already and in transit to Amazon as we speak- Hopefully the book will be "in stock" at Amazon next week. -Conrad Barski
This is inaccurate- My understanding is it will ship this week from No Starch and will ship from Amazon next week- Sorry for the delay.
Be sure to read ahead: The hash table discussion up ahead includes some code to optimize GTW, as you describe. Update: Should have read more carefully...I see you saw this already. BTW, if your GTW site is ever live I'd be happy to link to it! -Conrad Barski
\o/ ! That's definitely better than the Dec. 15 - 17 estimate I was getting. PS. Glad to see you are getting some good press over at Slashdot too
I assure you I have received email from Amazon bumping my pre-order to early December - that is absolutely accurate.
I don't doubt you got the email, others have gotten the same info. My publisher told me today that Amazon will have it in stock this Friday. I hope very much that Amazon will send it much, much sooner.
&gt; slime was a bit rough How so?
Slime didn't include the feature-check for :arm (which ccl doesn't yet include), so it warns on load. Additionally, the ssh setup on the devboard was a bit complicated so it took a while to set up the tunnel properly.
Wow, great job. You should better submit a patch to cliki itself. It is embarassing to point someone new to lisp to cliki.net. What impression one could get except that this is ugly.
Thanks. I would like changes like this to be incorporated into cliki. In fact, I had begun by modifying the cliki source tree, also fixing some bugs in the server-side code. But when I learned that the codebase was at the end of its life, the next best option was to collect the client-side hacks in a userscript.
Me too! I bought the digital copy to tide me over (it's great - thanks!) but I really like hard copy for programming books.
IMHO, it would be better to improve the CLiki instead of fixing it in such a strange way.
I agree, but it is not within my power. Drew Crampsie and the Tech Co-op take care of cliki.net. Drew wants to totally replace the old and very broken codebase with a new system, but I do not know when or how that will happen. Until then, there is no harm in tweaking things a little on the client-side.
If you could implement "live preview" of page edits similar to Stackoverflow comment preview I would call you a king :)
Hrm ... maybe I should get around to fixing up the ucw-cliki tarball he sent me.
[this old usenet posting](http://groups.google.com/group/comp.lang.lisp/msg/60f4c36a707db3fe) by Erik Naggum about CLOS is wonderful.
Excellent post! Thanks for putting it here. Required reading, no doubt about it.
That's it, as far as I know, there were minor issues left. But the ucw-cliki is also far from perfect, and probably improvements of the current cliki can be merged into the ucw-cliki.
While you can represent the board as a 1x9 array, it would probably feel more natural as a 3x3 array (thus simplifying x-coordinate, ref-cell, etc.). Also, I don't see a proper defvar/defparameter for *marker* or *player*.
The only value you pass to draw-board's numbers-p is t, so you can remove that variable and all its checks. This makes drawing the board easier: you can make it a single multi-line string and eliminate the ~% fuzz, making it much easier to read your graphics. In switch-player, instead of (if cond (setf x y) (setf x z)), you can do (setf x (if cond y z)). This removes the duplicate setfs. Just a style comment -- in play, your "(if (y-or-n-p" is not properly indented. It is nice to see some lisp code. :) Thank you for posting it.
Change (when (not ..)) to (unless ..) &lt;(when (and &lt; (not (check-for-win-p)) &lt; (not (stalemate-p))) &lt; (play t)) &gt;(unless (and (check-for-win-p) &gt; (stalemate-p)) &gt; (play t)) You don't need progn here, WHEN has an implicit progn in its body &lt;(when (check-for-win-p) &lt; (progn &lt; (format t "~a has won! " *player*) &lt; (force-output nil) &lt; (if (y-or-n-p "Play again? ") &lt; (play-again) &lt; (quit)))) &gt;(when (check-for-win-p) &gt; (format t "~a has won! " *player*) &gt; (force-output nil) &gt; (if (y-or-n-p "Play again? ") &gt; (play-again) &gt; (quit))) &gt; Here the OR before DOLIST is unidiomatic and incorrect since DOLIST returns NIL. MAPCAR with a predicate might be better. Lift the winning positions to its own variable, since it could be useful elsewhere. Don't hesitate to use functional constructs, either your own or stuff from libraries, like alexandria. &lt;(defun check-for-win-p () &lt; (or &lt; (dolist (x '((1 2 3) &lt; (1 4 7) &lt; (1 5 9) &lt; (2 5 8) &lt; (3 6 9) &lt; (3 5 7) &lt; (4 5 6) &lt; (7 8 9))) &lt; (is-line-p x)))) &gt;(defparameter *winning-positions* &gt; '((1 2 3) &gt; (1 4 7) &gt; (1 5 9) &gt; (2 5 8) &gt; (3 6 9) &gt; (3 5 7) &gt; (4 5 6) &gt; (7 8 9))) &gt; &gt;(defun check-for-win-p () &gt; (mapcar (alexandria:compose 'is-line-p 'car) &gt; *winning-positions*)) Or if you don't want an Alexandria dependency (defun check-for-win-p () (some 'identity (mapcar 'is-line-p (mapcar #'car *winning-positions*)))) 
You should also go ask comp.lang.lisp, they'll tear it apart.
`(when (not a))` is the same as `(unless a)`, yes.... However, `(when (and (not a) (not b)))` is _not_ the same as `(unless (and a b))`.
Try loading it on github, people can fork it to show you alternative methods.
Bonus: he would also get an implementation in Ruby there
Then (unless (or a b) ..) 
Sticking your head in the toilet and flushing is also a possible way to rinse off shampoo, but that doesn't make it the most ideal. 
That's basic De Morgan law. You can get the negation out if you toggle and/or. (not (and a b)) = (or (not a) (not b)) (not (or a b)) = (and (not a) (not b))
If you're looking for places besides r/lisp, no matter it's reputation, #lisp@freenode.net is a pretty friendly place.
There's a one-player Tic Tac Toe with AI in Touretsky's Gentle Introduction to Symbolic Computation which is very interesting.
* If you must use global variables, define them with defvar or defparameter before using them * Have CREATE-BOARD create and return a board. Don't set a global variable in the function. * (floor (/ x y)) is an unnecessarily long way to write (floor x y) * Write a setf function for REF-CELL instead of having REF-CELL and SET-CELL * I'd stick the choice validation and re-prompting in the read-choice function so that it always returns a valid choice * SELECT is a very generic name and doesn't clearly reflect what the docstring syas it does * Using a one-dimensional array for a two-dimensional board leads to all kinds of awkwardness * Recursing on PLAY is weird; better to have a loop that is something like (loop (when (or stalemate somebody-won) (return)) (take-turn) (switch-players)). But nicer. 
Bonus: works for real poo as well.
Amazon now says in stock on the 8th. (Monday) - My copy is now scheduled for the 10th!
Kind of a funny headline - "ECL now compile ECL-specific thing"
Thanks for linking my blog. The book covers Common Lisp and the commercial AllegroGraph product, so not too many people will find it interesting. That said, if you are into Lisp and the semantic web, please have fun with it :-)
Here's the webpage for the video: http://homepage.mac.com/svc/LispMovies/index.html#2 Source code: http://homepage.mac.com/svc/LispMovies/reddit.lisp.html The HTML generation it uses looks a lot cleaner than [CL-WHO](http://weitz.de/cl-who/).
It does? Looks similar to cl-who.
I'm interested in both, so big thank you.
Perhaps. There's a lot fewer `cl-who:str`s than I'm used to, but that could be solely due to how many explicit strings appear in the source.
Screamer is a work worthy of close attention. I played with it for the last two days and like it. There is an extension of it called SCREAMER+[1] which I have taken the liberty to mirror here[2] because it's original page no longer exists. However, this extension is not Free Software by any means. The license is "for non-commercial purposes". If you intend to do a clean-room implementation, please don't look at the sources. Better yet, it would be a nice if a domain specialist, preferably an academic can contact the author to request a more permissive license. [1] http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.6.6353 [2] http://mahmud.arablug.org/screamer-plus/screamer+.lisp 
If you have a lot of explicit strings in your CL-WHO, it's time to look into a templating engine, perhaps html-template?
Very abbreviated: 1. Write a bit of code in foo.lisp. Compile it with C-c C-c. 2. Poke at it from the REPL to see it works. Maybe write a test-case based on that poking in test.lisp. 3. Go to 1. Now, doing this has a drawback: maybe you wrote FOO and compiled it, wrote BAR that uses FOO and compiled it, accidentally deleted FOO, went to test BAR in the REPL and it was fine -- even though FOO was now missing from the sources it was still in the image. To prevent this, every once and a while get a clean image and reload everything you've got. The heavy-handed way to do this is to so ,restart-inferior-lisp in the REPL. There are softer ways but more things can go wrong with them, so I'll leave you to discover them on your own. How often is often enough? Depends. Anything from once a day to every 15 minutes could be a reasonable answer. Start with maybe once every couple of hours? Other things: * I also tend to write any non-trivial format strings in the REPL. * I use \*slime-scratch\* a lot. Add (setq slime-scratch-file "/something/scratch.lisp") to .emacs to make it persistent. * Learn to use the inspector in Slime. Make sure to use the fancy one. * Write PRINT-OBJECT methods for your classes: this pays off in multiple ways -- the REPL, the debugger, the inspector, and even plain old "sprinkle PRINTs around" all become more effective if you have good PRINT-OBJECT methods. 
I've been in touch with the original author of Screamer+. He was open re-licensing it, but needs to check with his old university first. We'll see.
Generally, I write **very** small bits of code at a time, then check them in the REPL. I also use DESCRIBE, INSPECT, and TRACE liberally. Not to throw yet-another-language at you, but you should read [Thinking Forth](http://thinking-forth.sourceforge.net/). The lessons there can be applied in the Lisp REPL as well.
Write programs as you would in any other language: oragnize your code in a file or files. When you start a working session, load the files into the lisp image from the REPL buffer (load, or require or asdf or whatever you like.) When you modify a function, evaluate it in the file buffer (C-x C-e) to load it into the running lisp, or compile it (C-c C-c). Use the REPL buffer to test things. Save your changes, use a version control system. Compile the entire system (in the REPL, using compile-file, or asdf) and pay attention to and eliminate all warnings. Start with that, read the Slime docs, and you'll develop your own working habits in time.
I am a lisp noob, too, but I use the REPLs for both Lisp and perl and have found the experience superior to my many years of experience with C and C++. Lisp is both compiled and interpreted, and you can definitely program Lisp with a code-compile-test-debug style, but a REPL provides you an additional tool that gets you information faster. Here are two reasons: First, it is easy to experiment with a single fragment or an entire function at the REPL. This is for more than just syntax; I want to know if my function is working. I can save these experiments in a test file if I choose, but I am able to immediately see the results of my dabbling. I do this all the time to make sure I understand what a particular function is going to return, be it mine or some other package's. Because I can do this in the REPL, I do not have to write additional code fragments that must be compiled into my environment and output at the right times. I do not have to run a long debug session that starts from the beginning of a program. The program environment is already live in my REPL as I code. That brings me to the second reason. You can have your program's environment live on the REPL as you code. You can see immediate impact from your new code. The Lispcast videos show a good example of this. You can start up your program's main loop (a webserver, game, whatever), add bits and pieces, change functions, etc, and see immediate results on your client (browser, game client, whatever). You can do this in the middle of operations. You are literally altering the code of a running program as it runs. You do not have to start over from the beginning of your program to see the effect of your new code. Last mental image here... Imagine you are writing a game. You want to test that a sparkly effect appears when you kill a boss. The game has a lot of data to load when it starts up. You then have to load your save point, get to the boss, and kill it. You probably set up special codes for giving the boss 1 hp or something to help yourself get to the point more quickly. But to just test some quirk of your sparkly effect with a code-compile-test-debug cycle, you go through this long process of setting up the situation. If you are running the game through a REPL environment, you make your sparkly code change, respawn your boss, and kill it. No waiting for load. No waiting for save point. Instead, you have an artist's luxury of seeing the immediate effects of changes, able to freely try things out. Here is the first of the Lispcast videos, which will show you a live demonstration of what I am talking about: http://www.lispcast.com/uncategorized/episode-1-humble-beginnings-2/ As you watch the video, keep in mind that this is not just an update of webpages. It is an update of code. For example, to get a new link to show up on a page without a link-adding interface, he goes to his REPL and pushes the object version of the new link onto his *links* variable. One browser refresh later, and the link appears. What he does in Hunchentoot, he can do with any system, including ones he is building.
Start with a small programming problem, break the problem down and write it from the bottom up since the lowest level code can immediately be tested. Write a function, test it at the REPL. When you're not quite sure how some built-in function works, and you're too lazy to read the documentation, test it at the REPL. For example, are the "start" and "end" arguments to "subseq" inclusive or exclusive? Evaluate (subseq "012" 0 2) to see -- you don't need to put it in your function and then test the entire function. See Marco's video here http://common-lisp.net/project/slime/#documentation for an example of this style in action. Check out PCL to get you up to speed on common lisp: http://gigamonkeys.com/book/. It sounds like a practical exercise (Chapter 3) might be a good place for you to start. Learn how to use the debugger/inspector: http://common-lisp.net/project/slime/doc/html/ Finally, check out On Lisp sometime for a philosophy of programming in lisp: http://www.paulgraham.com/onlisptext.html
I use emacs+slime, and instead of running bits of code in the repl, i run them from expressions in the file, with C-M-x. This works fine, with advantages 1) no switching back and forth repl/code files 2) the file contains a record of code you used to test/write the little bits, sometimes i move them to a testing file. (Though usually these are very partial tests, if i *really* want to test i usually try generate many random cases for it, and check some consistency.) One disadvantage is that sometimes i can't figure out how to stop a thread that won't end, where C-c C-c ends it if it were run in the repl.
Once my file is evaluated with M-x evaluate-buffer, I use a trick to test the function I'm writing. I hit a key that re-defines the current function (with my new edits), eval's it, and prints the output. So the cycle becomes edit, hit key, look at message, repeat. When switching to another function I change the testing function. (defun myfunc (beer yum) (+ beer yum)) (defun jmc-eval-and-test () (interactive) (eval-defun nil) (jmc-test)) (define-key emacs-lisp-mode-map (kbd "&lt;kp-enter&gt;") 'jmc-eval-and-test) (defun jmc-test () (message "out: %s" (myfunc 1 2))) So in the above, I'm editing "myfunc". I add a statement, then hit the keypad's Enter key -- the biggest key. Emacs prints "out: 3" in the message buf. Edit, hit Enter =&gt; another message. This technique is very fast, and can be recreated from scratch with five lines of easy Elisp. (lots of excellent ideas. I'm going to try Slime today!)
It helps to use fmakunbound when you want to delete a function (or makunbound, for a variable), so you can be sure you haven't left code depending on it lying around. You should still restart now and then to make sure your program is actually loadable, but you can go a bit longer without wasting doing that by unbinding functions when you want to get rid of them. I assume that's one of the "softer ways", but it's so useful I had to point it out.
ack...need to download **again**. 
I use Clisp / emacs / slime. I generally fire up Slime, open a second buffer (two buffs visible) allocating one to the REPL and one to my file. The REPL is used to experiment with how a certain command / set-of-commands will work, and for testing functions. Functions are typed in the file buff and compiled (C-x C-e) as I go. I manually test the various functions, recording the results in comment if the function isn't self-explanatory. That's about it - it's a very workable system for me, and imo superior to large compilers for test-on-the-fly coding. 
That's very encouraging. P.S. nsiivola, thanks for all you're doing. 
&gt; In other words, you have no idea what happens when you send a message to an object, how many arguments it needs to be happy or anything. (Much like many people in this newsgroup.) Pure gold. 
&gt; If you have a lot of explicit strings in your CL-WHO, it's time to look into a templating engine Nah. I think it's more a) a personal choice or b) a business choice, because non-programmers need to modify the templates.
Is it the parenthesis that turns so many people off Lisp?
dude, get a package manager.
parenthesis and prefix-notation…
That must be it.
This is really cool. Thanks.
I like my lisp like I like my Linux: Built from scratch by a team of Swedish nymphs in bikinis! 
It is weird that after awhile it is upside down. When I look at a non-lisp language all I see is all the stupid syntax getting between me and my program. Sometimes I wonder why anyone would even bother with anything but the most minimal of syntax. Haskell, Lisp and Concatenative Languages seem manageable, but something like Actionscript seems almost ridiculously overdesigned. I also wonder why syntax isn't just optional in most languages. If I can program in the parse tree itself (Lisp) then let me do it. Don't force me to jump through the hoop of your parochial little syntax.
I have my problems with languages that use a lot of funny characters, really arbitrary syntax design, character combinations of funny characters, where there is a lot of context dependency (switching between postfix, prefix and infix) with operator precedence and with languages where 'nothing' is significant (like whitespace or heavy concatenation of functions). I'm used to see expressions and also have these expressions bounded by ( and ).
It had the opposite effect on me. Using exclusively parens strikes me as elegant. Languages that use brackets and braces in addition to parens just create clutter. In fact, the use of brackets in scheme and clojure is a real turn-off to me.
SBCL is released monthly, most of the time. Put it in cron?
No no, didn't you hear? It's all Erik Naggum's fault.
I know the line noise in Haskell isn't actual syntactic sugar but it nevertheless is a real turn off to me. I'll manage some day though.
I would call Haskell's syntax sugary, but it is sugary primarily in that it eliminates extra typing rather than creating more. 
where's my slime :(
you bloody beauty!!! 
(not (it 's) (all that bad))
Writing Haskell is a bit like writing poetry. The flexibility allows you to create something really beautiful, or really ugly. Edit: Hah, this makes writing Java like writing end-user docs for 5 year olds.
I'm just starting with Lisp. For me it's mainly the prefix notation in arithmetic expression as I do a lot of numeric stuff. I guess it's just a matter of time until I get accustomed to it (I hope).
This is currently my favorite reddit/lisp post; I am eagerly waiting for you to post your revision of this code, given everyone's input. :)
For parenthesis, if you use a proper editor that understands Lisp, they become a non-factor. When I hear people complaining about parens, I think they must not have ever used Emacs with paredit which makes managing parenthesis a non-issue. For prefix notation, if you realize that mathematic operators like +, -, *, / are simply functions that take an optional number of args the design choice of prefix notation makes perfect sense. When considered this way, you see the kinds of elegant constructs like obtaining the sum or product of a list just by calling the appropriate function on an list numbers. Also, you don't have to learn a bunch of precedence rules like in C. 
Hmmpf ... had to recompile from source to include threading support. On OSX threading is only experimental. I ran the test suite and got approximately a dozen failed tests, all relating to threading. Not sure exactly what they mean but I really really want to use threads with sbcl and I dont have a linux machine at home.
via: http://ambientideas.com/blog/index.php/2010/11/clojure-refcard/
Thanks. Just in case you aren't aware, there is a subreddit for Clojure (named r/Clojure as you might expect), so please cross-post there. Edit: Oh my.. you're older than I am here. Respect and sorry for my hastiness.. :-)
I have a virtualboxed linux that I use to develop threaded sbcl apps on my macbook
SBCL threads on OS X are good enough light work. Definition of "light work" is nebulous, though... For personal use at at home, you're probably OK. For servers I'd make sure to have an external monitor ready to kick the process over if it gets hung. For end-user applications -- tricky. I think I know what most of the issues are, but haven't had time to address them yet. I hate to say it, but a bit of funding would go a long way there -- if a redditor wants to pitch in, feel free to contact http://sb-studio.net/. Don't take this the wrong way -- I'm not saying "pay or it won't happen". (The failures you're seeing in the test-suite are mostly related to thread/signal interactions -- but you can be bit by them even if you don't explicitly use signals, due to GC using signals to stop other threads.) 
In addition to paredit grab [parenface](http://www.davep.org/emacs/parenface.el).
It's a bot.
Linus is not Swedish, and it's not a bikini, but [here](http://www.pollsb.com/photos/o/6691-lt_a_href_http_en_wikipedia_org_wiki_linus_torvalds_gt_linus_torvalds_lt_a_gt.jpg) you go!
Oh for the love of &lt;Deity&gt;... put a warning on that. 
You could make a macro to give you infix notation for things like mathematical expressions. see: http://www.cliki.net/infix I've never used it so I cannot attest to its quality. But it is definitely possible to do. Incanter for clojure includes one as well that is quite nice to use, it's called $= or something like that (I mainly use cl).
I am oddly aroused.
haha really? I had no idea. Thanks for the heads up.
Haha. Not this time.
Adding infix notation to Lisp is not a difficult task. However, it's likely a better idea to work with prefix until it becomes natural. If not, then you can add the &lt;20 lines at the link below to your Clojure project and get runtime support: http://fogus.me/fun/unfix/infix-src.html :-)
Strategically placed "Parallel Lisp Systems" book. As if I need another reason to buy that book. Sigh. Here I come Amazon Marketplace. ;-)
I actually was just looking at that too. I had my wife use her university access to get some of the papers from the same author out of the ACM DL to sate my want of this book. I'm thinking of hacking some BaLinda this weekend :D *edit0*: wow, this paper is full of mistakes. You can use it to get a grasp of what's going on, but there are quite a few mistakes (missing params &amp; `cond`s). Yikes. Example: (defun Eval (Form Env) ; Env is in the params, but never used; Envstack is used henceforth, and as a dynamic language, I've no idea where it was defined, or just a mistake (cond ; ... (( = (CAR Form) 'COND) (Evcond (CDR Form) Envstack)) ; fine, looks normal... ; ...)) ; ... (defun Evcond (Condform Table Envstack) ;d'oh, Evcond is supposed to take 3 params, not two ;...) *edit1*: Still, I've implemented enough of BaLinda Lisp in a few hours to run the search example, kinda sorta. I'll fix `FUTURE` later, but it was dead simple in CL.
I can say something later about the book, when I'm back in Hamburg and have some time.
No worries; I was just curious about your thoughts on the matter, since I'd like to buy it, but not if it is mediocre. *edit*: I guess I should note that I PM'd lispm about this yestereve, and asked his opinions on the book.
If you please yes. I'll look forward to that.
Æh, I'm disappointed. I was expecting a theme that'd make my desktop look more like the LM's UI, not a wallpaper with a bunch of wires on it.
As a follow up, Amazon shipped it and I'm thoroughly enjoying the read now. 
If they need help with hosting, they should state that along with contact person, otherwise the attitude is completely unjustified. Solidarity is a human value, but it is easy to see that very few people acknowledge it today.
&gt; Your sense of entitlement does not translate into someone else's sense of duty. Sounds like an old-school Randian.
Ok, maybe "we don't give a shit" is a title looking for a flamefest, but I agree that it's a bad idea not to provide audio/video recordings in some form. If the objection is "but people PAY for the conference!", then I say: I would even *pay* for these videos, if that is the problem (I never go to lisp conferences because they are *far*, not because I am not interested). On the other side, I think that making these materials public would do a great service to the Lisp community, unless the idea is "we like it to be an old and esoteric culture and we don't care if the world forgets about us". Basically, these conferences have a paywall model. Wasn't that supposed to be a bad idea? 
The basic problem is this: many people whine about ALU being lazy. Few actually join and help them organizing the conference. A few old farts keep the ILC alive. Without them the conference would not happen at all.
I am not sure I understand the situation. Are the videos not being done because there is no one that helps with them, or because the ALU does not want that people watch the conference without paying for it? These are two very different reasons!
They could put selected videos online to make people interested for more. I think it is more the work to do it that makes it difficult. In the end there is just enough support to organize a conference, review papers and publish them.
**Parallel Lisp Systems, A study of Languages and Architectures** C.K. Yuen The author is from the National University of Singapore. The book is from 1993 and has 229 pages. The main contents are: * an introduction and some background about Lisp (70 pages) * BaLinda Lisp (49 pages). Lisp + FUTURE + Tuplespace. * Overview of parallel Lisp dialects (Multilisp, Qlisp, Spur Lisp, Concurrent Scheme, CmLisp) and comparison (30 pages) * BIDDLE, dataflow architecture (15 pages) * current developments * logic programming The whole book is kind of mixed up. The BaLinda stuff is interesting, some of the rest not so much. 
The over-arching idea looks interesting, but having read the "Self Interpreter for BaLinda Lisp" paper, I can see your "the whole book is kind of mixed up" comment as worrying. Still, it looks interesting.
D.herring has commented the original link that it actually is more of a copyright issue than a time/work issue. At least now it is clear what the real problem is, not that it is an uncommon one.. The actual question now is what can we do to help with the situation.. As has been pointed out, publishing material for local meet-ups is one alternative.. TC Lispers are doing quite good job with that, I think more should follow that example, as will I, as soon as I manage to get a meeting here. But still, we should further dig and sort this issue, well.. let's at least document the way things stand for the beginning.
There is too much filler material. It is for example not clear what the appendix on Logic Programming is for...
Yeah, I'm going to pass. I can probably find many interesting research papers on a similar topic that don't have filler. This is *exactly* why I asked you opinion on the matter :D
Jokes on "lisp" are as funny a joke on your surname. Yeah, never heard that, how funny.
&gt; If they need help with hosting, they should state that along with contact person, otherwise the attitude is completely unjustified. Just like the attitude resulting in cursewords in the very first post in the thread is completely unjustified.
Thank you for your summary. It seems that you've saved me some money. :-)
&gt;The actual question now is what can we do to help with the situation. Not much, short of reforming the ACM. It's their policies that are the problem here. Really, these days, the ACM seems to do more to hold back the dissemination of CS research than to promote it.
Yes, video and audio would be nice. No, no-one owes them to anyone.
Still beta. No news there.
Looks like cl-fad [hasn't been updated yet](http://bknr.net/trac/browser/trunk/thirdparty)? ("Last change: 14 months edi: Update to 0.6.3")
This looks really interesting, but I don't quite get it... Is the docstring being generated by a macro? If so, cool! I had no idea that could be done. I think this talk would really have benefited from some sort of recording
Same here.
Hmm, how exactly is a separate DEF-DOCUMENTATION form less prone to desyncing from code than a separate docstring? I can see how it being structured helps with generating a variety of output formats, but there's nothing to solve the fundamental problem of the code and the docs living in two separate places, with only manual synchronisation.
Nice development. So far, Common Lisp has been a second level citizen on Windows, and that might be one of the reasons it is not that widely used.
Where is the "don't believe Let Over Lambda" [1] part? :-) [1] in which earmuffs appear discouraged 
&gt; I had no idea that could be done. DOCUMENTATION is SETF'able, that's how.
&gt; there's nothing to solve the fundamental problem of the code and the docs living in two separate places the idea, as I understand it, is that given such nicely-structured way to write "docstrings", you'd have less incentive to write separate reference-type documentation in the first place. the need to write separate tutorial- or manual-type documentation is still there, though.
I understand this much, and to this end it's a very good approach. But the the problem is that you still end up with something similar to: (defun foo (some-lambda-list...) ;; Code goes here ) (def-documentation foo (docs-for-some-lambda-list...) ;; Docs go here ) There's still nothing tying `SOME-LAMBDA-LIST` and `DOCS-FOR-SOME-LAMBDA-LIST` together. They still need to be kept in sync by hand, and in fact it's now slightly worse, since the docstring is no longer in the body of `DEFUN`. **Edit:** I just noticed the "It's not where the docstrings are" note in the Problems slide. I missed it earlier, so at least it's acknowledged.
note that nobody's preventing one from shadowing DEFUN and friends such that they'll accept the hairy structured "docstrings" as well as the traditional ones. can't see that making much difference, but dunno.
That's not exactly what I had in mind. I was thinking rather of introducing a family of macros such as `DEFUN-DOC`, `DEFMACRO-DOC`, etc. accepting annotated lambda lists in place of the ordinary ones accepted by the usual CL special forms. This way the lambda lists and their docs would live all in a single place, and there'd be no possibility for them to get out of sync.
I mean in the sense that this was announced two weeks ago and got some discussion on reddit already.
There's also [RDNZL](http://weitz.de/rdnzl/), which provides Lisp &lt;-&gt; .NET interop on Windows. I was able to use it to create a "Hello World" program utilizing [WPF](http://en.wikipedia.org/wiki/Windows_Presentation_Foundation), which kinda blew my mind. (Though for some reason I had to recompile a RDNZL DLL to get it to work under .NET 4.) If anyone's interested, I could make the DLL available and try to track down the Lisp code I used.
Absolutely. Publicize that thing. Anything that makes entry easier is good.
He didn't really discourage them, he just didn't use them, and explained briefly how someone as *hardcore* as he is would never make the mistakes mentioned in this post.
A few caveats: * It turns out it's not a "Hello World" program in that it doesn't actually show "Hello World" anywhere. But it does display a blank WPF window. * It does so by manipulating WPF objects directly. XAML isn't used, and I don't know how to use RDNZL + XAML. * I did this as quickly and dirtily as possible. It's entirely possible I'm not doing things "correctly". * This should be a web page / blog post / wiki entry, but I don't have the time today to make it so. Onward: The RDNZL tarball comes with a RDNZL.dll that you need to "move... to a location where your Lisp's FFI will find it - the folder where your Lisp executable is located is generally a good place for that."^1 I did this experiment in LispWorks, so dropping it in `C:\Program Files\LispWorks Personal\` worked. While I could display WPF dialog boxes in .NET 4, creating a WPF `Application` resulted in an error: `Error: .NET error (System.InvalidOperationException): The calling thread must be STA, because many UI components require this.` The DLL in the tarball is built with an old version of Visual Studio. As a shot in the dark, I re-compiled the RDNZL.dll using Microsoft Visual C++ 2010 Express. I replaced the DLL in `C:\Program Files\LispWorks Personal\`. This eliminated the error. A copy of this DLL is [available here](http://waltergr.com/misc/RDNZL.dll).^2 The code follows. The easiest way to run it is to launch a Lisp implementation and enter the following.^3 (require 'asdf) (asdf:oos 'asdf:load-op :rdnzl) (in-package :rdnzl-user) (enable-rdnzl-syntax) (import-assembly "System.Windows.Presentation") (use-namespace "System.Windows") (import-assembly "PresentationFramework") (import-types "PresentationFramework") (let* ((win (new "Window")) (app (new "Application"))) (setf [%Height win] 300) (setf [%Width win] 300) [Run app win]) If everything works, a 300x300 pixel window will be displayed. Footnotes: 1 - From http://weitz.de/rdnzl/#download 2 - MSVC++ Express is free to download, so anyone can build a copy of this DLL. If you already have a recent version of the Platform SDK, you could probably use that as well. 3 - ASDF must be available, and RDNZL and its dependencies available to ASDF. The easiest way to do this on Windows is to install [LispWorks Personal](http://www.lispworks.com/downloads/index.html) and use Edi Weitz's awesome [starter-pack](http://www.weitz.de/starter-pack/). (Note that the current version of LispWorks Personal is 6.0.1, but I've only tested the above on LispWorks Personal 5.1.1.)
This is seriously cool since &gt;CL-JavaScript allows you to add user scripting to your Common Lisp application I'm just wondering about serializing the JS objects. Would something like CL-Store work? I could live without serializable closures (or coroutines or continuations...) though it would be great to have that too...
I wonder if this means there could be a Lisp backend for node.js that is faster than the current implementation of node.js. It would be interesting to see an optimization competition between the implementations, where the winner has the most reasonably optimized and most readable codebase.
This is especially cool considering the relative amounts of effort applied to the competing implementations - CL-JavaScript is only three guys (and the big CL hammer, granted).
&gt; I wonder if this means there could be a Lisp backend for node.js that is faster than the current implementation of node.js. FTA: &gt; The new generation (V8, Jägermonkey) beats it by, depending on the benchmark, a factor 4 or so. So not at this time (node.js uses v8), but I don't see why not in the future, given enough effort. I still think this is pretty cool *now* though.
True. With Common Lisp support, Windows finally has a chance of being used.
Very cool. I can't google up a copy though :( Where can I get one?
Two guys and one girl, that is.
I'd say that there aren't any spectacular improvements to expect from CL-JavaScript beyond this point -- the object system can be further refined, maybe the type inferer can be extended, but that won't buy is more than an additional, say 50% speedup, max. There are things that you can do when compiling to machine code that are just not viable when compiling to a high-level, dynamically typed language like CL.
&gt; There are things that you can do when compiling to machine code that are just not viable when compiling to a high-level, dynamically typed language like CL. but but but, with a *sufficiently smart compiler*... In all seriousness though, having masticated upon it, I think you're spot on. 
I see that sbcl compiles to machine code, and there are plenty of compiler optimizations one can use to give good hints to further reduce type-checking and so forth. I am not sure there is a significant enough limit to see a difference between the optimized compiled sbcl vs V8.
All serious CL implementations compile to machine code nowadays. That, however, doesn't mean user code has the same control over the code generated that you would have if you were generating it yourself. Type declarations help (and CL-JavaScript uses those), but clever machine-code tricks (to implement, for example, super-efficient inline caching) aren't possible.
Would be nice if it went for ECMAScript 5, since that's what all the modern engines are aiming for.
&gt;Ironically, very little documentation right now. 
Say what you will, I learned more about Lisp in 50 pages of LOL than in all other books combined. And I have them all, and I have read them all. The guy is a good tech writer. Period. 
That’s an interesting performance claim to make, but there’s absolutely zero information on that page to back it up. Faster by what metrics?
Load the system, load bench.cl, run the benchmarks in there. Or, download Sunspider or V8Bench yourself, run them.
The timing code in bench.lisp appears to ignore time spent during parsing, compilation, and execution of the top level forms in the JS file. Is the same true of the runs of SunSpider and the V8 benchmark that you’ve measured? Edit: If the numbers for SunSpider and V8 *do* include parsing, compilation, etc. then that’s a very impressive result.
Why not JSON?
CL-JavaScript compiles slower than browser engines -- the timing is just for execution speed. (Of course, with typical 'benchmark' code, compilation speed is hardly the issue -- these are small programs that do lots of work. The point is that you couldn't use CL-JavaScript in a browser. You'd be waiting 20 seconds before GMail's scripts were compiled.)
Thanks for the clarification.
If you have things you need low-level compiler support for, feel free to ask for them on sbcl-devel. No promises, but you never know... (Apropos: LOAD-TIME-VALUE is a great way to implement inline caches in portable common lisp -- dunno if you already use it, just saying.)
Thanks for the offer. I'm currently mostly focusing on Allegro (we're adding JavaScript scripting to AllegroGraph), but might at some point need to do some SBCL-performance-sqeezing. As for load-time-value, yes, that's what we're using, and indeed, it works pretty well.
You need to write a blog entry: "Using LOAD-TIME-VALUE for portable inline caches". 
True, though there are some photos of the LM is highres which might be worth it...
This is extremely cool. Keep up the good work. I had poked around UCW and Weblocks in the past and had given it up mostly due to lack of docs/tutorials.
[iTunes link](http://itunes.apple.com/us/app/pixie-scheme-iii/id401023057?mt=8).
Using (setf (fdefinition ...) ...) at runtime is not a sensible trick. Instead of using get-output-stream-string, use with-output-to-string. Instead of (string-downcase (string thing)), just use (string-downcase thing).
for me it is too much string stuff anyway...
Don't give up on UCW. An excellent tutorial is hidden inside wiki.lisp, the wiki demo application.
I wouldn't say give up on UCW either. And it's worth reading Felideon's blog on it if you're interested which I link to in the article. However drewc as far as I know has stopped using and working on it and he was, to my knowledge, one of the maintainers/main developers if not *the* main developer. There also hasn't been a post to the mailing list since July though there may have been commits since then. I don't track the source. It is a bit sad as UCW is one of the older and more successful lisp frameworks. It'd be nice to see some official statement as to where the project stands.
I disagree with the completely unjustified, self-appointed denomination of "utterly sensible". * First of all, why not use CL-WHO, which does all that already? * Second, as xach points out, the `(setf (fdefinition ...))` thing is awful, it should've been a macro. * Third, and a relatively minor problem is that the post itself manages to miss the mark in a few places, such as claiming that "you *cannot* use `(apply some-fn)`", which is incorrect in a subtle, but important way.
Pretty nice. Reminds me of running scheme on a Sharp Zaurus. Haven't played with it a lot but it is difficult without the Bluetooth keyboard.
Completely depends on the data. The data could be simple and the lisp program could be a one liner. Or...
If it's pure, regular text processing and you know perl already, it would be much more pragmatic just to use perl. You might not want to be pragmatic, however. In this case, how complex is the format you need to digest? Does it need a full parser, or just a bunch of regexp hackery? * If the latter, take a look at [CL-PPCRE](http://weitz.de/cl-ppcre/) * If the former, there are [many different parser packages](http://www.cliki.net/parser). I can't recommend any, however, not having used any. * Finally, you might want to write your own thing, if what you do is similarly complex to need more than just regexes, but not significantly so. As for the reading, it is slightly confusing, but ultimately pretty manageable. [WITH-OPEN-FILE](http://www.lispworks.com/documentation/HyperSpec/Body/m_w_open.htm) and [READ-LINE](http://www.lispworks.com/documentation/HyperSpec/Body/f_rd_lin.htm) should give you most of what you need.
In my opinion, the data is simple. essentially I am looking for either NODENAME: or PATHNAME:, after which I need to grab specific, similarly denoted fields of either. I'm pretty sure I could build a grammar (or something) from what I need to grab, but I've been unable to figure out how to define the grammar in the lisp engines i've found so far. I attribute that to my unfamiliarity with lisp
Thank you for the links. I dont think the format is very complex. Its even tokenized for me, and the fields are guaranteed to exist. I actually don't need much from the thing. But I feel that building one on my own is currently beyond me. I may talk like I know whats going on but I'm not just a newbie at lisp, I've never written a generalized parser. I understand that there are engines that exist where if I can define a grammar for what I want to capture, I can somehow gain access to what is grabbed programatically and the details start to get away from me about this point. Again, thanks for the links.
Yes, I'd use Lisp for this. CL-PPCRE etc. if needed; nothing fancy.
SPLIT-SEQUENCE is also useful.
HDTP and SICP will help not much with these tasks in CL. CL has a bunch of functions to read from streams: http://www.lispworks.com/documentation/lw50/CLHS/Body/c_stream.htm What you do is to open the file (see WITH-OPEN-FILE), then to go a simple way read the lines (see READ-LINE) and then break up the lines (for example with some SPLIT-SEQUENCE function from a library). Looping is done with LOOP. LOOP also COLLECTs the results. The you can think of what the function should do? * should it return the data in full? * should it be a mapper, such that a function gets applied to each csv data line in the file? That's basically it. The base idea is to start hacking, using a Lisp compiler, ... Look at the code you are writing then: Does it look elegant? Does it use many variables? Do you set variables all the time? Does it look imperative? Etc. Are the defined functions the best building blocks? 
the program might look like (with-open-file (in "file.txt" :direction :input) (loop for line = (read-line in nil) while line do (when (or (search "NODENAME:" line) (search "PATHNAME:" line)) ;; do the stuff: grab the data you want ))) I've written it just off head, you might find bugs in there. UPD: really, i've forgot to properly handle EOF. corrected
I disagree, even if you know perl; lisp is the better choice for text processing. First, although perl and ppcre are equivalent with text matching, we normally **do** something with the data afterward. Lisp has a simpler way of dealing with hashes of hashes, lists of lists, etc. $#something["blah"] is not exactly intuitive. Second, the set-based functions are very helpful. I need to create the union or intersection of two sets, **boom done!**. Third, the REPL creates a living, breathing conversation with your data. You don't need to reparse for every try, you can accumulate the changes as you go. Finally, you can output your data and functions in lisp to use later. Here is one of my favorites: (defun write-to-file-as-variable (var path data) (with-open-file (s path :direction :output :if-exists :overwrite :if-does-not-exist :create) (format s "(setf ~a '" var) (print data s) (format s ")"))) 
I've been using a combinator-based approach to handling text-file databases for years; it's simple to use and highly effective. I documented the system in three exercises on my [blog](http://programmingpraxis.com). The [first exercise](http://programmingpraxis.com/2010/10/19/text-file-databases-part-1/) gives functions to read records from a file in various formats, including csv. The [second exercise](http://programmingpraxis.com/2010/10/22/text-file-databases-part-2/) gives functions to process those records, including map, filter, and fold. The [third exercise](http://programmingpraxis.com/2010/10/26/benfords-law/) gives an example. There is also a lengthy [description](http://programmingpraxis.files.wordpress.com/2010/10/textfiledatabases.pdf) of the system including many examples. The code is in Scheme, not Lisp, but should be easy to port, or you may just wish to use the original in Scheme.
Lisp is funny in that, once you know it, you tend to create your own "X" instead of using someone else's. Take a recursive decent parser, you can use labels to create all the states, a variable to hold the function of the state you are currently in and another for the current match, and the body would consist of a (multiple-value-bind (state done) (funcall *state* (read-char stream))) So a recursive descent parser might be *more* complex. Then you write a macro around this basic parser and create your own "Build-Your-Own-Parser-Hobby-Kit". 
Check out http://www.cliki.net/SPLIT-SEQUENCE for quick-and-easy splitting similar to perl's built-in split. Also, you can learn a lot of manipulations here: http://cl-cookbook.sourceforge.net/strings.html 
Not to start any kind of language war, but you were mistaken on a few things. CL-PPCRE is faster than perl's regex, partly because of the compilation stage where the regex is converted to the parser. They are mostly equivalent in syntax (every new version of perl seems to introduce and obsolete a small family of extensions). Lisp's hashes are more correct and, depending on how you configure them, faster than perl's. However, perl's hashes are super useful, and once you get used to perl's concise syntax, they are easy to work with. Create a new hash reference: my $foo = { a =&gt; 1, b =&gt; 2 }; Get a: my $a = $foo-&gt;{a}; # or $foo-&gt;{"a"} Set a: $foo-&gt;{a} = 5; Hash of hash: $foo-&gt;{a} = {fruit =&gt; "apple}; Getting a's fruit: my $fruit = $foo-&gt;{a}{fruit}; Perl is line noisy, but let's not toss in random nonsensical symbols to make the claim. :) Still, Lisp is a language wherein you can easily build upon to do similar quick and concise expressions, defining your own syntax if you want, all in the name of readability. Perl has two repls of note: perl -d and Devel::REPL (the latter being the most useful, and bonus cookies for mixing). You do not have to reparse as you go. However, Lisp provides some other features (like trace) that perl's REPLs completely lack. But if I had the choice, I would still choose Lisp over perl for anything serious (for example, perl's I/O is slow), and once my comfort level in Lisp is good enough, I could use it for the one-off parsings, too. Disclaimer: I have personally tested differences in speed (of development and of execution) between sbcl and perl on tasks related to the OP's, so it would not do any good to say, "Oh, you get those statistics from those webpages with old versions of blah and blah." Both Lisp and Perl are pretty good languages. Lisp is much more what I would consider a real industry-level language. 
It's nice to know that ppcre is faster. That's another feather I can take to my boss when I use lisp! :) Well, my point for the syntax issue is that lisp just seems more accessible, especially when doing lists of lists of lists... As for the REPL, I had forgotten about "-d". Although I **love** slime. I do like perl, but I feel like I get more complex issues done more quickly with lisp. Then again, I am a little rusty with it. Although, for one-liners, you still can't beat Perl.
Lists within lists: my $a = [[[[[9]]]]]; $a-&gt;[0][0][0][0][0] =&gt; 9 my $b = [0, [0, 1], [0, 1, 2, [3]]]; # argh, commas $b-&gt;[2][3] =&gt; [3] # list in hash in list my $c = [3, {a =&gt; [5, 6]}]; $c-&gt;[1]{a}[0] =&gt; 5 Yeah, once the list is long enough, you get tired of all the commas quickly. 
&gt; I disagree, even if you know perl; lisp is the better choice for text processing. Unless you know perl and _don't_ know Lisp, which is the case here. In this situation the pragmatic choice is to use perl, which was designed for and excels at text hackery, however you slice it.
Lisp is so awesome that you don't need to know it to program in it. You are using it anyway, you **just don't know it!**
A hundred up-mods! This is an awesome example with, not only the Lisp example he gives, but everyone chiming in with examples from other languages in the comments. Good stuff! Check out http://programmingpraxis.com/2010/10/26/benfords-law/3/ to get straight to the meat, then back up (paginator) to see how he sets the stage first.
I do this sort of thing a lot, and my current go-to technique is outlined here : http://common-lisp.net/~dcrampsie/smug.html 
lol what?
Holy crap guy. Your site is awesome.
It doesn't really relate to the problem at hand, but I've been writing my own Lisp interpreter on and off over the last few weeks (I think I've rewritten it at least six times now), and even though it's gimpy, underpowered, and leaks memory like a sieve with a gunshot wound, it's been an incredibly useful experience.
Hey I tried to register for the meetup but haven't got an email yet. It's been about 35 hours. Anything I can do about that? Would love to meet the author. And other programmers interested in similar things.
lisp regular expressions [can be very fast](http://common-lisp.net/projects/cl-irregsexp/)
Why is sourceforge hostile? I feel like I missed some news.
Their CVS server is so old that "cvs export" requires special hoops for me to use it properly. And most of the projects I pull from SourceForge are so old that they haven't migrated to whatever other options SF offers. Their download interface is really awkward and it can be hard to find a direct link for something to fetch. You have to deal with mirror selection, interstitial ad pages, and other crap.
I'm not sure where the problem could be. But it's no worries... just show up. :-)
It's partly from Greenspun's Tenth Rule: Any sufficiently complicated C or Fortran program contains an ad hoc informally-specified bug-ridden slow implementation of half of Common Lisp. and from another quote, I wish I could find it. Something like this: I found that I had been thinking in Lisp all along, just now the computer can keep up!
looks better than SPARK/ADA.
Not any more!
now if only I could figure out asdf in clisp.
The docs on loop scare me. I'm having a hard enough time figuring out which words are expected by the api and which are supposed to represent variable names and when I'm supposed to specify when in my loop I want to fetch a line from the file. I am noticing that I'm still trying to figure out where in all these loops the data is going to land without resorting to globals, but I have faith that this paradigm shift is worth exploring. I think i'll revisit this when I don't have a work deadline.
I left out license info. I'll add the MIT license to each project tonight.
You might want to look at the [LOOP for Black Belts](http://www.gigamonkeys.com/book/loop-for-black-belts.html) chapter from Practical Common Lisp then. The Hyperspec, though wonderful and clear, can be intimidating for someone new to the language.
Well i'm working my way through that book now. Glad to know it addresses this!
Awesome! I just tried it out for the first time, and after 5 minutes of play deleted my manual /usr/local/asdf directory. Sent you $10. I'm a poor college student, but it would be sweet if you kept this up!
For one, he's doing way too much stuff inside the result of the macro. No wonder he couldn't get it working. Write some functions, then write your syntactic sugar macros.
I think you were downvoted because `it` and `all` aren't verbs.
Maybe to work around defvar's semantics, where it doesn't initialize the variable if it's already bound? But I think a better way to do that would be defparameter, not defvar + setq. 
Don't really like that sort of use, though. For one, \*earmuffs\* please, people using the macro don't necessarily note it. Secondly, i was under the impression that defvar/parameters are things 'more for compile-time' than run-time; that it'd be better to use a hash table here. A setf-able function (subway-line name) would be a tad more work though, although one can also make a with-subways.
Sorry, I missed this - what are you looking for? I linked directly to the PDF
Haha, s'all good. I was looking for an implementation.
Oh, the paper does have implementation stuff, but I dunno of anything pre packaged
Ok. Thanks.
So you're saying I should have a hash table from line-name to line structure in some global *lines* hash table instead of having a variable for each line?
Thanks, that does make a lot of sense. Is it bad form to introduce new variables using setf? (i.e. just do a (setf ,line-name (make-subway-line ...))) 
It's not bad form, it's undefined.
Thanks, xach.
Maybe. You wouldn't pollute the global namespace if defline was called a lot, and evaluating (defline *really-important-variable*) wouldn't cause problems as it would now. However, if you are really only calling defline a handful of times at compile time, and need to reference those line instances elsewhere in your program, I would think it would be better to use defvar+setq.
The trade-off is between "polluting" the namespace of special variables vs. ease of reference. Special variables are simply using the relevant package as a hash table mapping a symbol reference `lines:*foo-line*` to the value slot of that symbol. The alternative is using an explicit hash table, mapping the expression `(gethash 'lines:foo-line lines:*my-lines-table*)` Especially if this is a self-contained calculation, the convenience of global variables might be handy. Even in a library, the supply of packages to hold symbols is as practically unlimited as the supply of hash tables. The key advantage of special variables is that they allow re-binding that gets automatically unwound by the implementation. Which might or might not be needed in your application.
Essentially yes, but i guess it doesn't matter all that much if it is a contained situation. Easy of reference could be improved with [define-symbol-macro](http://www.lispworks.com/documentation/HyperSpec/Body/m_defi_1.htm#define-symbol-macro), but that'd defeat the point. (It would take the symbol again)
Why not use Kawa? It'd run circles around this.
I can't tell much from the site, but it seems Jawara has a different purpose: &gt;Jawara [...] is a light-weight Lisp programming language aimed for elegant embedded, distributed computing. Jawara interpreter is implemented on Java and runs on Android platform. Perhaps it has primitives to help with distributed computing? Still, nothing Kawa couldn't handle with enough elbow grease, but if Jawara comes out of the box this way, it might be interesting regardless of any other issues.
Now I have sticker envy. 
I don't leave reviews on Amazon, but I'll leave one here: This is a great book. Not perfect, but well worth having if you're learning Lisp or have a compulsion to read every Lisp book you can get your hands on. I very much liked the general organization of the book (power / symmetry / hacking / science). The author has also been very independent in both his explanations and some of his implementations, which gave me a new point of view and a couple "Aha!" moments. My only critical remark would be that frequently a chunk of code is presented and then an explanation provided for what it does, but missing was some explanation of a general strategy before starting - leaving the reader to determine the objective by assembling the steps. This was not always the case, but it did strike me as the one improvement I might like to see. Great fun, 4.5 stars.
Now I wonder what is "embedded, distributed computing." Is it related to buzzword-oriented computing?
not only does this embed distributed computing, but it does so *elegantly*. it scales the cloud into your phones, or something like that.
I wonder if we can order more.
No Startch Press added stickers to compensate for the delay, which is quite nice of them. Mine is still not here, though, they really underestimated the demand :(
Out of curiosity, what else is on your list?
what's the use, when you already have decent free alternatives like powertab (closed source afaik, and a bit dead) and tuxguitar (opensource) or GuitarPro if you want to pay for one.
This looks convenient. Two things tripped me up a bit, though: 1. Forgetting the final slash of the path creates a project called "lisp" in the parent directory, instead of what you intended. 2. "~" wasn't expanded. 
Bleeding edge SBCL has ~ working. 
I'm really liking the ASDF2 stuff, does anyone have plans for writing up an "ohh shinny" article beyond the documentation?
What does your school require as a result from your study? A project? A presentation? &gt; This is because I have yet to create a .lisp file. PCL does not explain it at all. Does it need some kind of main function? What? Once I create a file, how do I execute it? I could probably dope it out at a bash prompt, but at school I'm confined to Vista. For creating a lisp file... just create a file on disk and in your REPL use (load "myfile.lisp"). Now you have loaded your definitions and can play around with it. Your VIM mode probably has something to allow you to load the entire file/buffer or the current definition into the connected REPL. You can also try out [Quicklisp and quickproject](http://xach.livejournal.com/278047.html). As for a bash prompt, you can install cygwin on Vista. I believe CLISP will work this way. Main functions... Lisp is more a breathing thing than that. You build out little pieces that you try out and explore in the REPL/inspector/etc before continuing. An equivalent to other language's main() might be a file that looks like this: (defun main () (format t "Hello!~%")) ;; I am simulating an entry point by calling this at the top-level (main) When making a dll or exe or comparable, your particular implementation will probably allow for you to pass a function into a delivery method that registers it as the entry point. It's not really an important detail at this stage (unless you're trying to build an app right now). &gt; I'm really much more comfortable with vim (all right...kill me now...). I'm by no means a vim expert, but I do know more about it than I do Emacs, and new commands I learn for it somehow seem more intuitive for me. I also understand it has a pseudo-SLIME-like plugin. Would I really be missing something if I dropped Emacs? If Emacs is too much given your time constraints, try the free editions LispWorks or AllegroCL. You get your editor and a built-in REPL. Lots of people use VIM so give it a go and just worry about the language for now. Know that if you're serious about CL then revisiting Emacs/SLIME is in your future. &gt; I'm in Chapter 11, "Collections". I feel like I understand everything in Chapters 1-10. But I understand it in the sense of, "I know this is possible, and I know which keywords its involved with...hold on while I look up the exact specifics on how to use them." I've been telling myself that I should just keep chugging along, and that things would really crystallize once I went through the "Practical" chapters at the end. However, I'm still kind of uncomfortable about it. &gt; Related to that, I feel like it would be good if PCL had some kind of exercises to do. Any recommendations? CL can have an awkward initial learning curve. Choose targets/projects for yourself and try to build them out. ANSI Common Lisp has exercises but a strange coding style. Touretsky's Gentle Introduction book (available as PDf for free) has exercises. &gt; Over the summer, I read the first chapter of SICP. Last week, I read the first few sections of chapter two, and did some exercises (at the REPL) (in CL, not Scheme) just to make myself feel better. I have until May (and would be willing to use the summer too)...should I stick with PCL? Or read SICP first? PCL is more practical. SICP is a very good book. What do you want to get out of all of this? 
If you intend to learn Common Lisp, you should try to learn the basics of Emacs/Slime. It really is not all that difficult once your environment is set up correctly. I don't use Allegro Lisp much, but do have it installed. I don't have much trouble running Practical Common Lisp source code in my favorite Lisp, Clozure CL, so if you are having problems getting Allegro CL setup properly with emacs/slime (franz.com has code that for your .emacs config file that worked for my Mac OS X/Emacs 23/Slime setup) just install one of the excellent open source Lisps like SBCL, CCL, cmucl, or clisp. Since I don't know if your what OS you are using, I won't bother giving you my .emacs config file, but google will point you to several good ones. In all Emacs tutorials, of which there are many, C-x C-s (which saves a open buffer to file means Control-x Control-s. *note below M-x means Meta-x (meta key (ESC on my system) followed my the "x" key. Once you have your Lisp environment setup, open Emacs, * Type C-x 2 to split the emacs window in two * C-x o to get the cursor in the bottom window (buffer) * Once there, type M-x slime to start Slime/Swank server (REPL). You can type expressions here, functions, etc. You will also most certainly want to open a file, and write a program. * Type C-x o to get focus on top window (buffer) * C-x C-f path/to/a/directory/mylispapp.lisp Type a few expressions, a list, math expressions, whatever, etc. * Put the cursor after one of the expressions you just wrote: type C-x C-e to evaluate it. The result will appear in the echo area at the very bottom of the emacs window (just below your open REPL) * Enter a lisp function in your open file. Type C-c C-c to compile function. You will see the function name in uppercase letters in your REPL. Type C-x o to switch to REPL (lower buffer). Call the function. * Switch back to upper window (C-x o) and type another function. * Compile top buffer to file with C-c C-k. Emacs will ask you if it should save the file, type "y" for yes. Anyway, I think you should stop reading PCL until you figure out your Lisp environment. If *really* makes Lisp much more fun and productive. LispWorks is nice, but many still prefer Emacs/Slime. And since it is open source, and you can use one of the many great free Lisps, you would do well to learn it, if you want to learn Lisp. There are tons of great tutorials online. But get your .emacs file setup properly so that everything gets loaded, and you will be all set. [Bill Clementson's blog](http://bc.tech.coop/blog/081209.html) has some great info on it. You can even find sample .emacs files online and you can get an idea of what lisp hackers are using in the Emacs/Lisp environments. You can also find Emacs cheat sheets or make one yourself, which is exactly what I did as it help reenforce the learning of Emacs/Slime and Emacs commands. PCL is an excellent book, but there are tons of great books that also have short exercises, which I find help me. For example, as I knew several imperative languages before trying to learn Lisp, thinking the Lisp way, and using recursion didn't come naturally to me, so I do endless hours of short coding exercises taking apart and building lists. See [99 Lisp Problems](http://www.ic.unicamp.br/~meidanis/courses/mc336/2006s2/funcional/L-99_Ninety-Nine_Lisp_Problems.html). Lastly, I won't tell you not to read SICP as it is great, but as it is in Scheme, you might either apply the concepts to CL, or try the exercises in Common Lisp or just pick up another one of the several Common Lisp books that are available online in PDF form. Good Luck. 
&gt; This is because I have yet to create a .lisp file. PCL does not explain it at all. Yes it does. Reread Chapter 2 and skip down to the section titled "Saving your Work" and read from there to the end of the chapter slowly. In it, it also explains that while you are working in an emacs buffer of code (NOT the REPL, but when connected to an implementation of lisp using slime [an abstraction taken care of for you by lispinabox]), you can put your cursor on sections of the code you've written and send them to your implementation for evaluation. Emacs allows you to keep tabs of documents open. Some documents are special, like the REPL in SLIME. Others are mere text files that emacs knows contain lisp code (and helps you format them as such, as explained in chpt2). As you write code in the buffer attached to the file you've made (that you save periodically), you push functions or definitions to your REPL with a given command (again, see chpt 2). Then once you want to play with your data or functions or whatever, you can swtich out of the buffer of code into the REPL buffer in emacs and then play directly with your new stuff. Thats the gist of what's going on. Also, once you get emacs slime lisp up and running (likely with lispbox), the editor can prompt you for the necessary variables its looking for when you begin to write out a function you want to use. YMMV. Does any of this make sense?
I learned more about Emacs chords reading this than I have with the Emacs tutorial. I wish people would condense this stuff like you have more often. Thanks!
I would also say that learning Emacs is a long term project, so don't get overly hung up on all the different things it can do. Get the basic commands: new buffer, switching back and forth, copy/paste, jumping around; and put it on a post-it note near your screen. Get slime running because you can then do tab completion to explore new functions.
Check out [Slimv](http://www.cliki.net/vim) for slimey Vim &amp; CL goodness. Ignore people who want you to learn Emacs **and** Slime **and** CL all at once, focus on CL for now and save Emacs + Slime (it *is* good) for later.
Another great way to pick some up is to load up a program in your favorite language, and then type "C-h b". This will pop up a buffer with all keybindings for the active mode(s) and what function they're bound to. Press 'C-h f' and type the name of a function if you want more information on what it does.
or [lilypond](http://lilypond.org/) which uses scheme as it's backend.
**SICP and Practical Common Lisp** You should definitely do both, but i realize that it's not going to be feasible if you have time constraints for this independent study project. I think that if you do decide to tackle SICP, you should go "hog crazy" and read closely and solve all exercises. As someone who did that about a year ago, I can tell you first hand that you learn a great deal from the exercises and they are NOT optional! **Learning Common Lisp** I'm not an advanced user by any means, but here's some recommendations: * Graham's ANSI Common Lisp supplemented with [Chris Riesbeck's notes](http://www.cs.northwestern.edu/academics/courses/325/readings/graham/graham-notes.html) * Land of Lisp: very fun book that uses games to explain concepts. I think it goes great with Practical Common Lisp * Succesful Lisp by Lamkins: I wish I'd read this one earlier. It's geared towards beginners but makes a lot of things explicit.
It is more simple than you think. SLIME just sends lisp code to REPL as if you were typing it. Yes, you could ignore SLIME and do it via copy-paste. You do not need any special format of a file, it could send code even from any text file. So just create it in editor and start sending code with M-C-x. You do need to learn Emacs commands. Most commands can be entered in plain english. E.g. to open file M-x find-file &lt;RET&gt; file name &lt;RET&gt;. You do not need to learn Emacs as an editor -- it can be easily configured to work just like any Windows editor, most keybindings work. Try EmacsW32 for better out-of-box defaults. &gt; should I stick with PCL? Or read SICP first? It depends on whether you want to learn theory or practice :) There are people who like algorithms and programming language theory. There are people who like creating software. There are people who like a bit of both.
Again?
I have a question. Given choice between LISP and C++ which one would you prefer and which one is actually better?
Well Visual Basic 6 is better than both of them so you should probably use that. But seriously, it's Common Lisp, not LISP. Realistically, the one you have a better understanding of is the one that is better for making games.
But C++ is always known for it's speed which plays a crucial role in games. I'm sorry I don't know much about LISP, all I know is it's a meta-programming language.
All-caps for programming language names is out of style for at least one-and-a-half decades, and that includes Lisp. Lisp is family of programming languages, this screencast is about Common Lisp. All Lisps are exceptionally well suited for meta-programming, because writing powerful macros is much easier in Lisps than other languages for the very regular syntax that's the same for code and data. But that doesn't mean meta-programming is the only important feature of any Lisp. Most popular implementations of Common Lisp compile to native code, and the language has a couple of features to allow for heavier optimization than what's usually possible with dynamic languages. Therefore, it can be almost as fast as C++. Of course, if you're writing commercial games that have to be absolutely state-of-the-art, C++ is preferable, not just because of its speed, but also because it's the most popular language in games programming and it's thus the best supported by tools, libraries, and documentation. It's interesting to note though that Lua has in recent times become very popular for those parts of the games that don't need that much raw speed. That demonstrates that the advantages of a more dynamic and high-level language than C++ can be very valuable for games programming. So Common Lisp is potentially a language that can combine the advantages of C++ and Lua, and can also add some features that none of those have. In the end it's surely very true what greml1n wrote, the language you know better will also suit you better for writing games.
Thanks! I guess I had a bias when I read the part about loading function definitions from a file. I read it and thought, "Oh, that would be useful for when I'm tinkering around trying to make something work." But it didn't occur to me that it was a viable way to store a finished program, ready for execution :P And I'm in no rush to make EXEs or DLLs, so I'll worry about that when the time comes. If you're comfortable with running programs from a REPL, I can become comfortable with running programs from a REPL. &gt;Lots of people use VIM so give it a go and just worry about the language for now. Thank you. &gt;Know that if you're serious about CL then revisiting Emacs/SLIME is in your future. I'm all right with that. It's just that an unfamiliar language combined with an unfamiliar editor (and really, combined with an unfamiliar OS with respect to coding) is a bit disorienting. Once I have a better grip with Lisp, I'm sure I'll be much more receptive to learning Emacs. &gt; Choose targets/projects for yourself and try to build them out I tried that before, and it didn't go so well. But I think that now I know enough of the language to give it another go. I'll also be checking out the exercises you mentioned. &gt;PCL is more practical. SICP is a very good book. What do you want to get out of all of this? To be honest, I'm not sure. A number of factors convinced me to start learning Lisp. The people who were mentor-ish when I was first learning to program (in Python) are all Lisp fans. There's esr's quote about the "profound enlightenment" achieved with learning Lisp. And from what I've read and learned, I like it just because it's very likeable. I have no idea how much it will influence my career in the future. But for right now, I just want to see what's there. Right now, I'm working on fairly involved projects in Python and Java. Maybe I'll realize that some piece of them would be much better in CL. Maybe learning Lisp will just influence the way I write Python. Maybe it won't help me at all in the near future in any tangible, but will just be dang interesting and satisfying and change the way I think. I don't know. Again, thanks a lot for your post--it was immensely helpful.
Ah. I eat my words. As I replied elsewhere: &gt;I guess I had a bias when I read the part about loading function definitions from a file. I read it and thought, "Oh, that would be useful for when I'm tinkering around trying to make something work." But it didn't occur to me that it was a viable way to store a finished program, ready for execution :P So yes, now I'm squared away. Thanks. 
Thanks, that's what I'll be doing. It's very frustrating to be trying to figure out some code while having the environment be working against you. So for now, I think I'll be using Slimv + Vim (+ maybe Cygwin, although I just had the idea of putting Linux on a USB drive and loading it at school).
Glad to hear! I've recently begun the "99 lisp problems" (google it) challenge to go along with practical common lisp and land of lisp. Keeping the problems in one file as you go helps because at least for the first 6 or 7 you start to be able to re use the functions you've made to simplify your life. I will say that without the material in the first half of land of lisp I would have been hard pressed early in this problem set. Again, YMMV, but I found that being able to crank out simple elegant solutions on the first try to some of these was very encouraging.
Perhaps it will help if you take a look at these pages: http://www.endpointcomputing.com/articles/lisp.html http://www.algo.be/cl/myths.htm There is a lot of misunderstanding about Common Lisp... Those two pages try yo clear things up. In short: Lisp is not slow at all! With a good compiler (like Steel Bank Common Lisp) you will not only generate fast code, but you can even *interactively* see the native assembly code that's gnerated for your code while you optimize it. But remember: first make your program corect and your code clear, *then* optimize *only* what is slow (and some Common Lisp systems have great and easy to use profilers that will help you with that) You may also want to read a bit more about Common Lisp -- there are some great books out there: * *[Practical Common Lisp](http://www.gigamonkeys.com/book/)*, by Peter Seibel * *Land of Lisp*, by Conrad Barski These are basic books. There are lots of other books for more advanced topics. 
It is so encouraging to hold a brand new Lisp book in ones hands. It took quite a while to have it shipped here to Germany. The last ones that came out were Let over Lambda, 2008 and Practical Common Lisp, 2005, which is half a decade old by now. I do not know if this is much or little compared to other langs, but I personally could definitely gobble up more Lisp literature. ;) So while I am about to launch into Land of Lisp right now, I am also sorry that Nick Levine had to give up on his, also great sounding and promising, Lisp Outside the Box. I wish anyone a nice first Advent Sunday and keep on consing. P.S. I forgot the important bit, Danke Conrad!
It might be an interesting endeavor to clean up/expand the Common Lisp Cookbook. Even submitting a list of "how do you..."'s could probably go a long way towards compiling a lot of the knowledge it takes to be really productive in CL in one place. It's easy to forget how daunting CL was on day one (Emacs, SLIME, which implementation, ASDF, etc) and then after all of that getting to spinning off processes/threads etc. The nice thing about the cookbook is that it has the potential to be useful for more advanced users as well. That said, I have accumulated tens of Lisp books and I'd love for more recent ones to outnumber the ones from 20-30 years ago.
Thanks, I'll definitely take a look at them. 
&gt; It's easy to forget how daunting CL was on day one (Emacs, SLIME, which implementation, ASDF, etc) Yes! I think a hands-on Common Lisp primer would be great. Step-by-step instructions to getting your first couple of programs running, using third-party libraries, etc. The kind of thing that would't really go into a book (because these things are kind of volatile), but is still necessary for beginners.
I absolutely agree that the CL Cookbook could be a great resource, it seems that the mantainers have abandoned it.
swank-js author here (I'm ivan4th). I did this thing because I've got tired of using mozrepl for client-side js development. Another reason is that I wanted to learn more about Node.JS, so I didn't reuse [slime-proxy](https://github.com/3b/slime-proxy) but made my own swank backend in js instead. This thing can be used to develop / debug js with most browsers that can run IE6. Tried it with IE6+, iPhone, Chrome, FF, etc.
This thing has the potential to be huge in the Web Development world, thank you for putting your time and effort into creating this. I haven't tried it out yet but it will be high on my priorities that's for sure! And may I suggest to the OP cross-posting to /r/web_design? Not sure how many users over there use Emacs and such but I would bet that the ones that do would be greatful :)
I do like the Common Lisp Cookbook, but would also love something along the lines of O'Reilly's Ruby Cookbook, but for Common Lisp. Unfortunately, if something like this does ever happen, it will be in Clojure. (Not a dig against Clojure, just that it is *not* CL). 
I believe the CL cookbook is modeled after the print Perl one. What about the Ruby one do you want expressed in CL?
&gt;It's easy to forget how daunting CL was on day one (Emacs, SLIME, which implementation, ASDF, etc) As a CL novice...thank you! As helpful as /r/lisp [was for me](http://www.reddit.com/r/lisp/comments/ebvqz/some_dumb_questions_about_practical_common_lisp/), it seems like posts like that shouldn't be necessary.
From April 2008. No longer works with the current version of Hunchentoot, and doesn't specify what version of Hunchentoot it was written against. This line: (setf *web-server* (start-server :port 8080)) needs to be (setf *web-server* (hunchentoot:start (make-instance 'hunchentoot:acceptor :port 8080))) There may be more changes needed - I didn't look closely.
I guess this proves that Javascript is an acceptable Lisp? EDIT: I guess I have to add ;-) for the humor impaired...
Since I wrote these tutorials a few years back, and they're periodically posted to /r/lisp/, AND it looks like our server is down this morning for unrelated reasons, I suppose that I should explain myself here while you're waiting. ;-) In our basic AI class -- like many elsewhere -- we want our students to use Lisp, but our students don't know it yet. This means we typically need to spend the first N weeks teaching Lisp rather than AI and even then our students only have a tenuous grasp of it. And the weeks we spend teaching Lisp are weeks we don't spend teaching AI. If I was teaching a class solely on Lisp and functional style, I'd probably do it the traditional route: start with s-expressions and work my way up through functional style. This is how basically most lisp books do it (or *did* -- Practical Common Lisp is a recent exception). It's also how math treatises are written: fundamentals on up so you can see the beauty of the thing. I call this the Jonathan Livingston Seagull approach to coding: start by telling the students various guru meditations when they just want to know the [rule for a loop](http://www.conures.net/stories/seagull.shtml) (see fifth to last paragraph and on). The problem is that this is a horrible, horrible way to teach students rapidly to program in Lisp. Instead of starting with what students are familiar with, you're starting with what they are *least familiar with*. S-expressions. Functional style. Functions used as data in general functions. Extensive use of recursion. After many years teaching this way I gave up: at the end of the tutorial session the students appreciated the prettiness of the language (a-la math treatise) but still couldn't code at all in the language. So nowadays I do it backwards. I start with tutorials showing how to do exactly the same thing in Lisp that they've been doing in Java or C. Variables and declarations, iteration, function definitions, comments, data structures, style. The objective is not to teach what makes Lisp great, but to teach *just enough Lisp that you can program in it as if it were C*. In fact, if you make your way through the three tutorials you'll discover that they don't cover macros or (IIRC) closures. How could a lisp tutorial do such a crime? Easy: neither are necessary to the language to do some initial work, and I then cover these "real lisp" topics later in the class once the students are more comfortable with coding in the language sufficiently to do their AI projects. Aaaaand I never expected them to be used as general tutorials out on the interweb: they've got a very specific purpose. I suppose since these tutorials keep getting posted I might as well build a tutorial 4 which covers macros etc.
Two prominent misnomers: s/declarative/imperative/g "Lisp functions tend to take on functional form rather than declarative" and "[ a declarative style -- yuck ]" 
I read a pre-release version of this post, as we were talking about it on #chicken. It's good to see it here.
Is there a summary available, like what methods he uses?
He'll be writing a blog post about it.
Ever since I read about scheme2js I've been wanting to be able to write a website using Scheme for both the server and client-side code. The scheme2js authors have a system called [HOP](http://hop.inria.fr/) that is intended for this purpose, but I've never heard of anyone using it.. Is ParenScript maybe a better approach?
I congratulate the winner, Gabor Melis. He was a colleague of mine at his previous (non-Lisp) job. He tried to introduce Lisp in the company but sadly he got mostly negative reactions. So it was gratifying to present this article to his former colleagues. :)
Argh, half the article is about what programming language he used, half the article is background about the competition... not one paragraph about _how his program works_.
You do see SETQ being used to introduce variables in some articles and books though -- was this acceptable for some older pre-CL Lisps?
He does quite a bit of explaining in his blog post: http://quotenil.com/Planet-Wars-Post-Mortem.html
I, for one, welcome our new Lisp AI overlords.
Thankfully, he doesn't have that problem in his current job. He works on Lisp at Franz, Inc.
Congratulations!
I'm always astonished when they don't make any glaring technical errors in the reporting. Asking for a technical discussion is expecting too much!
To be fair, there's no way the reporter could possibly know that, it's written in Lisp after all.
Good point :)
I'm amused how there's nothing in his code that really unique to lisp (beyond a few convenience macros). His implementation could be ported to other languages without too much hassle. I think it'd be a lot more code in other languages, but it'd be definitely doable. If Gabor had been a python programmer he'd probably still have won. I keep seeing people making "Oh, well, lisp is good at AI" comments in other places, and it amuses me that Melis' bot didn't use any of the crazy flexibility that supposedly eases AI problems.
You can drop the "AI" part. ;)
What didn't work with (something like) this? yum install clisp 
i tried that, you'd think it would work, right? have no idea there isn't a single clisp package.. there is however a clips... wth is that? 
A quick google gave me this: http://pkgs.org/requires/clisp (don't have any CentOS machine running so I can't test this) Otherwise you can always download the source code and compile? I'm also sure that there are some nice make install packages that turns it into a rpm packages as I've seen those on many other platforms.
clips is an expert system shell. It is unrelated to clisp, except in the sense that it uses s-expressions for its embedded language. 
I've never really seen (common) lisp as an incredibly terse language. At least not compared to more modern languages such as haskell. Do you really think it'd be a lot more code in, say, python?
Start with [the source](http://quotenil.com/git/?p=planet-wars.git;a=tree;h=9aad7d1d4554824511420e5114acbde48312cda3;hb=9aad7d1d4554824511420e5114acbde48312cda3). The readme will tell you which three source files to browse. Be warned though, they add up to about 1500 lines of lisp with no colorized highlighting. You might want to download it first.
Here you go, As root, yum install readline-devel.i386 gcc As any user, wget http://ftp.gnu.org/pub/gnu/clisp/release/2.49/clisp-2.49.tar.bz2 tar -jxf clisp-2.49.tar.bz2 cd clisp-2.49 mkdir tools; cd tools; prefix=`pwd`/i686-pc-linux-gnu wget http://ftp.gnu.org/pub/gnu/libsigsegv/libsigsegv-2.8.tar.gz tar xfz libsigsegv-2.8.tar.gz cd libsigsegv-2.8 ./configure --prefix=${prefix} &amp;&amp; make &amp;&amp; make check &amp;&amp; make install cd ../.. ./configure --with-libsigsegv-prefix=${prefix} cd src make As root, make install 
If you're not dedicated to using clisp, SBCL is generally nicer on Linux with SLIME+Emacs, and you can get a binary at http://www.sbcl.org/
I am just dedicated to learning lisp sir, that's all. I'll give this bad boy a try since the repo that has clisp is all jacked up on the CentOS box. Thank you,
SBCL is certainly a lot faster, but unless you're already comfortable using SLIME+Emacs, the readline support in clisp makes it a much much friendlier REPL.
For that, I grab linedit for sbcl. Better readline support than clisp.
My experience is that code approaches a more "medium size" project, then Common Lisp starts to become terse. I think most (semi-)modern languages would have comparable LOC for a solution of this sort.
Down for me.
 C-x o
awesome, but shouldn't the right window also close?
I'm not sure what *should* happen, but in my experience with emacs, usually windows stay open. The Lisp image is not necessarily something you want to start and quit every time you want to evaluate something. C-x o switches between windows C-x 0 (That's a zero) will close the window you are in C-x 1 will close all windows except the one you are in You can find out a lot on how to navigate windows in the emacs manual under windows.
There are some things that your fingers will eventually learn so well that your brain can forget about and get on to more useful activities. These include buffer navigation/management commands. Besides the one Doors points out, which lets you cycle through which of the visible buffers is active, here are some others: C-x b ;; switch to a different buffer C-x 0 ;; (that is a zero) hide the current buffer C-x 1 ;; hide all but the current buffer C-x 2 ;; split the frame into two, horizontally C-x 3 ;; same but vertically 
The default binding for kill-buffer is "C-x k".
&gt; I'm not sure what should happen, but in my experience with emacs, usually windows stay open. Some windows will close automatically (for example in vc-mode the commit message buffer will disappear after you commit). Others, like git mode's file selection buffer (similar to dired), or the compiler output from building a project with CEDET, will remain open. In my experience, it's hard to predict which ones will stay open and which ones will close automatically, but after you use them a couple times you realise the decision had a very good (usually time-saving) reason behind it. I tend to keep 3 buffers visible for always-open tasks and 1 spare buffer for the ones I know will close afterwards.
The system this describes, GTFL, looks really neat. (I just went to go add it to Quicklisp, but it's already there. There's so much stuff now I forget what I've added and what I haven't...)
I assume you're using Emacs/Slime. I find the easiest way to work is: * First split the Emacs window with C-x o (As mentioned) * M-x slime to open a REPL in one buffer * Open your Lisp code in another (C-x C-f) * C-c-C- with compile a function * To evaluate a Lisp expression (you don't need to change out of current buffer) place cursor after the expression and C-c C-e * C-c C-k compiles and loads file (now C-x o to REPL and test code) Sounds like your are making it more complicated that need be. There should be no need to open/close windows, or switch in/out of Lisp mode. Hope this helps.
I've looked (somewhat briefly) at the NLP system this was developed for, and the output of GTFL is wonderful.
C-h t runs the tutorial and really is a helpful start.
Just started to read the book a couple of days ago. Take a look at chapter 7 where he describes the DOLIST macro. But the answer to your question is that cd is the current element in the list. So the body ie FORMAT is done on every element in the list or database in this case.
cd will be each element of ***db*** in turn. format will process the item, then cd will become the next item. This will go on until the list ***db*** is exhausted. you can imagine it to go somewhat like this. 1st iteration cd = (car ***db***) 2nd iteration cd = (car (cdr ***db***)) 3rd iteration cd = (car (cdr (cdr ***db***))) 
cd there is the **var** part of `dolist (var list-form etc` So basically `cd` is the variable that holds each element of **db**, as *thekcd* explains in his post
It's a loop variable: (dolist (x list) (....)) Is the same as: for x in list: ....
Once you're beyond trivial examples into large projects and real-world code, conciseness becomes less a matter of minimal syntax and average identifier length and more a matter of abstractive power.
Thanks for posting this. Here's btw. the link to the web site, including demos: http://martin-loetzsch.de/gtfl/
As others pointed out, the "cd" is the variable that will, on each iteration, hold each element in the list. I wonder if it would have helped if that line was: (dolist (compact-disc *database-of-compact-discs*) 
I wish I had better luck finding the function 'draw-call-tree' shown in Figure 1 of the PDF. It doesn't seem to exist in Babel2, unless I somehow missed it. 
Yes, thanks for that, by the way. Quicklisp, and GTFL work perfectly with CCL 64-bit on OS X. 
 Oh god, that's just nasty.
What are my other options?
The fine article offers a few good suggestions: use the CLHS for reference, use dpans2texi, print the dpans3 postscript files yourself.
Poorly worded on my part. What I meant was: Are there any other options for purchasing a higher-quality PDF? 
I don't think so. This problem is at least 10 years old. Erik Naggum [wrote about his experiences](http://www.xach.com/naggum/articles/3239756833803284@naggum.no.html) with buying from ANSI. I wish this project came to fruition: &gt; As a bibliophile I would so very much like to produce the last &gt; public draft of the Common Lisp standard in a nicer font and in the &gt; high-quality binding that I think it deserves. Since it is not &gt; going to change any time soon and we should try not to worry about &gt; its status as ANSI standard, I should hope there is a sufficiently &gt; large market that I am willing to take on the job of producing this &gt; book in a lasting and beautiful version.
My guess: Land of Lisp.
my guess too. but it doesn't show up in [Google trends](http://www.google.com/trends?q=Lisp)?
Planet Wars? :-)
My guess: Lisp-the-speech-impediment dwarfs any programming-related searches.
My guess: recent win in Galcon AI challenge and all the buzz around that.
In that case, wouldn't you expect to see a similar, if not bigger, spike around the time PCL was published? 
Long John Silver
Yes. That appears to be exactly what the graph shows!
Return it.
Found that out last year. I feel like there should be a blinking block of bold, red text warning you on the ANSI site.
wikileaks!
Beta, what do you mean? http://ccl.clozure.com/blog/?p=113
Release notes: http://trac.clozure.com/ccl/wiki/ReleaseNotes/1.6 Notably for Windows users, [Quicklisp](http://www.quicklisp.org/) now works. curl -O http://beta.quicklisp.org/quicklisp.lisp wx86cl.exe --load quicklisp.lisp (quicklisp-quickstart:install) To get a Lisp webserver running, then do (push :hunchentoot-no-ssl *features*) (ql:quickload "hunchentoot") (hunchentoot:start (make-instance 'hunchentoot:acceptor :port 8080)) (I didn't try it without disabling SSL.)
But is one book enough to push the rating so much? Probably, it can be a combination of the "Land of Lisp" and the Galcon AI challenge? But will this spike in popularity convert into more lisp developers?
Then that impact is really impressive... will this attention convert into more Lisp developers?
"...*now* works"? Quicklisp worked fine in CCL 1.5 for Windows, too...
Hi Zach. Thanks for Quicklisp. For me &gt; Installation fails on Clozure Common Lisp 1.5 on Win XP with 'Error: Could not load ASDF "2.009" or newer'. Updating ASDF to the newest version still results in failure. Details and a full log are available in the body of my message to the Quicklisp mailing list with the subject "Installation fails on Clozure Common Lisp 1.5 on Win XP". Last I heard was &gt; ...I hope to get a good test environment for Windows XP going this week and I'll try to reproduce and fix your problem as soon as I can. Thanks, Zach 
Sorry about that. I could not reproduce, it just worked fine.
In Clozure, you can do (load "http://beta.quicklisp.org/quicklisp.lisp")
Is the file persisted anywhere? (My Google searches unfortunately didn't locate the portion of the CCL manual where its `load` semantics are specified... The reason I ask is to make sure that using `load` like that won't make the following output from `(quicklisp-quickstart:install)` incorrect: To load Quicklisp every time you start Lisp, use: (ql:add-to-init-file) )
The quicklisp.lisp doesn't need to be persisted for Quicklisp purposes. It only grabs the rest of the system and installs it. You never need to load it again.
Cool, thanks!
No, but Quicklisp is a step in the right direction. The next step is probably standardizing libraries and documentation. :bordeaux-threads =&gt; :threads :cffi =&gt; :ffi :usocket =&gt; :sockets :hunchentoot =&gt; :http-server :clusterfuck =&gt; :gui etc. with a release strategy to ensure that everything plays together nicely, and easily accessible documentation for each one. Zach's Quicklisp already gives the community a sense of central organization. Inclusion into Quicklisp gives him some say in how systems are put together and maintained (http://blog.quicklisp.org/2010/11/devils-guide-to-quicklisp-projects.html). I don't think it's too far of a stretch to turn that into a very minimal-standardization effort that could at least result in a core set of "blessed" libraries. Zach could pick a couple people to do the dirty work, and assume the position of "not-particularly-benevolent dictator" to ensure that the process doesn't get hung up on silly issues. This would be really nice when attracting new users, and would even be nice for more experienced programmers. Case in point #1: pretend you just picked up Common Lisp a few weeks ago. Try to build a small program that parses small xml files. Time how long it takes you to find the right library (there are several). Case in point #2: pretend you just picked up Common Lisp a few weeks ago. Try to build a web client. Time how long it takes for you to discover "Drakma". The best part is: once a set of libraries are "blessed", maintenance and improvements to those libraries become more of a community issue, which leads to less duplication of effort, and more work on the core. For example, imagine in the distant future, a single lisp system called :gui. Since it is the obvious standard, programs are written in it. Since programs are written in it, people seek to make it easy to use, and make it run well on their platform. Eventually, it receives so much attention that it flawlessly compiles to the native toolkit on Windows, OSx, GTK, Qt, etc, using beautiful code.
Yep, the idea sounds great. I hope it will be a success.
standards for everything! centrally defining THE right solution, "blessed" libraries... hell, i hope you'll never get close to politics! :) if something is needed then it's a regularly updated cookbook with the 1-2-3 best recipes for a given task, not a standard nitpicking about the curviness of cucumbers used... and certainly not :usocket =&gt; :sockets!
Well how do you find this cookbook?... I guess it would have to be in a standard location... And how would you find the entry about http servers?... I guess it would have to have a name like "http servers"... And how would we decide who gets to post the 1st, 2nd &amp; 3rd best recipes?... I guess it would have to be curated by a person or a group of people... Finally, what is a library if not a "regularly updated cookbook with the 1-2-3 best recipes for a task"? In the end you really just implemented my solution all over again, albeit in a slightly more roundabout and less future-proof fashion. The only difference is, with my version, the computer can read it too.
WRT the ability to load from an HTTP URL, it is mentioned in the 1.6 release notes: &gt; cl:load uses a primitive built-in http client so that it can load files from a url, e.g., (load " http://beta.quicklisp.org/quicklisp.lisp") 
Decent idea, horrible execution.
oooh. that never got answered. Going to read the book and report back. BRB
I enjoyed it very much. 
Question: is Lisp really THAT good at controlling bugs? Edit: Downvoting without giving an answer. How infantile and yet not unexpected.
Best book about game programming in Lisp by a medical doctor in 2010!
finals this week after that I'm diving in
Thumbs waaaaay up. Honestly, the last time I had that much fun while reading a programming book was a BASIC programming book with lots of games I worked through when I was 8 years old on my Atari 800XL.
I actually bought it "for a friend" for Christmas. He is always asking about "learning to program" but really isn't a computery-type, although he does like math. When I saw LoL a month or two back I figured it would be perfect for him. I'm going through it now so I'll be ready to answer any questions. The book is definitely more "readable" than most other programming books, the style is quite funny and as someone who already knows quite a bit about programming, I feel like I'm picking things up pretty quickly. I'm a developer, but as someone who has never done Lisp before I'm realizing LoL probably isn't the best for complete newbies. The author does spend a bit of time comparing Lisp idioms to those in other languages, which makes me feel that a lot of that content will go over some folks' heads. Like I said, I've never done Lisp before, and while the REPL is great, I feel like I ought to take a sidebar from the book and learn Emacs (SLIME) just so I can actually "save my work". This obviously isn't really a fault of the book, but I keep waiting for the transition between "playing in the REPL" and "writing real programs". Perhaps my brain just is broken from all these years with C-ish languages and their tools?
Best comment made by a redditor within the last two hours in r/lisp about a thread concerning a book about game programming in Lisp for 2010 for 2010! (sorry, I couldn't resist - how many lisp game books are there?) :( (ah, the post's been edited.)
&gt; When I saw LoL a month or two back Has *Land of Lisp* already usurped the "LoL" moniker from *Let Over Lambda*?
Are LoL and LOL distinct?
*Let Over Lambda* has been referred to as both LoL and LOL for some time. http://www.google.com/search?q=lol+\"let+over+lambda\" Even if it weren't, in situations where the name is lowercased (URLs, Lisp package names, etc.) or no distinction in casing is made (Google searches, etc.) the "namespace clash" is even more problematic. EDIT: I propose LaoL for *Land of Lisp*. EDIT2: Er, I guess LofL makes more sense. LoLi is right out.
A friend bought me the pdf as a birthday present after he heard that I want to learn Lisp. I am working my way through it and are busy with chapter 8 at the moment. Its a great way to learn the language and I am having lots of fun with it. Thanks for a great book.
Just in case, [here's](https://github.com/ivan4th/xml-match) my matcher that can be used for web scraping too. Another one is [cl-xmlspam](http://common-lisp.net/project/cl-xmlspam/), didn't try it, but looks good, though it uses more imperative approach.
The book is really nice; as others have noted, it's funny and instructive in a way that brings me the good feelings of my Commodore days :-) However, yet another explanation of what is a list is not very useful to me personally. This is obviously not a critic of LOL, I just hope that, now that finally there are some very good introductory lisp books, someone will write some more advanced ones. 
I just finished reading it a couple of days ago and it's very good. I was thinking of making a more detailed review when I have a bit more of free time. But if you're wondering if you should read the book, my advice is yes! It is worth reading it :-) 
Zach Beane writes: &gt; Unfortunately, SBCL 1.0.45 and newer [have a compiler bug](http://thread.gmane.org/gmane.lisp.steel-bank.devel/15480) that interferes with building CLX. 1.0.44 does not have the problem; if you want to use CLX or projects based on it (e.g. McCLIM), you should avoid 1.0.45. http://blog.quicklisp.org/2010/12/december-quicklisp-dist-update-now.html
Ok, this may not be the forum for it but I can build SBCL fine on Ubuntu. But I can never get the new version to work with emacs/SLIME! I just end up reinstalling the Ubuntu package. Is there just a package for the newest build?
I think you have to set your inferior lisp in your .emacs file. I don't remember the syntax, but I got it to work.
What problem do you see with emacs and slime?
It's Lands Of Lore for me!
Hey, xach! WarWeasle-&gt;bwbeer I'm at work and I don't have access to my machine but if I remember correctly, it can't find package CLC. My internet is really screwy at home so I don't know when I'm able to get on at night.
Hey, I already said I was a Lisp newbie! Let Over Lambda doesn't have any cartoons! Without any cartoons, how's a guy supposed to know it's even a thing?!
The problem is that you use SLIME from Ubuntu package which is patched to work with CLC (common-lisp-controller, a Debian-specific thing). But if you build your own SBCL there is no CLC in it. (Ok, I guess you can add CLC, but why?) Here's what I do: 1. Remove SLIME package. 2. Grab real SLIME from official site, you can put it to your home directory. 3. Add path to SLIME into .emacs file. 4. Profit! Here's how it looks for me: (add-to-list 'load-path "/home/alex/lisp/slime/") (add-to-list 'load-path "/home/alex/lisp/slime/contrib/") (require 'slime) (slime-setup '(slime-fancy slime-tramp)) 
Like [PAIP](http://norvig.com/paip.html) and [On Lisp](http://www.paulgraham.com/onlisp.html)?
If I were going to introduce a completely new person to programming I'd try [SICP](http://mitpress.mit.edu/sicp/full-text/book/book.html) or [Touretsky](http://www.cs.cmu.edu/~dst/LispBook/index.html).
Thank you! Last time I did some searching and couldn't find anything. I gave up and played with that "parsing with monads" article. I'll try it as soon as my free time and my internet align for a few minutes. (maybe tonight?) As an aside, the Lisp community has been one of the most helpful, friendly groups I've had the privilege to meet. This is just one example why. :)
I'd also highly suggest looking into Xach's quicklisp, which also includes the installation and setup of slime. Highly recommended. 
Slime in **in** QuickLisp? WOW. I never thought to look for it in there since it's mostly a emacs thing. 
See http://www.quicklisp.org/beta/ under "To configure SLIME..."
Some Lisp books have done such things. My memory is the first half of Tourtezky's book is completely side-effect free.
Obviously not; I've already read those. But I think there are areas of lisp which still aren't well represented in books. (If you want to dig lispit, I made a tentative list of such topics some times ago — not that I have the skills to write such a book, of course). 
So Conrad can write volume II, name it *Return of lisp*, and we can call it ROFL.
Anyone knows why their Mac OS X binaries are behind (currently 1.0.29)? Lack of developers/testers/hardware? Some technical reasons? Thanks!
Dunno, but the latest release builds and runs just fine for me. Worked through Land of Lisp on 1.0.44, no problems. 
i'd buy that on general principle
that is a perfect example of how naming variables makes a world of difference, or is it like this in lisp?! haha!
Well, that is left as an exercise :) But you can find a working example of how to recursively apply the function draw-node-with-children here: http://martin-loetzsch.de/gtfl/#tree-drawing 
At ILC I asked Kuroda Hisao about why this stuff is distributed as fasls only. I couldn't quite understand his answer - something to do with only wanting to give sources to universities. It's too bad, because some of it looks pretty neat.
Cute. But I can't imagine that it would actually save time...and Emacs users aren't really the type to get smitten by something like this--most are probably more than happy using their keyboard.
YYYYYYYYYYYYEEEEEEEEEEEEEEEEEEEEEEEEEEEEEESSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS! this looks so amazing. I hope this is as usable as it looks and will end up in an Emacs release (24!). http://lispgamesdev.blogspot.com/ Please repost to /r/emacs!
&gt; Emacs release (2.4!) &amp;#3232;_&amp;#3232; 
&gt; probably more than happy using their keyboard. As long as it's a 20 year old Model M. Or even better, one of [these](http://world.std.com/~jdostale/kbd/SpaceCadet1.jpeg)
24! Sorry sorry I meant 24! Usually I used to be the guy who got upset by people posting the wrong version number of Emacs! I used to be the one to point out the high version numbers when people questioned the stability and durability of Emacs. I used to be like you guys!!!! I used to belong here!!!! It's 24!! Not 2.4!! 24!! (security carries me to the exit and my sobbing screams fade away in the distance:) I used to be like youuuuuu!!! 24!!!!!! 
It's a shame but from the end of the page, it seems there are some comercial interests. A good open source ML library in CL would be a good thing to have.
I have been coveting a space-cadet keyboard for the past year. And every time they come up, I think, "Surely I'll be able to find one for sale somewhere." ...and I'm always disappointed.
I thought it was a good book, but perhaps a little too babyish for me. I was looking perhaps for more information about how to build large complex systems on CL and how you use CL to tie into common DBs etc. I soon realized that was outisde of LOL's scope, but I still enjoyed the book.
/me strokes the-fritz's hair in a calming fashion. There, there, it will be all okay.
Well, this particular example came from a chapter about creating a CD management system, so when I first came across the code, I do not remember being confused about it. On the other hand, "cd" has a remarkably similar look to "cdr", and if the reader is still uncomfortable with the general syntax, I can definitely see it being confusing. Poor names are a programmer choice, not necessarily a language thing (with special exception to certain languages that had identifier and line limits). Most of the time when I read Lisp code -- even in the emacs world where the .el code samples can be as bad as online JavaScript samples -- the authors tend to be more deliberate with their names than, say, people who write cute unix utilities (dd, cp, mv, ci, vi, etc). I've noticed that the flexibility in identifier names is sometimes used, too; some people like to add punctuation to provide connotation to identifiers. For example, an identifier with a ! is going to be related changing something, and an identifier with a ? is going to be related to asking about something. 
this is already in emacs 23 and probably 22. it just isn't as useful without a touchscreen or tablet.
I realize this doesn't necessarily make for good marketing[1], but it would have been awesome to see how that interface deals with errors. For example, the demonstrator typed "contacts" and then changed it to "contact"; had he pressed Enter while "contacts" was still there, I would be interested to see what happens. Same question for a non-existant/non-mapped field. 1 = well, it can make for great marketing if the error recovery is intelligent
He misspells customers (@ 0:26, "customres") and the system returns relevant results. I'd be curious to see what happens when you have similarly named tables and or fields. Still, interesting system.
Are there any comercial users of Lisp in New Zealand?
That's a great point, thanks. I saw that but dismissed it as some kind of British spelling, then totally forgot about it when I was writing my comment.
No worries; I thought it was pretty neat, but I'm still curious about the points you raised, and their related ones (similarly named columns/tables, &amp;c. &amp;c.). 
As much as I love the idea of Lisp, I have to agree with Peter Norvig on why he has provided a lot of [support for python](http://norvig.com/python-lisp.html): because of those damn parentheses. Yup, you eventually learn to love them, but for some reason, they really do get in the way of most people's thinking about the code clearly. In a way, it's like the recursive leap of faith: once you see it, it's a bit difficult to think how you could have NOT seen it, but until then... Norvig basically likes python because it's "lisp without the parens"'
shaikwahajuddin
SBCL 1.0.45 Win32 binary is available at http://ntemacs.sourceforge.net/ now. 
http://gigamonkeys.com/book/ is a book for learning it Here's a good list of features that Common Lisp has: http://abhishek.geek.nz/docs/features-of-common-lisp/ 
There are probably people on here with a much better background on this, but Lisp is a functional language (as opposed to the imperative languages you are so familiar with). Functional languages tend to disallow side effects in statements and have a foundation in Lambda calculus. Functional languages are actually pretty interesting from the little bit that I've played with them in classes.
That's not really true - Common Lisp supports functional programming but doesn't really enforce it, and it supports imperative and OO constructs as well (loops, setf, CLOS, etc.). In fact, it can be argued that Lisp's macro system actually makes it less "functional" than most other language
If you have to ask what jazz is, you'll never know.
Lisp is elegant. The core/syntax is very small, but the flexibility is huge. Lisp is perfect, in the sense that it's powerful enough to implement any new fangled idea that comes along (OOP, generics, etc). When you get comfortable in lisp, you start wondering why you ever coded in anything else. Where/when It should be used over another language? Good question. I don't use it a lot, day to day, although I do prototype stufs in it. I suppose in a perfect world we'd all be lisp weenies, but as it is, tools, libraries, etc make a big difference. Learn yourself some lisp, you'll thank yourself for it. (As an aside, I hated the lisp I did in school. Stupid parentheses! It takes a bit of effort to 'get'.) Oh! Also, macros of extraordinary power.
Agreed on first point. I just wish Python or Ruby had Condition System.
Read The Little Schemer if you want a book. It's fantastic. (I've also heard great things about Land of Lisp). Lisp is an elegant language. You write Lisp programs differently than C programs, for instance. There's a certain beauty behind the recursion that powers the code. I'm not certain that I can explain it, I just know that it's awesome. For inspiration, look up the Y combinator. I guess that I'm really talking about functional languages as a whole, but Lisp is the car of them in my book.
The bottom line is, lisp code is essentially represented in lisp data structures, so it's possible to manipulate code the same way you do data. This makes macros and syntax extension ridiculously easy, compared to other languages - take C#, for example. Say you wanted to add 'unless' as a keyword. It would be largely impossible, unless you work for microsoft and push it through the whole process. On lisp, it's just a simple macro. I'll leave it to other people to describe *why* you might want to do such a thing - but suffice to say it's superbly handy at times.
Lisp is said to be a functional language. IMO, it isn't any more functional than say, Python. In fact, Python encourages a style of separating the imperative code from the functional code, whereas variants of Lisp encourage having side-effects deep inside "functional" expressions.
There are a few really nice things in Lisp compared to languages such as C and Java, but I'll stick with my personal favourite: compile-time and run-time metaprogramming. * You need to write a program that - at run-time - reads in a configuration file (or takes some user input) and then generates the source code for, compiles, and runs a program specifically tailored to that input. * You need to write a program that - at compile-time - generates a lookup method for a known number of values so that the rest of the system can access this method at run-time. * You find yourself writing the same boilerplate code around a bunch of similar methods. The boilerplate is not insignificant and you have found several versions floating around the codebase - each with its own set of bugs. You want to get rid of this boilerplate code so you can focus on the code specific to each method. Lisp macros make the above scenarios laughably simple. (Higher-order functions help, too.) ----- I have found that macros make Lisp really good at compressing your source code, by which I mean that any time you find yourself writing the same "pattern" of code three times, you rip it out and turn it into a supporting function/macro. What is left is the bare-bones, minimal expression of the solution you are working on, and this is nearly priceless when it comes to reading, debugging, and extending the functionality. ----- I mainly used Paul Graham's _On Lisp_ to learn Lisp, after I'd worked with Python for a bit. (I'm not sure if I'd have been able to comprehend _On Lisp_ if I hadn't already been exposed to dynamic programming via Python first, though. Lisp has a few other features that I hadn't been exposed to before then.) I haven't read this book yet, but scroll down its [webpage](http://landoflisp.com/) for great amusement. On a more serious note: [Why Lisp](http://www.gigamonkeys.com/book/introduction-why-lisp.html)? ----- PS: Note that other languages do have "macro" facilities (I'd discount C's awful text-substitution travesty, though). Erlang has its fairly usable parse_transform modules (but not so easy to use at run-time), and apparently Template Haskell and Lua are roughly as powerful as Lisp in this area. 
Eh, ignore my incoherent ramblings up there and just read [The Nature of Lisp](http://www.defmacro.org/ramblings/lisp.html).
This is the best description of the benefits of macros that I've found. It's from *[Practical Common Lisp](http://gigamonkeys.com/book/)* ([chapter 7 footnote 5](http://www.gigamonkeys.com/book/macros-standard-control-constructs.html)). &gt; [Lisp's] `DOLIST` is similar to Perl's `foreach` or Python's `for`. Java added a similar kind of loop construct with the "enhanced" `for` loop in Java 1.5, as part of JSR-201. Notice what a difference macros make. A Lisp programmer who notices a common pattern in their code can write a macro to give themselves a source-level abstraction of that pattern. A Java programmer who notices the same pattern has to convince Sun that this particular abstraction is worth adding to the language. Then Sun has to publish a JSR and convene an industry-wide "expert group" to hash everything out. That process--according to Sun--takes an average of 18 months. After that, the compiler writers all have to go upgrade their compilers to support the new feature. And even once the Java programmer's favorite compiler supports the new version of Java, they probably *still* can't use the new feature until they're allowed to break source compatibility with older versions of Java. So an annoyance that Common Lisp programmers can resolve for themselves within five minutes plagues Java programmers for years.
&gt; In fact, it can be argued that Lisp's macro system actually makes it less "functional" than most other language If macros are written in a functional style, the code that gets substituted into a macro usage will end up being functional. Same with imperative. It seems to me macros are orthogonal to being a functional vs. imperative language. But I'm not a macro wizard. Is there some application for macros that violates the above?
It's missing the figures, though. But if you google a little, you can find them. And if you google harder, you could find a pdf including them.
That is an excellent point, but it ignores the tension between being an *advanced language* and a *general purpose language*. Can you actually come up with a language construct that improves a language for every-one? It is truly wonderful when you can do this and this is the goal of much programming language research but we seems to have gone pretty much as far as we can in this direction. A change that makes a language better for writing code in one application domain usually makes it slightly worse for writing code in unrelated application domains. It is more realistic to imagine that your DOTAXES macro makes the language better for writing accountancy packages, while being resented else-where as bloat that doesn't help. Sun will publish the JSR and find that programmers don't want a general purpose language cluttered up with language extensions that help with domains in which they are *not* working. You get turned down. 
how does Python encourage the separation of imperative and functional code?
Thats a good question that isnt easy to answer. I think learning parts of Common Lisp and Scheme widens one's horizon. Looking at the Object-System of C++ which has a lot of pitfalls, you will notice that the reflection api of Java makes you free and is highly flexible - and even though you mostly dont need it, in some cases it gives you the possibility to do things that you never expected to be able to do in C++. Now looking at the Common Lisp Object System, Java's Reflection API looks like a cheap hack. Bash is not a real programming language. It is a shell language and should be considered as such. Its there to glue other applications together, and it does a good job. Looking at Perl, I must say that the Syntax degrades it to a shell language. However, Perl and Python adopted a lot of things from Lisp, but if you know Scheme or Common Lisp, you will notice that these things are in some sense "bounded", and not as general and beautifully integrated as in Lisp. So from a pragmatic point of view: Common Lisp lacks of easy-installable portable libraries and good documentation, same for Scheme (except for some implementations like Racket) - the communities are smaller than for example the Java-Community and many of them have an academic background with academic interests, and there are less companies interested in it. So if you want to work in a small software-company, maybe PHP, Python, Perl and C++ may look better in your CV than Common Lisp. On the other hand, Learning Lisp opens you another world of programming, another philosophy that is different from most of the other languages. For example, the principle to make a language mightier not by adding features but by removing limitations. Learning Lisp can be frustrating in the beginning, but as soon as you got some basic knowledge, it is fun. And as soon as you have learned it, you will get another point of view on programming.
It's not the list of single features which makes lisp great, but the way the work together. See the [first chapter of *On Lisp*](http://www.bookshelf.jp/texi/onlisp/onlisp_2.html).
Python has a relatively strong convention that side-effecting code should return None (e.g: Setters, things that are solely executed for their side effect). This means that you can't: some_functional_computation(x.set(..), y.set(..)) But you have to write: x.set(..) y.set(..) return some_functional_computation(x, y) So the imperative part (calls to setters) is separated into statement lists, whereas the functional part is actually a nested expression. In Lisp, the convention is the opposite, meaning that even if you "print" a value, you can embed that statement deep inside an expression. If you look at ELisp code, that kind of thing happens a whole lot.
&gt; Why is it better than some other language? Here are reasons why I like Common Lisp: 1. Nice, unambiguous syntax -- no need to remember lots of weird rules, and if you forgot something you can easily look up in doc. 2. Excellent possibilities for elimination of boilerplate code through macro system. Almost everything is possible. (Related to 1) 3. Mature standard written by sane people, no confusing over different versions. 4. Dynamic typing, but high performance, compiled to native code. (Related to 3: language designers took performance into consideration.) 5. A lot of nice language features -- multiple-values, condition system, LOOP etc. 6. CLOS as a pretty advanced object system. 7. Interactive development, ideal for explorative programming and research. 8. Mature implementations with IDE support and stuff like that. It has downsides too, but for me upsides outweight downsides. 
Lisp is like a ball of mud. Add more and it's still a ball of mud - it still looks like Lisp. 
&gt; Scheme is like a ball of snow. You can add any amount of snow to it and it still looks like a ball of snow. &gt; Moreover, snow is cleaner than mud. [Marc Feeley](http://snow.iro.umontreal.ca/)
"Common Lisp lacks of easy-installable portable libraries" This problem was solved recently http://www.quicklisp.org
No you've got it bang on. However, if you're repeating the same code, it's tempting to abstract it away. Because common lisp lets you do this with macros and object oriented programming as well as with functional programming, lisp programmers are less likely to rely on functional constructs than, say, Haskel programmers who don't have a choice. 
To me that looks more like there isn't much functional code in Python anyway. It simply means that you have to write most code in a purely imperative style, where in Lisp there is a non-pure-functional style the default. Lisp uses often higher-order and functional code and mixes that into the overall code. Lisp encourages all functions to have a useful return value (or even more than one) one, so that code can be written in a more functional style. So, when in Python you write: foo.move(forward) foo.turn(left) foo.move(forward) In Lisp this may be written so that each function returns FOO as a primary value. (move (turn (move foo forward) left) forward) Which looks slightly more functional to me. Lisp is certainly more functional then Python because it encourages a style where functions can be passed around and can be chained - independent of having side effects or not. 
1) Lisp Macros - functions which generate code. This is by far the most powerful and distinctive feature of the language today, and what, I think, makes Lisp Lisp. This is possible because in Lisp, data structures (lists) *are* code. So macros are merely functions which are registered with the compiler which produce output that is treated as code. This enables the language itself to be extended. For example, whereas in other languages, AND and OR are keywords, in Lisp they are macros which *could be* implemented by the programmer (though are provided by the default package). Here's a simplified version of OR: (defmacro or2 (x y) `(if ,x t (if ,y t)) Impossible in any other language. But why should you care? This allows you to build new language constructs. The patterns movement was created to cope with deficiencies in languages like Java and C++. To implement a pattern, you must painstakingly implement a pattern by hand, coding classes and their relationships to each other. In Lisp, there's no need for a patterns movement. You write a macro that instantiates several classes or related functions in a single expression. In fact, the entire object system (CLOS) is pretty much just a bunch of macros. Your jaw should be dropping right about now. Imagine doing that in *any* other language. You can't. And the reason is that in Lisp, *code is data*. Any language that treats code as data, and gains Lisp's ability to manipulate expressions, will look awfully close to Lisp. 2) In the past, we would say that another distinctive feature of Lisp is that it is functional. It is still a wonderful functional language, but now ML, Haskell, and even mainstream languages like Ruby (and to a lesser extent, Python) allow you to do much of what Lisp did decades ago. 3) Number system. The standard operator seamlessly interoperate floats, ints, complex numbers, bigints, and rationals. 4) Higher performance functional programming. Compiler advice and expansions allow you to fine tune performance, rivaling performance of other functional languages and even besting Java. (See Norvig's comparisons). Lisp handles complexity really well. AI and symbolic math are tough in other languages, but relatively easy in Lisp. You can write a usable Prolog interpreter in a page of Lisp, for example. Try that in any of the other languages you mention. I have seen AI systems written in Java and C. [Greenspun's 10th rule](http://en.wikipedia.org/wiki/Greenspun's_Tenth_Rule) is not a joke.
Also available for free: * [Practical Common Lisp](http://www.gigamonkeys.com/book/) * [Common Lisp: A Gentle Introduction to Symbolic Computation](http://www.cs.cmu.edu/~dst/LispBook/index.html) 
Other languages are complicated in useless ways and underdeveloped in useful ones. Special syntax for a `for` loop, for instance, is a useless irritation which makes code harder to read and edit with a smart editor. Absence of support for higher order programming is incredibly frustrating. Lisp is one example of a language which gets things about right. The syntax itself is as simple as it possibly can get (except for Forth), which means a text editor can slurp, move, refactor, chop up, and rebuild lisp code easily, and you can do so yourself with macros from within the language. On the language side, especially in Scheme, functions are first order objects which you can quickly use to construct all sorts of other, more complex abstractions (I find the separate namespace for functions in Common Lisp slightly less optimal). There are other things, which are less lofty. Lisp's nested syntax encourages you to write tons of short functions or macros because its actually a mess to not do so. This produces easy to understand, bottom up programs. Object oriented languages in the C++ lineage encourage you to dump shit-tons of code into methods for classes, and the class system (I find) makes finding the thread of code somewhat difficult within a single class, since there is this big bag of state implicit in every method call. A little inconvenience in the syntax, I find, encourages me to think in small, functional units. I like it. After a few years of programming in lisp, I find myself writing tons of small functions, and then combining them with special functions which generalize the idea of composition of functions. I rarely write a function longer than 20 tokens. It takes some getting used to, but I find my bug rate is much lower this way. Every time you write a for loop by hand, for example, when you really mean a map or a fold or a filter, you introduce chances for bugs. If you mean map, fold or filter, write that, and then focus on just the function which is actually operating. Less place for bugs to creep in. Every time you write a new function when you really need to just compose two functions or compose them in some more general way, you introduce the chance for a bug. If you mean compose, write compose. Every time you write a new function when you really mean to partially apply it to one argument, you introduce a chance for a bug. etc. tldr: lisp is simple and powerful.
&gt; Which looks slightly more functional to me. I think it depends: It seems you've switched from destructively-update "foo" to return a new foo, and that is indeed more functional, and probably more prevalent in Lisp than in Python though just as easy in Python: foo = foo.move(forward).turn(left).move(forward) But if you still are using destructive update, then that Lisp syntax makes it a lot less clear that it is indeed using destructive update whereas in Python it is completely clear that is the intention. "functional" is very subjective, but I think destructive updates are relatively consensually un-functional, and by having them mostly in functions that return None in Python, or having their type be something like "IO ()" or "State s ()" in Haskell, they're quarantined away so that the code that looks functional is more likely to actually be functional. &gt; Lisp is certainly more functional then Python because it encourages a style where functions can be passed around and can be chained - independent of having side effects or not. Lisp might make a lot more use of HOF and I agree that is a strong point in claiming Lisp is more functional than Python (though I think the points I mention above are a reason to think the opposite). But Python actually supports HOF's no worse than Lisp does, even if their definition has to be given a name and split into its own statement. A syntactic clunk is a small price to bear, a Lisper has got to agree to that :-) After learning Haskell, I find it hard to consider a language that does not even name the function-composition operator (Haskell's dot `(.)`) to be very functional, so I see neither Python or Lisp as very functional.
&gt; A change that makes a language better for writing code in one application domain usually makes it slightly worse for writing code in unrelated application domains. But you are usually only writing in one domain at a time. With Lisp macros, you can implement a change that makes coding your current project better, instead of having to put up with a general purpose language.
&gt; You can write a usable Prolog interpreter in a page of Lisp, for example. I second that. Yesterday I wrote a simple virtual machine and bytecode compiler in something like 150 lines of code.
I fear you may not be approaching this from the right angle. Lisp is a general purpose language that allows for a good flexibility and elegance in expression. It is for this reasons that advocates of Lisp are generally disparaging of most other languages - they simply do not allow for as much freedom of expression. Expression is key to programming. Programming is at heart expressing ideas in the clearest fashion. &gt; Is it better at implementing certain data structures? What does better at implementing data structures mean? Do you care about space? Time? Both? Depending on what lengths you are willing to go to, you can write (or at least use) code at as low a level as you want with Lisp (as you can with almost any language i.e. calling C/assembly). However, I think most programmers would agree that the best data structures are those that are straight forward and well suited for their domain. Lisp has a lot of options available to make experimenting with data structures a fairly painless experience. I'm not sure I could say that about any of the other languages you know. &gt; Is it really that much faster? Faster than what? Speed is relative. Until you know what is happening in a program, how can you know if it's fast? Lisp allows you to easily do some compile time computations that would be unwieldily in other languages. The fastest code is code that doesn't need to be run at all! The syntax of Lisp is near trivial. It does it's best to not get in your way. If you feel as though you suck at Lisp, then it is probably symptomatic of a lack of understanding of general programming principals. You should learn Lisp exactly for this reason. Stretching your region of comfort means learning more about *Programming* (as opposed to "programming in language X"). The other answers given to you contain many good points about what makes Lisp a good language. There are some specific features mentioned as well as the themes "Fun" and "Power". Keep all of these things in mind, but don't forget that *understanding what you want to happen* in a program and *expressing that concept* through language is what you are doing when programming. Ease of *clear* expression is therefore the most important thing a language can offer. Whether you find this language in Lisp or not, there is no doubt that it has much to offer.
Also available for free: * David B. Lamkins - [Successful Lisp, How to Understand and Use Common Lisp](http://www.psg.com/~dlamkins/sl/) * David J. Cooper Jr - [Basic Lisp Techniques](http://www.franz.com/resources/educational_resources/cooper.book.pdf) * Stuart C. Shapiro - [Common Lisp, An interactive Approach](http://www.cse.buffalo.edu/~shapiro/Commonlisp/)
Care to post the source? Sounds interesting
I'll just leave these here: [Is Lisp a good language to learn first?](http://www.reddit.com/r/lisp/comments/cqctz/is_lisp_a_good_language_to_learn_first/c0uhok3) [Why we love Lisp](http://c2.com/cgi/wiki?WhyWeLoveLisp) That said, you may not love Lisp, but I think anyone that hasn't gotten eyeballs deep in it will certainly learn a lot about programming in general by doing so; not just about Lisp. But meh... what do I know? I only dabble with it myself.
The point I was trying to make is WalterGR's quotation understates the benefits that one gets from macros in Common Lisp. I've tried writing macros to add improved general purpose features to Common Lisp and given up because CL is already an excellent general purpose language. Coming up with fully general purpose improvements is a lot of work for not much payback. WalterGR's quote leads you down the path of trying to invent the kind of general purpose macros that would make a Java programmer say "Heh, Sun, you should add those to Java." That is hard to do. If that were the only use of macros I would admit that I'm not really talented enough to make much use of them. I think that a much bigger deal is when you get requirements dumped on you, and you realise that you can use defmacro to tweak the language close to the way that the requirements are worded. Then your code consists of some defmacro's providing some infrastructure, followed by some code that follows the requirements documents suspiciously closely, as if the language were designed for the very work that you end up doing ;-) For example, Steven Landsburg has a [post](http://www.thebigquestions.com/2010/10/20/the-noble-savage/) on Allais paradox. I suggested using [code](http://paste.lisp.org/display/115804) to get a feel for what the probabilities really meant. To avoid cock-ups I structured my code so that the relationship of the code to the each given scenario was perfectly clear, eg, (defun 1b () (percentage-case (89 (small-win)) (10 (big-win)) (1 (big-regret))))
if you think that destructive updates are not 'functional' then you rule out languages like ML, SML, OCAML and many others. That Lisp does not make a visible distinction of side-effecting from side-effect-free forms, but in reality functional techniques are used everywhere, whereas they are rare in Python code, makes Lisp less functional than Python?? Okay... In Python the functional features are discouraged by convention and by the dictator (see MAP, FILTER, ...). In Lisp they are encouraged by language design and convention. The library is full of higher-order functions, functions that can be combined and typical code uses them a lot. The reason that PRINT returns a value is because it can then be combined in a functional way. What makes a language 'functional'? The absence of side-effects? Okay, then SML and OCAML are not FP languages? That one can do something in Python which in reality is really rare makes Python MORE functional? The a . b is just syntax in Haskell. The corresponding form (lambda (...) (a (b ...))) is longer, but widely used in Lisp. Functions for that exist: (curry #'a #'b) . 
Lisp had quite a large standard library for its time. But then it got standardized and frozen in the mid-80s, so other languages had 25 years to flash by in terms of standard comprehensiveness. Nowadays you can count [anything thats in Quicklisp](http://www.quicklisp.org/beta/releases.html) as Common Lisps *new* standard library, since its available for everybody, everywhere, at no cost, with liberal licences, on almost every implementation, on every platform, and while at it, it's very easy to use. Its "quickly" approaching Lisp's own version of "write once, run everywhere".
Says the man who made quicklisp.
Hey, Marc Feely said it, not me! I met Marc at ILC and he told me about his Scheme Now project. He was very kind towards Quicklisp and wished me luck. I think the names he came up with ("snowballs" for archive files, "snowfort" for the repo, etc) are cute...
I'm not a Lisp guru. I hack when I have a few minutes or when I need to solve a problem that doesn't require anything other than data as a deliverable. The reason for this is that the other developers here do not use lisp, do not want to use lisp, and I won't make them. Buy why do I use lisp? Power. Pure and simple. Not that lisp doesn't have gotchas, it does, but not like other languages I've used. It's like the view from the top of a mountain. I can't describe it for you, you have to experience it. Yes, all these things are important: intuitive numbers, exceptions and conditions, CLOS, closures, macros, DSLs, etc, etc, etc.... But what Lisp does best, is that is brings them together like the cockpit of modern warplane. Everything is set up to **solve the problem**. Do you know what the problem is? Then you write and debug it. If you don't, you explore the spaces around it. If you don't have a clue, then it can't help you but even then the REPL is a great place to start. Lisp is my doodle-pad. I test ideas and receive answers. It's a conversation between me and my computer, but always with me in the lead. The code becomes a way of organizing my thoughts and sometimes, on a good day, I can tell if my thoughts are good just by looking at how my code indents. I've never seen this anywhere else. Maybe Forth programmers get to see *some* of this (garbage collection and lists need to be implemented). There are not a lot of libraries for lisp because many things are just dead simple to do. I've made a few myself without realizing. But if you want to know Lisp, the heart of lisp, look up [CONS Cells](http://en.wikipedia.org/wiki/Cons_cell). As the Taoist might say: Lists within lists: The gateway to all understanding.
this looks like an old article about the abandoned Lisp-Stat (aka XLisp-Stat)
Thanks, couldn't think of Successful Lisp for the life of me...
I didnt check if they simply recycled an old Tierney article, but the publication date of this one is October 2010. They still link to xlispstat though.
the picture in the article looks like it uses Motif... ;-)
The problem with hacking Kinect is finding a physical activity that I find interesting.
I come from a .NET background, and I really like how stable the language is. There's no "new version" coming out every year, no mandatory upgrade treadmill. I have a lot of C#/ASP.NET clients who don't want to pay to upgrade their website from C#2 to C#4, or ASP.NET2 to ASP.NET 3.5; development on old systems gets harder (newest versions of visual studio don't even have a compiler targeting .NET 1.1!) So, it's nice to have a language where 20 year old source code still works, and I can have confidence that code I write today will still be valid lisp in the years to come. The only upgrade treadmills I have to deal with are with the libraries I use.
Yup, the discussion at the end seems new though: &gt;Lisp-Stat was originally developed as a framework for experimenting with dynamic graphical methods. To be able to experiment with those methods in the context of realistic data analyses, it was natural to add solid data analysis capabilities. The resulting system was strongly influenced by the S language as described by Becker et al.6 &gt;To give data analysts the greatest possible flexibility, it is very useful to embed a data analysis framework in a full computing language. This facilitates novel combinations of existing methodologies as well as the development of new methodologies. The approach taken by the developers of the S language was to develop a new language for this purpose; Lisp-Stat took the approach of adapting an existing language: Lisp. Lisp offers a number of features not shared by many other languages. It is a mature language with well developed debugging tools and a number of useful introductory texts,7–10 and it is flexible enough to support many different programming paradigms. In addition, full Common Lisp systems also include the ability to compile new functions as they are developed, thus almost eliminating any efficiency penalties often associated with interactive language systems. The Lisp-Stat system is designed as a specification that can be implemented within a number of different Lisp environments rather than as a specific implementation. &gt;Object-oriented programming is particularly suitable for graphical applications and has been used as the basis of most window management systems in use today. It is a natural paradigm for graphics programming in statistics and also has other non-graphical statistical applications. The object-oriented programming system in Lisp-Stat is a prototype/delegation system in the sense of Wegner,11 rather than a more traditional class/inheritance system such as the Common Lisp Object System (CLOS). The prototype-based system appears to provide more flexibility for interactive development of new kinds of objects than a class-based system. This is also illustrated by the implementation of the ggplot2 package12 for R, which also uses a prototype-based object system. &gt;Lisp-Stat has been used as the basis for implementing several higher level analysis systems with graphical user interfaces. Two prominent examples are the regression analysis system ARC13,14 and the visual data analysis system Vista.15 &gt;Experience in using and developing Lip-Stat has also profoundly affected the R16 system. The memory management system used in R17 is based on one developed for Lisp-Stat; adding a name space system to R18 was motivated by experience in Lisp-Stat, and the exception handling system in R is patterned after the Common Lisp condition system. &gt;At the time of writing, Lisp-Stat is available at http://www.stat.uiowa.edu/∼luke/xls/xlispstat/ .
You do not sound like you're bashing Lisp. What I like about Lisp is that it's designed to give me the facilities I need and get the hell out of my way. Lisp assumes that it *is* your application, and it's running right now. You just need to teach it how to be the application you want to write. Since it's running right now, you can build up your data structures in memory right now, and look at them, and write functions to try out on them, all interactively, while the program runs. If things go wrong, you don't just get a core dump or a stack trace; you get an interactive shell you can use to examine the stack, changes the values on it, redefine the functions on it, and restart from anywhere on the stack. Lisp doesn't make you write code that doesn't actually address what you're trying to do. It demands very little boilerplate. Heck, you don't even have to write functions to manipulate your data. You can just stuff some data in a variable and try out some expressions to see what they do. If they do what you want, you can capture and keep them, and arrange them however you like. A lisp system is a live system, waiting to be told interactively how to be the application you want. It doesn't make you do much of anything, and it doesn't prevent you from doing much of anything. It gives you a huge library of data structures and operations, hands the keys to you with the engine running, and then gets the hell out of the way so you can go exploring. That's why I like it.
[Sure](http://pastebin.com/W6BBMhTw), but I have to warn you: it's a bit ugly, incomplete (I was working on it now) and uses some implementation specific features (like byte strings from Racket). 
&gt; Not sure if schemers smile or frown when I mention racket though... Depends on the Schemer; I'm not a fan but they do have some neat ideas. As for CLOS, I used to get around this by using Scheme systems that have CLOS-alikes baked in (like RScheme or STklos).
For me it's the syntax, or lack thereof. Or, perhaps more specifically, there is syntax but it's always the same syntax. I'm studying (by necessity) languages like C# and Java and it never ceases to amaze me how utterly complicated languages have become in terms of syntax. The simplest concepts devolve into some weird and totally arbitrary alphabet soup. Don't even start on C++. And Haskell? N?gga please. With CL, you only need to learn a handful of syntax-related things and from there you can build whatever you want. In CL I focus entirely on the solution, and not on the language itself. 
Why wasn't it ported to Common Lisp?
So it's impossible to write something like or2 in Haskell?
Special syntax for a for loop? CL's loop macro is the most special loop construct I've come across.
Good point. That was a poor example. I should have chosen something like defclass or defun, where some of the sublists are treated as data, but I'm not sure there's a nice example that is easy for non-lispers to understand. hmmmm.
But its just a list of tokens and lists. But I'm still not a huge fan of it, and prefer to employ higher order functions and recursion whenever reasonable.
&gt; if you think that destructive updates are not 'functional' then you rule out languages like ML, SML, OCAML and many others. The part of the program that's using destructive updates is not a functional one. ML, SML, OCaml allow non-functional programming of this sort as well as functional programming. &gt; In Python the functional features are discouraged by convention and by the dictator (see MAP, FILTER, ...). In Lisp they are encouraged by language design and convention. I repeat, the most basic functional building block (the dot composition) is missing in both Lisp and Python. While Python is discouraging map/filter/... in favor of equally-function list comprehensions, I'm not sure where various Lisp variants stand in comparison to Python's lazy/functional itertools. My view is that both are similarly functional, which is not very. &gt; The reason that PRINT returns a value is because it can then be combined in a functional way. The only way to combine it is to expose evaluation order and place it somewhere in it. I argue that exposing evaluation order is one of the least functional things one can do. When you're programming imperatively (and the part of the program that prints is imperative), it should be explicitly imperative and sequenced, which is how it is done in Python (in its own statement). Note that Haskell and Python are pretty similar in this regard, do you feel Haskell is less functional because of its quarantine of imperative programs? &gt; What makes a language 'functional'? The absence of side-effects? Okay, then SML and OCAML are not FP languages? They are not pure functional languages, and that pretty much means that portions of your SML/OCAML programs are imperative even without being explicitly designated as such. The parts of Haskell programs that are imperative are designated as such. &gt; That one can do something in Python which in reality is really rare makes Python MORE functional? I didn't say that because HOFs are rare in Python it is more functional, just that it supports HOFs just as well (or almost as well) as Lisp, so lack of support is a weak point against Python being functional (though lack of actual use in practice is a strong point as I admitted above). &gt; The a . b is just syntax in Haskell. The corresponding form (lambda (...) (a (b ...))) is longer, but widely used in Lisp. Functions for that exist: (curry #'a #'b) . You could similarly say that map and filter are just syntax in Lisp, and that corresponding list comprehensions are widely used in Python. Or that any functional idiom is just syntax and could be implemented in either Python or Lisp. The point is that if Python has no `filter` it is an indicator against it being functional just like Lisp not having (.) is an indicator against it being functional.
[https://github.com/blindglobe/common-lisp-stat](https://github.com/blindglobe/common-lisp-stat)
They have failed -- I can still read text.
ITER is cooler.
The core was ported to Common Lisp. But at that time there was no simple free Common Lisp implementation that ran on platforms like Windows and Mac. XLisp was such a Lisp, but was more like a pre-Common-Lisp-Lisp (later versions of Xlisp then were based on Scheme). It looks though that there was again interest in using Common Lisp as a base for a statistics system last year.
While Scheme without additions is constraining for real world programming, the multiple name spaces of CL make aspects of higher order programming somewhat clumsy. Consider (Scheme): (define y (lambda (f) ((lambda (g) (g g)) (lambda (g) (f (lambda (n) ((g g) n))))))) (define fact (y (lambda (fact) (lambda (n) (if (= n 0) 1 (* n (fact (- n 1))))))) vs. (Common Lisp) (defun y (f) (funcall #'(lambda (g) (funcall g g)) #'(lambda (g) (funcall f #'(lambda (n) (funcall (funcall g g) n)))))) (defun fact (n) (funcall (y #'(lambda (fact) #'(lambda (n) (if (&lt; n 1) 1 (* n (funcall fact (- n 1))))))) n)) You should try both, perhaps starting with Scheme for simplicity's sake, to decide which fits your neurons better. While I consider my brain more Scheme shaped, I can't say I don't miss things from Common Lisp and Smalltalk when I hack Scheme.
Wow, that makes a lot of sense. I guess that is what has drawn me to Scheme... &gt;I consider my brain more Scheme shaped. That made my day.
I agree with the general tenor of your post, which is that LoL may not be a good introduction for newbies. I may not be a Lisp expert, but I'm a journeyman and fairly comfortable with various lisps like Common Lisp (CL), Scheme, and Clojure. As a result, I can follow all the material easily, but I doubt the same would be true of someone without Lisp (or programming) knowledge. I'm currently around chapter 7 or 8 of the book. That's not very far, but some esoteric parts of CL have already been introduced. For example, in chapter 7, the functions that combine to write a graph to file in DOT format ultimately rely on the use of CL special variables. Special variables (and dynamic scope) are one of the interesting (and arguably extremely useful) parts of CL, but it's hard to describe them in a way that is accessible for a complete newbie. The functionality provided in chapter 7 could have been rewritten using pure functions that produce a string; I think that would have been clearer. Other examples exist within the early chapters. There are hints that your life as a programmer would be easier if you avoid side effects, but the examples make liberal use of (push...). Quasiquotation is introduced for a clever purpose, but I think its introduction undermines the argument that Lisp syntax and evaluation is beautiful in its simplicity. (That is, quasiquotation is another special form that violates the basic evaluation rule.) Because of the quick introduction of these somewhat advanced topics, I feel the book represents a bit of a missed opportunity. Imagine if the concepts in SICP, say from chapters 1 and 2, had been explained using material from LoL rather than material from calculus. The subject matter is ideal for getting youngsters interested in programming; in fact, I had hoped to use the book as an introductory text for my nieces and nephews. Sadly, I think LoL will only make sense if the reader has some prior exposure to Lisp and programming. Anyhow, just my $.02 
It looks great. Thanks
...uhuh... sounds reasonable... quite true ... good point ... wait, CMUCL? wtf!? :) 
I thought the same thing. Not the "wtf" part because CMUCL is a very nice implementation, but it is not the first one that comes to mind when people ask "Which Lisp?". On OS X, my favorite CL implementation is OpenMCL, with SBCL a close second. For Scheme, Gambit has some nice features. 
Do you mean this: http://common-lisp.net/project/iterate/ Looks pretty neat. More lispy anyways.
OpenMCL! It hasn't been called that for years!
you get to develop exclusively in CL? Where do I sign up?
Coming up on 7 years of near exclusive CL'ing, and i'd say the number is 55%-70%... i haven't done a lot of bit banging, barely touched the pretty-printer, and i don't have much need for a lot of the constant variables etc (most/least-positive foo) and some of the more obscure hooks and specials.
I'm completely jealous of your position of using CL exclusively. I don't know that I can come up with an accurate estimate, other than: **not enought**. I would love the [Common Lisp Cookbook](http://cl-cookbook.sourceforge.net/) to get flushed out enough that I became familiar with more. As it is, I frequently find that I've re-invented the wheel.
You're right. Maybe I'm tiring of the amount of Lisp implementations, javascript framework, etc, that use a form of the word "Closure". I guess I prefer OpenMCL to "Clozure CL" as it tells more about CCL's history. I like plain CCL, but sometimes feel people might not be familiar with that name. Anyway, Clozure CL is first rate, with unicode and native threads. The only minor thing is that the TRACE function doesn't behave in the way it normally does on other implementations. You need to insert: (declare (NOTINLINE function-name)) in the first line of the function you want to trace. I mention it because someone new to Common Lisp studying recursion might want not understand why trace doesn't "trace". Anyway, it's not a big deal, just an extra step. 
&gt; Hyperspec's all-on-one-page symbol listing For the curious (like me): http://www.lispworks.com/documentation/HyperSpec/Front/X_AllSym.htm 
I found that it's hard to estimate how much symbols I use, so I wrote this http://gist.github.com/741780 Feeding it onto my projects gives 35.07 %, but that only accounts for ASDFied and not thrown away code, so in reality it should be somewhat higher.
not bad :)
Hello, the response to this question has been wonderful :) especially stassats analyzer. Mine says 25% when fed the source to IOSKETCH, which has about 10K lines by this point. So I guess I was grossly overestimating before. About how I get to develop in CL: Despite having a computer science degree, I have never worked as a programmer professionally. Being an independent game developer, I can use whatever language I like best :)
Counting only FBOUNDP symbols, I get 29% which is somewhat better.
The tool by stassats gives me 39.57%, with the same caveat he mentions. It seems to have a problem with circular lists. Of course, it only tells you the upper bound of the amount of symbols you *regularly* use.
Wow amazing. Where can I find your games written in CL?
hi @tianyicui, My games may be found at http://dto.github.com/notebook/games.html Recent demo reel: http://www.youtube.com/watch?v=Nr3piK3T6a8
seem to be some broken links
Idea #1: don't ever take ideas from this guy. It's the most confusing website, or any UI for that matter, I recall seeing in the past several years. The title is horrible, the links are pure WTF, the presentation (why, for the love of everything that's holy, is it a mov!?) is both hard to read and completely overloaded with idiotic effects. And to top it all off, he doesn't say a single word about the actual ideas he might have, it's just meaningless "oh yeah, it's gonna be soooo great" and then a bunch of scribbles / screenshots for us to guess what he meant.
It is neat. Very handy and way better than LOOP in pretty much every way.
Who can argue with first love.. ;) however I've heard so many good things about SBCL lately, I decided to put it in the post anyway (making it clear in good conscience that I've not used it myself).
&gt; Can you actually come up with a language construct that improves a language for every-one? Why'd you need to do that with macros? If you have a macro that's terribly useful *for yourself*, you can just go and write it *yourself*. It doesn't have to be useful for everyone, just for people writing in your domain. That's another advantage over, say, Java. In the Java process, you have to come up with an enhancement that will be significantly better for many, and at least not worse for everyone. You don't need to do that in Lisp. The difference is sort of like as if you needed to submit a formal proposal to your project manager every time you wanted to implement a new method in Java, who'd then go and consult everybody on your team and hold a vote. It'd make you go crazy before you got anywhere, and the resulting code would be a huge mess of hacks making old methods do twenty new things, even if splitting them into subfunctions would be much cleaner, because the paperwork you have to go through makes it practically impossible. What Lisp does is make you your own language committee. Sure, you can use that to do ultimately harmful things. But that's true with any sufficiently powerful tool and hardly limited to Lisp.
How odd, I wonder if qu-loading Verrazano's giving anyone else issues with shadowing type-of.
Work in a smaller company, start your own, or one where software development isn't a major/primary focus so much as being one tool in a broader role of "problem solving."
What topics are missing? People (including me) nibble at this idea occasionally, but we need a combination of people writing CL and people who want to CL but don't have some need satisfied to get anything off the ground.
Are your games opensource? I would love to look over and learn from CL game code
One thing I found interesting were the parentheses across lines for a whole block.
When I first saw [this screenshot](http://nimbusgarden.com/ben/_HCI_/SeeLisp/SeeLisp_files/SeeLisp.033-001.png), I thought those lines were pointing to something else; took me a moment to realize that they were parentheses. I'm not sure if I prefer this or some light back ground coloration based on block level, but it's a neat to see something (somewhat) novel.
yes :) http://github.com/dto/terahertz is a recent one. The downloadables on the page ones all include source but the version of the engine is older. for newer source of my engine: http://github.com/dto/iosketch 
Interesting, I'm going to have to check this out on the weekend. Maybe I will finally ditch LOOP.
The best answer would probably be to compare the TOC of one of the O'Reilly cookbooks with the CL cookbook. I know I've missed out there before, but I can't recall at the moment what I was doing. As is, it's still a very useful resource (for me, anyway) and I often just read through random parts of it to see what an idiomatic Lisp implementation looks like.
We'll call it 'emacs'...
Awesome, thanks for the link
[CLISP](http://www.gnu.org/software/clisp/) is probably your best FOSS option as it has been around and working on Windows for a very long time. You will need [Cygwin](http://www.cygwin.com/) installed as well, I believe. Another option is [Clozure CL](http://www.clozure.com/clozurecl.html). It is, in my understanding, much more capable than CLISP, most notably with support for threads. For working through PCL and getting familiar with Common Lisp, either should work. For anything past (+ 2 3), you should probably consider installing GNU Emacs and then download and install [SLIME](http://common-lisp.net/project/slime/). Oh, and there are several other options that may run under windows to some success (SBCL, ECL, ABCL, GCL?, ...)
I see Windows binaries here: http://common-lisp.net/project/lispbox/ I have not tried them.
Why not just download emacs and type "control-x ielm"?
For Windows XP, the Allegro CL trial and LispWorks Personal Edition should be pretty easy to install and try. In 2010, people who use Lisp write it as "Lisp", not "LISP."
&gt; Machines from Symbolics and Texas Instruments are already on the market. This technology will be crucial to high-performance systems of the late 1980's and 1990's. By moving CAD in this direction, Autodesk is positioning your applications to take advantage of this development. D'oh. 
&gt; A good open source ML library in CL would be a good thing to have. Perhaps Mahout would be a useful starting point for such a thing. 
Thanks for the pointer to ielm. A minor correction: I think you meant "meta-x ielm" (where "meta" is either ESC or your command/alt key).
On windows, your best bet is the trial edition of lispworks. Some time ago I tried making sbcl+slime work on windows, and hated the process so much that I ended installing it inside a virtualized linux.
You are lucky to have such an illuminated employer :-)
Sorry for that. I hope it didn't confuse you for too long. :(
This. Who is it, and are they hiring?
Tried it a while back on windows, worked very nicely though the lisp implementation seemed a little slow compared sbcl on linux on the same machine. Two years ago, so it may have been upgraded or broken in the mean time though
Not-bad, free-as-in-beer Lisp IDE: http://www.lispworks.com/downloads/index.html
Clisp, even though its website looks (intentionally?) archaic and abandoned, is IMHO still the nicest (free) implementation to start with Common Lisp on Windows and it has been in steady development for now 18 years. Precompiled, native (non-Cygwin) binaries (installers and zips) are available, the REPL has nice GNU Readline support and many other non-standard modules and libraries built in, it is very easy to generate Windows executables. Conrad Barski based his recent book, "Land of Lisp", solely on Clisp, because it is generally so confortable to get started with. If in doubt, go Clisp. ([Get the Clisp Windows installer from Sourceforge](http://sourceforge.net/projects/clisp/files/clisp/2.49/clisp-2.49-win32-mingw-big.exe).) As of my knowledge, CCL for windows is not available as a easy installable binary, but only through a SVN repo, and it requires a complete Cygwin environment to build and run. If you need a more robust thread support than Clisp offers, and a native compiler, CCL is the way to go.
See this: http://www.lispworks.com/documentation/HyperSpec/Body/v__stst_.htm
Java developers _would_ be proud of fitting everything into a single class.
It's generally believed that Common Lisp is for industry and Scheme is for academia, however, at this point you probably won't care. So I would recommend grabbing a copy of Racket: http://www.racket-lang.org It's now become a very mature environment for writing scheme programs. It also includes a web server, large number of libraries debugging and profiling tools. (it even has a place in which you can type (+ 2 3) and receive the response "5" :) ) edit: I should have mentioned before that Common Lisp and Scheme are both dialects of Lisp. Probably the two most notable. As such, they share a lot in common - the syntax is very similar and many of the built in operations are comparable. There are some minor differences in how you define functions and symbols. Learning Scheme will not hinder you learning Common Lisp later. I also should point out that the industry/academic issue is not a concrete fact. It is entirely possible to use Common lisp as a learning language, just as it is entirely appropriate to deploy Scheme in a production environment.
It's still not a standard library; there is no central control or planning. For example, quicklisp libraries don't use consistent function naming and api conventions^1, quicklisp makes no attempt at completeness, and libraries may not be documented. When they are documented, the documentation style will be inconsistent, the quality variable, and cross-referencing between quicklisp libraries will be almost non-existent. .^1 They don't even use the same system naming conventions. Some (but not all) quicklisp projects use Seibel/java style reverse domains as system names.
But there's nothing special about loop; it's just another macro. You could implement it on top of tagbody/go. In fact, Clisp does, and you can macroexpand it and read the code it generates. [13]&gt; (loop for i from 10 downto 1 collect i) (10 9 8 7 6 5 4 3 2 1) [14]&gt; (pprint (macroexpand-1 +)) (MACROLET ((LOOP-FINISH NIL (SYSTEM::LOOP-FINISH-ERROR))) (BLOCK NIL (LET ((I 10)) (PROGN (LET ((#:ACCULIST-VAR-6657 NIL)) (MACROLET ((LOOP-FINISH NIL '(GO SYSTEM::END-LOOP))) (TAGBODY SYSTEM::BEGIN-LOOP (WHEN (&lt; I 1) (LOOP-FINISH)) (PROGN (SETQ #:ACCULIST-VAR-6657 (CONS I #:ACCULIST-VAR-6657))) (PSETQ I (- I 1)) (GO SYSTEM::BEGIN-LOOP) SYSTEM::END-LOOP (MACROLET ((LOOP-FINISH NIL (SYSTEM::LOOP-FINISH-WARN) '(GO SYSTEM::END-LOOP))) (RETURN-FROM NIL (SYSTEM::LIST-NREVERSE #:ACCULIST-VAR-6657))))))))))
Note that the html is `(&lt;em&gt; * &lt;/em&gt;)` which indicated he indeed typed (\* \* \*) but didn't escape the astericks and markdown mutilated his post. In the future, OP, either enclose the expresison in backticks, indent the line 4 spaces, or escape the astericks by typing \\\* instead of just \*.
This. Just noticed that myself, markup fail :)
Why did you submit this both to comp.lang.lisp and reddit? Is it on stackoverflow too?
Haha, hedging my bets/colleague who's also interested but hates reddit with a passion. I didn't bother with SO though.
If you are familiar with Eclipse, Cusp might be worth a look: http://bitfauna.com/projects/cusp/index.html http://sergeykolos.com/cusp/intro/ Also, where do you work? :)
When was that? I just picked CCL off the Win32 zip indicated, extracted it, and hi-de-high.
Ì'd install Linux; perhaps go for Ubuntu under VirtualBox if you need Windows for something -- and then go for SBCL + Emacs &amp; Slime there.
Practical Common Lisp uses Common Lisp, not Emacs Lisp.
There's no reason a beginner to Lisp needs the "overhead" of using another OS to learn the language. (And Zach Beane's [Quicklisp](http://www.quicklisp.org/beta/) eliminates the biggest headache of Lisp on Windows: installing libraries and their dependencies.)
Do you use Cusp? I haven't tried it out but am curious about how well it works. Do you like it?
Well, you could always just pull an interpreter from the MIT website, along with a complete PDF of of the textbook, 'Structure and Interpretation of Computer Programs'. Its a foundational textbook for CS and uses Lisp to teach all it's concepts. Links for both are: [here](http://mitpress.mit.edu/sicp/full-text/book/book.html) for the online version of the textbook, and [here](http://www.gnu.org/software/mit-scheme/) for the download page for the Scheme interpreter. It's integrated with emacs, so if you are already familiar with that you will pick it up quickly.
I think it is modeled after the Perl one, for better or worse. One complaint I would have, despite being a licensed LW user, are the LispWorks-only examples (Win32, Threads, maybe some others).
When I worked with it a year or so ago, it was functional, but still a bit buggy. I had to restart the REPL more than I would have liked. Really though, it was just bad enough to facilitate my move to emacs + SLIME and I've not looked back.
No, I'm an Emacs user. I have tried Cusp out of curiosity and at least at the time it seemed well featured and fairly reliable.
Funny, I'm not really used to Lisp, and it seems to be that it has to do so many things using words that other languages have simple syntax for.
Agree. Why does this site smell of a snow job, and not particularly well executed one, to me? People would be better off following the work at VPRI if looking around for funky fun ideas. At least Alan Kay has a \begin{understatement} decent \end{understatement} track record along with the visionary thing.
Asterisk in the value namespace is by default bound to the value of the last expression evaluated in the REPL. See: http://www.lispworks.com/documentation/HyperSpec/Body/v__stst_.htm#STSTST 