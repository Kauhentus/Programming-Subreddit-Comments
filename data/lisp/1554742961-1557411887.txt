You can look at the books section in the sidebar for some very good recommendations, when I got trough that process initially (I learned by myself), I read many books, I recommend based on my experience: * Practical Common Lisp (You can buy it or read it [onliine](http://www.gigamonkeys.com/book/)) * [On Lisp](http://www.paulgraham.com/onlisp.html) for better understanding of macros and some other concepts, Some people will recommend you other literature, but I think for grabbing the spirit of the language these are a good combination.
&gt; I vaguely remember it being architecturally bound to some ancient api or something of that sort You probably mean clx, based on Xlib; while the modern Xorg WMs use XCB; but there are a lot of other WMs still using Xlib, and the CL CLX package used IIRC is an updated fork.
FWIW, I'm somebody who in the past 6 months evaluated both CL and Clojure as a (hopefully) long-term platform investment and ended up with Clojure. There were aspects of CL that I really loved. The REPL experience was better, restarts are awesome, the fact that there's a spec with multiple implementations is a net win and someplace I hope Clojure gets to over time. However, there are two major things that Clojure gets right that I think Common Lisp gets wrong: immutability and the seq abstraction. In fairness to Common Lisp, these features weren't really available due to hardware constraints at the time, but we now have more than enough power and improvements in persistent data structures. Also in fairness to Common Lisp, both of these ideas were first implemented as Common Lisp libraries. Unfortunately, both of them are so fundamental to how they use the language, they really need to be the default, not just an addendum. These two features enable me to model my domain as just maps and sequence operations on maps, rather than dealing awkwardly with lists or being forced to reach for something heavier like CLOS.
I really liked Land of Lisp.
I like your article very much, I used to write a blog which I abandoned for no good reason, and I say this as someone who's made, publish and kept typos in the long run. Sometimes some typos (or wrong-edits) make the reader try to guess what you were trying to say, having a proof reader could help with that (some people suggest [grammarly](https://www.grammarly.com/?q=brand&amp;utm_source=google&amp;utm_medium=cpc&amp;utm_campaign=brand_f1&amp;utm_content=329885936582&amp;utm_term=grammarly&amp;matchtype=e&amp;placement=&amp;network=g&amp;gclid=Cj0KCQjw4qvlBRDiARIsAHme6otagE_aT2E8oB8l2BEbYXXkSCGkKzKvvT4M6iWGhjhJoFur6My-nb0aAo7AEALw_wcB) but I've never use it and for that reason I can't recommend it), Here are some things in your which are grammatically incorrect: * "..This mean" should be "This means". * "... and it's supporting functions" should be "... an its supporting functions" * "... run's an asynchronous shell command " should be "..runs an asynchronous command" * "The first thing we need to do it send a command:" should be "The first thing we need to do is send a command:" * " but here it's doesn't much matter either way. ", I think you meant "but here it doesn't matter much either way" I am not a native English speaker, but I hope I did not make any errors "correcting" you, in any case it is easy for you as the writer to read what you intended to write instead of what you actually wrote, so please just consider my inputs as the things a second set of eyes caught.
I actually do have that! Picked it up in a humble bundle a while back. It has b en enjoyable as I have been poking my way through it.
Awesome. Thanks for the recommendation. I haven't heard of those yet so I will have to check em out.
It was my first Common Lisp book, I found it very fun and educational. Asides from that the Lisp Alien has become an icon for the Language, I was just trying to minimize the amount of reading while maximizing the amount of core language concepts learned. But there are some really nice things on Land of Lisp that are not in the two books I cited (i.e. Lazy Lists, and some AI concepts). If the Op decides to start with this he must consider that some of the code is CLISP (mainly the excution of external programs), and there are a couple of wrongly written examples (I remember the hamburger one). In Practical Common Lisp, if he goes that route he should ignore references to "Lisp in a Box" and use Portacle instead.
If you have already been programming for some years in another language, try Practical Common Lisp. It would be the quickest induction to Lisp, in my opinion. &amp;#x200B; As for IDE, simply download and install Portacle, which will be an extremely easy way to get started. \~\~Note, this implies you know how to use Emacs, but Emacs itself also comes with a tutorial\~\~ YOU ALREADY USE EMACS? Praise Saint IGNUcius! Still, i'd recommend you to use Portacle instead of using your own Emacs installation, since Portacle is already highly customized for Common Lisp development.
&gt; So many people have trouble getting into Lisp because the only available editor is Emacs. Note: There is also a [Language Server Protocol (LSP) server for Common Lisp](https://github.com/cxxxr/cl-lsp) that should enable development using Visual Studio Code. In theory, there is also the Clozure CL IDE on Mac and the Corman CL IDE for Windows, however i have zero experience with them. I wonder how do they feel like compared to Emacs? Additionally, in the past we had the Jabberwocky IDE (made in Java) and Dandelion (Eclipse IDE Plugin), which as far as I know, are unmaintained nowadays.
I will look into. But I can't promise I won't just look at what packages it has and integrate them with my own. :)
&gt; Dandelion (Eclipse IDE Plugin), which as far as I know, are unmaintained nowadays. not actively developped, but maintained. It was updated to ship the latest SBCL, the author fixed some issues. https://github.com/Ragnaroek/dandelion
&gt; But I can't promise I won't just look at what packages it has and integrate them with my own. Lol, of course you will eventually customize your Emacs setup for Lisp. However, the suggestion to use Portacle is that it will help you focus full-time on learning Lisp, without any need to spend time doing emacs configuration and customizations. Also, Portacle comes with SBCL already installed \*, and it has both ASDF and Quicklisp installed, which means you'll be able to fetch complete libraries from the web and build your own "systems" in no time. \* which is, along with `'(CCL ABCL LW ACL ECL)`, one of the most awesome Lisp implementations out there.
Thanks for this info!!
Sounds good. I'll have to give it a shot.
Does SICP really utilize anything else than basic mathematics? After all, it's a freshman course. If you're looking for a book that just teaches Lisp, some are mentioned in the sidebar.
[HtDP](https://www.htdp.org/2019-02-24/)
It doesn't use any fancy math concepts, no category theory there. You should feel comfortable (as well as challenged) when digesting the SICP material. Don't search for easier alternatives. You will benefit from it, so I highly encourage you to push it through.
Computer Science Logo Style by Brian Harvey teaches much of the material in SICP, but using Logo as the instructional language. It's aimed at (bright) high school students so minimizes math prerequisites. Last I looked, the complete text was available online.
i.e. *How to Design Programs*. It's very frequently recommended as SICP-light.
Also, Simply Scheme by Harvey is specifically intended to fill the OP's need. It does use some custom code for its exercises. Both book and code are available. https://people.eecs.berkeley.edu/~bh/ss-toc2.html
Thank you sir and good luck on your journey
Thank you! I appreciate the help! Maybe I should look into grammarly for my next post :&gt;
From what I understand both "Lisp in a Box" and Portacle are emacs configurations? What makes Portacle the better one? It seems to be the one others recommend too, but I wouldn't mind a bit more background if you have is. Also I have started reading Practical Common Lisp so your information will be out to use. :)
&gt;What makes Portacle the better one? Portacle packages Emacs with SLIME, and SBCL with Quicklisp and ASDF. It is also actively maintained by Shinmera.
I think Lisp in a Box is not maintained anymore, asides from the Emacs configuration it does some other stuff, like installing SBCL and Quicklisp. I really never used it, I made my own configuration and installation before Portacle was a thing, and after trying Lisp in a Box and not liking it that much.
A few considerations: - Use `defparameter` for program globals, in this particular case you probably want to use something like: `(let ((sym-str (symbol-name s)) ...` - `fboundp` and `boundp` are fine, but there's also `symbol-function` and `symbol-value` - `(setf funcs (sort funcs #'string-lessp))` because `sort` mutates the source sequence - Style nit: use `-` hyphen to separate terms in a symbol instead of underscores - most (good) Lisp code out there follows some basic conventions - see [Google Common Lisp Style Guide](https://google.github.io/styleguide/lispguide.xml)
Does the vscode integration actually work? The last thing I want to do is recommend an editor and have it be a pile of half-baked, unmaintained junk. And that’s what everything that’s not Emacs+SLIME (or commercial IDE’s) seem to be.
Very nice, thank you! In your function async-run, the variable \*mode-line-shell\* is unbound, you probably meant \*async-shell\*?
Yes! That's what it was called on my personal config, but I changed it for verbosity, and missed that one. Sorry!
When I re-read the book a few years ago (many years since I was a freshman in college) I found the book assumed you quite familiar with basic calculus and electrical engineering. A reasonable assumption since it was a book for freshman MIT students. My memory of those things were quite rusty and led to some initial discouragement. &amp;#x200B; However I got past it with some googling and after a bit the books examples switch away from calculus and electrical engineering to topics such as interpretation and compilation.
If you're using Emacs anyway, the Emacs LISP introduction might be a good start because you'll learn things which are also really useful for you.
I came to write this. This book is a much better way to learn to program in my opinion. I did love sicp too though. Take a look at their paper, the structure and interpretation of the computer science curriculum for a comparison of htdp to sicp.
Just wanna randomly ask, why is &amp;aux considered a no-no? [https://google.github.io/styleguide/lispguide.xml?showone=Defining\_Functions#Defining\_Functions](https://google.github.io/styleguide/lispguide.xml?showone=Defining_Functions#Defining_Functions) \- as stated there.
&gt; (setf funcs (sort funcs #'string-lessp)) because sort mutates the source sequence That explanation is misleading (it actually makes it sound more like the `setf` is unnecessary!). You should say instead that while `sort` does mutate the input sequence, it doesn't always mutate it to the full result! For example: CL-USER&gt; (let ((a (list 3 3 3 2 2))) (values (sort a #'&lt;) a)) (2 2 3 3 3) (3 3 3) The return value from `sort` is the correct sorted sequence, the value it leaves in `a` by mutation is not.
Probably just because it feels out of place. The argument list feels like it should be just for arguments --or we should start calling it the argument and local variable list. Using `let` or the like within the function body expresses intent more clearly.
As far as I remember it only uses a bit of calculus. But not everyone learns that in high school (iprobably most MIT freshmen did learn it in high school).
For what it's worth I didn't know any electrical engineering at all when I read SICP and thought its explanations were sufficient.
&gt;(why should this be necessary?) To get thread support. :) It is weird though, the Linux and Windows SBCL binaries from [sbcl.org](https://sbcl.org) do have thread support. (The Windows one has an alarming warning about threads being experimental on Windows but they seem to work fine).
Hi Dylan, Welcome to Lisp. I see you have refactored your program. Just wanted to say that you usually don't really need to use SETF (or SETQ), it is more 'idiomatic' to use `let` blocks. For example this part: ``` (do-external-symbols (s "SB-EXT") (let (sym-str sym-size) (setf sym-str (symbol-name s)) (setf sym-size (length sym-str)) (if (&gt; sym-size word-size) (setf word-size sym-size)) (when (fboundp s) (push sym-str funcs) ) (when (boundp s) (push sym-str vars) ) ) ) ``` I'd rewrite it as: ``` (do-external-symbols (s "SB-EXT") (let* ((sym-str (symbol-name s)) (sym-size (length sym-str)) (word-size (when (&gt; sym-size word-size) sym-size))) (when (fboundp s) (push sym-str funcs)) (when (boundp s) (push sym-str vars)))) ``` Some notes: - Let (and `let*`) can initialize values, and this is what i'm doing on my example above. - `let*` is similar to `let`, however it executes the assignments in sequence, so sym-size can refer to sym-str with no problem. - See that word-size can have its value inside the `let*`, no need for a separate `setf`. - I am using `when` instead of `if`, it's usually considered good practice to use `when` (or `unless`) instead of `if`, when there is no ELSE expression.
The style guide says to not use intern ... why ? Its useful
Thanks for the welcome ! Ahh that explanation of let* is exactly what I was missing since I tried it as per your rewrite but with let and lisp was complaining I now understand why :) I’ll definitely use let* instead of setf.
Thanks for your feedback ! I’ve refactored my code with this in mind :)
Yeah, but I think it is misguided. One can easily think of many derived/constant parameters from input parameters which might as well be visually exposed as part of the arglist.
&gt; Ahh that explanation of let* is exactly what I was missing since I tried it as per your rewrite but with let and lisp was complaining I now understand why :) I’ll definitely use let* instead of setf. Just for rounding them all up: - `let` establishes bindings 'in parallel' - `let*` establishes bindings sequentially, so one can refer to the previous one - `flet` allows you to define local function bindings (= "local functions"), 'in parallel' - `labels` is like `flet` but this one allows any local function to refer to any other local function within the `labels`. This is useful, for example, for creating local functions that call one another.
Thanks :D I'm finding lisp to be very different to the programming languages I know and I'm enjoying learning about the language :D
&gt; The style guide says to not use intern ... why ? In normal situations you don't need to 'intern' a symbol manually, by calling `intern`. You implicitly intern symbols when... - you use a keyword in your code - you define a function with `defun` - you define a special with `defparameter` or `defvar` - ... ? \#'apply /u/lispm to correct my mistakes...
The style guide explains its reasoning. IIRC, whether symbols are GCed is undefined. For example LispWorks may GC unused symbols.
&gt; I'm finding lisp to be very different to the programming languages I know Yes. However there is a lot of influence on Lisp on many 'modern' languages. The following features you might find in other languages: - "everything is an expression" - last value is the implicit return value of an expression - symbols - garbage collection - values always have types, and those types can be inspected at runtime etc
Learn how to properly format s-expressions. Your code does not properly end them. Beyond that, learn how to use LET\*. You SETF where not needed, and it makes the code longer with no good use. Good work so far though!
Thanks, yeah I’m struggling with formatting s-expressions but I’m getting there ! :)
I suggest using an editor that can either balance them, or does them properly by default. We all know which editor-macros I'll refer to next, so I'll stop and close with Multi-line Indent: C-M-q.
Lol I’m new to Emacs and still trying to figure it out !
Might just be because I used to do assembly and similar coding in the past that I find Aux cleaner and prettier to use (Where variables have to be defined before use in its own section etc), which is why I wondered. Like making a macro with a gensym let binding, it might as well just be aux variables, looks cleaner and more organized.
How is this anything like a LISP? Or, if it's not at all, why do you state it as a LISP-like language? What is it you are trying to say by mentioning LISP?
It's not an easy operating system, but it does have a nice editor built in! Paredit or the like is essential. If I want a single (, or {. or \[. or ", I have to backspace over the automagically inserted close. :) Even more fun is that I use Spacemacs, so don't even ask about keystrokes! [http://spacemacs.org/](http://spacemacs.org/)
It really has nothing in common with any specific dialect of LISP, nor does it inherit LISP's more superficial attributes like the commands most dialects tend to have in common. &amp;#x200B; It's LISP like in the sense that it uses a code-as-data/data-as-code paradigm, that the base language isolated from any specific dialect is extremely minimalistic, and that the general flow control of the language is governed by something resembling prefix notation and a trickle down / bubble up pattern.
That sounds awesome. Can you tell me what the AST is for this code? `sum = 0` `for range { i, 3, 999 }` `if { i % 3 == 0 or i % 5 == 0 }` `sum += i` `print sum` How is that data? In other words, can you show me how that exact code is constructed using expressions written in that language, and then evaluated? In other words, here is the CL version of a quick glance of the code, but programmed using CL datastructures, and then that data evaluated as code. `CL-USER&gt; (list 'progn (cons 'defvar (list '*sum* 0))` `(list 'loop :for 'i :from 3 :upto 999` `:do (quote (when (or (eql (mod i 3) 0) (eql (mod i 5) 0))` `(incf *sum* i))))` `(list (intern "PRINT") (intern "*SUM*")))` `(PROGN` `(DEFVAR *SUM* 0)` `(LOOP :FOR I :FROM 3 :UPTO 999` `:DO (WHEN (OR (EQL (MOD I 3) 0) (EQL (MOD I 5) 0)) (INCF *SUM* I)))` `(PRINT *SUM*))` `CL-USER&gt; (eval *)` `466336` &amp;#x200B; &amp;#x200B; Cheers!
That example was written in a syntax called [ONE+](https://github.com/Gallery-of-Kaeon/Kaeon-FUSION/blob/master/Kaeon%20FUSION/Documentation/1%20-%20Foundations/2%20-%20ONE%2B/README.md), which is a syntactic superset of a language called [ONE](https://github.com/Gallery-of-Kaeon/Kaeon-FUSION/blob/master/Kaeon%20FUSION/Documentation/1%20-%20Foundations/1%20-%20ONE/README.md), using a preprocessor called [super mode](https://github.com/Gallery-of-Kaeon/Kaeon-FUSION/blob/master/Kaeon%20FUSION/Documentation/3%20-%20Standard%20Interface/1%20-%20Super%20Mode/README.md), which is what the "[USE: SUPER] [SUPER]" was for. ONE+ makes writing ONE by hand far easier, and super mode makes the code look more like Python. ONE is more or less a literal representation of an AST. When that particular example is converted to ONE, it looks like [this](https://pastebin.com/wgH6g0c4). Once the code is converted to ONE, it can be executed using the [FUSION](https://github.com/Gallery-of-Kaeon/Kaeon-FUSION/blob/master/Kaeon%20FUSION/Documentation/1%20-%20Foundations/3%20-%20FUSION/README.md) flow control rules. The only command Kaeon FUSION recognizes at the start of runtime is the [use](https://github.com/Gallery-of-Kaeon/Kaeon-FUSION/blob/master/Kaeon%20FUSION/Documentation/2%20-%20Interfaces%20and%20the%20Use%20Command/README.md) command, which super mode places in the generated ONE code implicitly to import the [standard](https://github.com/Gallery-of-Kaeon/Kaeon-FUSION/blob/master/Kaeon%20FUSION/Documentation/3%20-%20Standard%20Interface/README.md) and the stack interfaces. The use command dynamically modifies the interpreter's code at runtime by "importing" plugins, which can drastically alter the properties of the language. Once the standard interface has been integrated, it brings with it most of the functionality expected of a typical programming language, including variable and function support, basic IO utilities, math and logic operations, etc. The execution of the subsequent commands then proceeds about how you'd expect it to. First, sum, ForLim0, and For0 are declared as variables with values of 0, 999, and 3 respectively. Then, a new scope is declared and i is declared within it with a value equivalent to For0. Then another scope is declared, nested within the previous one. The new scope basically acts as an if statement within a loop, "breaking" if the value of i on the current iteration of the loop is not a multiple of 3 or 5. You'll notice that the outer scope ends with a loop command, which is basically a disguised GOTO which jumps back to the beginning of its parent's scope if given an argument of true. The execution ends with the value of sum being printed to the console.
If anything, I'd advise against using uppercase characters in Lisp symbols since the default reader upcases all symbols nonetheless. So, `defun adj` instead of `defun Adj`. And perhaps use slime/sly instead of a simple inferior Lisp buffer - you can access the debugger/inspector much easier with these toolkits.
Why are you having so much problem establishing connection to Swank? It should connect quite quickly if it's on localhost.
&gt; Does the vscode integration actually work? The last thing I want to do is recommend an editor and have it be a pile of half-baked, unmaintained junk. I have not tried it, because I only use VSCode occasionally. I fully agree with your sentiment.
If one decides to use VSCode, an interesting alternative is [VSCodium](https://vscodium.com/). It's purportedly a clone of VSCode without the pesky "telemetry" being sent back to the mother-ship using proprietary, non-open source code... [VSCodium](https://github.com/VSCodium/vscodium): 100% Open Source Version of Microsoft VS Code [https://itsfoss.com/vscodium/](https://itsfoss.com/vscodium/)
7pm UTC happens when this comment is 20 hours and 37 minutes old. You can find the live countdown here: https://countle.com/lVkdkl_El --- I'm a bot, if you want to send feedback, please comment below or send a PM.
Great, thanks for taking on this project, it's lovely to see it progressing. The gl stuff I mess around with seems good at causing issues so I'll try track down some more.
cool, now it's time to learn why there is a Printscreen button on your keyboard.
Yes that’s true. I had it hibernate but very often there is a problem connecting to Swank with repeated tries.
This is a troll. The git repo is just a few shreds of garbage code.
Wish I could upvote this twice
Wow. Ok. Thanks for the constructive feedback. Have a nice day,
You're off topic here.
This subreddit is dedicated to LISP. Given how my language is essentially a LISP dialect, albeit with a slightly different parsing model and syntax, I thought I'd post my project here in hopes that those familiar with LISP might have some feedback regarding it. I'm not looking for validation. It's fine if you don't like what you see, but I'd prefer it if you POLITELY specified exactly what you didn't like instead of just calling my code garbage and myself a troll. &amp;#x200B; Now, I'm aware that my implementation is shaky, but my goal with this project was to prove a concept, not necessarily to provide a polished, production ready product. The ability of my language to dynamically alter the code of its interpreter at runtime, and by extension to dynamically what is legal and illegal in the language, is to my knowledge unique among programming languages and, in my opinion, provides a better way to implement domain specific languages than what LISP offers.
Come on, at least try to make it look like a Lisp, and don't capitalise it as LISP. `WE DON'T LIVE IN THE SEVENTIES WHERE WE USE TELETYPES AND THEY LOOK LIKE THIS`. Pretty shite attempt for the weekly "I made a Lisp but it's not a Lisp because no s-expressions/dynamic typing/anything that makes a language a Lisp but it's a Lisp pls stop with the downvotes i'm trying new things"
You're so looking for validation, that it if you had "validate me" tattoed on your forehead, it would make things less clear. Anyway, using my matchmaking skills, I have found a good collaborator for your project: https://code.google.com/archive/p/mindforth/
Ok.
Alright.
Ok, so not a LISP-like at all. Have fun with it, but you should avoid lies.
Not necessarily. I'd say they wouldn't mind validation (who would), but for the most part desire constructive criticism, as opposed to your kneejerk banality.
Sorry, but could someone explain to me what the point of this post is?
Due to daylight saving time this would be 9pm instead of 8pm local time in Norway, sure this is correct?
PAIP is truly a great book, my first read was SICP followed by The Little Schemer, the seasoned schemer and the reasoned schemer. DISCLAIMER: in true programmer fashion I have not finished one of those books yet\^\^
It is a great book. In a few lines of code there is tremendous power and logic. I have read somewhere that this book can give you superpower in programming and that is true. One can discover the joy of programming in this book. Of course it is Lisp a so powerful language. Can get so much from that.
&gt; *It really has nothing in common with any specific dialect of LISP.* Elsewhere you called it a dialect of Lisp, which directly contradicts this statement. Are you retarded? Something that has "nothing in common" with the dialects in a family of languages cannot be another dialect in that family. Two languages are dialects if they have in common a significant mutually intelligible subset that is usable as a language on its own.
&gt; according to the comments section in one of the links below: credit is given in the third paragraph: &gt; Credit: The following was first written on z0ltan.wordpress.com by Timmy Jose.
Dang it :D Thanks mate. Yeah 8pm norway time
I also don't actually understand what we're supposed to be looking at here, I think I'm missing the point. Help me Obi-Wan.
I think "Worse is Better" is one of the factors. People have heard stories about how big a language Common Lisp is (yes, but it was big for its time - nowadays? Not so much) and how Clojure is simpler. However, I also think that it's indicative of our industry to automatically assume that "Newer is Better". Clojure is a Lisp that came later than Common Lisp therefore it must be better. Or, "More Popular Is Better" (isn't the most popular programming language PHP? What are we doing here!?! ;-)). Clojure gets more hype (on Hacker News and similar outlets) therefore it must be better. Battling this very human behaviour is futile. I tend to make up my own mind, look at new stuff, compare it to my aging toolbox (containing '70s things like "C", or "Smalltalk", and bits of this '50s language we're discussing here) and usually find it lacking. My company switched from the JVM to the Erlang VM, setting the clock back by a decade, and found that everybody is now much happier and productive (in Elixir, I grant you that, but that's a very thin veneer over a very old system). Older is Better :-)
sharing the joy of Lisp programming. Exchanging any useful comments even related to the code. The post has been inspired by the "generate" function in Peter Norvig's book which is a rich in information function; And later thought I will share my working screen with you.
Damn, this time, I won't be there. Sad ! pomdapimp
Hahah silly, everyone here use emacs. Next thing you're gonna say that some people here were too lazy to learn emacs and run their lisp in sublime text, that would be silly \* starts sweating a lot \*
Posted by u/\[deleted\] 20 hours ago Ok, now I'm trolling, but it's fun! :) [https://github.com/Gallery-of-Kaeon/Kaeon-FUSION/issues/1](https://github.com/Gallery-of-Kaeon/Kaeon-FUSION/issues/1)
But is the Print Screen button mentioned in the book?
I'm currently learning via exercism.io and I enjoy it a lot. Some exercises are reviewed, and you need the mentor's approval to start the next reviewed exercise. While waiting for a review, you can work on non-reviewed exercises. If you're stuck on an exercise, you can still look at other people's solutions.
https://github.com/google/lisp-koans
Its one of the exercises
maybe not quite SICP, but a good preparation for it and a lot of useful things can be found in [https://www.coursera.org/learn/programming-languages](https://www.coursera.org/learn/programming-languages) (there are 3 parts). It has some material from SICP, but of course in smaller doses :) awesome course. And the tutor uses 3 languages instead of just lisp. He uses SML, Racket, and Ruby. I would start with it.
I finally started following along with your blog posts this week, going line-by-line with the code and making sure I understand what I am doing. I am making small proofs as I go along. I break down fn's into their component parts and use the pure forms of the fns (e.g. axpy vs. axpy!) to make sure I can do the linear algebra in my head. There is quite a bit of content on your blog. So far it seems completely exhaustive on the topic of machine learning and linear algebra using Clojure. There is a lot of additional resources to back up your primary source. Keep up the good work!
Mobile upload is lighting fast. Took 5 secs instead of trying to print screen from an fr keyboard under slack, save then go reddit attach etc.. I am tired already....
There's a Print Screen button exercise? I guess I'll have to reread it.
Thank you for reading and trying it out. Please follow up with experience reports. I'm eager to hear how people are using it. As I am going to write a book, it's important to me to see what works for people and what needs more explatnation.
migth help: cl-exercise: a Common Lisp Learning System running on browsers coding schools, like Kattis competitive Programming websites like CodeForces, HackerEarth, HackerRank, and CodeChef. lastly, Peter Norvig’s book Paradigms of Artificial Intelligence Programming is available on Github https://lisp-journey.gitlab.io/blog/these-years-in-common-lisp-2018/
I went through these over the winter and learned a lot! Super useful! Now they live on as a quick reference when I forget something.
Something to consider... &gt;"Fundamentals are the psychological entry to a subject, and foundations are the logical entry. Fundamentals must be easy for the novice, while foundations can be hard for the expert. Learning a subject is movement from fundamentals to foundations." &gt; &gt;\- [Practical Formal Software Engineering](https://books.google.com/books?id=J0_YnjM2ahAC&amp;pg=PA1&amp;lpg=PA1&amp;dq=Fundamentals+are+the+psychological+entry+to+a+subject,+and+foundations+are+the+logical+entry.+Fundamentals+must+be+easy+for+the+novice,+while+foundations+can+be+hard+for+the+expert.+Learning+a+subject+is+movement+from+fundamentals+to+foundations&amp;source=bl&amp;ots=0bhvNc_MT4&amp;sig=ACfU3U05EMhfIAu-5ZcJFZOwIwcBYN1B7Q&amp;hl=en&amp;sa=X&amp;ved=2ahUKEwihzrPhw8bhAhUIBnwKHTA6CdwQ6AEwAHoECAkQAQ#v=onepage&amp;q&amp;f=false), Bruce Mills One sure method to begin the journey from fundamentals to foundations in learning Common Lisp is through immediate correction/feedback using the interactive "[LispTutor Jr](http://alarm.cti.depaul.edu/lisptutor/login)" online by ***carefully*** reading the lessons (take notes!) and doing the strictly guided exercises, and then completing all of the exercises / projects in the "[Land of Lisp](http://landoflisp.com/)" book. The primary advantages are that both are used at [university](http://reed.cs.depaul.edu/peterh/class/csc458/) and that LispTutor has been [proven](https://pdfs.semanticscholar.org/eb83/9c06ce9db59ed3279cec7df0f2fb09d9583a.pdf) to work. &gt;The original LispTutor was developed at Carnegie Mellon University by Reiser, Anderson, Corbett, Farrell and others. Lisptutor Jr is a simplified version of the system, but it is still used by many people interested in learning the classic language for Artificial Intelligence: LISP. &gt; &gt;[About](http://reed.cs.depaul.edu/peterh/tools.html) LispTutor Jr As quoted above, the original LispTutor interactive training system was created at Carnegie Mellon (home of CMUCL from which SBCL is derived). It has been used there, and at other schools, to teach Common Lisp. Its contents are derived from the insightful "[Essential LISP](https://www.amazon.com/Essential-Lisp-John-R-Anderson/dp/0201111489/)" book that was the result of AI research into what exactly does it take to teach students who've never been exposed to Lisp how to program in it competently. The special focus of the "Essential Lisp" book and the LispTutor is Iteration and Recursion, since those are often the most difficult for students to understand and internalize well. In fact, they cover things that no other Lisp book I've seen does, such as providing principles to help determine what the three primary variables in a particular Iterative structure should be initialized to. That alone helps reduce student error by avoiding over iterating or under iterating.
A related [question](https://www.reddit.com/r/lisp/comments/bboaz3/learn_lisp_with_checked_exercises/?utm_source=share&amp;utm_medium=web2x) was just recently asked. There may be [suggestions](https://www.reddit.com/r/lisp/comments/bboaz3/learn_lisp_with_checked_exercises/ekl2g81?utm_source=share&amp;utm_medium=web2x) of use there.
For similar reasons, I like to use &amp;aux to give local, lexical bindings to global variables that are going to be repeatedly used: ``` (defun p/element (input &amp;aux (ctx *ctx*) ...)) ``` It makes it easier to understand the function, and it gains (a small amount of) performance from avoiding the overhead of repeatedly using a global variable.
To implement a breadth-first traversal, you need a queue of remaining nodes to visit. That queue forms your "continuation", so to speak, so you don't lose track of any branches of the tree. That is to say, when performing breath-first tree traversal, you must refrain from recursing down into the depth. However, you must eventually visit everything; thus, you save the unvisited nodes into the queue. An alternative is to impement breadth-first traversal as a depth-limited depth-first traversal with iterative deepening. So that is to say, you do depth-first to depth 1, and visit all the bottom nodes. Then you do depth-first all over again to depth 2, and visit the bottom nodes, which are now the second level ones. Then repeat with depth 3 and so on.
Following [this recent /r/lisp discussion](https://www.reddit.com/r/lisp/comments/ba7zuw/solid_design_principles_in_common_lisp/), i wondered if anyone had done a writeup of CLOS OO vs. Java OO; i found this Quora post as a result. But if anyone knows of such a writeup, please let me know!
Really wish the videos are available as well, especially the keynote talks.
Could be even more interesting to read about vs Smalltalk OO and Scala OO.
Yes, i'd love to see those comparisons as well.
Yes, that was unfortunate. If I understand correctly, the problem was that ELS was co-located with the &lt;programming&gt; 2019 conference, which just happened to have no recording. (I'm not criticizing co-location here, I understand that it takes a huge burden off the shoulders of the ELS organizers.) &amp;#x200B; Good news is, ELS 2020 will be organized as a standalone conference and has great local organizers. So I am optimistic that there will be recordings next year.
Perhaps someone will help me, I cannot find it anymore... There was a book, I think the author's name was Krishnamurti, it used a language developed in Racket (it allows one to create languages other than Scheme), it was building all kinds of popular language constructs from ground and up. I thought the book was called something like PLAY... i.e. Programming Languages Something Something, but I cannot remember at the moment. It had no combinatorics / linalg / real analysis etc. kind of math (mind you that languages are math too, just of a different kind, so, programming is a kind of math, but then there are very few things that aren't math...) But, the book was similar in spirit to SICP in that it was building things typically found in modern programming languages from the very basic blocks.
I made a meat-and-potatoes single-dispatch, single-inheritance OOP system for TXR Lisp. It's still great to program with. Basically: "It's the Lisp, stupid." Not the OOP. The OOP has some nice advantages, to be sure, but the Lisp brings them out. A garbage language for imbeciles like Java retrofitted with a multimethod object system will still be a garbage language for imbeciles. CLOS can't be contrasted with Java or explained in terms that make sense in Java, because all the explanations will lead to the folowing problem: "I can't really follow any of the Lisp stuff you have there, but if I imagine that generic multi dispatch stuff put into Java, things don't suck significantly less, so I don't get the point.""
I am working on learning! My path to Lisp has been C++ -&gt; SQL(if you count that) -&gt; Python -&gt; Haskell -&gt; Lisp So I'll just be lurking here for a while.
Nice future directions for the CL Foundation: &gt; We would like to allow each project hosted with common-lisp.net to activate their own fundraiser &gt; Would like to provide convenient ways for projects to utilize continuous integration services across CL implementations &gt; Hosting of source code escrow with particular support for Common Lisp based projects and products
Implementing clojure's persistent vector and HAMT-based hash tables in guile. I have no idea how to do the transient stuff, but I suspect that will come to me when I really start grooking how the pvectors work.
Wrote a little pattern matching macro for working with the IR in my toy compiler. I should have time to refactor some of the optimization passes with it tonight. I probably need to look at how I handle closures soon.
I'm still working on v1 of [`cl-bodge`](https://github.com/borodust/cl-bodge) with stable API and proper documentation. Soon I'll start adding support for Tiled editor format into [`trivial-gamekit`](https://github.com/borodust/trivial-gamekit). In between those, I'm experimenting with C++ support in [`claw`](https://github.com/borodust/claw).
I have some projects i have currently on "private repository" until they're mature enough to be published: - a library for fast and automatic (encoding, CR/LF and delimiter detection) for data text files of almost arbitrary size. It's near ready. - (surprise suprise) this one shall not be disclosed yet, but it's a nice project that will hopefully showcase the elegance of CL for practical stuff - previously I was working on beating other programming languages at a particular benchmark one consultant posted on the internet, see [my Github](https://github.com/defunkydrummer/prime-bench) for more info. Long story short -- i got pretty decent results. within my company i'm also using it to parse some electronic invoicing documents (XML UBL format).
Started a bytecode-compiled scheme-like with delimited continuations. Haven't had as much time for it as I would like lately but it's been a blast.
A REST interface built on Neo4j (a graph database) that enforces a schema, which is defined within the database. The REST endpoints are constructed dynamically as requests come in, so it adapts to schema changes in realtime, and scales horizontally. Strictly, I'm building stuff on top of it, because those things are the reason I built it in the first place, but they're not yet in a state worth talking about. And I still have a lot of work to do on it yet: [https://github.com/equill/restagraph](https://github.com/equill/restagraph)
Cool! On what level are you implementing it? C?
Absolutely I count SQL. It may not be Turing-complete, but it's the canonical 4GL.
&gt; i got pretty decent results You certainly did! Following links to the consultant's page, TIL that SBCL is *"&gt; 100+ times faster than Common lisp"*...
Scheme :) The vlist implementation of guile is fast enough - within 1-2x of regular lists in guile 2.2 - and that is written in scheme. Guile 3 is getting even faster.
Welcome and keep lurking!
&gt; Following links to the consultant's page He needs to update it. I explained that SBCL is just another implementation of CL. He previously was using CLISP, and thought that CLISP = Common Lisp. A frequent misunderstanding.
I'm working on a game with cepl. So far I don't have a lot to show for it I'm just trying to get it to render primitives properly
Working on a templating engine to supplement LaTeX. I mean, LaTeX is cool, but different packages do interact and conflict too often, and sometimes little things need too much LaTeX code to work properly. And I'd rather write Scheme than tex macros. (I'm currently using Chicken)
I kind of wish CLISP would do a name change for this reason, or had done one years ago. Something as minor as retroactively picking a meaning for the C would help a lot, so people wouldn't be left guessing. "Clarification Lisp".
[deftask](https://deftask.com/), a task manager/issue tracker for teams, powered by SBCL and PostgreSQL in the backend. Although it only includes task management at the moment, deftask aims to do more than that. Putting the final touches to a brand new feature (notes), which should be out in a few days from now.
I have been lisping professionally for about 15 years, and never made that mistake. I may even look at people making that mistake as a sign that I should likely stay away from their code and writing. Is that right? Likely not, but it gives me an excuse :)
Well it's a newbie mistake, so I won't say you're wrong to avoid their code. But getting your bearings in the Lisp world is a tough time in a programmer's life, and I feel it's obnoxious of the project to add one more point of confusion without a reason.
I have been toying with ltk and nodgui, and it's been a very pleasant experience. The framework is simple and very discoverable. Also, for those not following: Tk actually looks decent nowadays ! [some notes and screenshots](https://github.com/vindarel/ltk-tests), [simple GUI for cl-torrents](https://raw.githubusercontent.com/vindarel/cl-torrents/master/assets/torrents-tk.png). We can develop the GUI interactively, and we can run Tk apps remotely. I'll carry on with a more complex app. And I did contracted work for Atlas Engineer !
&gt; I kind of wish CLISP would do a name change for this reason, or had done one years ago. Something as minor as retroactively picking a meaning for the C would help a lot There **is** a meaning for the "C" in CLISP: It's implemented in (mostly portable) C, so it can be (and has been) compiled in a *lot* of platforms.
Perhaps if that explanation were all over CLISP materials, that would be as good. The name's still unnecessarily confusing though.
Currently working on a new Lisp-dialect (https://github.com/codr7/g-fu) in Go. It's sort of a double win, I get to do it my way after years and years of jumping Lisp hoops; while potentially trojan horsing some magic into the Go community, which is my only hope if I'm ever going to work in the language. It's still fresh and very much aiming for correctness and finding the best way to express what I want to say in Go rather than performance.
Still slowly adding onto the ncurses-based TUI library [croatoan](https://www.cliki.net/croatoan). * Support for [menus, 256 colors](https://i.imgur.com/iywc1iG.png) has been implemented for some time * Working on [forms](https://i.imgur.com/DdILSyF.png) support these days.
I'm working on a set of tools for Super Mario 64 rom hacking. I currently have a level script assembler and disassembler.
I'm currently exploring [Lisp options for GUI programming](https://github.com/goober99/lisp-gui-examples). I've finished examples using the Racket built-in GUI library and LambdaNative. I'm currently working on porting the example to Clojure using the fn(fx) bindings to OpenJFX.
Trying to finish this iup gui stuff I started
Nice 👍 where will ELS 2020 be held?
what is iup gui?
Wow! This seems like a big endeavour. Do you plan to translate s-expr to latex macros or something else?
I started working with a graph database namely tinkerpop but figured that it is not what I need because, at the time, it did not support range queries.
&gt; Atlas Engineer Is this https://atlas.engineer/about ? I already stumbled on their website. Seems like a nice company to work for.
Proof-reading my latest LISP book.
I am working on: - [Netfarm](https://gitlab.com/cal-coop/netfarm), a distributed object store with signing and "mutability" through use of a seperate update list for objects among other useful "traits" which I do not have a better word to describe - Some kind of very small most-of-Scheme bytecode system. There's tail recursion and I'm considering making the only mutable values boxes, but I'm not sure how practical that would be.
I did not know about lispmemes. Tx!
Let us know when it is ready!
Cross platform GUI library for using the native widgets on each platform. https://www.tecgraf.puc-rio.br/iup/
yes and yes. The one that posted a job announce two days ago. They contacted me not so long ago. It is worth having public projects and blogging and all that :)
wow ! What kind of book is it ? What Lisp and what topics ?
yes please ! I'll help later on :)
he's doing this: https://www.reddit.com/r/Common_Lisp/comments/au0dmv/more_iup_gui_stuff/ IUP is a GUI framework. http://webserver2.tecgraf.puc-rio.br/iup/
I'm currently creating a calendar program, from the ground up with parsing ICS files, to full GUI. Currently I have a working terminal interface, and is cursing over timezones. The plan is to soon start working on the actual graphical parts (and keep cursing over the lack of good GUI alternatives for Guile). https://git.hornquist.se/calparse
Awesome. Invitation to add these screenshots to the repository/readme.
in my college we have a class simply called programming languages where we go through multiple languages and get a feel for them. this last one is lisp so currently working on a "Game Of Life" Variant. And i can tell you that whoever created LISP and all its everything had satan or something in mind.
I'm trying to become as proficient in Hy as I am with python. Elisp is the only lisp I am more or less proficient in, and while I'd love to learn some more common lisp....I need the scipy stack. And I don't want to mess with the interop layers.
I'm a Guiler and Guix lover, who is this person I am talking to? I don't recognize the username
Couple things, one is a GS1 (the big old spec for barcodes for coupons and medical items, etc) parser and verification tool to go along with it. Another is an extendable DPS parser and trigger notification for a video game. This one is more of a learning project, I want to support multiple games but first I want to be able to configure triggers and notifications in app in lisp. I recently did some batch processing in GIMP and it felt so right. Lisp just feels like an incredible tool for building such a system, initial playing around with the idea has yielded some very well performing notifications and it's been a real blast to build. I've recently come back to lisp so am learning allot and just generally having a blast. Haven't had this much fun building things in years.
&gt; ltk If you have a reasonably easy solution to display nice data tables in LTK, i'm all ears, please PM me or mention me so I get to notice it. I really liked LTK's elegance and documentation, but suffered the lack of widgets. And seems that i need to have a good understanding of TK and its ecosystem to be able to use other widgets.
Subscribe and choose your flair!
This is awesome, thanks!
&gt; Trying to finish this iup gui stuff I started `(incf encouragement)` I'm already watching your GitHub repo!
&gt; I need the scipy stack. Don't forget to take a look at these: https://www.cliki.net/linear%20algebra And also (used in production by a company that does actual quantum computing) https://github.com/rigetti/magicl And if you want to leverage CUDA https://github.com/takagi/cl-cuda
&gt; Lol I’m new to Emacs and still trying to figure it out ! Download [portacle](https://portacle.github.io/) and follow its built-in tutorial, it should be helpful.
I'm working on a debugger for TXR/TXR Lisp. I deleted the crappy old one out already, and have implemented some needed infrastructure work. Debugged code will throw exceptions, and will be restarted likewise. It has to handle the virtual machine compiled code as well as interpreted.
The entire video is interesting for anyone interested in contemporary classical music or strings, as Samuel Andreyev is a great explainer. I've bookmarked the time where some of the actual Lisp code behind the composition is showed off. OpenMusic was posted in this subreddit years ago, and the software is still being developed, last release in December '18. Can't speak to what's changed as I haven't dived in myself just yet, but I'm very excited by it: It is Lisp software that I didn't know existed and was therefore dreaming of an inferior version of.
Working on a program synthesis program in Common Lisp. My goal is to be able to describe a program to my IDE and it should be able to write it itself, and then I can eventually tweak it. It is based on evolutionary programming l, but I'm planning to also throw in macros when the time is right (when I've mastered them) and use a mixture of the two. Until then tho, my engine just does really simple symbolic regression.
Cool. Bloggin about application of Lisp was something I had hoped to start this year.
In the vein of Scribble?
Cool! This is written in common lisp?
The screenshot is from a very old pre-Macos-X version of PatchWorks written in Macintosh Common Lisp.
I go by the name manumanumanu in the irc channel. my only claim to fame is my version of racket's for loops in guile: https://bitbucket.org/bjoli/guile-for-loops They are zero cost in the sense that the guile optimizer makes my loops as fast as hand rolled named lets, and macro expansion costs are small.
The composition is from 1995 so I'd assume approximately that timeframe. Since your posts it looks like a lot of work has been done on OpenMusic. A shame that building it still requires LispWorks.
Yeah. I wrote a library in C to handle file IO and ROM addressing, but most of the assembler/disassembler was written in CL.
Not sure why it is a 'shame'. PatchWorks and later OpenMusic used be developed with Macintosh Common Lisp - which was a single-platform commercial Lisp implementation. LispWorks has the a viable cross platform GUI library for their purposes and it replaced MCL, since MCL as a product was discontinued. The OM6 port to Linux also used LispWorks. There is a new version in the works. https://openmusic-project.github.io/om7/
ELS 2020 will be held in Zürich. &amp;#x200B; Some more good news: I tracked down the recordings of ELS 2018 and they might be released 'soon'.
Will do!
It is essentially an extended and updated version of [Scheme 9 from Empty Space](http://www.t3x.org/s9book/index.html) that covers many of the techniques used in the [new Scheme 9 interpreter](http://www.t3x.org/s9fes/index.html), but it goes beyond that. It is currently above 400 pages and will discuss the design of an interactive LISP environment that compiles to abstract machine code. The implementation is not a toy LISP and many design decisions will be explained and alternatives shown. It's quite a piece of work ahead, but maybe I will manage to publish it this spring. I hope so!
I can only think of a scrolled-tree with columns, I don't think there is a specific widget for that. &gt; lack of widgets true. nodgui has a bit more widgets: https://notabug.org/cage/nodgui: scrolled-treeview, date picker (not looking native, but doing the job), password entry, progressbar, tooltip, autocomplete listbox, history entry,… and the author is very helpful.
Some more music/audio projects :) https://github.com/CodyReichert/awesome-cl#audio
That's how you invoke it. Are you sure the file is present and spelled correctly? If you simply launch it and do (load "filename.lisp") does i work?
I'm currently working on getting a CFFI-based COM library for getting at Windows API's you can't just through function calls. Then on top of that I'm planning on making a similar library for WinRT components. All this because somebody wanted to send Toast notifications on SBCL. (joking, I've needed this sort of functionality before but always hacked my way around it)
I have the review and testing of some PLN additions to CCL at the top of my to-do list. In my other copious spare time :) I'm trying to get a mutation testing package for Common Lisp up and running, so I can apply it to various QL packages and possibly SBCL internals.
I needed to type in the path instead of the name and that worked. Maybe I just have it in the wrong place?
Related: http://harleqin.github.io/2015-12-30-generic-functions-and-multimethods-versus-visitors-and-factories.html
Very cool! At first glance, this reminds me of [nested rhythmic language called prop](https://pbat.ch/proj/prop.html) that I wrote some years ago.
I bought the 2014 version of Scheme 9 from Empty Space. Thoroughly enjoyed it! Looking forward to a new edition - especially that compilation to abstract machine code stuff!
I enjoyed http://www.4clojure.com And it's not exactly what you asked for, but there's a nice math and video game curriculum here: https://www.bootstrapworld.org/materials/spring2019/ The nice thing about writing video games is that there are implicit checks based on whether your game "works".
I actually already have large LaTeX documents that need "fixing". So I can't do much more than write code that will do substitution where LaTeX won't easily do.
I'd still be curious to see it, if you get it to the point you feel you can share it.
Thanks stranger, this finally got me started to learn lisp. I would have never heard of this otherwise.
You're welcome! If using the LispTutor jr, I would recommend selecting the "Mastery" option rather than the "Traditional" option when asked how to start the lessons. And, if sample code is listed in the lessons, typing them in and running them can help better understanding. This is especially true for the first chapter on Iteration (Chapter 3), because this version of the LispTutor doesn't have exercises for that chapter (there are exercises for the Recursion and the advanced Iteration (Loop Facility) chapters that follow). But, it is still a critical chapter to read and the lesson's code should be entered and run and modified and tested until there's a solid understanding of how to plan / design an Iteration using the provided rules on properly initializing the interdependent loop variables based on the type of loop one is creating. The exercises are best approached as a puzzle / game, because there may be more than one correct answer to a given exercise, but only one of them is being asked for by the exercise. So, experimentation is sometimes in order. If stuck on any of the exercises, then typing / running / testing code outside of the exercise screen might help loosen the answer from the old noggin'. All of the exercises provide an example of what a valid output should look like when the correct source code has been entered in the exercise. Look around the exercise screen for hints. All of the possible Lisp primitives that could be used in the answer are listed at the top and to the left side of the screen. Brute force in attempting some or all of those primitives is a valid problem solving method / heuristic to obtain the specific answer being asked for if nothing else comes to mind after reasoning / testing things out first :-)
I am working on making part of the SRFI Scheme standard the work I have done around databases, in order: - https://github.com/scheme-live/ordered-key-value-store - https://github.com/scheme-live/generic-tuple-store-database - https://github.com/scheme-live/immutable-quadstore
Since you already have an asd file you can (asdf:load-system :havoc) to load your project. (ql:quickload :havoc) also works (because quickload is a wrapper over asdf.) If you learned Roswell already then look up "how to distribute a script" Wiki page. make a roswell/ subdir in your directory (sibling of src) and ros init there to make your script.
32 years ago, a project programmed in C and LISP being called CLISP was not confusing. Perhaps you are confusing the fact that Common Lisp was not really a language at the time, but a description of what dialects have/should have in common? The CL standard did not come out for another 7 years after CLISP was launched. If you find it obnoxious to not pander to potential newbies 30+ years in the future, that is your decision, and one that is not taken lightly. Thank you for validating my excuse :P
One thing we should mention is that ASDF does not by default look into the current directory, it has a list of directories where it looks for systems ( asdf:\*central-registry\*), you can push your directory there before attempting the asdf:load-system. However, my recomendation is to place your project on \~/quicklisp/local-projects, and load with quicklisp (ql:quickload :havoc).
It's my understanding that at least as early as 1992 when version 1 was released, CLISP was meant as a Common Lisp implementation, which was possible with CLTL being out, even if the ANSI standard didn't exist. I wish I could dig up some early project announcements, but no luck. Anyway, I don't care who has dibs. This has been confusing people for literally decades. It can't be a good thing for CLISP or CL if every Lisp newbie has to get publicly corrected on this point. Say what you want about keeping undesirables out, CL is nowhere near being overpopular. Anybody learning the language is welcome in my book (as opposed to skimming *On Lisp* and proceeding straight to trolling).
The name was placed on the project a long time before version 1 came out. While I understand what you are getting at, I have been using linux full time for a while now, and my first kernel was a 0.96. There is, in fact, a lot of software that I use long before a version 1 is released. When I started lisping professionally, people confused GNU Common Lisp with CLISP, because of the simple fact that CLISP had to adopt the GNU General Public License and became a part of the GNU Project, and was known as GNU CLISP by some. People confuse Linux with GNU/Linux. People confuse C with K&amp;R C, ANSI C, ISO C and Standard C. People confuse chords with triads. People confuse RGB with CMYK. People confuse JScript with ECMAScript with JavaScript. And that is, sort of, why I like working with Lisp based companies. I do not use popularity as a gauge for quality, and in fact, often the exact opposite holds true. So if the name of an implementation versus the name of a programming language versus the name of a standard prevents popularity from taking hold, it almost separates the wheat from the chaff, for my personal tastes, as it were. That's just my personal opinion, as the lack of cares means I don't spend my time judging an implementation based on newbie confusion regarding the naming scheme. I avoid CLISP for many other reasons :P If you think it is not a good thing for CL or CLISP, that's your opinion, and I respect your right to have such a thing. In the end, I care not. Peace Out.
If you prefer to NPM way of I think Roswell is the way to go. But either way, you don't need to load each file every time you spin a new REPL. that's what ASD is for. Load the files using `(asdf:make "havoc")`. ASDF will take care of loading the files, normally from FASLs (FASt Loading files) unless one of the files has changed then it will rebuild it and the files they depend on. Because ASDF only looks into your local filesystem instead of calling make directly you'll normally use `(ql:quickload "havoc")` which in case you depend on a library that isn't present in your local filesystem it will download it before calling ASDF. For subsequent calls you can call ASDF:MAKE directly but why do the bookeeping? The save-lisp-and-die is when you want to build an executable. I would recommend using ADSF's built-in build-operation for that. It is listed in the cookbook you linked it.
Minor comment, you seem to specify fixnum a lot, presumably because you want unboxed integers. The size of a fixnum is implementation dependent, so you could instead specify the size of the integer you want \[say (integer 0 255)\] and let the implementation take care of the rest. Your histogram-bin has different limits in SBCL it is (1- (expt 2 62)) while on CCL it is (1- (expt 2 60)). [https://github.com/defunkydrummer/auto-text/blob/master/histogram.lisp#L24](https://github.com/defunkydrummer/auto-text/blob/master/histogram.lisp#L24) Because classes don't use the type argument it serves mostly as documentation, so its better to use integer I'd use integer for something like csv-config [https://github.com/defunkydrummer/auto-text/blob/master/csv.lisp#L48](https://github.com/defunkydrummer/auto-text/blob/master/csv.lisp#L48) And this is a major nitpick that I see around a lot don't start your files with (in-package :common-lisp). If you are really worried that the current package doesn't use the CL package do (cl:defpacakge ...) and (cl:in-package ...).
&gt;Minor comment, you seem to specify fixnum a lot I have fixnum fetishism. &gt;and let the implementation take care of the rest. Your histogram-bin has different limits in SBCL it is (1- (expt 2 62)) while on CCL it is (1- (expt 2 60)). &gt;https://github.com/defunkydrummer/auto-text/blob/master/histogram.lisp#L24 I understand, and thanks for pointing out the exact line of code. In that line, I'd need the biggest high-performance integer available, since i don't know the file size in advance. But maybe i should specify unsigned integer to 2^60 instead. &gt;This is a pet peeve of mine that I see around a lot don't start your files with (in-package :common-lisp). Yes, lispm did the same observation.
I currently have my projects with the others, in `~/Documents/lisp` but I guess I can move them somewhere else. I don't like having a `~/quicklisp` directory though, can I make that a `~/.quicklisp` ?
LispTutor jr a very good option to start learning Common Lisp. I'll repeat/consolidate some of the things I've previously mentioned in other posts here. If using LispTutor jr, the "Mastery" option may lead to more lessons than the "Traditional" option after logging in. If sample code is listed in the lessons, then typing it in one's own Lisp editor/environment (ex: [Portacle](https://portacle.github.io/)) and running/playing with it can help improve understanding. This is especially true for the first chapter on Iteration (Chapter 3), because this version of the LispTutor doesn't have exercises for that chapter (there are checked exercises for the Recursion and the advanced Iteration (Loop Facility) chapters that follow). But, it is still a critical chapter to read and the lesson's code should be typed / run / tested / played-with for different made-up scenarios until there's a solid understanding of how to plan / design an Iteration using the provided rules on properly initializing the interdependent loop variables based on the type of loop one is creating. The exercises are best approached as a puzzle / game because there may be more than one correct answer to a given exercise, but only one of them is being asked for by the exercise. So, experimentation is sometimes in order if the lessons were not carefully studied or well understood before moving to the exercise. If stuck on any of the exercises, then typing / running / testing code outside of the exercise screen using one's own Lisp edit/environment (ex: Portacle) might help brainstorming better. All of the exercises provide an example of what a valid output should look like when the correct source code has been entered in the exercise. Look around the exercise screen for hints. All of the possible Lisp primitives that could be used in the expected answer are listed at the top and to the left side of the screen. Brute force in attempting some or all of those primitives is a valid problem solving method / heuristic to obtain the specific answer being asked for if nothing else comes to mind after reasoning / testing things out first :-) A good approach in using LispTutor Jr is to combine it with another learning resource. After carefully reading the lessons (don't skip *any* AND *do* take notes!) and completing all of the strictly guided / checked exercises, then one can then complete all of the exercises / projects in the "[Land of Lisp](http://landoflisp.com/)" book. The primary advantages are that both are used at [university](http://reed.cs.depaul.edu/peterh/class/csc458/) (perhaps, increasing confidence in the approach) and that LispTutor has been [proven](https://pdfs.semanticscholar.org/eb83/9c06ce9db59ed3279cec7df0f2fb09d9583a.pdf) to work. &gt;The original LispTutor was developed at Carnegie Mellon University by Reiser, Anderson, Corbett, Farrell and others. Lisptutor Jr is a simplified version of the system, but it is still used by many people interested in learning the classic language for Artificial Intelligence: LISP. [About](http://reed.cs.depaul.edu/peterh/tools.html) LispTutor Jr As quoted above, the original LispTutor interactive training system was created at Carnegie Mellon (home of CMUCL from which SBCL is derived). It has been used there, and at other schools, to teach Common Lisp. Its contents are derived from the insightful "[Essential LISP](https://www.amazon.com/Essential-Lisp-John-R-Anderson/dp/0201111489/)" book that was the result of AI research in determining what it takes to teach students who've never been exposed to Lisp how to program in it competently. The special focus of the "Essential Lisp" book and LispTutor is Iteration and Recursion, since those are often the most difficult topics for students to understand and internalize well. In fact, they cover things that no other Lisp book I've seen does, such as providing principles to help determine what the primary variables in a particular Iterative structure should be initialized to. That alone helps reduce student error by avoiding over iterating or under iterating.
Explaining this will depend on understanding how well you understand lisp. If you're pretty novice, stick to not using macros. Once you appreciate the fact the lisp code is structure of lists and symbols and not text (text is just one way of representing the symbols and lists), the explanation of these macros will start making more sense. But to be a little more helpful, use \`macroexpand\` to see what happens when you invoke the macro. For instance in sbcl: \`\`\` \* (defmacro += (var num) \`(setf ,var (+ ,var, num)) ) \+= \* (macroexpand '(+= foo 2)) (SETQ FOO (+ FOO 2)) \`\`\`
Always indent properly, so you can read the code: (defmacro iterate (var start end countBy &amp;rest bodies) (let ((var2 (gensym)) (var3 (gensym))) `(do ((,var ,start)(,var2 ,end)(,var3 ,countBy)) ((not(&lt;= ,var ,var2)) T) ,@bodies (+= ,var ,var3) ) )) There's three main tools to understand here: backquote is a template, `gensym` is used to make new variable names, and `do` is an (old-fashioned) general looping feature. You can look up references on those. The macro idea that won't be in a reference is that the `let` binds `var2` and `var3` at macro expansion time, so that the names returned by `gensym` are available to substitute in the backquote.
I recently open-sourced an implementation of the \[actor model\]([https://github.com/j3pic/simple-actors](https://github.com/j3pic/simple-actors)) I wrote a few years ago, and then used it to write a tool to deploy Serverless services (for those who haven't used Serverless, it's possible to build multiple projects that depend on each other at deploy-time, but Serverless itself only supports deploying a single project. It's a pain in the ass to deploy multiple services that depend on each other, and there are zero tools for it). &amp;#x200B; Although Serverless is a JavaScript thing, I wrote the deploy tool in Lisp because there are a number of things about it that made the job easier. The tool supports orchestrating a rollback across all the services if any of them fails to deploy. This rollback can either be initiated interactively via a restart menu, or through a command line option.
Common Lisp already has `incf`. `(incf var 42)` will increment `var` by 42. The `+=` macro is an incorrect reimplementation of `incf` that evaluates the place twice.
When you first install Quicklisp, you can call the install function like this: &amp;#x200B; (quicklisp-quickstart:install :path (merge-pathnames ".quicklisp/" (user-homedir-pathname)) &amp;#x200B; That puts the Quicklisp dist in \`\~/.quicklisp/\`. Be sure to include the slash at the end of \`.quicklisp\` or Quicklisp will be installed directly under \`\~/\`, as a consequence of how \`merge-pathnames\` works.
Since you have installed quicklisp via roswell, there is ~/.roswell/local-projects. If you have a directory that stores all of your lisp projects, I recommend creating a symlink to that directory under local-projects, since the projects are searched recursively. i.e. ~/.roswell/local-projects/lisp -&gt; ~/Documents/lisp .
Some time ago I created this project for a similar purpose: https://github.com/wvxvw/sudoku-solver . At the time Roswell wasn't that popular (I'm still not using it, but I guess, it's because I'm almost not writing in CL anymore). I didn't try to address some of the issues you are trying to solve, viz: creating binaries. I think ASDF had something to say about it. I.e. there should be a way to do this in a "more portable way" (not all Lisps have that option / implement it wildly differently).
Yeah, I'm using a makefile for that, and I have the build instructions for ASDF in the .asd file. The thing I didn't know is that I had to declare my main function as an external one in the package definition (defpackage #:hello-world (:use #:cl) (:export :main))
thanks, I'll be sure to check it out
It is not necessary to export the symbol. You can simply refer to it using two colons instead of one, i.e.: (sb-ext:save-lisp-and-die ... :toplevel #'my-app::main-function ...)
Also, the AI winter was not caused by Lisp, but rather by lack of pre-research, bad hardware and *COST*.
You can put yout projects anywhere you want if you just [configure ASDF to find them](https://common-lisp.net/project/asdf/asdf.html#Configuring-ASDF-to-find-your-systems).
When you install quicklisp that directory (without the .) is made for you, so you already have it. Having your projects in local-projects, makes it so as long as you have a asdf file you can load them from there with quicklisp.
haha Well I pulled a finger out this week and began the tutorial docs.
I also appreciate the RSS feed (had looked and not found one before).
Why not compile TeX into Lisp and run LaTeX inside it? You might be able to include arbitrary hooks into Lisp code, then.
Fixed, committed and pushed.
I would be careful when using that website. 'Jean-Phillippe Paradis', the inventor/maintainer of this site, is unwilling to remove people from his website on request, unless they read a bunch of drivel he calls 'policy' and one registers oneself for some bogus reason. It's then unclear what the effect then is. I haven't given him a permission to list my name, my social media accounts, my homepage, etc. Still he refuses to simply delist me. He has some mental issues and unfortunately enjoys the negative attention he gets.
I have some working sketches and drafts. I'm scoping for ideas what should be in such library before making the software public. Comments much appreciated.
Very interesting; is the screenshot from a linux build?
yes, first window is in the listener and the second is a standalone window stream started with a similar function call (but outside the context of an application frame).
What would I need softwarewise, to reproduce these charts?
when are we going to see an OpenGL backend for CLIM?
Looks cool!
I've been following progress of this library on IRC, and I'm looking at integrating it into Climaxima. Hopefully this will be a good test of reusability.
Just McCLIM and the library (which is not published yet).
As far as I'm aware nobody is working on OpenGL backend for CLIM at the moment.
That's a real shame. I'd love to have utilities such as this graphing app on windows without having to set up the windows development environment.
how about Scigraph?
I've tried to use it but it doesn't fit my needs. It could be that McCLIM is simply not ready for it (random bugs and rendering problems), or it may be that its design was limited by the fact that it was meant to be portable across various lisp rendering mechanisms (like dynamic windows). Also I find it hard to use.
On a Lisp Machine in CLIM: [scigraph example](http://lispm.de/lisp-pics/Graph%20in%20CLIM%20on%20Genera.png)
Since we are at it, do you happen to have scigraph documentation? README in Scigraph bundled with McCLIM has a dead link, I'd love to have it in the repository (even if I'm not going to use this software myself). As of differences worth highlighting: - charts are output records with helpers to make them standalone sheets or frames (by means of adding them to the output record history) - stream interface is modeled after format-graph-from-roots and format-items (with some twists) - having stream interface means that we can render chart to a file (for output-only backends like postscript or png) There are other ideas I have but they are too vague to put them as statements.
&gt; Since we are at it, do you happen to have scigraph documentation? http://lispm.de/docs/CLIM/scigraph.zip
Thank you, I've put the file on mcclim website and added the reference in the README (https://github.com/McCLIM/McCLIM/commit/dda0fad17b948d3635548465ee0ac0e86247e634).
I wonder if it's possible now to make a full-featured CL IDE with this, Juno style.
try (defvar *xxx* 17) (defclass foo () ((bar :accessor bar :initform *xxx*)))
Probably along with (defmethod make-instance :after ((foo foo)) (incf *xxx*))
&lt;TELL "It seems that the "&gt; &lt;COND (&lt;VERB? DROP PUT&gt; &lt;TELL D ,PRSO&gt;) (T &lt;TELL D ,PRSI&gt;)&gt; &lt;TELL " didn't agree with the boat, as evidenced by the loud hissing noise issuing therefrom. With a pathetic sputter, the boat deflates, leaving you without." CR&gt; &lt;COND (&lt;FSET? ,HERE ,NONLANDBIT&gt; &lt;CRLF&gt; &lt;COND (&lt;==? ,HERE ,RESERVOIR ,IN-STREAM&gt; &lt;JIGS-UP "Another pathetic sputter, this time from you, heralds your drowning."&gt;) (T &lt;JIGS-UP "In other words, fighting the fierce currents of the Frigid River. You manage to hold your own for a bit, but then you are carried over a waterfall and into some nasty rocks. Ouch!"&gt;)&gt;)&gt; &lt;RTRUE&gt;) Yup. I was distantly aware that those games were written in a Lisp dialect, but seeing how Lispy it really is, is kind of lovely.
I mean, I can bet that I can write some basic reader macros and operators that will allow me to parse this code and execute it in Common Lisp.
see the original MDL-based Zork: https://github.com/historicalsource/zork
This works, but I'm looking for a solution that does not involve globals.
Reevaluate the `DEFCLASS` form with a different `:INITFORM`.
I'd like to avoid having to rewrite all the other slot definitions.
You don't need globals to store this value. You can store values within the class itself, in a class-allocated slot. (defclass foo () ((bar :accessor bar) (bar-initvalue :initform 17 :allocation :class))) (defmethod initialize-instance :after ((obj foo) &amp;key &amp;allow-other-keys) (with-slots (bar bar-initvalue) obj (setf bar bar-initvalue) (incf bar-initvalue))) (bar (make-instance 'foo)) ;; 17 (bar (make-instance 'foo)) ;; 18
Using SWANK-MOP I found out that I can do (setf (swank-mop:slot-definition-initform (first (swank-mop:class-direct-slots (find-class 'foo)))) 17) and it does exactly what I want. I guess SWANK is good enough for portable MOP functionalities. Any other package recommendation? I've only heard about `cl-mop` or `closer-mop`, not sure how useful they are for this use case compared to SWANK.
imo the most clean solution is what @Grue proposed. Relying on the slot order here (and on swank-mop) doesn't make much sense. If you must work with moppery use closer-mop which is meant as the application programmer library (in contrast to swank-mop which is there for slime usage).
`first` was just for the example, of course I to do this properly I would find the slot whose name matches (e.g. with `swank-mop:slot-definition-name`). But you are right, closer-mop is probably the library I should use then. Thanks for the pointer!
Here is the final answer: (setf (closer-mop:slot-definition-initform (find-if (lambda (slot) (eq (closer-mop:slot-definition-name slot) 'bar)) (closer-mop:class-direct-slots (find-class 'foo)))) 18)
Wow, now that's archaelispology!
...and, necrolispancy!
Thanks for sharing. The mop is really powerful. Just out of curiosity, why do you need to do something like this?
Working on [Next browser](https://next.atlas.engineer/), I want to implement buffer-local variables and be able to set their default value. I figured that a CLOS class would be a perfect fit. More generally, I want to have &lt;whatever-class&gt;-local-variables, e.g. window-local-variables.
(Still) Working on my Lisp [music sequencing/pattern library](https://github.com/defaultxr/cl-patterns/). Just recently pushed some big improvements to backend handling, the clock (event scheduling), and the [Incudine](http://incudine.sourceforge.net/) backend. I'm making pretty good progress and I feel like most of the big changes to the library are behind me now (hence why I bumped the version number to 0.5 after pushing the aforementioned). There are still some bugs and missing pieces but so far I haven't gotten any major bug reports yet (though that could be because I haven't advertised the library much yet). I'm also working on a game using cl-bodge. I've decided to try writing my own physics/collision detection for it, and so far I have circle-circle collision detection working without issues. Rectangles will be next. I also added status effect functionality, and the "poisoned" and "burning" status effects. Poison is occasional random damage, and burning is constant damage. Both are affected by a "severity" parameter. I also wrote in cute animations for the status effects which are also affected by the "severity" of the condition. I'm also going to be participating in the Lisp Game Jam in a few days, though I am not very confident I'll be able to make anything worthwhile for it ^_^
hey, a quick blog post on the subject would be super nice. (a github gist makes the job) Something we can reference to.
I really enjoyed the S9Fes book. Can't wait for your new one!
Another screenshot showing that data series are presentations (serie may be an arbitrary object, not necessarily a list of y values, object only has to obey the protocol to access data) https://i.imgur.com/rmCSHoH.png
Just do it! :)
Yo svetlyak40wt! How's ultralisp going?
Slowly, because I lack of free time. Right now rewriting an authentication subsystem, so that it will be easier to login with GitHub and to support other identity providers like bitbucket or google.
I don't know any. Your best bet is going to use a foreign library for that, such as Ltk or Qt. There is also https://gist.github.com/VitoVan/abeeb79da01298855692153f1830360e that I've googled, but it's X-only.
If you're not worried about portability and you're using X on Linux/Unix, you can call the `xdotool` command to move the mouse through something like `uiop:run-program`.
I use LTK for windows; how can you use it to move the mouse?
If you are on \*nix you can probably used X11's XTest extension to move the mouse. [https://github.com/sharplispers/clx/blob/master/extensions/xtest.lisp](https://github.com/sharplispers/clx/blob/master/extensions/xtest.lisp) In this post you can see it was used to automate playing a game. [http://vito.sdf.org/dino.html](http://vito.sdf.org/dino.html)
you're looking at a foreign library for this. You can read PyAutoGui's code to see what they ultimately call under the hood. For windows, you might be able to get pretty far by shelling out to autoit
Welp, I misread - I don't actually know if ltk is capable of that. You should be able to bind `SetCursorPos(int, int)` with CFFI though, https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-setcursorpos
 (or null node)
You can use (next nil :type (or null node)) And suppose you don't want NIL and don't want a warning to appear, you can do (next (error "NEXT unsupplied") :type node)
And your constructor is mistyped: should be (:constructor make-node (&amp;optional data next prev))
Thanks
Thank you !
On Windows you can just ```lisp (define-foreign-library user32 (:win32 "User32.dll")) (use-foreign-library user32) (cffi:defcfun ("SetCursorPos" set-cursor-pos user32) bool (x :int) (y :int)) ``` and bam you have API. Way easier and more reliable than `run-program` or the like
Practicing alispchemy on such material might lead to further necrolispmancy!
I'd be motivated to do this if cash prizes were involved.
What's the project? I'd say stick to CL/SBCL since you get a nice native-code compiler and Quicklisp is a godsend without any context though.
My next project is a tool to automatically setup small embedded computers. Have to use ssh, maybe libssh, parse flags and arguments, etc. I like Quicklisp, but there are many packages out there lacking good documentation and examples. How are Clojure package and dependency management?
I don't know much about Clojure, so I can't really give much advice on it. There is [trivial-ssh](https://github.com/eudoxia0/trivial-ssh) for SSH, which looks trivial and documented enough.
&gt; My next project is a tool to automatically setup small embedded computers. Have to use ssh, maybe libssh, parse flags and arguments, etc. As much as I am a Lisper at heart, this looks like a job for a bash script to be fire-and-forget-run on each Unixlike that you set up. If there is no interactivity required from your utility, I think you might do it quicker if you write it in the Unix shell.
What are your fears, or what do you think would be better with Clojure ? I barely know Clojure, but: when I setup and load a project it is more resource-intensive (cpu and ram). CL is pretty slick. When I look at Clojure deployment documentation, I see Maven and all Java stuff, with third-party solutions. In CL, I build a self-contained executable (as explained here https://lispcookbook.github.io/cl-cookbook/scripting.html#with-asdf). There are solutions for deployment: https://github.com/CodyReichert/awesome-cl#deployment ps: I think there are more CLispers than Clojurers in /r/lisp.
I would say Common Lisp, people who use Clojure would say Clojure.
this is the channel =&gt; [https://www.youtube.com/channel/UCMV8p6Lb-bd6UZtTc\_QD4zA](https://www.youtube.com/channel/UCMV8p6Lb-bd6UZtTc_QD4zA) &amp;#x200B; this is the pushing pixels with lisp playlist =&gt; [https://www.youtube.com/watch?v=82o5NeyZtvw&amp;list=PL2VAYZE\_4wRITJBv6saaKouj4sWSG1FcS](https://www.youtube.com/watch?v=82o5NeyZtvw&amp;list=PL2VAYZE_4wRITJBv6saaKouj4sWSG1FcS)
And that's the problem right there. So many people have asked this question without getting much objective answers. Was hoping to get some answers from people who have used both.
Scsh? ;)
If you're setting up a bunch of computers, I recommend looking into Ansible
After my first lisp project I found that it's hard to figure out which third party package to use. So many packages to choose from, some poorly documented, some unmaintained (or at least very inactive on GitHub). These problems reflect upon my style when developing, using more time planning how to do things and what to use then actually coding. Regarding Clojure I must say that the biggest turn off for me is Java. I'm no Java guy, the thought of having to install Java was what initially made me choose SBCL. I know there's probably more CLispers here, but I think the ratio more even here than in /r/Clojure
&gt; it's hard to figure out which third party package to use There are resources to help you with this; here are two: https://github.com/CodyReichert/awesome-cl and https://borretti.me/article/common-lisp-sotu-2015. I also use Quicksearch to find libraries and try them out for myself.
Clojure programmer here. I'd recommend avoiding Clojure. Startup time is a bear! While it IS possible to speed up a few things about it (using things like [https://github.com/hypirion/inlein](https://github.com/hypirion/inlein) which starts a background daemon to avoid certain repetitive tasks), you still have to wait 1-2 seconds before your program even starts up to do anything. Check out my toy app [https://git.calmabiding.me/scstarkey/dicegen](https://git.calmabiding.me/scstarkey/dicegen) to see how that works. Even though you can use it quite easily for these kinds of automation tasks, it's a pain to deal with the shell. If you did want to get up and running quickly to do shell kinds of things this is the package to use: [https://clojure.github.io/clojure/clojure.java.shell-api.html](https://clojure.github.io/clojure/clojure.java.shell-api.html) Good luck with your discernment!
(This isn't related to setup/deployment) Though there are plenty of good Clojure resources/learning-materials, I'd argue that the Common Lisp would just has a fantastic number of really excellent resources which I reckon would be ideal for what you're wanting to achieve. I had to google what a slack bot is, but it made me think right away of the book "Paradigms of Artificial Intelligence Programming" as it covers many topics which would be very relevant. It even starts of with a simple sentence generator, and then moves into more advanced methods of conversational programs, like a psychiatrist sort of one IIRC. Hth :)
&gt; This implementation is adapted from SBCL code. It's encouraging to see open source implementations of Common Lisp leveraging each other's code/logic. I don't know if that's the norm, but unless there are available resources to reinvent the wheel, or to make a better wheel, then perhaps that should be considered standard practice if it isn't yet. Afterall, SBCL itself was derived entirely by leveraging/forking CMUCL code/logic.
I have no idea if it's Lisp implementations themselves. I simply saw that the code is free to be borrowed from SBCL thanks to its license, and that it was viable to do so due to how the code was structured. So I did it.
Borrowed? As a technologartist, be loud and proud! &gt;He headed the team that developed the Macintosh. **Steve Jobs** said that while it was being developed he kept in mind a quote from **Pablo Picasso**. **“Good artists copy. Great artists steal.”** &gt; &gt;[https://quoteinvestigator.com/2013/03/06/artists-steal/](https://quoteinvestigator.com/2013/03/06/artists-steal/)
Small embedded computers do not mesh well with JVM/Java ecosystems. Basically, I would avoid Clojure like the plague.
Thanks, that awesome cl list is.. well, awesome!
Here is an easy way out of the library problems (works for me): My default state is that I assume - every - 3rd party library to be a liability. If I *absolutely* don't need to use it, I don't use it. SBCL by itself is rock solid and has extensive support for pretty much everything I need (sockets, built-in FFI to C, ASDF/UIOP). 90% of the time, I don't need to use any 3rd party libraries whatsoever since SBCL built-ins cover me. Now, if that's not the case and I could leverage some functionality from a 3rd party library, I do a cost-benefit analysis weighted towards rejecting the library (remember, default state). I look at the candidate library, and score it on multiple levels: Documentation, code quality and (most importantly) its dependencies to other libraries. Low scores on any of these are grounds for immediate rejection. If the functionality that this library provides could be easily reimplemented by me using SBCL built-ins, ** 99% of the time, I will reimplement it myself rather than end up with a 3rd party library dependency**. This process has saved me a lot of time, believe it or not, in the long run. Also, everything I build ends up solid and straightforward, can be quality-evaluated with minimum time/effort and doesn't end up drowning in a web of transitive dependencies.
Sounds interesting. I'll check out the book, never heard of it. While there are plenty of books written for any programming language it seems like the majority of common lisp books are pretty good.
You don’t run out of heap memory, you just can’t print the structure. Before you print it, type `(setq *print-circle* t)`. This will enable special printing of circular structures.
This is exactly how I've been thinking. I personally do not like using third party libraries for the same reasons. Much better to implement stuff myself. I'm often using Go and tend to keep dependencies low (even though there are numerous libraries which are widely used). The problem is that, especially when learning a new language, implementing everything myself takes time. This is an important factor when deciding upon using a library or not.
You (accidentally?) double posted. See [my answer](https://www.reddit.com/r/lisp/comments/bemq81/node_structures_that_point_to_each_other/el6y6na/) in your other thread.
Well, like I said, SBCL has extensive support for a lot of things especially things that a beginner would normally attempt. But, depending on what exactly you're trying to do, reimplementing other things could be time intensive. For instance, SBCL doesn't come with a webserver. Every CL webserver library out there is terrible garbage according to my criteria/scoring. So, one sacrifice that I have made is to accept that I'll never do anything web-related on top of Common Lisp. I use Erlang for that and from my POV, it's a win-win situation. I don't have to use Common Lisp for everything. Another bonus of sticking to SBCL when you're starting out is that you'll learn its "standard library" and extensions, very very well since you'll not be distracted by 3rd party code. If you stick with CL for the longterm, this will be a major benefit since it'll help you get better at rapidly evaluating other libraries and also know when to go the reimplement or reuse route.
Currently building a statistical timer for my company! It's my first large lisp project and is really helping me branch out. Currently struggling through figuring out cl-opengl so I can display recorded data in a friendly fashion, but I've already got a working event server, and functional databasing going, so I'm pretty proud of my progress thus far. Beyond that I've been chewing through Let Over Lambda to try and improve my understanding of macros, and looking into old Lisp AI books, really feeling McCarthy's "Advice Taker" idea, but I'm definitely not on that level yet.
For automatically setting up machines via SSH, you might want to look at Pallet. It's Clojure though.
yeah sorry, reddit bugged out :(
cool thanks, I'll give that a go :)
If this is a critical path project you should use the language/platform you are most familiar/comfortable and get the job done first. However, if this is purely a learning exercise, you've kind of answered it already - choose the language/platform you are more interested in learning, and dive in. Rarely is it a good idea to combine the above two goals ... just my 2c of hard earned wisdom :-) If by some chance, this is a real project (not just learning) with a highly flexible delivery deadline (it could happen, I guess), you can't go wrong with either choice. While a lot of comments talk about the relative merits of Common Lisp or Clojure over the other - think about this - you're already ahead if those are your choices. Having worked in both languages, I can safely say you could successfully deliver the project you've outlined in both of them. While there are bound to be local minima in each choice, they both address your broader objective (I presume) of building a robust solution in an expressive language. Good luck.
You can customize how it's printed: (defstruct (node (:constructor make-node (&amp;optional data next prev)) (:print-object (lambda (node stream) (print-unreadable-object (node stream :type t :identity t) (format stream ":DATA ~s" (node-data node)))))) (data nil) (next nil :type (or null node)) (prev nil :type (or null node)))
Project is not time critical, that's why I'm using it to learn something new. I have, sadly, made the same discovery as you. Learning a new language shouldn't be done in critical projects. &gt;While there are bound to be local minima in each choice, they both address your broader objective (I presume) of building a robust solution in an expressive language. Spot on. Thanks!
The sad part is that the first project I tried to do in lisp was a slack bot, i.e. a web server. The exactly same thing came to mind. While there are some serious quality code behind some web servers in lisp, they are often poorly documented, hence a pain to use. Especially for a beginner. I would love to use common lisp for web related stuff (I work a lot with http apis, sockets, etc), but it seems like a *bumpy road*.
&gt;I am now confident to say that package local nicknames have been tested and behave the same way on SBCL, ABCL, and CCL. #YAY!! This is exactly what I was hoping for to be added to CCL!!
&gt;Common Lisp leveraging each other's code/logic. +1. And i think SICL goes along with that idea - to have a modular CL implementation so its modules can be reused.
ECL has them too : )
Where has this been all my life?!
The intermittent problem I've had with compiling compiler/optimizers.lisp for what seems an eternity appears again and I can't get past commit f4a517fc232a8d0295490c0955ae2fe674fce731. Has anyone else encountered that?
If you're of the "I'll do everything myself" persuation, it should work out. Do you find Portable-Aserve or Hunchentoot documentation inadequate?
Portable-Aserve (zaserve) number of first-order 3rd party dependencies (not including the ones SBCL comes with): 15 usocket, bordeaux-threads, cl-ppcre, flexi-streams, quri, trivial-garbage, trivial-backtrace, split-sequence, queues.simple-queue, cl-store, alexandria, md5, cl+ssl, local-time, cl-base64 Note that the actual number of dependencies is a lot higher since I'm including transitive dependencies. That's enough for me to run away screaming. Erlang Yaws has 0 dependencies outside of Erlang itself. I don't want to base anything on a bloated codebase that's using "portability" APIs I have no need for (since all I care about is SBCL). Why should I pay the extra costs? Hunchentoot fails for similar reasons. I don't need all the extra crap it depends on. The only CL webserver that I would deem high quality is John Fremlin's teepeedee2 but it's still missing features I need and nobody is working on it.
I mean, you could write one of your own, but the question is, do you *really* want to reimplement things like fast-http? Or write your own cryptography instead of using ironclad? Or do you simply want to only use it as a "lighweight HTTP connector" to something like Nginx? (Since you could already use SCGI to achieve the same things, I'd imagine.)
Not the OP, but I found hunchentoot to be a little bit too magical for my tastes. There’s obviously some hidden global state being manipulated behind the scenes, and I haven’t dug into it to see what’s happening under the hood. That being said, it’s also worked very well for me. The purist in me is a bit uncomfortable, but the pragmatist in me is delighted :)
I don't have the time to implement what you're talking about, thus I willingly sacrifice solving certain problems with CL. I refuse to compromise and use libraries I deem low-quality just so I can use CL. I guess a lot of others see it the other way. There are other languages that solve same problems in a way that I like that I'm not hesitant to use. In my ideal world, CL developers would write high-quality libraries that don't need to compromise just so they can work on additional implementations. I wish we had an SBCL-only (or CCL-only) webserver that took advantage of everything SBCL has to offer. I'll always think it's far better to have high quality libraries that are not portable and are tied to one specific implementation, than bloated portable libraries that don't do anything particularly great.
For the project you've described, I can't think of any big advantages one way or the other. If you want to avoid shelling-out to ssh, there is probably a mature java ssh library that would be a bit easier to integrate with clojure. SBCL wins on startup time, but if you can batch runs together that becomes not much of an issue. &amp;#x200B; Since you're more familiar with CL, I don't see a reason to switch, unless you had a burning desire to learn clojure, in which case this might be a good excuse.
Since the project [automated setup of embedded systems, apparently remotely via ssh and friends] is not time critical, and you already started in CL, and you'd like to explore Clojure... I'd say develop a prototype in CL (what you have experience in). If you can, focus on using an FP style (e.g. map/filter/reduce and friends where possible instead of loop smash). If that works out, you have a minimum viable implementation; which should be portable. Try to port it to clojure and use that as a learning opportunity to compare and contrast. Maybe that informs where you go in the future. &gt;Pros and cons regarding to project setup and deployment? Setup is pretty trivial. You can get the _clj_ command line script and use it [per the guide here](https://clojure.org/guides/deps_and_cli), or leverage build tools like leiningen (oldest, most popular IMO), or boot. For editing, if you're already using emacs (or vim) good news: you can keep using that. There are multiple clojure dev environments, the one I use is emacs + cider, or if you want a pre-baked setup (plus optional vim support), spacemacs + clojure layer. Your deployment options vary. If target has a jvm, you can just ship an uberjar (typical bundled dependency option) that bundles all dependencies for you. Alternately, in the CLI space, it's become more popular to ship the clj script and just do command-liney things using that, since you can script everything in clojure, and setup dependencies to files, git repositories + hash, etc. (e.g. there's more general notion of dependencies out of the box beyond assuming artifacts pointing to jars on maven repositories). If you're intending to run scripts on embedded, that could be problematic. I've had clojure running on embedded jvms on lego EV3 robotics bricks (still very powerful by embedded standards; they're able to run a linux distro), but it wasn't ideal; although I had ECL running on the same system (no love for SBCL, CCL, etc. there at the time). If you're running in a resource constrained environment, unless you are able to aot-compile your code into a native binary with the graal compiler [even then, not guaranteed to reduce resource usage enough, also not viable for any code that touches the classloader e.g. via runtime eval], you'll run into insurmountable problems. While you can set and keep the jvm memory footprint low, the practical choice in clojure land (and most host environs by extension) is that memory is cheap and plentiful and gc's are good at their job; so it's not uncommon to have clojure-jvm programs expecting ~500mb-1g of (eventual) heap space unless you target that explicitly. Even then, some things on the jvm can end up being fat (strings for instance). So if memory is at a premium (like it was for my ev3 experience, and later on a rpi3), that's definitely a potential con. You could switch to cljs via [lumo](https://github.com/anmonteiro/lumo) or planck, and get 99% of the experience and code portability via .cljc files, plus fast startup, etc., but running v8 on embedded might still be too much for embedded dev. If you're communicating with said systems and configuring, vs. executing your own clojure stuff, then that seems more palatable. The [clojure toolbox](https://www.clojure-toolbox.com/) has some decent libraries to sift through. SSH stuff is typically done over jsch, such as in [ssh-cli](https://github.com/punit-naik/ssh-cli/blob/master/test/ssh_cli/core_test.clj) which has some simple commands for remote execution, etc. If your objective is learning, and time nor host resources are constraints, then I'd stick with doing both. Keeping to a functional style is just useful IMO, but has the benefit of making it more straightforward to lift from the CL implementation (some things pop right over if you write with porting in mind).
The Cookbook had you covered :) https://lispcookbook.github.io/cl-cookbook/data-structures.html#circular-lists
This was over on [https://www.bountysource.com/issues/55429455-implement-package-local-nicknames-in-ccl](https://www.bountysource.com/issues/55429455-implement-package-local-nicknames-in-ccl) btw. Would be cool to understand if that was effective at all... Sample size n = 1 though :(
Common Lisp because stuff like the CLOS is so amazing: https://lispcookbook.github.io/cl-cookbook/clos.html
&gt;Things would be a lot better if more people focused on SBCL only and wrote high-quality libraries that don't need to pile on layers of hellish portability abstractions. **No. This is terrible.** If you work like this (eg Python, Node, Clojure probably, etc, etc) you're practically ignoring the standard and de-facto standards and programming in SBCL. This has run on effects, *if many people do this (which actually they do, but it's not to the point of "SBCL is the only used implementation") then their programs won't be portable CL-plus-defacto-standards and won't run anywhere other than SBCL, and we'll be in the same land as the languages that have only one implementation.* The good news is that most of these abstractions are about as simple as `(defun foo () #+sbcl (sb-ext:foo) #+ccl (ccl:foo))` and incur you no runtime slowdowns, and they're not terrible. I would guess that about half of the portable-aserve dependencies have been accepted as "standard enough" (usocket, b-t, flexi-streams, trivial-garbage, split-seq, alexandria, not sure about the others) and have been maintained and documented well. (I think split-sequence for one is probably one of the most micro-optimised libraries around, since there are many types of sequence and thus there's a lot to do, but I digress.) It's certainly rational to be skeptic of, say, npm's dependency hells but CL libraries are actually useful and have a good size. The mentality behind making libraries is very different here.
Definitely learn the one in which diagnostic messages point to line numbers in `.java` files, that is built exclusively on exotic, immutable data structures, and in which every problem is regarded as sequence processing.
Effective? What do you mean?
What is your build error? Which bootstrapping binaries do you use? What platform do you build on? Have you asked `#ccl` on freenode?
Ah lol ! I wasn't putting the two together ! doh!
Thank you :)
No error, just non-termination on line saying &gt; ;Compiling "/home/jakub/CCL5/ccl/compiler/optimizers.lisp"... The recent binaries I've had working (it often doesn't work with the newest released binaries on Github anyway). Linux/AMD64. Not yet.
#+ does not help with API design. It also does not help with extra layers of indirection bloat. You missed most of my points.
Have you compared what compatibility libraries expose and what the implementation packages have? They're shockingly similar. (I'm not sure why you haven't called CL a bloated language yet.)
If you can afford to learn both, I'd say you can always learn the enough of either one to start a small project, then switch to the other language and compare. &amp;#x200B; OTOH, even paulg recommends Clojure nowadays: [https://twitter.com/David\_\_Desimon/status/1118725501504360448](https://twitter.com/David__Desimon/status/1118725501504360448)
\&gt; Macros [https://www.metalevel.at/prolog/macros](https://www.metalevel.at/prolog/macros) Also see op/3, we can create and also customize prefix, postfix, like Haskell.
Prolog can DSL. See op/3 and full macros. It feels more unhinged without s-expressions.
[https://www.metalevel.at/lisprolog/](https://www.metalevel.at/lisprolog/)
&gt; Clojure programmer here. I'd recommend avoiding Clojure. Startup time is a **bear**! Ironically, I use Armed **Bear** Common Lisp which also runs on the JVM, and startup times are also "a bear". I'd blame the JVM. Once the JVM starts it's all happiness, though.
&gt; Portable-Aserve (zaserve) number of first-order 3rd party dependencies (not including the ones SBCL comes with): 15 Wait until you get to use that thing called "Node.js" with "NPM Dependencies"
&gt; And that's the problem right there. So many people have asked this question without getting much objective answers. Was hoping to get some answers from people who have used both. They are very different languages, that look similar on the surface. Clojure is mainly a Functional Programming (FP) + immutable data language; it's tailored that way. It allows OOP, of course, and it also allows to mutate data, but everything is geared for doing FP with immutable data. Thus, it is "opinionated" Common Lisp is a truly multi-paradigm language; it allows you to mix FP, OOP, procedural programming, imperative programming, declarative programming, work with mutable data, or don't mutate it, etc. Common Lisp's OOP system ("CLOS") is exemplary, yet to be topped. The exception handling system is exceptional, too. CL isn't "opinionated" at all: Quite the opposite, it is a "you want it, you got it" language: - Want to mutate data? You got it. - Want to recompile this function to native code? Ok - ... While the program is running? You got it. - Want to change the class of an object at runtime? Sure! - Want to use a different hash function for your hash table? Sure! - Want to run this on the JVM? Ok - Want to embed your program inside a C program? You got it. To be honest, if I wanted to do Functional Programming with strictly pure functions/immutable data -which is what Clojure is tailored for-, i'd better pick F#, OCaml or Standard ML, since I could get the advantage of type inference with an interesting type system. But this is my choice. Others think that Clojure's peculiar mixture of FP + s-expressions + dynamic typing is a nice sweet spot.
As well, a running prolog instance can be connected remotely, and dynamically modify the code like Lisp albeit in database style. Also prolog syntax itself is modifyable and inspectable. Such as ':-' is an operator, which we can change the meaning of. Can Lisp change the meaning of '(' ?
Besides Javascript being a language I'm doing my best to avoid, I wouldn't use Node.js for similar reasons.
I'd suggest looking into [Gauche Scheme](http://practical-scheme.net/gauche/) instead, scsh is basically abandoned.
I'm going in! Wish me luck!
&gt; Small embedded computers do not mesh well with JVM/Java ecosystems. Basically, I would avoid Clojure like the plague. As a counterpoint, if you like Clojure's *ideas* and want something that works better in that niche, there's also [Ferret](https://ferret-lang.org/#outline-container-sec-2), which looks and acts like Clojure but compiles to C++11. Unrelated, but interesting: Ferret's source is a literate org file that seems to also be used to generate the ferret-lang.org site.
I don't know about ABCL but in Clojure's case I don't think the startup time is the JVM's fault. Java programs startup two orders of magnitude faster than Clojure programs (or at least they used to, last time I tried Clojure).
I remember this being the case if I used 1.11.5 to compile newest 1.12 sources. The solution was to use a 1.12 bootstrapping binary.
Valuable feedback, thank you!
1.12 is what failed for me. It fixed the same problem for me once in the past, but not now.
Which exactly bootstrapping binary did you use and which commit did you compile?
Sure. `(set-macro-character #\( #'paren-reader-function)`.
The Lisp code in the examples is in strings. Which means that a program with syntactically invalid Lisp code in a string shall still be considered a well-formed Prolog program. If in a compilable unit, it'll compile without any problems, and it's only going to fail at runtime.
The newest commit, and I tried it with both the newest binary that I had built for myself that worked for me *and* with the newest 1.12 release for Linux labeled as "1.12 snapshot (December 2017)" on Github.
You are correct, it seems that the most recent commits have complicated CCL's build. You need a different bootstrapping path. I have built master successfully using this path: 1.12-dev-dec2017 -&gt; f120efb* -&gt; 2912b11 -&gt; a2fc47e (master) *evaluate the code from https://plaster.tymoon.eu/view/1144/raw?password in order to bootstrap package-local nicknames
Question is, why not compile Clojure into, say, Chez? Seems like a better fit.
You’re right — it’s not just the JVM. It’s also the Clojure libraries that need to load up.
Yes. You just need to open a swank connection. https://github.com/cbaggers/livesupport
Thank you very much
Best answer and comparison I've seen. If you're going to bring up ABCL then I will also make readers aware of other vm/language targets for Clojure. ClojureCLR targets the CLR which gives you access to the .net ecosystem. Clojurescript transpiles to js (and uses the Google Closure compiler to get insanely performant code). The compiler understands .cljc files as a DRY method for targeting one of these vm's + js. All of these are official variants.
My Clojure Dev environment is pretty heavy on system resources, but the projects I've deployed are pretty light.
&gt;ClojureCLR targets the CLR which gives you access to the .net ecosystem. Yes, but is it production-quality and supports all clojure libraries? (or 85% of them)?
It tracks just behind Clojure releases afaik, but the project is active. You are right: Clojure users like the JVM more.
Lisp is a family of languages. Clojure, CL, and Scheme are Lisp dialects - distinct languages that are similar to each other.
Common Lisp and Scheme are Lisps. Clojure is not.
Totally incorrect. I can take 50 year old Lisp code and run it on top of Common Lisp or Emacs Lisp (minimal to zero changes needed) or Scheme (some changes needed). If Clojure was a Lisp dialect I could do the same but of course I can't. I have to rewrite everything including logic. Core Lisp datastructures do not exist in Clojure. The syntax is different. &amp;#x200B; Clojure is an entirely new language that has borrowed some features from Lisp but that doesn't make it a Lisp. Dylan is more of a Lisp than Clojure even if it doesn't have s-expression based syntax.
All we're doing here now is arguing over what the definition of lisp should be. All you've shown here is that Clojure doesn't live up to your definition of lisp and its criteria, but haven't explained why your definition is more useful than the common definition of lisp, which clearly includes Clojure (and what OP is honestly asking about to begin with). We can always add criteria to disqualify, but if there's no real reason to do so just for its own sake.
Did you really only respond to my comment to shitpost about how Clojure is not a Lisp, where your only argument seems to be "I can run legacy code on that with minimal effort"?
How can it be a Lisp if it doesn't run Lisp code? We have the historical record to tell us what a Lisp is, not some postmodern definition. Before Clojure, Lisps ran Lisp code. Then Clojure comes along and claims to be a Lisp but it's not running any Lisp code without a complete rewrite. I rest my case.
You and me both! I'm liking the look of it so far.
\&gt; why your definition is more useful than the common definition of lisp Well, Common Lisp allows us to run existing Lisp code. To me that's useful. Clojure does not. It's 100% source code incompatible to other languages like Common Lisp, ISLisp, Scheme, ...
&gt;Core Lisp datastructures do not exist in Clojure. The syntax is different. Clojure 1.9.0 user=&gt; (cons 1 '()) (1) user=&gt; You'd have to substantially rewrite a Scheme program that makes heavy use of call/cc if you wanted to run it using CL. Early Lisp also had dynamic binding of variables, so that would be a pretty substantial rewrite for any Lisp that uses lexical scope by default. If you don't consider Clojure a Lisp, cool. If you can't see any reason why others just \*might\* consider it a Lisp in spite of that, well, alright.
I suggest you ask the same question on the /clojure channel.Asking about anything but common lisp and scheme on a lisp channel normally invokes strong opinionated responses.
Try (cons 1 1).
When I say Lisp, I mean the family of languages which actually shares code, books, libraries. Multitude of languages have spawned from Lisp, which have taken ideas from it: ML, Logo, Dylan, Clojure, Ruby, ... But practically they are all incompatible with Lisp. Clojure was created as a mix of ideas from Common Lisp, data structures from Functional Programming languages, and a mix of Java and the JVM runtime.
I’ll just throw this out there too: this has become my absolute favourite way to build a C library. Hook it up to ECL and you basically get a REPL for free to test different inputs and outputs. I was shocked at how little effort it took.
My point was less about claiming that current Lisps don't support dynamic binding (hence why I said "by default", as in, dynamic binding is also available with special variables) and more about how it really isn't always as easy as you claim to convert code between the several main dialects of Lisp.
Ferret has no GC, it has manual memory management I believe. At least that's what I understood from its website.
A bunch of applications have been ported from a dynamic binding Lisp to lexical binding Lisp. Emacs Lisp for example supports both in the same implementation. It runs dynamically bound Lisp and lexically bound Lisp. Just tell Emacs Lisp what is in the file and it does the right thing.
I think Clojure is best suited for long lived processes. So backend end services, servers of all sorts, pollers, big data processing pipelines, or big desktop apps that are meant to be worked on for long sessions at a time. While it can also be used for scripting, if you don't mind a 1 or 2 second startup time (though graalvm is slowly eleviating that). What it's not good at is running embedded in another program, targeting small embedded systems like micro controllers, android or iOS development (though ClojureScript is pretty amenable to these). I think for CL, it's the other way around. But the biggest difference apart from the environments they're better suited at is that CL is very much a Lisp with strong support for imperative and OOP paradigms. While Clojure is very much a Lisp with strong support for functional and concurrent paradigms. I'd also say CL is better geared towards low latency, single threaded performance use cards. While Clojure is better geared towards high throughput, high scale, multi-threaded/distributed use cases. But most likely, you'll be happy with both.
Interestingly, I can build f120efb after the changes provided using the 1.12-dev-dec2017 binaries, but the resulting binaries still hang in the same place when trying to build 2912b11 afterwards.
&gt; the common definition of lisp, which clearly includes Clojure Citation needed.
&gt; Is there just a regular Lisp or does it exists only through a dialect? Common Lisp, the result of a formal ANSI standardization process, is literally standard Lisp.
 [https://en.wikipedia.org/wiki/Lisp\_(programming\_language)](https://en.wikipedia.org/wiki/Lisp_(programming_language))
My take on this is that all Common Lisp (CL), Scheme and Clojure share a similar syntax and prefix notation. And all of them including LFE and prolly others can be dubbed LISP. They are differences among them. &amp;#x200B; For instance, one big difference between CL and Scheme is that CL is LISP-2 vs. Scheme dialects are LISP-2. Clojure is a LISP-1. &amp;#x200B; Also, Scheme is not a language, it is a family of language, see /r/scheme for more information ;-)
&gt; Scheme is a Lisp dialect that has (maybe no longer true) a focus on minimalism and academic elegance. Not very practical. Honest question, why do you think Scheme is not very pratical?
Oh come on, that's just disingenuous; its one thing to have criticisms of this definition, but its another thing to imply that its not the common definition, as if this is just coming out of nowhere; Clojure is obviously included in most definitions of lisp, *right down to this very subreddit, which has it in the sidebar* You'd be more hard pressed to find an area that throws out the entire language because you can't copy and paste among other lisp dialects (that are seldom used to begin with by the way). Other areas' mentions of Clojure: https://en.wikipedia.org/wiki/Clojure Directly says is a lisp &gt;Clojure (/ˈkloʊʒər/, like closure)[13] is a modern, dynamic, and functional dialect of the Lisp programming language on the Java platform.[14][15] Like other Lisps, Clojure treats code as data and has a Lisp macro system https://clojure.org Direct &gt;Clojure is a dialect of Lisp, and shares with Lisp the code-as-data philosophy and a powerful macro system. https://learnxinyminutes.com/docs/clojure/ Implied, with slight ambiguity (says lisp family, could just mean closely related, like Dylan) &gt;Clojure is a Lisp family language developed for the Java Virtual Machine. It has a much stronger emphasis on pure functional programming than Common Lisp, but includes several STM utilities to handle state as it comes up. https://www.braveclojure.com Implied, Strongly &gt;Do you want to learn Clojure, the most powerful and fun programming language on the planet? Do you want to unravel the mysteries of Lisp and functional programming? https://objectcomputing.com/resources/publications/sett/march-2009-clojure-functional-programming-for-the-jvm Direct &gt;Clojure is a Lisp dialect. However, it makes some departures from older Lisps. For example, older Lisps use the car function to get the first item in a list. Clojure calls this first as does Common Lisp. For a list of other differences, see http://clojure.org/lisps. https://medium.com/@ertu.ctn/why-clojure-seriously-why-9f5e6f24dc29 Mostly direct &gt;I said “Okay. Now it is time to select a Lisp dialect.” I found the Clojure language among Lisp variants and I saw that it can run on JVM. (Mentions Clojure as a lisp many other times throughout) . And see that list? I just went through the first two pages of google. If your thoughts are then to say maybe most of those links inevitably subclass from the same source, lets at least contrast it with the amount of articles I went through that didn't call it a lisp (list below): .
Yes.
\&gt; What's the difference between these? &amp;#x200B; "Lisp" was a language conceived by John McCarthy (MIT) in the late 50's. It evolved through the decades, adding a lot of features. There were many Lisp dialects in the 60s and 70s largely inter-compatible and compatible with the first Lisp implementation (Lisp 1.5). The most important Lisp implementation of the late 60s and early 70s was probably MACLISP which was from the MIT. &amp;#x200B; In the 70s, however, a new language appeared, called Scheme, which is now considered a "Lisp dialect" and incorporated new ideas, the most important one being "lexical binding". The Lisp implementations incorporated then lexical binding into the language, diluting the difference between Lisp and Scheme. &amp;#x200B; Common Lisp was detailed in the early 1980s, was a successor to MACLISP, and was standardized as ANSI Common Lisp in 1994, incorporating advanced OOP concepts from the late 70s and a considerable influence from Smalltalk and Scheme. &amp;#x200B; Nowadays "Lisp" means either "Common Lisp" or "a language of the Lisp family". &amp;#x200B; Both Scheme and (Lisp 1.5, MacLisp, Common Lisp) are languages based around the linked list cell (or "cons cell") as the main data structure. Programs are made of cons cells. The language itself (its syntax) is all made of s-expressions. &amp;#x200B; Clojure is a much more recent language (2000s), which is a language based on s-expressions, very influenced by Scheme. Superficially, it resembles Lisp and Scheme. Clojure isn't based on cons-cells and this is the main essential difference; while it appears similar to the other lisps on the surface. &amp;#x200B; Lisp was the first mainstream language that allowed Functional Programming (FP) -and imperative programming as well-, Scheme added further emphasis for Functional Programming. Clojure is specifically tailored for FP plus immutable data structures. Racket is an evolution of Scheme. &amp;#x200B; There are small differences between Common Lisp and Scheme, there are even stronger differences between those two and Clojure. &amp;#x200B; For practical purposes, any programmer who learns one of those three, will easily jump to any other, anyways. All of them use s-expressions, all of them have "code as data", all of them have macros (with differences in the way macros are implemented, of course.) &amp;#x200B; There are many differences between CL, Scheme and Clojure, but if we have to summarize the "philosophy" of each one, this would be the Philosophy: &amp;#x200B; \- Common Lisp: Be Industrial Strength and Unopinionated. Let the programmer use any programming paradigm, even GOTOs if he/she likes. Leverage Smalltalk's "image-based" development. Leverage OOP to the max. Who cares if the language has a ton of features to learn. Have many implementations that comply with the standard as strictly as possible. &amp;#x200B; \- Scheme: Make a minimal language core that is easy to learn, build on top of that. Functional programming and recursion is to be favored and encouraged. Add some features from other lisps in a modular way. Have many implementations which will comply with a essential (minimal) core of features. &amp;#x200B; \- Clojure: Be strongly Opinionated, Rich Hickey guides the philosophy of the language. Data should be "first class". Language is designed to be compatible with the Java JVM as an essential feature, and it's also designed from the ground with concurrency in mind. Functional Programming with Immutable Data Structures is to be favored at all times. Have one main implementation.
Hmmmm. No idea why that hangs for you though. It worked for me. Make a GitHub issue at Clozure/ccl.
Oh hey its you again, hi yes stalker senpai
No.
Shet
&gt;https://en.wikipedia.org/wiki/Clojure &gt;Directly says is a lisp &gt;https://clojure.org &gt;https://learnxinyminutes.com/docs/clojure/ &gt;https://www.braveclojure.com &gt;https://objectcomputing.com/resources/publications/sett/march-2009-clojure-functional-programming-for-the-jvm What you're proving with your URLs is that "Pages which talk about Clojure say Clojure is a Lisp". Clojurians say Clojure is a Lisp. That doesn't mean that outside the Clojure world everybody agrees. Clojure is a good language, a very interesting one, with cool features that have already influenced other languages. But it's not easy to conclude "Clojure is a Lisp". It can or can not be a Lisp depending on the criteria applied.
There are basically two camps in the Scheme world: the people who want to use a simple Scheme for teaching (see SICP and others) and those who want to actually develop libraries and applications with Scheme. For an example see R7RS small and R7RS large. The teaching dialects are often very minimal not very practical. Actual Scheme implementations and their libraries are very practical. They provide a lot of functionality which one would expect from a typical Lisp and some have large libraries.
I share pretty much the same sentiment.
right to the point! this little funny flame war in top comment is hilarious. I do not really know clojure (only scheme and now learning CL), but do you know why CLpers dislike clojure so much? Is it because clojure stole a name of one CL implementations or something?
&gt;Clojure is a good language, a very interesting one, with cool features that have already influenced other languages. But it's not easy to conclude "Clojure is a Lisp". It can or can not be a Lisp depending on the criteria applied. Well, just to keep in mind, while I was arguing earlier that it *should* be considered a lisp (and still would), my point in this and my last comment is separately only to talk about what it is commonly thought of as, independent of what it should be. &gt;What you're proving with your URLs is that "Pages which talk about Clojure say Clojure is a Lisp". Clojurians say Clojure is a Lisp. Absolutely I realize its a hard piece of data to track down, a hard bias to account for; the silent data of "what percentage of people *not* talking about Clojure would consider it a lisp if actually asked". The other group, people outside of the Clojuresphere who have at least, say, made a blog post specifically calling it not a lisp for instance, is also harder to track down and is going to disproportionally underrepresent the actual number who feel that way compared to articles that are just about Clojure that happen to mention it being a lisp. What I am about to say is less scientific, however, in that I do doubt that less people consider Clojure a lisp than those that consider it not a lisp, and that it I pretty much unanimously see it described full on as a lisp (and not just from, say, articles from the perspective of Clojure, as Clojure will probably have some bias 'talking about itself', but also from articles from other perspectives that happen to mention Clojure because of topic overlap, the greatest example being articles on Lisp itself). If your point at least is that this is unprovable one way or another based off of this, this I can definitely concede, and that would probably make me think this wasn't disingenuous after all.
The built in \`length\` function will do that for you.
you seem to know all 3 fairly well, can you please expand on this, "any programmer who learns one of those three, will easily jump to any other, anyways". Can you rank in 10 point scale (10 being very easy to jump, like one day of reading manual) how easy it would be to jump from &amp;#x200B; scheme -&gt; CL CL -&gt; scheme clojure -&gt; scheme clojure-&gt;CL scheme -&gt; clojure CL -&gt;clojure &amp;#x200B; Thanks
You are not thinking in Lisp. * Recursive (defun count-elems (list) (if (null list) 0 (+ 1 (count-elems (cdr list))))) * Tail recursive (defun count-elems-tail (list &amp;optional (count 0)) (if (null list) count (count-elems-tail (cdr list) (1+ count)))) * Iterative (defun count-elems-iter (list) (loop :for count :from 0 :for _ :in list :finally (return count)))
That will be incredibly subjective. What's your *actual* question? Assuming you're new to lisps, are you asking which one to learn first?
Will have to make a GitHub account first, though. However, I *was* able to just "single-step" through commits since f120efb forward, so I now apparently have a working build of the master. It just somehow worked that way, no idea why.
&gt; You'd have to substantially rewrite a Scheme program that makes heavy use of call/cc if you wanted to run it using CL. This makes a Lisp implementation not a Scheme, but it doesn't make a Scheme implementation not a Lisp. &gt; Early Lisp also had dynamic binding of variables, so that would be a pretty substantial rewrite for any Lisp that uses lexical scope by default. Wouldn't you just declare the variables as dynamic in CL?
no, not quite, I was just curious in the transition :) I have 0 knowledge about clojure, I played with racket a bit (3 first chapters of SICP and half of more of racket guide, but never actually used it for anything serious...), and now I am reading PCL. I switched to CL, because it looks to be more in line with what I do (I am not really a coder). So I wonder if it would be difficult to me to switch for scheme any time I need if I need. For me the switch would mostly imply to learn "infrastructure" like libraries etc. I do not care much about lisp1 vs lisp2 (I think lisp1 is more pleasant, but not a deal breaker). and I also a noob in macroses, know only basics... so this is also a difference between scheme and CL. So, my questions is overall about transition -&gt; how difficult to learn the ecosystem and what not...
You can switch between Common Lisp, Scheme, Emacs Lisp and most of your knowledge translates. There are some differences, but they are all Lisps with the same foundations. &amp;#x200B; Very little if any of your Lisp knowledge will translate to Clojure besides getting used to an s-expression syntax.
I dunno, I would put Java and C# in the same language family. In linguistics, a language family definitely does not mean every language in that family can roughly understand each other -- it literally means they spawned from the same beginnings and evolved over the time. The same applies to programming languages, IMO.
I see :) thx.
I can only guess, but the main reason as it appears to me is that Clojure doesn't adhere to the common lisp standard and is very much an opinionated language. Clojure for me is a good mix between functional programming from haskel and cl. that said whatever the language differences the biggest one is community.
Use a hashtable to store trip_tbl instances. Also, your naming scheme is not Lisp-like. Maybe it's propagated from your database naming, but ideally you'd use something like: (defclass trip-table ... :initarg :db-id :accessor db-id and so on
Interning a new symbol inside your package to accomodate rows in your table feels very wrong. Not only you intern new symbols in your package over and over, but it also prevents you from garbage-collecting your objects since they will forever be accessible unless you `makunbound` the variables they are bound to. I would rather prefer some kind of storage in a hash table, where the values are the created DAOs and the keys are arbitrary - it can be your ID, or anything you want. Initially, you create the DAO, and store it in the hash table *without pushing it into the database*, so you may later fill in the missing slots. When you have the data to fill them in, insert it into the DAO's slots, *push the new dow into the database*, and `remhash` so the DAO is no longer accessible and can be freed.
Two votes for a hashtable, definitely looking into that now. The naming schema is a Mito thing primarily, it's a little unlispy, but it's a lot more friendly than trying to us cl-sqlite.
It definitely felt like I was going about it the wrong way honestly. It works partially, but the second I get an out of order event the entire facade just crumbles. And GC has been a nightmare I am well aware of, which is part of why I asked to begin with. While it seems possible, I don't think it's the appropriate way to go about it. Looking at hashtables now, that seems exactly like what I need to use in this instance. I've never used them before, though I've heard of them. Thank you for the pointers!
When people just say "this is/I have written in Lisp" they clearly mean Common Lisp. If it was Clojure or Scheme they would say so.
&gt; Can you rank in 10 point scale (10 being very easy to jump, like one day of reading manual) how easy it would be to jump from &gt; scheme -&gt; CL &gt; CL -&gt; scheme &gt; clojure -&gt; scheme &gt; clojure-&gt;CL &gt; scheme -&gt; clojure &gt; CL -&gt;clojure I don't think one could do this ranking. All three languages are fairly easy to learn for writing simple things like FizzBuzz, etc. To learn any of these three extensively, none is "easy": Scheme has a lot of extensions (the SRFIs) to do useful stuff. Common Lisp has a lot of features to learn. Clojure also has its own concepts with its own slang (refs, atoms, protocols, transducers) plus at some point in time you're expected to be familiar with the Java ecosystem as well. You'd be better choosing one according to the *Philosophies* outlined above. For example, 10 years ago i would immediately jump to Clojure, since would have preferred a language with only ONE main implementation and mostly ONE way of doing things (this has its benefits). Nowadays i'm a big fan of CL since i enjoy having ultimate flexibility and being able to move my programs from one implementation to another with no code changes. If I were, for example, doing development that required a very small and fast implementation, it's highly likely that a specific Scheme implementation would fit the bill. If you learn any of those three, jumping to other shouldn't be a big deal. In any case, please follow modern tutorials for learning. Don't be discouraged from learning CL/Clojure/Scheme because of not following modern guidance. For example nowadays, having a complete Lisp IDE is extremely easy thanks to [Portacle](https://portacle.github.io). Or you have a complete Scheme environment with Racket and DrRacket. If you have a bad experience learning CL/Clojure/Scheme experience because you chose to edit code using Notepad, it's not the language fault!
&gt; I switched to CL, because it looks to be more in line with what I do (I am not really a coder). Stick to CL until you get good at it, then the jump to Scheme or Clojure will be easy peasy. You need to learn the fundamental first, like macros. These will be useful to you in any "Lisp family" language.
Excellent comment!
Personally I would expect that a programming language family shares a base vocabulary. In linguistics see the concept of a language dialect. In linguistics languages are members of language families. Dialects are variations of a language. For example Germanic is a language family. German and English are members. German: Das Haus hat eine weisse Tür. English: The house has a white door. There is a Proto-Germanic language underlying these. A dialect then is a variation, like some low German: Dat Huus hett een witte döör.
&gt;Edit: Oh, and that this really just feels to me like the same sort of 'scheme is not a lisp' flame wars that came before Clojure. Bingo. This is about as fresh as disco lol, but hey some folks still like KC and the Sunshine Gang. Fyi, the same retreaded talking points come up every time there's yet another proxy-war initiated by either an innocuous question, or a post intended to clear the dance floor. It used to be confusing, but after the first couple of iterations, the pattern emerged and led to [enlightenment](http://wiki.c2.com/?IsSchemeLisp). The responses are like clockwork now, and form a suitable training corpus for a markov chain chatbot.
&gt;Asking about anything but common lisp and scheme on a lisp channel Don't you know those are mutually exclusive here? Take a straw poll on whether Scheme is a Lisp. You may be surprised by the results. Or [not](http://wiki.c2.com/?IsSchemeLisp)
&gt;Scheme is a Lisp dialect Heresy
And racket lol
top marks for the outwardly innocuous question and [predictable result]([https://www.youtube.com/watch?v=QrkUlAb-I8Y&amp;list=PLjIuADMrDKIY5yTkJkK3mi_dqZjzTMfcA&amp;index=9&amp;spfreload=10]) :)
A new language constructed using iterations of syntax and implementation patterns in place for decades :-) As for a base vocabulary: * `(defun func (arg) body)`, * `(define (func arg) body)`, * `(defn func [arg] body)`. I'm not even sure implementation should enter the discussion, though that's just how I think about it. Usually I'm far more interested with learning how different languages develop syntax to solve different problems. How do these languages think about these problems? This is clearly easier to do with DSLs, but general-purpose languages also offer a lot of fun history lessons. I think my base definition for a 'programming language family' then would be 'if you can muddle through a program written in language A knowing *only* language B. For instance, I can muddle through that simple German sentence having never spoken a significant lick of it in my life but, knowing English, I could've read probably everything but *Tür*. Assuming that *T* has a similar plosive sound as *d* would have in *door*, upon hearing *Tür*, I might've understood. That's not to say that anything beyond a first-grade reading level would be anywhere in my grasp, but if we say German and English are in the Germanic family, it's reasonable to say Common Lisp and Clojure are in the Lisp family (by the consequence of understanding one giving you a basic understanding of the other). Things get really interesting if you consider spoken language construction analogous to programming language implementation (in which case you're absolutely correct that CL and Clojure would be too different to really relate), but I think that's not giving enough credit to language designers :-) Even so, I can't use German grammar books to teach English nor can I digest any significant work in German before translation, so the two don't share 'books or libraries'. I'd *love* to actually have time to study this… it's honestly *the* most interesting thing about programming languages for me :-) There are simply so many patterns and parallels you can draw. It makes me wonder what would happen if you tried to extrapolate/predict what kinds of changes could happen to a programming language over time.
FWIW, I disagree. &amp;#x200B; Clojure is very different compared to CL/Scheme/Elisp which are relatively similar, but Clojure was designed by an experienced lisper so knowing other lisps, particularly common lisp, will give you a leg up while learning Clojure.
In CL and Scheme I feel that I have freedom to code however I want. In Clojure I feel constrained by a very rigid and opinionated environment. I wanted to like Clojure, but it leaves a bad taste. Note: I have been a lisp programmer since 1978.
Take this proto-lisp code: maplist[x;f] = [null[x] -&gt; NIL;T -&gt; cons[f[x];maplist[cdr[x];f]]] diff[y;x] = [atom[y] -&gt; [eq[y;x] -&gt; ONE; T -&gt; ZERO]; eq[car[y]; PLUS]] -&gt; cons[PLUS; maplist[cdr[y]; λ[[z]; diff[car[z];x]]]]; eq[car[y];TIMES] -&gt; cons[PLUS; maplist[cdr[y]; λ[[z]; cons[TIMES; maplist[cdr[y]; λ[[w]; [¬eq[z;w] -&gt; car[w]; T -&gt; diff[car[w];x]]]]]]]]] We see vocabulary like: function definition, conditional, maplist, null, NIL, T; cons, cdr, atom, eq, car, lambda, not, ... The code in Common Lisp is: (defun maplist1 (x f) (cond ((null x) NIL) (T (cons (funcall f x) (maplist1 (cdr x) f))))) (defun diff (y x) (cond ((atom y) (cond ((eq y x) 'ONE) (t 'ZERO))) ((eq (car y) 'PLUS) (cons 'PLUS (maplist1 (cdr y) (lambda (z) (diff (car z) x))))) ((eq (car y) 'TIMES) (cons 'PLUS (maplist1 (cdr y) (lambda (z) (cons 'TIMES (maplist1 (cdr y) (lambda (w) (cond ((not (eq z w)) (car w)) (T (diff (car w) x)))))))))))) As you can see, it does use EXACTLY the same base operators and the code structure is exactly the same. It even runs as it was defined : CL-USER 23 &gt; (diff '(TIMES X (+ X A) Y) 'X) (PLUS (TIMES ONE (+ X A) Y) (TIMES X NIL Y) (TIMES X (+ X A) ZERO)) For me that's a family. Btw., the MLISP code is from McCarthy, 1960.
&gt; less people consider Clojure a lisp than those that consider it not a lisp Most Clojure users have no prior Lisp experience, how can they know anything about it?
&gt; actually meant that very little code lasts ten years actually quite a lot of code lasts ten years. Kenny Tilton makes fun posts, but that's about it. Yeah, I even was there in Stanford in 2005.
yea I wasn't intimate with the various os's apis for this
Yea, lots of other people appear to have been there too and commented as such, which is why that thread is valuable relative to op's query. Fascinating perspective from the language creator, derived from primary sources. The reference was not about Kenny, who actually appears to have aimed for accuracy and invited feedback; ad hominems are worthless anyway.
&gt; who actually appears to have aimed for accuracy that's a stretch &gt; ad hominems are worthless anyway. It's not ad hominem. He is like that. Funny, but 'accuracy' wasn't his strong point. &gt; Fascinating perspective from the language creator, derived from primary sources more like hearsay. Actually there are better references what McCarthy thought about Lisp future - he actually gave a talk now and then about it. But at that point he wasn't involved in practical Lisp so much. www-formal.stanford.edu/jmc/lisp20th.ps
\&gt; than the common definition of lisp, which \_clearly\_ includes Clojure What would that definition be? That it has parens? That would exclude Dylan. That it has conses? That would exclude Clojure. I've added the emphasis because it seems to indicate that you are starting from the assumption that Clojure must be a Lisp and looking for supporting premises. Keep in mind I'm saying this as someone who normally refers to Clojure as a Lisp and will continue to do so. But /u/lispm's arguments have shown me that there isn't a precise definition of Lisp that matches the commonly used 'extensional definition' of Lisp. This in turn means the term is in danger of becoming a meaningless label. I ask you, can you produce such definition? When you hear someone saying Clojure is not a Lisp, do you think it is an attempt to put down Clojure? is showingYour post elow shows people \_referring\_ to Clojure as a Lisp, not any definition of Lisp. The only definition I saw below is linked in Wikipedia, a single citation to the book [Milestones in Computer Science and Information Technology](https://www.amazon.com/gp/product/1573565210/ref=dbs_a_def_rwt_hsch_vapi_taft_p1_i0) which can be summed up with parens + prefix (excluding Dylan) and seems to be from a randomly selected book.
The Ferret author made it to scratch a specific itch: Clojure-esque lisp that works on embedded systems. Being usable on more heavyweight hardware is just a nice bonus. So most of its decisions stem from that. For example, it defaults to no GC, preferring no pauses and low latency over high throughput. You *can* still configure it to use a garbage collector if desired, but it's not the default behaviour because it's less desirable for that sort of hardware and use case. It's pretty cool, though you lose the convenience of REPL-driven development when using it. :(
Lisp 20th is a 1981 reprint with 1999 footnotes (e.g updated information about prolog). This discussion happened in the context of 2005. The slides are orthogonal to the QA posted in my submission, as they focus on Elephant. Contemporary accounts point to his opinions evolving over time, but I guess we can just discount his input because he's not involved or something (except for starting the whole thing, but whatever)....yikes.
&gt; as they focus on Elephant which he was focusing on at this time. He wasn't doing much Lisp then. &gt; we can just discount his input because he's not involved or something Feel free. For me it was interesting to hear 2005 a wide variety of Lispers (Baker, Gabriel, Allen, Clinger, Lieberman, ...) with widely different opinions.
&gt;That's the advantage of not having a BDFL This is a very important point. A BDFL won't always take the best decisions.
Good luck to both you and /u/ironpotato. It's pretty nice to use so hopefully you'll like it. My opinion so far is that it does a pretty good job of filling that shell scripting niche where what I want to do is too long, complicated, or gross to do in bash but not worth making a "proper" program. Basically, the Perl/Ruby/Python zone. I did a couple tests where I implemented the same script in Racket, Gauche, and Perl, and Gauche did a good job of fitting neatly in the middle performance-wise. Nothing fancy, just a few calls to shell `amixer` to mess with volume levels and get a feel for using Scheme for some basic "glue" code. Anyway, Perl was what I tested against, since it was near-instant and easy to toss together. Racket was easily the slowest, though it improved a lot when I used `raco exe`. Gauche using `gauche.process` lib was a bit slower than `raco exe`, but when I skipped `gauche.process` and used `sys-system` instead, it became nearly as fast as Perl, but arguably nicer to read. Ideally I'd rather be able to use something Clojure-like for this niche, but it's just not feasible right now. ClojureScript via `lumo` *can* be nice for shell scripting tasks, but its startup time is still way too high for some things. [Pixie](http://pixielang.org/) was perfect for the job but it's unfortunately abandoned. Back when it was still maintained I started a frontend to a bunch of Nix commands, sort of like what `apt` is for apt-get, apt-search, apt-cache, etc., and I was really happy with how it was turning out. In fact, I still use the half-finished tool, but knowing the language was dead killed any desire to keep working on it.
Oh man....John McCarthy, just a run of the mill, inactive lisper. Sounds like Joe Bag 'o Donuts with parens. Amazing how you can discount the man's opinion doesn't suit your purposes, but revere it freely when the winds blow differently.
I was there. Just telling you how it was.
&gt; When you hear someone saying Clojure is not a Lisp, do you think there intention is to put down Clojure No, my actual problem ironically is *exactly* that &gt; there isn't a precise definition of lisp Remember, someone wrote about Lisp being a family of languages including, say, Clojure and Scheme. Someone *else* tried to hop in and say that this relatively normal and common definition somehow doesn't get to count. How am I getting the talk about how there's no precise definition of lisp and you can't say one is the correct one, I didn't come to shoot down a definition of lisp, that was in fact metatronxyz, I came *shooting down this idea of shooting down a definition of lisp*, and as part of it was showing exactly that if you were going to somehow decide some definition be official, why is that one more useful in this conversation, or more useful generally? How did this get all flip flopped? This feels like when you're in school and someone hits you and you hit them back and the teacher gives you a talk about starting fights and then you do that Jim stare at the camera for 10 seconds.
Wow, this is very very extensive!! (incf upvotes 100)
Programmer bro grabs to you my friend.
\&gt; No, my actual problem ironically is *exactly* that You problem is exactly what? IIUC is that people try to put down Clojure by saying is not a Lisp? If so I think that's a chip on your shoulder. Clojure's value is not tied to it being a Lisp. Does not being a Lisp means that someone Clojure (through means of ClojureScript) is not the best alternative for front-end web development when looking for a language with macros? \&gt; Someone *else* tried to hop in and say that this relatively normal and common definition somehow doesn't get to count. I don't see it that way. Someone \_stated\_ that Lisp is a family that includes Clojure and Scheme without any definition. Someone challenged that, widely accepted, statement and provided a definition. The definition may not be particularly useful to me or you (I have enough problem trying to load code from pre-ASDF). You reject that definition w/o providing an alternative one, that captures the familiar meaning you (and I) have encountered. Claiming it is just a random criteria with the purpose of disqualifying Clojure. The goal of my original comment is to point that those who that argue for backwards comparability as the standard expose the lack of a precise definition of what it means to be a Lisp. I don't think anyone is going to change their mind about what Lisp means as the result of this argument.
I appreciate it
&gt; For practical purposes, any programmer who learns one of those three, will easily jump to any other, anyways. Yeah, no. Any and all modern programming languages are easy to learn. The effort is in understanding the idioms, important constructs like macros and the libraries. The knowledge is definitely not transferable.
His statement is incorrect. Saying you can easily move between Clojure, CL and Scheme is as incorrect as stating you can easily move between C++, Python and Objective-C.
I disagree as well. The bulk of the knowledge -libraries, macros, idioms- does not transfer. And looking specifically at Clojure, it's a very opinionated language and that opinion is Functional. In contrast Scheme and CL are not. The posters claiming they are interchangeable don't know what they are talking about.
If you don't need the shell, then passing a list rather than a string will cause uiop:run-program to not spawn a shell (when the platform allows). This gives a pretty good speedup on sbcl, and also makes it easier to properly build command-lines dynamically. So it might be interesting to see your implementation benchmarked against `(uiop:run-program '("ls") :output :string)`
(Disclaimer: I mostly compare to Common Lisp here, but assume I'm in general comparing to other lisps as well. Its tiring to write 'Common Lisp and / or other related lisps' over and over) I didn't say why is it useful (usefulness is relative to a goal, and anything can be framed as useful if the question is open ended, although I am also not implying that it is not useful), I said why is it *more* useful, and I didn't say why is it generally more useful, but why is it more useful than the common definition of lisp used at the top of this thread for this specific conversation. As in, if there is going to be a 'correct' definition, why that one? To me, lisp is a lot more than being able to copy and paste from one project to another, but let's explore that deeper for a second; why can't you possibly copy and paste between a CL project and Clojure? After all, I think the implication here is you can't copy and paste it because its lacking features that make it a lisp, not because of some superficial changes that would make direct pasting impossible but keep the language otherwise the same (such as a switch from s expressions to m expressions; in fact, I think you or someone else already mentioned its not the parenthesis that make the lisp, implying others at least agree that the syntax is less significant here). If I, say, can't copypasta the code `(defun add (x y) (+ x y))` , is it a language issue? I argue that it is not; Clojure can understand this text, it only would need a library defining the `defun` macro in this fashion. That is certainly more work than what you would require in a lisp dialect that already has `defun` automatically defined, and considers it idiomatic, but it is still a library problem, or an idiom 'problem', not a language one . I say Clojure can also likewise understand the majority of other common lisp code (until we get to reader macros, which I will get to later), as long as the library has been defined. If you had code like, say, `(defun attack ((Player a) (Player b)) (with-slot (hp str def) ... (setf ..)))` and so on, nothing about this is a language impossibility in Clojure, but a library issue; do we have a library for `defun`, do we have the macro with-slot defined, `setf`, etc. You might say 'well, that is cheating, other dialects have those defined as a bare primitive, you could cover almost everything if you're just allowed to count libraries you don't have' but in that case I would say that is another big point of *exactly* why Clojure is a lisp; the fact that every addition can be delegated to library additions, instead of core language changes, the fact that these libraries build up that same lispy language using that same 'lispy' primitive of s-expressions, where symbols sort of sit side by side with all extra syntax between them removed, requiring something as a bare minimum to at the very least denote the start and end of a block of meaning (parenthesis, in our case) , where these blocks of meaning recursively build up into more complex blocks of meaning, where the first symbol of a block can sort of determine the 'language' that determines how the rest of the block is meant to combine into new meaning, etc. where in Clojure you can cover everything you might try to express in CL in a Clojure library just as CL's libraries can cover everything you might express in Clojure, except when writing a library for Clojure that requires actual manipulation at the reader level. It is a pain to lack libraries in this scenario, but it nonetheless does not change what language we are using when we lack them, even if they have never existed, and so hopefully it wouldn't change what dialect it is either (unless we concede that Clojure would become a true lisp once a full set of CL and other older lisp compatibility macros and functions are defined). Anyways, when do we actually get to library limitations? You only truly get to a *language* issue when you get something like the fact that the unquote in, say, CL, looks like `(+ 1 ,(+ 1 2)) instead of Clojure's `(+ 1 ~(+ 1 2)), but this is a *syntax* change, and a minor one at that. I believe the cons different mentioned earlier would also finally be a real difference, so that's one to at least talk about. You only truly get to another language issue when you talk about these things, or realize 'oh, Clojure doesn't have reader macros.", and you're cut off from implementing any part of CL that requires them -- although even then only the syntactic part, the semantics can still be implemented . So we do finally come to differences, and there are more not written here, but is it really more accurate to then say Clojure is just not a lisp, or is it really accurate to say it is just inspired by it? To me its just throwing out the baby with the bathwater, and its much more descriptive to just say its a lisp, say, without reader macros, and with some superficial syntax changes, etc. Yes, you have to be careful this doesn't become 'its a cat, except with no whiskers, oh and its much heavier, oh and also it barks, oh and also its called a dog", but I don't think we're at that level. If we compare Lisp to ..ducks, and the duck family, I have a much easier time thinking of CL as a duck and Clojure as the smaller African jumping duck, rather than thinking of it as another animal simply inspired by the duck, like a platypus. I also would say that Clojure and CL *can* reproduce into hybrids, it just takes a little more work like it would to breed a horse + donkey mule. To me the things it has are very significant to what makes a lisp lisp, but the things it lacks are not. The only large feature that I'm on the middle about that it lacks that is significant (in power at least) is reader macros, but unlike normal macros, I would not also go as to far as to say they are vital to being a lisp, its just a big feature. Naturally, that part is a bit more subjective, so I won't argue there's a right answer there. I am definitely open to hear about other major features its potentially lacking. Thanks for reading all of this if you get through it, I'm going the fuck to bed, this stuff is so hard to really organize and put into words
[removed]
This is surprisingly rich material from articles I haven't seen before and from 5 years ago! Thank you!
Common Lisp: https://www.reddit.com/r/lisp/comments/b0n7u6/which_book_is_the_best_for_learn_common_lisp/
Yes it did feel like striking gold when it turned up in Google. Glad others found it useful too.
Common Lisp: A gentle introduction to symbolic computation - David S. Touretzky
I'm a beginner of Common Lisp, too. What I currently read is "Practical Common Lisp" by Peter Seibel. It's a very good read. You can have an online version here: [http://www.gigamonkeys.com/book/](http://www.gigamonkeys.com/book/) There is also an ebub version somewhere on GitHub. &amp;#x200B; Manfred
\&gt; I said why is it *more* useful It is more useful to me to identify the languages which share code, then to adhere to some much more vague idea of 'language' and 'dialects'. I can take a LISP book and I know what I will learn and where I can apply that. I can talk to fellow Lispers about it and they will understand me. It creates a community of practice. The wider definition of 'Lisp family' based on relatively undefined/unclear criteria has no useful practical implications. It's similar to the definition of OOP, for which zillions exist and which are hard to agree on. \&gt; lisp is a lot more than being able to copy and paste from one project to another For me it's a wealth of literature, research, implementations, libraries, applications and people working with that. \&gt; copypasta It's not about tiny code snippets. \&gt; nothing about this is a language impossibility in Clojure You'll just don't find it, because that style of programming is actively NOT supported and actively discouraged in Clojure. The language is designed to overcome that style of programming. \&gt; only truly get to a *language* issue Take code from the average Lisp book. None of the operators used there will be in Clojure. But you wouldn't even find the style of programming in Clojure. Clojure strongly supports a certain programming style much more oriented to immutable functional programming, and discouraging large parts of typical Lisp programming style. And that's totally okay. But it makes porting my code basically impossible. But I knew that, since Clojure never promised to be compatible and it made zero effort to be.
I'm likely not as fluent as many of the other commenters, but I've played with both for hobby programming and think each has strengths and weaknesses. Clojure has, IMO, an incredibly beautiful syntax and a clean and readable notation for dictionaries/maps and array like objects as first class language features. It also runs on the JVM (except for clojurescript, which I've never used, and which transpiles to javascript). The JVM thing can be a blessing or a curse, depending on what you're doing. If you want to (or need to) interact with libraries or other code from the java ecosystem, clojure is an excellent swiss army chainsaw and a good choice for shifting an existing java project into a polyglot world. If, on the other hand, you don't need jvm interoperability, the jvm dependency gives you slow startup times, slightly slower runtime perf than SBCL, and a set of dependencies that can deter your coworkers from deploying your clojure prototypes in production. Clojure also gives far more up front conveniences for writing pure functional code. This will pay off if you make heavy use of multithreading: and the JVM is an ecosystem that encourages you to do exactly this. If, on the other hand, you want parallelism via IPC, sockets, message passing, and network calls, I don't have an opinion on which language is best for that. Probably it is still clojure. Purely functional code helps here as well. Common lisp, as others have mentioned, is not a functional language. It's a python/ruby style multi paradigm scripting language that compiles to extremely fast executable code (if you use SBCL), has a bit of a crufty syntax for things that should be first class language members, like arrays and dictionaries, comes with a wildly expressive macro system, and an object model that taps ruby metaprogramming on the shoulder and says "Here, hold my beer." Personally, I'd recommend, if you don't have library dependencies and don't have to work with other people's code, that you learn both, and then write your own set of common lisp macros to give it conveniences inspired by some of the non-JVM advantages of clojure (and maybe some conveniences inspired by other modern scripting languages). This will also give you time to change your mind about not needing libraries, and, eventually, pick the one whose community gives better library support for what you need.
Never used Emacs, so I'll defer on that without complaint ;) Again "possible" is not my point: &gt;"Not really. One just adds declarations or replace the construct in the few places where it would actually matter. For tougher cases write a translator." I suppose we just differ in what is considered substantial **in this context.** The original poster was implying it was little to no effort, and that's why they're considered "real Lisps". I'd consider adding (potentially a great deal of) declarations, or writing a translator to be more effort than the original poster was implying for something to qualify as being "a real lisp" because they're so alike you can just drop one program into another was hardly any effort at all. That was my contention, not that it would be some monumental effort to achieve the porting of a program which expects dynamic binding of variables to an environment which expects lexical scoping by default. I'll agree to disagree though. I've never actually ported a program like this, so at the end of the day I'm speaking out of my area of jurisdiction anyway ;) I don't even use Clojure, but I just think to consider it to not be a "true lisp" when there are considerable differences between many of the other "true lisps", difference which make them just as incompatible, is just a bit disingenuous.
"This makes a Lisp implementation not a Scheme, but it doesn't make a Scheme implementation not a Lisp." I suppose I was conflating the two things. Every valid C program (or, thereabouts) is a valid C++ program, but you wouldn't expect the reverse! Not one of my brightest moments ;)
right, clojure does require a huge change in thinking towards functional style programming. For myself it took some time to get over the initial hurdle, and took several attempts, but I gave it another chance after reading https://dl.acm.org/citation.cfm?id=359579 "Can programming be liberated from the von Neumann style" by John Backus
&gt; I suppose we just differ on what is considered substantial in this context. Throwing away the code is substantial. Moving it to a similar Lisp is much less effort. &gt; hardly any effort at all That's not the problem some people have. The problem is that they are sitting on a code base from 10kloc upto multi-mloc. At some point in time the old platform may no longer be supported - now what? Move it? Port it? Reimplement it in Java or C++? Throw it away? Moving from dynamic binding to lexical binding took roughly a decade: from Scheme on top of Maclisp in 1975 to the first Common Lisp in 1985. That's all long done. Winston/Horn's book LISP first edition was using a dynamically bound Lisp. The second edition was then updated to use lexical binding. The third edition was then updated to use CLOS. But the book did not need to be thrown away... When a new language variant came up that was sufficiently different, then compatibility libraries or translators were provided after some time. Another example the first CLOS implementation grew out of the LOOPS implementation of Interlisp. It was then ported to plain Common Lisp as Portable Common LOOPS (PCL). That one was then expanded in a standard CLOS implementation. When PCL (and a smaller implementation) it got developed, it was then ported to EuLisp (TELOS), ISLisp (ILOS), Emacs Lisp (EIEIO), Scheme (TinyCLOS), ... a translator ported CLOS software to Dylan ( https://github.com/dylan-lang/lisp-to-dylan )...
Well, I tried that, but didn't seem too fast. [Check it out here.](https://pastebin.com/uRbcQrB8)
I don't disagree with anything you've said, you're clearly much more learned on the subject than me (I've never even used common lisp, for cryin' out loud!) so I'll defer to you. I still think Clojure is a Lisp though ;)
Sidebar &gt;&gt; Books. You might want to start with Touretzky and continue with Seibel. Abelson/Sussman is for the truly adventurous beginner.
Webassembly has parens, macros. Is it a Lisp? https://github.com/WebAssembly/spec/pull/155
I'm not sure, I've not used it. I like that it has those things, though. I'm not trying to strictly define what makes a Lisp and what doesn't, I'm not qualified to make that judgement on such a large scale and never will be. I'll ask McCarthy if I end up going to that Log Cabin Home in the Sky before you do ;) I consider Clojure and Racket to be Lisps, that's all. Having sexps and macros is potentially the biggest reason why, but that doesn't mean I think every language featuring them is a Lisp.
I write Common Lisp and have been in the CL community for years. It is a mistake for us in the CL community to see Clojure as a Lisp when it clearly isn't, because to do so would be to dilute the - useful - definition of what Lisp is and how it gives raise to ecosystems. To accept Clojure as a Lisp would fracture everything that has percolated through history. It just doesn't make sense, history comes up to you and slaps you in the face. On the other hand, I can see why many in the Clojure community would like to see Clojure as a Lisp. It gives them instant marketing appeal and something bigger to be a part of. Moreover, it was kind of disingenuous on the part of Rich Hickey to present Clojure as a Lisp. It's not a Lisp, it never was.
Interesting. But wha't the core benefit? Just another syntax for a subset of Verilog?
Well, you get access to the entire Racket Lang and libraries, plus macros. That is much more than syntactic sugar (if that's what you mean by *syntax*). The learning curve is *maybe* less steep if you already know Racket? Dunno, just thoughts.
&gt;you get access to the entire Racket Lang and libraries I'm not sure whether this is really an advantage or even another unneccessary complexity (as with e.g. Chisel). Replacing Verilog for FPGA design by something more specific and less deceptive is a good thing from my point of view. I currently experiment with Lola-2 by Prof. Niklaus Wirth (inventor of Pascal, Modula-2 and Oberon), which is dedicated to synchronous designs and translates to FPGA. If you want to have a look at it, here are the links: [https://github.com/rochus-keller/lolac/](https://github.com/rochus-keller/lolac/), [https://github.com/rochus-keller/LolaCreator](https://github.com/rochus-keller/LolaCreator).
In the [Conclusion](https://blog.cneufeld.ca/2014/08/concluding-thoughts-on-the-less-familiar-parts-of-lisp-series/), the author states... &gt;There’s one more thing a newcomer to Lisp should do, and that is really get a firm grasp of macros. We know that C and C++ discourage C-preprocessor macros, for valid reasons, but Lisp macros are a very different species, and once you understand their power, it opens up entire new realms of possibilities. There are those who claim that a good understanding of Lisp macros even helps when programming in other languages, and perhaps that’s true, at least for some. I think an understanding of Lisp macros helps the programmer to think of the algorithms themselves in an abstract way, just as algorithms help the programmer think of data in an abstract way, and that that abstraction leads to a more complete understanding of the problem. He discusses macros further at the following link in a 9 part series of articles: &gt; So, in a series of posts, I talked about Lisp macros and their power. &gt; &gt;... &gt; &gt; In this series of articles, I described how to set up Lisp macros to create a new looping structure in the language, for a particular use case I had in my work. &gt; &gt;[https://blog.cneufeld.ca/2013/10/summary-of-lisp-musings-posts/](https://blog.cneufeld.ca/2013/10/summary-of-lisp-musings-posts/) In addition, he offers... &gt;... a 6-part series describing exception handling in Lisp, specifically to point out the similarities and differences to exception handling in C++. &gt; &gt;[https://blog.cneufeld.ca/2013/11/collection-of-lisp-exception-handling-posts/](https://blog.cneufeld.ca/2013/11/collection-of-lisp-exception-handling-posts/)
Sounds like exactly what I've been looking for. I've been using void linux and going with the suckless philosophy. I'm using WMUtils to manage windows, and doing things with bash scripts is just not pretty or friendly. This seems like it will open a world of possibilities
I'm just having a class that teaches Verilog and FPGAs, and I must say, this is a life-saver. I hate Verilog, but love all Lisps. I wish I found out about it sooner tho
=D
Thank you!
Misses a golden opportunity to refrain from that `#lang` thing that Racketeers are natively infatuated with.
Something else you might want to consider instead of bash scripts, if you don't care about portability, is using [fish shell](http://fishshell.com/). I usually suggest it to people because it makes a great interactive shell, but it *also* chooses to ignore POSIX compliance in favour of saner syntax. To get that saner syntax it does a couple lisp-y things: preference for adding built-ins (or using commands) instead of creating new syntax, and uses parentheses for sub-commands instead of backticks or things like $(). It's still not a good choice for anything heavyweight, but it fills the "quick shell script" role without making me want to tear out my hair, and those two design choices give it an almost lisp-like feel as a bonus. A couple small examples: function hr set -l delim '=' if test (count $argv) -gt 0 set delim (string sub --start 1 --length 1 $argv[1]) end for i in (seq 1 (tput cols)); printf "$delim"; end end function clock # 3 is height to move down for font mono12. 8 is shift for doh # and 2 more if I want to centre on the date too. set -l date_font 'future' set -l time_font 'mono12' while true; set -l h (expr (tput lines) / 2 - 5 ) set -l w (tput cols) clear for i in (seq 1 $h); echo; end; figlet -w $w -f $date_font (date +'%A, %B %d') figlet -w $w -f $time_font (date +'%I:%M%P') sleep 20 end end The clock is just a dumb little thing I did to see how fish scripting felt, and the `hr` is a quick-n-dirty way to draw horizontal lines like an html &lt;hr&gt; tag. Using parens for sub-commands makes it almost look like a lisp with the outermost parens removed.
I recommend, in this temporal order: 1. Land Of Lisp 2. On Lisp 3. Let Over Lambda The first one will get you started on the basics. When you worked through that, you should be used to writing and reading Common Lisp comfortable. The second one gets into more interesting territory that is specific to Lisp and its macros. This will give you an appreciation for what it means to have macros available. The last one seriously overstates how complex it is, but it is a great resource for understanding what scope is (while expanding on the whole macro thing), which is a seriously underappreciated topic.
What's wrong with verilog? Verilog is great for fpga
I still think verilog is better for fpga. This seems kinda useless
Didn't say it wasn't good. I just hate the syntax
Racket has one of the most powerful macro systems of any programming languages, I wouldn’t underestimate it. I could see someone adding in extra compiler phases with it, particularly for something like verilog.
Cool cool. I have `Systematic Programming: An Introduction` by Wirth. I'll take a look. I did not get to the end of the article when I replied earlier, but seems like the point of `Fairylog` is lisp macros and *not writing verilog*: &gt; Now you can write Verilog code with RACKET MACROS what more needs to be said? As an example of what is possible, the CPU I designed that was programmed to produce the videos at the top of the post, was able to mostly implement its own instruction set through the use of macros. &gt; Now, I have never wrote any HDL code before, but after examining Verilog for a few hours I knew we were not going to be friends. &gt; As a parting entertaining anecdote, I have still managed to never write an actual Verilog program from scratch! Achievement unlocked :) &gt; At this point it is still a tool mostly designed by me, for me, so you can expect it might change quite a bit at any time. Testament to Racket though, the original working version of Fairylog took me just 2 weeks to get going.
No doubt Verilog is challenged in different ways; starting with the fact that it was conceived as a simulation language and not originally meant for synthesis; it also offers too many degrees of freedom for an FPGA developer; a lot of stuff is never used when you do FPGA development, even less when you do synchronous designs only (which applies to the majority of designs); but since it is conceived to the general case it gives users plenty of opportunities for mistakes. The large number of books and tutorials specifically on digital design with Verilog shows that the correct application is rather a secret science and one would never reach the goal with the IEEE standard alone. An alternative with fewer footpins and a focus on FPGA design would definitely be advantageous. In fact, I've already done trials with an alternative HDL in Common Lisp. I'm aware of MyHDL, SpinalHDL or Chisel. Even if I think CL macros had major advantages to the other mentioned I didn't follow up on it because just creating yet another embedded language (yes, also the synthesizable subset is nothing but an embedded subset of Verilog) doesn't make any sense and suffers from similar disadvantages as the original. But there are undoubtedly better ways to benefit from macros than more or less replicating the syntax constructs of Verilog. What's the point of having "(always (\[#:posedge clk\_100mhz\])" instead of "always @(posedge clk\_100mhz)"?
I knooow. I really want to like fish, but I can't justify the lack of posix compliance :(
Wow, such empty
Any framework or library for this purpose ?
If you're considering using Gauche Scheme for things you're already abandoning it any way, so what's the difference? It's just mental hurdle, a pointless nagging thought of "but but but portability". I did the same thing for a while, used fish interactively but still always sh or Perl for scripts, until I finally went "this is silly, I'm not sharing this stuff anyway." In the off chance I need something portable and can't just install fish on the other system (extremely rare) I'll just rewrite it, it's not likely to be that much work, and it means I don't have to hate myself every time I make a short shell script. :)
&gt; What's the point of having "(always (\[#:posedge clk\_100mhz\])" instead of "always @(posedge clk\_100mhz)"? Personally, I don't see a point. The author will have to speak up on this. I really think it's just that they didn't like the look of Verilog. That the feeling I get anyway.
Caveman2 and/or Racket's built-in one?
Racket does ?
[Racket does.](https://docs.racket-lang.org/continue/index.html)
Would Caveman2 reduce among of code compare to Racket ?
No.
[contrived example](http://imgur.com/Xqf0hGK) [less contrived example](http://imgur.com/SZU9Zxh)
[removed]
CLX (let* ((display (xlib:open-default-display) (root-window (xlib:display-roots display)) ;might need the car, dont' have a repl open. (xlib:warp-pointer root-window x y))
Working on a frankenstein gui/compositor/desktop/ system. It's based off of laziness, (view symbol) gives you a graphical representation of a symbol that evaluates to itself when clicked. Default display methods for symbol, list, string, and arrays(as images), xwindows and child views implemented. Structure/class/function/package views come next, just needed a view/window-manager first with simple key-binding. action/reactions can be added to each view, which in the end should be pretty autonomous, they can launch their own thread or give up control to a manager, or even fork a new process. Frame rates or update-on-change can be specified for each view, just finishing up xfixes,damage,composite,sync, present,and dri3 extensions to X (the price to pay for accurate framerates). It includes a system that keeps track of all instances, and allows easy deleting of objects(eventually will gc them as well). Media crawler is already written, the mime-type storage comes next, eventually hoping to get the search running parallel with simd instructions. Simple cursor closures that can do grid-layout of objects, text layout in any direction, e.g. english (:right :down) chinese (:down :left), max-rects, vertical/circular menus. Still need to add switching text-layout directions, requires a cursor for each of the 8 combinations right now. Image loading and display is done, including rgba transparency. Flexible layouts just finished today for desktops and applications. CSS3 translator for view properties and their layout comes later when ready for mass consumption. Desktop layouts are chosen depending on the amount of windows on the screen, can cycle through different layouts or cycle the windows within the layout. Hrm, that seems like a lot. The next thing to be worked on is probably cleaning up the x window-manager and key-binding helpers and adding them to the other basic xutils. Now that I have automatic layout and graphical event and variable listeners, debugging x extensions should be much easier.
I’m partial to radiance (https://shirakumo.github.io/radiance) for CL and Awful for Chicken Scheme.
Can also really recommend radiance for CL. Really great.
Very interesting. Few people have written thoughtful commentary on so many of the obscure, but sometimes useful, dusty corners of Common Lisp. This could be quite a useful resource, especially with a little clarification of formatting and perhaps licensing.
As a Lisp programmer, I applaud your use and appreciation of the magic of macros, but this kind of creeps me out: (let v? (not (= val '_))) Is your `let` not lexical? It reminds me of a feature of infix Dylan that bugged me.
&gt; this kind of creeps me out What creeps me out is... *sigh,* yet another Lisp-1 ;-) Question for u/codr7, does `let` support this? (+ (let a 2) a) ;=&gt; 4
[removed]
Yeah. The whole Lisp-1 thing seems like it's for language implementors , not language users. Having to pointlessly call your variables `the-list` or just `l`, instead of `list`, gets old *really* fast.
Common Lisp is a VERY complex language, and the dual namespaces are part of that. And complexity is the last thing I need for an embedded scripting language like g-fu. Nope. The binding will be available in the current environment, but let without a body doesn't return anything so it'll try to add `nil` and `2`.
It has two modes, both lexical. When invoked with a list of bindings as first argument, it will behave more or less like you expect it. When called without it will introduce the same bindings into the current lexical environment rather than opening a new, which allows reducing nesting and the number of live environments.
It seems his let is not even a `let`, more like `var` from JavaScript.
seeing as this is lisp ontop of X with no window manager or desktop environment printscreen does absolutely nothing. Though I do have keybindings working and easy access to a surfaces data that could be written to png easily, it seemed easier to snap a pic than write a screen cap function before bed.
&gt; Why? I'm always curious about programming language design choices. Thanks for the answer! &gt; complexity is the last thing I need Yet your `let` is more complex than usual.
https://web-artanis.com/
It's optionally less complex and leads to less nested code, nothing you see here is by chance or coincidence.
do you have a link to the barcode reader? It'd be nice to have one for my receipt scanner and not have to write it.
Arcadia would be ideal. It’s a Clojure interface for Unity, but it seems like it’s excluded by the gamejam requirements, which is a shame.
.. Reliable ?
Well a shell, vs a (possibly embeddable) scheme variant is different in my mind. Plus C interface! You make a good point though, if I was in a slightly different situation I'd agree with you. But I think I'd rather have a scheme than learn yet another shell scripting language. Unfortunately I do tend to share my utility scripts. Like I said, this is for windowing, so it's a bit more involved than my average shell script anyway. And I wouldn't dream of sharing this code, because I don't want to hurt anyone. Unless they really want examples of how to use WMUtils, then it's on them....
Try `import -window root png:/tmp/foo.png`.
Ah. Thanks for explaining that. You did indeed make some of the same choices as Dylan, which I certainly respect, but isn't really my thing anymore. I am glad that at least the necessity of implementing a Lisp in every other language is being fulfilled. (:
Cool. Never got into Dylan myself, once I realized they dropped the parens but kept the overly-descriptive-names I sort of lost the motivation. I've grown fond of always keeping two languages around, one host language that provides basic building blocks and system access and an embedded scripting language for everything else. The idea of writing entire applications in nothing but Go doesn't appeal to me at all.
&gt; printscreen does absolutely nothing. &gt; I do have keybindings working Pick one? ;)
I used [Hunchentoot](https://edicl.github.io/hunchentoot/) for Common Lisp in a hackathon, and it helped me tie for the Best Functionality award out of about 12 teams.
 Any other support libs ? I'm seeing it at level of mini framework like Flask
Second Hunchentoot. It's simple and easy to understand. I use it with JS front end tech
Thanks for checking that. I got a &gt; 2x speedup on my system, though async-run was still faster.
Why isn't anyone recommending ANSI Common Lisp by Paul Graham as the first book? Is it dated? Or people just think that there are better resources? Because I'm reading it now and really enjoy it.
&gt; I'm seeing it at level of mini framework like Flask Hunchentoot is more of a web server than a web *framwework*. For a very interesting framework that offers something not easily found elsewhere, see Weblocks.
I haven't read this particular book but it seems fairly popular and has good reviews. If you think it is worth recommending you can recommend it for OP and maybe give your short comment why. It is most likely not dated. I started with Common Lisp: A gentle introduction to symbolic computation - David S. Touretzky - this book is very old and uses some weird name convention that seems obsolete. But it is first time that everything started to click for me (before that I tried to get into programming many times). I think it is pedagogic masterpiece. One of the biggest advantages of Lisp is access to highest quality books out there. And there's a lot of them so stick to what you are doing and you should be fine. After you finish and want to learn more you can search for further recommendations.
Yeah, I wouldn't do something like *that* with fish, but it's good for smaller stuff that bash is suited for while being less frustrating as a bonus. Depending on what I'm doing, where I'm going to use it, and my mood, I basically use a mix of bash, fish, gosh, perl, and sometimes ruby for scripting type stuff. They all have different pros and cons so I don't pick just one thing to use. Like I was saying, I'd love to use Racket or Clojure(script) instead of some of these, but they both start-up time issues that don't mesh well with scripts where you expect (near) instant execution and feedback.
I can bind keys, doesnt mean there is anything bound or that I have a print screen function. Or at least I didnt before this afternoon.
thats cool. But I'm being difficult and if I have to do something I'm doing it in lisp. Besides, now I have png writing from any X11 surface and I dont have to start a shell. I have to say I'm pretty surprised how often non-lisp solutions are offered for everything. I thought this was r/lisp?
What do you mean by a web-framework? Do you need a bare-bones web-server or something akin to Django but in Common Lisp? &amp;#x200B; Here is a variety of both kinds to check out: &amp;#x200B; [https://github.com/fukamachi/clack](https://github.com/fukamachi/clack) [https://edicl.github.io/hunchentoot/](https://edicl.github.io/hunchentoot/) [https://github.com/fukamachi/woo](https://github.com/fukamachi/woo) [https://github.com/fukamachi/caveman](https://github.com/fukamachi/caveman) [https://github.com/hargettp/hh-web](https://github.com/hargettp/hh-web) &amp;#x200B; There are others as well. If I were to build a web-app, I would probably use Clack since you can use it as a wrapper to build an app into which you can plug in different web-servers (Hunchentoot, Woo, etc).
I cannot really compare the book with others, because it is my first book about lisp. On the other hand, I like how the author explains everything incrementally and with many small examples, without overwhelming the reader with complex material on the very start. So yeah, I do think that it is a good book for a beginner.
Start with Lisp in Small Pieces /s
I appreciate your enthusiasm for sarcasm, but to become a master you mustn't use /s. *I'm a human being, and this action was performed manually.*
Thanks bot, but here it is mandatory.
Thanks for working on this. I remember in late 2016 I was trying to go through some of Andrej Karpathy's online material using clojure and it seemed like core.matrix wasn't up to it. Will give it another shot with neanderthal once I make some time.
order of evaluation is left to right. If there's a problem with x, as in the error, y will never have been evaluated, and changing it to see what happens with x accomplishes nothing. Note the person said he has no problem when he manually substitutes the integer values, which again has nothing to.do.with y being evaluated.
I never tried it but you could use [EQL](https://gitlab.com/eql/EQL5/wikis/home), which is ECL with QT. I think, since it is embeddable in C in theory you could turn it into an executable.
I am successfully using Shinmera's Qtools and Deploy to build working applications.
&gt; if I have to do something I'm doing it in lisp Good luck with that. Seriously. I've had the same attitude for years and know just how hard but 'rewarding' it is, providied you don't count 'rewarding' as most people do, but rather as making a few electrons dance to this very specific tune. I think most interesting Lisp software exists because of this attitude.
[https://sourceforge.net/p/sbcl/mailman/sbcl-help/?viewmonth=201904&amp;viewday=23](https://sourceforge.net/p/sbcl/mailman/sbcl-help/?viewmonth=201904&amp;viewday=23)
+1 for radiance.
...see [my\_app](https://gitlab.com/eql/EQL5/tree/master/my_app) for an example how to build an executable.
2D or 3D? You can also find some resources helpful at http://lispgames.org
Is it though? What rule in particular do you think excludes it? I think we had submissions based on arcadia.
It's good but there's more publicly accessible materials (at least "officially", that is).
There are many options, besides Gtk: - LTK, tk bindings. API is really nice and well documented, but will require you to bundle TCL/TK. Doesn't use CFFI. - EQL (Qt). Qt already bundled. Works even on Android. - FTK bindings (the maintainer posted here recently), a lightweight toolkit. - FTW, this is directly calling the Win32 API (so no external libs to install), works straight away and has a ton of examples. - Graphic-forms, same, doesn't work in my machine but has very elegant API - abcl-jazz which is my example on how to call Java Swing UI from ABCL. - there is also a wxWindows biding, another cross-platform toolkit.
This is an excellent book if one wants to learn Common Lisp at the level of its guts, i.e., cons cells, lists and functions. It is slow to get to the code part, but instills a very deep understanding.
I'm slugging away on [https://github.com/lispnik/iup](https://github.com/lispnik/iup) Still in development, but it runs fine native on Windows 10 and Ubuntu with SBCL or CCL. Theoretically it should be possible to save an image executable but I have not tried that yet.
Sorry for correcting you, but **EQL5** doesn't have Qt bundled, that's **CommonQt** (which is also in Quicklisp). In EQL5 you need to download Qt5 from the official website, in order to be able to build the binding.
I confirm I had success with windows 10 and sbcl the link above is my post to sbcl-help mailing list.
Thanks for correcting!!
Tip for bundling TK; there is a way to bundle all of TCL and TK into a single executable; you can \[generate them online here\]([http://kitcreator.rkeene.org/kitcreator](http://kitcreator.rkeene.org/kitcreator)) just select the OS and make sure that you check the "Tk" checkbox.
Clearer examples. Image wise at least. (calc-layout '(a b c) '(1920 . 1080)) ((A (1920 . 360) (0 . 0)) (B (1920 . 360) (0 . 360)) (C (1920 . 360) (0 . 720))) ['(A B C)](https://i.imgur.com/RJhE954.png) (calc-layout '((a . .80) (b c d))'(1920 . 1080)) ((A (1920 . 864) (0 . 0)) (B (640 . 216) (0 . 864)) (C (640 . 216) (640 . 864)) (D (640 . 216) (1280 . 864))) ['((A . .80)(B C D))](https://i.imgur.com/zePdbOk.png) (calc-layout '((a (b (c d) (e . 100))))'(1920 . 1080)) ((A (960 . 1080) (0 . 0)) (B (960 . 490) (960 . 0)) (C (480 . 490) (960 . 490)) (D (480 . 490) (1440 . 490)) (E (960 . 100) (960 . 980))) ['((A (B (C D)(E . 100))))](https://i.imgur.com/3B4CUSX.png)
It's getting to the point where most of the things I need to do now just need one function of 5-10 lines. I think my screen cap function is about 9 lines and hey, less typing than the above shell command and automatic timestamped filenames
Did this happen? Any videos?
You shouldn't use GTK on Windows (on anything really but I digress), it's a disaster. Here are some realistic solutions: 1) Use Winapi directly, through SBCL FFI or CFFI. (http://zetcode.com/gui/winapi/) 2) Use SBCL FFI or CFFI to interface with a 3rd party GUI library that's easy to use (that's not QT). Examples include: + https://github.com/vurtun/nuklear + https://www.fltk.org + https://github.com/andlabs/libui
Why? I kind of do not like the looks of wxWidgets, but what is wrong with the other solutions.
[javafx based](https://github.com/cljfx/cljfx) [swing based](https://github.com/daveray/seesaw) Both work great on W10, and elsewhere.
Thanks!! This helps me a lot for taking another look to LTK.
&gt;1) Use Winapi directly, through SBCL FFI or CFFI. &gt;Stay - far - away from wxWidgets, graphic-forms I don't understand. `graphic-forms` is almost using the Win32 API directly. In any case, there is the `FTW` library, which maps almost 1:1 to the Win32 API.
Sorry setup I had broke so I could only stream or record, not both. I'm back tomorrow though with a proper episode
6pm UTC happens when this comment is 18 hours and 25 minutes old. You can find the live countdown here: https://countle.com/eDdaIkNIj --- I'm a bot, if you want to send feedback, please comment below or send a PM.
Don't stop and keep going! I like that it's looking [very mature!](https://github.com/lispnik/iup)
&gt; order of evaluation is left to right. If there's a problem with x, as in the error, y will never have been evaluated X and Y are *alternatives* (substitutes) in this situation. So the order of evaluation is irrelevant, since they're components of different concrete forms.
I've missed SO MANY of these streams that I'm starting to wonder if my perception of time is breaking apart. I'll be there today though. I hope.
**Qt** (not QT) is perfectly fine if you *already know it* (I knew Qt long before I started learning Lisp. Many are in the same boat). &amp;#x200B; On Linux, Qt is first choice for many reasons.
That's possible, but Clojure-on-Chez could still be often more useful relative to Clojure-on-JVM.
Will be good to have you back! seeya there
Oh definitely. I'm all for more Clojure host platforms.
You are ~~EVAL~~ EVIL!
of course hack could be vastly improved by adding global declarations and recording clines, adding proper expression scope tracing etc. then it would be possible to: c99&gt; int i = 42; c99&gt; printf("%d\n", i); c99&gt; float xxx { ... float x = 15.0; ... return x; } c99&gt; xxx();
[IUP](http://webserver2.tecgraf.puc-rio.br/iup/) is cross-platform, but does not seem to support Mac OS X directly. Since it does support FreeBSD with GTK+, it is probably possible to make it work somehow.
You can even start another ECL from it (tried it on Linux): \`\`\` c99&gt; system("ecl"); \&gt; (ext:quit) c99&gt; \`\`\`
It sounds like you're specifically looking at Common Lisp. I also develop primarily on Windows 10 with SBCL and it's also my go to Lisp. But on Windows, the only GUI I've had any consistent success over time with is LTK, which works, but it's, TK.... So when it comes to cross-platform desktop GUIs, I use Racket. It has a mature GUI that is simple to compile and deploy. It even has a nice RAD plugin, MrEd Designer. https://github.com/Metaxal/MrEd-Designer The GUIs are still pretty big, but in my experience, still smaller that an SBCL dump. I still perfer CL, but at least Racket is still a Lisp and probably a lot less hassle. That being said, I'm hopeful for IUP, but haven't tried it yet.
[Echoing my comment](https://www.reddit.com/r/linux/comments/bg96a8/lisp_gui_on_windows_10_in_2019/eljhyeb/) from your removed post on /r/linux: [You might try Racket.](https://racket-lang.org/) It's free and cross-platform. It can build GUIs pretty easily, AFAIK. It also has a great IDE, with lots of good support for other text editors.
Not as dated as Common Lisp :) I took my baby Lisp steps with this book holding my hand, Paul Graham is an excellent writer, and he knows his parens. He also wrote a more macro-oriented book called On Lisp, which is available for download from his website (http://www.paulgraham.com/onlisptext.html).
perhaps it's because you're using X and Y to denote something else than the example that uses x and y as variables. In the example error, y was not evaluated because there was a problem with x.
Do you mean [this guy](https://github.com/root-project/cling) wasted his time?!
Does the ffi module have c++ support ? If yes, he has :D
goodbot
Land of Lisp is a pretty bad book for a beginner to start with. The problem boils down to this, Conrad wrote it as a book for moderately experienced Lispers but his editor demanded he dumb it down. Unfortunately the resulting book is a bit of a mess level-wise. And honestly the way some of the games are built- seriously, generating a vector graphics file that you have to open in a separate viewer in order to see each turn of a game. Seriously Conrad? What were you thinking. And no mention of Practical Common Lisp?
My recommendation would be install Dr Racket (Racket is an extension of Scheme) and read How to Design Programs, which is written by the authors of Dr Racket. Racket, Doctor Racket and HtDP were written to teach students programming.
certainly he did not, this is just a toy while that repl gives you i.e result printer etc. I'm not saying it would be impossible to expand this hack to something with similar capabilities, but it would be a tad longer than 7 lines of code. As of C++ support - if you compile ECL with CXX core it is possible to work with C++ expressions.
&gt;And honestly the way some of the games are built- seriously, generating a vector graphics file that you have to open in a separate viewer in order to see each turn of a game. Seriously Conrad? What were you thinking. As I understand it, that is standard praxis for a lot of applications now, whether written in Common Lisp or not. &gt;And no mention of Practical Common Lisp? I found Practical Common Lisp to be kind of boring. I never finished it. I mean, yeah, it's easy to understand and covers all the important topics, but it doesn't give me the enthusiasm I need. Other people think it's good because it is right for them, they recommend it and I assume that's enough for whoever is looking at this. I think the first book I ever finished working through was On Lisp, but I wouldn't recommend it as a beginner's book. Land Of Lisp seems straightforward enough for me – understanding alpha-beta-pruning is not for beginners, yes, but the algorithm is implemented completely and correctly, the book doesn't require you to understand it, so I don't see it as a barrier. &gt;The problem boils down to this, Conrad wrote it as a book for moderately experienced Lispers but his editor demanded he dumb it down. Damn, that's sad.
Until upstream accepts my PR, this fork allows you to use the latest versions of SBCL and CCL, which have had been updated from SBCL 1.2.13 and CCL 1.7 to 1.5.1 and 1.11.5, which you need to run some libraries like websocket-driver that expect somewhat up-to-date implementations.
I started with ANSI CL by Graham. I still use the language reference in the back alot, if I don't have access to the hyperspec. LoL is over-rated. He uses implementation specific code walking, which turned me off. If I was starting now, I would follow SJL's excellent (road to common lisp)[http://stevelosh.com/blog/2018/08/a-road-to-common-lisp].
&gt;The image file that is created during system initialization contains the entire cons pool of the system Does this mean that all cons cells are statically allocated? So, there's no memory allocation going on at runtime, just setting of their contents? Does that mean every cons cell has to be able to possibly hold every type of primitive data? Again, apologies for my ignorance.
The tiny (100 lines) Prolog is nice: https://www.t3x.org/lisp64k/prolog.html And here an explanation https://www.t3x.org/lisp64k/logic.html Lots of examples for the tiny lisp!!
Thank you, u/nils-m-holm for posting this. I've enjoyed the time I've spent on [t3x.org](http://t3x.org), and I will be spending many more hours reading there and thinking about what I've learned there.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/h_n] [C REPL Using Embeddable Common Lisp](https://www.reddit.com/r/h_n/comments/bh58di/c_repl_using_embeddable_common_lisp/) - [/r/programming] [A quick C repl in Lisp (x-post from r\/lisp)](https://www.reddit.com/r/programming/comments/bh2zt7/a_quick_c_repl_in_lisp_xpost_from_rlisp/) - [/r/tinycode] [7loc C REPL in Lisp](https://www.reddit.com/r/tinycode/comments/bhap3m/7loc_c_repl_in_lisp/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I suggest https://github.com/Clozure/ccl/issues/ and `#ccl` on Freenode.
Good idea. Posted [https://github.com/Clozure/ccl/issues/210](https://github.com/Clozure/ccl/issues/210).
WTFFF!!!! Lisp always keep surprising me. Now I'll brag about that in public.
Just try Guile Scheme bro.
 (let @ (fun (rf fs..) (if (= rf _) (fun (rf) (fold (reverse fs) (fun (acc x) (x acc)) rf)) (fold (reverse fs) (fun (acc x) (x acc)) rf)))) What's with the ugly, JavaScript-like outdentation of lambda bodies?
I think we need a new name for it. There are two kinds of lambdas, \`fun\` and \`mac\`, where \`mac\` is short for macro, and macro forms are created by binding \`mac\` expressions to variables using the \`let\` form. &amp;#x200B; This seems to imply that whether something is a function call or a macro is not known until runtime.
Objects-as-closures have been done to death. They're more popular in Scheme, where you pretty much have to do something like this if you want to do OOP.
Hey, so although there is some math-y stuff in that book, I don't personally feel like this problem is too math-y. It will be a matter of learning through it. You can do it. Keep trying even if it takes a few days. You are developing great problem-solving skills by sticking with it. &amp;#x200B; So I remember in the book, that they recommend adding adding parameters to the iterator that hold state. So for example, if you are trying to write an iterative process to find the sum of a list of numbers, the iterator takes a parameter "sum" that starts as zero. Then you add the current value to the sum, and pass that value as the sum for the next iteration. &amp;#x200B; This is a pattern called "accumulation". You have a variable where you keep accumulating the result as you go. This pattern was sufficient for much of the early iteration work if I remember correctly. Hope that helps. Definitely let me know if you have questions or want to talk about the specifics.
From what I can remember, the math in SICP consists mainly of discrete mathematics and some calculus concepts (I think you write some functions that simulate integration?). I would mainly focus on learning some discrete math, seeing as you struggled with iteration vs recursion and moving between the two.
Hi, this doesn't answer your quesion but: Don't despair, I also had a very hard time with SICP but now all of that stuff is really easy.
Thanks for the encouragement! The book is quite interesting and I'm not thinking of giving up. I suppose what's math-y is relative. The last exercise I struggled with was \[1.19, explained \[here\]([http://community.schemewiki.org/?sicp-ex-1.19](http://community.schemewiki.org/?sicp-ex-1.19)). If you look at those explanations, they're focused on deriving the formulas for the intermediate states. I consider this math-y because the reasoning is mathematical. The authors give you two formulas that are equivalent and tell you that there is an equivalent third that can be derived from the second. The book does not give the reader a method for determining this. It seems to expect the reader to have a method for that derivation. I don't have any method for that. So while I know that I need to pass state forward during each iteration, I don't know how to compute those states. And computing those states is a matter of math.
Thanks for the encouragement!
Can you jump into discrete math without refreshing topics like algebra and geometry?
It works on the recent snapshot: [https://github.com/Clozure/ccl/releases/tag/v1.12-dev.5](https://github.com/Clozure/ccl/releases/tag/v1.12-dev.5).
I did not see mentioned OPs math background. I wonder if this blog post is helpful: https://funcall.blogspot.com/2009/03/not-lisp-again.html?m=1
Oh yes. That is indeed mathy. Lol. I skipped some of the problems like that. I can't really help much because Im actually very lacking in mathematical prowress. Good luck! Sorry for the misunderstanding.
Tail recursion to iteration is trivially easy, because it's just a syntactic sugar for iteration. Actual recursion to iteration is less easy, because actual recursion returns (backtracks). To turn it into iteration, you need an extra data structure, like a push-down stack, to simulate the returning (at the very least), if not a bunch of other information that is otherwise held in the recursion stack frames. State information may need to be stored in the nodes of this stack in order to know what to do when returning to any node. Recursion implicitly stores state by keeping track of the specific return address within a function. If a function makes several recursive calls in different places, the control returns to the correct place to step through these. If you make this explicit, you have to track that yourself: "okay, at this point in the stack we went down that leg of the recursion, so we have to go down this other one now ...". If you're recursively traversing a graph that you're allowed to mutate (like doing garbage collection or whatever) there is a trick that lets you store the return pointers into the structure itself, avoiding the allocation of a stack. Other than that, a possible strategy is to change or rearrange the algorithm: solve the problem afresh with iteration rather than mechanically simulate the recursive solution. A good example might be recursive binary merge sort: recursively chopping a list in half, except when it's one element long, sorting the halves, and then merging them. The binary merge sort has local variables for the two halves of the list. Copies of these proliferate among numerous stack frames. The iterative version has to keep track of those pairs somehow, as well as which stage of processing they are at: has the right one been sorted yet so that the merge can be performed? In this case, what we can do is change the algorithm to be bottom-up to avoid the complexity of simulating the recursion. We break the list into N lists of one item (using an external array of length N to hold the pieces). Then we sweep through the array, merging them pair-wise: now we have N/2 lists of length 2 at the bottom of the array. We repeat that: merge pairs of these lists, and so on, until we are down to one list.
I found exactly the same as you, almost as if the computer science problem was being explained by using a mathematical problem that was not to do with the computer science problem at hand. The example you give is unfortunately a bad case of this early in the book. Many on this group like to make out like SICP is no big deal, just an undergrad book. It's hard the first time you're reasoning about these concepts! Don't worry though, once you get in the swing of it, it all comes together. I have a distinctly average mathematical background, but found that the book got less maths-y further on. Stick with it. The real benefit it will teach you is, as the title suggests, how to interpret and structure data and programs in an interchangeable, appropriate and elegant manner. When you hit a road block, take a break for the day, let your brain work on it overnight, and try again tomorrow.
Depends on dlib. Where is dlib? IDK.
You'll definitely find at least some of that in most College CS texts, which SICP is, but from what I remember of it there's not a ton if it in SICP. You can just skip those exercises keeping in mind that for the audience it was targeting: students would have likely already had or were taking Calculus at the time. So they aren't (usually) throwing in the math to be arcane, it was just something the students were expected to know and didn't require (re-)explaining. That said, there may be some areas where you find you'll hit a wall and can't just skip an exercise because understanding it may require following the math in order to move on to the next section. Think of those situations as a challenge that you will run into while programming at least occasionally: to get from A to B you have to go learn something about D, K and M first. So there may be times where you need to put down SICP for a bit and detour to (re-)learn some math to progress. Generally, the stronger your math and related problem-solving skills are, the easier you will find many types of programming tasks so it won't be wasted time or effort. The alternative is to accept that at best, there are going to be areas of programming/programs that will always be opaque to you (at worst, they will be completely inaccessible) which sounds like your primary discomfort right now...
For the most part, yes. But to me SICP is really all about computation, not mathematics. If you know how the call stack works, and you know how function calls work, then you will understand how recursion works. And you will be able to deduce how tail recursion probably works. If you know what the computer is doing “under the covers” when a recursive function is invoked — if you can think about how the call stack is being manipulated — then you will have no problem converting what the books calls a “linear recursive” algorithm to a “linear iterative” one, and you will understand exactly why it works. “Tree recursive” algorithms will come later. :) Before continuing with SICP I would recommend reading a book/taking a class on computer architecture. “The Elements of Computing Systems” aka nand2tetris is a great resource. So is “Computer Science from the Ground Up”.
That is a good REPL. A great REPL also comes with an inspector so you don't have to traverse trees of objects by eye, a debugger so you don't have to print out program states yourself, function-definition lookups, etc, etc, tldr SLIME is a great REPL.
Good catch! In related good news, it seems to have no conses. Would it be accurate to call this a Clojure for Golang? I'd argue that "vaguely Scheme-like, designed for specific host, we need no stinking conses" should qualify a language as a Clojure. A few syntactic and semantic differences between this and Clojure can't be reason not to call this a Clojure, because that would mean Clojure couldn't be called a Lisp. Unthinkable ;-)
An idea: you could use Genera along with the VLM emulator.
&gt; like being able to go to a function's definition, look at the online help that doesn't look to be a specific Lisp Machine feature. Basically any integrated Lisp IDE does that.
Emacs isn't a full Lispm or Lisp implementation, but the CADR emulator and software are very easy to find.
In "visual" term, from an user perspective, Emacs can be an operating environment that does not follow UNIX model nor Windows "widgets apps" model. So for the little I know (mostly docs and videos) about LispM my answer is yes in showcase term. My personal setup is NixOS that load emacs/exwm at boot so essentially "boot to Emacs", NixOS config itself is in org-mode, manually tangled upon change so the system is actually configured in text via Emacs. Emacs offer a fully-integrated text environment from notmuch that not only provide a featured MUA, superior to GMail but also give the ability to link messages and searches in org-mode, so you can have an org file with clickable links to specific message or searches to build a report, exported on the fly, grabbed from a skeletor template. we can also have clickable links that actually execute elisp code to do things like change windows in our frame, export a document in a single click etc. we also have an emacs "widget library" to create "application" inside Emacs buffer. We have org-wiki that can be used as a real featured file-system interface, I'm actually in the process of "wiki-ifyning" my entire home since it does not "spam" a traditional filesystem access, does not rename files, move them etc, only place org-files where you want. Of course there is dired with also wdired mode. There it ix to paste buffers in a pastebin-like web services, there is md4rd to browse and post on reddit (even if super-buggy), there is org-agenda, there is proceps (top-like application inside Emacs), there are few package manager frontends and systemd one etc. Of course it's not a LispM but IMO for the user perspective it offer the best "poor man's" approximation of a LispM and can be used today for real usage, not only as a historical curiosity... While living on top of *nix OSes (mostly) it still offer LispM paradigm.
To me what the author describes is basically interactive development. We could do that in Smalltalk or Visual Basic. With both probably being similarly effective. Then there are text-level interfaces to talk to a running program with IDE integration. Smalltalk has an interactor for that. Working from an editor is interactive development, but the Read Eval Print Loop is the thing with the prompt I'm typing to. The thing which I can make the center of my development flow. The thing which has a stack of loops when I'm checking out my code. The thing where I can inspect my running program in terms of Lisp data. What makes a Lisp REPL really different for me, is when I can compute code and can work on the code as data level. When the barrier between code and data begins to fade away.
&gt; in light of 50 years of Unix this year It's 60 years already, isn't it? Time flies!
Sure. I guess my point is a REPL isn't enough: it's infinitely more useful to have good toolage too, and that even a nice REPL (I tried Emacs with Python once for a test and it was okay) has its limits.
Yeah, but a really good REPL has all that integrated: inspector, backtrace, stepper, source code lookup, error loops, ... having them as external displays (like the SLIME backtrace) is nice, but my first tool to look at a backtrace in various depths is the REPL itself.
Right, gotcha. I think CL has that covered, with its elaborate condition and debugger system (*cough* that I did not see in the Clojure demo *cough*) and introspective tools like INSPECT.
just to start simply -- syms isn't nil with this body ```lisp (macroexpand-1 '(defmacro/g! nif (expr pos zero neg) (list 'g!hello))) ```
https://letoverlambda.com/index.cl/errata
&gt; comes with an inspector so you don't have to traverse trees of objects by eye That reminds me; has anyone any good material on how to use Chez's inspector and not get crazy in the process?
Where is g!result bound in the last macro form? It gets unquoted three times I don't see where it's supposed to be unquoted from.
I did check the errata before posting but even with your hint I can't see where it's covered in there. I'm obviously missing/misreading something.
You'll need to read the defmacro/g! macro to understand that.
&gt; The original code, exactly as it appears in the book is [here](https://letoverlambda.com/lol-orig.lisp). But in most cases you will want the [production code](https://github.com/thephoeron/let-over-lambda/blob/master/let-over-lambda.lisp) maintained by the Phoeron. This is a slimmed down version with most of the interesting functions/macros as well as bug-fixes and small additional features. When browsing the text online, you will see the original content, exactly as printed. &gt; NOTE: If you are using SBCL, you must use the production code since it contains some important fixes related to how SBCL handles quasiquotes. It is the mention about production code.
Ah, thank you.
I did just that, as I had editwritten, but the *purpose* kind of eludes me.
defmacro/g! is an aid for writing macros, it automates the process of using gensyms. Just specify the symbol you want to hold a gensym in your macro by prefixing it with g! and defmacro/g! generates the boilerplate gensym code. Ultimately the g! symbols disappear during macro expansion.
That's an interesting thing but I kind of feel that in conjunction with quasiquote, this is mildly confusing. Of course this "scheme-ish" approach works well for Scheme, but if I already have one level of explicitness for generated names in form of the unquotes, I don't expect another thing about them being implicit (or vice versa).
This might be useful and the API seems simple. However, I want to know more about how it works.
So this is the weird half-bakery that people talk about when they criticize the book. I see! Don't put this in a production program unless you want to tarnish the reputation of Lisp.
I don't think Clojure should be called a Lisp. It has about as much in common with it as JavaScript has with C++.
I don't think Gnu Emacs can really do what you need. As mentioned below, dedicate Lisp machines from Lisp Machines and Symbolics were built to run Lisp, and Lisp provided a full operating environment Emacs began as Editing MACroS, a set of macros in the TECO language running on a DEC machine at MIT's AI lab. The version of TECO there implemented Control-R mode, which allowed interactive execution of TECO. An assortment of TECO macro packages had been written to make TECO easier to use. Richard M. Stallman and Guy Steele (mostly Stallman), collected them, regularized the syntax, and released the result as EMACS. It became what everyone at the AI Lab used, and Stallman commented later that he realized how successful he had been when *he* no longer remembered how to do stuff in TECO itself. TECO went away, and Stallman re-implemented Emacs in Lisp. It got the nod because RMS was also a major Lisp hacker, and in the "Lisp Machine Wars", Stallman would reverse engineer stuff done by Symbolics, who had gone commercial, and contribute the results to Lisp Machines. Gnu Emacs is a Lisp interpreter in a clever editor disguise. Most of Emacs is written in the Lisp dialect it implements (a variant of MacLisp, IIRC). But because it uses Lisp as the underlying language, it's possible to extend Emacs in all manner of ways, and folks did. You could use it to read and reply to email, read and reply to Usenet News, play games, interface with compilers and debuggers and become an IDE, and even use it as your shell. Old time Unix honchos on machines with Emacs installed would set up their userid to invoke Emacs when they logged in, and Emacs *became* their shell. They could run the underlying shell in a sub-shell communicating with Emacs and have full Emacs capabilities in talking to the underlying shell and manipulating the results returned. Emacs is a layered product running on top of the various OSes which it has been ported to, but nowhere near the integrated environment Lisp machines provided. the closest current equivalent to those environments I can think of is Nicklaus Wirth's Oberon, which was available in native implementations for various architectures, but hasn't been maintained in years. There are stand-alone Common Lisp implementations that may implement the features you mention and might be a better starting point. See [https://common-lisp.net/](https://common-lisp.net/) for pointers.
you can find frightful things in production code without lisp.
I think we cannot totally rule out the book because people are trying to use it's contents in production, I think the author never does any claims that the code is usable, as with many books the idea is to make you aware of some concepts and provide example code so the reader can see is not just empty words. Some of the code on other very recommended books has limitations too, or works just on some circumstances, the authors often times are not worried about all the corner cases and implementation details.
Well, that explains a lot about the problems I've been having writing macro generators for x. Maybe I'll just switch to clisp for the code generation.
&gt; But to me SICP is really all about computation, not mathematics. How do you make the distinction? I also thought that SICP tries to go away from having you think of the full machine, aka "under the covers".
Exactly. I am not sure why is advertising itself as a Lisp.
I guess I think very literally and mechanically, so for me it’s natural to think about how data is transferred throughout the machine.
`'(A (B C D E))` isn't "runtime", though.
symbols are interned, which gives them their package-ey qualities, at read-time, long before any possible "runtime" information you might have. whatever it is you're trying to do, probably the most obvious solution is to just put everything into the same package. if that's not an option, i suggest you take a step back and reconsider whatever it is you're trying to do - it sounds like your problem is beyond the scope of common lisp's packages
Right, sorry, may have left out some details while trying to not overload the question. That line getting evaluated at compile time is the issue, because the program doesn't know all the symbols that should be shadowed yet. I sense this is probably a structural issue more than me missing out on some function, but figured I'd check.
Shadowing is a concept that is only required when you have conflicts. A conflict can occur if you "use" a package into your package (i.e. make it visible in your package) and that package has the same-named symbol as one in your package. (Or at least one). A conflict can also occur if you "use" two packages that have some symbol names in common. Shadowing resolves clashes. Your package has a "shadow symbol" list. Names on this list are protected from clashing. Those symbols have to be present in your package. The shadowing list says "these symbols, present in this package, take precedence over any other symbols that are visible via use". If the clash is between two symbols from used packages (no such named symbol is present in your local package) you can use `:shadowing-import-from` in `defpackage` to bring in one of the two symbols into your package, and put it on the shadowing list. Clashes between your own package and a standard one like `common-lisp` should not happen if you `use` that package from the beginning. Clashes only occur for exported symbols. When you use a package, only its exported symbols are visible (and subject to potential clashes).
From a design perspective, maybe MY-PACKAGE shouldn't `use-package` CL-USER. Alternately, if you're trying to avoid using symbols from `common-lisp`, you might want to create another package that doesn't use `common-lisp`. &amp;#x200B; If you absolutely have to do shadowing, and you have to do it at runtime, you can try this: &amp;#x200B; (defun intern-locally (symbol) (shadow symbol) (intern (symbol-name symbol))) (defun recursive-mapcar (func list) (loop for item in list collect (if (listp item) (recursive-mapcar func item) (funcall func item)))) (recursive-mapcar #'intern-locally '(A (B C D E)))
But you would call JavaScript member of the Algol family wouldn't you? In the sense of Lisp v Algol, Clojure is a member of the Lisp family.
If you `use-package` on `cl-user`, it should have no effect (let alone cause conflicts), since `cl-user` ought not be exporting any symbols!
Clearly, this guy's `cl-user` is exporting symbols, otherwise how are they ending up in `my-package`?
If you want to learn Algol, you don't read *JavaScript for Dummies*. You can also consider Clojure a member of the Algol family, and observe that nobody cares. Being an Algol doesn't seem to help with marketing.
This is a very helpful but detailed explanation about packages. The second link is the source where I first saw the link. [https://www-fourier.ujf-grenoble.fr/\~sergerar/Papers/Packaging.pdf](https://www-fourier.ujf-grenoble.fr/~sergerar/Papers/Packaging.pdf) [https://www.reddit.com/r/Common\_Lisp/comments/a31atc/packages\_in\_common\_lisp\_a\_tutorial/](https://www.reddit.com/r/Common_Lisp/comments/a31atc/packages_in_common_lisp_a_tutorial/)
From the Author's page: Text written as lecture notes for a three hours talk given on September 11, 2001(!), a satellite talk of the EACA Meeting at Ezcaray (Spain). This paper (45p.) is a presentation of Common Lisp for Mathemacians, more exactly a presentation of the Common Lisp Object System (= CLOS) which is now the main constituent of the language achitecture. The nature of this paper is didactic, with simple examples that can be repeated on any ANSI Common Lisp environment. Sections: Introduction. Common Lisp Object System. What typing is. CLOS and mathematical structures. CLOS and the Kenzo program.
[There's also this.](http://www.flownet.com/gat/packages.pdf)
&gt; derived from a macro elsewhere in the code If a macro is *interning* symbols that must end up in a specific package, try to use `shadow` instead of `intern`
Note: I realised this link was already posted by lispm a while ago. Sorry for the cross post. Moderators, please feel free to remove it if you wish.
FYI, `shadow` interns.
I came across this post by Christophe Rhodes that specifically discusses this exact case (the LoL g! macro) with regards to SBCL: http://christophe.rhodes.io/notes/blog/posts/2014/naive_vs_proper_code-walking/ I came across this for another reason -- I've been wanting to write something like parenscript / inline lisp code for other language and was hoping to write a macro that: * Macroexpand-ed code down to just lisp special forms * Transformed those forms to another language I.e., inline Java-bytecode creation, or compile down to &lt;your favourite&gt; language. * Handle all FFI calling between CL and the target language However, of course, SBCL and CCL on macroexpand-all have their own implementation-specific symbols (sb-impl::comma-expr/sb-impl::comma in this particular case). So, a follow on question -- is there anything like sb-walker:walk-form that is (more) portable? I'm only curious how often this type of code walker is necessary (The iterate library includes its own code walker for example). I couldn't find anything in the CCL manual that seemed to be similar (though CCL has macroexpand-all but it will include CCL implementation details).
Heh. I was *just* going to build the 1.5.2...
Clojure has some really nice debugging and inspection tools provided by cider.
I'm confused on what happens with F and the AB stuff
They’re recursive calls to the very function you’re defining.
Original: &amp;#x200B; [http://clocc.sourceforge.net/dist/port.html](http://clocc.sourceforge.net/dist/port.html)
\`string-downcase\`
F is a function that replaces an old value "A" with a new value "B". Recursively. F calls itself repeatedly with the tail of the list. Eventually the list runs out until there is no tail left. Might be a little easier to follow if with descriptive names like this: (defun replace (lst old new) (cond ;; if base case, stop recursion. ((null lst) nil) ;; else if lst is an atom. "listify" it. So append will work later ((atom lst) (list lst)) ;; else if head is null, recur on the rest of lst ((null (first lst)) (replace (rest lst) old new)) ;; else if head is not atom. (it must be sub-list) ((not (atom (first lst))) ;; then append recursively computed results of first of lst and rest of lst. (append (replace (first lst) old new) (replace (rest lst) old new))) ;; else if head = old ((eql (first lst) old) ;; then construct a new list, with NEW value for head, OLD will be lost. (cons new (replace (rest lst) old new))) ;; else. Did not match old pattern. Make a list preserving the head (t (cons (first lst) (replace (rest lst) old new))))) To really understand it, you may want to read the book "The little Schemer". It drills recursion into you. Many books just throw an example at you and expect you to get it. For me little schemer was the only thing that worked.
Thank you.
Thanks that's an interesting, all be it daunting, read.
Do you *want* OP to die from legacy UNIX madness? I tried to set up that emulator for quite a while. I just couldn't get the file system to work with the emulator. Trying to use that emulator on modern GNU/Linux systems is just pure torture. Or maybe I was very unlucky. I don't know.
&gt; F is a function that replaces an old value "A" with a new value "B". Not only that, it *also* removes NILs from the list, apparently, and flattens a nested list into a flat one. (Seems kind of important to me at least.)
There should be no difference to any other code, for instance JavaScript produce by babel is copyrighted the same as original code. I have script in bash that generates CSS file and it also have the same license and my main code. [https://github.com/jcubic/jquery.terminal/blob/master/css/emoji.css](https://github.com/jcubic/jquery.terminal/blob/master/css/emoji.css) here I've forge to include the license but it should be, in my case, MIT. &amp;#x200B; With lisp there should be no difference, but you decide what license to put on source file and which on generated code, if you want to put different license on generated and source code it's fine, you decide it's your code. Also it's good idea to write the comment that the code was generated and by what program.
CLX itself is MIT-licensed so you should not have any issues with releasing CLX-derivative code under MIT as well, or any other license that fulfills MIT's requirements, such as GPL.
I’m on mobile and don’t have references around but reuseaddr is a flag you can set on a socket to allow its address/port combination to be reused right away. Without it, there’s a period of time where the OS will hold onto it and not let you rebind to it. I was having some trouble with a similar thing a week ago. When I’m back at my desktop I’ll have a closer look at my notes and see if there’s something useful for you.
The copyright owner can only be one person. A machine (including a generator) cannot claim copyright. Only intellectual creations, i.e. man-made works, can be protected by copyright. It is also very questionable whether the requirements of copyright for individuality in machine-generated works are fulfilled at all.
Add the license explicitly to the code you generated.
So the copyright/licence of the generated code should be at the purview of the person who writes the generator? If I write a macro, is the generated code copyright me since it only exists as a product.of.my.work? I'd say it's not a translation since clx does things differently than both xcb and xlib. but even if, a protocol, and an implementation of a protocol are two.separate things when it.comes to copyright and.licences, no?
this is not derived from clx, it's generating extensions for clx using the xml protocol descriptions from the xcb project.
That's already done, just wondering if its legit to change it from the code generator.
I'm hoping thats the case.
https://github.com/stapelberg/libxcb/blob/master/COPYING Doesn't seem to change much - it still seems to be a permissive license from a brief glance.
Like with any code transformer (or any data processing program, for that matter), it's unlikely that you'd be able to "infect" the generated code with your ownership. If you compile your C program with GCC, does it become the property of Richard Stallman? I don't think so.
If the target code does not license the code, it's your code, if it based on your work on the source side. Check the docs of the code generator to be sure. All compilers generate code (intermediate and binary), imagine when your compiled code would be licensed differently from your source.
No, that's not the right conclusion. If it's a translator then the translation is a derived work of the original. If it's a (true) generator then the generated work is not a derived work and in many countries not protected by copyright. See e.g. [https://www.certuslegal.com.au/intellectual-property-law/computer-generated-source-code-not-protected-by-copyright/](https://www.certuslegal.com.au/intellectual-property-law/computer-generated-source-code-not-protected-by-copyright/).
Wow you are totally right. After waiting a few minutes, I can restart the function without a problem. Weird that I didn't find this behavior mentioned anywhere, I can't be the only noob trying the Land of Lisp examples with usocket/sbcl. I have almost no knowledge about socket programming so I hope you don't mind me asking, in what scenario would it be beneficent not to be able to reuse a socket even after closing it? Thanks for your reply!
Here's the FSF's take on the question: https://www.gnu.org/licenses/gpl-faq.html#GPLOutput
&gt; *in what scenario would it be beneficent not to be able to reuse a socket even after closing it?* In no scenario. It's just a piece of traditional Unix networking idiocy that doesn't seem to want to go away. Every shred of documentation I've seen that tried to explain it didn't hold water. The idea is that when a server application is killed and restarted, the remote peers are still trying to communicate with its endpoint, and that could cause some problems. However, all those hypotheses are false. TCP connections are identified by *both* endpoints: the remote and local address. The local TCP stack knows when it's getting datagrams from the old clients before the local endpoint was was torn-down and re-created, because those old clients are using old remote IP addresses and port numbers that are not known to the new socket. For instance, some documentation says that `SO_REUSEADDR` allows a socket to be bound even when the endpoint is in the `TIME_WAIT` state. But that is wrong: the server endpoint **as a whole** is never in a `TIME_WAIT` state: it is specific connections that are in a `TIME_WAIT` state. The `TIME_WAIT` state happens regularly for connections when and endpoint is in service, even as that same endpoint continues to accept new connections. I suspect that what really happened is that someone made their coding easier in the following way: when a server socket was torn down, if any connections associated with it were in the `TIME_WAIT` state, then that endpoint was kept around in the kernel. Since two endpoints can't share the same local address, that prevented a new endpoint from being set up until the old one timed out. Then someone found this inconvenient and instead of fixing the code to make it smarter, they put in some hack whose ramifications they didn't understand properly, and connected it to an option flag (so it's the user's fault for using the flag if something goes wrong). Hand-waving documentation was written and that was that. I think that today's stacks handle the resurrection of the endpoint just fine; just that flag sticks around like an "onion in the varnish".
It seems to focus on Windows. Does it support other operating systems? The advantage over SBCL doesn't seem clear. Why would you pay for this?
i'm the one who has written the code generator from the intermediate format which I produced from the xml description of the Xprotocol.
Meh, a closed-source Windows-only Lisp with its main scope of usage being "Artificial intelligence". I bet the guys over at TensorFlow are shaking right now.
I've never heard of it before and never used it, but apparently it's $15 and can make standalone Windows EXE and DLLs
I've never heard of it before and not used it much (except dabbling with a GUI program just now), but yeah just Windows. Apparently it's trivial to make DLL and EXE binaries and extend via COM though. Also, it's $15 apparently.
Really? It seems to date back to the days of Windows 3.1, for those who know that there was once a Windows 3.1 I mean Pentium 300Mhz, 32Mb RAM? Demo version has a number of restrictions in comparison with the full version. But it is not reflected in evaluating the compiler for studying purposes at all. Demo version has these restrictions: 1. Does not allow to build DLL files 2. Does not allow to create callback-functions (such as Window procedure in GUI application ) 3.Any program compiled by demo version, will display the message, informing that it has been compiled by BEE Lisp demo version on startup. In all the rest, demo version is similar to full version of BEE Lisp. Full version can be retrieved in "Buy BEE Lisp" section, or by clicking "Buy" button in the top right area of the site. System requirements: Pentium® 300 MHz CPU equipped PC 32 MB of RAM (64 MB is recommended). 24 MB of free space on hard disk. Microsoft® Windows 98, Microsoft® Windows Millenium Edition, Microsoft® Windows 2000, Microsoft® Windows XP, or Microsoft® Windows Vista. Unessentially: Internet connection speed 56 K or above (for product registration). Is it worth talking about?
it's unclear how linking/combined work applies to the way lisp systems are used.
Windows API is for masochists!! Do you indulge in spot of self-flagellation every now and then?
this seems to be based off what fsf says about the gpl which emphasizes user entered data. However, there is no user entered data here. There is the xml protocol description licenced under MIT. My parser to intermediate format and generator to CLX compatible code, and the possibility of other programmers writing their own code generators. The gpl seems to allow me to licence the parser and generator under gpl, licence the clx generated code under mit, but it is unclear whether the gpl will infect the other programmers generators since lisp isnt linked the way C code is.
&gt; Out of desperation I thought about using Lisp as some kind of server while the desktop app would be the front end. That means making a full circle and almost coming back to a web application. I do not like the idea of web app because of it's limitations. I am not looking for electron. I do not like the way it handles right click. Take a look at this project - [Extensionless PHP Graphic User Interface library](https://github.com/gabrielrcouto/php-gui). It uses XMP-RPC to drive the Lazarus widgetset which is cross platform. I don't think it will be that difficult to get it working with Lisp unless your program is truly GUI intensive. &gt; I am willing to consider OpenGL or CFFI based solutions but I need example showing that it works and I can build an executable that works. [OpenWL/DL - two foundation libraries for building a cross-platform GUI with non-C++ languages - Nim forum](https://forum.nim-lang.org/t/4783) (It is not a Nim library, but a good discussion developed around its introduction) Which ever path you choose you will probably have to delve down into some low-level plumbing to even out some kinks.
if the c code and the compiler together make a greater work, then yes. If another programmer uses some of the code in their own generator, does it then infect their generator, which I would prefer them to have total control over? It's unclear, at least to me and some others, how linking and derivative works apply in regards to lisp code.
this is not about the xml description, it is about my code and anything that uses it afterwards.
Your situation seems to similar to the guile-xcb bindings [https://github.com/mwitmer/guile-xcb](https://github.com/mwitmer/guile-xcb) They licensed it GPLv3. It seems reasonable that generating code from specs (even if said specs are machine readable) doesn't impose any license restrictions
6pm UTC happens when this comment is 18 hours and 49 minutes old. You can find the live countdown here: https://countle.com/uvf5FZfWV --- I'm a bot, if you want to send feedback, please comment below or send a PM.
I’m looking forward to seeing what all the buzz is about!
though in their case their parser and working implementation are licenced as a unit. The intermediate format isnt actual working code, and the clx output doesnt work on its own either, it requires clx. it seems the way they have it, writing a window manager using their bindings would infect the windowmanager, something I wouldnt want. Perhaps the point is moot since probably nobody will use it, and the code is unneccesarily inconsistent.(I like to use several different techniques at the same time to see what works best or to learn new things. e.g. there's a lot of use of obscure format directives to produce the working clx code instead of macros, which are used in the parsing.)
Lol I have no idea when that would be beneficial. I’ve been doing socket programming in various languages for &gt;20 years now, and its one of those things that I get bit by every year or so. There’s also an SO_REUSEPORT that some operating systems require as well, but I don’t think usocket exposes that. Maybe under the hood :reuse-addr covers both.
&gt;I've written a system that parses the xml for X into an 'intermediate' format and a generator to massage it into a format suitable for CLX. I'm not sure whether I fully understand what you actually do. You say that you re-use the interface descriptions of the XCB project which are available in XML format under MIT to create an equivalent representation in another format. That's a translation from my point of view, a derived work of the XML representation; but since the original is MIT licensed you can essentially do with it what you want. Then you use this to generate a layer on top of CLX which I assume is a Lisp version of the XCB API using CLX to implement it; or the other way round: generating an alternative implementation for the CLX API. So your work you want to license under GPL is the generator, which uses your "intermediate format" as input and generates some code as output. I don't see a reason why you not should be able to do this. Your generator uses the input but is not a derived work of the input. Whether or in what degree the output of the generator is protected by copyright is disputable. But since you are the author of the generator you can clearly state that the generator itself is GPL licensed and whatever is generated can be used under whatever license your users prefer. But watch out if your generator pastes code into the generated result which is not your intellectual property this could affect the license of the generated code; in that case it depends on the size, the creative value and the license of the pasted code. Just small fragments out of context have little chance of beeing protected by copyright laws. But this is just guessing from distance, not a detailed and final analysis.
&gt;does it become the property of Richard Stallman? Surely not, but in some countries he would at least have a stake in it depending on what and how much of his creative work is reflected in the generated result.
the x protocol and implementations of that protocol are two separate things. The xml description of the protocol is not xcb, it describes what goes over the wire, not necessarily how it got there or what is done with it afterwards.. clx implements the protocol with its own quirks, e.g. xcb was created to get around the synchronous nature of xlib while CLX was asynchronous from the get go. I'm pretty certain as the author I can licence the generated code under any licence I choose for the clx X extensions. I'm just worried about other users who might use some of the tools and intermediate format to say make a direct copy of the xcb implementation while not having their use of the tools in creating their own implementation generator be poisoned by the gpl. All of what I see with the gpl seems to apply to C code and how linking/greater works/derivitives work there, but it's not clear, to me, how it works with lisp. With an image based lisp, what is considered linking? Can you in fact use any GPL code in an image without poisoning everything? If you write a window manager using an x implementation licenced under gpl does that mean your wm has to be gpl? It would seem so under C. But I'm probably over thinking it, I doubt anyone will use it, though I wanted the gpl so I could benefit from any fixes people would come up with. lol, maybe I'll just go MIT, the GPL licence is roughly the same size as all the code.
for example the guile parser/bindings/implementation are gpl and it seems anything that touches them is gpl as well.
Your clarifications confirm my assumptions. &gt;but it's not clear, to me, how it works with lisp. Works the same way as with other technologies. &gt;Can you in fact use any GPL code in an image without poisoning everything? Don't mix up proximity with linking. A Lisp image can also be seen as a storage medium. Just because two programs are present in the same image doesn't mean that one is a "work based on the" other. But for what reason should your generator be in the same image as the generated code?
my generator wouldnt. It's just about someone else creating a derivative or greater work by using the gpl code to produce an implementation and how that inplementation would or would not contaminate other code. Your explanation of image base stuff works fine when the programs are not interelated, but the case of a windowmanager using a protocol implementation is a totally different story, e.g. stumpwm doesnt exist as a functional piece of software without the clx implementation of the protocol.
Russian. Funny requirements. Also, such software means a lot of work for \~$15. Could it be simply code stolen from Corman Lisp with a new GUI?
This is a tricky question; there is no one-size-fits-all answer. Consider the parser generator GNU Bison. The parser that it generates contains considerable "boilerplate" material from a "parser skeleton". If a human examines a generated parser side by side with the skeleton, it's evident that large portions of the parser coincide with large portions of the skeleton. For that reason, a "Bison Exception" is featured in the program's license: &gt; **Bison Exception** &gt; &gt; As a special exception, you may create a larger work that contains part or all of the Bison parser skeleton and distribute that work under terms of your choice, so long as that work isn't itself a parser generator using the skeleton or a modified version thereof as a parser skeleton. Alternatively, if you modify or redistribute the parser skeleton itself, you may (at your option) remove this special exception, which will cause the skeleton and the resulting Bison output files to be licensed under the GNU General Public License without this special exception. GCC generates code that requires some run-time support. There is an [exception](https://www.gnu.org/licenses/gcc-exception-3.1.en.html) for that. In general, translated code inherits the license of the source code. When was the last time you saw a proprietary software license that attributed ownership to the compiler they used, rather than to the software house that wrote the code? If your translator has some features that cast doubt, you can spell it out in the license. If your translator adds significant boiler-plate, you can have something similar to the Bison Exception which allows free use of those pieces in translated works, but doesn't allow cannibalization of those pieces into competing translators that have stricter/incompatible licenses.
Clojure is no Lisp.
Here's part 1, if you want to check it out before tonight! [https://www.youtube.com/watch?v=nFwh-R1jVaY&amp;t=14s](https://www.youtube.com/watch?v=nFwh-R1jVaY&amp;t=14s) See you later baggers - I'm actually somewhere with a good connection for once!
The highlighted parts are recursive calls. A function can call itself. That is called recursion. In mathematics, we have recursive definitions: for instance N! is 1 if N is 0 or 1. Otherwise it is N * (N - 1)! Recursion makes definitions compact, and makes them easy to prove correct. Recursion is not always easy to understand; it requires getting used to. If you already know what the function does, then it's easy to read recursive calls. The problem arises when you don't know what the function does! The recursive calls are asking you to understand the function in order to understand the function. The trick to reading recursive functions is to skip the recursive cases at first, and look at the non-recursive ones. Understand all of them. Just like with N! we first understand that 0! is 1 and 1! is 1. Write out input-output example pairs for all these cases. We have only one non-recursive case: the case `((ATOM L) (LIST L))`? This tells us that the call `(F 1 10 20)` will yield `(1)`. Thus, if the input to the function isn't a list, it is "listified". Then, examine at the most general recursive case: the fallback case. Understand it, and write an input-output example, or several.In this function, that is the last case `(T (CONS (CAR L) (F (CDR L) A B))`. This tells us that unless special conditions occur that are handled in other ways, the expression `(F L A B)` is equivalent to consing the first element of list `L` to the result of `(F (CDR L) A B)`. So the basic recursive/inductive structure of `F`. From this we know that if none of the special conditions apply at all, the output of `(F L A B)` will simply be a copy of the list `L`: a new list made of the elements of `L` in the same order. This gives us the intuition that `F` is basically a list-copying routine, when none of the special conditions are encountered. For instance, given `(F '(1 2 3) 10 20)`, we might expect the output `(1 2 3)`. (Unless those conditions do apply to some parts of the input.) Then consider the other recursive cases one by one, starting with the one which has the simplest result expression. **Invent examples for all the cases and write them out.** Examples are input-output pairs. The simplest result expression is found in `((NULL (CAR L)) (F (CDR L) A B))`. This one is simplest because it calls `F` recursively, and just returns that result without doing anything to it. It is saying that if the list starts with the item `NIL`, then that item is simply dropped: `F` is applied to the rest of the list (and `A` and `B`), and that is returned. This tells us that `(F '(NIL 2 3) 10 20)` means exactly the same thing as `(F '(2 3) 10 20)` and there we have is our input-output example pair. The object `NIL` is the same thing as the empty list `()`. So this case has the effect of "squeezing out" empty sublists. Next, let's look at the second most complicated remaining recursive case: `((EQL (CAR L) A) (CONS B (F (CDR L) A B))`. This says that if the fist item of `L` is equivalent to `A` (same object, or same number), then `F` is applied to the rest of the list, like in the fallback case, but instead of the first item of `L` being consed on front, the value of `B` is consed. In other words, an `A` to `B` substitution is applied to the first item, which is combined with `F` being applied to the rest of the list. An example input-output pair for this might be `(F '(1 2 3) 1 100)` yielding `(100 2 3)`. Lastly, there is `((NOT (ATOM (CAR L))) (APPEND (F (CAR L) A B) (F (CDR L) A B)))`. The expression `(NOT (ATOM X))` means exactly the same thing as `(CONSP X)`: this is testing that `(CAR L)` is a `CONS` cell. This case says that if the first element of `L` is a list, then `F` is applied to the rest of the list, like in all the recursive cases. `F` is also applied to the first element, and the result of that is prepended to the processed rest. An example case for this might be: `(F '((1 2 3) 4 5 6) 10 20)` which yields `(1 2 3 4 5 6)`, because '(1 2 3) which is the `CAR` of `((1 2 3) 4 5 6)` is `APPEND`-ed with `(4 5 6), the `CDR`. Furthermore, a more complex input case like `(F '(((1 2) 3) 4) 10 20)` will still flatten everything out to `(1 2 3 4)`. Here, `F` is first called on the `CAR` which is `((1 2) 3)`. That will yield `(1 2 3)`, which then simplifies the problem to `(F '((1 2 3) 4) 10 20)`. So from all this we understand that this function combines two features: it flattens the input list `L`, and at the same time it substitutes occurrences of the `A` value with `B`.
If the different "components" in the image are linked (i.e. that one needs the code of the other to be able to run) then it's obviously "work based on the" other component. But if there is no such link and you just call both independently by name via REPL then it's just an "aggregate". There are technical means to detect links.
https://github.com/lmj/global-vars might be useful here.
 (defun bar () (let ((x (load-time-value (list (random 400))))) (car x)))
let over lambda over let over lamdba. You can do it all using closures.
Why don't you want to use the obvious and natural solution of a closure?
As x has lexical scope not only will x not survive an invocation of bar, the name x won't even survive compilation.
What are you talking about?
I'm talking about the fact you seem to have posted some random lisp code that has nothing to do with the question.
Is that really so?
Thanks, I forgot about that one. One concern I didn't mention is - how such form will behave in context of image dumping? If I compile and load all my code, and then dump it as image (for distribution as an executable), will such forms be expanded to take space in the dumped image file? Since I'm planning to pre-allocating large vectors, I'd like to avoid that.
Yes. As I explained in my initial response.
:initform allows you to provide a form, which could be a "whole" lisp program, not just simple static value, like 17.
From what I understand, this actually does solve the (more important) half of my problem - there will be a list of 400 random elements allocated once, and available for further invocations of the function in a variable. The code doesn't allow setting `X` itself and having the new value survive to the next call, but that's less important for me. Whether static variable's name survives compilation is immaterial, what matters is that code can access data that was initialized only once and then retained for further invocations.
They will end up in the image, as it's done at fasl load time. But you can always add indirection: (defun bar () (let ((x (load-time-value (list nil)))) (unless (car x) (setf (car x) (make-array 1000))) ...)) And that indirection is no slower than using symbol-plists.
Thanks. This will be helpful in other areas of my code as well.
¯\_(ツ)_/¯
&gt; Why don't you want to use a closure? Because I'd like to be able to make use of such static variables deep inside a function, without having to alter function definition. It's a code style issue - using a static variable is a "local" abstraction, it shouldn't pollute everything upstream from it. (There was also a remark in Let Over Lambda that closures cannot be compiled, which I might be misunderstanding.) &gt; as well as trampling over the expectations of a with- style macro What are the expectations and how are they trampled? My example `with-static-variable*` establishes a scope within which you can access a static variable.
That looks like it may work, and feels better than putting stuff in plist of a gensym. Thanks!
closures can't be compiled, but if you compile the function that creates the closure the closures it creates will also be compiled.
[with-c-syntax](https://github.com/y2q-actionman/with-c-syntax) (a joke macro) treats `static` as `DEFVAR` with a `GENSYM` name, as you said. If you write like below: #{ int func () { static int y = 0; return ++y; } }# Its expansion contains a form like this: (DEFUN FUNC () (PROGN (DEFVAR #:|static-var-Y-storage-735| 0 "generated by with-c-syntax, for static.") (LOCALLY (DECLARE (SPECIAL #:|static-var-Y-storage-735|)) (PROGN (PROGN (SYMBOL-MACROLET ((Y #:|static-var-Y-storage-735|)) (BLOCK NIL (TAGBODY (RETURN (INCF Y))))))))))
&gt; You can do that with closures. How can I do that within the macro? Given code like this: (defun some-processing-fun () (many (levels (of (nesting (with-static-variable* (entities (make-array #.+max-entities+ :element-type 'entity-id)) (some-code-that-fills-array-with-data entities) (loop for entity across entities do (some processing))) ...))))) I can't magically make my macro hoist a lexical closure all the way to above `DEFUN`. The whole point of a macro is to avoid having to manually change the whole defun to acomodate it. &gt; closures can't be compiled directly, but if you compile the function that creates the closure the closures it creates will also be compiled. What about closures created around top-level `DEFUN` forms? &gt; Using setf creates a "global" doesn't it? Which means you've changed the "global" environment. So your with- has side-effects beyond its scope. Which is not something I'd generally expect a "with-" macro to do. There is no way of creating "static variables" without changing the global environment. That said, proposed implementation stores static data in a plist of a gensym, so there's no way (that I know of) to access it from outside of the code inside the `with-` block. That, IMO, maintains expected semantics. Compare with e.g. `WITH-OPEN-FILE`, which also can change global state (by creating a file).
Great minds think alike :). Also thanks, this macro made me chuckle.
ah, there's my concern. I want people to use the parts to make their own generators that they can licence as they wish. I would just like for my project to receive code additions for the things I dont need at the moment and havent implemented, e.g docs, I just throw those away, who needs documentation anyways?
Could you elaborate - where are you entering it? ``` &gt;&gt; (defun eplus (x y) (+ x y) EPLUS &gt;&gt; (eplus 4 5) 9 ``` I assume you are new to lisp - where are you learning it from? What is your setup? (In my case, theory was easy to be found. Setting up was a pain; and wasn't introduced to lisp communities. Don't want others to go through the same process.)
Works here in abcl, sbcl and ccl. &amp;#x200B; What error do you get?
Firstly, thanks for the downvote. What you're trying to do basically boils down to "I want to do something I can't really define but I want to do it in a really stupid way and I don't want to use any of the straight forward mechanisms and I can't make my bodges work so how do I make them work without doing anything sensible." Which is really boring. So I'll leave you to it.
&gt; *I want to store data within a function that will be initialized once and preserved between invocations of that function* http://clhs.lisp.se/Body/s_ld_tim.htm Anything else?
I didn't downvote you.
&gt; Could it be simply code stolen from Corman Lisp with a new GUI? [Corman Lisp from ten years ago?](https://web.archive.org/web/20091215113126/http://www.beelisp.com/)
Thank you for your laughing, and this topic reminds me `load-time-value`. I'll rewrite the macro with it.
It's not Common Lisp, it's a custom Lisp, apparently weakly typed, and with a fairly small number of functions. Documentation: http://www.beelisp.com/online-help/default.htm &gt;BEE Lisp is an acronym for Balabanov Eugene Embeddable Lisp. It is a light-weight but powerfull lisp compiler designed for software developers who tends to focus on the task rather than details of implementation in their daily life. Author: Balabanov Eugene https://www.linkedin.com/in/eugenebalabanov?originalSubdomain=de From the LinkedIn profile: &gt;Author of BEE Lisp N/A (My own project) Jan 2007 - Dec 2011 &gt;BEE Lisp compiler. A compiler for Lisp langauge, used to be my diploma project, turned later into commercial shareware software. Currently put on hold, because I put my efforts to SHADE Sandbox. Project site: www.beelisp.com
&gt;Could it be simply code stolen from Corman Lisp with a new GUI? Can't be, see my post above. It's a different Lisp and a diploma project so couldn't be a copy. Corman CL is light years beyond.
Since symbols are namespaced, I just use a globally special variable that isn't exported. Prefix it with the function-name to make it more clear: ``` (defvar *foo-counter* 0) (defun foo () (incf *foo-counter*) ...) ```
You may want to check these repos for SBCL code related to LoL: - https://github.com/kofno/land-of-lisp - https://github.com/drunkfoxx/Land-of-Lisp
The complications of trying to set up a real emulator is what I was really trying to avoid, because I've heard similar stories. It seems like though from consensus that using the emulator is the 'right way' to achieve what I'm aiming for.
I was already familiar with a lot of this history, but thank you for taking the time to type it out for me! &amp;#x200B; &gt;There are stand-alone Common Lisp implementations that may implement the features you mention and might be a better starting point. See [https://common-lisp.net/](https://common-lisp.net/) for pointers. This may end up being a good middle ground avenue for trying to demonstrate some of what I was wanting to demonstrate. I'm already familiar with CL and have SLIME all set up and everything. Thanks for that piece of advice.
Elsewhere in this thread it was mentioned that I could try Genera, and a reply to \*that\* comment indicated that the effort involved in trying to get the Genera emulator is non-trivial (apparently never got it to work). &amp;#x200B; Is there a similar effort/time complexity in trying to run CADR vs Genera?
I didn't realize that was part of the question.
Right, I'm aware that Emacs doesn't go "all the way down" as a Lisp machine would, but it is \*much\* easier to set up Emacs and hopefully get most of the way there. A second goal, which I should have been better about making explicit, is that I also want it to be easy for others to get a taste of some of the things I'd demonstrate on their own. That said, I am getting the general impression that doing this 'right' entails getting into the weeds of setting up an emulator.
&gt; Emacs doesn't go "all the way down" as a Lisp machine would It also does not go into left and right. The GNU Emacs look&amp;feel is totally different from any Lisp Machine user experience.
The CADR is significantly easier because it requires much less setup (you have to set up NFS for the Genera emulator to netboot and you need to patch Genera or use a really old Linux VM for graphics to work).
its designed to allow time for the remote side to properly shutdown, as the least error prone way to shut down communications between a client and a server is to tell the client to shut the socket down. the "risk" is that without confirmation of remote side shutdown, the local side may end up seeing old data that may somehow be passed through to the new client that isn't expecting it.
Does it offer anything over ClojureScript?
Seems to be a simple lisp, so I doubt (but haven't looked) if it offers nearly the same library as clojurescript.
Actually on dumping an image the big array will be dumped as well if `bar` was ever called before the dump, since you're mutating that list
That makes a lot of sense! Thanks! I’ve always wondered!
Might be good to ask /r/racket as well
Did you see this? [https://docs.racket-lang.org/quick/index.html](https://docs.racket-lang.org/quick/index.html) Also if you don't know scheme already learning it would help
There are at least two sites, running in production: &amp;#x200B; * [http://skazorama.ru](http://skazorama.ru) * [https://ultralisp.org](https://ultralisp.org) &amp;#x200B; What problem do you have? We can discuss it at [the Gitter chat](https://gitter.im/40ants/weblocks) or in the GitHub issue if it is a bug.
Thanks but I asked for anything other than the documentation.
Yeah I was just making sure you're aware of this. The racket documentation is really quite good IMO so I thought maybe just a gentle introduction into it would help. But if you really don't want to touch the racket documentation learn scheme. [https://web-artanis.com/scheme.html](https://web-artanis.com/scheme.html)
["How to Design Programs"](https://htdp.org/).
The idea is not to call it before dumping.
I am learning Common Lisp, right now reading Touretzky's excellent Gentle Introduction. I like to study Lisp code, and this seemed a good one to study.
Not sure how in ClojureScript you can interact with JavaScript, this is not very promising [https://clojurescript.org/reference/javascript-api](https://clojurescript.org/reference/javascript-api) in LIPS you can easily call any javascript function or method on any object. The LIPS demo show how to use with HyperApp (that's JSX based) you probably can do the same with Preact or React.js not sure if something like this is even possible with ClojureScript.
Thanks for the reccomendation! I need to read more code!
Realm of Racket
Clojurescript gives full interaction with Javascript, but you're right that sometimes it's unintuitive; this is largely due to the fact that Clojurescript relies heavily on Google Closure, which much public JS code is not compatible with. So for example, in cljs you can't just console.log a Clojure map, nor can you println a javascript object; you have to do some translation. So it makes sense if one of LIPS selling points is that it is easier this way. On the other hand, the optimization, library support, and full-language experience that Clojurescript gains for these prices is more than sufficient for me...
This looks is nice, but I bet programming it in Lisp would have made it much easier. The single example is quite shows enough of the declarative nature of it.
The Infocom games were programmed in a lisp derivative called ZIP, itself derived from MIT's [MDL](https://en.wikipedia.org/wiki/MDL_\(programming_language\)). You can even peruse a version of the [Zork I sources](https://github.com/historicalsource/zork1) now.
Cool they also have ["The hitchhiker's guide to the Galaxy"](https://github.com/historicalsource/hitchhikersguide)
See also: [http://www.cs.cmu.edu/Groups/AI/util/lang/lisp/code/tools/src\_cmp/mkant/sc.cl](http://www.cs.cmu.edu/Groups/AI/util/lang/lisp/code/tools/src_cmp/mkant/sc.cl)
I've heard of Fennel before. Did they fix... &gt; (quote hello) Compile error in 'hello' unknown:3: symbols may only be used at compile time &gt; (quote (hello world)) Compile error in 'hello' unknown:3: lists may only be used at compile time ...Oh. Um, these are Lisps? Did I forget something?
Aww, not again. We are, #lispgames, quite an inclusive community :) Also Fennel mentioned as an "Exo-Lisp" in implementation section of r/lisp sidebar.
Oh no, a Lisp has to do list (and symbol) processing. There's like, no Lisps that do that, how will we ever survive?
I never worked with Fennel before personally, but according to messages above it can do symbols and the lists processing no probs just not in runtime :)
Finally got time to look at this again, this advice seems to have solved it. I just made the package not use :cl, hadn't even thought of doing that. Though I then did have to explicitly call (cl:defun ...) etc.
Thanks!
This is just a kind of Lisp implementation with some special constructs. David Betz developed a bunch of these Lisps in C, for example XLisp and XScheme. An early version of David's XLISP was used a the Lisp for AutoCAD: Autolisp. See also XLISPStat, a statistics language and IDE based on XLISP. At some point in time David's compact Lisp implementations written in C were used in a bunch of applications, often as an embedded scripting engine.
Thanks, I didn't know about the XLisp and Xscheme story, I had heard about ZIL but but this is a bit different than that, if I am not mistaken, I think it won't read ZIL files but the adv files. I haven't looked at the code, but it seems to me is just a Lispy DSL written in C more recently.
Just answering my own doubt, I just looked at the code and it says `* advcom.h - adventure compiler definitions *//* Copyright (c) 1993, by David Michael Betz All rights reserved*/` so it is the old compiler.
And XLisp is the base of [Nyquist](https://en.wikipedia.org/wiki/Nyquist_\(programming_language\)), for sound synthesis.
There's Dunnet, in Emacs Lisp. Not very interesting code as it happens though. Pretty ad-hoc. I think Inform and TADS have raised the bar beyond that sort of code.
Well, that's pretty useless for a Lisp then considering you usually want to process those at runtime.
To be honest the biggest problem I had was that the tutorial was not working. [The quickstart page][http://40ants.com/weblocks/quickstart.html] It seems to be inconsistent with current package. The first link you gave was broken. The second one should be a good start point... Thank you!
There are convenience wrappers to retain the closure compiler advantages while generalizing [performant interop](https://github.com/appliedsciencestudio/js-interop/blob/master/README.md)
Method, property, field access is there for cljs via the dot macro and host calls to via the js namespace, and finally the goog object libs. Invocation, alteration, manipulation of host js stuff is pretty trivial overall. I don't see much difference on the interop front (re limitations). I regularly consume and use js libs in this fashion when doing cljs stuff. Some [intrrop libs](https://github.com/appliedsciencestudio/js-interop/blob/master/README.md) smooth the experience, particularly if you're doing advanced compilation.
I can already hear the anger from r/lispmemes.
Please don't do that. Make it stop. We...don't want any more toy interpreters. This can't even process lists or symbols. Your title isn't funny. *JUST STOP WITH THE GODFUCKINGDAMN SHITTY INTERPRETERS THAT YOU CALL LISPS, THEY ARE NOT RELEVANT AND GIVE LISP A BAD NAME THANKS HAVE A GOOD DAY*
Good. Hopefully you'll grow some taste some day.
It's still got linear tables, I don't really see the issue.
Piss off. Those aren't lists.
I really like the feel of `this is my mech`. DMOMD was also cool.
Uuuhm, ok? Rude.
'Tis the traditional voice for talking to people who pretend to know what constitutes a Lisp but don't.
Why should i use mkcl instead of ecl?
I've [suggested better taxonomy](https://old.reddit.com/r/Clojure/comments/bj0w2n/gfu_a_pragmatic_clojure_for_go/).
I think you are giving lisps a worse name than a toyinterpreter ever could.
And note: Roswell already supports it. Don't bother cloning it and building it by hand.
The compilation fails while building the contrib modules. https://gist.github.com/guicho271828/953ea8375f9638a05fe47951639b2b24
Why would toy interpreters give lisp a bad name? People are so enthusiastic about the language they want to see how it works and play with it in a simplified form. In tree forth world it's practically required that you write one at least once so you know it for real. I think this kind of stuff would be much more common in other languages if they had simple grammars and consistent semantics. It's an indictment on languages like c++ that you can't even approach the idea of a toy interpreter / compiler.
One if the defining properties of a lisp (toy or not) seems to be how strong the kook opposition is. There seems to be a nonlinear response between how innocent, exploratory, and innocuous a project is, and the amount of impotent rage displayed by self appointed gatekeepers. Heaven help this poor author if he actually uses his implementation for anything practical (unsanctioned experimentation and learning is already a felony offense, one shudders to think if the penalty for engaging in greater heresy). Again, it's utterly impotent though, so the beta bullies only succeed in decreasing the time until they inevitably give themselves strokes from screaming into their pillows for the nth time. Poor souls.
Lol, it's more of a smell. So much triggering over nothing.
You have hit on a pretty interesting and stunning one here! Basically as I can see from what you posted on github I would say that the version of gcc that you use is not (in its cpp phase) including files in the same order as on my machine. Instead of including /usr/include/features.h as it should when processing line 26 of /usr/include/x86_64-linux-gnu/sys/types.h it goes on to include ./features.h picked up in the current working directory of the compiler process. The name coincidence is quite unfortunate but should not trigger this behavior. Can I ask you what version of gcc this is (as is the output of "gcc --version") and on what exact flavor of Linux is this happening?
How about turning this into a proper issue on [MKCL github site](https://github.com/jcbeaudoin/MKCL).
Thank you for the link.
It is so cool to see...browser games...written in Lisp! So, my understanding is that Fennel is used, compiled to Lua, and then some sort of Lua to Javascript transpiler is used? I'd like to hear more about how this generally works. And also if this Fennel setup would be good for regular non-game web apps. Teach me how to avoid Javascript and I will be a happy man.
What are the .so.bodged and .dll bodged files in the games that use cl-bodge for?
It's actually even deeper than that...the js substrate is actually [TIC-80](https://tic.computer/), a tiny computer with "cartridges"/roms. Looks like it goes fennel-&gt;lua-&gt;tic-&gt;tic-80-&gt;js. I was pretty impressed by the amount of layers removed from js it actually is, plus it has its own built-in editors for sprites, music, sound, code, etc.
Those are just plain-old shared libraries that cl-bodge loads during a startup.
Very neat. Haven't heard of the whole "fantasy console" thing before and ending up finding [this good article](https://medium.com/@G05P3L/fantasy-console-wars-a-guide-to-the-biggest-players-in-retrogamings-newest-trend-56bbe948474d) explaining some of them. TIC-80 is open-source under the MIT license, making it a more appealing option than some of the others. I came across Fengari as well which is a Lua-&gt;js. That'd probably answer my question for non-game web apps. It's not a transpiler though. Instead, a Lua VM for javascript.
Just in case, have a look at 3b's [`cl-vulkan`](https://github.com/3b/cl-vulkan) library - maybe you could combine the efforts. Personally, I'm using Nuklear library (via [`bodge-nuklear`](https://github.com/borodust/bodge-nuklear) bindings) - it's easier to integrate via CFFI than ImGui because it's written in pure C.
From experience it seems everyone makes a Scheme interpreter without any knowledge of what constitutes a Scheme other than "it has lambdas and prefix notation". Then you miss out on tail recursion, lists, symbols, etc, it's just a bad example. People can't write interpreters for their own languages as easily, so they use Lisp as a scapegoat in a way. The Norvig lis.py tutorial also is pretty shit, you don't need to invent half a lexer and parser to read Lisp. The environment is only any good in the second lesson too.
&gt; One if the defining properties of a lisp (toy or not) seems to be how strong the kook opposition is. A Lisp that...isn't a Lisp is not worth proper discussion. &gt; unsanctioned experimentation and learning is already a felony offense, one shudders to think of the penalty for engaging in greater heresy...probably more reeees How the fuck is this a learning or exploratory experience? You just about can't make a worse interpreter, mostly cause it's even easier to write a Lisp *in Lisp* (see SICP chapters 4 and 5, Lisp in Small Pieces, etc) and you get memory management, bignums, conses, symbols, and most Lisp things for free, then you have so much less to consider. All these Lisp-in-Foolangs are like building a house using only nails you make yourself. &gt; only succeed in decreasing the time until they inevitably give themselves strokes from screaming into their pillows If /r/lisp keeps this bollocks up, death is becoming a preferable option.
&gt; *Why would toy interpreters give lisp a bad name?* One of the negative myths associated with Lisp is that it's a toy language that is just implemented all the time by academics and students to a poor level of completion, and is not suitable for real work. The point is quite valid. This is caused by the confusion between "Lisp", the adjective that people are allowed to use for new, experimental languages, versus "Lisp" the family of mainstream dialects. In other language families, they radically change the syntax and the naming. Algol changes syntax, gets renamed to Pascal, changes syntax gets renamed to C, and so on, ... if someone makes a toy Algol-like, chances are they make up some new name for it. If someone makes a toy C, even if they do call it C, everyone knows it's not the real thing because C is widespread, and the toy hardly compiles or interprets anyone's code. When it comes to lesser-known languages, newcomers don't always know the fool's gold from the real thing.
There's always comp.lang.lisp.
&gt;Did you even read the source posting for lispy from Norvig, the origin of this exercise? Why did I ask, of course not. Yes, I did, I once tried to write a Lisp as an extension language for an engine I wrote in Python. Then I tried to add lambdas and strings and it went to shit because you have to reimplement the environment and the parser becomes even more difficult due to the lexer-parser stupidity. My point is that writing one of these doesn't teach you much Lisp since you haven't a clue *why* we write our Lisps like this and only *how* (well not actually, I can only think of ECL and CLISP as maybe being mostly written in C) they are written. SICP goes through the environment model and gives you context that makes this make sense, though maybe that's too much reading for people who write crap like OP.
&gt; SICP goes through the environment model and gives you context that makes this make sense, though maybe that's too much reading for people who write crap like OP. SICP - vaunted as it is - teaches you nothing of how to implement anything without already having a scheme to bootstrap metacircularly. It's a fine trade off, but ignores a practical reality. Hence...Lisp in Small Pieces, Make A Lisp, and any other example (like Norvig's blog posts) that walk you through the fundamentals, and in the process ,tie together many concepts that are elided entirely due to the necessary pedagogical aims in SICP. So, yeah, exercise for the reader (despite the fact the language had to be bootstrapped somehow....). For someone interested in the bootstrapping, say - to understand extant implementations and requisite design choices - it's useful. Learning by construction (and demonstrating the triviality of it from a familiar medium...say python, or rust) is a useful exercise. Either you missed Norvig's point entirely, or chose dodge it (I can't tell). Newlisp, Picolisp, etc. all are bootstrapped in various ways, not to mention guile and the schemes. That's the dirty secret that's often left out, until you go exploring or learning....
I am always happy when Lisp implementations never stop growing, so thank you very much /u/jcbeaudoin . On the other hand, I always wanted to know the differences between ECL and MKCL, and the only answer so far is here, in 2010: &gt; &gt; So what are the differences from ECL in practical terms ? &gt; Grab the source code, compile it and read it. It should be obvious by then. &gt; I am much too busy writing code to go on top of MKCL to elaborate on this... [Source](https://groups.google.com/forum/#!topic/comp.lang.lisp/cuQbgKmBwm0) The release announcement said: &gt;MKCL strives for greater reliability and stability in a quest for the ease of use that thus result. Which, so far, is the only claimed difference from ECL. Please take this message in good nature since I really think it's good to have many Lisp implementations when each one complements things other one is lacking or cannot offer. I always had the curiosity to try MKCL, but I still couldn't find some simple description that would tell me what would I gain compared to ECL etc. &gt;Changes to the code structure of what is currently evolving to become MKCL 1.2.0 have been extremely extensive. So much so that I have deemed best to drop this current code base and to rather start a complete rewrite from scratch that would then import the best and most recent parts of the previous code base when appropriate. This is exciting, have you considered, by any chance, doing something like using the LLVM backend, or perhaps researching if output to WebAssembly (either direct or via a C-&gt;WASM compiler like Cheerp) is possible?
Sure, but this Lisp doesn't have any Lisp features so what can you learn from it? One can't process lists or symbols, so you don't have to bother about symbol lists or memory management, but I've done that argument to death. It's barely a learning experience since there's nothing to learn (other than how to overengineer a parser and write a printer maybe). If [sl3.c](https://raw.githubusercontent.com/8l/openvmtil/master/lib/sl3.c) wasn't as type-unsafe I'd suggest anyone interested in bootstrapping a Lisp skims throuhg it.
I implemented a memoized longest common subsequence in Meta-CVS back in 2002 or 2003. See here: https://common-lisp.net/project/meta-cvs/downloads/ Code is in `seqfuncs.lisp`, using a memoization macro from `memoize.lisp`.
&gt; SBCL 1.14.2 Time to upgrade? ;)
&gt;doesn't have any Lisp features Shouldn't have used a universal. Expressions are denoted as lists of symbols delimited by parens, of which the first element is applied to the rest, depending on evaluation rules. The interpreter is environment-passing, call-by-value, and implements the fundamental computational construct lambda. Technically, everything but lambda is more or less extraneous (depending on how far you want to go encoding things without care for efficiency), so the rest is leveraging extant shortcuts from rust (or python in the original example). Everything else can be boot strapped; for now, it evaluates expressions denoted by lists, e.g. a toy implementation but an implementation. I'd say it's well within the moniker of list processer (implemented in a non-list processor) that can be gradually extended with remaining core features. It's semantic bitching. Author never claimed to have a reference implementation of common lisp, scheme (R?R?), or any other preconceived construct; only Norvig's basis from the blog. Author got a lot of out of the exercise too (again, on the implementation front as well), but at least you qualified your disdain with barely instead of another arrogant universal.
&gt; Expressions are denoted as lists of symbols delimited by parens `Vec&lt;RispExpression&gt;` is not a list. A hypothetical `cdr` or `rest` would be O(n). &gt; Technically, everything but lambda, application, and the recursive definition of eval is extraneous Sure, but you don't see anyone using Church numerals or lambdas-as-conses and all that. See https://en.wikipedia.org/wiki/Turing_tarpit &gt; I'd say it's entitled to the moniker of list processer What lists, and how do I process them? There's no quote or cons. &gt;The stated gripes seem more like semantic bitching. Author never claimed to have a reference implementation of common lisp, scheme (R?RS), or any other preconceived construct; only Norvig's basis from the blog. Then Norvig fell short. You definitely need conses and symbols at least to have a Lisp.
**Turing tarpit** A Turing tarpit (or Turing tar-pit) is any programming language or computer interface that allows for flexibility in function but is difficult to learn and use because it offers little or no support for common tasks. The phrase was coined in 1982 by Alan Perlis in the Epigrams on Programming: 54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy. In any Turing complete language, it is possible to write any computer program, so in a very rigorous sense nearly all programming languages are equally capable. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
&gt; *Author never claimed to have a reference implementation of common lisp, scheme (R?RS), or any other preconceived construct* Ah, but you see, "Lisp" refers to a pretty specific preconceived construct. &gt; *Expressions are denoted as lists of symbols delimited by parens* Actually, no; it doesn't have "symbols". For instance, lambda parameter names are mapped to values using a hash table keyed on character strings. That's one part of the code I closely looked at yesterday.
On this last point, I have glanced (sometimes more intensely, sometimes less) at LLVM since its pretty early days (more than a decade ago I'd say) and yet my latest addition to the MKCL "contrib" directory is a fork of TCC (renamed mkcc) customized to better serve the needs of MKCL. So I guess you could see somewhat of a philosophical orientation statement there. Thank you very much for the mention of Cheerp. It is an approach I was not much aware of. It looks interesting and I will definitely investigate its potential in the context of MKCL.
Very cool, I'd love to hear your thoughts on cl-vulkan and how your bindings compare. Best of luck, looking forward to seeing where this goes
The great thing about cheeep is that produces wasm directly, while the solution that uses "binaryen" goes through LLVM first. Also, binaryen is a huge download and uses (yuck) NPM, while cheerp is an easy install. If you're able to make a compiler that easily produces wasm code from true Common Lisp (even through C), that would be a huge gain for the community.
&gt;I can already hear the anger from r/lispmemes. Thanks for publicity!! **There are over 50 memes in /r/LispMemes , come join the party!!**
&gt; Ah, but you see, "Lisp" refers to a pretty narrow, specific range of preconceived constructs. Whatever you say chief. Preconceptions (I'd say more like dogma) are definitely full on display by the Party Members here. &gt;If you aren't conforming to a preconceived construct, just don't give it a name that, by and large, denotes membership among works based on a preconceived construct. Preconception is in the eye of the beholder, to an extent, and there are some truths that are more portable than myopics would like to admit. In the process, they lose sight of some of life's beautiful concepts, but they never lose their death grip on preconceptions. In some cases, such rigidity is admirable, but in a medium that has in various points been described as fundamental to language, expression, and extensible computation, it seems utterly silly; unless the rigidity serves another purpose (e.g. control, likely as compensatory mechanism). [The inventor seemed to, towards the end, lament the kind of stagnation such mental prisons seems to have caused](https://groups.google.com/forum/m/#!topic/comp.lang.lisp/4iUYVwonx7k). &gt;Actually, no; it doesn't have "symbols". For instance, lambda parameter names are mapped to values using a hash table keyed on character strings. Yet in the source code, from the caller's perspective, there are no strings....indeed, `x` has meaning as an identifier in an environment; the fact that quote has yet to be introduced as a construct (thus enabling bound vars, identified by symbols, to relate to symbols as data) is an issue of versioning and bootstrapping (e.g. the entire purpose of Norvig's original exercise....). Of course you'd miss the forest for the trees, what with said preconceptions - neigh prescriptions - about what the author should or shouldn't have done / could or couldn't have done. Like I said, non-linear response; here we are lol.
What Kaz said.
&gt;If /r/lisp keeps this bollocks up voted are 0 right now
&gt;Vec&lt;RispExpression&gt; is not a list. A hypothetical cdr or rest would be O(n). If - for this exercise - you're primary concern or criteria is performance, that's laughable. Further, the backing implementation for storing s-expressions - again denoting proper lists - is irrelevant to the user at this stage of interpretation, since the only means of constructing said lists are via the lexing/parsing performed by the reader. Certainly, the interpreter implementation can implement the denotational semantics of list operations and construction and expose these to the user, to enable not only interpretation but programmatic construction of expressions [lists] without leveraging the reader. &gt;What lists, and how do I process them? There's no quote or cons Yet here the author is.....processing lists from the reader and evaluating their results in an environment; e.g. computing results. Ye gods, how can this be? What is this black magic, certainly some kind of Other?!? &gt;You definitely need conses and symbols at least to have a Lisp. Perhaps one useful for your purposes. Certainly of the eventual kind McCarthy evolved. For an exercise in bootstrapping and interpreter that processes lists? Read, eval, and apply operating on the domain of lists-as-programs is kind of the central theme. SICP points that out. The next step is to introduce internally consistent means for generating programs (e.g. constructing expressions), of which `cons` is traditional (and again, completely feasible to implement with what's already present, efficiencies and leveraging provided functionality aside). I'd be surprised if the author doesn't go there next in the learning process.
Sorry but I am a bit fuzzy on that 'huge gain' point. Could you elaborate, please?
There is no true Lisp compiler for the wasm platform. There's only a Scheme compiler , but it is barely R1RS, doesn't even have garbage collections. WASM allows execution of a very low level bytecode in browsers, instead of them being confined to Javascript. That's why it is going to be more and more important in the future.
echo chamber's gonna echo.
gcc --version gcc (Ubuntu 7.4.0-1ubuntu1~18.04) 7.4.0
&gt;echo chamber's gonna echo echo chambers are cool things though
you've never been in one with howler monkeys then.
&gt;One of the negative myths associated with Lisp Actually, I spent about 20 of my 26 years of programming life uninterested in Lisp because I thought it was something of a toy language one implements for fun. It was only greenspun's tenth rule that made me think perhaps this stuff called Common Lisp was good.
The "preconceptions" here are actually "prior conceptions": tangibles. Not in the sense of "preconceived (false) notions". The idea that a word which denotes something specific should stay specific isn't really "dogma". Those other things can exist; just find another word.
&gt;denotes something specific should stay specific list + processor is both tangible and broad enough to apply to this case. I think Norvig's original article met the criteria, as does this adaptation.
&gt;Yet here the author is.....processing lists from the reader and evaluating their results in an environment; e.g. computing results. Ye gods, how can this be? What is this black magic, certainly some kind of Other?!? Barely. "Lists" are just used in place of an AST here. You can't perform any operations on lists in Risp. &gt;That's rich. Burn your idols (especially Norvig after ILC 2002 when he suggested Python was a Lisp).
&gt; Barely. "Lists" are just used in place of an AST here. I think, as before, that's the point. SICP illustrates this too (list of data, evaluator interprets list to get more data, code/expressions are data, evaluator itself is eventually discovered to be just another expression, etc. &gt;You can't perform any operations on lists in Risp. Except evaluate them and compute results lol. Again, I'd be surprised if the author doesn't continue exploring the natural sequence and flesh things out to allow more operations.
&gt;SICP illustrates this too (list of data, evaluator interprets list to get more data, code/expressions are data, evaluator itself is eventually discovered to be just another expression, etc. SICP comes with `quote`. &gt;Except evaluate them and compute results lol You can't do anything else with "lists" here. `(subst 'y 'x '(lambda (x) x))` isn't possible for example.
yet here it the author is computing with lists... (def add-one (fn (a) (+ 1 a))) // 🔥 =&gt; add-one risp &gt;(add-one 1) // 🔥 =&gt; 2 I think your precise point (as already addressed) is the construction, or modification of lists, outside the reader. Sure, as the author states... There’s still a bunch more to implement... That would like include reader and evaluator support for `quote`, exposing `cons`, etc. Again, following Norvig's intentionally simple layout.
&gt;yet here it the author is computing with lists... Again, in this case they could have used a normal AST and it'd all be good. You're not manipulating them at all, as there is no way to manipulate a list in a program.
Thanks for gcc version info. That gcc version is also the one I use on Ubuntu 18.04. The first line of output of "gcc -v" would be a big hint as to what is different in the includes search path of your instance of gcc. That 'features.h' include file is not so wrong in itself as *included at the wrong time*, and that is a includes search path issue. Indeed the first thought of a fix that came to me while writing the diagnostic posted here just two notches above was in fact to somehow mangle (at least partially) the name of the generated header file. But you see the somewhat unsettling thing here is that this 'fragile' generated file name scheme seems to have been a feature of the system for as far back as the early 1990's during the days of EcoLisp, the ancestor of ECL, and has not been changed much ever since. Nor has it caused trouble until now AFAICT. If one digs a bit deeper you get hints that this is in fact the remnants of a kind of manual optimization scheme used way back then and abandoned a long time ago during the early ECL days. The final irony of this all is that this generated header file is pretty much useless now and could fairly easily be done away with entirely.
Any footage of usage ?
For those of us who are behind: &gt; The most recent version is SBCL 1.5.2, released April 29, 2019 (release notes).
&gt; in this case they could have used a normal AST and it'd all be good. Yet they use symbolic lists; the AST is not abstract, it's concrete and denoted with some intent using the simple syntax and representation. Again, this is central to the representation and evaluation model. Runtime manipulation is a feature; the ability to define programs as trivial recursive encodings of lists enables everything else, including runtime modification of the program using the same operations provided (e.g. constructing new programs by defining lists). And again, the inclusion of lambda is sufficient to allow arbitrary encodings of higher level concepts, including list construction, should one decide to define the rest of the system by construction. The rest of the features are arguably library-level details at this point, or features amenable to an optimized implementation leveraging the extant compiled language to enable what amount to pragmatic shortcuts (either for efficiency or readability of implementation or both).
&gt; Runtime manipulation is a feature Corollary: ...that defines a lisp. &gt; And again, the inclusion of lambda is sufficient to allow arbitrary encodings of higher level concepts, including list construction, should one decide to define the rest of the system by construction. Yet again, you don't see many Lisp implementations using lambda for everything. You could use Church encoding for numbers too, so including numbers is also not an issue. (Or use symbols, that was cool in the early 60s)
&gt;Corollary: ...that defines a lisp. Qualifier, a lesser toy lisp approaching practical utility. Performing computation with a minimal list processor (as currently expressed, with lambda, turing complete) is impressive enough. Again, the improvement is feasible with the extant constructs (lambda), which erodes to a complaint of "lacking existing libraries" vs. a fundamental limitation. &gt;you don't see many Lisp implementations using lambda for everything. Small sample sizes don't invalidate the premise. In fact, the unfettered linkage to expressing lambda calculus in so pure and simple a manner is probably one of the great achievements (if not intrinsic beautiful properties).
I don’t understand what you’re saying. Can you give a specific example of something you’d like to do?
I'm trying to have something like this I open [https://server.com/foo.lisp](https://server.com/foo.lisp) and it run my php interpreter with foo.lisp file I would need to configure my apache server to run that file as CGI script but interpreter would be my LISP in PHP. This is how I was using guile on my shared hosting, I had scm file marked as CGI script and I have my first like \`#!/path/to/my/guile\`. The best for this would be LISP in PHP because I will have all libraries loaded by php.
Scheme is hygienic. This is a big deal. This means that the symbols you use in your macro output will never (unless you try very very _very_ hard) conflict with the symbols around it. You have to selectively introduce bindings unhygienically. Let's say you use the list procedure in your macro output. In scheme that list procedure will be the same as the list procedure that is visible to your macro definition Common lisp is unhygienic. This means that the names in your macro output may conflict with the ones already in the code. If the file you are using a macro in redefined the list procedure the macro output code might fail in weird ways. This is very much a matter of taste. I never liked that aspect of common lisp macros as I think it is a package of bugs waiting to happen. I have spent more time debugging issues due to other people's bad CL macros than I have spent fighting syntax-case (and the opposite, one guy redefined car and blamed me because my macro used for simple pattern matching broke). The standardised syntax-rules macros in scheme are not very powerful. They don't allow arbitrary code execution and are generally only good for smaller macros. Every scheme also has a lower level macro facility which differs between implementations. For the times when defmacro makes sense it is trivial to implement in scheme using lower level macro facilities if your scheme doesn't already provide it. However: almost no schemes provide a nice way to do reader macros. There is read-hash-extend, but that is very limited. Racket and common lisp has solved this problem in different ways.
you know about pharen ?
I have not a conventional point of view regarding the topic of DSL. It stems from the fact that Domain Specific Language or Application Public Interface are the same to me. At the end of the day you want to provide an interface that easy to the mind. Scheme provides some tools that allows to display an Abstract Syntax Tree that is different from the normal flow of evaluation/execution without relying on another parser. That is a great thing. That is the great power of LISPs and macros. Macros are just one way to present your API. There is passing procedure as arguments that is sometime named Inversion Of Control (or Hollywood Principle). There are more advanced forms of that called combinators (used in picture language and parser combinators etc...). There is also more hooks when you have access to an Object-Oriented framework. I came to LISP because the tooted DSL magic, I only end up writing a 4 line macro that does the job.
I should probably write a blog about this subject. But racket does too much marketing with DSL. I assume their parser are well behaving and have good error reporting (line, file, variable context...) that usually what is missing in DSL based APIs. Usually in LISP, a DSL is when you present another syntax. Let's take the example of [racket datalog](https://docs.racket-lang.org/datalog/Tutorial.html): &gt; parent(bob, john). &gt; parent(ebbon, bob). &gt; parent(ebbon, B)? How is the above better than the s-expr based: &gt; (parent 'bob 'john) &gt; (parent 'ebbon 'bob) &gt; (run (q) (parento 'ebbon q)) This is the same learning curve. It requires some work to understand. Simply said, I am in camp of "everything must be s-expr"
The hygiene problem is vastly mitigated by the separate function namespace in Lisp, but like fish don't know that water is wet, Lispers didn't know that dropping the namespace distinction would be as damaging to macro programming as it turned out to be. Schemers went on a decade-long hunt for a solution, and to their credit, they did solve it eventually. So you can write macros in Lisp or Scheme. (Fully understanding macro programming in Scheme is harder, especially with systems that also address *phase separation.*) You should probably ask questions about Clojure (and related languages like Hy) in r/clojure. That said, Clojure has macros, but their use is sometimes discouraged by the community. Maybe they have problems, IDK. Try asking r/clojure for more.
So the first part is relatively easy: Let your webserver (Apache, nginx) rewrite \`[https://server.com/foo.lisp](https://server.com/foo.lisp)\` to \`[https://server.com/lispinterpreter.php?file=foo.lisp](https://server.com/foo.lisp)\`. (and then use regex to do this for every \`.lisp\` URL you want). &amp;#x200B; Now the second part is harder. If you want to interpret LISP code you need an interpreter somewhere. I just found [this rather old library](https://github.com/lisphp/lisphp) that can interpret LISP code from within PHP. Another (quite bad) option is to shell out and let PHP run lisp in the command line, catch the output and return that. &amp;#x200B; Beware of security! If you don't validate your input and you shell out you basically give people command line access to your system and that can be REAL dangerous :-)
I like one of the first examples from beautiful-racket "stacker" which is essentially Forth. That's one case in which the syntax is more than just sugar, and is quite necessary. Well, I suppose you could explicitly pass a stack through every procedure (or use a monad?) and such, but hopefully you understand what I'm trying to get at.
Given a very positive feedback of a repl hack (https://www.reddit.com/r/lisp/comments/bgwtsh/fun_ecl_hack/) I've expanded it a little. I've added a printer and declaration inference. Some experimentation with generic functions in C followed and that would be it. Please see the readme.
&gt;If the file you are using a macro in redefined the list procedure the macro output code might fail in weird ways How is that different from functions?
I think that is what [mod\_ecl](https://www.cliki.net/mod_ecl) was trying to do.
Late binding is not what I want when I'm writing most code, and that includes macros.
Hygiene is far from solved. There are loads of edge cases where it either doesn't do what you think or simply fails to provide hygiene. You have to wade deep into macro territory to find the edge cases, but they can actually be triggered by regular macro writing. Not only that, implementing macro hygiene is _HARD_. People.complain about implementing call/cc, but if you think about program representation call/cc is simple. Implementing macro hygiene is never pretty. Syntax-rules is also the only macro facility you can use if you want your macros to be truly portable. Syntax-case differs enough between implementations to be extremely tedious to use across imementations. I have a syntax-rules implementation of clojure's threading macros that is easily portable across schemes: https://bitbucket.org/bjoli/guile-threading-macros/src/default/
Lisp is uses late binding quite a lot… I don't think 'unhygienic' macros are a big problem in CL code. The practice to generate symbols which don't collide with anything is widely known and can be learned. It has packages to separate symbols, too, and competent implementations don't allow to redefine built-in functions anyway. * (defun car (a) (cdr a)) WARNING: redefining COMMON-LISP:CAR in DEFUN debugger invoked on a SYMBOL-PACKAGE-LOCKED-ERROR in thread #&lt;THREAD "main thread" RUNNING {10005205B3}&gt;: Lock on package COMMON-LISP violated when setting fdefinition of CAR while in package COMMON-LISP-USER. See also: The SBCL Manual, Node "Package Locks" The ANSI Standard, Section 11.1.2.1.2 Type HELP for debugger help, or (SB-EXT:EXIT) to exit from SBCL. restarts (invokable by number or by possibly-abbreviated name): 0: [CONTINUE ] Ignore the package lock. 1: [IGNORE-ALL ] Ignore all package locks in the context of this operation. 2: [UNLOCK-PACKAGE] Unlock the package. 3: [ABORT ] Exit debugger, returning to top level.
I only though it was used in CL for global variables and for parameters. That is really a no-surprise way of doing it. I am just sceptical of the macro code I write not using the functions that are visible at the macro definition. I would go as far as to say that it's a bad idea. Dynamic scope is explicit in the common cases in CL and *practice* makes it even more clear.
I actually did a program that uses a canvas to draw an animated epicycles in parenscript using trident script to make it interactive. I was planning on doing a blog post about that but I never did it, even when the code works, I can share it, The point is that this method could be used to program games as well. I don't know if anybody has enough interest in that, but I had fun doing it.
&gt;I am just sceptical of the macro code I write not using the functions that are visible at the macro definition. This is just as true for any late-bound function. If Lisp calls the function through the symbol function, then redefinitions will be possible all the time and will have immediate effect on each call. Similar for CLOS methods: one can add/change/remove CLOS methods at runtime and Lisp will update the next call automatically to adjust to the new set of methods. These are things which make Lisp 'dynamic'.
Tried Chez instead of Guile? Not quite sure what *exactly* you're trying to accomplish.
Datalog isn't a DSL, though, it's a [pre-existing programming language](https://en.wikipedia.org/wiki/Datalog).
\&gt; Common Lisp - unhygienic (how does it influence real scenarios) Don't worry dude. It doesn't influence real scenarios. It's mostly a dreamed-up problem by Schemers. Plus there are well-known, legitimate uses for capture (e.g. anaphoric macros).
&gt; Clojure has macros, but their use is sometimes discouraged by the community. Maybe they have problems, IDK It's discouraged mostly as a style thing, not due to deficiencies in the system. The advice is basically to use functions where functions make sense, and to use macros where functions can't do the job for some reason, such as needing to create custom syntax. This is partly (perhaps largely) because Clojure is an opinionated language that pushes FP idioms, and macros frequently interfere with that. If you implement your cool new block of code as a function, you can pass it to other functions like `map` and `reduce`, but a macro can't be directly used as an HOF. To use a macro or special form as a HOF you have to wrap it in another function, adding additional boilerplate. So what you often find in Clojure is that macros get used by libraries to create DSLs or implement new syntax, which is stuff that is usually called directly, not used inside other functions or macros. It's also common to separate the macro-specific code from other logic. The macro portion *only* does the necessary syntax transformations, with helper functions called to do most of the real work.
In Scheme the local variable definitions shadow literal words in the syntax of the macro, as in this example: (let ((else #f)) (cond ((foo x) 'foo) (else 'bar))) =&gt; unspecified return value Oops. I've never run into the problem that Scheme hygiene is supposed to protect you from, but I ran into the shadowing problem frequently when I used to write Scheme code.
&gt; Hygiene is far from solved Hmm, right, I vaguely remember having read the title or abstract for a paper by Oleg about breaking `syntax-rules`. More recently, Matthew Flat proposed scope sets, do you happen to know if that approach solves some or all of these edge cases?
&gt; I only end up writing a 4 line macro that does the job. Does that make all the difference in the world?
&gt; It's discouraged mostly as a style thing, not due to deficiencies in the system. The advice is basically to use functions where functions make sense, and to use macros where functions can't do the job for some reason, such as needing to create custom syntax. That's been my experience with the (Common) Lisp community as well. That said... &gt; This is partly (perhaps largely) because Clojure is an opinionated language that pushes FP idioms, and macros frequently interfere with that. Interesting.
Those are all explicit expected behaviours. I don't think I have ever met a macro that expects to be "configured" by overriding its internal bindings. When it happens it is all an accident. Accidentally dynamic is not what I would call CLOS (which I love) or the late-bound top-level (practical).
Interesting... such a long time I don't see a lisp game..
&gt; *I've compiled everything using my php shell.* Someone please confirm that's not actually a thing.
\&gt; I don't think I have ever met a macro that expects to be "configured" by overriding its internal bindings I don't think I have ever met a macro where this actually was a problem.
That is indeed a problem macros that match literals (of which cond and cut are the only standard ones I can name, ). One could rewrite the cond macro to treat the symbol else, regardless of whether it is bound in the scope, as a statement. What other cases did you encounter? Most macros don't match literals like that, and with syntax-case that is less of a problem. Or you could do lie in CL and just use #t as the last test case.
I worked at one company that was using a horrible pseudo-relational database system that had the most insane XML-based syntax (and which table you were querying was specified by a URL that had to be looked up first.. columns numbers to be looked up too). I wrote a macro that reduced the problem down to a simple, SQL-like syntax that would expand into the gnarly mess of code that was actually required. The problem was that sometimes, I'd get the error `bad syntax`, and I couldn't tell why it was bad syntax since it clearly looked like it should match. I had no clue during the life of that project that local symbols were actually shadowing the macro. It was during another project that I actually identified the cause.
It does influence real scenarios, by making macros generally easier to write. You can use the same utility functions to manipulate code and regular list data. In Scheme, you can't use `map` on a syntax object representing a list, and you can't use `car`, `cdr`, `reverse`, or any other functions either. When I've written Scheme macros, I've resorted to implementing syntax-object-specific versions of them, such as this syntax-object version of `reverse`: &amp;#x200B; (define (stx-reverse stx) (let loop ((rest stx) (result #'())) (syntax-case rest () (() result) ((hd . tl) (loop #'tl #`(hd . #,result)))))) You'd never have to waste time doing something like that in Common Lisp.
regarding clojure, it has macros more like common lisp (e.h. unhygenic). There is core support to get around the problems unhygenic macros cause, namely convenient auto-gensym identification within macro definitions. quasi quote, un/splicing, etc. operate like CL, with a minor modification in `~` vs `,` for unquote, and `~@` vs `,@` for unquote-splicing. Splicing works on any generic seqable thing too, in addition to lists. The change in delimiters comes from the language treating commas a whitespace, and reserving ampersand for the reader macro to invoke deref in a reference type. There are ways around the hygene problems in CL (Hoyte writes his own auto-gensym macros in Let Over Lambda, and Seibel does something similar in Pratical Common Lisp). There are likely already libraries that do this. I don't think it's that big of a deal in practice, although your mileage may vary. I do like the CL/Clojure style of macros vs.the default syntax-rules stuff and variations in scheme. Could be historical accident though. The age-old argument over when to use macros vs. functions (particularly when functions are so ubiquitous) is alive and well, and macros see plenty of use (from DSLs to basic enablers for programming) in clojure libraries. There isn't an aversion to using macros (as evidenced by the existence of macros in many libraries and the bulk of the core language...), although there's a compelling argument as to asking why you'd use a macro if you could use a function. CL, for example, has had similar advocates that seem remarkably consistent with notable (or at least published) clojure folks. Here are a few vocal members from both languages publishing similar advice (with references to books that may be informative): The first step in writing a macro is to recognize that every time you write one, you are defining a new language that is just like Lisp except for your new macro. The programmer who thinks that way will be rightfully be extremely frugal in defining macros. Introducing a macro puts much more memory strain on the reader of your program than does introducing a function, variable, or data type, so it should not be taken lightly. Introduce macros only when there is a clear need, and when the macro fits in well with your existing system. Macros execute before compile time, and the compiler sees the result of macro execution. Because of this level of indirection, macros can be difficult to reason about, and thus it's best not to use them when a function will do the job. However, macros have legitimate uses, and it's worth understanding how they work. *Norvig, Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp, 66. The first rule of Macro Club is Don't Write Macros. Macros are complex, and they require you to think carefully about the interplay of macro expansion time and compile time. If you can write it as a function, think twice before using a macro. The second rule of Macro Club is Write Macros If That Is The Only Way to Encapsulate a Pattern. All programming languages provide some way to encapsulate patterns, but without macros these mechanisms are incomplete....In Clojure, you just implement feature X using a macro. The exception to the rule is that you can write any macro that makes life easier for your callers when compared with an equivalent function. But to understand this exception, you need some practice writing macros and comparing them to functions. *Halloway, Programming Clojure, 191. Clojure macros let you automate patterns in your code. Because they transform source code at macro expansion time, you can use macros to abstract away any kind of pattern in your code. You are not limited to working within Clojure. With macros, you can extend Clojure into your problem domain. Internally, Clojure uses macros to implement many of its most powerful features. Halloway, Programming Clojure, 223. The main drawback of macros is that they can make it hard for other programmers to understand your code. After all, if you're creating your own language dialect, other programmers won't be familiar with it. Even your future self - say, in a year or two - may have a hard time understanding the structure of your code if you've made heavy use of macros. Because of this, experienced Lispers will do their best to use alternate techniques to macro programming whenever possible. Often, a beginning Lisper will write a macro in situations that could be addressed in other, cleaner ways. *Barski, Land of Lisp, 352. Though instructive to the point under discussion, we also tried to show how macros can be used to mold Clojure into the language that shortens the gap between your problem space and solution space. In your own unique programs, you should try to do the same. But the most important skill that you can learn on your path toward macro mastery is the ability to recognize when to avoid using them. The general answer of course is whenever, and as often as you can. *Fogus and Houser, Joy of Clojure, 176. The conventional wisdom surrounding macros is to use them only when necessary because they can be difficult to understand, contain extremely subtle bugs, and limit you in possibly surprising ways if you think of everything as functions. These aren't defects in the lisp macro system itself but instead are traits of macro programming in general. As with any technology, the more powerful the tool, the more ways there are to misuse it. And, as far as programming constructs go, lisp macros are the most powerful tool. *Hoyte, Let Over Lambda, 3. This is a rabbit-hole though, as macros encourage more macros: the more macros you write, the more macros you need to solve the issue of their being unavailable at runtime, and therefore not suitable for use in many functional programming idioms that call for passing higher-order functions around. ...a macro is convenient or powerful in one context (compilation), but can make life difficult in another (runtime); consider splitting the core functionality out of your macro’s implementation and keeping it in its own function. The macro can simply delegate to it at compile time, but if you need to leverage its capabilities in a setting that benefits from a simple function, that route is readily available to you. ...macros should be used only when you need your own language constructs ; it follows that they shouldn’t be used where a function can be as effective. Macros are our only solution if we need: -Special evaluation semantics, -Customized syntax for frequent patterns or domain-specific notation, -To gain ground by precomputing intermediate data at compile time. ...we should also always ask ourselves whether there’s a function-based way to achieve the same goal. Emerick, Carper, Grand, Programming Clojure, 244. By default, we should use functions: it is inelegant to use a macro where a function would do. We should use macros only where they bring us some specific advantage. *Graham, On Lisp, 106. I couldn't find a quote from Rich Hickey, although there may be in a transcripted talk somewhere. He provided first class support in the core though, so I imagine there's a fondness (perhaps from his prior mileage in CL).
Looking forward to the game content.
I actually had it happen. There were two instances of an auxillary function that did some simple destructuring of arguments. It ended up breaking in weird ways. It took.me more time than I'd like to admit to fix it (I wrote one of the auxiliary macros, someone copied it and made changes and used it in parts of the codebase). I ended up trying to understand what triggered the bad behaviour in my function until the other guy had a look at it and just said "oh, but your using (aux-blah-blah ...) Incorrectly. The difference between overriding methods is that you work with an already known environment (already known classes, some hum of which expectations there are about how the method should work). With macros you can just hope that it works. It is slightly better in CL with the (at least) two namespaces, but it is still not a pretty situation. Hygiene, with all its warts, at least gives you simple guarantees about how the macro is supposed to work. I know people don't agree with me, and probably you of all people the least, but this is one thing of CL I just can't wrap my head around how it can be turned into a good thing. To me it seems unprincipled, and that mindset is probably what makes me prefer scheme
Julia for anything numerical, Maxima for things algebraical.
Thank you for this very well written answer. Since you are well versed in Lisp literature, do you know if books such as On Lisp or Let over Lambda apply to Clojure (of course some syntax would differ) ? If not, what is the best way to learn metaprogramming for Clojure ?
I have been there as well. It sucks. I usually use syntax-case and check keywords using guard-clauses like so: (symbol=? 'aux (syntax-datum #'match-name)), but that is also a risk of errors, but at least it puts the fault more on the user of your "DSL"
&gt; &gt; I came to LISP because the tooted DSL magic, I only end up writing a 4 line macro that does the job. &gt; But does that make all the difference in the world? &gt; Or is it inconsequential? Yes it does make a difference. The code is more readable with the macro. It is also faster than equivalent Python code.
"Service unavailable" error...?
Instasubscri...! Oh, it's 503. Nevermind.
Yes, I know about it. The problem is that in compile to php, not sure how it will work if you want to exchange S-Expressions between backend and front-end.
Modern resources: * https://lparallel.org/ * https://trac.common-lisp.net/bordeaux-threads/wiki/ApiDocumentation
I think it's a non-problem. The compiled php is still running lisp logic. So the code can still process lisp lists/sexps as normally as any lisp running. Consider this: compiled SBCL code is x86, it's not lisp anymore, yet you use it without thinking about x86 assembly. I hope I'm right and this helps :)
Oops. Looks like hunchentoot ran out of worker threads and somehow never recovered. ``` Can't handle a new request, too many request threads already ``` The server is restarted and back up. Going to try to repro this locally and keep an eye on the server. I guess I'll have material for another post sooner than I thought.
thanks :-)
If you match the list as in (elements ...) The #'(elements ...) is a list that can be used with map and friends. I don't know why this is, and I don't like it either. Maybe the reason is to spend less time pattern matching.
&gt;The hygiene problem is mitigated by the separate function namespace in Lisp What about generating symbols with `gensym`? As far as I know, correctly used this removes any hygiene problem. I don't remember any Common Lisp programmer complaining about hygiene problems.
I'd say they're definitely constructive, e.g. the macrology from the CL books (typically well written) will cross train or directly transfer to clojure (did for me at least). There are plenty of macro treatments in just about every clojure book (similar to CL texts), along with specific, short treatments like "mastering clojure macros" that are useful for quick bootstrapping but less impressive than the stronger CL texts (on lisp, paip, let over lambda). A lot of the clj authors reference cl texts (and others) with macro examples too. I'd look at "clojure programming," by carper et.al, which has a pretty comprehensive treatment. There are more recent books (e.g. 3rd edition of the first clojure book, "programming clojure" by halloway, I think updated to clj 1.9), and several I haven't explored. Depending on well roundedness, work in SICP if you can (metaprogramming by construction, excellent philosophy on language design) and/or a racket text. My perspective is far from complete though (particularly with racket and the various rxrs schemes).
Have a look at LFE (lfe.io) It solves the inherent problems of both Lisp and Erlang at the same time.
Oh, but it does not. Say I have a macro depending on the boo-ya function, and the place where macro expansion happens does not use the one I export, but has it's own. In scheme the macro would use the one visible to the macro definition, whereas in common lisp you have a problem. Not a very common problem, but one I spent at least an hour debugging about a year ago. I have spent enough time arguing the merits of macro hygiene online to know people actually prefers the common lips way. To me it just seems like a bad idea, even though it rarely leads to problems. Macro hygiene leads to macros that are a bit more complex to do complex things with, but tries to guarantee some things for you. This means a bit of boilerplate to introduce unhygienic bindings and bit more work for things you would otherwise solve with mapcar or reduce in CL. I think it is a good tradeoff for a good principle, many people don't.
But incomplete, toy implementations of Scheme are often called some kind of Lisp, in which cases Scheme escapes the damage.
So you would recommend to work through SICP first ?
&gt;Oh, but it does not. It does. &gt;Say I have a macro depending on the boo-ya function, and the place where macro expansion happens does not use the one I export, but has it's own. In scheme the macro would use the one visible to the macro definition, whereas in common lisp you have a problem. No, in Common Lisp you don't have a problem. If you want to refer ro a function in a specific package, just fully qualify it with the package name. I.e. if you want function "myfunc" in the "reddit-helpers" package, write that one in your macro as `reddit-helpers: myfunc`.
&gt; What about generating symbols with `gensym`? The part of hygiene that `gensym` solves, macro-local bindings, would have solved the same problem in Scheme, too. The Scheme problem is that every local variable anywhere can shadow function bindings used *by* the macro. Since most local variables are not local functions, the chance of that happening is much lower with a separate function namespace. (The package system takes care of much of the rest. )
Older resources on *LISP: * [Wikepedia page](https://en.wikipedia.org/wiki/*Lisp) * [Getting started in Star LISP](http://people.csail.mit.edu/bradley/cm5docs/nov06/GettingStartedinStarLisp.pdf) (a pdf) * [An emulator](https://github.com/LdBeth/star-lisp)
Do it :) Seriously, I think embedding Lisp in mainstream languages is a great idea. 'Lisp in small pieces' and SICP both contain good recipes to get you started, Norvig did one in Python that I've heard good things about as a starting point. The only tricky part from my experience is quasi-quoting, I guess that explains why most tutorials and examples leave it out. For whatever its worth, I'm working on a similar idea (https://github.com/codr7/g-fu/tree/master/v1) in Go and would be happy to answer questions to the best of my ability.
Sure, in a rosy world where people fully qualify that stuff. I have worked on enough common lisp code to know that it is very very rarely a problem, but I have also been bitten by other people's sloppy practices in ways that would not happen in scheme. I prefer CL in many ways, but that is definitely not one of them
&gt;I have worked on enough common lisp code to know that it is very very rarely a problem Then we're in agreement.
If you already know scheme (unsure which implementation), it would be additive. I'd recommend SICP to anyone. I think the early examples may be limited for someone experienced with scheme, and they focus on a simple dialect, building more complex stuff through the book (state isn't introduced for a while for example).
Then Lisp is damaged, and there isn't any reduction in harm.
I've found that the best solution to problems with `syntax-case` is to write the project in Common Lisp. The only thing I miss from Scheme is `call/cc`.
I'd also love to read more about this.
You may find this interesting: [https://ahefner.livejournal.com/20528.html](https://ahefner.livejournal.com/20528.html)
Selling points: * Low hygiene macros ^(j/k)
Googled this after finding an Atari 520STE outside and .. as any lisper would do.. thought "hmm maybe I could run lisp on that" :)
That's an impressive engine you've got there. I'm surprised you have developed so many features so quickly
LFE = Lisp Flavored Erlang I made a link for you: http://lfe.io/
Thank you :-) the links are very good especially the MIT paper.
Thank you :-) very useful.
Actually, Lisp in Rust is spelled `(Rust Lisp)`... All these parenthesis...
Or implement defmacro :) It is about 7 lines of code, or 9 of you want optional argument support.
Reading the Hunchentoot source, particularly how Bordeaux and usocket are use to handle incoming requests, was very useful to see at least how in one case multiprocessing / threading can be handled. Recommended reading. https://github.com/edicl/hunchentoot/blob/master/acceptor.lisp (Other parts are interesting as well, but the acceptor is particularly educational.)
This is accurate. The version on TIC-80 is a bit out of date, but the latest release of Fennel has full support for backtick quasiquote in macros and limited support for backtick outside macros (as long as the backtick returns data types which exist at runtime). Lists and symbols are compile-time concerns in Fennel since Fennel literally has *no* runtime. This would be completely infeasible in an old style lisp like elisp because it has very poor syntax literal support for vectors and hash tables, so you end up using lists for those, but in Fennel you have convenient syntax for those data structures, so there's no need to use lists for anything other than code.
I've run into problems doing that, particularly in Racket. I had one macro that used another macro in its expansion. Racket decided that the symbol for the inner macro didn't refer to anything if the outer macro was used across modules. It was a bit more complicated than that, but I don't remember the details. The problem imposed severe limits on what I could do with `defmacro`. The problem existed in a version of `defmacro` that Racket provided as well as any I tried implementing myself.
Thanks for the clear explanation.
The common implementation of defmacro in syntax-case just converts everything to the syntax env where the macro is used. Unless all bindings are visible at the expansion site you will have a problem. But that isn't different from how CL does it, so I'm not sure I understand.
Game author here; hi. Fengari is also extremely cool, but it's not used here. I think TIC-80 uses emscripten to compile the canonical Lua C implementation into js, whereas Fengari is a (fairly literal) port of the C code (compiler and VM) to Javascript. I would expect the emscripten approach to be more faithful to the existing implementation, while Fengari would have much better integration with the existing browser ecosystem. I've only used Fengari a small amount, but I was very impressed by what I saw. We use it for the live REPL in https://fennel-lang.org and it ran the entire Fennel test suite without breaking a sweat. We were able to wire the repl up so it could run unmodified in Fengari by telling the repl to use `coroutine.yield` as its stdin function; then we hooked up the Enter key in the browser's input field to send its contents to `coroutine.resume` of the repl's coroutine: https://github.com/technomancy/fennel-lang.org/blob/master/repl.fnl#L74 (pardon the non-highlighted link; GitHub hasn't learned how to color Fennel yet)
What have been your best resources for furthering your understanding of Lisp and getting into Lisp game dev? I finished Practical Common Lisp, done a bit of learning Scheme as well, and try to use lisps whenever possible for little projects. Always looking for new resources.
I don't have a good answer for that unfortunately. I'm more or less completely self-taught when it comes to games; I learned by doing. For a game jam, I think you'll get much more bang for your buck learning how to effectively harness coroutines than you would by learning more traditional lisp concepts like macros. For This Is My Mech we had only one place where we would have used a macro, and even that would have been a better fit for pattern matching than a macro in the end. But coroutines were absolutely central to the flow of the game. They let you write non-blocking code as if it were blocking, which can turn a gnarly set of conditions into a very straightforward, linear flow.
The audio isn't great, but there's a recording of a talk I gave at [FennelConf 2019][fennelconf2019] on writing single page apps (backend+frontend) in Fennel, using [Fengari][fengari] and [OpenResty][openresty]. I managed to get a pretty nice interface to React in Fennel using macros, and got JWT auth working so the SPA could talk securely (well, "securely" - it is very much just a proof of concept) to the API. I still need to get around to releasing the source, but this kind of approach is definitely possible. Fengari does have an impact on bandwidth and performance since it's a Lua _interpreter_, not a transpiler, but it worked fine for the basic UI code in the demo. [Link to the talk recording](https://conf.fennel-lang.org/v/fennelconf-2019-mischenko.mp4) [fennelconf2019]: https://conf.fennel-lang.org/2019 [fengari]: https://fengari.io/ [openresty]: https://openresty.org/en/
That's awesome, I'm going to watch it! And it's cool that Fennel has its own conference.
Very cool. Yeah, learning by doing, always a great idea unless you want to be a surgeon. :)
That's a lot different from how CL does it. In CL, macro "visibility" is determined by two things: 1. The fully-qualified name of the macro symbol, determined by the value of `*package*` when the symbol was read, not when the macro is later expanded. So if you called a macro named `foo` from another macro in package `bar`, then in the expansion you'll always get `bar::foo` and never `xyzzy::foo` (unless `bar` imports `xyzzy` and `foo` is an external symbol in `xyzzy`). 2. The function/macro bindings in effect at the macro expansion site. A macro can be shadowed by a `flet`, `labels`, or `macrolet` redefinition. Otherwise, it'll have its original value. Scheme lacks packages, replacing them with invisible syntax metadata. So of course when you do `datum-&gt;syntax` on a symbol generated by a traditional macro, there's no telling if the symbol will have the same metadata as it had when you tested the macro at the REPL, especially when modules are involved. To create the same problem in CL, you'd have to write a version of `macroexpand-1` that does something like this: (defun my-macroexpand-1 (form) (recursive-mapcar (lambda (obj) (if (symbolp obj) (intern (symbol-name obj)) obj)) (macroexpand-1 form)))
A fix for the problem you faced is on [MKCL github repository](https://github.com/jcbeaudoin/MKCL) in this [commit](https://github.com/jcbeaudoin/MKCL/commit/00148600a06ed4a9eb6512e7ce882b775291b372) currently on master branch HEAD. The fix does away with generated header files out of lisp source compilation and consolidates all lisp-to-C generated content to a single intermediate C file. If you're curious, you could give it a try by locally cloning the [MKCL github repository](https://github.com/jcbeaudoin/MKCL.git).
There is no standard way to do module qualifications, but there are a wide assortment of non-standard way. In guile I'd do (@@ (module) name). The problem is that these rarely are documented and aren't really meant to be used. So yeah, maybe defmacro in scheme isn't really a good idea :)
Eeh, I wouldn't recommend binding Hunchentoot straight to port 80. Place it behind nginx or something and make it serve static files. In fact your blog is probably 100% static files, so you don't even need a dynamic webserver.
Your post looks more like an stackoverflow answer than a blog post. There are the "whats" and the "hows", but not the "whys". Also, I don't feel confident in a blog that starts "this is how I built the blog". It's like you have started writing just because "you have to" and not because you have things to tell. I prefer you talk about things you've worked a while with (or in) and then -after a while- present the blog construction, that will already have some wrinkles ironed out. In other words: expose your credentials. "What I learned on my last game jam", "Typical lisp game libraries", ...
&gt; Domain Specific Language or Application Public Interface They're actually quite different things. You might choose to make your DSL available as an API but it's not required. The usual use for a "DSL" is as part of bottom up programming, you create the language you need for the problem domain you are solving. It's not necessarily for "the public" to use.
You're examples are all quite naif and therefore poor examples of a DSL. A better, but still simple example, might be using "built in" iteration over a list of customers versus a function or macro that is customer aware. The function could even be something as simple as a wrapper around the "built in" iteration facilities.
The only correct answer is that all four of the languages you mention are excellent for creating DSLs.
It is consequential because the cost of code maintenance, which is where the bulk of the cost of software lies, is directly proportional to the number of significant lines of code. 10 lines are cheaper to maintain than 100 lines.
I've already have Lisp in JS with full macro support, I've only need to port it to php but was wondering if anyone was already using similar setup with existing tools.
I'm not sure about this. You would need to have your S-Expression parser written in LISP to be able to use it x86 assembly. unless the compiler also include some runtime utilities like read function to be compiled to X86. I think that with tools like Pharen you only have basic php output without any runtime code.
I have no proof but I'd bet a solid dollar that any lisp compiler will include anything required in the native code.
Of course. But whether /u/amirouche 's code was reduced from 100 lines to 10 lines by virtue of the 4-line macro is unspecified.
There are Lisp ports for ARM. I'm sure they can control hardware on RPi in much the same way as any other language you can run on RPi.
I highly recommend ECL ([https://common-lisp.net/project/ecl/](https://common-lisp.net/project/ecl/)), especially if your target platform is ARM.
Raspbian has SBCL, ECL, Quicklisp, Emacs, Slime etc. Github has some libs to use the GPIO. Not sure about the SPI, I2C and UART interfaces, but you could call out to wiringPi if you need them.
For Arduino and other systems there is [ulisp](http://www.ulisp.com/) the complete list is on the site. For RPI you could try binding a GPIO library using CFFI, or directly accessing de/gpiomem, [this article](https://bob.cs.sonoma.edu/IntroCompOrg-RPi/sec-gpio-mem.html) explains how to do that in assembly, even without knowing assembler the article contains enough information to give you an idea on how to read and write to the GPIO. through that device, I think the trick is figuring out the correct addresses.
How many active users does Next have? Is there any usage data available? &amp;#x200B; Looks like the vast majority of the work is being done by two individuals going back to January of 2017. For potential new users, what should our expectations be for the long term of this project?
That is interesting. :-)
thanks :-)
Thanks :-) &amp;#x200B; I am looking for taking control via parallelism an autonomous system.
I just found a page on [eLinux.org](https://eLinux.org) describing how to access GPIO from different programming languages, it contains a sample for [shell](https://elinux.org/RPi_GPIO_Code_Samples#Shell), which should make it easy to use something like [inferior-shell](http://quickdocs.org/inferior-shell/) to access the GPIO.
upvote to motivate you to keep going :)
Good work! Hope to see NeXt working on Windows as well soon!
You are making a very good point: Next browser still needs to get traction (it's a beta after all). It's very young and in the coming months we will need to focus on building a community: work on the documentation, tutorials on how to build extension, work on the website, etc. For the better time of 2017-2018, Next was mostly a proof of concept for macOS only. I ported it to GNU/Linux in December 2018. Until April 2019 Atlas Engineer was involved in other projects so no time was given to Next. I resumed my work on it a month ago and I will dedicate the coming months to implement the remaining essential features that are missing (e.g. the download manager). Next is a very unique project and I'm hopeful it will going to get far! :) In the end, it was built from the ground up to be resilient to web renderer breakages, so unlike what happened to most webkit-1-based browsers it won't break if one renderer stops working: we can switch renderers any time. This will hopefully guarantee some longevity to Next.
Thanks!
upvote because the project is extremely badass. :)
The PyQT Port will certainly enable that! Though you are free as well to make a C# port, it isn't terribly complex, we just haven't documented the API/protocol :D
&gt;parallelism [https://github.com/orthecreedence/cl-async](https://github.com/orthecreedence/cl-async)
SBCL is great, but it has got no threads on ARM32.
Hi! Just wanted to give you a heads up that Next compiles and runs on FreeBSD 12 using sbcl 1.4.15 and current quicklisp as well. I'm using it for typing this comment right now. ;) I guess it'll make a nice addition to my stumpwm based setup. :D However, typing text is a slow process, Next lags behind every keypress. Is this a known issue on Linux as well, or might this be something specific to FreeBSD?
yes, I am looking something like this. Thanks :-)
Thanks for the feedback! There is no noticeable lag on Linux as far as I can tell. Key presses are transmitted over a BSD socket, so I guess there might be something kernel dependent.
ulisp is really very interesting. Are there any real examples/applications apart from educational purposes?
I find that many of the projects in the "Larger Examples" section in the side are close to real life applications, In particular the six projects fetured when you scroll down on the page, plus the GSM one could be easily turned into something useful. But other than that I don't know of any examples of uLisp used "in the wild".
Yay! looking forward to using it on Windows!
I've been wanting to use this browser for a while now but it crashes frequently whenever I try it on Linux. Hopefully this update will help. What is the cause of [this large box](https://imgur.com/a/vj1vgTa) at the bottom of the screen though? Whenever I open the browser or navigate to a new page that large box saying "Loading url..." remains at the bottom of the screen until I do something that covers it up (e.g. "M-x ctrl-g").
[ferret](https://ferret-lang.org/) was designed for embedded systems (initially robots, as I recall). You won't be interacting with your device though (e.g. with a live repl), but if you want to express your control logic and deploy to a device (really a broad range of devices), it looks viable.
&gt; I think this kind of stuff would be much more common in other languages if they had simple grammars and consistent semantics. It's an indictment on languages like c++ that you can't even approach the idea of a toy interpreter / compiler. Not really. With something like Haskell you'd need to write an entire garbage collector to have a whole compiler.
I'm glad you guys are still working on it. I want to eventually move on from qutebrowser towards this, but last time I tried next browser, it was very slow, and crashed alot. Also, if I remember correctly, hinting required the pressing of \[Enter\], did you guys fix that, because that is annoying.
I started out by looking at cl-vulkan and ended up only keeping a highly modified version of generate.lisp which reads the vulkan xml spec and outputs the foreign function interface. Everything else is layered on top. I would compare vktk to "HI" Human Interface, though not as polished. HI was Nichimen's Common Lisp OpenGL 1.2 UI toolkit for the animation program Mirai.
Yes, version 1.2.1 essentially fixes the stability (and slow down) issues of Next on GNU/Linux. Regarding the hints, I'm planning to overhaul them very soon in a much smarter way: you'll be able to use (fuzzy) completion over the name / URL of the link! :)
Thanks for your feedback! Good news: 1.2.1 should fix most crashes on GNU/Linux! (Yes, 1.2.0 was very unstable :p) The large box is the minibuffer that does not get resized properly. This is due to a bug with WebKitGTK. I'm working on it, but it's surprisingly non-obvious :/
I work on autonomous systems in academia. Our code is mostly written in Clojure with a mix of C++ (for low level stuff such as driving the motors. Lately I have been porting some of it to Ferret \[1\] so full stack lisp is possible from bare metal controlling hardware to a general purpose PC handling high level logic.) and Matlab. &amp;#x200B; Directly driving motors via raspberry pi using GPIO is not possible since Linux is not hard real time you either need a dedicated driver chip that you talk to it via SPI or I2C then issue commands to it using FFI + WiringPI or add a microcontroller (i.e Arduino) with your firmware that you talk to it over UART (Serial port) then any lisp that has serial support can send commands to your microcontroller which drives your motors. &amp;#x200B; \[1\] [https://ferret-lang.org/](https://ferret-lang.org/)
Also, regarding adblocking, general security, etc.
Since the higher end boards are multi core, dedicate one to polling loops. Did I see that on one of the open source architectures? Or an ARM cell phone with one clocked lower. To save power on the polling loops, harden up the soft real time, soft irq etc.
I would like to add on to this that the next release of Next has plans to move to unix domain sockets for performance/security reasons
[The article is on Sci-Hub by the way](https://sci-hub.tw/10.1109/isca.2018.00022)
Not a GC nor chip expert, but the next practical question could be, can GC leverage the GPU?
Sounds really interesting! I have been wanting to switch to a mouseless browser for quite some time now. Since I use stumpwm, I wanted to try this browser. I really like the idea and see me using it, but it does not play videos for me.
Hardware based garbage collection. When will we reinvent lisp again?
Have a look at: CRAM: Cognitive Robot Abstract Machine http://cram-system.org/cram I've never used it myself, but I bookmarked it as something to test out in the future
You need to install gst-plugins-* packages and probably gst-libav (the names may vary).