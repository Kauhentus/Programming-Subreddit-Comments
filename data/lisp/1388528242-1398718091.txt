I think this graph is borked. They were using an invalid tag for CL threads. Here's a better one. CL is *not* an outlier: http://langpop.corger.nl
Which mailing lists?
http://dir.gmane.org/index.php?prefix=gmane.lisp
Using "lines changed" as a reference sounds like an awful idea to me; it'll give an edge to verbose languages.
I made a patched version: https://bitbucket.org/ktg/public/downloads/lispstick-ktg-20140101.zip It runs on path with spaces and highlights matching parentheses.
imagine you have a swarm of small flaying drones; to control it with standard approach and languages, you would have to contact each drone, determine it's position, calculate position comparing to others and issue command. Then you continue the sam for the rest. Obvious drawbacks are scalability (when you add a new set of drones to swarm, you have to modify the code) and complexity (e.g. you move your drones to different terrain or formation, you have to recalculate things again). With Proto you are like general; you work on set of them, issue commnads like move to X or color itself to green and leave Proto to handle boring details.
Of course, based on the chart, VimL crushes it.
Indeed. It seems amazing to me that VimL beats out Common Lisp, Emacs Lisp, and Clojure on # of github projects.
Common Lisp have a problem that it is has a strong close source implementation. Suppose that some day I will quit my job and work as freelancer that can choose any language he want. Now I will ask myself can I trust the SBCL compiler? can I trust the libraries? Maybe in order to use trustworthy libraries I need to pay money. Does the commercial implementation has a bigger user base then the free open source? I think that it is an important reason why Common Lisp is not the most popular language.
Lots of popular languages don't have a closed source implementation, like Python.
I wrote that the close source implementation is the problem. It split the community. It split the user base. It reduce the need to create good libraries (because some people can just pay the close source guys to build the libraries). Python succeed because it did not have a strong close source implementation.
I still don't know what you're talking about, there are lots of open source Common Lisp implementations, and all of them follow the same standard. Since quicklisp, there also has been lots of good libraries around. I would even dare to say that SBCL and Clozure are stronger and more popular than any closed implementation.
Same. My guess is that there's some giant package -- autocomplete or something -- that everyone copies to their dot files, then mirrors on GitHub.
What is the relationship (if any) between this document and the "hyperspec". Which (if any) is considered to be canonical? Are there any other key or definitional works that I should be aware of as a lisp neophyte? I'm not thinking of tutorial or introductory texts here. 
IIRC, the Common Lisp standardization process was not fully complete by the time the 2nd edition of Common Lisp the Language was published. It has some things in it that aren't quite standard: http://stackoverflow.com/questions/108537/what-are-the-main-differences-between-cltl2-and-ansi-cl That said, it's an excellent book and a simpler read in many places. I tend to use the Hyperspec for almost everything when I need to reference, but recommend CLtL2 for a good overview (and a more readable explanation of most of the LOOP options).
The original CLtL1 was a very nice and compact book. It defined a non-object-oriented CL without much extensibility. It was the result of two years work (82-84). CLtL2 then was a larger book: * it had all the contents of CLtL1 * plus all the changes * plus additional content (Series, ...) thus it was not very easy to read. Good for implementors/users of CLtL1, because it made the changes explicit. But for any normal Common Lisp user it presented a confusing picture with lots of useless information (how it was in CLtL1 and why it was changed). ANSI Common Lisp later then published a standard document. * a coherent standard text * it removed things from CLtL2, which implementations tried to add later (environment access for macros...) * Series did not make it into the standard The ANSI CL Standard was sold as a printed document, but the quality of the publication was sometimes not so good (photo copy quality). Kent Pitman took the last version of the standard under development (before the final publication) and converted it to HTML (using his Lisp Machine) and LispWorks published it as the Common Lisp Hyperspec. There are other HTML versions of the pre-standard document. Franz provides one for example. The Hyperspec is the most used one, though. 
&gt; Python succeed because it did not have a strong close source implementation. Python succeeded because people like the syntax, and Lisp failed because people dont like the syntax. Thats it. Every other organisational problem the Lisp ecosystem may have pale compared to the fact that people simply do not like the damn syntax, and choose to write their domain knowledge down in some other language and not in Lisp. All the problems you mention are present in the C world even more than in Lisp, but in the C world nobody cares that there are GCC, MSVC, ICC, CLANG, etc. Also there are various incompatible JavaScript engines, browsers, frameworks, and they are all a PITA, and still nobody cares because they can grok the syntax. While you can object that javaScripts syntax doesnt matter because JavaScript bootstrapped its popularity through getting embedded in the browser, Python bootstrapped its popularity _on syntax alone_.
In case you are a "read offline" kind of person like myself, you may enjoy the contents of the [readme](http://www.cs.cmu.edu/Groups/AI/html/cltl/readme) two levels up, or the tl;dr version is that the tar file is available from: ftp://ftp.cs.cmu.edu/user/ai/lang/lisp/doc/cltl/cltl_ht.tgz 
Looks like good stuff - code normal Clojure, submit as map-reduce. A functional language like Clojure should be much more natural fit for map-reduce than Java.
I hate newLisp with a passion.
Feel free to tell me, especially how those design decisions affected your work. Sure, there *are* parts I don't like either but there are places where I find it more useful than any lisp out ther. YMMV
http://mxr.mozilla.org/mozilla/source/js2/semantics/README?force=1
I think everyone and their dog is storing their .vimrc in github. That would account for a good portion, I'm betting.
ah, the clever search feature. good job. I (honestly) didn't actually think of that. I think there's something else though... ftp://ftp.mozilla.org/pub/mozilla/source/mozilla-19980331-unix.tar.gz is the earliest tarball I can find, but it's in C here.
Too bad I can't find any earlier (livescript/mocha) source examples. Just for the sake of seing sexps.
Eich said he was hired at Netscape to "do scheme" so it's not impossible that its first prototypes were sexp based.
Lisp implementation in JavaScript: [Parenjs](https://bitbucket.org/ktg/parenjs)
These techniques can be used to optimize inner loops and the other very small regions of code which typically take most of the time to execute in most applications, leaving the bulk of the code to use the full range of features provided by Lisp, and this can all be done in one language.
I disagree. Aside from the fact that none of that relies on an interpreter (many implementations don't use one), I don't think it's pathetic to say that if you want write code that is as fast as micro-managed code (essentially the only kind of code you can write in C), then you'll need to micro-manage your code. I'm just thankful that I don't have to do it by default. 
Yeah. Just like, you know, every other compiler in existence.
You don't seem to have read the paper correctly. Because what the authors write is that it's actually quite difficult to write lisp-code in a way that even allows for their optimizations. This is *exactly* what micro-management of code is.
So you're saying it's nothing that is specific to lisp but can universally applied to any compiler which needs to perform tight loop-optimization.
If I understand what you just claimed I said, no. The point is that in the areas that *aren't* critical, you can avail yourself of the full feature-set of Lisp. Additionally, you can write the initial version of your program entirely using the full feature-set of Lisp, use profiling to detect what needs speedup, and modify just those areas using techniques like those discussed in the paper to speed them up. This kind of thing is discussed in, for example, [ANSI Common Lisp](http://www.paulgraham.com/acl.html) by Paul Graham, *chapter 13: Speed*.
So this pile of glop: (defun mult (to from val) (declare (type (simple−array to from))) (declare (type fixnum val)) (let (( size (array−dimension to 0))) (dotimes (i size) (setf (aref to i) (the fixnum (∗ (aref from i) val)))))) Generates a basic AXPY loop, with no unrolling, vectorization, cache-awareness, etc. Color me not impressed. Optimization has moved on since 1970.
I'd guess SBCL is your best bet among free Lisp compilers these days. For the C, you can use GCC or Clang, both freely available, or the Intel compiler, etc. A vaguely new GCC turns this into code that uses all 16 of my SSE registers and the `addps` instruction. ATLAS may be able to generate something even faster. I'm guessing I'd have to use the FFI to get SBCL to do that.
Several Lisp compilers compile to C.
http://www.pvk.ca/Blog/2013/06/05/fresh-in-sbcl-1-dot-1-8-sse-intrinsics/ 
not "lisp in javascript" but "[the implementation of] javascript [written in] lisp". So that you'd have something, just to be explicit: bash$ make javascript-engine-binary ... ok, compiling lisp code 
There is another way to make Lisp go *much* faster than C. It is when you can use Lisp to transform your data in some other Lisp program that will be itself compiled. Look at the CL-PPCRE library. This regex library outperforms the GNU Regex by 5x-20x .
I wonder when a retro-hardware nerd with Lisp Machines will upgrade to one of these.
... If you are a shitty c programmer. I love lisp - it is the reason why I participate in reddit (back when it was in lisp) - but lisp will never be as fast as optimized c. This is okay, since it gives us so much more
thanks!
I use Lisp all the time at work in the form of Emacs Lisp... Other than that, it helped me get into functional programming, which I now do for a living. The company I work for happens not to use Lisp, but it could – there are plenty of new web startup-type companies using Clojure, for example. BTW, a book I'm reading mentioned the history of "Maoist mathematics," which I think is pretty tragic/funny. From a 1977 interview with a Chinese mathematician: &gt; Question: Should you not present beauty of mathematics? Couldn't it inspire students? Is there room for the beauty of science? &gt; &gt; "The first demand is production. [...] &gt; &gt; "Before the Cultural Revolution some of us believed in the beauty of mathematics but failed to solve practical problems; now we deal with water and gas pipes, cables and rolling mills. We do it for the country and the workers appreciate it. It is a beautiful feeling." I love it: *the first demand is production.* It is true in a way... But even Communist China reverted this policy. Enjoy your education, broaden your mind!
I got my current job because of my experience with Common Lisp.
To get a job. No, I can't say that I have. To do a job. Yes, all the time.
Not personally, but I'm sure my friend /u/Baggers_ wouldn't mind me mentioning his experience. I introduced this fellow to Common Lisp a few years back and, after working on [this](http://www.reddit.com/r/lisp/comments/1ok9dg/cepl_lispy_opengl/) for a while, he has recently relocated to Oslo to join a games/graphics startup. They were mainly impressed that he wrote a pretty useful compiler to GLSL, though he did try to make it clear that it was an accident.
I worked at two companies, one to do Scheme and Erlang, the other to do Common Lisp. The fact that my resume was very lispy obviously helped me get those lisp jobs. So, yes. But if you don't care about lisp jobs, and are happy with any job, then please stick to java/C#/C++/other, and leave us the lisp jobs. Cheers.
Yes, several. Not all of them writing Lisp.
Same here. 
Yes. In fact, for the last 10 years, all of my jobs have been Lisp related.
sounds interesting
It looks great! If you allow me the curiosity, what sort of game engine (from a 3rd party / open source / homebrewed) are you using?
The best jobs with the biggest names and most rewards both financial and professional I've ever had were more because of what learning lisp and, to a lesser extent, Haskell, did to the way I think about programming. That said, I couldn't get a job writing lisp, so I co-founded a company that uses it. 
indeed I researched years ago. Yahoo was the only company big into using it for their search engine. Everyone else then started using google :D
We use Clojure at my company, and actively hire Clojure devs.
Is this supposed to be a joke?
Do you offer telecommuting?
Likewise. Ok, not all the time, but when client requires something fast with deployment free thing, CL is my first choice.
Good work so far. Thanks for sharing this!
I understand the sequence abstraction http://clojure.org/sequences is considered to be an improvement over CL's (and other lisps') cons cells.
Don't use CONS cells if they're a bad fit.
The sequence abstraction is a tremendous improvement in generic iteration approaches, without a doubt. It has distinct similarities to Microsoft's IEnumerable/LINQ system. 
2x0ng rocked man! I played the hell out of that game, so simple yet so enjoyable. Your newest creation sounds awesome as well, will definitely give it a try when time allows. Keep it up!
Ditto.
Heya man! Well told and once again thanks for setting me up. My life is much better with too many parens in it :) Note: The job doesn't involves writing lisp but does involve working on compilers.
Why is this getting posted here again? It was dumb when it was written and it hasn't improved with age.
So nobody speaks about lisp because : - they're too happy lispin' around - they don't want people to steal their job
&gt; in the form of Emacs Lisp this reminds me of an interview... the interviewer said like "You listed Lisp as one of languages you know... how is this old thing useful?" and I mentioned Emacs... but then he said "Emacs? Isn't that also an old thing? What kind of man still uses Emacs or VIM." and then I knew this interviewer would be hard to work with...
Does experience with Clojurescript count?
Where are you located and is working remotely possible?
The opposite (sort of) happened to me. I was interviewing a potential hire and asked what his favorite language was. "Lisp! Did you know that Paul Graham, Yahoo Store, blah blah..." Then I asked if he ever _used_ Lisp. "Well...um...no...but I admire the elegance..." I knew some Lisp at the time and resolved to learn it well enough to not be like that guy.
Congrats, dto! Quick plug: Check out #lispgames on freenode if this sort of stuff interests you.
Every job I've ever had has been because of Lisp: * TA-ing AI-bootcamp courses in the early 1980's * Reviewing an implementation of Common LIsp for CDC machines in 1984 * Working at Xerox AI Systems in 1986-88, and for en-vos/Venue until 1994 * Working for [GST](http://www.gst.com) as a NASA contractor Granted, my last job search was in 1994, and I haven't used Lisp at work since 2004 or so... *sigh*
This is awesome. OP, do you work on this project?
[Quick link to Github Repo](https://github.com/fukamachi/lesque)
Yes, yes. It's all clear now. Indeed. Indeed. Most indeeddly.
The real answer is STM. The user-experience answer is: the stuff built on top of STM, for supporting the multiple concurrency paradigms and letting you write something high-concurrency (like the Ants demo for Clojure, google that) in a 'correct' way with few lines of code. There are lots of refinements, but the biggest differences architecturally are that Clojure has STM built in, and then is built as a language that fluently exposes all of the things that STM can give you. STM isn't something that's easy to add to a language -- in fact I think Clojure is the most popular language that supports it! Please note that this doesn't map into a "so use it for x" argument very well. STM is obviously useful in high-concurrency applications, and the software architect in you will probably be quite pleased that it's available, but the bottom line is that *I* don't yet think in terms of refs and actors or ANY of the Clojure paradigms yet. So if you don't think in those terms already, then Clojure would just be a departure from your normal way of working; a new (arguably cleaner) syntax to learn, a new ecosystem, and probably some interop with Java if you're doing anything really interesting.
Many locations. SF, Seattle, Kansas City, more coming up. shoot me an email @ jlisam@climate.com w/ resume
Also please checkout this link and see if any of them interest you http://www.climate.com/careers/sci-eng
I think between the [github page](https://github.com/fukamachi/lesque) and the [google translation](http://translate.google.com/translate?sl=ja&amp;tl=en&amp;js=n&amp;prev=_t&amp;hl=en&amp;ie=UTF-8&amp;u=http%3A%2F%2Fblog.8arrow.org%2Fentry%2F2014%2F01%2F04%2F191742&amp;act=url) one can get a decent feel for the introduction of the library. However google does butcher his parting words pretty badly so here's my hopefully-more-accurate translation: &gt; I haven't used it [Lesque] in production yet so I don't how it feels there, but that doesn't mean it's completely unusable. If you have a chance, please use it.
The comments make him look like a troll. The fact that he makes no valid points in the post but the criticizes commentators for not refuting his argument kind of confirms there is nothing of interest here. This is coming from someone that deeply understands the concept of hating/avoiding Java.
The google translate version is plenty acurate enough to get an idea of what is going on. Also a quick google for resque shows excatly what was being cloned.
When I wrote the first version I didnt know the definition of a compiler...I just wanted some code to turn my lisp into glsl and it seemed pretty easy to do..later I looked up the definition, as I had used the word in a couple of functions, and got a nice suprise...So yeah that goes over fairly well in an interview!
Great post.
Just to make things clear: clisp is just one among lots of implementations of Common Lisp. The usual acronym is CL. To download and install libraries, you should check [quicklisp](http://www.quicklisp.org/beta/#installation). To create a project, check [quickproject](http://www.xach.com/lisp/quickproject/). A quickproject's project structure will make it clear where to put library dependencies for your project, which will be automatically installed when you try to quickload your project.
I would like to plug the site I run - http://articulate-lisp.com/ ! 
plugging stuff again: Video tut on installing Common Lisp (sbcl), emacs, slime &amp; quicklisp: http://youtu.be/VnWVu8VVDbI Video tut on making a project with quickproject: http://youtu.be/SPgjgybGb5o
Here's my setup procedure for Windows: [gist](https://gist.github.com/tshatrov/6765120).
Lol, i should have mentioned i'm on linux :o) thanks though!
I thought Clozure was like, lisp with Java libraries or something?
CLisp is a fairly complete implementation, fairly stable, and probably the best free Common Lisp for cross-platform support. On the flip side, if you are interested in big problems, it is strictly a byte-coded implementation (last I checked) and so it is probably the slowest of the major CL implementations.
No, that's Clojure. It is another Lisp language, nothing to do with Common Lisp.
Do most of them compile to machine code?
But i can always compile it with other software and distribute it that way, right? 
Yes, but you have to be careful not to design things so they only work in CLisp. CLisp does provide several nice libraries (or extensions) that it's easy to get used to using. And there are a number of areas of the CL standard that produce "implementation-defined" behavior. Meaning it's okay to use those features, but different CL's might give different results. So if you are writing "production" code, it's a good idea to get started with the same CL implementation you're going to use for your final builds. On the other hand, for lots of use cases, these license issues aren't important and CLisp is a great choice.
Very cool. This especially great if you already have redis installed in your infrastructure and don't want to manage something extra like beanstalkd. I'll be sure to play with this next time I'm implementing a queuing system.
Clozure CL has *excellent* windows support, including native OS threading, and compiles to machine code =].
Generally the implementations all follow the CL spec as close as possible, and on top of that provide implementation-specific extensions for other stuff. For instance, sockets and threading are not part of the spec, so a lot of implementations expose these as extensions under a separate package. This may sound complicated, but in fact most functionality that isn't in the spec has a cross-implementation library written for it (for instance, `usocket` wraps the socket extensions of all major implementations and provides a standard interface). When building an app/project, I avoid using implementation-specific extensions directly at all costs and always default to using libraries that provide a compatibility layer. This makes it so your project can run on as many implementations as possible. To compare your implementation to others, clisp is generally known for being a bit slower since it compiles to bytecode, not machine code. For many applications, this does not matter at all. Don't be enticed by the riches of machine-code compilation unless you really need the speed boost (consider it premature optimization). Clisp is one of the implementations that *does not* support native threading, so if you plan on building thread-based concurrency into your apps, you may want to check out SBCL (great for \*nix/mac systems) or Clozure CL (great on windows/\*nix/mac). Clisp has *excellent* support for large-number math (think 1 with a hundred zeroes after it). While bignum support is part of the CL spec, I believe clisp's implementation is known for being one of the best. For general learning and getting used to the CL environment, you probably can't go wrong with clisp. It also tends to be pre-installed on most \*nix systems, which is a bonus (no packages to maintain/install).
If you are working through land of lisp it's socket code only works for clisp. There is a portable socket implementation, [usocket](http://common-lisp.net/projects/usocket/)
Lol, I WAS working through it and then I got bored of tutorials and tried to write my own code. Harder than I expected! I'm getting there though :o) I'm actually writing an automated player for my multiplayer game i wrote and am hosting xD
Lol, Clozure and Clojure sound entirly too similer :P
Well, it's much easier on Linux, everything "just works" there, even before quicklisp was a thing.
Man, tell me about it. Closure (a lambda that closes over variables lexically), Clozure (a CL implementation), and Clojure (a JVM lisp that has nothing to do with CL) were all confusing as hell when I started.
You are too generous.
I beg you pardon? 
Some context [here](http://xach.livejournal.com/321647.html).
xD Oh dear, a third one! Lol, as confusing as the vocanulary is though, i think the hardest thing is probably getting used to the syntax. 
No, sorry.
[Steps for Windows](http://www.reddit.com/r/lisp/comments/1jq5rk/common_lisp_gui_options/cbhk0ek)
For "How did you get Slime?" I'm surprised you don't have an option for ELPA / the built-in package manager in 24.
Some people used "Other" for that.
awesome looking games! I'd love it if you could write us a pdf book on how you program games with lisp (*sorry for asking for something so ridiculous lol). I just picked up LISP as my second real programming language behind python. I've also done BASIC, C, VHDL to name a few, but LISP just speaks to me. I'm terrible at using it, but I intend to fix that. I bought Land of Lisp and have looked at some of the online LISP books. They're all good, but very few of them show you how to build GUI applications or game programming. I wish LISP had something as well documented as Tkinter.
Radio buttons for OS is a bit of a poor choice, I'm sure many of us use multiple platforms with emacs (&amp; slime), I went with the OS I *primarily* use, but it felt wrong doing so.
You can fill it out more than once if you like.
:P
Yes. In the past I have given two conference talks about how our search engine uses Common Lisp "only at compile time", basically making a catalog of runtime slowdowns as they appear with dynamic languages in practice and then bumping them off one by one with SBCL. I put "only at compile time" into quotes because half of the code written runs only a negligible percentage of the CPU cycles and it is very valuable to have it as dynamic code. Apart from debugging utilities (programming is all about finding out what the heck is going on, anyway) a lot of the work to set up the search engine before you fire it off on a query is also in that category. The guy changing the tires on the race car doesn't have rocket boots on either. While I'm at it worth mentioning that although we use all the tricks mentioned here we did turn array bounds checking back on. There are some macros to turn it back off locally but that's only used in functionality like bit scrambling, not in mainline fast code operating on regular data. I also use C++ collection classes with bounds checking in personal code. The devastation from bounds errors is a bit much, especially if you mix arrays and lists a lot and list pointers follow garbage data interpreted as pointers.
If you like to start doing instant GUI examples in Common Lisp, you could try [EQL](http://gitorious.org/eql/eql), which is not too far from CommonQt (much of EQL code can easily be ported to CommonQt, as of recently). Both EQL documentation and examples are easy enough for newbies. Especially on Windows, it's easier to start with EQL, and switch to CommonQt if you need more Lisp speed (SBCL).
http://arclanguage.org/forum and http://arclanguage.org/newcomments have some activity.
There was a fair bit of criticism of it when it came out. After all the talk, it was seriously underwhelming. A particularly apt comment on Hacker News: "a collection of Lisp macros that's little more than a first year computer science project". Paul Graham obviously had bigger fish to fry than being Arc's BDFL, so there was little momentum to carrying the project forward. Here some other links: http://www.righto.com/2008/05/why-arc-is-bad-for-exploratory.html http://shlomif-tech.livejournal.com/18438.html
What's the problem? Clojure *is* a Lisp, it just uses an extension of S-Expressions instead of pure S-Expressions. I don't care that it runs in the JVM. It also runs on top of JS. If being in the JVM is a problem, then CL and Scheme also aren't Lisps because of ABCL and Kawa.
Hi, thanks for your kind words ;) I have had a book idea on the back burner for awhile. I would definitely like to make a book out of what I've learned, especially as regards multimedia, GUI, and games in Lisp. I'll keep you posted
Are you thinking that this will be ground software or flight control software? LISP likely isn't very well suited for controlling the actual hardware as it's not suited for hard real time programming. I don't see why it couldn't be good for ground software though, particularly since the numerical precision in most LISPs can be quite good.
I really like the look of the main gameplay mechanic, good work! Could you shed some light on what sort of patterns and libraries you utilised?
http://www.flownet.com/gat/jpl-lisp.html has a nice story on the use of LISP at JPL for some missions, both on the ground and in space. I don't see why it would be needed for getting off a launch pad. IANARS (I am not a rocket scientist :), but I think most trajectories and what not are calculated in advance, not recalculated on the fly on the rocket. 
Hi Joey thanks :) I hope you enjoy the game. I used LISPBUILDER-SDL and CL-OPENGL for graphics/sound/music/keyboard/mouse and so on; the game engine is my custom Xelf library. http://xelf.me/ As for patterns? Hmm, I should write an article about it I guess. 
The author of Lisp for the Web here. Just want to mention that the book is free if you want to. Leanpub allows a variable pricing model. Since I wrote the book to be read, I used the option to make it available for free.
I bought it. Will read a bit in the evening... 
Thanks! I hope you enjoy it. The book was fun to write; Common Lisp is indeed an amazing language.
haha, I was about to ask for a TOC in advance. Gonna help myself then. Thanks. ps: I'm also gonna checkout your [Patterns in C](https://leanpub.com/patternsinc) TOC, really curious about it. ps2: for a reason I didn't see the TOC down the page. *facepalm*
Thanks, not a bad idea. Now it may look as though I've stolen poor Adam Petersen's original [Lisp for the Web article](http://www.adampetersen.se/articles/lispweb.htm). But it's OK - I used to be him:) 
Thanks! I have to give credit to Leanpub - they have a great platform and a nice philosophy. Btw the [source code](https://github.com/adamtornhill/LispForTheWeb) is already copyleft licensed. It would be great with a review of the book. I intend to keep the book alive, update and improve it based on reader feedback.
Got it for free, promoted it to my lispy friends and as soon as I read it (and get some money, start of the year is being... special) I'll gift it to someone (paying)
I would love to see that. I was reading through your source a few weeks back, and I found the implementation very clear and easy to follow. Thanks for contributing this, and congrats on getting some exposure!
&gt; \* Using macros as a short-cut for efficiency. Some older coders found useful to use macros to create things like state machines. I would say today is more common to use [optimize](http://www.lispworks.com/documentation/HyperSpec/Body/d_optimi.htm) declarations. Optimize on what? The state machine interpreter?
I use `dolist`/`dotimes` a lot (`dotimes` more when I'm testing something, but it does find its way into my code here and there). They are a lot less verbose than typing out a `loop` statement. `do` confuses the hell out of me and I avoid it at all costs. I can generally pick apart what it means when someone else uses it, but wherever I might use `do` I use `loop` instead.
*Here's a bit from linked Wikipedia article about* [***Fexpr***](http://en.wikipedia.org/wiki/Fexpr) : --- &gt;In Lisp programming languages, a **fexpr** is a function whose operands are passed to it without being evaluated. When a fexpr is called, only the body of the fexpr is evaluated; no other evaluations take place except when explicitly initiated by the fexpr. In contrast, when an ordinary Lisp function is called, the operands are evaluated automatically, and only the results of these evaluations are provided to the function; and when a (traditional) Lisp macro is called, the operands are passed in unevaluated, but whatever result the macro function returns is automatically evaluated. --- [^(about)](http://www.reddit.com/r/autowikibot/wiki/index) ^| *^(/u/rogersm can reply with 'delete'. Will also delete if comment's score is -1 or less.)* ^| ^(**To summon**: wikibot, what is something?) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=bot%20glitch&amp;message=%0Acontext:http://www.reddit.com/r/lisp/comments/1va6a2/what_is_the_lisp_bitrot_rate_what_can_we_learn/ceqcwdq)
Imagine that fexprs were not lost, but dynamic scope and other things made them inefficient and, more importantly, "hard" to compile "properly". Now, some SCHEMER came about and lexical scope became "standard"... and defmacros, with variable capture and the like, started being "improved" upon. Now, the "issue" with macros is general in they are second-class, and fexprs were in the background, waiting... [possibly waiting for this](https://en.wikipedia.org/wiki/Kernel_\(programming_language\))
*Here's a bit from linked Wikipedia article about* [***Kernel (programming language)***](http://en.wikipedia.org/wiki/Kernel_(programming_language\)) : --- &gt; &gt;**Kernel** is a Scheme-like programming language by John N. Shutt in which all manipulable entities are first-class objects, and is thus more homoiconic than any other Lisp. &gt;Kernel exists as concept and is implemented only incompletely. --- [^(about)](http://www.reddit.com/r/autowikibot/wiki/index) ^| *^(/u/drewc can reply with 'delete'. Will also delete if comment's score is -1 or less.)* ^| ^(**To summon**: wikibot, what is something?) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=bot%20glitch&amp;message=%0Acontext:http://www.reddit.com/r/lisp/comments/1va6a2/what_is_the_lisp_bitrot_rate_what_can_we_learn/ceqdg10)
The lesson from Common Lisp is: "standardize smartly, and then be extremely conservative." This is easier for Lisp than for a lot of languages because so much more semantic space is available to Lisp via metaprogramming that it doesn't need to get everything into the standard. But Common Lisp's standard is extraordinarily complete and competent. 
Thanks a bunch...I still have some more LISP learning before I try to wrap it together with a GUI for work purposes, but I'll def remember your username for help when i inevitably need it! :)
Well, a good example is in On Lisp. The author writes an interpreter for Prolog, and in the next chapter, uses macros to compile prolog to lisp at compile-time.
 &gt;Historically some lisp coders liked to use macro definitions instead of function definitions to do code substitution. The idea was similar to some pre-processor techniques used in other languages to inline code. This can be accomplished today with inline declarations and is no longer necesary. This is pretty much exactly right. If you can't rely on a compiler listening to INLINE declarations (or the language does not support them), the compiler generates slow code in any case, and you're using a machine which can execute several hundred thousand instructions a second on a good day, then you use macros, a lot.
"Any lambda expression is formed visually by encapsulating a command with their variables between parenthesis" ... really? So wrapping parens around something makes it an anonymous function? How is that at all related to Lisp beyond the same sexp syntax? I am very confused now, and want to know what exactly this has to do with Lisp/LISP/lisp. **edit** : https://github.com/wetube/bitcloud/blob/master/server.lisp is a 'common lisp' like file, yet it is not valid CL at all, and either makes syntax errors or is simply wrong : "in DEFCLASS TRANSACTION, the slot specification (ESCROW NIL) is invalid; the probable intended meaning may be achieved by specifiying (ESCROW :INITFORM NIL) instead. [Condition of type SB-INT:SIMPLE-PROGRAM-ERROR]" sigh. So wants to use lisp, but not learn it first, or wants to learn lisp and then use it? more confused now. :( 
I have this huge ERP system I'm writing. Well, I have a thousand raw defclass definitions and a few defgenerics. Looks like I'm almost done. Err, not.
Is calling sexp syntax "lambda expressions," apparently. I see no Lisp here.
The ideas seem more than unusually idealistic. 
oh no... pie charts?! But good to see that most users are on Emacs 24 and using GNU/Linux.
Haha you're right, as long as the rule-birth and rule-death don't intersect I don't need the if. Thanks.
You could ask Charlotte Herzeel. She cited it in her paper: http://www.p-cos.net/documents/s32008.pdf
I actually tracked from her paper. Thanks for the hint. I will try to see if I can reach her. Other suggestions are still welcome.
Didn't know about (declare (ignore variable)), thanks. Does it have benefits as far as memory or run-time, or does it just silence compiler warnings? I didn't use an array because I hadn't thought about it. Didn't even know until just now that you could declare an array as 2-d without having to do a nested definition. Thanks!
Are you implementing http://en.wikipedia.org/wiki/Hashlife ?
*Here's a bit from linked Wikipedia article about* [***Hashlife***](http://en.wikipedia.org/wiki/Hashlife) : --- &gt;**Hashlife** is a memoized algorithm for computing the long-term fate of a given starting configuration in Conway's Game of Life and related cellular automata, much more quickly than would be possible using alternative algorithms that simulate each time step of each cell of the automaton. The algorithm was first described by Bill Gosper in the early 1980s while he was engaged in research at the Xerox Palo Alto Research Center. Hashlife was originally implemented on Symbolics Lisp machines with the aid of the Flavors extension. --- [^(**Picture**)](http://i.imgur.com/XcwT0zE.png) ^- **^The ^6,366,548,773,467,669,985,195,496,000 ^\(6 ^octillionth\) ^generation ^of ^a ^very ^complicated ^Game ^of ^Life ^pattern ^computed ^in ^less ^than ^30 ^seconds ^on ^an ^Intel ^Core ^Duo ^2GHz ^CPU ^using ^hashlife ^in ^Golly. ^Computed ^by ^detecting ^a ^repeating ^cycle ^in ^the ^pattern, ^and ^skipping ^ahead ^to ^any ^requested ^generation.** [^(image source)](http://commons.wikimedia.org/wiki/File:Turing_Machine_in_Golly.png) ^| [^(about)](http://www.reddit.com/r/autowikibot/wiki/index) ^| *^(/u/eleitl can reply with 'delete'. Will also delete if comment's score is -1 or less.)* ^| ^(**To summon**: wikibot, what is something?) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=bot%20glitch&amp;message=%0Acontext:http://www.reddit.com/r/lisp/comments/1vfv4n/im_working_on_a_common_lisp_implementation_of/cerx913)
Nope. The optimizations sound really interesting, but are way beyond me. I only used a hash table as a (not common) naive choice. Figured that with all the checking if x position was alive a hash table would be fast. Then it was pointed out to me that arrays are also accessed in constant time.
Not only are arrays also constant time, they're likely to have a much smaller constant, too. Still, hashtables might have a few advantages for this application: (1) it's easy to make the grid unbounded with hashtables than with arrays, (2) for sparse configurations, hashtables could conceivably use less memory.
There is an ACM paper that Smith co-authored describing 3-Lisp in detail, with code. I don't know specifically what information you need, but it may be useful. PM me if you need a copy: &gt;Jim des Rivières and Brian Cantwell Smith. 1984. *The implementation of procedurally reflective languages*. In Proceedings of the 1984 ACM Symposium on LISP and functional programming (LFP '84). ACM, New York, NY, USA, 331-347. DOI=10.1145/800055.802050 http://doi.acm.org/10.1145/800055.802050 
&gt; Your university or public library's Inter-Library Loan department may be able to borrow a copy from another library for you. [According to WorldCat](http://www.worldcat.org/title/interim-3-lisp-reference-manual/oclc/123316307) the only library in the US that reports having a copy is Stanford. The are three libraries in Germany that also have it.
&gt; The implementation of procedurally reflective languages http://commonsenseatheism.com/wp-content/uploads/2013/10/Rivieres-Smith-The-implementation-of-procedurally-reflective-languages.pdf see also http://publications.csail.mit.edu/lcs/pubs/pdf/MIT-LCS-TR-272.pdf 
Thanks. I have already contacted a local librarian.
Thanks for the links.
I wrote one of these recently. Regarding a good way to input your data I allow the user to specify the board as a list of strings where "X"s are live cells. I didn't use an explicit board in my implementation (which is based on the second CL entry on Rosetta Code). I only compute on the effects of live cells (i.e. my life board is simply a list of live cells, or a "cell-list"). I use this function to allow the user to input patterns that way. (defun string-sequence-to-cell-list (board) (iter :outer (for string :in-sequence board :with-index j) (iter (for char :in-string string :with-index i) (when (eql #\X char) (in :outer (collect (cons i j))))))) ...which allows you to do things like this: (defparameter *blinker* (ensure-cell-list '("..." "XXX" "..."))) (defparameter *glider* (ensure-cell-list '(".X.." "..X." "XXX." "...."))) "ensure-cell-list" is simply a wrapper around the other function that does noting if the data is already in a cell-list form. When you are using these cell-lists you only need append the lists (and remove the duplicates) to combine any two patterns onto the same board.
But Scheme which runs in Common Lisp.
Could you elaborate on what you mean by not having an explicit board? What do you do when eg your glider reaches the edge?
Cool, I just noticed this got posted here (that's my blog). I've been playing with mocl lately and I'm trying to record it since there isn't much online about it. Feel free to ping me about it and such.
Unfortunately I think not. [This](https://wukix.com/support/ticket/5) looks to be the relevant ticket. It looks like someone was investigating ØMQ for bidirectional communication, but I have no idea if it's progressed at all.
For what it's worth there have been some [recent improvements](https://wukix.com/support/ticket/33) (see comments) to the general call glue, but CL-&gt;native callbacks are still pending further development.
Looking forward to further improvements, keep up the good work!
Well, let's say you wanted some kind of table structure: a natural representation of the elements of that table is an object with key and value slots.
A circular list.
Ah...so maybe this is how hash tables work in Lisp(haven't gotten there quite yet)? Thanks!
Hmmm...i thought about that, but a circular list's last right cons cell will point back towards the first elements left cons cell. the dotted list (A B C. D) just ends with a pointer to D. Could you explain to me how they are related? Please forgive my simplicity of mind :)
It isn't, in fact, but it is how association lists work: which are a now-underrated data structure.
Just in case y'all haven't seen this yet :) http://xkcd.com/1312/
[Image](http://imgs.xkcd.com/comics/haskell.png) **Title:** Haskell **Title-text:** The problem with Haskell is that it's a language built on lazy evaluation and nobody's actually called for it. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=1312#Explanation) **Stats:** This comic has been referenced 15 time(s), representing 0.16% of referenced xkcds. --- ^[Questions/Problems](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Website](http://xkcdref.info/statistics/)
I've heard of alists, thanks! Will keep in mind.
Note that you get an overview about buffer commands using c-h m . Also a GUI-based Emacs has menus which contain the necessary commands.
Since a list is made out of cons cells, you could look for the same cons cell. You would not need to look for the same content.
There are menus on the Emacs I'm using, but I either don't know what the commands mean or am looking in the wrong places. There are a whole lot of commands, and the names arent so clear, so I was hoping an experienced Lisper could just point me to the more useful ones rather than having to research and experiment with every command.
Have you seen the Slime manual?
Thanks!
Thanks! Never thought of that before!
I haven't - taking a look at it now, thanks!
Nice. Although I'm not clear on the difference between SxQL and s-sql. s-sql accomplished the same AFAIK and is not postgreSQL specific. Btw Guicho, you should blog about how you are implementing optima in optima.
Such magic. 
C-c C-c: compile and load current function C-c C-k: compile and load current buffer It doesn't make sense to execute non-toplevel code most of the time, because it depends on context. I have a keyboard macro saved to copy a s-expression, so I can easily copy paste chunks of code: (fset 'copy-sexp (lambda (&amp;optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([67108896 134217734 134217847 134217730] 0 "%d")) arg))) (global-set-key (kbd "C-x c") 'copy-sexp)
Interesting, I wanted something like this for Postmodern but ended up just creating the tables manually.
If you are using standard Common Lisp, you could look at the list-specific function *list-length* which is required to detect circular lists (opposed to the general *length* function for generic sequences) .
I use them because, as /u/lispm noted, the right value can be accessed with `cdr` instead of `cadr`. So with data that normally comes in pairs (key/value, x/y, etc) it's convenient.
Should the number you're after be called the length, though? I'd say the length of a circular list is infinity, and would call the number you want the period of the infinite periodic list, or something like number-of-distinct-cons-cells.
Go through until the tail is the same object identity as the initial tail
As an example, here's the littlest circular list. It is also a dotted pair: CL-USER&gt; (setf *print-circle* t) T CL-USER&gt; (let ((cell (cons 'a nil))) (setf (cdr cell) cell)) #1=(A . #1#) 
How about "circumference"
M-x slime-cheat-sheet
I love the picture at the end. 
I get the analogy, but probably not the right way mathematically...although thats probably not what you meant anyway lol.
There's a half-assed binding to Akka via ABCL: https://github.com/ubikation/chemicalambda
You could write your only simple evaluator. If the source code only contains simple function calls, you just need to recursively 'evaluate' the expressions.
This would force me to have the `car` of every list to be a function, right? So any thing that should actually be a list would read `(list foo bar baz)`? I'll give it a go, thanks.
This is the answer: make the values be functions you call and write a macro to turn the syntax you want into that.
Another full lisp on erlang vm is [lisp flavoured erlang](http://lfe.github.io/). As it is standard erlang byte code it will work fine with things like http://erlangonxen.org/ and OTP. Also it is a lisp(2/n) like common lisp so it feels very familiar. It was written by Robert Virding who was the co-creator of Erlang. He has [a good talk on it here.](http://vimeo.com/17016059)
I assume he wants to control the evaluation, checking the car. In that case, Rainer's suggestion is the simplest. (defun e (list) (if (listp list) (if (allowed (car list)) (apply (car list) (mapcar #'e (cdr list))) (error "!"))) list)) _edit: ahem_
Including one from C.Queinnec https://www.youtube.com/watch?v=aQMQyD7sdPU&amp;list=PLa5ilFtyOSl9JUhr_7oXqTfTxSxsid2Vo LiSP's author.
I was able to write a macro that will evaluate a form and one that will evaluate a list of forms. What's giving me trouble now is writing them in a way that they will accept either a variable or an intermediate form that expands to the final list of forms. This is my absolute first time with macros. Should I just live with the long function for now and come back to it later?
Many people suggests macro-based answer here, but I vote for a condition-based solution. I guess your code is something like (defun aaaa (bbbbb) ... ... some nested code ... .... (case-like-clause bbbbb ..........(("q" (return)) ..........(("n" (format ... because your `return` suggests you want to dynamically alter the control of the code. my solution is: (defvar *alist* nil) (defun aaaa (bbbb) .... (handler-bind ((trap (c) (trap-value c))) (funcall (find bbbbb *alist* :key #'car :test #'equal)))) (define-condition trap (condition) ((value :reader trap-value :initarg :value))) then (push `("q" (lambda () (signal 'trap)) *alist*) It is AT THIS POINT that I write a top-level macro. (defmacro define-key-handler (key args &amp;body body) `(push `(,',key (lambda ,args ,@body)) *alist*)) though I'm not sure it actually works (because ,', is a bit complicated). Or, I can add a bit more abstraction: 1.`key` is a symbol, 2. inside the body `return` automatically signals a `trap` (defmacro define-key-handler (key args &amp;body body) (with-gensyms (exit) `(push `(,',(string-lowercase (symbol-name key)) (lambda ,args (tagbody (signal 'trap :trap-value (block nil ,@body (go ,exit)) ,exit))))) then you can write (define-key-handler q () (return)) (define-key-handler n () (format t "~&amp;Enter new word: ") (return (life (read-line *query-io*))) I like this solution because it separates `aaaaa` and each clause. Each clause can be written in a declarative way. Separating the caller and the key-handlers is also itself beneficial because dynamically binding *alist* allows you to use the other set of key bindings. For example, consider we have an alternative association list `*alist1*`: (let ((*alist* *alist1*)) (aaaaa bbbbb)) ;; inside this dynamic environment, *alist* is ;; replaced with *alist1* Please consider.
Is there a transcript anywhere to read along with? I find it hard to pick up on everything the speakers say. I don't know the proper way to describe the phenomenon, but the audio is "echoy" or "spaced out" or "unnaturaly deep". I get used to it after a while, but it's still hard for me to make everything out.
This method sounds good, gonna take some studying though. Thanks!
Obviously not finished yet but there are definitely some good ideas there. I really like the idea of using getf for hash tables and slots
Yes. Normalizing some aspects of ... the spec ? the language ? ... Would really be all it takes. Which may break older code.. Or everything. But if it worked like GHC or Racket does when adding language extensions or modes then that could be a good compromise. Heck, even C++ has the --std arg for most compilers. No reason Lisp couldn't right?
Not in quicklisp yet.
There are two dynamic variables named \*request\* and \*response\*, alter those to alter the response and the request data.
I find that misleading, this is in no way Common Lisp for the 21st century. A bunch of new names, a different package and a really really slow way to call primitive stuff. It's fine to have generic functions in Lisp. If you use CLOS to provide interfaces to stuff like FIRST, SECOND, ... those will be really slow. No Lisp compiler optimizes CLOS calls in a useful way to make those fast. The result will be a slow language like Ruby, which has its usage. But in no way this is the Common Lisp for the 21 century. Just renaming and adding some CLOS functions on top is not a future for a general purpose Lisp. Fine to make an experiment, but please choose a grand name AFTER the result is grand - not before, when even the plan looks primitive. Sorry. 
Thank you for your reply! I have it almost figured out, but it isn't working. Here is what I tried: (progn (setf (aux-request-value 'name) name) (redirect "/add-elem")) Going into the source of the destination page, I can see my "name" info is not present on that request. (Looking at another page, which successfully receives POSTs with added info, reveals a "form value" header containing "name", so I know that I'm looking in the right place.) Do you have any further tips?
I'm currently at a lecture so I can't check up on documentation and stuff right now. I can reply in about 7 hours hehe :)
It expands to (let ((function 42)) ...) Figure the rest yourself.
Trying (function 42), gives me "FUNCTION: 42 is not a function name; try using a symbol instead". I know that #' is for functions. Looking at the hyperspec, this: http://www.lispworks.com/documentation/HyperSpec/Body/t_fn.htm kind of seems like it is what is happening/being used(?), but I don't understand what is going on. 
First you need to see what the reader creates: CL-USER 24 &gt; '(let (#'42) (+ . #'5)) (LET ((FUNCTION 42)) (+ FUNCTION 5)) or CL-USER 25 &gt; (read-from-string "(let (#'42) (+ . #'5))") (LET ((FUNCTION 42)) (+ FUNCTION 5)) Does that help? #' and . are already doing something during parsing by the reader - see above. Note though, that this is a rather useless 'tip' - one should not use this LET + #' effect in code. This use of the dot-notation is sometimes, seen, though. 
It doesn't matter what FUNCTION does, start with LET. LET creates a binding for FUNCTION, so that it evaluates to 42 inside of this LET. \#'aaa is a reader macro that expands to (function aaa) (something . (foo bar)) is the same as (something foo bar), because of how lists are constructed from cons cells.
The let assigns the value of 42 to the symbol 'function'. Is there something you don't get in the excellent explanation in the blog comments? 
It may help to understand that the reader expands reader-macros like #' and ' _even when they are not in places that are evaluated for a value_.
Ok, I got it. I thought #'x calls x, didn't realize it expands to (function x). Thanks. 
Ok, I got it. I thought #'x calls x, didn't realize it expands to (function x). Thanks. 
This actually seems like another attack on the utility problem, just cloaked differently. This is a problem the author and I worked on previously with www.quickutil.org, but it hasn't been met with much success*. I see hints of our work in this with e.g. `imaginary-i`. I don't necessarily agree with the approach of CL21. It makes the language feel closer to "scripting" languages by making as many operations as generic as possible. Everyone envisions the next version of Lisp to be different. My vision is a Lisp with more support for static typing, and parametric polymorphism. It's a shame I can't write a type-generic library that is efficient for a variety of data types. I also envision concrete support for interfaces (in the API sense) and dynamically loadable libraries. With all that said, the author disclaims himself by stating it's an experiment, just as Quickutil is. And I think that's fine. \* I'm not prepared to call it a failure yet, but the interface and implementation perhaps aren't all that good.
&gt; in no way this is the Common Lisp for the 21 century. What would that be, in your opinion?
That's a tough question. I haven't thought about that for some years. ;-) Soon after Common Lisp appeared, there were 'better' descendants developed: * EuLisp * Prefix Dylan * Infix Dylan * ISLisp All of those are interesting. There are also other languages which are influenced by CL (or parts of its eco-system) like Factor and Clojure. One question is what do you want to do with it? Common Lisp was designed to be able to implement and 'deliver' (means 'bringing into production') more or less complex applications (CAD systems, databases, Expert Systems, ...). Military was not happy that every software development group/company was bringing their own Lisp dialect with their products. But today? * Teaching? * Programming language research? * Applications? * Scripting? * Internet services? * Internet clients (browsers, ...)? * Systems programming? * GUI Desktop Apps? * GUI Mobile Apps? * Embedded software? * Secure applications? * Development tools (like Emacs, Eclipse, ...)? Maybe we like that there is already a programmable language, which does not change every other year? There were thoughts about the next generation... http://www.cliki.net/Lisp%20-%20Next%20Generation But actually I'm not so much interested in the language of the future. For me it is important to have a good Lisp on current platforms with a good integration. Maybe improving tools. Maybe better/simpler GUI programming. Good documentation. Implementations which agree a bit more on the various extensions. It is quite hard to replicate something like LispWorks, Allegro CL, SBCL or Clozure CL with a new Lisp dialect ... there was so much effort going into these. I'm willing to make some compromises for them and to accept that the language is not totally consistent. I guess I will keep using CL for some time... 
Thank you for the link, but unfortunately I can't seem to make that response code work: (progn (setf (aux-request-value 'name) name) (redirect "/add-elem" :code 307)) has no additional POST data.
I agree with your assesment, althougth maybe for equality a good compromise would be to make equalp generic, as structural equality can be 'expensive' to check already.
When you call *redirect*, you don't simply "change between pages": you send the client a response that says "Please, could you send a request to this URL?". Then the client executes itself, and receive the desired response. You can't add POST data when redirecting, because you can't add such data to a *response* : it would be like "Please, could you send a request to this URL? Oh and you'd be kind to send the following data: …" and there you have a stateful protocol. If you still want to do that, use [cookies](http://en.wikipedia.org/wiki/HTTP_cookie).
Right. If you're going to send data with a *redirect* it should probably be done either in the GET variables (ie /redirect/url?var1=val1&amp;var2=val2) or in cookie data (assuming the redirect is on the same domain). No sane HTTP client will allow you to [send POST data on a redirect](http://stackoverflow.com/questions/46582/response-redirect-with-post-instead-of-get#answer-47735). It's against the HTTP spec. It sounds like you want to load a route other than the one chosen, add data into the request, and have the new route send the response. I think this might be possible with Hunch, but not sure how this is accomplished. However, don't get this confused with a *redirect* since they are two very different things. My advice is to break out your routes you want to swap into callable functions and have the route that's adding data into the POST call the function of the route you actually want to send the response.
I asked the author about his intention and the answer was "please consider it as a glowing iron, heated for annealing. The discussion is welcome and intended, and I'm going to make an issue-thread on github for discussion." Also, he is not trying to *supersede* Common Lisp. What he do be trying is building a layer on it -- a better, well organized API, I guess. I also think the implementation and API is a different problem. His implementation is now based on CLOS and slow but it is possible to add compiler-macros for basic (cl-defined) types. Types of arguments can be obtained via &amp;environment env and variable-information (though they are defined in Cltl2). The API is getting more important because Lisp needs more people. There are bunch of flexible (but not programmable) programming languages which have better APIs, and they have 100x larger community in which programs are less often speed-intensive. What CL21 should supersede is those languages. CL may be good at speed and its metaprogramming, but there are rooms of improvement in its API. As long as ANY part of the language is worse, then it would not impress the people who like the other languages. Recently, thanks to quicklisp, the library problem is getting better (sorry zach ... I fled away from macroexpand-dammit, it was beyond me). It has now over 900 libraries, though it is incomparable to the number in clojars (8166) and python pip (39362). The other elements are the development environment and API. (According to Fukamachi, in spite of being a hacker based mainly on Emacs + SLIME, he claims there are relatively less information on Vim-based lisping. He also wrote about (Sublime-text-based lisp development)[http://blog.8arrow.org/entry/2013/12/19/183508].) I have more things I want to say here but its time to go to the lab, I may come back later.
An interesting project conceptually. Certainly one that I think has appeal from the sense of regularizing functions and their interface, something that is fairly warty today. I rather think that an overhaul of functions to have argument order normalized and naming regularized would not be the worst thing to happen for the "CL 3" effort. However, I also agree with lispm that a clos-based approach is *slow*. I have done benchmarks of DEFUN vs. DEFMETHOD, and DEFUN beat DEFMETHOD handily. So an effective generic layer over Common Lisp will have to determine how to solve this problem of speed. A thought experiement: is CLOS the right abstraction for this kind of system? One of the bright spots of Clojure is the sequence abstraction; I see that fukamachi is trying for a similar idea. That is good. I've hacked together a badly done seq system for myself and will demo it at some date. A critique I have is that threads are deferred. In a 21st century language, threads must be addressed. The memory model must be well defined and understood. The semantics of memory access and sharing drive correctness. This is much more important than function renaming. Another critique of Common Lisp is that OS and language should be more separate. This effort does not address that. I personally like C &amp; Python's approach here: a function exists, and the implementation figures out which os calls to make. That is to say, IMO the (any) language should confine itself to control and data structure primitives and atomic elements for composability, a specification should exist for dealing with the outside world, and implementations can reify the specification so that portability can happen. One thing that could be very useful would be to require the ability for macros to include lexical environments in their macroexpansions; I believe that is what is required to create tools similar to fexprs (might be wrong). Another aspect of my ideal language-of-the-future is optional contracts/typing. A macro system that wrapped defun/defmethods with a set of contracts and performed inferences on them to determine "correctness" for development-only would be quite lovely. Anyway, I guess my point is that I don't think a simple skin over Common Lisp is useful enough to supercede just using CL + some libraries. Certain fundamental improvements could be made that might dramatically improve capability. But, as it once was said, do not despise the day of small beginnings. There are some good ideas here.
There's also Termite for Gambit-C: http://code.google.com/p/termite/ which is quite nice.
&gt; though it is incomparable to the number in clojars (8166) and python pip (39362) Yeah, but 90% of those libraries are probably crap that nobody cares about. Consider that the CPAN has about 29,000 dists right now. How many of them are actually important? The top 1,000 dists are going to account for a huge percentage of CPAN usage.
If you macroexpand the macro form, you see the code which is generated. CL-USER 6 &gt; (macroexpand '(and (numberp ’fred) (oddp ’fred))) (IF (NUMBERP (QUOTE FRED)) (AND (ODDP (QUOTE FRED))) NIL) Compare that to the function call: (logical-and (numberp 'fred) (oddp 'fred)) In the case of the function call, all arguments will be evaluated before the function LOGICAL-AND will be called with the results. Since the argument evaluation causes already an error, the function won't be called.
Great point. Thanks. 
I think I understood some words :-/ :-( 
The only thing I find lacking is a good GUI library. If you can afford lisp works then its no problem of course .
Sounds like you want a route that calls other routes. Don't use a redirect. Like I said, let's say you have `/new-user` and `/decide`. You want `/new-user` to be a simple handler that just calls the function `handle-new-user` (or whatever you want to call it). `handle-new-user` will take care of processing the data and sending the response itself. In other words, the `/new-user` handler is really, really naive and just passes data to the `handle-new-user` function and stops touching the request/response after that. Now do this for *all routes that `/dispatch` is going to call* (give them a naive handler and a lisp *function* that handles the request/response). Once that's done, you set up `/dispatch` to look at your data, make the routing decision, and instead of *redirecting* to another route, it just directly calls the handler function for that request, in this case `handle-new-user`. Since `handle-new-user` sends the response itself, dispatch can dumbly pass requests to it without worrying about what response is going back. Hope this helps.
Alright, I think I see what you're saying. Up until this point, I have been using the define-easy-handler macro to make my pages, which, if I am understanding correctly, both makes a handler function and assigns it a URI/URL. To redirect to another page, then, I simply used (redirect) + the URI of the new page. Would you mind walking me through the syntax for calling the handler function directly? The documentation on http://weitz.de/hunchentoot/#define-easy-handler is a little obtuse.
Haven't used hunch in a while, but I'll try to break it down: (defun handle-new-user () "Add a new user." (let ((data (get-data-from-request-somehow))) (add-the-user) (return-response))) ;; notice here we don't *do* anything, we just call handle-new-user (define-easy-handler (new-user :uri "/new-user") () (handle-new-user)) ;; here's our dispatch function. (define-easy-handler (dispatch :uri "/dispatch") () (cond ((some-condition?) (modify-request-data) ;; call the function that the "/new-user" handler calls directly (no ;; need to go through the routing system). whatever string that is ;; returned from this function will be sent out in the response (handle-new-user)) ((some-other-condition) (do-something-else)))) 
It seems that I have to explain how the code works. First of all, your key handlers sometimes *return* ("n" (format t "~&amp;Enter new word: ") (return (life (read-line *query-io*))) and sometimes not (and continue to execute the rest of the code): ("r" (rule-change)) ("c" (recenter) (draw-board))) Therefore, when the execution encountered a *(return xxx)* in a key handler, it should immediately return the value of *xxx*. In my code, if there are no *return* in the handler, *funcall* returns normally and execute the rest of the code. However if the trap handler is invoked then the function *aaaaa* immediately returns the *value* of the condition variable. (sorry I forgot *(return-from aaaaa .....)* in the previous post.) (handler-bind ((trap (c) (return-from aaaaa (trap-value c)))) (funcall (find bbbbb *alist* :key #'car :test #'equal))) ...rest of the codes to continue....) Let's see the macro in turn. *exit* contains a gensym'ed symbol. *tagbody* and *go* have the similar effect to that of labels and *goto* in C programming language. (tagbody (signal 'trap :trap-value (block nil ,@body (go ,exit)) ,exit)) If *,@body* contains *(return X)*, it immediately returns from the *(block nil ...)*, and the block evaluates to X. The value is then passed to *(signal 'trap :trap-value X)*. The trap handler described above handles the condition. If no *return* occurrs in the block, then *(go ,exit)* is called and it jumps to the tag *,exit* . In this case, the call to *(signal ...* is skipped and no condition is signalled. Therefore the *funcall* returns normally and it allows the *...rest of the codes to continue....* part to be executed. 
just in case someone doesn't want pdfs, here's a png album http://imgur.com/a/KLFuR#0 (beware, 2bits color depth)
I would like to see packages used more aggressively while doing something like this. Eg. organizing specialized vs non-specialized versions into packages named appropriately: #'list:first vs #'vector:first vs #'seq:first 
Not without a proper HTTP redirect, which won't let you forward the POST data. If you want a client-side solution (and your market is newish browsers) you can use pushState to "fake" a URL change.
Very interesting. My prof happens to be specifying a Scheme denotational semantics in Scheme out of frustration of the current specifications. Always cool to do some archaeology and find useful nuggets from times long past :)
I impressed my interviewer by zipping around in vim (he asked me to code in front of him). That was a promising start.
Thanks to alezost from the #emacs IRC channel pointed me into the right direction with the following snippet. (defmacro macro1 (list) (cons 'progn (mapcar (lambda (elt) (list 'macro2 elt)) list))) (macroexpand '(macro1 (1 2 3))) ;; ^^^ gives this: (progn (macro2 1) (macro2 2) (macro2 3)) My problem was that I kept trying to figure out a way to include `progn` in a backquoted sexp (i.e. ``(progn ...)`). And of course I couldn't just create the list within the expression anymore if I started with that, so I thought it might need some real trickery. All those examples that started out with the backquote really got me in a limited frame of thinking. Lisp macros really are something.
You should read about quasi-quoting :)
I'm looking it up now and it seems that backquoting is just quasi-quoting. Is that right?
 easy. (defmacro my-macro (sym list) `(progn ,@(mapcar (lambda (elem) `(another-macro ,sym ,elem)) list))) 
I'm working on my own small OS, it's not anywhere near a presentable state though. I remember seeing this project on google code and assumed it was dead, I'll definitely look into it a bit more.
Pretty much but quasi-quoting is extended so instead of using cons in the previous example you could do this: `(progn ,@(mapcar ...)) Search for "barski quasi-quoting", I think that will give you a nice tutorial on it
Gah. I guess just starting to think about unevaluated lists and macroexpansions was/is confusing me a bit. But I think I'm on my way to better understanding it. I get that there's a difference between creating the code in compile-time prior to run-time. Hm. But about running it. Couldn't you just eval the list returned by the defun? I guess my ultimate question is if you can somehow still manage to get away with some macro system (minus the compile-time generation of the code) using just defuns? EDIT: http://dunsmor.com/lisp/onlisp/onlisp_15.html I'm guessing the two ways of defining the with-style block mentioned there is what you meant. Gonna try and understand now why the macro+function approach is more practical.
You Always LISP Once?
(I know.)
Here are a couple of other papers by Hart. RIP. [*AI Memo 57 - MACRO Definitions for LISP*](ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-057.pdf) [*Notes on Implementing LISP for the M-460 Computer*](http://www.softwarepreservation.org/projects/LISP/book/III_LispBook_Apr66.pdf#page=201)
Any pics of it running?
Error: Undefined Function: I, Undefined Variable: KNOW. ....I'll let myself out. 
&gt; with-style block sorry I had to describe a more bit. it only applies to (with-*** (args) &amp;body body) style macros, which bounds some variables and execute body, such as with-open-file. I found it again. It was in fare's style guide. http://google-styleguide.googlecode.com/svn/trunk/lispguide.xml?showone=Macros#Macros
I am literally laughing out loud!
I have a library of parenscript extensions that has 3 different chaining parenscript-macros (fchain, pchain, fpchain). Maybe they do what you want. See https://github.com/aarvid/arvid-parenscript-extensions
AJAX?
Websockets/AJAX/Long polling/whatever.
You could try [ht-simple-ajax](http://martin-loetzsch.de/ht-simple-ajax/) or my library, [smackjack](https://github.com/aarvid/SmackJack). Both are available in quicklisp. Both depend on hunchentoot. Both use ajax to allow a web page call a lisp function on the server and returns the result of the function to a callback function on the web page. ht-simple-ajax uses get and passes only strings. SmackJack is more flexible. It allows both get and post, choice of response format (string, xml or json). Optionally function parameters can be passed as json. Flexibility has its costs as it depends on parenscript and cl-json. SmackJack can also use long polling to do the inverse, the server can call a function on the web page.
The 'new compiler' memo describes something which sound suspiciously like tail-recursion elimination! 
I don't know how it would work with Eclipse involved, but one option is to write them in a file named my-stuff.lisp and then evaluate `(load "my-stuff.lisp")` in the REPL. I usually define a system named my-system.asd that says which systems are needed to load the project, then use `(ql:quickload "my-system")`. And I automate it with quickproject. But for simple stuff, my-stuff.lisp works fine.
If someone knows something about OpenDylan, I can contribute my knowledge of .deb packaging and walk the packager through that process.
Thanks for this! I appreciate it a lot. I just browsed it a bit. Will definitely see if there are ideas there I can use or code to copy. Not sure what the difference are between the chains (though I didn't know about those ps functions/macros -- like with-ps-gensyms), but I'll look it up and will play around with it a bit.
Not sure, it might be called Cusp. 
Thanks, did something similar to what you said and it worked!
I've dropped you a message on here about this.
The thing that is mentioned there (assuming it's the "recursive functions ... rewritten using the PROG feature") is very different than what was done in Scheme: it's limited only to recursive functions. The Scheme thing started in the neighborhood of actors, with things like code that has all functions tail-call some function instead of returning, and therefore it was needed to have all tail calls eliminated -- as a new language *feature* rather than an optimization of an occasional recursive definition. (Hence the discussions on "Tail Call Elimination" vs "Tail Call Optimization".) My guess is that the explicit mention of optimizing recursive functions is the result of following the mathematical roots of the language, where you'd prefer these kinds of definitions over explicit goto's.
I'd be up for maintaining the packages etc if I knew how.
I'm glad to see Lisp being used, but I'm not glad that it's being used for such woo-woo.
I would **highly** recommend using the [OpenBuildService](http://openbuildservice.org) for Linux packaging. It will automatically handle package creation and repository hosting for some of the biggest distributions (e.g. Debian, Ubuntu, Fedora, and even Arch). There's a public instance you can use hosted at http://build.opensuse.org.
It's completely bogus to call this a Lisp OS. It is, at best, a Lisp assember along with enough LAP code to create a 16-bit bootloader, using BIOS calls to emit some output. And the new "Ink" dialect of Lisp looks like vaporware. [The author on Hacker News](https://news.ycombinator.com/item?id=7129709) &gt; the project is only at very very initial stage, with an assembler written in Common Lisp, and a 16 bit bootloader. Currently I can only describe it as a toy. 
I think the pic would look something like "REPL&gt;"
*ps-once-only* and and *with-ps-gensyms* are the parenscript equivalent of the common-but-not-in-the-standard macros *once-only* and *with-gensyms* (see [alexandria](http://common-lisp.net/project/alexandria/draft/alexandria.html#Macro-Writing)). I wrote the following chain macros as parenscript only macros. I did not see the value in having dual common-lisp/parenscript macros. *pchain*: is a progn chain like you want. returns the value of the last call. *fchain*: is a functional chain. wraps everything in a lambda instead of a progn and returns the object of the chain. *fpchain*: is a functional progn chain. Uses progn and returns the object. has no real practical difference from *fchain*. *pchain* is used the most. I only use *fchain* when I need the object to be returned or passed to another function. I do not use *fpchain*. 
Heh. As per other posters, damn.
Any chance of a précis for non-experts?
I'm not sure what you need. You can use AJAX, or Websockets if needed. https://github.com/3b/clws is a CL websockets library that works for me. But I believe it is linux only, though. 
Dude. Would you mind chatting about that? I maintain a Lisp introduction (articulate-common-lisp) site, and I really hate that there's no decent non-emacs F/OSS solution for Lisp &amp; Cusp isn't maintained anymore. 
Once you get a decent "build this thing" script going, it's really straightforward in general, particularly if you're committed to not doing custom patches for each distro.
PM'ed you about it.
Given that Lisp has been financed by the military and the Common Lisp standard itself is financed by DARPA mostly, I find an Astrologer refreshing and amusing. Lisp has been used a lot to develop weapons and has been used in various parts of the military. Some of that has defended our freedom, some has done quite a bit harm and some of that has been gotten out of control. I would add, some of the AI stuff which Lisp has connection to, is not much different from rule-based Astrology. I always find it amusing that many technical people have little respect for pseudo science, yet much of what they do is one-dimensional and from some point of views as shameful as Astrology software, probably more. Are people developing expert systems for financial schemes more or less shameful than an Astrologer? Why is it that we give applause to quick get-rich schemes by optimizing click streams and such, but Astrology is 'superstition'. Marketing bullshit tells us these companies are innovative - but in reality they are not and they are not contributing. I'm with you to say that Astrology is pseudo science. But let's be honest , much of the 'science' around us is not much better.
I don't use SBCL very much these days, or CL for that matter. But in an era when new (and often half-baked) languages are popping up every day, it's great to see that a rich and powerful system like SBCL, with its long history, is still under active development. Congratulations to the team. (I'd love to hear more about the register-spilling optimizations. Has anyone published benchmarks?)
Nice! Got any benchmarks for that new iterative method ;)?
One of the popular software for making graph diagrams is http://www.graphviz.org/. It's rather easy to dump relationships from your data into [.dot file format](http://www.graphviz.org/pdf/dotguide.pdf) for graphviz to interpret. 
note: the article is about python, lisp is only mentioned briefly (5 times) in the comments, without giving a lot of information. ps: still cool to read this, just wish to know more details.
Here are some clojure interfaces for graphviz: [dorothy] (https://github.com/daveray/dorothy) [rhizome] (https://github.com/ztellman/rhizome) [loom] (https://github.com/aysylu/loom) .
I think the OP is specifically referring to [this](http://dwave.wordpress.com/2011/05/20/learning-to-program-the-d-wave-one-software-you-should-install-a-book-you-should-buy/#comment-21948) comment: "The main processor doesn’t run an OS in the sense you’re thinking of. The OS is written in LISP and isn’t exposed to developers at this point."
Some time ago they were hiring Lisp-experienced developers.
I think the clojure guys were working in a more featured repl. Maybe I'm confused but I kinda remember a talk about nrepl mentioning persistent sessions that were not far from an ipython notebook.
I guess that by "OS", they mean the logic to map arbitrary QUBO problems to multiple instances of the fixed-size chimera interaction graph that their hardware heuristic implements.
Persistent sessions… Like core files?
Shame it doesn't work.
Aight, from my blurry memories, nrepl would just manage text inputs, it's not a resumeable binary dump. I think this is the talk https://www.youtube.com/watch?v=sSQ1dqqINrQ&amp;t=14m00s (rewatching it right now) **update**: yes, go to minute 14 https://www.youtube.com/watch?v=sSQ1dqqINrQ&amp;t=14m00s , browser based input/output pairs. Somewhere between Scala IDE Worksheet and IPython. Page reload conserve the s-exps / user session.
Does anyone know what has become of Movitz?
You can always generate the dot file from lisp, That is how loom does [it](https://github.com/aysylu/loom/blob/master/src/loom/io.clj#L135) and how I did [it](https://github.com/PuercoPop/cl-datastructures/blob/master/src/binary-tree.lisp#L116-L145), among others.
+1
I don't think it helps to use terminology and concepts not found in the standard documentation. The weird terms must be unlearned to parse more complete references. 
And it seems very well maintained, excellent!
Do I have to write these document sources myself when I use ProjecturEd?
You could start from an empty document within the editor and add content step by step. Unfortunately you can't do that yet because the editing operations are incomplete. I'm focusing on other features instead, more on the depth of the editor.
Yes, I was initially thrown off by, and eventually irritated by, the constant references to the fictional "function symbol table" concept in particular. Especially as that name can easily give false impressions of how things are structured internally.
I agree. Also the explanation of function quote is strange. Though he did not mention *obarrays*. ;-)
Pah, what kind of new-fangled implementation uses an obarray? Oblists were good enough for our grandparents and they should be good enough for us.
That's true, I should have put "quantum annealing optimizer" or something similar instead of computer. It isn't a universal quantum computer.
Could you drop by our IRC channel, #dylan on Freenode?
&gt; Lisp is a weakly-typed language. This is completely wrong. Lisp is a lexically-scoped, dynamically-typed, *strongly*-typed language. &gt; Lisp functions and variables do have types, Again incorrect. Functions and variables don't have types (hence dynamically typed). Values have types, and they don't implicitly coerce into other types (strongly-typed). &gt; Since variables are not declared in Lisp [...] Huh? &gt; [setf] is more general since setq must have an atom as its first argument, whereas the first argument to setf can be an arbitrary l-value. Not exactly. I'm not really impressed with this primer. It's got a bizarre coding style, it's mixing up concepts in a misleading way (e.g. describing `apply` as being related in any way to `eval`). Why bother presenting an archaic form like `prog`? Why even bother mentioning `rplaca` and `replacd`, you already mentioned `setf`. No one uses the former directly. It feels like it's written by someone with just a tiny amount of Lisp experience. 
Ahh good ol' St. IGNUcius... setting an example for us all by abstaining from non-free software!
The task you've set out to do is pretty weird. Unless you make the macro [anaphoric](https://en.wikipedia.org/wiki/Anaphoric_macro), there's no way to for your code to know what level of the loop it is in (unless you happen to track that separately, but that would be pretty silly). Since it therefore makes no difference that the loops are nested, you can make due with a flat loop: (defmacro nfor (times &amp;body body) `(dotimes (,(gensym) ,(reduce #'* times)) ,@body)) The code that you've given can't be run (commas not inside a backquote), and features a weird `state` variable. That said, your attempt at a macro shows that you do not yet grasp the basics of macro writing (for example, you shouldn't think about using `eval` in this situation). [On Lisp](http://www.paulgraham.com/onlisp.html) is one of the more comprehensive guides to macro writing, so I'd suggest absorbing that. Best of luck in your learning! P.S. Formatting and indentation go a long way to making your code readable. See the Reddit formatting help for formatting, and try reading [one of the many things written about Lisp indentation](https://www.google.ca/search?q=lisp+indenting+guide).
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Anaphoric macro**](http://en.wikipedia.org/wiki/Anaphoric%20macro): --- &gt; &gt;An **anaphoric macro** is a type of [programming macro](http://en.wikipedia.org/wiki/Macro_(computer_science\)) that deliberately captures some form supplied to the macro which may be referred to by an anaphor (an expression referring to another). Anaphoric macros first appeared in [Paul Graham](http://en.wikipedia.org/wiki/Paul_Graham_(computer_programmer\))'s On Lisp and their name is a reference to [linguistic anaphora](http://en.wikipedia.org/wiki/Anaphora_(linguistics\))—the use of words as a substitute for preceding words. &gt; --- ^Interesting: [^Macro ^\(computer ^science)](http://en.wikipedia.org/wiki/Macro_\(computer_science\)) ^| [^On ^Lisp](http://en.wikipedia.org/wiki/On_Lisp) ^| [^Paul ^Graham ^\(computer ^programmer)](http://en.wikipedia.org/wiki/Paul_Graham_\(computer_programmer\)) ^| [^Hygienic ^macro](http://en.wikipedia.org/wiki/Hygienic_macro) *^\/u/ahorne ^can ^reply ^with ^'delete'. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less.* ^| [^(FAQs)](http://www.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/) ^| [^flag ^a ^glitch](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=Glitched comment report&amp;message=What seems wrong: (optional description goes here\)%0A%0A---%0A%0AReply no. 48154:%0Ahttp://www.reddit.com/r/lisp/comments/1xa2j4/code_writing/cf9koqe)
Thanks for your reply. a) I'll look into anaphoric macros. Didn't know about them. b) I hadn't noticed it, but you are correct. It seems reddit's formating ate the backquotes. There is one in the let, before the ,c and one before the loop that is being appended to r. :-/ c) The state var is just holding up to where each loop should count. d) I can't use a flat loop, cause I want to have "dimensions", for exampe x and y for the pixels of a picture. e) I definitely don't get macros yet. These toy examples are me trying to understand. I have looked into "On lisp", but I remember becoming stuck. I'll try again, and maybe ask for help here. Thanks for your encouragement. f) I did put 4 spaces in front of the code (and 8 for the first identation, and 12 for the second), but it wasn't formatted correctly :-/ 
Firstly as a style thing, my preference is to accumulate strings where possible and dump to stream in one place, then (format stream "float") becomes just "float". I'd try to encapsulate the syntactic elements of C in different functions that can be composed, such as statement, expression, block, declaration, function call, operator, reference, dereference. Capturing these general cases and then dealing with the special cases should mean less format/string wrangling. For a nasty sketch of a function call, which can take symbols like memset and int and convert them to strings: (defun c-funcall (func &amp;rest args) (setf args (c-mutate-args func args)) (format nil "~4t~(~A~)(~{~(~A~)~^, ~})" func args)) If you want memset to always have sizeof applied to its last argument, that can be added in c-mutate-args. Good luck anyway, this is just my 2 cents.
If I may: a) What you're proposing seems like new syntax - you want N nested loops to be generated, each with their own variable otherwise how is your code going to get at the values? Macros are for code generation / syntactic abstraction, rather than being a quotation away from functions, think of them as an evaluation away from functions. d) Part of the power of lisp is that almost everything is an expression that returns a value that can be composed into other expressions. DOTIMES accepts a result form that is evaluated at the end and its result is returned, it defaults to nil. NESTED-DOTIMES above doesn't accept a result form. GENSYM is used to avoid variable capture and helps implement single evaluation (really, read the macro chapter of Practical Common Lisp and then read On Lisp, they're both available free online) and should be used for things that are be generated by the macro and not referred to in the body argument. The vars are variable names the user chooses to label the values of each nested loop, they should be left alone in order for the code in the body to be able to refer to them. Macros can be a little mind bending and are easy to over-use. If in doubt, try functions. If its clearly new syntax/semantics, or you start running into the need to call EVAL, try making a macro. Sometimes I prototype macros as functions and when I'm happy either write a macro that does a little prep and calls the function, or convert the function into a macro. MACROEXPAND-1 is your friend. 
I believe you also need to have an empty line above and below the code, not only the spaces in front.
Here is a non-anaphoric version where you need to give variable names. Returning a useful value is left as an exercise (defmacro rfor (bindings &amp;body forms) (labels ((expand (btail) (unless (and (consp (car btail)) (symbolp (caar btail)) (not (null (cdar btail))) (null (cddar btail))) (error "bad binding form ~S" (car btail))) (destructuring-bind ((vn nn) . tail) btail (if (null tail) `(dotimes (,vn ,nn (values)) ,@forms) `(dotimes (,vn ,nn (values)) ,(expand tail)))))) (expand bindings)))
Ok, thanks. Test: `(this ,is code) (this is code with 3 spaces identation) This is not code. 
Indeed :-) 
&gt; Isn't a function just a quotation away from a macro, besides the "at compile time" part? Slightly different as a macro also implicitly sends its result to some compiler or evaluator. You instead use an explicit EVAL. EVAL doesn't know about the lexical environment it is executed in, so it is quite limited for this purpose. For instance, it would be impossible for you to reference any binding of the index variables via EVAL (at least to my knowledge). &gt; What do you mean a result form? DOTIMES returns an optional result. A macro that bears its name should really match its semantics. I have since figured out how to put that in... &gt; why do you make a gensym for the extent, but not for the vars? Extent is evaluated while the list of var names are not. I don't evaluate the var names as they are syntactic elements. This means that they are known at macroexpansion time. This is not true of the extents. The extents are determined at execution time, which means that I must bind the result of the extent form to avoid multiple evaluations. There is a more subtle point here, but I am having a hard time articulating it. The variable name list is pulled apart by the macro and stitched into the macroexpansion. I can do this because I know its value at macroexpansion time. The extents, on the other hand, must be treated carefully as they are the result of a form and I don't know that result when the macro function is called. This means that I cannot pull the extents apart in the macro function, I have to instead craft code that will do that at execution time.
Thank you for the code. I understood it immediately by reading it. Now I have to try to figure out why I didn't come up with something like that with the many wrong ways I tried. (Really hard, cause I have a text file littered with wrong attempts in various ways, going in diff directions.) How do you start writing something like that? At the backquoted end? (Although I was totally missing the requirement(?) to give/name vars.) 
Based on your replies to the other comments, anaphoric macros are probably not what you want. But since the other comments here do a good job of describing the more typical way of variable binding in macros, I figured I'd post an anaphoric version just to show another option. (defmacro nfor (times &amp;body body) (macrolet ((nfor* (times n body) (when (&gt; n 35) (error "nfor called with more than 36 dimensions")) (if times `(dotimes (,(intern (coerce (list (code-char (+ 65 n))) 'string)) ,(first times)) (nfor* ,(rest times) ,(1+ n) ,body)) `(progn ,@body)))) `(nfor* ,times 0 ,body))) (nfor (2 3 4) (print (+ a b c))) This macro binds successive letters of the alphabet as the indices of the nested loops, thus "saving you the trouble" of having to specify the names of the indices yourself.
&gt; For instance, it would be impossible for you to reference any binding of the index variables via EVAL Ok, that's very useful. Thanks. ..I understand the rest now. Thanks. 
a) Can't you evaluate something that was quoted, with the full use of the language? Put code in a var and then throw that var in the middle of something? (Taking care/being careful of name collisions.) d) This is over my head, but I vaguely get what you are saying. A lot of seemingly useful leads. I'll have to study these. Thank you. 
Thank you for your example. I'll have to study it, as it's over my head. Three qs though: a) It gives me the error: "EVAL: undefined function NFOR*" b) Why is this anaphoric? c) Why does it seem that anaphoric macros are not what I want? PS: Thanks for giving a usage example. It really really helps understanding the code. 
Yup you can eval a quoted form, but the more you do it and the more the code you eval depends on the current state of the computation, the harder the program is to reason about - both for you when debugging and for the compiler when optimizing. Sometimes its unavoidable such as when writing a REPL or other interactive environment, but over the years the best practice came to be, as a rule of thumb, to restrict code generation to compile time, which is what macros do. Yeah I'm probably not understanding precisely what you're doing, but in partially implementing my idea while relaxing this afternoon, I found that MACROLET doesn't work for this purpose but FLET does: (defmacro anafor (ranges &amp;body body) (let* ((gensyms (loop for range in ranges collect (gensym))) (result `((flet ((pos () (list ,@gensyms))) ,@body)))) (loop for range in (reverse ranges) for gensym in gensyms do (setf result `((loop for ,gensym below ,range do ,@result)))) (car result))) CL-USER&gt; (anafor (2 2 2) (format t "~A~%" (pos))) (0 0 0) (1 0 0) (0 1 0) (1 1 0) (0 0 1) (1 0 1) (0 1 1) (1 1 1) NIL Disclaimer: this code guaranteed to disappoint if used in earnest.
Thank you for giving me a specific code example. This will make me understand. ..Is pos kind of "exposing an api"? I am not totally sure why it buys me what I think it does (calling anafor just with the values, and not having to put symbols for the vars(?)). Why not do something like this: When you call anafor, instead of "pos", write eg something like (1 2 3). That would be interpreted by the macro as "variable positioning". For example: (myMacroApplyCode (10 20 30) (/ 1)) would return 1/20. ie the 1 in the body/code part, is interpreted as an index to the data part. (That should somehow be codified so that the macro knows when I'm passing an index or an actual number. eg (/ (isInputDataIndex)1 (actualNumberToDivide)2) ). I am not sure why at the end you take the car of the result. (The cdr gives nil, and just result gives an error from eval that this is not a function name.) ..Btw, I think the loop for range, shouldn't be on reverse.
Oops. Yes, that macro certainly doesn't work. It does give some insight into my (faulty) thinking when I made it. I started out constructing `nfor` as two separate `defmacro` forms: `nfor`, and its helper `nfor*`. They looked like this (and this code works): (defmacro nfor* (times n body) (when (&gt; n 35) (error "nfor called with more than 36 dimensions")) (if times `(dotimes (,(intern (coerce (list (code-char (+ 65 n))) 'string)) ,(first times)) (nfor* ,(rest times) ,(1+ n) ,body)) `(progn ,@body))) (defmacro nfor (times &amp;body body) `(nfor* ,times 0 ,body)) I then decided to package them all together in one top-level form by using `macrolet`. In non-macro code this kind of factoring would work fine, but since the form that calls `nfor*` was not actually "made" until after macro expansion, it never had a chance to capture `nfor*`. This version of `nfor` is anaphoric because it introduces variables into its scope that its user does not explicitly ask for. That is, you do not have to specify something like: (nfor ((a 2) (b 3) (c 4)) (print (+ a b c))) Because it is understood that this `nfor` creates its own variables to represent the loop indices, starting from `a`. I had only brought up the use of anaphoric macros because your post did not make it obvious that you had planned on introducing variable binding to `nfor`. You clarified in one of your comment responses that this is what you were planning on doing, though. That is the "normal" way of doing things, and it is normal for a reason: It is generally a good idea. The down-side of anaphoric macros is that it is non-obvious where the variables came from, and they don't let you customize the variables that they create. These disadvantages make them of somewhat limited use - you tend to end up sacrificing readability for a slight convenience.
Dan Lentz, Consultant/Software Developer writes on Linkedin &gt; My common-lisp implementation of a very interesting lock-free concurrent index structure proposed by Phil Bagwell and Martin Odersky. It is a fairly new data structure related to Clojure's more familiar Hash Array Mapped Trie (HAMT) but innovates some new concurrency characteristics unique to this data-structure. For example, it introduces a "restricted RDCSS" concurrency technique called "generational CAS" which achieves a significant subset of the capability for which one otherwise might have needed MCAS, but using only the single-word compare and swap operation that is widely available on inexpensive consumer hardware and far more efficient than software-based MCAS alternatives. Also, the storage space consumed by a ctrie always remains proportional to the number of nodes it contains; this means it always remains extremely efficient, regardless of the sequence of insertions and deletions that may occur. &gt; More information on the ctrie data structure may be found on Wikipedia: http://en.wikipedia.com/wiki/Ctrie &gt; My project includes implementation of the basic Ctrie data structure based on a well-defined protocol of generic functions that serves as the abstraction by means of which to support a variety of back-end storage models and the ability to easily extend support to new ones. Currently these include a memory-mapped persistent storage backend based on a meta-level MOP based abstraction of memory-mapped-class, also, another persistent storage backend based on a 64 bit tagged-memory VM heap with mark-and-sweep collector, and several different implementations for memory-only (non-persistent) options to support fast performance capability for use-case of transient ephemeral data models. &gt; One goal of this project is to develop an index structure that is well suited to concurrent access and contention and, in particular, the demands associated with graph database platforms. Documentation is slightly dated (still based on the prior release) and work is ongoing, of course. If you are interested in my progress, please have a look! The project is on github: https://github.com/danlentz/cl-ctrie 
Yes I put the pos function in there to provide a way to get at the state of the nested iterations while clobbering a minimum of the namespace that can be used in the body of the macro. It may be nicer to allow the user of the macro to choose the name of the function, and faster to allow them to choose the names of the variables as in other examples in this discussion so that a function call is not necessary inside the nested loops. In the myMacroApplyCode example you've given, if digits are to be interpreted as indexes into the iteration state, then you'll have trouble doing arithmetic in the body and almost certainly trouble reading this code in 6 months time. Because I'm splicing expressions with ,@ it helps to have an additional list wrapping them; the last car unwraps the result. It feels like a kludge when I do this but it works well; I'd be interested in learning a better idiom. I did mean to reverse the order of the loops, but forgot to reverse the order that pos returns them. Or one could reverse neither. Anyway, just a sketch. Good luck!
Looks like plain old *Courier*.
Reminds me of John McCarthy's lament at the W3C's choice of SGML as the basis for HTML. An environment where the markup, styling and scripting is all s-expression based would be nice. What is the evaluator for alpha++, an implementation of CL, scheme or is it something all its own? Something like Parenscript would make sense for converting to Javascript for client-side evaluation.
So... What are the three down votes for?
FUCK NO! Holy shit that looks fucking idiotic.
Change can be challenging. I hope this project is fruitful, or at the very least that lessons are learned, and that "don't try to improve things" is not among them.
Three links to the same project in twenty days, it looks like an agressive ad campaign.
Extending COERCE is nice. Collecting + doeach seems nice. The Reader macro for regex seems kind of unnecessary... Just set CL-PPCRE to a default library or something instead? Generic functions instead of separate functions is okay but the separate functions still should exist because it tells a lot of type info about the structures used to the compiler and the programmer.
It is possible for something to naturally catch peoples' interest. One link per week is not aggressive.
It looks like how most rubyists would choose to rename core functions. I mean, a name is a name. CL could use some marketing
I guess I've arrived as a curmudgeonly old Lisper, but I can't help but say "Just learn Common Lisp, friends. The Hyperspec is right there, read it and then program in the language." If you have enough time to care about whether or not you can denote a hash table with curly braces or with a regular function call, then you might not have an interesting enough problem to solve in front of you. 
Things I like: * syntax for hashes and regexps * simplified hash handling * the idea of using #' also for anonymous functions and function composition. What I do not like: * interpolated strings by default, this is just evil * overriding the syntax for immediate arrays, making them adjustable with evaluated arguments by default, with no apparent way to revert to the standard behavior. Undecided on: * generic extensible sequences. I think it is a good idea, but others thought so too and this is yet another API doing the same thing. I would actually prefer something along the lines of Christophe Rodes' "User Extensible Sequences" (why are they not a CDR?) with more support for immutable collections. Overall I think this proposal is very much geared to a dynamic type of programming while unfortunately getting in the way if a more static, performance orientated approach is needed. 
I don't write web applications on cl, but I suppose those who do would more often write regexps. Also, #/ was a free slot in the readtable. So I don't really bother.
I haven't had much luck using search engines to find existing answers to Common Lisp questions. I've had much better luck throwing questions out via mailing lists, IRC, usenet, or twitter. Reddit and StackOverflow often have responsive people who will provide support. This works best if the task is common enough (and e.g. getting hunchentoot running on threaded SBCL on OS X is not that uncommon). If the task is less common (and I think using vim and slimv qualifies), you may have to work harder to find the people who can help you, or you may have to start a group yourself and try to gather people to provide mutual support. Passively searching for answers, for whatever reason, just doesn't seem to be that fruitful for Common Lisp. Maybe it will help as more questions are asked publicly and the answers recorded. But sometimes the questions are highly specific to the person learning, and half the skill of answering them is understanding what's really going on. For example the question might be "How do I remove the double quotes from a string?" or "How do I remove parentheses from a nested list?" or "Why does my macro return something with :: in it?" or "How do I compile a program?" and the answers aren't exactly related to the questions at all, but related to understanding deeper properties of the system. But anyway, it may help to find people who use Common Lisp and who can guide you along as questions come up. I like to help, so feel free to contact me if you get stuck on something.
Agreed that Interpolated strings by default is terribly evil. If you want to replace format with something that has string interpolation, be my guest, but opt-out interpolation of strings is nothing but a source of bugs. 
Have you tried [Aquamacs](http://aquamacs.org/)? It's the path of least resistance for Emacs on OS X.
I didn't see much there that is all that interesting. Most of these things are just very light syntactic adjustment that most people (myself included) have long since done for themselves, if they needed it. Writing this sort of stuff is already trivial due to the nature of CL.
**1) Getting CL to run** On Mac OS X I would use Clozure CL (or, better and more expensive, LispWorks). When I was learning Lisp at the University, decades ago, we had a full site license of Allegro CL. Every student had access to one of the most advanced development tools: good error messages, good debugging tools, compiler, ... To me it is important that students&amp;learners have access to these tools. Fortunately nowadays free/no-cost systems are also quite good. The need to choose an implementation is not going away. Use the typical approach (which Linux distro, which Hifi amplifier, which school for the daughter?): evaluate the options and ask others for advice. **2) Editing and running CL code.** That's a tough one. I'm personally not the biggest fan of SLIME and GNU Emacs, but it works well and provides many of the necessary features for Lisp hacking. It's just easier for a bunch of Lisp people to develop a good editor support, if the editor itself is written in Lisp and might already support some Lisp development. Convincing Lisp users to use Eclipse, Netbeans, IntelliJ, ... etc. is tough, because the tools were not written with Lisp users in mind. It's difficult to get a critical mass. It has been tried. You can see that even with a Lisp dialect like Clojure, which targets Java and/or JVM users - most of them are are using GNU Emacs for some reason. Again, on the Mac I edit code in LispWorks or in Clozure CL - which bring their own variant of Emacs written in Common Lisp. **3) Debugging and troubleshooting.** I find that for many basic and complex Lisp debugging problems SBCL is an extremely good choice. You might want to expand on the problems you have with debugging. Reddit is a good place to ask. There were dedicated forums and dedicated IRC channels for newbies, but those seem to be less active - while there is more activity here on Reddit or on Stackoverflow.com . **Some more advice** In my experience also many people will not 'get' Lisp. The hurdles are S-Expressions, Functional Programming, Meta Programming (Lisp in Lisp, Evaluation, Macros, ) and interactive development (especially with poor and/or the wrong tools). It might be useful to get more training on these topics, if there are problems. My advice for beginners: connect with other users (Reddit, Stackoverflow, ...). Let them help you over the initial hurdles. Once you feel comfortable with the tools: write code. Rewrite code. Write more code. Rewrite more code. Repeat. 
&gt; 95% of the developers I know aren't going to learn Emacs. This just breaks my heart. I can't imagine 95% percent of **anybody** being unwilling to learn something new, let alone programmers that are supposed to be looking for new ways of approaching things. I'm glad that you have received help from the community. I first started trying to learn CL years ago with a text that I found in the school library. It turned out that there was an error in one of the examples of macro quoting and I struggled for days trying to figure out what was going on before asking on comp.lang.lisp. Within a few hours I had received a dozen annotated examples correcting my mistake and really giving me a much deeper understanding of what I was doing.
But if everyone is doing this it would be quite useful to have a standard, no? I doubt that the way you've done it looks the same as the way I've done it, so we will waste time when comparing code.
About editors - you don't need to learn all emacs, basic open/save, undo, select and paredit. I understand that it's added burden, but in a team effort, with someone knowledgeable around, it won't weight much and distract from the semantics and idioms of lisp. - subjective: I consider s-exp a major trait of Lisp, I wouldn't wanna learn lisp without this, and writing/editing code with paredit is something I wish everyone to experience. my 2 cents
As a new Lisper - still in the first third of PCL - coming from Python, Lisp seems really great, but also overly large in too many places. I want that largeness to remain, because it feels like it allows me to describe things down to any level of granularity, but it also means that I have a lot of typing and things to hold in my head to do really simple things. I forget which part of PCL it was now, but it described out this big thing, and I thought "What on earth is it doing here?" and then realized after slowly picking my way through it that the equivalent in Python was a few words that made perfect sense. Then it said "That's a lot type. Don't worry, we can do this," and it was still really huge. It did that a few more times, and the end result was still many times larger than the Python equivalent. It makes it difficult to sell a lot of us younger [at least to the language] folks, when we start to think "Oh, forget it. I'd be done already in Python." To me, the less I have to type, the more I can hold in my head, the more connections I can make, and the deeper and more powerful the system I'm able to write. I can think really far through a system in Python. I feel like I'm spending as much effort for whole modules I've written just in understanding and holding in my head a small bit of recursive work with a LOOP. Lispers seem to roll their own tiny helpers all the time, but if the language included a bunch, I think that would also be really nice. I reserve the right to change my mind on the above as I grow into an old, curmudgeonly Lisper :)
&gt; 95% of the developers I know aren't going to learn Emacs. Yet they've presumably learned other systems. 
Well to be frank, what is on the left side (the so called 'modernized') isn't even objectively better. I'm not going to agree to standardize something when I don't really see the point.
Well, I applaud your perseverance and from personal experience understand the difficulty of the goals you have already achieved and the magnitude of the challenges on the road ahead. I also found learning CL to be (shockingly) difficult, unlike learning any other programming language. Having started programming at age 8, college at 13, and grad study at 18, I sat down one morning to learn common-lisp with the naïve expectation that I would probably have a significant portion of my first project completed by noon. I remember, at midnight, when I still hadn't even figured out how pathnames worked or how to declare a package or even conveniently compile and run my code, thinking "this had to be a fluke; I'm sure by tomorrow it will all be clear..." Well, the embarrassing truth is that it was probably two years later until felt like I achieved a reasonably satisfactory level of productivity with CL and probably another two before I felt like I was actually starting to get good at it. I'm not sure how common my experience is -- most common-lispers I have encountered tend to be brilliant enough that I suspect they must have probably been able to pick it up much more quickly than I. By far, the best approach I can suggest (much more than reading books) is to read every bit of CL source code you can get your hands on. I have stacks and stacks some 4ft high of printouts (8pt font, 2-up landscape orientation) and have evolved a technique of printing and binding each project into its own volume, printed in the order of compilation starting with the .asd system definition file. I use a very thick, stiff cardboard for backing and polyurethane cover, with professional grade tape on the spine, which I label with the library name and version. I often enjoy referring back to these and have derived a great deal of pleasure from reading the work of those more skilled than myself and committing approaches and idioms that I find particularly beautiful to memory -- for such time as I encounter a similar situation in my own work. Actually, my facility for printing is automated and included as an asdf operation extension in my repository http://github.com/danlentz/cldoc By means of encouragement, let me just add that the satisfaction and joy I have accrued as a result of my commitment to study common-lisp has been worth many times the effort I have invested in its study. I hope you find your effort to yield the same.
There's some great stuff in this - especially the hash &amp; regex syntaxes. Does anyone understand the feature "Organize symbols into several packages"? I'd love to see CL with a Python-like package system. I.e., file-scope. This plus a package management that learns lessons from npm / bundler / pip would be a huge boost to the community, IMO.
Oh fucking whatever man. Really? You spend all of your time on a few line items that are little more than nuisance instead of use and marvel at the beauty of the whole? What the fuck is wrong with you? Jesus f christ, what fucking language doesn't have shit that is stupid / wrong / crufty / whatever. Stop complainin and keep codin. 
It's a shame that Lisp isn't more widely used. Languages like Python and Ruby are eating Lisp's lunch because they give beginners and experts a way to express extremely common idioms efficiently and readably. The problem with "just read the hyperspec and write your own curly-brace reader" is that this excludes a huge community of programmers. There's a reason CL is less popular than F#. Lisp is stuck in the past, IMO, and it's a huge loss to the wider programming community. 
I was thinking lately that I should print and bind some source code. Do you have a PDF or something similar which shows the output of your CLDOC?
I'm a step ahead of you :) as soon as I wrote that I created a repo on github and I will reddit a link to it as soon as I am done. If you wouldn't mind, though, I'm doing this from my iPad while on the train. Although it is simple cut and paste if you wouldn't mind testing it to verify I'd appreciate as I'm not certain when I will be able to get a slime/emacs.
sure
Ok have a look. Hope the CL compiler in my brain is working and it works without issue on the first try :)
I actually like the way Common Lisp packages aren't scoped per file, because IMHO an unrestricted tree structure like filesystems is not a good way for humans to store data/code. I would prefer something more human-friendly, like an object system with type definitions and named properties.
Using macros you can make your code as concise as you want, where you want. Just give it some time. I am a CL user who also uses Python, and I feel the same about python that you feel about lisp.
In several implementations ASDF is not used in CL-USER. These implementations might have their own DEFSYSTEM. Clozure CL: CL-USER&gt; 'asdf:defsystem ASDF/DEFSYSTEM:DEFSYSTEM CL-USER&gt; 'defsystem DEFSYSTEM I've used Clozure CL for testing.
Changes committed. Hope that resolves the issues. Glad to fix if you email, or even add you to the project if you like. Good question re: ps files. Let me venture two guesses, one or both of which might be correct. - there might be some way to define a printer on your system that outputs to PDF rather than a physical printer. Macs do this I believe. You might possibly do the same on Linux through the process of installing Ghostscript and configuring a print queue for it. If you can do that I'll add a slot to print-op to specify DESTINATION. - there might be an option to enscript for this. It could easily be added as another slot to print-op "file name" or some-such although I dislike having keyword arguments that conflict with others or only make sense in certain contexts... Hey actually I can dispatch on destination if it's nil use the default print queue, if it's a string use that print queue, or ifs a pathname save to file. This actually sounds reasonable -- I think I've answered my own question. Let me know what you think and I'll be happy to make it so. 
Got it. See comment below it should be fixed now.
Personally I found Homebrew to be the best way to install sbcl on a mac. getting a current version of postgresql to work was actually more difficult because I had to overwrite the old version that Apple provided. On emacs, What environment are you used to? I just bit the bullet and learned the basics (it really doesn't take that much time unless you start customizing it). Emacs + paredit + slime + quicklisp make a really convenient editor. On debugging and troubleshooting, have you tried lispforum.com? The people there helped me over a couple of rough spots and I just decided to read through most of the threads and learned a lot. I also found the people on IRC helpful so long as you don't start by criticizing. Is there something in particular you would like to see covered in a tutorial on debugging and troubleshooting in sbcl?
You can install Quicklisp in more than one location. The default is in ~/quicklisp/, but you could copy it somewhere else, or use the :path option during installation, to have multiple locations. There is no automatic way to check out a project (and some projects aren't available for checkout even if there was an automatic way), but if you know where to get a project, unpacking it or checking it out in ~/quicklisp/local-projects will make Quicklisp load it in preference to what Quicklisp provides directly; replace ~/quicklisp with your quicklisp directory as needed. Quicklisp does not update itself automatically. If you come back to a project a month later, the Quicklisp libraries will be the same as when you left them. If you evaluate `(ql:update-dist "quicklisp")` you may get new libraries. There is some infrastructure in place to mix and match versions of libraries in Quicklisp (there's a way to have multiple dists installed, and set which libraries have priority over each other from each), but there's no real easy interface to it. I'd like to make it better. Things only get better when people make them better.
I really agree with you. I was a beginner in high school, got interested in common lisp shortly after my first programming class. I downloaded the sbcl interpreter for windows and played around. Read a lot of online tutorials, especially PCL. Yet I agree, some parts were very difficult, especially for people who may not be very experienced with installing libraries or programming in general. For instance, I never really understood how to use many Lisp libraries. I ended up using quicklisp for a lot of things, but was never certain of how to really install things and I still think I may be loading my libraries the wrong way. I also have had a hard time installing some things on windows such as commonqt, I made a post on here a while ago and I'm still trying to debug the installation process and even make out what is going wrong (I am trying to follow the instructions that were given as replies to my post). Just looking at the replies, though, it appears that it is not an easy process even if it goes smoothly - you need to go so far as to install visual basic and compile the source of commonqt yourself, stuff that can be really intimidating to a novice programmer. Compare this with python, where most libraries come as a binary that you double-click to install. If only lisp had something similar, it would be much easier to deal with for beginners. One last thing - I'm lucky to be one of those who actually uses emacs for everything. But there is no need to use emacs for Lisp. You can edit your code with any text editor (sublime, notepad++) and then load it into the interpreter, which is not that hard for beginners. Though I agree that having an IDE (that isn't emacs) would certainly help. I myself am too much of a beginner to contribute to this effort, I think - but I think part of the problem is that the Lisp community is much smaller than that of more popular languages like python and java, which feeds into a vicious cycle because it means there are less people to support beginners. I think the community of lisp experts could really help lisp become more popular if they put a focus on building tools to make lisp more accessible to beginners, keeping in mind that many of these are people who have never used linux or a command line before and may not know what the word "compile" means. 
I'd like to add one more thing - perhaps it would be helpful if the mods here or some of them created a learnlisp subreddit much like learnprogramming, learnjava, learnpython that's geared towards getting people interested in lisp and helping them with beginner questions. It might be a good idea and could really help revive the community. And one other thing I noticed is that it's not obvious how to use Lisp to write useful programs, immediately. Maybe it is just me being stupid, but I don't know of any game libraries or graphics libraries for lisp that are easily installed and used... 
First, release management is hard. Second, it's really important for serious use. I don't have the bandwidth to work on it right now. Wish I did. It's worth having a good solution. Third, Fare and Xach are the people who understand the guts of these systems the most. Xach's answer is good for your own personal fork.
&gt; And one other thing I noticed is that it's not obvious how to use Lisp to write useful programs, immediately. Maybe it is just me being stupid, but I don't know of any game libraries or graphics libraries for lisp that are easily installed and used... I think most of the Lisp users are not in the gamer demographic. Speaking for myself, I don't think games are particularly useful (I recognize the sexiness of 3d graphics, I just don't care anymore outside of the computer science problems they present (trees, data slinging, etc)). ;) David O'toole has done some games in CL. There's also libsdl. I've never bothered getting it going. I've had some success with cl-cairo2 for rendering graphs.
Looking at building a new skin over Common Lisp is a good idea - better than a new and incompatible Lisp. Further, Eitarow Fukamachi has done a lot of work in Lisp and has produced a variety of useful things. He deserves respect for his work, even if you disagree with it.
I think you are right. I guess I should have said this instead: What are some cool projects that you can make in Lisp that would interest a beginner programmer? The answer to this question was never clear to me as a beginner. I guess I just stuck with it cuz I liked recursion and the elegance of the language... but I personally did not find many practical uses for it. (Not to say there aren't any, of course there are, I just mean as a beginner it was not obvious to me what I could do with this language)
My remarks. * string interpolation = not by default, please. * yes to easy hash usage. it's a very effective approach * nice work on coerce * not convinced on the loop facilities. Maybe use &amp; improve ITERATE? * regexes are improved, but still eh. Perhaps more Perly inspiration needed? * Absolutely agreed that elt/nth/aref should be abstracted (other examples available). Performance is going to be an issue if CLOS is used for everything. I will examine this at leisure later and file issues. Finally, when someone who has used Common Lisp intensively for a while wants to take a spin at revamping it, I believe it's worth honestly working with them for a bit to explore what improvements could be done. After a few iterations on this sort of project by different people, perhaps we can have a viable set of CDRs aimed at a more clean Common Lisp. 
Preprocessing? No -- what are you thinking might be useful in that regard? I basically rely on enscript (which itself has a mind numbing legion of options) but am open to suggestions (including additional enscript parameters that might serve as useful to support).
I haven't seen it mentioned but another fantastic resource is the #lisp channel on freenode IRC. It's a bit nondeterministic in that there's no telling who might be logged in and paying attention at any given moment, but many times I have found quite expert assistance with a degree of instant gratification you can't get from email or other fora. :) 
It's surprising that you did not start to get ideas about practical applications of common-lisp from "Practical Common Lisp".
I don't know that there's enough usage to warrant fragmenting the subreddit.
&gt;This just breaks my heart. I can't imagine 95% percent of **anybody** being unwilling to learn something new They *are* willing to learn something new -- Common Lisp. I worry you're intentionally constructing a strawman here.
That's a hard question to answer for any language, right? The really awesome stuff takes months to do, because it's hard and Thinking Is Required(tm). For Lisp, I would argue that some kind of function definition/creation/evaluation on the fly is probably the starting point for 'hey, this is awesome'. Along with some sort of macroology. Other awesomeness is the high speed interactive development with SLIME/emacs. 
But my point isn't "read the hyperspec and write your own curly brace reader." It is "read the hyperspec and DON'T write your own curly brace reader." A curly brace reader is a silly trick. It has little to no bearing on what you will and will not get done at the end of the day. Some of the other features in the library are of more obvious value (generic accessors, for instance) and I have no problem with libraries that recognize that there is a need for such things and fill it. But I don't think their absence represents an existential threat to Common Lisp. Peculiarly, I'm much more open to projects which create entire new Lisp dialects, because I think the underlying issues with Common Lisp are too big to be solved by a handful of new features.
Well, I think people are sort of mislead by the flexibility of Common Lisp to the conclusion that things will always be short and succinct in the language. In my opinion, succinctness is not one of the major benefits of Common Lisp in particular. The major benefit of Common Lisp is that most implementations, SBCL and the commercial ones, for instance, are really industrial strength programming platforms which give you enormous freedom and power. For instance, one can declare that variables in Common Lisp have dynamic extent, which allows the compiler to stack allocate them, which can enormously improve performance in tight loops. Can you do that in Python? Does the idiom make sense? Despite a superficial resemblance to contemporary dynamic languages, Common Lisp is its own magical beast and should be approached as such. It isn't here to make programs _short_. It is here to let you program with a high level of control over the entire process of programming.
Your extremely juvenile comment has made me realize that my original comment was pretty juvenile too. Thanks for holding up the mirror!
As a newcomer to lisp and to diving into programming as well (I've dabbled with bash scripts, some recipe-type python scripts) I have to agree that SBCL is quite friendly, especially compared to CLISP. CLISP error messages were horrible, giving me only the error and not the where it's happening (if I got "a proper list should not terminate in 2" or whatever, I have to comb through the program looking for everything that receives a list). The SBCL backtrace on the other hand gives me the function call which produced the error, which makes things much better. SBCL is also stricter about omissions (eg will complain about `(loop for i do ...)` where CLISP is perfectly happy with it), which certainly isn't a bad thing. Learning emacs: I think the learning curve on that one was shallower than vim, at least for normal use. Aside from the "standard" keyboard shortcuts not working (C-x, C-c, C-v, C-z, etc) it works pretty much the same as other editors. I only know how to kill/yank lines and regions, open/save/switch/compile/load buffers, compile sexps, and *that's all I need to know*. I'm sure there are other things that would be really helpful like being able to navigate by sexp but I'm happy enough to have an integrated REPL (this is huge) and be able to do those basics.
This seems to me as if it might be an interesting platform for literate programming. So perhaps adding support for that might be an idea for further work.
I hear ya. It could always be better sure. My experience was that before Zachs Quicklisp, working with ASDF was really difficult. Now, everything is just incremental learning. As well, things are getting better incrementally as well. Zach started off with a few hundred libraries and projects in QL. Six months ago or so he had over 900+. People USED to complain about there being no libraries for Common Lisp, now because of this amazing quicklisp thing there more than I will ever really have time to test. Other tools will come along too. It's just a matter of time. My only hope is that as the popularity of the language increases that we don't get people polluting the language with syntatic idioms and bad ideas from other languages. It would be nice to keep things 'lispy'. One of the best things to do when you hit a wall, if you have the opportunity, is to walk away for a while. Take some time to see if you miss programming in Lisp. Given all of the complaints you posted, walk away and see if can actually stay away. My bet is you won't be able to resist and you will really start to enjoy emacs and sbcl and slime and etc.
Thanks for being cool about it.
Thank you. 
Despite my username I think programmers can have a lot of fun being productive using a lot of different editors and environments. My only point (lisp and editors aside), is that it would be a shame to think that 95% of *any* population would be unwilling to learn something new.
Hey, if I can dish it, I can take it.
How are you loading libraries? Normally, from the repl, I type (ql:quickload "insert-library-name-of-choice") If it is a new library to me, then I might load (ql:quickload "manifest") (manifest:start) and that will load a little webserver that shows you the documentation for every library currently loaded in your lisp image. Manifest will give you a port address, then point your browser at: localhost:83946 or whatever port number manifest gave you when it started
Thanks again. Last night I found this PDF (http://jcsu.jesus.cam.ac.uk/~csr21/papers/features.pdf) which seem like the proposal of the technique to CL. It made some things clearer but It never have occured to me to use (progn ...) at this point. I guess these things come with experience....
&gt; A curly brace reader is a silly trick. It has little to no bearing on what you will and will not get done at the end of the day. I strongly disagree. Programs are meant for reading as much as writing. There's a reason that JSON has experienced such widespread adoption, and sidelined XML: it enables programmers to easily visualize complex data structures. Hashtables, I think you'll agree, are a fundamental data structure, and all modern languages now offer a syntax for expressing operations on them efficiently. Not having access to syntactic representations of fundamental data structures causes potential new recruits to Lisp to roll their eyes and go with the flow of languages like Python and Ruby. Lisp (and Lispers) are constantly mocked in production software environments because of these archaic aspects of the language. &gt; Peculiarly, I'm much more open to projects which create entire new Lisp dialects, because I think the underlying issues with Common Lisp are too big to be solved by a handful of new features. Yes, CL has so many awful warts. The problem with brand new Lisp dialects is that they invariably are missing the libraries required to attract a new community, and get lost in the noise of the ever expanding set of failed Lisp dialects. Clojure seems to be gaining steam because it has access to the vast trove of Java packages. What we need is a Matz-like figure to build the new language, most of the core libraries, an excellent package system (like nom), and provide a way to solve some hard problem that lots of people care about (e.g., concurrency)- then, we'll be off to the races.
I work in a production environment using Common Lisp and I've never felt the need for curly braces for hash tables, nor do we routinely mock the language for production uses. I simply don't see the problem denoting hash tables with s-expressions. It is literally a triviality. 
You don't feel that way, but most of the rest of the programming community does, and they're voting with their feet. Millions of programmers write code which provides JSON responses for web APIs. In modern languages, they write something like this: {user: {id: user_id, name: user_full_name }, recent_location: { latitude:location1.lat, longitude: location1.long, name: location.name } } In an instant, another programmer can scan this and make sense of what is happening. Now, consider what that this becomes in CL. (let ((h (make-hash-table)) (user (make-hash-table)) (loc (make-hash-table))) (setf (gethash loc :latitude) (getf location :lat)) (setf (gethash loc :longitude) (getf location :long)) (setf (gethash user :id) user-id) (setf (gethash user :name) user-full-name)) (setf (gethash h :user) user) (setf (gethash h :last_location) loc)) For all of Lisp's power, that is a comical, unreadable mess. 
I see I'm somewhat spoiled by the ease of searching for solutions with other languages. Thanks for the tip on being proactive about finding help. On mailing lists, I recently found this link: http://dir.gmane.org/search.php?match=gmane.lisp. Are these the ones to use? Thanks, Xach!
I think #2 would have helped me to just start learning LISP right away, instead of dealing with the new environment at the same time. I'm good on environment now, and love Slimv, but it would have been good to push off using that for a bit. My friends, who've I've been gushing about LISP to, don't want to learn Emacs or Vim because they are so good at other editors that they can't imagine returning to what feels like the beginning for them.
Yes, they might be willing to learn LISP. But LISP and another weird editor at the same time? Not as likely.
No, it's this: `((:user ((:id ,user-id) (:name ,user-full-name))) (:recent-location (:latitude ,location1.lat :longitude ,location1.long :name ,location.name)))
Great! Yes, this is definitely along the lines of what I was looking for a few months ago. It it on Cliki.net?
I basically gave up on editing on my Mac, and installed SBCL on a Linode, a much easier process. I just edit remotely now using a screen session, which works out better all around, since I use Vim on the Linode as well.
I think a simple website is the ideal project for a beginner. It is great to see your work on the web, even if it is just a blog or something. I have also been using http://projecteuler.net/, although as the math gets harder, I get less interested. A projecteuler for web applications would be more interesting and helpful.
Thanks. My intention wasn't to complain, however, but to give the community an idea of what beginners might feel as they learn LISP.
I don't mind a curlybracey syntax for hashes, but I it absolutely is not needed, and is the wrong tool for this particular job. A read-syntax should not evaluate it's arguments, and should construct the object at read-time in general: (let ((foo 42)) (gethash #{:foo foo} :foo)) ; =&gt; FOO or 42? FOO would be more consistent. ;; Consider (aref #(foo bar quux) 1) =&gt; BAR (Though I might be amenable to persuasion that non-dispatch syntax ie. {:foo ...} could expand into something that generates the object when evaluated instead of at read-time.) For your case: (defun hash (&amp;rest content) (alexandria:plist-hash-table content)) (hash :user (hash :id user-id :name user-full-name) :recent-location (hash :latitude (lat location1) :longitude (long location1) :name (name location1))) 
I want to applaud the fact that this is written as a library, and carries a minimal MIT licence. This is the way to do it. MUCH kudos. I haven't look at the thing itself beyond examples, and re. those my feelings are mixed. Some things look nice (coerce, getf -- assuming it does gethash-style multiple return values), string interpolation looks bad, others I'm indiffent to. Ok, I just peeked at the README. My biggest gripe (aside from string interpolation) is on the #() and #{} syntaxes. IMO they should idiomatically construct their objects at read-time, as (read-from-string "#(foo bar quux)") =&gt; #(FOO BAR QUUX) does now. I see the motivation for the evaluation time behaviour and overloading, but I think [] and {} would be better candidates for that. I also STRONGLY recommend against re-writing stuff in the standard readtable. Have the user say: (cl21:use-extensions :cl21) and make that also set the \*READTABLE\* at load/compile-time. Right now -- unless I'm missing something -- loading CL21 is going to break an awful lot of things in a manner that is not immediately obvious. [1 2 3] =&gt; (make-array 3 :adjustable t :initial-contents (list 1 2 3)) I would be much happier with. (Though I suspect I'm fine with #' hijacking, except PLEASE not in the standard readtable.) I don't like PUSH and POP on vectors as they naturally will operate on the end instead of the start, and mutate the object instead of the place. I see lots and lots of subtle bugs coming from here. PUSH-BACK and POP-BACK might be better names, and you could then support those on lists as well with identical semantics though O(N) performance... Re. lazy-seq. I didn't look at the implementation, but I would urge you to consider re-purposing improper lists for this. Ie. make your sequence functions call the function stored in the CDR of an improper list to generate more elements. Or something like that. :) I *am* fine with "" supporting C-style escapes, though, and unicode escapes would be nice too. ...but interpolation by default? No, that way madness lies. ...but all these should be taking with a truckload of salt: as I said, I've only looked at the README and the examples on the webpage. Good luck with the project! EDIT: One of the reasons I'm not worried about performance really, is that (taking coerce as an arbitrary example) the nice optimized world of regular COERCE is only CL: package prefix away -- but you may want to consider making CL21:COERCE built in such a way that implementations could still optimize when used with vanilla types. Ie. ;; Written in a browser, user beware (define-compiler-macro coerce (&amp;whole form object type) (if (constantp type) (let ((c-type (eval type))) ; EVAL is fine for this, and not much else (if (typep c-type 'standard-coerce-type) `(cl:coerce ,object ',c-type) `(,(coerce-object-function-for-type c-type) ,object ',c-type))) form))) 
&gt; perhaps it's a combo of the original page images plus OCR for search Exactly.
&gt; Common Lisp is not a modern dynamic programming language like Ruby or Python or Javascript. If you try to use it that way, you'll be disappointed. Exactly the reason Lisp is losing ground to modern languages. We've done the experiment - stagnant 70s era CL is failing to gain traction. Honestly, though, I think a much more important problem to tackle is the package system. We need something as good as NPM.
I don't know! I didn't add it there. Perhaps I should add it. 
Those are good lists. Sometimes I get confused because the real mailing list name doesn't match the category gmane puts them in, but it can be a nice interface anyway. For example, the LispWorks mailing list is called lisp-hug, but gmane calls it something like gmane.lisp.lispworks. And SBCL lists are under gmane.lisp.steel-bank.
&gt;&gt; nothing but a source of bugs Any examples?
If that was the goal, then I consider it a good way to contribute. 
As "good" as NPM ? No thanks, I don't want a shitty package manager.
Seriously?
As far as I can tell cl21 only modifies readtables it creates. There's still potential for that to introduce confusion, but it's not clear to me what it should do differently. If I understand correctly it can only cause a problem when code is loaded while it's readtable is bound to \*readtable\*. The main time for that to happen is probably when loading systems from a cl21-user repl. It might be unfortunate that system loading facilities don't all start by binding \*package\* and \*readtable\* to defaults.
Strings = boring. Interpolation = not boring. It makes reading code harder, because you need to pay attention to every string. If it was opt-in, eg. #"{foo}", then I would not worry about it, but grabbing standard string syntax for it seems very wrong. 
Yes, I'm using it at work and I find it a pretty command-line UI masking shitty semantics.
What's the problem? What's better? ASDF is a joke by comparison. Bundler has all kinds of problems that they fixed in npm. 
Oh, that's OK then -- I was worried about the usage example in the readme explicitly using the package but doing nothing about the readtable, but still having the read-syntax extensions taking effect. If it's just the readme that is skipping over that detail it's fine.
This is great! But he lost me at the webgl setup code. I picked up later when he stared drawing, but this is definitely one of those... * Step 1 hunchentoot/websocket * Step 2 webgl and js library load * Step 3... * Step 4 Triangles! * Step 5 animation loop with repl-able live changes! Profit!
There is a lispgames wiki, github org and irc channel. Which is pretty active. https://github.com/lispgames/lispgames.github.io/wiki/Main-Page
This was so fun to watch! I was oddly impressed by the accuracy of his typing. I think he made one mistake.
Check out Cua Mode: http://www.emacswiki.org/emacs/CuaMode
That `in-ws-repl` macro is intriguing.
I will share code that used this video.It just very simple wrapper to parenscript/clws. I used Common Lisp for over 7 years. I always want complete GUI library for CL on most OS(like...CAPI in LispWorks). Maybe, It seems possible via Web. and Parenscript is very good. It very easy to use and extensible. just I'm web baby, so needs more study :-&lt;
Really?!. please let me know mistake. :-)
Surprisingly enough someone found a use for DO where it's not disgustingly unreadable. Congrats.
 `(* ~n ~n) Is `~` doing something different than `,` here? I haven't seen that syntax.
I'm the author of this short comparison, so thanks. Also thanks for lispm for x-posting. Hopefully the code isn't too embarrassing.
It looks like interesting work so far, and I myself have attempted to put thin wrappers on CL to make it as clear and concise as something like Python, and I applaud anyone who can successfully wrangle the inconsistencies. But in regards to the string interpolation, I guess to me it's just annoying to force me to rely on scope when I can just write stuff inline. For example, is CL21 forcing me to write this... (let ((foo (get-foo-data))) (princ "${foo}")) ...instead of simply writing this? (format t "~A" (get-foo-data)) I like the theme of reasoning locally as much as possible rather than hunting for stuff. The string interpolation feature just feels like a code smell to me since it feels like something that really belongs in a library (i.e. feels like web templating) is enabled all the time whether I want it or not.
It uses cl-interpol so just (princ "${(get-foo-data)}") is enough.
Nifty. My (vaporware) solution for the same problem is implementation-supported PRECOMPILE: ie. have the implementation provide a source-level compilation that expands all macros (*and* compiler-macros) recursively. The reason for including compiler-macro expansion is that then you can have co-operating compiler-macros as well -- for the expressivity benefits an implementation-provided MACROEXAND-ALL is enough. With it co-operating macros can communicate via special variables: (let* ((*required-bindings* nil) (precompiled-body (impl:precompile body env))) `(let ,*required-bindings* ... ,precompiled-body)) As near as I can tell the solutions amount to the same thing in the end, with the iteration vs one-shot being the only difference of note -- obviously the &amp;continuation could be provided for compiler-macros as well.
TIL about interpret mode. Does it really expand as it evals? Seems handy for bootstrapping.
So... Does this mean you can somehow define two macros in terms of each other?
After reading your announcement I Glanced through the quickdocs link ( http://quickdocs.org/rutils/api ). I like the looks of WITH-OUTPUT-TO-LIST. That seems like a nice abstraction that I haven't seen before for a common pattern. 
I wrote a quickstart for hunchentoot on openshift. http://github.com/atgreen/lisp-openshift
Hey this is cool. Something that might have been of interest to me, in addition to what you wrote there, would be some background on how this heroku integration actually works, for someone not knowledgeable about heroku. Because heroku doesn't appear to officially support Common Lisp? After some poking around and following links on your blog, I found that your example is based on this https://github.com/bhyde/heroku-buildpack-ccl64 repository which creates a "buildpack" for heroku. Within the sample byhde app your basing your tutorial on, a setup script is obtained using this command. curl https://gist.github.com/bhyde/5383182/raw/gistfile1.txt Specifically this line appears to setup the lisp "buildpack. " heroku create -s cedar --buildpack https://github.com/bhyde/heroku-buildpack-ccl64.git Maybe some information/background about common lisp on Heroku would be helpful? Do you happen to know how well this works compared to the officially supported languages? Are there any limitations? Cheers,
Upon further inspection, I have determined a little more information that might be useful to someone. The Common Lisp heroku buildpack uses CCL's "save-application" feature to dump a complete image of your CL app into a file named "lispapp". Heroku looks for a file called "Procfile" to determine what to run. What are the contents of Procfile in this sample app example, you might ask? Just this: web: ./lispapp So when you push your app up to heroku, it runs this executable lisp image that was created by the buildpack, and thus your hunchentoot app is online. There is some other stuff going on in the buildpack "main.lisp" file, which appears to mostly be concerned with fixing the asdf path for the hunchentoot deploy, but really the gist of it appears to be dumping the lisp image, then telling heroku to run it. Now I'm curious how Heroku handles redeploys... hmm I might just have to try this out myself! Sorry if no one is interested in this. I was for some reason. Thanks cheryllium.
I admire your curiosity! Also, thanks for taking the time to read my post. I am actually where you are right now in terms of understanding how it works, so please let me know what else you might find out. When I wrote the post, I focused on how to do things (not why) because I thought a beginner would just want to setup and get going, not worry about how the setup actually works. I think it would be good to include though, at least the information you've given here, for those curious. I'll definitely edit it into the post, perhaps once we both have a little better idea of how it works.
Just for purists like you there's an alternative syntax: #h() ;) But, you know, Lisp is a language of many choices, and that's what I like about it.
That works. I agree about protecting your freedom. Just for clarification, I don't believe the problem to be my puritanism. I object to unnecessary entropy. You look like you are adding a lot of useful utility here that I don't really understand the need the use of {}'s here. It seems clever on the surface, I guess. The problem is the next programmer that comes along and and introduces some other whacky nonsense, and before you know it, we end up with a Perl like syntax. Afterall, friends don't let friends use Perl. Amirite? But I belabour the point and you did offer the proper way syntax so all good. Thanks! Other than that, rock on. It will take me a little time to digest. Thanks for the hard work. 
Source: https://github.com/digego/extempore 
*print-hash-table* does not print #h()
its in the package starter-kit-lisp if I remember correctly. I don't remember the name of the mode. It also turns fn into ƒ 
Is there an alternative stream? Chrome won't play the video, and with Safari I get the message that I need Chrome of Safari to display it...
Also, check out Aquamacs if you're on OSX - Mac shortcuts using Command work out of the box (for save, copy, cut, paste, select all, etc.)
Same here.
1. Thanks for doing this. 2. I would advise forking the upstream code and copyin/tagging it for an actual production deployment. This ensures that the state of the system is consistent. 3. `curl https://gist.github.com/bhyde/5383182/raw/gistfile1.txt | bash` This command says: suck this unknown file from the internet and run it. It's just *bad* hygeine to do that. I'd advise putting the steps in that script in the blog, then people can copy-pasta them if they like. 4. You can use both SBCL and CCL on Heroku. I'd advise sticking with one or the other for both dev and deployment. That way you don't run into odd issues where one system does one thing and the other system does the other. For Heroku, I'd probably stick with CCL, as its a faster deployment. For a beefier server, SBCL would probably be better. 
Thanks for the suggestions! You make some valid points, which I'll be sure to incorporate into a revision. A question for you, are SBCL and CCL the only lisps that there are buildpacks for, for Heroku? Could you please provide a source for this?
They are the premier open source Common Lisp implementations. Runner ups include the ECL/GCL/MKCL family (designed for integration with C), ABCL (JVM), and CLISP (a bit unmaintained AFAICT). It is probably possible for ABCL to get turned into a buildpack. I know performance is something the Bear has struggled with. CLISP has, I think, threading issues (I don't know). ECL isn't something I've heard about for webservers. I think Allegro works on Heroku from the original work done on buildpacks. I don't know about Lispworks. I don't know about mocl (but it's for embedded devices anyway). So. There's my informal and unresearched survey of the Common Lisp scene.
I don't think the one cell savings ever made a difference. Consider that anytime you cons up a list there is a 50% overhead/cost proportional to the length of the list.
This is awesome. 
Thank you so much, this worked!
I have a follow-up question. When you downloaded the prebuilt dlls, what directory did you put them in? For instance, I put mine in C:\Qt\4.8.5\bin\commonqt. But I feel like that is not a proper place for them, somehow.
http://www.emacswiki.org/emacs/PrettySymbol
This actually looks fairly badass. There are a lot of things implemented here that I've duplicated needlessly. However, I'm having a hell of a time figuring out how to use the hash syntax (git version): `#{"name" "andrew" "city" "sf"}`. It tells me the reader macro isn't defined, even when `:use`ing `rutils` `rutil` and `rutils.readtable` packages. I also tried to do `(ql:quickload :rutilsx)` and got a reader error (it's not able to find the symbol `+default-opts+` when loading the package).
It appears that (named-readtables:in-readtable rutil:rutils-readtable) near the top of a file does the trick. Make sure you place it after the in-package form because in-readtable will associate the current package with the readtable in slime. The reader functions are exported à la carte as well. 
Cool, that did it. Thanks!
This is much better than having to find the .zip of the .dlls in a folder twenty levels deep into an obscure Japanese university FTP site.
Interesting "three reasons" you have there. May I add my two cents: 1. There will always be different implementations for Lisp - in my opinion, their differences don't matter much unless you want to do something very specific. So we should send the message to the beginner: "Just pick one, and don't spend long on the decision." 2. I don't know anyone who edits it in vim, just saying, Emacs is definitely more popular. But there is no need to edit it in Emacs. You can edit Lisp in any text editor, and many do. For instance, I know notepad++ and sublime text both support Lisp syntax highlighting at the least (not sure about the repl). I think the idea that you have to use Emacs to edit Lisp is a popular misconception. Finally, another thing that we can do to address this is to write plugins or maybe a Lisp IDE with a small learning curve. I know of one person who's trying to do something with Eclipse. Maybe you can help us out? 3. I think you are spot on with this point. If you want to address this issue, I think the best thing you can do is write beginner tutorials for those starting out with Lisp. If you spend hours getting something to work, write a tutorial about it so that other beginners don't have to spend hours too. It would also be nice to have more beginner tutorials on common libraries, like Hunchentoot for instance. It would be awesome of you to do this. Another thing we can do is make things easier to install/setup. For instance, I recently wrote an installer for CommonQt so that people can start developing with CommonQt very easily. I'm working on beginner tutorials for it next. Anyway, I really like your blog, and I'm glad you've enjoyed lisp. I just want to say one last thing: if you identify a problem, that is great, but it's even better if you can identify a solution. You identified three problems you perceived, in this blog post. I hope you'll help us solve them, and bring more people to the land of lisp :)
"Powered with ♥ by Common Lisp" Replace Common Lisp with X. That meme is so annoying. :( Sorry I don't have more substantive comments. 
I'm confused, what meme?
The "Made/powered with/by #\HEART_SYMBOL in ,X" meme. 
I agree with you on many points, especially the lack of package descriptions. The lisp community is both awesome and infuriating. [There is an essay about us.](http://www.lambdassociates.org/blog/bipolar.htm) Partly, this is because lisp is so simple to develop with that explaining it is more difficult than making a good enough solution. Look at how many people contribute to various packages. The mode is 1. What I can explain, however is why emacs is so universally used. Emacs, [besides being the thermonuclear option of text editors](http://en.m.wikipedia.org/wiki/In_the_Beginning..._Was_the_Command_Line), is really just a lisp with a text editor built in. Lisp's syntax, or lack of it, allow emacs, slime, swank and CL to work together seamlessly. It's lisp, all the way down, until you get to the damn turtles. Oh, and don't be surprised when your mind shifts and you start thinking in lisp. Then when you have an idea to share you can just express it in lisp! But why not just code it up first, after all it's only 2:00 in the morning...
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**In the Beginning... Was the Command Line**](http://en.wikipedia.org/wiki/In%20the%20Beginning...%20Was%20the%20Command%20Line): [](#sfw) --- &gt; &gt;**In the Beginning... Was the Command Line** is an essay by [Neal Stephenson](http://en.wikipedia.org/wiki/Neal_Stephenson) which was originally published online in 1999 and later made available in book form (November 1999, [ISBN 0-380-81593-1](http://en.wikipedia.org/wiki/Special:BookSources/0380815931)). The essay is a commentary on why the proprietary [operating systems](http://en.wikipedia.org/wiki/Operating_system) business is unlikely to remain profitable in the future because of competition from [free software](http://en.wikipedia.org/wiki/Free_software). It also analyzes the corporate/collective culture of the [Microsoft](http://en.wikipedia.org/wiki/Microsoft), [Macintosh](http://en.wikipedia.org/wiki/Macintosh), and [free software](http://en.wikipedia.org/wiki/Free_software) communities. &gt;==== &gt;[**Image**](http://i.imgur.com/Qt84myb.jpg) [^(i)](http://en.wikipedia.org/wiki/File:Neal-Stephenson-in-the-beginning.jpg) --- ^Interesting: [^Command-line ^interface](http://en.wikipedia.org/wiki/Command-line_interface) ^| [^Graphical ^user ^interface](http://en.wikipedia.org/wiki/Graphical_user_interface) ^| [^Neal ^Stephenson](http://en.wikipedia.org/wiki/Neal_Stephenson) ^| [^Command-line ^completion](http://en.wikipedia.org/wiki/Command-line_completion) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cflil90) ^or[](#or) [^delete](http://www.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cflil90)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/) ^| [^flag ^a ^glitch](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=Glitched comment report&amp;message=What seems wrong: (optional description goes here\)%0A%0A---%0A%0AReply no. 66272:%0Ahttp://www.reddit.com/r/lisp/comments/1ykwd4/uncommonlispcom_a_new_lisp_blog_by_a_newbie/cflil02)
I don't see it as an annoying meme. More like a way to prove to the general public that Common Lisp is still used for new and shiny projects. In communities of other programming languages, it's often considered good publicity for the language and it's welcomed. Nowadays that you see Python under every other rock, it's inspiring to see Common Lisp still being there and well. My $0.02.
What is happening is that you have installed Qt but it is not added to your Path, so then it couldn't find the qt dlls when it tried to run your code. Also I think it was a typo in your comment, but make sure your qt version is 4.8.5 (not 4.8.1) - it should be if you installed from the link on my blog though. I have made a note to add this path modification to my installer as well. The thing is, I did not embed a Qt installer into my installer, so I don't know where your Qt is installed. It is usually at C:\Qt\4.8.5 but you have the option of installing it somewhere else. This is why you will have to change the Path manually for this part, at least until I figure out how to embed the qt installer.
I wouldn't consider this a meme, more of a fad. It seems a pretty trivial thing to be annoyed about though. 
Yes, I meant QT 4.8.5. Once I manually added `C:\Qt\4.8.5\bin` to my path, ccl worked great. I got an empty window, which I think is the expected behavior. Very cool!
Ah yes, but did you click on the heart? ;) I think it usually says, "Made with . . .", rather than "Powered with . . .", my attempt to be cute about Lisp being powerful.
I like VIM because the block commands play well with LISP. d - delete y - yank i - in a - all b - block My most used command is 'dab', which is delete all block, and allows me to easily delete an entire list, in a matter of seconds.
Cute! You may want to code a login form soon though before people start spamming your blog with this... 
You know you can redefine keys in emacs to be anything you want, right? I was an early vi user (yes, when it was written by Bill Joy in the early 80's) and when I switched to gosmacs I made the bindings similar to vi (which is pretty much the same as vim). Yeah, other people couldn't walk up to my emacs and use it, but it was what I wanted. These days, in gnu emacs, there are vim modes that emulate it pretty darn well.
I wonder whether you are aware that the Revised Revised Report on Scheme was called An UnCommon Lisp.
Thank you for sharing this, this is an amazingly innovative project. I have a few questions: * Is there any protection against XSS? Can Evil User create a page such that when Victim visits it, Victim creates pages without wanting to. * I really like the idea of editable CSS and editable code, giving a shared code environment. Is there any way to share CSS / code. It all seems to be inline at the moment. * What inspired you? Are there other projects doing something similar? I know Wikipedia supports Lua scripts, but I don't know of any others.
I'll probably eventually move to Emacs with Vim commands, but for now Vim, and Vim-Fireplace suit me.
I'm curious, what's the use case? Do you have an expensive object or a transient object such as a socket, and wasn't too prevent mistakes? I'd think you would prefer to make it an expand time error instead of a runtime value replacement.
Thanks for your nice comment. And about your questions : 1) I did my best to protect the wiki against XSS but I'm not sure it works in any case. Crackers are so clever people !! HTML tags are wrapped in LISP-like functions introductiong some protections, but some functions open security holes (input, script, iframe,...) ; they can be disactivated if needed. You may have a look in the section "start" (http://epsilonwiki.free.fr/alphawiki_2/?view=start_about) to have more informations about the security. 2) until now there are several levels of sharing a CSS or JS code : the code can be written in the page where it is used, or in a different page to be shared by several other pages grace to the "require" function, or completely externalized and called at the page load via the HTML template ; things must be improved, some work still to be done. 3) inspiration : first HyperCard/HyperTalk (which inspired Ward Cunningham, the father of the wiki concept) ; then the beauty of s-expressions easy to be evaluated in a few lines of JS ; then the emacs concept by Richard Stallman ; then, because emacs is too complex for me, the quest of an emacs for the dummies ; the ugliness of the MarkDown syntax, and even the Creole syntax (sorry Ward) ; all this convinced me to do this work. I didn't know LUA, I know HOP and some other tools for writing, composing and coding web pages. All these projects are so big, so clever and so powerful ! But I find them definitively too complex for me, difficult to install, to master their specific syntax, without a gentle learning slope. In a previous comment "spacebat" wrote : « Reminds me of John McCarthy's lament at the W3C's choice of SGML as the basis for HTML. An environment where the markup, styling and scripting is all s-expression based would be nice. » It's my quest : I took "as they are" HTML, CSS and JS ; I choose (IMHO) the simplest of the LISP philosophy ; and I did my best to unify them in a unique syntax. It's an endless quest ... Feel free to install your own alphawiki to test it, it's easy. And tell me back your opinion. Thanks.
I was playing around with adding [eigen](http://webyrd.net/cl/cl.pdf) to `kanren-trs` this morning, and this came up along the way. It didn't actually end up being appropriate for the problem at hand, but seemed interesting enough by itself.
sorry, it is public now. /r/lisp does not strike me as a place where beginners would be willing to ask what they might consider "stupid" questions, especially with the links to articles that are beyond the scope of the beginner programmer. this is why I think it's a good idea to have a place devoted for beginners to ask questions and get help.
I don't agree. People can and do ask all kinds of questions, and get answers, on /r/lisp.
Questions are asked on /r/lisp because there was no other subreddit for such things. The majority of posts here aren't beginner questions, however. The sidebar does not contain guidelines for posting questions or mention that it's a valid use of the subreddit. So I thought it would be nice to have a learnlisp, in the way you have java and learnjava, python and learnpython, etc. You're entitled to disagree. :) 
Agree with Xach, /r/lisp is small enough already that a new sub shouldn't be needed. Also, I've seen a lot of newcomers on here treated with great respect. On top of that, I very often learn new things just by reading others' responses to "stupid" questions. I think the sub is a great idea for when /r/lisp gets more traffic, but as it is we get a handful of posts a day here (if that), and maybe 5-10% of those are people asking questions vs just posting article links. There are a lot more people willing to answer questions than questions being asked =]. Maybe it makes sense to update the sidebar to let people know it's ok to ask anything.
Well, we have had a lot of these sorts of things. On irc we have a channel for noobs to ask stupid questions. All of these things die because the traffic is low enough that there isn't enough noise from noobs to make it a problem. Give it a go, see how far it goes.
Perhaps it would be worth putting effort into improving /r/lisp then, with additional beginner-friendly links and improved attention from the community. I recall seeing beginners treated pretty unforgivingly in /r/lisp a few times, and didn't say anything. Perhaps I and others should speak up More often, to keep /r/lisp great for novices and experts alike? In any case, I agree with the issue about size. Lets get the beginner questions posted, and start helping!
Who will answer questions in /r/learnlisp? I don't know if lisp has a large enough community to support two subs.../r/learnpython has more than 2x as many subscribers as /r/lisp does!
My main motivation for /r/learnlisp was to create a place where beginner questions are encouraged, where the beginner can have no doubts or hesitations in asking for help, and where they know they'll be treated with friendliness and patience. 
Just discuss it here and we'll see what would be useful to add to the sidebar.
If you see a newcomer being treated unfairly, then absolutely speak your mind. There should be no fear of fighting for fair treatment and the opportunity to learn and grow, even if you're speaking against those with clout. We have a responsibility to share our knowledge and help others. Otherwise, what's the point of this forum?
Perhaps a quick note that says something along the lines of "Have a question? Need help getting started? Don't be afraid to post. We're here to help each other." I think the CL community is sometimes perceived as being a bit elitist and a small gesture like this may help people feel a bit more at ease if they're asking a question they might feel is dumb. Something that is making a newb tear their hair out can usually be solved by many of the regulars here in about 30 seconds. When I was starting out, I feel as though I was treated with respect and given proper critique and encouragement. This resulted in me building a number of libraries and apps that people find useful. I'd like to extend the same courtesy I was given to other newcomers and have this be a friendly place to learn and grow our knowledge collectively. To me /r/lisp is already a great place for this, but adding a few nice words to the sidebar might make it a bit more approachable.
Please ask question here. We have 2 new posts daily on average, which is way to low for such a cool technology. 
elisp questions are welcome too?
yes.
`(strange-let ... (let ((y y)) (lambda () (list x y))))` Such rebinding might happen through macro expansion, so it's not always obvious. I don't think it's a good idea, and suggest proper documentation instead. If you must, I find it more parsimonious to use a box (e.g. a cons) and clear its contents on exit, with `unwind-protect`.
神语言。。。
This appears to be under a new type of license. Would it be fair to distill it down to the term, "antifork?" 
I love the "I can take this language with me anywhere" aspect of Shen. Unfortunately when I was evaluating it for use on a project I realized I needed continuations which it didn't support so far as I could tell. 
Wow, that's an ugly license. I wonder why they decided on that.
Sure, go ahead and release it on github, I'm sure people want to help out
Hopefully Shen/Qi can weigh in here, but I think they want to create a Larry/Linus/Guido situation: benign dictator for life in charge of driving the spec, but not how it's used.
 An Approach to the DIN Kernel Lisp Definition. María Victoria Cengarle, Luis Mandel, Martin Wirsing, Heiner Brand, Klaus Däßler, Thekla Schneider LISP and Symbolic Computation 01/1992; 4:319-369. DOI:10.1007/BF01807179 Abstract: http://cs.au.dk/~hosc/vol04/04-cengarle-al.html The above issue also has an response of the authors to Henry Baker. DIN is the German equivalent to ANSI: Deutsches Institut für Normung. Kernel in this context means: the core level of a Lisp language. The Germans wanted to define an efficient Lisp with layers. The core language would be good enough to implement much of the next layer. But this DIN Kernel Lisp wasn't really materializing. Much of the effort later went into EuLisp, which also has a layered design. See: http://henry.github.io/EuLisp/Doc/EuLisp-0.991/html/eulispcl1.html#x3-50001
If I had 1500 dollars for the plane ticket + hotel + travel expenses, I'd totally go. Unfortunately, though, I'm a broke student.
https://bitbucket.org/pnathan/lispdev/ 
Although the title says DIN Kernel Lisp Baker points a lot of criticism to CL. &gt; In other words, we recommend that DKLisp take up Scheme's original suggestion of using #t and #f to mean Boolean "true" and "false" respectively. There are several good reasons for this. First, the practise of primitive predicates returning arbitrary values encourages the user to do the same, putting a needless load on the garbage collector to recycle this garbage It also advocates for compile-time generic functions, which wouldn't have the run-time performance of CLOS's counterpart. Other performance oriented suggestions inclucde inmutable cons cells as Racket now does and immutable strings. &gt; Since constant strings may be referenced without having to be copied, they can be used in a large number of places where safety would otherwise require copying--e.g., symbol-name, subseq. Since the vast majority of strings in Common Lisp programs are never side-effected, the trade-off between safety and efficiency has been drawn in the wrong place, thus slowing down all but a small fraction of the applications of strings
Thanks, I was unaware what DIN Kernel Lisp was.
Hwat?!
Thanks for summarizing the highlights. Funnily enough the author already spotted in '92 many interesting areas of improvements, and beyond just syntactic sugar.
From the article: &gt; First, the practise of primitive predicates returning arbitrary values &gt; encourages the user to do the same. Why not mandate that primitive predicates return a boolean (*i.e.* `t` or `nil`) instead of a generalized boolean? &gt; Finally, specialized Boolean values make a program more readable, since the &gt; reader doesn't have to perform mental flow analysis to determine whether a NIL &gt; means an empty list or a "false". Which is why in CL you can write `()` or `'()` for the empty list and `nil` for the false value; you can use `endp` to test for the empty list and `not` to test for the false value. While I agree that having the empty list and the false value be the same is weird, I think the drawbacks of not treating anything other than `nil` as true outweigh the advantages. First, it's really convenient; to look up something in one hashtable or in another as fallback, just do (or (gethash key table1) (gethash key table2)) Second, take a function like `position`; what should it return if the item is not in the sequence? I say `nil`, obviously. If I want to look for the position of an item and signal an error if the item is not in the sequence, in CL I can do (let ((position (position item sequence))) (if position (do-something position) (error "~a is not an element of ~a" item sequence))) If an integer is not true, I'd have to write `(if (not (null position)) ...)`. Yuck. 
Would be good if someone can make it work for Emacs 24.1, the code in trunk uses a lot of functions from Emacs cl package that only got introduced in 24.2.
You are not allowed to give answers! I have posted on that subreddit, which says in the sidebar : "Do not give out answers. What will anyone learn from that?". So, nobody can/will answer questions if they read what they are supposed to do.
What's going on with that site? Dan Weinreb died in 2012. All of the posts on his blog are dated from today.
Something is messed up with the software that runs or generates the blog. All the entries came through my feed reader today.
Your objection about generic functions is silly. Premature optimization is the root of all evil, and if optimization *is* necessary you can fall back on functions from the cl namespace.
I had a lengthy discussion with /u/paracelsus who is Mark Tarver afaik, the creator of the language. Imho he is too much driven by dogma and arrogance, but judge for yourself. http://www.reddit.com/r/lisp/comments/1dyem0/presentation_on_shen_slides_and_source_code/c9v28qr
There is also documentation for a release 2.0: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.4.5138&amp;rep=rep1&amp;type=pdf Geometry, for example is a module of Arizona. http://www.stat.washington.edu/research/reports/1991/tr224.pdf The doc mentions that it is Public Domain. But the source code seems not to be found on the Internet...
I do think that nil is a bit too semantically overloaded in CL. Being able to store false values in collections without having to resort to (multiple-value-bind ... ...) or (setf (values ...) ...) to disinguish between a found false value and a missing value would be nice. Likewise, when I'm messing with a simple form, I'll want to use single letter symbols and wish **T** was at my disposal. If an undefined value were introduced, one could write: (or-defined (gethash key table1) (gethash key table2)) A similar if-defined form could expedite the position example. Modern Perl introduces a defined-or operator // which is handy, but I'm sure the false vs undefined vs not-present distinction is a source of bugs. However I guess the implications for the introduction of such a value to CL might make it not worthwhile. I agree that for CL the advantages of false nil may outweigh the disadvantages.
Would have been nice to voice that concern via the issue tracker. :-(
It does actually - has had it since 1.7. Shen Prolog is implemented using continuations.
The arrogance is yours; as I pointed out 1. You've not bothered approaching the Shen group with your project for help or advice. Nobody knows you you are or what you're doing. 2. You dismiss the community as insignificant - despite there being &gt; 400 programmers in it. 3. You have some weird idea - not cited anywhere in the license - that making an error with the kernel requires some face-losing 'apology'. The word is never used. 4. You've presented no argument or done any homework to show that whatever this project you are doing actually conflicts with the license. You come over as something of a self-entitled bore frankly. 
 I just tried it and it does work, just don't byte-compile it! This is an old problem, but follow the instructions in the manual/README closely and you should be OK. The problem is not related to missing functions in cl, though the error message might lead you to believe that. It's related to lexical-binding which was defective in that emacs version. If you're worried about efficiency, know that SLIME byte-compiles its hotspots itself.
I don't understand this. Why shouldn't I be able to take Shen and make a derivative work that doesn't comply with the Shen spec, and call it something else? I can do this with any GPL licensed language, why not with Shen?
You cannot take GPL code and incorporate it into a closed source app. Unlike the GPL, Shen is not viral wrt extensions of itself. The license page explains why we don't do forks from the spec. Shen is not more or less free than GPL - it reflects a different set of values.
Really? Hmm... that's very interesting.
I'm not talking about proprietary code. If I want to take GCC and make a new free (libre) language based on C, I can do that, even if it isn't compatible with C. I can't do that with Shen. And I think that's bad, and less free. Apparently you don't. Interestingly, I think one of the FAQ items is wrong: &gt; If I produced my version of Shen, and it conformed to your standard in 2013 and then you added a new feature, would I be required to update my implementation? &gt; You are not compelled... I think this is wrong. From the definitions at the top of the license: &gt;By ‘Shen standard‘ we understand the latest standards for Shen laid down by the copyright holder. Later, when talking about distributing modified versions of Shen: &gt;It is permitted for the user to change the software...and distribute the modified version of Shen (hereafter the modified version) **provided the resulting program conforms in all respects to the Shen standard** and is issued under that title. So the modified program must conform to the current Shen standard. I think you have to, if you want to distribute a modified version of Shen, update your version forever, or stop distributing it.
1 . Why should I. I'm interested in your science not you as a person. 2 . Let me rephrase my original sentence, to make the interpretation clearer. &gt; They don't want the community to splinter so they rather have no community. -&gt; &gt; They rather had no community than a splintered one. Let's face it, apart from your subreddit, [where everybody treats you like a king,](http://www.reddit.com/r/shenlanguage/comments/1rfe45/blessings/) you act patronising, are arrogant towards critique and argue on an unprofessional personal level, and this is probably why you got a new username. You don't want a community where everybody can express his/her ideas, you want a cult where everybody expresses your ideas. 3 . The code still has to be retracted which was the main point you silently ignore. And in the context how you patronise people it would surely feel like an apology to me (how can you argue with my subjective interpretation of it?). 4 . You acknowledged that publishing buggy code does. Which also forbids studies which study code quality.
Oh and if you didn't want people feel entitled to build upon and experiment with your work, you shouldn't have based your entire, tax funded, academic career on it.
'Less free' is a meaningless phrase because freedom is not a scalar quantity like weight, more like a vector one. Shen allows you freedom to take kernel code and make it part of a proprietary application. GPL code gives freedom to modify but not to freely incorporate within closed applications. Therefore neither license can be meaningfully said to be 'more free' than the other. New implementations have to conform to the latest standard, but thereafter we don't enforce, but only encourage people to adopt the fixes we issue. In practice this merely means recompiling from the publicly available sources. 
You have presented no argument at all to show that your project (whose identity like yourself, we know little) conflicts with the kernel specification at all. This is not a matter of personality. You have simply not argued your case and I doubt that you ever will. Nothing in your posts shows any technical knowledge of Shen. You might surprise me and cease to be a bore, but I expect all we will hear from you is more of the same. Had there been some sort of a case, then that would have been of interest to the online group to know why the kernel was impeding your project and we would have stepped in to help and support your work. Instead you have opted for ranting on reddit. Your problems are a product of your own making. 
Did you listen at all? The problem was/is not with the kernel, but with the license demanding all buggy shen derivatives the be retracted, which conflicts with open sourcing code which very purpose it is to be of varying quality. This is what doability studies are about you know? I actually asked in the IRC channel and was told that this specific use case was not possible. And considering what kind of person you are, I was frankly not willing to make a gamble on goodwill.
&gt; New implementations have to conform to the latest standard, but thereafter we don't enforce, but only encourage people to adopt the fixes we issue. Whether you enforce a given part of your license or not has no bearing on what it actually means.
I posted this comment on the blog entry, but I'll post it here too. Note that it is written in a way that's directed to Dyomkin. --- I commend the continued effort by members of the Lisp community to take their stab at the "utility problem" (which I described in the first section of this post: http://symbo1ics.com/blog/?p=1936). First, I want to mention a few things about Quickutil, and then mention a few things about your RUTILS. You say "The QUICKUTIL approach just adds unnecessary bookkeeping and introduces another import mechanism, [...]". This may have turned out to be true. New syntax—especially the extremely flexible syntax I proposed—didn't turn out to be very popular. In fact, dynamically loading utilities from Quickutil actually garnered a lot of blowback from the Lisp community, for various reasons: insecurity, subpar implementation, and so on. I have thought about it, and although I have not decided definitively, perhaps Quickutil should just offer its `SAVE-UTILS-AS` function, as described here: http://quickutil.org/how#generating . Some people suggested Quickutil should have just been a collection of tens of ASD packages. Some even said that there should be one ASD per utility (!!). You said you think Quickutil solves the wrong problem. I'm not sure it is, and here is why. (And I apologize, because I will be repeating myself somewhat from blog post entries and so on.) Almost every project, hobby or professional, that I have come across in Lisp—and I have seen several—have a file called "utilities.lisp", "utils.lisp", "utility.lisp", or something like that. Almost always, that file contains functions that are re-implemented, copied from the internet, or whatever. One company I worked at had an entire directory called "utils", which contained, among about 10 other files, "utils.lisp" and "macro-utilities.lisp". Here, we had the usual definitions of things like `FLATTEN`, `STRCAT`, and so on. There were also more unusual utilities, such as `COMPLEX-&gt;CONS`, `SUCCESSIONS`, `TRUNCATE-STRING`, and so on. One thing is for sure: people seem to be afraid of adding large dependencies to their project (I have observed this first had at another company I worked at in the 2000s where disk and RAM were constrained quantities on an embedded system), people want dependencies to only do one thing (people don't want 6 dependencies that overlap in their functionality), and people want quality dependencies. Most of these criteria aren't met with utility libraries. As such, people roll their own, and copy cookbook recipes from the net, or excise what they need from previous codebases. I'm definitely guilty of it. Quickutil wanted to solve that by an entirely different approach to libraries: let programmers choose what they want à la carte, and let them contribute to the community pool of utilities. Quickutil allows that, but right now (1) you can do some funky loading of utilities which goes back to what I said above as well as what you said, and (2) you have to contribute by making a Github issue. One of the roaring benefits of Quickutil is that it has amazing, unique documentation: a website which can be searched, with source code and docstrings available. It has been suggested that the functions of the Common Lisp standard even be put into this format. I sincerely think Quickutil is closer in the right direction to solve the "utility problem", but it is not yet perfect. Now, for your library RUTILS. You seemed to have some of the same quips with Alexandria as I did and I agree with your approach. Utility libraries like SPLIT-SEQUENCE which have the spirit of the CL standard should be congealed into a library, not compartmentalized. It is also nice that you address most of the important utilities. But I think RUTILS will probably not garner a lot of attraction for the following reasons: * It is not uniform. Some functions are abbreviated, some functions are spelled out, etc. * It adds new reader syntax in several places. A lot of people seem to not like this. (Some people will see "literal" syntax, like your vector syntax, which evaluates arguments as counterintuitive and unconventional, especially.) * It is duplicating functionality of already existing libraries. (I am not saying this is bad, but some people will think it is.) * It is not comprehensive. * There's no obvious way to add to it. I envision that some people may use RUTILS, and Alexandria, and people will continue making their own buckets of utilities. And since people will have their own utilities, they'll continue making their own utility libraries. And, unfortunately, these libraries will probably be named "The Utility Library Everyone Should Use". RUTILS, like most other utility libraries, just causes more splintering, and less coalescence. I hope some of these comments were informative, or at least provided food for thought.
A little late to the party. I posted this comment on the blog entry, but I'll post it here too. Note that it is written in a way that's directed to Dyomkin. --- I commend the continued effort by members of the Lisp community to take their stab at the "utility problem" (which I described in the first section of this post: http://symbo1ics.com/blog/?p=1936). First, I want to mention a few things about Quickutil, and then mention a few things about your RUTILS. You say "The QUICKUTIL approach just adds unnecessary bookkeeping and introduces another import mechanism, [...]". This may have turned out to be true. New syntax—especially the extremely flexible syntax I proposed—didn't turn out to be very popular. In fact, dynamically loading utilities from Quickutil actually garnered a lot of blowback from the Lisp community, for various reasons: insecurity, subpar implementation, and so on. I have thought about it, and although I have not decided definitively, perhaps Quickutil should just offer its `SAVE-UTILS-AS` function, as described here: http://quickutil.org/how#generating . Some people suggested Quickutil should have just been a collection of tens of ASD packages. Some even said that there should be one ASD per utility (!!). You said you think Quickutil solves the wrong problem. I'm not sure it is, and here is why. (And I apologize, because I will be repeating myself somewhat from blog post entries and so on.) Almost every project, hobby or professional, that I have come across in Lisp—and I have seen several—have a file called "utilities.lisp", "utils.lisp", "utility.lisp", or something like that. Almost always, that file contains functions that are re-implemented, copied from the internet, or whatever. One company I worked at had an entire directory called "utils", which contained, among about 10 other files, "utils.lisp" and "macro-utilities.lisp". Here, we had the usual definitions of things like `FLATTEN`, `STRCAT`, and so on. There were also more unusual utilities, such as `COMPLEX-&gt;CONS`, `SUCCESSIONS`, `TRUNCATE-STRING`, and so on. One thing is for sure: people seem to be afraid of adding large dependencies to their project (I have observed this first had at another company I worked at in the 2000s where disk and RAM were constrained quantities on an embedded system), people want dependencies to only do one thing (people don't want 6 dependencies that overlap in their functionality), and people want quality dependencies. Most of these criteria aren't met with utility libraries. As such, people roll their own, and copy cookbook recipes from the net, or excise what they need from previous codebases. I'm definitely guilty of it. Quickutil wanted to solve that by an entirely different approach to libraries: let programmers choose what they want à la carte, and let them contribute to the community pool of utilities. Quickutil allows that, but right now (1) you can do some funky loading of utilities which goes back to what I said above as well as what you said, and (2) you have to contribute by making a Github issue. One of the roaring benefits of Quickutil is that it has amazing, unique documentation: a website which can be searched, with source code and docstrings available. It has been suggested that the functions of the Common Lisp standard even be put into this format. I sincerely think Quickutil is closer in the right direction to solve the "utility problem", but it is not yet perfect. Now, for your library RUTILS. You seemed to have some of the same quips with Alexandria as I did and I agree with your approach. Utility libraries like SPLIT-SEQUENCE which have the spirit of the CL standard should be congealed into a library, not compartmentalized. It is also nice that you address most of the important utilities. But I think RUTILS will probably not garner a lot of attraction for the following reasons: * It is not uniform. Some functions are abbreviated, some functions are spelled out, etc. * It adds new reader syntax in several places. A lot of people seem to not like this. (Some people will see "literal" syntax, like your vector syntax, which evaluates arguments as counterintuitive and unconventional, especially.) * It is duplicating functionality of already existing libraries. (I am not saying this is bad, but some people will think it is.) * It is not comprehensive. * There's no obvious way to add to it. I envision that some people may use RUTILS, and Alexandria, and people will continue making their own buckets of utilities. And since people will have their own utilities, they'll continue making their own utility libraries. And, unfortunately, these libraries will probably be named "The Utility Library Everyone Should Use". RUTILS, like most other utility libraries, just causes more splintering, and less coalescence. I hope some of these comments were informative, or at least provided food for thought.
OP here. Last week, I decided to write about reader macros, which I think are not as well known as regular macros. I would welcome any feedback and suggestions. Please let me know if this has been helpful.
Haven't checked the code, but the JSON example points into the right direction. There are several ways to use reader macros. The most natural reasons: * to implement Lisp's s-expression syntax. Implementations do this. * to make s-expressions more convenient. Not often done. Lisp already comes with quoting and backquoting * to extend s-expressions to new data types and serialization formats. JSON is a good example. Syntax for hashtables is another. Syntax for CLOS objects yet another. Then there is a slightly different uses: * to increase compatibility foreign code: for example Objective-C like calls, C-like identifiers, ... * infix syntax * rule system syntax * embedded SQL 
That is really cool and well-written. I haven't studied the code in detail but the motivating examples are clear and the results are good. I would recommend mentioning cl-syntax and named-readtables for managing readtables, because they make it possible for multiple readtable schemes to coexist.
That's amazing! And it only took 56 years!
So... _now_ it's acceptable because he started writing scripts with it? Curious reasoning.
1. I'm pretty sure that /u/lispm didn't write the original article. 2. newLISP is basically a disaster. You get a few scripting-friendly features at the cost of anything resembling sane semantics.
Does this really work? Multiple arguments in shebang lines are not widely supported.
&gt; newLISP is basically a disaster. Yeah but there are room for fun disasters, provided you never personally have to use one. 
Looks like cl-launch is getting closer to the space [runcl](https://github.com/orthecreedence/runcl) takes (which is a very simple script abstraction around instantiating CL which I wrote after having problems scripting with cl-launch). I'm glad scripting is getting more attention, because it's a market that the language hasn't really gone after yet, and could potentially bring a lot of newcomers. I use bash for just about everything, but when things require more speed/power that's when I move to CL. It's nice to be able to do that without having to rewrite the script headers on every platform.
It was written with NSIS. I changed the description to be less confusing now. 
Restarting emacs will load the new slime, which should be in sync with swank.
Take a look at chapter 11 of The Book of Shen 2nd edition - there's a whole chapter on exceptions and continuations.
Thanks. Will do. 
The Emacs crowd is rollings its eyes. But for non-neckbeard use, thank you! :)
I'll look into clarifying the wording here; the FAQ was designed to make this aspect clear.
writer of the post: http://lisp-univ-etc.blogspot.com.br/2012/10/lisp-hackers-francois-rene-fare-rideau.html
Yes, so that's not happening. Is there a way to force it to sync?
Linux. All the arguments are mashed into a single one. `cl-launch.sh` has some logic to deal with that, but I don't quite understand it.
I'm listening - unfortunately you're not saying anything worth listening to. The IRC channel contains about 7-8 people at any time; not all of them active. The news group contains 400, common sense (which you seem to be short of) would suggest mailing the group. Anyway I've listened to this lame story and it was entertaining for a while, but I've other things to do. 
huh. just tested it, you're totally right. weird behaviour.
I ran into this once when my lisp init file loaded swank explicitly.
I can't speak for the post author, but some Python features that I find annoying: * Single namespace, combined with hobbled lambdas * No dynamic scope, combined with awkward lexical scope * Conflation of declaration, assignment and binding * Random choice of this.method() vs function(this) * Less choice in code layout and woe from copying python source on a web page Despite this I think Python is a good language, its easy to learn and obviously makes it possible to get the hard things done too.
I think it just says “hi, here’s your argv, enjoy”.
Thanks for the suggestions. I will incorporate some of these in the article.
I think that we have enough disasters when it comes to programming languages. 
On what platforms *is* it supported?
&gt; Random choice of this.method() vs function(this) It's worse than random. I always guess wrong. 
Looks like it. I only say "strange behaviour" because for me that breaks the principle of least surprise.. one would expect it to behave like a shell command line.
What version is available via an emacs package?
I've been hearing a lot about LISP recently, and having programmed in it before, this news makes me happy. However with the world so focused on web, 'cyber', and the sort: what does LISP bring to the table? How do we get new generations of programmers excited about this cool and unique language? 
We don't. Lisp stands on it's own merits, we don't need C# style advertisements because, frankly, the people who read those won't understand it. Lisp requires a certain ability to think differently from other types of programming which in turn requires a different ability from the general public. Lisp will gain traction in time, but not because we do anything other than use it. 
Reducing the scope of LISP to please beginners is at the opposite of LISP. Showing them how to embed json through reader macros, how to output pascal from the pretty-printer, transpile to js ?
That's a lot like saying "we have this really awesome idea, but we're not gonna advertise it because people will just find it eventually." When you have something that's good at what it does it's the users responsibility to share the good news. If everyone kept useful tools hidden under rocks they'd hardly be any meaningful advancement, we'd be replicating things at an alarming rate. So I ask again, how do we share this really cool tool so others don't have to suffer through less useful tools?
I don't think I said anything about pleasing beginners. I only want to get the word out. I only heard about LISP because of a 1 day segment in my Programming Language course. It deserves more than that, because of its abilities.
Man, I got pretty hooked when I found the c2 Wiki and read about it years ago. I don't think that you need some kind of special brain sauce to understand Lisp, but learning a PL that isn't very popular may require that you like programming a lot.
All good, glad to clear the air hah.
I don't know if i agree. I think back in the day that was true, when the internet was just getting started and resources were hard to find. But in this day and age I think truly useful and interesting things should be freely shared and given to the people. We, as responsible users of said thing, should be telling people how cool it is and how to use it in cool ways. Not an easy task by any means, but something I think we should all aspire to.
Just trying to save you some heartache.
Then we don't disagree :)
We offer resources to make it easy to try out. Like an interactive repl (even if limited) embedded in a nice web page. Lots of easy-to-use tutorials. Installers for common libaries (shoutout to quicklisp for being awesome). Forums where people can ask questions (like IRC, /r/learnlisp and /r/lisp). To get my generation interested, teach with examples. Show us a finished product - look at this web application (desktop application, game, data analysis program, whatever) that I made in Lisp. Walk us through how to make them. Teach by making things and we will be happy. I remember trying to explain to one person why Lisp is elegant. I told him all about the macros and how you can do cool things with them. He said to me, "That sounds theoretically interesting, like a really cool idea, but what can I use it for? I use python for everything and it works. Why should I use Lisp? What can I make with it?" He said, "I don't just program to enjoy programming. What I really want to do is make things." So I believe we can get people excited if we can show them, in a way laymen can understand (which has always been my struggle), things that you can make with Lisp, and especially things that Lisp allows you to do which are not possible in other languages. 
So, after much experimentation, I have found a solution. As Xach suggested, the problem is having multiple versions of Slime. However, removing them and restarting emacs doesn't work because the version of Slime is set at compile time (in slime.el). So the compiled version of slime.el continues to use the incorrect version number even after the old versions have been removed. The fix is to delete slime.elc and force a recompile. This seems like something of a bug to me, so I'll file it with the Slime folks and see what they think.
There's no point in using (progn (in-package ...) (in-readtable ...)). They're not functions, they're macros. They can just be typed one after the other, sans progn.
Do you mean Lisp, the abstract concept, or a specific concrete language?
Thanks! I changed it.
May I suggest putting them on separate lines? My mental parser read the two calls and then backtracked to the beginning of the line to make sure they weren't nested in, say, a `progn`. 
I like your tutorial style. My (small) suggestion would be to always put functions, macros, and class names in `monospace font` to easily distinguish them. First case in this point is the first tutorial, last paragraph: &gt; Our strategy will be to create a class called hello-world-app that ... as opposed to &gt; Our strategy will be to create a class called `hello-world-app` that ... * First tutorial, first paragraph is in italics. Is it part of a synopsis of the tutorial used elsewhere? * First tutorial, first section Is `named-readtables` loaded by commonqt, or does it require a separate `(ql:quickload 'named-readtables)`? * First tutorial, second section, last sentence: &gt; ... and we can refer to it now as “show-name()”. And not `(show-name)`? If this sort of feedback is helpful, I'll continue. Reading back over this before submitting, I feel it might be overly pedantic.
Could you explain a little further how the slot option works?
Sure thing! they originally were in a progn, which explains why they're formatted like that once I removed the progn. I'll put them on separate lines now to be more clearer.
According to the CommonQt webpage, you can use the slots and signals options to define a class's signals and slots. I am going off the information here: http://common-lisp.net/project/commonqt/#id106285 (That page, by the way, is the only other qt reference I can find. I must say, though, qdescribe is very useful for looking up documentation.) If you think a more in-depth discussion of how these options works would be useful, someone may need to ask stas about it or read the commonqt source to figure it out, as I don't know. Or did you mean I should explain how slots/signals work in Qt? 
By the way, I'd be extremely grateful if someone here would do an eli5 on readtables for me. I could never really understand what they were, or how they are different from namespaces.
I think I may have assumed too much knowledge of Qt in this tutorial. Signals and slots are a huge part of how Qt works, perhaps I should explain that in tutorial 2 which is the first time we actually utilize this concept? It might be a good idea for me to rewrite parts of this with the assumption that the reader knows Lisp but knows nothing at all about Qt. I guess I did leave out a lot of explanation of the qt fundamentals.
Looking really great. A suggestion I have is to recap at the end of each tutorial, showing a full example. A lot of times when I read tutorials, I find it more palatable to read all the code at once as a reference once I know the building blocks. Including a full example at the bottom is a nice way for your readers to see *everything* in one working example they can copy-paste and start messing with. Also, the code *may* be more readable with highlighting. I wrote a CL-specific highlighting util in javascript: https://github.com/orthecreedence/highlight-lisp you might like. I personally think your site is very readable already though, so feel free not to bother with highlighting =]. EDIT: Forgot to say, thanks for contributing.
Hmm, I was initially against the idea of including the full source, under the premise of not wanting people to just take and run the code without understanding it. But I think it would be helpful to have at the end. To not make the blog posts too long (since the code will get much longer, and may span multiple files), what do you think of hosting the full code on github gist, and linking to it there? I love github's way of showing code, and I'd rather not offer a file to download. I welcome other suggestions. I'll definitely take a look at your javascript plugin, it looks really cool! I have to figure out how to put these things in a wordpress blog though. I have put "learn wordpress plugins" on my to-do list, as another thought I had was to use the github plugin that displays code with syntax highlighting and line numbers.
Yeah a gist is a good idea. I'd avoid a file download too =]. 
I modified my tutorial slightly here: http://cheryllium.wordpress.com/2014/03/03/commonqt-tutorial-2/ Please take a look at section 2: Creating Some GUI Elements. I added some extra explanation about how Qt works. I hope this makes Qt clearer to my readers :)
I think people would best be served by having more tutorials and more support for existing libraries. I don't think the Lisp community is at fault for this, of course, since we are pretty small, unfortunately. 
Readtables and namespaces are not similar at all. Namespaces are orthogonal environments in which we can store different 'objects'. So in the class namespace the symbol foo refers to the class too whereas in the function namespace it refers to the function foo. AFAIK there is a variable, a function, a macro and a class namespace. Because the first symbol of a form is looked-up in function namespace if we want to use a function stored in the variable namespace we have to use the funcall form. Readtables on the other hand define how the lisp reader translates the stream of characters (normally from the source files) into its internal representation. (Which I think are s-exps in the case of cl implementations but for example racket doesn't use s-exps). So using a read table is how the function read turns '(1 2 3) into a list, (1 . 3) into a cons cell and #(1 2 3) into a vector. You can also create your own read tables to teach the lisp reader new syntax. Like Ruby syntax for hashtables, or to read CSV as a list. Hope that helps.
Thanks a lot for your suggestion -- this was sorely missing from the article. I have added a new section on packaging the syntax. Please let me know what you think: https://gist.github.com/chaitanyagupta/9324402#packaging-the-new-syntax
named-readtables is also quite useful. I mention it in a new section on packaging the new syntax. Let me know what you think. https://gist.github.com/chaitanyagupta/9324402#packaging-the-new-syntax 
How you got a phd with these discussion skills is beyond my comprehension.
Just the other day I wrote a tutorial on reader macros: https://gist.github.com/chaitanyagupta/9324402 I hope it clears your doubts on readtables. 
For Common Lisp beginners, I'd suggested the CL equivalent to this: http://tryclj.com/. Bonus points for including PCL or one of the other books inline, so as to go ahead and start learning immediately.
Thanks! Excellent write-up
Maybe I missed something, but the interview contains only a single sentence about BODOL. The rest of the (very short) interview is platitudes about functional languages without specifics.
One question, does the `named-readtables` merge the reader macros of qt with the ones in my current project? I want to make sure I understand this. I think what it is doing is making it so that the same new syntax created by the qt library available to be used by my project as well.
Which community for which Lisp?
It looks good to me, thanks.
This looks like a load of interesting implications. 
I registered trylisp.com some time ago and haven't gotten around to building anything with it. It is unlikely that I will anytime soon. :-/
&gt; One question, does the named-readtables merge the reader macros of qt with the ones in my current project? I am assuming you are talking about what the following line of code does: (named-readtables:in-readtable :qt) If you take a look at the macro expansion: CL-USER&gt; (macroexpand-1 '(named-readtables:in-readtable :qt)) (EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE) (SETF *READTABLE* (EDITOR-HINTS.NAMED-READTABLES:ENSURE-READTABLE ':QT)) (WHEN (FIND-PACKAGE :SWANK) (EDITOR-HINTS.NAMED-READTABLES::%FROB-SWANK-READTABLE-ALIST *PACKAGE* *READTABLE*))) T You will see that it doesn't "merge" anything -- all it does is that it makes the readtable named `:qt` the current readtable. (via `(SETF *READTABLE* (EDITOR-HINTS.NAMED-READTABLES:ENSURE-READTABLE ':QT))`). The section on packaging new syntax in my tutorial talks a bit more about how libraries should provide custom syntax -- I think it should help clear up some of the confusion. https://gist.github.com/chaitanyagupta/9324402#packaging-the-new-syntax
I haven't seen non-ascii characters in a language before, the author mentions some resistance to using them, does anybody have any info on that?
You could have a build of JSCL running on it!
Yes. 2000 an friggin 14 and this whole web is still the same old stinking shit that forces people to use plugins if they want to avoid needless work. 
[APL?](http://en.wikipedia.org/wiki/APL_%28programming_language%29)
I don't like the syntax but the semantics are interesting combining laziness, first class environments and ubiquitous metadata. Bookmarked.
Some of his copyrights on this go way back. It was cutting edge at one point, surfacing an REPL on a web page.
So let's bikeshed about syntax! I think the pattern matching syntax is a mistake. It's the same mistake some people make when they create a new binding form in lisp with a syntax like (let x = 1 and y = 2 in (print (+ x y))) This breaks keyboard code navigation, it breaks automatic indentation, and more importantly it basically breaks homoiconicity (in the sense that yes, programs are lists, but then again C programs can be seen as strings; it's just not an easy representation to programmatically manipulate).
[Racket](http://www.racket-lang.org/) supports unicode identifiers and Racketeers often use `λ` for `lambda` (the unicode version is bound to the same thing in the base language).
Then you should take a look at Agda's [standard library](http://www.cse.chalmers.se/~nad/listings/lib-0.7/README.html). They are crazy with unicode names.
That was one of the things that bugged me the most. It feels like it throws out a major benefit of the language in preference to this one feature. It's a feature I think would benefit Lisp, but I'm sure there's a more Lispy way to do it.
[Structure and Interpretation of Classical Mechanics](https://mitpress.mit.edu/sites/default/files/titles/content/sicm/book.html) might interest you. It's not quite like Little Lisper, but it's Lagrangians through scheme, sort of. I don't really know any math texts like that. A cultural thing, I guess. Maybe try [Coding the Matrix](http://codingthematrix.com/)?
Some background on the company: * http://chatsubo.net/company.html * http://chatsubolabs.com * https://github.com/kraison/
Fuck the bots. They are driving me away.
I *think* the general idea is that `this.method()` is destructive, and returns nothing, whereas `function(this)` operates on/returns a copy.
I really wish they would've taken a different approach when they designed their products. I'd pay for an IDE that could deliver services (like refactorings, intelligent code completion) to Emacs by being run in a headless state. I'm sure Vim users would love that too.
I have read Coding the Matrix myself, and it is fantastic. I already knew linear algebra and python well before reading it, so I cannot speak to how great it is for people unfamiliar with the topic. What I love about the book though is that it has the quality of all great technical books in that it is not extremely verbose, and I believe the book is a reference for how applied maths should be taught. I cannot express how useful directly using the new math topic and having an alternative representation of the concept that is interactive is for instilling that concept well; using mathematica or some other system along side a math textbook is precisely how I would teach those topics and would be of tremendous benefit in helping others realize the beauty of mathematics much earlier. Learning maths this way was of tremendous help when I was learning PDEs for the first time for instance, and I cannot imagine how much more difficult making the abstract concepts click would have been otherwise. Anyways, I really love math and wish more people experienced how beautiful and exciting it is in life instead of feeling that it is useful and not applicable to them despite being surrounded by mathematics all the time. I cannot understand how someone is not enthusiastic about having a language to describe the universe precisely; it is the closest thing to a super power humans can achieve IMO.
Document it and put it on Quicklisp :)!
It may be overly juvenile, but you may want to rethink the name cliterator. 
Just maintaining the long-standing Lisp tradition of unfortunate names... it's obligatory really.
Downvotes just show a lack of sense of humor...
How about a modern, searchable version of the HyperSpec? As reference material goes, the old HyperSpec is anachronistic and nowhere near as usable as any equivalents that most non-Lisp programmers are used to.
I say keep it. Part of the charm of free software is that it doesn't have multiple layers of bureaucracy stopping stuff like this happening.
It might be good to have some interface compatibility with http://common-lisp.net/project/sequence-iterators/.
Here is another one that shows a new friend of copy-paste that I called note. It allows one to simply paste the very same object at the selection instead of a copy of it. http://www.youtube.com/watch?v=JIby1e6dmE4 I also created an overview presentation that tells a little bit about concepts, features and internals of ProjecturEd: https://github.com/projectured/projectured/blob/master/documentation/overview.odp?raw=true 
Most of that seems to be Clojure specific. For Common Lisp users interested in macros a first read is Paul Graham's 'On Lisp'. And, no, in Common Lisp macros are not needed for code inlining. Most Common Lisp compilers understand the INLINE declaration. 
We've been discussing writing that - a browser-based lisp repl - on irc actually. 
(quit)
 I'm not sure to what extent compilers honor the declaration as forced inline, but clhs only indicates it's optional at all: http://clhs.lisp.se/Body/d_inline.htm
Somewhat related: there's a pretty cool emacs library for clojure refactoring [here](https://github.com/magnars/clj-refactor.el) that you might want to check out.
That's why I wrote most compilers understand it.
Clojure has an inline declarations as well, implemented as metadata on functions, which serves as a JIT hint. This might not be useful for clojurescript though. The author also used the macro as a way to cheat JS into giving different line numbers, so not really in a classical inline way.
Another option is `define-compiler-macro`. It is pretty likely that one of inlining or compiler macros or both is available on a given CL implementation.
I'm one of the contributors to that library. Glad you like it!
"What Lisp is good for is figuring out the right language for what you want and embedding it in Lisp" -- Harold Abelson Accordingly, the author put stratified design to practice and built on the substrate of Lisp a quite remarkable language called Symta (influenced by Refal, APL, Forth and others) for this program. The Symta code for the entire game clone totals a paltry 1100 lines. Program text here: http://sym.at.ua/load/symcraft_v0_1/1-1-0-3 Symta: http://sym.at.ua/load/symta_v0_2/1-1-0-2 Related work: https://github.com/saniv/symta-iso Finally, I am not the author.
I have a half-baked engine I built about a year back. I never lost interest, I just lost the time to actually continue building it: [Ghostie](https://github.com/orthecreedence/ghostie). Basically, you build your levels as different layers in an SVG editor, then assign which layer is your "physics" layer via a meta file, add your SVG game objects, and you have a collision-based platform game to play in. There's an included demo that shows everything off. There's a pretty big TODO list on the engine, but it *works* and is fairly fast. That said, I've never built a real game in Ghostie or in CL in general. I'm guessing you'd be able to squeeze more performance out of highly optimized C++, but in the platformer world this may not matter. I know I can build things in CL about 3-4x faster than I can in C++, which is something to keep in mind, although without existing tools you may be spending a lot of time reinventing the wheel. That's not to say there aren't viable platformer toolkits in CL, I just don't know what they are.
You can also take a look at lispbuilder-sdl to get the bases covered and concentrate on the game itself.
Interesting. The symta stuff uses my code without following the license. That's kind of annoying!
Did you asked them for them to do a license review?
No, I didn't - I didn't know about this project until today.
Well, SDL covers a lot of the 2D graphics (including sprite animation)/sound/input stuff very well, but as far as a game engine itself it leaves you wanting. For instance, there's no architecture besides a main loop (think separate threads for rendering and physics/simulation w/ synchronization between them), collision detection, level building, character modeling...you have to figure all that our for yourself. As a 2D graphics toolkit it's a great place to start. I wouldn't say it's anything near a game engine though. 
Where's the Lisp?
There is also [Clinch](https://github.com/BradWBeer/CLinch), xelf which has been used by dto for multiple games and and sdl2 port. You should check lisp games wiki. Their irc is pretty active too
Symta was developed by someone from /prog/ on 4chan by the way. I have a (probably old) version of symta
I'd recommend xelf, dto and other guys are usually active on #lispgames
If you follow the second link in my opening comment, you should come across a zip archive for Symta. Within the archive are a number of Common Lisp projects which implement the Symta language (and supporting libraries) in, ontop of, and symbiotically with, Common Lisp. Similarly, if you follow the first link you'll find another zip archive which contains the Symta program text for the Warcraft 2 clone.
I wouldn't call Symta a DSL though
It seems somewhat generous to use the plural.
Oh hey, a Korean Lisper? Cool.
At least the encoding should be mentioned in the file, especially if it's not UTF-8; probably EUC-KR-DOS by the looks of it?
It doesn't matter, because the program doesn't show Korean letters but reads from a website in which the encoding is mentioned.
But the regexp contains some letters? It wasn't autodetected properly when I opened it, that's why I mentioned it.
I've also written up an example game for my game engine, and will be releasing that with some docs soon.
Woo!
Maybe this explains why Yale won...
Thank you :) I have to thank the SBCL project team as well, as it's SBCL's multiplatform support that makes the magic work :)
There's a lot of good stuff here, and the presentation is pretty good. I didn't try to run the code, I'm just eyeing it, but I think I have some stylistic issues where you're doing the (copy-readtable) every time you invoke this reader macro. I tend to feel that's probably too high-overhead. I'd think in your setup function you should be able to generate a set of readtables which the various functions are mutually closed over and that can be swapped in and out without actually consing a new readtable at every readmacro invocation. (You might also be able to get away with just a single readtable. If you think you need more than one readtable, I'm betting using dynamic variables to control state will give a cleaner feel.) The way you've done it makes you more robust against someone dynamically setting the readtable in the middle of a read, but I would claim that anyone who does that is violating good style, and I'd make the same suggestions to them that I'm making here. It's fine to bind the readtable dynamically, but I think dynamic side-effect to readtables is at least something you should do cautiously, not just for the side-effects but because there's cost in speed and debuggability. It's easy for a user/programmer to confuse himself if he ends up in a breakpoint in a dynamically instantiated readtable and makes any modifications to it.
You don't really address what happens if someone uses evaluable expressions in the middle of this. That's presumably your purpose since you're not just writing a special-purpose JSON reader. You give a few examples that illustrate the issue, especially because you are going to gobble up comma and you need to address what happens if someone uses backquote within a subform. A rational suggestion is to disable backquote in recursive forms, though there are other ways to make more elaborate versions of the recursive readers that notice whether they're up against constituent characters or a subread of a compound form and in the latter case try to re-instantiate a readtable that doesn't have odd comma behavior for within the latter case. You have a note that suggests that you might get away without comma being overridden, but it's true the error messages might be less informative if you do that. If you stick to overriding the comma behavior, you might want to have a special variable that you bind that says whether you're in a context where comma is expected or not, so that within the subread of forms for a brace, you can disable the expectation. In that case, it's possible you could actually hold onto the old/outer definition of comma and invoke it instead in that context. That might allow backquote to work again. I'm just thinking aloud and didn't try any of this. It's just something to think about.
Did you haven any problems with sbcl on windows? I mean, I heard it's support is not that good on it.
Hi. No real problems anymore, Windows support has improved a lot. 
I can even use Wine to make a game EXE that works on Real Windows :)
Looks like [this](http://www.reddit.com/r/bestof/comments/1umqu6/timonoko_accidentally_makes_a_lispbased_os_for_a/) was the cause of the spike.
If you want to strictly follow the last CL recommandation, shouldn't you delete *take-until* and replace it with (take-while (complement pred) iterator) ?
All I can find is [graphviz-dot-mode](http://graphviz.org/Misc/graphviz-dot-mode.el), [video here](https://www.youtube.com/watch?v=WEEuaN62hNI), all of which looks a bit painful. I'd like to see something like yEd also.
&gt;All I can find is graphviz-dot-mode, video here, all of which looks a bit painful. That's true, is it only visualizing code? I also downloaded Lightable for clojure in case it had something like that, but it had a lot of bugs, and the focus was more on "live previews", while I was thinking of something like yEd, or the "compose filters/shaders" modes in some 3d modeling etc. programs. I think that for certain types programs it might be more than a novelty, those similar to the shader composition example.
In a [timely post](http://www.wisdomandwonder.com/wordpress/wp-content/uploads/2014/03/C3F.html#sec-10-3-4) Grant mentioned a few other tools that play nice with callers. I just noticed this is /r/lisp and not /r/emacs :-) not that there's a big gap there.
Are you actually trying to do data flow based programming? Or do you just want an IDE that lets you arrange lisp code on a canvas?
&gt;Are you actually trying to do data flow based programming? Or do you just want an IDE that lets you arrange lisp code on a canvas? The second, I don't have any plans for data flow programming. But I just tried using 2d rectangles in a way equivalent to lisp parentheses, and in yEd at least, the result was much less cumbersome than I would have thought. And I think that for data flow like stuff it could help making the code readable. Are there any generalized enough lisp or non-lisp tools for this kind of thing? I think lisp is better suited cause of the simpler syntax.
There are a lot of active projects in the data flow arena, but yeah.. not sure if they are relevant. [Flow](https://www.youtube.com/watch?v=RsoeERfS7Gs) is young and light, but I wouldn't call it general purpose. A rich IDE for lisp that allows for multiple views on the same code model is something that I'm really interested in. I totally agree that lisp is the language best suited for this, and it's really sad to see people invent stuff like XML and json when they really need s-expressions... None of my ideas are new, I guess.. back when lisp machines were popular there were lots of half-baked [attempts](https://www.youtube.com/watch?v=xt-HHV_fC7Y).
Flow looks nice slightly more general. As an architecture it's probably the same as the Photoshop/Blender etc. tools. I think as an interface they need to rely a bit more on "spatially grouping in blocks" than connecting edges. &gt;it's really sad to see people invent stuff like XML and json when they really need s-expressions... I can see how they wanted something less 'up to interpretation' with xml, to use it as a standard, but wtf it is supposed to be more like a standard, yet there isn't a standard way to have a key-value structure. XAML kind of has one but it is even more verbose.
https://github.com/ykm/cl-iterators/issues/1 ...still not a 100% compatibility but most of them achieved though.
I'm on mobile w/o flash support. What is this all about?
It looks to be a simple Lisp implementation in MIT’s [Scratch](http://scratch.mit.edu/about/). I.e., exactly what it says on the tin.
It loads for me, but slowly. Here's the [Google cache version](http://webcache.googleusercontent.com/search?q=cache:vlmau0P4Vw4J:http://www.pvk.ca/Blog/2014/03/15/sbcl-the-ultimate-assembly-code-breadboard/).
I have been looking for a lisp assembletr for quite a while. I didn't know sbcl allowed access to the assembet. Very cool stuff here!
Still no support for dalvik. Just out of curiousity, what is the problem of just letting dex run over the generated bytecode, and then run it?
Came here to ask this. Is AOT compilation possible? This is probably the main thing needed to run on android. 
dex isn't available at runtime, so to the extent that one can specify all the code that will be executed at buildtime, running dex over the ABCL system image should work (one would need to modify the build process as directed by 'build.xml'). Afterwards, all code encountered at runtime would need to run in interpreted mode (or possibly, one could implement a web service that would given the JVM code, it would return the Dalvik code to be executed). Essentially, someone has to put in the time to understand Dalvik enough to get ABCL working on it, but no one has stepped up to do this yet. We are targeting new compiler(s) for the ambitious [abcl-2.0](http://abcl.org/trac/milestone/2.0.0) that would include support for Dalvik, but this is more notional than something the ABCL dev team currently can be said to have the necessary resources. Patches are always welcome…
So after 3 years of forking ECL does anyone know the most significant differences between MKCL and EC?
I've used Parenscript in a production environment and I ultimately recommend against using it to generate Javascript. In fact, I recommend against using any system to generate Javascript for production environments except possibly those systems which are bona-fide compilers rather than transcoders. Why?: Here is some parenscript code which works: (+ 1 2 3) (let ((x this)) (chain x (some-method "10")) Here is some that does not work: (apply #'+ 1 2 3) (let ((x (let ((y 10)) this))) (chain x (some-method "10")) (The first line fails because `+` is not a function in parenscript, despite being one in Common Lisp, and the second line fails because Parenscript expands lets differently depending on context, and sometimes it clobbers `this`.) In a sane system these two sets of lines would both execute and have identical effects/values. They do not. Parenscript constitutes a misleading _facade_ of Common Lisp on top of entirely different semantics, those of Javascript, and you will trip over yourself eventually unless you write Parenscript exactly as if you are writing Javascript, except in parentheses. However, doing so you complicate your own development process for very little benefit. Parenscripts stated goals of having no run-time, but resembling Common Lisp while producing Javascript are schizophrenic. You cannot easily achieve a sensible system with these goals. If you really want to use Lisp in the browser, I recommend something like Chicken Scheme, which can compile to the browser but which does a much better job of giving you the semantics of Scheme, not some bastard combination of both languages. If that doesn't convince you, consider the following totally valid, but utterly perverse, Parenscript code: (defun + (a b) (+ a b)) 
Can someone explain what Variants are and a basic example of where they are useful? I read through a lot of the macros, but it's a bit hard to digest when I'm not even sure what the end result is accomplishing.
If you want a value that is both an integer and a string, you use a structure of some kind (a pair, an actual structure, a class, whatever) with two slots: one for the integer, the other for the string. In OCaml, for instance, the type of such values could be written type int_and_string = { the_int: int; the_string: string } This is a record type with two fields, `the_int` and `the_string`. A value of type `int_and_string` looks something like { the_int = 3 ; the_string = "Hello!" } Variant types are the dual construction: they are the type of values that are *either* an integer *or* a string. In OCaml, you would define type int_or_string = | An_int of int | A_string of string A value of type `int_or_string` looks like `An_int 3` or `A_string "Hello!"`. This is the equivalent of OP's `defvariant`. When you operate on a value of type `int_and_string`, you extract both fields and do something with them. When you operate on a value of type `int_or_string`, you first look at the shape of the value and, depending on whether it looks like `An_int i` or `A_string s`, do something with either `i` or `s`. This is what OCaml's `match ... with` construct is for. Assuming that `x` has type `int_or_string`, the expression match x with | An_int i -&gt; i + 3 | A_string s -&gt; String.length s evaluates to an integer. If `x` is `An_int 42`, the value is `45`; if `x` is `A_string "Hello, world!"`, the value is `13`. This is the same as the `match` macro in OP's text. Now the example of variant type I gave is moronic. For a real example, take anything that can be either one thing or another. It's a bit difficult to give a "good" example of what variants are typically used for. They're just as useful as record types (i.e. structures); what example of those would you give to someone who had never used one? Here's a simple one anyway: in Lisp, a list of integers is either `()` or a cons cell that contains an integer in the car and a list of integers in the cdr; in OCaml you could represent that as the type type int_list = | Nil | Cons of int * int_list Here the product type `int * int_list` is the type of pairs `(x,xs)` where `x` is an `int` and `xs` is an `int_list`. A (naive) function that computes the sum of the list could be written as let rec sum list = match list with | Nil -&gt; 0 | Cons (x,xs) -&gt; x + sum xs The type `int_list` uses a variant type, also called a sum type, and a product type; that's why it's called an algebraic datatype (ADT). As a final note, I've hardly ever missed variants in Lisp. In languages like OCaml or Haskell, you can't live without them, and the static nature of these languages makes them all the more useful. For instance, in the definition of `sum`, the compiler actually checks that I have handled both cases (`Nil` and `Cons`); if I had forgotten one it would have warned me. On the other hand, if you want a Lisp function that works on both integers and strings, you can make it generic, or use a `typecase`, and the whole static checking thing goes against the spirit of Lisp IMO, so I'm not convinced of the value of `defvariant`.
The Boost C++ library has a fairly succinct description of "variants". &gt; Whereas standard containers such as std::vector may be thought of as "multi-value, single type," variant is "multi-type, single value." http://www.boost.org/doc/libs/1_55_0/doc/html/variant.html The concept has been around for a long time, but different communities use different terminology for it. In OMG IDL, this construct is known as a "discriminated union". In XSD, it is called a "choice element".
I'm very interested in seeing if ABCL &amp; invokeDynamic (JRE8) will start playing well together. I'd love to see the Bear be known for his speed.
&gt; (defun + (a b) (+ a b)) I would describe this as peculiar, to say the least. I'm glad to see that Parenscript has caught some of its `this` clobbering, though. 
Even without support for InvokeDynamic, running on Java 8 seems quite speedy. One thing that has changed that should significantly help out is that the PermGen space has been removed in favor of the MetaSpace abstraction, which allocates information about classes more effciently. The ABCL compiler generates quite a few classes for every fasl, roughly one for every top-level form. 
Gotta appreciate the readme :)
Thanks for the great explanation. It makes more sense now.
It's incredibly difficult to get any of this information from the author. I've urged him to write docs and/or at least outline some of the key differences, but the answer usually ends up being "read the source." I'd like to use/try MKCL but I just need to know there's a bit more of a support structure around it first. Not to mention ECL is still getting built onto, even with Juan Jose not leading anymore
OK, I admit, I am a disaster at writing documentation, there you have it. On the other side, the internals of MKCL have changed enough that I would be well into my 3rd entire rewrite of it and that would have been too much of a burden on the main development effort, mainly when I consider the extent of the coming major release (1.2.0). I am already years behind my original development schedule so any more overhead is not likely to sit very well with me. The MKCL public interface is largely covered by CLHS and getting ever closer to it so you should be pretty much covered in that area, just do not insist too much on those "implementation-dependent" or "undefined" areas of the spec, at least until the dust settles and the internals doc gets written. You can get pretty far within the discipline of a CL "conforming program". I am possibly over cautious against flame bait but I much prefer to be safe than sorry in that department. 
That makes sense, thanks for the response. I understand how writing docs too early would be a wasteful exercise. By docs I didn't really mean the CLHS, since that's pretty well documented already . I more meant the C API and various docs about architecture and internal workings. Sounds like it's changing too rapidly for you to even write it though. Also, congratulations on the release =]
SBCL introduced this incompatibility to common practice. Usually it would have been thought, making a package creates one with a useful default. For example when working in a REPL and creating a package on the fly. That's not in the standard, but it was practice. Then the SBCL developers thought, it was bad to have a default and it was not specified, so let's change it. Since `MAKE-PACKAGE` and `DEFPACKAGE` have no standardized default package use list, the above behavior is undefined. Solution: provide a package use list when creating a package. Also note that MAKE-PACKAGE is a function and not executed while compiling a file. DEFPACKAGE OTOH has a compile-time side effect.
99% of the implementations did do it with a default and many Lisp books and a lot of source code made that assumption - regardless what the standard says. Especially since this change was introduced with ANSI CL and voted for in 1989 - after a different practice existed. Thanks to the SBCL authors to exploit this change without much benefit for the user.
I think SBCL's position is defensible. I'm fairly sure that the traditional (pre spec) behaviour was to use a default which was 'some list of packages convenient for that implementation which may or may not include some variant of the CL package', and code that relied on that 'worked' in the sense that you quite often got what you expected but occasionally suffered from the Spanish inquisition. Better to make such code fail immediately, really.
Thanks for the suggestion. I actually didn't even load paren-files as it didn't come up as a dependency. I'll look into it.
How about plain Javascript? There are node universe tools which do pretty much the same thing. Not that I don't know what you are getting at. I'm developing a game using my own super-weird lisp dialect that transpiles to JS too.
paren-psos and paren-files were both written by Red Daly and perhaps not entirely polished for public consumption. Great code though.
Wow, this is interesting news. I think this is fantastic!
thanks a lot for reviewing it...I will incorporate these into the code....valid point against nil's as a terminating condition in take...as told before, I am just in the learning phase...your comments were really helpful.
:)...it should be...thanks.
I don't use Clojure, but sometimes I feel bad for posts about it here. They are often doomed to be downvoted.
I understand your position, but I think that "being compatible with the spec" is much better defined and easier to comply with than "being compatible with tons of old source code *you* may happen to personally know of but that *most people* would not reasonably be expected to know about". It's easier and more concrete to "authoritatively" argue about what the spec says and doesn't say than about what tons of old code might appear to be saying. It's easier to agree on "conforming to the spec" than "conforming to an arbitrary apparent consensus". Also, as I understand it, one of the goals of making the Common Lisp specification was to document existing practice. What's the point if you're going to try to ignore the spec to defer directly to the old code and practices anyway?... As always, my 2¢.
Why not post in /r/Clojure for Clojure specific stuff? This post better belongs there, not here.
sbcl 1.1.16, defpackage.lisp ;;; the list of packages to use by default when no :USE argument is ;;; supplied to MAKE-PACKAGE or other package creation forms ;;; ;;; ANSI specifies (1) that MAKE-PACKAGE and DEFPACKAGE use the same ;;; value, and (2) that it (as an implementation-defined value) should ;;; be documented, which we do in the doc string. So for OAOO reasons ;;; we represent this value as a variable only at compile time, and ;;; then use #. readmacro hacks to splice it into the target code as a ;;; constant. (eval-when (:compile-toplevel) (defparameter *default-package-use-list* ;; ANSI says this is implementation-defined. So we make it NIL, ;; the way God intended. Anyone who actually wants a random value ;; is free to :USE (PACKAGE-USE-LIST :CL-USER) anyway.:-| nil)) 
see my [comment](http://www.reddit.com/r/lisp/comments/20vry7/makepackage_different_behavior_between/cg867tr) about sbcl. edit: on the other hand the sane default for any keyword regardless of the function is *NIL* **unless it is explicitly documented**.
Each implementation has its own default. By making package with unspecified use lists fail early, we avoid silently accepting incompatible code that might compile by accident, but actually `rm -rf /` (as [tfb points out](http://www.reddit.com/r/lisp/comments/20vry7/makepackage_different_behavior_between/cg79ei1)). This decision is in line with the general philosophy of SBCL: most of the time, we try to make it so safe code that runs on SBCL without warning will act the same on any standard-compliant implementation (unless it uses non-CL extensions, of course ;). BTW, the meaning of an empty `:use` list is specified in the standard. What's ill defined is the absence of any `:use` list.
This makes sense. Also, I didn't know empty `:use` was in the spec. Thanks for the reply.
Hm. It would be better to have a CDR to standardize behavior here, no? Implementation-defined is, IMO, ugly. Why should one form (that is not addressing implementation-specific extensions or OS level behavior) behave one way on one implementation and a different way elsewhere? That is bad form. Anyway, thanks for the information here and on SO.
This [interpreter](https://github.com/blakemcbride/LISPF4) and the compiler you posted are the only projects that I know of that merge the Lisp and Fortran languages. The Fortran files in the LISPF4 repo compiled on my machine with only small modifications. Pretty awesome for something made in the 70-80s! A related project is an implementation of Clojure's core.matrix using the fortran BLAS library via jblas https://github.com/tel/clatrix I've been returning to my scientific computing roots lately thus spending a lot of time with Fortran. Over the past couple of months, I've gotten to know the features of modern fortran (9X/20XX) and I like it. I like the module namespacing system with its "use only" directive to use only particular functions and subroutines from a module. [Pure procedures](http://h21007.www2.hp.com/portal/download/files/unprot/fortran/docs/lrm/lrm0157.htm) create functions and subroutines that have limited side-effects. The interface block allows for multiple dispatch procedures (e.g. [here](https://gist.github.com/jborden/9708981#file-push_array-f90) is the "push" interface I wrote for creating dynamically allocated arrays of different types). Modern fortran is surprisingly elegant. 
Fortran 77 on a Symbolics Lisp Machine: http://lispm.dyndns.org/images/Fortran-77-Genera-7-2.png
Do you have more information about how the fortran code is being used? I see at least two possibilities: fortran was being compiled to lisp, than executed or there was a fortran compiler whose executables were interfaced with the lisp machine's debugger. 
Fortran compiles to Lisp, which then compiles to machine code. With special support for debugging.
Found a bug in the Fortran code. Both values are stored in x1, instead of x1 and x2, respectively :)
Wow. I'm just learning clisp after years of C and Fortran, this is probably going to be one of the most helpful resources I could have ever ask! Thank you for posting.
That was another random-find submission. I was chatting a bit with [stream-lisp](http://www.stream-lisp.org/) author on twitter, we drifted into lisp-1 vs lisp-2, which led to [this](http://www.nhplace.com/kent/Papers/Technical-Issues.html) paper by Dick Gabriel etc etc All hail the web wanderfulness
Ah, got it. Cool.
Fortran was always more pleasant in practice than it seemed like it should be, somehow (though I've not used anything earlier than Fortran 77: earlier standards do seem a bit primitive).
&gt; Can Lisp read graphical input without too much hassle, could i set up a program that could track the movement of something like chess pieces in a chess program without having to turn my code into a monstrosity of external libraries and kinda functional hacks You can do whatever you want in lisp, including graphical processing. However, you're going to get more mileage standing on the shoulders of giants and using other people libraries. You would probably have good luck with something like OpenCV (a C library, but lisp can call out to C easily). Building something like this on your own without any programming experience is going to be ...upsetting. &gt; Can Lisp manage large databases / integrate itself to other languages like perl, lets say i wanted to make a program that learns to play chess like a Grandmaster, i program in how chess works and what piece does what etc, i then have it record 1000 games of chess and track every move and evaluate what moves are good, what moves are bad, and basically track everything and create a database, It can *connect* to large databases just fine =]. You would probably use something like BerkeleyDB or SQLite. Lisp can talk to either, and many others. --- AI is hard to start with for someone with little experience. So the first step is to be ok with the fact that it's going to take you a *long* time to figure it out. Secondly, lisp is a tool, not a magic wand to make AI easier. I personally think it's well suited for AI because it's fairly trivial for lisp to build lisp programs within itself and evaluate them. This comes from the fact that there's little distinction between *code* and *data* in lisp. `(+ 1 2)` is a list with three elements, but it's also code that evaluates to `3`. The ability to build and evaluate lisp forms trivially is a great tool in AI because a program can essentially add on to itself (if done correctly). I don't think you'll need much Perl. It's fairly well suited for crunching data, but you might as well just use lisp because I think it's just as well suited. Perl has a lower barrier to entry to when processing large amounts of files from the command line, but if your program is loading data from game feeds, parsing it, and sending it to a database, you won't necessarily need Perl to even be in the picture. If I were you, I'd take things in smaller chunks. Parsing graphical input of chess games is a fairly involved project. Reading it into some sort of machine learning system is another entire project in itself. I'd pick one of those and start there. It sounds like you're more interested in AI, so maybe just look for move logs for games played by masters and forget the whole graphical processing stuff. I've never built anything like what you're talking about, so maybe others can weigh in on specific methods. I have done some work with neural networks/genetic algorithms but those may not be as well suited to an AI chess player as some other form of machine learning. At some point the language you're using fades away and what's left are the concepts and the algorithms. I would read up on machine learning quite a bit if I were you, and see if you can get a hang of the inner workings of how some other chess AI systems work.
Instead of graphical processing, you might want to connect directly into the program you're running it with. Graphical processing could work, I'm not familiar with any libraries though. Lisp *can* manage large databases - it's very good at it. That's what lisp is all about! *LIS*t *P*rocessing. It's very easy to import databases - most LISP learning resources seem to go over that pretty early actually. They can be stored and read in whatever format you want - you might just have to program a few functions to translate if you want to do any odd migrations. edit; actually, this book, Practical Common Lisp: http://www.gigamonkeys.com/book/ Check it out! The first example program it walks you through is a basic mp3 database. It covers a lot of the functionality of LISP and databases right off the bat, so you can see if it's good for your aplication without too much investment. It walks you through setting up an environment, and then each and every line of code, letter for letter.
&gt; i know a lot about programming, but i've never taken the time to actually learn a language enough to be able to do anything with it. Sorry, but if you have never programmed in any language, then I don't see how you could know a lot about programming. Before starting to learn about AI, you should learn a bit of programming. Common Lisp is certainly fine for that, too, you should start with Seibel's Practical Common Lisp. Then you can progress to Norvig's PAIP book, which is a good intro into classical AI approaches. This will take a lot of time, but the journey should be enjoyable. Common Lisp will serve you well.
"In theory, theory and practice are the same; in practice, theory and practice are different", "No battle plan survives contact with the enemy", "You can't learn to swim without getting your feet wet", etc. :-)
Bad wording, what i meant to say is i know a lot of the theory of programming, but i have very little experience creating applications, i actually programmed in a lot of languages, since i tried a lot of different languages when choosing which one to learn, so i know most of the basic concepts of programming, Anyways, your advice is greatly appreciated. Thanks :)
You need to learn to program first. You might try using A Gentle Introduction to Symbolic Programming as your introductory text for this task. Expect to take 1-2 years to be comfortable doing well in programming. Best of luck, and don't be afraid to ask questions.
I got swept up in the hype of it as a language for wizards, now I just think it's a very practical language What dialect did you use? Scheme? Common lisp?
I used Common Lisp and used the Cygwin terminal and Emacs. Is Common Lisp the best dialect?
No I don't think I did, however it looks as though it would have made the experience less frustrating. From a quick Google search it seems SLIME is a way to enhance EMACs for programming in CLISP, I defiantly didn't do that, just used EMACS as a text editor. 
Haha cheers man.
Thanks for the mention =].
I came to lisp from PHP a few years back and found web development to be a bit of a paradigm shift. I was looking for basically a mod_lisp (which in my mind would magically let apache serve my lisp files individual scripts, much like PHP). Instead of having one script &lt;--&gt; one page like PHP's most basic form of operation, with lisp you're going to set up what's basically an app server and send your requests to it from apache (reverse-proxy). This is almost like how php-fpm works (if you're familiar). The webserver (apache, nginx, ...) serves your *static content* (image files, CSS, etc) and sends any other requests back to your lisp process. As far as what to use for you backend process, there are a few options. If you're starting out, I'd check out [Hunchentoot](http://weitz.de/hunchentoot/). It's a threaded server (one thread per request) so it's going to act a bit like PHP as far as a request -&gt; response cycle. Hunchentoot is established and very stable. There are a number of frameworks people have built for it that add nicer routing and organization. If you're familiar with evented/async/non-blocking programming, there are a few options as well. I built [Wookie](http://wookie.beeets.com), which is an evented app server. It's nice because it runs on top of cl-async, which means you can use any of the [drivers built on cl-async](http://orthecreedence.github.io/cl-async/drivers) in your app. Admittedly, the list is pretty tiny, but growing over time. There's also [Teepeedee2](https://github.com/vii/teepeedee2), which is supposedly the fastest webserver around (in any language), although I don't think anyone has verified this claim except the author =]. So my general setup is Nginx (for static content) which reverse proxies to Wookie. For static websites, I have a makeshift markdown templating engine modeled a bit after Jekyll. I need to package it and document it sometime since I use it in a number of sites, but for now you can read the source for the [wookie doc site](https://github.com/orthecreedence/wookie-doc) (specifically `template.lisp`, and check out the `views/` folder). For dynamic websites, I build a REST(y) API in Wookie and just have the entire front-end live in javascript, which modern browsers are more than capable of (much like an iPhone app). An example of this is [musio.com](http://musio.com), which doesn't use lisp in the actual serving of web content (it's PHP) but the entire JS app is downloaded up-front and all page changes are pushState/AJAX/etc. It's a really nice model to work with if you like javascript.
I'n 2003 I was a Perl/Python/C web developer. In 2004 I moved over to Common Lisp and have used it ever since. I program web applications for a living. I am not a web developer, but a lisper. Setup is SBCL or CCL with hunchentoot usually. &gt; How has lisp made your development more efficient/enjoyable? The fact that you asked "how [...]?" and not 'can it [...]?' is also the answer. 
Actually, it's on the way! Turtl is all based on note-taking right now, which probably won't do you much good if you're looking for a Dropbox replacement (you have to manually download, modify, and re-attach files). It's more of an Evernote replacement as it is now. Currently there are three versions of Turtl: chrome, firefox, and desktop. Although they share a common core, it's still a pain maintaining all three. In the next few weeks, I'm going to completely obliterate the browser extensions and replace them with simple bookmarking that just talks to the desktop app. This will make the desktop app the single place where all Turtl code lives, and will also allow me to start building in some more features I want without having to worry about adding those features in the extensions (I've been trying to keep feature parity between desktop and browsers which is exhausting). My ultimate goal is for Turtl to be able to open a new drive/mount on the computer it's running on and any files put on that drive would be automatically encrypted/synced. This would almost be a marriage between TrueCrypt and Dropbox. When you log out, that drive disappears, and if you log in on a new computer, your files will be pulled down automatically. I'd like to keep the note-taking/bookmarking aspects as well, but file syncing is a big target for Turtl. I'm also going to be going after the mobile market pretty soon. Got a lot to juggle though!
There's a quite new book "Lisp Web Tales" available http://lispwebtales.ppenev.com/
Pharen has been around for a while now (since I started programming in CL) and I've always wanted to try it out but never had the opportunity. I like it. It's lexically scoped and translates fairly well down to PHP (as in, you could read it and know what's happening without seeing the generated code).
Yeah, I usually program in a Unix operating system, but for this project I just used what they told us to use; because I started it pretty last minute and I wasn't familiar with the language or functional programming. 
Actually, I'm interested in this as well. Looks awesome. Thanks for posting.
I like it too but I think the compiler has a bug. I tried writing a subset function using nested HOF (see https://gist.github.com/agumonkey/9749615)
There are a few other blog posts in the spirit of this book around the web
That's an interesting idea, especially for someone who's not very well-versed in osx (me). I wouldn't have thought of anything like that. I'll keep that in mind when I'm looking for ways to build the file syncing stuff. Thanks! 
Book: [Web development with Clojure](http://pragprog.com/book/dswdcloj/web-development-with-clojure). Tons of slides, blogs etc.
I'm a web developer and has been trying to use Common Lisp for web development for a few years. [ningle](http://8arrow.org/ningle/) and [Caveman2](http://8arrow.org/caveman/) are CL web frameworks that may be worth considering. Since both of them base on [Clack](http://clacklisp.org/), you don't need to depend on a specific web server, ex. Hunchentoot. FYI, http://quickdocs.org/ is written with Caveman2.
What about the Google templating lib? I can't remember the name of it, but I'm assuming that you know the one I'm talking about.
Check out camlistore project, they have very similar ideas, perhaps you can use them as a backend.
Looks impressive, thanks for the tip.
I wrote my own templating library: [hh-web](https://github.com/hargettp/hh-web). What I always frustrated me about front-end web development is it never seemed modular: to a date picker to a page, for example, you have to add the markup, then you have to update your script library references, then you have to possibly add your own script to handle events on that picker, then you have to add any style tweaks to your CSS, etc. The central concept of the library I created is that of a "tag" which let's you include all this stuff in a bundle, so that if you use that tag on a web page (or a template in this library) all the HTML, CSS, JS, etc. will be rendered onto the page for you. 
&gt; any templating libraries along the lines of jinja that would allow for nested pages. You mean a templating library which has template inheritance? I think there's no such thing in Common Lisp world. I hope somebody ports Jinja2 to CL.
Yeah, Jinja2 on CL would be ideal. It looks like CL-EMB could be extended to support template inheritance... But really I just wanted to put together an app. Maybe when I get some time to circle back I could look at how difficult it would be.
I saw the cl-closure-templates. Couldn't really tell from the examples whether it supported template inheritance, and so I started somewhere else. Moved, started a new job, etc. and so I haven't been able to continue my lisp experiments. 
I've found that the world is full of horrible and malformed html that does not parse with anything saner than a browser. In that case, I have found no better solution than writing awful regexps with cl-ppcre on the output of drakma
I wrote [xml-match](https://github.com/ivan4th/xml-match) library some time ago and used it to convert some pathological HTML to a proprietary semantic XML format. It works with cxml-stp though (not cxml-dom). There are also other pattern matchers that are useful for web scraping, doing it via DOM is just painful.
I almost missed the mention to https://github.com/AccelerationNet/css-selectors css3 query language library. Dank U.
Somebody (Preferably not me) should port Scrapy over to CL.
cl-closure-templates supports inheritance.
Well, I should probably do a proper writeup and upload some parts; anyway here's how I've done my last scraping: - patched CL-HTML5-PARSER to use the CXML API, which allows me to - use PLEXIPPUS-XPATH for queries, - generate results and - output to LaTeX, Graphviz, some R scripts to produce a PDF Works quite well, however it has a lot of dependencies apart from the Lisp side, which makes setup a bit painful.
"We simply did not find enough interesting commercial projects that have not been presented on one of the previous ECLMs." That bar is too high. 
Truly a bummer. ECLM is a great format for hearing about cool Common Lisp stuff and meeting practical Common Lisp hackers.
The official way to control whether Drakma returns a string or an octet vector is by binding `drakma:*text-content-types*`. Also, I would recommended against using CHTML: it's rather old (doesn't handle HTML5), buggy (bad markup can put the parser into an infinite loop), and appears to be unmaintained. CL-HTML5-PARSER works better, even on older documents, and is actively maintained. 
As a quick note, this is great for traditional websites that serve static content but more and more you're going to be dealing with sites that generate a lot (or everything) in the browser via javascript. Although not lisp, PhantomJS is a great tool for web scraping that gives you the *true* content (as in, the actual generated DOM that users see) for any page. It has the added benefit of saving you from dealing with bad markup since Webkit handles it for you. I used Phantom at my last company as part of a queuing system (built in lisp of course) that would scrape our own pages and serve the content to search engines. This let us have a completely browser-driven webapp where all pages were generated in JS, but also boost our SEO via self-scraping. Worked really well and google loved us.
Very cool! I started work on hh-web in 2010; Polymer has been on GitHub since 2012. Yes, well after I finished the early implementations, later packages such as Polymer and AngularJS started to appear, but more focused on either a browser-side implementation or Node.js (both written in Javascript). The advantage of hh-web (for this audience) is that it is written in pure Common Lisp, which in IMHO is a superior language to Javascript.
If I understand your meaning of template inheritance correctly, then the [hh-web](https://github.com/hargettp/hh-web) package I mentioned earlier does support that, although instead of "template" the term is "tag." Since tags can arbitrarily reuse other tags, and tags can take not only parameters but other tags in their body, it's completely possible to define a tag type that defines a "standard page" layout, and just apply the parameters or body needed to instantiate for a specific use. Every occasion I've used hh-web I wound up doing just that: setting up a few base tags to define my page layouts, then used those as wrappers around the content-specific or page-specific page elements needed for a given page. Oh, and actually, since this is Common Lisp, it is actually possible to have tags "derive" their behavior/appearance from other "base" tags. That's a separate concept from simply inheriting or reusing a template. For example, in the base HTML tag library shipped with it, all of the HTML elements typically used as input controls in a form derive from a common "input" tag, since they all render to the same HTML input element anyway. 
Second it. I think ECLM (and general CL conferences) should be more open to small and practical projects and behave less like nuclear physics meetings with exclusive membership. Look and learn from Clojure and Racket conferences...
There's definitely been a huge amount of improvement on the client side frameworks in recent history. Probably mostly due to browsers starting to support more advanced features, and generally not needing to support IE6,7 etc. anymore. Also, very much agree with CL being a better language than JS. Although, after reading "Javascript the Good Parts" I feel a lot more comfortable with the language. Turns out if you boil it down to a smaller core language, there's an alright language hiding in there. Add a functional library like [UnderscoreJS]{http://underscorejs.org/} and it's pretty pleasant. 
I also use CL+ParenScript+PhantomJS for web scraping: https://github.com/eryx67/cl-phantomjs so exact example from CasperJS site, http://docs.casperjs.org/en/latest/quickstart.html#now-let-s-scrape-google, looks like: (let ((script (phjs:wrap-ps (defvar casper (ps:chain (require "casper") (create))) (defvar links (list)) (defun get-links () (defvar links ((ps:@ document query-selector-all) "h3.r a")) (*array.prototype.map.call links (lambda (e) ((ps:@ e get-attribute) "href")))) (casper.start "http://google.fr" (lambda () (this.fill "form[action=\"/search\"]" (ps:create :q "casperjs") t))) (casper.then (lambda () (setq links (this.evaluate get-links)) (this.fill "form[action=\"/search\"]" (ps:create :q "phantomjs") t))) (casper.then (lambda () (setq links (links.concat (this.evaluate get-links))) (return links))) (casper.run (lambda () (phjs:phjs-send (ps:create :found links.length :links links)))) (return t) ))) (phjs:with-phantomjs (srv) (phjs:call srv script) (phjs:receive (srv msg) (phjs:return-from-receive (hash-table-plist msg))))) 
You should organize one.
I use EQL with module :webkit, [see trivial example](http://gitorious.org/eql/eql/blobs/master/examples/M-modules/webkit/strip-html.lisp). It gives Lisp access to WebKit, and CSS2 selector support (integrated in QWebKit).
Did not know this existed. I'm bookmarking this project. Thanks!
I wrote http://hashmoot.com/ as my first real Common Lisp project and I thought I'd chip in about the web development aspect of it. (This is my first ever Reddit post, so please be gentle!) My background lately has been C# and .NET. One thing that surprised me was how good it was to do things in the REPL rather than debug/step through code or create unit tests. Being able to interact with the objects gave me a different appreciation for what was going on. Being able to instantiate objects and interact with them was much more powerful than I expected, despite the number of times people told me it would be! The problems I faced were usually because of a combination of a library and my lack of understanding. For example, I use cl-twitter in a limited way, and I still haven't fully grokked its approach. The source code is there for me to read, but some of it is still a bit beyond me. Starting out, Emacs and Quicklisp were great to use. I wouldn't want to try using Common Lisp without Quicklisp. I didn't use RESTAS for very much, but what I did use it for just worked. I had some difficulties using cl-closure-templates (which again could well be down to my lack of understanding) so I'd probably try a different templating mechanism next time. I'm going to check out some of the other ones people have mentioned here. The use of cl-closure-templates did force me to separate out logic from display. With no evaluation mechanism in the templates (as far as I know) you have to evaluate all the values you're going to render before passing just the data to the template. This is usually how it's recommended to do things in other environments but I liked the 'cleanliness' this brought. No intermingling of code blocks inside HTML made it all much clearer (although maybe it's not too fair a test because http://hashmoot.com/ is a fairly simple site). Overall, I was impressed with the breadth of things I could do in Common Lisp. It's a general programming environment that has been doing useful things for years, rather than a web-focused platform or a new platform with limited libraries for non-web stuff.
In my experience, I think Lisp is great for developing APIs on the backend, not so much for the front-end. There are tons of tools in the Javascript community that is better suited. On the API side of things, you're free to use whatever you want to build an API. So I have a Node.js server that does everything it's good at, and communicates with my Lisp API for the fun Lisp work.
Not true at all. Everything on the "frontend" can be specified by judicious use of macros with associated CSS and parenscript inclusion. 
I have been told that some of bigger players render scraped pages and then do OCR on that.
Sure, well, you probably should use Emacs and [SLIME](http://common-lisp.net/project/slime/doc/html/index.html#Top) because you'll really be missing out, especially when it comes to debugging, if you're not. And you'll also want to set-up and use [Quicklisp](http://www.quicklisp.org/) to manage your CL libraries.
I would also recommend the EVIL extension so your emacs distro has a text editor to work with.
Thanks! From people who have previously had this class they say that lisp is the worst part so I'm trying to learn as much about it as possible.
By worst, do you mean hardest? Or is the course material bad? 
Lisp isn't evil but it is old. You have to tolerate the obscure naming and general cruft that comes with it. However if you stick with it, you'll at least be glad you learned it, and forever curse most languages for being far less cool than Lisp. And if you want to learn something that fixes all the horrible naming, try [Chicken Scheme](https://en.wikipedia.org/wiki/Chicken_%28Scheme_implementation%29). Two more hints. Download the Hyperspec (using something like [sitesucker](http://www.sitesucker.us/home.html)). Once you have it local, you can set up Emacs to look-up any identifier in it with one line in your .emacs: (setq common-lisp-hyperspec-root "file:///users/ddp/src/HyperSpec/") In other words, if you're sitting on a line in the SLIME REPL that starts with "(defun", while your cursor is on the "d" in "defun", you can invoke a SLIME command to go open a tab in your browser that goes to the definition of the Lisp macro for "defun" (or whatever else you're pointing at). Super useful. There's also a site called [Lispdoc](http://www.lispdoc.com/). The following Emacs lisp (elisp) can be bound to a key to look up any identifier there: (defun ddp-lispdoc () "Searches lispdoc.com for symbol under point." (interactive) (let* ((symbol-at-point (symbol-at-point)) (thing (symbol-name symbol-at-point))) (browse-url (concat "http://lispdoc.com?q=" thing "&amp;search=basic+search")))) You'll note that Emacs' extension language is Lisp, more or less. Enjoy the ride! :-) 
They say it is the hardest that we learn. But its just a basic programming class. We are just doing MATLAB and Simulink as well as Lisp. It doesn't help our professor is crap.
Commenters seem to be assuming you're learning Common Lisp. Is it Common Lisp or Scheme that you're learning, or both?
That is the class!
A good environment is nice. But making learning it fun and interesting is better. Once you get into it you will want to get your environment sorted. Here is something cool a youtube demo of a demo of the computer vision library common-cv (a binding ot opencv): https://www.youtube.com/watch?v=m_ytVKMqm-k Once you take in intrest you and want to hack something then that will motivate you will go out and learn what you need to know. 
That's the weirdest combination of languages I've ever heard for a basic programming class. Lisp is awesome but has a somewhat steep learning curve. [The first paragraph at this link might be a bit helpful](http://learnyouahaskell.com/introduction#so-whats-haskell). It's about Haskell, another functional programming language, and that paragraph describes Lisp just as well.
It's probably an early engineering course, maybe with a focus in AI? 
At the risk of pissing people off, I would second suggestions here that you learn Scheme instead of Common Lisp. It's a lot cleaner and you won't get bogged down in a lot of distractions inherent to Common Lisp. This was just my experience after trying CL and switching to Racket. Racket seems fairly popular, and there's also Chicken Scheme. Clojure may be more practical (for some definition of practical).
While Racket has better documentation, more examples and more libraries than CL, it somehow seems just as full of "distractions" as CL to me. That doesn't mean it's not a good Lisp to learn.
I don't have any philosophical objection to vi bindings, but I'm not sure it's wise to go with Evil mode when first learning Emacs. Mixing the two interfaces is bound to be somewhat confusing for someone just getting accustomed to the environment. Unless you're already proficient with vi, I'd say at least stick with the regular Emacs bindings while you're learning so the tutorials make sense. Then you can switch to something nonstandard if you feel like it. (Of course, this may be my preference for Emacs talking. :P )
The definition of a lisp is fairly vague and it could easily be argued whether Kernel fits that definition or not. I'm not particularly interested in arguing definitions. W.r.t fexpers in lisp, I assume you are referring to the Pitman paper from 1980? What's the point of bringing that up?
Lisp is not a single idea. It's several which work together seemlessly to create something more. For example, lisp can be seen as expressing the AST (Abstract Syntax Tree) instead of parsing the language and then creating one. Also, since lisp compiles as it runs the same functions are available at compile time. These work together by creating a macro system which can use lisp to generate lisp. Wait until you learn about conditions and restarts, you have no idea what you are missing. Oh, and the CLOS (Common Lisp Object System) is based on the MOP (Meta Object Protocol) and shames most other object oriented programming languages. Oh, and you can customize the parser and it's self documenting. I guess what I am saying is, Lisp is car wax and a desert topping. Or taking the red pill, and the blue pill with a bottle of whisky. 
What uni is KU :)?
There's /r/learnlisp if you have any further questions!
Spend some time getting to know your editor, and let it handle parentheses matching and formatting for you. One of Lisp's great strengths is homoiconicity, but it can be frustrating to work with when you're more accustomed to the more-or-less line-based editing style of many other programming languages. If you use emacs, the paredit package makes expression-based editing easy and fun (and you'll miss the experience when you switch to working in other syntax-styled languages). I don't know enough about other editors to comment on the support they provide. When I was starting out, I found lisp _very_ frustrating to work with, because I thought I had to manually manage all these little parens, and keep them balanced and so on -- I just want to re-order these two expressions, gah I deleted the wrong thing aah wtf this sucks etc etc. Learning to edit the source was a hurdle to learning the concepts in the language. Once I learned to use supporting tools better, that all changed. I now find lisp syntax _easier_ to work with than other languages, and more fun.
It's the University of Kansas
Well, reading history is important. This way you can better understand many design decisions made by developers over time. And learning so called "philosophy" is vital thing just because following it is usually the most reasonable way of writing in Lisps (in Lisp**s**, because generally all Lisp dialects have many things in common). However, I partially agree with you: one shouldn't spend too much time reading it instead of doing something else.
Evil mode lacks some important features, though. Especially, paredit behaves quite insanely sometimes because of some thing inside Evil and text manipulations don't always work correctly. I tried fixing it but failed as I lack Emacs Lisp knowledge. I use Evil mode with Emacs too, as well as VIM with slimv. However, I personally find Emacs + Evil + SLIME combination better for working with Lisp code and VIM for working with plain (or something close to it) text.
Since this is for a university course, it will probably be scheme. The reasoning is usually that you still get all the lisp with a greatly reduced learning curve... 
Avoid taking Dr. Brown's CS course on Scheme. He taught for a good decade by simply reading the buggy slides that come with SICP. Another decade later, and it looks like he is still on the faculty... I'm rather surprised the Aero dept has Lisp in the curriculum. Fortran, C, or even Excel are the traditional choices in that area. Your prof has an unusual background for the Aero dept. Maybe he has a connection to Odonata Research LLC? Then again, with all the interest in UAVs, it makes sense to fuse AI with Aero, and Lisp definitely excels in that area.
Racket has cleanly defined sub-languages that are tastefully chosen for the express purpose of sticking to only a core set of fundamental concepts. I would say it's one of the better lisps to learn in that it's specifically meant to be used as a pedagogical language.
The first thing you should know. Lisp is the best language you're going to find in this lifetime and the next. Stick with it. Don't get discouraged by arbitrary difficulties like matching parens. The parens allow structured editing with paredit. You can perform operations on the structure of the program, instead of "raw" edits on plain text. It's something that just isn't possible in other languages. The parens also allow a consistent syntax throughout the language. This opens up the door to easily write code that manipulates code. Matching parens turn out to be an asset.
I didn't write lispdoc. Bill Moorier (née Bland) wrote it.
Fair enough. I got pretty confused when I tried to use Evil mode when I started with Emacs though. The mixture of a modal interface with a command oriented one was disorienting. (and I'm assuming the OP may be unfamiliar with both.)
Ah, okay. Corrected. It still rocks! :-)
OK, so it's a brief introduction, and it's almost certainly Scheme (and not taught by Dr. Brown). Maybe this is something most beginners know anyway, but Scheme is a great language for students. Like other Lisps, it's based on a theory of computation and has a conceptual elegance, power and depth consistent with its mathematical origins. Scheme is particularly simple, consistent and clean. There's just about zero syntax to learn, but it may challenge you to look at programming from a functional perspective and to deal with a certain absence of "syntactic sugar." In particular, you'll probably find yourself using a lot of recursion in your homework assignments. Scheme is very approachable, but there's no limit to where you can go with it. Like other Lisps, it can have a profound effect on your understanding of what programming is and how to go about it. A brief introduction may not teach you a lot, but perhaps it will be a watershed in terms of how it inspires you. Good luck!
Patience. Most beginners tend to lack patience and the desire to stick with things. They then walk away frustrated that the gem they were looking for not only was in the dirt, but needed cutting and polishing before it was worth setting. But the gem still exists, for those who will work on it.
I do agree with you on that point. But I feel that overall the language is quite baroque and thus it has the potential to be somewhat confusing for a beginner.
Don't panic.
There is something often missed with CL (common lisp): it can be used as a low level language. Look at byte manipulation or I/O tools in CL. Check what CL have in common with diametrically opposed languages like C. I think it's a good entry point for understand in a second time what make lisp very unique. But remember : each language have it's own appropriate usage. Nevertheless, CL is good for a large panel of non-professionnal projects
After the internet has largely abandoned April Fool's Day jokes, it doesn't surprise me that a lisp implementation would feel the need to remind everyone what this day is all about. 
I've seen loads of April fool jokes today :)
i was like **woow** .. then i saw your comment. :(
Here is a funny joke: any breaking news about Common Lisp at all.
Here is a funny joke: oh my god, that one was awesome!
&gt; Even the error messages are slightly more user friendly. he, he...
Fuckin 1st of April...... EVEVRY.DAMN.TIME
Of all the lameness on the front page today this one actually was good. I had to click to confirm! :)
I fooled by that. Damn it :)
I did a bunch of work on slime-cl-indent a few years ago, dunno if there is something more recent. The enhancements include support for named styles you can set per file, etc.
http://random-state.net/log/3516613715.html
Sorry for my useless post, but I just want to say that I love internet for moments like this.
There is [djula](https://github.com/nubgames/djula) (older repo with docs [here](https://github.com/nallen05/djula)), a port of Django templates which is quite similar to Jinja2. The syntax is almost identical and it also supports inheritance. I guess, one could easily extend it to support Jinja2 or Liquid.
A friend remarked that everything is 20 years ago - except the things that happened very recently, which are 10 years ago. :) With software 10 and 5 years might be closer to mark, but... :)
Interesting... do you have the original link?
https://groups.google.com/forum/#!original/comp.lang.lisp/oSslA8mJdho/bykVwkiIMcUJ 
It looks like someone is learning lisp and decided to make a website that copies/steals things they have read. It is very odd, but either they do not care about ownership and like re-publishing stuff from usenet, or are as clueless about that as they are about Lisp and Common Lisp. Regardless, I knew it was Xach from the get go! (then again, I read c.l.l). 
I always found the 'its only bits' very inspiring, freeing from the 'native code' mindset. Thanks.
What is ~v? I can't find it in the hyperspec. The bit about incremental programming with ILISP/Slime is good. I've often wanted to communicate this to people but never thought about how best to say it. Now I will say this. I'm still yet to convince anyone in real life to try Lisp, though. Their loss, I suppose.
It means a placeholder used in arguments of directives in formatting string of the format function, an actual value you pass as an extraordinary argument to the format function itself. I recommend read [CLtL2](http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node200.html) instead of CLHS in cases: * formatted output * loop macro
These are not the most current versions of SBCL, but the latest compiled versions of SBCL, that's why. In other words: SBCL is mainly tested under GNU/Linux on a 64 bits processor and not-so-tested on any other platform, probably for reasons of time and money.
Do they just need help with release engineering to keep everything updated?
Perhaps there's some form of cost benefit analysis going on and there's not as much demand for precompiled binaries on many of those platforms. Just looking at what I have: stable 1.1.16 on Mac OS from Homebrew and stable 1.0.8 on Linux using apt-get. Homebrew fetches the source, patches it, and compiles it locally. I'm not sure who compiles the Linux version I get using apt-get, but I presume it's Ubuntu since I'm using their repositories. In both cases I used the easiest install path for the OS and I'm pretty sure neither used a binary from the SBCL guys.
Do you have some basis for saying that "Windows users tend to use CLISP or commercial implementation"? 
All you need to do is download the currently available binary and the latest version. Install the binary and then install the latest version sources
I'm a little late to this, but if I may cons an 'aha!' moment I had today to the list: * To adopt an OOP style is to reference the return value of a lambda expression within the body of a lambda expression.
Yes, it would be preferable if more platforms were up to date, and we do lack time. I understand even Linux is a pain right now: our most frequent builders have to mess with their environments to ensure backward compatibility with older glibc.
I actually laughed. 
Basically use arrays rather than lists whenever possible. Lists can bring about worst case performance on caching CPUs. The general practice in Lisp is to use lists to begin with because they're very easy to work with and flexible and then switch them to more appropriate data structures later. Often this is because you want better "big-Oh", this is why you'd switch to a hash map, for example. But even if you're just iterating through a list you can help the cache by switching to an array even though the big-O won't change.
Just use a multidimensional array? Each `transform` just boils down to a 3 * 4 array of real numbers to begin with. This means giving up the flexibility of having a more generic representation, but the whole point of this pattern is to trade that flexibility for performance. It's a little easier in C++ because of its value types, but here it shouldn't be hard at all to write your own accessors. Also, be careful that you've got an array element type that your implementation can actually pack into an array unboxed. [`FLOAT` is the supertype of `SINGLE-FLOAT` and `DOUBLE-FLOAT`](http://www.lispworks.com/documentation/lw50/CLHS/Body/t_float.htm), so `FLOAT`s will be boxed to maintain the flexibility of having floats with two different sizes and layouts[1]. You can verify this with [`UPGRADED-ARRAY-ELEMENT-TYPE`](http://clhs.lisp.se/Body/f_upgr_1.htm), which returns `T` on SBCL (64-bit Darwin). [1] In theory it wouldn't need boxing if `DOUBLE-FLOAT`, `SINGLE-FLOAT` and `LONG-FLOAT` are all the same type, but I don't think any current implementations do that.
 (code-in (head (remove-if (lambda (x) (equal x 'PHP)) language-preferences))) codeIn . head . filter (/="PHP") $ languagePreferences Meh.
Definately look into paredit. It is a big deal. It allows structured editing on the code rather than raw text edits.
Can anybody tell me what is Clojure (primarily) used for? I see a lot of people playing around with it, but I've yet to see it listed in a job posting. Or there isn't a "killer app/domain" for Clojure?
Clojure is much *much* more popular than Common Lisp if you're in the bay area startup scene. So, web apps.
It's seen some uptake in 'big data' analytics work. For clojure, IMO, the killer app is a Lisp on the JVM that's designed to fit around the JVM.
Its worth noting that DEFSTRUCT can create array-based structures which should help with memory contiguity, provided the values are not boxed: (defstruct (vector3 (:type vector)) (x 0.0 :type single-float) (y 0.0 :type single-float) (z 0.0 :type single-float)) 
It's possible, with judicious use of structures and by permuting data in struct of arrays format. CL definitely makes arrays of structs painful… although there are cumbersome hacks to fake them with specialised arrays and indexing tricks (or multi-dimensional arrays), or via the FFI. Still, the endgame is often SoA and specialised arrays work fine for that purpose. I find it interesting that SoA layouts are perfectly suited to MAP/MAP-INTO.
Clojure is currently dominating [Functional Jobs](http://functionaljobs.com). Take a look there.
Shouldn't a decent GC already be better at this than C? Caches use the idea that related information tends to be closer together (so grabbing data close to the data requested is more likely to correctly pre-fetch). In C, you allocate to memory and the location never changes. Over time, related data can become spread across the heap. In contrast, GCs perform heap compaction which tends to put related pointers and data close together (and most linked lists tend to be close together -- if not actually right next to each other). The cost for this is GC pauses and cycles spent compacting (reduced by multi-threaded and generational collectors)
I would personally hope for any competent Lisp implementation that the storage for a structure is already a vector. Just with an added type tag or something else to find the type for the structure.
Outside the startup scene, mostly on finance and big data analysis for people looking for a modern Lisp. Before anyone downvotes me, yes Common Lisp is the right Lisp, but the industry has chosen another path.
I'll add mine. It's beginner stuff so you may find it boring, but I remember them as really interesting Aha! moments when I was learning. * Realizing that lambda and let are actually the same thing. * Learning that OO can be elegant and flexible, not just a messy way to bundle state and behavior together in hierarchical spaghetti code. * Finding that syntax can be simple. Later... finding why it's so important that syntax be simple. * Reflecting on the fact that there are actually languages that I can keep in my head without a huge cognitive overload and over-complicated semantics/corner cases. * Finally, understanding that even if it doesn't do what I want it to, I can change it or implement my own, relatively easily (Lisp in general and Scheme in particular was the reason I got into interpreters). 
I use LIL every day, fwiw.
Really? What do you use it for? Just defining any ordinary data structure? What do you find nice about LiL? I'm interested in using it.
I imagine that the stack will likely forever live in the cache. The use of the stack to hold data is unique, but might be a pattern worth looking at. http://www.more-magic.net/posts/internals-gc.html
&gt; What do you use it for? Defining interfaces of course. &gt; Just defining any ordinary data structure? No, the exact opposite. You define an interface, and it does not matter what data-structure underlies the interface. The same interface works for any structure. &gt; What do you find nice about LiL? I have been using Interface Passing Style for a while now, like 5 years, and LiL simply puts together all the things that I had done before.
I'm also interested in it, too. the only consideration is about speed. is it possible to move the runtime dispatch into the compilation time? I think the gf dispatch (like `(gf &lt;interface&gt; A B)`) is done in runtime. I'm sorry if I'm not correct.
I personally think it's a dead end. CLIM was doomed to die since very beginning. Basically, it was an attempt to reinvent the bicycle just because "we can do this in Lisp". However, many people think that CLIM has a horrible/overloaded/overcomplicated/inefficient architecture. I guess that's the reason why no one works on it anymore. Don't panic, we have many other great (or close to that) GUI libraries/frameworks, i.e. Qt, Tk, so it's not *that* bad. Nevertheless, the idea that stood behind CLIM was nice, too bad nobody decided to complete it.
I have been Lisping full time for 10 years, and have not used McCLIM in about 7. So it is a dead end for experienced open source common lispers, imho. I suggest looking at Allegro or Lispworks if you want CLIM.
I strongly disagree with the idea that it was an attempt to reinvent the bicycle just because "we can do this in Lisp." - it was a different way of looking at user interfaces, and happened to be done in Lisp. There was a sub-thread on comp.lang.lisp a number of years ago, discussing whether or not Emacs+Garnet was as good as Genera as a development environment. Kent Pitman posted a few comments explaining what Genera had that other systems don't, and those features had CLIM's predecessor, Dynamic Windows, at their core: [Comment #1](https://groups.google.com/d/msg/comp.lang.lisp/XpvUwF2xKbk/o6CKxgzNLFUJ) [Comment #2](https://groups.google.com/d/msg/comp.lang.lisp/XpvUwF2xKbk/Xz4Mww0ZwLIJ). I do sort of agree that it was doomed to die, but more because I am cynical and believe that [worse is better](http://en.wikipedia.org/wiki/Worse_is_better) is a good explanation of why inferior solutions seem to always win in the end. I understand that Dylan had a successor to CLIM called DUIM, but I have not looked into it. I don't know whether they changed anything substantially, or just ported CLIM to Dylan.
Just out of curiosity: is Genera still used and how good is it? I want to try it, but I don't have a DEC Alpha.
I see. I guess something is just wrong with me that I see bicycles and inefficiency everywhere.
It's possible to run it on a virtual machine. Look [here](http://www.advogato.org/person/johnw/diary/12.html) and [here](https://github.com/ynniv/opengenera) for further instructions.
Pretty sure there's a guy on #lisp who is maintaining MCLIM in some sense. Can't remember his nick though. For pragmatic purposes, it's not used anymore.
And, when was the last time I used Lisp on Lines? And why is that fact that I think LoL is dead as well funny to you? You have an odd sense of humour indeed ... any other project, that I do not use, that is "funny" as well? For that matter, I would like to know exactly what you find similar between CLIM and LoL ... can you show me an example? I have not used CLIM in a long time, and LoL in about 3 years for that matter, so you will have to be a bit more specific than "They both use MOP!" or "The web and the desktop are the same, so they are the same!".
Ah, thanks. I'll check it out :)
I think it's important to understand early on that the parentheses aren't annoying or weird, they are just a really simple syntax for writing trees. You write into the Lisp syntax tree directly and the sooner you understand that the sooner you stop seeing the parentheses and just see the trees.
As for 'continuing,' it looks like robert strandh is sketching out what [a "CLIM 3" could/should be](https://github.com/robert-strandh/CLIMatis) It's in very early stages but it's the only instance of a CLIM being developed in the open and recently that I know.
"Funny" really means "remarkable" in this context. It's remarkable to me because you declare McCLIM dead and because of the subjectively perceived similarity of CLIM and LoL. And I took your verdict about McCLIM to be broader than you probably meant it, applying it to CLIM the spec, when you where talking about McCLIM the implementation. CLIM and Lol both approach their field on a higher abstraction level than usual. Both support common operations on the domain objects independent of visual appearance / interface. Note that I have not really used either of the two. I do not want to come across as a wannabe expert. That would be ridiculous when talking to author of LoL. I just played with them for educational purposes. I thought LoL was very cool especially the MAO part. I could imagine several applications for it, for example entities/inventory objects in games. I did not know you regard LoL as dead. If this is so, it's a pity. It used to be in quicklisp, why has it been dropped? 
&gt; subjectively perceived similarity of CLIM and LoL Definition of similarity? Because I have a version of LoL that has [Mc]CLIM as the backend... and a version that uses CLX as the backend ... and a version that uses SQL as the backend ... so I would like to know more about what is perceived as similar. &gt; I thought LoL was very cool especially the MAO part. I still use MAO every day, and for that matter, my modern "Lisp on Lines", which is basically the LoL I did in 2005 reborn. &gt; I did not know you regard LoL as dead. If this is so, it's a pity. Dynamically Scoped Context-Oriented programming mixed with lexically scoped continuations does not work. I still use the concepts I developed in it every day, just not the library called LoL, which I stopped developing in about 2008. &gt;It used to be in quicklisp, why has it been dropped? Has it? Probably because I do not use it and it does not work .... but I do not know having never QL:SYSTEM-APROPOS looking for it... I still have the 2004 darcs archive of LoL, and I use the alist/plist code all the time... Since this is the first I have heard of it being dropped, you are likely the only user. If you want to fork the contextl/UCW using version of it, please feel free. Xach will likely put whatever library you create in quicklisp, and it will no longer be 'dropped'. 
Yes. Pretty much.
Ltk? Lispy is probably gonna cost you money though
SBCL by default sets FPU control register. This register has flags that deal with floating-point exceptions and precision. Unexported function set-floating-point-modes does that: https://github.com/sbcl/sbcl/blob/master/src/code/float-trap.lisp#L58 If I remember correctly, SBCL has exported this function from some package but I can't remember from which one.
Modest amounts, yes, but it's for personal / hobby use.
Quick browse of the ltk manual: that looks interesting and initially it looks quite Lispy. Thank you.
It works well but it looks ugly/not native.
Mh, this doesn't seem to cause the problem, since CCL seems to use the same settings (by `(get-fpu-mode)`) as SBCL (by `(sb-int:get-floating-point-modes)`). Also, SBCL doesn't use the `:precision` parameter on x86_64.
I don't think there are any options available that meet your requirements. If you make something like that, please share.
Ah. Ugly is not good. Oh well. Thanks again.
That is exactly the correct way to do it! Edit: I'd just directly write (or null type)
You could consider moving off OS X into cross-platform Javascript+CSS GUI, via "lispy" development of course. Just as an example (already cited on Reddit), look at the source code of this page: http://jsutil.sourceforge.net/SweepSecondParen.html 
Thanks :).
It looks like libsass don't mind completely breaking backward compatibility on their C wrapper. Are you sure that your struct definitions agree with the exact version that gets loaded in?
You seem to have a lot of demands. "Lispy" "GUI" and "OS X" is not a very well-supported combination these days: Lispworks has CAPI, Allegro seems to have a bunch of various kinds of GUI stuff, ranging from GTK/X window to their "Common Windows" and CLIM. But I'm guessing you don't want to spend the money for these products. "Cross-platform" is pretty much limited to Ltk, and you think that is "ugly." OS X is not the primary platform for SBCL, and SBCL doesn't have much history of supporting GUI development. Clozure Common Lisp concentrates much more on OS X: if anyone were to create a free implementation of Lisp GUIs on Mac OS X, I would expect it to appear for CCL first. Of course you dismiss Objective C (which is, naturally, the primary GUI environment on Mac OS X) as "yeuch!". It's also not clear what you mean by "currently supported." Apart from the commercial offerings, there aren't a lot of people sitting around waiting to make sure your experience is problem-free. Maybe you should be posting to r/iwantapony?
If you really really want to write OSX GUI apps in Lisp and have them look good (that is, "good" by the standards of typical OSX users), it's quite doable; however, there is no solution that makes it super easy. If that's what you're after, you're out of luck. The lowest-effort routes are probably: * Clozure Common Lisp's Cocoa interop * Lispworks CAPI * Ltk CCL: You said you didn't want a bare-bones FFI, and CCL's Cocoa interop is sort of close to that, but it really is one of the easier ways to go. It provides some conveniences that make it more than just a bare FFI, and its contribs include even more stuff that makes things even easier (especially in Paul Krueger's contribs, which provide a ton of handy tools and examples for making Cocoa apps from CCL). Lispworks will cost you more than a thousand bucks but less than two thousand, and it's well worth it. I've happliy paid that license fee several times now. It isn't necessarily easier than using CCL's Cocoa interop, because you do have to learn CAPI, and that's not trivial. On the other hand, you can get extremely close to the same results you could get using Cocoa directly, and as a bonus, most of your GUI code will be platform-independent. If you don't need to turn your project into a standalone app or distribute it to others, you can do it for free using the Personal Edition. Ltk: someone called it ugly. I think that's overstating it. The appearance of the GUI depends on the local version of Tcl/Tk you're using. Heres the Ltk site: http://www.peter-herth.de/ltk/ Here's the (very old) screenshot of Ltk on OSX: http://www.peter-herth.de/ltk/ltk-osx.png While working on an embedded UI that used CAPI, I experimented with porting it to Ltk. It worked pretty well. There was enough flexibility in Tk and Ltk to get fairly close to the appearance we got with CAPI, and to make the UI look pretty good. You might not have as much luck, but given that Ltk is free and pretty easy to set up and use, what have you got to lose? If it doesn't work out, you'll be no worse off than you are now. Good luck. One last caveat: no matter what route you go, making a good-looking UI is a lot of work, and making one that meets the standards of typical OSX users is extra work. Over the past ten years that market has become slightly less finicky about the appearance of apps, but it's still pretty finicky. 
Please, remember [Clojure is not a Lisp](http://www.loper-os.org/?p=42), and move this thing to /r/clojure. 
“Conditional binding” is a common pattern in functional programming ; it doesn't deserve such a long and ill-written article.
So, is that a new version of http://common-lisp.net/project/babel/ ?
what makes you think that, besides five characters?
I really like the site. More Lisp libraries/programs should have more modern looking sites than the average common-lisp.net project.
Poor name choice of the author makes me think that.
Babel2 is at least six years old. I personally don't know which project was first Babel, or Babel2. Do you?
Babel is at least 7 years old.
Get the following warning while compiling with g++ gcc version 4.8.1 (Ubuntu/Linaro 4.8.1-10ubuntu9) Core dumped while executing the given code: (set t1 (thread (for i 1 10 1 (pr "" i)))) (set t2 (thread (for j 11 20 1 (pr "" j)))) (join t1) (join t2) terminate called after throwing an instance of 'std::system_error' what(): Enable multithreading to use std::thread: Operation not permitted Aborted (core dumped) 
I think your g++ was not compiled to use multithreading. Everything works fine in g++ (GCC) 4.8.2 on Cygwin. Or, https://www.google.com/search?hl=en&amp;q=Enable+multithreading+to+use+std%3A%3Athread%3A+Operation+not+permitted+Aborted+(core+dumped) http://stackoverflow.com/questions/17274032/c-threads-stdsystem-error-operation-not-permitted [SOLVED] C++11 threading. - Ubuntu Forums | http://ubuntuforums.org/showthread.php?t=2183408 
Neat.
Agreed. In case anyone else is interested and missed it, it says at the bottom: &gt; Inspired by: [HTML5 UP](http://html5up.net/telephasic) That's a link to a template called "Telephasic".
Loading [this from CLLIB](http://clocc.cvs.sourceforge.net/*checkout*/clocc/clocc/src/cllib/elisp.lisp) might cause the universe to implode, though.
How does this differ from the partial implementations in the cl or cl-lib libraries found in emacs core; the same thing, a fork, a reimplementation?
The cl library extends Emacs Lisp with some Common Lisp functionality. The Emacs Common Lisp implementation is a real CL which runs parallel with Emacs Lisp (but they can interact).
I doubt this will ever come out. But you could do what I did in 2008 and email David Margolies and ask.
It's currently in a "fun hack" stage, but it could possibly evolve into an alternate extension language for Emacs. I.e. some version of "CL Emacs" that Common Lisp programmers pine for.
We are! Most of the things I want are based on issues that I've had writing some of my own applications with it.
###धन्यवाद
Sounds good! It would be interesting to hear which features are driven by which demands.
Found it...just set `asdf::*user-cache*` to the directory I wanted. On a side note, is there any way to get the absolute pathname of the current directory? `*default-pathname-defaults*` seems to be different on different implementations and not always return an absolute value.
I understand CL macros quite well, but found this article pretty confusing. Perhaps because of the lack of good definitions. The statement "A syntax transformer is a function that takes syntax and returns syntax" begs the question: what is syntax? for example. Is syntax basically s-expressions? Is define-syntax the equivalent of defmacro? What exactly does hash-quote do? Why is it necessary? What is the advantage to racket's approach to macros versus CL? 
I may misunderstand, but why have immutable strings when symbols are already immutable strings?
This is very sophisticated and cool.
Do you really want UTF-8 as an internal encoding? That would make accessing characters O(n). Or maybe you meant that each character is still taking up 4 bytes, but is encoded with UTF-8. That will make converting to and from UTF-8 cheap, but more expensive accessing code points and, perhaps, things like unicode property tables.
I like macro hygiene, but mostly work in `defmacro` style Lisps, so here is my attempt to explain while reminding myself of how things work. Might be slightly incoherent. Syntax is a representation of code which includes information about scope, which is how scheme macros can preserve macro hygiene. For instance, the two syntax values produced by #'x and #'x represent two different symbols, which is why you can't write a syntax transformer which introduces a binding which code passed in as an argument expects to use (without intentionally breaking hygiene). Consider the Common Lisp Macro: (defmacro with-it (expr &amp;body body) `(let ((it ,exrp)) ,@body)) (with-it 10 it) ; -&gt; 10 This works the way a common lisp user expects because the 'it passed in as the body of the macro is the same symbol as the `it which appears in the `let` expression produced by the macro. Symbols read this way are interned, and as such they really are the same object. Things work differently with syntax-based transformers. Here is a naive implementation: (define-syntax with-it (syntax-rules () ((with-it expr body0 ...) (let ((it expr)) body0 ...)))) (with-it 10 it) This will produce an error, however, because the `it` mentioned in the syntax passed to the syntax transformer is not the same `it` as the one in the macro expansion. Syntax-rules, because it assumes that you want macro hygiene by default, basically hides this from you. This is because in the vast majority of cases when a symbol appears in some syntax passed into a macro you _dont_ want it to have anything to do with symbols you introduce in the macro expansion (in Common Lisp you `gensym` those symbols which appear in the expansion to avoid accidentally shadowing bindings which the user has expectations about). If you wish to consciously violate hygiene, then you have to use syntax case. Why? Consider that syntax-rules doesn't contain any Scheme-semantics code in it at all. The first argument to syntax rules is a list of symbols which we want to match literally in the rest of the syntax-rules expressions, and then it expects a list of pairs whose first element is a PATTERN and whose second element is an EXPANSION. Neither the pattern, nor the expansion is evaluated as scheme code. This is why the expansion parts of syntax-rules expressions don't include unquote splice-like syntax, because the expander knows from the pattern which symbols need to be inserted into the expanded expression and which symbols are necessarily `gensymed`. In our example, `expr` and `body0 ...` represent pieces of syntax which syntax rules knows to expand - no unquoting necessary. Any other identifiers which appear in the expansion are assumed to be fresh syntax and hence unrelated to any symbols which might appear in the syntax passed in or the environment. `syntax-case` gives us the ability to break hygiene by exposing, along with some utilities, the ability to examine and construct new syntax objects, controlling the scope in which they should be understood. Consider the correct implementation of `with-it`, using syntax-case: (define-syntax (with-it stx) (define (syntax-first stx-sq) (car (syntax-e stx-sq))) (syntax-case stx () [(with-it expr body0 ...) (let ((it-scope-holder (syntax-first #'(body0 ...)))) (with-syntax ((it-syntax (datum-&gt;syntax it-scope-holder 'it))) #'(let ((it-syntax expr)) body0 ...)))])) (with-it 10 it) ;-&gt; 10 In a `syntax-case` expression, we provide the syntax upon which to match, a list of identifiers we want to treat literally (in this case, that list is empty), and a series of pairs. Unlike in `syntax-rules`, however, this list contains pairs containing a pattern and then an arbitrary body of Scheme expressions. The programmer can construct the returned syntax in any way she chooses. In this concrete case, we use the utility function `syntax-first` to extract the piece of syntax corresponding to `body0` and then we use `datum-&gt;syntax` to create an identifier `it` which has the same scope information as `body0`, which means that if `it` is mentioned in the expansion, then it will refer to our new identifier. I admit there is something oblique about all this. But consider the following: each piece of syntax is a data structure which contains a reference to its scope. Scope is static in scheme, so it is possible, at expansion time, to know for a given piece of code what variables are referenced from which contexts. Whenever we construct new syntax objects in a `syntax-rules` expansion, they are, by default, sequestered into their own scope, and hence are not referencable from any other pieces of syntax. This is confusing for identifiers, especially if you come from Lisp, because symbols (which Lisps use as identifiers) are usually interned and hence two symbols with the same denotation almost always mean the same symbol. Not so in Scheme! Identifiers may look the same, but they need not share the same scope, and hence at execution time, need not be bound to the same thing. Indeed, two different identifiers may be so different in a given scope that one is bound and the other is unbound, as in our naive syntax-rules version of `with-it`. If you want to explicitly break macro hygiene you have to fiddle with that mapping between scopes and identifiers, and Scheme exposes the appropriate functions to do that. 
Accessing individual random characters is O(n), but that's surprisingly unusual to need. Unless Dylan has a guaranteed O(1) access, I'd say the tradeoff in storage is worth it. It's either that or have more than one kind of string (one with six bytes per character, one with compact encoding).
Maybe it's unusual in Dylan, but I can see numerous scenarios when processing strings when random access is needed. And even for sequential access, it would need a special iterator, because the ordinary "for i below length ... (char string i)" doesn't work anymore, unless the compiler is really smart. Things like accessing substrings, you can't allocate the necessary space beforehand, but need first to determine how much space is between the bounding indexes, processing the string twice. And so on, and so on.
This was incredibly helpful, thank you. As a crusty old CL guy, my reaction is - boy, that seems like a lot of work to write macros. Is this all to achieve hygiene or are there some other benefits? My sense is that one should be able to introspect more deeply on the bindings in a block of code and do something useful with that. Is that actually true in practice - or is all this added complexity just for hygiene? 
The normal iteration constructs use the iteration protocol in Dylan, http://opendylan.org/books/drm/Collection_Operations#HEADING-102-674 ... so they can be made smart enough. for (char in string) // whatever end; 
If you don't mind clobbering source directories, there is an option of `(asdf:disable-output-translations)`. I use it in conjunction with `(asdf:initialize-source-registry` ``(:source-registry :ignore-inherited-configuration (:directory ,*build-dir*)))` to ensure a self contained environment. ASDF includes pathname utilities, and `uiop/pathname:ensure-absolute-pathname` might serve your need.
Well, I think it is mostly about hygiene, but there are some other neat things you can do with Racket's macro system that are hard to do with Common Lisp, like provide clear error messages with meaningful line numbers and so on. Racket also supports something called `syntax-parse` which is sort like `syntax-case` really cleaned up and well integrated with their systems. Some of that stuff involves inspecting into the syntax objects a bit more, but I get the impression that the mechanism by which hygiene is enforced is left to the implementation on purpose, and hence the objects are somewhat opaque in general. It really isn't that much more complexity when it comes down to it, especially if you are really serious about writing high quality macro code in Common Lisp. I've written big macro-heavy libraries in both languages, and I slightly prefer the Scheme way, because it feels cleaner and it makes me write more composable, better factored macro code. And it is nice to just not worry about hygiene at all.
Strongly disagree. Imho all web designers should be forced to study the essays of Jan Tschichold before being allowed to publicize web pages. A fancy landing page advertising your super awesome project is one thing, but please keep technical information and documentation in a sane portable format. 
To OP: You are being downvoted in this sub because AutoLISP, the scripting language used by AutoCAD, is only superficially similar to Lisp and your question is very specific to that piece of software, which means that your question is more or less off-topic. I think StackOverflow would be better for your question. Consider the autolisp or autocad tags. [Here's a search as an example.](http://stackoverflow.com/questions/tagged/autolisp+autocad)
I want to start by saying that I agree Stack Overflow is a better place to ask this sort of question and get answers. That said glancing at our side bar: &gt; A subreddit for the Lisp family of programming languages. I have no idea how superficially or not AutoLISP is to other Lisps, but I could see from that sidebar how someone might get confused (especially someone new to Lisps). I can say that the way we present ourselves to the community might be a little less cold if we didn't just downvote the man/woman. I want to +1 your effort to point the guy to stack overflow, but really, this subreddit isn't so crazy busy that important stories were being lost because of this post. Couldn't we have just pointed the guy to SO without downvoting him too?
I'm a C++ developer and it's definitely leading us (back?) to Lisp.
I think it depends on what you feel downvotes are for. If you see them not as a personal attack on the person submitting but rather as a way for a subreddit to separate the topical submissions from the less topical ones, then downvoting a post like this is appropriate, in my opinion. Having said that, I didn't downvote OP, and I did give him a pointer to where he should go since I saw he was being downvoted without explanation. But I do generally feel that downvotes are not necessarily a commentary on your value as a human being. They are a (poor, in my opinion) means of keeping the signal to noise ratio high in particular forum. A loss of three karma points is not going to hurt OP, but it will keep this post from being on /r/lisp's frontpage, which I think is appropriate, since really, even if OP was confused in good faith, his post has little to do with the subject matter at hand. Even if AutoLISP does feature s-expressions. That this is a low-traffic sub is kind of beside the point. I subscribe to read about Lisp.
When I started learning Common Lisp, I downloaded Lisp in a Box. This is a no brainer and highly recommended. My box is an old PC running Windows XP. Editing and running CL code: Lisp in a Box runs in EMACS slime mode, I still don't really know what that means, and I'm pretty sure that I will never look it up. It is not necessary. EMACS and E-Lisp are supposedly wonderful things. That's nice! Reading list: All of Paul Graham, Guy Steele Jr.'s Common Lisp the Language, 2nd Edition, Peter Seibel's Practical Common Lisp, and all the other free stuff on the web. As for debugging, when you're writing a function don't write it all at once, type an expression into the top level, once it does what you want it to do then it can go into a function. When things don't work as expected you have a very short piece of code to think about. If you still can't work it out look it up in CLTL2. The hardest parts of LISP are the sheer size of the language and the fact that it is functional. Here is a sample of simple stuff, look up APL's monadic iota function (TryAPL is a good place to find it) in CL this works just fine (defun iota (n) (loop for x from 1 to n collect x)) Granted that there is no error checking, and it could be made far more efficient, but it works and its dead easy.
This has a lot of downvotes because it tries to charge for access, FYI to anyone wondering. Not sure why there are so many upvotes for this. 
&gt; many upvotes they probably didn't actually click the link
&gt; "I think that object orientedness is almost as much of a hoax as Artificial Intelligence" AI is as far away from a hoax, and hence from OO, as anything could be. It works already in a biological substrate and known by the name of 'real intelligence'. We just haven't successfully ported it to the electronic one.
I think it depends what the term 'hoax' refers to: if it refers to the behaviour of some early practitioners then, well, perhaps they believed their own bullshit but one has to wonder.
Very interesting! I am just getting into Lisps in general (Mainly Clojure with some Common Lisp and Scheme thrown in here and there) and this was a great look at how Common Lisp works at a lower level. Thanks for the link!
The word "SBCL" doesn't appear in this article. I think it's important to realize that SBCL and its Python compiler (common to SBCL, CMUCL, and Scieneer) are doing some hard work to get the results, and results vary considerably on other implementations. In other words, what is shown here is an example of what's possible, but not what's typical, in Common Lisp implementations.
Great post. I use Common Lisp just about every single day but when I read a post like this I realise I feel like I hardly know anything about it again. I rarely get to use the type declaration stuff since my code doesn't really leave the prototype stage. I'm always worried about putting any type declarations because I feel I might be creating myself more work later on. Yeah, I don't like commitments. I'd be interested to read about how people actually decide to use them when developing some software.
I'm glad I'm not the only who has noticed this. It's not just C++, though. All the time I'm hearing how language X has got a new feature and I think "one step closer to Lisp...". I can see it now, one of these languages is going to make its reader programmable, then someone will realise that they might as well just write directly into the abstract syntax tree, and what's the best way to write down trees as strings..?
This is purely an assumption, but I'd say it is like most optimization: You put it in when you realize that you need to for performance reasons. Either by running a profiler, or due to experience.
Check out Steven Levy's "Hackers, Heroes of the Computer Revolution". There is a good bit about what Richard Greenblatt, who ran the AI Lab, demanded of hackers who wanted to program Conway's Life. 
Yes, but the type declaration is not applicable there. DECLARE is not specifically about type declarations and it does not make sense to omit the declaration identifier, when it comes to types. If some Implementation recognize the syntax used in the example, then it is an extension to the standard. Some implementation complain. Added example, ECL: &gt; (compile 'baz) ;;; Loading #P"/usr/lib/ecl-12.12.1/cmp.fas" ;;; OPTIMIZE levels: Safety=2, Space=0, Speed=3, Debug=0 ;;; ;;; Error: ;;; * Syntax error in declaration ((UNSIGNED-BYTE 5) X Y) BAZ Use 'TYPE' as declaration identifier in portable code and don't omit it. 
Your point is well taken. I will update the post soon. Thanks for taking the time to point out my mistake; having used SBCL and LispWorks for so long, I am embarrassed to find that I've been relying on something the compilers did for me above and beyond the standard all this type. Of course there should be an explicit TYPE in that declaration! (I'm surprised to find my post here; I didn't know patrickwonders had posted my article here. My blog isn't quite ready for primetime yet, hence my surprise. Pat, if you're reading this, don't worry, it's fine, I was just caught off guard. :-)
No offense was meant by not mentioning SBCL by name; but you're right, I should have named it, giving credit where due. I will update that post in the very near future. I was a bit too cavalier with my reference to Lisp there, I see that.
Type inference and type-based optimizations is done by several compilers. SBCL/CMUCL/SCL additionally does use the declared types for runtime type assertions and/or compile-time type checking. One incompatibility I sometimes get bitten by is the VALUES declaration. SBCL/... use it as a type declaration, where in some code bases and implementations it is used as documentation.
I don't understand your objection to StrmSrfr's reading of the spec. The "declaration: type" page he linked is explicitly talking about forms in declarations. To me this is an inconsistency in the spec. The "declaration identifier" glossary entry specifies that TYPE can only be ellided when the type named is a symbol, but the "declaration: type" page clearly specifies that elliding TYPE is allowed for arbitrary type specifiers.
I think that there should be a lisp where static typing is possible, it is great for catching bugs. For example, you can pass sort a function that doesn't return a boolean, but it will work fine. A static typing system shouldn't allow that.
Well, the downside of static typing is that you have to specify the type anywhere the compiler can't infer it. If you specify a type that's wrong, you have a bug. If you specify a type and later it turns out you wanted a different type, you have to change it everywhere it's specified.
Rereading the spec... There definitely is an inconsistency. The `TYPE` symbol was not required for a few types. For ANSI CL it was voted to NOT require it for ALL types, but the authors failed to make it totally clear in the specification. So, implementations should be updated to allow the abbreviation. Until this is done, it's best to code defensively.
There's Typed Racket, and Shen.
Personally I tend to put them in when they're obviously correct and provide some sort of explanatory value to the person reading the code.
SBCL already does this. It gives plenty of warnings if you violate the type constraints (given either manually using DECLARE statements, or determined using type inference).
SBCL fails to catch if you declare a variable an unsigned-byte 16 and then a function only taking unsigned-byte 8, passing the unsigned-byte 16 to the function will only raise an error at run time.
That's a fundamental difference in approach between statically typed and unityped languages. SBCL will only (*) warn on definite type errors. `(unsigned-byte 16)` and `(unsigned-byte 8)` intersect, so the first declaration might simply be too lenient. What use would warnings be if they were triggered any time a value with undeclared type (i.e., of type T) was passed to a non-forall-polymorphic function? The other issue is that CL actively supports function redefinition (modulo file compilation). If you want, you can ask for non-standard type derivation: CL-USER&gt; (setf *derive-function-types* t) T CL-USER&gt; (defun foo (x) (declare (type (unsigned-byte 8) x)) x) FOO CL-USER&gt; (defun bar (x) (declare (type unsigned-byte x)) (foo (+ 256 x))) ; in: DEFUN BAR ; (FOO (+ 256 X)) ; ; caught WARNING: ; Derived type of ; (+ (TRULY-THE #&lt;SB-KERNEL:NUMERIC-TYPE UNSIGNED-BYTE&gt; SB-C::Y) 256) is ; (VALUES (INTEGER 256) &amp;OPTIONAL), ; conflicting with its asserted type ; (UNSIGNED-BYTE 8). ; See also: ; The SBCL Manual, Node "Handling of Types" ; ; compilation unit finished ; caught 1 WARNING condition BAR (*) That's the goal anyway, but we sometimes get foiled by overly clever derivation when conditionals are involved.
You will want to make sure you do: (ql:quickload 'qt) You have to tell quicklisp which packages you are using by using quickload. By the way, I have written a few commonqt tutorials that may help you, at cheryllium.wordpress.com :)
It just needs to be evaluated once. Remember that Lisp is interpreted, so once you get qt into your namespace it stays there for that interpreter session. (I hope I'm using the correct terminology here.) Thus, if you have multiple files, you just need to make sure they are loaded in the right order. I usually use asdf for that.
Great, thank you!
Thanks for the tutorials you posted. I was going through them recently and I am trying to working on experiment more and add to the repository of CL UI examples. I started with `cl-cffi-gtk` but I could not get to render on Linux and turned to `CommonQt`. Still learning and will see where it goes 
Lisp is not interpreted, it just supports interactive use: it does not exit when a piece of code you tell it to execute finishes running.
Typically we specify the list of needed libraries separately from the code that uses them: we put it in an *.asd file recognised by ASDF (bundled with Quicklisp). For example, see http://www.quicklisp.org/beta/faq.html, question "Can I load a local project that isn't part of Quicklisp?". For an introduction, see http://xach.livejournal.com/278047.html.
I'd say "for that image" since you can freeze images and reload them but whatever, your terminology works well for when talking to a beginner :)