Some say the ancients discovered lisp and this was their name for it.
Must have. At what conference will such a badge be handed out?
So, to provide some context, I wrote quite a bit of CL in my life, and I'm familiar with CL to the point where I did some yak shaving on implementations (as an example, I added return-from-frame to CMUCL). I guess I shouldn't have played dumb and asked a question that I knew the answer to. You are making my point for me. The point was that immutable data structures being the default in the language make parallelization trivial. I never have to worry about things being "thread-safe" and I never lock my data structures, because I know that if I "have" a data structure in hand, it will never change from under me. As to plists vs hash tables, that is another thing that I like about Clojure: there is no such distinction, you just use maps (or sorted maps). For small sizes, Clojure will use an array map, for larger sizes, a hash map, but that's an implementation detail. 
RIP
&gt;So, to provide some context, I wrote quite a bit of CL in my life, and I'm familiar with CL to the point where I did some yak shaving on implementations (as an example, I added return-from-frame to CMUCL). I guess I shouldn't have played dumb and asked a question that I knew the answer to. &gt;You are making my point for me. The point was that immutable data structures being the default in the language make parallelization trivial. I never have to worry about things being "thread-safe" and I never lock my data structures, because I know that if I "have" a data structure in hand, it will never change from under me. Well, you already knew my previous answer, And I already knew what you have just said ("immutable data structures being the default in the language make parallelization trivial"). However that doesn't mean doing the same thing in CL is unpractically difficult or very hard. This is my only point. &gt;As to plists vs hash tables, that is another thing that I like about Clojure: there is no such distinction, you just use maps (or sorted maps). For small sizes, Clojure will use an array map, for larger sizes, a hash map, but that's an implementation detail. Yes, this was pointed out to me some months ago in the past. It is a nice feature. 
Personally I find that somewhat disrespectful.
Why? Every ancient weapon needs its hokey religion. ;)
Thanks for bringing back to my notice! Is there a documentation or tutorial somewhere? The best I could find is [this](http://mmontone-programming.blogspot.com/2014/09/embedding-python-in-common-lisp.html). However, I'm still unsure how to do the basic things: * Do I have to `defpyfun` for every function? (For me, the burgled-batteries.syntax didn't seem to work. `(import :numpy)` keeps throwing an error. * Even after I do use `defpyfun`, how do I use the functions: what is the equivalent of `numpy.array([1,2,3])`?
The last time I've seen so many `DO` statements was in the early 80s. ;-) Besides, a lot of the usage of `DO` in the code is slightly wrong. The iteration clauses of it are: \`(variable init-value next-value)\`. But the code often assumes that one needs to set the variable in the `init-value` or `next-value` forms. One only needs to return the next value and the macro sets the variable already in each iteration. Instead of `(do ((i 1 (incf i))) ...)` it's actually `(do ((i 1 (1+ i))) ..)`.
When one needs to implement a really different Lisp dialect (lexical syntax, syntax and semantics), one example is PseudoScheme. It translates Lisp-1 Scheme to Common Lisp. [https://github.com/sharplispers/pseudoscheme](https://github.com/sharplispers/pseudoscheme) &amp;#x200B; it translates for example this Scheme code (define (incit1 c) (let ((a (lambda (b) (+ b c)))) (a 31))) (define (incit2 c p) (let ((a (lambda (b) (+ b c)))) (p a 31))) into this Common Lisp code: &amp;#x200B; (COMMON-LISP:DEFUN INCIT1 (C) (COMMON-LISP:FLET ((A (B) (+ B C))) (A 31))) (PS:SET-VALUE-FROM-FUNCTION 'INCIT1 'INCIT1) (COMMON-LISP:DEFUN INCIT2 (C P) (COMMON-LISP:FLET ((A (B) (+ B C))) (COMMON-LISP:FUNCALL P #'A 31))) (PS:SET-VALUE-FROM-FUNCTION 'INCIT2 'INCIT2) One can see that it knows how to deal with the Lisp-1/2 conversion...
I'm pretty sure it popped up in an APL program at some point.
Sounds like you should submit a PR.
Would be cool if you rate the addon :\]
It's not completely programmable, though, more like an S-expression-based configuration language.
It's a rule based language. Several have been implemented in languages like C or Java. Some still use a lisp-like syntax. Example CLIPS: https://www.csie.ntu.edu.tw/~sylee/courses/clips/bpg/node5.1.html The original rule systems they kind of emulate in the case of CLIPS is ART (automated reasoning tool). ART was one of the big commercial AI development systems for Lisp - often called expert system shells. The other ones were KEE and Knowledgecraft. Since these were huge, commercial and expensive, cheaper alternatives were developed - like CLIPS. But thes copied some of the language design from the Lisp-based systems.
It was very interesting to watch. It sides apart from all the childish and oversimplified videos on YouTube. The code snippets were great, it's very readable even for non programmers.
How do they test their changes?
RESTfull web services have low overhead, especially when on the same server or on a local high speed network.
I just added an issue. Thanks for suggesting that!
Wow, my dad (RIP) had a tetragrammaton he drew himself. I shall find it and hang it on the wall, I saw that image for years as a kid. &amp;#x200B;
Lisp and games has always been a weird thing, didn't Jak 2 use lisp somewhere?
Any articles about it?
DDD works well with CLOS. Some design bits you would normally agonize over in other languages, are made simple using CLOS's multi-dispatch.
I like this one: https://fsharpforfunandprofit.com/ddd/
Really??
There are several books available, but I think that good summary is [DDD Reference](http://domainlanguage.com/wp-content/uploads/2016/05/DDD_Reference_2015-03.pdf). Be aware that DDD has changed over the years, since the publication of the [Blue Book](https://www.amazon.com/gp/product/0321125215/ref=dbs_a_def_rwt_bibl_vppi_i0) (not Smalltalk one :)). Personally I find DDD very vague.
Thanks for that hat tip; Figured that out after reading PAIP, although I used *labels* and *let\** (along top-level *symbol-name* *symbol-function* sets) due to semantic differences in CLJ.
&gt;The last time I've seen so many DO statements was in the early 80s. You're off by a 1.5-2 decades; I picked up that idiom from On Lisp (which I read circa 2012), so blame Paul Graham. Notably, both CCL and SBCL use *do* pervasively in their lower level implementation source, and they seem to date from the mid 90's ;) So my limited isn't quite as ancient as the CL standard. Thankfully, I migrated toward higher order stuff, including recursive FP style tail-call iteration (again, from Graham), along with friendly constructs and eventually *loop* and its sub language. As one of the stated goals was for learning, I seem to have covered most of the bases in the spec (excepting the more primitive control and iteration constructs, but those are likely to be explored in the future). &gt; One only needs to return the next value and the macro sets the variable already in each iteration. Good to know.
Didn't C++ have it before PHP?
\&gt; You're off by a 1.5-2 decades; I picked up that idiom from On Lisp (which I read circa 2013/14, published \~ 1993), so blame Paul Graham for the anachronism. Notably, both CCL and SBCL use *do* and *do*\* pervasively in their lower level implementation source (hundreds of times), and they seem to date from the mid 90's (the source is unmodified to this day) ;) It's early 80s because * in 84 in CLtL1 there is no LOOP in Common Lisp, it was added in CLTL2 and formally with ANSI CL (early 90s). Implementations usually added some form of LOOP as a loadable library then. * CCL (Clozure CL) is actually based on MCL (Macintosh Common Lisp), which is a renamed Coral Common Lisp, which is based on Coral Lisp - ca. 1984 * SBCL is a fork of CMUCL, which is a renamed Spice Lisp, ca. 1980 Thus (older) CL implementations tend to use a restricted smaller language in the core and LOOP gets loaded like kind of a library at one point. I wouldn't also expect idiomatic code from Graham. Use of Scheme-like tail recursive functions is usually discouraged in portable code, since the CL standard does not mention/support/require TCO at all and implementation differ in their support of TCO (none, restricted, partially, in compiled code). \&gt; Good to know It's also a source for error: (do ((i 1 (decf i))) ... Above works because the DECF returns the new value. First the form sets I to a value and then the DO macro sets the value of I again. If the user code is different and sets the value differently from its return value, then we may get a problem, because DO then sets the value to the different return value. Example: (do ((list '(1 2 3) (pop list))) ...) Here POP removes the head of the list, but returns the head of the list as its value and not the shorter list... thus it is not doing (do ((list '(1 2 3) (rest list))) ...) as one might think and which would be the correct way to iterate on rest lists. &amp;#x200B;
&gt;It's early 80s because •in 84 in CLtL1 there is no LOOP in Common Lisp, it was added in CLTL2 and formally with ANSI CL (early 90s). Implementations usually added some form of LOOP as a loadable library then. •CCL (Clozure CL) is actually based on MCL (Macintosh Common Lisp), which is a renamed Coral Common Lisp, which is based on Coral Lisp - ca. 1984 •SBCL is a fork of CMUCL, which is a renamed Spice Lisp, ca. 1980 Your grasp of history continues to impress. Surely, the extant forked code in the standard library (e.g., array.lisp) is packed to the hilt with *do*. Yet, SBCL's ARM compiler - apparently originated in 2012 - still uses (do ..) idioms. Maybe it's not that anachronistic, or merely subject to taste. &gt;Thus (older) CL implementations tend to use a restricted smaller language in the core and LOOP gets loaded like kind of a library at one point. I don't the aforementioned compiler example fits this case since *loop* usage shows up in the same file; no idea. It makes sense to build on the primitive kernel though. &gt;Use of Scheme-like tail recursive functions is usually discouraged in portable code, since the CL standard does not mention/support/require TCO at all and implementation differ in their support of TCO (none, restricted, partially, in compiled code). That seems like sound advice if portability is a primary concern; there seems to be countervailing opinion that TCO (at least for self calls, not arbitrary mutual recursion or "full" TCO) is generally supported amongst the primary CL implementations as a sort of pseudo standard; thus it's not a practical problem. I haven't had a problem between CCL (my original starting point) and SBCL (current favorite) at least. &gt;It's also a source for error: That certainly seems to fit the profile of side-effecting, place-oriented operations leading to erroneous behavior. My original error (from 2012) was mistaking *incf* and *decf* as cognates for *inc* and *dec* vs *1+* and *1-* . The mutable semantics ended up in my favor (and worked during testing in the REPL), but could fail in other superficially similar cases. Very good to know.
A dialect of Scheme called [GOAL](https://en.wikipedia.org/wiki/Game_Oriented_Assembly_Lisp) was written in Allegro CL and [heavily used throughout the series](https://news.ycombinator.com/item?id=2474833).
**Game Oriented Assembly Lisp** Game Oriented Assembly Lisp (or GOAL) is a video game programming language developed by Andy Gavin and the Jak and Daxter team at Naughty Dog. It was written using Allegro Common Lisp and used in the development of the entire Jak and Daxter series of games. Syntactically GOAL resembles Scheme, though with many idiosyncratic features such as classes, inheritance, and virtual functions. GOAL encourages an imperative programming style: programs tend to consist of a sequence of events to be executed rather than the functional programming style of functions to be evaluated recursively. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Oh wow I thought it was just some AI, that's amazing.
\&gt; supported amongst the primary CL implementations as a sort of pseudo standard keep in mind that it has mostly a status of a compiler optimization and not a language feature. Also it interacts with various language features like dynamic bindings. Take this source code: (defun foo (x) (labels ((bar (y) (if (zerop y) y (let ((s *standard-output*)) (print y s) (bar (1- y))))) (baz (y) (if (zerop y) y (let ((*standard-output* *standard-output*)) (print y *standard-output*) (baz (1- y)))))) (print 'bar) (bar x) (print 'baz) (baz x))) If we load it with LOAD into SBCL, then BAR is tail recursive and BAZ is not. If we LOAD it into ECL, then neither BAR, nor BAZ is tail recursive. If we compile it with COMPILE-FILE and load it into ECL, then BAR is tail recursive and BAZ is not tail recursive. I would generally only use tail recursion when my code actually needs it, my implementation supports, I can control the usage and I know about the TCO limitations of the various compilers I'd be using. Not at all supporting TCO are ABCL, Lisp Machines and most interpreter-based implementations. &amp;#x200B;
I Googled "Courier Prime Code Lisp" after reading what you said, and I immediately found this: https://news.ycombinator.com/item?id=18894200 Do you know if it would have to be a program like Glyphs Mini to do it? I tend to use editors like sublime text and I can't imagine such an option being available. 
&gt; Usually the CL compiler will not warn you that TCO was used or was not used. One would need to know that calls in a dynamic binding are not tail calls AND recognize in the source code whether there is a dynamic binding or not. Fascinating. So the conventional warning would be "don't establish dynamic bindings inside tail calls, because they will preclude tail calls, if you want to try to leverage TCO at the compiler level. Compiler won't warn you either. Consenting adults only." Honestly the thought of dynamic binding inside a tail recursive function never crossed my mind, unless of the form in the *bar* example where the var is read but not actually bound. I've used dynamic bindings fairly significantly, but never in this fashion. Is that a common idiom in CL, or an edge case to be wary of? Is it possible for the return value of a tail call to invoke a function that includes a dynamic binding (or somewhere down the call-stack), which would interfere with optimizing the tail call? Or (again assuming the binding is inside another function invoke, to be evaluated an another stack frame), do most compilers still merrily detect the tail call and optimize into a jmp [this seems like the expected behavior to me...]? &gt;Style: The style point is sound. I would conform to the capabilities of the implementation of choice (unless marketing for portability and a broad audience). Regarding the necessity (or not) of tail calls, I'd be interested in seeing what code you think "needs" it other than leverages TCO due to stylistic choice. Since general TCO (e.g., including optimized mutual recursion) is likely to be broadly unsupported (which is not a drastic limitation for a broad set of use cases - self recursion as in the *bar* example is fine). Other than the precluded case, everything else seems amenable to manual transformation (perhaps some macrology could help) to an iterative solution or trampolined. This seems to indicate choice vs. need. &gt;Not at all supporting TCO are ABCL, Lisp Machines and most interpreter-based implementations. Good news for me then. I don't use or support ABCL, CLISP, or anything Lisp Machine related (although we have some legacy Symbolics hardware at work, some of which was still in service up until I think 2012 or so [maybe still...], until experimental migration to Genera/linux).
It's not just dynamic binding. It's anything which has *dynamic extent*. (defun foobar (x) (labels ((baz (y) (if (zerop y) y (unwind-protect (baz (1- y)) (print y))))) (print 'baz) (baz x))) \&gt; I'd be interested in seeing what code you think "needs" it other than leverages TCO due to stylistic choice. I could for example imagine that some graph processing is easier in terms of TCO calling functions. Or if I want to implement a state machine in functional terms - to avoid an implementation based on tags and gotos.. &amp;#x200B; &amp;#x200B;
&gt; paamayim nekudotayim Ya, but they don't throw errors about it in Latinized Hebrew.
&gt;&gt; keep in mind that it has mostly a status of a compiler optimization &gt; general TCO (e.g., including optimized mutual recursion) is likely to be broadly unsupported I've seen Schemers complain (resignedly) that everybody uses the term "TCO" for all forms of (ahem) TCO, even though "general TCO" as present in Scheme is not an "optimization" in any sense of the term. It's a control structure. A tail call can easily be slower than a regular function call. Depending on the implementation, an actual optimization might actually be to *omit* tail calls if the call is provably non-recursive. 
I never used PHP, do you think I should learn it? Looks like a Job Security kind of language 
Uncharted used Racket Scheme to do gameplay scripting too.
It isn't a language for me. I don't know you so I can't evaluate if you should learn it. Every language has its pros and cons. There are good reasons to learn any of the popular languages depending on what your goals are. 
Why do lipo companies put "fire" in the name of their battery?
&gt;Nix is a giant step forward in operating system research. Not only does it address most of the criticism of Unix (including those found in the Unix Haters Handbook), it also paves the way for many more features and research explorations that could be critical in this day and age where topics like reliability and trust are at the center of many scientific, but also social and political debates. &gt; &gt;Pike was wrong. And this proves another more general point: it’s probably wiser to refrain from claiming that any research has become irrelevant, unless you can prove that no further development is possible. And the Utah talk was hardly a mathematical proof. It only served to further entrench the idea that Unix is “good enough” and that we’ve got to live on with its idiosyncrasies and issues. &amp;#x200B; Nix is a giant step forward in assembling Unix-based distributions but fails short as OS research.
&gt; but fails short as OS research. Do you have any juicy hyperlinks in that particular area? Thanks!
[This](http://bitsavers.informatik.uni-stuttgart.de/pdf/xerox/parc/techReports/Smalltalk-72_Instruction_Manual_Mar76.pdf) might load better.
&gt; I wouldn't also expect too much idiomatic code from Graham. Use of Scheme-like tail recursive functions is usually discouraged in portable code, since the CL standard does not mention/support/require TCO at all and implementation differ in their support of TCO (none, restricted, partially, in compiled code, lower debug level, ...). Thus in an implementation, which bootstraps itself with an interpreter, one might be able to use loops like DO and even LOOP in the lower-level code which runs in the interpreter, but not TCO. This is different in Scheme, where an interpreter also would support TCO - not just the compiler. In typical (Common) Lisp implementations the interpreter does not support TCO, but the compiler does/may. This is interesting, as I'd also picked up doing Scheme-like tail recursive functions from Graham's books. They're somehow just very conceptually pleasing, but it sounds like perhaps not practically ideal in CL. 
Definitely NOT available on Codeforces, which is a shame. Hackerrank, Codechef, and SPOJ support is not consistent -- there are many problems where Lisp is just flat out not supported.
I had the GUIX package manager retrofitted for a while. It's pretty nice. The biggest blocker for Guix-SD is really that its a "free software purist" distro, which whilst very noble means that you're not getting any proprietary firmware by default, and thus no wifi on most modern laptops. If you can get over that hurdle there are others (mostly higher up the stack - video codecs anyone?). 
I agree that's annoying. Especially, if the purist distros actively discourage you from obtaining tainted items.
I, for one, hope you keep doing these updates.
Thank you very much for this digest. I was happy to find out about [terminal625's Minecraft-clone sucle](https://github.com/terminal625/sucle).
Thanks, very inspiring.
&gt;JSCL 0.7.0 now supports CLOS thanks to the work of vlad-km Wow! Thanks for this update, otherwise I wouldn't have gotten these valuable news!
This is amazing stuff you're doing! Thanks for the updates.
@you and @all: thanks for letting me know and for the nice feedback, always good to hear :]
I'm sorry I suggested this without knowing the state of it, but it did inspire me to check it out. It seems like a Python FFI and therefore a good candidate for Tensorflow API. It seems like Tensorflow is architected incorrectly though... Sounds like a lot of logic is in the Python API and all the other bastards are left re-implementing what that has.
I think one of the major demerits of lisp are its lack of libraries - if only we had access to python's libraries. With that thought, I came across [hylang](http://hylang.org) \- while not common lisp, it's a lisp over python that has / will have the macro-system of lisp, and the python libraries as well: I'm converted! Enjoy hy-ing! 
I know about it but I didn't like it for some reason that I do not remember. This said, there are burgled batteries that you might be interested in : https://github.com/pinterface/burgled-batteries Though I have no idea how well they work. Plus most of the stuff that you need is there. Honestly if you want to use CL to create a web server, it's all there. Might not be a Django, but more like Flask; still should be enough for many tasks. 
I haven't noticed the size of them getting to me, but I also wonder if I could like these languages even more if I did such a thing. Can you recommend a not too hacky way to do this? I just asked in /r/Sublimetext is they happen to know of a way. It might also be interesting if you posted a screenshot of what yours looks like. 
Here's a sneak peek of /r/SublimeText using the [top posts](https://np.reddit.com/r/SublimeText/top/?sort=top&amp;t=year) of the year! \#1: [Sublime Text 3.1 Released](http://www.sublimetext.com/blog/articles/sublime-text-3-point-1) | [6 comments](https://np.reddit.com/r/SublimeText/comments/8ho83k/sublime_text_31_released/) \#2: [I just want to say Thank you Sublime](https://np.reddit.com/r/SublimeText/comments/9jn1qo/i_just_want_to_say_thank_you_sublime/) \#3: [Sublime Merge - Git, Done Sublime](https://www.sublimetext.com/blog/articles/sublime-merge) | [6 comments](https://np.reddit.com/r/SublimeText/comments/9hdw69/sublime_merge_git_done_sublime/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/afd0dd/blacklist/)
[I discovered hylang while searching for tensorflow support on lisp.](https://www.reddit.com/r/lisp/comments/af55tk/what_is_the_state_of_tensorflow_in_lisp/edyr6g6/?context=3) Is there a more detailed documentation or tutorial for burgled-batteries somewhere? (I have asked the same question in the linked thread.)
A mere distribution of GNU/Linux, as such, does fail short as "high fallutin' OS research". Topics such as better package management, upgrades and such are legitimate OS topics; just maybe without he lustre of real-time work, microkernels or scheduler activations and whatever not. 
[picolisp way](http://rosettacode.org/wiki/Quine#PicoLisp) 
Does anyone know what equivalent roswell script would be to this: https://github.com/mifpasoti/Gtk-Demos/blob/master/demo1#L2 ?
why sed? 
If people make changes to a demo, and get an error, SBCL has verbose error output that a lot of people aren't used to and are put off by. The sed script is to reduce that error output to the essentials. To see the full error output, simply remove the sed filter.
tl;dr The language snigl doesn't have syntax for comments and instead uses a trick equivalent to `#+(or) ("Foo bar baz quux" 123 :FRED)` in Common Lisp.
Note that he Xerox Star is not related to Lisp. It's an office system written in Mesa. The hardware on which the Xerox Star OS and software was running was also used to run Interlisp or Smalltalk systems - but that was a different operating system then...
Awh, MasInterLisp, now that is a blast from the past. What halcyon days to remember in our winter of discontent.
Cool, but building it would conflict with CHICKEN.
Does simply redirecting the output to dev/null work? demo1.ros https://gist.github.com/guicho271828/48db7a94a03d36ed33ce2cc8a4d0d7ab
Is this the first time Interlisp-D can be run under emulation, outside Medley?
While a bit... opinionated, it's worth noting that in any Forth worth the name, comments are just a pair of words, conventionally `(` and `)`, that turn off compilation/interpretation and then turn it back on again. So if this decision doesn't sit right with you, for any reason, feel free to add a comment format.
I guess you don't plan on major organizations using your stuff, because those people are going to want to see big copyright blocks at the tops of source files. 
I have nothing to sell. If someone feels like using it, fine; if they don't, also fine. That being said; everything is still there, the only difference is using regular language constructs rather than treating comments as a special case. _: " Copy this, copy that. Copy left, copy right. " ...
&gt; in any Forth worth the name, comments are just a pair of words From what little Forth I remember, I think `(` doesn't turn off compilation but skips text until it finds a `)`. There's also `\` that eats the rest of the line, like `;` in Lisp. 
Seems fine to me as long as you are prepared to talk about it if asked. As someone who does hiring, I like seeing interest in programming languages on people's resumes. If you have a skills section, put it in the skills section, possibly nearer the end. Otherwise you can throw it in the interests section.
This question is too broad to be answered properly and isn't even really a Lisp question since there is no general resume that will suit all job offers. /r/cscareerquestions/ should have better advice. Nonetheless, If you're applying for a junior position, then it could be a good idea to throw whatever you got at the resume, especially if it matches the technologies that your employer seeks. I'd expect that your interviews will mostly query your problem solving and thinking abilities, though, since they cannot query your previous work experience if you have none.
This isn't lisp, as others mentioned. There is an effort to get Medley working again. If you're not involved, lmk.
I always put all these things to CV, never had any problems. Why not. To know something is not a shame, shame is not to know ;)
Showing breadth of knowledge and interest is good. One thing I suggest for jobs seekers is to put a portfolio of nontrivial work up on github. Don't have any you can show? Create some for your next job search.
Two things I would mention: 1. You should probably be tweaking your resume for different employers. So the question should be more like "is my Haskell and Common Lisp experience or skill important enough to *this employer* to make it worth taking up valuable space." Which we can't answer without information you probably want to keep private. 2. You need to be careful that *every word* on your resume can be confidently backed up with truthful and helpful answers when you are in an interview. You may end up in the room with someone who keeps CLTL2 on his nightstand and has fixed bugs in SBCL: are they going to embarrass you by asking basic Lisp questions? I have been burned myself this way, years ago: I had been a user of statistical process control software and read the basic training material in a summer high school job, so I mentioned "SPC" on my resume. An interviewer asked me what "Cp" and "Cpk" were, and I looked dumb because I couldn't remember that basic fact from 10 years earlier. Luckily I still got a job offer, probably because the software guy on the panel loved me. (And I made damn sure to look it up that evening in case it came up in a later phone call. I realized I had seen the concept and could have explained it, but my knowledge was limited and stale so I couldn't even remember the basic industry terms.) Basically, unless there is some scenario where a better job match or useful discussion happens on the basis of that buzzword, you might be better off without it. 
"There is no shame in not knowing; the same lies in not finding out." -- Russian proverb
https://github.com/wmannis/cl-svg/blob/master/docs/API.md
I use cl-pdf for things like this quite a bit.
Put in your CV that you've worked through HTDP, SICP and PAIP. That's an attention grabber.
*beep beep* Hi, I'm JobsHelperBot, your friendly neighborhood jobs helper bot! My job in life is to help you with your job search but I'm just 489.1 days old and I'm still learning, so please tell me if I screw up. *boop* It looks like you're asking about resume advice. But, I'm only ~12% sure of this. Let me know if I'm wrong! Have you checked out TalentWorks, /r/resumes, TIME? They've got some great resources: * https://talent.works/blog/2018/01/08/the-science-of-the-job-search-part-i-13-data-backed-ways-to-win/ * https://www.reddit.com/r/resumes/ * http://time.com/money/4621066/free-resume-word-template-2017/
I think it's nearly true that things like this are just universally positive (assuming you actually know and can discuss the languages you're claiming to know). It's rare to be interviewing somewhere that is going to care that much about your ability to write Haskell or Lisp, but almost any technical interviewer is going to see knowledge of those things as evidence of other positive traits. I don't care what editor or IDE someone uses, but if they can get excited enough to spend five minutes in an interview talking about how they've customized Emacs to do exactly what they want, I'll probably hire them, because I'm hiring for people who are smart and engaged far more than for someone who checks exactly the basic requirements of the job. You don't generally matter Haskell because someone made you. You do it because programming is interesting and something about Haskell got you excited. So put that on your resume.
If you make changes, and those changes cause error messages, you don't want to see those error messages? &amp;#x200B; The scripts shouldn't actually have any error output, unless you make changes to them which introduce errors. It won't make any difference how you display the errors, if there aren't any. But if you make changes which cause errors, it would probably be better to see all the error output than none of it. &amp;#x200B;
There are three OS images that run on this emulator, one of which is Interlisp-D.
+1 for programmer dvorak. I switched years back, not because of the dvorak part but for the symbol key placement, and it was absolutely worth it.
And the HN discussion: https://news.ycombinator.com/item?id=18911940
Whilst I like Emerick's Clojure book a lot it hasn't been updated since 2012 and is unlikely now to ever be updated.
True story: Few years ago I've got a call from an HR agent, while I was on a train, so, it was somewhat loud. **Agent:** Your resume says you program in ehl-eye-ess-pee. **Me:** Speak up, please, I don't quite understand... **Agent:** I was really curious if ehl-eye-ess-pee has anything to do with ey-ess-pee, it sounds kind of similar. You are doing dot-net, aren't you? And that was, basically, the only time anyone noticed Lisp on my resume.
I think, you are overthinking it. I don't believe that inventors of popular programming languages ever even considered the number of special constructs and keywords they are introducing. If you read the history of creation of any of those, you'll see that it was mostly "random", "overnight", "joe walked into my cubicle and said let's do that" kind of thing. Programming seems to be split between two extremes: on one hand a very rigorous world of mathematical proofs, which ends as soon as you graduate from college, and on the other hand -- a complete magic and dragons heavily peppered with marketing tricks world of actual programming products. Take any programming book which isn't about algorithms or automata etc. Let's say, program architecture. None of such books ever has a convincing power of even a case study, it is usually pure subjective "expert" opinion. Is it worth your time to ask the question about how so-called expert came up with their opinion? For kicks and giggles? -- Maybe. But, other than that, I don't think it's meaningful.
How about the Wizard book?
If you just say "Lisp" you might get hits from people looking for Autolisp (CAD) experience. 
Free [PDF scan](http://www.mediafire.com/file/7n18v2kx0gkoh91/Peter+Kogge+-+The+Architecture+of+Symbolic+Computers.pdf) of blogger's favorite.
Found error: P. 127: *Currying is detected when the number of actual arguments is less than the number of formal identifiers in the lambda expression. In this case, only those identifiers with matching variables are replaced, and the rest are left as identifiers for a new lambda expression.* That is partial application, not currying! Currying doesn't perform any parameter replacement; currying is the breaking up of a function of N arguments into multiple applications of one argument to a chain of functions. E.g. some *f(x, y z)* is turned into a *g* which can be called as *g(x)(y)(z)* that calculates the same thing: *g(x)* returns an anonymous function that takes *y*, and that function yields another one that takes *z*, and that one finally yields *f(x, y, z)*. 
I am pretty confident that if I were to ask about these books, 9 out of 10 colleagues wouldn't know about them. Clean Code and Code Complete on the other hand... (*inb4* I'm working in the wrong place)
I have heard only good things about LispWorks's CAPI. I have not used it myself. I do web interfaces myself, and only simple ones, so I haven't encountered the same types of problems.
Well, the current mainstream UI device is clearly the browser/web, so why C matters
I don't think there's any problem with C interoperation, unlike C++. And cffi-grovel is manual, not automatic, you grovel whatever you need.
In the past I could write Lisp code that worked and produced expected UI. On the web I can not use Lisp. I would have to use JavaScript of Elm to produce any interesting UI elements. Parenscript is not a viable solution. C matters because I can use Lisp to write front end code.
There are no problems when everything works. But how do you debug when something fails to work and grovel gives a a very long winded error message that means nothing to you.
No idea, don't recall that happening to me. I guess you debug it the usual way, by thinking hard.
There is no point thinking hard until you accumulate a body of useful information. Also I live in the real life and have to spend my thinking hard hours on other subjects.
Well then, there's nothing that fits that requirement. Maybe the commercial options, but I'm sure they suck in their own way (besides being pricey).
&gt;On the web I can not use Lisp I use ClojureScript for front-ends, single-page apps, etc. works great
&gt; Parenscript is not a viable solution. Why not?
I am afraid you might be right.
&gt; Recently, when I tried Gtk based examples on Linux nothing has worked. Try mresto's mini-project: https://www.reddit.com/r/lisp/comments/ah3aej/sbcl_gtk_demo_scripts_update/?st=jr8hrbax&amp;sh=370053b9
UI: No. Unless you use imgui libraries or things like SDL2/OpenGL (which should work fine with CL). C: You should have no serious problems. Post the problems you ran into with grovel here so that others can help you.
On the contrary especially on the web you can use Lisp. Please avoid JS as the first stop when shopping for web UI elements. Use normal HTML and CSS, if and only if you absolutely need something dynamic or some form of logic, add a bit of JS. CL can produce HTML outputs just fine.
Hi dk_jackdaniel. What is the status on the bounties currently listed as active? I think I want to take one on.
I'm using [fork](https://github.com/borodust/claw) of [cl-autowrap](https://github.com/rpav/cl-autowrap) for interoperating with C libraries. Amazing experience so far. Depending on a library quality, it can be wrapped in 15min. [bodge-ui-window](https://github.com/borodust/bodge-ui-window) is an [example](https://github.com/borodust/bodge-ui-window/blob/master/examples/basic-example.org) of combining several libraries built with this tech for drawing a UI :)
I use Qtools for Qt access from within Lisp and I interface with libraries using CFFI and CL-AUTOWRAP. I enjoy the combination.
I've had no problems with cl-cffi-gtk on Linux. I've had odd crashes with GTK on Windows but I think that is a bug in GTK in Windows rather then Lisp or cl-cffi-gtk. (Yay random unhandled exceptions in GTK code... Something about GTK not doing locks correctly on Windows or GtkFileChooser is buggy on Windows 😐)
For the historical record: for an early version of .NET, David Miles was able to get the \[ABCL\]([https://abcl.org](https://abcl.org)) interpreter running with some amount of real wizardry. &amp;#x200B;
Does it work from the command line? Most of the examples work for me. /snek-master/examples$ sbcl --script grid-bz-walk.lisp To load "zpng": Load 1 ASDF system: zpng ; Loading "zpng" To load "png": Load 1 ASDF system: png ; Loading "png" To load "cl-svg": Load 1 ASDF system: cl-svg ; Loading "cl-svg" itt: 0 itt: 100000 itt: 200000 itt: 300000 itt: 400000 itt: 500000 itt: 600000 itt: 700000 itt: 800000 itt: 900000 file: tmp.png Evaluation took: 18.786 seconds of real time 18.754649 seconds of total run time (18.551051 user, 0.203598 system) [ Run times consist of 0.812 seconds GC time, and 17.943 seconds non-GC time. ] 99.83% CPU 2 forms interpreted 289 lambdas converted 49,809,404,744 processor cycles 6,701,557,496 bytes consed &amp;#x200B;
Good bot
Thank you, shelvick, for voting on JobsHelperBot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://botrank.pastimes.eu/). *** ^(Even if I don't reply to your comment, I'm still listening for votes. Check the webpage to see if your vote registered!)
Depending on how you value your time over the money, LispWorks CAPI could get you going with UI real quick and its a pleasure to work with. The IDE is designed around ability to inspect all UI objects in real-time which is nice. Not sure if it allows you to build "complex" or "beautiful" interfaces though, I believe for this Qt provides more options. 
OM7 is for example a new open source LispWorks application. The OpenMusic project has over the years tried a lot to run on non-LispWorks. But they don't see any real alternative for what they are doing... &amp;#x200B; [https://openmusic-project.github.io/om7/](https://openmusic-project.github.io/om7/) &amp;#x200B; &amp;#x200B;
https://github.com/inconvergent/snek/blob/master/src/load.lisp this is an extremely weird way to load, no wonder you're having problems.
Im wishing for web backend for mcclim btw
There's a "lots of bits of LIsp" video on CFFI and Grovel: new one: https://www.youtube.com/watch?v=BL9MiiCcETM &gt; we take a look at making use of all the great C libraries out there without having to write bindings by hand. We look at cl-autowrap and cffi/c2ffi but also talk a little bit about the groveller too. On CFFI generally: https://www.youtube.com/watch?v=A5CnYlG7sc8
It would be nice if someone ported it to Qt5 (it is stuck in Qt4). Debian Linux has already dropped Qt4 and other distros are following it. I sometimes fantasize about having enough time to contribute an effort to port it to Qt5.
Same here - porting it to Qt5 would be very good, but I do not have enough time to do it or knowledge.
i stopped developing this repo, but if i recall correctly this is probably because i was using an older version of sbcl that behaved somewhat differently. the solution (probably) is to remove `(asdf:load-system "snek")` from load.lisp. and then and instead insert it into the script you are trying run. making sure you insert it after `(load "../src/load")` in said script. 
&gt; a very long winded error message that means nothing to you. Huh. I think in that case it is your responsibility to investigate the stack trace, no? Publicly available libraries are open sourced so it is everyone's responsibility to investigate it and fix it, and the "long message" is actually more helpful than nothing. Unless, in fact, the library authors are not actively maintaining the project, like in the case of cl-gtk-someversion, and even after sending the patches nothing happens. This is the largest concern I usually have.
C interop matters because it is the only way how to get access to anything you don't have native in Lisp. Which is pretty much everything, even that web UI HTTP needs sockets. Browser/web as an UI sucks horribly, especially for desktop applications - what you can build in 10 minutes in QtDesigner takes you a day or two using a web framework of your choice, will break/resize in weird ways whenever screen/window size changes, glitch in all sorts of ways depending on which browser and which extensions your user has and integrating it with the standard desktop services is a royal pain, especially if you need to access hardware or anything outside of the browser. Oh and you need at least two programs now (the application and a browser). If this browser UI for desktop applications fad died yesterday it would have been too late.
Thanks so much. I'll try that this evening. I really enjoy your work. Its fun to play around with this great tool.
I'm trying from the command line but not having any results. the author is in here mentioning he/she used an older version of SBCL. It used to work with me but I think it was a commit before they introduced the asdf system. My version of SBCL is 1.4.6-2.fc29. Is yours perhaps a bit older?
Here, you seem to be talking about back-end driven web programming. The browser platform is increasingly used for programs that don't even have a back end. That's the problem. 
There was no stack trace the way you imagine. You do not know what you are talking about. Lisp gave me an error with a very small stack trace which told me that a repl command was invoked.
&gt;So I wonder if there any point of trying to use Lisp in situations where you have to nontrivially interoperate with any complex C libraries. As far as I know we have at least two or three libraries that automatize the creation of bindings to C, so I would expect that the interop with C is really easy. At least it seems so whenever I explore code that uses CFFI. Also, by the way, using ABCL, the interop with Java is *damn* easy. 
For C inter operation [ECL](https://common-lisp.net/project/ecl/main.html) might be a good fit, and they have [EQL](https://www.cliki.net/EQL) for QT GUI development. As always it comes with its trade offs, but depending on what you are doing it may suit you. 
As mentioned by the author /u/inconvergent, moving the asdf system call `(asdf:load-system "snek")` out of load.lisp file solved it for me. thanks everyone.
While new features have been added the stuff covered is still going to be very appropriate and accurate. As in &gt;90% of the material is still applicable to the latest version of Clojure.
yes but it covers nothing that's been introduced in the last 6 years and that's a lot.
It seems like only a few years ago that they dropped support for Qt3, and a number of apps went away because Qt4 had zero backward compatibility. I wonder if it's worth it to even use Qt given that you have to be prepared to completely rewrite your app's UI every few years. 
How about this small collection ? https://twitter.com/pierre404/status/1088379286787112961
This emulator is capable of running Interlisp-D, as per the README. I'm curious if it's the first time Interlisp-D runs on an emulator, excepting Medley (which I suppose may or may not be considered some version of Interlisp-D).
I would say yes. Never used Interlisp so I can't be 100% sure. But looks like a version from 1977. Even has DWIM code. Also has references to BBN Lisp from which it came.
I had a Xerox 1108 Lisp Machine in the 1980s, and yes, that code is InterLisp-D. I loved the first InterLisp environment, but when Xerox switched to Common Lisp, my Machine did not have the horse power to run properly.
Thanks. But do note this is the PDP-10 Interlisp. Not Interlisp-D. &amp;#x200B; For your information, there is now a Dandelion emulator which can run Interlisp-D: [https://github.com/livingcomputermuseum/Darkstar](https://github.com/livingcomputermuseum/Darkstar)
The PDP10/interlisp github site seems to be getting updated as I write this, but Interlisp-10 is now here [https://github.com/PDP-10/Interlisp-10](https://github.com/PDP-10/Interlisp-10)
good bot
Anyone used [GTK-server](https://www.gtk-server.org/) with Common Lisp? Seems to be actively maintained and has some lispy samples, but I didn't find any larger use of it in a CL project. The idea seems to be interesting at least for simpler UIs. 
What are you trying to be with that tone? An ignorant version of /u/stassats?
Would it be possible for you to paste the error and any relevant output over here?
clojure ain't a lisp though, and this is just an upwork ad
What those people are working with in that stock photo don't look like no Lisp.
just a generic html/css/js picture as usual
True, but for beginners it would be a start.
&gt; Also, by the way, using ABCL, the interop with Java is *damn* easy. That sounds like a reasonable option. If one thinks of the JVM as just another cross-platform library (that includes the kitchen sink and the house attached to it), and if the performance is there, then why not? Xach refers to a thread on the topic of "Java GUIs with ABCL" at the following link. [https://xach.livejournal.com/310363.html](https://xach.livejournal.com/310363.html) I don't know if there's one out there, but it could be helpful to see a screenshot of a working application using ABCL, perhaps with code showing how the GUI was created entirely in Common Lisp without writing any Java and without relying on a bridge to a GUI written in Java. &amp;#x200B; There is a small sample Mandelbrot application using ABCL and the JVM for the GUI in, "Common Lisp Recipes: A Problem-Solution Approach", as shown in Google books... [https://books.google.com/books?id=FPxSCwAAQBAJ&amp;pg=PA648&amp;lpg=PA648&amp;dq=Java+GUIs+with+ABCL&amp;source=bl&amp;ots=vW7L1ueLm6&amp;sig=ACfU3U1nGW\_C0ITJtfbyDvoe8L0Dvzv5og&amp;hl=en&amp;sa=X&amp;ved=2ahUKEwjJ9Oe7yYngAhUOB3wKHYHlBvwQ6AEwBXoECAkQAQ](https://books.google.com/books?id=FPxSCwAAQBAJ&amp;pg=PA648&amp;lpg=PA648&amp;dq=Java+GUIs+with+ABCL&amp;source=bl&amp;ots=vW7L1ueLm6&amp;sig=ACfU3U1nGW_C0ITJtfbyDvoe8L0Dvzv5og&amp;hl=en&amp;sa=X&amp;ved=2ahUKEwjJ9Oe7yYngAhUOB3wKHYHlBvwQ6AEwBXoECAkQAQ) &amp;#x200B;
&gt;I don't know if there's one out there, but it could be helpful to see a screenshot of a working application using ABCL, perhaps with code showing how the GUI was created entirely in Common Lisp without writing any Java and without relying on a bridge to a GUI written in Java. Been there, done that. Want to see how it looks? Try it yourself, my own "abcl-jazz" wannabe-library: [https://github.com/defunkydrummer/abcl-jazz](https://github.com/defunkydrummer/abcl-jazz) I'm going to post this one as a separate post, since many people have asked for this before. 
I'm posting this because from time to time people ask in /r/lisp or /r/Common_Lisp about the possibility of doing UI development under Lisp by using the Java GUI libraries like Swing. This is an example that shows how it could be done in an easy way: Includes functions to make working with Swing easier, and some simple sample code. In any case, creating a Swing GUI under ABCL is far, far easier than doing it directly on Java. 
This is the oddest thing I've seen in a while.. I'm not sure anyone like swing that much, not even hard core Java people.. isn't JavaFX the new UI thing for Java, I mean, if you have to do fat client apps in Java..? 
Lol, "Ask, and you shall receive!" Thank you for the work and the link. From the link: &gt;Instead of Electron, let's use: &gt; &gt;as platform: the JVM, which is usually already present Many Windows users may be surprised to learn that not only is the JVM likely to be on their workstations and servers, but how many copies there may be of it. Simply searching using the following at the command prompt from one's C: drive ("C:\\&gt;"), or wherever software is usually installed on one's machine, can reveal how seemingly ubiquitous the JVM is... `C:\&gt;dir *java*.exe /s /r`
&gt; I'm not sure anyone like swing that much, not even hard core Java people.. isn't JavaFX the new UI thing for Java, I mean, if you have to do fat client apps in Java..? JavaFX also has its fair amount of hate. I choose swing because it's very simple to learn and there are tons of tutorials out there. My purpose was to show that this isn't difficult at all. 
&gt; Many Windows users may be surprised to learn that not only is the JVM likely to be on their workstations and servers, but how many copies there may be of it. Exactly. Case in point: My workplace laptops don't allow me to install any software that requires installer. But it gave me a JVM runtime there. So i can execute whatever comes in JVM bytecode :)
As someone who hasn't really paid attention to clojure, why is it not a lisp? What makes a language a lisp or not? 
"Electron is immoral". Love it.
Can SWING do TUIs? Through this?
There's too much syntax, as Clojure uses [] for literal vectors and uses vectors in many places like defn and let. It's also quite opinionated compared to CL or even Scheme.
Yes, it's becoming common for businesses to lock out the ability to install software, block downloading files ending in .exe, and even lock out the use/availability of USB/CD/DVD drives on laptop workstations. I suspect that this will become most workplaces eventually. Unfortunately, this limits SBCL's and ECL's exposure in the workplace. It's fortunate that ABCL, Clozure CL, and Corman Common Lisp offer zipped no-install versions of their binaries to download. I believe CLISP also provides a zipped version of the last binary. A roundabout way of obtaining SBCL is through downloading the excellent Portacle IDE which includes it. But, for a subset of newcomers who just want to explore Common Lisp on Windows (and Linux via Wine) and who may not be prepared to invest time in Emacs, Corman Lisp might be a more familiar environment.
Thanks for this! A couple of months ago I searched for examples on using ABCL with a Java GUI and all I could find were 5 line hello worlds, and even those were hard to find. The "swing-test.lisp" file looks very clean for not being a native lisp toolkit. Again: Thanks!
You're welcome, sir. Brothers in Lisp.
[https://www.infoworld.com/article/3261066/java/javafx-will-be-removed-from-the-java-jdk.html](https://www.infoworld.com/article/3261066/java/javafx-will-be-removed-from-the-java-jdk.html) &amp;#x200B;
&gt; "Electron is immoral". Love it. I also like to say "Programming for the JVM is immoral" too... lol 
&gt;Corman Common Lisp might be a more familiar IDE/environment. Latest version of Corman CL isn't available in binary form yet. And it doesn't work with ASDF3 yet. But sooner or later all this will be possible. I love Emacs, though. 
momma always say JVM is for the devil 
JVM's pretty cool. Things like jvisualvm, etc.... Too bad it's for java.
Can jvisualvm be used with Java classes compiled by ABCL, Clojure, Jython...etc?
He who?
You've done those searching for a way to do cross-platform GUI development in Common Lisp a good turn. Thank you!
I should've Googled this first, but apparently the answer seems to be yes! &amp;#x200B; [http://clojure-goes-fast.com/blog/profiling-tool-jvisualvm/](http://clojure-goes-fast.com/blog/profiling-tool-jvisualvm/)
Sorry, my first post. I botched it: it should have been a link 
Thanks but I don't think Swing is the best option; you should take a look at Qt instead. Also, see `ltk`, which is cross-platform as well.
I like the way he bashes the religious praises of God Lisp by Graham, Seibel, Raymond, and then proceeds to a down-to-earth explanation of how Racket gave him an edge in a real-life project.
Thanks for the correction.
momma advice is good for you
Maybe some TextArea or similar component is able to be addressed at a row,column level. 
&gt;Can jvisualvm be used with Java bytecode compiled by ABCL, NetRexx, Clojure, Jython...etc? In theory anything that is compiled to a bytecode class can be used from ABCL. 
Sounds good that he kicks out the religious part. I think it does Lisp more harm than good - people come in expecting a religious enlightenment, and find a programming language. Sure, Lisps are good programming languages, but they don't make people discover Ultimate Thruths About Life, which is why they feel disappointed and cheated nonetheless.
Why ... does this fucking page redirect to `https://practicaltypography.com/graylist.html` unless the reader first visits `https://practicaltypography.com`, which the visitor must figure out for himself? "Deep linking is copyright infringment" is still a thing? 
The "best" option really is subjective in most cases. It often depends on a combination of goals/requirements/constraints and available resources/skills at a particular time and place. In other words, "best" changes depending on circumstances. There are many applications with complex GUIs that are written in Java and are cross platform. Yet, despite the fact of ABCL having Java interop and being hosted on the JVM, it's very rare to see any reference to using only Common Lisp for GUI development with the JVM that also provides practical examples. I'm just glad that more people will get a chance to kick the tire using your examples and compare it with their experiences using Qt and LTK. Perhaps, when they have the time, they can then share their comparisons of the strengths/weaknesses in using either JVM/Swing, Qt and LTK for GUI development in Common Lisp, and how easy and reliable they think each can be expected to be for what might be considered complex GUIs written Common Lisp.
https://practicaltypography.com/why-racket-why-lisp.html
\&gt; Every expression is either a single value or a list. Or a variable. &amp;#x200B; &amp;#x200B;
Haven't tried it.
Thanks for this encouragement. On my readme, i mention the `snow` library. If somebody wants to use swing for UI within Common Lisp, that's the most professional way. It is well documented. However, i feel my approach makes the simpler stuff easier.
Good job, fellow lisper d00d! Can't wait until I get home to try.
sonofabitch
Meh. It needs some adjusting to load, but I am a total fan of the art you've managed to create from it.
Spending time learning to work in Emacs will spoil the experience for other source code editors. It really is true.
&gt;Spending time learning to work in Emacs will spoil the experience for other source code editors. It really is true. There are people who think the Emacs learning curve is spoiling CL adoption. I think both arguments are true. Corman CL IDE might be a new hope. Just put some bling bling on it to look 2019-fresh. Perhaps we can put a picture of Roger Corman dressed like a hip-hop or reggaeton artist, to help with the marketing. 
Ten years ago there also used to be the Snow project: https://common-lisp.net/project/snow/docs/tutorial.html 
Yes, it's a high quality lib, as far as I can see. I mention it on my readme file, under "Prior Art". I didn't like it being dependent on an external layout management ib, though.
I agree. A variation and extension though.. I see a problem of citation. The real business seems to be in Mac Lane and Barendregt. The wide applicability of the structures and processes layed out there is undeniably powerful and seductive. I'm just in the throes myself. Why don't they teach this stuff in kindergarten? /Bourgeois dilettante/ 
That is very cool! I think ABCL is an under appreciated resource. I have only used it recently with DL4J, so I am glad to see a very different application.
I need to finish barendregt then.. I wasn't ready to absorb before. What's MacLane book title ?
I don't think he's talking about copyright infringement. Judging by that page's name, he's doing this for traffic from some "graylisted" sites (including Reddit) that bring in lots of traffic that doesn't pay. See *[Why you should pay](https://practicaltypography.com/why-you-should-pay.html)* for more of his idea on a web-based book, and *[The economics of a web-based book: year one](https://practicaltypography.com/economics-year-one.html)* for his reflection when the book was a year old.
Great
I understand the intent, but the way this is implemented is confusing. At first I thought this post was spam because the graylist page is not about Lisp. It would be better to use some kind of overlay or message at the top of the page.
&gt; It would be better to use some kind of overlay or message at the top of the page. Indeed.
There's a library called [lanterna](https://github.com/mabe02/lanterna). Clojure folks wrapped it for some text-based roguelike games.
I'd seen that, just can't stand the idea of coding in Java. Using a library is open in a decent language like CL.
/Category Theory for the Working Mathemetician/, S. Mac Lane It's all pretty new to me and I don't mean to imply mastery, just that the bare expositions are more cogent to me than the works of the LISPers. Their enthusiasm attracted me but I had to follow bibliocrumbs to find the good bits.
Right because where you are referred from is super important! You're searching for something in Google. A search result takes you to Reddit. There you click on a link that takes you to `practicaltypography.com`. Oops! You're now some asshole "from Reddit".
Reminds me that I pinged paul graham on twitter and he honestly acknowledged that he was taught things he describes in On Lisp by others and he had to struggle. Surely there are deeper readings.
My particular moment came with the understanding that LISP, like all programming languages, is just plumbing. It's the transparency and flexibility that make attractive.
TL;DR: The article begins by critiquing well-known authors' advocacy of Lisp as lacking concreteness. Then he gets into the reasons, which are: 1. Everything is an expression 2. You can use lists for everything. Lists are used to represent Lisp code. (This isn't actually true for Racket or any Scheme dialect implementing hygienic macros.) 3. Lisp supports functional programming. 4. Racket comes with a lot of libraries and they're all exhaustively documented. 5. DrRacket is more convenient than the command-line. 5. It's convenient to use S-expressions to represent XML. 6. Racket has a LaTeX-like metalanguage called Scribble. (The author does not mention that Racket includes a "literate programming" tool similar to the one Knuth developed for TeX, and Scribble is used as the typesetting language for that. Because Scribble is implemented with macros, Scribble/LP code is directly compilable without having to run a preprocessor first.) 8. Macros. Supposedly, Racket macros are more powerful than those of Common Lisp, but the author also seems to mistakenly believe that CL macros just inject things into templates. 9. Racket's macro system can be used to create new programming languages and DSLs. 10. The dev team is friendlier than those of other large open-source projects and they're quite open to accepting PRs from outsiders.
That's also something I like in a programming language. Lisp, forth ... few bits, very principled, very open.
From a tiny kernel, a mighty graph does grow.
Exactly. And then you can [shrink it](https://www.google.com/search?client=firefox-b-d&amp;q=growing+a+language)
There went my evening. Thank you!
There went my evening. Thank you!
That's a swing-based component that does what you asked for. You'd be doing the same thing as in OP's case, calling java via interop, which OP gives you plenty of examples of if you look at the implementation here.
Clojure code is different to Lisp code. They are not compatible. I can take Lisp code from 20 years ago and run it on Common Lisp or Scheme with minor if any modifications. That's not possible with Clojure. That makes Clojure not a Lisp.
While JavaFX may not be included in the Oracle JDK binary, it is still being developed under the open source OpenJDK project that Oracle's proprietary JDK binary is based on. Also, here's some helpful advice found on StackOverflow regarding deploying applications based on the JVM from the context of including JavaFX... &gt;**Advice on Deployment for Substantial Applications** &gt; &gt;I advise using Java's [self-contained application](http://docs.oracle.com/javafx/2/deployment/deploy_overview.htm#CEGHEAHD) deployment mode. &gt; &gt;A description of this deployment mode is: &gt; &gt; &gt; &gt;*Application is installed on the local drive and runs as a standalone program using a private copy of Java and JavaFX runtimes. The application can be launched in the same way as other native applications for that operating system, for example using a desktop shortcut or menu entry.* &gt; &gt;[*https://docs.oracle.com/javafx/2/deployment/deploy\_overview.htm#CEGHEAHD*](https://docs.oracle.com/javafx/2/deployment/deploy_overview.htm#CEGHEAHD) &gt; &gt; &gt; &gt;You can build a self-contained application either from the Oracle JDK distribution or from an OpenJDK build which includes JavaFX. It currently easier to do so with an Oracle JDK. &gt; &gt;As a version of Java is bundled with your application, you don't have to care about what version of Java may have been pre-installed on the machine, what capabilities it has and whether or not it is compatible with your program. Instead, you can test your application against an exact Java runtime version, and distribute that with your application. The user experience for deploying your application will be the same as installing a native application on their machine (e.g. a windows .exe or .msi installed, an OS X .dmg, a linux .rpm or .deb). [https://stackoverflow.com/questions/18547362/javafx-and-openjdk](https://stackoverflow.com/questions/18547362/javafx-and-openjdk) &amp;#x200B;
Aw man I used to program a bit of lisp for fun a long time ago, even made a text chess program that could look all of 3 moves deep (ie was crap). I intend to pick lisp up again and watch all of your episodes one of these days. Keep it up!
While, as far as I'm aware, there isn't anything preventing ABCL users from using JavaFX in their projects to write Common Lisp applications that run on iOS, Android, Desktop and the Web. The ABCL developer would now need to go through additional steps to package JavaFX (aka OpenJFX) as a library in their applications. However, if the target is simply the Desktop, then the Common Lisp developer can simply rely on the Swing library that's already included with the JVM and that's likely to already be on a large number of Windows workstations, and perhaps even Linux workstations. The Swing examples provided are a nice guide to the latter set of developers who only need to target the Desktop for GUI development with Common Lisp and who don't want to package an external library like JavaFX that supports more platforms.
&gt; Friend or foe? Let's see your Referer header! Friends don't let friends send Referer headers! (And if web pioneer JWZ does it for HN, it can't be all wrong.)
&gt;You can use lists for everything. Lists are used to represent Lisp code. (This isn't actually true for Racket or any Scheme dialect implementing hygienic macros.) Could you elaborate on this? That's news to me
You should have a look at the Land of Lisp book, one of the exercises is a board game with lazy move planning!
In Scheme, macros operate on opaque "syntax objects" that have the information necessary to enforce the hygiene. The only way to access them is through a special pattern matching syntax. There is also syntax for constructing syntax objects, since you can't just use `cons`.
Interesting! In what way do these syntax objects differ from lists? Got any recommended reading?
Cheers! will certainly try to.
Racket's documentation is a good place to start. https://docs.racket-lang.org/guide/stx-obj.html
Great! Thank you!
here's a Paul Graham paper about this [Roots of Lisp](http://www.paulgraham.com/rootsoflisp.html)
I am currently reading through this analysis of ’Recursive Functions...’ http://blockml.awwapps.com/example/example/document.html And, I seem to recall that http://www.paulgraham.com/rootsoflisp.html do go over some or all of your questions.
The Roots of Lisp. I have a toy project of mine that is an (incomplete) implementation of the Lisp described there; it is heavily commented in Polish, but otherwise readable (since it's standard Haskell): https://github.com/phoe-trash/malish Other people likely have better documented and more complete examples.
You do not really need logical operators to define EVAL. Attached below is the Common Lisp translation of a minimal EVAL by McCarthy from the LISP I Programmer's Manual (I hope I did not mess up the copy-paste). If you use LABEL in the place of LABELS, it would be entirely self-contained (as the original was). Translation by myself, from a book that I have never published. Enjoy! (labels ((eval (x e) (cond ((atom x) (assoc x e)) ((atom (car x)) (cond ((eq (car x) (quote quote)) (cadr x)) ((eq (car x) (quote atom)) (atom (eval (cadr x) e))) ((eq (car x) (quote eq)) (eq (eval (cadr x) e) (eval (caddr x) e))) ((eq (car x) (quote car)) (car (eval (cadr x) e))) ((eq (car x) (quote cdr)) (cdr (eval (cadr x) e))) ((eq (car x) (quote cons)) (cons (eval (cadr x) e) (eval (caddr x) e))) ((eq (car x) (quote cond)) (evcon (cdr x) e)) (t (eval (cons (assoc (car x) e) (cdr x)) e)))) ((eq (caar x) (quote lambda)) (eval (caddar x) (append (pair (cadar x) (evlis (cdr x) e)) e))) ((eq (caar x) (quote label)) (eval (cons (caddar x) (cdr x)) (cons (list (cadar x) (car x)) e))))) (evcon (c e) (cond ((eval (caar c) e) (eval (cadar c) e)) (t (evcon (cdr c) e)))) (evlis (a e) (cond ((eq nil a) nil) (t (cons (eval (car a) e) (evlis (cdr a) e))))) (assoc (x a) (cond ((eq nil a) nil) ((eq x (caar a)) (cadar a)) (t (assoc x (cdr a))))) (pair (a b) (cond ((or (eq nil a) (eq nil b)) nil) (t (cons (list (car a) (car b)) (pair (cdr a) (cdr b))))))) (eval (quote ((label append (lambda (a b) (cond ((eq nil a) b) (t (cons (car a) (append (cdr a) b)))))) (quote (a b c)) (quote (d e f)))) (quote ((t t))))) 
I usually use [https://edicl.github.io/cl-who/ CL-WHO] with Parenscript.
Sure, this solves one part of the problem, then if I want to define this notion of a template, to avoid repetitive work I would need a bit more. I could just write some macros, to expand on top of CL-WHO, however it would be nice if there was already such macros or a package that did it for me.
You could use clip (https://shinmera.github.io/clip/).
Did you see those options ? https://github.com/CodyReichert/awesome-cl#html-generators-and-templates I prefer Spinneret over cl-who (easier to compose, some more features like markdown integration), and Flute adverts to be even easier to compose and create one's own tags. 
I'm using closure-template at [ichi.moe](https://ichi.moe/) and it is a good option. The fact that it can generate equivalent JS code to process templates is a feature that shouldn't be underestimated. The disadvantage is that the best documentation for this library is in Russian, so it might be harder to understand it, if you can't read it. &gt;without the need of creating separate template files which are often cumbersome No, they are convenient. Keep your HTML and Lisp code separated, you'll thank me later. The biggest advantage over something like cl-who is that you can copy paste HTML examples from your favorite framework's documentation without back-converting it into Lispy format. Another advantage is that Emacs web-mode is great for editing Closure templates, while editing a tangled mess of Lisp code and cl-who macros is a pain.
hmm, maybe what I thought was a bug was actually a feature ;)
The book [Lisp in Small Pieces](https://en.wikipedia.org/wiki/Lisp_in_Small_Pieces) will answer this for you.
**Lisp in Small Pieces** Lisp in Small Pieces (Cambridge University Press, 1996 ISBN 0-521-56247-3; paperback edition (December 4, 2003) ISBN 0-521-54566-8; translated by Kathleen Callaway) is a book by Christian Queinnec on Lisp, Scheme and other related dialects, their interpretation, semantics, and compilation and contains code for 11 interpreters and 2 compilers. The English title is a kind of recursive acronym (Lisp in Small Pieces). It was originally published in French by Interéditions with the title Les Langages Lisp. The revised edition, published by Paracamplus, bears the title Principes d'implantation de Scheme et Lisp, another acronym based on the cover layout which orders the title as the following list '(Lisp Implementation Scheme Principes).This book is available in English from Cambridge University Press, the French version is available at Le Monde en Tique, a Parisian bookstore. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
A vote here for **spinneret** by Ruricolist. 
Though in Roots of Lisp, Graham also uses some things he doesn't define. Some are trivial, e.g. `caar`, but as far as I can tell, he doesn't define `defun`. 
Yes, it is still a good option. Another little known option is lofn template. [https://github.com/lokedhs/lofn](https://github.com/lokedhs/lofn)
You might find Shen interesting (formerly known as Qi). It's an academic Lisp that is based on a smaller bootstrap language that can be ported to a new system; then you get the rest "for free". http://www.shenlanguage.org/ http://www.shenlanguage.org/shendoc.htm#Kl 
That would mean a purely p2p system, somehow I doubt that this is used a lot. It is at most a hybrid system with the server delivering the data and the client doing (a lot of) the processing. Yet the data still comes from a server where you can use lisp or whatever language you want.
&gt; *Your task is to write a pure LISP program ... limited to using the following functions* See, this is the sort of bullshit that leaves students with a bad impression of Lisp. The prof didn't get the memo in early 1980-something that Lisp isn't capitalized any more as LISP, and that it's a multi-paradigm language that supports imperative, functional, object-oriented and other techniques. 
1) This isn't a Lisp assignment, this is an assignment in list processing that happens to be using Lisp as a language of choice. Literally the same assignment could be done in any other language. So, the note about "bullshit that leaves students with a bad impression of Lisp" does apply. 2) Programming languages aside: what kind of algorithm or approach would you use in general for that assignment? 3) FYI, /r/learnlisp also exists.
Yes, unfortunately.
Let's clear up something about Lambda Calculus. Lambda Calculus is a branch of math dealing with anonymous functions. It isn't Lisp. Lambda Calculus has no list manipulation at all, let alone lists made of cons cells. It has no `quote` operator for expressing its own notation as a piece of data which could then be operated on by Lambda Calculus. Lambda Calculus, unless extended with additional term types, has no data type other than functions. A very inefficient "Church Numeral" encoding of natural numbers in terms of functions. A lexically scoped Lisp can simulate Lambda Calculus in the sense that Lambda Calculus expressions can be translated to Lisp and evaluated. That Lisp won't be doing any usual Lisp stuff like manipulating symbols, conses, strings, numbers, or even defining global bindings with `defun` or `defvar`: it will just be "lambda soup". 
I don't think you have a Lisp if there are no character strings and numbers. What you have there doesn't pass the Lisp Hello World test cases like: (+ 2 2) -&gt; 4 (print "Hello, world") 
I played around with this in 2013. The main issue at the time was that CCL caches package name lookups IIRC. Would love to see this implemented!
It's true, but it seems worth noting that Lambda Calculus *is* very usefully extended, and supplemented with other concepts, to form the basis of formal systems. For instance, it's typical to employ a (sort of typed) lambda calculus combined with N-order predicate logic and a theory of syntactic structure (which itself involves things rather like `cons`) for formal semantic analysis of natural language (where there's also an analogue of `quote`).
Package nicknames should *only* be package local. 
Take a look at how Gauss summed the numbers between 1 and 100. You might find some inspiration there. 
FWIW you should use probably use functions not macros for composing with cl-who. As others have mentioned, spinerret makes this easier.
&gt; *extension to defpackage, :local-nicknames.* what is the API? *defpackage* is just a macro; everything that *defpackage* does is understandable in terms of functions like *intern*, *import*, *export*, *make-package*, *use-package* and whatevernot.
Really? I've always found macros more natural, and they were used in [Lisp for the Web](https://leanpub.com/lispweb).
They may not have a *modern* LISP, but they definitely definitely have a LISP. There were no strings in LISP 1.5. There were no strings in early MACLISP. There were not even slashified symbols (pseudo strings) until PDP-6 LISP (the direct predecessor of MACLISP, a.k.a. LISP 1.6). Numbers were lists of digits in early LISP I. You can do this in a very minimal LISP. 
I read blog and I disappoint. The first step to resurrect old hardware is to clean it properly. Disassemble clean reassemble. 
https://github.com/jaeschliman/clinik Here are some early attempts at this... quite a mess but may provide some pointers. $DAYJOB got in the way and I never returned to it... Think I even have an additional version laying around on a HDD somewhere, will try to dig it up
Good Lord ! He comes back, but I can't attend the stream :( ... See you next time, buddy !
I think with the advent of Quicklisp, people have let their natural tendencies (laziness) seize control and practically gone full retard. The Common Lisp library ecosystem is slowing turning into a node.js-like swamp. This is why years ago I rm -rf quicklisp and refuse to use it. This practice forces me to do a manual evaluation pass on every prospective 3rd party library before I use/depend on it. Needless to say, 9/10 I reject it as it's bad garbage. Here are some of the dependencies of spinneret: :depends-on (#:parenscript #:alexandria #:cl-ppcre #:global-vars #:serapeum #:trivial-gray-streams) Not bad right? Most of the usual suspects (alexandria, cl-ppcre, trivial-gray-streams) that have been well-vetted by now and some (needless) bloat in the form of global-vars. Also, I am not sure why parenscript is not optional. But then, let's look at "serapeum": :depends-on ("alexandria" "trivia" "trivia.quasiquote" "uiop" "split-sequence" "string-case" "parse-number" "trivial-garbage" "bordeaux-threads" "named-readtables" "fare-quasiquote-extras" "parse-declarations-1.0" "introspect-environment" "global-vars" "trivial-file-size" "trivial-macroexpand-all" Fucking christ! This is what I call an instant reject on my side due to dependency-orgy. Nearly **20** third-party library dependencies for a html generator. I am sorry but this is completely unacceptable. 
Wow, this is interesting, so they want to move it to Chez-Scheme because it's faster?
Next up: hierarchical package names such as a:b:c.
&amp;#x200B; `&lt;syntax&gt; (##core#lambda (nth avdamp-num) (display (nth-root nth avdamp-num 20)))` `&lt;syntax&gt; [display-nth-root-of-20] (##core#begin (display (nth-root nth avdamp-num 20)))` `&lt;syntax&gt; [display-nth-root-of-20] (display (nth-root nth avdamp-num 20))` `&lt;syntax&gt; [display-nth-root-of-20] (nth-root nth avdamp-num 20)` `&lt;syntax&gt; (display-nth-root-of-20 2 1)` `&lt;eval&gt; (display-nth-root-of-20 2 1)` `&lt;eval&gt; [display-nth-root-of-20] (display (nth-root nth avdamp-num 20))` `&lt;eval&gt; [display-nth-root-of-20] (nth-root nth avdamp-num 20)` `&lt;eval&gt; [nth-root] (fixed-point ((repeated average-damp avdamp-num) root-function) 1.0)` `&lt;eval&gt; [nth-root] ((repeated average-damp avdamp-num) root-function)` `&lt;eval&gt; [nth-root] (repeated average-damp avdamp-num)` `&lt;eval&gt; [repeated] (= n 1)` `&lt;eval&gt; [fixed-point] (try first-guess)` `&lt;eval&gt; [try] (f guess)` `&lt;eval&gt; [average-damp] (average x (f x))` `&lt;eval&gt; [average-damp] (f x) &lt;--` &amp;#x200B; This is the call stack. It's in average-damp that the issue happens (at the bottom). I used the Chicken scheme implementation to get this info :-).
&gt;The rest of this report will provide lots of numbers, but none of them expose the main benefit of Racket CS over the current Racket implementation: it’s more flexible and maintainable. It is faster in some cases, but it is more maintainable (according to the article.)
Oh I see, I love open source projects interacting like this, isn't it great :D
I find functions to be easier to debug (a major reason for the lisp truism "Never use a macro when a function will do"); I haven't read "Lisp for the Web."
Think of something you want to make, and start using some programming system to try to make it. If you get stuck, try to find some help. If it's hard to make progress and hard to find help, maybe switch to something else.
Alternatively, choose scheme and follow "how to design programs" or "structure and interpretation of computer programs" if you don't know what to make. Or as an aside if you have the time and motivation.
In the `nth-root` procedure, you've defined `root-function` as a procedure of no arguments which, when applied, returns a procedure of one argument. However, `average-damp` expects a procedure of one argument. Changing `root-function` so that it is a procedure of one argument which returns a number fixed the issue for me.
Thanks, I Appreciate the help. &amp;#x200B;
&gt;Thanks, I Appreciate the help. &amp;#x200B;
&gt;Edit2: what I want to do is program Equations , do numerical computing and stuff in that area ( theoretical physics, mathematics) If that's what you want to do, better take a look at Mathematica, MATLAB, SageMath (open source) and GNU Octave (open source). &gt;but I also want to program robotics and machinery, operating systems, software,etc... For each field there will be a few programming language that is more suited to the task, even if most programming languages are general-purpose.
Thank you for your reply. &amp;#x200B;
Macros nest really nicely with CL-WHO at least. I just have to wrap my new HTML with `(htm ...)`
I wouldn't worry about what dialect to choose at this stage. If you learn to program, you will likely use/learn more than one over time. As a new learner, it is much more important to understand how to properly analyze, design, and construct programs than what particular dialect of Lisp to choose first. You might consider trying the following course to see if it's a good fit. # Systematic Program Design [https://www.youtube.com/channel/UC7dEjIUwSxSNcW4PqNRQW8w](https://www.youtube.com/channel/UC7dEjIUwSxSNcW4PqNRQW8w) The free course is taught by famous computer scientist, Gregor Kiczales, who is one of the authors of an influential Lisp book and CLOS (a powerful dynamic object system for Common Lisp), and is known for developing the concept of aspect-oriented programming (all can be Googled for more details). His focus in the course is to help beginners learn to program well so that their programs closely match their designs. He uses the DrRacket programming environment to ease the student into learning how to do it in dialects of Lisp and by creating games (like Sudoku). The lessons are pretty short. But, if you feel that the lessons pick up speed too quickly in the middle of the course, then you can always watch/practice earlier lessons again to allow time for things to sink in. More about the instructor to get an idea about his goal: "Most of Kiczales' work throughout the years has been focused on allowing [software engineers](https://en.wikipedia.org/wiki/Software_engineer) to create programs that look as much as possible like their design, to reduce complexity and make [code maintenance](https://en.wikipedia.org/wiki/Software_maintenance) easier, ultimately improving software quality. " [https://en.wikipedia.org/wiki/Gregor\_Kiczales](https://en.wikipedia.org/wiki/Gregor_Kiczales)
Driving force is maintainability, racket devs are more familiar with scheme than C! 
I hate to say this, especially here, but as an absolute beginner you are better off starting with Python. Lisp is an amazing language, and one you should definitely learn at some point, but with the current state of the software development world I don't necessarily recommend it for beginners. Two main reasons: 1. There are way more resources (books, tutorials, answered questions on StackOverflow, etc.) available for Python than for any Lisp. This means that it's easier to find help when you run into problems. 2. The current software world is dominated by C-based languages. Python is (remotely) C-based, so you will find the switch from Python to other popular languages easier. At the same time though, Python has taken on a lot of Lisp concepts, and is a clean and enjoyable language to write in. In short, learning Python as your first language will be easier and and more effective than learning Lisp.
but... the only moral choice is rust...
Thanks a lot! I don't know why I made that `root-function` return a function... This part of the chapter looks easy (because of scheme's syntax) but I get confused with all these functions being passed to functions and being created by functions!
Thanks! I got confused with that `root-function`... I'm using guile, would you recommend me to use chicken scheme instead? I like learning guile since it's the 'official' GNU/Linux extension language.
I just happened to know Chicken Scheme and decided to install it to see if I could get more info than I got from you :-P. https://www.gnu.org/software/guile/manual/html_node/Interactive-Debugging.html You might want to try ,bt for a backtrace. Are you a beginner programmer?
Thanks for the resource! Yep, I am. I'm really enjoying the book 
Great! See you shortly!
that sounds like a ... *reads username* yea that 
You know, I only mentioned the lambda calculus because I was pretty sure some pedant would say "Lisp just reduces to the lambda calculus". Instead, you show up the same pedantry in reverse. Don't worry, no one has confused Lisp with the lambda calculus. Here's some pedantry in return: &gt;Lambda Calculus has no list manipulation at all, let alone lists made of cons cells. It has no quote operator for expressing its own notation as a piece of data which could then be operated on by Lambda Calculus. So what? The whole premise of the question is that we're removing features. And anyways, just like numbers, cons cells _can_ be encoded as functions. Please investigate Haskell lists and thunks. &gt;It has variables (named function parameters), but they are not symbol objects. Wrong. The lambda calculus has not only bound variables (function parameters) but also free variables. &gt;A lexically scoped Lisp can simulate Lambda Calculus in the sense that Lambda Calculus expressions can be translated to Lisp and evaluated. You should pause longer to think about why this would be so easy in any Lisp. It's not a coincidence. As Prof. Ramsey says [here](https://stackoverflow.com/questions/2750421/what-type-of-lambda-calculus-would-lisp-loosely-be-an-example-of), "Lisp corresponds to an untyped, call-by-value lambda calculus extended with constants." So, the question was, "how much of the extension can be removed without losing Lisp"? Again, the passing reference to lambda calculus was meant to be a backstop for pedants. 
&gt; *cons cells can be encoded as functions* Not easily if we want functions to satisfy *atom* and fail to satisfy *consp*. &gt; *The lambda calculus has not only bound variables (function parameters) but also free variables.* The concept of free variables is required in L. C. to articulate processes like beta reduction. A stand-alone L. C. expression (not embedded in any other expression) must be *closed* (have no free variables) in order to be semantically well-formed. &gt; *You should pause longer to think about why this would be so easy in any Lisp. It's not a coincidence.* It requires lexical scope; that was not present in MacCarthy's Lisp 1 or Lisp 1.5, and missing even from some dialects in current use like Emacs Lisp. According to *The Evolution of Lisp* paper, lexical scope was basically introduced into Lisp circles by Scheme. 
&gt; A stand-alone L. C. expression (not embedded in any other expression) must be closed Mr. Church would like to disagree. The Calculi of Lambda Conversion, Chapter II, page 8, definition (1): "A variable x is a well-formed formula, and the occurrence of the variable x in this formula is free." I see that you said "semantically well-formed". So is the following formula semantically well-formed? (&amp;lambda; x ((K I) x)) y where K is the constant function K == (&amp;lambda; a (&amp;lambda; b a)) and I is the identity function I == (&amp;lambda; x x). Is y free?
Yes, please!! We need them!!
I think we should mention Roswell on this topic. https://roswell.github.io There's also the curious and mind-blowing WCL which could help: https://github.com/wadehennessey/wcl &gt; The goal of WCL is to allow hundreds of Lisp applications to be realistically available at once, while allowing several of them to run concurrently. WCL accomplishes this by providing Common Lisp as a Unix shared library that can be linked with Lisp and C code to produce efficient applications. For example, the executable for a Lisp version of the canonical ``Hello World!'' program requires only 20k bytes on 32 bit x86 Linux. Also the recipe on building executables: https://lispcookbook.github.io/cl-cookbook/scripting.html 
Caching of package lookup is problematic because of DELETE-PACKAGE. If a program wants to cache package lookup in a compiled file it can do (load-time-value (find-package package-name)) so the package is looked up once when the compiled file is loaded.
&gt; There's also the curious and mind-blowing WCL &gt;&gt;Real Time Garbage Collector WCL now works with RTGC, a fully concurrent garbage collector. RTGC was tested by having WCL recompile itself. RTGC did 2069 concurrent garbage collects in the 16 seconds it took to recompile all of WCL. Sounds impressive. What happened to WCL?! Was it based on another impl? 
epsiode starts around 10:10. I'm still waiting on youtube to finish processing the trimmed version
For command line parsing, [Didier Verna's CLON](https://www.lrde.epita.fr/~didier/software/lisp/clon.php) seems very complete. I think that for scripting CLISP is nice, because it starts quickly. On the other hand, I don't understand why one would package a Lisp utility(or application) as a command-line utility to be integrated within shell scripting, since it would be far easier to do the other way around: do all the scripting in CL using the REPL and invoke external utilities from CL. 
It makes sense to deliver lisp applications or scripts that can be called from a shell when you're working in the context of a larger team which does not use lisp.
&gt; of a larger team which does not use lisp. A very long way to write "heretics" :) &gt;It makes sense to deliver lisp applications or scripts that can be called from a shell Yes, but I was mentioning it on the context of *shell scripting*; if the end-user is able to use something as ugly as BASH or (ugh) PowerShell, then a Common Lisp REPL through SLIME can't be that hard. 
That makes me 76 days to properly learn Lisp.
I have a game idea this year!
Or learn it improperly and write a game in it anyway.
I'm just going to leave [this](https://clisp.sourceforge.io/clash.html) here.
&gt; Light 13 candles in a circle round your Linux box, Sacrifice a white rooster, invoke Saint IGNUcious and ... Now I see why my shell didn't work. I didn't do the "kill the rooster" part.
They are pretty particular about those requirements. Sacrifice a black rooster and your vim session will never let you quit. Even across reboots.
Emacs Lisp has lexical scoping.
Is it Common Lisp only or is Scheme ok?
/u/CelloAxeMurder You can check the demos [at my GitHub](https://github.com/defunkydrummer/abcl-jazz), if you are able to catch the exceptions the Swing library throws, that would be a BIG thing for me.
They say any Lisp dialect is good. Scheme, CL, Clojure, Emacs Lisp etc..
Please read the rules. Everything is explained on the game jam page.
I see that "missing from" is an awfully wrong wording; lexical scoping is present in recent versions of Emacs, as an option.
Haha this is painfully true
As a relative newbie to lisp and a serious newbie to game development, what tools/engines should I focus on learning within the next 76 days?
I have the same question.
For 2D games there's Xelf, Sketch and trivial-gamekit. Xelf probably has the most documentation out of the 3.
thanks!
Well, *K* isn't the constant function, but a constant-function generator: (K &lt;whatever&gt;) yields a constant function (λ arg &lt;whatever&gt;) that ignores its input and returns &lt;whatever&gt;. Thus ((K I) x) ignores x and just returns I, and so we basically have (λ x I) y; x is identified with y, but then ignored. I think that doesn't rescue *y* from the semantic problem that it doesn't refer to anything. However, a non-strict evaluation strategy does sidestep the question by not requiring the value of *y*.
There is no such thing as a "generator" in LC. If K is a generator, then P == &amp;lambda;mnfx.mf(nfx) too, is a generator. It accepts a Church numeral M and returns a function that adds M to another church numeral. The resulting function, &amp;lambda;nfx.Mf(nfx) is still a function of three arguments, though. Is it still a generator? If so, what does it accept and what does it generate? Thinking about lambda functions in terms of generators is a bottomless pit that will leave you lost in a pool of "lambda soup", as you called it. I like that term! K is the constant function Kab that returns a for any b. To quote Church [Calculi of LC, pg 58], "Typical of the difference between the calculi of &amp;lambda;-conversion and &amp;lambda;-K-conversion is the possibility of defining in the latter the *constancy function*, K == &amp;lambda;a(&amp;lambda;ba), ..." Of course, it does not save y from being an *undetermined* variable [ibid, pg 9], but undetermined variables do not cause any lack of sound semantics. Undetermined variables arise in mathematics and as long as they can be eliminated, they do not cause any harm. To get back to the original point, though: you are absolutely right when saying that undetermined variables are *not* symbols. Symbols have *identity*, which variables in LC (determined or undetermined) do not have. &amp;lambda;aa is the same as &amp;lambda;bb (modulo &amp;alpha;-conversion), but (eq 'a 'b) would be false in LISP. Anyone who thinks that undetermined variables are symbols should try to express the above in LC. 
Just in case, `trivial-gamekit` documentation can be found [here](https://borodust.org/projects/trivial-gamekit/)
While I like this book a lot and purchased my copy when it first hit the stands, the price these days borders on ridiculous.
Omg, I've done it! (define (iterative-improve good-enough? improve) ;; returns a procedure that takes a guess as an argument, and keeps ;; improving it until it's good enough (lambda (first_guess) ; '1.0' (lambda (num) ; '2' (define (iter guess) (if (good-enough? guess num) guess (iter (improve guess num)))) (iter first_guess)))) ;; the call, example: (sqrt 2) (display (((iterative-improve good-enough? improve) 1.0) 2)) This exercise has made me understand recursion and how `lambda` functions work much better. I'm sorry if I'm annoying you people of this subreddit, should I delete the thread?
By the way, does trivial-gamekit separate drawing and game logic? Aka, I can have 60fps graphics but 30fps logic
I don't think so, since it's a decent exercise! /r/learnlisp would be a better place to ask this question though.
Here's a sneak peek of /r/learnlisp using the [top posts](https://np.reddit.com/r/learnlisp/top/?sort=top&amp;t=year) of the year! \#1: [Interfacing with your OS – the Common Lisp Cookbook (new sections 3.3 and 3.4, other improvements)](https://lispcookbook.github.io/cl-cookbook/os.html) | [3 comments](https://np.reddit.com/r/learnlisp/comments/advgmj/interfacing_with_your_os_the_common_lisp_cookbook/) \#2: [Paul Graham Lisp, or "Avoiding the CLOS"](https://np.reddit.com/r/learnlisp/comments/941f7v/paul_graham_lisp_or_avoiding_the_clos/) \#3: [Lisp Style Tips for the Beginner](http://people.ace.ed.ac.uk/staff/medward2/class/moz/cm/doc/contrib/lispstyle.html) | [5 comments](https://np.reddit.com/r/learnlisp/comments/838krf/lisp_style_tips_for_the_beginner/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/afd0dd/blacklist/)
Oh, thanks for telling me about that subreddit. I will check it out.
It doesn't, but you can create separate thread to run game logic in and then push updates to rendering (main) thread via `gamekit:push-action` function.
Also r/scheme, the language SICP uses. 
There's also Shinmera's [Trial](https://github.com/Shirakumo/trial) and he sent [this tweet](https://twitter.com/Shinmera/status/1091731450477637633), which makes it a good opportunity to get some first hand information on how to use the engine.
Ah, I didn’t see the link because it’s the same colour as the other text! Thanks.
I have a faint memory of a blog entry about CL2000 with similar goals
For iteration, Shinmera’s library `for` is pretty good. https://shinmera.github.io/for there’s also iterate, but I find for works a bit more nicely. Also, if you want functional-style sequence functions, map, reduce, etc. all work generically over sequences. (And some implementations like sbcl and abcl have an extensible sequences protocol that allows you to adapt new types to be used with these functions.) Fset also provides a bunch of immutable datastructures and reader macros for entering them as literals: they work pretty well but, honestly, I’ve never found that the standardized utilities are all that painful to use: loop, in particular, is a really nice way to express imperative algorithms as “executable pseudocode”
I just tried to find the project you mentioned, I remember it, but couldn’t find it again. Anyone have a link? The dialect had some Clojure features like seq if I remember correctly.
https://github.com/cl21/cl21 ?
Any hints on getting ABCL working with JSS? I've installed ABCL 1.5.0 on Gentoo, and separately fetched the contrib jar. I've been able to load the abcl-contrib module, but doing a require on jss fails. Can you share some information on how you've configured your environment?
If you are willing to go beyond Common Lisp, you may want to try [hy](http://hylang.org): a lisp over python - so you can access all of python's libraries. It's still in development, and I haven't done any serious development with it, so take it with a pinch of salt.
&gt; make it feel like similarly dynamic languages from the past few decades? Why do you need to make it worse?
Ah. What you probably want is `Dylin`: the infix Lisp-2 Dylan, which fixes all those issues of Common Lisp very nicely. Thankfully, it's actually just a layer on top of SBCL so it's very fast, portable, free, and retains 100% Common Lisp compatibility so you can use all your wonderful old libraries. Unfortunately^it^doesn't^exist^:(
Hi, I just do (require :jss). I downloaded the ABCL dist and it "just works". I already had a JVM installed, and i execute it by calling the java executable. My environment is Windows 10 64-bit. Which version of Oracle's poor excuse for a programming language are you using? I think ABCL will not work with versions newer than Java 1.8. 
&gt; systems that feel like language or stdlib improvements For me, Scott Burson's `fset` and `gmap` packages have achieved "stdlib" status. 
&gt;Is there a library (or set of libraries) that touch up Common Lisp and make it feel like similarly dynamic languages from the past few decades? So, you want to downgrade Common Lisp?
Yes, that one. I preferred plain CL better. 
You can access python libraries through CL using burgled-batteries. 
Gentoo's not including the contribs.
No, it appears to be related to Gentoo's ebuild. They didn't ship the contrib jar.
&gt;iterating uniformly over lists, Use `loop`. Loop for i in list &gt;arrays, vectors, loop for i across array &gt;hash keys, loop for i being the hask-keys of var &gt;replacements for type-specific methods (e.g. combining addition, list, and string concatenation all under + or other niceties like that) list concatenation: concatenate 'list x y string concatenation: concatenate 'string x y + is numerical addition. Want to overload everything? use CLOS. &gt;Common Lisp and make it feel like similarly dynamic languages from the past few decades? You mean, a library to downgrade Common Lisp? Good grief... 
Tease.
links: I found https://github.com/slburson/misc-extensions/blob/master/src/gmap.lisp (and [fset](https://github.com/slburson/fset) is more famous).
I've been at your place as a (total) beginner not long before. Now I don't feel the need of those anymore, I don't die out of frustration everyday, but I understand there may still be a need. Specially to help quickstart people. I built my first program with [cl21](https://lispcookbook.github.io/cl-cookbook/cl21.html) without any issue (or just one ASDF-related that is on stack overflow). But it has some issues that need to be addressed. Iteration: https://lispcookbook.github.io/cl-cookbook/iteration.html examples with loop, iterate, for, map and series. Someone is working on a generic CL: https://github.com/alex-gutev/generic-cl (however: we should consider that the way it is is what makes CL super fast, with good type warnings and error messages). Syntax improvements: https://github.com/CodyReichert/awesome-cl#language-extensions some people do use fn or f-underscore. 
Best attempt: https://github.com/tamurashingo/reddit1.0/ (seen on https://github.com/azzamsa/awesome-cl-software#social-news)
&gt;combining addition, list, and string concatenation all under + or other niceties like that) `concatenate` does this job nicely, and can even do some things not supported in all popular languages, such as concatenating a mixture of lists and arrays (you specify the result type). &gt;syntax improvements Macros can give you any syntax you like. There's even a library that implements C syntax.
&gt; Macros can give you any syntax you like. There's even a library that implements C syntax. I guess I’m more curious about which, if any, syntax improvements have very widespread community support
That is not uniform... they use different keywords. I wish to have more access to the type information in the environment, which guarantees the proper compile-time dispatching with the exact same syntax.
I believe this probably needs a superb language designer --- the one with aesthetic and practicality in mind. And a lot of time and money.
I couldn't either.. I know it's a super simple name maybe common lisp .next.. if I get an Eureka I'll edit 
&gt; type information in the environment, which **guarantees** TIL that CL is statically typed... when did that happen? 
&gt; fset is more famous I think of `gmap` as part of `fset` (technically a dependency, AFAIR), Despite the name, `gmap` is a generic `fold`, but with lots of syntactic sugar. (gmap (() 0 '+) 'identity (:index 1 101)) =&gt; 5050 (gmap :list '1+ (:list '(1 2 3))) It is "second-class" polymorphic, i.e. if you want polymorphic abstraction over `gmap`, you need to use a macro, functional abstractions will be monomorphic. That's arguably the right thing for a language that wants to be
There is the type predicates (e. g. "stringp", "arrayp", "integerp", etc) 
Perhaps [Folio2](https://github.com/mikelevins/folio2) is something for you.
&gt; I wish to have more access to the type information in the environment, which guarantees the proper compile-time dispatching with the exact same syntax. You're on to something interesting here. If I understand correctly, you want to leverage whatever type information the (SBCL/CMUCL/?) type inferencer must know, to be able to know which type has variable 'x' at compile time and thus be able to do some dispatch based on this information. This is a very interesting idea and hopefully this could be done in a portable way. Even in implementations without type inference, if one uses the `(declare (type` declarations, such declaration ought to be accessible from somewhere.
Well, at least things like Folio2 is a step in that direction. Perhaps if people keep working on refining such things, we'll get there.
I had posted this elsewhere for the same query: Thanks for bringing back to my notice! Is there a documentation or tutorial somewhere? The best I could find is [this](http://mmontone-programming.blogspot.com/2014/09/embedding-python-in-common-lisp.html). However, I'm still unsure how to do the basic things: * Do I have to `defpyfun` for every function? (For me, the burgled-batteries.syntax didn't seem to work. `(import :numpy)` keeps throwing an error. * Even after I do use `defpyfun`, how do I use the functions: what is the equivalent of `numpy.array([1,2,3])`?
So cool!
How true and so underrated. 
I used to play this game, spent years trying to get used to the sprawling mess that is Common Lisp and at least months trying to bend it into something semi-coherent. Don't get me wrong, it's still one of my favorite languages and I learned a lot from it. But in the end I decided that I'd be better off spending my time building exactly (https://gitlab.com/sifoo/snigl) what I want instead. My take home from that whole drama is this: learn to love the mess or move on, it is what it is and pretending otherwise just causes more suffering.
hy is hardly a Lisp, it's more of a Python with more parentheses.
What makes a lisp a lisp?
Well...Hy could be a lisp, but it's quite constrained by compiling to Python (or the Python virtual machine). The scoping is quite odd, compared to CL or Scheme, and they had to remove LET even.
&gt;get used to the sprawling mess that is Common Lisp I never understood this feeling. I've used Algol-60, Forth, RPL, all sorts of Basic, C, C++89, C#, a bit of x86, Z80 and 6502 assembly, Java, Pascal, Delphi, Actionscript, Javascript and Python before coming to Common Lisp. I never thought it was "a mess". "Sprawling mess" is something that i'd reserve for PHP4, Lingo, and perhaps Ruby. I learnt Ruby after CL and it was an infuriating experience. 
"I miss the Maker &amp; Retro movements" --&gt; yes. Makers are still there, but they'll be gone in something like 20 years. Remember the 80s? Not only you could open a computer and mess with its parts (I had an Apple \]\[+, and I could take away memory chips, ROMs, etc from it, and put replacements if I wanted). People would tune their car engines. Things were hackable. Now you have computers you can't hack; "smart" phones that control your life and you can't even take their batteries away! (see, you cannot login to your gmail account with your password on a different device. you need your PHONE!) And soon this will happen to electronics, I guess (please, convince me that I am wrong!). There is no reason for the industry to keep making small parts of things. Why wouldn't a big company just make a project, send to another big company for manufacturing, and then sell it? no need for replacement parts. Customers will buy brand new versions every X months... &amp;#x200B; There -- our freedom going away.
I was feeling ill this morning and watched this video until I felt better. Really an inspiring ‘retirement project’ story! A similar project, well not too similar, is Mezzano which is Common Lisp on bare hardware.
Great comment!
Bringing a copy of that up has been on my to-do list for a little while now. I've been assuming there wouldn't be much drama involved. 
I’m just going to leave this here. https://github.com/bradleyjensen/shcl
&gt; Now there are car engines you can't easily modify. For the most part you can; the tools are just different. Now we use CAN bus analyzers instead of interchangeable carburetor jets. Are some things designed for tamper resistance? Yes; much of that is related to government-mandated emissions liability for a very long duration after the sale. The first [open-source engine computer hardware](https://www.reddit.com/r/cars/comments/6p2jed/open_source_software_for_cars/) came out around 2001. &gt; (see, you cannot login to your gmail account with your password on a different device. you need your PHONE!) You certainly can, but the optional multifactor authentication usually leverages SMS in the consumer space. &gt; And soon this will happen to electronics, I guess (please, convince me that I am wrong!). There's a certain amount of DRM to worry about, but overall the future is bright. Did you know that [hackers have general-purpose computers now running open-source emulators of the proprietary games console that Nintendo introduced in 2017](https://yuzu-emu.org/)? That other hackers are [replacing the firmware in the latest servers with reconstructed versions](https://www.linuxboot.org/), for performance, security, and control? Home stereolithographic printers? You can order dev-kits for any kind of electronics you please, and sometimes they're quite cheap. RISC-V is an open ISA, with open-source synthesizable cores available for download on Github. 
I haven't sat through and watched any of your streams at length, but I did skip through some areas and caught several gems. You're doing really slick stuff, across a broad region (not "just" graphics / gamedev...which is impressive enough). I caught the bit where you discussed Checkmate; do you have any notes expanding on that [you mentioned it went beyond the typical HM type checker]?
Cheers, checkmate is very incomplete but it's using bidirectional type checking. It's really just a nice simple strategy for checking that smart folks have proved have some nice qualities. I'm not so hot on the theory so I'd recommend: - [this paper](https://www.cl.cam.ac.uk/~nk480/bidir.pdf) for the full details - [and this one](http://research.cs.queensu.ca/~joshuad/bitype.pdf) for a slightly lighter intro. I'm hoping that one day it'll be a pleasant system for expressive a variety of type systems from c#ish things through to more dependently typed approaches. Currently the inference for special forms is baked into checkmate so I need to make that user extensible. I also need to make sure what is there gives me enough to express CL's ranged integer and sized array type, this seems to imply some dependent types so appending `(array foo (5))` to an `(array foo (2))` can result in `(array foo (7))` and `(integer -2 2)` * 2 results in `(integer -4 4)`, etc. I could special case these of course but that's no fun. There are of course plenty of other issues and tradeoffs to be made so it might not end up being useful outside of my small projects, but it'll be fun to try.
Have you thought about reading The Little Typer? I'm reading through it now. It probably won't help you implement dependent types but I think it will make you gain intuition.
My copy of that and 'Type-Driven Development in Idris' arrived this morning :)
Maybe you can point me in the right direction is this question has been answered before, but why do you find Gerbil scheme attractive, coming from CL? Fare had a post on his blog some time ago where he attempted to answer this question but I didn't really understand what the fuss was about. 
It was Fare's post for me. To put it simply, it's not what I find attractive, per se, but what I find distasteful yet completely needed to interact with my systems. HINT: It comes between B and D, yet K&amp;R are also good letters! :P [https://www.reddit.com/r/gerbil\_scheme/comments/ao7vr1/what\_got\_you\_into\_gerbil/](https://www.reddit.com/r/gerbil_scheme/comments/ao7vr1/what_got_you_into_gerbil/)
Why Gerbil?
Because it's a language made to program and run systems. Not to learn, not to Lisp Machine, but to program and run systems. I am not a student, nor a full-time hobbyist. I am a systems developer, and gerbil is amazing to develop systems. It's also on the up and up, and continuously growing and improving. That is a big appeal. 
Yes but how can you tell that that's what it is? I skimmed the APIs, looks alright but I don't see why Gerbil over CL. Does it support live re-compilation like CL?
&gt;Yes but how can you tell that that's what it is? By reading the documentation, programming using the language, and interacting with the community. \&gt; Does it support live re-compilation like CL? A lot better than CL does... we actually compile! We are built on a compiler, and there are certain pieces that require compilation down to machine code. Which is not at all needed for CL: "compiled function n. an object of type compiled-function, which is a function that has been compiled, which contains no references to macros that must be expanded at run time, and which contains no unresolved references to load time values." . In other words, a compiled function could simply be some text to feed the interpreter. Which may not exist either! :) Even better, gerbil trivially supports compilation to static binaries, or dynamic libraries, and interacts with operating systems quite well. We have defsyntax and ##defmacro :)! &amp;#x200B; &amp;#x200B; " &amp;#x200B;
LOOP. And even that is not widespread, nor really improved. It's not quite polish notation! :) 
&gt;A lot better than CL does... we actually compile! We are built on a compiler, and there are certain pieces that require compilation down to machine code. &gt;Which is not at all needed for CL But what does this mean *in practice*? The following CL implementations compile down to machine code: LW, ACL, SBCL, CMUCL, ECL, MKCL, CCL, Corman CL. &gt;Even better, gerbil trivially supports compilation to static binaries LW, ACL, SBCL, CMUCL, ECL, MKCL, CCL, Corman CL do this, trivially as well. &gt;or dynamic libraries LW, ACL, Corman CL, ECL, MKCL, LW -- all of them can do this. Don't get me wrong, I think it's excellent that Gerbil Scheme has it's own subreddit, and I wish them the best, the more Lisp dialects out there that get growth, the better, but I simply don't understand your comparison where supposedly CL is far inferior on compilation options. Surely there should be points where GS fares better than CL, but this one?! 
I would like to see Gerbil users coming from Common Lisp list a few projects (including implementation and runtime constraints) that they used Gerbil for. Maybe that will illustrate exactly where they find Gerbil to be better. I haven't used Gerbil and for me Common Lisp pretty much means SBCL which doesn't do shared libraries so there are projects that I could use Gerbil for.
&gt; It comes between B and D Making sure you both still remember the safeword?
&gt;I haven't used Gerbil and for me Common Lisp pretty much means SBCL (not at all interested in any other CL implementation) which doesn't do shared libraries Yes, but this is your choice, since most likely whatever you're doing with SBCL will compile just fine with ECL which is a free, mature implementation that can compile to shared libraries. No need to get fixated on SBCL -- i switch the same project between SBCL and CCL pretty often, for example. It's 2019 and thanks to portability libs being used everywhere, switching to a different implementation is often a piece of cake. 
In theory I could switch to ECL, in practice it turns out to be 100 times slower than SBCL thus unusable. I've also found it to be not as reliable. I was making sure all my CL code works under CCL for many years. But with gbyers going away, SBCL consistently generating more performant code, SBCL working on Windows and ARM64, SBCL having super convenient built-in extra libraries that CCL doesn't, I decided to stick with SBCL. As an example, here is something I posted today on a different thread where ECL and CCL are not competitive with SBCL, performance-wise: https://gist.github.com/atomontage/262e6ac3c5bf982b3f1110cdfbe79b15
Having been a professional CL developer for the last 15 years, I find that those lisp image creations are great if you prefer a lisp image, and I've have used all of those implementations to create binaries. So, given that I prefer Gambit + Gerbil for non-language purposes, I am not going to lie and state where I think it may fare better for you, for that is not my choice. ... and actually, have never used MKCL or Corman CL for longer than trying it out. If you want Common Lisp, then use it! It's a great language with a tonne of implementations, and ASDF is still being actively worked on, with Quicklisp being a wonderful library system. If one of those implementations produces the binaries you prefer, and CFFI (or the implementations equalp) is a good way to interact with external .so and the like, I am not saying that Gerbil is better at creating binaries than all of those implementations of CL. I am saying that I prefer it. Nowhere did I say it was inferior or superior to every Lisp implementation, but he was asking about CL. At least we do not have to break the standard for PROG2 :) 
Thanks for this reply, drew.
One extended version of this problem I currently have is this: Imagine you are writing a function `map-array` that can map over multidimensional arrays. Now imagine how to make it return an specialized array automatically. For example, ``` (defun fn (bv) (declare (type (array bit) bv)) (map-array #'1+ bv)) ``` Ideally the compiler should know that the result array should be an array with an upgraded-element-type of `(integer 1 2)`, which is `(unsigned-byte 2)` on sbcl. To implement this behavior as a user-supplied compiler-macro of `map-array`we need to have access to the type inferer, say `(infer-type function arg-types &amp;optional env)`, that returns the return-type of applying arguments of `arg-types` to `function`. In this case ideally we should get `(infer-type #'1+ '(bit) env) -&gt; (integer 1 2)`, and then call `(make-array ... :element-type '(integer 1 2)...)` in the compiler-macro expansion to return a compact array.
If you can live with a layer on top of native declarations, you could build on this sketch: (progn (defun get-decls (env) (multiple-value-bind (r p) (macroexpand '#1=#:handle env) (and p r))) (defmacro with-decls (&amp;environment env (&amp;rest decls) &amp;body forms) `(locally (declare ,@decls) (symbol-macrolet ((#1# ,(append decls (get-decls env)))) ,@forms)))) Example use: (defmacro tell-decls (&amp;environment env) `(quote ,(get-decls env))) (with-decls ((type (integer 0 1) x)) (with-decls ((type string y)) (tell-decls))) ;; =&gt; ((type string y) (type (integer 0 1) x)) 
This is a fantastic talk! Thanks for sharing it!
Uhm, how I view it? Is it behind a paywall(monetary or subscriber-based)?
That's strange. Just clicking on the link worked for me.
I am using a third party Reddit client, will try in official or in browser.
&gt;&gt; Does it support live re-compilation like CL? &gt; A lot better than CL does... we actually compile! We are built on a compiler, and there are certain pieces that require compilation down to machine code. You either (1) mean something sensible but phrased it horribly wrong so that it is impossible to guess what you meant or, (2) are completely ignorant about Common Lisp implementations (I think more of them have a compiler than not,and there are even several that only compile to machine code and have no interpreter). Which one is it? And if it is (1), what on Earth did you mean?
Thumbs up for this one (well done!). However, I think /u/guicho271828 meant getting the type that was inferred at compile time. This would work only on implementations with type inference, like SBCL and CMUCL. 
&gt; In theory I could switch to ECL, in practice it turns out to be orders of magnitude slower than SBCL for most of the problems I'm trying to solve, thus unusable. I've also found it to be not as reliable. Oh see, yes, it appears to be slower. &gt;I was making sure all my CL code works under CCL for many years. But with gbyers going away, SBCL consistently generating more performant code, SBCL working nicely on Windows and ARM64, SBCL having super convenient built-in extra libraries that CCL doesn't, I decided to stick with SBCL. Last year I delivered a solution that included a small Lisp program for ETL purposes. It included its own benchmarks, and I recall that CCL was at about 70% the speed I got with SBCL at that time, so it was OK for me. I really like how fast is CCL at compiling. It is blazing fast compared to SBCL! This helps me whenever I want to try a new library (system), particularly when it needs to load and compile a lot of dependencies. I also feel CCL sometimes gives more detailed warnings or errors. 
CL is not implementations. It's a standard which does not require the items your implementations have, whatsoever. So, either (1) you glossed over the meaning of Common Lisp and started judging me based on implementations and not ANSI or CLtL2 or (2) you mean something sensible but your are stuck in trying to see something wrong and cannot see the forest for the trees? I have been a professional CL developer for 15 years. CL does not require compilation to machine code whatsoever. The compiler can be outputting sexps which are interpreted. It could output C code, or ECMAScript code... ... or gerbil. A CL implementation could output gerbil code. So, to conclude, I mean "we are built on a compiler, and there are certain pieces that require compilation down to machine code" and "prog2 evaluates first-form, then second-form, and then forms, yielding as its only value the primary value yielded by first-form". 
Mine is "Englebert Humperdink". If you ever come by, bring a cat o' nine. 
The link that OP posted was to the WebM version of the talk (which is around 678M according to the directory listing) which your 3rd party reddit client/embedded browser may not be able to view.[This](http://mirror.linux.org.au/pub/linux.conf.au/2019/a1/Thursday/Lets_LISP_like_its_1959.mp4) is a link to the MP4 version of the talk (which is apparently only 357M or about half the size of the WebM). I don’t know if the WebM is higher quality than the MP4 and I’m not sure if that’s why OP linked it or if they just prefer more open standards.
This may be the best talk on programming and open source and lisp, combined and apart, that I have seen. 
Sorry man, all I have is Cat 5.
Well, just so you know, I did download gerbil scheme.
Thanks! I think I'm closer to guessing what you meant: was it either of these: (1) Gerbil Scheme is define by a standard, the standard defines "machine code" and "compile", and the standard requires a Gerbil Scheme implementation to have a compiler that produces machine code. or (2) Gerbil Scheme maybe doesn't have a standard, but it currently has an implementation. This implementation has a compiler that produces machine language, and you can count on this implementation to always compile certain types of things down to machine code, now and in the future. or am I still confused about what you meant?
SBCL runs on Windows and SBCL runs on ARM64. That wasn't always the case. So for my needs, SBCL is more complete than CCL (which runs on Windows but doesn't run on ARM64).
A CL implementation could output anything, but SBCL outputs (performant) machine code. In the same way that a Scheme implementation could output anything but Gerbil chooses to do one particular thing. I guess your answer is accurate and to-the-point if you choose not to narrow "CL" down to a specific implementation. But if you do, the same questions remain.
Here’s the YouTube link for those interested : https://youtu.be/hGY3uBHVVr4
Make it (defun event-loop (socket) (with-open-stream (stream (stream-connection socket)) (loop (write-line (read-line stream)) (write-sequence *response* stream) (finish-output stream))))
&gt; Surely there should be points where GS fares better than CL, but this one?! It Fare-s better, evidently. 
Fare's post isn't about anything "distasteful" for interacting with systems, though. The points are: (1) Fare has great rapport with the author; (2) the "module system, the actor system, the object system, the libraries" are in "good taste"; (3) the code is "consistent and with a coherent sense of aesthetics, being implemented by one man" and (4) decent efficiency from GVM, together with something called "observability": being able to stop the program at any time and inspect its state with regard to the source code or something like that.
In the mid-80s I worked for ExperTelligence. They sold a Lisp for the Mac. I wrote demo programs and user manuals and did demos at user groups around the country. I was very into Lisp back then. Even attended IJCAI-85 in Los Angeles. Then I got sidetracked for 30 years with cybersecurity :-) Now I’m doing a little work with Python and NLP. Thanks for pointing out r/GOFAI! Subscribed.
Cool! /r/GOFAI has been around for a while, but it seems the old moderator made it impossible for anyone to submit anything, and deleted their account.
Yes.
That's quite true. I am really just a lone hacker that likes things to work well without to much know-how. I was not searching for a new system, but I have a distaste for racket, and it briefly mentions gerbil. So, while it was Fare's post that directed me toward gerbil, it was not the same reasoning that he laid out that attracts me to it. 
Gerbil does not have a standard. I suppose my jest was not taken so. In order to clear things up: 1) Gerbil is a scheme compiler and interpreter that uses another scheme compiler, Gambit, to compile beyond code. 2) Gambit can compile to a lot of things, including machine code, and Javascript. 3) Gerbil is not a standard, but is based on, and can use, all the scheme standards. You can specify if you want to act as a certain language. This is not limited to sexps. 4) Gerbil has a massive library built in that grows daily, and has a package management system that uses git repositories. It is indeed comparable to many implementations, of both CL, scheme, and other languages that have both an interpreter, compiler, runtime odds and ends, etc. The package management system is similar to QL, or pip, or what have you. If you desire a standard, gerbil is not going to be the type of language you want to work with. However, it is, in and of itself, fairly stable as far as syntax, built-in library modules, and the like. &amp;#x200B;
Oh cool! Gambit is one of my favorite schemes. Gambit plus extra libraries and a package manager sounds great. I'll be sure to check it out. (I have to say I feel this last comment of yours is much better marketing than "A lot better than CL does... we actually compile!", which confused me quite a bit. :)
There are still tons of researcher doing symbolic AIs. Look at all the papers that appear in AAAI that are not Machine Learning, they are still dominant. I am specialized in classical planning and running research in a industry lab. Personally I don't like the name GOFAI. It is a passive-aggressive insult to the community from the "mass" and the investors. Good Old Fashioned implies it "felt good but is not actually good". FYI, check out the SAT revolution (the modern solvers can now solve SAT instances with millions of variables ) and the Planning renaissanse after 2000. Evolving kinds of BDD/ZDDs. Much more computational theories are available now compared to the 80s. Also in the KR area, although I am not so familiar with it.
Completely agree, anyone interested in AI should check out modern SAT solvers eg Clingo I wish more were written in Lisp...
I don't think they have to be written in Lisp. The most usages of SAT solver are as a NP oracle, so it suffices if we have a nice wrapper. Thats why I wrote CL-SAT as a solver-agnostic API. Oh, by the way, from thia month's Quicklisp update CL-SAT can automatically download, build and invoke most of the SAT competition 2016-2018 solvers. https://github.com/guicho271828/cl-sat
Windows 10 supports arm and has a 32 bit X86 emulator so you can run normal Win32 stuff as well Currently it's just on a few Qualcomm laptops though officially though some people have gotten it working on the Lumia 950 and a raspberry pi https://github.com/WOA-project/WoA-Installer
AI in the broadest sense but probably best described as cognitive science, [ACT-R](http://act-r.psy.cmu.edu/) is a 'cognitive architecture' (a theory of the core components of the human mind and how they interact) which researchers (including me) use to develop models of human cognition and human-like artificial agents. It's been under development for decades and is still written in Lisp. Another notable cognitive system under active development and written in Lisp (Allegro Common Lisp to be precise) is [CogSketch](http://www.qrg.northwestern.edu/software/cogsketch/index.html).
What an amazingly detailed comparison, thanks for writing this! (I wish there was a way to make this more generally “discoverable” by others who’re curious about this)
Just wanted to say this is a fantastic article. As a novice, I've always wondered this. And definitely got my interest up on Racket and Scribble.
You could do the same thing with USOCKET, and then your code would be portable.
Yeah, I wanted to try and plug into some lower level socket stuff first! Thanks for the tip :)
Ah great! This worked. Thanks. 
The sb-bsd-sockets API is kinda portablish, ECL and CLASP use it.
Veeery old. In case you need more, see [The Art of the Metaobject Protocol](https://www.amazon.com/Art-Metaobject-Protocol-Gregor-Kiczales/dp/0262610744). There is even a Wikipedia entry: [https://en.wikipedia.org/wiki/The\_Art\_of\_the\_Metaobject\_Protocol](https://en.wikipedia.org/wiki/The_Art_of_the_Metaobject_Protocol) with download links of parts of the book.
**The Art of the Metaobject Protocol** The Art of the Metaobject Protocol (AMOP) is a 1991 book by Gregor Kiczales, Jim des Rivieres, and Daniel G. Bobrow (all three working for Xerox PARC) on the subject of metaobject protocol. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
No, that's not how sockets (or any kernel interfaces) work.
Great thanks for the help 🙄
You read multiple times until there's no more data.
AMOP is 1991, this is newer actually: AMOP is one of the referenced publications. 
Sure. I just wondered why a paper from 1993 suddenly pops up in reddit; is there a special occasion or did the poster just discover it now by coincidence? If the latter then he/she might like AMPO too ;-)
The typical convention is as follows: 1. Sender sends size of the payload first, say as an int, so receiver knows how much data is expected. 2. Receiver receives/reads an int. 3. Receiver allocates an octet array according to the size of the payload or whatever data structure is needed for the situation. 4. Receiver reads, possibly multiple times, up to the size of the payload into the buffer; the OS may split the data depending on the kernel TCP window size, buffer size and other factors.
Thanks for this, do you know of any literature or code that shows this in action? I presume in http, the payload size is the Content-Length header? Thanks!
Implementations matter.
Why don't Prolog programmers just use Lisp? Lisp is just Prolog plus awesome extra stuff. I mean I program in Python at work lol but if I had a choice I would totally program Prolog all day and night
What stuff does Lisp have that Prolog doesn't?
Hard to argue with this, it's basically why I'm using Python at work 
When it comes to just Common Lisp: object system, metaobject protocol, imperative operators, a lot of FFI bindings, arrays, multiple usable programming paradigms. These are the ones I can name off the top of my head.
This has to be a troll
I never grocked prolog, but saw rule based systems - PAIP, prolog in lisp, adding failure, difficulty of a true NOT.
Nope, I'm going into this loving Prolog bit seeing Lisp has a dedicated community and I want to know what people love about Lisp that Prolog doesn't have. 
They're not even remotely the same!
Lisp is more practical for most applications because it's not a logic programming language. The two languages are almost completely different
That's the kinda like asking why anyone uses Python when Haskell can do all the same stuff and more. I am not sure how well you know Prolog and Lisp but given how different these two languages are and the different goals they were designed for, it is difficult to take your question with a straight face. You certainly can implement Prolog in Lisp (and it has been done) and probably could implement a Lisp in Prolog too but that doesn't mean that one is some sort of superset of the other. 
I think this is not a April 1st. Or is it?
Prolog proponents will disagree (since logic programming is Turing complete and all that) but Prolog is a just a domain specific language (DSL) for logic programming. In Common Lisp, you can use a logic programming DSL as a library. Thanks to Lisp macros, the DSL can provide decent syntactic sugar for expressing the facts and rules and all that. There are a few logic programming systems for Lisp. As a stand-alone language, Prolog is basically a mistake. You're stuck in a single paradigm, and must externally interface to other tools if you want anything else, like ordinary imperative programming, OOP, functional, and so on. Prolog is one of numerous historic example of people wanting to do some aspect of Lisp stuff and putting it into production use with fewer resources. "Let's throw out all of Lisp, and then just hack up a language run-time and syntax for only a logic programming system that we can sell to customers on cheap hardware". Another example of this is [CLIPS](http://www.clipsrules.net/), an expert system so closely based on Lisp work that it uses S-expression syntax, yet isn't Lisp. In 2019, you can have all of Lisp with tons of memory left over, so the user can fill it with other applications and Firefox memory leaks.
Symbols, lists, cons, homoiconicity! Even PAIP Part I is "ok let's use LISP for cool AI stuff" and the part II is "OK let's use LISP to build a Prolog interpreter to do the rest of our cool AI stuff" and I'm sitting here like "OK I get why building stuff from the ground up is interesting for pedagogical purposes but in practice why not just start with the Prolog interpreter already built in?'
Alright, I see where you're coming from! Basically: Lisp has waay more than that stuff and isn't built upon unification like Prolog is. Lisp is a multi-paradigm language, as compared to Prolog. I think you'd find Common Lisp has more in common with Python than Prolog (while being vastly better than Python).
Because it's easier to embed Prolog in a Lisp than the other way around. Prolog is extremely limited in its abilities. It doesn't have macros. It can't generate code. There are no DSLs, and no continuations. Lisp does have all of this stuff. Try writing a window manager in Prolog. Or an operating system. Or a browser. Or an editor. It's going to be slow, inefficient and a huge mess.
The kernel maintains its own buffer for the socket. When you read from userland you are really reading from a kernel buffer. If you don't drain the kernel buffer in one read, you can keep reading until you do. You have a number of ways to manager your userland buffer, some examples: + You can allocate a fixed size buffer and dynamically grow it after every read (performance hit but in many cases it doesn't matter). + You can allocate a static buffer do multiple reads to it, advancing the index after every read (by the amount of octets you read). By static buffer I mean a buffer big enough so that it won't require dynamic allocation. In many cases you can know ahead of time what the length should be. If you don't, you can guess. You can fall back to dynamically growing the buffer if you are about to exceed its length. + You can dynamically allocate a buffer for every read you do. Each buffer ends up in a queue and after all your reads are done, you concatenate them to a new, final buffer (or not). 
TCP/IP illustrated by W. Richard Stevens is considered [rightly] the bible. Stick with the 2nd editions.
Well they would be Prolog programmers if they did this, would they not?
Why do we have to keep re-sampling a new value of `u2` until `u1` satisfies the epsilon criterion? Is there some suspicion of a dependence? The `twopi` variable can be a global *defconstant*. Or, completely opposite, it can be pulled into the loop: (do ((two-pi (* 2 pi)) ;; no step form, obviously! (...) ...) ..) Co-locating it with the captured state variables `z1`, `z1` and `generated` is a bit misleading. I think the `progn` is not necessary: after the *test-form* in do, there can be zero or more forms which are an "implicit `progn`".
It computes a pair. The C++ version seems to return x, then y, then a new x, then a new y, ... &amp;#x200B; Why not just return the two values directly? &amp;#x200B; &gt;(defun box-muller (mu sigma &amp;aux (two-pi (\* 2 pi)) u1 u2 z0 z1) &gt; &gt; "Returns two random numbers" &gt; &gt; (loop do (setf u1 (random 1.0d0) u2 (random 1.0d0)) &gt; &gt;while (&lt;= u1 double-float-epsilon)) &gt; &gt; (setf z1 (\* (sqrt (\* -2.0d0 (log u1))) (sin (\* two-pi u2))) &gt; &gt;z0 (\* (sqrt (\* -2.0d0 (log u1))) (cos (\* two-pi u2)))) &gt; &gt; (values (+ (\* z0 sigma) mu) &gt; &gt;(+ (\* z1 sigma) mu))) &amp;#x200B;
I thought this was /r/programmingcirclejerk at first
Actually Prolog does have all that stuff, which is why I'm asking since Prolog is basically a superset of Lisp
So... how would you implement macros in Prolog?
https://www.metalevel.at/prolog/macros 
No special occasion; i just happened to encounter it recently, whilst looking for introductions to the CL MOP that *aren't* AMOP, to point people to. Although the Wikipedia page for AMOP you mentioned does provide links to chapters of the book, i feel those chapters aren't suitable for people wanting a overview that goes beyond what Wikipedia covers; so i thought that maybe the posted document might fill the gap between Wikipedia and AMOP. :-)
&gt; Why not just return the two values directly? That would be a different algorithm, basically. Calculating two values in a single operation, one of which is saved for the next call is what Box-Muller *is*.
The box/muller paper talks about pairs of numbers.
That's interesting. But - again - it isn't the same. 
Nice. With your changes it's down to: (defun bm-generator (mu sigma) "Returns a generator function." (let ((z1 nil)) (lambda () (or (prog1 z1 (setq z1 nil)) (progn (do ((two-pi (* 2 pi)) (u1 (random 1.0d0) (random 1.0d0)) (u2 (random 1.0d0) (random 1.0d0))) ((&gt; u1 double-float-epsilon) (let* ((r (sqrt (* -2.0d0 (log u1)))) (w1 (+ mu (* sigma r (sin (* two-pi u2))))) (z2 (+ mu (* sigma r (cos (* two-pi u2)))))) (setq z1 w1) z2)))))))) which does seem a fair bit cleaner. &amp;#x200B;
Yep, you can do that. I didn't particularly want to in this case.
Then see my other comment how to make the generator out of a two-value function.
Yeah, that's perfect — logic and generation abstraction are decoupled, can re-use the generator code, can test separately, etc.
What about reader macros?
One can also use `(shiftf z1 nil)` to set Z1 to NIL and return its previous value.
Why don't you find a book about C that has a chapter on building a Prolog interpreter, and then go troll the C subreddit.
For my own understanding I'm going off reader macro as defined [here](http://dorophone.blogspot.com/2008/03/common-lisp-reader-macros-simple.html): \&gt;The [CLHS](http://www.lispworks.com/documentation/HyperSpec/Front/Contents.htm) defines, with characteristic obliqueness, a Reader Macro thusly: reader macro n. &gt;1. a textual notation introduced by dispatch on one or two characters that defines special-purpose syntax for use by the Lisp reader, and that is implemented by a reader macro function. See Section 2.2 (Reader Algorithm). &gt;2. the character or characters that introduce a reader macro\[1\]; that is, a macro character or the conceptual pairing of a dispatching macro character and the character that follows it. (A reader macro is not a kind of macro.) In which case yes it just sounds like it's about defining operators? http://cs.union.edu/~striegnk/learn-prolog-now/html/node84.html
I read this paper some months ago, Robert Strandh gave me the URL for it on the #lisp channel. This was an eye-opener to me -- this paper, in my personal opinion, indirectly shows how far behind we are (regarding the state of the art) when we're using current mainstream operating systems, particularly Unix. &amp;#x200B; Highly recommended!
Reader macros allow much more than defining operators. Effectively, they are a way to define arbitary syntaxes, so that you can include into your Lisp code pieces which are syntactically not part of the standard language. E. g., you can define a Prolog parser and include pieces of Prolog code into your Lisp source: (defun assert-clauses (prolog-env clauses) "Add CLAUSES to the database of PROLOG-ENV." …) (defun query (prolog-env query) "Query the database in PROLOG-ENV and return T or NIL." …) (defun parse-prolog-query (stream dispatch-char infix-arg) "Parse a Prolog query expression from STREAM." …) (defun parse-prolog-clauses (stream dispatch-char infix-arg) "Parse Prolog clauses from STREAM until the closing #\}." …) (set-dispatch-macro-character #\# #\? #'parse-prolog-query) (set-dispatch-macro-character #\# #\{ #'parse-prolog-clauses) (assert-clauses *prolog-env* #{ contains(V, []) :- false. contains(V, [V|_]) :- true. contains(V, [_|T]) :- contains(V, T). }) (query *prolog-env* #?contains(bar, [foo, bar, baz]) ) 
Junk that I use: https://plaster.tymoon.eu/view/1162#1162
Yeah lisp isn't too well documented compared to most of the C languages too, also it's like a totally different way of thinking. That's also what makes it fun though.
Try writing a big system in Prolog. I did. It was a pain. It was part of a billing system for a telephone company. I ended up just translating/implementing the resolver into [another stupid old language] and then I could still have a flexible rule based system *and* decent UI and file I/O code. I wish I could have done it in Lisp. I really like Prolog. I wrote a Prolog in C at a young age. It turns out when you do Prolog in Lisp, the syntax is more flexible, plus you can drop in to imperitive/functional/oo (almost) anywhere you want, although it's more likely most of your code in a big system will be something else and just use Prolog-ish stuff for a part. I did support for a Prolog vendor long ago, and most of their customers used Prolog as a piece inside something larger. But I also got over the idea that I would write an AI in Prolog that would answer my every question and do my homework.
Yes, Prolog can also do that. That's because the core of Prolog is unification, you can define new symbols to create a new syntax and it will still work if it unifies in some other place.
Prolog is actually pretty good at what it does and pretty interesting to work with. However, it indeed is "just" a DSL: logic programming is what it's best at, and it's also the only thing it does well. 
It's true Prolog has been optimized a lot, with research work like the WAM (Warren Abstract Machine). Not all the Prolog-like systems (in Lisp and not) have all the optimization of a "real" Prolog.
Could you please show an example of how to include pieces of alien code in a Prolog source? I'm genuinely curious.
There is also I think a related paper from Howard Shrobe of MIT which describes operating system of Lisp Machines.
&gt; object system LogTalk &gt; metaobject protocol No probably not. &gt; imperative operators setarg/3? But often you get away with caches over a more pure approach &gt;a lot of FFI bindings If you were arguing for languages based on popularity you'd pick Java. &gt;arrays arg/3 and setarg/3 &gt;multiple usable programming paradigms Just write a macro. I'm seriously surprised at how ignorant /r/lisp is.
Here's an example from my university notes: :op(40, xfy, &amp;). :op(50, xfy, ---&gt;). true ---&gt; valor(w1, 1). true ---&gt; conectado(w2, w1). true ---&gt; conectado(w3, w2). conectado(W,V) &amp; valor(V,X) ---&gt; valor(W,X). solve(true):-!. solve((A &amp; B)) :-!, solve(A), solve(B). solve(A) :- (B ---&gt; A), solve(B). solve(A) :- clause(A,B), solve(B). With op you declare new operators, with its precedence rules and so on, then the solve part is the metainterpreter, which recognizes the new syntax and gives it a syntactic meaning. This metainterpreter is not complete though, it will fail in arithmethic predicates for example, but completing it is not very complicated but requires many more lines.
Wow! I completely wasn't aware of LogTalk and arg/setarg. I think this needs to be boosted higher.
&gt;To communicate complex data structures (such as trees or graphs), they must be converted to a stream of bytes by the creating component, and it must be analyzed and parsed into an equivalent data structure by the using component. No. enum { MAX_SIZE = 4096 }; static char buf[MAX_SIZE]; static unsigned long input_size; static void read_in(int in) { ssize_t bytes; if ((bytes = read(in, buf, MAX_SIZE )) &lt; 0) { perror("read"); _Exit(1); } input_size = bytes; } static int get_int(unsigned ptr) { int x; memcpy(&amp;x, buf + (ptr % (MAX_SIZE - sizeof x)), sizeof x); return x; } &gt;• An artificial order between the different components is imposed, so that components can not work as libraries that other components can use in any order. The author doesn't know what a named pipe is? &gt;Current computers have two kinds of memory, a primary memory which is fast, volatile, and expensive, and secondary memory which is slow, permanent, and cheap. In contrast, the Lisp operating system would present a single abstraction of the memory, which looks like any interactive Lisp system, except that data is permanent. Just mmap a file? &gt;Instead of each application having its own address space, we propose that all applications share a single large address space. This way, applications can share data simply by passing pointers around, because a pointer is globally valid, unlike pointers in current operating systems. This is a terrible idea. Shared heaps make it fundamentally difficult to scale garbage collection and confuse per user accounting of resources. A separate heap approach such ass Erlang uses is far cleaner.
That's still Prolog(ish) syntax though, just with additional operators. I was hoping for something more heterogenous, involving modifications of reader behaviour. Like inclusions of code in another programming language, or XML templates, or, I dunno, a heredoc.
I don't understand the first example. What is it meant to show? How does it solve the issue of passing a complex data structure between programs without serializing it and passing it via a file/network/pipe?
ok, i think this author is screwing around some. "1.2.2 Hierarchical File systems" "There are two significant problems, namely hierarchical and file..." "Whether a document is called Lisp/Programs/2013/stuff, Programs/Lisp/2013/stuff, or something else like 2013/Programs/Lisp/stuff, is usually not important." that was all he had to say about the "problems" of a hierarchy! even if you were to tag all files in a flat namespace with attributes the set of attributes per file would still be a tuple (order matters -- that's why you can't re-arrange path components willy nilly). 
&gt; (order matters -- that's why you can't re-arrange path components willy nilly) The original intention was that you don't care if you are looking for Lisp programs done in 2013 or files done in 2013 that are programs written in Lisp. Hence `2013, Lisp, program` is equivalent to `program, 2013, Lisp` and all of its permutations.
I'd love to see some of the things described there (the permissions system, the file system, etc), tried in [Mezzano](https://github.com/froggey/Mezzano).
&gt;No. &gt; &gt;enum { MAX\_SIZE = 4096 }; &gt; &gt;\[...\] Hang on. Isn't getting away from C, and especially direct manipulation of pointers, one of the primary points of the entire exercise here? &amp;#x200B; &gt;The author doesn't know what a named pipe is? IIRC the paper explicitly discusses named pipes at one point. &amp;#x200B; &gt;Current computers have two kinds of memory, a primary memory which is fast, volatile, and expensive, and secondary memory which is slow, permanent, and cheap. In contrast, the Lisp operating system would present a single abstraction of the memory, which looks like any interactive Lisp system, except that data is permanent. &gt; &gt;Just mmap a file? This \*entirely\* misses the point of the discussion, which is that the artificial distinction between fast-but-volatile memory (RAM) and slow-but-nonvolatile-memory-accessed-by-transferring-through-I/O (disk) is already going away and will in a few years be as obsolete as paper tape. So we should start preparing for this now, rather than retrofitting legacy OSes for this massive architectural improvement. &amp;#x200B;
I didn't know that was still active. A comparable project is ChrysaLisp: [https://github.com/vygr/ChrysaLisp](https://github.com/vygr/ChrysaLisp) &amp;#x200B; &amp;#x200B;
This is a troll so I will give a troll-y albeit honest response: I don't use Prolog because I find miniKanren to be better in every way, to the point that I would consider Prolog effectively deprecated and a waste of time.
You don't neeed t and you probably shouldn't represent a graph with pointers but should probably use offsets within a block of memory. Then serialization concerns mostly disappear.
Think of something you want to do. Use a programming system to work on it. Break it down into smaller pieces and work on each piece in turn. If you get stuck on a piece, ask for help. If you can't get help and don't make progress, try a different system.
It's hard to regroup when things are spread and diluted, at least I suffered from that a lot. I think it's mostly psychological. Gather your motivation, go deep into a specific subject, no matter what it is or what language you use to build it. As xach said finding a project is good idea. Keep it playful, keep it exciting, don't worry and keep finding for interesting new knowledge. It will come :)
Here's an example from olden times. I had a bunch of CDs and a handful of computers with cdrom drives. I wanted to use all my computers to rip the cds to mp3 instead of just one at a time. I worked on a lisp program to run on each computer, rip the cds to mp3s in a shared filesystem, and communicate results back to a central coordinating program that would put the raw files into a directory structure for me. This involved running subprograms (like eject, cdparanoia, and stuff), communicating messages over the network, parsing and serializing, dealing with timeouts and errors, and stuff like that. I used Lisp and it was a lot of fun and I learned a lot about how things worked. And when I was done I had something useful.
&gt; The author doesn't know what a named pipe is? Yeah man, how wonderful is the human mind, that the author (Robert Strandh), even not knowing what a named pipe is, somehow managed to create the current state-of-the-art in Lisp compilers, [CLEAVIR](http://metamodular.com/cleavir.pdf). I've heard he's illiterate too. 
\&gt; but it really feels like stuff is barely explained properly if I want to do anything over that. Racket and Clojure seems to have more juice in that regard \`define\` "juice", please. But yeah, Practical Common Lisp is IMO directed to programmers with previous experience in other languages. That's why I liked it so much -- it was a quick read. &amp;#x200B; \&gt; Problem is, my programming skills, either knowing a specific language or knowing functional/objective/algorithmical concepts, are a jumbled mess To be honest, Common Lisp isn't easy to learn without solid functional/objective/algorithmical concepts, and I can't realize how Racket or Clojure would be easier to learn in that context. Still, in some parts they will be easier to learn than CL because of more uniformity on the language. (That being said, my heart stays with Common Lisp.) I'd stray away from this subreddit and suggest you start with Python first, which has a very gentle learning curve. At the end, "programming" is not about knowing a specific programming language. &amp;#x200B;
This requires that a graph fully fits inside a block of memory. If your objects are loosely scattered across the heap, then you must copy them and arrange them in a block of continuous memory, which is yet another, more blunt form of serialization - putting them in a series.
Under juice I mean that they actually have up to date/new tutorials/documentation and are constantly evolving, language with the compiler/framework. The newest Common Lisp ANSI is well over 10 years old by now. Like quicklisp is still a "beta" package manager and SBCL could not be bothered to implement it. There is hyperspec as a main documentation, what can only reliably tell what is in the ANSI.
&gt; Like quicklisp is still a "beta" package manager and SBCL could not be bothered to implement it. What?
I dont say they ever planned it, I just say that why should it be separate? I think it is a good practice to make non-core libraries easily available. Every never language has a compiler with lots of crucial stuff included.
&gt;Under juice I mean that they actually have up to date/new tutorials/documentation and are constantly evolving We are evolving, see Common Lisp Cookbook for an example of constantly evolving documentation. &gt;The newest Common Lisp ANSI is well over 10 years old by now. Yes, but, contrary to Java, C, C++, C#, Javascript, Python, Go, and `&lt;name your fancy language here&gt;`, Common Lisp **can be extended by the user**, thus we don't need to wait for a new standard to implement whatever features we need. This, largely thanks to lisp macros. Unlike Java, where you need to wait for the new Java spec and the new compiler(s) Unlike Python, where you need to wait for the new features and the new CPython implementation Unlike Go, where you need to wait for the new features and the Go compiler... and you're stuck since they are +10 years without introducing exception management or generics. *etc.* &gt;Like quicklisp is still a "beta" package manager and SBCL could not be bothered to implement it. Package managers should have nothing to do with implementations or the standard. Quicklisp is just another Lisp program, you don't need to "implement" quicklisp inside SBCL/etc. You can write your own package manager too and use it instead of quicklisp, if you want. &gt;There is hyperspec as a main documentation, what can only reliably tell what is in the ANSI. There's also the CLTL2 and CLTL1 books online, which also cover the language. There's also the "free" version of the ANSI spec. There are also tons of books. In practice this isn't a problem at all. 
What do you mean by programming system? Sorry if this is a dumb question. ( current comp sci student )
&gt;I dont say they ever planned it, I just say that why should it be separate? WHY should a package manager be integrated into the standard? This makes no sense. It has nothing to do with the programming language!! The standard has the spec about packages (called "namespaces" in other languages), this is enough for anyone to layer any package manager or build tool on top. &gt;I think it is a good practice to make non-core libraries easily available. `(ql:quickload "library")` See? One line of code. QL makes non-core libraries easily available. 
&gt; they actually have up to date/new tutorials/documentation and are constantly evolving, language with the compiler/framework A stable language is a godsend (yet libraries can evolve and add syntax sugar if you want), the "beta" disclaimer is just a disclaimer. Stability is cherished in Lisp land. for the documentation… there are efforts. See https://lispcookbook.github.io/cl-cookbook/ and https://github.com/CodyReichert/awesome-cl#learning-and-tutorials Also, grab other books. 
Just as a FYI, note this post: [https://dev.classmethod.jp/cloud/aws/lambda-custom-runtime-common-lisp/](https://dev.classmethod.jp/cloud/aws/lambda-custom-runtime-common-lisp/) or [translated](https://translate.google.com/translate?sl=ja&amp;tl=en&amp;u=https%3A%2F%2Fdev.classmethod.jp%2Fcloud%2Faws%2Flambda-custom-runtime-common-lisp%2F) Here they create a lambda runtime by using ECL and compiling down to executable. The executable just does a Hello, world. Source for the above example: https://github.com/cm-tt/ecl-lambda 
Read SICP (Structure and Interpretation of Computer Programs), it's a classic textbook about computer science from MIT Press. It starts very basic, but by the end of it you will know things Man was never meant to know. The book is freely available and I recommend this nicely typeset version: https://sicpebook.wordpress.com/ebook/ SICP uses Scheme, but both Scheme and Common Lisp are in the same family of languages, when you know one you can easily pick up the other. Read the book at your pace and do the exercises. Be diligent rather than fast, re-read earlier parts if you have to. A mandatory reading for getting into Common Lisp: http://stevelosh.com/blog/2018/08/a-road-to-common-lisp/ He gives actually good advice, i.e. don't bother with Emacs, Slime, Quicklisp, Roswell and all that stuff when you start out. You can still use them later of course, but start with baby steps. A terminal and a text editor is all you need to start out (having the editor auto-insert matching parentheses would be very handy to have though). &gt; I like common lisp as long as "Practical Common Lisp" goes, but it really feels like stuff is barely explained properly if I want to do anything over that. I'm going to make myself unpopular here, but Practical Common Lisp is really not a good book. It reads like a commentary on how he write his MP3 program rather than a textbook. And I did already have experience with programming Scheme in general.
Well, thanks, I did not know that there is a more up to date documentation on what is relevant today. Im sure these are not a "problem in practice". But I dont think that it is a bad thing to have a package manager, a syntax checker, autocompleter, project manager maybe even an entire tutorial (Rust) coming with the go-to compiler. I feel like these come together. They definitely do so in modern languages. If you want to do your own thing (package manager, documentation and so on), that is not a problem in practice. But they are a minority. The majority uses quicklisp, and the most relevant documentation/tutorial among other utilities. I know the language can be expanded. That does not mean that you dont want a common ground. Maybe being able to call something a "common lisp" implementation with less legacy code and with expansion on new concepts, such as easier thread handling (did not use it yet, but if Go and Rust brag about it being easy to write multi-threaded apps in them, then I think that Lisp might be lacking in that matter).
I did not say integrate into the standard, I said why shouldnt it come with the most popular of the compiler/s? Really. Most people use it. If you dont want to use it, you dont have to.
&gt; But I dont think that it is a bad thing to have a package manager, a syntax checker, autocompleter, project manager maybe even an entire tutorial (Rust) coming with the go-to compiler. The `compiler` is called compiler because it turns source code into something that can be executed. The things you mention (package manager, a syntax checker, autocompleter, project manager, tutorial) don't belong to a compiler. They can belong to a starter kit. In which case, perhaps you haven't seen [Portacle](https://portacle.github.io/). There you have a compiler, autocompleter, built-in quicklisp (package manager), and IDE. &gt;They definitely do so in modern languages. Your take on what a "modern language" means, is probably different to what I think a "modern language" is. For example, for me Golang isn't a "modern language" in any sense of the word, neither is Javascript. Haskell, Standard ML, Julia... those perhaps are modern languages. &gt;But they are a minority. The majority "Minority" and "majority" are almost meaningless in the Lisp world. This isn't a popularity contest. &gt;I know the language can be expanded. That does not mean that you dont want a common ground. We already have a common ground: - alexandria - bordeaux-threads - uffi - asdf - cffi - closer-mop - fset etc. &gt;Maybe being able to call something a "common lisp" implementation with less legacy code Implementation with less legacy code? How does the code *inside* an implementation affects you? &gt;and with expansion on new concepts, such as easier thread handling In Lisp you don't need a new standard and you don't need a new implementation for "easier thread handling. Again, this isn't Java, this isn't Javascript, this isn't C++, this isn't C#. You just download the library you want, because Lisp can be extended using Lisp. For example if you want software transactional memory (which gives you easier thread handling), yo don't pray that the language creators build this into the language in the next 5 years. You just do: `(ql:quickload "cl-stm")` ##TADA -- easier thread handling &gt;Go and Rust brag about it being easy to write multi-threaded apps in them, then I think that Lisp might be lacking in that matter *"That's just like, your opinion, man"*
&gt; but Practical Common Lisp is really not a good book Please elaborate, since I feel some urge to create a CL tutorial.
&gt; /var/task/bootstrap: /lib64/libc.so.6: version `GLIBC_2.28' not found (required by /var/task/bootstrap) Can you try SBCL built after https://github.com/sbcl/sbcl/commit/6a78c5d72f14e65e0dd5be48efc00375e1df966e ?
&gt; The compiler is called compiler because it turns source code into something that can be executed. Then call it framework, toolchain, starter kit. Developing software together, non-UNIX-like is not a bad thing as far as I am concerned. Common Lisp projects are acting separately, and yeah it works. Something like Rust language developers are a big phalanstery and it works out just as good, maybe more streamlined. I would be glad if some CL devs worked like that, but trying to criticize CL to make it change is not my point with this post. &gt; "Minority" and "majority" are almost meaningless in the Lisp world. This isn't a popularity contest. Its technically meaningless everywhere then. &gt; Implementation with less legacy code? How does the code inside an implementation affects you? Didn't each others code affect programmers before? If not, why would you want to create CL to collectivise Lisp derivatives? &gt; "That's just like, your opinion, man" What opinion? I said I did not really use multithreading, I just dont think its without a reason that they said that.
&gt;Something like Rust language developers are a big phalanstery and it works out just as good, maybe more streamlined. Rust is still in its infancy. Mozilla, the creator of Rust, hasn't even yet rewritten its star product (Firefox) on Rust. Call me back when Rust is used on a spaceship, for designing an aircraft, for rendering 3D Movie characters, for airline scheduling, or for managing huge graph databases. &gt;Didn't each others code affect programmers before? If not, why would you want to create CL to collectivise Lisp derivatives? I don't understand your question. Perhaps there is a language barrier here. &gt;I just see racket with everything together, nice and cozy. Good.
&gt; I did not say integrate into the standard, I said why shouldnt it come with the most popular of the compiler/s? Really. Steps to install quicklisp: 1. Download one file: quicklisp.lisp, from the QL website. 2. `(load "quicklisp")` 3. `(quicklisp-quickstart:install)` Is that so difficult? 
&gt; Because the ugly Common Lisp actually has worked for those critical applications. I dont think that it negates that Rust is doing pretty good for itself. I heard that Firefox has some rust code. Common Lisp has a good history. History. I would not go as far as trying to negate the values of Rust with that. &gt; I don't understand your question. Perhaps there is a language barrier here. Maybe I misunderstood.
I would still like if it came with a compiler.
Have you thought about trying [ABCL](https://common-lisp.net/project/armedbear/)? According to [this tutorial on lambda &amp; clojure](https://aws.amazon.com/blogs/compute/clojure/), &gt; AWS Lambda’s Java support also makes it easy to write Lambda functions in other jvm-based languages. Maybe a similar approach would work for ABCL? Note however that ABCL appears to lack the ability to generate standalone jars: https://abcl.org/trac/ticket/383
I suspected you were the person I needed to show up on this thread. Thanks, I'll try that soon!
Neat! Thanks for the info! Maybe I can look into enabling more implementations, too.
Hmmm. I don't know the jvm very well at all, so this might require a lot of up-front learning for me. Thanks for the suggestion, though! Well see if methods I know more about bear fruit.
see also https://github.com/snmsts/aws-lambda-test https://github.com/pokepay/aws-sdk-lisp https://github.com/y2q-actionman/cl-aws-custom-runtime-test
I sort-of mean programming language. But that doesn't feel like it encompasses all the things that go along with it. A programming language involves an implementation, and that usually includes an interpreter or compiler or both, a debugger, an inspector, a stepper, maybe an editor, documentation, libraries, discussion forums, conferences, etc. When you work with a language you work, to some degree, with all the parts of its surrounding pieces. I tend to think of that whole thing as a programming system. It's not as narrow as the specific syntax and features of a language.
you can still use a hierarchical filesystem and satisfy that need with an appropriate tool: find / -path '*program*' -path '*2013*' -path '*Lisp*'
Ohhh true you mean a tech stack. By the way you type beautifully and eloquently! If you ever wanna practice together feel free to PM me. I mainly like python and Linux. Thanks for the response!
A newer sbcl does work, but runs into issues in usocket complaining about the syscall poll(2) not being permitted. It seems like other people have traced this to a problem with Amazon's lamda environment not supporting ipv6. [Here's a blog post about it (translated from Japanese by Google)](https://translate.googleusercontent.com/translate_c?depth=1&amp;nv=1&amp;rurl=translate.google.com&amp;sl=auto&amp;sp=nmt4&amp;tl=en&amp;u=https://blog.3qe.us/entry/2019/02/06/013916&amp;xid=17259,15700023,15700186,15700190,15700248&amp;usg=ALkJrhg9TQoEiv6XA_7PS8uKrUCtQc4Fpg). At least things are running up to that point, so thanks for the suggestion.
Yes, it seems like a couple people have looked into it in Japanese. Sadly, I don't know much of the language, but katakana + code are getting me somewhere.
Actually, this feature was partially addressed in abcl-1.5.0 in the ability to create AIO ("all in one") jars. Better documentation is certainly needed, but for someone who knows what she is doing, there is no technical reason that ABCL applications can't be packaged as standalone jars. ABCL could certainly stand better tooling to help automate the build process. 
6pm UTC happens when this comment is 10 hours and 52 minutes old. You can find the live countdown here: https://countle.com/6ExboJdIU --- I'm a bot, if you want to send feedback, please comment below or send a PM.
I think you should build your runtime on amazonlinux environment. I used [this Dockerfile](https://github.com/y2q-actionman/cl-aws-custom-runtime-test/blob/fbdb491cb9f4aca42186a1e8324205017ebcf5ed/bootstrap/Dockerfile#L1) for building when I tried to use SBCL for AWS Lambda runtime. &amp;#x200B;
If it doesn't support ipv6, then why is it being used? Is localhost or some other name resolving to an ipv6 address?
I has been a while, but from what I remember, my main problem was that the book read like a source code commentary on an MP3 manager that happened to teach you just enough Common Lisp to be able to understand the code presented, rather than being a book about Common Lisp that uses pieces of an MP3 manager as a case study. I have the same problem with Land of Lisp or Realm of Racket, they all feel like books on a different topic that just happen to use Common Lisp. As I kept reading through PCL I was more confident in being able to create an MP3 manager in any language, rather than being able to create any program in Common Lisp. I have been writing a series of blog posts on how I wrote my MessagePack library for Racket and it has the same "problem". I put up quotation marks because my goal is specifically not to explain Racket, but rather MessagePack and I use Racket just as the language of implementation. The reader learns only the bare minimum of Racket to be able to follow along with the examples, but the focus is on MessagePack. (I hope to release part 2 some time today) http://hiphish.github.io/blog/2019/02/11/implementing-msgpack.rkt-pt1/
I have one for sale that comes with QL, and interacts perfectly with whatever compiler you are currently using. Give me a PM, I accept cash and credit. &amp;#x200B;
Thanks, i appreciate it.
I am not an experiences LISPer, but the key for me seems to be the name of the language itself "list processing". It would be a good idea to understand the nature of lists themselves, and how they map into the data structures and algorithms taught using the so-called "structured programming languages", like C, Pascal, Algol and Java etc
Neat! I'll have to try it later. Thanks for the blog post, too.
People are different
Call/CC is the wrong hammer to use. Catching the full continuation is often too much, and you might have to rely on dynamic scope as a workaround. Delimited continuations are the bee's knees. There is an old talk at MS research where Matthew Flatt of racket fame talks about using delimited continuations (and uses a continuation based web server as an example): https://www.microsoft.com/en-us/research/video/delimited-and-composable-continuations-in-plt-scheme/
Aw, that's nice. I donated. 
the guy's point at 30:12 regarding cdr is incorrect. something like (cdr (cons 1 2)) will return 2 and not (2) like the person suggests.
Thank you kindly and Happy Valentine's Day. The fundraiser is coming along steadily; we are closing in on 20$ of the way to our Matching goal. 
You can implement prolog with macros. So is rather pointless.
Macros.
Did this ever make it onto YouTube?
Has now. Thanks for waiting
Thank you! I wish I could get in for the streams but my high school doesn't get out til 2:30 EDT and then I don't get home til 5. I'm off next week so hopefully I'll be able to catch the stream. Hope to see you then. 
Fantastic, hope to see you then!
I think we all played with the idea of making our own opinionated scheme-like language. I have found lots of ideas that I have ported to my own (ever-growing) prelude in projects like this. The only thing is that i have started finding a lot of features that requires me to start implementing my own reader. The whole keywords/numbers-as-accessor-function is actually pretty neat, at least with literals. Janet seems nice and all that, but what cool stuff does it have that I don't have in guile? I looked through the docs but couldn't find much.
&gt; Janet seems nice and all that, but what cool stuff does it have that I don't have in guile? windows is a supported platform, for one
"Not a robot." /obligatory
Guile could possibly be built on Windows using Cygwin, and then deployed with [Cygnal](http://www.kylheku.com/cygnal/) and any additional required Cygwin libs as a Windows program. Someone would just have to try this and cob together an installer. I created this Cygnal thing for the sake of maintaining a TXR port to Windows. Cygnal is derived from Cygwin, which is LGPL-ed, which means you can use this as a run-time for proprietary apps, even. 
&gt; which is that the artificial distinction [...] is already going away and will in a few years be as obsolete as paper tape. While I agree that OP totally missed the point, I think you're being wildly optimistic here. I would bet people were saying the exact same thing in '85. If somebody doesn't go and _implement_ a flat abstraction, we could go another thirty years with a short-term/long-term memory distinction.
&gt; Just mmap a file? "I have an idea for a packet-switched network-spanning-network allowing computers to communicate with one another across arbitrary topologies..." "Lol, what's wrong with serial ports?"
Sure. And if you wanted, you could use a filesystem as a database by storing every row as a single-line CSV in files that increment numerically, and then use cut, grep, cat and sed for queries and joins. But that would be a messy, horrible, and inefficient hack, and you wouldn't want to build anything on top of it.
Cool idea. Looks nice, although I don't think I'd go out of my way to learn it (just yet) Also, there are too many girl names in the Industry. I'd like to see, say, a "Jared" language.
Jared from subway kind of ruined the usage of that name.
Correct. I forgot about Jared. Sorry, I was just throwing things out there jokingly, I didn't mean to cause some kind of disturbance.
personally dexador + plump + clss
What we need is Common Lisp bindings to headless Chrome ala puppeteer js. 
But you cannot scrapr JS pages with that
yeah cc are too much but this paper is old .. at the time it was a cool idea I guess. I wonder if Hacker News still rely on continuations.. thanks for the video
Honestly who would even try to scrape a dynamic content...
I’m mid 20s..na we’re good. Who would even do that is valid lol 
Just out of curiosity, could Cygnal allow a "Unix shared library" such as [WCL](http://pgc.com/commonlisp/) (with [RTGC](http://realtimegarbagecollector.com/)) to work as designed in Windows as it's claimed to for Linux in the excerpt below? &gt;Common Lisp implementations for Unix have traditionally provided a rich development environment at the expense of an inefficient delivery environment. The goal of WCL is to allow hundreds of Lisp applications to be realistically available at once, while allowing many of them to run concurrently. WCL accomplishes this by providing Common Lisp as a Unix shared library that can be linked with Lisp and C code to produce efficient applications. For example, the executable for a Lisp version of the canonical \`\`Hello World!'' program requires only 20k bytes. &gt; &gt;**Real Time Garbage Collector** WCL now works with [RTGC](http://realtimegarbagecollector.com/), a fully concurrent garbage collector. RTGC was tested by having WCL recompile itself. RTGC did 2069 concurrent garbage collects in the 16 seconds it took to recompile all of WCL. &amp;#x200B;
Did I miss the sarcasm? :) I scrape nothing but dynamic content
I don't know. Can someone quickly answer this question: does WCL work in the Cygwin environment as it does under Unixes? If it does, then there is a good chance that a Cygwin application requiring WCL could be deployed with Cygnal's `cygwin1.dll` substituted for the Cygwin one.
take the how to code courses (simple data and complex data) on edx. they are taught by grigor kiczales, of CLOS fame. they are basically an online course for the how to design programs book. then take dan grossman’s programming language course on coursera. it uses small, racket, and ruby. you write a small interpreter in racket. the books realm of racket and land of lisp are good to start with as well. i recommend going through the little schemer too. these things will be a much more structured and fun approach. the online courses i mentioned are excellent.
A Selenium binding ? https://github.com/TatriX/cl-selenium-webdriver/ (which would use an headless browser but which one ?)
I've wrestled with this one a while ago, but it does not seem to be up to date with all selenium features :( I've given up on this, and just use python when I feel like using Selenium
hey then you can open an issue I guess, it will let others know, the author know his project got interest, and he might… improve the lib.
Most websites are entirely dynamic anymore. Yes, they shouldn't be and it is bad practice but it is also industry standard. Ideally you could at least get the data without JavaScript but that is often not the case
&gt; but doesn't run (...) at runtime wat
Assuming by Clojure, you mean _more_. My own baby, Snigl (https://gitlab.com/sifoo/snigl), might be of interest. Be aware that there is some Forth in there as well, which looks weird even compared to Lisp on first encounter.
Picolisp
&gt;I'm looking for a lisp that has Clojure/Hy syntax Those are disjoint sets.
"in a runtime"? Admittedly, that's more nonsensical than before, maybe "some other VM" would be more logical.
Take a look at [Gerbil](https://cons.io/guide/intro.html#using-gerbil).
Then nothing to learn! Great, you've done it OP! /jk
ECL can be used as a shared library on its supported platforms including of course also Windows.
[removed]
Only if `/` denotes set intersection.
LOL I really did a poor choice of words, I mean that I wanted something compiled to machine code, not evaluated at runtime
I'm from a clojure background and started branching out to cl and scheme as the written material tends to be more extensive outside clojure. I picked up "The little schemer" which I like so far. I like the format of the book and it takes a different approach on teaching recursion. Fun examples so far. Coming from clojure you should take to it quite well.
&gt;Do you have a use case in mind? Not really, I just want to have at least one lisp in my top five languages that I love to work with. I plan to make every University project in at least one of these languages in the long run &amp;#x200B; I saw ketos, but I really didn't like how the special forms are a very long, when I said Clojure/Hy syntax, I meant the way that the special forms are small words (like \`def\` intead of \`define\`, etc) &amp;#x200B; Thanks for the recommendations, I gonna look then up :) &amp;#x200B;
I really liked this one, thanks!!
&gt; *University project ... in the long run* Forget the university long run and graduate, man! 
If nothing else out there satisfies you, then you can write your own. This is the fundamental theorem of lisp and, historically, why we're all so good at cooperating. :insert trollface here:
Yeah! This is the only way how does opensource work!
&gt; I really didn't like how the special forms are a very long A [powerful IDE](https://portacle.github.io/) can help you complete/handle long keywords without a second thought. Consider looking for one for your language of choice to ease typing/reading.
If "defun" and "defvar" count as small words then SBCL (A fully compiled implementation of Common Lisp) meets the prerequisites.
you never heard of static running ?
I don't recall a clojury + native lisp. If your heart is ready take chicken scheme and write a syntax layer
I love gerbil, and use it all the time. I would not, however, recommend it as a learning lisp, for a beginner. It is made for experienced lispers. Why would you recommend it to the OP based on their posted preferences? 
&gt; I meant the way that the special forms are small words (like `def` intead of `define`, etc) You can make them into small words :)
&gt;I tested some lisps, but none really satisfied me. Which lisps did you test and why they didn't satisfy you? 
Microcontroller != microprocessor. STM32 can't easily address external RAM, and can't run programs contained in it. 
Appendix A (page 24) of this paper describes a fairly straightforward implementation. &amp;#x200B; [https://3e8.org/pub/scheme/doc/Quasiquotation%20in%20Lisp%20(Bawden).pdf](https://3e8.org/pub/scheme/doc/Quasiquotation%20in%20Lisp%20(Bawden).pdf)
Here's a relatively straightforward implementation in CL: https://github.com/fare/fare-quasiquote
Jumping out the window would teach you more about modern Lisp implementation than some guides, unfortunately. The Scheme implementation is quite simple: like QUOTE, QUASIQUOTE (\`) and UNQUOTE (,) are just reader syntax that produce a list of their symbols and their values. For example: `(foo ,bar) is read as: (quasiquote (foo (unquote bar)))
Translating the read syntax to a macro syntax is just 15% of the job of implementing quasiquote. The real work is in expanding `quasiquote` (which can contain nested `quasiquote`). 
They don't have the syntax, no? But I think RSR6 has square brackets
That's very true. I think one way to approach it is to count quotes, and only eval when we find an unquote with the right amount of quasiquotes.
There is more than one approach pososible. Your quasiquote expander has to recognize the nested quasiquote, expand it fully, and then process that expansion. So for instance if we have `(quasiquote (quasiquote (unquote x)))` the inner part gets processed, leaving just `x`. The outer quasiquote has no interaction with that. But suppose it is `(quasiquote (quasiquote (unquote (unquote x))))`. The inner expansion will leave behind `(unquote x)`, which then belongs to the outer backquote. We can illustrate this with an implementation that doesn't blow up when there are more commas than backquotes: This is the TXR Lisp interactive listener of TXR 210. Quit with :quit or Ctrl-D on empty line. Ctrl-X ? for cheatsheet. 1&gt; (expand '^(,x)) (list x) 2&gt; (expand '^(,,foo)) (list ,foo) The point here is that `,foo` and `x` are treated the same. So if we imagine this to be an inner backquote expansion and add the outer level of nesting: 3&gt; (expand '^^(,x)) '(list x) 4&gt; (expand '^^(,,foo)) (list 'list foo) But this did nothing more than just process the inner expansion. We can type that in manually and get the same result: 5&gt; (expand '^(list ,foo)) ;; replace ^(,x) with manual expansion (list ,foo) (list 'list foo) 6&gt; (expand '^(list x)) ;; likewise '(list x) So in this implementation, that's basically it: when we encounter the inner backquote, we recurse into the expander and obtain an expansion. Then we process the replacement code. In this implementation, the "too many unquotes" errors are diagnosed outside of the backquote: 7&gt; ,x ** warning: (expr-7:1) unbound variable x ** (expr-7:1) unquote/splice without matching quote Unreduced unquote and splicing terms are recognized by the evaluator via global bindings that produce an error. These are like special operators, and so it is separately done in the compiler: 8&gt; (compile-toplevel ',x) ** warning: (expr-8:1) unbound variable x ** (expr-8:1) sys:unquote: unexpanded quasiquote encountered The error message is a bit different, to keep the users alert and on their toes. 
Yeah, Scheme has the [] syntax, which is just an alias for (), so does Racket too. I don't see any benefit to the mandatory []/{}/etc syntax though, we're talking Lisp here, not JSON.
Additional syntax is a controversial issue. As someone who primarily does Clojure (which itself has a love it or hate it reputation in the greater lisp community), I find it does make it easier to read. But maybe that's because it's my first lisp and I came from a Java/JS background
Thanks, it's interesting how nested quoting only uses list instead of cons. Why is the code inefficient? It looks fine to me.
Make your lisp reader rewrite a quasiquote form as soon as that form is recognized. Now nested quasiquote forms are never encountered since they are rewritten before the outer quasiquote expression is even recognized. The alternative implementation is with a macro. Now the rewriting goes from outer to inner and that makes the implementation much more difficult. I use the ctl2 quasiquote code in this way for my own kiezellisp language (c#).
Section 3.3 of the paper discusses using `append` and `list` instead of `cons`. A more efficient implementation can recognize places where `list*` and `nconc` could be used instead of `list` and `append`. For a first implementation I would do it the easier way illustrated in the paper myself.
&gt; Guile could possibly be built on Windows using Cygwin, and then deployed with Cygnal and any additional required Cygwin libs as a Windows program. &gt; Someone would just have to try this work out any issues, and cob together something resembling an installer for people. it is a losing battle to try and make something work on windows if the developers never cared about it in the first place. i use all three major operating systems, and it blows my mind some people are so hostile towards windows. it is the only os that gets that sort of hate.
what about racket? https://racket-lang.org
Scheme, for it's long syntax, Clojure running in a JVM (can be awful to display error messages), Hy sometimes giving nonsensical error messages like python
My first programming language which I understood well enough was Python, which did not have many braces. I don't mind the interchangeable []/() Racket has, but that's about as far as I'll go. [] and {} represent different data types to () in Clojure and are necessary to create programs, which I dislike.
Optimizing list construction can also be left up to a compiler. E.g. a compiler can recognize that `(append (list 'p) (list 'q) x)` can be done better as `(list* 'p 'q x)`. This is good because it doesn't matter where that *append* comes from; it doesn't have to have come from backquote. 
Any specific reason why you went the Python lispy road ? I guess you are pretty familiar with python. Cuz imho there is better lisp ways for game dav, especially game jams, like Urn+Love2d or Fennel with Love2d. 
Related to `nconc`, I recently found CLHS permits the use of `,.` instead of `,@`, which explicitly allows the use of nconc --- quite surprising as I never saw such a code. http://www.lispworks.com/documentation/lw71/CLHS/Body/02_df.htm
&gt; It is sad that CLHS does not permit quasiquoted multidimensional vector and a quasiquoted structure object. What would you do with it if you could?
Here is how ,,@ (spelled ,,* in this dialect) gets handled properly, so that the "distributive rule" works: 1&gt; (expand '^(,whatever)) (list whatever) Therefore: 2&gt; (expand '^(,,*x)) (list ,*x) So now, when we add an outer backquote to take this `,*x`, the inner backquote has ensured that it's inserted into a `list` form: 3&gt; (expand '^^(,,*x)) (list* 'list x) 4&gt; (expand '^^(a ,,*x b)) (append '(list) '('a) x '('b)) The key point is that `list` is variadic. So when `(unquote (splice expr))` is processed, we can think of it as multiple arguments being spliced into its syntax. Since `unquote` can be understood as generating a `list` form, that plurality of arguments is naturally handled. Well, that isn't exactly accurate. `unquote` **isn't** variadic: 1&gt; ^(a b (sys:unquote 1 2 3) c) (a b 1 c) But: 2&gt; (eval ^^(a b (sys:unquote (sys:splice (list 1 2 3)) c))) (a b 1 2 3) This is due to the order of expansion. The `sys:unquote` is processed first, by the recursive expansion of the inner backquote, which leaves the `sys:splice` alone. The unquote turns into `list` code. Then, the outer backquote expands the splice, generating multiple arguments for `list`.
A really tangible quasiquotation implementation, along with a nice recap of what nested quasiquotes actually mean can be found in the [Appendix C. of CLtL2](https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node367.html).
Yes, quasiquotation is a tricky one. In my Scheme interpreter I implemented quasiquote using this approach (also check comments there): http://axisofeval.blogspot.com/2013/04/a-quasiquote-i-can-understand.html But still looking for a simple algorithm/implementation of hygienic macros...
Here is something to chew on. Suppose you want to use backquote to generate backquote syntax. We can illustrate this clearly by using the macro language to write most of the template, and use the comma notation for the insertions we'd like to do: `(quasiquote (unquote ,x) ,y) ; this type of thing Problem is, these things clash! `,x` is the same darn thing as `(unquote x)` and so what we really have here is: (quasiquote (quasiquote (unquote (unquote x)) (unquote y))) ; this type of thing See the problems? The inner quasiquote steals the `(unquote y)`, for instance. There is a clash. In TXR Lisp I solved the problem by providing two parallel quasiquote implementations, which use symbols in different packages. They share the same expander implementation, of course, but it's parametrized on the three symbols. The quasiquoting read syntax generates code that uses `sys:qquote`, `sys:unquote` and `sys:splice`. 1&gt; '(sys:qquote (sys:splice x)) ^,*x The public symbols `qquote`, `unquote` and `splice` are in the `usr` package: the public "userland", analogous to CL's `common-lisp`. package. Thus, no problem: 1&gt; '^(qquote ((unquote ,x) ,y)) ^(qquote ((unquote ,x) ,y)) `,y` is not `(unquote y)`, but `(sys:unquote y)`. That `sys` one is recognized by the printer and turned back into comma notation; the `usr` symbol isn't. Needless to say, when the `sys:qquote` expander is walking code, it doesn't recognize `qquote`, `unquote` or `splice` as special, and *vice versa*. 2&gt; (let ((x 3) (y 4)) ^(qquote ((unquote ,x) ,y))) (qquote ((unquote 3) 4)) 3&gt; (eval *2) (3 4) So if we want to write backquote code that generates backquote code, we just use one implementation to do the generating, and the other for what is generated. This could go to three or more levels with additional namespaces, but that's probably going overboard; there is hardly a use case for that, I think. 
You could interpolate into structures that are themselves embedded in structure: 1&gt; ^(blah #S(time year ,(+ 2000 19))) (blah #S(time year 2019 month nil day nil hour nil min nil sec nil dst nil gmtoff nil zone nil)) As an alternative to: 3&gt; (list 'blah (new time year (+ 2000 19))) (blah #S(time year 2019 month nil day nil hour nil min nil sec nil dst nil gmtoff nil zone nil)) The advantage is that in a macro, we get a real literal when things get compiled down: 6&gt; (defmacro whatever (name x) ^(defun ,name () #S(time year ,(+ 2000 x)))) whatever 7&gt; (whatever foo 19) foo 8&gt; (compile 'foo) #&lt;vm fun: 0 param&gt; 9&gt; (disassemble 'foo) data: 0: foo 1: #S(time year 2019 month nil day nil hour nil min nil sec nil dst nil gmtoff nil zone nil) syms: code: 0: 9C000004 close t002 0 4 0 0 nil 1: 00000002 2: 00000000 3: 10000401 end d001 4: 10000002 end t002 instruction count: 3 entry point: 3 foo Quasiliterals, when expanded and substituted in the context of macros, can become true literals. 
I would say none. As a lisp machine (or rather an OS) is a pie in the sky project that's never going to produce anything practical. I'd rather have lisp on non-lisp machines.
It looks like OP is counting systems that boot out of the boot loader straight into Lisp as "Lisp machines". 
I had a Xerox 1108 Lisp Machine in the 1980s and made some serious coin writing and selling software for it.
Yes, "an OS".
Well, it's not the 80s anymore.
module 100
PAIP [1] which is available for free contains a far better, in my view, introduction to Common Lisp, than Touretzky's book which is not by any means bad, it's just that PAIP is amongst the best ever. Given that nobody has infinite time to spend reading books, if you have to read a Lisp book make sure that PAIP is one of them. If you want to read more Common Lisp books after, I would suggest Graham's On Lisp and Let over Lambda. [1] https://github.com/norvig/paip-lisp
&gt;Is Common Lisp the best dialect for me to learn if I want to learn about and develop Lisp machines? Well, historically Maclisp deriatives have been used on most LispMs, and Common Lisp was a unification of them, so you'd have the best chance understanding the code then. Honourable mentions should go to [Scheme-79](https://dspace.mit.edu/handle/1721.1/6334) too, which interprets a minified version of Scheme as an instruction set.
Hello, The answer is fairly simple: I've never hear about Fennel, nor Urn, also my daily job is in Python, and I've used Pyxel some time already. But, thank you very much for the recommendation, I'll surely give it a try. I've toyed around with LÖVE2D, and Fennel looks absolutely great! Best regards. 
7pm UTC happens when this comment is 10 hours and 33 minutes old. You can find the live countdown here: https://countle.com/ApoTBM_Qd --- I'm a bot, if you want to send feedback, please comment below or send a PM.
What?
[modulo](https://en.wikipedia.org/wiki/Modulo_operation#/media/File:Divmod.svg)
Very funny.
Thnaks, appreciated
&gt; -7 points Are these kinds of voting patterns an indication that Lisp is not an LFSP anymore? To the OP: I'd think that learning CL would help. Maybe add Emacs (Emacs Lisp), which reportedly is similar to Maclisp, and could prepare you for more pervasive use of dynamic scoping. 
I will respond, kindly assuming that you are not trolling me :-) There are important developer user interface ideas from the old Lisp Machines that still live in programming environments like Pharo Smalltalk. While I also appreciate more modern agile development (Jira, SCRUM, git repos, pull requests, sprint planning, etc.) for large team development efforts, I still believe in solo development in interactive programming environments. As great as emacs + slime, etc. are (and now VSCode with Lisp support), it is not quite like the old Lisp Machines. Of course, the Lisp Machines were expensive. I worked for a company that did $8 billion a year in business and I was the only programmer with a Lisp Machine. My company considered me, and the machine, to be a research investment. Xerox would not have been able to support the Lisp Machine product line without one huge customer: the CIA who had what was reported to be a fantastic analyst work environment layered on top of the environment provided by Xerox. With due respect, consider that things you may not have had experience with still have high value, even if now a footnote in history.
It is a wonderful book, one of my favourites in regards to style, teaching approach subjet choices. To me it was the best way to start learning about LISP (I like to use all caps, as I am nostalgic of that name). It is also a perfect companion to PAIP and others. Those errata were already fixed in the Dover edition.
This guy has an interpreter with nested quasiquotes : https://www.youtube.com/watch?v=Ad9NtyBCx78 Sources available at https://cpmaker.com/source-preview
The OP said he wants to contribute to Mezzano or ChrysaLisp. The old lisp machines from the 80s are never coming back. And anybody trying to bring them back is wasting valuable resources which could have been directed towards something attainable and useful.
What does LFSP stand for?
&gt; Those errata were already fixed in the Dover edition. What do you mean?
Thanks! That's the info I'm looking for.
I have virtually installed Mezzano three times to experiment with it. I hope that the author is inspired by the old Lisp Machines. I will ask him.
I don't know if I want to contribute to either of them specifically. But I'll probably contribute to some project(s) of that kind in the future.
What about McClim?
I was just confirming what the preface says, that the errata present in the orginal edition, were fixed in Dover's edition. As per the actual list of errata, I personally have not seen it published anywhere. Perhaps you could ask the Author?
If you're interested in the CADR code, check out this: https://github.com/LM-3/sys It's Lisp Machine Lisp aka ZetaLisp.
Last year i was in the same spot as you. What I'd recommend you doing is defining exactly what your project will be and then try to fit Lisp into it. When I had to decide my project I was really into electronics and FPGA, so I decided to create a DSL in Lisp that would generate vhdl code, it was a lot of fun
The "Analyst" was written in Smalltalk: http://www.bitsavers.org/pdf/xerox/xsis/ANALYST_V1.2t_Reference_Manual_Jul87.pdf
Godot game engine recently released C API for game scripting called GDNative. Maybe try to add Lisp support via FFI and then do something crazy like hot reload, for e.g, Clojure's Figwheel. If that is possible, we can get instead of in old school game where we open console with tilde key and using specific commands to manipulate game world, we can directly manipulate game world using a real programming language. Some Lisp implementations that might be handy would be: - Embeddable Common Lisp (ECL) - Chicken Scheme - Gambit Scheme At least that is what I have in mind, because from what I see, one feature that really makes Lisp great is the interactive programming.
&gt; Scheme, for it's long syntax &amp;#x200B; The nice thing about Lisp is that [syntax](http://stevelosh.com/blog/2016/08/playing-with-syntax/) is what you want it to be. Why settle for someone else's idea of [syntax](http://xahlee.info/comp/lisp_syntax_macro_reader.html) if you find it tiresome? &amp;#x200B; &gt; Clojure running in a JVM (can be awful to display error messages) &amp;#x200B; [ABCL](https://common-lisp.net/project/armedbear/)'s error messages may be more helpful, while still giving access to the huge Java library, ecosystem, and very fast and mature virtual machine. &amp;#x200B; &gt; Hy sometimes giving nonsensical error messages like python &amp;#x200B; Perhaps, if a language is given time to develop, its errors will as well. This might be an advantage [a](http://www.lispworks.com/documentation/HyperSpec/Body/25_ab.htm) [Lisp](https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node219.html) with several mature implementations has. Particularly, [one](http://www.lispworks.com/documentation/HyperSpec/Body/01_db.htm) based on a well [designed](http://www.lispworks.com/documentation/HyperSpec/Body/c_condit.htm) standard that's been long understood by its community. &amp;#x200B;
Maybe getting off-topic, but along the same lines was [Pre-Scheme](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.3.4031) , which had a formally verified compiler (VLISP). I've considered this language for bootstrapping a Lisp machine project. Others here can probably explain why I shouldn't try this... :) &amp;#x200B; &amp;#x200B;
Both books are great and it's wonderful that both are available for free. It was quite heartening to finally see the highly regarded PAIP online for everyone. But, each author may have a somewhat different scope of audience in mind. Perhaps, at different levels of experience even if there may be some overlap. It's advantageous for Common Lisp newcomers that they can choose between either one, or both, depending on their comfort level in tackling what some might mistakenly consider an intimidating language / ecosystem / community. &amp;#x200B; An [excerpt](http://www.cs.cmu.edu/~dst/LispBook/index.html) from the Preface of , "Common Lisp: A Gentle Introduction to Symbolic Computation"... &gt;When I wrote the book I had three types of reader in mind. I would like to address each in turn. &gt; &gt;**Students taking their first programming course.** The student could be from any discipline, from computer science to the humanities. For you, let me stress the word ***gentle*** in the title. I assume no prior mathematical background beyond arithmetic. Even if you don’t like math, you may find you enjoy computer programming. I’ve avoided technical jargon, and there are lots of examples. Also you will find plenty of exercises interspersed with the text, and the answers to all of them are included in Appendix C. &gt; &gt;**Psychologists, linguists, computer scientists, and other persons interested in Artificial Intelligence.** As you begin your inquiry into AI, you will see that almost all research in this field is carried out in Lisp. Most Lisp texts are written exclusively for computer science majors, but I have gone to great effort to make this book accessible to everyone. It can be your doorway to the technical literature of AI, as well as a quick introduction to its central tool. &gt; &gt;**Computer hobbyists**...The ‘‘Lisp Toolkit’’sections of this book will introduce you to the advanced features of the Common Lisp programming environment that have made the language such a productive tool for rapid prototyping and AI programming. &amp;#x200B; An [excerpt](https://github.com/norvig/paip-lisp/blob/master/docs/preface.md) from the Preface of, "Paradigms of Artificial Intelligence Programming"... &gt;The intended audience for this book is broad: anyone who wants to become an advanced Lisp programmer, and anyone who wants to be an advanced AI practitioner. There are several recommended paths through the book: &gt; &gt; &gt; &gt;***In an Introductory AI Course:*** Concentrate on parts I and II, and at least one example from part IV. &gt; &gt;***In an Advanced AI Programming Course:*** Concentrate on parts I, II and IV, skipping chapters that are of less interest and adding as much of part III as time permits. &gt; &gt;***In an Advanced Programming Languages Course:*** Concentrate on parts I and V, with selections from part III. Cover [chapters 11](https://github.com/norvig/paip-lisp/blob/master/docs/chapter11) and [13](https://github.com/norvig/paip-lisp/blob/master/docs/chapter13) if similar material is not presented with another text. &gt; &gt;***For the Professional Lisp Programmer:*** Read as much of the book as possible, and refer back to it often. Part III and [chapter 25](https://github.com/norvig/paip-lisp/blob/master/docs/chapter25) are particularly important. &amp;#x200B; It wouldn't surprising if some read "Common Lisp: A Gentle Introduction to Symbolic Computation" first, then read "Paradigms of Artificial Intelligence Programming" afterwards.
&gt;Would you kindly suggest any ideas for me? It would be fantastic if your project could also conttibute to the benefit of the Lisp community. Some ideas that IMO would be helpful would be: - create a LLVM backend for the SBCL compiler (there has been some work done in this direction, also see CLASP) - create a full featured Lisp implementation that outputs Webassembly code - create a Lisp implementation that has allows good performance application delivery on the Android platform - create a new , powerful IDE for Common Lisp -- or you can bring the (recently opensourced) Corman CL IDE to new levels of productivity - Create a Lisp library that can execute modern-spec Javascript code 
Additional note: In 1989, the TIOBE index for most popular programming languages was: 1. C 2. Lisp 3. C++ In 1994: 1. C 2. C++ 3. Pascal ... 6. Lisp 
The TIOBE index is oh so unreliable.
the 'Flavors' story is her : [https://en.wikipedia.org/wiki/Steve%27s\_Ice\_Cream](https://en.wikipedia.org/wiki/Steve%27s_Ice_Cream) Steve's store was very popular at that time (you had to wait at least 30 mn to get an ice cream) the then whopper was a tribute to Burger King So you know what MIT programming guys like to eat ...
AI winter ended with "deep learning".
Clojure? 
&gt; create a full featured Lisp implementation that outputs Webassembly binaries makes me think of https://github.com/Arboreta/arboreta-wasm
Hey, cool. Ideas: - improve the GUI situation: create bindings to IUP (an attempt: https://github.com/klimenko-serj/cl-iup), or to Qt5, or to WxWidgets (old project: https://github.com/lisp-mirror/wxcl), or work on McClim (or Garnett) - create an admin panel à la django-admin with Weblocks - work on SBCL to lower binaries size (this as been a google summer of code topic once IIRC). Revive WCL, Lisp as linux shared libraries: https://github.com/wadehennessey/wcl Finally, SBCL's ideas: http://www.sbcl.org/gsoc2014/ideas/ (http://christophe.rhodes.io/notes/blog/posts/2014/sbcl_summer_of_code_2014_participation/)
Interesting. Is there information how they measured? "Ranked by global search-engine popularity" sounds like the same method used by Tiobe; or do they have more reliable data?
It was the heyday of Reddit, which started as an r/programming with generally competent programmers, kind of like lobsters nowadays, but without the invite system. Since Paul Graham was involved, and since the site was written in Lisp, and since it happened to draw many people interested in Lisp, and since there was energy to re-new the raging arguments that "plagued" USENET earlier, there was buzz, and with it came programmers, and code, and blog posts, etc. Reddit was great for programmers back then. Then came cancerous growth, signal drowned in noise, competence turned to mediocrity turned to monkeyism, and now the Lisp giant sleeps again, and Lispers can only lay back and enjoy the calm. Until next time.
Never mind that, how did out-of-fuel, plummeting Ada manage a level flight? 08 to 13 was post-recession, that's probably what it is. 
&gt;bring the (recently opensourced) Corman CL IDE to new levels of productivity &amp;#x200B; Perhaps, this [post](https://chaoticlab.io/lisp/update/2018/12/30/corman-3-1-release.html) and the comments below it might provide some encouragement and some insight as to the benefits of working on that project.
Hopefully, that project is picked up and progressed! &amp;#x200B; I've read that at least one VM has been [ported](https://github.com/appcypher/awesome-wasm-langs) to Webassembly. I wonder if the same can be done for Common Lisp?
&gt;I've read that at least one VM has been ported to Webassembly. I wonder if the same can be done for Common Lisp? Well, CLISP can compile to bytecode that is then executed by the CLISP JIT VAN. in theory you can "easily" port this JIT VM to webassembly, since CLISP is written in C; or port the whole CLISP. However its performance, already at machine-level is weak compared to the lisps that compile to native code. In Wasm it would be even slower. 
Any chance this is it: https://github.com/domus123/vhdlisp ? If not, unless licensing issues, could you please provide it? We have a VHDL-based project this semester, and I believe lisp can help keep the syntax cleaner.
That's not it, but I know the person who wrote that one. I'll let him know about this thread Mine is not yet available on Github (gotta still fix some ugly code and some bad workarounds that i made for it to work).
Is it useable as a blackbox? In any case, I guess my juniors would be able to use it. Thanks :) !
&gt; Interesting. Is there information how they measured? "Ranked by global search-engine popularity" sounds like the same method used by Tiobe; or do they have more reliable data? I bet they just used TIOBE index there.
&gt; Then came cancerous growth, signal drowned in noise, competence turned to mediocrity turned to monkeyism, and now the Lisp giant sleeps again, and Lispers can only lay back and enjoy the calm. Lots of food for thought here.
It looks like aside from [Lua](https://github.com/vvanders/wasm_lua)'s [VM](https://cdn.rawgit.com/vvanders/wasm_lua/d68f46a8/main.html), someone's ported [Perl](https://webperl.zero-g.net/) and [PHP](https://github.com/oraoto/pib) to [Webassembly](https://webperl.zero-g.net/democode/index.html)! Or, am I misreading that? Are Perl's and PHP's runtimes faster than CLISP, WSL, Eclipse CL, ECL...etc? I'm not familiar with their performance.
There's something attractive about a small, cross platform UI library. Has anyone had a chance to use/try [IUP](https://en.wikipedia.org/wiki/IUP_(software)) with [Common Lisp](https://github.com/klimenko-serj/cl-iup)? It seems to be actively maintained. Any issues with performance or functionality?
&gt;It looks like aside from Lua's VM, someone's ported Perl and PHP to Webassembly! Or, am I misreading that? &gt;Are Perl's and PHP's runtimes faster than CLISP, WCL, Eclipse CL, ECL...etc? I'm not familiar with their performance. One needs to be very careful with evaluating the languages that have been ported to WASM because in most cases they are not full ports and lack a lot of features. 
That's a good point! It wasn't immediately clear what version of the Lua VM was ported. But, running the following in the browser Demo produced... function hello_lua() print "Hello Lua!" print(_VERSION) end hello_lua() Hello Lua! Lua 5.3 Running the following in the Perl browser Demo produced... perl -v This is perl 5, version 28, subversion 0 (v5.28.0-26-ge0b45cd50b) built for wasm (with 1 registered patch, see perl -V for more detail) Copyright 1987-2018, Larry Wall Perl may be copied only under the terms of either the Artistic License or the GNU General Public License, which may be found in the Perl 5 source kit. Complete documentation for Perl, including FAQ lists, should be found on this system using "man perl" or "perldoc perl". If you have access to the Internet, point your browser at http://www.perl.org/, the Perl Home Page. Another version of Forth [ported](https://el-tramo.be/waforth/) to WASM is explained in this [article](https://el-tramo.be/blog/waforth/). So many ports! &amp;#x200B;
Hard to say what the cause of that drop is. Basically the question is: why were people using Lisp before, and why did they stop using it? Some possible answers: * More Lisp features in the "more conventional" languages. E.g. Julia for the computational sciences, or lambda expressions in Java and the like. * Generational turn-over. Possibly we've reached a point where a lot of old-time Lisp programmers are simply retiring? * The PG/HN/Reddit Lisp hype. (see /u/death's comment)
 &gt;Honourable mentions should go to Scheme-79 too, which interprets a minified version of Scheme as an instruction set. Thanks for this, now I got something interesting to learn today!
&gt; Xerox would not have been able to support the Lisp Machine product line without one huge customer: the CIA who had what was reported to be a fantastic analyst work environment layered on top of the environment provided by Xerox. Do you have a source for this? Because I want to eventually mention this into an internal document I'm assembling.
&gt; What about McClim? /u/lisperss you're welcome to contribute to finish a production-quality free CLIM backend for Windows.
Thanks, they are looking good. The WASM ecosystem is evolving very fast! What I claimed about those languages was only true 1 year ago, it seems.
Thanks for the tip! I'll check it out.
I don't have any preferences. This is just preparations for my journey into the land of Lisp machines :)
I am a young person trying to learn Lisp. I am under the impression that Lispers are somewhere but I do not know where. I looked into the CLISP web page and it looks ancient. I don't mind that it looks ancient but would be nice to know at least who is involved and to have a GitLab or something. Anywho, I don't mind too much because I am still learning. I started with Elisp and now I am reading Structure and Interpretation of Computer Programs. Clojure has a slack and other places where people meet. Is reddit the only place where I can find Lispers? Maybe the community needs to update some stuff and change a bit. 
We are here, on Reddit, also on the #lisp channel on the Freenode IRC server you'll find them, and most of all on repositories (i.e. GitHub), also lispers seem to follow each other on twitter. &gt;I looked into the CLISP web page and it looks ancient. Note the CLISP is just one of many Common Lisp implementations, if for example you were at the repository of [Steel Bank Common Lisp](https://github.com/sbcl/sbcl) you will find plenty of activity, for example last commit was 6 months ago. &gt;but would be nice to know at least who is involved There are many (free) Common Lisp implementations and each of them has its maintainers' group: ABCL, CCL, ECL, SBCL, CLASP, to mention just the more popular or recent ones. So it's not as if everything revolves around only *one* compiler and thus everybody is gathered around. Additionallly, Lisp (or at least CL) is used for wildly diverse tasks and thus it's natural that the community will be less concentrated in only one place: - quantum computer simulation - game programming - web dev - computational chemistry - scientific numeric computation - symbolic calculus - data analysis etc. It also bears in mind that some of the usages above are by getting paid for doing it full-time and thus perhaps with little spare time to join an online community. 
Implementations: SBCL (www.sbcl.org) IRC: #lisp on Freenode (slack is not popular with Lispers) Blogs: Planet Lisp aggregator Emacs Lisp has a huge following too and the community is extremely active.
&gt;Scheme, for it's long syntax Well, if you don't like long syntax, perhaps Clojure is the best choice. Considering i have all sorts of auto-complete functionality on my Lisp IDE I personally *like* the verbose Common Lisp, it makes third-party code very easy to read and understand. 
That is really helpful. Is there a place I can find stuff oriented towards web development? I found this YouTube video: https://www.youtube.com/watch?v=bl8jQ2wRh6k&amp;t=511s&amp;list=WL&amp;index=14. I think web development is good material for newbies. Where can I find more about CL and web dev?
&gt; Where can I find more about CL and web dev? You ask, I deliver. https://lisp-journey.gitlab.io/web-dev/ 
Wow thanks for following up on this thread! I would never have guess about the mixins.
[L\_Gouzenes](https://www.reddit.com/user/L_Gouzenes) kindly followed up in an old thread [https://www.reddit.com/r/lisp/comments/aabi4f/whats\_with\_the\_name\_defwhopper/](https://www.reddit.com/r/lisp/comments/aabi4f/whats_with_the_name_defwhopper/) with this. Had no idea. Burgers and ice-cream!
I don’t have a definitive reference, sorry. I used to demo my software in Xerox’s booth at AAAI, and I think I heard this when I asked about large customers. As someone else pointed out, the Analyst system I mentioned was probably on the Xerox Smalltalk environment (same hardware, you could reboot from one to the other if you also had a Smalltalk license). Sorry I couldn’t be of more help.
Guile could work too I guess
Yep.
A sludge of linear algebra called "artificial neural networks" is nothing that amazing (or useful) compared to symbolic AI.
[Language for smart people?](https://acronyms.thefreedictionary.com/LFSP) That's a little harsh.
&gt; work on SBCL to lower binaries size And there's already a little bit of existing work in that direction, google "sbcl tree shaker" Also, please name it `shake-shake-shake` like the [LispWorks people did](http://www.lispworks.com/documentation/lw51/DV/html/deluser-169.htm). They have a sense of humor at LW!
Wow!! Thanks!
It generated a lot of buzz again in AI for business uses. 
Sure. It's more of a dead end than symbolic and won't lead to general AI though.
It seems that all the cool kids are [doing](https://hackernoon.com/web-assembly-proof-of-concept-with-emscripten-vs-code-530e69eb4de0) it :-) &amp;#x200B; With the [.Net](http://learn-blazor.com/getting-started/what-is-blazor/) run-time now [ported](https://en.wikipedia.org/wiki/Blazor) to WebAssembly in the form of [Blazor](https://blazor.net/), [C# development](https://web.archive.org/web/20181022123032/https://msdn.microsoft.com/en-us/magazine/mt829752.aspx) will have a very wide reach across all platforms and architectures that support a modern browser. It seems that [performance](https://www.reddit.com/r/csharp/comments/8gjx3v/a_small_performance_comparison_of_monowasmblazor/) is being [improved](https://www.reddit.com/r/csharp/comments/8gjx3v/a_small_performance_comparison_of_monowasmblazor/dyeabsd/) by creating a "static compiler that will turn .NET code into WebAssembly code, rather than running on an interpreter running on top of WebAssembly." I suppose any Common Lisp implementation running in a web browser would likely have to follow a similar solution.
&gt; Well, K isn't the constant function, but a constant-function generator If you approach LC like this, you will have a very hard time when things get more complicated.
When I say that the [standard term](https://en.wikipedia.org/wiki/Lambda_calculus#Standard_terms) *K* isn't a "constant function", what I mean is that when an argument *c* is applied to *K*, leading to *K c*, **that** expression is then a constant function. The *K* term itself cannot be a constant function because it yields different values for different arguments. If *a* and *b* are distinct, *K a* and *K b* are distinct, right? A constant function yields the same value regardless of its argument, like f(x) = 42. The standard term *λx.λy.x* already has a name: *K*. This can just be pronounced as "kay"; there is no need to use any misleading alias like "constant function". If I have a hard time when things get complicated, that doesn't mean I'm doing anything wrong. I've found at times in the past that I had an easy time reasoning about something until clearing up some critical misunderstanding, after which I suddenly had a hard time.
&gt; Perhaps you could ask the Author? Thanks for the suggestion! I've updated my original post with his answer.
And Linus Torvalds was wasting valuable resources by developing Linux. We already had Windows, Mac OS, and commercial Unix. :)
Bad analogy, there was nothing comparable to linux at the time.
s/Bad/Loose/ Um, Hurd? :) There is nothing comparable to a modern Lisp OS/machine, BTW. 
&gt; Um, GNU Hurd? :) Are you serious? &gt; There is nothing comparable to a modern Lisp OS/machine, BTW. Modern hardware and software can run lisp very well. My lisp machine of choice is a Mac.
Random access to lists is slow. You'd need to use merge sort.
Thank you, it's a good hypothesis. I'll try. 
\&gt; Modern hardware and software can run lisp very well. My lisp machine of choice is a Mac. I have an iMac Pro. Finally a Mac I own is way too powerful for Lisp or Lisp is too efficient. But anything from a Raspberry Pi and upwards runs a full Common Lisp incl. IDE nicely.
Nice, this builds upon your previous work that did not take predicates into consideration right? Cool, I figured that was the difficult part.
Yes, I'm serious--that's what the colon right-parenthesis means at the end of the line. &amp;#x200B; Although GNU Hurd doesn't get much respect nowadays, in it's early years it seemed to have potential. Maybe if we hadn't wasted so much time on Linux, we could now have an elegant microkernel-based OS, instead of, well, you know. &amp;#x200B; Furthermore, I told Stallman a few years back that I thought the whole GNU project as implemented was a waste of time. Why didn't he use a Lisp system language like Pre-Scheme (statically typed, formally verifible, and non GC) instead of C (blech) to create a Lisp machine? Even at the time GNU was started, Unix was getting long in the tooth. We could be using a real Lisp OS now, instead of, well, you know. Running Emacs on Lisp, as it should be. His answer was "expedience". &amp;#x200B; So why do we keep throwing good time away after bad? Why do we have SBCL, ECL, Clasp, CLISP, etc. (don't get me started about Scheme distros). Isn't it a waste of time to keep playing nice with C/Unix? &amp;#x200B; "SBCL on Linux" != "[http://metamodular.com/lispos.pdf](http://metamodular.com/lispos.pdf)" I would argue. :) &amp;#x200B;
You could also coerce to vector, sort that way (using elt, aref, or svref instead of nth), then coerce back again, if the goal of the exercise is to use that specific sorting algorithm. As an aside: a common source of bugs in Common Lisp programs, which I have seen many times, is forgetting that SORT is a destructive operation. It should have been named NSORT, with SORT the non-destructive variant. I think the bad naming was inherited from Interlisp?
&gt;Modern hardware and software can run lisp very well. My lisp machine of choice is a Mac. Correction: you are running the Common Lisp language on a Unix derived OS--it's not a Lisp machine or even a Lisp OS.
\&gt; CL's SORT so much faster CL is a language and not an implementation. From many implementations the source is available, so you can study their SORT implementation. With lists no one uses Quicksort. One might even argue that there is no Quicksort for lists, since it assumes a modifiable vector. Also check out ROTATEF and similar for swapping values. \&gt; (if (&lt; x y) T nil) That would be just (&lt; x y) . Also: recursive procedures may have some overhead and a stack limit.
Thanks, I didn't expect less from you. 
The project was renamed to `quicksys` as suggestion of Xach (original author `quicklisp`) to avoid confusions, since quicklisp-meta was not intended to replace quicklisp or be parte of the original project. 
New url: https://lisp.com.br/quicksys/
Exactly. My little message to the lisp community is: It's a reminder it's not yet time to 100% jump ship to neurons. Build symbols on top of neurons. Make symbols great again XD
This was extremely timely too. One of the most amusing take homes for me from the [recent OpenAI piece](https://blog.openai.com/better-language-models/) was that a huge portion of their network was dedicated to storing facts! If only we could provide those facts to the network directly ... and then have it go out and test them :)
It can be.
Getting an SBCL release notification is like discovering a generous Amazon gift card one received last X-mas but forgot to use. Thank you, team!
There are two enthantements, an optimizations and few bug fixes. Why does it deserve a minor version's increment?
Pretty sure SBCL doesn't follow SemVer
That is sad. 
Not for someone who doesn't think SemVer is a universal solution.
SemVer seems a reasonable solution. Simple and intuitive. 
It is so "simple and intuitive" that several major projects using SemVer fail to use it correctly [2] to the point of other people commenting on it, and that articles are written by the authors of SemVer itself that discuss its future [1] [3]. [1] https://news.ycombinator.com/item?id=19135965 [2] https://news.ycombinator.com/item?id=13378637 [3] https://news.ycombinator.com/item?id=19068865
Thank you for links, I found a few interesting thoughts, however don't see if people have some good replacement for semver. 
There's no silver bullet. Versioning is not a solved problem.
Agree. Sadly, semver became so common that when you see a version which looks like a semver but behaves differently, this blows your mind :(
&gt;bug fix: TREE-EQUAL with :TEST 'EQL now correctly computes its answer. (reported by Bahodir Mansurov) Whoa, that's a quite important one. 
Kudos to the SBCL team for the sustained, non-stop effort. I wish CCL would get a new release soon, though. 
I still haven't read the paper, but it would be cool to see if this can bridge ML and formal verification of AI systems. Have you looked at all at formal synthesis (such as: https://ieeexplore.ieee.org/document/7798782 )? It's fun stuff, but the time complexity is prohibitively large unfortunately though it has been used in real-world driving scenarios (I think).
What about thinking very hard and discussing with Xach improvements to Quicklisp instead of another system altogether?
Many thanks to Yuki YOKOTA. The documentation explains at length the steps taken. There are some questions I still have in my head, but perhaps that would be solved if I browse the AWS documentation. But, perhaps somebody could answer my questions: Question 1: Considering [the AWS documentation on Execution Context](https://docs.aws.amazon.com/lambda/latest/dg/running-lambda-code.html), am I correct in saying that the SBCL executable image contained in `bootstrap.exe` will startup only once, and after executing any lambda function invocation it will be eventually "hibernated" by the AWS runtime until a new lambda function "thaws" it again? and thus, Question 2: Lisp implementation startup times won't be a problem? Question 3: Isn't it possible to rewrite [the "build bootsrap" shell script](https://github.com/y2q-actionman/cl-aws-custom-runtime-test/blob/master/build-bootstrap-out/build_bootstrap_in_vm.sh) so it tells SBCL to load a certain `.lisp` file, instead of executing all Lisp commands through `--eval this` and `--eval that` directly on the shell? I think it would be more elegant that way, however I don't know if AWS or Docker is imposing some limitation here. 
&gt;Question 1: I think so, too. &gt;Question 2: When I was trying to do some works at beginning, I sometimes encountered timeouts at first invocation. (the default timeout is 3 seconds). However, second and more invocations worked fine. If the first error is not good, I think you extend the timeout properly. &gt;Question 3: You are right. This dirty part is because of my laziness only. I tried what codes should be `eval`ed many times. These trials remains there. Sorry for confusion.
&gt; Alas, the Scheme language has been brought to the web! 'Alas' implies that this is something you are sorrowful about - got a chuckle out of me, but probably isn't what you mean! Thanks for the article, though. I've not checked out scheme in a long time, so find this sort of thing super helpful for keeping up with what's out there these days. 
See the way Shinmera's [Deploy](https://github.com/Shinmera/deploy/blob/7bd96ba3f88a424e03394de1adadf4a4993f849c/deploy.lisp#L143) does it. You need to pass an extra argument to CCL's core-dumping function.
Works perfectly, cheers mate!
&gt; support for building under ABCL and ECL (as well as CCL, CMUCL, CLISP and SBCL itself) Can someone explain, give a usecase ? Thanks.
&lt;3
Since it's fairly compatible for 30+ years, strictly following SemVer might be too boring?
It could make porting to new platforms easier. Also with SBCL being potentially meta-circular, compiling under more platforms can make the code more 'healthy' and less susceptible to bit-rot of other compilers. It also reduces requirements for getting a working SBCL, particularly for the case of ABCL, making the potential requirement only a Java runtime. If you can imagine a diagram like this https://akr.am/languages/ but for build environments.
I use that setup, but with a plump extension for xpath: [https://gist.github.com/mmontone/d16ce10d17535778daabef1a1e360273](https://gist.github.com/mmontone/d16ce10d17535778daabef1a1e360273)
Ha! Thank you for correcting that. I will fix that with an errata on the post. I am glad you enjoyed it.
Thank you so much for your answers and for answering quickly. I think your project really benefits the CL community. &amp;#x200B; &amp;#x200B;
&gt; See the way Shinmera's &gt; Deploy &gt; does it. You need to pass an extra argument to CCL's core-dumping function. Pretty cool! Didn't know you could do that, thanks! 
Try r/AutoCAD maybe. AutoCAD's Lisp dialect is particular to that application. Only people with installation of AutoCAD can try any of your examples and debug them. Mainstream Lisp is not developed using AutoCAD; nobody wants to ship AutoCAD to deliver a Lisp program to a non-CAD-using end-user. 
Thanks! I'll try them out.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/autocad] [Lisp code is adding extra quotes when reading csv. Is this changable?](https://www.reddit.com/r/AutoCAD/comments/av2gkn/lisp_code_is_adding_extra_quotes_when_reading_csv/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I know it feels like we just posted about that, but it was a month ago, and today we actually launched the Kickstarter, any help sharing and any backing is supported. If you want to discuss anything about the game, it is made in Common Lisp with libraries available to everybody (so far), so anything you'd like to know, just ask!
Keep the good work on!
I already discuss with him about something related and presented the quicksys as well. Quicklisp has your own life development cycle and it's really stable. My main idea it's quicksys being available to quicklisp to use with [http://ultralisp.com](http://ultralisp.com): which has a non-peer-reviewed submission and fast update cycle. &amp;#x200B; The idea of flow is: \+ Use Quicklisp to get quicksys \+ Use quicksys to get every software is not on quicklisp (like ultralisp). &amp;#x200B; It will make the same habits of Xach and works for me too :) If you think you can change the Xach mind try it at [lisp@freenode.net](mailto:lisp@freenode.net). The most time he is available on there.
I wonder what they _are_ following that led to the increment. I’m sure it makes some kind of sense, right?
[https://github.com/quicklisp/quicklisp-projects/issues/1654](https://github.com/quicklisp/quicklisp-projects/issues/1654) if you have interest in putting this in quicklisp as available system, it can be done by here.
I don't see this ever reaching 10000$ nevermind 100k. First, the kickstarter page, visually, looks like shit. Low resolution assets, shitty font and color scheme choices and the look and feel of the presentation overall do not inspire confidence in the creators. Second, they come out and ask for sustenance (70% of the funding money) which is 2000$ a month per developer. One can live like a king in many parts of the US on that sort of money. Instant red alert here. This could fly if we were talking about established creators with a well-documented history. Not a bunch of unknowns who are in all probability going to fail. Here is my advice: + Ask for the minimum possible and spend the majority of the money in the game itself (assets). + Do this as a side-project while you find your sustenance elsewhere. 
Thanks for the advice, I think it is logical that some people will find this unreasonable, and won't want to back us, and if we don't reach the goal we'll have ways to continue, as we said in our page, this is a way to guarantee the project is going to have dedicated resources, but the project will continue no matter what. And thanks for being brutally honest, we value all opinions, and will take it into consideration if we ever go trough this process again.
FWIW. I really enjoy the ones I’ve seen. It’s so awesome to see you work “live” and shows what’s possible once you realize “best practices” and “that’s how it’s always been done” is sometimes a horrible stance to take in an argument. 
Ah, wondering why a black screen… Enjoy!
It's the squeeze out unwarranted assumptions in the build process. I'm told continuing to provide support for obsolete processor architectures is also useful, for a similar reason. It helps find bugs in algorithms that can affect the popular ones.
Well done and thank you! SBCL is a great choice. Clisp is also very nice and easy to use. But, SBCL is said to be the highest performance open source Common Lisp implementation.
Ideally, running a proper Lisp daemon would be better, like Hunchentoot, but this is an okay compromise.
Does somebody still use CGI in 2019!? 8-)
Nah, just spend 5-10 bucks a month to buy a vps. It will improve your quality of life massively. There are so many things you can do with it besides hosting Lisp webapps.
Since the API for SBCL is (mostly) rock stable (the CL spec), this either means that SBCL would just increment the patch number forever, or it would base minor version number increases off subtle SBCL-specific API changes that some applications exploit. There have been some of the latter, but they mostly come from applications that dive into non-public parts of SBCL to get the job done. Nibbles (and Ironclad) broke at one point because of such changes. I can think of only one API change that caused more widespread problems: the change to the representation of backquoted forms in 1.2.2. A certain (not entirely proper) style of macro that walked over its form arguments could fail with that change, since it would have to be extended to walk through the non-list objects the new implementation provided.
Since the API for SBCL is (mostly) rock stable (the CL spec), the use of SemVer either means that SBCL would just increment the patch number forever, or it would base minor version number increases off subtle SBCL-specific API changes that some applications exploit. There have been some of the latter, but they mostly come from applications that dive into non-public parts of SBCL to get the job done. Nibbles (and Ironclad) broke at one point because of such changes. I can think of only one API change that caused more widespread problems: the change to the representation of backquoted forms in 1.2.2. A certain (not entirely proper) style of macro that walked over its form arguments could fail with that change, since it would have to be extended to walk through the non-list objects the new implementation provided.
But shouldn't changes like these (from 1.4.16) lead to major version increment? * minor incompatible change: ENSURE-DIRECTORIES-EXIST no longer establishes a CONTINUE restart in case of an error. * minor incompatible change: Defining macros (DEFVAR, etc) which require a symbol as the name will fail to macroexpand if given a non-symbol.
Those changes didn't break much existing code, if any. The backquote change had a more substantial effect. I think SBCL (and the other lisps) could use some separation of their non-standard APIs as "this you can count on" and "this is incidental, it can change without notice", and changes to the former would be more significant version number changes (as would major internal reorganizations, for example new GC schemes). But as with everything, resources are limited.
Cool! I think the Makefile can be reduced to: CFLAGS+=-std=c89 -Wall -pedantic all: mp clean: $(RM) mp (If you're on Plan 9 or using Plan 9 mk then maybe things work differently)
Be sure to also post in r/acme !
ANN is very much non-linear. If it was linear algebra, then there would be no point in multiple layers because they would all collapse down into one layer. 
Do you know about [XMLisp](http://www.agentsheets.com/lisp/XMLisp/)? You may also find [Enamel](https://www.xach.com/naggum/articles/3207626455633924@naggum.net.html) of interest.
Those certainly look very close to what I built. I'm glad I posted this before spending time making this open source.
Actually, on further reading, I'm not exactly sure what XMLisp is. It seems geared toward graphics? It's not my area of expertise.
Looks like they developed XMLisp as part of a larger project, that "hijacked" the name and repository :) The relevant code is in `trunk/XMLisp/sources/XMLisp/XMLisp.lisp`.
I like to use generators like cl-who for small stuff, separate template files for bigger stuff. I don't usually like to see a ton of markup mixed in with code.
&gt;I suspect some people will look at this and not like the "impurity" this might bring to Lisp. It's interesting and perhaps somebody will find a good use for it, but on the other hand i find FAR easier to write HTML or XML using s-expressions and a library like `spinneret`. It also makes it far easier to edit as well.
I've used separate template files in other programming languages (Ruby on Rails etc.) but I find them to not be very productive because it's hard to build reusable UI components. I've used XHP in PHP/Hack, and found that to be pretty fantastic (but boilerplatey), which is where I got the inspiration for this from. 
&gt; But, SBCL is said to be the highest performance open source Common Lisp implementation. There are some benchmarks on Cliki (though old), and there CMUCL and LispWorks were also as fast. CCL is not too far behind, too. 
&gt; Also SBCL will scale very badly with CGI since that starts a new process for each request... This. I think CLISP has a FastCGI interface. That would be better. There's also CL-FastCGI, although i have no idea if it still works. As said above, it's strange to listen to the "CGI" word in `(get-decoded-time)` 
That's very helpful! It's been forever since I tried Acme on a local hosted copy of Inferno. I vaguely remember it being rigid in some ways (no way I could find to change the editor's colors or any syntax highlighting), and flexible in others (like a shell script or Rexx script, it seemed to easily pipe any command directly to the OS from selected text without any additional coding, and it had a kind of interpreter for certain file/line path commands). But, I don't recall if it had any [auto](https://github.com/ds26gte/scmindent) [indentation](https://www.reddit.com/r/lisp/comments/aax05n/corman_lisp_31_has_been_released/) logic for certain languages. If it doesn't, then your life may improve even more significantly by adding that capability for Lisp development. 
Yeah, I know. For a lisp server seems the best option is to just pay a vps and mount it for yourself or even better, have your own server running. But as for non paid hosting, or even if you donate to heliohost to get more serious service, I guess it's nice to have lisp, because all options are usually only php and sometimes perl. Heliohost has django, rails, java, net, perl, php, and now lisp &lt;3. Ofc sure there are some nice free vps to use, but I guess I'll go for a vps when I've learned something and I'll need some service to offer. Anyway, I'm very happy with the heliohost admin, since he added lisp just because I've asked him. It's strange to see a project who hears their users today, so I guess it's a very nice host to have knowing that the admin will at least listen to you and think about your requests. Django was added because a user asked too. We started a project to learn web development, so this host is fine for our needs. We've moved to heliohost because one of our members wanted django. I'm very happy to know I can use lisp now for practice a bit, even knowing the best option should be go for hunchentoot ( which I hope I will sooner or later). Also I won't have any libraries, but It's nice to see that a lisp cgi hosting exists, even today xD. For our project is a very good option because we'll have all those languages available and the others have their respective sql libraries. It also has sqlite, postgresql, mysql. And common stuff like wordpress and alike ( which I hope no member of our project will use)
Right, It seems the best option is to use hunchentoot. Also what about woo? It claims to be the fastest server in the world, but I've heard some users weren't very happy with it.
As you are learning a web development in Common Lisp, I hope you'll try a Weblocks some day. Here is a Quickstart tutorial: http://40ants.com/weblocks/quickstart.html Feel free to contact me if you'll need any help.
Each layer is linear, but thanks to multiplication the network becomes non-linear. Forward and back-propagation is all linear, though.
Yeah, I guess I'll spend some money when I'll have better experience. For what we are doing ( just started a project about web development to learn between us, and also learn how to work with other devs ), It will be a very nice option, since it supports several languages and also the admin seems to be a cool guy ( he accepted to install sbcl &lt;3 ). I was making tests with apache on my own machine and the time command to see if I did well recommending sbcl instead of clisp. I saw that the first time is a bit slow ( 0.49 ), but clisp even more ( 0.78 ). And I've tried repeatedly again and again, and sbcl was getting faster, but clisp had a limit. &amp;#x200B; The fastest time of clisp was 0.14 The fastest time of sbcl was 0.09 &amp;#x200B; Btw the test was with lynx --dump to my subdomain which points to my machine. The cgi example made by the admin of heliohost was slow, but I guess it's because ssl handshakes or alike. &amp;#x200B; I've tested in my host account with the same command, and it's a bit slow. This one has no ssl yet, so should be a bit faster, but the fastest time I've got is 0.69 &amp;#x200B; the first time I've tried it was even slower I guess, but I've tried it from the browser and the next ones with the time and lynx commands. So it gets a bit faster when you request it constantly. The slower value I've got is 1.35 for that host ( waiting a bit before tested it again ). That's sad, but I hope using lisp will compensate that speed loss. &amp;#x200B; I guess it's a win to have lisp instead of php xD &amp;#x200B; Btw, I'll take your advice about using a vps when I'll learn more and have something to offer. For practice goals, I'm fine atm knowing I could do some lisp scripting to test the power of lisp ( yes, I also need to learn lisp ) 
(Hi, unhappy woo user here.) Woo can eat flaming death, since it has a nice tendency to lose if you poke it too hard, and has an annoying dependency on libev and other CFFI stuff.
&gt; Weblocks It seems a very interesting framework. So I should go directly for weblocks instead of using hunchentoot?
Oh, I see. It uses hunchentoot
Hunchentoot is a Http server, not a framework. 
I thought weblocks was a framework with a builtin server. But I guess it's nicer this way so learn hunchentoot won't be a waste of time because weblocks is not replacing it, but built on top of hunchentoot.
Great points
Each layer is not linear. RELU, tanh, and sigmoids are all non linear functions. RELU isn't even differentiable. Weight * Output matrix multiplication is the only linear thing happening in a neural network. Backpropagation requires computing the gradient of the error with respect to the weights, this requires taking the derivatives of strictly non-linear activation functions. How can passing a matrix through a non-linear function constitute as a linear operation? Forward and back-propagation all pass matrices through non-linear functions.
How could multiplication, a linear operator, lead to nonlinearity...
Perl will never die!!!
Glad to hear that you find it helpful. Just really been liking Acme due to how language-agnostic it is when it comes to extending it. Anyways, my experiences with Inferno have been fairly good. Really like how powerful Inferno's shell when compared to even Plan 9's RC. Hosted Inferno really shines when you spend most of your time using it with the occasional outside interaction with the host OS itself. It even supports reading S expressions right out of the box. As for auto indentation in Acme, it's kind of supported by passing it the -a switch. This would copy the indentation from the previous line. For my purposes, it's good enough.
As far as I'm aware, that's only possible if the system's using GNU make. A POSIX-compliant make would need more information to know how to compile the files. Tried to write the makefile so that it's as easy to port to other operating systems as possible. You could probably even compile it using APE in Plan 9 if you felt like it and removed any gcc-specific flags.
Thanks to multiplication with the NONlinear layers in between. With only linear layers it could just be represented with a single linear layer. 
 New version of Weblocks, which I'm working on, is built on top of Clack. And Clack can use hunchentoot, woo and other http servers to serve requests. 
 x^2 
The concept of gradient descent is using local linearization of non-linear error functions. I feel everyone is correct here but we're arguing semantics. There's a lot of linear algebra being used in a system that is non-linear over all.
After juggling between hy and common lisp, I am forced to settle on common lisp. There are still features - reader macros specifically - that are pretty well developed in common lisp. And I can see the appeal of "restarts" in common lisp, that absent in hy or clojure.
Imagine a two-layer single-input single-output "network". Maybe it's (x+a)(x+b). Each layer is linear, but the total output is non-linear. Also...the activation function is the only non-linear component here. The derivative (or close enough) of RELU is just 1 if x&gt;=0, or 0 if x&lt;0.
Can all (x+a)(x+b)...(x+z) polynomials be represented as the linear expression (x+ε)?
I don't think that Rich, or really anyone in the Clojure community think that any individual thing in the core Clojure language is really novel. There's no "leap of advancement" going on, and I'm not aware of anyone saying there is. Clojure is just a language that tried to make an advancement on others by bringing together a collection of good ideas and binding them together into something cohesive and well thought-out. &amp;#x200B; Now, there are some libraries for Clojure where that may not be the case. Spec seems to be a new take on runtime contracts, and where Rich is going with it in aftermath of the recent Conj seems like a very interesting trajectory. But again, it's not necessarily anything new, it's just taking good ideas and figuring out a good way to fit them together into something practical for writing what Rich calls "situated programs".
Of course not, but that is not how any of this works. The results of the first layer enter the second as input. So you have ax +b coming out of the first. And c(ax+b) +d = cax +cb +d coming out of the second linear layer. Which is equivalent to the result of a single layer of ex+f where e =ca and f=cb +d. 
There's a few nitpicks: &gt; The function type-of returns the type of the given variable This takes a value, not a variable. For example, (type-of (+ 2 2)) does not have a variable. &gt; You see, the type of the same variable changed to simple-array.... The variable didn't have a type in the first place. &gt; Defining New Type I don't believe the type specifier is quite right, since if no array-type is given, the type is NIL which is the type of nothing (not even NIL). So, your result for `(typep '#(1 2 3 4) 'small-number-array)`. Otherwise, I can't complain, it's a pretty good introduction.
It's not (x+a)(x+b). Even without the activation functions, the output of the first layer would be y1 = x+a, y2 = y1+b = x+a+b and it would be linear according to your reasoning. But in fact the output of the first layer is already non linear with the activation functions : z1 = act(y1) and z2 = act(y2) = act(z1+b), where "act" is the activation function. So no, it's not linear.
What do Lispers think of Gilad Bracha's and Matthias Felleisen's very negative comments on Common Lisp, the way they call it, optional type system? [https://www.youtube.com/watch?v=JBmIQIZPaHY&amp;t=40m42s](https://www.youtube.com/watch?v=JBmIQIZPaHY&amp;t=40m42s)
&gt; This takes a value, not a variable. For example, (type-of (+ 2 2)) does not have a variable. I consider this as a expression mistake. Maybe the word "variable" here should be changed to "parameter". My mistake. &gt; The variable didn't have a type in the first place. I think it got mentioned somewhere that the type are bound to values instead of variables. But you are right. This sentence is misleading. &gt; So, your result for `(typep '#(1 2 3 4) 'small-number-array)` lies. This example was inspired by an example shown in [CLHS](http://clhs.lisp.se/Body/m_deftp.htm). I could not fully understand your meaning. Could you please elaborate on this?
I think that's a bug in the CLHS. You'd need `&amp;optional (type *)` I think.
I do not think so. As you can see in [Type Specifiers](http://www.lispworks.com/documentation/HyperSpec/Body/04_bc.htm) section, it says: &gt; Except as explicitly stated otherwise, the subsidiary items can be unspecified. The unspecified subsidiary items are indicated by writing \*. It is the same in `deftype`. The default value for an optional parameter is not `NIL` as usual, but `*` which means "any type".
Who are these people and why should I care what they think?
They are quite famous computer scientists. One of them designed Strongtalk, the other Racket, both of which have some kind of optional typing idea in them.
&gt; This is because Lisp types are implemented as CLOS classes. That's not quite right. Some types are classes, as required by the standard, some are not required but may be. NUMBER says "System Class" but FIXNUM is "Type". And on some implementations there's indeed no fixnum class. Moreover, (integer 0 30) doesn't, and can't, correspond to any CLOS class.
A better source would be http://www.lispworks.com/documentation/HyperSpec/Body/03_dh.htm
And if you want to talk about array types you should describe array type upgrading.
True. This one is more appropriate.
Ah I see, yes it wouldn't be POSIX make but I'm fairly certain the expected default rules are in place on BSD make and even Microsoft NMake, as is support for the `+=` operator. Fair enough though; keep up the good work.
You might mention CHECK-TYPE which is handy at the beginning of a function to check the arguments.
I don't know their specific comments, but the type system has always seemed a sort of weak point, to me. I think it works much more as a system of compiler hints than anything you can really infer with or build contracts with as you might in some more strongly typed languages. There are so many great things people have built into lisp that are paradigms from other languages, but I don't think the type system is plastic enough to accommodate something like converting a type system from another language the way people have made prolog style programming or non deterministic programing available.
Right, right. Some types are not class.. I thought of introducing the difference between type system and CLOS, but I forgot it :-D I will add it. Thanks!
Do you think that it would be much more complicated? I am considering whether to add these... What do you mean by `function` type here?
Well, at first I wanted to add a section named "type checking" or so. But later I thought it would be too complex to explain both runtime and compilation time type checking, because `declare` is a beast. So I plan to put them into another chapter related to "performance" stuff. What do you think?
I agree. Personally I really appreciate Julia's type system. In Julia you may specify a type or simple rely on the type inference. Together with multiple dispatch you may write very flexible code. But after tried it for some time...I still went back to Common Lisp because it is so hard to beat the power provided by Lisp. :-P
&gt; I consider this as an expression mistake. Maybe the word "variable" here should be changed to "parameter". My mistake. Still doesn't sound quite right. The right word is `object`. `(type-of (+ 2 2))` is `(type-of 4)`, and returns the type of object `4`.
you can declare a variable has a type `(function (fixnum fixnum) fixnum)` for example: (defun reduce/fixnum (fn array) (declare ((function (fixnum fixnum) fixnum) fn) ((array fixnum 1) array)) (reduce fn array))
That's a difficult kettle of worms since CL isn't required to do compilation type checking when you use declare. But that's independent from CHECK-TYPE. That's just used to enforce the contract of a function. If FOO is meant to be called with a fixnum and a string, defining FOO as &amp;#x200B; (defun foo (a b) (check-type a fixnum) (check-type b string) ...) &amp;#x200B; enforces this.
They don't understand what they are talking about. 
Both languages are a sort of a disaster. Racket stinks far more than CL ever did. Also, look at the people that designed CL: Steele, Moon, Gabriel, Weinreb. Titans.
Meh, it's correct but mostly for fun. It's true that if the user lies about their types **and** has a low safety setting you can easily get weird results, and perhaps even segfaults. But that's not a very nuanced argument, because you can still use the type information to make safe decisions. The more interesting parts of CL's type system which does limit it regarding static analysis are things like SATISFIES, making it trivially turing complete. CL-USER&gt; (defun please-die (x) (declare (type fixnum x) (optimize (safety 0) (speed 3) (debug 0))) (the fixnum (expt x 2))) WARNING: redefining COMMON-LISP-USER::PLEASE-DIE in DEFUN PLEASE-DIE CL-USER&gt; (please-die "hello") ; Evaluation aborted on #&lt;SB-SYS:MEMORY-FAULT-ERROR {100BCA9DC3}&gt;. CL-USER&gt; (please-die "hello") #&lt;unbound marker {BD1F9A526C5FF351}&gt; CL-USER&gt; (please-die "hello") #&lt;unknown immediate object, lowtag=#b1001, widetag=#x39 {BD20AC1BD15C7C39}&gt; CL-USER&gt; (please-die "hello") ; Evaluation aborted on #&lt;TYPE-ERROR {100BCDD123}&gt;. CL-USER&gt; (sorry couldn't be bothered to get this all into proper formatting)
Why does Racket stink far more than CL did?
Bracha actually praises Lisp way of doing things (late binding, extensibility, liveness, etc.). He is originally a Smalltalk guy.
Because it's rooted in academia and also has the ideological stench that's so prevalent in Scheme-land. I can accept most of the compromises behind Common Lisp because they are pragmatic and helpful in me trying to use the language to solve real-world problems. Racket on the other hand I find mostly useless. Interactivity, performance, flexibility are all sacrificed in the name of "cleanliness". 
&gt;parameter In Common Lisp a parameter is a variable in a function definition, which gets bound to an argument when calling the function. TYPE-CASE is unrelated to parameters.
They just didn't update their website showing Lisp in the menu. https://www.heliohost.org/#whitelist but well done.
I see, you're right then.
Yea, I certainly didn't mean to suggest I'm not using lisp for this reason! I still use it and enjoy it more than other languages. This falls more into the "ways I'd like to see common lisp v2 extend the current language."
I looked into Inferno only briefly years ago. Perhaps, shortly after it was open sourced. It was quite interesting, but I did not go deeply into it. However, I've read that while one could develop for it in C, I seem to remember reading how its primary application development language was supposed to be Limbo which would run on a VM called Dis from inside the Inferno environment. From what I've read of it, Limbo has its advantages and it has influenced other languages by the same author. Although, in retrospect, I wonder if it really was appropriately named considering it's current state of development. I also recall reading that the authors considered using Java as an application development language within Inferno, and maybe even had a prototype, but Java may have still been going through changes at the time or something to that effect. It's too bad they didn't consider using an ANSI Common Lisp implementation like CMUCL instead. The only Lisp I'm aware of that was developed for it (using Limbo) was a [Scheme](https://code.google.com/archive/p/inferno-scheme/) from [this](https://web.archive.org/web/20170315003558/https://www.cs.drexel.edu/~bls96/) [author](https://web.archive.org/web/20160907194512/https://www.cs.drexel.edu/~bls96/frontmatter.pdf). Have you been able to get a Common Lisp compiled and running inside Inferno's environment and callable from Acme?
&gt;Because it's rooted in academia and also has the ideological stench that's so prevalent in Scheme-land. Not good reasons to dislike Racket, but at least it was informative enough for me to know I could disregard the rest of your post, so thanks for the warning.
&gt; Are Gilad Bracha and Matthias Felleisen of the same caliber? Will they be remembered? Yes? Gilad bracha is certainly a Titan and also cares deeply about interactive development
Hmmmm, reasonable. Actually `object` is the term used by CLHS. I was afraid that `object` is not straightforward. You are right, it is better to just use the correct word and explain it if necessary.
True. `Object` is a better word.
Understood. As for `declare`, currently I want to add it to another chapter related to performance or so. In my humble opinion *normally* you do not really need to `declare` the type for trivial tasks.
Yes. `declare` is implementation dependent while `check-type` is not. IMHO `check-type` is hard to use because it adds burden to run-time. Maybe a section of "type checking" that introduces both would be better. Thanks.
Ha, I am not a Lisp priest anyway. I am not satisfied with the type checking functions of Lisp. IMHO type checking is important because it may prevent some serious errors as early as possible. But `check-type` slows the program down and `declare` is implementation dependent.
Yes; [PicoLisp](http://folk.uio.no/jkleiser/pico/doc/ref.html#ev). 
Thank you so much!
When Python started, one of the reasons I for one took to using it was he contrast to Perl. It was scheme-like in simplicity, and it was hard to be obscure. I'm sorry to see that they've gradually accreted more and more. In particular, this syntax can be hard to make out, in my opinion.
&gt; a language feature Lisp has had since the beginning Half of it. The other half would be something like `bind` here, some version of `let` that has neither an implicit `progn` nor a scope of it's own: (when (bind line (read-line stream nil nil)) (frob line)) 
If I understand correctly, this feature is essentially `when-let`.
(require prfi/572)
I agree. I've been using Python for over a decade and I feel they've lost sight of some of the core ethos of the language in the last few years. 
This would also work if we had the full "power" of this new Python assignment expression in Lisp: (progn (var line 1) line) ;;=&gt; 1 The point is that `setq` etc are "assignment expressions", but they *only* assign to variables that we bind with `let` and friends. The scope of these bindings however is confined to the expression.
What a misleading click baity title.
This is an apples to oranges comparison when it comes to Lisp since the real feature is every statement being an expression, which of course Python still doesn't have. PEP 572 is yet-another kludge bolted on top of a collection of kludges to fix imbalanced in a (crappy) language. Lisp doesn't need this sort of kludge because it is internally consistent and based on an evaluation model that allows for that internal consistency to propagate all the way to the top. End result being a language that feels seamless and organic and not a collection of gross hacks written by people who should have known better.
Though Lisp has had assignments as expressions from the early dawns, the idiom that is being promoted in PEP 576 is more common in C: if (match := pattern.search(data)) is not None: do domething with match vs if ((c = getc(file)) != EOF) { /* process c */ } In Lisp, we hack up an anaphoric macro for this sort of thing.
Am I missing something or is this pretty much analogous to how the `=` operator works in C? 
I've done most of my experimentation on P9P's version of Acme; however, I did do some work on Inferno's Acme over on a Window's system. I never did use any native lisp for Inferno like the one you posted. Instead, I simply used the os command in order to run SBCL within a win in Acme. I did compile Common Lisp and C programs from within Inferno using Inferno's Acme. The way I did it in Windows was issuing this command: `os cmd` If you were doing this in some sort of Unix environment, I suppose you would replace cmd with whatever shell you were using. After that, you would just issue a cd command to the directory you were working on and perform your typical development commands from within the win window.
\&gt; because it adds burden to run-time using DECLARE may have the same effect.
Æh, I dunno that that is something I'd accuse Common Lisp of being. I love it, but it's very clearly a compromise language and we're still paying the price of that.
That's literally it. 
Thank you for the tip and screenshots. When I first looked at Inferno, I remember wondering if a small and capable distributed OS like that could be the basis for a portable GUI based C and Common Lisp environment, rather than the current GUI based C and Limbo environment. Now, with the advent of [WebAssembly](https://www.reddit.com/r/Common_Lisp/comments/au0dmv/more_iup_gui_stuff/eh74nfg/), I think that something similar will come about not just for Lisp, but other languages. The web-browser may become a type of hosted distributed GUI based environment, if not a true [OS](https://win95.ajf.me/), for certain applications.
https://imgur.com/a/q1auYVA
It's missing tests and polish, but I think it could actually be useful to someone else, at this point. &amp;#x200B; I'd appreciate any feedback and contributors. I haven't gotten to use it for anything beyond testing yet.
It's meh. I mean, I'd love a way to do this, this is primarily what one does? I do it in lisp as well, especially in clojure dealing with java objects. &amp;#x200B; But in java it's most of the time (especially dealing with legacy code) \`\`\`java it = getElement(es); if (it != null) { doSomethingWithIt(it); } \`\`\` Java Optionals kinda help with that \`\`\`java Optional.ofNullable(es) .map(e -&gt; getElement(e)) .map(...) .orElse(...); \`\`\` But it would be great to have some kind of \`if-let\` \`\`\`clojure (if-let \[it (is-this-what-we-think-it-is? element)\] (do-something-with it)) \`\`\` On the other hand, one should do something along \`\`\`java it = getElement(es); if(it == null) { return ; // whatever you want to return, Optional.empty(), ... } doSomethingWithIt(it); \`\`\`
Except for maybe creating a new scope? (An unclear scope at that, as is the Python tradition.)
Does it? That'd be really weird, since the scope that makes sense depends entirely on the surrounding context.
How's the cold start time?
For the example lambda in the repo, I see in the 40-60ms range for most calls (total time) and then single digits that are likely when it reuses the iterator. Was playing a little to see if compressed runtimes slow it down, but I wouldn't say I'm sure enough yet. I'd say compressed runtime looks closer to 60ms avg and uncompressed closer to 40-50ms?
I guess this is not specific to this recipe, but I was curious to know how did Lambda store local resources, more specifically in this Common Lisp context, Quicklisp sources and fasls. Can I access a large code base or am I limited to small scripts?
You can dump a core with all the libraries preloaded.
As already mentioned, try Racket, eapecially if you find plain Scheme too chatty. Idiomatic Racket code is very concise and beautiful. Perhaps not as concise as Clojure can sometimes be but I found it better overall.
You're not wrong, but Python always did that, unless I missed something.
I wrote a macro called ‘autoquasi’ in Scheme recently for use in a DSL for non programmers. It does just what you describe, in a nested fashion.
Cool! Can you share it?
Sure, it looks like this. If you have a list with an identifier in the first position that you don't want to be interpreted as a function call you can add a ! as the first element to 'escape' the list. (define-syntax auto-quasi (lambda (x) (syntax-case x (!) ((_ (! v ...)) ;; ! escapes, don't evaluate (syntax (list (auto-quasi v) ...))) ((_ (v rest ...)) (identifier? (syntax v)) (syntax (v rest ...))) ;; evaluate as function ((_ (v ...)) (syntax (auto-quasi (! v ...)))) ((_ v) (syntax v))))) It gives you this: (auto-quasi (1 "hi" (+ 2 2) (5 (+ 5 5)))) =&gt; (1 "hi" 4 (5 10))
Hi, ACME allows for selecting text within delimiters (ie if you double click on the character just after an opening parenthesis, it will select all text up to the closing one). Is this not sufficient for your needs ? Looking at the code I see some potential issues: \- any file with a size greater that BUFSIZ will lead to a segfault (BUFSIZ is guaranteed to be 256 according to standard, so not that big) \- characters or escaped delimiters are not taken into account, for instance (a b #\\) c) or "hello \\"world" &amp;#x200B;
Web Framework: [http://40ants.com/weblocks/quickstart.html](http://40ants.com/weblocks/quickstart.html)
&gt; My lexer doesn't works very well for parenthesis. Your lexer is doing too much work then. Lex the string into a list of symbols and use the shunting-yard algorithm modified to handle unary operators. 
The reason it's actually: [https://github.com/ryukinix/lisp-inference/issues/18](https://github.com/ryukinix/lisp-inference/issues/18)
But thanks for the suggestion!
Oh in that case the lexer is doing too little haha :-).
Yes! :)
Online test: [https://mybinder.org/v2/gh/yitzchak/common-lisp-jupyter/master](https://mybinder.org/v2/gh/yitzchak/common-lisp-jupyter/master) Hacker News Discussion: [https://news.ycombinator.com/item?id=19302515](https://news.ycombinator.com/item?id=19302515)
&gt; buf[i] = NULL; `NULL` is a pointer constant; it may be defined as `((void *) 0)` in any conforming C implementation. Don't assign that to an lvalue of type `char`. 
This is perfect! I've always needed a simple web interface to my lisp servers. Is all the code needed for the web interface in [lisp-inference](https://github.com/ryukinix/lisp-inference)/[web](https://github.com/ryukinix/lisp-inference/tree/master/web)/**webapp.lisp** ? 
Yes, it is. Be glad to the Russians Common Lisp developers! =&gt; [http://40ants.com/weblocks/quickstart.html](http://40ants.com/weblocks/quickstart.html)
I'm reading the book as well and also going through teachyourselfcs.com to better my programming skills as never earned a CS degree (I got an IT degree). I'm find the book to be very good at making understand the small details that are most important to a program. It's making slow down mentally and really understand the components of whatever code I'm working on. At the same time it's helping me think quickly because I'm noticing important patterns 
It would be easy to do in Common Lisp, this is my version, does what you ask: ``` (defmacro auto (l) (let ((fpos (car l))) (cond ((not (symbolp fpos)) `(quote ,l)) ((or (functionp fpos) (fboundp fpos)) l) (t `(quote ,l)) ))) ``` Usage: ``` &gt;(auto (+ 1 2 3)) 6 &gt;(auto (plus 1 2 3)) (PLUS 1 2 3) ``` 
&gt; you can add ! as the first element to 'escape' the list &gt; `(auto-quasi (1 (sin 0.5) (! a b c)))` How it is this different from putting `quote` instead of the `!` symbol? 
FYI: Have you seen [this project?](https://github.com/y2q-actionman/cl-aws-custom-runtime-test) Thanks for `lisp-images`!
Not sure if works with Lisp, but from what I've read of compilers and parsers, generally only 1 character is fine for lookahead
At most one. For basic lisp (s-exprs **without dot notation** plus quote macro) without any validation/error messages there are no lookaheads needed. Including the dot notation you need to lookup one token when parsing stuff after an opening bracket. *You may need a 1 character lookahead for tokenization, depending on how you handle it.* &amp;#x200B; If you read elixir, here's how to do the dot-less version: [https://github.com/drcz/scheme-workshop-for-prosperity-and-happiness/blob/master/part2--lisp-in-lisp/elixir-eval-and-parser.exs#L79-L97](https://github.com/drcz/scheme-workshop-for-prosperity-and-happiness/blob/master/part2--lisp-in-lisp/elixir-eval-and-parser.exs#L79-L97) and if you prefer ansi-C, there: [https://github.com/drcz/drczlang/blob/master/c-src/parser.c](https://github.com/drcz/drczlang/blob/master/c-src/parser.c) &amp;#x200B; I believe there are plenty of better implementations though, I think this one was neat (C as well): [http://web.sonoma.edu/users/l/luvisi/sl3.c](http://web.sonoma.edu/users/l/luvisi/sl3.c)
I guess no lookahead is needed, really. You only need to remember which state the Lisp reader is in right now, and what character you are working on at the moment. You could take a look at the way the Common Lisp reader is defined at http://clhs.lisp.se/Body/02_b.htm - I do not think it requires any lookahead at all.
You'll only ever need one character of lookahead, and [PEEK-CHAR](http://clhs.lisp.se/Body/f_peek_c.htm) so happens to give you one character of lookahead (and can jump whitespace, which is useful).
Crap, I deleted my post. For basic S-expressions without the dot notation (and without any error messages/validation) you need no lookaheads. With the dot notation you need one, for parsing tails of the list. If you read elixir, here's how to do the dot-less form: [https://github.com/drcz/scheme-workshop-for-prosperity-and-happiness/blob/master/part2--lisp-in-lisp/elixir-eval-and-parser.exs#L79-L97](https://github.com/drcz/scheme-workshop-for-prosperity-and-happiness/blob/master/part2--lisp-in-lisp/elixir-eval-and-parser.exs#L79-L97) If you prefer C, there: [https://github.com/drcz/drczlang/blob/master/c-src/parser.c](https://github.com/drcz/drczlang/blob/master/c-src/parser.c) I might be missing something but it always worked for me. &amp;#x200B; For full S-expressions in C consult first this beauty [http://web.sonoma.edu/users/l/luvisi/sl3.c](http://web.sonoma.edu/users/l/luvisi/sl3.c) &amp;#x200B;
Yes! It was useful to see someone else working on it. Last I looked at it, I think it was more of a proof of concept. I think both princess have been growing up next to each other. I just made a few different choices. Also, you're welcome! Sorry I'm behind on updating them, recently.
I can't think of any ANSI Lisp situations that require more than one character of lookahead. Or possibly token. Even the two-character macro dispatch syntax doesn't require lookahead. What this means is that can have syntax like *&lt;x&gt;{&lt;integer&gt;}&lt;y&gt;*, where *&lt;x&gt;* and *&lt;y&gt;* are characters, which are arranged in a generic way by entries in the read table. When the reader sees the character *&lt;x&gt;*, it then has to collect an optional *&lt;integer&gt;* token and one more character. Only then can it decide which function to dispatch. Each such pair of characters can be assigned to a different function; you have to read both characters and the optional argument before identifying the function. Examples of this are #123=(x #123#). Here two instances of it occur, "sharpsign equals" and "sharpsign-sharpsign". Both have an embedded integer. However, this isn't really lookahead because when the reader processes the first character *&lt;x&gt;*, there is no question that it's dealing with a dispatch macro character that requires another character, possibly preceded by an integer token. At no point does it have to backtrack and/or change its classification of that character. Some situations in ANSI CL scanning require multiple characters of lookahead, effectively. Some tokens have two levels of syntax. For instance if we are reading `12345`, we do not know whether we are dealing with an integer or symbol. That is because the a character like `A` might follow, giving us `12345A`, which changes the interpretation of the `12345` before it. The reader algorithm works by simply accumulating "constituent" characters (characters that may constitute tokens) into a token, until some non-constituent character is encountered which terminates the token, or end-of-stream. The accumulated characters are then analyzed when the token is turned into an object. 
Discussed here https://www.reddit.com/r/lisp/comments/aofq13/lisp_and_the_foundations_of_computing_talk/?utm_medium=android_app&amp;utm_source=share
1
I think your web interface might be vulnerable to code injection using #. if you use READ-FROM-STRING.
Ouch, this is terrible if is true possible. &amp;#x200B; But since the expression received it's quoted as a list expression, how can this still happens? Do you mind to elaborate on that?
Well...you could do something like `#.(progn(sb-ext:run-program"/bin/exploit"'("foo""bar"))'a)` which evaluates to `a`, but the exploit is run (on SBCL).
&gt;\#.(progn(sb-ext:run-program"/bin/exploit"'("foo""bar"))'a) Wow, didn't know the \`#.\` syntax. This is terrible. The read-from-string came from this contribution: [https://github.com/ryukinix/lisp-inference/pull/23](https://github.com/ryukinix/lisp-inference/pull/23) &amp;#x200B; I have a earlier version that didn't use it. Maybe I should revert it.
You can bind `*read-eval*` to NIL to prevent that form of attack, which isn't too hard.
Thank you for the help. I didn't know about this detail! Pretty nice :)
Sometimes, the Windows builds are not updated. Anyone has built one from source?
One character of lookahead is needed. This happens when, for instance, parsing (FOO). While scanning the symbol FOO, you will at some point read the closing parenthesis, which is basically a lookahead, because you will have to put back that character for later consumption. Alternatively, you can also use PEEK-CHAR and only consume a character if it is not a delimiter.
read-from-string for user input is a bad idea regardless of \*read-eval\*. Consider that it can intern a symbol in any package. Now consider that these symbols will never be garbage collected and will accrue with time, eventually filling all your RAM.
Um... tl;dr?
A way to improve the o notation of lambdas.
I know some of the issues. There is a planned task to do the string parsing properly at: https://github.com/ryukinix/lisp-inference/issues/25 This will be solved at LL(1) parser using meta-sexp.
&gt; Web Framework: http://40ants.com/weblocks/quickstart.htm At: http://40ants.com/weblocks/installation.html &gt; There is a comprehensive installation guide on the main web site: http://weblocks-framework.info/installation ...oops?
Take a look in this important note at the home of [40ants.com/weblocks:](https://40ants.com/weblocks:) \&gt; This is not original Weblocks, it is a fork with completely changed API. \&gt; Read [Quickstart](http://40ants.com/weblocks/quickstart.html), because all other sections were not updated yet and have incomplete or outdated information. &amp;#x200B; To install it I recommend these steps: &amp;#x200B; \`\`\` (ql-dist:install-dist "[http://dist.ultralisp.org](http://dist.ultralisp.org)" :replace t :prompt nil) (ql:quickload :weblocks) \`\`\`
Ha, PEP 572 strikes again! I'm going to poor more oil into the elitist fire, but still. My way of explaining to people not in the programming world, who come to hear about Python's popularity is that it's kind of like MacDonald's of programming world. A technology which allowed to push the quality bar even lower, but still sell due to some weird aspect of simplicity of work for the grunts and corresponding price. This PEP is kind of like trying to create BigMac with creme brulee. Idiotic at heart, but should make people who like creme brulee happy, I guess, since they used not to like BigMacs all that much before.
So perhaps they should fix the link, if it's misleading?
I didn't do this, but from looking at their documentation (interesting project!) it seems that they position it more as an application server. Thus, my guess would be that the deployment wouldn't be different, in principle, from how you'd deploy Tornado for example: i.e. put some load-balancer in front of it (I think Amazon already gives you one: ELB), or use the more generic approach: us ngnx as a load balancer.
I just rewrote it maybe it will be a bit easier to read.
I'm not sure what the lambda calculus has to do with your scenario. It seems like you could replace every instance of "lambda term" or "lambda calculus" with "[S-expression](https://en.wikipedia.org/wiki/S-expression)" without losing any meaning. This seems especially true because you mention "interpreting a lambda calculus [term]" in an "outer program". What do you mean by interpretation? Alpha-conversion, and beta-reduction? Or something else? Is the outer program also implemented in the lambda calculus, or in Lisp? In short, am I missing an important connection to lambda calculus here? Or are you just asking about efficient ways to express data using S-expressions?
Oh yes, were absolutely could. The protect terrifies me. We already have so many ancient irrelevant archaic crap inside all current OSes. https://twitter.com/msimoni/status/1101103875803754497
Thanks for the refactoring and the advice. I didn't write this program using Plan 9 C since, as far as I know, there hasn't been a Plan 9 implementation of Common Lisp yet. Wrote it in C89 to ensure compatibility with as many platforms as possible. Anyways, the new iteration of the program now has checks to prevent a buffer overflow.
Thanks for letting me know that BUFSIZ is guaranteed to be smaller than I thought it was. Still, it was sloppy of me in not putting in checks to prevent a buffer overflow. I haven't added support for escaped characters yet, but I did fix the issue concerning buffer overflow. I'll probably add support for the escaped characters at a later time.
It seems to be like lambda terms are denoted by the variable `term`. 
My confusion stems from the fact that the lambda calculus has no single, universal encoding for objects such as lists and numbers. Encodings do exist (such as the Church encoding and the Mogensen–Scott encoding). E.g., under the Church encoding, it's understood that when we write the numeral "2", it's really a shorthand notation for the lambda term, "λf.λx.f(f x)". But if we don't mention Church encoding, then "2" has no "default" LC representation to fall back on, and "λf.λx.f(f x)" has no universal meaning other than its "obvious" one. Similarly, (non-universal) encodings exist for pairs and lists. But the OP hasn't indicated which encoding he's using. He's just written a bunch of sexprs, and has skipped any statement on how they are to be represented in LC. Yet he then claims that "this is to speed up the O notation of certain transactions in the lambda calculus." That doesn't make sense. Without knowing the encodings of these expressions, there is nothing at all that can be said about the performance of evaluating any of them in LC. For example, you could design a numeral encoding in LC which requires O(2^n ) characters to represent the numeral n. Similarly for lists. What can we say about the performance of his proposal then? My concern is that the OP is regarding Lisp as a language that was inspired by the lambda calculus (true), and therefore conflating Lisp and the LC as the same thing (false).
What's the channel?
/u/fisxoj, have you tried doing the same for Azure Functions? 
Here is my sort of reasoning: 1. Lambda calculus is a very enviable abstract machine. It is totally abstract and purely functional in the true sense of the phrase. 2. Lambda calculus on modern machines has a poor o notation 3. Systems like lisp give s-expressions the ability to do anything that say c or assemble could do; however these resulting systems are far less abstract. 4. Therefore, perhaps a middle-ground can be reached. Something that tries to keeps some of the abstractness of lambda calculus while not compromising on O notation (although it does still compromise on speed this is less important than o notation at scale.) 5. Perhaps using the lambda calculus like a processor with limited registers to hotswap lambda terms in and out of memory can improve the O notation without sacrificing abstractness. Perhaps a system built in this way can compiled between this method and the pure lambda calculus interchangeably.
Correct. In this current encoding index 0 is a lambda term which may be an integer value and the number of trailing empty lists indicates the "operation code" of the outer machine. There may be a more efficient way to encode this. I am certain there is also a way to encode it so that multiple instructions can be output at once. I simply tried to design it such that like lisp it can be manipulated into whatever else you can imagine. I want to make it clear that my encoding for the operation codes is probably not the most efficient. I also want to point out that determining which operation to use with the number of trailing empty lists might not be the most efficient way to count either. It is just one that is easy to demonstrate visually and relatively simple computationally. It fails when you get into higher number of opcodes.
I intended to leave the specification vague. You can use whatever encoding you'd like. I use church in coding except I encode numbers differently as shown at the bottom of my post. The key in speeding it up depends on it. By encoding numbers in the way I suggested a lambda term can be parsed into an integer that represents the index of an array. Once an integer has been parsed, from that array a lambda term can be retrieved at o(1). Normal church encodings require numbers to be encoded as the length of a list. This is not suitable for the design I am specifying. You may use church encodings for computations within the machine however if you want to request a piece of data outside the machine you must encode it as Ive listed in the bottom of my post.
I have Windows 10 x64 build for 1.5.0 with MSI installed. Built this morning on MSYS2 with SBCL 1.4.14 with all tests passed. https://1drv.ms/f/s!AuT7-6xtZ_8EhNxDfGe4QpqvzMEPew
If anyone wants to do the same. The work flow is below. 1. Install latest SBCL windows binary 2. Install Msys2 64 3. Install MingW64 toolchain 4. Install WiX Toolset 5. Add **installlocation**\msys64\usr\bin to windows path 6. Add **installlocation**\msys64\mingw64\bin to windows path 7. Download and extract latest SBCL release tarball 8. Open Powershell or cmd and navigate to SBCL directory 9. run 'sh make.sh' 10. run 'sh tests\run-tests.sh' 11. run 'sh make-windows-installer.sh' 12. MSI installer is now in output directory
I don't think those sexprs are intended to be represented in LC; they are artifacts of a machine (evidently based on Lisp concepts) that somehow acts on representations of LC, but those are not given. We don't know whether the LC supports numbers at all, or is just pure LC. It does have to support functional terms like λf.f, but will that be (lambda (f) f) or something else? That is not shown. 
The video resolution seems too low, please consider reuploading --- youtube might have reencoded it
I think it just needed some time for reprocessing. I can select 720p and 1080p now. Let me know whether it works for you.
7pm UTC happens when this comment is 9 hours and 32 minutes old. You can find the live countdown here: https://countle.com/ZUpUegR9C --- I'm a bot, if you want to send feedback, please comment below or send a PM.
All the resolution options seem available now. Also awesome stuff Martin, it's always lovely to see more cando &amp; clasp content.
Always cool to see news about Cando
Fantastic work. I had not heard of the ETL conference until you just mentioned it. My wife and I just peruses the conference site, but probably not time to make arrangements and attend. Beautiful venue! I hope the major talks are available on YouTube. Sorry to be off topic, but has anyone used Clasp with deep learning frameworks like mxnet or TensorFlow?
ELS conference site: https://2019.programming-conference.org/track/els-2019 Looks like a cool location. If I could just get the registration website to accept any password I try to use... Tensorflow is annoying to use from most languages. The only complete API is the python API. They have a C++ API, but it is mostly for fast feeding (Python isn't just very slow, it is also unable to use multiple CPUs for multiple threads, so the pipeline can stall if your math engine is fast enough). If you want to interface with something that is C++ (as opposed to C), then Clasp should be your choice. All/most other implementations can only interface to C++ code by going through a C interface, which is really annoying. Clasp has real C++ integration. It asks LLVM (the compiler toolkit is uses) to give it all the metadata about the C++ classes and makes direct interfaces to CLOS. ThirdLaw people are a bit skeptical about machine learning. But we are looking into genetic programming for molecule design.
They only accept a certain subset of special characters IIRC.
Very interesting; I thought the C++ bridge was somehow specific, but ... are you saying we can use arbitrary C++ objects from Common Lisp? If yes, this is very exciting: what is the "kind" of C++ artifact that needs to exist for this: headers, an object file, a library, something else? 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/chemistry] [Here is what we are doing with Common Lisp - computational chemistry in cl-jupyter notebooks](https://www.reddit.com/r/chemistry/comments/ay3m08/here_is_what_we_are_doing_with_common_lisp/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
gavino... is it you?
If you are watching in the first hours after upload the episode starts at 10:00
I am not the gavino you seek.
Clasp picks this up from LLVM. All the structure you need about C++ objects you can ask about in the LLVM libraries. Clasp itself compiles to LLVM as its last stage. In the end you have object files all made by LLVM, some from C++, some from Lisp. There isn't literally universal support. Template classes for example have to have additional hand-written support. I don't think there is any support for anything the C preprocessor has munched up (as in, access the before-preprocessing symbols). But yes, the Cando chemistry package is a large number of proper C++ classes that are available as classes in Lisp, without going through a C layer.
... link got lost: https://umap-learn.readthedocs.io/en/latest/#
&gt; https://umap-learn.readthedocs.io/en/latest/# Uses Numpy for number crunching and Numba for JIT LLVM compilation... Perhaps [MAGICL](https://github.com/rigetti/magicl) which provides binding for BLAS and LAPACK could be used? Let's hope some |lisp number-crunching hacker| challenges it by using those, maybe `cl-cuda`, `lparallel`, and maybe CLASP!! 
Thanks for the clarification!
I have not! This is already more than I have time for, but if they use a similar interface or something we could explore it.
Based on number of Google searches. Well that makes sense, since you can't program in Java without searching the web for "How the heck am I supposed to program in Java?"
You may modify your implementation's RC file with the first two lines you mention. This way, they will be executed each time you start your Lisp image, and then you can just `(ql:quickload :app)`. Just a question - is there any particular reason why you do not use `~/quicklisp/local-projects/`?
No reason, really. Would it be suggested to use this as my daily common lisp workspace? 
Did you try https://portacle.github.io?
The very minimal answer could be: According to *Recursive Functions of Symbolic Expressions and Their Computation by Machine*, one only needs symbols, lambdas and conses to make a Lisp system. The rest really is sugar. Though, macros, generic interfaces (and other niceties for dynamic typing) and a productive programming environment are hallmark features of Lisps which might make a language more recognisable as a Lisp.
Agreed. You can essentially boil it down to plain lambda calculus if you want to. I think the entire point about Lisp is that it doesn't have a "minimal concept"/core, it's so flexible that it can be bootstrapped in many different ways.
be completely encased in parentheses
Any projects you place or git clone into `~/quicklisp/local-projects` should be automatically found by quicklisp.
http://www.paulgraham.com/diff.html
Yes - it's the default location for QL local projects.
doesn't or does?
Doesn't. It has multiple cores.
https://www.reddit.com/r/lisp/comments/9wghp0/the_scratch_castle_alternative_lisp_formatting/e9l9xgr/
I'm not criticizing, though. I actually enjoy the parentheses. And I know, there are other languages that are also considered lisps that are not encased in parentheses. 
http://www.nhplace.com/kent/PS/Lambda.html
quicklisp depends on ASDF to load the "projects" or systems. You can configure ASDF to find your projects on your machine. See the manual: https://www.common-lisp.net/project/asdf/asdf.html#Configuring-ASDF-to-find-your-systems
I like this guide: https://xach.livejournal.com/278047.html. I seem to remember running in to trouble with that asdf setup at some point -- my current setup renames the `projects.conf` file to `50.conf` and uses `"/full/path/to/projects/dir/"` instead of `(:home "src/lisp/")`; so one of those alterations might be necessary. 
What's so special about cons vs basic memory access in your opinion?
If you would like to have a reproducable builds for your projects, I recommend you to use Qlot: https://github.com/fukamachi/qlot It allows to pin quickdist versions in qlfile.lock file and separate installed libraries for each project.
Maybe some \`with-\` macros could be replaced by closures. But what closure does \`defclass\` map to?
Haskellers think that template Haskell is all the macroism they need, and complain about stuff they could use macros for. That's why I am excited about hackett :)
well in LoL the author says that let over lambda is basicall object creation, and iterating once more (let over lambda over let over lambda) allows for class definitions (static variables).
Lambda calculus was not actually part of the original LISP (as per Steele &amp; Sussman 1978: 4): &gt; Contrary to popular belief, LISP was not originally derived from Church's λ-calculus [Church] [LISP HISTORY]. The earliest LISP did not have a well-defined notion of free variables or procedural objects. Early LISP programs were similar to recursion equations, defining functions on symbolic expressions ("S-expressions"). But, following in Graham's suggestion that McCarthy discovered LISP rather than inventing it, I would say that McCarthy just hadn't discovered that lambda calculus was a necessary component.
&gt; one only needs symbols, lambdas and conses to make a Lisp system So Clojure isn't a Lisp by that definition, right? Since `cons` isn't defined in the same way.
That's a real surface-y feature. And anyway you can of course have atomic elements not enclosed in parens. 
Shriram Krishnamurthi did a talk, [Swine before PERL](https://cs.brown.edu/~sk/Publications/Talks/SwineBeforePerl/), and at one point in that talk, or in the Q&amp;A afterwards, he addressed the idea of using a partially evaluated language instead of one with macros. I think it was in response to a question from the audience, but haven't located the time at which it was fielded. It might have been a question during the talk rather than in the post-talk Q&amp;A.
Thanks, that's exactly the kind of pointer I'm looking for :)
it's at 33:50
I like what clojure and scheme do to break up the visual overload with parents, though I'd prefer more parents than more syntax. I work daily in javascript and see how the cognitive burden of doing the same thing so many ways simply by changing the flourishes of syntax is just frustrating. Not to mention the setup needed to keep the formatting integrated into your workflow, which is still not fool proof. 
I pop symbolic links down in local-projects to wherever my actual workspace is. Q
Well, conses can be strung together without side effects, and they're garbage collected. I don't know if conses were around before Lisp, but I know GC was invented by McCarthy so programs wouldn't have to deal with memory management.
I remember Racket's conses are also immutable, but JMC never used side effects (except label? I'm not sure) so it wouldn't matter.
They are focusing on macros that do have equivalents in other languages, namely iterators. True compile-time computing to build code at compile time, so that all your assumptions during development stay in one single place each, it not about a random set of with- macros.
I wasn't thinking about mutability, but rather that Clojure doesn't actually create cons cells: https://8thlight.com/blog/sarah-sunday/2017/01/24/common-lisp-clojure-cons-cells.html