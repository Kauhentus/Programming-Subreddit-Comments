I believe it's on by default, now.
The oldest variant I know of (it's not really the same) is the syntax mechanism in Symbolics Genera. Package names are local to a 'syntax'. That way you could for example have multiple Lisp dialects (each with a syntax) and each have its own LISP and USER packages.
Great job fukamachi san. (ql:quickload :docbrowser) (docbrowser:start-docserver portnumber) -&gt; if already some webservice is running on 8080
Still no threads on OpenBSD :(
I haven't thought about this until you mentioned it now. This is just highly speculative and you all may downvote me if you want, but I thought it is an interesting correlation: Perhaps Lisp programmers are so used to presenting data in a tree format that they are content when they have the basic HTML down -- after all, a basic HTML page is almost like a Lisp program only with XML instead of s-expressions.
Perhaps Lisp programmers are just old enough that they learned HTML in the 90s and haven't kept up with the cool stuff that came out in the past couple years.
If that were the case, I suspect we would see a lot more `&lt;FONT SIZE=4&gt;&lt;FONT COLOR=RED&gt;`.
This is just me speculating, but could it be that many Common Lisp implementations and libraries have been around for a long time, and haven't had a chance to update their documentation? Furthermore, almost every week there's a new javascript library to do something, or a framework for node.js, and since there's so many, and they're all quite new, they need to stand out from the crowd, thus making it important for the creators to spend time making a nice webpage. Of course, maybe if Lisp people spent more time trying to sell their libraries and frameworks, more non-lispers would be interested in them?
I *did* refresh a bit in the 2000s.
That certainly describes me.
Perhaps in attractiveness, but based on well accepted design guidelines, I would be completely confident in saying that you would see improvements in objective usability metrics by simply adding the more explicit separation of data, as was done above.
The only problem would be if these websites were not readable in a text browser like w3m. I tend to look at lisp documentation inside of emacs with w3m. Just as I reference the hyperspec within emacs with w3m.
You seem to have me confused with someone who thinks the cover of books matters, along with whatever color someone's dress is. I basically don't care. I want functionality, not web 2.0 shinies and whatever the design fad du jour is. Yes. There are fads. Yes, it's hilarious watching designers go ape about someone who isn't following them. Because it's incredibly shallow. When I *do* care, I only care enough to install Twitter Bootstrap because it's sufficient unto the task. If *and only if* I was marketing my idea to shallow or mass audiences, I would hire someone who knows how to make things look all shiny and faddish. edit: Further, I want to point out that your modification is not nessiscarily good. Is it the right shade of grey? Do you want borders? Perhaps what really should be done is italicize the header, not grey the content? Should you have a faint border around the content so it pops? *I have no idea*. I am not a designer. I know just enough to know it's an art and a hard problem (leaving aside the question of empty-headed fads and focusing in on design that matters), so I don't bother myself it.
&gt; It's about as far from slime/emacs as I have ever gotten You are aware that [you can use SLIME with JavaScript](https://github.com/swank-js/swank-js), right? Of course it's nowhere near as nice as using SLIME with Common Lisp, but it's by far the most comfortable JavaScript development environment I have found. It's very strange that it's not more widely used.
Interesting how proud you seem to be, that you don't care about making something the least bit more convenient to use for [most people, who are unlike you in that respect] even if it doesn't take much effort. And I understand treeturtle's point as "It's no effort". Your argument about the "right shade of grey" is totally irrelevant, because treeturtle's design is lightyears closer to the Zeitgeist and you are arguing about meters.
And shows off what you can do. "Why would anyone not use css, when it is so easy?? Hence it must be impossible to use with that system."
Your last sentence is my main concern.
That's what I first thought when looking at web libraries actually.
I have an very limited about of time. If a pretty site is not in project scope, it isn't going to get done. I've wasted a great deal of time trying to make sites pretty previously, and it did not contribute to anything useful. Further, I have a limited give-a-crap about conforming to the zeitgeist. Perhaps complainers should reflect upon man pages and their usefulness.
Thanks. That should make my life better next time I have to do the JS dance.
I know a compatible implementation is in the works for one other CL. I'll let them announce it in their own time, though...
I've noticed this phenomenon as well. But I get used to browse sites such as gnuwin ones or CLHS and with less CSS I'm more satisfied because sometimes I look at the website through a text browser and I'm already familiar with its appearance. By the way you don't find out how good the website is done until you use a text browser and sometimes you haven't other option. But, yes, a decent CSS will not hurt.
There are some nicely formated project websites. [lparallel](http://lparallel.org/) comes to mind, and I also tried to make the documentation for [cl-async](http://orthecreedence.github.com/cl-async/) very readable (however, I do come from a strong web background). The quicklisp site also looks nice to me: well-formatted text, callouts, etc. However, I agree with you. I think that a lot of lispers completely gloss over documentation (if they do it at all). It's a part of the culture that upsets me because there are so many good libraries out there without outdated or non-existent docs. Nobody wants to go wading through sources just to figure out if the library their looking at *can even do what they want*. This lack of importance placed on docs carries over to the appearance of the docs, I think. Another thing to consider is that many projects in other languages that you are probably comparing lisp to have large(r) amounts of users. If I had a library used by 1000 people, I'd probably make sure the site was pretty slick. But if I write a library that only a handful of people are using, then it's more of a proof-of-concept and nobody wants to sit around for two weeks using their free time to make a really nice site for a library that nobody uses. So part of it is a chicken and egg problem: better (looking) docs attract new lisp users, more lisp users means docs are now more important so maintainers update them more, better (looking) docs attr... The best way to solve this problem is to build some useful libraries in lisp and make really nice doc sites for them =]. I'm working on a web server in lisp right now and plan to run the doc site off the server and make it really nice looking...so hopefully that would answer some of your critique. The server is in beta though, and probably a ways off from being done.
Except then they'll start to complain about the parentheses and go off on a side project to make a parentheses-free Lisp. Or they'll start complaining that they have to use Emacs and yet another editor war breaks out, with those who "get it" (and are often older and curmudgeonly) yelling at the youngsters to get off their lawn. /sarcasm 
Tastes change. What was in in 2006 is out now. Animated GIFs gave way to Flash sites which gave way to rounded corners which gave way to Metro-style "flat design". And given the UI-affordance shortcomings of that last I suspect it'll be on its way out soon. Lisp has an old-school hacking community, to whom an informational site for a software project -- as opposed to, say, a marketing type site, social network, or interactive game -- should be written in an HTML style that conveys _content_, not _form_. If you want to pretty it up you can tweak the default styles in your browser; then you can also keep the appearance of all those plain HTML sites in line with whatever Web trends are prevailing this fall -- leaving the project maintainers free to do their damn work. 
&gt; My logic was that it relates to the web so maybe it should have a more modern site design. The conclusion does not follow from the premise
Translated by Shiro Kawai of Gauche fame; he even [translated the source examples to work on Gauche](http://blog.practical-scheme.net/gauche/20130223-land-of-lisp).
Please don't ever again make design suggestions. I have never seen so much shit created with so few lines of css. God awful. Just stay away.
Speak for your self. I used to do graphic design for people like you. God awful time. Give me a good plain html page with just enough ordered/unordered lists and paragraphs to make it easy to read and it's done. All this web 2 point OH garbage can just go away.
You can't sell ideas to people that don't want to hear them. Those that don't like lisp won't like it any more with all the pretty graphics. As a former graphic designer, most design processes end up being the re-allocation of limited resources away from the simple/readable to the complex/unreadable/butpretty. Simple is good. Stay away from graphic design, it is an endless pitt of sheit.
It is a PERFECT excuse not to use that sheit. All that crap does is make a simple, easy to ready, easy to render on any device layout unnecessarily complex and unreadable on anythign but the majour browsers and a few majour platforms. This is just the standard keeping up with the Joneses argument. It should die with the Joneses.
Perhaps Lisp programmes know what matters and what doesn't. Give me content, leave the unecessary fluff.
Man pages are great, but when I really want to read one (in contrast of quickly looking up something), I read them on die.net, because there I have decent formating and typeset. I fully understand that you have limited time! You share that problem with me and most adults. And you can handle your projects as you like. If you don't enjoy creating a good layout, fine. But your "fuck off" attitude towards a (subjective but surely not absurd) problem statement is hugely in contrast to all those people who nicely want to draw newcomers to lisp.
Should I speak for myself or "for people like me"? I think people like me are the majority on the web. You talk like there's no valid reason that css is ubiquitous on the web (except for the lisp community of course ;-)). But, just because you don't appreciate a nice layout or a beautiful typeset, does it mean we all need to agree with you and go away?
I don't think that's a problem with css, you can apply it such that the underying html still looks as usual on it's own.
// stealth edit for anyone wondering. i am not sure why some of these sorts of posts bother me so much. sorry about that. 
I like it best when there's good information presented in an aesthetically pleasant way.
I don't think that web 1.0 pages are a problem. Unmodern presentation ought not to be a problem. Gross inability to access the information is a problem, as is wrong information. That is a fine argument if you can make it. But in this setting, I think that the problem is that people pay attention to the surface appearances. 
And better manners
Wrong information and inability to access information is far worse than badly presented information. I would under no circumstances want the formatting of the documentation to impede its function. But one function is, to get information accross. And the layout treeturtle chose - in my opinion - does a good job in guiding the eye through the documentation. You could have done the same thing in web 1.0. But the beauty of css is that the design is separated from the semantics. By the way, OP didn't request "the design fad du jour". There are readability-improving rules, which are worth consideration, which stay the same over time.
Oh I thought by nature it had to use threading to do events and network related things. Huh.
// another stealth edit. My hatred of UX consultants, photoshop users and SEO consultants is well understood by those that know me. However, as has been pointed out, my comments really are not helpfull in any way, so editing this into silence.
You are right. They are horrible. 
Nope, the OS abstracts that via select/epoll/kqueue/whatever-c-function-your-platform-uses-most-efficiently. You basically say "here's a socket I just sent out data on, when it receives data on it, run this function." That function is attached to an event, and when the event is ready (ie data was received), it's put into a queue which your event loop runs. While you're waiting for data to come in on the socket, you can do other things (for instance, process an incoming request, make an outgoing HTTP request, etc). This way you can do a lot of network IO at the same time all on one thread. Many very successful (as in highly scalable) systems use this evented approach (as opposed to one thread per connection) and are able to handle tens of thousands of incoming/outgoing connections all in one thread. Some use a hybrid (nginx comes to mind) where you have N worker threads (N being your number of CPU cores) and each worker thread is an evented system that is able to handle tens of thousands of incoming requests by itself. cl-async doesn't really touch threading...in fact, it needs a few updates to make it more thread-safe, for instance if you want to share an event loop (the object that tracks all the pending events) between two different threads, it would be very difficult to do that right now without wrapping the implementation in a lot of code. I'm working on it as I have time though.
The OP complained about lack of Ajax and also complained about static HTML. Documentation should be static html. I like the fact that Hunchentoot includes hunchentoot-doc.html in its installation. I have 75 projects installed, 22 come with html documentation, 15 of these I have bookmarked in w3m. I agree that some css is not a problem but many modern sites use css to such an extent that they are unreadable in a text browser [sports.yahoo.com](http://sports.yahoo.com) and others are barely readable like [api.jquery.com](http://api.jquery.com/). I checked out [restas](http://restas.lisper.ru/en/) and it does look very readable in w3m and looks nice in a modern browser.
I also think that you can do bad things with css, as your example of sports.yahoo.com shows. api.jquery.com is not much worse readable than the [hunchentoot reference](http://weitz.de/hunchentoot/#reference). While css can be used in bad sites, it is the solution for formatting that does not destroy functionality and further is well separated from the content. In contrast in web 1.0 you needed to do semantic stuff (create a table) to get visual effects and include all the design definitions (font, colors, margins, etc) in the very same file as the information. &gt; The OP complained about lack of Ajax and also complained about static HTML. Where? I understand this discussion to be purely about the look of the pages.
first line of the OP: &gt;Almost all of them have almost no css/ajax or are even a static page.
Oh, right. My fault. I indeed cannot think of benefits to ajax and dynamic pages (except the dynamic pages generate the docs directly from source, for which there are better ways).
I believe `intern` by default interns symbols into the current package (stored in `*package*`), which if you're calling from `:loom` will be the loom package. If you always want that `intern` to put those symbols in the `:cl-abc` package, add the package name to the optional package argument for intern, so `(intern (string-upcase raw-key))` Becomes `(intern (string-upcase raw-key) :cl-abc)` Note that I haven't tested this, but I think it should solve your problem!
I think kqr's point was that if you've got multiple `$`, the `init` ones can be replaced with `.`. These all do the same thing: putStrLn $ show $ [[1,2],[3,4,5],[6]] putStrLn . show $ [[1,2],[3,4,5],[6]] (putStrLn . show) [[1,2],[3,4,5],[6]] putStrLn $ show [[1,2],[3,4,5],[6]] Multiple dollar signs looks weird.
I'm not sure what are you using, but the last time I checked *major browsers* are the only browsers on devices since 2010. Aside from that, can you convince me that jekyll/org-mode will generate complex html? Hell, even [Dillo](http://dillo.org) will render that.
That makes sense, and seems to be exactly what's going on. Thanks! This raises another question though. I just got bitten by comparing symbols from `:cl-abc` from within a `:loom` context. In this case I easily worked around it by converting them to strings (I suppose I also could have interned them in `:loom`). But does this mean that it's really not the best idea to use symbols to store random data? I usually find them more pleasant to work with than strings, but all this package business is significantly detracting from that.
Personally I'd recommend you to intern the symbols into the KEYWORD package (beware though, symbols in the KEYWORD package can't be SETF:d). Examples: (intern (string-upcase s) 'keyword) ;; To intern a symbol with some name S into the keyword package (setf :hello 5) ;; Error! You may have seen symbols from the keyword package before, they're prefixed with a colon, so writing :hello is shorthand for interning the symbol HELLO into the KEYWORD package. I hope I've been clear and haven't gotten any facts wrong. Google's Common Lisp Style Guide does not recommend interning/uninterning at runtime: http://google-styleguide.googlecode.com/svn/trunk/lispguide.xml?showone=INTERN_and_UNINTERN#INTERN_and_UNINTERN Edit: Uhm, btw, symbols are by default upper-cased by the reader automatically so you writing 'Ab is useless, because the symbol that gets created actually has the symbol-name AB, if you want case-sensitive symbols then write them like this: |Ab| ;; Don't forget to quote/prefix with colon if you don't want the symbol-value to be evaluated
Read this: [The Complete Idiot’s Guide to Common Lisp Packages](http://www.flownet.com/gat/packages.pdf) by Ron Garret It should clear things up.
Obviously if you're only `show`ing one value, you only need one dollar sign. I often need to show and concatenate several values into a string. I'd use interpolation, but I haven't seen a Haskell library for interpolation with acceptably minimal syntax.
Ooo! Sweet link. I have not seen that before, thank you.
Yeah, I thought about using KEYWORD, but was vaguely uncomfortable with all the colons. That's certainly significantly better than all the interning nonsense, though, so I should probably reconsider. And I did try it without the STRING-UPCASE call first--`(intern 'a)` =&gt; `|a|`, not `'A`.
I wouldn't recommend using symbols to store random data, but identifiers which are part of the application domain -- like twelve musical notes -- are entirely appropriate as symbols. Export them from a common package and use them in dependent packages. Then `intern` will work without fuss.
because Aaron dropped lisp for python
Package local nicknames [just landed on trunk for ABCL][r14405]. [r14405]: http://trac.common-lisp.net/armedbear/changeset/14405
Much kudos to Rudi!
I wish he'd come out for some tutorials for Blocky instead of making these games... And yes, I do realise that you can use the source code for this to understand Blocky, it's just easier to learn with tutorials and you won't get any weird misconceptions about stuff.
That's definitely true, but making it easier for others to try out your own dogfood is also pretty important ;-)
Are you saying that you are experiencing cases where f $ g $ h $ x is not the same thing as f . g . h $ x ? Because the first one looks really weird, while the second one reads naturally as "the composition of f, g and h applied to x." One hidden benefit of the second one is that you can just copy-paste let compo = f . g . h in compo x You wouldn't be able to do that with the first one, because it is parsed as (f $ (g $ (h $ x))) and not (((f . g) . h) $ x)
Is there any specific reason you think a parenthesised expression is better than using the application operator designed for that? Yes, it's 100% irrelevant. I just felt like pointing it out as an aside in my real reply in case you had missed something, and it blew way out of proportion.
Hi, I definitely recognize the need for a proper release and tutorials and recently spoke with FaRe about this. One purpose of the game-making has been to refine the engine by refactoring it continuously across many situations and adding stuff each time. I think with 2x0ng, blocky is getting to that point where I could sit down and write some documentation and put out several remix-friendly simple games for people to modify. I'm targeting mid April for release of 2x0ng on Desura, so I'd like to do the release after that time (as the current testing process for 2x0ng has already caused multiple bugs to be fixed in blocky.)
Needs more media exposure
It looks like that thing will be able to run/compile Lisp into LLVM IR... sounds really interesting. Will it mean that Lisp code can be run and ported to the platforms that rely on LLVM?
What a gift for all of us! Thank you, really.
This is an impressive accomplishment. 
can someone eli5 for me?
It is already possible to embed ECL in C++ and by reading Christian's description it seems nothing has changed.
Love the sound FX. They remind me of Shamus, an old 8-bit game by Synapse. An OSX port would be nice too, or porting notes to that effect.
what was the answer before this came along?
Use C, not C++
Great. Out of curiosity, what app(s) or audio plugins (VST or AU) do you use for creation or editing of sounds for your games?
I have somewhat followed the development of his interpreter on IRC and I must say that I am impressed with the speed at which he developed. It seemed like he implemented a new special form every day. With that astonishment of course comes a bit of cynicism: if indeed he has implemented the core of CL, is it actually *correct* in the ANSI sense? There were two other concerns: speed and GC According to him, the speed of the interpreter is about 1000x slower than any compilers. This is supposed to be mediated by using LLVM. The concern with LLVM was (IIRC) its GC, which might not be suitable for Lisp. I also wonder whether it supports things like the full numeric tower, which isn't a trivial thing to bolt on. I have personally (with current CL implementations) tried to interface with C++, and I had a terrible time, ending up wrapping the C++ in C, and interfacing with C. So I understand the want for a C++ friendly implementation. But at the same time, do we really want to trade the benefits of a mature implementation so we get some C++ connectivity? Would anyone use a CL implementation that is only good at being C++ glue? With the completion of this, Lisp advocates will now claim that Lisp is good at C++ interfacing, just as ECL is good at building binaries, just as SBCL is good at producing native code, etc. But that's the problem: - SBCL: Fast, *but poor at deep interaction between other languages* - CCL: Lightweight, good Apple/Cocoa support, ARM, *but not as fast* - ECL: Good at talking to C, small binaries, can be portable, *but slow and C-lunky* - LW: Good at building binaries, GUIs, *but non-free, difficult to write fast numerics, still bad at talking to C++* - CLISP: Good at bignums, portable across most platforms, *but slow, has a strict license*. In other words, "Common Lisp can do *X*, but you must choose implementation *Y*, and lose the benefits of implementation *P*, *Q*, and *R*." I hear this a lot on IRC. When someone is complaining that SBCL doesn't make small executable dumps, for example, someone suggests switching implementations. It is difficult to get the best of both worlds. Finally, it's not clear to me how he plans to actually integrate with C++? How are C++ classes and methods and so forth represented in Lisp? How does C++ make use of Lisp? I'm a little afraid that this implementation is evidence that current CL compilers are too hard to hack and improve. In any case, best of luck.
I haven't read Land of Lisp, sorry. Try a different book? Paradigms of AI Programming and Practical Common Lisp should be pretty good for learning Common Lisp.
Thanks. I'm pretty into AI as is, so I'll definitely give it a look.
Paradigms of AI Programming is not especially about AI programming. It's more about learning useful techniques in Common Lisp in the context of classical problems that were once considered AI. For modern AI stuff, Norvig has another book, AIMA.
Finally... I think they were expecting to deliver it by last September. What's the main difference between Clozure CL and other lisp implementation, like SBCL?
AFAIK, CCL specializes in OSX integration. Other libre Lisps don't have that specialty. 
See also Daniel Weinreb's [Common Lisp implementation survey](http://common-lisp.net/~dlw/LispSurvey.html).
Indeed, they're both great implementations. For some reason, I'm always a little surprised CCL doesn't often market performance enhancements the way SBCL does in their release notes. I suppose it just shows their different priorities.
WOW, I am jealous!
CCL has mature/working threading implementation on Windows.
indeed. i
Yup. Last time I tried SBCL^1 it locked up when trying to use the [Hunchentoot](http://weitz.de/hunchentoot/) Lisp web server^2 on Windows. CCL worked great. [1] This was some time ago, and I haven't tried [the Windows fork](https://github.com/akovalenko/sbcl-win32-threads/wiki) of SBCL. [2] For those not familiar with it, Hunchentoot serves static content and does lower-level web frameworky stuff.
OSX threading is working too, compared to SBCL. I think it is very experimental in SBCL for OSX. Appendum: So far I have used OSX only for a week. When I installed sbcl (once from macports, the other directly from the site) both had no thread support. I recall reading that it is experimental, and therefor switched off by default. Now I have recompiled ( make.sh --fancy) and threading works fine for me. 
PAIP is a brilliant book, probably my favourite technical book. It's in many ways quite different from LOL. However, just as LOL does, it requires you to study the code in order to understand it. So there is the danger you might be similarly frustrated, especially with the symbolic computing and natural language sections: they're PAIP's version of LOLs text adventure but on steroids.
If you have issues with threads on SBCL/darwin, we'd love to hear about it.
If you study PAIP closely and succeed at finishing it, you will be far, far, far beyond where you would be if you study LoL closely and succeed at finishing it.
Which is pretty much outdated, and, if not updated to reflect current state, just does more harm than good.
Keeping it up to date would be a great project.
If Lisp is the red pill, then PAIP is washing it down with a bottle of tequila. 
You mean as in Page number? I'm not quite sure what you mean :S
&gt; I'm a little afraid that this implementation is evidence that current CL compilers are too hard to hack and improve. I share that concern and it's one of the reasons I'm a big fan of what Robert Strandh/beach is doing with [SICL](https://github.com/robert-strandh/SICL). Admittedly, it's far from finished and I don't know of an up-to-date status report anywhere but even having a shared stdlib (or portions thereof) seems like it would reduce CL compiler complexity substantially.
No problem. It's called "This Ain't Your Daddy's Wumpus", I think.
Short answer: not really. Skim them and move on; don't let yourself be bogged down by those chapters. Long answer: I'm reading Land of Lisp right now too. Two years ago I bought the book and got bogged down in that same spot. This year I'm trying it again. Last week I reached the same point: chapters 7 and 8. I'm not particularly interested in the game, but I read through the chapter, typed in the code, and kept moving on. It gets a lot more interesting after Wumpus, IMO. Fact is, you're not going to become a master Lisp programmer by reading Land of Lisp. You'll need more than this book alone can offer, and you may very well need to read this book more than once: you might read it once to see all the high points, then read it again to dig in and understand what's really going on. Barski covers a lot of ground quickly but he also seems to repeat material (which is a plus). The point of the games is to show you how to do cool things in Lisp. You won't be able to do them all yourself by the end of chapter 8, but you're seeing what CAN be done and building up exposure that'll let you forge ahead on your own later. So keep moving. I found chapter 9 to be a lot more interesting and useful that 7-8. As for other hints: * be sure to check out the Land of Lisp forums for some chatter on various topics; * use CLISP: the book's examples work better with CLISP than SBCL, at least in my experience (learning the hard way); * take time to try out the various snippets of code whenever Barski explains various Lisp features; * have fun. The book is an interesting guided tour of Lisp and Lisp techniques, not a master course. Keep moving, enjoy the ride, and move on from there.
I can see why you think what you think and I do find your points to be valid, however there is a problem with using lists when you see long cxr (where x is some combination of A:s and D:s) expressions, which I think (if I remember correctly) is quite common in LoL.
Thanks. This is honestly the best answer yet. After LoL, would you recommend SICP? I know it's about lisp, but I've heard it's really good.
tl;dr: If you're looking to read in Clojure data structures, you want to use clojure.tools.reader.edn
I have a master's in CS, and SICP is the best CS book I've ever read, about lisp or not. I would recommend it way, *way* before LoL.
Aside from your post being needlessly snarky, it's not even clear what you're talking about. &gt; I have tried reading the books you suggested Books? I mentioned only one book, and it was less of a suggestion than an affirmation of a suggestion by the OP. &gt; NOTHING can suck the fun out of programming faster than your (and other peoples) suggestions. What suggestions are those? Care to actually describe your experience to save others the pain that you went through? If you want to have a conversation about books or whatever, that's great. But just cutting others down is not constructive, and sucks the fun out of many things in life, programming included.
Hmmm. You are right, my post is not useful. Sorry about that, deleting.
It would be nice if Clozure CL has installer on Windows.
I wrote one in my standard library, but in a pinch you can use `cl` to write: (loop for i from 0 below N collect i) In general you can do all sorts of pythonicish things with Common Lisp's loop macro. If that floats your boat (it sinks mine) spend a few minutes reading [Loop for Black Belts](http://www.gigamonkeys.com/book/loop-for-black-belts.html). The loop macro in Emacs Lisp's `cl` emulation is basically complete except for a few edge cases, I'm given to understand. 
Ok, I think this is an easier entry than Emacs + SLIME, but does it provide at least the most interesting features? What about cursor movement? Is it as easy as C-M-d, C-M-u, C-M-b and C-M-f?
it seems to be back up for me. Thanks (sort of) Network Solutions. 
nope, it's not up. stupid Firefox. 
This made my week. You really get a feel for how different systems were back then. I can also sense the DEC influence on those systems. I wish I could learn more. Also, i wish Symbolics lived longer.
&gt;croudsourcing Is this why it's crowdsourced? Heheh. Seriously though, interesting, lets see if this can spark some interest in Guile.
No automated installer is A GOOD THING ^(TM). Just download the Windows version of Clozure CL as a single zipped file, and unzip the files/folders into a directory you have access to on your workstation. Go to the unzipped files and double-click either the clearly named 32-bit executable or 64-bit executable, and PLAY! No worries about having stupid policies on your work computer that restrict your ability to install programs that impact your registry get in the way of learning Common Lisp! Sweet. http://ccl.clozure.com/download.html
Everytime I see guile I want to try and pick it up or try to embed it into an app... But then I see that it isn't LGPL and look for another lisp or scheme. 
Err... yes it is: http://www.gnu.org/software/guile/manual/html_node/Guile-License.html ??? Update: As of 2006: http://www.gnu.org/software/guile/news.html 
Well I stand excitedly corrected. Thanks vplatt. :D
'croud' sourcing... 
Interesting, I didn't know that guile [supported other languages](http://www.gnu.org/software/guile/manual/html_node/Using-Other-Languages.html#Using-Other-Languages). However, it seems that while emacs lisp is [reasonably well implemented](http://www.gnu.org/software/guile/manual/html_node/Emacs-Lisp.html#Emacs-Lisp), ECMAScript is only [a bit more than half-implemented](http://www.gnu.org/software/guile/manual/html_node/ECMAScript.html#ECMAScript), and support for Lua is [underway](http://www.gnu.org/software/guile/). So basically, scheme is most reliable at this point.
thonic boom!
fantastic demonstration of just how far backwards we have gone / not progressed much at all.
That's nature. Genes appears then fall asleep. They're not lost though, they just need a context to shine.
that is a mighty fine observation. i agree. hopefully we can start writing a lot of this stuff again by pilfering the ideas of old.
Occasionally I'll look for libraries that perform some function, when I'm adding features to a website that's not written in CL, in hopes that eventually I can move more and more code to CL. I haven't kept a list of everything I've looked for but haven't found. Most recently I believe I was looking for libraries that would let me post blog posts to Google Blogger, tweets to Twitter, and status updates to a Facebook page. I know I didn't find solutions to all 3. IIRC all I found was an old library for Twitter that didn't work with OAuth 2.
It would be nice to have a website where people may submit requests for libraries and eventually someone would choose one of them and implement it.
Mainly documentation
Yeah, and then take that code, abstract it a bit, and you have the first pass at a library.
There is a Cliki page: http://cliki.net/Suggested%20Programming%20Projects 
4 or 5 years ago, I went through about 2/3rds of the [python challenge](http://pythonchallenge.com), solving the problems in lisp, before I found a library that was insufficient to solving the problem at hand. But I did find a library and I didn't have to start from scratch in making it work the way I needed it to. LOC is pretty much irrelevant to OPs question, btw.
In your opinion, what purpose would such a page serve? If someone can't be bothered to write a library that they *need* (and then share it), why should they expect someone else to write it? I mean this as an honest question. Perhaps I'm completely uninformed, but looking at the libraries in any given community, I assume they were written because the author *needed* them, or were paid by someone who did. Do the java, python, ruby, et al. communities have similar pages of missing libraries where people jump in to fill the void?
Maybe I'm missing something, but twitter appears to have only announced limited oauth2 support 4 days ago (3/11/2013). [source](https://dev.twitter.com/blog/application-only-authentication)
Here's my process: look for it on github, cliki, google, etc. If it exists, great, use it. If it doesn't exist, or it's broken/old/undocumented/abandoned, I write it myself and try to - keep it abstract enough so that it's useful to as many people as possible, not just serving my one specific need. this is usually the difference in putting in 10% more time, but making the library 300-400% more useful. - document the hell out of it - let people know "hey! I made this!!" by posting on reddit and adding it to Cliki (I only do this once I'm somewhat certain of the library's stability) It would be nice to have a list of libraries people want, but in my experience the best libraries are ones that are built because someone needs it for their own purposes, not because someone else thought it should exist (practically useful vs theoretically useful). If you need something that doesn't exist, build it, and let the lisp world know! 
You could be right. It's very possible I didn't R the specifics C.
The list seems to be both hopelessly outdated *and* nonsensical.
&gt; In your opinion, what purpose would such a page serve? As I understand it, the benefit of such a list would be to identify the perceived shortcomings of Common Lisp. It would be a list of "I would use Lisp, but cant because it lacks support for X, so I use Python instead" suggestions. Then somebody else, who is motivated by improving the Common Lisp ecosystem would fill that gap and invite the claimant to reconsider his language choice. &gt; I assume they were written because the author needed them, or were paid by someone who did. Many libs for an underdog language are written by that language's evangelists to make their language more attractive. Otherwise why would anybody write a library for language X when that functionality already exists in library Y, and he only wants to use the library and not to improve the language's ecosystem by reinventing elsewhere already existing wheels? &gt; why should they expect someone else to write it? I mean this as an honest question. I guess that the Common Lisp community at large is interested in increasing the number of Common Lisp users in the long run. If you have more users, more work will be done, more code will be written, more knowledge will be shared, the ecosystem will be strong. BUT, the only way to attract new users is to *already* have an attractive ecosystem before they even look at it, otherwise they wont consider switching to it. Which means, you have to bootstrap it completely on your own, for free, solely because you love the language an want it to thrive in future. And the way to bootstrap it is not to scratch your own itches, because that will only attract you and not somebody else, but to find out what *other* users would want to have in the ecosystem in order to switch, and then you have to scratch their itches in advance.
Lisp is a programming language. It's capable of everything any programming language is capable of. The "solutions" are the same in all languages. It is all algorithms. It is the conveniences that vary, and to learn them you need to do more than dip your toes. It is very easy to be fooled into thinking "language X is useless! It doesn't even have Y!" and miss the fact that is has all sorts of other things. http://random-state.net/files/nikodemus-cl-faq.html#how-can-i-learn-common-lisp
&gt; If someone can't be bothered to write a library that they need (and then share it), A good question. One answer is that at least in some cases, I don't know enough to do a good job writing the specialized code that makes a superb library. (For example, I don't know enough to write a useful crypto library, or an xml parsing library, but I can use them while bootstrapping what I do know.) Still learning. &gt; why should they expect someone else to write it? Oh, I agree; I shouldn't *expect* anything. But it is true that sometimes people who can write such things may be persuaded by someone describing a need. But certainly no expectation exists. 
And: * Room for comments and discussion. * The ability to vote for a proposal so that the biggest missing pieces are obvious. * A place to link to similar libraries in other languages. * Requests for improvements/additions to existing libraries. * Ability to request documentation or examples for libraries that already exist. * A ban on comments that say the proposed library is not needed. * A ban on Lisp evangelism and criticism of other languages. * A modern website. Something like Dell's Ideastorm, for instance.
First, stop saying "all those parentheses:" it's neither funny nor relevant.
This answers the question OP asks.
But trying haskell may give you ideas on trying to use const everywhere in C++. Trying C++ may give you ideas on how to implement virtual inheritance in C. Trying C may give you ideas on how to implement functions in assembly. In the same way, I'm hoping that Lisp can provide new ideas that can translate back into other languages, and if that happens, I would like to record the process, simply because of curiosity. Specifically I'm eager to see if macros change the way I program in the languages that don't provide them (directly, that is; I know all turing-complete languages can do anything the rest can). Hopefully people familiar with Lisp could provide good examples for this experiment?
None, I made the thread to deal with an issue that seems to bother a lot of newcomers (and more). Thanks anyway!
People are certainly not complaining about a lack of libraries for Common Lisp. I have, however, heard complaints about the lack of go-to libraries. You want to do something? Here are five different libraries written hastily by five different people and they are slightly different in their features and operation. Good luck and have fun with finding out which one suits your application.
When learning some new programming concept, I try to fit it in a very simple task, like Bulls and Cows (aka Mastermind). It is well defined, has simple semantics, and is not completely trivial. For example, when I was first reading about monad transformers in Haskell, I stacked StateT on top of IO to hold the game state. Personally, I wouldn't use your approach to learn a whole new language, but after having a solid grasp of the basics, I'd tack on more advanced concepts piecewise like you suggest. Another task I like to implement in as many languages as possible is a METAR parser (meteorological forecasts for airplane pilots).
I'm trying to get some help with my [CLinch](https://github.com/BradWBeer/CLinch) Library. I've been dealing with personal issues and I'm just now getting back to it. Eventually I want to create a super-editor (3D, animation, etc) but I just don't have the time/energy/expertise to do it. I'll take any help you're willing to give.
[Rosetta Code](http://rosettacode.org/wiki/Rosetta_Code) has a list of snippets which need implemented for their collection. Also, a few hundred lines of code will solve much more complex problems in Lisp. I think you could implement Prolog in as much. 
For a nice language comparison, my pet program is a Markov chain generator: Split a text into words, then for every word triple a1, a2, a3: a1 and a2 are the key in a dictionary, a3 the value to insert into the list stored under the key. Select next word a4 from the text, repeat with a2, a3, a4. Then a3, a4, a5 and so on, until the whole text has been stored in the dictionary. Second step: Start with the first two words of the text (a1, a2), and randomly select ONE of the words stored under that key as a3. Output a1, repeat with (a2, a3) as the key until a given number of words have been output. The result is a pseudo text that on a VERY casual glance looks like a legit text, but has no meaning. Write such a program in every language you know and compare source code size, speed, quirks and so on. Sample code in Python for a better description: import random w1 = "" w2 = "" triples = {} for line in open("test.txt").readlines(): for word in line.split(): key = w1 + " " + w2 if not triples.has_key(key): triples[key] = [word] else: triples[key].append(word) w1 = w2 w2 = word key = w1 + " " + w2 if not triples.has_key(key): triples[key] = ["."] else: triples[key].append(".") random.seed() w1 = "" w2 = "" for i in range(1000): list = triples[w1 + " " + w2] word = list[int(random.random() * len(list))] if word == ".": break print word, w1 = w2 w2 = word print 
Then you end up with pythonic lisp which might not be the best lisp. For example, I use a Ruby library called "timecop" at work. It seemed useful and I wondered what it would look like in Lisp so I copied it's features and ended up with [delorean](https://github.com/cddr/delorean/). The code and API is pretty different though. My point is we shouldn't simply transcribe libraries from other languages. We should make those features available in a "Lispy" way
And: The site must be written in Lisp. :)
&gt; The "solutions" are the same in all languages. It is all algorithms. I don't agree. You don't have first class functions and closures in every language. While OOP is just an abstraction, the formers change the way how you think about programming a lot.
Seems like a OSQA clone would do the trick?
A closure is a function pointer and data pointer. A "real closure" is much much more convenient, but you can implement solutions with the same general shape. Agree about the OOP, though. Sometimes the braindamage it causes can take years to get rid of. :P
The RetroForth mentioned there comes with several different VMs. One is in Common Lisp (SBCL and ECL). http://retroforth.org 
awesome
Feel free to edit it.
great, now there is 4 things i know about called Gazelle.. why dont anyone do a basic search before naming things?
Why thank you! I definitely went for readability and conceptual clarity over speed. :) My next project for cl-6502 is to build a simple compiler to 6502 asm. I've already switched over to a new sexp-based assembler on the dev branch ... ;) Of course, gotta get games actually working decently in famiclom first. At least Super Mario Bros and Mega Man 2.
Upvoting myself and dropping in to say that if I sound intelligent, its due to Hraban's good editing, and if I say anything stupid then its my own fault. 
What are the 4 things (3, assuming one is the animal)?
yeah, i included the real one too ;) 1. A parser generator framework, https://github.com/vic/gazelle . 2. Microsofts Gazelle Browser project, dont know what happened to it. 3. And now this lisp-js thingy. The oldest is the parser framework... but i know when not even microsoft gives a shit, why should anyone else. Not exactly a big list i agree, but it still irks me. it takes 2 seconds to check a name (if its not a brain dead one, like .NET hehe) 
It's cool, but it has no documentation or tutorial explaining how to use it, I've got it running in in VS2010 and the repl works fine in my sample console application, but having figuring out how the environment and nodes play with each other via the source code is a little tedious.
Well, there was a process. I wrote something called "jsel" which was a Javascript transcoder in Emacs Lisp. About 80% of the way done with that project, I realized I wanted to completely refactor it, and so I chose a new name. "Gazelle" is sort of a pun on "jsel." Plus, its an elegant animal, which is how I aspire to code. Whether I reach elegance is another thing.
In addition, different libraries can have huge "impedance mismatch". Data structures used between libraries may need massive amount of data massage between them. I have numerical programming in my mind. Many people write interesting libraries, you can't just use them over same data. Languages like R have huge number of libraries that operate on same basic data structures and have similar convention. Some basic convergence to class structure and simple CL coding conventions like using :key and :test parameters consistently could be helpful. I think that epigram #9 from Alan Perlis: *"I think It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures."* applies to libraries: It is better to have 100 libraries operate on one data structure than 10 libraries on 10 data structures.. 
So. Um. Wouldn't it make more sense to work through ECL and add documentation rather than *writing an entirely new Lisp dialect*?
What is the intention of the dual BSD/LGPL licence? 
Also, check out the demo: &lt;http://orthecreedence.github.com/highlight-lisp/&gt;
Just tried to integrate it with my CL-HTTP code. Works. Cool.
Great. It has always been one of my first suggestions to Lisp beginners who aren't already advanced programmers in other languages. (For example students with only a Java course under their belts.)
How's this book for people that already know lisp? The blurb says it's for "both novices and experienced programmers". Is that true? I'll buy it, if it's actually useful for me, but not if it's just a good introduction.
&gt; ECL doesn't provide (realistic) documentation on embedding. What are you talking about? ECL = Embedded Common Lisp. The whole implementation is about embedding. The [whole manual](http://ecls.sourceforge.net/new-manual/) is about embedding, which for example gives you the C equivalents of important CL functions and constructs.
I agree. This is the first place I point beginners interested in Lisp.
&gt; What are you talking about? ECL = Embedded Common Lisp. The whole implementation is about embedding. No. ECL can be used as to write Common Lisp programs. For instance, you can create a standalone executable. See [this part of the manual](http://ecls.sourceforge.net/new-manual/ch24.html#ext.asdf.intro) for the intended uses of ECL. &gt; The whole manual is about embedding, which for example gives you the C equivalents of important CL functions and constructs. No it isn't. Most of the manual is about Common Lisp. There is [a chapter](http://ecls.sourceforge.net/new-manual/ch31.html) on embedding. I'm pretty sure I can initialize the Lisp environment and close it, but that's it. Here's an example. I want to pass a double* from C to Common Lisp, do some work with that data, and pass a double* back to C. I'm not seeing anything like that in the documentation.
Maybe I didn't give it a fair chance, but I would say no, not for people that have knowledge in Lisp.
What's a good book for those who have read SICP already (and knew LISP at one point)? FWIW, I never really tried out macros.
[Practical Common Lisp](http://www.gigamonkeys.com/book/)
Cool to see this here! I am the author. Just in case anybody wonders: Its a toy I use to experimentally synthesize sounds. For its tiny codebase it can produce quite a roar already. Feedback welcome!
I second [Practical Common Lisp](http://www.gigamonkeys.com/book/). If you're particularly interested in macros, there's [On Lisp](http://lib.store.yahoo.net/lib/paulgraham/onlisp.pdf). I'm also really fond of [PAIP](http://www.amazon.com/Paradigms-Artificial-Intelligence-Programming-Studies/dp/1558601910), but it is not available online for free, and after reading SICP, the more "practical" kind of problems covered by PCL might be more interesting.
This conversation is not very productive, so I'm going to let it die, but just for the record, this is the code for the first example under "C Calling Conventions": #include &lt;math.h&gt; ... cl_object angle = ecl_make_double_float(M_PI); cl_object c = cl_cos(angle); printf("\nThe cosine of PI is %g\n", ecl_double_float(c)); Which is not what I'm talking about at all, and it's just one example. The bigger point is that the documentation is not comprehensive, not organized very well, and there are no complete examples. It's not like I'm the first to comment on the documentation.
The example does exactly what you mentioned: &gt; I want to pass a double* from C to Common Lisp, do some work with that data, and pass a double* back to C. You want the conversation to die because you were completely wrong, and now you won't own up to it.
Similar to my typed-cl: https://github.com/kruhft/typed-cl. Nice idea handling the optimization levels.
There's also defstar, and really, it's better than yours (more features, mainly). I also like that it follows the "star at the end means it's slightly different"-convention for naming. https://bitbucket.org/eeeickythump/defstar/src/9836a2e97cf2?at=default
Nice library with some good features. Looks like what I was going for but actually somewhat complete :)
Great, that means you will actually learn something! If that means having to use other lisp resources, keep at it until you understand those chapters!
Yes, I think defstar should be the canonical version for something like this, would you be prepared to call your library obsolete and instead link to the defstar library on your github or something like that? I'm currently writing up an Issue form for the defstar repo for renaming and so on. EDIT: Written and sent: https://bitbucket.org/eeeickythump/defstar/issue/2/library-consolidation-effort
As long as the library actually works as advertised I have no problem with putting a link to it on my project. I'll give it a try next time I write something to see how well it works.
have you seen [trivial-types](https://github.com/m2ym/trivial-types) ? 
Nothing like writing your own code to make all the other libraries come out of the woodwork. I'll definitely look at defstar when I have some time, soon. I like my name better though! I thought about it for all of two minutes!
Indeed! I like yours, too. I think my problem with the defstar library is the change n syntax with the arrows and whatnot. I also very purposefully kept everything (name type), which I think is important. One of the things I love about lisp is how there's almost no syntax. Maybe we can combine them or something. I'm game. I also didn't handle docstrings, and probably more, I now realize.
Great! But why...?
why not?
I'd prefer keywords for optional things (defun-typed (foo fixnum :inline t ...) ...) say
For an intro to CL as such I'd recommend 'On Lisp' by Paul Graham, which he has released for free online. It was really readable and a fairly easy read. After that I would recommend 'Let over Lambda' by Doug Hoyte. Also readable and mostly easy, but every so often reading it my brain would halt, melt and catch fire.
The two recent blog posts http://netzhansa.blogspot.ca/2013/03/dealing-with-excel-files-from-common.html and http://abcl-dev.blogspot.ca/2013/03/mft-excel-format-from-common-lisp.html have finally inspired me to publish my library written in Common Lisp for dealing with MS Office binary formats. There are many gaps to be filled in but it's a good start and it's already solving real-world problems. I hope people will find it useful and who knows, maybe some will send a patch. Enjoy!
This, and pages linked to from that page, may be of interest to you: http://en.wikipedia.org/wiki/COM_Structured_Storage
Yeah... I can't read that yellow at all, could you please change it?
good point, fixed, thanks!
for those unable to get it to build using make: you need to add "-lrt" to the last line ;)
This is a big loss. I learned Franz Lisp from *LISPcraft* and *Common LISPcraft* was one of the first books I bought on Common Lisp. His research into Digital Libraries (where I work now) was very interesting as well: he will be missed. 
I don't understand what it's good for.
" It communicates with the user in a similar way to the well known and widely used read-eval-print loop. Simply speaking the REPL is a very powerful and generic way to talk to the computer ... The main difference from the standard REPL is that it has to handle different kind of input and output devices simultaneously. These IO devices include among others a keyboard, a mouse and a graphical display as a bare minimum ... " This looks looks sweet. I can't wait to try it. I have been thinking about an editor that can apply structure to plain ascii text files without imposing html directly into the text it self, and a viewer that can render these sorts of things. This project seems to provide a whole bunch of infrustructure to make this happen. Woot!
Most unexpected deaths happen only inside hospitals, genius. 
As a note, these sorts of editors seem to start to arise after people have worked with structured documents for a while. I could see this system being evolved to be a requirements management system, ala IBM/Telelogic DOORS.
First, it's an interesting project: it's taken an old idea and revivified it into a working system for today. This can be used to drive a variety of other projects, such as... Second, I have a passing acquaintance with requirements management software. This has to encompass specifications and linking out to other files. See Wikipedia for the details. They are entirely non-hackery and quite enterprisey. (Technically, transclusion is what you want, but RM software isn't that exciting) But-... what you need is a way to have metadata quasi-embedded into the data, and this data might be text, table, source code, etc, etc. Sort of an OLE-ish system. Having an intrinsic understanding of the source material is a significant benefit here: maybe you want to point out one particular part of the semantic structure and link that to another document. Typically you wind up doing regex kludgery and/or guesstimating based on the `div` contents (or similar).
sounds right. everything i touch is a structured document. even my notes will self define structure. indeed, and awesome to see something like this done in common lisp.
Now ESR says some things that are just erroneous, like objects don't know how to print themselves, but I do wonder what he means by this. Actually, I wonder if this is a common feeling amongst people new to Common Lisp. I remember CLOS being a stark change vs message passing, but I never thought that the code looked ugly. ESR even says that he likes the multimethod and generic function basis. Is there an intrinsic aesthetic issue with CLOS amongst new comers? Is it just the desire to write "string".print rather than (print string), i.e. a desire and familiarity with postfix?
This looks just like people who criticize Lisp only because of parenthesis: it's misinformed and idiotic.
It's a claim without a reason. Nothing to learn here. Move along. 
Great, I'll have to read it.
Ooo. This looks like fun! Thx. I will check it out when I have time. Thanks for putting this together.
As a technicality I don't think it is an ad hominem to describe a product of design as ugly.
Not liking the CLOS is only one of many things the author writes, and it is more a side node. So why bother and reduce this blog post to this one statement?
Nice! Web development in Lisp has become quite viable thanks to RESTAS and clack/caveman/ningle
On being told about print-object, ESR dismissed it. But there is also the [~/ format directive](http://www.lispworks.com/documentation/HyperSpec/Body/22_ced.htm) if you don't want to mess with the canonical print representation.
I'll pass on the CLOS comment, matters of taste and all. But I couldn't help noticing the actual content of the article, which boils down to: "My program had serious algorithmic flaws. Changing compilers and even translating to another language didn't help, because I NEED ATTENTION and all those technologies SUCK, also I'm an expert in this Lisp thing, I'm still excited about the lexical scoping thingie and I am able to casually use the words 'impedance mismatch'. So had to change the algorithms after all, which actually helped." I'd like those 10 minutes of my morning back, please.
Yeah, I especially liked the beginning of the page he links to, "Python for Lisp programmers". You can really see his "expertise" on Lisp: &gt; Python supports all of Lisp's essential features except macros, and you don't miss macros all that much because it does have eval, and operator overloading, and regular expression parsing, so some--but not all--of the use cases for macros are covered. So eval can replace macros, and Python isn't missing much in terms of macros except for the tiny little fact that you can't define your own... Fantastic.
Norvig is no dummy agreed. But still, there is an ingredient Lisp has that no other language has this way: Lisp can grok any Lisp expression without needing a parser. S-expressions are their own ASTs and that helps a lot.
Haha. Money comment on the blog. &gt; Jeff Read on Monday, March 25 2013 at 12:23 pm said: Well, looks like the Boston Lisp folks called it. At their last meeting a couple of weeks ago, some of them predicted that you would: &gt; a) discover that your speed problem is better solved by algorithmic optimization than by switching to a faster language or compiler; &gt; b) write a post critiquing the shortcomings of Common Lisp. &gt; They were pretty spot on except they thought you would critique CL’s lack of libraries, not the ugliness of CLOS. :)
Maybe CLOS is ugly, but it's better than any other object system I've seen.
Neither he is. He is still, however, wrong.
I particularly like this: &gt; CLOS objects are quite unlike Python objects (which are in many ways more like CL defstructs) I guess he hasn't noticed that you can define methods on instances of STRUCTURE-CLASS. Or that Lisp has these macro things which mean if you don't like the "naked" syntax of bits of the language you can dress it up how you like. I don't want to be nasty but what *is* it, in terms of software, that ESR has done which makes him so well-known?
And this is basically what happens when someone doesn't know what they are doing in a new language and think they know better: they collide full-tilt and the result is a mess. It's a cautionary tale for all of us smug lisp weenies. :)
Someone mentioned an old object system named T in the comments and remarked that it was very nice. A bit of searching returns these links: http://en.wikipedia.org/wiki/T_%28programming_language%29 http://mumble.net/~jar/tproject/ http://www.amazon.com/The-Programming-Language-Dialect-Lisp/dp/013881905X
As a Smug Lisp Weenie (SLW) I reject caution! They say I should wait and learn the intricacies of Lisp! Bah! Watch this: cl-user&gt;(ql:quickload :cl-Cthulhu) cl-user&gt;(PHNGLUI-MGLW-NAFH-CTHULHU-RLYEH-WGAH-NAGL-FHTAGN) Bwahahaha! **Bwahahaahahaha** **BWAHHAHA-OH My GOD MY EYES ARE MELTING!!!!!!** 
Absolutely nothing. He's a gun nut who thinks he knows something about technology.
esr was one of the famous F/OSS evangelists in the 90s. You can find his fingerprints in a variety of the basic Linux utilities &amp; man pages. And, fwiw, being articulate and having an opportunity to be in the spotlight often means you get to stay in the spotlight if you want to. Software is more than code, it's people. :-) 
Don't you have anything better to do than troll and be angry at gun owners?
I hear a lot of people recommend Practical Common Lisp. I'm sure it's a good book for some people, but I found it incredibly boring. I remember reading K&amp;R when I was learning C and it was exciting to me. The pacing was good, the examples were very illustrative (if unsafe), and I felt like the authors broke the language down into just the right size pieces to teach them. Practical Common Lisp, more often than not, had me saying "yeah, I get it". So I would flip forward a few pages and then be completely lost. New concepts were thrown in where the summary of previous things were, so if you skip what you find to be repetitive then you might just skip parts of new material. Like I said, I'm sure it's great for some (and I've heard lots of good things about it), but I couldn't force myself to finish the beginning chapters. I used other resources to learn what was at the beginning of the book. The later, practical chapters are great though, and worth the price of the book itself if you have never explored something like them.
Lol it sure would be.
One can imagine McCarthy, Wilensky, and Weinreb standing in Jedi robes looking on at the new generation... :-) 
The good thing you only have to type (p-rly-fh&lt;Tab&gt; when using fuzzy completion (no closing paren in case you're using paredit).
Because it was the only thing I found interesting for discussion. The overarching content of the post is suposedly on optimizing Python. As [cmm points out](http://www.reddit.com/r/lisp/comments/1b1wbl/clos_is_an_ugly_pile_of_ugly_esr/c938rvk), the parts of the post regarding pypy and cython are probably just crap. I don't even know what reposurgeon really does, nor do I really care. In the end, he did what anybody should have done from the start, fixed a algorithmic shortcoming of his software. Further, it looks like he had to rely on someone else to find the O(n^2) bits for for him rather than profiling and understanding his own code, something that is not typically a resource I have. So, all in all I think that this is a pretty bad example of Python optimization in the real world. I don't mean to sound caustic here, it's just that the topic of the post wasn't worth discussing, IMO. However, as an aside, ESR talks about an attempt to port to SBCL. Since I posted to /r/lisp, I assumed that people would understand that I wanted to focus on the Lisp related aspects of the post. [I already mentioned](http://www.reddit.com/r/lisp/comments/1b1wbl/clos_is_an_ugly_pile_of_ugly_esr/c92t0vw) that he is dead wrong regarding control of the printed representation of objects. I also suspect that he is correct that control of subprocesses might be much better supported in Python than in SBCL (for instance subprocess control is better supported in Bash than in SBCL, so good Python support wouldn't be much of a surprise). I, honestly, don't think that CLOS is ugly (so long as you are willing to accept Lisp syntax in general). It made me wonder if this was a common sentiment.
Isn't that what the internet is for? I must have been misinformed by my minions.
These guys invented stuff before I was born that languages are still trying to integrate. Indeed.
I was surprised how congenial the whole conversation was on his blog given the racy conclusions he came to. It worked out better than expected.
I saw the dependency on Bordeaux threads and am a bit confused. This only handles transaction, correct? So I need to make threads seperately if I wanted to use threading? 
Gotta say, I think the author's just trying to make Lisp seem a lot more politically relevant than it actually is.
What is this I don't even
I don't think this has one bit to do with Lisp, but everything to do with the backwardness of not allowing gays to enter legal partnerships with the same rights as straight people.
I see there's a connection to Lisp, but what I wanted to say is that I think the post is a political opinion backed by the blub paradox as an argument, and not a programming language opinion backed by gay marriage as an argument.
Fair enough, though I think that was pretty obvious; if your ultimate point is that this article therefore does not belong in /r/lisp because it is not really about programming in Lisp then I will concede that you are probably right --- I honestly hadn't noticed until just now that it was posted in this subreddit.
The subreddit is not only about 'programming in Lisp' - it is about 'Lisp'. Its people. Its projects. Its programming problems. Its books. Its history. Its future. Its public perception. Its conferences. Its applications.
I agree, but it is still debatable whether a political discussion of gay marriage that just so happens to use Lisp as part of analogy fits.
I liked the part where [Tim Berners Lee fixed someone's html markup](http://www.forbes.com/sites/timothylee/2013/03/26/how-gay-marriage-is-like-lisp/?commentId=comment_blogAndPostId/blog/comment/1598-2269-1373). That would be equal parts embarassing and awesome.
I've found this article very funny. Haven't you ?
Worst analogy ever.
[Today I'm going to compare and contrast Spam and Racism](http://www.youtube.com/watch?v=zhG5hB-Fuig)
Nice catch.
Xpost to programming
Possibly, but it does get points (from me, at least) for creativity.
Awesome! Some features like multiple icons/buttons and auto layout are still not present in today, 'modern', GUI builders. We had pretty advanced tools and languages 20 years ago (CL, Smalltalk, Oberon). Now, today we have enormous CPU power, memory and disk size but still are plumbing single damn button in css, html and javascript. Sad.
Indeed. I now have the problem that I cannot STAND looking at js/html/python/perl/c etc. The moment that I have to interface with any of these types of things I feel like I die just a little inside. It isn't so much that I want a perfect world, it's that I want an easy world. We had all of this oh so long ago, why do we keep on re-purposing sheit? Ultimately the answer is economics and an illiterate consumer, but damn, it just hurts to know just how poor we are despite the riches around us.
I think it would be cool to try getting this ported to the Ouya.
This looks really cool. Good job!
I played around with https://github.com/ageneau/ecl-android. Once compiled and installed you have ECL running on your Android device/emulator including a REPL, etc. However loading modules like cl-opengl or lispbuilder-sdl isn't working, which makes it pretty hard to port things over to Android. I looked at blocky/2x0ng an saw that you are using SDL....Or would you use a completly different approach, e.g. get rid of SDL ? 
Exciting! How did they find your game do you think?
How can I start diving into the sbcl source code?
Oh! I found them actually---the site says it is open to unknown indie devs, so I took a chance and emailed!
Thank you miah_ :)
Yes I will have to do a lot of thinking and research----once I get a device...
A bit off topic, but I see that there most platforms are significantly behind on the binaries that can be downloaded. A lot of these platforms don't really matter much any more, but 32 bit GNU/Linux is still quite popular (i.e. the recommended download from Canonical). Is the issue that the SBCL project needs some maintainers for those particular builds? I am using 64 bit Ubuntu, so it isn't a big issue for me, but does it indicate that the project could use some loving from some of the more diverse user-developer base? Also, does anybody know what it would take to host a PPA for Ubuntu (or similar for Debian)? This would make it easier to instruct people in what it would take to install a relatively new SBCL version.
Really nice game, well done David!
Build SBCL from git, install it, and M-./M-, away in SLIME.
Building SBCL is fairly simple (compared to CLISP or CMUCL, for instance), so developers don't worry too much about consistently uploading binaries for the latest and greatest. There's a small group of people who try to build and upload binaries for the platforms they use. If you're interested in helping, you could start posting links to release tarballs on sbcl-devel.
http://www.sbcl.org/gsoc2013/ideas/ 
You will probably want to look at some papers as you go to get a good idea of how the python compiler works and how the sbcl build process works if you'll be working on either of those. The wiki http://sbcl-internals.cliki.net/index is helpful and the papers http://sbcl-internals.cliki.net/Papers are pretty informative.
Why did you choose to use GPLv3 instead of the LLGPL (or some other license)?
I didn't know about the Lisp Lesser preamble until later. Besides I have no idea whether it's any good legally, or whether it conflicts with the new v3 (I think LLGPL dates from GPL v2 era.) 
It's the first of that month.
Yes, what I'm saying is that I need to have someone evaluate whether LLGPL can be used together with GPLv3 without issues (I have zero clue of the legal status of LL preamble as it is. I don't want to just slap this text on.)
And a two page writeup here: http://indiestatik.com/2013/04/01/2x0ng/
&gt; - Easier to read, compare: (+ (expt 2 30) 2) with [+ [expt 2 30] 2] &gt; - The [] keys are closer to the central row of your keyboard than the less comfortable (). &gt; - You don't need to hold the shift key to type [] therefore you can code faster. Yep, but now we have a *brackets problem*. I propose &lt;+ &lt;expt 2 30&gt; 2&gt; The two advantages above apply: &lt;&gt; are even more central; no shift key. Clearly, in order to bring Lisp into the 21st century, in the long run we need other kinds of parentheses. *Suggested milestones:* 2015 (codename: *Supreme Style Lisp*) ⟨expt 2 30⟩ 2020 (codename: *Battle against Gravity Lisp*) ⌊expt 2 30⌋ 2025 (codename: *The Sky is the Limit Lisp*) ⌈expt 2 30⌉ Yep, you will need a new keyboard. The price of progress I guess.
See MDL. Example: http://www.retro.co.za/adventure/zork-mdl/rooms.mud &lt;DEFINE XUNAME () #DECL ((VALUE) STRING) &lt;MAPF ,STRING &lt;FUNCTION (X) #DECL ((X) CHARACTER) &lt;COND (&lt;OR &lt;0? &lt;ASCII .X&gt;&gt; &lt;==? &lt;ASCII .X&gt; 32&gt;&gt; &lt;MAPSTOP&gt;) (T .X)&gt;&gt; &lt;GXUNAME&gt;&gt;&gt; MDL was an semi-influential 'Lisp dialect' in the 70s. For example CL's extended lambda list originated there.
And by 2030 (codename: *Literate Lisp*) "+ "expt 2 30" 2" Want quotes? "print '"expt 2 30""
Structure editors, while interesting, seem to be to low level, as they are still tied down to the text representation of code, just presented in a more fancy way. What [Subtext](http://subtextual.org/subtext2.html) does is quite a bit more interesting, as it moves beyond text without falling into the traps of visual programming.
Common Lisp already has this as Pascal Bourguignon pointed out years ago on [comp.lang.lisp](https://groups.google.com/d/msg/comp.lang.lisp/Nvdio3taI0Q/bn_VqLTaxG4J) I'll put it here for the lazy: (set-syntax-from-char #\[ #\() (set-syntax-from-char #\] #\)) (set-macro-character #\[ (lambda (stream char) (read-delimited-list #\] stream t))) [map nil [function print] '[a b c]] A B C --&gt; NIL 
I've released a mac version: http://blocky.io/2x0ng-1.0rc1.dmg
This is epic, thanks for the link.
I had a fantastic time in 2011, and am very excited about going this year.
One site that I use to practice programming and maintain my thinking skills is projecteuler.net. Essentially its just a bunch of number theory problems, but they get hard fast.
[sbcl-1.1.6 cannot compile SVREF and (SETF SVREF) of symbol macros](http://www.advogato.org/person/crhodes/diary/163.html)
It's impressive how everybody seem to have fallen for the joke, it is a great joke.
actually I do think ⌈expt 2 30⌋ or ⌊expt 2 30⌉ is a good idea...
Now *that's* awesome.
This paper seems to be unaware of the later InterLISP stuff, particularly SEdit. That's sad, since SEdit beat the shit out of any other structure editor I have ever seen, anyway.
Assuming the insert function is supposed to return a list that is like the input list but with object inserted at position N, your function is incorrect. For example, (insert 'a '(b c) 0) does not return (a b c). There is also the question of what the function should do when N is larger than the input list's length. Should (insert 'd '(a b) 3) signal an error or should it fill the missing elements with some value? Your function also is quite inefficient, using subseq and append to construct the result, position and last to find the length-1. Here's a simple implementation: (defun insert (object list n) (check-type n (integer 0)) (insert-1 0 n '() object list)) This checks that N is a nonnegative integer and calls an auxiliary function to do the actual work. We can think of the list as three parts: a left-hand side, the object, and a right-hand side. The auxiliary function will iterate to the position N, all the while constructing an appropriate left-hand side and iterating the input list to get a right-hand side. When it reaches that position, it will construct the final list. (defun insert-1 (i n lhs object input) (cond ((= n i) (revappend lhs (cons object input))) ((null input) (insert-1 (1+ i) n (cons nil lhs) object input)) (t (insert-1 (1+ i) n (cons (first input) lhs) object (rest input))))) Again, if we reached the position, we construct the final list. The remaining input is the right-hand side. Since we construct the left-hand side in reverse, we need to reverse it back when constructing the final list. Common Lisp provides us with REVAPPEND, which is a more efficient way to say (append (reverse a) b). If we've not yet reached the position, but the remaining input is the empty list, we just fill the missing elements on the left-hand side with NIL until we reach it. Otherwise, we've not yet reached the position and there is still input. We move one element from the input to the left-hand side and go to the next position. Of course, this code can be improved. We can use LABELS to "hide" the auxiliary function and pass fewer arguments each time. We can use an optional or key parameter to say what should happen when N is larger than the length of the input list, and if filling, what object to use for it. I'll leave it as an exercise to the reader.
He's (one of) the inventor(s) of emoticons ! Lispers are amazing.
You are aware that there is a Clojure subreddit? http://www.reddit.com/r/clojure/
Along with what others have said (about your function not really returning the correct values), you should realize that length, subseq, position, last, and append all iterate over at least part of the list (length iterates over the whole list). Might I suggest a simple recursive solution: (defun insert (list value n) (if (&lt;= n 0) (cons value list) (cons (car list) (insert (cdr list) value (- n 1))))) Obviously you can declare/check types if you need to, or just let it fail when it cannot compare n to a number or subtract from it). edit: For funsies an iterative version: (defun insert (list value n) (let* ((head (cons :head nil)) (tail head)) (dotimes (i n) (let ((new (cons (car list) nil))) (setf (cdr tail) new tail new list (cdr list)))) (setf (cdr tail) (cons value list)) (rest head)))
Your solution is a lot better than my deleted solution. Besides being shorter, it's faster. I'd just change (- n 1) to (1- n).
Some issues I see: * `push` pushes to a place, so where you are using it you could use `cons` or `list*` and it would make more sense and be less computation * `subseq`s third argument is optional, if you just want the rest of the list elide it. Alternatively consider `nthcdr` * `(position (last target) target)` wont alway return the end of the list. (eg: '(3 3 3 1 1 1 2 2 2 3 3 3), will cause you issues, because the last element is 3, and `(position 3 target)` =&gt; 0 * rather than `(append first-list (list val) other-list)` you can `(append first-list (cons val other-list))`. Not a big deal, but less computation and fewer forms.
Perhaps this subreddit should rename itself to /r/commonlisp to avoid people being confused that this was for general lisp topics?
Figuring out how to use a local jar when there is nothing available in Maven/Clojars was one of the more frustrating experiences I've had in Clojure. That said, leiningen is a work of beauty in terms of how well it integrates with clojure and the rest of the java ecosystem.
Good point. I tend to follow both (also r/scheme) mostly because the volume is so low, and because it's neat to see the different perspectives afforded by the CL and Scheme communities. I also see that the r/clojure sidebar fails to mention the other lisp subreddits. That is a shame.
 (defun ninsert (val target n) (cond ((&lt;= n 0) (cons val target)) (t (push val (cdr (nthcdr (1- n) target))) target))) 
They put up a quick bit about 2x0ng on the Free Indie Games blog: http://www.freeindiegam.es/2013/04/2x0ng-david-otoole/
Yes, you will have to use some kind of a GUI library. I think that GTK is a better (and modern) alternative to Garnet. Instead of Lisp Builder, Quicklisp is nowdays the most popular way to use third-party libraries. Apparently, CLISP has some kind of bindings to GTK: http://www.clisp.org/impnotes/gtk.html So that you have everything you need (now) already included.
Yes, let me know what platform if possible. (I'm guessing 64-bit Windows.)
Sorry, that's silly. I responded asking for your platform info , from the "new message screen" and didn't see the upper Mac context of the thread. Ok, let me know if you are able to run the game from the shell and get standard output.
I cut of the upper lines, like loading of SDL functions, etc. ConnectPort: can't find mach server port name = jackdmp_entry.501_default err = unknown error code Cannot connect to server Mach port jack server is not running or cannot be started Opening project: STANDARD Set project path to /Applications/2x0ng.app/Contents/Resources/projects/standard/ Reading data from /Applications/2x0ng.app/Contents/Resources/projects/standard/index.blx... Reading data from /Applications/2x0ng.app/Contents/Resources/projects/standard/index.blx... Done. Loading 232 resources from file standard:/Applications/2x0ng.app/Contents/Resources/projects/standard/index.blx... Looking for object database /Applications/2x0ng.app/Contents/Resources/projects/standard/database.blx... No database file found. Continuing... No system variables file found in this project. Continuing... Started up successfully. Indexed 983 resources. Opening project: 2X0NG Set project path to /Applications/2x0ng.app/Contents/Resources/projects/2x0ng/ Did not find index file /Applications/2x0ng.app/Contents/Resources/projects/2x0ng/index.blx in project 2x0ng. Continuing... Starting without database or variables loading, due to user command. Started up successfully. Indexed 983 resources. Simulation update time set to 33 milliseconds. Creating OpenGL window... Creating OpenGL window... Done. SDL driver name: Quartz Setting frame rate to 30 Scanning for connected joysticks... Finished initializing Blocky for project 2x0ng. Signal 13 masked fatal error encountered in SBCL pid 6876: some deferrable signals blocked, some unblocked JAR: Blacklisted client Xquartz JAR: Blacklisted client Terminal JAR: Blacklisted client loginwindow JAR: Blacklisted client Xcode JAR: Blacklisted client SystemUIServer JAR: jack server not running? I tried also with jack server running (the one which comes with fluxus), but same error.
Dear AnotherLisper, Please stop flooding /r/Lisp with Clojure stuff. There is /r/Clojure for that. I come to /r/Lisp to read about Common Lisp and maybe an *occasional* link to outside that sphere when it actually merits.
Hi. I've released an updated version for Windows, which should fix the crash issue that had made the game unplayable on some versions of 64-bit Windows. This one is built with CCL and appears to work: http://blocky.io/2x0ng-win32-1.0rc1c.zip
I noticed "McCarthy fanfic" in the ideas section. Haha, that would be... interesting.
Thanks for this info. Am still working on this...
Garnet is pretty old and afaik unmantained. You may have better luck looking at the X window manager Stumpwm and the underlying CLX library.
The contact form on both this site and LispNYC's is broken (500 error).
I just pre-ordered mine with the 30% discount.
If you're particularly interested in graphics or games, [lispbuilder-sdl](http://code.google.com/p/lispbuilder/wiki/LispbuilderSDL) is worth your consideration.
The specific post 1.1.6 patch to fix this can be found at https://github.com/sbcl/sbcl/commit/e626db9d157d8790efe3762a7f46cc347161f8e8
Some dude wrote a keylogger using clx years ago, pretty sure I have the code on my old computer somewhere. I'll try to find it when I get home EDIT: Found it online http://hocwp.free.fr/temp/clx-keylogger/clx-keylogger.lisp.html
LispWorks uses mailboxes: http://www.lispworks.com/documentation/lw61/LW/html/lw-1058.htm#37778
mailbox in SBCL: http://www.sbcl.org/manual/index.html#sb_002dconcurrency
or about anything else that has its own bloody dedicated subreddit. (and I don't even have anything against Clojure).
Let's hope WJ never finds out about reddit.
is he the one that wrote those annoying "Ruby: " posts?
I don't mind the occasional non-CL post. I think the Lisp family has a lot to teach each other about interesting topics- * hygenic macros (Scheme) * fexprs (Kernel) * typed languages (Qi/Shen) * dynamic scope (NewLisp/elisp) But I don't know that AnotherLisper is being particularly respectful of the existing community.
There isn't any overlap between AnotherLisper's links and those posted to /r/clojure -- except for his first post which appeared in /r/lisp days *before* the link was posted to /r/clojure by someone else. This is not "best of", this is trolling. I would guess it is WJ from cll. I don't mind an occasional Clojure post that has some relevance. That's not the issue here. We're talking about a guy with a clear agenda. He doesn't post to /r/clojure. He doesn't post to anywhere else! He doesn't post *about* anything else! He only posts clojure stuff to /r/lisp.
I think the real problem is not the presence of Clojure posts, per se, but the frequency of them. This guy is posting a Clojure link every single day and turning the Lisp subreddit into noise for those of us who are uninterested in Clojure.
I just found this sub the other day because the dude posted a clojure link of mine and I was wondering where the traffic was coming from, so sorry to be part of the problem. I have no idea who he is or why he's all up in this sub. That said, the sidebar material doesn't make it clear that only Common Lisp links are welcome, or that Clojure ones aren't; "the Lisp family of programming languages" is fairly open to interpretation. It could be that the dude just really likes Clojure?
If we all downvote him persistently enough, his links will disappear. Reddit is inherently democratic in a way, if most people do not mind Clojure links and dont downvote them, they will stay. So downvote away. Also, the current mods should explicitely designate /r/lisp to Common Lisp, so that no misunderstandings arise. If /r/lisp is about Lisp in general, and not about Common Lisp in particular, then "the Lisp" doesnt exist and Clojure is explicitely welcome, since it is, like Scheme, "a Lisp".
Well, I'd be more comfortable with this if this was the Common Lisp subreddit. But where is one to go to discuss general Lisp related issues? I'd agree that articles pertaining to Clojure alone don't necessarily belong here, but articles comparing Clojure with Scheme might? It isn't like there is so much traffic in r/lisp that things are getting pushed off the front page really fast or anything, so I guess I don't see the point of getting bent out of shape about it anyway. 
So having less content overall is the best solution to decrease the ratio of Clojure content, and not compensating with more content of another kind?
From the side bar: &gt; A subreddit for the Lisp familiy of programming languages. From Wikipedia: &gt; Clojure [...] is a dialect of the Lisp programming language I guess if familiy is not the same thing as family...
AnotherLisper vs random_lisper. The battle of the century. 
&gt; A subreddit for the Lisp familiy of programming languages. Where does it say that clojure doesn't belong here?
Why not create an r/commonlisp for that and let r/lisp be for general lisp stuff and interlisp comparison?
&gt; or about anything else that has its own bloody dedicated subreddit So no Lisp stuff in /r/programming? No programming related stuff in /r/technology? /r/lisp's sidebar says "A subreddit for the Lisp familiy of programming languages" and even mentions /r/clojure under "Other Lisp related subreddits" which sure makes it sound like Clojure related content is welcome here. There actually is an /r/commonlisp. Yeah, it's pretty barren, but maybe commonlispers who aren't interested in seeing stuff about other Lisps should go there instead? And if you feel that there's too much Clojure content here perhaps a better fix than complaining would be to post more content about the Lisps you do care about?
I suggest everyone take a look at adambard's reddit history: http://www.reddit.com/user/adambard/ * He is promoting an "automated marketing" tool for reddit that can post to reddit on a schedule * The website for this automated marketing tool (www.redditlater.com) solicits for paying customers: "If you are a cynical marketing person who wants to pay me for this service, please contact me." * A link to his own web site, adambard.com, has been promoted by AnotherLisper * He commented on this very post trying to sow doubt about this being spam: "It could be that the dude just really likes Clojure?" Maybe email spammers just really like Viagra, too.
I reported two of AnotherLisper's posts this morning. It is the first time I have reported reddit posts. Having frequented this subreddit for a year or two I feel that we are Common Lisp *leaning* but welcome to all lisp content. AnotherLisper however, was posting Clojure content at a high frequency and is only active on /r/lisp. As p_nathan and random_lisper have said, the problem is a sort of disrespect of the existing community and its norms. I welcome moderate amouts of quality Clojure content and would be happy to see AnotherLisper join us and help grow this community. Just tone it down a little, not *every* Clojure blog post is worthy of /r/lisp. Same goes for CL posts! :)
This is one case of a problem child, and it can be addressed without getting into other issues. He repeatedly ignores polite requests to stop spamming r/lisp. He doesn't explain himself. This pattern is all too common on cll. I don't want /r/lisp to suffer the same fate.
So you should post all CL topics on /r/commonlisp, then. As far as I, and the sidebar, am concerned, this subreddit is for Lisp as a whole, not the "Oh, I believe Common Lisp is the only Lisp" folk.
I thought we had downvotes for that...
There's a difference between an occasional clojure post and a guy who * frequently posts clojure links to /r/lisp * never posts to /r/clojure or anywhere else * never posts *about* anything else * ignores polite requests to stop spamming /r/lisp * does not explain himself or interact in any way Anyone familiar with comp.lang.lisp will recognize this pattern. We clearly have a problem child here, and this needn't be conflated with quibbling about what's acceptable or not.
I wasn't going to say anything, but I noticed he edited [his comment here](http://www.reddit.com/r/lisp/comments/1c2mi7/troll_alert_in_rlisp/c9cgk5j). It originally said "I the dude posted a clojure link of mine" and later he removed the "I".
&gt; ignores polite requests to stop spamming /r/lisp if the material is actually acceptable (which you don't seem to dispute), then this doesn't seem to be a legitimate complaint. he shouldn't have to stop. you just want him to act less weird.
A legit typo, honest! I also changed "find" to "found".
What does "not responsive to downvotes" mean? Do they have some magic hack which means their posts continue to show up even when they fall below whatever your threshold is set to?
 &gt;Also, the current mods should explicitely designate /r/lisp to Common Lisp, so that no misunderstandings arise. If /r/lisp is about Lisp in general, and not about Common Lisp in particular, then "the Lisp" doesnt exist and Clojure is explicitely welcome, since it is, like Scheme, "a Lisp". Please don't do this. There is quite enough CL elitism already.
Because only Common Lisp has "Lisp" in the name, and thus claims the throne of Land of Lisp. Clojure, Scheme, Racket, etc explicitely decided not carry Lisp in their names because their authors *do not want* them to be perceived as "just another Lisp dialect". &gt; for general lisp stuff and interlisp comparison There is no general interlisp stuff and interlisp comparison. If there is demand for such stuff, and there usually isnt, it can easily be cross-posted and nobody would mind.
oh, I wasn't even aware of /r/commonlisp's existence up to now. it doesn't look very populated.
do posts like "Speclj, a TDD/BDD framework for Clojure" belong _anywhere_ but the special Clojure subreddit (and perhaps a TDD/BDD subreddit, if such exists)? I'd like a serious answer, please.
Other things from the side bar: &gt; Other Lisp related subreddits: r/scheme, r/clojure, r/racket No explicit mention of /r/common_lisp (does that even exist?). The only reason to not explicitely mention the elephant in the room is if the room was intended to house the elephant, while the linked "others" have their own ones. &gt; Useful Lisp resources: &gt; Planet Lisp &gt; Quicklisp &gt; LispForum &gt; Cliki &gt; Common Lisp Directory &gt; Common-Lisp.net &gt; Common Lisp Hyperspec &gt; comp.lang.lisp &gt; Common Lisp Professionals Mailing List All common lisp links. No Scheme links, No Racket links, No Clojure links. &gt; Free Lisp Books &gt; Practical Common Lisp &gt; On Lisp &gt; Common Lisp: A Gentle Introduction to Symbolic Computation &gt; Common Lisp The Language (Pre ANSI Lisp) &gt; Structure and Interpretation of Computer Programs (Scheme) So basically the side bar is chock full of CL stuff, and besides SICP mentions the other dialects only as "other subreddits". If you ask me, this very certainly implies an intended focus on CL.
you know, when i first saw this post, i thought "geez, anotherlisper must've been posting dozens of things for weeks", and i was merrily going along under that assumption. i just looked. he's posted 8 things in about 8 days. 1 of which was realm of racket (not clojure!), which still has a positive vote count. at this point i consider you and random_lisper completely unreasonable.
Signal to noise. Flooding /r/lisp with Clojure content makes as much sense as flooding /r/cpp with Java.
The spam problem is what voting fixes: no other fix is needed.
Just to give an impression of the size of the problem: of the 25 posts mu client (Alien Blue) is showing me currently, 1 is from the person being complained about here.
One post a day is actually a lot in /r/lisp. It's not the front page of Hacker News. It's a small subreddit. In the 8 day period you cite, there have been 13 posts (excluding this one) and 8 of them came from AnotherLisper.
I can understand how Clojure is a Lisp, since it is. I just don't see how Java is a C++.
I guess the very first sentence in the sidebar may have been clumsily worded at the time of writing, which is a little sad since the first impression is important.
Do posts like "cl-olefs, step towards reading ppt, doc, xls in common lisp" belong anywhere but the special Common Lisp subreddit (and perhaps a Microsoft Office file format subreddit, if such exists)? "I'd like a serious answer, please."
I agree. I don't see what the problem with having Clojure content in r/lisp is. I subscribe to r/lisp, r/scheme, and r/clojure. The volume in all three combined is low enough that I'd almost rather there be one r/lisp that contained info about all lisps. Looking at the pattern of downvoting of Clojure-related content in this subreddit makes me think that there are some people who really want an r/LispsExceptClojureBecauseThatThingIsNew subreddit. Seeing how badly the poor dude who posted an honest question about NewLisp and his blog generator got flamed to death (can't find the link because shabavh is apparently no longer a redditor--I only found his username because I wrote him an apology for the treatment he got here), maybe this subreddit does need to revaluate what kind of community it wants to be.
I would humbly suggest this is a Common Lisp subreddit. I don't suggest that Common Lisp is the only "real" lisp or the "best" lisp. This isn't about elitism. While non-CL posts are not explicitly banned, I think a statistical survey of all posts on this reddit would demonstrate that the majority are CL posts with occasional dips into other lisps. I don't actually think there *is* a general lisp reddit but that would be a nice thing to have. I realize that the sidebar claims this is &gt; A subreddit for the Lisp familiy of programming languages. but it also lists `jeresig` and `mortenaa` as moderators and I don't recall seeing either of them post or comment in the several years I've been here. Like Freenode's #lisp, I believe this reddit to be dedicated to Common Lisp. Unlike Freenode's #lisp, I believe we tolerate some non-CL content and I think that's fine. Perhaps that is the core miscommunication here, bolstered by the lack of active moderation or administration by jeresig and mortenaa. I have contacted them and am open to suggestions as to how to improve things.
It would appear he hasn't really posted that much, [or exclusively Clojure content for that matter](http://www.reddit.com/r/lisp/comments/1bwtvg/barski_felleisen_van_horn_et_al_realm_of_racket/). 
It appears this has been a divisive issue because the masthead says &gt; A subreddit for the Lisp family of programming languages. It probably says this because jeresig and mortenaa wrote it but have not been active here for some time. Consequently, the majority of posts over the past year or two have been CL-related but the vast majority of readers (many of whom do not post) expect that this is a general-lisp reddit. No wonder this conversation is so heated. :-(
Yeah, [he's posted all of 8 things in 8 days to r/lisp](http://www.reddit.com/user/AnotherLisper/submitted/), and 1/8th of that content was Racket related. I do think we have a problem here, and it's not AnotherLisper.
The binary release for OpenBSD doesn't run out of the box on 5.2 without doing a non-obvious library symlink due to minor version number changes. I managed to build of the most recent SBCL source release but I wasn't sure how I could package it to get it up on the main site. Do you have any directions for packing up the built binary for submission?
Considering in the same 8 day period there were only 13 posts total (excluding this one), this makes subscribing to /r/lisp like subscribing to AnotherLisper's personal link stream.
You're complaining about more lisp-related content? You should go check out /r/java or /r/python some time. How I read this: "I want content about lisp, but not all lisps--forget that we said that, but not too much, and not too much by one user." I agree with flammableweasel's [comment above](http://www.reddit.com/r/lisp/comments/1c2mi7/troll_alert_in_rlisp/c9ckkq2) and I now consider a certain segment of /r/lisp to be completely unreasonable.
But you've failed to make the case that Clojure is off-topic by the charter of the sidebar. And 7 posts about Clojure in 8 days seems like a bizarre threshold for "dominated." If Common Lisp is what people here want (it's not what I want for /r/lisp--I'm happy with the current charter), then I suggest that you can find what you're looking for in /r/common_lisp.
Regardless of what it says on the sidebar (and FYI most of the links are CL links), /r/lisp *is* focused on CL by actual historical usage. I admit that "dominated" may be somewhat off the mark, but 7 posts in 8 days (out of 13) is still the majority of submissions and is a lot to come from a single user who ignores community etiquette.
So let's get it together on /r/lisp and *spell out* what is appropriate content, rather than expect people to infer something contradictory to what is clearly stated. And then if there is a rule for how much content is too much, then that should be spelled out too. As it is, what appears to be a small minority of /r/lisp has decided to attack a particular user (i.e. calling him a troll, and reporting stories that *still fit within the charter of the sub-reddit*). You keep saying this user is ignoring community etiquette, but that etiquette as you define it seems to be 1. not spelled out (actually, spelled out in the converse) 2. in some cases insane ("less lisp content!") and 3. disagreed upon by a large number of the existing community. If /r/common_lisp doesn't fit your needs, then can I suggest starting /r/LowVolumeMostlyCommonLispButDefinitelyNotClojureContent?
This seems like a pragmatic solution to me. I hereby apologize to /u/AnotherLisper for reporting his posts without contacting him directly. As I wrote [here](http://www.reddit.com/r/lisp/comments/1c2mi7/troll_alert_in_rlisp/c9clnbb), I have thought of this as a predominantly common lisp community for a long time. A revising of the charter and, perhaps, the movement of many posters to the mostly inactive common_lisp subreddit is worth consideration.
I believe that's what binary-distribution.sh is for.
The reality here is that, if he truly is spamming the sub for a long enough period, then no one would be arguing here. This is not an argument about whether or not cross posts and non common lisp material should be here. It is welcome. This argument is between those that want to nip a spam issue in the bud and those that want to see it drag on for ever until EVERYONE has 100% clear proof that it is annoying in spam. Heuristics are hard. How long do you have to let it go on before it is classified as spam?
random_lisper supported by upsetlisper.
I think there are three things going on here. Firstly, there has been some historical bad blood between the Clojure people and CL people, which mostly seems to have originated at the Clojure end. This is almost a repeat of what happened with Dylan where, presumably in a confused attempt to attract users, various Dylan people said somewhat nasty things about CL. The tragedy of this is that all this effort is aimed at the wrong target: a new language needs to gain users from languages with large numbers of users, not from other related minority languages. In Dylan's case this was C++, which was an easy target and remains such; in Clojure's case it is, I guess, Java, which is also a pretty easy target. Secondly there was (and perhaps is) a rather persistent troll in comp.lang.lisp, who had developed a violent hatred of CL, and posted various (initially) Ruby and (later) Clojure stuff, including resurrecting extremely old threads for this purpose. With no voting mechanism, and since this person would hijack threads, this made CLL even more toxic than it already was. The behaviour of this person was very different than AnotherLisper's, who does not hijack threads. Thirdly, and most unfortunately, there seem to be some people (perhaps only one person) who think that "Lisp" should mean "Common Lisp", and who are attempting to enforce their opinion by a combination of changing definitions (for instance declaring that CL is the only Lisp), and by forcing non-CL content out of Lisp fora. As someone who has used CL almost exclusively for a long time (when I learnt CL it had neither an object system nor a condition system) I find this extremely offensive and unfortunate, and this sort of elitist behaviour among CL users (again, perhaps it is only one) is actively driving me away from CL.
Hard to say. I'd guess it's because * he was a new member * he didn't respond to comments on his posts * 8 posts in 9 days is a lot of activity for this subreddit If trying to curb the frequency of his posts (because literally half the homepage was _AnotherLisper's_ content) is being too strict about "Common Lisp *mostly*" then we should codify that in the charter somehow. I do agree that cross-pollination and occasional posts about non-CL languages are a good thing.
Both /r/commonlisp and /r/common_lisp already exist.
&gt; as have been said in other places in this thread, most participants think of _this_ subreddit as the cl one. Most, or some? Have you actually measured this? The subreddit description says "A subreddit for the Lisp familiy of programming languages." Spelling errors aside, that makes it pretty clear that the sub is for all lisps, not just Common Lisp. If most subscribers managed to misread it... I don't know what to say. &gt; looks like the situation needs to be corrected. Agreed. People's expectations and the subreddit description should be made consistent. That could be accomplished by having a separate cl specific sub (like /r/commonlisp, which I mentioned previously) or by updating the /r/lisp description. Which route is taken is ultimately up to the community and mods, but in my mind, repurposing /r/lisp as the Common Lisp sub would be analogous to repurposing /r/programming as the C sub. The name would be deceptively general.
It's an interesting way to put a "Lisp Family" subreddit policy: All lisps are allowed, but common lispers decide what is welcome through moderation. Other lisp families better be happy with downvotes, though.
This entire heated conversation has come down to a difference between theory and practice. The masthead does say "Lisp Family" languages. In theory, we should get a diversity of content. In practice, the *majority* of postings on this reddit have been Common Lisp for the 2 years I can remember attending. I was happy with that distribution of content. Clearly, there is a large community that feels differently so we should deal with that. I think my comments elsewhere in this discussion show that I do not believe myself better than our other users, nor Common Lisp better than other Lisps. I am surprised at how problematic and divisive this issue was. Regardless, I want the entire **community** to reach a mutually beneficial solution.
Hey, thanks. Yours was by far the best response so far! I see exactly what you did there. It was just what I did, except without unnecessary variable definition and BS exceptions handling. Also, yours was the only response that wasnt all &gt;Pff, silly noob, he should leave the coding to pros like us...
Still early and lots to add but the front-end is mostly in place. If anyone is interested in contributing to [the repo](https://github.com/lamberta/minispec), the definitions are written in markdown so it's easy :)
Not a big fan. makunbound doesn't delete a special variable!
That info was gleaned from the CL Quick Reference. Hopefully with more eyes, and more pull requests, more rigor is applied over time.
Very useful! Thank you very much.
Cool, thanks for the suggestions. I went with http://minispec.org (I wanted to check for interest before dropping my lunch money on a domain :)
Sort modifies its input. '(1 2 3) is a literal list and the consequences modifying it are undefined. Use LIST or COPY-LIST. 
Right. For some reason I kept reading \*x* as *.
You have it right. I was not thinking about the right issue. 
If you adopt a functional paradigm, you should never change a value or reference, only return new ones. So you should (sort (copy-list *x*) #'&gt;). Not that you're obligated to use a functional paradigm. I program imperatively, too. But functional programming is more trustful.
I both like this ... and don't. +1 on the example driven nature. +1 on linking each symbol to CLHS. -1 on various issues of accuracy, consistency, and style. (Eg. SETF is listed in the "defining variables" section; FUNCTION, FUNCALL, and APPLY --and many more-- are in "definining functions" section; somewhat confusing usage of both dynamic and special variable without defining either; talking about SET and TREE is misleading and going to lead to sore thumbs -- they're lists; etc.) What I'm saying that this can become something wonderful, but that I would not point a newcomer at this yet. Lots of sorting out needed first. 
I would also strongly suggest (1) not keeping the CLOS section so separate (2) slicing it up into smaller pieces, and making sure those makes sense. A few examples: - ENSURE-GENERIC-FUNCTION is quite exotic in comparison to bread and butter DEFGENERIC and DEFMETHOD. - FUNCTION-KEYWORDS and METHOD-QUALIFIERS are even more exotic. They should be buried in an appendix. - SHARED-INITIALIZE should be listed right next to INITIALIZE-INSTANCE, because unless you're doing metaprogramming it's typically the one you want to use -- or should at least consider. Etc. IMO there's little point in listing all the bits and bobs of CLOS unless you also take time to explain how they hang together: someone who knows what they're looking for but doesn't remember the exact contract isn't really served by this, and someone who doesn't yet know how CLOS works as a gestalt will be lost wondering how they're supposed to use DEFINE-METHOD-COMBINATION. (The example you give is brilliant -- for the :METHOD-COMBINATION option to DEFGENERIC, but utterly useless for D-M-C.) Also, -1 on prominent CLtL2 links: it conflicts with ANSI CL in a number of places, and people keep getting confused unless they're given careful coaching on how "it's OK to read CLtL2, but don't assume anything you read there actually holds"... and even then half the time they still go and assume things which aren't so. 
Found it - http://s3.amazonaws.com/defunkt.baconfile.com/phosphorous.pdf
Some feedback: Your function `get-slime-buffer` already exists in Slime: `slime-output-buffer`. Unfortunately, it signals an error instead of returning nil, so you'd need to call it differently (`ignore-errors`). The idomatic way to default an optional argument is to use the `defun*` macro (recently aliased `cl-defun`) from `cl` (now `cl-lib`). (defun* get-slime-buffer (&amp;optional (buflist (buffer-list))) ... Unlike Common Lisp, Elisp doesn't use earmuffs as a convention for special variables. They're generally used for buffers not associated with files (`*scratch*`, `*Messages*`). The `progn` in `switch-buffers` is superfluous. I think `switch-buffers` is a poor name to use for your specialized buffer *toggling*/*swapping* memory function. Imagine someone coming across your un-prefixed function without context trying to guess at what it does. There's no need to mix `format`'s `%s` with `buffer-name` because `%s` uses the `princ` print form. You never declared `*temp-bookmark*`. I would just use a `let` for this. Or you could use `rotatef` as a cool trick here and avoid the temp variable. (rotatef (window-buffer (selected-window)) *buffer-bookmark*) 
I have something similar, except it (1) starts slime when necessary, and (2) uses find-tag-marker-ring to record the source buffer. (defun slime-switch () "Start Slime if not connected; switch to *slime-repl* if not already there; switch back to original buffer if in *slime-repl*." (interactive) (cond ((not (and (fboundp 'slime-connected-p) (slime-connected-p))) (ring-insert find-tag-marker-ring (point-marker)) (call-interactively #'slime)) ((not (eq (current-buffer) (slime-output-buffer))) (ring-insert find-tag-marker-ring (point-marker)) (slime-switch-to-output-buffer)) (t (pop-tag-mark)))) 
This is probably the main reason I avoid reader macros. It's enough that there are functions rewriting my code everywhere and the unsuspecting hacker has to decode all of it in his/her brain, but adding completely new non-sexp syntax on top of that can be confusing as hell in all but the most basic cases. Unless you are truly writing an end-of-the-line application that nobody else will build on top of, or have a very basic syntax addition without too much bells/whistles (cl-interpol comes to mind...it provides a lot of power, with a very small syntax adjustment), then it *is* too much power. Other than that, it's really not that hard. You have functions, macros, atoms, objects, just like any other language. Just document everything your library/application exports and then it's just a matter of reading the docs.
A very valuable feedback, thanks a lot for your time and patience!
Very interesting, thank you! I'm just a former C/C++ programmer that's fallen in love with Lisp after many years of total ignorance, and now I'm trying to recover lost time. But there's so much to learn, and I feel ashamed when I compare my meagre Lisp abilities to the skill of the experts in this beautiful craft... Yet I really adore it! (No, I'm not a youngster, I'm 50 ;-) )
s-expressions are a textual data format for numbers, symbols, strings, arrays, lists and a bunch of other things. Thus the first use of reader macros is to implement all these and to provide a simple way to add new textual data formats. This is perfectly fine. What CL kind of needs is a community registry for those (or some other mechanism), so that there are no conflicts, etc. You can do more with reader macros (like infix syntax, ...) - but above is perfectly reasonable. 
Not for a single person.
I'd say that the problem with (Common) Lisp is more the way it "looks" to the general public when compared with 'newer' languages, rather than its power and flexibility. Using Python as a comparison. Lisp might be very old in terms of computing languages, but that doesn't mean the resources for learning it have to be outdated and invisible. When they are people, especially hobbyist or casual programmers, will just go to a more visible and approachable. language instead. Visibility: Python * The top search result directs you to the Python foundation website, a modern, clean looking design which you'd expect to see on almost any website 2010. * The second result takes you straight to the PSF download page where you can download the CPython package of your choice. It also provides links to alternative Python Implementations which you might find useful. Common Lisp * The top search result is a wikipedia article... * The second result directs you to a half built webpage with no links to implementations or helpful information for new programmers. * The first implementation [result](http://www.clisp.org/) looks like it hasn't changed since 1990 Documentation: Python * Documentation easy to find on Python.org, Often comes with implementation download. * Presented well with good explanation of terms and enough detail for both new and advanced programmers. * tutorials, howtos and examples spread throughout. Common Lisp * Hyperspec not immediately visible * Hasn't adopted 'modern' user friendly approach, shows its age. * Lack of information on each individual page. * Too much jumping around. Ease of Use: Python * Easy to work with on almost any OS * Numerous choices for development, most of which are fairly friendly to new users. Common Lisp * SLIME is powerful, but sucks for anyone who hasn't used it before. Even copy/pasting is frustrating at first. Opinions/Discussion welcome. It'd be nice to hear the views of other, more experienced, Lispers on this sort of thing.
Always good to see someone take the plunge. A function of a thousand sexps begins with a single paren...
There's a lot of subtle signaling that happens when language resources are up to date (yes, including the aesthetics of the web pages), that lets new users relax a little that they're doing things right. Common lisp isn't that hard to get into. Quick lisp makes most package installation a breeze. However, that confidence I have now came with a lot of trepidation and uncertainty at first. Getting an environment set up looked very little like what Peter Seibel describes in PCL, simply due to the ways in which people get software have changed. Because so many people use python, and because the community refreshes things periodically, python rarely makes me feel like I'm unwittingly dropping into an archeological dig. Clojure, by virtue of being new, also makes it feel like most things you read will be current. That said, only time will tell if that cycle of renewal will prevail, or if we'll be cursing some legacy Clojure code in 10 years.
As a decidedly inexperienced Lisper, established terminology/method names such as cons, car, and cdr are what got me the most. It's silly, but it seems to me it was unnecessarily vague what these (quite) simple methods actually do, in addition to why they are called what they are instead of the more modern labels. (Which I am now aware there are reasons for) It's a silly issue and perhaps superfluous, but it goes along with your points that in general it is inscrutable.. And that's a shame. 
When you have a function call like `(+ 1 (- 2 3))`, Lisp looks at the first thing there (the function `+`), and then hands it the evaluated result of the other arguments. When you evaluate the expression `2` you get -- and you can try this in your repl -- the value 2! When you evaluate the expression `(- 2 3)`, you get the value -1. So the `+` function can't tell the difference between `(+ 1 (- 2 3))` and `(+ 1 -1)`.
I keep hearing that, but isn't that what macro expansion is for? I can't think of a single case in which reader macros caused Common Lisp code to be unreadable. Maybe I've just been looking in the wrong places. On the other hand, the tendency to nest eight levels deep, combined with indentation schemes that do not show the end of 'blocks' does make it hard to read. It's very easy to fix, though, and at least in principle, one could automate denesting and indentation changes.
I don't understand how it can change though. It goes from an expression being just '+' to '(+2 4)'.
Let's look at it simply. This isn't quite right, but is good enough for now. An expression is either: a *base object* or a function call. A *base object* (this is not a lisp term; I don't know of one, so if a reader does, please correct me) is either a *number*, *string*, or *symbol*. Symbols are bare text, like `+`, `if`, or `and`. *number*s and *string*s are, well, numbers and strings. (In lisp, you use double quotes to delimit strings, not single quotes). *number*s and *string*s are *self-evaluating*; that is, when you evaluate them, they return themselves. Try this in the repl! When you type `2`, the repl replies `2`. A function call looks like this: `( &lt;function-name&gt; &lt;expression&gt;* )`. So, an open parenthesis, a *function-name*, zero or more *expression*s, and a close parenthesis. A *function-name* is just a symbol. And we defined *expression* above. Let's say that you need to put gas in your car. You go to the station, and the attendant asks you how many gallons of gas you want. You answer him "twenty dollars worth of gas." But wait, "twenty dollars worth of gas" isn't a number of gallons. There's no button on the pump for "twenty dollars worth of gas". So before he can tell the pump how much to pump, he has to *evaluate* "twenty dollars worth of gas". In the same way, in the expression `(+ 1 (- 2 3))`, `+` can't do anything with the expression `(- 2 3)`. Can you? You can't add an expression to a number. So first you *evaluate* `(- 2 3)` to get its value, then add its value to `1` (from the earlier expression). That's how Lisp works: to evaluate an expression, evaluate each sub-expression, then hand each value to the function call. And you can even do this for the function itself! In Arc, a newer dialect of Lisp: arc&gt; ((if t + -) 1 2) 3 arc&gt; ((if nil + -) 1 2) -1 
The fact that so much written about Common Lisp seems dated and perhaps stagnant has a lot to do with the fact that the language hasn't changed. Because of that, most if not all of that dated information is still relevant, correct, and applicable. That to me is one of the major benefits.
Interesting. It still doesn't explain why when it's a single expression (+ 2 3) it will return '+', '2', '3'. And if it's bigger, it returns a bigger grouping. 
An expression is something that produces a result and contains 1 or more of either of the following: - Some "thing" that can't be divided into smaller parts. - Some "other thing" that CAN be divided into smaller parts. The important thing to note here is that the definition is recursive: the "other thing" is an expression. Expressions contain a grouping of some "indivisible things" and/or expressions. (+ 2 3) Is an expression. Since expressions can contain other expressions you can put that INSIDE another expression: (+ 3 (+ 2 3)) This new expression doesn't contain 5 "things"...it contains 3 "things". The first two +,3 are indivisible...the third just happens to be an expression that you could break down further; but on this level it doesn't matter...it still just considered 1 "thing".
Ok, this is easy. Basically, a list is a pair of parentheses and whatever is inside those parentheses. Maybe there's nothing inside -- and *that's* a null list. Another word for a null list is **nil**. (eq nil '()) T (eq nil ()) T See what I did there? One of these things is not like the other. In the first expression I quoted the list and in the second I didn't. Now let's put something inside the parentheses. '(+) (+) (+) 0 Now that's interesting! With the quote character before the left paren, lisp evaluates it as a list with a plus sign inside. *Without* the quote character, it returned zero. That behavior may seem surprising, so let's ask lisp what's on its mind: (documentation '+ 'function) "Return the sum of its arguments. With no args, returns 0." So now let's look a little closer into the single quote character because it seems to make all the difference in whether **(+)** is a list or a function call. It's really quite simple -- you see, that single quote is really just shorthand for a function named **quote**. In other words '(+) is the same as (quote (+)) said either way, lisp will answer with **(+)**. Now, what happens when I evaluate **(read)** and then type **(+ 2 2)**? Lisp responds by *printing* **(+ 2 2)**. But if I type **(+ 2 2)** directly into the REPL, lisp *evaluates* the expression and returns the result. (+ 2 2) 4 I'm sure you've encountered that term before - REPL. It means **R**ead, **E**val, **P**rint, **L**oop. Essentially, what the REPL is doing is a fancy version of (loop (print (eval (read)))) A minute ago when we ran read all by itself and typed an expression in, we essentially left out the **E** and **L** -- and just did the **R** and **P**! And *that* is what's going on in your code: You're reading the expression typed into the keyboard into the 'expression' variable binding. So when the expression typed in is **(+ (* 3 2) (/ 4 2))** and then in the body of the let form, say (first expression) it's the same as if you had said (first '(+ (* 3 2) (/ 4 2))) And because the three members of the *list* **'(+ (* 3 2) (/ 4 2))** are - + - (* 3 2) ; this is a list within the list - (/ 4 2) ; and so is this you get the predictable results that (first '(+ (* 3 2) (/ 4 2))) + (second '(+ (* 3 2) (/ 4 2))) (* 3 2) (third '(+ (* 3 2) (/ 4 2))) (/ 4 2) Now we get to what I assume is the actual reason for your assignment -- when lisp parses a list (except for special forms and macros), it evaluates the second and subsequent members of the list *and then* applies the function to those members. So the first member of the list is the function that is applied to the second and subsequent members. When the REPL encounters (+ (* 3 2) (/ 4 2)) it looks at the second member and sees that '(* 3 2) is a list and that the first member of that list is '*. So it looks at the second and third members and sees that they are both numbers, which are atomic. So then it does something like (apply #'* '(3 2)) which returns 6. Then it does the same thing for the third member and sees that '(/ 4 2) is a list and that the first member of that list is '/. So it looks at the second and third members, sees that they are numbers, which are atomic. So it does something like (apply #'/ '(4 2)) which returns 2. So now, the original expression has been simplified to (+ 6 2) At which point, the function '+ is applied to those atomic arguments. (listp '(+ (* 3 2) (/ 4 2))) T (atom '+) T (atom 6) T (atom 2) T (long-winded-p 'gensyms) T One approach might be something like (defun parse-expression (expression) (if (atom expression) expression (let ((operation (first expression)) (arguments (rest expression))) ; MAGIC GOES HERE ))) And lisp has wonderful facilities for learning about what's going on with your code. One of those facilities is called 'trace': (trace parse-expression) It'll show you what arguments a function was called with and what it returned. CL-USER&gt; (parse-expression '(+ (* 3 2) (/ 4 2))) 0&gt; Calling (PARSE-EXPRESSION (+ (* 3 2) (/ 4 2))) 1&gt; Calling (PARSE-EXPRESSION (* 3 2)) 2&gt; Calling (PARSE-EXPRESSION 3) &lt;2 PARSE-EXPRESSION returned 3 2&gt; Calling (PARSE-EXPRESSION 2) &lt;2 PARSE-EXPRESSION returned 2 &lt;1 PARSE-EXPRESSION returned 6 1&gt; Calling (PARSE-EXPRESSION (/ 4 2)) 2&gt; Calling (PARSE-EXPRESSION 4) &lt;2 PARSE-EXPRESSION returned 4 2&gt; Calling (PARSE-EXPRESSION 2) &lt;2 PARSE-EXPRESSION returned 2 &lt;1 PARSE-EXPRESSION returned 2 &lt;0 PARSE-EXPRESSION returned 8 8 CL-USER&gt; 
Just because the language hasn't changed doesn't mean the resources shouldn't be kept up to date with current presentation/design standards. Keeping them obscure and archaic has hardly grown the community.
Requiring modern design aesthetics for the documentation of a programming language, and using it as a yardstick of relevance, says more about the reader than the subject. I think in this case that growing the community is far less an objective than with most other programming languages. 
What description of `cons`, `car` and `cdr` did you see? I'm surprised you saw a vague description. I would have thought any source would describe them as "`cons` makes a pair, ` car ` returns the first element of a pair and `cdr` the second", which is not vague.
What was much less vague than why, to be fair. For some reason the vague why still made it hard to wrap my head around. Can't recall the first places I started reading, unfortunately. It was probably not the best reference to use, whatever it was.
Exactly what i wanted to say.
Perhaps not vague, but it *could* be confusing to a padawan, that the second element of a pair could be at the head of a big 'ol chain of conses.
My livelihood depends on everybody else ignoring Common Lisp. I'd be cool with renaming it CrotchRot-2000 and hosting all its documentation on geocities.
What command returns '+', '2', '3' ? Note that `(+ 2 3)` is *very* different from `'(+ 2 3)`. In the first, you're saying "add two to three". In the second, you're saying "construct me a list, where the first thing is the symbol `+`, the second is `2`, and the third is `3`.
I don't know. Mostly, i think it is about economics, not the tools. Show a programmer money, they will code in anything you want them to. It's all the same. As long as programmers get paid, they don't give a flip. They blog a lot about this and that, but in the end, only the all mighty dollar counts. Likewise, the reason that one language is chosen over another at the outset has more to do with the economics of the stack they are written on than the programmer/management. In a perfect world where everything is equal and there are extra costs to picking your fav language to develop in, Lisp would do quite well. In a world where the boss only cares about the dollar, all that counts is how quickly you can get it out the door. And, almost ALWAYS, the economics favour a large stack / ecosystem over a small one. And the cost of the stack is simply to the economic history of our industry. The imperative language guys were able to pump out a lot more crap than the Lisp folks riding the personal computer fad to $$ and they simply won. Once they established dominance the game was set and done. As well, a lot of good points are made about common lisp marketing. However, the real big bang will be when we see next big thing cash in and we all find out it is built on Common Lisp. Once people see there is money in it, things will change quickly. You just need 100 monkeys showing some cool high profile stuff and blogging about it and you will Lisp grow enormously into it's own niche. Just my thought on this. 
Not having a BFDL will keep Common Lisp in its niche status because of inability to evolve.
I've heard about reader macros for html trees, in what other use cases did you use r-macros with good results ? Someone should call Slava Akhmechet (owner of defmacro.org) to setup {reader,compiler,...}.defmacro.org
I think the Clojure documentation situation is quite bad. * ClojureDocs is outdated * Different pages on the main website apply to different versions of Clojure. * The API reference is little more than the function docstrings. * Any information prior to 2010 on seqs is outdated. * Any information on dynamic variables prior to 2010 is outdated. * Much of the information from those nice talks Rich Hickey gave in 2008 is outdated. * Much of the information on setting up with SWANK Clojure is outdated. There's certainly no nice canonical language lawyer's reference to the entire language like the Hyperspec. There's also no freely available online tutorial book up to par with something like Practical Common Lisp, Introduction to Symbolic Computation, or Successful Common Lisp.
Reader macros are for example sometimes used to integrated other languages or help with the FFI: * Objective C FFI calls * Specification of foreign symbols (with automatic lookup) in MCL * SQL query syntax in LispWorks' SQL interface 
I have done several integrations with Windows build of game engines and Corman Common Lisp, using Corman's DLL interface and header file including abilities. It takes me about two weeks to get things hooked up, and then I'm doing ninja things like changing methods and seeing updates on a DirectX/GL window in real time. Unfortunately, what I ended up learning, at that time games are still a huge pain in the neck to write in Lisp. C++ is much much much easier because of the libraries. Trying to deal with game physics in Lisp is the real problem. Graphics are relatively easy.
You had me at: - What it is: being a lazy asshole, I ... 
As a PHP programmer of 8 years, just now branching into Clojure; I concur.
Besides that, Common Lisp is not like Clojure, Ruby or Python, in this aspect. It is more similar to Java. It is a standard, having a BFDL won't make the standard magically evolve. Unless we have a really good benefactor. Not a BFDL, but simply some kind of organization that can setup meetings and ask the community for decisions, and then invest in update the standard (since most lispers say that Common Lisp is never updated because of money). More or less like Red Hat is for OpenJDK today.
The problem is information asymmetry -- clients, not being programmers themselves, lack the ability to distinguish a high-quality product from one of lower quality. When the sellers in a market know more about the thing being sold than the buyers, there exists a perverse incentive for sellers of lower quality product to misrepresent their goods to extract a higher price. The buyers who have bought higher priced, lower quality goods will then begin to discount the highest amount they're willing to pay -- thus driving the prices down. When the prices drop too low, the sellers of the *actual* high-quality products exit the market because the highest price buyers are willing to pay is now lower than what they're willing to sell for. That's what's going on in places like odesk and a much better explanation of the phenomenon is outlined in "[The Market for Lemons: Quality Uncertainty and the Market Mechanism](https://en.wikipedia.org/wiki/The_Market_for_Lemons)". So no. It's precisely the opposite of mediocre. Fact is, I won't get out of bed for the rates we'll get if the bozos enter the market.
I don't know if I agree completely with you, even by seeing your point. Crappy PHP developers didn't kill the market for real web developers. There are, indeed, clients that only see price, but not quality. But do you really want to have this kind of client?
An autonomous collective which never got the specification for the language updated, so we must deal with threading using libraries, undefined behaviors, implementations having some different symbols representing the same thing (how do I get the command line arguments, again?), and some even having their own exclusive set of symbols (require in SBCL is the first one that comes into mind). Common Lisp is great, it's the most powerful general-purpose language in the world. But the standard is showing its age, and having simply an autonomous collective is not enough for this. The autonomous collective wasn't the sponsor for the creation of the language in the first place.
Crappy PHP developers *did* drive most good PHP developers out of the market! That (PHP) is a perfect example of a Lemon Market. Wages are generally lower because even bad code often works and employers can't understand why they'd pay $130k when they could get an "equivalent" developer at $70k. Result? Not very many of the best developers work with PHP.
But, to be fair, PHP *is* a crappy language, so it usually don't attract talented developers. It's not like Common Lisp (or even Ruby or Python). It's more like Java.
Those are all good points. I can't argue with a single one. I'm trying to figure out why it is that I felt like the path into Clojure was easier than the path into CL. Not sure all / any of these are correct, but here are some thoughts: - I overvalue website aesthetics (ClojureDocs might only cover 1.3, but it still looks reasonably new and grouped together). - Old (but not necessarily outdated) is a lot older in CL. PCL is comparatively a new CL resource, and is absolutely fine, but pretty much predates any notion of Clojure unless your name is Rich Hickey. - I've splashed out for a few dead tree Clojure books that probably make me feel that the tutorial situation is better than it is (though to be fair, I think PCL was not originally free, no?) - In disciplines related to my own (stats: I do applied social science types of things) there seems to be growing interest in Clojure, resulting in blog posts that teach me something as a snapshot in time. - Libraries often come from the Java world where documentation is either good and makes me feel good about Clojure's ecosystem, or bad and makes me marvel at how much better Clojure package X presents things. - The language itself is more "opinionated," which results in examples being perhaps slightly more homogenous. Those are just some thoughts as to why I may have the particular cognitive bias ("Clojure new; CL old") that I have. I suspect they may be true for others as well. Where things get harder for me to explain is with certain parts of the scheme community. [Chicken scheme](http://www.call-cc.org/), in spite of being a tiny community, signals in all the right ways to my superficially-interested brain: "We have everything you want right here!" I haven't done more than kick the tires with CC, but what little I've done felt very "safe."
For me the first result is http://common-lisp.net/
It pains me to say it, but many people are driven by appearence, and many Common Lisp sites show their age. It's also 100% the case that getting a libre dev environment running on Windows is a complete and total drag.
Yes, [it's this guy](http://upload.wikimedia.org/wikipedia/en/6/6f/Creepy_King_Bed.png).
I don't know, never heard about this domain.
The appearance of [common-lisp.net](http://web.archive.org/web/20130302014957/http://common-lisp.net/) was changed and the server was moved so it can be incomplete and can make this impression. But it's a step in the right direction from my point of view.
You do know that Mark Tarver has made [Shen](http://www.shenlanguage.org/) the successor to Qi?
http://www.reddit.com/r/Qi_Shen
Indeed it is, and I didn't mean to insinuate something different. I'm just saying that Java and PHP do not tend to attract talented developers.
Guy L. Steele?
Denommus, [I have a project to change that.](http://koioslisp.tumblr.com)
Wow. Very interesting. I love the idea of it be hosted in so many different languages and platforms. 
It's 404ing on me
There's no SSH library. It'd be nice to have something similar to https://github.com/paramiko/paramiko/
Seriously, [this is why I want to create QIX](http://www.youtube.com/watch?v=TV2kAcd5E20). Using Lisp to Visualize Lisp (in 2D and 3D) and solving difficult problems easily would bring developers to us. 
Any reason why a performant CL implementation couldn't, in theory, rival pypy in terms of performance? I don't know why I started wondering this, but I did, and then I found that there is an existing implementation. Unfortunately performance isn't great, but isn't too far off from CPython either. I just did a quick pystone benchmark on my Mac: **PyPy** $ pypy /usr/local/Cellar/pypy/1.9/lib-python/2.7/test/pystone.py Pystone(1.1) time for 50000 passes = 0.059495 This machine benchmarks at 840407 pystones/second **CPython** python /usr/local/Cellar/pypy/1.9/lib-python/2.7/test/pystone.py Pystone(1.1) time for 50000 passes = 0.511493 This machine benchmarks at 97753 pystones/second **CLPython on SBCL 1.1.4** (CLPYTHON:RUN #p"/usr/local/Cellar/pypy/1.9/lib-python/2.7/test/pystone.py") Pystone(1.1) time for 50000 passes = 0.987 This machine benchmarks at 50658.563 pystones/second **EDIT**: fix language fail
As I understand it, Python isn't slow (just) because its C implementation is a cheesy interpreter, but because the language semantics do little to constrain activity which is difficult to optimize.
The default way to code Python abstracts away the things that make code slow. Namely copying stuff around, allocating memory. There's no standard way to code low-level Python that uses the slow parts sparingly.
Well, because there's not much of documentation from the looks of it.
keywords: in theory :-)
In theory million-man-hour projects don't come about cheap or lightly... In theory I don't see any other inconvenient.
It would be nice if it could access 'native' Python libraries. I often want to use Python due to being able to access interesting extension libraries, and that seems likely to preclude using CLPython for this. For instance, the thing I wrote last week using Pika (a library that helps access AMQP systems) isn't at all usable atop CLPython.
Where do you think language semantics get out of hand? What jumps out at me are highly dynamic features like "everything is a dict". 
But they *are* reimplementing a VM from the ground up (PyPy). It's perhaps a moot point now that PyPy is nearly complete. It's even possible that there are technical reasons why a performant Python-on-CL implementation could never exist. I'm merely musing whether CL as a host language, with several existing performant implementations, could have been a pragmatic approach for languages such as python that are running up against limitations in their historic runtimes.
That's all fine but these devs are unlikely to be proficient in CL. In the end this is very important to drive a decision.
It is a casualty of the current [common-lisp.net](http://common-lisp.net/) shake-up. The regular [MKCL](http://common-lisp.net/project/mkcl/) page works OK though. I will try to have this fixed as I release MKCL 1.1.5 in the coming days. 
That's one of the prime suspects.
Does anyone know what software was used to generate the manual? It's got lots of "TO DO" portions, but it's very nice looking.
And the page sources are also pretty good looking.
How about [burgle-batteries](http://repo.kepibu.org/browse/darcsweb.cgi?r=burgled-batteries;a=summary)?
Damn true, this documentation is sexy!
Mountain Lion
Which is why pypy is so fast, because it has a pretty good JIT inside of it that figures things out eventually.
I know I'm being horribly superficial, but that is an awkward name. Marketing is a big part of language evangelism and I honestly believe the name will stifle the potential of this language.
Don't forget about [RH's insistance ](https://groups.google.com/forum/#!msg/clojure/4uDxeOS8pwY/UHiYp7p1a3YJ) that "Clojure" is to be pronounced "Closure" as well. I humbly submit my suggestion: Kjlodure (pronounced "Closure", of course).
&gt; The output of this is 10 when it should be 6765. I didn't look too closely but I think that the evaluator tries to implement function calls without using a stack and the result is that independent calls mutate a shared function object. Maybe it was only tested with functions that were not recursive.
What is this stuff? This looks more clueless than usual: EVAL ~~and COMPILE~~ include special cases for all the built-in *functions.* 
Browsing through this reinforces something Peter Seibel said at his talk at ILC2010 in Reno: If there's something you think is inelegant in Common Lisp, it's probably not because they didn't know any better -- everything was discussed at length and eventually a decision was made, and some people were happy and some people weren't.
No Hashtable lookup at run-time. It is done at compile-time. Predefined Symbols: (E PI true false null) are not functions.
Reality is messy.
Posting toy languages on this subreddit feels so dull
Would be nice to have the whole thing 1. available as a single fine for download (eg in mbox format), 2. searchable on the web
There are single file archives of this. A lot of interesting stuff is here: http://www.saildart.org/%5BCOM,LSP%5D/
That looks, in part, like someone's private mailboxes. Fascinating yet somewhat creepy to read through.
RMS suggested that all of the setting functions be removed apart from SETF. I wonder why this wasn't done.
Remember, on some early systems, incl. Lisp Machines at MIT, there were no passwords. There, others could read the mail... but that was known. Some file servers were open.
I'm scared to think what their seniors are.
&gt; Faster than Clojure. Poorly worded claim. Faster at what? There are lies, damn lies and benchmarks. Why even make the claim?
Heh, that sounds like me. Except for the master's degree. And the “proven” part. (And I have a perfectly fine job, and I wouldn't want to work solely on a CMS.)
In the context... "Java, C, Lisp or other high-performance languages". Don't think they're planning a Lisp Machine, but it's nice to make it on that list :)
That is awesome! 
/me dusts off resume
&gt; Don't think they're planning a Lisp Machine ... ... again. They've once built one internally. Apple developed one of the first Newton prototypes with a special ARM processor running Lisp (for the OS and the applications) with a runtime written in a subset of C++. The Lisp then was an early Dylan in prefix syntax. Even Larry Tesler was involved ( http://en.wikipedia.org/wiki/Larry_Tesler ). Unfortunately they never published the code...
Oh cool. I didn't know that. I think Apple has lost a little bit of that pioneering spirit these days.
Dylan was never shipped in a product, they wrote a different OS in C++ plus NewtonScript (in some ways similar to Javascript) for the production version. The early internal and beta versions of the NewtonScript IDE were written in Macintosh Common Lisp, though - just like the very different Dylan IDE. The Dylan version failed also because it used more than 1 MB RAM (!). I don't know/recall how much it actually was - let's say it used 2 MB RAM. The first Newton then shipped with 640 Kbyte RAM. 
Its nice to hear LISP being described as a high-performance language for once. I am tired of people who say that LISP is slow and inefficient!
You should challenge those people to a race.
Actually it has already been done! Check out the comparison here: http://norvig.com/java-lisp.html
interesting. i had been wondering about this exact issue of LLGPL
Thanks for this link! As it happens I am both working on a project using Clojure and trying to improve my German, so I find this book very well suited for my current interests. I suspect that I am not the only person around with those two interests, so I reposted the link to the book to /r/LANL_German. I would say that this probably would have done better in /r/Clojure but honestly spoken many Redditors reflexively &amp; thoughtlessly downvote content which is not in English... though that probably not much worse than the petty "we hate Clojure" attitude which appears to be popular in this subreddit lately.
Looking forward to the sources (to export it to HTML / Mobi). Thanks!
On the other hand, it has the advantage of not being a dictionary word like "Factor" (which is also a Unix command!).
Irrelevant anecdote: I think iTunes (and other Apple apps) uses a .plist file format (being xml though). It carries some kind of LISP legacy under the rug :)
I've seen quite a lot of people saying that Lisp websites were ugly et al. This is why I wanted to make a pretty website with some interesting resources for beginners. The website is hosted on https://github.com/Ralt/gettingstartedwithcommonlisp , so pull requests are welcome :)
It's cool that the site is pretty by modern aesthetics, but a bit more content would be nice. :) Some thoughts: - You might want to link to an implementations as well. - ...and environment setup installation directions. - ...and linking to ASDF is probably pointless because pretty much every implementation comes with it, and Quicklisp also updates it if it's too old. - I would also STRONGLY suggest not linking to On Lisp so prominently. It is not an introductory book, and has some non-ANSIsms that are going to trip people up. Touretzky's book and Land of Lisp probably deserve mentions. - You may want to consider linking to common-lisp.net, r/lisp, have a pointer towards #lisp, etc. Feel free to plunder my FAQ (http://random-state.net/files/nikodemus-cl-faq.html) for content if you want, but please don't attach my name anywhere. 
Thanks for the aesthetics compliment! This is exactly the feeling I want people to have :) About the content, I'm looking for feedback. I know it's quite poor right now, and I'd like it to remain unbloated. But there is indeed some content needed, [This link](http://random-state.net/features-of-common-lisp.html) on your FAQ is actually the kind of link I'm looking for. I'm in no way knowledgeable of all the great links out there that could be helpful to beginners, this is why I made this project on Github, so that people could pull request and make this somehow community-based. Switching to Jekyll might help this, and I should do this in a quick future :) I was just waiting for first feedback to see if the idea is well received.
I put together a very similar site recently: http://articulate-lisp.com
I agree that ASDF should *not* be linked to. It's mostly behind the scenes these days. Two good sites you might want to add are [quickdocs](http://quickdocs.org/) and [minispec](http://lamberta.github.io/minispec/). Also, I'd prominently suggest folks visit #lisp on freenode if they need help.
If you want to make a site to do beginners a favor, you have to identify what beginners have problems with and then focus on that. As I still consider myself a Lisp beginner, even after a few years of toying around with it, or at least I remember the sources of confusion when I tried to get into it, this is my list of things you should change on your site to make more valuable to people triying to get into Common Lisp: * Don't confuse beginners with "And these are the 43 different implementations you can choose from". Beginners need a opinionated leading hand to tell them exactly what to use. After everything is running smoothly, they can start expanding their views on their own. As a beginner, you *do not want to* investigate pros and cons of 1001 obscure implementation. You need to know what the consensus is, and you want to go with the consensus. My take: Get rid of the "every implementation is equal" bullshit political correctness and simply point every beginner to SBCL. Let them believe that SBCL _is_ Lisp. Do not even metion that more than one implementation exists. * Dont just list things. Ressources, Tools, bla. You are wasting your time, motivation and effort on something that is easily googleable. Instead, tell them in a step by step manner how to set all those up, so that they do not have to gather information from 27 different sites. Show them how to have first working results withing a few minutes. Write a lisp version of "Learn Python the hard way". * Dont use technical slang, it is confusing. Dont call the language "Common Lisp", just call it Lisp. The long name is unsexy and feels antiquated. Dont abbreviate it as CL either, dont use abbreviations at all. Dont call SBCL SBCL, just call it "the Lisp compiler". Dont mention ASDF. The name is a bad joke, butt ugly and confusing as hell. Since it is completely contained within QuickLisp, a newbie never has to directly come into contact with it. * Dont mention Vim or Slimv. Again, the newbie doesnt need choices, but a strong hand. The Lisp editor is Emacs, and should be presented as such, especially to a newbie. * Dont duplicate effort, the Lisp ecosystem is fragmented enough. Since the other guy at articulate-lisp.com is essentially doing the same as you, team up with him and share effort. Do what he isnt doing and then link the stuff together. Really, nobody and especially not newbies, needs the 1001st "CLISP, ABCL, CMUCL, SBCL, CCL, LW" list of implementation acronyms and then call that "Getting Started". I'd rather call that "Getting Scared Off". A newbie needs explicit, jargon-free, opinionated, step-by-step hand-holding. * Since you are trying to make a "pretty" website pleasing to the newbie eye: have more colors. Have it look more "lively". Get a logo and a "symbol" that people will remember and identify with lisp ([Ruby](http://www.ruby-lang.org/images/logo.gif),[Python](http://python.org/images/python-logo.gif)), for example a fancy lambda [like Racket](http://racket-lang.org/logo.png) or something similar.
I've always been interested in seeing an interactive REPL on a Lisp for beginners website. I know of many that exist including SLisp and js-lisp, but they are either not in use or not fully developed. That's one of the features that a lot of educational programming sites are developing and it is slightly ironic that a language that heralds the REPL as a historic feature does not possess a stable REPL for the browser. I'll get started on one and send a pull request as soon as I can. 
I am not one that cares too much to ge honest, but I gotta say that it looks good. Thanks for doing that for the community.
&gt; My take: Get rid of the "every implementation is equal" bullshit political correctness and simply point every beginner to SBCL. Let them believe that SBCL is Lisp. Do not even metion that more than one implementation exists. I don't want to get into an implementation argument, but with the number of people who want to build websites, I think CCL is a better suggestion. Websites on CL means Hunchentoot, Hunchentoot means threads, and CCL has better/existing thread support than SBCL on OSes that aren't Linux.
I don't necessarily agree with all the details suggested here, but a solid +1 on the general sentiment: make strong editorial choices instead of listing umpteen things; team up with other people interested in doing the same thing. 
It looks like you are allocating the closure objects at compile time, which isn't quite right. A closure should be allocated when evaluating an (fn ...) form so that the lexical environment at the time of evaluation can be captured. Also, you can compile the function body and argument forms before evaluating anything. There's no real need to call compile from within eval. You should get a speed up by lifting those compilations out together with the rest of the compilation.
I've been in getting started situation with Lisp recently. While your effort is appreciated the site doesn't help much to a beginner - it doesn't get people started. What would really help people interested in learning Lisp is an online REPL combined with a tutorial like they have for [python](http://www.learnpython.org/), [ruby](http://tryruby.org/levels/1/challenges/0), [haskell](http://tryhaskell.org/) and others. I would personally have appreciated a list of features that make lisp stand out with small examples - macros, `loop` construct, multiple dispatch, restarts (maybe), lambdas of course, `before` and `after` etc.
First of all, let me say I approve of this initiative! Second: &gt; This webpage is a comprehensive list of resources for people new in the Common Lisp (CL) world. This is probably not "comprehensive" right now, personally I'd go with something more grounded in the current reality like "This webpage is a project to build a comprehensive list of resources for people new in the Common Lisp (CL) world." Having documentation state "future facts" as if they were "current facts" is a mistake I've made in the past. Of course anyone seeing the page in its current state will understand what's going on, but it can be a bit surprising at first. Third: You might find something relevant on my [(Common Lisp) Programming resources page](http://www.hexstreamsoft.com/resources/). (Incidentally it's an example of a little more opiniated style.) Feel free to link to it and/or repurpose and adapt any of my content in any manner, it's Public Domain!
On logos and colors [this](http://www.lisperati.com/lisplogo_fancy_256.png) must mentioned: http://www.lisperati.com/logo.html
It feels a bit empty :(
List of resources to help you get started with Common Lisp: \*empty screen\* I laughed. But seriously, all that information would've probably fit in one screen. Who likes scrolling?
Yeah, I think [we resolved that and decided that he wasn't spamming because he wasn't posting very much at all](http://www.reddit.com/r/lisp/comments/1c2mi7/troll_alert_in_rlisp/). I think we also decided that this subreddit wasn't just for Common Lisp, and that those who *did* feel there needed to be a Common Lisp specific subreddit can find it here: http://www.reddit.com/r/common_lisp Or, that we could update the sidebar to spell out what is acceptable content instead of just carrying out an ill-conceived (and what now appears to be personal) vendetta against one person.
I prefer [this](http://www.normal-null.de/img/lisp/glossy120.jpg) http://www.normal-null.de/lisp_logo.html
As someone who is rather fond of Common Lisp, and who tends to defend the community, a certain contingent of /r/lisp would be actively turning me off to Common Lisp if I were predisposed to that way of thinking. Maybe the "lisp means Common Lisp" crowd secretly hates Common Lisp and is trying to drive everyone (even current users) away. Look people: Bhima's comment was constructive, and even suggested what many of you have been asking for. Right now his comment appears to have 6 downvotes to 6 upvotes. This is not reddiquette!
There is no "we" as in "we decided". We didnt decide anything. Everybody decides for himself. The decisions are being made not in advance by a binding majority vote, but for each new piece of the automated Clojure spam, by up or downvoting it. As I said, the fact that different subreddits exist has a purpose, and that purpose is that everybody can subscribe to information he wants to read and not be spammed with information he doesnt want to read. By not subscribing to /r/clojure you explicitely decided to not read about clojure. Why should you have to read about it anyway in another subreddit? Why should you have to read about Clojure on /r/java or /r/lisp?
You're right, the mods in this subreddit appear to have gone AWOL. But until such time that it's changed, the sidebar explicitly says this kind of content is allowed. We've been over this before. As far as I'm concerned, these downvotes constitute arbitrary harassment of a particular user. When it comes to Common Lisp, I'm the choir, but this nonsense is even giving me second thoughts about the maturity of some of its members. Further, as I've said, /r/common_lisp is the established clojure-free, scheme-free, *lisp-free subreddit that you really want.
&gt; As far as I'm concerned, these downvotes constitute arbitrary harassment of a particular user. As far as I am concerned, posting Clojure content to a non-Clojure subreddit constitutes arbitrary harassment of that particular subreddit. &gt; but this nonsense is even giving me second thoughts about the maturity of some of its members. I think you do not understand the concept of subreddits. The points of having different subreddits is not to cross-post content into several subreddits at once, with the intent to make it hard for people to avoid seeing that content (aka spaming). The point of having different subreddits is that everybody can pick and choose and fine-tune what kind of content they want to read by explicitely clicking on that "subscribe" button. Why should everybody at /r/lisp have to see Clojure-related content even if /r/clojure exists and they didnt subscribe to it? That completely undermines the point of subreddits and I personally consider it as intentional SPAM. &gt; /r/common_lisp is the established It isn't. It gets less than a link per year. The focus of common lisp content has since the beginning of Reddit been /r/lisp. &gt; that you really want. No, it is what *you* really want.
I think the main reason there isn't a prominent trylisp.org type site is that it's hard to sandbox Common Lisp effectively. It would be a good thing to have and [this](https://github.com/mabragor/cl-secure-read#readme) should help with reader issues, at least. :)
Exactly, resp. I don't like that logo with an alien, it's overcomplicated, having needlessly a lot of text and in general it appears ugly to me.
A zillion thanks to Ben Hyde for making this post.
thank you for your suggestions. I will add them to my site next time I take a pass over it. :-)
I think the chances of the author getting this info are better if you contact him directly as well as or instead of posting it to reddit.
It doesn't necessarily have to be a sandboxed version of Lisp. A tutorial REPL would do just fine, the user inputs something passed on a question and the REPL parses it for accuracy. 
Thank you for you spending your time on [articulate-lisp](http://articulate-lisp.com/). The [snippets](http://articulate-lisp.com/initial:abcs.html#snippets) is particularly useful quickstart material for someone with experience in other languages.
My impression on Lisp then reading [PCL](http://www.gigamonkeys.com/book/) and other materials was that it's alien. Some features are simply difficult to explain to my C# colleagues (like restarts and generics). From a look at any [timeline of programming languages](http://rigaux.org/language-study/diagram-light.png) it is immediately apparent that Lisp is very different from any modern mainstream language to the point of making an alien a more suitable mascot.
I prefer the other logo because to me it represents Lisp better. It is Escher-like and lisp is certainly an Escher-like language. Suum Cuique.
I have in development a prototype [site](http://www.smacklisp.com) with a REPL of a toy lisp-2 that is compatible with CL. I am currently working on a tutorial system to fit inside.
Quicklisp does not contain these kinds of project descriptions, which is why I'm glad Ben did the work of gathering them.
Awesome. What's a "kitty of death"?
A play on a SBCL joke. The SBCL repl on ms-windows showed a message on start-up "Your Kitten of Death awaits".
You're welcome! :D Unfortunately its down right now! I've emailed the provider and should get it online as soon as possible.
try /r/clojure. I think there was some upscuttle recently about a poster continually submitting Clojure links to this sub.
/r/clojure 
Where does it use *unification*? I see *substitution*. What do I get over a backquote expression plus a LET?
Interesting. I've been reading Joy of Clojure lately and thinking about the ideas there and how to integrate the ones I liked into Common Lisp. Using unification in particular makes me think that perhaps some sort of macro layer could be written over the basic CL forms to specify types and execute type checking (the unification algorithm is a major component of type checking). It would seem to me to be really quite wonderful to write some code in development, say: `(defun-typed (integer t string) (arg1 arg2 arg3) ...)` and have the type information propagate around to the different defun-typed functions. Conflicts would give compile-warnings. Then, when you're ready to release to production, you could set some `*typed-defuns* off and have the macro just render out regular code, ignoring your custom typechecker. This would be similar to https://bitbucket.org/eeeickythump/defstar/ but used for compile-time warnings. 
SBCL already does that to some degree: type inference, type propagation and compile-time type checking. Allegro CL and LispWorks are also doing type inference, too.
Don't worry, most people are just annoyed because that's all that that user does, nothing else. Posting Clojure stuff *is* okay, you just start to question a posters motives when that's all he does.
Absolutely, yet it'd be nice to have a stricter overlay that is controllable on my end. Might wind up being a hobby project of mine in a few years. :-)
Ah, gotcha! thanks for the clarification.
Has any implementation of Erik Naggum's [Enamel](http://genius.cat-v.org/erik-naggum/xml-sgml-nml-lisp) ever been released?
[Here's an old hack.](https://gist.github.com/death/5451382)
fmargaine, could you *please* consider teaming up with p_nathan? I know the temptation to do things my way/the best way but in this case fragmentation of efforts could do more harm than good, I'm afraid. On the other hand, joining forces could result into a more complete project. Anyway, huge props to both of you for starting this. I think a comprehensive" Getting Started" tutorial is the only thing Common Lisp is lacking in contrast to other "cool" languages (Python, Ruby, Java, whatever).
I agree that stuff like this should probably stay in /r/clojure especially since many Common Lispers have probably seen all of this stuff before.
It would be difficult to get me to code copious amounts of java for any sane amount of money. I very much believe in taking jobs that pay less if they afford me the opportunity to not hate my job :D
[Hiccup](https://github.com/weavejester/hiccup) is pretty much the standard library for generating html in clojure (there is also enlive, but I haven't personally seen it used as much as hiccup). Here is an example: &lt;div id='parent-div'&gt;&lt;h2&gt;'Hello there!&lt;/h2&gt;&lt;/div&gt; becomes [:div {:id "parent-div"} [:h2 "Hello there!"]] Much nicer and easier to read, IMHO. 
The substitution walks the structure and substitutes all of the embedded logic variables. So if I have a list (?a 2 ?b 4) and a substitution context {?c (3 ?a), ?a 42} then the substitution will backtrack until all of the logic variables that can be substituted are. The final result would be (42 2 (3 42) 4). The bindings occur entirely in relation to the substitution context.
It was useful enough to serve my humble purposes. Is it generally useful? That's debatable -- or not If you know the answer. In any case, that I've reached for this and like it probably means that I'm really looking for something like define-syntax or symbol-macrolet. Thankfully there are Clojure libraries for both. 
Perhaps I failed in making it clear that by "Lisp" I meant Common Lisp in the blog post. I usually follow the convention of using capitalized "Lisp" as a shorthand for CL, and usually use the term "lisp dialects" or "lisp like languages" for other lisps, which I usually call by name anyway, so I almost never say "lisp", and mean something other than CL.
Does anyone know if this is intended to become an actual Common Lisp implementation? Because if it is, I am (1) very excited and (2) I will work on integrating it into my examples for Common Lisp in http://articulate-lisp.com --- After pinging the author, this was added to the Readme: `JSCL is and will be a subset of Common Lisp. `. This sounds like a great opportunity to help a Common Lisp implementation get off the ground. :-) (Now I'm wondering how well it could work as a compiled environment for the browser).
give the maintainer an email and see what he says.
Take a look at Racket's Scribble. http://docs.racket-lang.org/scribble/ Fare added support to his CL tool. http://common-lisp.net/gitweb?p=users/frideau/scribble.git It solves much of the same design space, and has several other lispy features.
 (defun digest-tag-population (tag-population pick-tags count) (flet ((pick-tag-p (tag) (member tag pick-tags)) (animal-merge (animal) (mapcar (lambda (x) (cons (car animal) x)) (cadr animal))) (pick-position (list) (position (car list) pick-tags))) (sort (subseq (sort (mapcan #'animal-merge (remove-if-not #'pick-tag-p tag-population :key #'car)) #'&gt; :key #'caddr) 0 count) #'&lt; :key #'pick-position)))
Hi, I'm not the author but a minor contributor. AFAIK for the moment it's just an experiment. now we have in mind a better integration with js environment, like (js:alert (+ 40 2)) , but it's a small step at a time. 
 (defun digest-tag-population (tag-population pick-tags count) (let ((tags (mapcar #'car tag-population))) (stable-sort (loop for population in tag-population for tag = (first population) for members = (second population) when (member tag pick-tags) append (mapcar (lambda (item) (cons tag item)) members) into selected finally (return (subseq (sort selected #'&gt; :key #'third) 0 count))) #'&lt; :key (lambda (e) (position (first e) tags))))) Incorporating everyone's feedback: (defun digest-tag-population (tag-population pick-tags count) (stable-sort (loop for (tag members) in tag-population when (member tag pick-tags) append (mapcar (lambda (item) (cons tag item)) members) into selected finally (return (subseq (sort selected #'&gt; :key #'third) 0 count))) #'&lt; :key (lambda (e) (position (first e) tag-population :key #'car)))) 
not to distract from the hard work, but, ecma is a standard body. using their name in your lisp's name is the sort of thing they probably wouldn't appreciate.
You are right. I renamed to JSCL. Finding a name is the harder thing!
 (loop for population in tag-population for tag = (first population) for members = (second population) ...) may be written as (loop for (tag members) in tag-population ...)
Great idea, I completely forgot about destructuring.
(position) takes a :key argument, so: (let ((tags (mapcar #'car tag-population))) (stable-sort .... #'&lt; :key (lambda (e) (position (first e) tags)))) can be shortened to: (stable-sort .... #'&lt; :key (lambda (e) (position (first e) tag-population :key #'car))) 
It is entangled with stuff that I may not want or be able to open source. Also, i have to read it back, from paper tape.
Which is your favourite? I just bought Touretzky's Common Lisp, just beginning my Lisp journey. :)
I learned from Winston and Horn back when. It was on a DEC20 running Tops-20 where you could burn your entire semester's CPU quota in a few seconds of misplaced recursion: you'd have to go grovel with the department secretary for more. The DEC terminals also had APL key caps. APL was a great class too!
Hopefully in a box somewhere since we last moved house ;-)
If you're just starting out, Practical Common Lisp would be my recommendation. Despite all it's problems I really like Grahams ANSI Common Lisp.
I used a DEC10 and then a VAX11/780. A year later we found out that we had a government founded computer science lab in town fully equipped with Xerox Lisp Machines and a single Symbolics 3600. Winston/Horn was our bible, together with CLtL1.
You miss Lisp in Small Pieces ;) Oh, I see dig1 already pointed it out :)
http://a.yfrog.com/img737/7516/kxlfdm.jpg
How is The little Schemer?
Drooling over those Symbolics manuals -- likewise for the Interlisp book. I've not seen that one before.
Hey, I don't have so much time to give to this site, so I'm definitely interested in teaming up with you :-). Can you contact me at florian [at] margaine [dot] com ?
Also Wilensky's LISPcraft --- when I was writing Franz Lisp on a VAX 11/780 over a 300-baud connection.
This has probably been beat to death in the past, but has anyone looked at the prices being asked for copies of On Lisp? It was actually higher than this is years past. http://tinyurl.com/cvynyqh
Or see this one: http://www.amazon.com/gp/offer-listing/0135384222/ref=tmm_pap_new_olp_sr?ie=UTF8&amp;condition=new&amp;qid=1366982336&amp;sr=1-1
What's the blue book next to "Building Problem Solvers"? 
I still have my 30 year old copy of W&amp;H and I missed having Guy Steele teach me from it by one semester. TOPS-20 was a nice OS. Took years for Unix to catch up.
Semantic Information Processing, Marvin Minsky (editor), 1968, MIT Press. If you look more closely at the 'hardcore' Lisp stuff, so much traces back to Marvin Minsky. But you would need to dive into the 60s and 70s.
ANSI Common Lisp has a really nice reference section in the back with short descriptions that are accurate for the majority of use-cases.
I think this is a great intro book. It's also fascinating to be taught complex ideas using only one or two sentence questions and answers.
If you can read French, keep in mind Queinnec has written a new version of it. I can't read French... :( It's called Principes d'implantation de Scheme et Lisp
Keene's *OOP in CL* is a really good explanation of CLOS for the non-expert. It is well-written and the examples are well-thought out. For a tech book it is an easy read. For CLOS, it is better than PCL. I'd read it if you are not 100% comfortable with CLOS or are coming from Scheme
wow, can you tell us if you job is related to lisp now ?
You need a Programmer's Guide to Common LISP. I did the index!
PAIP demystified computer science for me. It simplified so many difficult AI concepts by reducing them to incredibly simple lisp programs. An all time classic. 
Alan Kay [once called](http://www.cc.gatech.edu/fac/mark.guzdial/squeak/oopsla.html) *The Art of the Metaobject Protocol* "the best book written in computing in ten years."
It's been done before: catechisms.
The hardcore Lisp stuff is symbolic AI, symbolic maths, programming environments, various, programming paradigms... Just check the list of his students: http://web.media.mit.edu/~minsky/people.html There are lots of publications by people like Bobrow (Interlisp, software STUDENT for his PhD, LOOPS, CLOS), Charniak (wrote the book AI programming), Drescher (wrote a Lisp compiler for the PDP-11 in his thesis, later ObjectLisp), Scott Fahlman (Spice Lisp, CMUCL, Common Lisp, Dylan, various KR stuff), Forbus (qualitative reasoning), Gosper (Lisp Machine stuff, Life), Greenblatt (Lisp Machine), Hewitt (Actors), Jack Holloway (Lisp Machine, PDP-6 Lisp), Kenneth Kahn (Director, Lisp Machine Prolog), Tom Knight (Lisp Machine), Joel Moses (Macsyma), Warren Teitelman (Interlisp-D), ... 
Pure gold. Thanks.
He also said that it should be rewritten using a language other than Lisp.
Just one example: Interlisp * Warren Teitelman. PILOT: a Step Toward Man-Computer Symbiosis. Ph.D. Thesis * Warren Teitelman. Automated programming - the programmer's assistant * TOWARD A PROGRAMMING LABORATORY, Warren Teiteiman * Daniel G. Bobrow, D. Lucille Darley, Daniel L. Murphy, Cynthia Solomon, and Warren Teitelman. The BBN-LISP System * Warren Teitelman,.... INTERLISP Reference Manual * Programming in an Interactive Environment, Erik Sandewall * AN INFORMATION PRESENTATION SYSTEM. Frank Zdybel, Norton R. Greenfeld, Martin D. Yonke, Jeff Gibbons Some of the stuff originated at BBN and then was developed further at Xerox PARC. Which led to Lisp Machines, Interlisp-D, LOOPS, KEE, CLOS, and some other stuff. The team behind Interlisp got an ACM Award in 1992.
CLtL2 isn't particularly hardcore imo. It's not the most captivating thing to read, but it's not too bad -- roughly equivalent to The Silmarillion.
I would also suggest [Lisp in Small Pieces](http://pagesperso-systeme.lip6.fr/Christian.Queinnec/WWW/LiSP.html). Very fun book. You have all the others that I have. My first was PCL, but my favourite now is PAIP. I have LOL but haven't read it yet.
I consider [QIX](http://www.youtube.com/watch?v=TV2kAcd5E20) hardcore, just because of the difficulty and scale of creating a "universal media editor". I define a UME as an an editor where when someone asks, "Can I make/edit X type of file/data?" and the answer is always yes. 
http://www.youtube.com/watch?v=oKg1hTOQXoY 54:00 onwards
Definitely. I was going to answer this one.
Lisp Machines manuals? If only I could put my hands on them :)
PDFs: http://bitsavers.informatik.uni-stuttgart.de/pdf/xerox/interlisp/ http://bitsavers.informatik.uni-stuttgart.de/pdf/mit/cons/ http://bitsavers.informatik.uni-stuttgart.de/pdf/mit/cadr/ http://bitsavers.informatik.uni-stuttgart.de/pdf/lmi/ http://bitsavers.informatik.uni-stuttgart.de/pdf/symbolics/ http://bitsavers.informatik.uni-stuttgart.de/pdf/ti/explorer/ http://bitsavers.informatik.uni-stuttgart.de/pdf/ti/microexplorer/ 
Let Over Lambda *isn't* hardcore, I think it's a pretty good book over all though, if you ignore the fan-boyism. The later chapters is when it gets interesting. Ps. I have no idea what hardcore would mean though, how would you guys define hardcore?
Oh WarWeasle, such a shameless plug ;-) PS. CLinch is really cool, do a tutorial or two (more than just the examples) and I'd adore you
paper tape? That's *cool*. Well, wish I could offer to help ya... I don't have paper tape readers. :)
I was going to say: any bookshelf without SICP is an incomplete bookshelf.
* Lisp programmers used it as a reference or inspiration * it started a field and is cited by later publications * it sums up years of research and development * it was harvested, exploited, copied, abused, mutated, stolen, reinvented by others * it costs a fortune in used book shops * the authors got an award for their research * others struggled years to understand it * if you move to a new home, you keep it, even though it is more than 20 years old * old bearded Lisp hackers start to cry if they see a copy * its markup language is Scribe or earlier * it contains Lisp expressions, lots of Lisp expressions 
Especially the one on editors
Wow, is there a 2 minute version of this video? Sounds fascinating but this is really plodding!
Here's an idea, disclaimer I will add some links later, but one thing I'd like to see is lisp based proto-implementations of programming languages (Richard Gabriel mentioned it as a common thing in early 80s) - there's the link to an early haskell in CL on reddit =&gt; [yale haskell / cmucl](http://www.reddit.com/r/programming/comments/6al45/haskell_style_pattern_matching_in_arc/c03byhx) - first caml were written in lisp, nicknamed 'heavy caml' **:wip:** - ml was lisp based too, actually Edinburgh LCF, can't access this stanford [MEMO](ftp://reports.stanford.edu/pub/cstr/reports/cs/.../72/288/CS-TR-72-288.pdf) **:wip:** - [javascript semantic verifier](http://lxr.mozilla.org/mozilla/source/js2/semantics/) maybe that's not hardcore but only obscure and vintage though.
Marked as TODO for next reading :)
What would you like to see and I'll see if I can make an example.
There are a lot of basic opengl tutorials floating around the Web, such as the whole "textured cube" stuff, making one of those in clinch would show how clinch makes some stuff easier, less verbose or more elegant over all
Oh wow, didn't notice that this was your project! I am sincere when I say it sounds fascinating -- I myself have been trying to imagine a more universal media representation ever since I heard about Xanadu -- but asking a prospective viewer to invest 26 minutes into something that may not have a payoff is a bit of an imposition in this era. A two minute video, or even a one minute one, that gets right to the point and highlights the benefits, might do a lot to attract interest and perhaps even assistance.
No. After college, I opted for grad school in Math instead of AI. After grad school, I became an embedded systems programmer, then moved to Brazil and wrote enterprise software. Right now, I divide my time between a consultancy related to the enterprise software, messing around with Lisp and taking care of my two year old son. 
Thank you. I'll see what I can do.
Would this be considered hardcore? Lisp lore: a guide to programming the Lisp machine (1986) http://archive.org/details/lisploreguidetop00brom 
More points of reference: an early JavaScript semantic verifier was written in Common Lisp and one of the first Clojure compilera was in Common Lisp.
Good luck and godspeed :)
Rainer, I looked at your goodreads.com bookshelf and noticed some titles: * Inside computer understanding. * Ai tools and technqiues. * Building problem solvers. * Introduction to knowledge systems. * Qualitative reasoning: modelling and simulation. * Inside case based reasoning. * Principles of biomedical informatics. * Calendrical calculations. The things these titles have in common are: * They use Common Lisp or an older dialect from the main branch of Lisp dialects. * They apply Lisp to an interesting problem domain. I don't know how good they are, but I like these kinds of books. This is because I think after one understands a programming language a good way to learn more (other than by writing programs, which is the best way) is to read useful programs that other people have written to solve some difficult or large problem. So my question to you (or anyone else reading) is: do you have anything to say about these books? Do you know of any other books in this style? Have any of these books been obviously superceded so you can say e.g. "Don't read Inside computer understanding, read ?x instead, because it is similar but written more clearly and approaches the problem in a better way."?
One subject area of personal interest to me is computer graphics and animation. One interesting resource I found was the paper "Computer animation with scripts and actors" by Craig Reynolds which describes an embedded DSL in Lisp. Another was the paper "L-systems, twining plants, Lisp" by Knut Erstad which describes a sort of 3D turtle graphics system in Common Lisp for procedural geometry. These are on my reading list. A more recent example of an interesting, Common Lisp program which is focussed on computer graphics and geometry, also has a graphical user interface, and whose source is publicly available is FREEDIUS. So this is my contribution to hardcore Lisp resources, for some definition of hardcore. If anyone has any resources on S-geometry (later became Mirai) or the Symbolics image processing program, I would be very interested. I remember reading a more recent paper by a graphics researcher where the author complained about the state of today's programming environments with regards to computer graphics research compared to what he had on a Lisp machine of yore. But I forgot what paper that was or how I came across it. It was a while ago. Nevertheless, his remarks stuck, and I would like to have a better idea of what he meant by them.
Great! :D
Yes, please. And make it so I can actually run the examples someday!
It's fairly conventional. An introduction to programming on the Lisp Machine. Unfortunately it was not updated for the release 8 of Symbolics Genera, which was a big step up (though some user complained) for some areas (networking, presentation-based graphics, ...). The manuals were also excellent, but they were a bit larger...
I gathered a few links (4 actually, 2 webpages, 2 videos) in http://www.reddit.com/r/nichimen 
Amazing, thanks
This is not quite correct. (I was one of the programmers who worked on Newton, and on the Lisp OS). The Lisp versions of the OS (there were two Lisp versions) never had trouble fitting in the RAM of the device. I ran them both daily on Newton hardware without any trouble. The first Lisp OS was slower than the team wanted it to be; it was written mainly by C programmers. The second one, written mainly by Lisp programmers, was very fast. The reason a Lisp OS was not shipped is complicated, and was mainly political and social, not technical. It's hard to summarize succinctly, but what it boils down to is that John Sculley told Larry Tesler to ship a C OS. The reasons why that happened might be hard to find out; the gossip in Newton at the time was that a certain marketing guy persuaded Sculley that Lisp was not credible.
Mikel, would the first shipped device with 640 kbyte be okay for it? Probably not that important, since the next versions got more RAM. Maybe the successor to Sculley, Micheal Spindler would have shipped it with Lisp...
Hmm. Are you by any chance Warren Teitelman?
It should be possible to implement such stuff under Smalltalk, Dylan or even Perl (Moose). At the time CLOS was created, the main implementors provided a public version with the MOP - Portable Common Loops (PCL). There were several other object-systems implemented in Common Lisp (mostly) and some of them also had a MOP - often inspired by the CLOS MOP or competing with the CLOS MOP. This was a hot research topic in the end 80s / early 90s. For example MCS, the Meta Class System. The good write up, book and spec, plus the portable implementation helped CLOS to gain acceptance. http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/lisp/oop/non_clos/mcs/0.html or TELOS: http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/others/eulisp/feel/telos/0.html
Kay gushes about Lisp usually. I think his point was only that many people will miss (or ignore) the important points in AMOP because they do not like or understand Common Lisp.
xah lee is a notorious troll: http://ergoemacs.org/emacs/_p/KickbanXahLeeFromEmacsChannel.htm https://news.ycombinator.com/item?id=466302 http://lists.gnu.org/archive/html/help-gnu-emacs/2010-12/msg02447.html etc.
Thanks for the update!
I appreciate that tutorials that use the older OpenGL APIs are easier to understand for beginners to 3D graphics, and target a larger amount of hardware. But I also feel that the people who write the tutorials should be honest and tell them the disadvantages: 1. The pipeline is less programmable. 2. Heavy use of direct mode. 3. Graphics literature in the past six years has been focussed on techniques and ideas requiring a far more programmable pipeline, as exposed by newer versions of the OpenGL API. 4. If they decide to pursue (low level) computer graphics further, then sooner or later, they will have to effectivley unlearn everything this sort of tutorial teaches them and relearn a different API. I also think relying on SDL is a mistake. Mainly because it limits what you can do in terms of OpenGL contexts, resource sharing and multiple threads. I think a more useful tutorial for a person wishing to seriously explore computer graphics might be how to setup possibly multiple OpenGL contexts with a particular major and minor version on a particular windowing system. tl;dr the tutorial gives a stock standard toy example of a few OpenGL calls in a non C language and like all such tutorials teaches an obsolete, inefficient, and just plain bad way to go about 3D graphics today.
Use one of the many Vim emulators for Emacs instead and enjoy SLIME. I personally use [evil-mode](http://emacswiki.org/emacs/Evil) and it is wonderful. Edit: I have always been an emacs user, but I envied the Vi/Vim users their modal editing which lead me to start using Evil. Someone coming from Vim to Emacs still has to learn some of Emacs to enjoy Evil-mode.
Agreed. After using and becoming comfortable with GL 3+, going back to the "before time" seems like putting on a dinosaur suit and running around in circles. I've found that any opengl tutorial for C translates nearly perfectly to a CL opengl tutorial once you learn the cl-opengl calling conventions (`glBindVertexArray` becomes `gl:bind-vertex-array`). So all you *really* need to get is a good window/input manager set up and then follow along with any standard opengl 3 C tutorial. GLFW is pretty terrific/simple for instantiating *newer* opengl contexts, as well as handling your input needs. cl-glfw is a great wrapper as well. SDL is ok, but does a lot of non-accelerated 2D graphics which is really just bloat if you asked me. Other than that, I don't really have a problem with SDL, I think it's yet another great windowing/input abstraction library. I just prefer GLFW. I will also say that jumping from GL 2 to 3 was a bit of a mindfuck. You have to do a lot more manual work in 3 because so much of the bloat and cruft was removed, but let's be honest: we're all going to be using the modern versions to get anything serious done in the near future, so I think it's best to bite the bullet, learn/abstract the difficult/irritating/mathy stuff and enjoy the bountiful fruits of opengl &gt;= 3 without even bothering with &lt;= v2. If anyone's interested, I've done some work on a [game engine in CL](https://github.com/orthecreedence/ghostie) on and off for a while now and there may be some useful examples for newer opengl in there if you want to dig (sorry for the crappy commenting). I do eventually want to abstract a lot of the matrix calculations, FBOs, vertex arrays, etc etc into some sort of opengl 3+ CLOS/helper library so people can use the work without tacking on a game engine (or ripping the code apart). Haven't gotten around to it yet though.
Thanks for the constructive comments. I have to admit I learned the old OpenGL 1 API (and before that coded up a software renderer) and have stuck with it through inertia and because I just need to get something displayed; hitherto I've not been interested in performance and the OGL1 API gives the path of getting something displayed with the least amount of faffery. (Shaders? Shrug.) However, it looks like a dinosaur like me has a lot to learn to get up to date so I guess I'll have to bite the bullet and update it. When I do I'll try to update the blog with another tutorial. An interesting exercise might be to do a Clojure/Web GL implementation for the web client side. What would you use instead of SDL that's relatively platform independent? I'm using Windows 7, Linux and MacOS X Mountain Lion? Needs to give keyboard and mouse handling - and preferably have a GUI toolkit to boot.
I'd like to share my experiences so far, since I am actively working with OpenGL ES 2 + X11 / Mac OS X: - Expect a rough ride if you support ES 2.0 only. A lot of important ES 2.0 functions require C pointers / arrays. In the first iteration I had large amount of code which transformed from Lisp to ffi baked arrays. After a couple more experiences, I simply dropped the Lisp structures and work directly with ffi data structures. Sometimes, good old OpenGL 1.2 is useful for quickly drawing something in order to test things. You can work with it without using ffi arrays by directly passing the values. - Expect a lot of crashes :) Since Emacs/Slime + CL allows for instant feedback, you can very easily screw your render callback. Even the most minor issue like a wrong datatype (double vs. float) might cause trouble if you're running it at 60 Hz. - Since I have a strong C background, I constantly have to fight against the urge of writing too much C code when dealing with vectors (float v[3]) or 4x4 matrices (float mat[16]). It's too tempting in C, in CL it is simply cumbersome. I am sure that there are some clever techniques to handle this equally convenient, but I am not yet there. Currently I have to do this like (setf (cffi:mem-aref mat :float offs) 1.0) etc. Of course the middle part is hidden behind a macro, but still, it's not that concise. The good thing is: the more advances I make, the more stable the whole interactive GL programming gets, thanks to CL and Emacs/slime. Another benefit: I have a very small solib for handling X11 windows and events and another short dylib for handling native OS X windows and events. Both libs adhere to a common protocol, how mouse events are delivered, etc. That way, I can directly work with OpenGL and Lisp without requiring anything else. The window system handling part was the easiest of the whole story. I am sure that it would be also possible to do it for Win32... 
I also use evil in emacs and recommend it heartily. Slime beats any other lisp/scheme solution, and coming from vi you'll find evil pretty complete.
I think SDL is a fine choice, so don't worry about switching. It's got some cruft, but it's ignorable cruft =]. You're absolutely right about the old API, from blank slate to showing something on the screen, it's hands down the easiest way to go. It's hard to ignore that fact when introducing people to graphical programming. WebGL would be cool, I'd be interested in seeing that since I really know nothing about it (but am fairly decent at javscript). Thanks for the response!
There is something clearly wrong with Xah. http://xahlee.org/Periodic_dosage_dir/las_vegas/20031015_copulate.html 
I've started a [series of tutorials](https://github.com/BradWBeer/CLinch/wiki/CLinch-Tutorials) based on NeHe's OpenGL tutorials. So far I have three. Could you could check if they run on your system, as I only have one computer to test on. 
It looks like I need to to choose a different windowing library. 
I can't make anything from that error. Do you have a windowing library that works?
This project seems to be going at it the hard way. Why not use a CL implementation that produces some kind of bytecode and write (or reuse) a bytecode interpreter written in JS? Edit: The intermediate language doesn't even have to be bytecode. You could reuse the front-end of some other implementation if it has any well defined and easy to work with intermediate language.
I think I found the problem. I was forcing the version of OpenGL to 3.1. Could you try repulling CLinch and trying again? Thanks!
[Try Paren](http://tryparen.tistory.com/). https://bitbucket.org/ktg/parenjs 
Thanks for pointing out evil-mode. I've been using it for the past couple of hours and it makes a good vim. This could be a slippery slope.
Yes, use of Google Closure has been considered, and will probably be used in the future. Anyway code is currently unoptimized and there're many simple optimizations that can be applied to the compiler too.
Great stuff! A little help/intro/about wouldn't hurt.
The README on the github repo explains what it's about https://github.com/davazp/jscl/
True, and I know it, updates about ecmalisp/jscl have been quite frequent on /r/lisp (which is good). But for someone outside this subreddita bit of a context would be helpfull. Also the interpreters (cmd, pyton, ruby, powershell, bash etc) usually start with name, version and sometimes author site.
Like you, I'm 15+ years invested in Vim. I've tried Emacs several times, *wanting* to find a way to make it work for me, but the best I've gotten so far is not good enough to switch. Evil-mode does help, but ultimately it's still Emacs with a Vim skin. Either Vim really works well for my approach to things, or it's shaped my approach. I used VIlisp for a few years, but recently switched to Slimv, and I love it.
Awesome work! For the window-opening tutorial, I'd maybe go over setting the OpenGL context since a lot of C tutorials specify a version to use. This is looking great though, thanks for sharing.
LOL. I did have that in there but some users (I'm looking at you Apple) had trouble with the specific OpenGL version. 
Well, I suppose it's not too hard to look up how to do it in GLFW (and cl-glfw bindings are easy to work with). Out of curiosity, was there no way to set context in Apple at all, or was it specific versions that weren't working?
I don't know. I'm working through other users and can't troubleshoot the problem. I had one user on #lispgames tell me removing the major and minor versions fixed his issues, so I removed them. I keep asking people to send me their Macs, but for some reason they never do. :)
I'll send it back, I swear ;)
I'm planning to write some docs but for the moment there's not much.
Cons is not destructive, thus it doesn't modify your variable x. Idioms for that are: (let ((acc '())) (dotimes (i 10) (push i acc)) (nreverse acc)) Or, using [iterate](http://common-lisp.net/project/iterate/) : (iter (for i from 0 to 10) (collect i))
100% passed all lparallel Tests. so far so good. Do you guys face any issues ?
Common Lisp is also not giving you TCO. Many implementations do at some optimization settings.
Why not asm.js? That could be even better target given all the fuss about it lately.
As said, cons is not destructive. It didn't assemble any list to return to you. Here's something more nearly apropos: [2]&gt; (let ((x '())) (dotimes (y 10) (setf x (cons y x))) x) (9 8 7 6 5 4 3 2 1 0) [3]&gt; Somewhat simpler... Break 1 [4]&gt; (let ((x '())) (dotimes (y 10) (push y x)) x) (9 8 7 6 5 4 3 2 1 0) 
That fragment shader code is begging for Lispification. Raw inline strings is yucky when you have macros.
Either that, or load it from an external file. Either way, being able to parse GLSL has some advantages. For example, it makes it possible to analyze how many draw buffers are used ("outs" from the fragment shader), which the OpenGL API lacks functionality for. That is handy for automatically binding draw buffers and set the draw buffer blending mode. Or you could do code obfuscation, etc :)
Just came to say L.I.S.P-like acronyms should be mandatory.
Cons is not destructive, as many people have said. I'll take this opportunity to encourage people to actually read the [documentation on DOTIMES](http://clhs.lisp.se/Body/m_dotime.htm) to see that it allows for a return-form (as does DOLIST). (let ((acc)) (dotimes (y 10 (nreverse acc)) (push y acc))) You should also read the documentation to realize that this produces the numbers from 0 to 9, not 1 to 10. 
Pretty sure this already has been posted No inherent damage in that I guess (2drunk to get reasonable msg across) 
I started learning Lisp a short time ago. I know I don't enough knowledge about the language to do something awesome. But do you guys think it is worth the shot? I mean, do you guys think it can help me learn more about lisp?
[http://www.reddit.com/r/lisp/comments/1bwea7/lispnyc_lisp_in_small_projects_over_5000_of/](http://www.reddit.com/r/lisp/comments/1bwea7/lispnyc_lisp_in_small_projects_over_5000_of/)
Definitely! If you want to learn anyway, it will help keep you focused on a goal and you'll learn much faster.
I an working on improvements to the compiler, I just hope the size does not go too big. However, it would be great to have benchmarking to guide the optimizations, so you you can contribute your benchs would be very helpful.
I don't know asm.js very well, but I think it is more oriented to typed languages, isn't it? Anyway I just learn about Uint8Array and I am excited to use it in JSCL arrays.
I was looking through your latest commits and found this. https://github.com/BradWBeer/CLinch/commit/b878b5843f2d9e098d99bc19c7ea9c8573414baf Why is it a macro? You could always make it a function and inline it, ya know. Also, radians-&gt;degrees is a function but degrees-&gt;radians is a macro? Wat.
Good catch. That's what I like to call "a stupid".
That's upsetting. Are GTK wrappers not compatible with ECL? Why? What about using other Lisp implementations? CFFI offers a fairly good native code interface.
This is related to a question someone has asked before, so I'll link to my comment there where I give an example how to get started with one way to make Lisp GUIs: http://www.reddit.com/r/lisp/comments/18vy1f/state_of_windows_gui_libraries/c8iw4n1 Bascially, if you use ABCL (Armed Bear Common Lisp), then you can use just about any Java library you want, including Swing/AWT for the GUI. CFFI has also been ported to ABCL, so you can use that Lisp library to access your C library or you can use a Java library like JNI (that you control through ABCL rather than Java code). The point is that even if it's not ideal, resorting to ABCL whenever there is a lack of mature Lisp libraries is a strategy that works because you piggyback on the maturity of the Java platform. The strategy is that even if you don't like Java the language, ABCL allows you to use Common Lisp instead but still use Java libraries and the JVM for deployment. It's also possible that some Java shops might be more likely to let you use ABCL at work for pet projects that may eventually be adopted by the team because it's still the JVM underneath and the same APIs, whereas Lisp would normally be rejected if using ECL, SBCL, CCL, etc. If you write something cool in ABCL, it can be exposed to Java programmers as an API so they can use it just like any other Java framework.
I'm not eligible. Brazilian residents can't participate. :(
Lisp's greatest strength is its ability to help programmers solve problems.
on the lisp-br mailing list, this was posted as the reason: &gt;Unfortunately the contest is not open to Brazil. We have recently re-reviewed the requirements and (after much discussion) have decided to keep them. Basicly our small project is similar to Google's Code-In, which is where the requirement originated. We don't have Google's cadre of lawyers and cannot risk inviting trouble to our friends and colleagues at the ALU. They coordinate the International Lisp Conference and distribute our money awards.
The signing in part is a no-go for me. Why would I want to sign in to take a test?
Of course the press release drops about a hundred buzzwords but no mention of lisp.
"What doesn't change in Clojure but is used often?" * Graphing * Unit testing Java code * Lightweight REST APIs What a weird question; what does it mean for *unit testing Java code* to change? The tests? You can change code.
[Unless you're Cisco, in which case they're completely prohibited!](http://lisp.cisco.com/) 
Fair point, but in my experience people are pretty good at ignoring (or pretending to ignore) a project in early stages of development.
hehe good catch.
folio2 is pretty much done now, feature-wise, but I need to get all the unit tests updated, and have not been working on it or other side programming projects for the last couple of weeks, due to hectic activity in other areas. Getting it done produced some additional ideas for consolidating APIs using a streams abstraction, but I don't think I'm going to do that just yet. I think the result would be a simpler and more elegant surface API, but it will require some nontrivial infrastructure work, and I don't want folio to fall victim to feature creep. I should get back to it and get the unit tests done before too much longer.
RavenBrook had also previously obtained MPS (memory pool system) as well.
When not even a major Lisp company wants to publicly "confess" that they built a project in Lisp, it is pretty telling how bad Lisp's public image must really be.
They say in that PR text: Franz Inc. is a leading vendor of Semantic Technology, Common Lisp tools and Professional Services. Now the knowledge that the software is written in Lisp is one probabilistic inference away. The PR site even 'includes' their homepage, which has even more Lisp content. Still, for a 'user' in that domain the software might be useful, without knowing any Lisp. Like Oracle might not say in a PR piece what their database is written in.
I find the title misleading. It does not give Erlang and Go in Clojure. Somehow Erlang-like actors and Go-like coroutines.
The actual Beaglebone Black: http://beagleboard.org/Products/BeagleBone%20Black
What would something like Gruff be used for?
There's CLSQL, check that out. http://clsql.b9.com/ I like Postmodern though (PostgreSQL) http://marijnhaverbeke.nl/postmodern/ I also found this http://stackoverflow.com/questions/123234/what-is-the-best-sql-library-for-use-in-common-lisp Also, CLIKI is cool, check it out: http://www.cliki.net/SQL
Since you don't need performance and you don't have a lot of data, you might just want to write out your structures to a file as an SEXPR and use READ to bring them back in.
"What doesn't change in Clojure but is used often?" Debugging Java stack traces.
I have a large web app that uses an append-only log for recording every DB write with occasional full-DB rewrites. I read the DB into a hash table that uses SBCL's :sychronized t flag and WITH-LOCKED-HASH-TABLE macro for write access. The DB journal and full-DB output use WITH-MUTEX so they can be called between multiple threads. You can also use SBCL's mailboxes if you want a lockless way to feed updates to a journal. If you create your own indexes this approach can be significantly faster than SQL and allow you to do queries that no single database or search engine will give you, or at least not in a performant way. I use my own indexes to do things like full-text search within a geographic distance sorted by a combination of upvotes, time, and distance.
CLSQL doesn't support simultaneous writes* when using SQLite. At all. It'll just throw an exception. http://common-lisp.net/project/cl-sqlite/ supports them, as does another library (IIRC) but whose name I've forgotten. So, OP: definitely check whether the library supports that, since support can't be assumed. \* Or reads during writes. 
Thanks, that may be a viable option.
There is a call to EVAL in the code. Why?
CL first-timer here; seem to have misunderstood what EVAL does, and ended up using it. Lesson learned, and removed it now, thanks!
I might be missing something but isn't this completely trivial?
The use of `DEFPARAMETER` is unclear. It is a top-level macro to declare a variable. If you want to set a declared variable in a function use SETQ or SETF. Comments for functions should look like this: (defun foo () "foo expects nothing and does nothing" ) instead of (defun foo () ;; foo does nothing ) Also don't use (apply #'max list). Use (reduce #'max list). APPLY has a built in arguments limit. 
I made it in order to start learning Lisp, and thought I'd share it. I guess it's something I might find useful for getting an idea of value distributions like folder sizes, git commits, commit lengths etc using bash one-liners from the terminal (like [here](https://raw.github.com/pranavrc/QuickHist/master/res/fromtheterm.png)). Also, I think it might help embed simple hists on poll threads etc, to help viewers look at the distribution of votes. It's something I can add features to, like expanding to proper image histograms, and the ability to sort the data and visualize it, and I'm eager to work on those! Thanks.
I'll get fixing. Thanks!
This is cool. Congratulations on finishing a project in Lisp that ties together a bunch of different technologies. You're through the most motivationally challenging part of the Lisp learning curve. There's a lot more to learn, but it's fun once you can build things where you can see the results :-) One of the most helpful things you can do at this point is to read well-written, idiomatic examples of Lisp. Reading Norvig's Paradigms of Artificial Intellignce Programming is a good step. Thanks for sharing!
Absolutely reading that book! I'm through the first couple of chapters already, and it's great :) Learning even a little bit of Lisp seems to have realigned my thinking a lot, and I'm pretty excited to continue learning. Thanks!
What do you mean, " directly work with OpenGL and Lisp"?
As far as I understand it it is just a subset of js that can be massively optimized. If one can force his language to compile to asm.js subset instead of full javascrit, there should be a lot of performance gains. How easy/hard would be to target asm.js as JSCL target, I guess you know much better than me :)
CLSQL also doesn't support AUTOINCREMENT for sqlite, last time I looked.
That's true. But this subset requires you write code to use only integers, for instance. Should we implement tagged pointers if Javascript supports different objects already? I don't think so. Maybe it will bedifferent in future revisions of asm.js.
Good find! I tried the patch but got errors when running make in lisp-kernel/linuxarm: cc -g -Wl,--export-dynamic "-Wl,--hash-style=sysv" -mfloat-abi=softfp -o ../../armcl -T ./armlinux.x pad.o arm-spentry.o pmcl-kernel.o gc-common.o arm-gc.o bits.o arm-exceptions.o image.o thread_manager.o lisp-debug.o memory.o unix-calls.o arm-asmutils.o imports.o lispdcmd.o plprint.o plsym.o albt.o arm_print.o -Wl,--no-as-needed -ldl -lm -lpthread -lrt /usr/bin/ld: error: ../../armcl uses VFP register arguments, pmcl-kernel.o does not /usr/bin/ld: failed to merge target specific data of file pmcl-kernel.o Not sure what's the official way to build ccl. A simple temporary workaround (at least until this works with ccl out of the box) was to save /proc/cpuinfo e.g. as /opt/cpuinfox, change the pathname in the executable in emacs and then change the "model name" to "Processor" in /opt/cpuinfox :-D Works on the original/older beaglebone too. edit: small things
Difficult on a desktop too. The slides aren't working quite right.
Bit of a disconnect between the Visual Lisp stuff and bringing peace to Iraq.
I like those widen-parentheses if I can use it on emacs.
Makes just as much sense as our reasons for invading Iraq.
[LispNYC](http://lispnyc.org/) are the organizers. As for the judges, stay tuned...
It's worth up to $2000 bucks. And it is guaranteed to give you new insights in the art of code.
This is important to me, as I need a safe-lisp for viewing untrusted 3D lisp markup.
This is pretty frickin sweet. Love the idea of being able to write something on an x86 system and with a few modifications be able to run it on a beagleboard. Gotta find time to play around with this.
1994?
I realized that a macro can recognize the outer macro binding through env. In this case the macro can stop rebinding the clause name. However *function-information* in CLTL2 is deleted in ANSI.
You don't like 1994?
To be fair, they use 'Relational Lisp'. That's also quite 'obscure'/'unknown'. Possibly anybody who understands it must be a relatively good programmer. It's something like AP5 on top of Lisp.
Could you try macroexpand-dammit? http://www.cliki.net/macroexpand-dammit
Evil-mode's not 1:1 compliant with vanilla VIM, but it is pretty close (and improving without replacing parts of Emacs that have the same functionality as the VIM feature). It is the best of both worlds though, and a VIM feature can always be ported over.
Thanks, I have checked it out. It's implementing a stand-alone macroexpand so the flow would be: 1. macroexpand-dammit with current env (symbol-macrolets are expanded) 2. look for remaining `my-clause's in the expanded code I also looked into the code and found it is binding an environment to the global variable. It gave me an inspiration.
I was hoping someone would know more about it. Do you know anything more?
From what I can google I think it probably *is* [ap5](http://www.ap5.com/). 
there are video and pdf versions here: [http://nimbusgarden.com/ben/_HCI_/index.html](http://nimbusgarden.com/ben/_HCI_/index.html)
A great language with a crazy licence. Non-spec conformant forks are forbidden, and code breaking it has to be retracted and publicly apologized for. I understand that changing the semantics just a little bit breaks their proofs, but it's still madness. **EDIT:** Due to interest in this post. Here is the part of the licence I recalled as the section with the apology. They want you to issue an announcement that you produced a bug and then retract it. &gt; Suppose I move Shen to another platform and make an error, breaking the spec, what happens? &gt; &gt; Generally you would want to avoid breaking the spec, but supposing that you did, you would &gt; first have to issue an announcement to your users explaining there was a bug. Second, &gt; you would have to fix it. If you could not fix it, you would have to withdraw it. **EDIT2:** This is what really bothers me about the Shen licence. It's about trust. Imagine you meet this nice girl or guy at a bar, beautiful, smart. You talk and laugh for a few hours and he/she asks you to come to her/his place.... but first you havo to sign this contract that you won't cheat, because he/she had this friend called Linux who got cheated on all the time and is really torn apart by this. Would you go with that person or the slightly less beautiful and smart one that isn't crazy? **EDIT3:** It seems that my point is rather theoretical but I actually got bitten by the licence in a real world. I had to develop a Programming Language for a Manycore CPU. I considered Shen and Picolisp as the basis because of their minimalism and build in Prolog Interpreters. As this was a university project I could not guarantee conformance upon publication, as Shen doesn't allow derivative publication that contains errors even if declared as such I went for Picolisp which is less theoretical but also less restrictive.
So, yeah. This is a small project of mine. It's not even close to being finished and I have a lot to do, but I think it's kind of time to show it off a little and see if people have any direct issues with it, or if there's any interest from the community or something like that. It's licensed under the LGPLv3, I didn't choose LLGPLv2 because I'm unsure where the pre-amble is supposed to go (probably before everything else, but yeah...). The code is slightly embarrassing, but that's just because I don't consider myself to be a very good programmer. Also, there's a small 'database' example in the root folder called "db", check that out if you like stalking other people's music taste.
Slight coincidence, I'm currently doing a simple mp3 database for my final project in my software design class and wish I could do it in CL, but it must be done in a "standard OO language." I really like the fact that you documented things unlike a lot of lisp programs/libraries I have tried using. Anyway, I'm finished with the semester on monday. I could look into making an ncurses interface. Although I have no idea what the state of ncurses is in common lisp, nor have I used it before.
Two ncurses bindings already exist, [cl-ncurses](http://common-lisp.net/project/cl-ncurses/) and a newer, CFFI-based [cl-charms](http://gitorious.org/cl-charms). Both seem fairly complete and usable. What is lacking is a lot of test cases, examples and documentation.
Qi already had a problematic license IIRC.
Hm, yeah. One of the consequences of seeing a lot of useful but undocumented libraries is that you get obsessed with documentation.
C, C++ and Haskell are examples of successful languages that didn't accept community input for creating a spec. Although I grant you they are different in the sense that you are free to create a spec-breaking implementation.
Enhancements are certainly allowed - adding graphics, concurrency etc is all kosher. AFAIK no language community would welcome, say, something that called itself 'Perl' or 'Python' but fundamentally changed the syntax and semantics of basic features. It might even be treated as a violation of trademark. So I see the Shen license as just enshrining legally what some communities do de facto anyway.
"I understand that changing the semantics just a little bit breaks their proofs, but it's still madness." The first part of your sentence rather undermines the second half. 
It's a pity that such a great language like Shen is mentioned in places like reddit or HN in negative context only, and that only its license is discussed. Shen is a revolutionary and beautiful language and please stop talking about license only! 
Yes it's a pity, but if the licence is the only thing that prevents people from even looking seriously at Shen which would otherwise be very interested in it, then it's something to be discussed. While at this topic another thing that bothers me about Shen is the ego of its creator that shows in almost every his post on the mailing list and his treatment as God by other community members. That and superiority complex shared on mailing list is what kills Shen, which is a pity given how nice the language is.
No it doesn't. Shen has a background in programming language research, prohibiting any change even semantic changes that are accompanied by new proofs and explicitly given a new name basically means that all further research on Shen is frozen except for the original creators.
If you're interested in Shen, the code and slides for this talk are illuminating.
According to science history books, Isaac Newton wasn't a nice person. But that doesn't stop us to use and appreciate things he invented. Mark Tarver is a genius too, so it's kinda "normal" that he's a little "weird"...
When was the last time you needed to change something in Common Lisp that violated the ANSI spec or Scheme that violated the RnRS? Shen has macros, are you really that constrained?
When doing PL research you don't want to build everything out of macros, you want to be able to change the core when absolutely necessary. And it's not like all Scheme RnRS were semantically compatible.
I think you can change Shen, but you can't call your derived version with the same name.
"his treatment as God by other community members." Comparing that dude to newton, discounting founded critique, demanding discussion but not providing it and showing that you didn't even read the thing you defend kinda gives credit to that claim.
I've read The Book of Shen, but was not so much interested in license terms. I found that aspect totally unimportant, cause there are much more interesting stuff in the book. For me, it's kinda phenomenon that every time somebody mention Shen in public place, it's always in a negative context. On the other hand, no one bitch about PLT Racket (just an example). Racket have a very weird community and, besides, look at this: http://s10.postimg.org/e1ylfxm2x/bloatware.png Very interesting! 
If you issue software that is defective and you find out, then you should say so to people who have downloaded it. That does not mean you are apologising - simply acknowledging an error. That all the license says here. Obviously the group has high standards for its work, but since you are not required to contribute to the kernel, you don't have to meet those standards. I think the crucial line that explains this attitude is here. "Our adherence to standards and discipline as system programmers allows you, the applications programmer, to be confident of basing your work on ours." IOW the trust issue is really about being able to rely on the system to be performant. Regarding Linux being cheated on. If you think that in some way Linux fell short of the mark (I agree with you, it did), you might ask yourself why it did so and whether the methodology of free forking and lack of standards contributed to the failure of Linux as a desktop OS. And it's the C21 - prenuptials are not a mark of crazy ;).
Yes I agree with the basic philosophy of guaranteeing spec conformance for the *Shen* language. This is the whole reason we have trademarks so people know what they buy is adherent to standarts. But why forbid derivative work that doesn't claim to be Shen? Also consider its target audience, it's not like there are hordes of theoretical computer science people waiting for Shen to be more open to create a fork and push it out of the market. And you probably know what you are doing should you decide to fork it and have good reasons. They don't want the community to splinter so they rather have no community.
Have you considered that people would like to use it but are kept away because of its licence? People criticize because they care, it's ambivalence that should worry you. Also if this is a persistent phenomena, is it possible that there is a reason for that other than people just being gratuitously mean?
It seems to me that there is only one person here (and on HN!) rising noise about Shen license: you. There are no others.
I never stated that I didn't learn Shen, I did, but I won't use it. The real world problem I had was developing a Programming Language for a Manycore CPU. I considered Shen and Picolisp as the basis because of their minimalism and build in Prolog Interpreters. As this was a university project I could not guarantee conformance upon publication, as Shen doesn't allow derivative publication that contains errors even if declared as such I went for Picolisp which is less theoretical but also less restrictive.
"For me, it's kinda phenomenon that every time somebody mention Shen in public place, it's always in a negative context." Also the people who up-voted my first post, deverdev and rixed seem to agree.
In my interactions I haven't found this to be the case and I certainly haven't treated him as God. But I'm just a user. Maybe you've been in a position where the author was being unreasonable about a proposed change to the spec. If so it would be good to hear about that. I can't think of an instance where he was rude or dismissive on the mailing list. He fixes bugs quickly and is responsive to questions on the list. 
Untrue. Research on concurrency and FFI is wide open.
If your version of Shen contained errors why not fix them rather than declaring them? I believe that that the whole point of the license was to guarantee integrity. What you have just said amount to 'the Shen license did not allow me to issue my buggy code under their rubric' so I went for something that did. 
Hello Mr Tarver, One reason I am disinclined to spend time with Shen is because the package system does not scale, i.e. there is no standard method of dealing with conflicts between external symbols coming from disparate packages. There needs to be a coherent/resolvable package system in place -- whether it's done CL-style or Java-style or some other way -- otherwise the lingering danger of conflict is a positive deterrent in writing code since one cannot be confident that others can use the code, at least conveniently.
If you want to knowingly distribute buggy code without any restriction then sure Shen is not the system for you. 
Well if you think that the Shen spec is inconsistent with some model of concurrency that you think is great - why don't you mail their group?
I wouldn't say genius, but he's certainly weird. In particular his sockpuppetting as 'paracelsus' both here and on Hacker News while referring to himself in the third person.
There are two problems with this attitude vis Shen. First, your fork on the kernel which you say is buggy inevitably affects the perception of Shen in much the same way that the rep of Linux has suffered from the prevalance of shoddy forks and poor coding. It is false that anybody who hacks a program knows what they are doing. Second it means that people who do use your flaky code may end up for help on qilang where Dr Tarver's resources are thinly stretched. If you were just experimenting with Shen on your own machine I don't think anybody would care what you did. However you want to distribute buggy student project code which breaks the Shen spec and you have an issue with needing to publically acknowledge when your code has errors - treating this as some kind of face-losing apology. You don't bother to go to the Shen community (which you say does not exist) to present any argument for why the Shen spec is inconsistent with what you want to achieve and you dismiss the community of 371 members in one line. Certainly given your attitude I'd agree Shen is not for you. Well that's it from me - other things to do.
Did you even read the above? There is no way that anybody would ever execute the code in a non experimental setting, because it ran on a CPU you had to flash onto an FPGA by yourself from source. The deliverables of the project wasn't even the language it were the papers describing the problems and chances of designing and implementing parallel hardware and software in one process. The "problem" is that it is good science to also publicize the work that lead to the conclusions in the paper. Something the Shen licence doesn't allow. "and you have an issue with needing to publically acknowledge when your code has errors - treating this as some kind of face-losing apology." I don't at all have a problem with stating that there was an error, it's the retraction part I have a problem with. The problem is that in my particular case the Shen licence doesn't assume that the derivative is never to be used in production or even run. As the CPU is co developed with the language this basically means that the CPU becomes part of the Language implementation. So should a bug in the CPU be discovered after the results have been released one had to: * Change the code to be conformant. This results in the publicized material being inconsistent with the published results. * Retract the code. Turning the research into bad research. 
Dr. Tarver, please, don't hide under this "paracelsus" name. Please don't. I have a strange feeling that you're hiding all your life. And there is no reason for that: you are smarter and better than Rich Hickey, I know that. You just need to show that to everyone - boldly and without any compromise! Mr. Tarver, kill 'em all with the best lisp ever - with Shen!
$70? Wow.
If your scientific results are affected by having to correct errors in your code, it suggests that your science isn't that great. If on the other hand you can correct the errors without hurting your results then failing to do so is sloppy. I would say that correcting the errors and demonstrating that your conclusions still hold is a mark of good research. Your methodology is OK for a final year project of a not very good UG - not for published work. Though in truth the referees would probably not have the time to dig that deep.
that's one expensive video, more expensive than the three top clojure books together. i guess it's directed towards companies.
Slightly relevant, while doing a course using sml/nj, many students wrote their own testing framework/library, I think it was a nice thing to do (but maybe you already did that before and are just asking for ecosystem tips) &lt;digression/&gt;
So you are changing work, publications are based on, because the changes *might* be invariant (to your paper and all the other work that might be based off of it in the meantime)? Even though the "mistakes" made are a part of the results of the study (which set out to explore what problems might arise), resulting in their "correction" because otherwise you *feel* sloppy? That and the fact that somebody mentioned work created in word, makes me really pity the librarian archiving your work. Btw the retraction part if properly enforced should also forbid git history containing mistakes. 
http://cliki.net/Test%20Framework
People have been complaining there are too many testing frameworks. I use [Stefil](http://common-lisp.net/project/stefil/index-old.shtml), which I think is pretty awesome because it feels better integrated into the Slime/Repl experience than anything I have tried elsewhere (then again, I didn't look very hard). Since you have programming experience, you might play with [HackerRank](https://www.hackerrank.com) instead of Project Euler. It allows you to program in Lisp and the problems are less esoteric and closer to actual programming tasks, IMO.
I don't think you really need a testing library, as you can just use a macro to enable/disable the tests in the files themselves. To store your data, you really just need a single global hash.
Others have recommended frameworks: I too like fiveam. However, the development cycle in Lisp makes the *need* for TDD (though not developer tests). I find myself writing functions directly into the repl and moving them into the source file as the gel. Alternatively I'll write them in my source file and test iteratively, using the Inspector. The very act of coding in Lisp in a good environment (for me Emacs + SLIME) makes my code better from the get go. I'll add automated tests to cover edge cases and to protect against regressions as the codebase expands. 
Yeah, or half the cost of a night of moderate drinking. Also about the cost of filling my gas tank. Or two tickets to a show. I guess you invest in what matters to you. 
Infinite SICP lecture videos. In a commercial setting it's not much. Though many basic introductory videos from other companies are no cost.
I use cl-project:make-project to build my projects usually, it creates a stub test file. Running tests from the REPL is quite easy. (ql:quickload "cl-project") (cl-project:make-project "fooproject" ...) ;; hack (ql:quickload "fooproject-test") ;; this reloads test package which runs tests (asdf:test-system :fooproject) ;; also runs tests in test package 
To me, a night out drinking involves a bartender and a decision about how to get back to my car in the morning.
Thanks for showing the project, it's definitely great seeing testing with context. Using REPL sounds like a good strategy as well. Cheers!
Whoa. This is awesome. Whole lotta frameworks, so little time. ;)
I'll definitely be checking out Stefil, as well as HackerRank. I like Euler a lot, but you're right, it is extremely math based. Thanks!
I for one, welcome our new canine overlord
I use the (pretty recent) [CLUnit](http://tgutu.github.io/clunit/), which I find ideal, because it is easy to extend, and works very nicely in interactive and non-interactive testing. I write a lot of numerical code and I prefer to test everything immediately after I implement it, saves a lot of headache in the long run. I don't follow any sophisticated TDD methodology though, but it should be easy in CL.
&gt; failed. assume a code like below. (symbol-macrolet ((A 1)) (my-macro ;;; (1) (symbol-macrolet ((B 2)) (my-macro ;;; (2) (symbol-macrolet ((C 3)) (my-clause a b c)))))) &gt; my-macro(1) calls macroexpand-dammit with a current environment. &gt; information of A is included. &gt; &gt; during the expansion initiated by macroexpand-dammit, &gt; the my-macro(2) will again call macroexpand-dammit, but &gt; the environment passed to (2) is identical to that of (1). &gt; so it has no information about symbol-macro B. the binding of B seems to be &gt; stored somewhere ... in *env* maybe. &gt; &gt; I came to think I have to use cltl2-defined environment... &gt; thinking about exporting macroexpand-dammit:*env*. worked finally, but I have to macroexpand-dammit twice, with two different environment. why??
Let's summarise your contribution so far 1. The apology part which you opened up with on this page is false. The word is not used in the Shen license. Nobody expects you to apologise for making a mistake. You're just expected to be open about acknowledging errors and to fix them *if* engaged in kernel work. If you equate this with some form of ritual humiliation then that's a problem in your attitude. 2. You have presented no argument for showing the your model of concurrency actually requires breaking the kernel spec so all the hand waving about retracting your work and being forced to correct errors might well be irrelevant. You've been invited to show why and how your concurrency model is inconsistent with the spec by posting to qilang. You've not done so or shown any interest in doing so. 3. You've dismissed the community as insignificant and shown no interest in what the top poster deech has produced in his slides. As regards your scientific methodology, that's up to you. It's your work and your time. I think the OP deserved better though.
I doubt he'd go for it. I'll be sure to ask him when he's done napping, though ;)
Good point, and thanks for bringing this up! I may dual-license under the Wookie MIT license and just a vanilla MIT.
Well, mail Bill and see what he says?
Good plan. I'm on it.
Please report back any status here, if you could. I got duckduckgo.com to redirect !lisp queries to lispdoc.com, which needs to either be reverted or redirected back to l1sp.org.
[duckduckgo](http://www.duckduckgo.com) *^if ^this ^link ^is ^offensive ^or ^incorrect, ^reply ^with ^"remove". ^\(Abusers ^will ^be ^banned ^from ^removing.)*
Awesome! Thank you @doublec for keeping Wasp Lisp alive. I played with Wasp (including MOSREF) and have to say it is pretty cool and clean implementation. With some additions (and/or fixes, like keeping drones all the time alive), I'm seeing it as serious alternative to Puppet/Chef where Wasp could have clear advantage due small size, good security and easy deployment.
Found a bug, reported to the author of macroexpand-dammit. Ported in github https://github.com/guicho271828/macroexpand-dammit and now I'm using the private version in inner-conditional.
Love it. As the conversation wore on, they asked about applications of "ai" and "expert systems." I could not help but think ... Google! Conversing in natural language, a less brittle system ... love it!
I remember the time when I was lusting for it. Never had the money...
&gt; I find myself writing functions directly into the repl and moving them into the source file as the gel. Sorry for my ignorance, but how is this moving and saving done? Simply by copy and pasting "stuff" to the .lisp file and saving, or is there something like, e.g. repl-start-session &amp; repl-save-session which would save all functions and defined globals to some file you defined before?
&gt; Sorry for my ignorance, but how is this moving and saving done? Simply by copy and pasting "stuff" to the .lisp file and saving, or is there something like, e.g. repl-start-session &amp; repl-save-session which would save all functions and defined globals to some file you defined before? Yep, copy and pasting from the repl into my source buffer. Saving a repl session isn't really that useful, and is not something I've ever done. There are a couple of things to watch out for when doing this: * If you rename a function in your source file and evaluate/compile it, the old version is still active in your running Lisp image. There have been a few times where I've renamed a function but forgot to either rename it's uses and recompile, or just forgot to rename them at all. Within your session the old version will still be called, leading to confusing results sometimes. * Forgetting to copy the "final" version of a function worked out in the repl back to your source buffer. 
Programming in Lua is about half that, but how I wish Roberto has chosen an s-expr syntax. He gets about everything else right.
Nice article about functional programming, but not about Lisp.
Yup, I occasionally check your fork and for some time I planning to cherrypick your changes. Keep up with good work.
I really admire to the whole Lua team for keeping the language core small after all these years and this amount of popularity; it is maybe the hardest part in language design progress. Hell, even Scheme got bloated over time, e.g. hygienic macros...
I contacted Bill Moorier who pointed me at the current maintainer. I will report back when I get a response
Thanks for clarifying.
Copying and pasting the post in comp.lang.lisp: I've just released a Common Lisp library called "readable". It adds a new abbreviations to the Common Lisp reader for data and programs (by modifying the readtable). It provides 3 notational tiers, which are cumulative. Here's a summary: 1. Curly-infix-expressions (c-expressions): Add a Lispy infix notation, so {a op b op c ...} =&gt; (op a b c...). No precedence, by intent. 2. Neoteric-expressions (n-expressions): An e(...) maps to (e ...), and e{...} maps to e({...}). 3. Sweet-expressions (t-expressions): Parentheses are deduced from indentation. Unlike practically all past efforts to improve Lisp readability (such as M-expressions), these notations are general, homoiconic, and backwards-compatible with well-formatted s-expressions. Macros, quasiquoting, special forms, and so on work just fine. You can mix them with traditional s-expression notation, too. Here's a trivial example of a sweet-expression: defun fibfast (n) if {n &lt; 2} ; Indentation, infix {...} n ; Single expr = no new list fibup n 2 1 0 ; Simple calls Which maps to this (the reader would accept either): (defun fibfast (n) (if (&lt; n 2) n (fibup n 2 1 0))) You can get the Common Lisp tutorial (which includes install instructions), download the code (open source software using the MIT license), and get other information from: http://readable.sourceforge.net If you're a Scheme user, the first two tiers are defined in SRFI-105; the third tier (sweet-expressions) are defined in draft SRFI-110. If you think s-expression notation came from the gods, well, this library isn't for you. If you have an open mind, check it out. You might also view: https://sourceforge.net/p/readable/wiki/Retort/ Constructive comments welcome. --- David A. Wheeler P.S. Installing and enabling it looks like this, per the tutorial: ./configure --prefix make make install run_your_common_lisp_implementation (require 'asdf) (asdf:load-system :readable) (readable:enable-sweet) ; Or whatever tier you want 
Oooh - I wonder what the logistics of getting a Swank server running on this would be.
I don't think that s-expression notation came from the gods and I'd like to think that I have an open mind. I just read your article. I agree that some people are turned off by s-expression syntax, but many people were initially turned off from Python by significant white space. It used to be a common argument, but once Python became popular, folks pretty much see that argument as silly. It's true that it did turn some people off of using it. It's a matter of taste, just as s-expressions are. Some people love it, some people hate it. That's just taste. Quoting famous people (lispers even) that dislike the syntax, doesn't really prove that it is objectively bad. Lots of famous lispers *love* the syntax, why not quote them, too? Speaking of subjective criteria, there is an explosion of people who like the syntax so much that they are creating layers where they can use s-expressions in language runtimes that don't natively support it: Lisp Flavored Erlang and Joxa bring s-expressions to the Erlang runtime. Hy is bringing s-expressions to Python. Clojure is bringing s-expressions to the Java and JavaScript worlds. Calling s-expressions a "bug" in Lisp is not acknowledging that it is a matter of preference. Some people might prefer sweet expressions or some other syntax. Even the folks building s-expression support into other language runtimes are generally coming with the attitude of "I like it, you might like it, too. If you do, here you go." not "the syntax of this language is a bug, I fixed your bug, use my fix if you aren't an idiot" which is how you sound.
The article is not mine. I'm just forwarding the news.
I have NEVER seen any proposal as ugly and idiotic as this. Just. Fucking. Wow. 
That code looks pretty nice. I wonder what applications it is being used in.
I think S-Expressions will keep working normally with this reader. The alternative syntax is optional, but possible.
I find it hard to believe you think the specific form of s-exprs is what gives lisp its power. Isn't it rather the homoiconicity and that s-exprs are fully general, not tied to the semantics of a programming language? Basically, any notation for general trees of strings would be good enough to make a lisp, right? To me, Wheeler's notation feels trivially equivalent to s-exprs and I don't really see why anybody would object to it (except maybe as being unnecessary).
Quite right. Homoiconicity is really the power there. Presumably M-exprs (though I have no experience with those) have exactly the same benefits. Perhaps I've grown to have an aesthetic appreciation for all those parentheses giving my code a nice big, warm hug. For example, the [Julia language](http://julialang.org/), which has been excitedly followed by many in the scientific community, looks to have very bland Python-esque syntax. However, they claim to be fully homoiconic and supporting of macros. From what I've read, the designers are trying to make the language as lispy as they think they can get away with. I don't immediately see where Wheeler's notation is trivially equivalent to s-exprs, however, that is almost certainly a function of my lisp naiveté rather than anything grounded in expertise. I am also willing to accept the word of People Smarter Than Me™ that the two are equivalent. Even if they weren't equivalent, I'd still agree that it is silly to object to this project.
I had done the same. Two days without a reply from Mike, though...
It appears to be [back up now](http://lispdoc.com/). 
If you mean, "I want to do X, I wonder what library I should use..." then [cliki's recommended libraries](http://cliki.net/Current%20recommended%20libraries) is a great place to start. For stuff not listed on that, or just second opinions, general help, etc #lisp on freenode is probably the best thing.
&gt; Clojure is bringing s-expressions I think Clojure is bringing the power of Lisp. Bringing s-expression is just a byproduct.
Not just a byproduct, it's part of the package and folks like it as far as I can tell, or a lot of people are faking it really well.
So it seems to have been sold. For $1500? Amazing. Configuration was: * Apple Macintosh II with 16 Mhz Motorola 68020 processor, 5 MB RAM, 80 MB Disk, Ethernet Card, Radius Graphics Card * TI microExplorer NuBus Board with 12 MB (!!) RAM 
Also available here: http://bigw.org/~pkrueger/misc/InterfaceProjects.zip
If you haven't already done so, get on the Clozure mailing list. Just today there was a posting on how to download the contribution without getting the trunk version of CCL.
I think emacs is inserting tabs. I'm usually careful about things like that, but maybe I missed some. I'll look into that. 
There's one, it's not fully ANSI-compliant yet though... And I don't remember what it's called.
[smacklisp](http://www.smacklisp.com) is a site that I am developing. The site is to be a playground for lisp with a REPL. The lisp used is an interpreted toy lisp-2 within CL. The [code](https://github.com/aarvid/SmackLisp) for the toy-lisp is available. The code for the website is not. An earlier version of this site had code evaluated directly in CL but I had trouble sandboxing each connected user. I am not saying that it is impossible to sandbox lisp, but it seemed easier, cleaner and more enlightening to implement my own lisp within a lisp. 
Wow, thaat's impressive though it is different from what I was looking for. What I am looking for is a way to enter Lisp code into a running system like SLIME over a remote SWANK does, but using a web interface. If I have my application running on the intranet, I would like to be able to call some functions from a web page (REPL is sometimes more convenient than ordinary graphical UI). It is something like you did, but instead of feeding commands to an interpreter, feed them to the Lisp eval so that they are evaluated by the system.
Thanks for your contribution to the conversation.
Looking at the [intro](https://github.com/lihaoyi/macropy#rough-overview), I was surprised to see that the first 2/3 talks about specific macros, and do not say anything about how to *write* macros. That is addressed in the last 1/3 of the document, and it looks like there is a good reason for that: Python does not appear to be very well suited for manipulating the AST (compared to Lisp). Nevertheless, it is impressive that you can implement this in Python. I am curious to see whether macros will be used only by Python wizards, or also by reasonably advanced users. For example, the R language also has macros, but very few users even know about them.
It was a conscious decision to put example macros first, and documentation of writing them last. Although LISP people know all about macros, the bulk of the people who will be reading the page will be wondering "Macros? I don't need no stinkin' Macros! What did Macros e'er do fo' me?". This is meant to cater to that crowd.
Btw., we call it 'Lisp' since the big flood, shortly after mankind killed the last dinosaurs.
Oh, thanks, SmackJack thounds very close to what I am looking for. Probably I will try to find some time to give it a try. Thanks a lot!
&gt; For example, the R language also has macros, but very few users even know about them. There are several reasons for that. First, the implementation is not as good as Common Lisp, Scheme, or Clojure macros. Second, macros are not nearly as appealing without s-expressions. Third, they're not necessary as often. Consider this code: foo &lt;- function(x) { cat("You sent the variable",deparse(substitute(x)),"\n") } &gt; foo(y) You sent the variable y &gt; foo(z) You sent the variable z Those two calls were done without defining y or z.
As someone who has endured Python for the last 3 or so years, I would gladly throw the thousands of hours of work into the trashcan for the ability to put thousands of hours into Common Lisp.
https://github.com/mathematical-systems/cl-gui seems a kind of thing you want, but I failed to build it...
There have been a few cases where, in R, I've thought to myself, "this looks like a job for macros." I've always been a little disappointed in the result.
The next step, of course, is to give it a SWANK implementation so we can move *off* the web browser as quickly as possible - heh.
It really makes an impression but it somewhat lacks of documentation and from the README description I can not understand whether it is what I am looking for. Still thanks for the hint. I've learned a lot already in this thread.
I learned Python first, but now also program Lisp too, so I have no interest in language wars. But for the Python programmers that are curious about whether or not MacroPy is equivalent to Lisp macros, the answer is no. MacroPy does have some limitations that Lisp macros don't. It's cool that MacroPy was written, and seems to be implemented in the best way possible that works for Python. The main limitation of MacroPy (according to the docs) is that macroexpansion is done at module import time. The consequence of this is that you can't just put a macro anywhere, you have to define it in a separate module from where the macro is used. To Lisp, a macro is basically another kind of function, except it's one that generates code. So there's no reason you can't do something like define a local macro inside a function just like how in both Python and Lisp you can nest functions. So Lisp can use things like MACROLET to do this, but MacroPy cannot because the macro must be defined in a separate module. There will inevitably also be psychological differences too, because in Lisp it's a low barrier to entry to write a macro because it's just regular Lisp code. The same way you can use backquoted s-expressions anywhere else (kind of like filling in a template), you also use them for writing macros, and it's fairly easy to tell what's going on. The parentheses and prefix notation of Lisp is what essentially makes it a language where you program a readable AST directly. Python's AST is a lot harder to manipulate. In many ways, Python as a languae is more readable than Lisp, but Python's AST is not. Programming regular Python code and writing MacroPy macros will psychologically be like writing two separate languages. There are other differences too, like Lisp compiler macros that can be used to do things like make Lisp act more like a statically typed language with similar performance because it's a macro that hooks into the compiler, not parser/lexer, etc. So in regards to macros, Lisp is superior but MacroPy is still a welcome addition. Neither *language* is better than the other, just different. Lisp has cool things like a condition/restart system that can act like a signalling mechanism rather than just handling errors, but Python has a clean and standardized way of doing generators (rather than ad hoc ways people do it in Lisp). Lisp's multimethods and generic functions with CLOS is powerful, and isn't really matched by Python multimethod libraries that miss features like CALL-NEXT-METHOD, :AROUND methods, or customization of method resolution, etc. But Python is more consistently object-oriented, whereas some Lisp built-ins aren't extendable using CLOS, you have to reimplement them. This list goes on and on. Both languages are worth learning. If people are interested in MacroPy, it might actually be helpful to give Common Lisp macros a try for a while because it might be easier to learn what macros are about, then do the equivalent in MacroPy so you have an idea of what to do with the Python AST. 
MacroPy has quasiquotes too; although Python's AST is significantly bulkier than Lisp's, quasiquotes make working with them bearable. Your macros end up looking like: @macros.expr() def expand(tree): addition = 10 return q%(lambda x: x * (ast%tree) + (u%addition)) It's 2 characters instead of 1 to quote and unquote, but it's not too bad really. You rarely ever have to construct the (rather bulky) ASTs by hand. I don't agree that python ASTs are harder to manipulate. Sure, they're a lot bulkier (so many different cases!) but I think func.body.left.right is somewhat easier to read and work with than (car (cdr (car (car (cdr func))))) or the equivalent (cadaadr func) ;; wtf does this do??? EDIT: got my `cadaadr` wrong
Awesome
how is this done?
I think your library caters to people who *write* macros, and may in the end create libraries of their own which extend the language. It is unlikely that end users will care so much about macros, even though they may like to use a construct that was implemented using macros, but the actual implementation is unlikely to be very important to them.
" I used SC3 and Cocoa, OpenGL on Clozure Common Lisp. " So, with that probably.
very interested. I tried to guess what kind of library he was using, only to find out he was at least using some heap library by nikodemus. isn't it Overtone on clojure, not clozure CL?
Edited it; clearly my Lisp skills are still no good, if i'm making so many silly mistakes in such a short example! It's the same example as above (with the really big `cadaadr`)
It's Clozure, it's defn in Clojure, video says defun.
Github has a very nice introduction that is simple to understand :-). It also has a graphical client for Windows and Mac OS X! I'd recommend licensing your software under the LGPL: http://www.tldrlegal.com/license/gnu-lesser-general-public-license-v2.1-%28lgpl-2.1%29
thank you for much information about the libraries, I'll try them out. you don't have to worry about your language skill (I'm from japan and not a native English speaker too) (do I have the right to say it? not sure) and neither about `the rule` ... again, great job.
It's not CLISP but CLIPS, a specialized Lisp for building expert systems.
This is totally badass. Sweet work!
Artists are ahead of their time. Let us programmers use this as an inspiring example, and say long live Common Lisp!
 Maybe write the info in your native tongue then someone can translate to English for you?
I think It may be more accurate and precise to say that in functional programming that the functions satisfy [time-invariance](http://en.m.wikipedia.org/wiki/Time-invariant_system) rather than claiming a function is timeless. Reading the latter phrasing implies to me that if I chose a purely functional language that I cannot model algorithms that use time as an independent variable, which would be a deal breaker for many applications. 
Just look at Wirth's voyage from Pascal through Modula-2 to Oberon. (The newer version of Wirth's Oberon is actually simpler than the old one.)
It looks like you've put a lot of work into this. My advice is to market it as a separate language, that has common lisp interop. Looking at the syntax you've created, I don't think it's a lisp at all, and calling it one will be confusing to people, not to mention it looks like it will essentially break macros. Coming from a beginner's mind, the syntax *does* look very clean and friendly. However, you're going to meet a lot of resistance from lispers. Most of them are lispers because they like (or at least can stomach) the syntax. Also, this will introduce more fragmentation into the lisp community. For instance, CoffeeScript is a fairly capable layer over Javascript, but I personally detest it and don't like working with libraries written in it. It actually makes me angry when a library I want to use is written in CS. As a lisper, I would much rather choose a library written in CL over Readable (if nothing else, because I wouldn't have to build/install the reader). So while I think it's a noble goal, you are going to fight an uphill battle trying to sell this as lisp. 
Cambridge, 1993. Steele and Gabriel try to point out the pointlessness of criticizing this particular brand of mental masturbation: &gt; ...we expect future generations of Lisp programmers to continue to reinvent Algol-style syntax for Lisp, over and over and over again, and we are equally confident that they will continue, after an initial period of infatuation, to reject it. (Perhaps this process should be regarded as a rite of passage for Lisp hackers.) 
I don't know if it qualifies, but it seems like (as it isn't expressly called AP5) it [was used as a software comparison](http://www.cs.yale.edu/publications/techreports/tr1049.pdf) in language productivity. From their own data it looks like it won but...
It was that particular study that let me to look into AP5. It is quite interesting, although I understand there is some controversy regarding the conclusions. From the description it also appears there was significant differences between the the skill levels and domain knowledge of the participants.
1. Catch/throw is **not** used for errors in Common Lisp, it is actually used for control flow. Read the CLHS on catch/throw and Practical Common Lisp's chapter on restarts. 2. I find the SUCCESS function to be unnecessary 3. run-parser, same thing here as in 1. 4. In SEQ. a DEFUN *always* defines a top-level function, it doesn't matter where you write it. Use LABELS.
Your use is correct as in the code will run in the way you expect it to run (I think, too lazy to try it out lol :-), but it's not the idiomatic way. The point of catch/throw isn't to do error-related stuff, it's simply a way to dynamically change the control flow. To quote the CLHS &gt;catch is used as the destination of a non-local control transfer by throw. Tags are used to find the catch to which a throw is transferring control. Instead use ERROR to signal an error and HANDLER-CASE to catch the errors. Read: http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html
Your question inspired me to dig out some old code and post it on GitHub. It is [an OMeta inspired parser](https://github.com/AlexCharlton/CL-Meta-Parser) I wrote last year. Hopefully it will be of some interest to you. It shows the use of conditions (in a somewhat more advanced way than using ERROR) with HANDLER-CASE, among other things. If you have any questions, don't hesitate to ask. As for your code, aside from samlamamma's suggestions, your LOOP in EITHER is a little off. LOOPs are surrounded by an implicit block from which RETURN will return from. Also it is common to have a new line after every expression in LOOP. Something like this: (defun either (msg &amp;rest parsers) (lambda (tokens) (loop for parser in parsers do (catch 'parsing-error (return (apply-parser parser tokens))) finally (return (fail msg)))))
Maybe even too powerful at times. Keep in mind that "non-local control transfer" sounds a lot like a `goto`, which has limited uses.
 (throw 'parsing-error (apply #'format t fmt rest)) This is why the error message is printed even if there's a catch: `(format t ...)` prints to `*standard-output*`.
Just FYI, https://github.com/nikodemus/esrap is a nice PEG parser system (n.b., I prefer more general parsing than packrat, but, eh). I've had good success with it with https://github.com/pnathan/pp-toml, a TOML parser.
I'm not a parsing expert by any means, so I'm probably not qualified to review your code, but you may find this useful as a point of comparison (possibly examples of what not to do): https://github.com/equill/mark-and-render I wrote that because the wikimarkup I wanted to use doesn't work so well with regular parser generators, and I have some experience with the shortcomings of regex-based wikimarkup renderers. Development has slowed down because I'm working on other parts of the overall system, but I'll be circling back once it becomes the bottleneck again. If you're looking for error handling, CL's condition system is fantastic. Don't worry about it sounding like GOTO - it's a different kind of thing.
Well, it isn't so simple as that. Haskell is a definitely pure functional language, without any cheating, and you can still program things which depend on time and side effects to the outside world. Purely functional programming limits the programmer to constructing objects in a purely functional way, but those objects themselves might denote non-pure operations. This is how it works in Haskell's IO Monad: the programmer constructs IO actions using purely functional Haskell expressions. Once the program is compiled the runtime may execute these compound IO actions. The programmer nevertheless never directly side effects. 
As Ahorne already said, you should learn about conditions because using THROW and CATCH is not lisp way to implement error handling. You can start right here if you haven't read it already: http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html
Yes, it looks pretty good. You code is very nicely written for newbie, btw. Mine was like lots of code in one function and another function called MAIN which I called to run all stuff.
Were they dead?
Oh and my OS is Xubuntu Linux (64bit) and Windows (64bit).
About 10 years ago I took a university course where we used DrScheme, which is now call [DrRacket](http://www.racket-lang.org/) I believe, to learn scheme. It was really simple to use (select the language you want to use, type code in one textbox, press go, and see the results in another textbox). I would definitely recommend it for learning scheme. I've been dabbling in scheme lately for some personal projects and also find [Chicken](http://www.call-cc.org/) to be great. Mostly because it's dead simple to compile scheme to a native binary (just run `csc filename.scm`).
Racket is a whole lot of languages in one package, one of them compatible to the R5RS Scheme standard. My personal preference on Linux would be Gambit-C or Chicken Scheme, but if you ask three programmers you'll get four answers, all of them valid... EDIT: Some more info about the Schemes mentioned: Gambit-C is very interesting for its green thread support, approaching Erlang in thread performance. Chicken Scheme is very portable and has lots of packages (called "eggs"). Both compile to C then native code. Racket has a JITter.
IMO, Racket is a good choice for you use largely because of the excellent Dr Racket environment and the great ecosystem around Racket. Dr Racket will work well on both Windows and Linux. &gt; Can I use all of them with any Scheme tutorial? For the most part, but really it depends. There are different scheme standards and some implementations extend the language, so if there is a particular book/tutorial you want to work through and it reccomends a particular implementation you should probably just use that. For example, I would suggest you consider working your way through [Structure and Interpretation of Computer Programs](http://mitpress.mit.edu/sicp/full-text/book/book.html). There's a free online course based on it in [OCW](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/index.htm) with video lectures, etc. To do a lot of the stuff in the book you need to tell Racket to use R5RS (or better yet, use [this package](http://www.neilvandyke.org/racket-sicp/)). 
I see, thanks for the answer! Although I'm not sure what green thread support and all that is all about. Not that I think it's that important for a beginner. I believe I'll try DrRacket first, maybe Chicken. Thanks yet again.
Ah yes, that's the one I've downloaded. Splendid.
I second the recommendation of watching the SICP video series. I would also recommend starting with John McCarthy's original [paper](http://www-formal.stanford.edu/jmc/recursive.html), especially if you have some background in formal logic. I personally code in Clojure, but I found starting with SICP and McCarthy's paper to be the best introduction to lisp you can get. 
I also learned Lisp as my first programing language. It's been 5 and a half years since I started. If there was one thing I wish I had done differently, it would be to mix theory and practice ASAP. I started out teaching myself from [SICP (pdf warning)](https://github.com/sarabander/sicp-pdf/blob/master/sicp.pdf?raw=true) and the accompanying [SICP video lectures](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/). Between a full time job, moving in with my friends+girlfriend, and doing a lot of the cooking and cleaning, I lost the time and motivation to keep going half way through. With SICP, you definitely get out what you put in. That said, I wish I had started working on hobby software of my own (in scheme, python, or common lisp) or Open Source sooner than I did. I started working through SICP in January 2008 and didn't really start "hobby hacking" until October 2009! SICP gave me a great foundation but there's also a real need for substantive projects to cut your teeth on. I guess what I'm driving at is that the theory and practice should both push *each other* forward. I don't see this in many CS programs either and I think that's sad. The joy of hacking is in teaching a machine to breathe life into an idea. There is a natural back and forth between me learning theoretical concepts and then wandering away from books for a while to just **build stuff**. Lately, I started working on a [Nintendo emulator in Lisp](http://blog.redlinernotes.com/posts/So-Close-and-Yet-So-Far.html) because I wanted to know more about low-level programming. That's had me searching around and reading papers like [Context Threading: A flexible and efficient dispatch technique](http://www.cs.toronto.edu/syslab/pubs/demkea_context.ps‎) or bits of books like [Computer Systems: A Programmer's Perspective](http://csapp.cs.cmu.edu/). It's key to my motivation to be able to bounce back and forth between theory and a real project. Having a project, however humble, is an excellent playground for things no book can teach.
I totally agree with your point. Having personal projects seems very useful indeed. Geez, a Nintendo emulator is way out of my league. Seems very advanced. Congratulations, nice website as well! 
Thanks for the bug fix. But it seems macroexpand-dammit works without your fix. I'm using SBCL 1.1.7 Here's my testing code: (defmacro my-macro (form &amp;environment env) (macroexpand-dammit:macroexpand-dammit form env)) (defun my-clause (x y z) (list x y z)) Then evaluating (symbol-macrolet ((A 1)) (my-macro ;;; (1) (symbol-macrolet ((B 2)) (my-macro ;;; (2) (symbol-macrolet ((C 3)) (my-clause a b c)))))) =&gt; (1 2 3) Am I missing something? I'll let John know about your fixes anyway.
Racket is good if you into IDE's. Other wise go for Chicken or Gambit Scheme which are 'small' and work great in a UNIX/Linux command line environment. My only gripe with them is that they don't have native thread support. But then why should you care if you are a beginner.
Well, it's way out of my league so far too. You'll note I only have the CPU working so far. But thanks, and good luck! :)
If you're at ease with emacs, I'd recommend GNU Guile 2.x (http://www.gnu.org/software/guile/download.html) beside Racket (which is really nice for its libs and docs), with the built-in Paredit mode for zen inducing s-exp editing and geiser extension (http://www.nongnu.org/geiser/) which support these two implementations. ps: having a s-exp aware editor is IMHO very important (emacs, vim or whatever)
There are a million optimizations... * you are aware that Lisp has multi-dimensional arrays? No need to implement your own version. * your code is consing like mad. For each cell you compute a list of coordinates. Then you compute your own access to the array. Then you return a list of element values, where you later count the ones... Probably you can do all that in a single small function. ... 
faster? How? You calculate a 2d access into a vector. It's likely that the built-in version is faster...
Well your FPS is set to 1, so the performance looks OK to me. But assuming you have some slowdown in other cases, the most suspicious part is the creation of all the SDL rectangles. You only need to create one. (defun draw-buffer (buffer) (let ((rect (sdl:rectangle :x 0 :y 0 :w *rect-w* :h *rect-h*))) (loop for y upto (1- *buffer-y*) do (loop for x upto (1- *buffer-x*) do (sdl:set-rectangle-* rect :x (* x *rect-w*) :y (* y *rect-h*)) (if (&gt; (element-at buffer x y) 0) (sdl:draw-box rect :color sdl:*black*) (sdl:draw-box rect :color sdl:*white* :stroke-color sdl:*black*)))))) Another optimization would be to remove the consing for the neighbors, but I doubt you'd see much difference with that. Rendering is typically the big cost.
Lines 8-15 look like a custom implementation of 2-dimensional arrays. Lines 17-21 use multiple SETF calls when one would do. Lines 24-28 look like a custom implementation of MOD. You're also using IF when you have no else-clause. Lines 48-51 have a bunch of SETF calls with the same place, which could be one SETF call with the COND providing the value. To me, "upto (1- \*buffer-y\*)" looks stranger than "below \*buffer-y\*". But almost any use of LOOP looks awkward compared to [ITERATE](http://common-lisp.net/project/iterate/), especially when you need to nest loops. You might want to read [Norvig's style guide](http://www.cs.umd.edu/~nau/cmsc421/norvig-lisp-style.pdf) (PDF).
Thank you so much for your answer. I read the first chapter of SICP and I don't really know. I might have to give it a longer chance but it seems very formal. I looked at the video lectures and they seemed quite alright but lectures aren't really my thing. Perhaps.
I reorganize your code a bit and the result is [here](http://paste.lisp.org/+2XY9); mainly, * We can get rid of most (if not all) of the global variables and consolidate the various pieces into one place. * We don't need to cons up all the neighbors and then count them; just count them directly. * Avoid specifying redundant information that can be calculated from other input (e.g., dimensions of individual cells). 
Parts of this read similar to what my thoughts on the next iteration of this would be. Instead of an array of integers, I'd like to make a cell class that keeps references to its neighborhood, removing the necessity of counting them up, and allowing each cell to determine its next state.
I don't agree with your reorganization. Moving the code to one unique big *update* function is not good style, in my opinion. Moreover, you don't need to use CLOS where a *struct* or, even better, a simple *let* at the beginning of your main function would have done the trick. EDIT: this is intended to be a small critic ; my apologies if it seems a bit agressive, this was not the intention.
This is mostly a taste complaint (kinda) but I think you should use (not actually :USE it in the defpackage form, mind you) the RED package instead of the REDIS package, then you won't write REDIS:RED-GET and will instead have red:get. EDIT: It felt mean to leave this post on such a negative note, so I just wanted to say that I really appreciate that you're doing this, it's awesome!
Copyright status? No mention on the linked page.
Wait, you can use a single SETF to set multiple values? I had no idea.
It belongs to TI. It has never been published under any 'free software' license. This archive does NOT come with any license which would allow us to use or modify the code. You would need to get a license from TI - which probably does not know what to do with such a request.
Hi, just wanted to let you know this tutorial is completely awesome. When I was working thru the first chapters a couple of months ago, I found a few minor typos in the code, eg `blogdeko` instead of `blogdemo`. If you are interested I would gladly help you proofread the document, it is one of my favorite CL tutorials. PM me if you want any help.
Great!! Garbage collection is very simple!
You mean the cool stuff in 2 million lines of source code?
This could be perfect for the model/controller part of a web framework.
As a CL user, it seems weird to process Lisp character input with a lexer rather than a reader.
I'm not sure I could say what the difference is... but at least it's all wrapped up in the `read_expr()` function which is analagous to `read`.
I am curious whether it is possible to recover anything that might be useful in the modern environment and if there is anything useful in that code at all.
I don't know; I certainly never use structs over CLOS unless there is a valuable performance difference (eg: stack allocation). Here I cant see this making any real difference at all. Also while I think count neighbors could be a separate function as opposed to a FLET, having it be a FLET has some compelling arguments (eg: not redeclaring or passing the variables d0, d1). To each their own though.
This is really awesome. In the intro you said you got the idea from the SICP lectures. Was that your only/main source of info on how to write this? Have you taken any compiler courses? I ask because I'd love to try something like this, but I wonder if my skill and knowledge levels are up to task.
Racket is fine. I'm not sure about the whole Scheme-then-CL thing: if you're happy with a single-implementation language, Racket is fairly industrial-strength (I'm saying this as a mostly-CL person).
Do you develop on Linux? In that case, what does your setup look like? (Common Lisp setup, eg. Editor, IDE?) On second thought, what's your setup on Windows (if you swing that way)?
I use LW.(I'm also probably a bad person to ask as I'm way out of the CL mainstream now).
This is a question of taste. I perceive your code organization as very influenced by the POO (C#, Java, and co), and I dislike this kind of programming style. Nothing more :)
Ah, I see. Did you buy it? If not - isn't the free version a bit limited?
For those who are browsing the code, this Perl one-liner will strip the font-specification controls from a file: perl -i -pe 's/\x06[0-9*]//g' &lt;filename&gt; Cleans things up a bit.
yes
Pretty much. In the later lectures they show how to implement `eval` in Lisp, so it's basically just a case of translating that into C. There's a very interesting [article](http://www-formal.stanford.edu/jmc/history/lisp/lisp.html) about how this happened the very first time around. I reckon you could do it pretty easily in any language you like - just start with a way to store the lists and atoms in memory and work up from there. I have absolutely no computer science training, but there's a lot of information out there on the internet for free. I've been messing around with programming since I was little, and somehow got good enough to make a career out of it. Attempting something you're not sure how to do, (and possibly failing, researching, and then trying again), is IMHO the best way to improve your skills. So go for it! :) 
Parts of the distribution are *not* under TI's license, but originate at Stanford or MIT and have a more open (though not necessarily free) license.
Scheme has a highly fractured community. You're going to drive yourself mad asking for advice about where to start, which implementation is better, etc, etc. Just ignore 90% of the drivel on the Internet and pick an implementation you like the sound of. It doesn't matter, especially not for a beginner. The SICP video lectures are good, but they don't beat reading and doing most of the exercises in the text. Also, the original McCarthy paper is a ridiculous place to start learning Scheme. That's purely of historical interest. There are Scheme (Kawa) and Common Lisp (ABCL) implementations targeting the JVM as well, like I said, these things aren't clear cut. Don't allow yourself to be force fed the Clojure kool-aid, make your own mind up. Not to demotivate or anything, but there is no Nirvana, only progress. Good luck.
This is true. I wonder if another language would be better as a start? Ruby perhaps. I don't know, but if I'm going to learn Lisp I think I'll go with Common Lisp. Haven't entirely made up my mind.
It doesn't matter. Truly. Peter Norvig (http://norvig.com/21-days.html) has put it well with respect to choosing a language: "The important thing is that you choose and get started." Once you make a choice, stick with it for at least a year and learn how to program. The choice is arbitrary.
Thank you so much. I must say, this is the best advice yet. (No offense to ye others.)
What kind of code will be making use of this?
All lisp code compiled with sbcl, presumably
I didn't find any reference to racket in the whole page or in the video. Except for having HTDP as a suggested reading.
I'm registered, and the pre-flight instructions direct students to download DrRacket.
Still waiting for the tree shaker that was a GSoC project a couple of years ago for sbcl.
Yeah but like, will it affect all code or just numerics intensive code or something like that :-)?
I don't know what kind of improvements they will be making here in particular (I know nothing about SBCL internals), but if they can make register allocation more efficient, that usually and in general means that all kinds of code can run more effectively. Loops may become faster as they have to swap less registers in and out, function calls may become more efficient, et cetera. If you want to really know the details, you'll have to read the paper by Briggs et al. (1994) they reference on the page.
Why not stay with Common Lisp?
May I suggest you simply call it *Stellar*? It's easier to remember and more catchy. Write up some examples and make the link to the github page more visible. 
At a guess, plotting was not easy for him (I've found libre UIs and plotting to be a mess in Common Lisp). BTW: if anyone has suggestions on a easy GUI/plotting library, I'm open to hearing them. I've tried commonqt, smoke, commonsdl, etc. not great. :-/ LTK is the best IMO, and it's a pipe out to TK.
Use the browser and Javascript libs? Gnuplot?
&gt; Use the browser and Javascript libs? Gnuplot Ugh. No. Seriously. The browser is simply not an acceptable replacement for native work and capabilities. Not to mention that Javascript is a heinous mess. Gnuplot is more acceptable, but frankly, it's limited in capability &amp; if I'm trying to display any sort of significantly complex multiplot data, it doesn't work. A real native toolkit that doesn't require weeks of futzing and bindings manual configuration would be real nice. n.b., cl-cairo almost was this, but the author ran off and executed the CADT model perfectly[1]. It's very frustrating. [1] http://www.jwz.org/doc/cadt.html
How about some LispWorks based libs? https://github.com/dbmcclain/LispPlotter The next one is actually a LispWorks application: http://www.inspiration.com/InspireData
One may want to add that these generational GCs have been used in countless Lisp implementations from the 80s until today. CL-USER 105 &gt; (room) &gt; Generation 7 allocated 33309816 &gt; Generation 6 allocated 0 &gt; Generation 5 allocated 0 &gt; Generation 4 allocated 0 &gt; Generation 3 allocated 1367000 &gt; Generation 2 allocated 45353104 &gt; Generation 1 allocated 11794616 &gt; Generation 0 allocated 7483816 
I'm not sure that lein really *does* many things that QL doesn't, but it does those things in a more straightforward way. One of the things I like most about lein is how it lets you manage your project with project.clj. It makes everything more managable, at least in my opinion. I also always found QL kind of hacky and only 99% reliable.
Right now I'm using Incanter, as it includes both plotting tools and statistical functions, so that's two dependencies covered in one. Here's a little example of how to define and plot a lightcurve using my library (I used a sine wave). (def phases (range 0.0 1.0 0.1)) ; Creates sequence (0.0 0.1 ... 0.9 1.0) (x-axis) (def mags (incanter.core/sin phases)) ; Takes the sine of that sequence (y-axis) (def lc (make-observed-curve :phases phases :mags mags)) (stellc.plotting/lc-plot lc) ; Plots the curve (stellc.plotting/lc-plot [lc :title (stellc.plotting/lc-plot-title lc :source "Hubble")]) ; Plots the curve, and notes that it's from Hubble in the plot title (could be useful when comparing two sources) At the moment, I really just want the plotting to be for quick, on-the-fly use, and not for making very customized plots. A user might want to just check to see if a light curve looks ok or not, so it'd be convenient to have something quick like (lc-plot some-lightcurve) instead of having to worry about pulling the right x-axis and y-axis data from the lightcurve and putting it into a generic plot function. Maybe I should make two separate plotting functions, lc-plot-quick and lc-plot, so that users can have both. I know I personally would rather just use the quick plotting function while I work, and then when it comes time to make high quality or customized plots, export the data to text files and plot it with matplotlib, and I'm sure many others will have their preferred plotting library they'd prefer to use.
Well, from the POV of a general PL, Fortran seems "messed up" only because it is not fit for any random general programming task. But Fortran was never meant to be a general programming language for solving general programming problems. It is a DSL tailored to a specific, narrowly defined task: helping scientists and engineers, i.e. people with no CS background and no general CS type task, to translate their formulas into numeric algorithms. A FORmula TRANslator. Even if you had scientists and engineers start out with pure Lisp, they would keep changing it until they eventually end up with something like Fortran, Matlab, R or Julia. Fortran is just the sweet spot you end up in when you set out to solve numerical problems.
Ideally though, that would be a DSL that is compatible with the parent, more general purpose language.
The last thing he says really hits home. "Programming hasn't changed much in 50 years since they... got locked into a strange set of limitations."
No, I think you're right. I just don't agree regarding Bison. It parses a DSL, not C, AFAIK.
Minsky says that people don't/can't write C programs that write C programs. He says nothing about the input format. Bison is a C program that happens to parse a DSL, but it is a C program that writes C programs, which in turn parse other languages.
Yes, I that that should be the message people should keep in mind. But still think there is something there that he is saying that I am missing. Perhaps he dreams of a world where Lisp programs write new programs with extremely little or poorly defined user supplied information. This sounds neat, but I am having a hard time actually formulating a single scenario where this really makes sense but doesn't boil down to standard machine learning stuff. Maybe a program that uses a neural network to fit a problem, then examines the behavior of hidden neurons to determine "intelligent" ways to think about the problem in terms of heuristic rules, then (and this would be the new step) translates those rules a function/program with no neural network all, only the "smarts" that were distilled from the networks training.
&gt; Even if you had scientists and engineers start out with pure Lisp, they would keep changing it until they eventually end up with something like Fortran, Matlab, R or Julia. For the record, R was initially a Scheme dialect, so they *did* start out with pure Lisp. If you dig around in the R source code you will see that the Lisp influence is still there. 
Lisp is way older and more firmly rooted in the field. That is a possible explanation for "use Lisp" to be more common. It should be said though, that while Haskell is very elegant, Lisp is much more so. The code isn't necessarily more elegant, but the language definitely is. Since the Lisp syntax can be summarised on a business card, basically everything you see in the language is built using a few basic building blocks that define the language itself (someone once said something about the core of Lisp really consisting of *seven* functions -- sans numerical manipulation, of course.) This is very similar to how the entire universe is (as far as we know) constructed out of a few elementary particles and their respective forces. As for power of the language -- nothing rivals Lisp in its metaprogramming capabilities. It could be argued that Haskell comes close with Template Haskell (and perhaps even more so now that they are doing better with well-typed TH) but TH still doesn't feel as native and effortless as macros do in Lisp. I think you should *try* Lisp to see how it can be constructed with a few basic building blocks and especially to experience how fluently you can do metaprogramming with it. Then you can make the comparison yourself.
If you prefer Haskell, code in Haskell.
I could be nasty and say "to paraphrase Philip Greenspun, every mission-critical military software I’d worked on contained an ad-hoc, informally specified implementation of half of Erlang." (Which I already have btw)
This question is a exciting as: I have some experience with Ferrari, but none with Porsche. I like the Ferrari 430. It has a blablabal. It drives blablabla. None of that is provided by Porsche. I also find the red color much more appealing. But I do read 'drive a Porsche 911' way more often. I have lost count of the various 'Porsche is so wonderful', 'The 911 is so elegant'. The authors must be unaware of Ferrari, what exactly is it, that makes Porsche so wonderful, especially compared to Ferrari? Then see this: http://www.youtube.com/watch?v=AO7XvOt9suM 
There is no clear ordering, both languages offer features that the other lacks. You will have to decide which ones are the most important for you. I will not catalogue differences, because you can find plenty of comparisons on the net and in any case, short descriptions are pretty meaningless unless you work with the language. But picking one just because more people tell you is silly. Google gives 4.5e8 hits for "wear blue", 7.7e8 for "wear green", but is this helpful for buying clothes? Probably not. Most serious programmers have tried both languages/families (to a certain extent), and that's what you should do.
No, you asked on the level of taste. Comparing feature names and surface. Without using it actually or trying to find solutions to practical problems by developing something. 
Languages are tools for thinking. If a language's constructs and associated tools fit well with how you approach the problem you're solving, you'll probably find that it feels good. If they do not, you may find that it feels awkward. Also, Lisp is a family of languages. I'm assuming Common Lisp here. There probably aren't many useful things that require a great deal more code in Haskell than Lisp or that are impossible in Haskell short of using it to write a Lisp implementation. I think your best bet is to just learn Lisp and write a few non-trivial programs to see how it feels. Lisp has a different answer to the problems that lazy evaluation solves, without some of the downsides: * Macros allow the programmer to choose when and whether certain code is evaluated * It's easy to create lazy data structures in Lisp Furthermore, homoiconicity makes writing programs that manipulate code easy.
Homoiconicity.
Do you understand why Lisp's syntax is the way it is? Because you should. Lisp is a truly multi-paradigm programming language. It has features for functional programming, declarative programming, OOP, imperative programming, and it is easily extensible. While in Haskell you have the purity of functional programming, in Lisp you have told top make the language be whatever you want. Do you want lazy evaluation? The language does not offer it in the standard, but you can easily implement it. While in Haskell you have implicit typing, in Lisp you have other powerful typing features (like multimethods, change-class and compiler hints). You'll only understand what is so awesome about Lisp if you try to hack it foot some time.
I went through this as someone already familiar with CL and enjoyed it. Overall it is quite well done, and I think it would be a useful exercise for someone picking up CL. My biggest nit to pick is that it describes let bindings of special variables as lexical instead of dynamic. There were a few less egregious nits too. It is a batch-mode program instead of the more typical interactive experience, which strikes me as a painful design decision but not necessarily wrong. By not pushing SLIME the author probably widened his audience (note the 300+ stars on the repo), but the audience will miss out on some fun aspects of typical lisp development.
Lisp (any dialect) and Haskell are very different. Comparing them does not make much sense. Install an implementation and solve some interesting problem (try not to write Haskell in Lisp when doing so). Does it work for you? good. It doesn't? well, at least you probably learned something in the process and hopefully got some work done. What implementation? For someone with Haskell experience, Clojure seems a fine choice. What makes Lisp elegant? that's a very hard question to answer. Let's take Haskell. You find purity appealing yet I despise it. You enjoy its syntax, yet my head hurts trying to decipher all those operators ($, !!, etc...). You like lazy evaluation, yet I prefer predictable, easy to reason, eager evaluation. This is not a rant against Haskell, different people different choices. Use what works for you.
It is worth to learn both. It always helps to know many languages. Even if you end up not using Lisp much, it will still improve you programming in general. **Less talk more code!** But I want to add my own personal experience nevertheless: I am currently forced to learn Haskell. On first look, it looked lovely and like an Lisp with fancy syntax. On the second look, it is is **very** different. Common Lisp is a pragmatic multi-paradigmen language that is used to solve real world problem, while Haskell (which is surely a useful language) seems to have more emphasis on "purity" and looking good. It starts with little things like recursion. Yes recursion is cool but why the fuck cant I have the usual loop constructs? Static typing is more a hassle than it is worth it in my opinion. Most of the time I am more struggling against the compiler than it actually being helpful. Yes the syntax looks nice but you pay a price for this niceness. There are pitfalls here and there. Is it really worth it? For a pure functional programming language, Haskell sure looks nice but I wouldnt use it in my free time. It just feel too constricting .
&gt;you can use normal function in Haskell. We can too, through lazy libs :)
&gt;What implementation? For someone with Haskell experience, Clojure seems a fine choice. I'd say Shen
Lisp is easy. When I program in lisp , the syntax does not come in my way. I am thinking only about the problem domain. That reason alone should be convincing for anyone to switch to Lisp.
Shen (or even Qi) would probably be ok too, but there is less documentation, tool support and people using them, which makes it hard to recommend them for a first practical take on lisp.
&gt; It starts with little things like recursion. Yes recursion is cool but why the fuck cant I have the usual loop constructs? You can. There are tons of different loops available in the standard library. In factc explicit recursion is usually considered un-Haskell-y. &gt; Static typing is more a hassle than it is worth it in my opinion. Most of the time I am more struggling against the compiler than it actually being helpful. The compiler only complains when your program is broken. Why is it better to get these errors when you try to run the program instead? ---- I don't intend to start a war here, it just seems to me these two allegations are based on a lack of experience rather than actual problems.
&gt;You can. There are tons of different loops available in the standard library. In factc explicit recursion is usually considered un-Haskell-y. I have been told otherwise but college folk tends to be retarded. Can you point to a good tutorial? http://learnyouahaskell.com/recursion says &gt; That's why there are no while loops or for loops in Haskell and instead we many times have to use recursion to declare what something is. Second point: &gt;The compiler only complains when your program is broken. Why is it better to get these errors when you try to run the program instead? Now this is a delicate question. Some of these errors wouldn’t even exist in a dynamic language. And even if there is some mistake, i still prefer to run my program and inspect it at runt-time. 
I don't think saying "the compiler only complains when your program is broken" is quite fair. For example compare implementing something like printf in Lisp and in Haskell. It certainly is possible in Haskell, but using clever type class tricks. But the straightforward way to write it in Lisp could be transcribed in Haskell and would not compile, giving an example of non-broken code that the compiler won't let you get away with.
Direct recursion in Haskell is a bit like `goto` in C -- it can be used but in general it's considered better form to use a more restricted form of recursion, because it's easier to reason about. Of course any restricted form of recursion can be expressed as direct recursion just as any loop construct in an imperative language can be expressed with `goto`, but if you have experience with procedural languages like C you'll probably agree that `goto` should be used sparingly. So to address your specific question, first ask yourself what you want to do with your loop. If you want to iterate over a list of elements to produce some other generic type, use a fold. There are several: `foldr` is used more in Haskell than in other functional languages because of laziness. There's also the left fold (you should probably use `foldl'` rather than `foldl`, again because of laziness, but there are exceptions). In a monadic context there is `foldM`, which is a left fold. I'm not sure if there's a monadic right fold built into the standard prelude but one certainly exists elsewhere. Now, some folds are special and deserve their own names: if you're intending to produce a list of things having the same cardinality as your input list with a one-to-one correspondence between input elements and output elements, you'll want a map. `map`, `mapM`, and `forM` are examples of these, with the latter two being monadic versions of `map` with the arguments ordered differently. Sometimes you want to loop to produce a list from a seed: in this case you'll want an unfold, which repeatedly calls a provided function argument until it returns a termination value, accumulating the non-termination values in a list. There are many others but these basic ones should get you started I think.
i think if anything can be said to be utterly free of the need for side-effects, it is the universe!
&gt; i think if anything can be said to be utterly free of the need for side-effects, it is the universe! Well said. I completely agree. Thank you for sharing your comment.
Honestly I think that the real difference between the two communities can be summarized by typing. Lisp is (ultimately) derived from the untyped lambda calculus, which is an elegant model for computation. Haskell is (ultimately) derived from a typed lambda calculus, which is also an elegant model for computation, but, and this is the key thing -- thanks to the Curry-Howard isomorphism one can establish a correspondence between certain logics and the typed lambda terms. This is a huge part of what motivates Haskell-style: the proofs-as-programs concept.
 (if (equal (language-preference you) 'haskell) (code-in 'haskell))) Seems a little specific. What if we remove the branch? (code-in (language-preference you))
Sounds like this is why Lisp is easier for me to grok. I'm a language mucker-about.
That is true. There is an overlap between programs one might want to write and programs that aren't well-typed. I do, however, believe that this overlap can be made quite small without sacrificing anything important. I commonly collaborate with a Python guy, and we've had this argument quite a lot. Very often, he relied on functions being able to return different types depending on what happened, or heterogenous lists, or a bunch of other things that "require" dynamic typing. While discussing this, we have both come to realise that there are ways to model most of those use cases with static typing, in a way that's more safe and easy to reason about. We have both agreed that things you only know during runtime are not as reliable as things you can determine statically. (And as a bonus, he's stopped writing "dynamic" Python code to the extent that's possible, and he now prefers homogeneous lists and functions returning values of a known type.) I think the problem might occur when inexperienced people are trying to shoehorn a Python program into GHC, which of course doesn't go very well.
If Haskell uses more parentheses, I might start coding with it. Or when Haskell start to use the same syntax as its list has. Actually I am interested in it. I read some documents explaining TH. They say the factorial definition like this: fact 0 = 1 fact n = n * fact (n - 1) has a AST like this: [FunD (mkName "fact") [Clause [LitP (IntegerL 0)] (NormalB (LitE (IntegerL 1))) [] ,Clause [VarP $ mkName "n"] (NormalB (InfixE (Just (VarE $ mkName "n")) (VarE '(*)) (Just (AppE (VarE $ mkName "fact") (InfixE (Just (VarE $ mkName "n")) (VarE '(-)) (Just (LitE (IntegerL 1)))))))) [] ]] and not something one can easily find it equivalent to: (progn (setf (pattern f '(0)) 1) (setf (pattern f '(n)) '(n * fact (n - 1))) * I heard that Haskell doesn't have symbols in compile time. I thought it caused (VarE $ mkName "fact") to appear. * [] and () appears at the same time * the types are inserted into AST. However in fact, type declaration has nothing to do with AST doesn't it? AST is just a structure, not a function. I don't care which parens they use. It may be {} or [] or even &lt;&gt; but it must be consistent. If haskell use [] for list syntax, then write always with [] in order to indicate the syntactical structure, not with the mixture of tab or | or = . By the way, the largest difference between lispers and haskellers I think is this: lispers think with AST. Haskellers, with Haskell.
&gt; And even if there is some mistake, i still prefer to run my program and inspect it at runt-time. Why? To my mind, the rational thing seems to be to get all errors up-front, instead of having to search for them and potentially miss a few. Could you give a good reason as to why you prefer to probe your program for type errors manually with the possibility of missing some?
You can use sequences for that.
&gt; For example, you can in place substitute "+" with a long code that contacts a web service and in the end, after 100 lines of code, returns "+". This 100 line function is made of forms made of forms made of forms and each can be replaced by the code that you might need. It's the beauty of the conciseness of the ternary operator in other language (a = b? 1 : 2) taken to a possibly infinite extreme. Technically, you can not generally do such substitutions in Lisp. Ironically, it's because Lisp doesn't have controlled side effects. This entire line of reasoning resonates more with the Haskell side of my brain than with the Lisp side, since Haskell programs are basically evaluated with recursive substitution, due to lazy evaluation. Besides, as long as your functions are pure, you can freely inline the calls without changing anything. This can not be said of Lisp. Case in point: (defun (do-arith) (let ((op (read-op))) (progn (format t "Using operator ~S!~%" op) op))) (let ((op (do-arith))) (funcall op 1 2)) ^(I'm sorry if I butchered the code a little, it was a long time since I did CL.) Since `do-arith` has (in this case trivial) side effects, it cannot reliably be substituted, yet it would be possible (and wrong!) to do so in Lisp. Haskell simply prevents you (with the type system) from substituting this, and everything you can substitute is safe to substitute.
Haskell's language boils down to something about as simple as a primitive Lisp, actually.
&gt; I think I would miss the static type system and algebraic data types very much, further I like Haskell’s purity and lazy evaluation It sounds like you're heavily invested in the Haskell mindset, and that anything else will feel inferior to you. So I'd suggest you learn Lisp purely as a way of reminding yourself that There's More Than One Way To Do It :-) But here's a fun exercise, anyway: work through Paul Graham's book [On Lisp](http://www.paulgraham.com/onlisp.html) translating the sample code to Haskell. When I tried this a few years ago, I found that the code samples from the early chapters became shorter and arguably clearer when translated to Haskell, but that the translation quickly became more difficult and unwieldy, and that by the middle of chapter 3 it was often impossible (for me, at least) to translate the Lisp code into a finite Haskell program. That's probably not the case any more, as Template Haskell's had a lot of work done on it since, but I expect the translations will still be awkward and lengthy.
I think that's the key. Almost everything in lisp can be built up or deconstructed down to a handful of simple primitives using s-expressions. And since lisp programs are also lists, you can write expressions that modify other expressions.
One point of necessary clarification in this discussion is whether you're talking about lisp as a language family (and what that means) vs, lisp as a language implementation ala common lisp. 
&gt; I was thrilled in the moment when I realized that all of the three parts of this banal form can be an arbitrarily complex forms themselves. This is also the case in Haskell, as well as most other expression-oriented functional languages. &gt; At its core everything in Lisp is just like this: &gt;(FUNCTION argument1 argument2 …) This is very similar to Haskell: Function application syntax is just: function arg1 arg2 argn and you can wrap parens around this if you'd like (although it's un-idiomatic). The only real difference is that most Lisps allow varargs, whereas Haskell doesn't. Admittedly, Haskell does have more syntax than Lisp does.
&gt; My favorite thing about lisp is that I can really understand the core of the language, keep it in my head, and like many others who worked through the wizard book, have written a rudimentary implementation. I'm not as versed in Haskell, sometimes I feel like it is a mysterious black box. Haskell, too, has a very simple core. In particular, GHC desugars code to System FC, an extension of the [polymorphic lambda calculus](https://en.wikipedia.org/wiki/System_F). Funnily enough, it's called [Core](http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType), in GHC. Writing a lazy lambda calculus interpreter isn't all that difficult, either. [Here's one](http://hackage.haskell.org/packages/archive/TinyLaunchbury/1.0.1/doc/html/src/TinyLaunchbury.html#Expr). Although it ignores the type system, it has let statements, primitive function, ADTs and case statements.
&gt; It is safe to substitute from a type system point of view, not from a semantic point of view. By substitute, it seems kqr means inline. i.e. substituting the actual argument for the variable. This is safe in Haskell (and is essentially what call-by-need is a memoized form *of*), but isn't safe in Lisp. In Lisp, you need to evaluate an argument (at runtime) before you can substitute it in (or 'substitute' it by putting it in a gensymed let-bound variable). This is because evaluating things can have random side effects. This is not a minor quibble. If you can pervasively inline, and if functions generally have no side effects, a host of optimizations become possible. See, for example, [rewrite rules](http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/rewrite-rules.html), and the assorted optimizations (e.g. list or stream fusion) implemented with them. Many of them are not legal in Lisp. For example, consider map f (map g xs) = map (f.g) xs If either f or g has side effects, then you're reordering them, which is wrong in general.
You call stuff like map and fold recursion? They fall more under declarative programming for me. But yes they are very useful. Most of them have similar counterparts in Common Lisp. But thanks for the response anyway. The problem is that I sometimes want to make the flow actually obvious. Looking at Haskell Code, I often find myself don’t having a clue when and where something is being computed. Some problems are much easier to describe with good old while and for loops. It seems to me that many Haskell programmer love functional programming. This is as bad, as falling in love with any other programming paradigm. It keeps one from making pragmatic choices. 
I cant remember ever having a typing error in a dynamic language that was hard to find and to fix. From my own feeling, most errors static typing catches are the ones that are created through the added complexity of static typing itself. Also i find myself in static languages more trying to get it compiling than actually running and testing. This can be bad, as the interesting bugs are mostly the ones happening at run-time. Yes i think the higher need for testing in dynamic languages is a good thing. What I wrote is quite subjective but I have never seen any study proving that static-typing has any worth. I think it is the job of the ones promoting static typing to provide prove.
even with that, you can separate types and structure in AST. I mean, like this (pseudocode): (typelet ((1 (Just (LitE (IntegerL)))) (n (InfixE (Just))) etc... ) (setf (pattern f '(n)) '(n * fact (n - 1))) the structure of the program is easy to read in this case, by removing the type declaration from AST and binding it to a symbol in another part of the code.
You forgot about `data`, `type`, `let...in`, list sugar, `do` notation, `if...then...else`, `case...of`, `where`, and a lot of other syntax Haskell has and Lisp doesn't. Haskell syntax is fairly small, which is a good thing, but it is no match for Lisp.
Some people have called Lisp a "high level assembly" so your parallel is not far fetched.
&gt; You call stuff like map and fold recursion? No, but that's the point. Haskell people dislike explicit recursion since it may be unclear what is meant and it requires more code than necessary. `map` and `fold` are however specialised kinds of loops, so when you have them, you rarely need `for` loops or explicit recursion. As said, though, there *are* `for` loops in Haskell (`forM` in particular behaves a lot like normal `for` loops in the context of side effects) which are great when you actually need them. &gt; Most of them have similar counterparts in Common Lisp. Isn't it common in Lisp to use those counterparts rather than loops with indexes and stuff? &gt; The problem is that I sometimes want to make the flow actually obvious. Looking at Haskell Code, I often find myself don’t having a clue when and where something is being computed. Some problems are much easier to describe with good old while and for loops. This is typical for someone used to imperative programming. Imperative programmers are used to writing code for a stateful machine, so they think programming is a lot about "pretending to be the computer" and executing statements in your head to find out what the final result should be. That's not how declarative programming works. At least not to the same extent. Declarative programming is more like writing Bash oneliners. You go from data structured one way to data structured another, one step at a time. &gt; It seems to me that many Haskell programmer love functional programming. This is as bad, as falling in love with any other programming paradigm. It keeps one from making pragmatic choices. I do agree. I also do think every programmer has a preference for one or a few paradigms, despite how it limits them from making pragmatic choices (as an example, I can say with reasonable confidence that you have a preference for paradigms which are not purely functional programming or logic programming.) I also think this is an evil necessity, since it's not possible to keep everything in your head at the same time, and civilisation is what it is because we allow people to specialise. As a declarative programmer, I know I should not make decisions about low-level code since that's not exactly my field of expertise, and whatever decision I make will not be pragmatic. Similarly, I am eager to help low-level people out with making decisions about high-level code.