https://github.com/guicho271828/trivia
Lispm, You have broad knowledge of Lisp. I will be very happy if I can read your blog about the history of Lisp, what is lisp from your view, and things about Lisp that we rarely know. Thank you so much.
Lisp is now, not in the past.
Someone should probably write to the FSF about their opinion on the LGPL and the LLGPL. They wrote something about using [the LGPL with Java](https://www.gnu.org/licenses/lgpl-java.html) a while back, which includes the phrase: &gt; the LGPL works as intended with all known programming languages In particular, would the LGPL require each library published under that license to be in its own compiled file (e.g. a FASL) like with the Java JAR example in the Java article? I think generating one binary file that includes everything is what the Lisp game community wants.
http://www.r6rs.org/final/html/r6rs-app/r6rs-app-Z-H-5.html
Ha! I was good no to suggest Optima, but you beat me to it!
[removed]
Ok so the square brackets are in the scheme spec but not braces. What about CL?
I'm crazy, not dangerous. This list make me laugh, thanks!
Lisp is technically a Leatherman. It will do anything but only when you really need it to.
Might want to take that back on Rust. New Firefox is really promising.
What's a shiv?
 (set-macro-character #\{ (lambda (s i) (read-delimited-list #\} s T))) (set-macro-character #\} (lambda (s i) (error "Unmatched }."))) (set-macro-character #\[ (lambda (s i) (read-delimited-list #\] s T))) (set-macro-character #\] (lambda (s i) (error "Unmatched ]."))) Now you can.
Well that was easy.
Thank you for the “higher level” opening!
An improvised weapon made &amp; used by prisoners. 
It looks very promising, especially as I am used to matching coming from OCaml. Thanks!
x-post https://www.reddit.com/r/programming/comments/7fjk5e/a_new_programming_language_carp/ with a blog post: http://blog.veitheller.de/Carp.html
I had a 20MB hard disk. Woohoo! Coral Common Lisp completely ate my brain. It made it easy to write GUI apps using the full Mac Toolbox, and deliver them as standalone apps. I used it for all kinds of experimentation, and through it got to know the Toolbox pretty well (handy, since I was working at Apple at the time, first as a tech writer and then later as a Mac programmer). That Lisp remained important in my work for most of the decade that I spent at Apple.
i didn't think much about it—I suppose because I'm familiar with git repos, github prints markdown files well, and github stars makes it easy to spread through github's social network. It also fits my workflow—I like writing in markdown inside my editor and committing from the command line, and I'm not sure how to do that with a wiki. Using a github repo also made it easy to re-host the large amounts of publications I referenced, to protect against dead links. Github has a nice thing called [git-lfs](https://git-lfs.github.com/) to host any amount of large files in your repo for free. Also, I have some code I want to put in there eventually for the animations I created to present this research: https://www.youtube.com/watch?v=K0Tsa3smr1w
agreed, that's actually why I called them 'artifacts'. it's the unfortunate lens that we have to view and experience it through, and I was interested in all the ways we have tried grappling with that.
I was really happy when I saw the title. I am really unhappy after seeing the code. I was thinking of language like this(well, maybe with GC) for a long time. Now it exists! Unfortunately, not... There are many design decisions that I don't like, and I surely won't use this language. (1) Dot notation? Really? I have to use (String.copy "somestring"). This is so bad. If there is a copy method, why do I have to explicitly state the Type's name too? Even C++ got that better, with polymorphism you'd just call (lispified): (.copy obj) (2) (minor) lack of commonly used macros. Even at the example, we can see 5 (use) forms at top, more below. Why not just implement (use-n ...)? This is why CL has alexandria; many simple macros or functions weren't implemented there, so we need that. (3) Ugly &amp; and @ syntax that clutters the code. (4) Modules are created using (defmodule), limiting modules to single file per module. (5) The blog posts mentions that you can't use REPL in a useful way; it would just spit out the code(what?). (haven't tested the language myself) This language looks like a wrapper over C++ (I know it's in Haskell). It's ugly. I also fail to see where I'd want to use it. Its complexity and lack of libraries is a big no-go for me. If I want to write fast enough code in Lisp, I have CL with SBCL, which is really fast. If I want even faster, I'll write some modules in C and either link them to CL using cffi or just write rest of the program in C as well.
The interesting discovery was that having parenthesis, code as data and s-expressions turned out to be immensely useful and not 'unfortunate' at all. 
If you use Emacs (I think many Lisp programmers do), then you can write in [Org Mode](http://orgmode.org/) and export to markdown. I've done that, and it works pretty well for the most part. Org Mode has a built-in exporter for HTML, but there should also be an Org module for exporting to wiki markup. I've never done that before, but [some searching](https://emacs.stackexchange.com/questions/15079/in-org-mode-how-do-i-export-to-jira-wiki-markup) suggests one or more such exporters do exist. Thanks for the informative reply. 
20MB? You must have been wealthy! Coral sounds familiar. Didn't they have their own word processor and paint programs?
I think you'd have to credit C++ for Firefox quantum. I was under the impression that only a very small amount is implemented in Rust. Sort of like linux is mostly implemented in C but has a few other languages used too.
(5) is just so bad: the REPL that couldn't. A LISP isn't just macros and parenthesis; there's a reason why we refer to implementations as "_a_ LISP". Access to mutation of the run time environment is a core component of LISP's power.
(5) is just so bad: the REPL that couldn't. A LISP isn't just macros and parenthesis; there's a reason why we refer to implementations as "a LISP". Access to mutation of the run time environment is a core component of LISP's power. 
I do find it interesting how accidental it all was (reading through History of Lisp 1979), and how they had an immediate sense that it wasn't something people would like on its surface, which still holds true today. Even further back, algebraic notation patterns have been around for hundreds of years. And even recently with Polish notation in the 30s, it sought to remove parentheses by avoiding infix altogether. Shortly after, Lambda calculus function application notation had explicit parentheses, but a shorthand was established to avoid parentheses by presuming left-associativity. Parentheses have long been culturally considered clutter when seen in large amounts. The ability to look past parentheses in Lisp allows you to see the elegance of what it truly represents, but I do find it unfortunate from a _design_ perspective when the presentation of a thing doesn't work in concert with cultural expectations enough to become popular. That is the unfortunate thing that I think people are trying to solve here. I find a lot of those 'fruitless' efforts to be very interesting and important to catalog. In a very large context, it's tempting to just point to culture and call it broken. And I really think a majority of people have a sense that this is true. But one of the core things that divides people is how to approach human nature to change culture. It's rather empowering to think that human nature must not be catered to, but rather pounded into submission of whatever logical thing that will better us. I think this is perhaps why software developers often just hate people, because it's frustrating to not be able to apply a logical process to our own squishy temperaments. I find that designers have a more different relationship with people—they still have that hatred, but when trying to change someone, they actually are better equipped to work in concert with human nature rather than against it. But designers are still thinking logically by just treating human nature as a pre-existing condition to be dealt with. I'm trying to take all this into account when doing research and building usability tools like Parinfer, because I think parentheses are 'unfortunate' despite it being the core of Lisp.
&gt; they had an immediate sense that it wasn't something people would like on its surface But they were immediately sensing that it was something pure and something extremely useful. A new paradigm. Lisp was a revolution in programming. A big bang. Nothing like that existed before. Recursive functional programming, an interpreter in the language itself in a few lines, programs as data, data as programs, garbage collection, managed memory, restartable images, list processing applied to itself, ... &gt; human nature I think this is misleading. It is about culture, not nature. There are a few assumptions people usually have and one is that Lisp is hold back by its parentheses and its a reason why it is not more popular. I think that's not true. Lisp is not popular, because it is in the end more complicated because it supports code as data, which makes a new meta-level accessible. If we remove this code as data, we get something like an untyped ML (-&gt; https://en.wikipedia.org/wiki/ML_(programming_language) ), which then uses and enables Functional Programming as a paradigm. You seem to come from the angle that Lisp is a programming language and that it would be helpful and useful when it would look like other programming languages you know of. It then would also be useful when BEHAVES like other programming languages you know of. But then you lose the nature of Lisp. I come from a different angle. I see lists as the fundamental paradigm. I want to write lists. I want to process lists. I want to write processes as lists. I want to process list processes. I want a list processor. I want list processing applied to itself. My mental model is the list evaluator. For me a program is not text which has the usual programming syntax, but a recursive process written down as recursive lists. (berlin amsterdam copenhagen hamburg luebeck) is one way to write a list. There are many others, but this is one and it has attractive properties: its start and end is explicit. Its boundaries to the surroundings is clear. Its elements are recognizable. We can write it in different 1d or 2d shapes, without the need for more complex reconstruction. We can find a simple internal representation and we can define simple transformations between internal and external representations. We can easily use lists to represent hierarchical information. We can then define list processing functions and write those as the same hierarchical lists. We then can define an EVAL procedure which computes values based on a relatively simple computational model applied to programs as lists. I don't think: Lisp is hold back by parentheses. My view: Lisp survives because it is different and it is based on a different fundamental paradigm: symbolic computation. Lisp is a different point of view, a different way to think about programming. 
**ML (programming language)** ML ('Meta Language') is a general-purpose functional programming language. It has roots in Lisp, and has been characterized as "Lisp with types". It is known for its use of the polymorphic Hindley–Milner type system, which automatically assigns the types of most expressions without requiring explicit type annotations, and ensures type safety – there is a formal proof that a well-typed ML program does not cause runtime type errors. ML provides pattern matching for function arguments, garbage collection, imperative programming, call-by-value and currying. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Prison knife.
Thank you, I understand your position now—Lisp being too fundamentally different from popular programming to have any meaningful UX to bridge the gap. I made Parinfer to allow Lisp to keep its syntax. I'm not actually trying to remove parentheses because I understand its strength is core to Lisp's ideas. I'm just researching different angles people have taken over the years to see if that UX bridge is in fact impossible.
Why only when you really need it to?
&gt; Lisp being too fundamentally different from popular programming to have any meaningful UX to bridge the gap. I think the 'popularity' wish leads mostly nowhere. I started Lisp programming in the mid 80s (after learning Assembler, Basic, Pascal, Modula-2, ...) and I have seen it slightly more 'popular' then, compared to what it is now. I was at a University with a dozen professors extremely good in Lisp (programming in it, writing books, implementing it, ...) and with lots of Lisp projects around and lots of use of Lisp in computer science education. Basically each computer science student generation learned Lisp in the first two semesters. But today is very different from the 80s. &gt; I'm just researching different angles people have taken over the years to see if that UX bridge is in fact impossible. Sure, why not. But keep in mind that many of these tools were not developed with that 'UX bridge' in mind. Stuff like Interlisp-D is hardcore non-compromising Lisp (managed Lisp code, Lisp interpreter, structure editor, ...), though influenced by stuff like the Smalltalk GUI and IDE, and AI programming (see for example LOOPS).
The RELP is the deal breaker for me, but Carp is new and experimental, so I keep watching, waiting for the REPL to change. Probably a debugger too. And package manager. I don't know. I was excited about Rust, so I just want something good to happen.
I'd call Lisp a light saber: * Looks different and is used differently by each wielder * Cuts through almost anything * Doesn't scale well - consider an army with light sabers versus one guy with a machine gun 
I hate how people pretend C is easy, simple, and reliable. It's really not. It's a shitty language, artifact of a past that I wish won't come back. 
They reimplemented the css engine in Rust, which is a good deal of code.
C's fairly easy to learn. At least, it's about as easy to learn most other things out there (except things like Scratch or Ruby). It is also objectively simpler than a lot of other popular languages. As far as reliability goes, I guess it depends on what you're relying on C for. It is true that many (most?) pieces of software that we regularly rely upon are written in C. &gt; artifact of a past Many good things are from the past. In fact, many "novel" or "good" ideas in software development of the present draw on ideas from the past.
Recently I was browsing the LISP 1 documentation, and it was clear that at that time they still didn't intend to use the syntax they actually ended up using. For each feature, the documentation starts out describing how it works using maths, and then describes what it looks like like in Lisp using M-expressions. Then they move on to describe the same thing using traditional Sexp (elements delimited using comma, and whitespace being significant), and finally showing the actual code, which looks the way you're used to. It's really interesting how they go through 4 different syntaxes before they get to the notation that the developer actually has to use. If that is isn't proof that the Sexp syntax was accidental, I don't know what would be. 
We have improved a lot since C was created, and it simply cannot express many things that are objectively useful for its domain, like ownership or type-safe tagged unions. 
You might be interested in [Ferret](https://nakkaya.com/2011/06/29/ferret-an-experimental-clojure-compiler/), it's a long the same lines.
&gt; Are you saying you don't want to follow the conditions of the licenses? Of course I want to follow the conditions of the licenses (including and not limited to actually *not using* software which license collides with my goals). The problem is that the interaction of various licenses in CL world seems unclear when it comes to *binary distributions* 
What's the benefit of doing that (exporting .org to Markdown manually), vs. using the built-in .org rendering capability in Github?
&gt; Doesn't scale well - consider an army with light sabers versus one guy with a machine gun Or, consider that army trying to run close together, or through a tight spot...
&gt; If that is isn't proof that the Sexp syntax was accidental, I don't know what would be. The s-expression syntax was not accidental, what was accidental was the use of s-expression syntax to represent programs for input and output. They used it during development of the Lisp system and it turned out to be useful. Even though it was tried to have different syntax variants, the s-expression version was still the most implemented and in the end it was by far the best supported in implementations.
&gt; Lisp is now. Absolutely, everytime I boot up my computer and head to [SO Common Lisp](https://stackoverflow.com/questions/tagged/common-lisp) every question answered not least than hour, and good every question reached 1.2k views. 
If are using Racket runtime, I don't think you have to choose. Racket runtime supports Scheme, so you can use the best tool for the job at hand.
You get to write everything in Emacs where you can take advantage of all its capabilities. Emacs users want that. It's also nice to have only one markup syntax (Org) to remember. This could be accomplished with [pandoc](http://pandoc.org/), which also supports Org on top of everything else. If you don't want to use Emacs, maybe look into that.
Scheme is a subset of Racket. The only reason to use a scheme implementation rather than racket would be the usual: if it's smaller, faster, etc, and you don't need the additional features of Racket. Here's something you might find interesting: https://stackoverflow.com/questions/45426679/chez-scheme-benchmarks
I think you missed the point: Github understands org-mode! So you can skip exporting to .md and use .org files directly.
I asked a question about why someone does what they do. I answered a question about why I do what I do. I didn't try to convert anyone to the Church of Emacs. You don't have to convert me to the Church of Github.
Hello, - 404 on http://www.warflagger.org/documentation/ after I completed registration with github, but I'm signed in. - reddit Oauth failed (bad request or so) the following is mainly about UI and UX. - Introduction: I'd appreciate a bigger font and more visual stuff in the text (some keywords in bold,…) - looking at a target (http://warflagger.net/target/7?), it wasn't obvious we have to highlight some highlighted text to see comments. - clicking on "reply": the text box is not resizable, but can have the full text. Are we supposed to copy text excerpts into some little String inputs ? the whole thing makes me think "I have thought about this system already but never even started to imagine how to do it". reminds me of http://www.co-ment.com
May as well link to the ecraven one directly, since it now has Racket: https://ecraven.github.io/r7rs-benchmarks/index.html
Use Racket if what you're looking for is a batteries-included development platform in the same tradition as CPAN, PIP, Gems, et al. It's a reasonably great general solution to all problems. Use Chibi if what you're looking for is a small R7RS-compliant Scheme to embed in a larger project. Use Guile if you want to do that, but want access to more packages and don't mind using LGPL'd software. Use Chicken if what you're looking for is a eminently hackable runtime environment with strong C interoperation and a reasonable collection of packages. Use Gambit if what you're looking for is something faster than Chicken and don't mind writing everything from scratch. Use Chez if being the fastest and R6RS compliance are things that really, truly matter to you.
Thanks
&gt; Use Gambit if what you're looking for is something faster than Chicken and don't mind writing everything from scratch. "Everything"?
Even Gambit itself! It's hyperbole to make a point: you'll find yourself writing more custom code when choosing Gambit because the extension ecosystem is relatively small; albeit with [one large exception](http://www.lambdanative.org/).
Also, there are lots of things you can **just do in C++ itself** to make the language more ergonomic for yourself. &gt; *I'll write some modules in C and either link them to CL using cffi or just write rest of the program in C as well.* Amen to that. If you **can** write the whole thing comfortably in a language like this, it must be that the requirements for what you are doing are Blub requirements.
Good thing the artist reveals his dim wit in the first two boxes so we can skip the rest. How can C++ be nunchaku, yet C be a rifle, given that inside C++ there is a complete C dialect that implements all C90 features either exactly or very closely?
The instruction set of Brain**** is also easy to learn.
Just read to the end, that's the relevant box.
Really nice seeing this progress. What browser is this based on? What JS vm are you using? Also you have a great project going on here with its own identity, have you considered changing the name and moving away from the franken-NeXT-Apple logo?
Hi! Thank you for the kind words and your help yesterday!! It is based on Webkit. In terms of names I have thought about it for a long long time, and I eventually settled on nEXT-Browser. I am open to suggestions though!
From what I've seen it already looks promising. Can't wait for the linux release!
Thank you for the kind words!
The first two boxes lay to rest most of the suspicion that the cartoonist is an ignorant ass; the last only confirms it beyond all doubt.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/emacs] [nEXT Browser Version 0.05!](https://www.reddit.com/r/emacs/comments/7fz9t2/next_browser_version_005/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Already looks usable, thanks for the effort!
Since you asked, here are my two cents about the name: The project looks great but, I think the capitalization is a little much. Reminds me of NeXT. Is the 'EXT' because it's extensible? In any case, I think just "Next" would be better. I don't think "Browser" needs to be in the name. Just "Next" or "next". Simple.
Almost the most important quality a name can have nowadays is to be easil googleable. "next" is not, I'm afraid.
I agree, Netscape, Opera, Firefox, Chrome is all googlable. Maybe Edge and IE. Since you feature the tree-based history, what about a name based on a tree? Maybe some tree also related to history?
Any plans to allow the user to limit what web resources get loaded when visiting a web location? I like the concept, but (similarly to Qutebrowser) I would not yet use this to browse the Internet, simply because it completely ignores the tracking issues with the vast majority of today's websites. For reference, I use [uMatrix in Firefox](https://addons.mozilla.org/en-US/firefox/addon/umatrix/) to achieve what I'm talking about (my only gripe with it being that it is mouse-controlled).
nEXT browser rock! Thank you for your contribution to community.
Thank you for the kind words!!
Hi! Thank you for your feedback, it is definitely something I considered. What about something like n-ext to separate the extensibility, but avoid the capitalization issues? What do you think?
No problem! :) Thanks for the support!
Hi yes! Absolutely an important feature and it is on the roadmap. This will be a little bit different than plugins in that the restriction of loading will be done way way before the assets are even requested. I'll be able to implement this in the resource handler (or whatever it is called) that actually loads URLs. I just need to come up with a simple, consistent way to allow people to hook into this mechanism and regulate the content they wish to load/not load.
Glad to hear it! I am looking forward to what you can come up with in this regard, especially in regard to the UI/UX part (I assume you want to go the keyboard-only route, of which I approve). &gt; This will be a little bit different than plugins in that the restriction of loading will be done way way before the assets are even requested. From what I understand, in uMatrix assets are not even requested unless a rule is met that would specifically allow it (as it should be).
You're correct about the keyboard only part, it will actually be impossible to use the mouse for anything but clicking on links. If you look at my own emacs config you'll see I've disabled the mouse entirely https://github.com/jmercouris/configuration/blob/master/.emacs.d/custom.el (disable-mouse package) I don't know much about uMatrix, but if that's true, then I guess it will be on parity with that :)
Sounds great. Make sure to post to r/LISP again when you have a working implementation, I'll jump on board as soon as it is done.
Actually, there already exists a [browser named "Next Browser" for Android](https://play.google.com/store/apps/details?id=com.jiubang.browser), so an entirely different name might not be too bad of an idea.
Will do of course!
Yeah, I've seen it, honestly I'm not too worried about them in particular as we operate in entirely different markets (they are basically just in China)
I will take this chance to discuss [the license of your browser](https://github.com/nEXT-Browser/nEXT/blob/master/LICENSE). Did you write this yourself, or is it a spinoff of some existing free software license? Why not go with a [copyleft](https://www.gnu.org/copyleft/) license, such as the GNU General Public License?
I propose the [Bodhi Tree](https://en.wikipedia.org/wiki/Bodhi_Tree), under which Buddha achieved enlightenment (the word *bodhi* by itself means enlightenment or awakening). There already exists the Bodhi Linux distribution, however, which might or might not be an issue.
**Bodhi Tree** The Bodhi Tree (Sanskrit: बोधि) also known as Bo (from Sinhalese: Bo) and "peepal tree" (Devanagari: पीपल क पेड़) was a large and very old sacred fig tree (Ficus religiosa) located in Bodh Gaya, under which Siddhartha Gautama, the spiritual teacher who later became known as the Buddha, is said to have attained enlightenment (Bodhi). In religious iconography, the Bodhi Tree is recognizable by its heart-shaped leaves, which are usually prominently displayed. The term "Bodhi Tree" is also widely applied to currently existing trees, particularly the Sacred Fig (Ficus religiosa) growing at the Mahabodhi Temple in Bodh Gaya, which is often cited as a direct descendant from the original specimen planted in 288 BC. This tree is a frequent destination for pilgrims, being the most important of the four main Buddhist pilgrimage sites. Other holy Bodhi trees which have a great significance in the history of Buddhism are the Anandabodhi tree in Sravasti and the Bodhi tree in Anuradhapura, Sri Lanka. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
The License is the BSD license just copy pasted, not sure why github does not recognize it Why didn’t I choose GPL? at the advice of some friends of mine who made a compelling argument. I also think there are some GPL compatibility issues if I choose to use BSD or MIT software- which I use right now If you can make a compelling argument for GPL, I would be willing to switch for newer releases
It is entirely OK to use non-GPL free software in your GPL program, should you choose this license. There would, however, be problems the other way around, e.g. when including your code in proprietary or non-copyleft software, or releasing a modified version without making available the source code -- which is kind of the whole point of copyleft. &gt; If you can make a compelling argument for GPL, I would be willing to switch for newer releases It is hard to get the point across unless you are familiar with the concept of 🄯 copyleft and software freedom in general. I am not a very good English writer, nor do I have the time or will to re-write in my own words what has already been written, so I will leave you a handful of links to articles that contain many powerful points to consider, all pointing to the *GNU Project* website: - [What is free software?](https://www.gnu.org/philosophy/free-sw.html) - [Why we must insist on free software](https://www.gnu.org/philosophy/free-software-even-more-important.html) - [Copyleft: Pragmatic Idealism](https://www.gnu.org/philosophy/pragmatic.html) - [How to choose a license for your own work](https://www.gnu.org/licenses/license-recommendations.html) - [Why Copyleft?](https://www.gnu.org/philosophy/why-copyleft.html) Relevant excerpts tangled from the above articles: &gt; “Free software” means software that respects users' freedom and community. Roughly, it means that the users have the freedom to run, copy, distribute, study, change and improve the software. &gt; Someone who uses your code in a nonfree program is trying to deny freedom to others, and if you let him do it, you're failing to defend their freedom. &gt; Releasing your code under one of the BSD licenses, or some other permissive non-copyleft license, is not doing wrong; the program is still free software, and still a contribution to our community. But it is weak, and in most cases it is not the best way to promote users' freedom to share and change software. I applaud you for creating a wonderful free-as-in-freedom LISP web browser for all of us to use, study, modify, improve and extend. I hope you will make the informed decision to adequately protect (🄯) your creation, so that these freedoms can never be legally taken away.
Personally, I interact with Lisp through a long-lived session, and when I want to do scripting-type tasks with it, I write functions to do things and call those functions interactively. It's a big advantage to have real objects, a real debugger, etc. available while doing things. When I really truly want to run something non-interactively, like from cron, I usually build a binary with buildapp and run it that way.
Common Lisp implementations are not generally used as scripting languages to be called from a shell (or similar). CCL originated from Macintosh Common Lisp, from a time when Mac OS was not a UNIX variant, second half of the 80s. It got ported to Unix systems and open sourced as OpenMCL and then renamed as Clojure CL. It's main purpose was always to write applications or as an IDE. Since it runs under Unix, it made sense to add capabilities to be able to call CCL from shell scripts, with various parameters. It still wasn't thought as a first class shell script language. CLISP ran relatively early on machines with shells and there was more interest to integrate it better into those.
Interesting. Yeah I haven't gotten to the long-lived session nirvana yet. What is your setup? Can you describe your typical workflow for scripting-type tasks in more detail?
I start emacs and run Lisp with slime or sly. If I have an idea for a task I want to do, I start a new file, define a new package for the file, and start writing code. I'll try out functions one-by-one as I write them, and build up a toolkit for working with the data and the actions of the task at hand. If it's a simple thing with no external dependencies, I'll leave the file as-is and just reload it when needed, but if it's something I expect to use often, I'll give it its own directory, write a system definition file, and reload it with ASDF whenever I want to use that functionality again.
That was a reference to the macro system, but I will admit my whole metaphor is wonky.
Sounds good but I doubt EVERYONE knows about the tree... It should be a little bit more common word
good side of clisp: it's lightweight, the interface is so-so good (as you mentioned) bad side of clisp: it's sort-of deprecated and not frequently updated. If you do the hard stuff you encounter some error. I use Roswell to switch impls mainly for performance reasons. For lightweight tasks CCL is better and for heavy loops SBCL is better. I don't try clisp often because it find it hard to maintain. I think it is ok to use it for small personal scripts, but I don't recommend it for long-term use.
This helps, thank you! Sounds like the workflow is similar to how I do Emacs customizations, e.g. build up bits that work in the `*scratch*` buffer and then copy them over to my settings file. I need to figure out ASDF next I guess.
Ah that stinks about CLisp not being actively maintained. Roswell looks interesting but again it's another wrapper program around my code which just seems weird to me.
7pm UTC happens when this comment is 1 hour and 18 minutes old. You can find the live countdown here: https://countle.com/Vn107060_p --- I'm a bot, if you want to send feedback, please comment below or send a PM.
Thanks for the feedback. &gt; clicking on "reply": the text box is not resizable, but can have the full text. Are we supposed to copy text excerpts into some little String inputs ? Once the opinion page is open, you should be able to select an excerpt with your mouse from the text box to the right of the Excerpt entry. You should also be able to select an excerpt on the target page, then click reply, but that is not implemented yet. - Reddit login should work now. - I'm currently working on adding more information to the article list, including # of opinions posted. Hopefully up by the end of the day.
CLISP could be used for a "properly deployed" application. You can use more than one Lisp implementation in the same project. I used Clozure Common Lisp (CCL) to deploy an application which runs as a background web service on Windows, with the browser used as the UI. The licensing web service, which also has a command line administrative interface, runs on CLISP. They share the same code, including libs for hashing a S-exp-ified software license and doing elliptic curve crypto on it. CCL code can generate a license; the server can sign it; CCL code can validate the sig. 
Co-ment comes close to what I'm doing. At least their source is open and conversations appear to be portable. It also has more of an emphasis on collaborative editing. Genius also comes close: https://genius.com/web-annotator What's different about WarFlagger is the moderation system. I want to build a forum that self balances without top down moderator intervention. 4chan without the ugly, perhaps (fwiw, I haven't seen 4chan.)
Actually the CLISP source repository is busy... https://sourceforge.net/p/clisp/clisp/commit_browser
you might be interested in this: [ASDF 3, or Why Lisp is Now an Acceptable Scripting Language \(Extended version\)](http://fare.tunes.org/files/asdf3/asdf3-2014.html)
Name a single historical tree that *everyone* knows about.
Yeah. I think that's better!
So do you more or less use Lisp inside Emacs as your shell then? (i'm a lisp newb and vimmer, so i have lots to learn)
Nope. I use my shell as my shell.
What about mixing different lisp dialects in the same project? Although I'm not sure if it makes sense to do such thing. Another thing I was asking myself is how is lisp mixing with other languages/frameworks for example Ruby on Rails.
I think [Yggdrasil](https://en.wikipedia.org/wiki/Yggdrasil) is getting closed thanks to to the MCU.
&gt; I need to figure out ASDF next I guess. I think the most important is to figure out using Quicklisp (which uses ASDF) and starting a project. For that there are helpers (cl-project, quick-project,…). https://lispcookbook.github.io/cl-cookbook/getting-started.html
I wrote a little about it here: http://xach.livejournal.com/278047.html
Would [newLISP](http://www.newlisp.org) be something for you? It's not Common Lisp, but a &gt; Lisp-like, general-purpose scripting language
The disk (and the Mac Plus) actually belonged to Apple. At that time they allowed employees to borrow a machine (maybe they still do; I don't know). You're probably thinking of Corel Paint; different company. Coral Software did publish two other titles, though: Object Logo and Pearl Lisp. 
&gt; Corel Paint Indeed. ⊙﹏⊙
Aha, well then, I submit: tree + browser = trouser. haha ;)
This. is. great. Thank you! :bow:
Roswell is great because it helps you to create a command line scripts. Run "ros init my-new-utility" Also, it is easy to build a binary from resulting my-new-utility.ros script. Just do "ros build my-new-utility.ros" Another great feature is ability to install such scripts from github, like: ros install 40ants/12forks
Any plans to introduce self-documentation? I love what you’ve done so far and I would love to be able to access nEXT’s documentation in-browser with something like Emacs’s C-h.
&gt; trees that survived the atomic bombing of Hiroshima should be a perfect name for a browser...
there’s definitely a plan, just so much to do :D PRs always welcome!!
Looks nice, but $29/$39 for an 80-page ebook is asbsolutely too expensive in my opinion. Unless the intended market is a business one, which in the case of Common Lisp is very tiny at best.
Does this talk about upgrading live a running image? I've always seen talks about live upgrade of classes etc, but no practical example of how we could do that.
Is it possible to select text input boxes without the mouse? can't figure that out. Also, ironically the links on reddit don't work for me at all.
That's very strange, the links work just fine for me on reddit: https://imgur.com/a/gQeJG Which version of OSX are you running? Maybe I have some issues with anything below high Sierra or something :\ Input boxes, not yet, that's coming soon hopefully. Unlike vimperator, the javascript actually returns all of the anchors to the Lisp backend, which then calls set-url of the active-buffer. The reason the link hints are implemented this way is to avoid websites that hijack the keystrokes of the end user, i.e. GitHub, google, etc from preventing the user using link hints. So in order to combat this, we need to make the function that receives the javascript in the lisp backend aware of text boxes/ other controls, and allow it to select them somehow. Sorry about the issues!
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/PHDXmK3.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) 
Thank you for your very thoughtful reply. Don't take my non-response as a sign of neglect, I've been thinking about this for the past day. I need more time to think before I can give a good answer/final decision. One other thing I would like to seek your advice on is, do you think I should require contributors to sign their work off to some org as the FSF does if I go this route?
I am running an older version of OSX, 10.12.6. That's cool, I will be watching with interest, seems like a very cool project. Any plans for a Windows port?
It's a productive and fun way to work on Emacs. The `*scratch*` buffer isn't a good place for anything you want to keep. You can customize it to prevent killing or to make it persist between sessions, but the default is kill-able and not associated with a file.
There aren't any concrete plans for a windows port, but if the GTK version of it is simple enough to port, maybe that can be maintained by the community Perhaps since you are running an older version of OSX, thusly an older version of webkit, and therefore some javascript features on reddit aren't quite working
You might be interested in [ielm](http://emacs-fu.blogspot.com/2011/03/ielm-repl-for-emacs.html) or [eshell](https://masteringemacs.org/article/complete-guide-mastering-eshell). 
Here's one I'm working on for the Quicklisp manual - it's a little different but by the end you'll have a fully working toy to play with: https://www.xach.com/tmp/quickstart.html
There's not a whole lot to it? You can just evaluate new forms in a repl on the running image, and methods like `update-instance-for-redefined-class` help patch things up if necessary.
I like the idea and topics covered and I understand wanting to charge money to compensate for your time and in improving your guide, but I would encourage you to expand the book to make the cost worth it to me. It being on Amazon would also make it easier to buy. 
cool, thanks!
Having looked at the website I came here to post the same thing. And how does it take 80 pages to explain one thing?
Welcome. I should probably mention that if you want elisp then ielm is the way to go. eshell is its own thing, and not without a sizable helping of inexplicable quirks.
&gt; Do you think I should require contributors to sign their work off to some org as the FSF does if I go this route? Hmm. This is a tought one. Also keep in mind that IANAL (I am not a lawyer). The reason the Free Software Foundation collects those so-called *copyright assignments* from contributors to official GNU projects is that is makes them able to enforce the GPL most effectively in court, should a violation of the license occur. From what I gather, this practice is mostly preventative on FSF's part, but it has successfully sued Cisco in the past, so it's not done in vain. For a better explanation consult the GNU.org article *[Why the FSF gets copyright assignments from contributors](https://www.gnu.org/licenses/why-assign.en.html)*. Taken from there: &gt; If there are multiple authors of a copyrighted work, successful enforcement depends on having the cooperation of all authors. So I guess the bottomline is: To be able to most effectively protect a possible future violation of your browser's license in court, you should either make sure that your major contributors are willing to cooperate if it comes to a license breach that you choose to sue over, or to preemptitively collect copyright assignments from them in order to be ready for such a scenario. With that said, however, I doubt that there could come about anyone with the backbone to take your creation and repackage it in conflict with the GPL. The only case I know about (the Cisco one) was about coreutils and some other libraries that Cisco used to create a product of their own, using GNU's work as building blocks. You are developing a full user application and not a general-purpose C library, which would take a full-out plagiator to take it and try to pass it off as their own creation. I am not aware of such a case in the history of free software, so perhaps you don't need to worry about it.
To be fair, the [TOC pdf](https://www.darkchestnut.com/img/common-lisp-in-the-wild_rev1_toc.pdf) is there (you need to click it).
Only if you use -static. Otherwise, it's just to stage.
I thought I saw a comment here earlier suggesting newLISP, but it appears to be gone now. Is newLISP not good for scripting?
&gt;Use Guile if you want to do that, but want access to more packages and don't mind using LGPL'd software. Why would anyone mind that? 
Not everyone has the _privilege_ of being able to use copyleft software; some of us have to work for a living, and that almost _always_ means a lawyer has put a stop to using anything copyleft.
Well, the LGPL is not really copyleft and rejecting would be silly and lock your company out of libraries like GTK+ and Qt. Have you asked your law department to reconsider their decision?
Of course I've tried, at multiple companies. Requiring that source be shared for any component we ship to a customer means it's a non-starter, usually. Worse still is the existence of patent grants, in some licenses. Completely untenable. GTK+ and Qt have locked themselves out; there are plenty of options, many superior, which do not require source to be shared.
Ooo how exciting!
Ah! Thank you.
You might want to take a look at [this blog post](http://malisper.me/debugging-lisp-part-3-redefining-classes/), it is part of an excelent series of blog showing how to debug Common Lisp programs. It also has some references to other materials to check.
PDFs cannot be sold on amazon, though. And kindle is a rather horrible format for anything but fiction.
And there is a [sample chapter](https://www.darkchestnut.com/img/common-lisp-in-the-wild_rev2_sample-chapter.pdf).
It's just that evaluating forms in the REPL is not really what I call "deployment with confidence" :-) so I was looking for maybe best practices or common patterns of how this is done. I guess I can wrap up a small function to re-load lisp files at a specific location, but... yeah.
TXR is a language built around a Lisp dialect, geared toward scripting. It has more comprehensive support for "hash bang" than probably anything else. Find anagrams in the dictionary file: [(opip (file-get-lines "/usr/share/dict/words") (group-by (opip copy sort) @1 :equal-based) hash-values (keep-if cdr) prinl)] $ txr ana2.tl | head -5 (("cognition's" "incognito's") ("kiwi" "wiki") ("gilding" "gliding") ("infidel" "infield") ("dailies" "liaised") ("ignite" "tieing") ("Chaitin" "Chianti") ("bribing" "ribbing") ("girding" "ridging") ("dishing" "shindig") ("griffin" "riffing") ("incised" "indices") ("dieting" "editing" "ignited") ("citric" "critic") ("fifties" "iffiest") 
Niiice! :) 
Hope some reviews appear here soon. 
&gt; Use Chez if being the fastest I am under the impression that Racket will use the Chez runtime real soon now. Will that mean that the speed difference between Chez and Racket will thereafter be about nil or at lease negligible? If so, that might suggest that if one started with Racket now, the significance of the performance difference might be gone before one had a chance to write enough code to produce any painful performance penalties, no? 
Additionally, it fits the [relevant xkcd](https://xkcd.com/297/) much better.
They are replacing the core with Chez, so future versions will be Racket-on-Chez rather than Racket-on-PLT. That doesn't necessarily mean it will be as fast as Chez, or negligibly slower. Racket-on-Chez may require deep performance concessions.
There is a many threads to one process relationship in most operating systems included Linux and Windows. Communication between threads requires only lightweight synchronization primitives (threads can access same memory space), whereas communication between processes requires pipes, sockets, or memory mapped files and synchronization primitives like global named mutexes. Processes do not share a memory space.
&gt; *As far as I can tell, it has never been tested in court, which means we have no idea if the license would hold up in case of a random lawsuit.* That reasoning applies if you're considering whether to protect something with LLGPL, not if you suspect you might be infringing on it.
Thanks for the lesson. What I was saying was that in Linux, at least historically, threads were *implemented* as processes. Hence some of the docs use both terms interchangeably.
TIL. Thanks for the lesson right back at cha! :-)
Well your post helped, I had to check if I remembered it right, and also found out about `clone` :)
Hey, thanks ;) yeah, I noticed that threads have all the attributes of a thread. It was helpful to see in the "/proc/pid/" file, that there is also a "task/" directory with all the threads of a process, and those have the same layout (same files) as the process (also have a "maps" file, for example). One crucial and necessary difference is that threads have an own Stack. Also I can imagine though they all share the same address space, they might have differing permissions on some memory regions.. but I didn't look that up
Also interesting comment: https://mailman.common-lisp.net/pipermail/pro/2017-December/001506.html
I just found out that the author has a [CLiki](http://www.cliki.net/Wimpie%20Nortje) entry.
A high quality-content video. Thank you.
Thank you for the valuable advice. Much appreciated.
The same with the Lisp Machine operating system from the 70s/80s: no password protection, no encryption. Even the commercial versions of Symbolics had that...
That is why I felt in love with Lisp. I believe I read about that attitude in one article on Scientific American.
Sourceforge might be holding that project back. Many people don't trust it because of [this incident](https://www.howtogeek.com/218764/warning-don’t-download-software-from-sourceforge-if-you-can-help-it/). They have [said](https://arstechnica.com/information-technology/2016/06/under-new-management-sourceforge-moves-to-put-badness-in-past/) that they've changed, but it's one of the last places I would ever look to try to find an active Free software project. CLISP should consider Github where more people will see and contribute to it (or at least mirror it on Github).
This does not really have much to do with MACLISP; it was a characteristic of (one of) the operating systems MACLISP ran on.
ITS got password protection later during its lifetime.
It's because save-application quits the Lisp process after it saves the image. When the Lisp quits, you of course lose the SLIME session connected to it. In the process of copying in-memory data structures to disk, save-application does some things that can potentially leave the Lisp in an unsafe state. I don't know specifically what those things are. What I know is that from time to time over the years someone has asked for the ability to save-application and keep running. Gary Byers answered that it should be possible to do that, but it wouldn't be easy. Clozure probably wouldn't try to do it unless someone paid them to implement that feature. Evidently, nobody did. So you can't fix it--or, more accurately, fixing it would mean either modifying CCL or paying Clozure to do so. 
Do you have the code posted somewhere? (Maybe you mentioned in your other videos, but that was some time ago). What I think would be cool at one point (in terms of feedback), would be perhaps to automate the process, e.g. make heap snapshots, pause/start threads, compare values, peek and poke memory etc., where possible.
Automating the hacking process is certainly within reach. Like writing more powerful functions (find-value value program-name), or through writing a layer on top of it, hiding the lisp? The code is on github: https://github.com/k-stz/cl-ptrace I'll add it to the post. Most of the code's functions were explored in the videos. 
It is typical to save-application from a fresh session. I used to do that from a short lisp file that loaded everything else I wanted in the image and called save-application at the end, then started a fresh Lisp and loaded that file. Now I use buildapp, which does pretty much the same thing, but automates it a bit.
Thanks for the tip. I'll check out buildapp.
There was a problem with people trying to find clever ways to crash the ITS kernel, so it was solved by adding a "crash the kernel" system call. This made it no longer a challenge and people stopped doing it.
and so is v1.15 of [Notalone](https://github.com/borodust/notalone/releases) !
I totally agree with int is_space(char x) { return x == ' ' || x == '\n'; } rather than `#include &lt;ctype.h&gt;` and using `isspace` et al. Those functions have undefined behavior if the incoming value of type `int` isn't in the range `0` to `UCHAR_MAX`, whereas `is_space` above is almost impossible to misuse by accident out of any code which has its definition (or a correct declaration) in scope.
thanks!
a bit late for Ludum Dare 40, no? ;)
Check out a Roswell as well. It is also is able to build binaries and a little easier to use than build app. 
Great videos! One question. Do you see a way to be able to modify memory while also allowing the original thread to run?
Indeed. I actually [hoped](https://www.reddit.com/r/lisp/comments/6z7hnu/trivialgamekit_simple_common_lisp_framework_for/) to make this release available before last [Lisp Game Jam] (https://itch.io/jam/lisp-game-jam-2017-hard-mode) started :/ Feedback is quite a hard thing to acquire.
yep! You can do it like at the end of the video: either attach to a thread you don't care about and thus have access to the whole memory space, Or you can attach quickly to the thread, change the value, and detach immediately. IIRC that's what the function READ/WRITE-PROC-MEM-BYTE does when it writes to the process memory via /proc/pid/mem, though we do simple file read() and write() operation, in the background, they notice its a speical "file" (/proc/pid/mem) and do the appropriate ptrace() calls on it. 
Cheers! I've learned quite a lot from your videos!
This is the repo linked from the post from a few days ago and that is still on front page.
I am sorry, because usually there is a warning is the same link has been posted in the same or other subreddit.
I have hard time deciding if this is genius, stupid, heresy, or all three at once. [Despite the rumours](https://www.youtube.com/watch?v=5-OjTPj7K54), the third one is in a different context than usual in the so-called holy wars.
You could use the LOOP keyword COUNT or SUM to tally the count. I think it's more idiomatic to use FORMAT to print the result.
You don't need RETURN-FROM PROCESS. Return 1 directly from the WHEN expression. Don't use SETQ COUNT, bind the value in the LET. Indent the LOOP expressions not so far to the right. COUNT directly in the LOOP. Don't use FINALLY. The LOOP should return the count, which you then would as an argument to FORMAT.
Would you mind posting the source where you read that? I'd love to read it.
An example might be reading or writing a file. 1. Open the file 2. Do stuff with the file 3. Close the file A. Handle exceptions / errors resulting from the above. In a language like C you'd have to write all of that every time, even though only the identity of the file and the "do stuff" step are different. In Lisp, if it didn't already exist, you'd write a macro to write all of that boilerplate code.
Picolisp: (zero *C) (in "4.txt" (until (eof) (let R NIL (and (loop (T (eol) T) (T (num? (accu 'R (read) 1)) (nil (line))) ) (inc '*C) (char) ) ) ) ) (println 'Result: *C)
[Here's my solution.](https://gist.github.com/death/927a6b0da136d69a12d8913882375d9b) It also uses `LOOP`, but I don't think it's confusing. I use `SPLIT-SEQUENE` to split the string. It is stable enough that I don't care whether it's in the Common Lisp standard or not. With most CL implementations, you can dump a custom core with such libraries loaded and use that for development.
Good call on format. I wanted to use SUM but couldn’t figure the syntax out. 
Thank you! This is what happens when the web developer writes lisp 😳
This is fantastic, thank you! I did use SLIME and it seemed to work great. &gt; With most CL implementations, you can dump a custom core with such libraries loaded and use that for development. I’m not sure I follow this?
Wut. That’s amazing. I’m not ready for that yet. 
For `SUM` to work, you'd have to return 0 or 1 from `process`.
For example, with SBCL: [death@sneeze tmp]$ sbcl This is SBCL 1.4.1.201-e1a80c079, an implementation of ANSI Common Lisp. More information about SBCL is available at &lt;http://www.sbcl.org/&gt;. SBCL is free software, provided as is, with absolutely no warranty. It is mostly in the public domain; some portions are provided under BSD-style licenses. See the CREDITS and COPYING files in the distribution for more information. * (ql:quickload "split-sequence") To load "split-sequence": Load 1 ASDF system: split-sequence ; Loading "split-sequence" ("split-sequence") * (uiop:dump-image "my-core") [undoing binding stack and other enclosing state... done] [defragmenting immobile space... 893+18377+1222+1021+25727+18859 objects... done] [saving current Lisp image into my-core: writing 0 bytes from the read-only space at 0x20000000 writing 848 bytes from the static space at 0x20100000 writing 2080768 bytes from the immobile space at 0x20300000 writing 12960576 bytes from the immobile space at 0x21b00000 writing 31621120 bytes from the dynamic space at 0x1000000000 done] [death@sneeze tmp]$ sbcl --core my-core This is SBCL 1.4.1.201-e1a80c079, an implementation of ANSI Common Lisp. More information about SBCL is available at &lt;http://www.sbcl.org/&gt;. SBCL is free software, provided as is, with absolutely no warranty. It is mostly in the public domain; some portions are provided under BSD-style licenses. See the CREDITS and COPYING files in the distribution for more information. * (split-sequence:split-sequence #\Space "split sequence") ("split" "sequence") 14 See value of `(documentation 'uiop:dump-image 'function)` and the [SBCL Manual](http://www.sbcl.org/manual/#Saving-a-Core-Image).
Ah ok, so _some_ CL implementations won't support `split-sequence` but some will? And doing `ql:quickload` is just a backup for those that don't support it?
Who is the dodo who replied to a 22-year-old thread a few hours ago?
oh god did this submission trigger that ? .. well I did date-tag it properly
LOOP DO has an implicit progn: (loop ... do (progn a b c)) == (loop do a b c)
I think it's safe to blame Google Groups, too.
yeah let's blame google groups
So I can do multiple expressions? I thought it was similar to the true case for an ‘if’ conditional. 
Mine: (defun day-4/1 () (labels ((contains-duplicates-p (list &amp;key (test #'eql)) (iterate (for (head . tail) :on list) (thereis (member head tail :test test)))) (validp (phrase) (not (contains-duplicates-p phrase :test #'string=)))) (count-if #'validp (read-file-of-lines-of-words "data/2017/04")))) (defun day-4/2 () (labels ((anagramp (string1 string2) (string= (sort (copy-seq string1) #'char&lt;) (sort (copy-seq string2) #'char&lt;))) (contains-anagram-p (phrase) (iterate (for (word . tail) :on phrase) (thereis (find-if (curry #'anagramp word) tail))))) (count-if-not #'contains-anagram-p (read-file-of-lines-of-words "data/2017/04"))))
Well, that's what my example shows. It's not like IF.
&gt; ron.g ... @gmail.com Perhaps obvious
Split-sequence is just a library implemented in portable Common Lisp. When you use `(ql:quickload :split-sequence)`, Quicklisp (the tool behind `ql:quickload`) will tell asdf (the actual library manager) to load the `split-sequence` library, and if asdf can’t find it or one of it’s dependencies Quicklisp will step back in and download them on the spot.
7pm UTC happens when this comment is 10 hours and 2 minutes old. You can find the live countdown here: https://countle.com/kqex109996 --- I'm a bot, if you want to send feedback, please comment below or send a PM.
Also, as I forgot to link last week's episode, here it is: https://www.youtube.com/watch?v=CA9wtu5Cxas
The obvious Ron G. I know always uses flownet.
Got it, thanks for the info!
... because C++ adds everything under the bloody sun and turns a simple, consistent language into a hideous hodge-podge of ideas. Roughly the same reason why Go is kicking Rusts ass in terms of projects in production. 
Right, because a nunchaku is an everything-under-the-bloody-sun hodge podge of ideas, compared to a simple rifle. I get it now!
Sorry, poor explanation - what I mean is that just having C embedded inside it doesn't make the same - because when you join a C++ project you can never be sure *how* they've used it. It can be like stepping into a whole new language. Lisp arguably suffers from this as well, but it's generally more consistent in the way it's applied (though if you're a schemer, and you encounter CL's loop syntax you can be in no-man's land for a while). So in that sense, the nunchaku is a much harder weapon to use effectively than a rifle, and that, i guess is the point. 
Part of the problem is doing redundant work, like following a singly-linked list chain over and over, and parsing integers three times more than needed.
Using NTH to iterate over a list.
A nunchaku isn't a complicated weapon which also has a gun embedded inside it, and is consequently hard to master due to the complexity. The analogy is completely fucking stupid. 
Well, you may think so. Lisp is also nothing like a shiv. Perhaps all jokes are literal - who knows? 
You use a list in lisp and a vector in javascript. They have very different performance profiles.
&gt; What am I doing wrong? That's not a fun question to ask! Instead I recommend asking: "How can I do it better?" You can get it faster still using lists: - I replaced `(reverse container)` with a [collecting clause](https://gist.github.com/hebertch/c7f54f9452608c7e754382b07961d939#file-aoc-lisp-L16) in loop. - I calculated the [length of the list once and stored it](https://gist.github.com/hebertch/c7f54f9452608c7e754382b07961d939#file-aoc-lisp-L4). `(length list)` has to traverse the linked list every time it is called. - I [accessed the element of the cell once](https://gist.github.com/hebertch/c7f54f9452608c7e754382b07961d939#file-aoc-lisp-L6). Each time you access an element of a linked list, it has to traverse to that position. I incremented the value in place, and [calculated what the old offset would have been by subtracting 1](https://gist.github.com/hebertch/c7f54f9452608c7e754382b07961d939#file-aoc-lisp-L7). - [Call parse-integer once](https://gist.github.com/hebertch/c7f54f9452608c7e754382b07961d939#file-aoc-lisp-L16) on all cells. This avoids the need to read from string and write to string every time you make a jump. Other changes I made to make it easier for me to debug: - Replace `do` with `loop while` [here](https://gist.github.com/hebertch/c7f54f9452608c7e754382b07961d939#file-aoc-lisp-L5). I just understand `loop` better. I tested it on input.txt and got 381680 (like yours) and the sample problem and got 5. (time (your-start)) ;; =&gt; 1.13 seconds of total run time (time (my-start)) ;; =&gt; 0.79 seconds of total run time If you want it _even better_, you should probably use a vector, like [Aidenn0 recommends](https://www.reddit.com/r/lisp/comments/7hzqq8/why_is_this_so_slow/dqv0wxd/). A vector would give you O(1) random access (as opposed to O(n) for the lists) and O(1) length (as opposed to O(n) for lists).
This is fantastic, thank you! It's impressive that a list gets pretty close to the node version. I'm learning so much :)
The shiv stuff is just the author being a completely ignorant asshole, comparing Lisp to a low-quality, improvised hand-weapon, and insinuating that Lisp programmers are crazy. *Apt* analogies can be enlightening and entertaining.
And continuously parsing textual integers from that list and formatting back to text, over multiple iterations, instead of working with a sequence of integers.
Usually it is good to work over streams and not files. Since the lines just contain a number, we can READ through the file: (defun read-numbers (stream &amp;aux (*read-eval* nil)) (loop for number = (read stream nil nil) while number collect number)) PROCESS is then redone to work over a vector, an one-dimensional array. The count is returned by LOOP: (defun process (cells &amp;aux (maxcells (length cells))) (loop for position = 0 then pos for pos = (+ (aref cells position) position) count t while (&lt; pos maxcells) do (incf (aref cells position)))) We then call the functions: (defun start () (process (coerce (with-open-file (stream "./input.txt") (read-numbers stream)) 'vector))) 
Oh! Thanks for the steam/file example.
Short presentation of CLIM Listener, CLIM Debugger, drawing and presenting objects, defining application frame and working with commands.
Lisp is great for all sorts of data mangling. Couple questions / comments though: * Why picolisp? Is there something it's especially good at? * What's with the incessant blinking circles in the video? * A live stream of typing for the code is fine, but some audio instead of typing messages at the viewer would probably be better.
Is this the master branch
One other thing that might be making it slow is that there is additional startup work involved in bringing up the whole lisp image. My guess is that if you ran your function from the REPL like: (time (start)) you would see times well under a second even before the optimizations mentioned below.
yes
Be careful to only use `read` like this on trusted input. For example: if your file contains `1 2 #.(uiop:run-program "rm -rf /") 3` you're gonna have a bad time.
TXR Lisp: (prinl (let ((cells (vec-list [mapcar toint (file-get-lines "input.txt")]))) (for ((moves 0) (pos 0)) ((ignerr [cells pos]) moves) ((pset moves (succ moves) pos (+ [cells pos] pos) [cells pos] (succ [cells pos])))))) $ time txr day5.tl 381680 real 0m1.468s user 0m1.448s sys 0m0.016s 
Using symbol macro to eliminate repetition of the verbose `[cells pos]`: (prinl (let ((cells (vec-list [mapcar toint (file-get-lines "input.txt")]))) (symacrolet ((cur [cells pos])) (for ((moves 0) (pos 0)) ((ignerr cur) moves) ((pset moves (succ moves) pos (+ cur pos) cur (succ cur)))))))
Interesting. My results dips to `2.5s` when run the REPL without any other optimizations.
Using ignore-errors is as a bad idea.
Adding a couple of declarations, running in 0.001 seconds on SBCL: (defun process (cells) (declare ((simple-array (signed-byte 32) (*)) cells)) (do ((moves 0 (1+ moves)) (position 0) (length (length cells))) ((&gt;= position length) moves) (declare ((signed-byte 32) moves position)) (let ((cell (elt cells position))) (setf (elt cells position) (1+ cell)) (incf position cell)))) (defun start (input) (let ((lines (with-open-file (file input) (loop for line = (read-line file nil) while line collect (parse-integer line))))) (print (process (coerce lines '(simple-array (signed-byte 32) (*))))))) 
meh, it was a quick-and-dirty way to get elt to behave like nth in the out-of-bounds case. Feel free to post a better solution.
ignore-errors is beyond dirty.
meh, it was a quick-and-~~dirty~~really-dirty way to get elt to behave like nth in the out-of-bounds case. Feel free to post a better solution.
Impressive, thanks!
You could separate the logic better. One (preferably reusable) function to read the input, another to process it. `split-input` reads a named file into a list of lines, where each line is a list of tokens. The way tokens are separated in the file varies from one problem to the next, so `split-input` accepts an optional regular expression parameter (by default "\\s+"). (ql:quickload "cl-ppcre") ; regular expression library (defun split-input (filename &amp;optional (re "\\s+") (with-open-file (stream filename) (loop for line = (read-line stream nil) while line collect (ppcre:split re line)))) Now both parts of problem 4 can be solved using the same function: (defun solve (filename key) (count-if #'(lambda (line) (= (length line) (length (remove-duplicates line :test #'string= :key key)))) (split-input filename))) ;;; part 1 ;; CL-USER&gt; (solve "04.dat" #'identity) ;; 325 ;;; part 2 ;; CL-USER&gt; (solve "04.dat" #'(lambda (s) (sort s #'char-lessp))) ;; 119 
Great reply. Following this thread has been so helpful. 
It's minimalist and powerful. A segfault a day keeps Java away. It's the software keyboard I'm using. Agreed. I might try out streaming with Twitch for that purpose sometime.
totally, or switch out your readtable
It's parsing and formating integers **hundreds more times** than needed. 
Ah, OK thanks! I haven’t tried picolisp, but there is ABCL too if you’d like Common Lisp on the JVM.
This doesn't really inspire confidence, after so many years of development we get something that for all intents and purposes depends on X11 and is not cross-platform, is full of glitches and rendering artifacts, is butt ugly and feels even worse. I don't know what it says about MCCLIM that 20 year old Symbolics Genera videos manage to be more appealing (visually/feel-wise). 
Glad you liked it! ;-) But to be honest, while it's not very encouraging to listen to critical voices from the peanut gallery like this one I tend to agree, that McCLIM could use some love. That's what we are trying to give this project (which is an amazing cesspool of ideas) – time and attention from developers. Thank you for watching the video and sharing your opinion.
I can't help but the old Unix-like UIs have their own charm to them; they don't try (and need not) to be super-polished, super-shiny, super-smooth, super-animated, but are simply focused on functionality. I like them a lot more than overly animated and overly smoothed out top-modern UIs, as if they where an end in themselves...
Well, Symbolics had many people working full time on their stuff. At its height it were almost 1000 people with a very large graphics division located in California, developing and selling high-end applications and systems into the various graphics industries. I'd say it quite useful to get basics of McCLIM right and develop some useful applications and learn from that. Sure it would also be useful to have a backend for a more modern graphics/GUI system. The questions is to get there... given that programming this stuff needs a combination of expertise in Lisp programming and GUI implementation + time&amp;money.
Is it possible to include an OpenGL context inside a CLIM window right now?
&gt; *You can ignore all the questions about order of evaluation of the initial value expressions, just get the scoping of the variables right.* TXR Lisp's `mlet` takes care of the order (but doesn't have a way to specify which init expressions see which variables: all variables are visible to all forms). 1&gt; (mlet ((y 3) (z (* 2 x)) (x (+ 1 y))) (list x y z)) (4 3 8) Circular ref, oops: 2&gt; (mlet ((y z) (z (* 2 x)) (x (+ 1 y))) (list x y z)) ** (expr-2:1) force: recursion forcing delayed form (+ 1 y) (expr-2:3) Rhetorical question: why have `mlet` in the language at all if you can just order the variables in a topological sort? Because circularity **is allowed** through lazy evaluations. Yo, check dis: 4&gt; (mlet ((x (lcons 1 x))) x) #1=(1 . #1#) The `lcons` constructor is a macro, arranging for `x` to be evaluated late, when its value is needed. By that time, it has a binding to the lazy cons cell that has been returned, and so the circular linkage is completed. There is a `lnew` operator that complements `new` for lazily constructing objects. We can use `mlet` with `lnew` to make an object which refers to itself: 5&gt; (defstruct node nil next prev) #&lt;struct-type node&gt; 6&gt; (mlet ((n (lnew node next n prev n))) n) #1=#S(node next #1# prev #1#) 
In this particular case, readline/parse-integers makes complete sense. It's lines of integers.
xlib certainly allows that. I didn't investigate how well it plays with McCLIM, but I saw gl extension in CLX. I think this might be possible with some coding effort to create right kind of pane. Not something you get out of the box though (right now).
Having it on Amazon would either make the price go up or reduce the money the author would receive. Furthermore you would only get a terrible to use kindle ePub version with DRM. Maybe LeanPub could be a solution, where you can have a flexible pricing range with recommended &amp; minimum price.
UI is hard, and the more general it is the harder it is to make fast. Keep fighting the good fight. There are plenty of languages, we can afford to have a few for exploration (or dare I say fun!) and the same goes for UI systems. It doesnt have to be a 90fps beauty if it delivers well in other areas. MCCLIM has a bag of potential, goodluck
Great! thanks! Hopefully you'll make some follow ups - my wishlist ;) : more on layouts and widgets (buttons, text-fields, ...)
Fukamachiware (integral) has that capability. (defclass user () () (:metaclass &lt;dao-table-class&gt;) (:generate-slots t)) This generates slots from an existing db. There is only jp "explanation" (not a document) though. http://blog.8arrow.org/entry/2014/01/19/180013 
Thanks! It looks like Integral is deprecated. But its something I can work with 😀
Clsql-orm behaves this way and should be mostly database server agnostic
This looks perfect. Pulls out all the information that I need (constraints, keys, etc.).
Perfect! I am the author, but havn't had to make any changes to it in a while. Just file github bugs if you run into trouble and I will look into it when I can :) Cheers
That's awesome. Will trouble you if required 😀
That is a very nice reply to a quite un-thoughtful comment. You, sir, are a gentleman and a scholar.
Maybe ask Erik himself. https://eriksvedang.com/contact/
Author of the blog post here! Yes, it’s been mostly Erik and I who’ve been active, and I didn’t really expect the blog post to blow up like that. Going to the [gitter channel](https://gitter.im/carp-lang/carp) is a pretty good first step, and among others I’ll often be online there and ready to answer any questions!
Give it a spin, besides inference engine and integrated object DB it has fantastic interop with both C and the JVM, should you need it. CL is great but also a bit clunky. 
Also: https://www.reddit.com/r/lisp/comments/7fmadk/a_statically_typed_lisp_without_a_gc_for_high/
Ok, I'll check this channel out. Nice to have a line of communication at least!
Thanks, sounds like another fun tool for the toolkit. 
MAGICL seems like it'd be useful to the community; what was your take on the existing ones (blapack, gsl-ll, llapack, matlisp, mgl-mat ...) ?
They’re all one or many of: too slow, wildly incomplete, wildly incomprehensible, buggy
wildly incomprehensible ? That's amusing.
Try to grok the latest Matlisp. 
A few clarifications: (1) isn’t true. It will infer the right version of the copy function for you, based on the types. Sometimes you mgiht want to be explicit and use the module name, but you don’t have to. (5) isn’t true either. You can extend the module from another file with another call to `defmodule`.
Thank you for the great libraries you've released over the years :).
Thanks. I've based my opinion on the examples. How does (1) work then? Is there a CLOS-like generic function "X" created and also an ordinary function "Class.X" created when doing this? Or does it work differently?
I understand. Carp’s documentation situation is admittedly abominable. It’s similar, but it doesn’t incur a runtime cost, because it is done at compile time. It’s similar in that you can define interfaces and then specialize on them by just defining a function that has that name and a fitting inferred—or annotated—type. The `str` function is a great example, where the interface is just `(definterface str (λ [a] String))`, where `a` is a type variable you can specialize on. Same with `=`, which is defined as `(definterface = (λ [a a] Bool))`. Does that answer your question?
I will keep an eye on that, the game itself sounds awesome. Once I can program in a considerable manner, I would want to do a Grand Strategy where historical evolution is simulated and generalized in a gamey manner just like the simulated network you are trying to program.
I want to het into using it bit im not sure how to get started. How do i set it up? I was checking the repository but i did not figure it out
Look in the doc directory, there's an install document. Basically you need [Haskell stack](https://docs.haskellstack.org/en/stable/README/) installed and then it's just two commands and an environment variable and you're ready to go.
Sounds super neat, best of luck. I'm sure you'll find people who are better-equipped to help you than I.
Thank for sharing.
Careful. The book that is being shared on the site, Interpreting LISP, is downright obsolete and contains outdated and misleading information about Lisp. Also, to add insult to injury, the C code in the book are also terrible as well. See [this thread](https://www.reddit.com/r/lisp/comments/6qc61v/second_edition_published_interpreting_lisp/) for the previous discussion on the book.
For example like this: (with-input-from-string (s (format nil "a b c~%a b c b~%a b c")) (flet ((dupl (list) (lambda (el) (find el list :test (lambda (a b) (and (not (eql a b)) (equal a b))))))) (loop for line = (read-line s nil nil) for list = (split-sequence #\Space line) while line count (notany (dupl list) list)))) 
deleted from reading list, thanks lot.
I suspect this code should also skip immediatly if dupicate found.
**PLEASE AVOID THIS BOOK AT ALL COSTS.** [Explanation.](https://www.reddit.com/r/lisp/comments/6qc61v/second_edition_published_interpreting_lisp/dkw66fl/)
thanks for the warning. I enjoy reading even crappy implementations so .. well at least others are warned. That said, I liked the PDF first pages.
gah missed it again, sorry dude
It seems like I'm getting less and less visitors every time
Interesting tidbit: iRobot still uses a Lisp derivative of this in their products.
Are you running that from the Unix shell like the OP, or is 0.001 seconds how long it took to call `start` from the REPL? I suspect a large part of OPs runtime is the Lisp environment loading itself. 
`nth` is an O(n) operation. You shouldn't be using it to iterate over the `cells`, which are a linked list, unlike in Node, where you're iterating over an array. 
Pretty awesome fact. 
I've long treated automatically generated "documentation" of this form (by a 3rd party and not the author) as useless since it's nothing more than a dumb in-your-face infodump that dilutes the documentation search space (which could contain actual documentation written by the author). That's not to say that I find automatically generated documentation in general to be useless. An author could structure and document his project accordingly so that auto-generated documentation is of value. But, coming in no-holds-barred bulldozer-like and doing it for *everything* is madness. Quickref also fails to take into account how one usually programs with Common Lisp systems, interactively from within an image. We already have slime-describe-* to give us what quickref does without pomposity.
Seems promising, but it shares a lot of the same functionality as http://quickdocs.org/ Also, I don't think I'll find the files section very useful
I don't particularly care for what Quickref does, nor how it presents itself, but if it at least gave an obvious link to the author's own curated documentation or project page (through the `:homepage` ASDF3 property) I would be a lot less bothered.
Compare: http://quickref.common-lisp.net/clack.html To: http://quickdocs.org/clack/ Can anyone find something that is better in quickref than quickdocs? Also, for systems with lots of files, I need to scroll past pages and pages of files before I get to actually useful information. When I tried it with ironclad, even the table of contents for the files was overwhelming. 
I really look forward to this project getting better as something that does a better job that quickdocs is sorely needed. However I have `(SETF (DOCUMENTATION ..) ..) on all of my public api (500+ symbols &amp; thousands of lines [of ref docs](http://techsnuffle.com/cepl/api.html)) and quickref is seeing none of it. I'd really like to see one of these systems use lisp's standard functionality for this. That said, best of luck with the project. Collating the docs in the ecosystem is super valuable and I hope this works out
mmh… [code folding](http://wikemacs.org/wiki/Folding), putting markers at every `(declare ` and `(the `, with help of [m-buffer](https://github.com/phillord/m-buffer-el) ?
[removed]
https://jeena.net/images/2014/real-humans-code.png From Swedish TV show!
Seems to be code from fare's [POIU](https://github.com/fare/poiu)!
May I ask why you decided on such a style (besides the obvious -- code density)? It's not at all common. What do you think is "super valuable" from such a collation? 
Reference docs are bad manuals, manuals are bad reference docs. I had to do one first and ref docs were more manageable. I really want to get back to writing manuals (I started them here) but they are much harder to do well. Docs in the browser have the potential to have features and styling not currently available in `describe` (inter-doc-string links for example). I think if someone is able to presents existing information in a way that helps some people then its valuable. It doesnt have to serve all people, especially if they already have something that works for them.
Diverse implementations give diverse features. Since ANSI Common Lisp is a standard, and there are many portable libraries out there (Bordeaux-Threads just to name one), it's easy to try your code with different implementations. **CLISP**, for example, has two or three nice things: * It is very small to install, compared to SBCL. This sometimes is an important plus. * It greets you with a nice menorah logo (and i'm not jewish at all, but it looks cool to me). From the official documentation: *(...)you may simply think that Common Lisp brings the Light to a programmer, and CLISP is a vehicle that carries the Light. Accordingly, CLISP enables you to see the truth, thus you can pronounce it as see-lisp.(...)* * It has a JIT (Just-in-time compiler) inside and has fast aritmethic support. However, it is slow compared to some implementations like SBCL. **SBCL** - Steel Bank Common Lisp * does not have a fancy logo * produces very fast code * the compiler does some static type checking, if you use declarations accordingl **CLASP** by Dr. Meister: * Compiles to the LLVM (low level virtual machine). This opens up many possibilities, such as for example, writing your code in the most wonderful of languages (Common Lisp) and output WebAssembly code (through the LLVM tooling), thus producing code that would run in a browser. **ABCL** Armed Bear Common Lisp or what i like to call "Clojure's worst enemy" ;) * Runs entirely in the JVM (Java virtual machine) * Allows to easily call Java code from Lisp and to call Lisp code from Java libraries. * Perfect if you need to interact with the JVM, either because you need to leverage the huge Java ecosystem, or because you want to let your boss believe you're creating a Java application, while in fact it's a Common Lisp program,. **LispWorks** and **Allegro Common Lisp** and **Scieneer Common Lisp** These are commercial CL implementations and i'm really glad they exist, since this means commercial (paid) support is available. This is excellent for people like me who work in a corporate environment full of people with business suits; you can always tell them "hey, Common Lisp is a professional platform, we can deploy in LispWorks with full pro support. (etc)" **SICL** by Robert Strandh and friends * New modern implementation aimed to be fully modular. Perhaps the most modern/advanced CL implementation(?) Pedantic comment: Note that CCL is Clozure Common Lisp, not Common Lisp. 
Hmm... That would be a perfect feature for a projectional structured code editor.
Competition is generally good.
Nice. It reminds me a bit of Emacs' [https://github.com/phillord/lentic-server](lentic-server) 
Love it! Just two lines for each delimiter... 
Azzamsa, Do you want to read about the history of Lisp? Ready for tasty 100+ pages on this? Here's what you want, an excellent paper on it: https://www.dreamsongs.com/Files/HOPL2-Uncut.pdf 
&gt;Lisp is now. Type to a repl. That was poetic! 
Dit you specify a situation in [eval-when](http://www.lispworks.com/documentation/HyperSpec/Body/s_eval_w.htm)?
Yes: `(:execute :load-toplevel :compile-toplevel)`. the `*instructions*` defparameter evaluates before the `define-instruction` calls just fine. The problem comes when I want to compile all of the instructions together. I will updating the OP to reflect this.
I think what you want to do is reasonable, but macro expansion can be tricky. See the notes in the documentation. It's difficult to say without the exact code.
What this sounds like to me is your `define-instruction` macro *expands* into code which manipulates `*instructions*`, which means the populating doesn’t actually happen until load or execution time.
In that case you have a few options- break the usage of `compiled-machine-step` into it’s own file which requires the first file to be `load`ed first, have `define-instruction` expand into an `(eval-when (:compile-toplevel) ...)`, or (and don’t actually do this- it has all kinds of subtle or not-so-subtle issues all over the place) have the `define-instruction` macro manipulate `*instructions*` during its expansion. I’m personally a fan of doing both of the first two.
Oh, one other point- if you stick a `defparameter` in an `eval-when` you may get surprised. It’ll create the global var at compile time and assign it the initial value (let’s say nil) and then at load time it’ll reset the var back to nil (because it’ll eval the defparameter again). Then at execution time it’ll again set the variable back to nil (although you’re unlikely to be doing anything that would notice this one). What you were probably looking for was `defvar`, which works like `defparameter` but doesn’t change the value if the variable already exists.
Hi. yes, this is what I'm doing, thank you! I like the number 2 option the best, but does it need to happen with the number 1 option? Like I don't totally understand the semantics of eval-when, are they executed in order? Or would I need to worry about `*instructions*` being defined after the `define-instruction` calls? thanks again!
Thanks for the heads up. The point of having it be a parameter would be so it would clear out every time I recompiled in case I accidentally added an erroneous instruction and deleted it. I think for this case it does what I want.
So, CL code is always operated on in order 
Well. Exact code would be pretty difficult to read, but I created a reduced gist [here](https://gist.github.com/hebertch/6063f2443936f9718ec6fcb9d4417ca3), including approximately what is spit out by the macros.
The problem is that the population of `*instructions*` is a macro-expansion-time effect. Thus the `*instructions*` variable which exists in the **compilation environment** receives a value during compilation. But that value isn't propagated to the compiled object file. The question is, what is the goal of this? In the compiled case, what exactly is the compiled `.fasl` supposed to contain? If you just want the final compiled form, you have to arrange for `(compile-machine-step-from-machine)` also to be called at macro-expansion time and capture its result. It could be as simple as: (defparameter *compiled-stuff* (compiled-machine-step-form machine)) make this `(compiled-machine-step-form machine)` macro work in such a way that that it expands into a `(quote ...)` literal which is assembled at macro-expansion time from the stuff in `*instructions*`. This could even be a `defconstant` since that stuff isn't expected to change. 
I think you need an eval-when in your macro. See the notes in the documentation.
So, (for most practical intents and purposes) code in CL is always operated on in order, in chunks called “toplevel forms”, but in multiple phases. Forms (expressions) that aren’t enclosed by anything else are always considered “toplevel”, so in this case your `defmacro`s and `define-instruction`s. The three phases defined in the spec are “compile time”, “load time”, and “execution time” (well, execution isn’t really a phase, per say). Not all code will go through all of the phases, but they do always happen in that order if they happen at all. Compile time is when code is being processed by `compile-file`, load time is when it’s being `load`ed, and execution time is pretty much any other time the code is being run. Macros, for example, get expanded during compile time (or load time or execution time, if the code never goes through an explicit `compile-file`). `eval-when` is one of the tools you have to get code running during compilation or loading (so, at the same time as macros are being expanded). In fact, `defmacro` uses this feature to make your macro available in the same file it is being defined in- otherwise, since macros are expanded before any code is “executed”, the macro definition would not be run until it was too late. However, `eval-when` doesn’t change the order- when `compile-file` is going through toplevel-form by toplevel-form expanding macros and hits `(eval-when (:compile-toplevel) ...)` then it’ll just run that body of code on the spot, no sooner or later. (As a side-note/clarification, if compile-file expands a toplevel macro and that macro expands into an `(eval-when (:compile-toplevel) ...)` it’s still required to run the body of code on the spot, which is why you can have a macro expand into an `eval-when` at all)
I wasn't referring to Lisp compilation. Sorry for the confusion. See my latest edit, but when I compile a CPU instruction, I use a macro to generate optimized code that can later be aggregated like you describe.
Wow this completely cleared it up for me. Thank you so much!
And now thanks to your other post I understand why my eval-when will be a problem.
Thanks!
You wrote: &gt; This works when I (load) but not when I (compile-file). I'm talking about that compilation.
Interesting theory, but surely there are better ways to store distributed data and/or code. Blockchains are very costly and tend to end up centralised cause not everyone can afford the hardware or startup coins to effectively mine or stake them.
If a coin can’t run on a laptop, its not a real blockchain, I’ve heard. By basing the Proof of Work on Scheme, I eagerly await custom hardware to mine the coin, once it has an acceptable market cap, of course.
Nice! I probably won't tune in for the live stream but I'm excited for the youtube video!
Hey that was written by me! (Aside: I redirected the page to point to the latest version of this post on my new blog) Fun fact: I wrote this post way back in 2008 while working for an online travel portal. This was based on some actual work we'd done there. At that time, flight travel in India had started to boom. This I think went hand in hand with a bunch of online travel companies (including ours) gaining a lot of momentum. To be more competitive, a couple of airlines decided that they wanted to introduce new discounted fares much more frequently than they were doing earlier. The only problem was that they were unable to upload their wonky fare rules in the GDS properly, so they started distributing excel sheets to travel agents with manual instructions on how to apply them. So our business team starts sending these sheets over to us, and initially, the frequency was low so we just manually hard coded these rules. However then they started sending these sheets every week or so which made our life hell. So we asked asked our business team to "translate" the airline's excel sheets and instructions into a csv, which was subsequently interpreted by a simple rules engine that we wrote. The only problem? Well, as anyone who's dealt with manually created CSVs will tell you, there were a **lot** of errors. This didn't really help matters much. We then added a couple of restarts to our CSV parser which allowed us to correct these issues interactively. This made life much better for us -- it was a lot easier than, say, getting a list of errors in a terminal and switching back and forth between the terminal window and the editor to correct them. Later on we plonked the CSV parser behind hunchentoot and asked our bizdev guy to upload the file there. A handle-bind around the parser collected all the errors in one go and showed them in a nicely formatted way in the browser (see the last section of the post). And so it was no longer our problem :-) Eventually these airlines decided they wanted to update fare rules **daily**. Thankfully our "business rules engine" was upto the task. Due to automatic feedback, our friend in bizdev became an expert at uploading the fare rules as soon as they came in. And for quite some time, we were the only ones who could show these cheap fares within minutes of them coming in (if I remember correctly, other portals would take hours to upload the same rules). Ours was a small team, and we had to manage this in addition to a lot of other things. If it weren't for CL's condition system, I doubt we could have solved this as smoothly as we did. In particular, interactive restarts allowed us (devs) to correct CSV errors without wasting a lot of our own time, and without needing to build a full-fledged UI for a non-dev. And when the time did come for a UI, it was dead easy to write a web fontend on top of it.
That's good: Clearly explained (although I probably know conditions too well to really judge that) and the examples are informative and neatly written. Pitman's paper, though, is a fun read if you're a language designer, but a little heavy if you just want to learn Common Lisp. I always like to point out that one great advantage of the CL condition system is that it establishes a protocol for error handling that allows several independently written modules to cooperate in the process. The author of a handler does not have confer with the author of the error signaling code to the able to handle it, other than knowing some superclass of the error signaled. Likewise, a handler can invoke a restart without the author even having to know if it exists (due to FIND-RESTART). This allows libraries to handle errors of their clients or vice versa, with minimal extra documentation. And of course, it allows a debugger to provide useful restarts.
Did you ever work or need an optimal solution to the Tavelling Salesman Problem?
Nope. Domestic flight travel in India is simple... point to point or max over two legs. For international flights we used QPX.
What’s QPX?
QPX was ITA software's flight search engine. Probably among the biggest software systems written in Lisp. It now powers Google Flights (I think).
One thing I miss in the condition system is that it does not have the facility to document each condition/restart/handers so that C-c C-d shows what may happen in the given function.
Hmm, I'm not sure what you're getting at. Those are all run-time entities, so I don't know what you'd expect an editor to know, and what text you'd be doing that C-c C-d on.
something like: "This function may potentialy signal the following conditions, A, B, C". If it provides a handler for C, then C would be removed from the list. It also tries to check the function being called, if they are apparent from the context (i.e. except non-obvious funcall/apply). Also "this function provides the following restarts..."
Why not try something like the tangle?
It keeps looking better and better. I eagerly await the GNU/Linux port.
Thank you! Me too!
&gt; EVIL mode now fully possible as an extension How's that ?? Only found a [feature request](https://github.com/nEXT-Browser/nEXT/issues/28), no commit mentioning "evil".
Hi, thank you for your comment! I am sorry, I was not exactly clear about this, I only say it is possible, I haven't actually implemented it as an example. Because there is now a "memory" of the buffer, aka you can switch a major-mode in/out and the major modes will retain memory, one could implement EVIL mode. If you really like, I can do a very basic example, but it isn't very high on my priority list right now (I am not an evil user)
Will there be a Windows version some day? We lack alternatives to qutebrowser since Firefox started to suck.
I am sorry to disappoint! To be completely honest, probably not, unless someone cares to port it themselves (the porting is rather trivial, I just don't have any windows machines) Maybe if there is enough demand/support, at some point I could take time off working to make a windows port
Sounds good. I could probably help if I found the time - not this year anymore, though. :-(
So this is just Crapple, right? I was so disappoint when I got back from parts foreign and tried to run it on my Slackware box.
I looked at stackoverflow I did not found anything so I will try with this post, maybe usefull tips of how to proceed.
I did it from scratch with Ironclad for a previous project. Wasn't that hard. Security audit still pending.. :) When I did more Ruby (connecting to the SO question) I also did it from scratch most of the time. Without CanCan etc. There is also a nice [Railscasts episode](http://railscasts.com/episodes/250-authentication-from-scratch-revised) about this topic. Don't know if this is still doable. Didn't do much Ruby since 2012.
Is the code available to review online somewhere?
Keep in mind there is a difference between authentication and authorization, your SO post seems to mix both terms. Authentication is proof of identity whereas authorization is about access control. I have successfully written Lisp applications that access Windows based services that use NTLM and Kerberos (SPNEGO) for authentication, I think the libraries got added to quicklisp. Both of those are somewhat niche though, and probably not what you want.
No, I could not find it anywhere. I have the printed book. I have found a thread here: https://groups.google.com/forum/#!topic/comp.lang.lisp/3aFx2ALHD50 Appendix A (p. 151-197) is dedicated to the full source code. I could post a few snapshots if it could help.
Lucid Common Lisp is pre-ANSI-CL, but close. ANSI Common Lisp would be fine. There might be a few adjustments needed, for example the package names. LISP is COMMON-LISP, USER is COMMON-LISP-USER. CLOS is no longer needed, since it is built-in. Maybe there is some MOP usage. Pathnames may need some adjustments. Generally I would guess that it would easy to update.
Much thanks, I will try it with SBCL.
I'm eagerly waiting for F-Droid release! (I don't have Play Store)
It looks great and it would fit much better on my hobby use than other alternatives I've used. Some nitpicks on my phone (huawei p8 lite 2017) It starts with the focus on the middle field, trying to write a function there is hard, must be single line and lateral scroll seems missing. Trying to paste with nothing in the buffer hangs the app. In my 5 minute test I've found no easy way to paste code from external clipboard. If I'm inspired tomorrow I'll try to code in there while commuting, it depends whether the input from advent of code will be simple or i find a way to enter it. Great job! 
Thanks for your feedback! Initially it's maybe a bit unusual how the app works; please see command `:h` and the help text (it will also tell you how to move the cursor, in all 4 directions).
Ok, note taken.
I wrote cl-gss which allows you to easily authenticate against Kerberos (and AD, since they use Kerberos). Perhaps that's what you used? I've used it myself to authenticate web applications written in Lisp and it works the way you'd expect it to. 
Giving it a shot. That's going to be my next project should I get funding.
What do I need to do to submit my 'Scheme Coin' to the symposium? Write a paper? Or is just the code good enough?
Should be pretty to implement with today's tools. Anybody familiar with VLSI?
From the symposium site: We invite submissions in the following forms: Papers: Technical papers of up to 8 pages that describe original results or explain known ideas in new and elegant ways. Demonstrations: Abstracts of up to 2 pages for demonstrations of tools, libraries, and applications. Tutorials: Abstracts of up to 4 pages for in-depth presentations about topics of special interest for at least 90 minutes and up to 180 minutes. 
Great Job!!! 
Well, it's light on its hosts and the bigger it gets, the faster it becomes. You can start by finding something to add value to a certain community. The rest comes by itself. Give me a hoot if you'd like cooperation. I'm familiar with Common Lisp but I can always learn.
The [2014 ICFP Programming Contest](https://icfpcontest2014.github.io/) required you to write assembly language for an [SECD Machine](https://en.wikipedia.org/wiki/SECD_machine), which is basically a 'scheme/lisp assembly-language'. We wrote a [compiler](https://github.com/ychin/icfp_2014_CannonBrawl) embedded in Haskell. ([Example output](https://github.com/ychin/icfp_2014_CannonBrawl/blob/master/solution/lambdaman.gcc)) The target language is simple enough that it could probably be implemented in hardware without much further concretization, with the exception of `LDC`, which needs to traverse a linked-list-of-arrays, and `CONS` which needs some concept of a heap and probably garbage collection. Has anyone implemented a hardware GC?
**SECD machine** The SECD machine is a highly influential (See: #Landin's contribution) virtual machine and abstract machine intended as a target for functional programming language compilers. The letters stand for Stack, Environment, Control, Dump, the internal registers of the machine. These registers point to linked lists in memory. The machine was the first to be specifically designed to evaluate lambda calculus expressions. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
The lambda is easy to find, and the copy/paste of s-expressions is nice. My only problem is interfacing with the outside world. I have not been able to paste data, or read an outside file, or write in a file created by the program. It might be possible, I have not managed it, so I'd guess it's not easy to do. And my watching a series in my commute made me unable to test it more extensively, sorry.
Thanks to Baggers for this very nice and much appreciated ongoing series on Lisp.
Nice! Too bad I don’t have android :/ I imagine porting this to iPhone would actually be pretty trivial due to the support of C in iOS
Yes, porting should not be difficult: both ECL and QML work on iOS. Somebody already gave me his old iPhone, now if I manage to get a used Mac, I will *probably* do the port personally (without promising anything, though).
Since space is very limited on a phone, the menu buttons are only shown for **3 seconds** if you press the button on the top right. Please see this [screenshot](https://gitlab.com/eql/EQL5-Android/blob/master/screenshots/REPL.png) from a tablet; the buttons are the same on a phone: On the top you have undo/redo, font smaller/bigger. On the right you have have **clear**, **file open**, **file save**, **eval everything**.
I've been working closely with the IOTA team recently and I'm starting to have some doubts about it given recent events (spam, which is supposed to make the network better, but 'certain types' are not handled properly by the assumptions made in the white paper and are being exploited last I heard, giving very long transaction confirmation times). I figure a good, accurate, well written simulator based exactly on the white paper would be a good tool to help with finding and solving such problems.
unfortunately even used macs are expensive for what they are, they hold value too well :/
Very interesting, the bundle covers very interesting programming languages: - Common Lisp (Land of Lisp) - Racket - Clojure ... and Assembly (which makes me extremely glad) But on the same bundle the "other" book, which IMO spoils the party: An R programming book. R is one of the most horrible programming languages i've used; of course, it is good for data analysis, but so would be doing the same in Python, with less pain.
Sorry for not explaining myself. I had already found them but file open (and save) seem to open on a limited subset of the drive, without good navigation to generic directories. The default directory for it it's \/data\/data\/org.eql5.android.repl\/files, I have not managed to find this directory with the default file manager in my phone, and... well, I managed to discover that if you go up from the default it kind of shows the SD storage (\/storage\/1234-5678, sample number), but pressing home it goes to \/data\/user\/0\/org.eql5.android.repl\/files, and navigating up this structure shows it empty, and it's another structure I do not know how to reach with my file explorer. Trying to manually set the directory to \/storage or \/storage\/1234-5678 hangs the application. So I have a limited window to insert and extract data as it is. Which is ok for me.
Update: thanks for reporting the clipboard and scrolling issues; these are already fixed in the repo; I will update the app in a few days.
Let me explain how I navigate (but I'm already used to it; maybe others find it too difficult to discover): Generally I click on the "documents" icon, then I go one up, and there I find the usual "Documents", "Download", "Pictures" directories of the device. To go to my external SD card, I too start from the "documents" icon (top menu), then I go up (3 times) until it shows `/storage`. Now I can select my SD card: mine is shown as "BAC6-96D0".
&gt; This is fantastic, thank you! It's impressive that a list gets pretty close to the node version. I'm learning so much :) I've seen the Node code you submitted, and if you write it in Lisp using fixed-length arrays of a specific type (like fixnum), and with careful optimizations, it should totally blow away the Node code in speed, and in fact, it can get pretty close to pure C speed. 
I tried my completely horrible code for advent of code 2017, [day 15](https://ideone.com/sUeY11)(feedback is welcome) and it worked nicely with no change at all. Unfortunatelly my phone must be crap, it lasted some minutes before giving the correct answer. But now I can create the code in here and test it with the sample input, and then use it in a better computer when I have access to one, nice! It's interactive (so better than Ideone), I already lost code in Ideone because of writing a lot before saving, I'd guess it would be hard here, and it's nicer than the other CL REPL I had in android. Later I'll have to find a better editor than Dcoder to edit the files and I'll be set :D
Thanks, I also like that series a lot, succinct with depth, like Lisp is. I wonder if he describes anywhere his workstation setup? It looks interesting, possibly 3 monitors? Also, what about the video setup?
&gt; Trying to manually set the directory to /storage or /storage/1234-5678 hangs the application. Want to know a funny thing? In order to debug this, one can just run Swank from the app REPL (command `:s`) and then connect to the device from Emacs on the PC (see [README](https://gitlab.com/eql/EQL5-Android/blob/master/examples/REPL/README-2-SLIME.md)): now every condition will be shown in Slime on the PC, and can be inspected there! In this case the error message is: C operation (fread) signaled an error. C library explanation: Is a directory. which simply means that it tried to read a file, but found a directory instead. Now you simply can type `q` in Slime, and the app will **continue** to run!
I was just looking for a way to try things out when I don't have a computer close, tyvm for this!
I can confirm that Land of LISP is both a fun and informative book.
Also Haskell and Erlang, which I both find intriguing. I would have also hoped for OCaml and Elixir but, hey, maybe in the future.
It's not mainly the fault of your phone: to be fast, this code would need to be compiled to C by ECL first. My laptop is quite slow, and your code took about 2 minutes in interpreted mode, and 12 seconds when compiled to C by ECL (which unfortunately isn't possible on the phone). So, this kind of number crunching will always be slow using interpreted ECL (and compiling to `.fasc`, which is possible on android, doesn't help here). (BTW, your example would of course need proper indentation; except from that, it's better style to use `(zerop x)` instead of `(= x 0)`. The rest seems fine to me.)
Nice. Thanks for sharing.
Emacs with Slime, StumpWM as window manager IIRC (from his live streaming videos). Don't know of course how he does it, but `xrandr` is pretty powerful in using 3 monitors, even with more than one video card.
One problem we always have to face in iOS is the license issue between LGPL and the app store. Are you sure that it can be solved?
Yes I know about your cl-gss library, but for various reasons I ended up writing my own implementation. I also wrote the server component so in principle it could be used by a webservice in an environment that called for it. But I never got round to polishing it e.g. I didn't write support for things like forwarding tickets or domain trust relationships. The libraries are on my GitHub [page](http://github.com/fjames86). 
I need to try StumpWM, its Common Lisp underground is tempting. I wonder if the "webcam" side is Windows based. I never as good experiences with Linux.
Didn't know about this, thanks for the heads up. But wouldn't it be possible to provide an installable file (like an APK on android), which could avoid the app store? I mean, I have no intention to make money with this tool.
If you are using a framework, based on Clack, then you can try Hermetic: http://quickdocs.org/hermetic/ I didn't used it yet, seems it is only supports a password based authentication.
I also will need a social authentication for one of my sites, based on Weblocks. It uses Clack underneath and I'll be glad if somebody will suggest a solution to authenticate user by Facebook or Google account.
Avoiding the official app store I think there are several ways, but not as easy as android APKs unless you have a jailbreaked iOS. If you have the complete app sources you can install as a dev app, but it will be runnable for only a week if you don't pay for the Apple developer program. If you target jailbreaked devices, you can distribute through the Cydia app store.
If you’re using Haskell, might [Clash](http://www.clash-lang.org) be of interest for you? 
In TXR Lisp, I combined [restarts and conditions into one](http://www.nongnu.org/txr/txr-manpage.html#TOC-9.31.1). There are two kinds of frames which introduce bindings into the search space for an exception: catches and handlers. Catches perform the non-local transfer and unwinding (analogous to `restart-case`); handlers just bind functions which are called (analogous to `handler-bind`). If such a function returns, the search continues. They are in the same namespace, denoted by symbols which are linked by a hierarchical inheritance relationship. The function [get-frames](http://www.nongnu.org/txr/txr-manpage.html#N-010405DA) returns a list of all the frames that are visible. The [Dialect Notes](http://www.nongnu.org/txr/txr-manpage.html#N-00F77525) section compares a Common Lisp and TXR Lisp example.
PC I’m coding on is running ubuntu with stumpwm (like vanlaser said). I then do scaled screen mirroring and the second (hdmi) output is connected to a [hd rocket](http://www.hauppauge.co.uk/site/products/data_hdpvr_rocket.html). USB from that, the microphone and the webcam are connected to an Intel NUC running windows 10 and OBS and I stream from that. Originally I did all coding &amp; capture from a single machine but I didn’t like how much it affected the fps of the GL stuff. I'd love that second machine to be running linux too but there are no drivers for the hd rocket. I'm using that device as originally I wasn’t planning on streaming and capturing to usb was great. I'm using a Samson CO1U microphone which is about £75 but sounds great even when I'm not talking directly at it. I think that's the lot :)
I looked into this a little while back in the hope that I could just generate a cffi binding using swig. It turns out that the [tensorflow c api](https://www.tensorflow.org/extend/language_bindings) isn't currently at a state that would be useful for anything beyond running predefined graphs. Building a lispy tensorflow binding seems like it would be a good use case for the LLVM CL implementation [Clasp](https://github.com/drmeister/clasp) once it's more mature, as the whole point of Clasp (as I understand it) is to allow one to use Lisp macros to work with big C++ libraries.
Thank you for the details, very helpful and much appreciated. Thank you also for that video series, and all the other videos, posts, and of course CEPL! In the future, would you consider sharing a bit of your emacs+stumpwm synergy setup? As I am struggling to go deeper into Emacs+Slime nuances, it would also be quite nice to see key-chords in a corner of videos. I know, it would detract from the main subject, but it would help understand what is happening "behind the Emacs+Slime scene". Thanks again.
Some of my generative work in CL using Vecto: https://fineartamerica.com/artists/burton+samograd Source code inthe artist statements.
No macros.
Pretty much nothing at this point. The reason more people don't use lisp is the lack of syntactic sugar, basically.
Lisp can do all these things, as can nearly every single programming language in existence. There's a lot of possible reasons for it, and they all compound and self-reinforce. Both libraries and tutorials ease entry. There need to be a lot of people using it to have the critical mass that will publish tutorials and libraries, so it's self reinforcing. That being said, there's plenty of software in all of these categories. https://franz.com/success/ http://www.lispworks.com/success-stories/ The PS2 game series "Jak and Daxter" actually *was* written in a special purpose lisp, called "Game Oriented Assembly Lisp" (GOAL) the compiler for which was written in common lisp.
[removed]
Absence of a decent package manager with versioning practically stops development of lisp's ecosystem.
&gt; The reason more people don't use lisp is the lack of syntactic sugar, basically. And the hill that represents emacs for most novice lisp users.
Did you try Qi or Qlot ? https://github.com/CodyReichert/qi https://github.com/fukamachi/qlot
also http://lisp-lang.org/success/ you'll find big applications with a complicate GUI, and much more. I think we (web surfers) have a bias to work on. There is no trendy fuzz on CL and that doesn't mean it is not used, or less than a new trendy language. Sometimes its use was even guarded secret, as a competitive advantage (so relates Paul Graham). As of today, we still see activity, new projects and new (big) players adopting it as their main application language (recently saw Riggetti, quantum computing (that already sponsored a Quicklisp feature, cool)). Some ideas of ready-to-use free software: https://lisp-journey.gitlab.io/software/
No. I used asdf-install and quicklisp only. It's great that these attempts to fix situation exist. Look what composer did to php, npm to javascript. Lisp also needs such tool. 
Is this really a lisp? It doesn’t share any of the syntax, but my god it has the most lispy macro system for any language like that
what?
Lisp doesn’t do these well or at all: - complete static type checking - definition of useful polymorphic types - declaration of polymorphic functions with a parametric type - GUI development is pretty difficult for free - complete, language-integrated lazy evaluation (its easy to make little lazy eval toys using closures though) - certain control over memory layout, e.g., array of structs - fast jump tables/computed GOTO (AFAICT, doing this in constant time is not possible in Lisp) You can imagine a lot more, and for many of these, macros aren’t a simple or even viable solution. A lot of things that Lisp (supposedly!) can do are often implementation dependent. And the intersection of all of the features that you want result in no implementations. For example, the intersection of the following: - ability to link static C libraries - ability to generate extremely fast numerical code with little effort - ability to generate smallish executables with tree shaking - free Some things Lisp can’t currently do, but could do if there was effort like - a great documentation system a la Sphinx. Not all this auto-generated crap - a great, free, cross-platform GUI library 
People don’t use Lisp because it’s a huge pain in the ass to get started with, compared to the multitude of other offerings. 
How does Python do it?
Qtools is free, and works cross-platform. I don't know what you qualify as "great" but it's been very serviceable for the plenty of native UIs I've made so far. I certainly wouldn't call it difficult to use, though. Regarding the intersection you mention, SBCL fulfils all of those points you listed, with the exception of tree shaking. With core-compression, the executables are suitably small for anything that isn't just a shell utility, though, so I don't really feel the need for it.
This has been [discussed here before](https://www.reddit.com/r/lisp/comments/38mwa9/) (and other times as well)
He's written a little about [why he thinks that S-Expressions are a bad idea](http://cl.cddddr.org/index.cgi?Essay%3AS-expressions%20are%20a%20bad%20idea&amp;l=) (that's from a note he wrote to Paul Graham giving early feedback on Arc).
But you can do bundles if you need? https://www.quicklisp.org/beta/bundles.html
[PLOT3](http://users.rcn.com/david-moon/PLOT3/) is a more recent version (2012).
I would say not. 1) Lack of tooling (quality linters, profilers, etc) and available high-quality IDEs, like Visual Studio, PhpStorm, PyCharm, Intellij IDEA, CLion - which are swiss-army knives and ready to do everything from refactoring to git integration (the only easy-to-use IDE - LispWorks - is quite expensive and not even close to any of them), or even text editors with good support for lisp outside of emacs/vim couple. 2) Quality of libraries, lack of documentation and tests 3) Historically arrogant community (secret weapon etc mantras based on some articles of some particular lucky guys). For younger breed it could be attractive however, to feel as a part of "elite".
As for documentation system I guess ccldoc is a good step forward: https://github.com/Clozure/ccldoc/
Python support is [built into tensorflow](https://github.com/tensorflow/tensorflow/tree/master/tensorflow/python) by the developers.
Submitted this since there was interest in Scheme Chip submission. It looks like it's related through tooling to the CLI verified stack: ftp://ftp.cs.utexas.edu/pub/boyer/fm9001/index.html Here's the other paper on DDD-based LISP: https://www.cs.indiana.edu/pub/techreports/TR544.pdf So, there's yall a triple whammy for my first submission to the LISP sub-Reddit.
\#1 tends to be caused by lack of demand when then causes lack of demand. There's a chicken and egg problem there. I'm told #2 isn't as much of a problem with CL but I'm more of a scheme person at the moment so I can't really say. I don't know how to evaluate #3
Is there an actual implementation of this, or is it just a design doc?
`#clim` on Freenode might be able to answer best on the topic. clim2 is Franz's fairly-recently-open-sourced implementation that AFAIK runs only on Allegro Common Lisp while McCLIM is a free-software implementation that is cross-platform. McCLIM looks nicer at the moment, too. :)
The reason why I'm here :)
Some languages can do things for which Lisp is not feasible. One application is things that fit into a very tiny space. You probably wouldn't use Lisp for writing a 512 byte boot sector. Lisp could be involved as the toolchain for developing such a thing (e.g. Lisp-based assembly language). Some applications/platforms are built around a specific language and everything else is locked out. Microsoft Excel isn't scriptable with Lisp (not from within at least, such that the script code executes inside Excel). Another example is the web browser: browsers use Javascript. The only way to use a Lisp dialect in the browser is through either a Lisp interpreter written in Java (such as EchoLisp) or a translator from a Lisp dialect to Javascript. There are probably many embedded systems for which the only supported high level language is C. For instance DSP chips and such. If you want any kind of Lisp, you have to port something yourself. So those are the kinds of barriers why you can use only certain languages in some situations, and none of those are Lisp dialects.
&gt; Historically arrogant community (secret weapon etc mantras based on some articles of some particular lucky guys). For younger breed it could be attractive however, to feel as a part of "elite". I have read some COBOL propaganda not long ago, and those people use exactly the same bullshit: COBOL is evidently a weapon that is used more often than you think, but the developers keep it a secret! 
I have never tried using tensor flow, but according to the documentation they use a RPC API, I could not find the documentation for it, but I bet you can use a sniffer to reverse engineer it, and then do whatever Python is doing from Common Lisp. Hacking this should be a fun project.
&gt; Source Locations &gt; As mentioned above, a token-stream keeps track of source locations. Nope, [can't do that with S-exps](http://cl.cddddr.org/index.cgi?Essay%3AS-expressions%20are%20a%20bad%20idea&amp;l=)! This is the TXR Lisp interactive listener of TXR 188. Quit with :quit or Ctrl-D on empty line. Ctrl-X ? for cheatsheet. 1&gt; (source-loc '(a b c)) (1 . "expr-1") 2&gt; (source-loc '(a b c)) (1 . "expr-2") 3&gt; (sh "cat foo.tl") (defun foo (a b) (+ a b)) 0 4&gt; (load "foo.tl") nil 6&gt; [func-get-form foo] (foo (a b) (block foo (+ a b))) 7&gt; (caddr *6) (block foo (+ a b)) 8&gt; (caddr *7) (+ a b) 9&gt; (source-loc *8) (2 . "foo.tl") 10&gt; (source-loc-str *8) "foo.tl:2" 
Achieve mainstream success. :(
Though not Python, Haskell and Rust has usable - something at least for MNIST - bindings. So it’s possible with Common Lisp I think. 
Yes.
Learning Lisp gives you a good understanding of programming languages and software engineering. It's also worth noting that a lot of features of modern programming languages are pulled from lisp. So even if you don't use lisp much at work, it's still worth learning.
You should. There is a pretty decent bundle of books that will help you get started available on humble bundle (https://www.humblebundle.com/books/be-a-coder-books). 
I disagree strongly. I think the basic syntax is much simpler and cleaner than other languages. The main reason a lot of people think they don't like the syntax is that they were not introduced to it properly. viz. they either got hit with it without being familiar with it, or were introduced to it by someone claiming that it was terrible, or were so fixated on C-like/java-like syntax that anything different was unacceptable.
[Take this test](http://wordsandbuttons.online/learn_you_a_lisp_in_0_minutes.html). I'm willing to bet even people who've never programmed a single line of code can get through it, and maybe even complete it 100%. If so, then you should be able to judge for yourself whether Lisp is interesting enough for you to devote some time to. If you really need help: http://web-artanis.com/scheme.html
It's improving: - https://portacle.github.io/ is a one-click away (ok, two) multiplatform and full-featured development environment: it ships SBCL, Emacs (slightly customized) and Slime, Quicklisp and Git. - on linux, `apt-get install sbcl` and optionnally `apt-get install cl-quicklisp` and we're good. - also [Lipstick](http://www.iqool.de/lispstick.html) for windows. We can use a Docker image and we can use other editors than Emacs (Vim, Atom, Sublime). https://lispcookbook.github.io/cl-cookbook/getting-started.html So now, I find it easier than, say, Clojure.
That doesn't have to be: Atom or Sublime work. They have less features I suppose though. https://lispcookbook.github.io/cl-cookbook/editor-support.html
Basic syntax: I agree, but I find some ways of doing too unusual and tedious. To trim whitespace, we had to `(string-trim '(#\Space #\Newline #\Backspace #\Tab #\Linefeed #\Page #\Return #\Rubout) s))`, seriously ? To concatenate strings, `concatenate` with a `'string` first argument. Why not, but could be better. (actually, all simple functions of [str](https://github.com/vindarel/cl-str)). We have to call to Alexandria to have a simple `read-file-into-string` function. `assoc-value` does not return the value, but the cons, so we have to `(cdr (assoc-value *))`… Alexandria and libraries usually fix that pb. I also like [cl21](http://cl21.org/) (aggressive syntactic sugars).
I hate it when someone takes the word right out of my mouth.
Every good programmer should know at least one lisp-like language and a functional language. It's not necessarily because you'll use these languages, but because they'll force you to understand different ways to solve problems, which will improve your work.
That's wrong; you didn't utter the word yet and therefore didn't properly consent to having anything snatched out of your mouth.
If you worry about the job market, advertise yourself as someone who knows "functional programming"
&gt; *But then again, the job market values Python, Ruby, Java, etc.* It does that now; what will it value by the time you're an expert? If you know Lisp very well, you kind of have a key to any language. Python, Ruby and Java are just collections of awkward syntactic sugar to some mutilated subset of Lisp semantics. 
After finding out how many other languages had been influenced by Lisp I decided to learn it. I knew that I would probably never use it at my &lt;dayjob&gt;, but if I could learn to solve problems in a way that was previously foreign to me, then it was worth the effort. I won't say that I "know" the language well, but it has changed how I look at certain problems. 
Necessity to use Emacs is not a solution, it is a part of a problem.
Not necessary - if you are on system side of things, better to learn C with a good C book (K&amp;R C Programing Language). Software Engineering is a as engineering as anything else, with practices which are language-agnostic, like layered and modular design, source control, code comments, documentation etc and has nothing to do with particular language.
CLIM2 from Franz has a lot of legacy code and works pretty bad on anything but ACL. That said here is a semi-working port to SBCL and CCL: https://gitlab.common-lisp.net/mcclim/gramps-clim2/ . This port works only on X11 but sources for other backends are left in code tree. McCLIM on the other hand was implemented from scratch and portability is one of its goals. It has more development focus, it is more complete and IMO it is more appealing as a tool to write applications in: https://common-lisp.net/project/mcclim/ . Of course it has some bugs and at this moment of time it works only on X11 server. McCLIM license is LGPL-2.1+ (until you use it as a library you may incorporate McCLIM in any setting with any license, see https://common-lisp.net/project/ecl/posts/ECL-license.html), and CLIM-TOS license is BSD (so you may do practically whatever you want with it). I'm saying that from perspective of person, who worked with code of both implementations. To sum it up: use McCLIM.
Yes. Especially if you are a complete beginner with no background in either programming or Computer Science/Engineering. Lisp, with its simple syntax, will let you focus on learning how to solve problems algorithmically, instead of getting bogged down by details. It's also one of the best language to learn functional programming concepts.
Nice!
A little perspective on the Franz CLIM implementation. CLIM was conceived as a standard for several platforms/implementations and several companies collaborated: Symbolics, Xerox and ILA were the initial collaborators. Later other companies joined: Franz, Lucid, Harlequin, Digitool, Illudium, ... The core code was written in a portable fashion and shared and licensed to the other users. Thus the goal of the core code is already portability among the participants. There is a portable substrate for things like streams and processes. But this does not include anything for CMUCL, SBCL, ECL, ABCL - because they either were not a target at that time or did not exist then. Also the CLIM source code was not open source / free software - and thus could not be ported to those by independent users. After the initial CLIM 2 effort, I guess there was no longer code shared. Also most of the more specific backends were not shared : Windows, Mac, Motif, ... Thus the Franz CLIM code is originally the portable CLIM code developed over a few years, with their fixes and enhancements - especially the backends they wrote. 
Vim, Atom or Sublime work as well: https://lispcookbook.github.io/cl-cookbook/editor-support.html
Leaning lisp is valuable, but at the current state of affairs it is valuable only because it opens your mind; it has little practical value in the real world (sorry, I am a Lisper too, but I believe this is the harsh reality). I think Lisp is a perfect *second* language. As first language to approach programming, Python is probably a more reasonable choice.
&gt; it has little practical value in the real world To be fair, as of late 2017, most Lisp dialects have all the necessary libraries for creating web applications, which is quite practical if I do say so myself. I've written a few web applications using Common Lisp that have been deployed in production, and they work great (and bring food to the table as well). **Edit:** Of course, I'm not saying that the current situation in Lisp world is perfect, far from it. We could use more libraries and more developers. 
You will not get an unbiased view here, but I would say that Racket (other schemes too, but Racket has better learning materials) is an excellent way to really _get_ programming, rather than just learning rote methods to make stuff work without knowing why. 
Clojure is a lisp with real-world value
&gt; I would say that Racket (other schemes too, but Racket has better learning materials) is **an excellent way to really get programming, rather than just learning rote methods to make stuff work without knowing why**. Couldn't have said it better myself. [SICP](https://mitpress.mit.edu/sicp/full-text/book/book.html) + [Racket's SICP language](https://docs.racket-lang.org/sicp-manual/) + [The Little Schemer](https://mitpress.mit.edu/books/little-schemer) (and its [sequel](https://mitpress.mit.edu/books/seasoned-schemer)) are the best resources for learning programming. 
What you describe is indeed possible, in technical terms, but since the number of Lisp shops/programmers is negligible, it requires a situation in which you can bring your own technology, do what you please, and interface with nobody else. Personally, in practice I've almost never found myself in such a situation (hobby projects besides).
As mentioned, the C API for TF has serious implementation holes. The Python API, which is the complete one, has performance problems, you can run into problems feeding fast evaluators, especially since you cannot multithread (in a way that would use multiple CPUs for userland code in Python). The C API can be used to feed faster in those situations. Overall I think it would be better to hack up a git checkout of TF to have a CL interface as native as the Python one (except that it could do multi-CPU). I don't see Clasp helping at this point if you want the high-level interfaces provided to Python.
There is a C api for tensorflow, but many of the things which make building models in tensorflow easy (like automatic computation of gradients for you’ve optimizers) are actually still implemented entirely in the python part of the codebase and so very difficult to access from other languages.
If you never programmed before I'd suggest [How To Design Programs](http://www.ccs.neu.edu/home/matthias/HtDP2e/), which is based on Racket. There is a nice MOOC based on this book [here](https://www.edx.org/course/how-code-simple-data-ubcx-htc1x). IMO, an awesome entry point to programming.
Some bootcamp founder said something that sounds truthy: &gt; start with whatever language your best friend knows, otherwise start with JavaScript If your friend is going to help you with Lisp (or racket or clojure), do it; otherwise -- well, before fully endorsing JS, lemme ask a little more about your background. What sorts of computer things are you fluent with already? Linux, bash, etc or just Windows and wizards? Have you dabbled with any programming before? When you say systems and infrastructure, can you give more concrete examples of things you'd like to do?
I struggled with some of the stumpwm bindings so I just remapped them to things similar to emacs and run with that, not sure how much I can help there but I have a slightly out of date copy of the file here https://github.com/cbaggers/.files/blob/master/.stumpwmrc
I'd start with Scheme (or Racket with DrRacket) and only then I'd go for CL+Emacs. I really love CL, but I do think that Scheme is much easier to get started with. After your friend knows Scheme it's pretty easy to explain CL in terms of it (Lisp-1 vs. Lisp-2, non-hygienic macros, etc.)
For CL they need to be using something like slime or sly, which right now ties them to emacs or vim. If they aren’t familiar with one of those already then sadly the best place to start is for them to get a little familiarity with one of those. Get them setup with a basic setup, not too flashy but try to get paredit in there if you can. Then show them how to start a session, how to use `C-c C-c` &amp; `C-c C-k` for compiling stuff and how a compiled function can then be used from the repl After that I think land of lisp is a really good starting place. I loved it but there are two issues: - it uses clisp so in a few places it deviates from the standard - it doesnt (IIRC) explain the stuff from above, namely, how to interact with lisp stretch goals: When the question of packages/namespaces come up, show how to use ql:quickload and then how to use something like quickproject to make a little project. This could be done before digging into land of lisp, but requires touching on packages sooner than necessary. If they are going to do land of lisp, it may be worth setting them up with clisp and then switching out for sbcl as soon as they are done. If they start with paul graham's 'ansi common lisp' then just get straight to sbcl, the errors are way better, it performs better and it adheres to the CL standard.
I appreciate this post for mentioning sly and not exclusively slime (although I use slime). Adding Atom slime may boost my appreciation
That's learning a completely different language, if you want to learn Common Lisp, learn Common Lisp. And if you want to learn Scheme, learn Scheme.
On a Mac you can download the Clozure CL IDE from the Apple macOS app stroe.
[Keycloak](http://www.keycloak.org/), and your app fronted by proxy is a good option. Two proxy options: * [Keycloak Security Proxy](http://www.keycloak.org/docs/latest/server_installation/index.html#_proxy) * [Apache Module](http://www.keycloak.org/docs/latest/securing_apps/index.html#_mod_auth_openidc) 
[Portacle](https://portacle.github.io/) includes an always-present buffer (reachable through `C-h h`) with information about keybindings and concepts, which should be helpful for people starting with Emacs.
There is an interesting project for teaching CL on github. Here is the link https://github.com/t-cool/cl-exercise if you find it good, please tell me. I hope that will help 
hehe and yup I'll start mentioning it often when it stabilizes enough for regular use. I haven’t tried it for 5 months though so maybe its time to test it again. Until then I cant recommend it as a real solution as newer users would struggle to know what errors are the editor iteration and which were CL and the misalignment of blame could make CL or slime look buggy, which would be a shame.
By the way, I started to use SLY recently, and will use it at least because of two features – stable backreferences to the results in a REPL and stickers (they are some sort of tracing, but you can rewind an execution and see which form returned what result). I mean, probably, it is better to go with SLY.
I know it's different, all I'm saying it's simpler and that OP should consider it since "pretty big beginners in coding" might not want to start their journey with this stuff: http://www.lispworks.com/documentation/lw51/CLHS/Body/m_loop.htm Scheme has all the essentials to get started, there's no reason not to learn both.
I've seen Lisp-1 and Lisp-2 several times and I wonder what does it means?
[removed]
Nobody starts with learning LOOP, but tail recursion isn't exactly natural for people coming from other languages either.
#'foo and foo in CL and just foo in Scheme. CL is actually lisp-n, as you can have variables, functions, packages, classes, types all sharing the same name.
Correct me if I am wrong, but lisp-n has to do with namespacing
Yes, it's all about namespaces, just that CL, often being labeled lisp-2, has more than two namespaces.
[removed]
The "n" in lisp-n isn't supposed to give a count of the different namespaces. It's just a question of whether the function position in a form has the same evaluation rules as the argument positions. 
But there are more entities than just functions. Scheme's define-record-type binds the name in the same single namespace, while it's a separate namespace in CL.
I understand that, but it has nothing to do with the LISP-1/LISP-2 terminology. You don't count up all the namespaces and then say it's a LISP-that number. It's just a distinction between two different versions of the language. 
Is there some central authority on terminology? Lisp-2 is a misrepresenting terminology. Even http://www.nhplace.com/kent/Papers/Technical-Issues.html says so, in the 12. Number of Namespaces section.
You can use whatever terminology you like, but since you kicked this off by saying that CL is "actually" a LISP-n rather than a LISP-2, you're hardly in a position to complain about the arbitrariness of terminology.
Lisp-1s use the same namespace for functions and variables. Lisp-2s separate those namespaces.
Ok, sorry, I wasn't aware that I'm not allowed to point inconsistent terminology. Will consult the definitive terminology guide next time.
No one wants to start with Scheme's format semantics http://schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-10.html#%_sec_7.2 or continuations http://schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_idx_570 or Scheme's pattern language... http://schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.3.2 You start learning Lisp with simple stuff, like in Touretzky 'Common Lisp: A Gentle Introduction to Symbolic Computation': http://www.cs.cmu.edu/~dst/LispBook/index.html 
Or try this book instead http://gigamonkeys.com/book/
also google lisp koans
I might have fallen for the Scheme is simple trope, guess I remember it as something else than what it is today at least. I might need to re-examine my whole Lisp is simple belief as well.
Simple are only small subsets of these languages. CL has a simple subset just as Scheme has one. If you look at the old SICP book, the Scheme they use there is not even making use of macros.
&gt; *bring your own technology, do what you please, and interface with nobody else.* No, just bring in your own technology and do what you please. Lisp doesn't imply you don't interface with anyone else.
I would avoid lisp oddities. Like, string manipulation is tedious (see (my) [str](https://github.com/vindarel/cl-str)), there are inconsistencies (a sequence as first or second argument), different functions for some different sequences (`first` doesn't always work), `loop` is not lispy,… I'd impose them some libraries (Alexandria, see [cookbook/data-structures](https://lispcookbook.github.io/cl-cookbook/data-structures.html), [for](https://github.com/Shinmera/for)) or even maybe make them use [cl21](https://lispcookbook.github.io/cl-cookbook/cl21.html). It's a CL library, we can mix it with regular CL in a project, so they won't have any problem reading other code or switch to regular CL later. I know I lost two much time dealing with sequence functions not applicable to arrays.
I would definitely recommend to learn lisp or scheme. I would also recommend SICP book because it gives pretty good understanding. I personally prefer Racket because there is a lot of examples on Rosetta code website. It is really helpful to learn basic operations like file reading etc.
I would avoid CL21, as it is poorly designed and poorly implemented. &gt; It's a CL library, we can mix it with regular CL in a project It's more or less an abandoned experimental library, without spec or sufficient documentation. CL sequence functions are applicable to all one dimensional vectors, as subset of arrays. 
The demo looks clean. Is performance on par with Lua?
This is quite interesting. I wonder if this can be implemented in an FPGA after I digest all the details. 
Thank you, very useful.
If you want Gnu Emacs on a Mac, you can use a real application of the latest version: https://emacsformacosx.com Another version is Aquamacs: http://aquamacs.org The version Apple provides is older and non-GUI. Common Lisp on a Mac alternatives: https://ccl.clozure.com/download.html https://itunes.apple.com/us/app/clozure-cl/id489900618?mt=12 LispWorks Personal Edition - useful mostly only for learning - the relatively expensive commercial version doesn't have limitations, though. http://www.lispworks.com/downloads/index.html 
Use Portacle, which is a package containing Emacs + SBCL + Quicklisp + Git, which should be a good enough software suite for you to start learning and developing Lisp. https://portacle.github.io/
[Portacle](https://portacle.github.io) seems to be the easiest way to get started right now.
My preferred version on Mac OS X is [Emacs Mac Port](https://github.com/railwaycat/homebrew-emacsmacport/releases).
Thanks for the link. That give me more insight into the subject
And *please*, if there's any issues with it, let me know by whichever means you find comfortable. Message me here, write me an email, or [file an issue](https://github.com/portacle/portacle/issues/new).
A gentle introduction is a wonderful starting point +1
just get Clozure CL (it's in the Apple app store and is free). It has its own editor (which is basically emacs) and you won't have to mess with slime or anything else.
Homebrew is used widely for development outside of lisp. So it would be just brew install sbcl emacs. Then grabbing quicklisp, which will install slime. Doesn’t sound as dire as you’ve described.
Also to note, CCL can be used from Emacs/SLIME just fine as well, and you can configure which lisp implementation to start up when launching slime. CCL's manual has more info on platform specifics. https://ccl.clozure.com/manual/
Thanks! That's a good question. However, I haven't seen any benchmarks comparing ECL to Lua - or anything else. ECL performance is discussed a bit in [this GitLab issue](https://gitlab.com/embeddable-common-lisp/ecl/issues/170) in which - for whatever it's worth - one of the maintainers says, "ECL applications after compilation are reasonably fast".
The [Common Lisp Cookbook](https://lispcookbook.github.io/cl-cookbook/getting-started.html) gives up-to-date solutions, namely, Portacle. You can send PR to add Mac instructions if needed.
I myself found this guide to be useful, as it explains how to make SBCL, Emacs (Aquamacs in his case but I went with a brew-installed emacs, I'll explain below), QuickLisp and Slime to work together: http://www.jonathanfischer.net/modern-common-lisp-on-osx/ My install of emacs went like this: brew install emacs --devel --with-cocoa --with-gnutls --with-imagemagick@6 --with-librsvg --with-mailutils --with-modules (I used --devel because the full-screen mode is broken - emacs crashes when closing a window *ahem* I mean, a frame - in the stable emacs and fixed in 26.x) I later went on to add Spacemacs to help me deal with my emacs config, but that's a topic that goes beyond getting started with emacs + common lisp on a Mac. About Melpa itself, emacs comes with Elpa by default (the GNU software repository), but Melpa is more complete. Easiest way I can tell you to activate it, is to install emacs as above (the --with-cocoa will give you the GUI version), then: M-x RET package-install And from the Package menu in the menubar, select Customize, then Package Archives and add the melpa archive Name: MELPA URL: https://melpa.org/packages/ That should get you started. Also, nothing stops you from using any other IDE and loading files in the SBCL (or other) REPL, rather than learning Lisp AND Emacs at the same time. Though I did so myself and have been quite stricken by emacs... ;)
We will hold a seminar using Practical Common Lisp. We made a learning system using lem, a common lisp IDE. https://www.youtube.com/watch?v=BCIvF8MTc9A
Thanks, all, for your suggestions. It will be a couple days before I can investigate.
As indicated in one of the replies, CCL Clozure has its own simple IDE that should get you started. "Practical Common Lisp" was written with the renewed interest in Lisp at the beginning of the century (fells good to say that), when Slime was just starting. So anything you can read in there (in termes of "system" settings) is already more than 12 years old. The current emacs (Apple has not updated the shipped version for a while, and probably won't) has a full fledged package manager that fully support Melpa, and you can install right awa all sorts of CL related packages. But before you go that way (emacs is a UI paradigm in itself), you really should start with the much simpler yet complete IDE that is provided with Clozure.
Also, you can install slime inside CCL, if you wish.
I had to follow the same typical path to set up LISP on a Mac. I used Youtube to search for hints as well. I never managed to get anything done with Slime or SBCL. Nothing. I screw up my Emacs config for sure. And every 6 months, I'd try again. I'd learn again key strokes combinations and try again to make sense out of it. I would end up with Slime in a window, an editor in another one. No way to connect a LISP program I would type in the editor with Slime/SBCL. And I don't know how to edit, save, run anything in Slime. A disaster. I gave up finally and switch to using/learning Javascript, Java, Python and Clojure on the web. I use web interfaces seamlessly to write, test and run my code snippets. 
Oh neat, didn't know this.
I have to admit I have a problem with Emacs - I get overwhelmed when I try to use it, so for now I just use my editor (Geany) when I try to write Lisp code. 
&gt; And I don't know how to edit, save, run anything in Slime. Editing files is usually done by typing on a keyboard. Last I looked Slime didn't change that. Saving files can be done by using the 'Save' command in the menu. Slime does not change that. You run Lisp code by typing Lisp code to a Slime repl buffer and pressing return. &gt; I gave up finally and switch to using/learning Javascript, Java, Python and Clojure on the web. I use web interfaces seamlessly to write, test and run my code snippets. Sounds like a good idea.
So helpful. Many thanks for your help. 
So *qooxdoo* is a JS framework without any JS? Huh?
It is better to install Roswell, like that: brew install roswell Then install CCL ros install ccl-bin ros use ccl-bin ros emacs The last command will start an Emacs, configured to use CCL with the Quicklisp available. It is also easy to switch to another implementation. Just do ros install abcl ros use abcl To switch to ABCL, for example. 
Use SLY instead of SLIME. It is much better!
Will you speak in English during the seminar ? Will the seminar be available on YouTube after the initial stream ? Thanks.
This way you loose all interactivity and fast feedback from the language. Read "Software development at 1 Hz" article to understand what I'm talking about: https://hackernoon.com/software-development-at-1-hz-5530bb58fc0e
Right ! It should be Qooxlisp, will edit.
This is exactly the experience all newbies in CL get, which is unfortunate and sad. Have you tried to install free Lispworks Personal? You should have no troubles to start learning Common Lisp with it. There is Clozue Common Lisp for OSX as well, its free and comes with an editor and repl. Its even available in Mac AppStore (for free). Its great implementation and more user-friendly (IMHO) than SBCL. P.S. Your experience with installing Emacs via package manager shows that you are not familiar with package managers on OSX, it has nothing to do with Common Lisp.
Yes, I know :-(
In what way are you overwhelmed? You could define your own keybindings if the emacs ones feel awkward to you. You could also try using emacs in CUA mode (standard copy paste key bindings)
I am using Sly, mostly out of interest, but I haven't used it in a way that made me go "wow", when compared with Slime, but then I am reasonably new to it... is there something specific that it does that makes your life easier/better?
I have quite a few package managers installed. There is no One True Package Manager, because as soon as it appears that there is One True Package Manager that everyone is using, there will be another. I have more package managers installed than I do copies of emacs. Probably more than twice as many.
A male colleague mentioned to me I was just probably mansplained how to use a keyboard to enter a LISP "program". I can't agree more. Thinking of it, this type of condescending comments is more typical of Usenet/Reddit than of the rest of the LISP sphere, which I found very helpful overall, except for this very senior, brilliant, admirable, clever and extremely knowledgeable LISP guru u/lispm. 
Please provide information as to why it is better?
I never used Mac myself, but I think installing brew is pretty much the starting point of anything related to programming, not particularly lisp, no? (I mean I know there are some other choises like macports, but they should also be providing the equivalent package, especially the important ones)
Hey, thanks for the advice. I know it's just keybindings but it's so different from anything I'd used. I'm not a fan of Atom, if I'm going to switch I may as well try Emacs again. I didn't know about the CUA thing though, I'm going to try it.
If you had asked a real question, instead of posting vague statements which are totally unlikely ('can't save anything in SLIME'), you would have likely made progress. There is a reddit group dedicated to help people trying to learn Lisp: /r/learnlisp . Instead of looking Youtube videos, try asking real questions and real people might help you. 
If you are new to programming in general then Portacle will be easier. If you have a good experience in python/ruby/node and care about server deployment, then roswell is a good choise, it can swap implementations, provides consistent tools for accessing lisp from command line and manipulating(writing, compiling, launching, distributing) a lisp script, CI integration...
This seems like FRP.
I wonder why this post has been down-voted so much. I found the question relevant and interesting, and the answers very interesting, too.
No, something like this? (defmacro with-hash ((&amp;rest decls) hash-table &amp;body body) (alexandria:once-only (hash-table) (loop for (var key) in decls for key-sym = (gensym "KEY") collect (list key-sym key) into key-let collect (list var `(gethash ,key-sym ,hash-table)) into sym-mac finally (return `(let ,key-let (symbol-macrolet ,sym-mac ,@body)))))) (let ((hash (make-hash-table))) (with-hash ((foo :foo) (bar :bar)) hash (setf foo 10) (setf bar (list (incf foo)))) hash) 
Thanks. Will test it out later. I still have a rudimentary understanding of Lisp.
No, but you could make one pretty easily: (defmacro with-hash ((&amp;rest bindings) hash-table &amp;body body) (alexandria:once-only (hash-table) `(symbol-macrolet (,@(mapcar (lambda (binding) (destructuring-bind (symbol &amp;optional (key `',symbol) default) (alexandria:ensure-list binding) `(,symbol (gethash ,key ,hash-table ,default)))) bindings)) ,@body))) (defparameter *h* (make-hash-table)) (setf (gethash 'foo *h*) :foo (gethash 'bar *h*) :bar) (with-hash (foo (b 'bar) (z 'baz :none)) *h* (print (list foo b z)) (values)) ; =&gt; ; (:FOO :BAR :NONE)
What happens when you try to set something which does not exist in the hash-table?
I see people have given your answer already but I was wondering what you would use it for?
http://clhs.lisp.se/Body/m_w_hash.htm with-hash-table-iterator
There's a with-keys macro in [cl-hash-util](http://quickdocs.org/cl-hash-util/)
I use REPL back references every day. Try to type #v in the repl. Also, copying of objects and function calls from stack to the repl is very useful. Object inspection works more intuitive. You just put cursor on the object and hit enter. Slime sometimes copies it to the repl, sometimes opens inspector. Stickers also are useful. View demo here: https://joaotavora.github.io/sly/#A-SLY-tour-for-SLIME-users
I've provided. Please, read my comment above. 
In RUTILS there's a generic WITH macro that can handle hash-tables. Here's an example of its application to a hash-table that has keys "key1" and "key2": (with (((val1 "key1") (val2 "key2")) ? hash-table)) (print (+ val1 val2)))
Before using such macros, as yourself: Will it really vastly improve your code by using it?
Lisp doesn't excel at the smallest scale. The base language can be verbose for small things and lacks built-in amenities. Superior support for user-defined abstraction doesn't pay until there's enough code to abstract. Running programs require a large, monolithic runtime. Not being statically typed, it also isn't the best choice for very large scale "pack programming." Lisp is very good at the upper limit of what a single developer or small team can do. 
https://github.com/azzamsa/awesome-lisp-companies#sweden Huh Michael Minock was my databases lecturer while he still worked at KTH. Nice guy, called people (no students, just in general :-)) numb skulls and made a lot of beer references. http://www.sciencedirect.com/science/article/pii/S0169023X09001499
Thanks for the list! It requires some proofreading though. E.g. I tried one random company - adUup and it seems to be dead with last traces from around 2008 Another one, StreamTech in the Netherlands disappeared around 2012
Can3p, thanks lot for suggestion. Sure, some of them dead. But I don't know each of them. I will add description (or icon ) to dead company, you can inform other dead company here, [Dead Companies #1](https://github.com/azzamsa/awesome-lisp-companies/issues/1)
wow, that's great story. and thanks for the link. :)
I find this list more embarrassing than inspiring. It would be worth doing some proper research first.
And tomorrow the job market will value something else. What never changes is the need for experienced coders who actually know shit about anything that matters, and Lisp is one of the stepping stones to get there.
ITA is no longer a lisp company, or a company for that matter...
Sorry for pasting the link early here. Actually I take all of them from Christensen's List, my mistake is putting the link early, Actually I will tidy it up in the following days, because I still have some task at hand. I think I am too excited till I pasted it early.
By mean, ITA didn't use any Lisp anymore ?
ITA got brought by Google. The Lisp system built by ITA *is* used by Google after the purchase, though I'm not sure of the current status. Also, the old Untyped company that used PLT Scheme/Racket is also dead. 
&gt; Sure, some of them dead. But I don't know each of them. [The original list](http://pchristensen.com/blog/lisp-companies/) contains links to each company website. Many of them are now just an empty page or return 404 error status. You could start by going through each link and remove company that has dead homepage.
ITA is not longer a company, it was sold to google in 2010 or 2011, Google still uses QPX which is written in lisp.
&gt; the Peter Christensen's list, which you based your list on, was last updated on 2008. No wonder why almost all of the info on the list are outdated. Sure, I sure it will be accurate in next week :), I need to do extensive research. Thank you so much for information.
Thank you so much for information. I will update the list.
I began a (very) small but up-to-date list here: https://gitlab.com/lisp-journey/lisp-journey.gitlab.io/blob/master/content/who.md
To bind a variable to a part of a structure, then *pattern matching* is a good generalization compared to a random `with-` macro. Such a macro is not able to integrate with other groups of destructuring macros, making it single-purposed, ad-hoc solution. (ql:quickload :trivia) (use-package :trivia) (defpattern hash (&amp;rest key-value-pairs) (with-gensyms (h) `(guard1 (,h :type hash-table) (hash-table-p ,h) ,@(iter (for (key subpattern . rest) on key-value-pairs) (collecting `(gethash ,key ,h)) (collecting subpattern))))) (let ((h1 (make-hash-table)) (h2 (make-hash-table)) (h3 (make-hash-table))) (setf (gethash :a h1) 1 (gethash :a h2) 2 (gethash :a h3) 3) (match (list h1 h2 h3) ((list (hash :a a) (hash :a b) (hash :a c)) (assert (= 6 (+ a b c)))))) 
We still do active development on common lisp, and our changes are sent back to the project!
[removed]
That's great to hear! ITA's QPX is one of the great example of real-world Common Lisp software, and it's great to see it continues to flourish under Google. (Also, does this technically means we can say that Google uses Common Lisp (even if it's just one department/division/unit/whatever :P)?
Sounds interesting. I know Racket has a lot of potential in many domains, esp. web development. Sadly, that's a pretty hefty price tag for a book, even with the 20% discount.
I'm a developer on QPX by the way. We have a decent size staff currently developing and updating QPX on a daily basis! Many of our team moved onto QPX because they could get to program in lisp. We even have some dev work on SBCL itself. 
&gt; (Also, does this technically means we can say that Google uses Common Lisp ( they even have a style guide :P https://google.github.io/styleguide/lispguide.xml
other than QPX do you see any other investment into lisps at google?
The link for proof, if it still looks like this: https://www.amazon.com/gp/bestsellers/books/3981/ref=pd_zg_hrsr_b_1_5_last
Please don't spam the forum with this rubbish.
I figured there might be at least some semblance of a sense of humor here :-\ I apologize. I'll take my slow cooker recipes and move on to greener pastures.
Quite a sensible guide! Why should we not use NCONC though? I get that non consing functions can trip you up, but to avoid completely?
All good stuff, thank you!
Thank you for the constant effort.
The price is ok in my opinion compared to similar books written in Python.
ORM is a bad thing. 
I plan to get back to SICP!
I plan on finishing the GTK release of nEXT http://github.com/nEXT-Browser/nEXT Feels so close!
Cells [presentation (ILC2003)](https://raw.githubusercontent.com/kennytilton/cells/master/doc/Cells-ILC2003.pdf) &amp; [wiki](https://github.com/kennytilton/cells/wiki) 
I stated writing a rive script interpreter in Common Lisp, and I plan to blog about it. 
I plan to stop worrying for my career and procrastinating less because of that. I'd like to do more Scheme work: - Continue my work on [wiredtiger](http://source.wiredtiger.com/) bindings for GNU Guile - Continue to work on [Culturia](https://github.com/a-guile-mind/Culturia), and finally index StackOverflow, Wikipedia, HN and reddit and make it my primary way to search the web. - Continue my work on a dynamic blog called [presence](https://github.com/a-guile-mind/presence) and maybe connect it to the federation I hope that GNU Guile JavaScript backend can somehow be executed in browsers because TCO is implemented in browsers or because someone implemented TCO in GNU Guile JavaScript backend.
I'll continue with [`cl-bodge`](https://github.com/borodust/cl-bodge) and [`trivial-gamekit`](https://github.com/borodust/trivial-gamekit) development. At this moment I'm working on [`cludge`](https://github.com/borodust/cludge) - visual tool (editor) for `cl-bodge` to help simplify some gamedev tasks that are better solved in WYSIWYG manner.
TCO for JS is already implemented in most modern browsers.
Continue trying to learn how to write programs to an acceptable level of quality.
&gt; Guile JavaScript backend can somehow be executed in browsers Like [biwa](http://www.biwascheme.org/index.html)?
Common Lisp UltraSpec.
Unlike biwa which is an interpreter, GNU Guile Javascript backend generates JavaScript code.
Oh, I see. My bad. :)
only safari implements proper tail call see https://kangax.github.io/compat-table/es6/#test-proper_tail_calls_(tail_call_optimisation)
I plan to work on new ways to find bugs in lisp implementations.
&gt; Many of our team moved onto QPX because they could get to program in lisp. Sounds like something I'd have done myself! :P Man, I'd love to come and work with you, too bad I'm on the other side of the world (assuming you guys are based in the US).
The advise against NCONC is because, IIRC, modifying lists destructively in general can often lead to unexpected side effects/bugs. Especially if there are references in other parts of the program to the list you are (destructively) modifying. I remember reading a blog post that gives an example of a subtle bug that can result from performing a seemingly simple modification on a list using one of the destructive functions, but I can't find a link to the post.
PicoLisp
*Lisp
The hacker hacker.
There are a lot, there's elisp (emacs), the dialect in Autocad (forgot the name of it), Clojure, uLisp, TXR Lisp, MAL, Racket, Shen, etc, etc 
Chicken 5 should be out soon, and that means updating a dozen eggs.
I'm planning to rewrite rest of the Weblocks and to write a full documentation for this frame work. This way it become useful for everybody, not only for me. Also, will post some articles (in Russian) for Common Lisp newcomers. Hoping some of my colleagues at Yandex will start using CL as their second language. Happy New Year, let's most our wishes will become the reality!
My hope is to write some type of substantial sized application. So far all I’ve really done is advent of code stuff, and I’m not super strong when it comes to structuring things. 
T (aka Yale T)
If you search before asking, you get this list from [wikipedia lisp page](https://en.wikipedia.org/wiki/Lisp_(programming_language)) - Arc - AutoLISP - Clojure - Common Lisp - Emacs Lisp - EuLisp - Franz Lisp - Hy - Interlisp - ISLISP - LeLisp - LFE - Maclisp - MDL - newLISP - NIL - Picolisp - Portable - Standard Lisp - Racket - RPL - Scheme - SKILL - Spice Lisp - T - Zetalisp See the [**Timeline**](https://en.wikipedia.org/wiki/Lisp_(programming_language)#Timeline) to know what dialect are disappear and what is not.
Finishing A Gentle Introduction, go to PCL. then learning to build intermediate web app with CL.
Well, I'll probably just continue working on what I've been working on in 2017. * [Trial](https://github.com/Shirakumo/trial) a dynamic game engine * [Lichat](https://github.com/Shirakumo/lichat-protocol) &amp; co, a novel chat protocol including server- and various client-implementations And of course maintaining and advancing the dozens of other projects I have as needed.
If it hasn't changed (haven't touched that thing in almost 30 years), it's simply AutoLISP.
https://github.com/asciian/papyrus is the link to the literate tool used.
Lisp Flavored Erlang
Can you provide some links and expound more on this GNU Guile JavaScript background? It's something I can try right now? I know of Guile, but I haven't heard of this. It's comparable to Clojurescript?
I use the one that comes with whatever web engine port nEXT is running on. There is an interface one has to implement to make a port to a new system, and one of the functions required by a given port is to be able to execute js. It's actually really cool because whatever web view and GUI technology you want, you can port nEXT to it really easily
A couple more: Hy (Clojure-like lisp on Python) and Urn (a mix of CL, Clojure, and Racket that compiles to Lua).
I want to get more devops down, this year. Get better at dockerizing, CI, testing.
Yeah but that way he won't get any upvotes!
[Lux](https://github.com/LuxLang/lux) can also be added to the list
It is not as complete as CL-PPCRE, but a bit faster.
Why is it faster?
I was wondering that as well, I tried to look at code but I am not good enough code reader to extrapolate why.
The time information does not look very useful. Either increase the resolution or the runtimes...
Art of the Metahacker Protocol
Not dialects. Those are completely different languages. Common Lisp and Scheme are at least as different as Java and C++ and nobody calls these "dialects of C".
I don't plan (as always): I'll simply let new inspirations happen, and follow them (time permitting).
&gt; 16 lambdas converted Looks like it's timing the one-time compilation cost.
My main project, [cl-patterns](https://github.com/defaultxr/cl-patterns), a Lisp library primarily written for algorithmic music sequencing. I also contribute to one of its supported audio backends, [cl-collider](https://github.com/byulparan/cl-collider), which is a Lisp interface to the SuperCollider sound server. I'm also working, albeit slowly, on a game in CL. Hit a lot of roadblocks with the SDL/SDL2 libraries but I think I'm finally getting somewhere.
[Pixie](https://github.com/vindarel/languages-that-compile-to-python#pixie-a-lightweight-and-native-lisp) built in RPython, the same language PyPy is written in, and as such "supports a fairly fast GC and an amazingly fast tracing JIT".
I don't have any definite plans, but I got really interested in DSP topic and will probably do some thing around it (not necessarily sound processing).
I've run the benchmarks myself (after simple modifs in my [github clone](https://github.com/joaotavora/regex)) and confirm the author's claim. It appears to be ~2x faster (on some reasonably old SBCL I have here). I ran each search 100 times to increase the time resolution and rule out the one-time compilation cost, which doesn't appear to have a great effect. ``` ./t/glep.lisp "def.*" ./src/core.lisp ./src/parser.lisp ./src/regex.lisp 0: (TEST "def.*" ("./src/core.lisp" "./src/parser.lisp" "./src/regex.lisp")) |======== ppcre-glep ========| 35 hits Evaluation took: 0.311 seconds of real time 0.311349 seconds of total run time (0.293457 user, 0.017892 system) 100.00% CPU 16 lambdas converted 622,690,900 processor cycles 82,866,368 bytes consed |======== glep-interp ========| 35 hits Evaluation took: 0.144 seconds of real time 0.143949 seconds of total run time (0.128107 user, 0.015842 system) [ Run times consist of 0.007 seconds GC time, and 0.137 seconds non-GC time. ] 100.00% CPU 288,014,188 processor cycles 104,519,520 bytes consed |======== glep ========| 35 hits Evaluation took: 0.172 seconds of real time 0.172128 seconds of total run time (0.138016 user, 0.034112 system) [ Run times consist of 0.033 seconds GC time, and 0.140 seconds non-GC time. ] 100.00% CPU 344,296,289 processor cycles 82,481,296 bytes consed 0: TEST returned NIL ~/S/L/regex ❯❯❯ ./t/glep.lisp "a+b*.*[^abc]$" ./src/* master ⬆ ✱ 0: (TEST "a+b*.*[^abc]$" ("./src/core.lisp" "./src/parser.lisp" "./src/regex.lisp")) |======== ppcre-glep ========| 249 hits Evaluation took: 0.426 seconds of real time 0.425628 seconds of total run time (0.396445 user, 0.029183 system) [ Run times consist of 0.007 seconds GC time, and 0.419 seconds non-GC time. ] 100.00% CPU 41 lambdas converted 851,350,373 processor cycles 145,050,480 bytes consed |======== glep-interp ========| 249 hits Evaluation took: 0.400 seconds of real time 0.398928 seconds of total run time (0.346727 user, 0.052201 system) [ Run times consist of 0.042 seconds GC time, and 0.357 seconds non-GC time. ] 99.75% CPU 798,252,674 processor cycles 345,577,888 bytes consed |======== glep ========| 249 hits Evaluation took: 0.180 seconds of real time 0.179670 seconds of total run time (0.166460 user, 0.013210 system) [ Run times consist of 0.010 seconds GC time, and 0.170 seconds non-GC time. ] 100.00% CPU 359,459,408 processor cycles 198,739,072 bytes consed 0: TEST returned NIL ~/S/L/regex ❯❯❯ ```
There is a dedicated page in the Wikipedia for this topic: https://en.m.wikipedia.org/wiki/List_of_Lisp-family_programming_languages 
There is a dedicated page in the Wikipedia for this topic: https://en.m.wikipedia.org/wiki/List_of_Lisp-family_programming_languages 
Hi, I'm author of this library. Thank you @bsd_lore. CL-PPCRE uses CLOS as regex object and `make-instance` is always slow. CL-PPCRE is fastest by `compiled`and `bmh` feature in This benchmark. This project remarkable points are size of project and faster than non-optimized cl-ppcre. The size of this project is under 300 lines but the size of cl-ppcre is 7000 lines.
C++ is definitely a dialect of C. C programs can easily be developed such that they are portable to C++ compilers. Not only as an amusing exercise, but as production. The implementation of TXR compiles with GNU C++ if you want; you just `./configure cc=g++` and off you go. I do this before every release. (Not true of Java versus C++ or C, of course; point stands there.) 
&gt; If you search before asking, you get this list from wikipedia lisp page You didn't include the 'else' clause, so I'm a bit lost. I thought this was a lisp forum. *laughing*
I find the "Emacs is hard" premise a bit overblown. Emacs+SLIME took me longer to understand than, say, PyCharm, but it still wasn't a real pain. 
&gt;Not being statically typed, it also isn't the best choice for very large scale "pack programming." Very large production codebases have been successfully done in Lisp in the past. It is a myth to think that you need static typing for large codebases. What you need is very good namespacing features and very high potential for abstracting stuff. Lisp, at least Common Lisp, has both in spades 
**This list has been updated at 2018-01-02**
&gt;whereas Common Lisp is a Lisp-2 and has different namespaces for functions and values. Note: Not just functions and values: there are many separate namespaces in CL: for example keywords, symbols, functions, and classes, reside in their respective namespaces.
your joke is gold.
Lisp is not very good at namespaces - packages are not hierarchical, no "import as" feature to avoid local symbol conflicts (shadowing import is not enough). no good build system to figure out package dependencies automagically (if you :use one package in another, you have to manually specify order of files in asd file, which becomes messy real quick), etc. 
I am not sure how Reddit handles threads notifications, (this is the author answer)[https://www.reddit.com/r/lisp/comments/7nf4an/regex_regular_expression_library_in_common_lisp/ds22vrm/]
Thank *you* very much /r/asciian, it is quite inspiring to see a new library of this quality.
The problem is that you need to "understand" and "study" Emacs(no it is not that hard - in like 5 years of daily use and after implementing a couple of packages you can be efficient enough with it ;) ), which diverges one from the actual goal - to study CL.
- keep up a slow grind on CEPL - learn more about bidirectional type inference by making a toy checker for a static subset of CL - learn about SIMD (using SBCL's VOPs to expose the instructions)
By the way, you can always contact me at the Gitter chat. 
Using CL, MithrilJS (v/Parenscript), and PostgreSQL: 1) OpenID Connect based SSO for our applications; 2) data warehouse and reporting; 3) Apple PassKit versions of our tickets; 4) rewrite of our POS.
So am I correct that this REGEX engine is also a backtracking one? Not a traditional engine that can only match regular languages? It would be nice to have a good option for linear time matching in cases where we don't need advanced perl regexp functionalities....
I stopped working on my Lex/Yacc based Lisp interpreter last year in order to learn more C (as required by Lex/Yacc). I've now learned a decent amount of C and would like to revisit/finish my interpreter. It's just a toy and will never be used for anything, but it's a right of passage and I really would like to finish it. Also, if nothing else, it will have forced me to become somewhat-proficient with C.
The backend of such a system could use this DFA/NFA code here: https://bitbucket.org/tarballs_are_good/regex/src
Thank you, cg84. 
It would probably be better to ask directly its author, /r/asciian.
This is not very attractive: &gt; UnCommon Web is able to use multiple HTTP server backends: Apache + mod_lisp, aserve (and portableaserve), or araneida. UnCommon Web also contains a small pure lisp http server. And this: &gt; UnCommon Web provides developers with the illusion that web pages are nothing more than function calls. reminds me to [Snooze](https://github.com/joaotavora/snooze).
Well yes if you look at the araneida part there. I guess I better delete that part for avoid innecesary noise on the main subject: UCW is a great and useful web framework. You can use their own http server, which works pretty good. Currently in my company we are using UCW and it's giving us great results. I don't know anything about Snooze so I can't compare. Greetings!
&gt; Common Lisp and Scheme are at least as different as Java and C++ Honestly, Common Lisp and Scheme are much more similar themselves, than Java and C++. Java compiles to bytecode, C++ usually compiles to machine code. Scheme and CL compilers compile both to machine code, usually. Java has single inheritance and all objects derive starting from a single class, C++ has multiple inheritance and objects do not derive from a single class. Common Lisp and Scheme are able to use mostly the same kind of OOP (there's a CLOS variant implemented in Scheme) C++ by default has manually managed memory (except for Microsoft.NET Managed C++), Java is by default a language with automatic memory management. Both Scheme and CL are languages with automatic memory management. etc.
&gt; The problem is that you need to "understand" and "study" Emacs(...), which diverges one from the actual goal - to study CL. &gt;From my personal experience I started to use Emacs to study CL and got stuck with tinkering Emacs, Any newbie can download Portacle, the Portable Common Lisp Environment, and have a fully configured Emacs. No need to tinker with it at all; it has already configured a lisp implementation (sbcl), parenscript, SLIME, and other goodies. So you can focus in coding. Emacs is still in the way, but I only needed a few hours to understand how to use Emacs. You don't really need too much Emacs to program in Common Lisp (again, through the use of Portacle). IMO most Emacs tutorials out there are way bigger than they should since they teach how to use Emacs for general purpose and include key combinations that are not really needed if you're under a GUI and with a mouse. To be honest, the minimum combinations a newbie to CL ought to know to be able to use Emacs are: Control-W cut Meta-W copy Control-Y paste (I blame those three for 80% of the difficulty in learning Emacs) Then the next most important key combination to know is Control-h-b, which will explain all the key bindings in the current mode. Which means, all the key combinations will be there to be seen. Immediately afterwards, Control-S for searching, and Control-G for generally cancelling any input. Now we can just code in Common Lisp: Control-C-K compile file Control-X-S save Control-C-C compile fragment The other thing left to learn to the newbie is the paradigm of buffers versus windows, which IMO is totally worth learning since it greatly enhances productivity. Afterwards they can use Control-X {0,1,2,3...} to set the screen layout to their liking and Control-X-B to find a buffer. It isn't hard, really, considering that the user is supposed to be a **programmer**, not a baby or a granny. (Although some grannies may already have customized their own Emacs in the late 70s!) 
&gt;Common Lisp UltraSpec. This is a great project, many thanks for working on it!
The problem is not that it is just a few keystrokes to learn. The problem is that one have to still retrain ingrained in brain (yes specially if its a programmer!) habits and hotkeys just to try out a new language! Also terminology - Meta? wtf ask normal people who never worked on an old terminals. Buffers? Windows? Frames? Kill? Yank? etc all straight from 70s. That all will definitely block any normal (not geek/ fan of old tech) to go even further. Regardless how easy it was for you personally, to break habits just to learn a new language (when you just want to try it out and not to spend next 20 years with it since employment possibilities for such an investment are pretty bleak) it is a little bit too much.
In www.ikkiware.com we are developing a entrepreneurs oriented Social Network, (www.huuii.com) which includes productivity tools (called Huuii Smart) a social network (Huuii People), a Polls tool (Huuii Polls) and a web site creator tool (Huuii Sites). We are located in Mexico. 
&gt; And of course maintaining Portacle is a godsend. Thank you very much Shinmera!!
May I know, what dialect you are using ? Is there any link to your project blog/article about CL/Scheme ? 
Hello /u/Kyo91, That's Good question. REGEX is a backtracking one. 3 years ago when I begin to write this library, the idea was the relation between call/cc and regular expressions. you can see cl-cont in my code. I wasn't taking care of the speed. But in the result, as you know, the code of library became small and clear and faster than ordinary. If I'm starting new project, I would like to write it as you says.
As far as I can see the options are: 1. qualify the symbols 2. export the symbols 3. ignore the package in your macro and just use the name Number 2 is the usual approach. Export the relevent symbols and let your users decide how they want to consume your library. For number 3 we can note that `(string= :foo 'foo) -&gt; t` so if you use this in place of `#'eq` in your macro (and do the equivilent for `find`, `case` etc) then you don't necessarily need to export the symbols. You are then essentially making [designators](http://www.lispworks.com/documentation/lw50/CLHS/Body/01_dae.htm) for your DSL's terms (I hope I got this terminology right). You may have also noticed that you didnt need to qualify `and` or `or` in `'(rashell.posix:and (rashell.posix:has-kind rashell.posix:regular )(rashell.posix:name "*.lisp"))`. The reason is that those symbols arent interned in your package, they are from the `cl` package. They only need to be qualified when in a package which does not `:use` the `cl` package.
I was looking for some Advent of Code 2017 solved using Common Lisp, this seems like a nice collection. (I am not the author.)
I witnessed the power of Loop... interesting. 
Another vote here for Portacle. It's just perfect, at least for newcomers and intermediate-level users like myself. Just install and open, there you are, with SBCL, SLIME, ParEdit, and other tools already installed and configured. 
&gt; Achieve mainstream success. :( Funny thing is, Lisp was actually a mainstream language. Common Lisp existed because the industry used some lisp dialects (Maclisp, etc) in production for doing "serious stuff" and needed to unify those dialects. It has been used in production software, some very serious software like... the autopilot of the Deep Space 1 spaceship. Nowadays it isn't a **popular** language, but I'd contend it's still a mainstream language, even more considering that it appeared in the era of FORTRAN and COBOL. 
&gt; Buffers? Windows? Frames? Buffers vs windows vs frame is a much more powerful way of working with files. I would not think of this as a minus, rather than a *plus* of working with Emacs. I can, for example, have two separate monitors (each one has a frame), and each one can have many files at once, and i can easily bring a buffer from one monitor to the other, etc etc. Yes, the terminology can be *slightly* confusing, for example calling "frame" what we call now a "window", as well as *kill* and *yank*, but, trust me, it's just a small amount of terminology to learn. Compare, for example, having to learn the abomination of confusing terminology that SAP (ERP software) brings to the table... "Transaction", "Transport", "Landscape" ... Emacs is far far easier. If you didn't like Emacs terminology, SAP will make you puke, I guarantee you! But honestly, it's not the end of the world. "Meta" = "Alt" "Kill" = "Cut" "Yank" = "Paste" Is that so hard to grok? In my opinion, not at all. Entering the world of Common Lisp there is also some terminology to learn that will be alien (or defined *differently*) to programmers foreign to Lisp -- for example car, cdr, atom, macro, closure, special variables, declarations, 'simple' vectors/arrays, fill pointers, lambda-lists, etc. Learning new stuff always requires uploading new definitions to your brain. 
You might want to use a case insensitive comparison in case the reader case changed from the compilation of your function to the compilation of the consumer of your function.
`CL:LOOP` uses the third option mentioned here. `(loop for x = ...)` doesn't care if `FOR` is `CL-USER:FOR`, `:FOR` or `FOO::FOR`. So you can go `(string= (symbol-name x) "FOR")` in your code if you want to follow this.
A fancy gameboy emulator called E'mu.
If you follow the link, this twit did start a blog, and he's copy-and-pasting it all over the place. Same fucking drivel in lisp, learnlisp, Usenet ... Mods on vacation?
I guess that's more a sign of the times we live in? It's the most fitting word I could come up with.
I would say there is plenty of Lisp in there, and the two languages are very related.
This is exactly what I wanted to implement someday!! C with a **true** macro system. Excellent idea, and it would be even more awesome if the compilation steps could be done within lisp (i.e. from the REPL). And it would be (* awesome awesome) if it had a way to define some C functions to be called later from CFFI so at the end one could have: - write C in s-expression syntax - compile within Lisp (using GCC, etc) - call some of those C functions within Lisp using CFFI. 
FYI, `(floor (/ x y))` is equivalent to `(floor x y)`. Same with ceiling.
I consider Lisp, Forth and C siblings conceptually. They all provide a small number of powerful concepts and get out of the users way. Most other languages get tangled up in ego bullshit, I suspect mostly because of narrow-minded designers who look down on users and are more into mental masturbation than solving problems. Cixl is in many ways an attempt to find a middle way between Forth and Common Lisp; it's more nested than Forth; and offers let-bindings, lambdas and multi-methods.
Or a Forth-inspired Lisp, it all depends on where you're coming from.
I'm really just beginning to learn either. It's similarity to forth seems obvious; what are its lispy attributes?
you might know it, pasting 'cause seems appropriate for the thread: https://github.com/eudoxia0/cmacro "Lisp macros for C".
&gt; Excellent idea, and it would be even more awesome if the compilation steps could be done within lisp (i.e. from the REPL). May be go read "10th Greenspoon rule" and figure out that it's CL and you ALREADY HERE, if you are in this group.
Sweet. Now if I could get it to build...
I kind of wish there was a target for PHP since that's what I hate working with the most, though my co-workers wouldn't see the point of using it.
C-Mera is great. I used it to generate C code from Common Lisp, as well as writing a simple "compiler" that translates JSON-like syntax into C++ code.
Why you don't want to use keywords? They are there for precisely this use case. At least that is my impression.
Why you don't want to use keywords? They are there for precisely this use case. At least that is my impression.
I am writing an editor with full thread safety in Qt where everything is accessible with hooks and/or advices. I have the GUI done, but I am still working on method dispatch and event loop stuff. Some parts will be done in C++ (it's based on ewig by arximboldi on github), but apart from a small core of c++ (a couple of thousand lines for the basic interaction with qt, buffer handling and some other things that need to be fast) everything else will be guile scheme. Still a long time to go for alpha release though, and I have zero time. 
Are you calling C++ code from Scheme or otherwise. How do you do it?
Nice! Will it also have java interop? 
Hi, thank you. We [already added ikkiware](https://github.com/azzamsa/awesome-lisp-companies/commit/fb45864bc7b2f3296a932f6cb04ee8d14efc63c5) to the list. :) 
Great! Thank you! :-) 
Some prose would help me understand this, I think.
I'd like to see timing for a generic function with a bunch of methods discriminating on that argument with EQL parameter specifiers. You'd want to prime the method dispatch table first by calling each method before you timed it.
I was just writing it and I updated it now. check it again
Are you using any special parameters to SBCL to get this file to compile? It exhausts the heap on my machine. I think there's one other approach you've missed: building a tree out of integer ranges (with &lt;, rather than with logbitp). I first came across this technique [here](http://www.foldr.org/~michaelw/log/programming/lisp/icfp-contest-2006-vm). Also I think Strandh uses something similar in his paper on optimized generic function dispatch, and makes an argument for why it is optimal for modern processors. And I have my own version in Serapeum, as [tree-case](https://github.com/TBRSS/serapeum/blob/master/tree-case.lisp). On my machine at least it's about twice as fast as fcase7.
I long for pkhuong’s solution being made robust. Vectors and functions are so heavy-handed. It would be nice if it actually compiled to computed offsets and jumps. Unfortunately that solution requires compiler support. Paul adds another AST node, IIRC. 
There's a reader macro for that. (read-with-handwriting :type :calligraphic)
I need this as a monospaced font, it's gorgeous! 
It will not work well as a monospaced font. Lowercase M is three times wider than lowercase I. But, if you really make sure to make this font regular, you can quite possibly make the letters align. Their widths are 1 unit, 2 units, 3 units. (:
Is it on Quicklisp yet?
Don't ruin the fuuuun. (:
Uuuh yes. `(ql:quickload (/ 1 0))`
It's not exactly equivalent. First, the remainder will be different: (floor (/ 2 3)) =&gt; 0, 2/3 vs (floor 2 3) =&gt; 0, 2 But even the quotient can differ due to float rounding errors: (floor (/ -114658225103614 84619.58)) =&gt; -1354984704, 0.0 vs (floor -114658225103614 84619.58) =&gt; -1354984705, 8473228.0
Here are a couple of fonts that include monospaced fraktur: [Fixedsys 3.00](http://www.fixedsysexcelsior.com/) [PragmataPro](https://www.fsd.it/shop/fonts/pragmatapro/) I’m guessing that calligraphic renditions of lisp code would have a LOT of parenthetical flourishing...
I set my Dynamic space size to be the maximum amount of memory available with my PC so yeah I use this special parameter
I must complete my International Planning Competition (an extreme AI competition!) initial submission before Jan 14, so unfortunately there is no time to wait for it to happen.
BTW, the one causing the heap exhaustion would be the earlier variants. I believe the final result, fcase9, would not require that much amount of memory for compilation.
Looks like somebody rendered McCLIM out to a printer... https://common-lisp.net/project/mcclim/static/media/screenshots/7G9BTn9.png 
Monospace is overrated. I’ve been coding in Comic sans for a couple of months now. It’s great. 
The opening parenthesis is a terminating macro character. Thus, the first token is simply the symbol `A`. See [CLHS 2.2](http://www.lispworks.com/documentation/HyperSpec/Body/02_b.htm). I can't make heads or tails of why you think this behaviour is unintuitive in any way. The only choice the reader has is to read one token at a time. Should `A(1 + 2)` then be read as a single symbol with the name `"A(1 + 2)"`? That would be very strange. If not that, then what in the world should be happening instead?
The way I see it is that #'read-from-string reads from the string tokens until it hits space. For "ab", since both are tokens, both are read. "(1 + 2)" as a lisp expression is a token so it is read. It therefore makes no sense that "a(1 + 2)" which is two tokens in the same sense "ab" is, isn't read appropriately.
`READ-FROM-STRING` reads a single complete Lisp form from the input. If you read from string "A B C D" then only A will be read. If you read from string (A B C D) then `(A B C D)` will be read. If you read from string "(foo)(bar)" then `(FOO)` will be read. The remainder of the string is just ignored.
A|B|C|D| -|-|-|-| B|B| | | C| |C| | D| | |D| 
Your intuition is incorrect. In `READ-FROM-STRING`, the reader reads [a single Lisp form](http://clhs.lisp.se/Body/26_glo_f.htm#form). For "ab", since both are tokens, both are read. "ab" is not being read as two tokens, it is being read as a symbol. "ab" in the beginning of your string is interpreted as a single symbol with name `AB`. "(1 + 2)" as a lisp expression is treated as a token so it is read. This is incorrect. `(1 + 2)` is read as a list of three elements, the first of which is the number `1`, the second of which is the symbol `+` and the third of which is the number `2`. It therefore makes no sense that "a(1 + 2)" which is two tokens in the same sense "ab" is, isn't read appropriately. No, "ab" is read as a single token, the symbol `AB`.
https://i.imgur.com/TChtMYN.png what the hell
The reader reads *expressions*, not forms. Forms are only relevant when we're talking about evaluation.
The reader reads any number of characters until it completes an expression. A symbol is an expression, a number is an expression, a cons or list is an expression, etc. `ab` is a single symbol, so it is read as a single expression. `ab c` is two symbols, so two expressions. `ab ()` is a symbol and a list, so two expressions. `(a b)` is list, so one expression. `(a b) c` is a list and one symbol, so two expressions. `ab(c)` is a symbol and a list, so two expressions.
Yes, sorry. Correcting now.
While very cool (I commented on the sister thread over on /r/programming) I agree with the other posters about needing to change the branding as it is too close to Apple's old product.
Thank you for pointing out that page, very instructive.
&gt;Your intuition is incorrect. In READ-FROM-STRING, the reader reads a single Lisp expression Complementing this: (I think the OP wants to read many expressions.) READ-FROM-STRING also returns the index (position) where the reader stopped reading, so you can use this to invoke r-f-s again to read the next expression, and so on and so on. 
I just threw up in my mouth a little bit
You cannot reasonably expect everyone coming to the language to read the entirety of the standard imo. Referring to intuition seems perfectly reasonable, though they can be wrong, as many in this thread have pointed out.
Ah this is really helpful! Thank you!
&gt; Ah this is really helpful! Thank you! You are welcome. Just FYI, just in case you didn't know: In Common Lisp, functions can return more than one value. The "other" values can be captured by using MULTIPLE-VALUE-BIND. Thus, read-from-string can be used in this way: (multiple-value-bind (result position) (read-from-string my-string) ... rest of code that uses result &amp; position. ) http://clhs.lisp.se/Body/m_multip.htm
Thanks, i always wanted to know where did this logo came from. I love it!
Just wanted to say congrats to /u/Anemone5 for rendering this. It's a really cool logo. 
you can expect people to read the relevant portion of the standard, not entirety. It is just a manual.
I've heard the feedback from many people, I honestly don't think it's going to ever become an issue, but since everyone is so concerned about it I've taken steps to work on that I've spoken to two designers who say they will offer alternative designs, let's see what happens :D
`a(1 + 2)` is character syntax denoting the same two objects in the same order as `a (1 + 2)`. Thus you have to accept the same output as the one which looked "OK" for `a (1 + 2)`. Otherwise you're proposing that the reader should produce different results for instances of (standard) syntax which are documented as equivalent. Note that no single object will print as `A(1 + 2)`. So even if we customize the Lisp reader with a custom read table to treat `a(` differently from `a (`, that will not get us `read-from-string` returning something which prints as `A(1 + 2)`. 
+1 genius :)
Thanks!
The glossary is quite clear about this. A [form](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_f.htm#form) is an object meant to be evaluated. An [expression](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_e.htm#expression) is an object meant to be interpreted as data. Since the reader only turns source code into data, it deals in expressions. It's only within the context of compilation and evaluation that this data turns into forms.
Just try to experiment and convince any of your colleagues-programmers to do it, and see how many of them will be convinced to try.
You don't need to explain it to _me_. I've spent my share of years with Emacs. For SAP people get paid to work with. But I could not imagine ordinary developers grok this stuff just to try out a new language! The entry barrier is too high, Emacs is a major part of this barrier and we all see results of it. In Marketing there is a rule stating the every additional click or page which separates the user from purchase reduces the number of potential customers significantly. Stephen Hawking in one of his famous books stated that every formula in the book reduces the number of readers twice(joking of course but there is truth in that). Emacs with its obscure terminology, less than friendly user interface, strange ways of working by the modern UI standards is one of the largest contributors preventing newcomers to get into the Common Lisp.
I am rather new to Common Lisp and I am still studying to figure out what are the trade-offs involved when solving these basic software design issues. I don't have anything special against keywords, I am just looking for other options.
Following number 3, I used the `subst-if` function to map symbols with the appropriate name to the “right” package: (defun %canonize-form-symbols (symbols form) (reduce (lambda (form symbol) (subst-if symbol (lambda (form) (and (symbolp form) (string= (symbol-name form) (symbol-name symbol)))) form)) symbols :initial-value form))
Better than that yet you can use the string as a stream and repeatedly use the normal `read` to read as many expressions from it as you need: (with-input-from-string (stream "a (1 + 2)") (loop with eof = (gensym) for expression = (read stream NIL eof) until (eql expression eof) collect expression))
&gt;And not the least, because of it the Common Lisp users will be associated with the basement dwellers who just adores the tech of 80s and love their PDP-11 standing near the bed. Don't make fun of my PDP-11, please. It is in perfect shape now that i've installed the dehumidifier (my basement was too humid). 
That would explain things; I've never had a need to refer to the CLHS (very little of my lisp work is in CL anyway – and the common concepts are prevalent elsewhere). Thanks!
Hi jmercouris. I just managed to get this running on linux. This is looking amazing. Can't wait to move over to this from Conkeror. 
Hi, I’m glad you were able to get it running! Thank you for the kind words, I’m excited to see where this project will go :)
Okay. Just got this running about an hour ago. Some feedback: 1) For newbs on Debian 9, some quickstart instructions: * Assumptions: you have installed sbcl, debian9 and quicklisp already. * Install libwebkit2gtk * Clone: https://github.com/nEXT-Browser/cl-webkit to a path within your local-projects. (~/quicklisp/local-projects/cl-webkit) * Git clone nEXT: https://github.com/nEXT-Browser/nEXT.git * Start SBCL: sbcl * In sbcl: (require :asdf) * In sbcl: (asdf:load-asd "/full/path/to/next.asd") * In sbcl: (ql:quickload :next/gtk) * In sbcl: (next:start) All of the above are in the download instructions, this is just some shorthand to help newbs get it started. 2) In the 1 hour that I have used this, I have learned most of the shortcuts already. I use Conkeror as my primary browser and switching over to this in an hour or less has been trivial. 3) I don't have a full handle of what about this is Alpha. There are things that are glitchy but given that you are using an existing toolkit + render engine, the full experience is already there. Realistically, this has most of Conkerors core features and then a whole bunch of new features that don't exist in Conkeror. 4) I am going to be trying to use this browser more and more over the next couple of weeks to understand the user experience. Overall, I cannot say enough good things about this project. I have been waiting for a lisp based browser for a long time. This, in some sense, is very usable already. The amount of features available is tremendous and as of now, if some polish and shine can be applied to the rough edges here and there switching to this from Conkeror full time seems plausible. In particular you have taken the development of this project with a very pragmatic approach and it is very much appreciated that it is available on Linux now. For a single dev project, this is remarkable work. Congrats. I and many others really appreciate it. I hope to start adding to the project via feedback to start and then by writing extensions and tools and so forth. Great work.
You rule, Nicolas. Great code snippet. 
This comment has made me really happy! I'm glad that this piece of software has fulfilled a need in at least one other person's workflow :) Thank you for sharing! I look forward to feature and pull requests :D I'm already hard at work on ver. 0.08 which should making extending next a lot simpler, and more emacsy. The reason it is alpha is because it is just the first release, and I'm worried about some issues. For example, I'm not sure if sessions/ cookies are persisted on all distros, things like that. On Mac I'd call it a beta, but it's still really untested on Linux.
I would be happy to provide detailed documentation and feedback on issues that I encounter so that they are reporducible for you. If I can help in other ways I will try to as well. Once again, thank you kindly for the project, it really is amazing.
I'm using this as an alternative to the outdated Lispbox for working through Peter Seibel's *Practical Common Lisp* book.
Lisp has a disadvantage. It changes the way you think about programming. That can affect badly your employability.
Different ways to solve the problem might theoretically improve your work. But they will also make your code less understood by your co-workers. If your co-workers do not appreciate the different ay do not do it. Finding another job after making such mistake can be difficult.
Thanks for that, very useful to keep in mind. Testing on Emacs elisp, I wonder why `(floor (/ -114658225103614 84619.58))` returns `-1354984569 (#o377777777765717111607, #x3fffffffaf3c9387)`
Does it use double floats? 
I think so: https://www.gnu.org/software/emacs/manual/html_node/elisp/Float-Basics.html Still, I can't explain the difference between -1354984704 and -1354984569? Doing this manually with calculator also gives -1354984569, but perhaps there is a meaning to CL's`floor` that I do not know.
 (floor (/ -114658225103614 84619.58d0)) =&gt; -1354984569 0.3739917278289795d0
Thanks!
i personally think the ones that matter at the moment are common lisp, racket, and clojure. all others are certainly interesting, but i feel these are the choices to get things done on. it would be wonderful if there was a lisp on .net other than clojure clr.
Eww, that privacy mine? No thanks.
Thank you. So many hidden jewels are in those pages. Unless it is also available somewhere else (perhaps a backup in Lisp Foundation sites?), I will try to salvage those pages and put them on github/gitlab. 
Not sure if anyone is maintaining them. There was a thread on pro@c-l.net sometime back: https://mailman.common-lisp.net/pipermail/pro/2017-October/thread.html
Would love to.. But Facebook? Sorry!
Thanks, unfortunately an archive or backup has not been shared yet. webarchive copy seems the only one available.
Probably in the same place as the ["State of the CL Ecosystem 2016, 2017, and 2018"](http://borretti.me/article/common-lisp-sotu-2015)
Like others, there is zero possibility of me making a fb account without a firearm at my head. I've thought maybe I will look into mastodon, but probably not. Socnets are terrible all around for many reasons.
Too bad you feel that way. I'm using the platform as an experiement and it's already been done on the Reddit.
Understandable, I know that some feel that way and they are often the most interactive and vocal (as we've seen in these posts). Par of this course is about how to think interactively with the teaching medium (Faceook) along with the course materials (like how to ask questions, answer questions and provide feedback). Wish you could join as you are someone that looks to be comfortable with interative mediums, but not my one of choice.
To those that won't take the course because it's on the Facebook: 1) are you concerned about the information you give when you post? 2) are you concerned about 'background information leakage' (cookies, link clicks, etc) I see the most vocal opponents have no problem with knowing how much information they release when they are posting in forums, but I thought I would ask.
Or at least part of the course, which will be covering SICP.
Leakage? FB [claims ownership of everything you share](https://gizmodo.com/5963299/facebook-will-always-own-you). They have scripts embedded in every major third party website to [track your activities](https://lifehacker.com/5843969/facebook-is-tracking-your-every-move-on-the-web-heres-how-to-stop-it). Forget logging out, they track you [even if you don't have an fb account](https://www.themarysue.com/facebook-targeted-ads/). I noped out a long time ago, and I don't see anything changing my mind.
From the person selling Emacs?https://itunes.apple.com/us/app/emacs-lisp-programming-environment-elpe/id1217644998?mt=12
Not too bad coverage for a recording device. On the internet; and they'll soon be getting into homes: http://www.mirror.co.uk/news/world-news/facebook-wants-put-cameras-microphones-11838345
Sometimes I'm into one killer feature. GUI for mac. Linux for stability (although I've never seriously triedt the BSDs). Ethereum for Smart Contracts. IOTA for temporary storage and (hopefully) Spam Prevention and fast , transaction (with the proper recording device, Ethereum) contract input. Facebook for recording what I put into it. Everything on the internet is recorded by someone; at least a bunch of stuff I know that get put into it is recorded, probably for all perpetuity. Same reason why I chose Ethereum, but not IOTA.
Yes, I learned a lot about the uses of commercial software recently through sales. Not much in sales (about 1k USD total last year; my best seller was "BPM Tapper (BPMT)"), but in how "not to do it". Things just sell in the App Store, i guess. I did very little marketing and content, at least time wise for content: except on facebook. So I'm trying to build reputation there. Something that can be taken away easily. And I'm using it for recording, as a computer engineering, everything I post for perpectual perpituity. And whatever others have mentioned. I don't get on reddit enough to post, but I guess I could try with more marketing, if you guys really want.[2] Now I'm working on marketing and content. [2] Good data. But only a sample set of one. Anybody else remember that one post to /r/lisp? [2] Just learned about the quality posting[4] rules on @reddit. It seems that they limit you to every 10 minutes at first. I've been a /r/facebook[5] user for years and never had a limit. [4] I mean /r/spam prevention. [5] I mean't that mistake. It show lack of inconsistency and 'walling' between interfaces. But on both directions and on what sides? Does @reddit convert it to /r/reddit, /u/reddit, at all? I would suspect a user, but i didn't mean it. I mean the group: the Anti-Facebook group, I'm thinking. Still trying to find if there's one on @Facebook. I guess I'll have to spend sometime and check. Would be convenient to do autoposting. Oh wait, there is: the other discussions tab. Doesn't seem to be a spam problem there. 
That's a test of marketing on @reddit. See all the links it made when i didn't have to type. i call it 'cross posting'. Maybe it'll create more interest in lisp, and thus sales of software in my maOS App Store[1]: [1]: Go into the @macOS AppStore and type "busfactor1". That's my store on the macos appStore, unless anybody else starts marketing under that name.
And there's an ability to not post a link to my macroA$$ app store, if you know what I mean. Everthing else is written in Common Lisp with LispWorks. Something I could figure out how to create executables with cheaply (but not for free, I think it's broken right now but haven't had a chance to report it). I could also figure that out with @emacs. And retarget it as a learning tool, but that didn't take much time. Maybe a few days. I'm sure my time to do that wasn't free. As they say.
And I created this: And kept it up the whole time. It doesn't use a server that has to be rebooted and I still can't seem to figure out the fucking init systems on unix. I wish it was more simple, like Unix V7. http://busfactor1.ca/bin/eturia ProTip: click in the title bar before typing in the window. the system allows for the graphical creation of album covers if you just click on it and learn to type with it Purpose: Education Price: Free (as in Free) 
Have you read this https://common-lisp.net/project/asdf/asdf.html#Controlling-where-ASDF-searches-for-systems ?
Slightly unrelated: Quicklisp searches for ASD files at every startup and at every `#'ql:quickload`, but skips project subdirectories during this search. To make it perform a fully recursive search, use `(ql:register-local-projects)`.
A real [Telescreen](https://en.wikipedia.org/wiki/Telescreen), finally!
**Telescreen** Telescreens are fictional devices which operate as both televisions and security cameras and microphones. They feature in George Orwell's dystopian novel Nineteen Eighty-Four as well as all film adaptations of the novel. In the novel and its adaptations, telescreens are used by the ruling Party in the totalitarian fictional State of Oceania to keep its subjects under constant surveillance, thus eliminating the chance of secret conspiracies against Oceania. All members of the Inner Party (upper-class) and Outer Party (middle-class) have telescreens in their homes, but the proles (lower-class) are not typically monitored as they are unimportant to the Party. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Yup. It's here.
You want a `:module`. Check this out: https://github.com/dlowe-net/local-time/blob/master/local-time.asd
Bundling third-party libraries with your project is a pretty old-fashioned way to manage things. What prompts the desire in your case?
Thanks. TIL!
Yes I see. The design philosophy behind these two is different - one (pathlib) is OOP and multi-functional, while os.path is just a set of functions not holding any state and operating purely on strings, and its simplicity therefore is a target to replicate in my ppath library.
IMO releasing this as a paid app seems unethical to me even if it's completely legal and/or compliant with the GPL. Shame on the author; this not how you impress your fellow Lisp hackers.
I'd like to keep everything required to build the project together. It's not much fun trying to get old software to build with newer library versions.
I may be misunderstanding but this example isn't exactly what I want to do. Each of the libraries would have its own ASD file. 
I guess the question is why you need to do this. Is this because you deploy by compiling on the target and there is no quicklisp?
I'm guessing join combines two lists like: (join '(1 2) '(3 4)) ;; =&gt; (1 2 3 4) so rev is a recursive function. try expanding for smaller test case. (rev '()) ;; =&gt; () (rev '(1)) ;; =&gt; (1) (rev '(1 2)) ;; =&gt; (join (rev '(2)) (cons 1 nil)) =&gt; (2 1) (rev '(1 2 3)) ;; =&gt; (join (rev '(2 3)) (cons 1 nil)) =&gt; (join '(3 2) '(1)) =&gt; '(3 2 1) so rev breaks the list into two pieces: the first element and the rest. the rest gets reversed (using rev), and joined with a list of just the first element.
Note that this is an O(N^2) algorithm. It can be implemented by an O(n) algorithm. (As/u/chebertapps suggests, I assume join is equivalent to Common Lisp's append.)
Sorry, I didn't mean to come off as snarky. I honestly do not have a facebook account and can't take part in it.
I'm sad you feel so strongly about it. I think it's fun.
&gt;I'm sad [Here's a picture/gif of a cat,](http://random.cat/i/MyTsd.jpg) hopefully it'll cheer you up :). ___ I am a bot. use !unsubscribetosadcat for me to ignore you.
It's more of a want than a need--technically I could make do. But I've got a few reasons. Number one, there are a few parts of this project that I'd like to structure as separate libraries in their own repositories (and have done). This is great, but it means bringing the project up on another system means checking out multiple repositories. And it means I can't do something like fix a bug in one of these libraries without testing against all projects I've used it in (even when those projects weren't hitting the bug). I feel it would be better to have a master copy of the library (as I do) and also a copy in the source tree of any project that uses it, so I can merge changes at my leisure. Number two, yeah I'd like to be able to distribute source without requiring Quicklisp to be installed. Down the road I'd like to do an open-source release, and although Quicklisp is a godsend for us Lispers, installing it is another hurdle for somebody who just wants to download a program and build it from source. Or you can imagine I want to show somebody the project, and want as few installation steps as possible between them expressing interest and me starting up the program. Number three, pretend it's 2030 and I haven't touched this code in 10 years. Maybe I don't even own the computer I developed it on any more, and my backups from that time are stored 1000 miles away. The hope is that the libraries I used are still in Quicklisp and that updates to them haven't bit-rotted my project at all. But there's no guarantee of this. (And no guarantee that I made a note of which versions are known to work, being in a "just use the latest" mindset.) The project may not build without changes, and I'm not a big fan of trying to change software I can't even make a working build of. It's realistic to think I'll find myself tracking down old library versions and trying to manually bisect their history to get a working build. And furthermore, at that time we can hope Quicklisp is alive and well--meaning that at that time I'll need some strategy for making a project-local configuration change to use the old copies I track down, and to store that change in the project so I don't have to do the library dance in the future. Which sounds an awful lot like what I'm proposing to do in the first place. If I keep the libraries I use in the source tree then none of the above is an issue, and supposing I do want to use the newest library versions of libraries in Quicklisp, it should just be a matter of deleting the local versions in the project tree (at least that's how I'd like to set this up).
Not iteration, recursion. I haven't touched Lisp in a long time, so the following might be completely wrong, but here goes! Stepping through: - Check if the rest of "xs" is empty. - If it is, give me "xs" (which should only contain 1 thing, because the rest of it is empty). - If it's not, give me the join of running the rev program, passing in the rest of xs, and the first element from xs. Taking '(3 2 1) as an example: 1. Is (rest '(3 2 1)) null? Nope, it's (2 1). Go to join, get told to run rev on (2 1). 2. OK, is (rest '(2 1)) null? Nope, it's (1). Go to join, get told to run rev on (1) 3. OK, is (rest '(1)) null? Yup! Return (1) Now that the program is done recursing, it has to complete the steps it "put off" until now. Essentially, we interrupted the 'join' function with recursion, and now we need to return to them and finish them, *but in reverse order.* Each time we hit the function, 'xs' is also different: The first pass it was (3 2 1), the second pass (2 1), and the final pass just (1). The remainder: 1. OK, so now I want to (join (1) and (first (2 1))). I'll return (1 2). 2. OK, so now I want to (join (1 2) and (first (3 2 1))). I'll return (1 2 3). 3. I'm done! As far as I understand it, the (join x (cons (y))) ensures we are joining lists, and not trying to join a list to uh... not-a-list.
I do think that's a great feature, but I don't like that I'd have to muck with the system configuration to make use of it. If I understand correctly, I'd either be switching my existing Quicklisp install to an old version (making it out of sync with my newer projects), or else making a parallel install and pointing my dev environment to it. And of course there's no guarantee I'll use only Quicklisp libraries! It seems much preferable to me to store the entire "known good" configuration in one folder in a way that doesn't require manual changes to the system configuration.
Are you looking for Qlot ? https://github.com/fukamachi/qlot a tool to keep dependencies locally in a project (à la python pip or ruby bundler). Also [Qi](https://github.com/CodyReichert/qi) (newer, to be tested) and for the record, [lpm](https://github.com/asciian/lpm) (in development, buggy).
Very similar, I think! I'd rather not have a dependency on either of those tools (an ASDF-only solution is preferred). Actually these lines from the Qi page may do what I need. I think I just had a word wrong and that's why I wasn't able to get it working! (asdf:initialize-source-registry `(:source-registry :ignore-inherited-configuration (:tree (:here ".dependencies/packages/"))))
How it works is like this. 000 Suppose we have a function called `reverse` which can reverse a list. (A normal list with no funny business like cycles.) In fact, in ANSI Common Lisp, [we do](http://clhs.lisp.se/Body/f_revers.htm). Suppose also we have a function `join` which appends two lists. In ANSI CL it might be defined: (defun join (a b) (append a b)) With `reverse` and `join` function, suppose we have this, which is almost exactly the same as your function: (defun rev (xs) (if (null (rest xs)) xs (join (reverse (rest xs)) (cons (first xs) nil)))) The only thing different is that inside the function we're calling `reverse` and not `rev`. Now suppose we verify that this `rev` correctly reverses a list, just like `reverse` does. Then we note that if `rev` implements `reverse`, we can replace the `reverse` call with `rev` without changing the behavior. Thus, we arrive at your original function which doesn't use `reverse` but recurses on itself. 
Yes, here's the source repository: https://github.com/BusFactor1Inc/ELPE
After trying to follow the dumpster fire that is DASH on facebook, no thank you! But good luck!
I am also very excited about this project. I just can't get sbcl with quickload to work in nixos, so is there a way to start sbcl as command like writing a small script with the lisp code in it? If so it should be pretty easy to write a docker container as universal way to install nEXT on all linux distries.
Yeeeah ! The gang is back !
So I think I've got it. What I posted above there works. You'd put this at the top of the project's ASD file, and replace `(:here ".dependencies/packages/")` with the correct path to the folder with the libraries. But I'm still a confused about why `:ignore-inherited-configuration` doesn't prevent it from finding system-wide libraries that the system depends on.
Yep, that’s probably the way to go, though I am not sure if you are exchanging one set of problems for another. Cheers
I just have the equivalent of (load "~/quicklisp/setup.lisp") in my ~/.sbclrc. If I needed a second copy of quicklisp that is older, it seems easy enough to arrange.
why... what a douche.
What do you mean? Can’t you compile it yourself?
Thank you.
Woo!
There are not well-established practices for this; if you want to use a autoconf script, I would say that's fine. If you can get it to output a lisp file that assigns a bunch of parameters, then you can just load that file as part of your build process.
This depends a lot on what kind of audience this is for: are the users complete neophytes, or can they fix environment variables such as `PATH`? Also, what platform: are we talking about Windows, where utilities could come from several third party sources. Git Bash from here, GNU tar from there and whatnot. In a sane Unix-like environment, either the utility you need is in the `PATH`, or else you can pretty much assume it's missing. &gt; *This library factorises common patterns for external program interaction and eases the production of command-lines for some utilities* Would this be used by someone who can't get those wrapped utils to show up in `PATH`? 
&gt; Would this be useful to someone who can't get those wrapped utils to show up in PATH? Actually, this is more a security consideration: If a program looks for external utilities in the path, then it cannot be setuid – otherwise, users can put their own version of a program in the path in order to execute any code on the behalf of the original program. 
&gt; half **douchebag**
Not absolutely true; a setuid program can drop its elevated privilege and then do things like regular `PATH`-based dispatch. In general, setuid programs should be designed to do as little as possible under elevated privilege, and look toward permanently dropping privileges as a goal, if possible/applicable. (Dispatching of utilities in a setuid program is possible without permanently dropping privileges. Namely, `fork`, then permanently drop privs in just the child, then `exec` the utility.) It depends on the details. Obviously, the dispatch of such a program cannot be used to produce some output or effect which is then trusted as the input to some security-sensitive decision.
That does look odd to me. I suspect he really meant to use map-into: (map-into (make-array *monster-num*) (lambda (x) (funcall (nth (random (length *monster-builders*)) *monster-builders*))))
I can’t get paid for my time to make and promote it? Just how much do you think i’ve made so far? Techically, I don’t have to give anything.
Apparently it's using that array only for its length. Maybe he wanted to do something like (let ((arr (make-array *monster-num*))) (setf *monsters* (map-into arr (lambda (x) ...) arr)))
&gt; Just how much do you think i’ve made so far? Does not matter. You should give all, you did not fucking write it dude.
I’m experimenting with thr App Store platform. I don’t charge for it, find the source repo above if you want to compile or modify it yourself. I am technically not selling Emacs, I am selling the ELPE (Emacs Lisp Programming Environment), a sandboxed version of GNU Emacs for running on macOS computers available through the app store set up for new users.
potato po-ta-to Keep telling yourself you're not a douchebag. You are.
Congrats. It means you're learning something, not just reading. I found and fixed several bugs in PAIP and LOL books code :)
What do you mean by modern? Could [Hedgehog](https://github.com/sbp/hedgehog) be of interest to you ?
"Modern" means active community, support, updates. Used in recent projects. 
the microschememay link 404's
Thanks!!! Awesome!! TBH, it is difficult to learn from a book with no example problems. I do try to run the code in my head when I am typing it out though.
https://picolisp.com/wiki/?embedded maybe
It's supposed to be just "microscheme" https://github.com/ryansuchocki/microscheme
I think this should work you use map and tell it the type of the list is a vector, then it makes an array of size *monster-num* and uses the lambda function to funcall a random builder from a predetermined list, this assigns the result of running the builder to each element in the vector. If you run: (map 'vector #'(lambda (x) 5) (make-array 10)) you get 10 fives which is a simpler version of that code in the question. It is perhaps not the clearest of idioms, but it should work.
Land of Lisp. It might be a good book for beginner. I don't know. I did not read it. For more "practical" starting point I would recomend PCL by Seibel or ACL by Graham. See what works for you.
Your point is about performance, while it should be about if the code is the most clear and specific way of writing down the problem. The argument for e.g. using an explicit loop should be one of clarity first and foremost. Try it with a loop macro and see if that code looks more clear to you. Only THEN check for performance. Optimizing compilers can be really surprising, it is hard to predict what is going to be optimized away or not. Case in point, it does not appear that the above map is creating a vector with SBCL. Taking a quick look at the disassembly of #'init-monsters (sbcl and optimize 3), I only see the array being allocated and map is transformed into a simple loop. Traversal rules indeed state that the array passed to map cannot be modified, but do not assume that a compiler does not optimize it when it can determine that the side effect cannot be observed. 1. make it work 2. make it nice 3. make it fast
[Armpit Scheme](http://armpit.sourceforge.net/)
excellent.
I believe that page could have been shared partly in response to [this thread](https://www.reddit.com/r/Common_Lisp/comments/7qd3vq/clrepl_the_longawaited_common_lisp_sbcl_full/)
Thank you. 
How big is your "microcontroller"? That term can range from an 8-bit PIC to an embedded 32-bit ARM processor. Also, do you really mean "bytecode" or do you mean native machine code? Personally, I have been intrigued by low-level Lisp-like expressions of assembly code like [Henry Baker's COMFY](http://josephoswald.nfshost.com/comfy/summary.html) But, frankly speaking, machines powerful enough to support garbage-collected symbolic languages are tedious to program at the assembly level, and machines small enough to want to program at bare metal are too small to support real Lisp. Unless you have some novel metaprogramming to do, Lisp is probably not advantageous. Before people mention the Lisp machines, the OS was programmed in Lisp because the implementors were Lisp programmers writing for other Lisp programmers. Not because Lisp was inherently good for low-level programming.
Great! We need more games written in Lisp :)
Interfacing with c++ is a real pain for most languages (unless maybe you compile via the same toolchain e.g. llvm). You have to extern everyhting you need and then work against that. It seems hard to do thoroughly and get a result that's nice to work with. The c++ enthusiasts I've talked to had some feelings that I feel familiar with from lisp. The main one being: having a language that trusts you to do things, even though you can shoot your feet off. The element of control both languages give are ace. &gt; Context: frequent lisper &amp; not very confident c++ coder
I try to steer clear of C++ as much as I can.
I think C++ is possibly the most badly designed programming language there has ever been. It has all of the disadvantages of both C and Java and literally none of the advantages. It's worthless as a low level programming language, it doesn't have global garbage collection, and it has a bazillion different ways of doing the same thing and I doubt there's a single person in the world who knows them all. It was a written as a language that was easy for compiler writers and hard for programmers: guess which there are more of. 
That was a fake interview [[snopes](https://www.snopes.com/computer/program/stroustrup.asp)] . I first read it [here](http://harmful.cat-v.org/software/c++/I_did_it_for_you_all). If you read it all the way through it's pretty absurd and obviously not in line with the rest of what Stroustrup says. &gt; Stroustrup: Well, one day, when I was sitting in my office, I thought of this little scheme, which would redress the balance a little. I thought ‘I wonder what would happen, if there were a language so complicated, so difficult to learn, that nobody would ever be able to swamp the market with programmers? 
For me personally, the C part is fine. It's easy enough to have an FFI that binds to the simpler parts of C (definitions and functions, but not callbacks so much). If you have a C interface to C++ code (using extern "C" {}) that works fine, too. But that means writing your own wrapper. When you start to use the higher level features of C++, which weren't a part of C, I think you'll find that CL does a much better job. Things like generic programming (templates), polymorphism (objects and classes), and domain specific languages all end up being much simpler and more powerful in CL. C can do things that CL can't, so it can make sense to use both. You may need libs from C++, which means making C wrappers, which isn't always straightforward. I believe /u/Shinmera has experience doing this with [QTools](https://github.com/Shinmera/qtools#qt-1), and it doesn't look very fun.
In short, CL sets me free while C++ gives me cancer. Source: I used both among others for more than a decade.
*Note: For this answer, (let ((lisp "common lisp")) ...* What is C? C is a fairly good language for very low level programming, a handy alternative to Assembler, with a huge amount of libraries and documentation available. C++ bolts into C a limited, flawed Object-oriented system, then also bolts into it convoluted templating and generics systems. Moreover, the standard has added, over time, more and more features that are not always orthogonal. Thus, many people are not so happy with C++. Common Lisp has an Object system that is far, *far*, **far** more powerful and flexible than the one in C++, true metaprogramming abilities. Thus, in these two regards, it is superior to C++. C is a friend of Common Lisp because it's easy to interoperate from Lisp to C (see CFFI, etc). However, i must say that, if you need it, CL can run very close to C speed (or *at* C speed). This, of course, requires writing in CL as if it was C, that is: * use only static arrays (simple-vector, etc) of fixed element type * inline functions as needed * declare everything, don't use arbitrary-length data types * avoid dynamic allocations, reduce consing as much as possible * etc etc etc Also, just as C, Common Lisp also has many stuff good for low level, for example: bit arrays, byte arrays, lots of bit operations, etc etc. Of course, C is still the better language for low level stuff, of course, but for me it was surprising that writing fast, lowish-level code in CL was possible. 
&gt;I try to steer clear of C++ as much as I can. You don't like Portacppe, the Portable C Plus Plus Environment?
I have experience in both C++ and Common Lisp. I don't find them particularly complementary, as there is a large overlap in their target problems. Lisp has much more ergonomic metaprogramming, and C++ gives the programmer explicit control over allocation. I will also point out that modern C++ puts a very heavy burden on library writers; I've implemented a container in C++ that provides some of the interfaces that STL does. There is a *huge* amount of code to back that, even though I used template metaprogramming to reduce that. The upside is that all the tools are there to make a very ergonomic library, that looks just like anything that is builtin (an advantage it shares with lisp). The downside is that it's easily 10x as much code to write that library. From my point of view C++ is really only a win over lisp when you either care about latency at the millisecond level (where GC hurts you), or are in a resource constrained environment (SBCL really wants ~100MB of ram for a typical application; there are implementations that can use far less ram, but they tend to be much less performant than SBCL).
I have some hopes about clasp, but I haven't yet found the time to really test it: https://github.com/drmeister/clasp
I dont disagree at all, I find it a mess as a whole. But the question is so vague that it just seems like an invite for language bashing and I find that pretty boring at this stage :)
Damn it, I want my image dispatched directly by the kernel's `fs/binfmt_elf.c` and `/lib/ld-linux.so`. Not some program written in C!
wow, I didnt know it was a fake, thank you! However, I think I will keep using the same story for discouraging people from C++ :p
I can't imagine anyone having written significant amounts of anything but the most deeply embedded C without seeing the benefits of c++. If nothing else, C++ is C with better metaprogramming, and automatic management of resources with dynamic extent. C++11 adds the ability to move resources around, which greatly increases its coverage for automatically managing resources.
&gt;I have already decided that my 2 langs of expertise will be C++ and CL and nothing will really change my mind on that. Why C++ and not C? 
Primarily because of OpenCV &amp; CUDA which are both primarily targeting c++
Since I've written this article, I'm curious what others think about the SERIES package. Why it is not widely adopted? I can see a lot of usages of the Iterate but none of this library, which is obliviously well documented and tested.
I think it's not immediately clear what the difference is between SERIES and a stream-based iteration package, or something with iterator objects, so it's not immediately clear that it's interesting. I've used it a bit and I'd like to see it used more.
I vaguely recall trying it a long time ago and not being able to figure out how to get started -- in particular, it wasn't documented (in whatever documentation I was using) that you needed to use `series:defun` instead of `cl:defun`.
FYI Series' documentation has been ported to a github wiki: https://github.com/tokenrove/series/wiki (nice article)
Looking at those timings, it seems to me you're testing interpreted code here (even the second test, for `sum-squares-loop2`, allocates almost 60 MB, but the code allocates nothing). Since the calculations are trivial, you're mostly measuring macroexpansion (and creation of interpreted function objects for the functional ones) plus some list traversal.
AMA
"for teaching #Lisp written in #Javascript." Apparently lisp is not enough language to write a tool for teaching lisp in lisp :p
Don't repost things. This subreddit is slow enough that it's just spammy.
I signed up just to answer this. In around 2006 I had this running in Windows 2000 on an old SGI VW540 and VW320. I remember the news of Izware buying Nichimen way back then. But like everyone else, we were swayed away from LISP by Python. Around 2004/2005 I succumbed to the comforting embrace of Softimage XSI (and mainwin...). Luckily I left the industry years before the heathens at Autodesk shutdown Softimage. Just as Mirai originally went silent in the early 2000's, Silo3D and Zbrush came to the rescue for modellers. Running a whois on izware.com says the domain is finally due to expire this year. Maybe after Greg Minter left around 2008, the new owners took out a 10 year lease. Which is when they went totally silent. Greg Minter and Bay Raitt have a great write up on some of their research and learning that was applied to Mirai: * http://www.theminters.com/misc/articles/derived-surfaces/index.htm Bay Raitt, the front man of Mirai's superior productivity demos, went onto Weta with a new tool under his belt, Zbrush. I would love to see the source code for Mirai. Probably a proprietary lisp to get it building on NT and IRIX cleanly. In terms of modelling tools, Wings3D is actually a superior clone of Mirai. That is pretty painful for some people to hear. But the developer did a really good job or cloning and improving the workflow.
Usually I use Parenscript, but this was javascript only.
It filters `xs`, returning a list containing only those elements for which `f` is non-nil.
If f is a function then it will call the function repeatedly using as argument each item in the list "xs" each time. It will also return the items of xs. I'm not sure why is the "t" (default) clause there for, to be honest, because if f is not a function, this will signal a condition (undefined function, etc). But then, i'm not a wise Lisper. 
I wanted to see some doc on the "Sigil" language, but didn't find any. I found this: https://github.com/burtonsamograd/sigil Which is not a programming language but a Parenscript compiler. 
Where does the `xs` variable convention come from? It's pretty alien in Lisp.
It is heavily used in ML languages, when naming sublists: `x::xs`, `y::ys`, ...
I guess it's true what they say, "You can write ML in any language."
Where did you find this?
Look forThe Order of Symbols book in the client/ directory. That’s the docs.
https://raw.githubusercontent.com/BusFactor1Inc/eturia/master/client/the-order-of-symbols.txt.html
Looks like homework
I don't see any documentation for what you're trying to do. What guide are you following?
Describing more about what you want to do would be a good place to start in terms of getting more specific help
I wan't to be able to use SBCL to compile lisp to a statically linked binary. The reason for that is that i want to build a lisp environment on top of the linux kernel, where the kernel executes a lisp image as "init". I might be mistaken but it seems to me that this asdf functionality makes it possible to do that.
The mechanism you found won't do what you want. If you want the Linux kernel to drive the lisp execution, you'll want to use ECL, designed for that task. You'll link the ECL shared objects with the Linux kernel compilation process, then change kernel init behavior to call the ECL functions to drive the lisp functionality
Roswell is recently working on a rather ad-hoc alternative to this problem: `--bundle-shared-object` option for `ros build` will just copy the shared object from the cached result to the current directory. Fukamachi is currently dogfooding the option for his project now.
James Gosling made something like this in around 1981 or so in support of an Emacs implementation: it was called ["Mock Lisp"](https://en.wikipedia.org/wiki/Mocklisp): basically an interpreter that worked by scanning/rewriting strings containing S-expression text, rather than actual data structures. 
It was developed on Franz Lisp and comes with a Windows version of Emacs.
I've been trying to get this to work for about the past year. Thanks for bringing it up. My understanding is that SBCL can be compiled with some option that makes it build a linkable .o file. I'm on a train, so I don't have the correct directory handy, but there's a make file in the dir that ASDF uses for some of those compiler options there, too. It seems distros don't build with that flag enabled and the error we're both getting is because the entry point for the static binary is defined in that missing file. It tries to build an executable without it and ends up with a pile of compiled code with no lisp implementation in it, as best I can reason. There's a set of patches that were contributed to SBCL a while ago that enable building this artifact, but I haven't successfully built SBCL in a way that produces the sbcl.o file. I think fare may have written the patches to SBCL. That would make sense. I would love to solve this for deploying lisp webapps as easily as ones written in go, personally. Let me know if you find anything!
7pm UTC happens when this comment is 4 hours and 1 minutes old. You can find the live countdown here: https://countle.com/__fG126543 --- I'm a bot, if you want to send feedback, please comment below or send a PM.
Actually 'Allegro CL' from Franz, Inc. 'Franz Lisp' was an earlier Lisp. https://en.wikipedia.org/wiki/Franz_Lisp
**Franz Lisp** In computer programming, Franz Lisp was a Lisp system written at UC Berkeley by the students of Professor Richard J. Fateman, based largely on Maclisp and distributed with the Berkeley Software Distribution (BSD) for the Digital Equipment Corp (DEC) VAX. Piggybacking on the popularity of the BSD package, Franz Lisp was probably the most widely distributed and used Lisp system of the 1970s and 1980s. The name is a pun on composer Franz Liszt. It was written specifically to be a host for running the Macsyma computer algebra system on VAX. The project was started at the end of 1978 shortly after UC Berkeley took delivery of their first VAX 11/780 (named Ernie CoVax, the first of many systems with pun names at UCB). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Cool that there are more people interesting in solving this. Thanks for the information and please let me know if you make any progress :)
Same here, will have a look at Roswell. Thanks
Okey i will look into ECL if i'm unable to solve this. Thanks!
What does "the shared object" refer to here? Shared libraries the project depends on? Or.. what? 
the shared library object loaded by CFFI. Some of which are system-installed, but they are not copied. Rather, the feature mainly aims at the shared object that was created by lisp during the build, such as those loaded by OSICAT. Those .so files are in the asdf cache directories so it is hard to find them and write a script that include them in the deployment package. Of course we can also copy all dependent .so files, if there is such need.
Alright, then I'd like to note that the [Deploy](https://shinmera.github.io/deploy/) library can already fill that need as well.
Thanks. well, the good thing is that the feature does not need explicit declaration, because it looks up each library object in some internal symbol in sb-alien package and collects the paths. the disadvantage is that it is currently sbcl-only.
Sorry but I heard many times RMS encouraging this behavior as he always says "free as free speech, not as a free beer". Actually that's boosting the free software movement, if you can make a living by selling a free software that everyone can get for free, you've proved it to be a valid business model. The whole point is about the 4 freedoms not about gratuity. Many companies in the past where saling CDs of GNU/Llinux, Openbsd, freebsd and there is nothing wrong with that :-)
Is Deploy able to bundle all shared libraries with the binary? I had a look at the link but i'm not sure how to configure it to do this. This is all dependencies for my binary after I build it with Deploy: linux-vdso.so.1 (0x00007ffe4d9e5000) libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fed10ec1000) libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fed10ca3000) libz.so.1 =&gt; /lib/x86_64-linux-gnu/libz.so.1 (0x00007fed10a89000) libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007fed1073e000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fed10388000) /lib64/ld-linux-x86-64.so.2 (0x00007fed110c5000) 
It does not handle transitive or implicit dependencies. It only collects what is referenced by CFFI, assuming that those are libraries that won't be available on a target system. Typically you do *not* want to ship essential systems libraries like linux-vdso, libdl, libpthread, libz, libm, or libc. Shipping these will land you in a world of crashes and pain unless you take special care to stuff all the leaks and prevent linux from doing its own thing, which can be very tricky.
We had one! way back when https://doc.rust-lang.org/0.9/guide-conditions.html The commit that removed it explains more https://github.com/rust-lang/rust/commit/454882dcb7fdb03867d695a88335e2d2c8f7561a
FYI a python library: https://github.com/svetlyak40wt/python-cl-conditions
The old IBM language [PL/I has "conditions" rather than exceptions](https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.ceea200/pliax.htm). Handling a condition takes place by searching the dynamic environment for "on unit" handlers, without unwinding the stack. These handlers are local functions. I **think** that local function can complete the handling by peforming a `GOTO` to a local label, which will unwind, which is a lot like a Lisp `go` out of a `lambda` into surrounding code. I suspect PL/I had this stuff first; Lisp copied it. 
R's error handling system is directly based on CL's condition system.
 Also, is that a ~400 line lambda function on that screenshot (lines 231-627)? Holy shit. A 400 line function should not happen in *any* language. A 400 line *anonymous* function should not happen at *all*.
With this kind of design I fear using lisp would make it worse
&gt; Holy shit. When I snapped the screenshot, I saved it as HOLYSHIT.png
With this kind of design, you already can't make it worse. (Please don't try to prove me otherwise.)
No good piece of development advice ever contained the phrase "you should just"
Lisp doesn't have RX library except of largely abandoned cells.
I mean, I've seen some horrible code. I'm not gonna prove you otherwise, but if you ever wanna believe me, take my word that people can make it worse. I worked in codebases that #defined BEGIN { and #defined END } or #defined VERYSMALLVALUE 0.0001.
I know that it is always possible to make code worse. There is a certain point though, beyond which the code is only suitable for throwing out or replacing.
I agree. We are definitely not going to be using Lisp. 
Clearly VERYSMALLVALUE should just be named EPSILON ;-)
Have you seen some of the code in [SBCL](https://github.com/sbcl/sbcl/blob/b719b7bcaad7e90492fb061ddf3cbb00a0e4fb24/src/code/reader.lisp#L1207)? read-token: 365 lines.
Oh, yes, I once had to work with vendor C code whose author had done their best to write it in FORTRAN by way of just such macros. `#define DO for` was especially confusing considering C also has `do`.
I'm *guessing* that more that the choice of how to structure the control flow, which is something one can change if one would like to favor 'readability', is due to performance considerations. They didn't want to take the hit of a extra function calls. Note they are also using read-time evaluating to 'inline' constants. Also note that most likely the code was written in the 90's for CMUCL, so the SBCL maintainers took the wise if it ain't broke don't fix it, specially if the reader algorithm is not going to change until hell freezes over. Just in case I wasn't clear, my point was not to shame SBCL/CMUCL developers but to point out that there are valid reasons for 400-line long functions.
[Dylan](https://en.wikipedia.org/wiki/Dylan_\(programming_language\)) was very much not independent of Lisp of course you probably know about it, but perhaps worth mentioning in context as [it also has conditions](https://opendylan.org/documentation/intro-dylan/conditions.html) 
I've read all three. Land of lisp is a really fun book -- it's got real panache and doesn't take itself too seriously. The code is a little odd, though, compared to most contemporary lisp. I thunk you could learn to code in lisp from it, but it won't prepare you for a professional context. 
RX being...?
http://reactivex.io/
Is there anything wrong with cells?
Neat explanation
&gt; Note they are also using read-time evaluating to 'inline' constants. What's to note about it? That's how you get CASE to use a constant.
Actually most of the code would have been written at CMU in the mid 80's as part of Spice Lisp project. Dill left CMU in '87. Lee Schumacher graduated with me in '85. Rob MacLachan is still there. &gt; The CMU CL reader (code/reader.lisp) was originally the Spice Lisp &gt; reader, written by David Dill and with support for packages added by &gt; Lee Schumacher. David Dill also wrote the sharpmacro support &gt; (code/sharpm.lisp). &gt; &gt; CMU CL's package code was rewritten by Rob MacLachlan based on an &gt; earlier version by Lee Schumacher. It also includes DEFPACKAGE by Dan &gt; Zigmond, and WITH-PACKAGE-ITERATOR written by Blaine Burks. William &gt; Lott also rewrote the DEFPACKAGE and DO-FOO-SYMBOLS stuff. &gt; 
Dammit; that is indeed a dealbreaker for me. It‘s a pity, cause it actually looks quite interesting other than that.
You know that floating-point computations are not necessaritly exact? That you use single-floats? That double-floats have a higher accuracy? If you want to do exact number computations, then Common Lisp offers unbounded integer numbers and rational numbers of integers.
 * (/ 0.01d0 10d0) =&gt; 0.001d0
&gt; double-precision, suffix your float by d0 Thanks for the article. It seems that adding **d0** to make it double-float works but (coerce 37.937045 'double-float) doesn't give the exact. Pardon a lisp newbie here but how can I concatenate a float with **d0**?
How many numbers are there between 0 and 1? You have 64-bits, you need to choose which numbers you can represent and not represent either way. Sorry, that's just how things are.
No, for example irrational numbers like `(sqrt 2)` can't be represented with a finite number of decimals; you have to round it to a sufficiently precise rational (which depends on the task at hand). This is not a bug really, floating point representation is one possible compromise, which comes with both benefits and drawbacks. You wouldn't use that for handling money, but this works fine for physical simulations.
Or perhaps Lisp implementors should read the specs of some other languages (like, oh, ISO C) and how unadorned floating point literals are double precision.
Thanks! Since I want to always use double-precision in my system, I just need to set the default float reader to 'double-float. CL-USER&gt; *read-default-float-format* SINGLE-FLOAT CL-USER&gt; (declaim (sb-ext:disable-package-locks *read-default-float-format*)) (*READ-DEFAULT-FLOAT-FORMAT*) CL-USER&gt; (setf *read-default-float-format* 'double-float) DOUBLE-FLOAT CL-USER&gt; *read-default-float-format* DOUBLE-FLOAT CL-USER&gt; 37.937045 37.937045 CL-USER&gt; 23.9535046 23.9535046 CL-USER&gt; (/ 0.01 10) 0.001 
Unadorned floating-point tokens becoming single precision floats is a really stupid language behavior. Even C is smart enough to make them double. Nobody should use single precision float for anything other than saving space in large arrays (e.g. audio samples or whatever). 
Thanks, in part, to having once read that many years ago: This is the TXR Lisp interactive listener of TXR 188. Quit with :quit or Ctrl-D on empty line. Ctrl-X ? for cheatsheet. 1&gt; 37.937045 37.937045 2&gt; (/ 0.01 10) 0.001 The floating point type of literals is double precision. And: 3&gt; *print-flo-precision* 15 Floating point precision for printing is 15 decimal digits. Perfect read-print consistency requires 17; 15 is a compromise for better "optics". 15 decimal digits of precision is how many the IEEE 64 bit double-precision format will preserve. But 17 digits are what is required to precisely preserve the 64 bit value in decimal. If you're storing S-expressions in a file or sending them over a network, and want the floating-point values to be preserved exactly, you have to crank that up to 17. 
Is it that hard to type the letter D? Good thing there's \*read-default-float-format*. And look at all these ML people, using 16-bit floats, they must be stupid.
Why on earth did you do (declaim (sb-ext:disable-package-locks *read-default-float-format*))?
Note that this still isn't exact. If you want exact numbers in lisp, use rationals. (/ 1/100 10) will be exact (/ 0.01 10) will not. If you want arbitrarily precise calculations that may include irrational numbers, use a computable real number library (computable-reals is in quicklisp). It's much slower than floats, but will let you extract the result at any specified level of precision. As a note: if you are using coordinates, *never* use floating point. Floating point values work great for multiplication and division but are very poor for addition and subtraction. Just calculating distance via the pythagorean theorum will open you up to huge inaccuracies. I don't know what your use case is, but for coordinates it's usually best to use scaled integers. Using 64-bit integers as coordinates can represent an area over 600000000000 times as large as the surface of the earth at a resolution of 1 nanometer, or a distance twice the diameter of the solar system at a resolution of 1 micrometer.
&gt; *ML people, using 16-bit floats* Doesn't add add anything substantial to my remark about "saving space in large arrays". 
Is that why they do it? And not because it's faster?
In practice, `*read-default-float-format*` is a bad idea, and it's best to leave it alone. Since it's `single-float` by default, people tend to assume that, and write code that assumes that, including type declarations. In a good scenario, that leads to errors; in a bad scenario, e.g. with `safety` set to zero, it may result in corruption. Note that you intend to set it to `double-float` precisely in order to save yourself from writing `d0`, thus creating the same issue from a different angle.
I thought I understood this, but here is something that is baffling me: From the hyperspec entry on encode-float, etc: (multiple-value-bind (signif expon sign) (integer-decode-float 37.937045) (print (list signif expon sign)) 
Came here to say basically this. Thank you for beating me to it.
When Common Lisp was being developed, there were computers from many different manufacturers with different word sizes and floating point formats. For programs to produce the same results on different architectures, the programmer had to be able to inquire as to the details of the floating point format in use. So functions such as integer-decode-float were created. Using this function we can examine the floating point numbers in the region of 37.937045. (defun list-neighbor-floats (start n) (multiple-value-bind (signif expon sign) (integer-decode-float start) (loop for sig from signif for return-float = (* sign (scale-float (coerce sig 'single-float) expon)) repeat n do (format t "~8d ~12,6f~%" sig return-float)))) This produces significand floating point 9944967 37.937040 9944968 37.937042 9944969 37.937046 &lt;= the closest float in the region 9944970 37.937050 9944971 37.937054 9944972 37.937057 9944973 37.937060 9944974 37.937065 9944975 37.937070 9944976 37.937073 The floating point number is actually exactly 9944969/262144 (#x97bc05/#x40000), or exactly 3.7937046051025390625 in decimal. Every floating point number has an exact decimal representation, but not every decimal has an exact floating point representation, that is because floating point uses only powers of two while decimal uses powers of two and powers of 5. This is unfortunate, as Guy Steele pointed out. The imprecision that people see in floating point numbers comes from the rounding that must be performed to fit the result in a limited space, not from the individual number. Floating point numbers are a brilliant engineering device, but they are not really numbers in the mathematical sense. For instance, (= (expt 2.0 24) (1+ (expt 2.0 24))) =&gt; t, from which it follows that 1 = 0, which pretty much causes mathematics to fail. Be careful with floating point! 
So `rational` gives the exact floating-point representation. But the problem is since the `*read-default-float-format*` is set by `single-float` by default, it's still having inaccuracies when coercing `rational` into a `float` just like what fisxoj said.
&gt; So `rational` gives the exact floating-point representation. No, rational is not a floating point *representation*. It is an exact numerical representation of rational numbers. `Ratio` is a way of representing real numbers that is exact for rational numbers but of course inexact for irrational. Floating point is another representation for real numbers that is inexact for rational and irrationals but happens to be really efficient and exact enough for a large class numerical computations. CL-USER&gt; (/ 37937045 1000000) 7587409/200000 CL-USER&gt; (coerce * 'double-float) 37.937045d0 Common lisp `number` type hierarchy: * number * real * rational * integer * fixnum * bignum * ratio * float * short-float * single-float * double-float * long-float * complex
Interfacing with C is comparatively simple, especially because of it's lack of name-mangling. Personally I don't really like C++, but it's not a very bad language either- but if someone's main point is how easy it is to interface, they shouldn't use C++ in my opinion
What are the longer term plans for CLIM-TOS development time? Getting either McCLIM or CLIM-TOS really solid and up to the spec seems nontrivial, and doing both at the same time seems especially difficult.
The requirement is: &gt; the product `a*(b^n)` is unchanged from state to state You're right that when `n` is even, `a` is unchanged until the final state. But the other two numbers (`b` and `n`) change, and the value of the product as a whole (`a*(b^n)`) stays the same: b n a a * b^n (exp-iter 2 8 1) = 1 * 2^8 = 256 (exp-iter 4 4 1) = 1 * 4^4 = 256 (exp-iter 16 2 1) = 1 * 16^2 = 256 (exp-iter 256 1 1) = 1 * 256^1 = 256 (exp-iter 256 0 256) = 256 * 256^0 = 256 
You are right, that makes sens, *a* doesn't have to change from state to state, but **a * b^n** has to. Thanks a lot
You are still using floating point numbers in every single example there. It actually quite nicely demonstrates that the single-precision floating point value 37.937045 is not equal to 37937045/1000000.
You can do it in javascript with sweetjs. https://www.sweetjs.org/doc/tutorial.html#sweet-cond 
We don't make any longer plans for it. I spend part of my time on each implementation (and this is at my discretion), but it is up to other contributors to give CLIM-TOS a spin. I've just hinted in the post, that some groundwork has been made and it "works".
What you should do is bind this variable, not set it, and bind only around the routines doing input/output. Changing or depending on global state means your code will not work well with others.
That looks like `CL:COND` not like common lisps's condition system.
Slightly related: I wish we could have real coroutines on CL :(
Couldn't you just implement one on top of CL-CONT? I don't know how well delimited continuations work in CL, but i suspect cl-cont is somewhat of a hack. For guile, they are a godsend. Andy Wingo's Fibers are really friggin cool.
I guess this was the most efficient (fastest execution) way of implementing it. I guess they could have also split each block in functions and then inline them into the block, but then, as one [wise guy said](http://web.mit.edu/humor/Computers/real.programmers), "*Real Programmers aren't afraid to use GOTO's.*" 
I think that this invariant is just a way to conceptualize the steps. We start with, say a = 1 and b^n being the inputs to the exponentiation. Since a = 1, b^n = a b^n. Then we somehow whittle away the b, and update a, producing a new a' and b' such that a' b'^n = a b^n. We keep doing this until b reaches 1 and so b^n disappears, leaving the answer in a. Of course, with recursion at our disposal, we don't in-place modify a and b, we can just recurse. 
Well, no, *a * b^n* doesn't change; it's always 256! The reason *a* doesn't have to change because one possible recursive case is that there is a rearrangement involving only *b* and *n* so that *b^n* stays the same.
Quite interesting. -1- I am currently checking gsll ? How does it position with Magicl ? both seem to have a link to BLAS and LAPACK. I am guessing that the difference is in the declaration of matrices gsll is based on a sub-package called grid. Your solution is more "lispy" isn't it? -2- I have tried to work with DASKR (a DAE solver with root finding solutions in Fortran) recently ... but bumped into a personal wall with the call of a second fortran function from a first function called by lisp through cffi (I know not well presented). You mention in your work you fixed bugs in the Fortran parsing ? What does it mean ? Have you heard of DASKR ? 
That's a shame. I am hoping for delimited continuations to be a part of at least r8rs (even though they are proposed for r7rs-large, I doubt they will make it in). They are much easier to work with than call/cc, and are much faster as well. They provide a good generalization on which coroutines can be built (although maybe a bit slower than special case coroutines). 
What does Numpy do? 
Hi Xach, Numpy is a Python library that includes a lot of functions for numerical computing. Most of those functions are implemented in C, for speed. It is extremely popular, and another very popular Python library (Scipy -- almost a scientific computing enviroment) is built on Numpy as one of its essential ingredients. For example with Numpy you can do FFT, matrix operations, etc. 
I don't do numerical computing things, but it seems a little unfair to be critical of a useful library like MAGICL because it's not more like Numpy.
Yes, I fully agree with you. 
I wrote a C wrapper for ClanLib and another for Gamebryo (both C++ game libraries) and could use them in Corman Common Lisp with that implementation's DLL support and FFI. Large numbers of small object allocations (e.g. collision contact tuples) killed performance, making it have 100ms frames in momentary intervals. I'm sure that's changed, but not completely. Even in pure C++ land these days, my own game engine requires specific memory management strategies for large numbers of small objects per frame in order to keep framerate smooth. Cache coherency isn't a thing I would even want to ponder for long in a lisp. In C++, it is doable. It has two orders of magnitude of gains for well formatted data and justifies the use of C/C++ in a large lisp system.
I agree, it was surprising to me that it just wasn't possible; given how powerful Common Lisp is in general. In C, there are several viable implementation options. Though having just spent some time in the language implementation [swamp](https://github.com/basic-gongfu/cixl), I can certainly see why language designers in general avoid continuations. They severely limit the implementation options and/or increase the number of hoops you'll have to jump through.
Hello. We definitely want to make the high-level interface a lot better. It currently crudely serves our needs, but it welcomes a lot of thinking and API design. 
GSLL was buggy and didn’t work for us, especially with complex numbers. MAGICL has a parser to generate bindings from LAPACK-style Fortran files. It can be readily used for that purpose if you have some Fortran code you’d like to use in CL. 
How flexible is the parser compared to, say, f2py?
Thank you. I'll give it a try. Especially interested in using DASKR (as previously mentioned). Some built an interface with Julia and others such Scilab , I am wondering about common-lisp. https://github.com/JuliaDiffEq/DASKR.jl Are you working with solvers as well ? 
It’s not a full Fortran parser. It’s enough to get declarations reliably (which is difficult!).
For call/cc that is definitely true, but delimited continuations is a different beast. The implementation in ocaml is for example implemented in pure ocaml as a library that can be loaded without affecting the performance of the code not using continuations. I think the same is true for Haskell. Undelimited continuations are hardly useful, whereas delimited ones are not only easier to use and reason about, but also faster and less prone to leak memory. The heritage of call/cc in scheme will forever plague implementations, since they, as you say, severely limit implementations. Using continuations in Bigloo and gambit is a nice way to make your program run 70% alower
My mistake, you are right *a^b* is constant. That a perfect explanation of why *a* is unchanged 
&gt; I agree, it was surprising to me that it just wasn't possible; given how powerful Common Lisp is in general. Continuations will mess with unwind-protect 
As far as I know, green threads need coroutines.
If we go into comparison there is also a symbolic manipulation library called sympy. I personally , on small computer , prefer to use Maxima which is (as you know I am sure) coded in lisp. Mixing maxima, lisp numerical tools similar to numpy or Magicl and modern solvers would be great. The top for me would be to see , one day ,the power of CLOS at the service of dynamic system analysis , just as it is done in Modelica (and metamodelica). So for me Magicl is welcome :-).
December 28, 2018... Somewhat morbid typo.
Sorry to hear about Lowell Hawkinson. He gave an entertaining talk at ILC 2010 in Reno about the history of Gensym.
I never get tired of reading those, especially the condensed Highlight Film I compiled from the best excerpts. Sometimes we forget how great a language we enjoy. I think a Road to Clojure survey would be great, too, and much different. 
&gt; Even if the project had had more mature leadership, it probably could not have overcome the unfortunate choice of an ALGOL-like syntax and type system, overemphasis on compiled code efficiency, and the obscure choice of first machine to build for [...]. LISP’s fundamental strengths were lost in LISP 2’s design.
Well, you are calling TESTME::TESTME when it is indeed undefined, you forgot to compile it. Nothing's changed about that. And the thing the NEWS entry is referencing is for compiling broken code.
Pretty much everything we need from Lisp history, we **have**. In living implementations. Mostly, the "different stuff" is discarded old ideas. Can you think of a single thing that might be worth implementing (now or in the future) that is not already known "in the literature", other than through some historic Lisp preservation project? (I mean: some historic Lisps had it, current ones do not any more, and it's so obscure that only source code and documentation for those Lisps covers it.) 
I am copying manually each page, and I will submit it as org (or markdown) text to those repos. It will take some time though.
The compilation I think is not the issue, as it compiles ok. Its the availability of the compiled code in the other window, the REPL.
Good luck with the lisping :) Also if you use `C-h m` in the buffer with your code in it, emacs will open a buffer showing all the shortcuts for the major and minor modes applicable to that buffer.