What do you think of Racket vs Common Lisp?
And why someone shuld learn Racket?
Python (scripting language, not the compiler) conférences
The key word here, I believe, is ‘meta-programming’- that is treating a program as data and therefore, being able to manipulate it programmatically. To do this, you need a homoiconic language such as lisp, prolog or even assembler.
In any lisp, Macros don't come first. They can range from simple (to the point of doing very little functions can do) to being very complex and powerful. But doing so requires not only an understanding of the essence of a lisp (code is represented as lists, therefore can be generated by other functions and eventually emitted and evaluated at the last possible moment. This of course requires an understanding of the syntax and nuances of stuff that goes in macros). for the most part a lot of what you can do in other languages you can do in lisp, you just structure it differently. Most code in other lanugages are "unbounded" in that they don't always seem contained by some boundary characters ( (,\[,{...etc) and seems more "free form". Also unlike other lisps, most things that would be special syntax structures that can't actually be assigned to - like the if statement, case, etc - are represented as functions. This makes the language easy to parse since it has a consistent structure. You can assign to a value the result of an if statement or cond (case) rather than do mutation of some earlier declared empty value to get it. This I think is one of the greatest things about it, functions are language features and thus allow you to add more, as opposed to if you wanted to create some new syntax structure in a c-style language.
Culture shock. Nothing else. This is only a subjective opinion: lisp has different roots, it's on the mathy side of things (even though emacslisp is not the best example of this). In this world you rarely contain state, you apply function to data. The thing is even CLOS, has a functional core to create a class system, that doesn't help one designing solutions in objects. Maybe try reading Practical Common Lisp (if not the case already) ? I suppose most languages you wrote with were imperative stateful ones, they all share the same mindset, store something, change it, repeat. But there are other languages and paradigms, that are even more strange than lisp. Pure fp like haskell, logical programming in prolog, APL .. Back to your request: I believe you just need time. It will click. And about the programmable programming language: it's from the fact that lisps system are not silos (no standalone parser, separate compiler). You can hook in the sexp parser to have your own syntax [0], you can twist the evaluation process with macros. So basically, you can layer your own programming language on top of lisp core. Compare this to, say, Java, where until recently, you had to suffer immenses amount of redundant boilerplate with zero way to avoid it.. it makes lisp look like heaven. But it's a very different world. [0] many lispers (not me sadly) did so: they added embedded json or html syntax, so their code can describe and manipulate such data without friction. It's so natural to lispers that they don't even blog about it. Some just hack the pretty printer system to ~compile to pascal http://www.merl.com/publications/docs/TR93-17.pdf [more](https://www.reddit.com/r/lisp/comments/1totwx/some_useful_lisp_algorithms_part_2_pretty/)
I used to be in the same boat as you, people sure do love to throw around that smart phrase, but it doesn't mean anything to someone who is not yet experience with Lisp. Programmable programming language means you can changed how the language processes code. You can add new language features yourself, you can make them into a library and thus allow others to retrofit their Lisp with those features as well. Let's take a hypothetical example: you want to get the current time and current temperature from some sort of sensor, log both, then do some computations with them. You cannot fetch the current values every time you need them because you will be getting different results, you need to bind them to variables first. Here is how Python would do it: time = get_current_time() temp = get_current_temperature() log_time(time) log_temperature(temp) foo(time, temp) bar(time, temp) baz(time, temp) Let's for the sake for argument assume that Lisp cannot do bind local variables. The only way to create a local lexical scope would be to use an anonymous function: (lambda (time temp) (log-time time) (log-temperature temp) (foo time temp) (bar time temp) (baz time temp)) We would then have to apply this anonymous function directly to the values we wish to bind: ((lambda (time temp) (log-time time) (log-temperature temp) (foo time temp) (bar time temp) (baz time temp)) (get-current-time) (get-current-temperature)) This is awful, it is hard to read and it is completely un-idiomatic. When I see code like this I have to stop and think *why* things were done this way. It is also easy to get the "ritual" wrong because of how convoluted everything is. What we would want instead is another form that gets rewritten to the above mess by the machine. Our new form should have a more meaningful name like `let`. It should put the variables and values next to each other and the instructions at the end. Like this: (let ((time (get-current-time)) (temp (get-current-temperature))) (log-time time) (log-temperature temp) (foo time temp) (bar time temp) (baz time temp)) Now this is much more readable and also included in every Lisp standard, but if it wasn't you could have easily added it as a macro and there would have been no difference. In fact, most of the features you have in Lisp are actually just macros which implement those features on top a few core concepts. The idea is that you give your program some specification and the compiler then re-writes your program according to those specifications. OK, that's a neat trick, but why would you want to do that? For one, it allows us to add new features and paradigms to Lisp. When Stroustrup created C with classes (aka C++) he could not retrofit C with OOP, instead he had to have an intermediate program that would translate his C dialect into proper C and compile that intermediate result then. In Lisp you could just add OOP as a library. Instead of waiting for a standards committee to add something to a language (like a proper module system to C++) you can have the community create and maintain that feature. Aside from adding big new features you can also add small domain-specific features which would not make sense outside your project. The [Guix](https://www.gnu.org/software/guix/) project has added a GNU/Linux package definition language to Scheme, that way you can write package definitions in a JSON-like form. Personally, I have written a small test-specification language for my MessagePack libraries: [https://gitlab.com/HiPhish/guile-msgpack/blob/master/test/pack/integer.scm#L26](https://gitlab.com/HiPhish/guile-msgpack/blob/master/test/pack/integer.scm#L26) The first item is a little description of the test, the remainder are test cases. Each test case consists of the integer to test and a sequence of bytes to test against. Here is the implementation: [https://gitlab.com/HiPhish/guile-msgpack/blob/master/test/pack/utility/test-cases.scm#L29](https://gitlab.com/HiPhish/guile-msgpack/blob/master/test/pack/utility/test-cases.scm#L29) Having a test-case DSL allows me to save a lot of boilerplate code, avoids mistakes by typos and makes the test specifications much more readable. Even if you don't know Lisp you can still read my test specifications. Another recent case for macros: I generate my website using GNU Guile and I have a page dedicated to [my (Neo)vim plugins](http://hiphish.github.io/vim/plugins/). To generate the HTML I need a list of plugin names, a list of plugin URLs and a list of plugin descriptions. That's three lists I need to keep in sync, because the number of items and their order is important. [https://github.com/HiPhish/workshop/blob/master/content/vim/plugins/index.scm#L118](https://github.com/HiPhish/workshop/blob/master/content/vim/plugins/index.scm#L118) And I need to do that same thing for Neovim. Instead of keeping six lists manually in sync I added a little Vim-plugin-specification-language to Scheme: [https://github.com/HiPhish/workshop/blob/master/content/vim/plugins/index.scm#L8](https://github.com/HiPhish/workshop/blob/master/content/vim/plugins/index.scm#L8) This was so trivial, the most time-intensive part was writing the docstring. Here is it in use: [https://github.com/HiPhish/workshop/blob/master/content/vim/plugins/index.scm#L23](https://github.com/HiPhish/workshop/blob/master/content/vim/plugins/index.scm#L23)
\&gt; CLOS. My code seems bulky and functional That's not unusual. CLOS was developed [as a blend of functional and object-oriented programming](https://www.dreamsongs.com/Files/clos-cacm.pdf). Some classic books in that area: [On Lisp](http://www.paulgraham.com/onlisp.html) (macros, ...), [PAIP](https://github.com/norvig/paip-lisp) (extending Lisp with various paradigms, implementing languages), [AMOP](https://en.wikipedia.org/wiki/The_Art_of_the_Metaobject_Protocol) (implementing CLOS in CLOS).
\&gt; I switched from NeoVim to Emacs about 8 months ago (although I’m still using evil keybindings). My main reason for the switch was dissatisfaction with VimScript, as well as some performance issues making me want to start from scratch. You can write Neovim plugins in any language as long as there is a [client](https://github.com/neovim/neovim/wiki/Related-projects#api-clients) implemented for it. For Lisp there are clients for Common Lisp, Clojure and Racket (that one was written by me). &gt; Lisp is better than VimScript by far, but that’s not hard. Vimscript is not really a language, but a series of commands. It's actually quite good for what it was intended to be: a small language for configuring a text editor. It's awful for anything beyond that though. &gt; But it’s so unlike any other language I’ve ever used. I’ve always used classes as a way to write code. But lisp seems to not enjoy the concept of classes at all. Even with CLOS. My code seems bulky and functional. There’s no feeling of design in it, like a junior high school student writing their first 400 line program in BASIC. I struggle to find ways to contain state. Lisp is unopinionated, there is no correct way to write your code. This can feel disjointed, but it means that you decide what is the best approach at any given moment. If you brain has been damaged by the idea that OOP needs to be used everywhere it will take a while to undo the brainwashing, but after a while you will be free again. I should also mention that Emacs Lisp is not like the other Lisps, so don't let that particular dialect taint your impression of the Lisp family. If CLOS feels out of place for the given task, then it probably is. &gt; I’m wondering if there’s something I’m missing. Am I just too in experienced? Probably the latter. I did not start using macros until quite a while later. I was braindamaged by the idea that a language has a fixed set of features, and everything else has to be implemented with only those features. So instead of writing a macro that generates me three lists and a simple function that takes three arguments, I would write one large complex tree-structure and a function that takes in one argument and plucks it apart internally. Instead of writing a test-specification language I would copy-paste the boilerplate or write a function which takes in several arguments and applies the boilerplate.
I'm probably not the best person to answer your question because I'm a relative beginner and I'm writing Scheme, not eLisp. On the other hand I am loving it, so maybe I can provide some insight on why you might too. &gt;But it’s so unlike any other language I’ve ever used. A reason to love it in my opinion - expand your mind and don't get stuck in the same patterns of thinking! &gt;But lisp seems to not enjoy the concept of classes at all. That's right. But things aren't so very different when you get into the style of closing over a lambda and returning it - you've just created an object with one method! I know that sounds crazy but I looove programming with 'function factories', it feels so much more flexible and simple. See [this chapter of Let Over Lambda](https://letoverlambda.com/index.cl/guest/chap2.html) to see what I mean - though I wouldn't bother with the rest of the book just yet, it's crazy advanced macro-philosophy. &gt; My code seems bulky and functional Hmm, bulky and functional aren't two words I think of together very often. It's OOP, where I regularly end up with 1000+ line classes, that I think of as bulky. If you adopt a functional style (i.e. mostly pure functions, with state mutation only in a few special places in your program) it becomes easy to break functions into smaller and smaller pieces. And don't be afraid to define functions inside other functions if you prefer to keep the pieces hidden. The usefulness of macros often only becomes apparent _after_ you've decomposed your program into small functions. It's then that repetitive patterns become obvious, and you can abstract away. These are just my brain-dump of why I'm enjoying this journey.
haha, sorry
In a nutshell. But this is only a problem when you can't earn a living with it. Or at least find a group to solve problems in Lisp so you can improve your work life.
I'm also a Ruby developer and I think I can understand your feeling; LISP requires some efforts to better understanding how this power can be used. First of all, some terms used by LISP sounds diferente from what we call in Ruby; metaprogramming is the one most hard for me: while we think about metaprogramming in Ruby from a semantic only point of view, where some methods creates other methods using methods and constructions provided by the Ruby Kernel and another core modules (examples which came from the simple attr_accessor method to create getters and setters until the powerful and expressive methods from Rails like has_many/belongs_to which by a simple call - in the class level - adds tons of methods to that class); in LISP the thing goes completely into another direction where the code can be changed directly using code because the representation of the code can be treated as a simple list of data, you can for example take a block of code and change its behavior by changing the code itself from the running program (think about changing the name of one variable or method within a block within the code itself.. and when you includes macros, we are talking about changing the way some codes will be read and parsed by the language... you can't redefines the way Ruby will read the "end" for example... actually, besides it's extremely flexible syntax, Ruby don't allows you to change nothing on it). This metaprogramming thing is not just a feature of the language (I'm working with Ruby since 2005 and I remember using strings+eval to add a method because the define_method wasn't there); for LISP, it is there from this conception 60 years ago and when you look how Mr. McCarthy put this power into the heart of the language, new kind of thoughts appear in your mind, you start thinking about programming into another way that even SmallTalk and consequently Ruby doesn't. A decade ago people has tried some things with Ruby to test some concepts where you write code in pure Ruby and it is translated to another kind of paradigm, says for example programming using pure Ruby and inferring a SQL from it - Github founder had this project called Ambitious which made this kind of stuff... To make this work you need a entire environment with a lot of resources in Ruby (and by curiosity the way he manipulated the code was by interpretation of the AST of the Ruby code, using practically a LISP style of code); For a LISPer nothing beyond what LISP itself offers is needed, and this is just the way to do the things. Well, just to cite another examples besides the metaprogramming, two other practical things that I have found in (Common) LISP and are amazing are the resets for errors which makes me perceive how Exceptions are just one abstraction to deal with errors and how it could be more advanced (I didn't found this concept in other languages, is there any mainstream language with something similar?); and the OOP in LISP goes way beyond anything we can dream in Ruby and even SmallTalk... the MOP is unbelievable deep, when you think Ruby have some clever ways to organize and provide OOP, read the MOP book and you will feel like Ruby has not get 70% of the whole ideia.. one very simple example is when you think Rails should write his own way to say "before" and "after" for methods when the CLOS have this by default to any method... but this is superficial.. I know almost no people which uses Ruby resources like method_added hook and people generally ask why this even exists but when you read the MOP book you perceive how little this kind of resouces exists in Ruby and how much deeper the thing can go.
Just one amazing example: yesterday I found this link here on Reddit: https://m00natic.github.io/lisp/manual-jit.html Now try to make a comparison with Arel, think how complex and how much effort is needed to create something like this in Ruby
You got some smart 5 year olds
Given the ELI5 request, this is my somewhat futile attempt. Imagine building something using Lego. There are a myriad of blocks, bricks and pieces that you have at your disposal. You can build a lot with it and generally the blocks are well known and formalised. Working with lisp is like using using Play-Doh. While there are predefined moulds (frameworks, tools etc) you can use to make shapes, inevitably lisp gives you the freedom to make any shapes you want.
IMO APL isn't an independent programming paradigm, more like a Code Golfing on Wall Street vehicle.
&gt; Am I just too in experienced? I picked up Ruby in a week. Matz is a huge fan of emacs lisp and Ruby is actually very lisp-like. I think you're just getting thrown off by the look of parentheses when you're used to using keywords (end).
1. It's based on Scheme, which was the brainchild of some very smart people and real torchbearers of our guild. 2. Its current status is the result of many very smart people working on one system for nearly 25 years. 3. These are not vain words, but the result of this that Racket is now an environment with a huge functionality, where still (close to) all the bits are very well thought out and honed over decades. You'll get included batteries like web-server, GUI, full numeric tower, a macro-system which has seen just so much love, docu-generator, slide-show-generator, optional typing, great FFI, stunningly good documentation (locally installable for your next offline coding session), IDE, debugger and more. Sure - you'll get even more with Python, but there you always feel that you have to compromise features and pragmatism over beauty (and sometimes performance). Racket really is over the tipping point, where its features are strong enough that it can combine beauty and usefulness as rarely found elsewhere. 4. You can still quite effortlessly jump between full-blown Racket and a specialised Scheme dialect. The proliferation of Schemes is often complained about, but a positive effect of that is that you can apply your Scheme knowledge in nearly all environments, e.g.: JVM -&gt; Kawa, .Net -&gt; IronScheme, scripting: Gauche, Guile, embedding: Guile and other smaller dedicated Schemes, fast standalone executables: Gambit, Chicken, Bigloo, whatever you like: Chez (which is also the basis for the next Racket). And again most of these implementations are no obscure niche products but they are being worked on often since decades by splendid people. I personally switched to Scheme/Racket after literally decades of language-shopping for all my personal projects, and I'm still in awe every day working with it.
JEAN-Marie passed away on Monday this week. He will be remembered.
I think the axes are more along the lines of - Minimal: C and Rust - Functional/Meta-circular: ML, Prolog - Dynamic: CLOS, Python
That's sad. Much too early!
Great answer!
Do you have a repository for it for apt?
Most of the issues you're running into seem to be a result of trying to force OOP code where you don't really need it. Ruby, Python, C++, et al. are all OO languages, so everything depends on the current state. Lisp is a functional language, so the goal when writing your code is to make everything independent of the state. It's like math, 1+1=2 whether you're standing, sitting, writing it out, or doing it in your head. As a result, you tend to do a lot of recursion. Common datatypes such as lists work differently. Keep at it and you'll get there. I suggest reading up on functional programming and see now people usually think when writing in this style.
Yeah, APL is a strange one. I perhaps should have said Plankalkül rather than APL because it was the first array-based language (and also the first high-level language). The real importance here is Matlab though. It's essentially APL with ASCII syntax. While "real programmers" don't give it too much thought, almost everything designed in the last few decades relied on Matlab at some point.
Funny thing is there is someone whose HN is Bike and is a lisper.
Why do you care?
Yeah, when I first read the project name I assumed that Bike was the author and just got a little narcissistic :P
That looks really nice!
For now, there is no .deb but contributions are welcome! Installing from the download page is really not hard: extract the archive and run `usr/local/bin/next`. Alternatively, you can install the Guix package manager and install Next from there.
You could try [Common Lisp: A Gentle Introduction to Symbolic Computation David S. Touretzky](http://www.cs.cmu.edu/%7Edst/LispBook/) This book originally was used as an Intro to Computing book for psychology majors at CMU.
If you've done some previous programming, Practical Common Lisp. If not, Gentle (as linked below).
This makes me really, really happy. Like a birthday present. And i'm pretty sure will be very useful for many things in the near future. The quote from Syd Barrett's Bike was the icing in the cake. &gt;This time, on .Net Core, without a line of C++ code, and fully cross-platform Wow! &gt;Now you have the batteries included! Which are of the size of **Battersea Power Station.** Love the Pink Floyd references. Let's set the controls for the heart of .NetCore!!
Clojure is "Worse is Better" applied to Lisp. It was originally implemented as the most simple contraption that could look kind of Lispy, and it barely even worked. It still has that stupid "recur" construct because Rich Hickey decided it would be easier to implement than TCO (he claimed that it would be impossible, but there are [techniques](http://home.pipeline.com/~hbaker1/CheneyMTA.html) that would have worked)
Nicely done!
The structure and interpretation of computer programs can be downloaded for free, and is a bit of a classic by all accounts. I haven't fully read it myself yet though! https://web.mit.edu/alexmv/6.037/sicp.pdf
Thanks. But I’m familiar with this book, and I wouldn’t call it neither easy nor approachable.
The about is that you don’t get to actually program anything, right? Which is not necessarily a bad thing. I’m dumb, I could use the visuals.
I don't think you don't get to program anything. If you want to get practical and are tired of the pictures, you should be on the level where you are able to grab PCL.
&gt;My manager finally convinced me by telling me about Lisp You're the luckiest employee in the world, for having such a manager. &gt;I’ve always used classes as a way to write code. Some stuff is easier done using message-passing OOP, which is what you probably understand as "using classes". Some stuff is easier done using multimethod-dispatch OOP, which is what CLOS let's you do. Some stuff is easier done using functional programming Some stuff is easier done using plain imperative, procedural programming Some stuff is easier done using logic programming. Lisp allows you to write your code in any of those ways. It's up to you to choose which approach suits better the *particular* thing you're programming. &gt;But lisp seems to not enjoy the concept of classes at all. I fail to understand which part of CLOS does not let you "enjoy" the concept of classes, because CLOS lets you do everything you could do in Ruby, Java, and C++; and then more, much more. &gt;There’s no feeling of design in it If a piece of software can be understood without too much effort and can be evolved, maintained, and/or debugged without unneeded complication, then it might be said to be "designed properly". Java -to pick an example- gives you some tools to create software that is "designed properly", like packages, interfaces, classes, exceptions, generics, and compile-type checks. Lisp gives you some tools to create software that is "designed properly", like packages, multimethods, classes, meta-object protocol, the "condition-restarts" exception handling system, a flexible type system, strong typing, extremely powerful debugging features, ability to correct a system while it's running, homoiconicity, and macros that dramatically reduce boilerplate code. If the software *you* create with Lisp doesn't give you a "feeling of design", then it's not the language's fault! &gt;TLDR: what do people mean by the programmable programming language? You can program the compiler to transform some of your source code onto different source code. This can happen on compile time or it can also happen at runtime, because the compiler is also available at runtime. This makes Lisp a "programmable programming language". But, additionally, the fact that Lisp source code is exclusively made out of lists and symbols, and that Lisp makes working with lists and symbols very easy, means that manipulating Lisp source code, using Lisp, is also very easy. This makes Lisp a particularly good "programmable programming language."
paging /u/PuercoPop, who is a Lisper that knows and has used Ruby in depth.
I wonder if OOP will be regarded as the middle age of programming. That is, if humans survive climate change well enough to care about programming history.
- because the [Guix](https://www.gnu.org/software/guix/) universal package manager and distro just turned 1.0 and is written in Guile Scheme - because the [Next browser](https://github.com/atlas-engineer/next) is growing and hackable in CL - because CL just got the [Ultralisp](http://ultralisp.org/) quicklisp distribution and it's a great improvement - because we're looking forward for [awesome libraries](https://github.com/CodyReichert/awesome-cl) to mature ([Coalton](https://github.com/stylewarning/coalton) brings ML-style type checking to CL, [iup](https://github.com/lispnik/iup/) brings an easy, lightweight, fully-featured and cross-platform GUI library, the [Weblocks](http://40ants.com/weblocks/) web framework is already good enough to build Ultralisp,…) - and the REPL + Slime is still an unmatched and cool experience.
I've also used FOIL for interfacing with the CLR, fwiw.
&gt; I can’t understand what it means to use Lisp to write language. I try to figure it out, look at some tutorials on Macros and such. But when I think I’ve figured it out, I don’t gain to ability to leverage that power. Here's what it means to use Lisp to "write language": You can make Lisp act more or less the way you want. Suppose you wish Lisp had objects that behave like the ones in Ruby. Unlike CLOS, Ruby takes the Smalltalk view of OOP, where you "send messages" to objects instead of calling functions on them. You could create some macros that transform the code that you'd rather write into the code that CLOS expects you to write. Below, I also use some features of CLOS to help things out. First, a method to "send a message": (defgeneric send (object message &amp;rest parameters)) This method makes it possible for method "foo" on one class to have a completely different argument list from "foo" on another class. They can have zero in common. A traditional method can then be defined using an EQL-specialized CLOS method: (defmethod send ((self my-class) (message (eql :my-message)) &amp;rest parameters) code...) ;; Call it like this: (send my-obj :my-message foo bar baz) &amp;#x200B; But that's not very traditional. In traditional OOP, `obj.method` is the norm, and the same syntax also accesses data members. It would be easier, and arguably still acceptible, to implement `#[obj method -&gt; args]`. If the arrow is omitted, then it's an access to a data member. That way you can just check for the arrow and you know if you have to generate a `send` or a `slot-value` call. A reader macro can read directly from the source file or REPL (it doesn't care which), and it can return literally anything you want. (set-dispatch-macro-character #\# #\[ (lambda (stream &amp;rest who-cares) (declare (ignore who-cares)) (let* ((object (read stream)) (member (read stream)) (closing-bracket (read stream))) (cond ((equal (symbol-name closing-bracket) "]") `(slot-value ,object ',member)) ((equal (symbol-name closing-bracket) "-&gt;") `(send ,object ,(intern (symbol-name member) :keyword) ,@(loop for arg = (read stream) until (and (symbolp arg) (equal (symbol-name arg) "]")) collect arg))) (t (error "Unexpected token: ~s" closing-bracket)))))) Finally, in traditional OOP, the methods and data members are all wrapped up in a single class definition form. A macro can provide a syntax for doing this. It would allow you to write this (like Python, `self` refers to the current object. Object members and methods can only be accesed through `self`): (my-defclass circle () ((x :type number :initarg :x) (y :type number :initarg :y) (radius :type number :initarg :radius)) (defmethod scale (scalage) (setf #[ self radius ] (* #[ self radius ] scalage)))) ..and have it expand to this: &amp;#x200B; (PROGN (DEFCLASS CIRCLE NIL ((X :TYPE NUMBER :INITARG :X) (Y :TYPE NUMBER :INITARG :Y) (RADIUS :TYPE NUMBER :INITARG :RADIUS))) (DEFMETHOD SEND ((SELF CIRCLE) (#:G642 (EQL ':SCALE)) &amp;REST #:G643) (DESTRUCTURING-BIND (SCALAGE) #:G643 (SETF (SLOT-VALUE SELF 'RADIUS) (* (SLOT-VALUE SELF 'RADIUS) SCALAGE))))) The macro definition: (defmacro my-defclass (name (&amp;rest superclasses) data-members &amp;rest function-members) (let ((message (gensym)) (parameters (gensym))) `(progn (defclass ,name ,superclasses ,data-members) ,@(loop for (method method-name lambda-list . body) in function-members if (eq method 'defmethod) collect `(defmethod send ((self ,name) (,message (eql ',(intern (symbol-name method-name) :keyword))) &amp;rest ,parameters) (destructuring-bind ,lambda-list ,parameters ,@body)) else do (error "Syntax error at ~s" method))))) Some examples (defvar *circ* (make-instance 'circle :radius 1 :x 10 :y 10)) #[ *circ* x ] #[ *circ* y ] #[ *circ* radius ] #[ *circ* scale -&gt; 13 ] #[ *circ* scale -&gt; 1/2 ]
The expressiveness of any computing system is defined by three things: means of primitives, means of combinations, and means of abstractions. Lisp got all these three right. If you still see the parenthesis, you are not an advanced user yet. If you still think in OOP, functional, declarative, etc. programming, you are not an advanced user yet. Think in those three things and just put the parenthesis into the text to make the computer understand you.
My examples: For scientific programming it would be cool if the we could program while always entering number with their scientific units, right? But of course we don't want to drag them around at runtime. Can you go for a unit-entering syntax while programming that is eliminated when it can be checked at compile time? Without changing the language and without waiting for anybody to hack up the compiler. https://medium.com/@MartinCracauer/a-gentle-introduction-to-compile-time-computing-part-3-scientific-units-8e41d8a727ca You have what is supposed to be a dynamically typed language. Can you write code that is statically (compile-time) type checked. Without changing either your language or waiting for somebody to hack up your compiler. https://medium.com/@MartinCracauer/static-type-checking-in-the-programmable-programming-language-lisp-79bb79eb068a
That's fair, but I stand by my point--a beginner will hit the limits of their understanding before they hit the limits of the language. Just choosing to learn Lisp before Python will not magically make someone a better programmer. That said, the first language I learned was Logo, with the next two being Scheme and Emacs lisp. I can try to be objective about such things, but my soul at this point is fully parenthesized at this point.
I just want to say, you are insane for writing this whole thing without using version control. idk what I'd do without the ability to roll back, or create quick experiment branches.
well, i just used the rebase before pushing the thing to github :)
I'm curious why one would chose .net core instead of another, more mature vm.
sorry, not sure I'm following
well, i was pushing the all the things to my private repo actually, for some time, and then just did a squash of all the commits before making the repo public
actually it took like a month and a half to make the thing work, starting from a simple idea. but the code that was here in the first versions, was... too ugly, i'd say
I learned Logo as a kid, then I learned C. I didn't really get into Lisp until university, when it was taught as part of a compiler's course. My point is that how a computer understand your code can be massively different than what you thought you wrote. Learning Lisp forces you to learn how to think in the model that the computer is actually using. This is especially useful when you start getting into more advanced concepts and meta-programming techniques.
What the mature platforms do you have in mind? When i'm thinking of the phrase "mature platforms", i'm always thinking of Java first. But what are the costs of embedding Java? Then, of course .Net comes to mind. But then, here's the thing - .Net Core is just .Net with simply less Windows-specific features and better performance.
I think it starts with extremely basic building blocks and builds on that. I think it does require some investment and effort, it's certainly not something you can just read without putting a bit into it yourself.
My advice is to come up with a neat project and to write it in Lisp. Start by writing a lot of very small functions with long names, because that's good style. Eventually, one of these things will probably happen: - you'll realize that a lot of the functions you're writing look pretty similar - you'll want a clearer, more expressive format to represent some piece of information as text than can be achieved by defining or invoking a function At this point, write a macro. There are many ways to go about this, but my favorite is: 1. write, as an s-exp, the code you want to write, which expresses the part of your problem that's relevant and elides the part that's irrelevant 2. write the code that your macro-invocation would expand into 3. write a macro which transforms the first form into the second one Once you've done that a few times, it's hard to go back to languages that don't have (actual, ergonomic, good) macros.
I haven't tried APL yet but from the little I've seen I'd definitely consider it an outlier. A cool one though.
True, but I minored in linguistics so this phrasing conveniently makes sense to me. I don’t expect someone to teach a 5 year old lisp haha
In Common Lisp: [https://gist.github.com/lispm/145fc3e0967f42ff44a11e0670be1aef](https://gist.github.com/lispm/145fc3e0967f42ff44a11e0670be1aef)
&gt; I'm curious why one would chose .net core instead of another, more mature vm. I smell Java... Jokes aside; **Why would one choose Java or .NET when the wonderful world of Lisp and Scheme is available?** The answer is, when you're part of a bigger project or within a big company, there are some policies in place, and those policies can dictate which technology stack you will use. Or what will the `*preferred-platform*` will be. OR, even if there is no restriction, you'll have to interact (or extend) other systems which will be written in `*preferred-platform*`, Besides that, **why choose .NET over Java**? I can think of some answers: - You don't like Larry Ellison - You think Oracle is evil - You know the Microsoft CLR/CLI and DLR were created with support for multiple programming languages in mind, unlike Java's JVM. - You are not satisfied with the alternative programming languages to Java on the JVM: - ... Groovy: Nobody uses it anymore, and you don't like Ruby anyway - ... Scala: functional programming gone berserk for worse - ... Clojure: you don't like it so much - ... Kotlin: just a more comfy Java - ... Xtend: more comfy Java, and tied to Eclipse IDE - You think F# is acceptable OCaml - You think C# is acceptable, more so than Java or Kotlin - You like the Azure stack, Azure Functions, Visual Studio, and how those tools fit together. - You constantly play Steve Ballmer's "developers developers developers" video everyday in the morning, to get motivation. - You think Microsoft is no longer the evil player in this industry.
&gt; well, i was pushing the all the things to my private repo actually, for some time, and then just did a squash of all the commits before making the repo public I do something similar too. /u/lobe5an, i deeply thank you for your repository; i also many projects of yours that deal with .NET or the Windows platform, these are very much welcome. Have you added them to Cliki?
&gt; learning Lisp forces you... to think in the model that the computer is actually using I don't think this is any more true of Lisp than many other languages. I appreciate that with many lisps you *can* "write high level assembly". It *lets* you, but doesn't *force* you. Furthermore: * Understanding your compiler/interpreter is essential to writing performant code in *any language*. Saying, "learn Lisp so you can write efficient code" is a violation of Knuth's law: "Premature optimization is the root of all evil". * The immediate goal of software design is writing maintainable code that solves your actual problems. Modern computers are fast enough that for most tasks, sub-optimal code isn't an issue. * One selling point of lisp is how it facilitates DSL creation. But a program with lots of macros has its own layers of superficial syntax that disappear by the time the program runs. So the most powerful feature of the language also takes the programmer farther away from the kind of low-level programming you extol. Granted, this isn't a loss of control, since you can write the macros to expand to near-optimal code--but it does mean that in practice you can't always see what the compiler is doing without going through *all* the source. Anyway, stop making me argue against lisp. :P I love me some lisps, but I don't buy into the aura of being a "magical language that gives you programming superpowers". It's the most expressive language family--what more can you ask?
ah, most of them are too dated and of no interest, some - maybe, i think, even added to quicklisp, but most are not
\&gt; Holy cow! I’m incredibly grateful so many people took the time to help me out. We are nice because Lispers are \~\~fanatical\~\~nice people.
Wow, this is an insightful post. I'm saving it!
though, AFAIK, i can remember, for ex. that years ago, Luis Oliveira even took some ideas from my repos into CFFI \[here goes a picture with 30 year old boomer\]
It's a computer science introduction and won't help much with hacking GNU Emacs.
&gt; I don’t expect someone to teach a 5 year old lisp haha Logo was taught to me in an institute when i was 7 years old (the class was intended to children my age); and Logo is a dialect of Lisp, so...
Emacs Lisp tutorial: &amp;#x200B; [https://www.gnu.org/software/emacs/manual/html\_node/eintr/](https://www.gnu.org/software/emacs/manual/html_node/eintr/)
Well shoot... I stand corrected
Many of the other answers have been great, but I'd like to give it a go from a different angle. Most languages are broken up into the following phases: 1. Tokenizing+parsing 2. Compiling 3. Assembling and/or linking 4. Running This is irrespective of whether it not the language complies to machine code, byte code, or something else (e.g. compiling to C or JS). What's more important about the above phases is that they at each step they produce something orthogonal to the previous and next steps. For example, let's take C++: 1. Tokenizing produces a set of tokens. 2. The tokens are parsed and that produces an AST (abstract syntax tree). 3. The AST is walked and assembly code is produced. 4. The assembly code is passed to an assembler and object code is produced. 5. Finally the object code is sent to a linker that produces an executable. With Lisp, because code is in the same form as data, each of these phases (some different) produce the output data type (homoiconic). What this enables is that at every phase, the output is code that can be executed! And the output of that execution is also code that can be passed to the next phase! This is what makes Lisp macros possible. And it means that any Lisp program - when run - can output more code that the Lisp program can compile and run... at runtime (this is similar to, but conceptually different from eval in Python or JavaScript, for the same reasons provided above). Hope that helps.
I respect the original question ELI5, and u/__eastwood approach at answering it with Lego analogies. Here's my Lego inspiration: There are many different kinds of legos provided by the Lego company, designed and built at the Lego factory. You can imagine clever ways to stick these pieces together to make neat, really amazing things out of simple bits. You can combine a bunch of rectangular blocks to make something that another person could think is a triangle: - --- ----- Right now, if you want a new kind of lego piece, you have to hope the Lego factory comes up with it and starts selling it at the store, so that you can fit it together with other legos to make new things. Until then, the best you can hope to do is try to combine the pieces Lego sells into the shape you want (you may not even be able to do that if the shape is tricky). How much better could you build something if you could create your "own" custom lego blocks? Instead of snapping blocks together to try to create a rounded shape (which has sharp, rough edges and isn't really round), what if there was a kind of round Lego? Maybe you need a triangular shape, or a ring shape. What if you really wanted an oval shaped lego? It would be so much nicer if you didn't have to hope that the Lego company would decide to make the kinds of pieces you need, and then have to wait for them to sell the pieces. Lego gets to tell you how to build, and you have to listen because they make the pieces. Maybe it's not so bad, since there are many kinds of lego pieces, and you can still build many things. Still, what if you had all the same tools the Lego factory has? Then you can make your own blocks. You can still build things based on your imagination, like with the blocks you'd buy in the store, but now you can imagine new pieces to build with and combine them with the pieces Lego provides. These new pieces may even act or combine in ways the original Lego blocks never could have (maybe you make pieces that light up if they are connected to pieces with a similar color). Finally, since you love Legos so much, what if you could use legos themselves to describe how to make new kinds of Legos? Say you can submit a combination of legos that describes what you'd like to build to your in-house Lego factory, and the factory could look at your combination and make a custom piece based on your instructions. You can now stick together lego pieces, which can describe new special pieces to the factory, which you can stick together with other lego pieces, which can be used to describe ....on and on. So then legos could be building blocks even for new lego pieces you can imagine, or pieces you stick together to build what's in your imagination. A "programmable programming language" is like to having your own Lego factory, except you can describe your own ways to build instructions in a language the computer can understand. You get the same tools the person that came up the initial language had (like ways to make the custom pieces that were the basis of the language they made, and ways to interpret instructions to make new pieces of language). You can make your own pieces of language, even if they are very different than what the language creator ever intended. Since you have you the tools to make your own pieces of language and say how they fit together, you can make a like a little language of your own to talk to the computer very easily or you can grow the original language with new pieces you want. You don't have to hope that someone else will eventually make new pieces for you, since you are a creator. You get to decide if making new pieces of a language is useful, since the language is now also your creation. You also describe how to make new pieces of language using existing pieces of language (like giving combinations of legos to the lego factory to instruct them to make new pieces). This means you can talk with the computer in the language it already understands, in order to teach it how to understand your new pieces of language and how they fit together, in a "new" language that you both understand. Since you're both starting from a familiar language, it is very easy to grow your new language with the computer, and to keep growing the language as much as you want.
&gt;A powerful programming language is more than just a means for instructing a computer to perform tasks. The language also serves as a framework within which we organize our ideas about processes. Thus, when we describe a language, we should pay particular attention to the means that the language provides for combining simple ideas to form more complex ideas. Every powerful language has three mechanisms for accomplishing this: - primitive expressions, which represent the simplest entities the language is concerned with, - means of combination, by which compound elements are built from simpler ones, and - means of abstraction, by which compound elements can be named and manipulated as units. [SICP 1.1 Elements of Programming](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-10.html#%_idx_124)
I think something based on turtle graphics (from Logo) or similar graphical (e.g. sketching, immediate interactive feedback) is useful for total beginners or non-traditional backgrounds. I like the work Tim Pratley did with Power Turtle for clojure/cljs [here](http://timothypratley.github.io/power-turtle/). I'm uncertain if there's an equivalent for emacs lisp or other dialects. You may get some mileage there though (they have a curriculum that walks through evaluation, up through data structures and library stuff). There's a similar web-based turtle graphics in Racket [here](https://www.wescheme.org/openEditor?publicId=CSjPU3Ss43), but it doesn't include a curriculum like Power Turtle does (you get an actual interacive REPL with power turtle too). If the graphics stuff is interesting, [quil](http://quil.info/examples) is a wrapper around the Processing language (favored for non-technical CS curricula at MIT, basically artists and the like). They include on online editor and you can see the resulting interactive sketch immediately. It's not a guided tour though (there are some tutorials), but could be compelling. The nice thing about these is that there's nothing to install; they all run in the browser; so no "quick start" that's actually 15 steps if and only if you have pre-requisite stuff installed and configured.
The book ["Common Lisp: An Interactive Approach"](https://cse.buffalo.edu/~shapiro/Commonlisp/commonLisp.pdf) is good; it's listed in the sidebar.
This was so much more eloquent than my jetlagged attempt. You captured what I was trying to say so perfectly and improved the analogy significantly. Thanks mate, I'm going to save this response for future use.
.Net is more nature than Java for some years already. Had generics support years earlier. Just the platform support not so.
I have a copy here, there are many exercises. The book starts with about 70 or so pages of diagrams though, then the rest is in s-expression format as we're used to.
r7rs large will contain srfi-159/166 which has numeric/si included. (show #t (numeric/si 2048 1024) "B") =&gt; "2kB". It is like format on steroids, only slower :)
I have a background in the arts, and found PCL a great introduction to Common Lisp. Once you've made it through that, SICP is fantastic. The lectures are available online as well, which may be easier to follow than diving right in to the text. If you want to hack emacs interactively I recommend `M-x ielm` and `C-h k C-x C-e`. There are lots of great CL books available, but once you get a good set up with SLIME (do it! quicklisp slime helper!), _nothing_ beats `M-.` -- you can jump right into the implementation of built-in functions and tinker to your heart's content. You can learn _so_ much this way. I absolutely love it.
My first language was Logo, does that count as a Lisp?
Try Racket. It has the most easy-to-use development environment I have found.
I'd say it's the other way, other applications interfere with SBCL. &gt;The possible solutions would include i think a save-restore of signals while calling into C If SBCL wants to block some signals, no third party code should be executing in that thread. So it's unclear how .net manages to do that.
May as well send it up to the [mailing lists](https://sourceforge.net/p/sbcl/mailman/) and the [bug database](https://launchpad.net/sbcl). Accepting donations (BTC): bc1q659n9v9jft4gluaz0sg9vjkcpz92wkx4q6w32h
I'd recommend "The Little Schemer" or "The Little Lisper" (same book, different language). 70 pages, simple, covers the basics. &amp;#x200B; You could knock it out in a few hours.
Please for the love of God. &amp;#x200B; Emacs Lisp is such a bad language; I can't recommend learning it as your first Lisp.
I've used it as a reference tool when I wanted to go deeper into a concept. It is pretty good for that.
If you are interested in meta-programming in general, check out FORTH as well. Instead of programming and extending the compiler (lisp macros) you modify the call stack^(1) to meta-program. There is also lazy evaluation (eg. in Haskell, or with functional closure "thunks") which can do at least almost everything macros can do. &amp;#x200B; \[1\] By call stack I refer to the compiler's list of functions and arguments to execute.
In Emacs Lisp?
SBCL, CCL, ECL seem primary candidate implementations. Scheme might be an alternative.
@CelloAxeMurder: And BTW, your approach is what I have tried so far, that is Emacs + [The Emacs Widget Library](https://www.gnu.org/software/emacs/manual/html_mono/widget.html). It works pretty well for Windows, because Emacs for Windows is totally portable. It is just a folder to drag and drop, which includes the `share/emacs/site-lisp/site-start.el` as a subfolder. So one can embed the app in `site-start.el`; remove bloat (such as `games` dir); zip and deploy.
1024 byte kilobytes are `K`, not `k`.
Seems that it's not: https://en.wikipedia.org/wiki/Kibibyte
On the scheme side, you could try [https://docs.racket-lang.org/gui/](racket/gui), which works by wrapping GTK, Cocoa and Win32, for Linux, Mac and Windows respectively.
I'm not sure I'm understanding the problem correctly, but there's an easy way to answer your question: signals are sent to the whole process, there's no way to target a thread with a signal. If you have several libraries loaded by the same process, even if they are in different threads, one library handling signals will impact all other libraries which want to handle them (too). This isn't specific to SBCL: bascially, every shared library which handles signals will have the same problem. It's just a bad design (of signals). Some libraries, however, knowing that they might be used in a context where some other code might want to handle signals offer workarounds for this problem: either they offer to disable their own handling code, or they offer to call other code after processing a signal. Maybe SBCL can be improved to allow others to also handle the signals it handles... but if .NET is the one handling the signals before SBCL can even see it... Unfortunately, a managed environment will very likely try to handle some signals, like SIGABRT for example... And if you try to have two managed environments sharing the same process... I don't think there may be a good solution to this, unless you have an OS which doesn't have signals.
Cool project name ;)
:)) I've opted against an English name and used a Romanian one, eventually. Eh, small perks.
Thank you, that seems a very viable path. My only concern is that I use on daily base Elisp (or at least Emacs) and I am afraid that mixing two languages so similar can affect both side of coding negatively.
&gt; there's no way to target a thread with a signal signal masks are per-thread.
Who is accepting donations?
Accepting donations? What?
That'd be of a very little use since you are only allowed one handler per PID, and all threads share the same PID. So, unless you can coordinate all of your threads (which is not the case with shared libraries), you cannot meaningfully use masks. In other words, if you could decide on behalf of .NET or SBCL who's going to handle the signal, then yeah, masks would solve this problem, but if both are contesting the signal, and neither can be configured to yield... at best, one of them will not get the signal.
Very cool, but I would've been even cooler if the images were before images.
It is as a single letter suffix in traditional usage: see third paragraph of: https://en.wikipedia.org/wiki/Kilobyte#Base_2_(1024_bytes)
What be of little use? .net messes up the signal mask that SBCL expects.
 A potential solution to this issue is "signal chaining" (read on for the link), though it would require knowing exactly what signals SBCL needs while running lisp code and what .NET need when running .NET code. I dove into this when trying to use Java via JNI from both SBCL and CCL and ran into similar issues. Ultimately it didn't work for me (from my perspective of neither wanting to change SBCL or the JVM), and I also grew to realize my desire to do this stemmed from me wanting to use CL to script Java. Since this time, I've used far less Java libraries, and when I do, I just use ABCL. Here's a relevant background from the SBCL manual (http://www.sbcl.org/manual/index.htm - section 13.9): &gt; Direct calls to pthread_create (instead of MAKE-THREAD) create threads that SBCL is not aware of, these are called foreign threads. Currently, it is not possible to run Lisp code in such threads. This means that the Lisp side signal handlers cannot work. The best solution is to start foreign threads with signals blocked, but since third party libraries may create threads, it is not always feasible to do so. As a workaround, upon receiving a signal in a foreign thread, SBCL changes the thread’s sigmask to block all signals that it wants to handle and resends the signal to the current process which should land in a thread that does not block it, that is, a Lisp thread. Here's how the JVM attempts to solve mixing other code that requires having its own signal handlers installed: https://www.oracle.com/technetwork/java/javase/signals-139944.html It's an old (Java 6 link though still applies to the latest JVMs) but very good document on mixing the JVM with native code that uses signals. SBCL could do something like this but ultimately I think mixing two separate managed environments may just be too much work for little gain. Rich Hickey went down a similar road of trying to use Java from CL when he wrote jfli (http://jfli.sourceforge.net/) which used JNI to use Java from within CL. Ultimately, I'm guessing these signaling issues kept this from being used on many different CL implementations. It is supposed to work very well in LispWorks though, you may want to try the .NET interop from there and see what you get. He then went on to write a CL library that used a child process with a socket protocol for JVM (or .NET) integration (http://foil.sourceforge.net/). This of course is slow for chatty communications and adds a lot of complexity to an application. Ultimately, I think there has be a mechanism like the JVM signal chaining in SBCL itself for this to work, and I imagine the design and testing of that will be quite labor intensive. You may also want to look into MKCL (https://common-lisp.net/project/mkcl/) if you want an open-source Lisp, as one of its design goals is to alleviate these signaling issues though I never looked into how it works. Jean-Claude Beaudoin, the author of MKCL also wrote cl-plus-j (https://common-lisp.net/project/cl-plus-j/) which is very similar to jfli in that it uses JNI over the CL implementation's FFI (and it is newer, so it uses CFFI). I stumbled upon MKCL too late to use it (it's not integrated in closer-mop and I already had a little project that needed libraries which needed closer-mop etc). Since I'm interested in Java interop, I moved over to ABCL and have been really impressed with the quality of its implementation (I love SBCL too -- just can't use them reliably for Java interop). CCL I briefly tried but I couldn't find documentation on how it used signals and at that point decided it wasn't worth further investigation. My main takeaway from this knowledge hunt though is to just write mostly CL code rather than add the complexity of having two managed runtimes in one process. I have been trying to force myself to think CL first rather than immediately look for a third party library in the ecosystem I'm most familiar and have been realizing just how complex and over-engineered the libraries I'm accustomed to actually are. I don't have a huge personal CL library yet (though I hope to build one, as I expect CL to be around and continue to have decades old code work). Since I don't have that personal library yet though, using Java libraries sparingly with ABCL is the road I'm on now. I hope this lets me use CL in a professional setting for more than trivial little utilities but that remains to be seen :-).
You could perhaps try [Sciter](https://sciter.com/) or something similar.
Have a look at https://github.com/CodyReichert/awesome-cl#gui - I found LTK a joy to build simple IUs with: http://www.peter-herth.de/ltk/ You can build a self-contained app. If you develop on Linux, you'll need a CI service to build it for windows and mac. nodgui is a good replacement (rather, complement) to ltk. - there are also IUP bindings in development for CL: https://github.com/lispnik/iup/ It's gonna be awesome.
Very cool ! You could add the libraries to http://ultralisp.org/, it's two clicks away.
I've seen ultralisp mentioned here before. How is it different from quicklisp?
&gt; *SBCL implementation crashes randomly on Linux should you load .Net Core runtime into a process.* Wut? Like into any process in the system, not necessarily the SBCL one that crashes?
If you say so. I don't know SBCL well enough to tell if it's not the other way around, i.e. maybe it's SBCL who messes with whatever .NET expects. The "of little use" refers to impossibility of having any control over what happens to signals if two libraries disagree on that, and you cannot change both.
Why did you interpret that in the most illogical way?
SBCL may very well work with the way .net grabs the signals for itself, except it doesn't preserve the original sigmask.
I didn't interpret; I'm asking. Is that sentence literal, or just written by someone who has no idea how to use articles in English? I've fixed too many "illogical" bugs to have any disbelief left. Linux has become such a bloated, convoluted mess that I wouldn't put this sort of thing past it. Plus, flaws have been uncovered in modern processors and surrounding peripherals such as memory which reveal that interactions are possible that were previously considered unthinkable, even if there are no bugs in the OS.
&gt;GUI I think you could totally do it that way with Emacs. Some guy at Amazon coded an Emacs-based user interface for some business unit there. SBCL, CCL and ECL are all implementations of Common Lisp. Scheme is another kind of Lisp that has several implementations.
[Common lisp is back baby!](https://www.youtube.com/watch?v=ug4c2mqlE_0)
Making fun of somebody's english is not nice.
&gt; A good reason to start learning Lisp in 2019 is so that you're more or less up-to-speed when 2022 rolls around. What happens in 2022?
In 2022 you have 3 years of Lisp experience under your belt, if you start now.
Maybe try racket? I've never used it, but people say it's good. Common Lisp and Scheme are very different. I think following along with Common Lisp would be very frustrating for you.
I would certainly try to use a Scheme to work through SICP, it expects some features like tail-call optimisation Common Lisp doesn't guarantee. Maybe installing [Racket](https://racket-lang.org) is the easiest solution, since it has a decent IDE which isn't hard to learn, and I think there is an SICP compatibility mode.
&gt; Second, say I keep using SBCL and just figure out the syntax translation, I strongly recommend you don't do this. For (+ 1 1) it'll work. When you start getting into data structures, functional programming, etc., it will be a big distraction from learning what you want to be learning. There are 3 or 4 well-known and widely used Schemes for Windows. Any of them should be good enough to get through SICP. &gt; First, What is a very easy noob friendly program I can use to practice what's in the book without having to do any technical tweaking and whatnot to get things to work? You could use notepad if you like. Or use one of the Scheme distributions that comes with an editor. Spending some time on learning Emacs will be worthwhile in the long run, since you'll be able to use it for both Scheme and other lisps. &gt; What is the difference between the two dialects for a beginner? What is the difference for a professional in the field? The biggest one (aside from the simple different choice of names for certain functions) is that Scheme is a "Lisp-1" and CL is a "Lisp-2". This means that CL has different namespaces for functions and variables, and special forms (or reader syntax) are needed when you want to use a function in a place where a variable is expected and vice versa. Scheme avoids that problem but then you can't have both a function and a variable named "list", for example.
if you are on windows 10, you can very easily setup mit scheme, the scheme used in the book on ubuntu through windows subsystem for linux. i can help out with that if you need. otherwise, you can download racket and use the "#lang sicp" to help work through the book. it's a language in racket that follows the language in sicp. definitely use one of these two options. you will needlessly complicate things using common lisp.
I just downloaded and launched racket. I typed a defining statement and so far looks like what the book shows. I will not substitute dialects since 3 out of 3 recommended not to.
I did not think of that as an option. I thought support for MIT Scheme was discontinued around xp/vista days. How would I do that? I never messed with Windows subsystem for Linux. I also have Ubuntu installed on a laptop but would prefer it on desktop.
&gt;The biggest one (aside from the simple different choice of names for certain functions) is that Scheme is a "Lisp-1" and CL is a "Lisp-2". That begs more questions from me; can you recommend a resource for learning the difference between both dialects? Like why people still use version 1 of something when there is version 2...etc
The first google hit I get for "Lisp-1 and Lisp-2" is this: https://stackoverflow.com/questions/4578574/what-is-the-difference-between-lisp-1-and-lisp-2 But really, you have a lot to learn if you're just starting SICP. Stick with it and eventually it will all gel. But it won't happen in one Reddit post, or one day, or one week. It will likely take weeks to get to the point you think you know what's going on, then months to realize you still have a lot to learn, and then years to really become an expert. &gt; Like why people still use version 1 of something when there is version 2 They're not version 1 and version 2 of something. A Lisp-1 has **one** namespace for both functions and variables. A Lisp-2 has **two** separate namespaces for these things.
Here it seems 4 of 4 recommend you do, and I know many people on, say, #lisp will agree.
I feel you have trapped me. You asked me about my thought process, which I gave, and now you're treating it like something I had said to someone. You yourself seem to believe (more firmly than me) that the sentence means something else than is written; how did you come to that conclusion without having a similar thought about the grammar? It could be that you just react to a clump of words and let them evoke a meaning. I'm somehow not able to do that, though, and so then these "not nice" thoughts about grammar issues come to the surface. However, I don't feel I'm casting any aspersions when I have these thoughts. I mean, the best intellects on the planet struggle with foreign languages. I embarrass myself in Japanese daily, and have imperfect English speakers in my family.
support for mit scheme continues, but not for windows. it is only supported on linux and mac os x. there are older versions for windows, and for sicp, even those would be fine. you might just try the "#lang sicp" in racket so that you can use DrRacket. but if you want to use mit scheme, then below are some instructions. it might be helpful to go through them to get at the real mit scheme. it comes with an emacs-like editor edwin. i avoided emacs for the longest time, but i recently started learning it. it can be helpful in the long run. windows subsystem for linux instructions: https://docs.microsoft.com/en-us/windows/wsl/install-win10 you can install mit-scheme with apt. i think it's just "apt install mit-scheme". i might be wrong about the package name. you will get an older version though, but again, for sicp that should be fine. if you want the latest, i am copying in detailed instructions from my own documentation on how to set it up: ****************************** Installation instructions for installing MIT/GNU Scheme on Ubuntu running through Windows Subsystem for Linux (WSL) on Windows 10. The general use case is to run the MIT/GNU Scheme through Ubuntu while having the option of running Emacs or Edwin directly through Ubuntu or pointing Emacs or Visual Studio Code on Windows 10 to call MIT/GNU Scheme through the WSL. # Links * https://www.gnu.org/software/mit-scheme/ * https://www.gnu.org/software/mit-scheme/documentation/mit-scheme-user/Unix-Installation.html # Download * Follow the download instructions for the latest 64-bit Unix binary (x86-64). # Setup Build Environment * `sudo apt-get update` - Updates the apt-get package manager packages. * `sudo apt-get install build-essential libncurses5-dev m4` - Installs the necessary build tools. # Install * Windows 10 has tar included now, but we will use the Ubuntu WSL to untar and install. * Open the Ubuntu WSL * `cd /mnt/c/users/&lt;username&gt;/downloads/` * `tar xzf mit-scheme-10.1.5-x86-64.tar.gz` (Be patient, as this command takes a bit.) * `cd mit-scheme-10.1.5/src` * `./configure` * `make` * `sudo make install` * Once done, Scheme should be already added to your path. ****************************** the only problem with this is that scheme will be installed on ubuntu under windows subsystem for linux but your editor will likely be in windows. well you can use something like visual studio code to edit your code, and then you can create a bash terminal inside windows studio code after install ubuntu under windows subystem for linux. in bash, you can simply call "scheme" if it's added to your path to get into a scheme repl. also, from cmd or powershell, you can call "wsl.exe scheme" to get into a scheme repl from there. hopefully that helps. i also might suggest the edx courses [how to code: simple data](https://www.edx.org/course/how-code-simple-data-ubcx-htc1x and [how to code: complex data](https://www.edx.org/course/how-code-complex-data-ubcx-htc2x). they are introductory, but they do get complex. and more importantly, they teach a *design method*. this method will help you as you go through sicp. also, the course uses racket (or at least racket's teaching languages). i am actually going through them myself at the moment to just get some practice and go through their method.
just as a note, racket will be fine early on in the book, but there will be parts that it will not have the support for. instead of using "#lang racket" at the top of your file, use "lang sicp". for instance, racket's cons creates immutable lists whereas mit scheme does not. so later in the book, when mutability is used, you'd have to switch to racket's mcons (mutable cons) to create mutable cons pairs/lists.
Be careful, Racket supports multiple dialects. Look for a setting to put it in Scheme mode (maybe R6RS or R5RS, referring to different versions of the Scheme standard)
In the long run, a more system-level solution is required that multiple language implementors have to adopt. Idea: suppose that we hide POSIX signal handling behind an API (implemented in user space) which implements the concept of a "signal domain". In this API, a signal handler is installed not just for a given signal, but for a signal domain (some sort of integer identifier, say a 32 bit "fourcc"). Furthermore, every thread executes in a signal domain. The API shall provide a light-weight, low-overhead function by which a thread can switch from one signal domain to another. When a signal is delivered to a thread, that handler is used which correspond to the thread's domain. That at least takes care of signals that target specific threads, like SIGSEGV, SIGBUS and numeric exceptions. Thus if a thread calls from SBCL to .net, and then returns, it just switches domains on both crossings. There is the question of what happens if a process gets SIGTERM, and threads from multiple domains are eligible to catch it with different handlers. It could be that every domain which has at least one thread in which that signal is unblocked will have the handler go off in that thread. It's a fairly ambitious thing to design, and more importantly to get people to buy-in.
I see that now! It was only an idea because I struggled getting MIT Scheme working on anything other than a windows xp VM, now that I actually see working alternatives I won’t ever think of that idea again.
I read through the answers in the above link. I guess it’s not really different versions but more of like actual “dialects”.No dialect is really superior to another in human languages, just different.
Yeah, I got it working on a windows xp VM and Max OS so far. I’ll probably give it a shot in Ubuntu natively and try the WSL method to learn about WSL not for the MIT Scheme program. Regardless, I think I will stick with your original recommendation as a daily driver, going through a book like SICP. I do not want to get distracted with IT work which I am excellent at, but I want to learn something different and giving my full attention and focus.
Yes and no. It's recursion with or without Tail Call Optimisation (TCO) but with TCO you won't blow the stack.
SBCL is an implementation of Common Lisp, which is the "other" family of Lisps - Scheme is the one used in SCIP. If you want to use SBCL/Common Lisp then the easiest way to get started is to download and use Portacle, no install required. If you want to use Scheme then download and use Dr Racket. Install and you are off. Dr Racket supports several Scheme-like languages, including the eponymous Racket, and also a "mode" specifically to support someone working their way through SICP. If you have no reason to choose Common Lisp I'd use Scheme and Dr Racket to work my way through SICP.
There was a couple of days a thread on this topic and my response got upvoted pretty far up, so I decided to put my response into a more comprehensive form than the wall of text I had put out back in the thread. I have attempted to explain the topic in a less technical manner, drawing comparison to how people embed DSLs into spoken languages all the time. Comments, corrections and suggestions for improvement are much appreciated. Wrapping my head around the concept of a programmable language is what took me the most time to appreciate because I could never find a good explanation as to why this is useful for regular programmers and not just language implementers.
I second Racket with `#lang sicp`, it should have everything you need out of the box. That's how I did it as well &gt; Second, say I keep using SBCL and just figure out the syntax translation, What is the difference between the two dialects for a beginner? What is the difference for a professional in the field? SBCL is an implementation of Common Lisp, which is a much different language from Scheme. Asking about the difference between Common Lisp and Scheme is like asking about the difference between Italian and French. Both are languages in the same family, and if you know one then learning the other will be much easier, but they are still too different to comprehensively list the differences. I do not recommend learning SICP with Common Lisp, it would be like learning French by speaking Italian. Common Lisp is still a language worth learning though, it is the Working Man's Lisp while Scheme is rather the Thinking Man's Lisp. If you want to learn both, then pick one and when you are sufficiently confident with it pick up the other. &gt; Out the box solution. I know there is the route of using emacs or vim, both of which I do not know much about and trying to avoid getting caught in technical issues and actually learn CS. Any text editor will do, but Racket has their own IDE called Dr Racket. Just pick an editor you like and go with it. The Lisp community does itself a great disservice by urging people to install Emacs and Slime/Geiser, it just puts people off when they think they have to install all this crap just to play around a bit with a language. Emacs, Vim, Slime and Geiser are great and you will probably want to use them sooner or later, but you don't have to when you start out.
I keep seeing #lang sicp. Which I assume is a precursor to add to the top of the file. I keep getting an error when I add it, everything works fine without it so far, but, when I try to add it I get an error like this " arithmetic\_test.scm:1:6: #%plain-module-begin: not in a module-definition context in: (#%plain-module-begin (module configure-runtime racket/base (require r5rs/init)) (+ (\* 3 (+ (\* 2 4) (+ 3 5))) (+ (- 10 7) 6)))" Any ideas what is causing this?
I would recommend using [MIT Scheme](https://www.gnu.org/software/mit-scheme/) for SICP. While I'd never use it for production code, it is the implementation of Scheme that the authors of SICP used to teach the book.
Correct, you need to put that line at the top of your file. The SICP language is not installed by default, it is a library (package): [https://docs.racket-lang.org/sicp-manual/index.html](https://docs.racket-lang.org/sicp-manual/index.html) [https://pkgs.racket-lang.org/package/sicp](https://pkgs.racket-lang.org/package/sicp) You can install it from the terminal by entering \`raco pkg install sicp\`, or from Dr Racket if you prefer a GUI. Don't ask me how, I never use Dr Racket myself, but it should be explained somewhere in the documentation how to install packages visually.
As a side note, without the SICP language you will be able to work through most of the book. However, Racket differs from Scheme in some subtle details, so eventually you will run into something that does not work. The SICP language smooths over those differences and gives you a Scheme that is 100% compatible with SICP. This is one of the downsides of Scheme. The Scheme specification is so minimal that every implementation adds its own little extensions. Racket is not even a Scheme at this point any longer, they consider it its own language which just happens to have Scheme as its ancestor.
So only *yes*, it was clear to me that was recursion, I was exactly referring to the tail call WRT the stack limits. Thanks for answering.
First, it is based on Quicklisp, it is a Quicklisp distribution. Once connected, one can see a list of his github projects and can click to add them to Ultralisp, which will rebuild under five minutes a new dist with your packages. It's the fastest way to distribute libraries. In quicklisp, you'd have to ask the maintainer and to wait one month before the new release.
I was wondering about this while reading, it's a good summary from that thread. By the way, there are a couple of typos in the post, I think 2. &amp;#x200B; &gt;(the first solution ~~the~~ **to** be precise) &amp;#x200B; &gt;The user of a macro writes a *specification*of (the space is missing here) &amp;#x200B; I hope I don't sound like a douche, but you asked for corrections.
No, yes *and* no. It's only *guaranteed* in Scheme, although often present in CL it's implementation dependent. Not all Lisp implementations. And it would work as long as the stack doesn't get blown with or without TCO.
Nice! I'm getting back into Lisp and Elisp and this is a good read, also added the rss feed :)
This is a really good idea. I do this often to learn other languages, so I’m not sure why I thought of it before. Maybe it’s because I’ve been only associating Lisp with my Emacs config so I’ve felt like my first project has to be some kind of Emacs package. Silly in hindsight. I thought of a neat project last night. I’m going to try to implement a decision tree for a game of Connect 4. There will be lots of list processing, with the tree being a list of lists of list of etc. and the game status just being a 42 length list. I made a Connect 4 program in Java years ago, but it didn’t have any decision making adversary, just code to detect a winning scenario.
&gt;What is the difference between the two dialects Common Lisp and Scheme are two different programming languages, not dialects. You might as well ask the differences between Java and JavaScript. Even their paradigms are different, with Scheme leaning towards functional programming and CL towards imperative (or even object-oriented) programming.
Curious: you don't speak about CL's reader macros ?
the following is a good technical explanation by Kent Pitman (who the editor and a principal writer (along with Guy Steele) of the CL spec) [Technical Issues of Separation in Function Cells and Value Cells](http://nhplace.com/kent/Papers/Technical-Issues.html)
I think "programmable programming language" is a bit of a meme. I never think about programming the language when writing code, just a function here, a function there, a rare macro to tidy things up. But I guess you need bold claims to entice people. I even think that I'd still prefer lisp if it had no macros.
Sure, this looks like a valid usage. The `LAMBDA` call can be replaced with `(curry #'has-type type)` if you use the `alexandria:curry` helper function - that's the way I usually write those, since `curry` has somewhat shorter code.
Fixed &gt;I hope I don't sound like a douche, but you asked for corrections. Don't apologize for doing the right thing.
Two reasons: 1) I don't know enough about them, and 2) this is just an overview of the concept of what a programmable programming language even is. I had a previous draft that was full of code and text explaining the code, but then I scrapped it all and started from scratch. This explanation is aimed at people who do not know Lisp but want to know what the fuss is all about, going into detail would just bloat the text and drown out the message. If someone wants to know how to actually write macros there is the two hour long video by Baggers, he has done a much better job than I ever could. Perhaps I should have linked to it as a further reference.
I agree that Lisp would be good even without the macros, it's just that the macros give it one big advantage that you cannot get anywhere else. But my point was not to sell Lisp, it was simply to answer this specific question. &gt; I never think about programming the language when writing code, just a function here, a function there, a rare macro to tidy things up. That's the way it should be, use the features that suit the problem best. For example, in C++ OOP is the big selling point, but you can write C++ without OOP just fine. On the other hand, in Java you are practically forced to use OOP, which is really dumb.
(lambda (a) (has-type type a)) is only marginally longer, clear, doesn't depend on the presence and knowledge of third party libraries.
Sure, gustibus non disputandum jest. If someone's the kind of a person who always pulls in Alexandria (like me), perhaps this advice will be useful for them. Otherwise, `lambda` is perfectly fine, too.
 (remove type *db* :key #'activity-type :test-not #'equal) activity-type will be more useful than has-type.
I installed the package from the package manager inside Dr. Racket. The line used to be red before installation, now it's white. I still get the error when checking syntax or running a program.
&gt; I even think that I'd still prefer lisp if it had no macros. I think I'm the opposite. The only reason I use lisp is for macros, and I (ab)use them heavily in every project. Though to each his own.
Fair enough, but AFAIK a reader macro is very different from a usual macro. It allows to program the reader. Hence a programmable programming language. https://youtu.be/CbciCrQCpkI?t=741 See also the crazy lisp library that allows to embed C code, cl-annotations that introduce a pythonesque `@` annotation (https://github.com/m2ym/cl-annot), or hash-table litterals,…
Racket, Chez. But for a beginner, Racket will be much less confusing for sure. There should even be [a SICP module for Racket](https://docs.racket-lang.org/sicp-manual/Installation.html). I've just installed it in like 15 seconds.
&gt;Does this level of metaprogramming offer any advantages to the average user or would we be better off just picking a language that already has all those big features? I'm just working my way through CLtL2, and I have to say: Common Lisp already *is* one heck of a big language! More or less, it provides more than enough features for what you'd reasonably want to do, and macros for those occasions when you insist on being unreasonable ;-) :D
&gt; “When I use a ~~word~~ signal,’ Humpty Dumpty said in rather a scornful tone, ‘it means just what I choose it to mean — neither more nor less.’ &gt; &gt; ’The question is,’ said Alice, ‘whether you can make ~~words~~ signals mean so many different things.’ &gt; &gt; ’The question is,’ said Humpty Dumpty, ‘which is to be master — that’s all.”
Why the hell would you want to kill all humans, anyway?
this covers a small part of meta-programming in Lisp, mostly the part that is concerned with syntactic source transformations.
"gustibus non disputandum jest" .... I am amazed by the beauty of the brain :-) (-: your jest was immediately marked as such. :-)
I didn't know anything about Lisp having macros when I started. I was hooked by how symbols worked, and lists made of conses terminated by `nil` which is also false. Also, the dynamic typing and good support for various kinds of numbers and exact math. I liked the uniform syntax: that every kind of list that occured in the syntax (list of parameters, list of variable bindings, list of base classes, ...) was the same darn thing! Wow, I thought, this brilliant simplicity is an embarrassment to language designers of the past half decade. I liked the reader also. Prior to being exposed to Lisp, I knew about read tables from Knuth's TeX, which scans by looking up character categories in a table. I mimiced the design in a macro preprocessor that I wrote, which allowed code to reassign character categories to play with the read syntax. Then as I was going through *Common Lisp: An Interactive Approach*, I was blown away when I discovered out that Lisp also scanned everything using character categories (via a "read table"). (Today, I'm not into read syntax that much.) Of course, I discovered macros, too. Basically, I got into Lisp without any hype. It was because I came into possession of the Stuart Shapiro book, by accident (*Common Lisp: An Interactive Approach*). That was in 1999 or early 2000? I hadn't been exposed to any Lisp memes, hype or advocacy whatsoever.
I see. I thought perhaps you were predicting that 2022 would be the Year of Lisp Domination.
Yeah, I remember when I [ran into this bug](https://github.com/tshatrov/match-client#known-issues) when using Graphicsmagick on Linux.
thanks
Thank you for your reply! I got your code working, just to be clear: ``` (defun activity-type (activity) "Returns the type of an activity" (getf activity :type)) (defun find-activity (&amp;key (type nil)) (remove type *db* :key #'activity-type :test-not #'equal)) ``` Your code works the same as my own code and I think it reads more cleanly! An additional question, the hyperspec notes that in the [documentation for remove](http://www.lispworks.com/documentation/HyperSpec/Body/f_rm_rm.htm#remove) that the **:test-not** argument is *deprecated*. So I looked at **remove-if-not** but that is also *deprecated*. Is there a better way to implement this than using the **:test-not** argument?
Disregard that deprecation, it doesn't mean anything.
Also found [https://talks.kepibu.org/2012/pyowa-bb/talk.html](https://talks.kepibu.org/2012/pyowa-bb/talk.html) from July 2012 - likely, the original burgled-batteries.
Nice. Are you aware of [http://clqr.boundp.org](http://clqr.boundp.org) ?
I wasn't aware! Thanks! ( I like Haskell, but Lisp seems to have taken my heart recently. I'm excited to learn about utilizing static typing... )
That reference is a nice way to discover new things! Thanks again \^\_\^
Just to note, in the optimized branch, numcl is 1.8x slower than numpy/C++.
Nuklear precompiled libraries for various platforms are provided via `nuklear-blob` system. Pereonally, I'm using Travis and Appveyor CI services to compile/[package](https://github.com/borodust/notalone-again/releases) CL apps for Linux/Windows/macOS.
What about using ECL and then telling GCC to cross-compile?
Hello, I tried: With `compile-bundle-op`, I get a light fasl, but it cannot run as is. It says to not find `parse-float`, which is indeed a library. With `monolithic-bundle-op` it is worse, it says &gt; The name "ASDF/OPERATE" does not designate any package. Are the fasl really executables ? The doc says &gt; load-bundle-op will load the output of compile-bundle-op. So we need to use `load-bundle-op` somehow to run a fasl ? Thanks for any hints.
What about using CAPI? I know it is not free, but it does solve all of your problems.
In the end you are free to rename procedures as you wish :) (define-syntax defun (syntax-rules () ((_ name (args ...) body body* ...) (define (name args ...) body body* ...)))) (defun hello () (displayln "hello world"))
https://github.com/marketplace/azure-pipelines supports Linux, macOS, and Windows.
If you're targetting the desktop, why do you need cross-compilation?
Maybe it would be easier to use read-delimited-list to read the body of the message, something like `(read-delimited-list #\] stream)`.
You might want to check the to-be-very-soon-awesome IUP bindings: https://github.com/lispnik/iup/
Fact: I was able to quickload bodge-nuklear and try the examples without installing anything else manually on my system. (good stuff Borodust)
I'm using Racket for a cross-platform desktop application (Linux, Windows, Mac). Maybe I'm wrong, I haven't tried, but I doubt that you could use [`setup/cross-system`](https://docs.racket-lang.org/raco/cross-system.html) for cross-compiling GUI applications in a way that would allow you to deploy them. Apart from testing, you'll also have to package them correctly. I currently still install MacOS in a VM and generate the executable and deployable .dmg in the VM, but it's a pain in the ass.
[I am trying](https://www.reddit.com/r/lisp/comments/c5tcge/ecl_crosscompilation/), but I am not very familiar with clang.
I saw it, but I also read [that](http://webserver2.tecgraf.puc-rio.br/iup/en/prod.html#disponibilidade): &gt;The library is available for several compilers: &gt; &gt; GCC and CC, in the UNIX environment Visual C++, Borland C++, Watcom C++ and GCC (Cygwin and MingW), in the Windows environment &gt; The library is available for several operating systems: &gt; &gt; UNIX (SunOS, IRIX, and AIX) using Motif 2.x UNIX (FreeBSD and Linux) using GTK+ (since 3.0) Microsoft Windows XP/2003/Vista/7 using the Win32 API No macOS.
The idea is to build all on a Linux box and use Windows/macOS boxes for testing.
They say they only work on mac hardware. I have found some hackish VMs but I might end up shipping viruses with the app.
FASLs are not, to my knowledge, executable. monolithic-bundle-op ought to be runnable with sbcl's runtime though. Downside is that IIRC FASLs are not portable between different builds of SBCL (other lisp implementations may be more forgiving on portability of FASLs; you can bundle it into a single .lisp file which will be highly portable, but slower to load).
Well, I think it doesn't matter how native is the code shipped. Nor it does count that you have to ship huge DLLs/Dylibs with the whole LISP runtime, or a few seconds a user waits for the interface to load. What matters is that a non-technical user can click on the icon and run the app. Also unpackaging the app should not be too painful. If under the hood they are shipping a Racket installer plus your application, what is the problem? As I understand, what they offer for free is possible only in commercial Lisp implementations.
Thanks. I will give a second look when I finish [this task](https://www.reddit.com/r/lisp/comments/c5tcge/ecl_crosscompilation/).
I don't know which linux distro you're using, but on arch the cross-compilation toolchain you'd want for macos is 'apple-darwin-osxcross' in AUR, plus you might need 'x75_64-apple-darwin-binutils'. I don't know whether those toolchains include utilities to build .app bundles or not.
First of all, the quickest and most painless solution will be to set up a VM and use that to compile your code, in particular if you plan to use libraries which have not been written with cross compilation in mind. One disadvantage of the effortless compile time compilation that Lisp enables is that it can make cross compilation difficult if one is not careful. If you really need to do cross compilation you need to do the following steps: * First cross compile ECL itself. Instructions to do that for Android are in the INSTALL file. Other OSes work analogously * Setup the compiler from the host ECL you built in the first step to use the appropriate C cross compiler. An example with asdf integration is e.g. in https://gitlab.com/spaghettisalat/jffi_repl_example/blob/master/app/src/main/lisp/asdf_libs/compile.lisp (this example file passes the names of the C files in via environment variables (see the si:getenv calls). The part with the jffi stuff you can delete, you won't need it). You also need to be careful to link to the cross compiled libecl.so and not the one from the host ECL (the ECL_LIBDIR environment variable specifies the location of the directory for the cross compiled libecl.so in the example that I have linked above). Same goes for the include files. I would avoid manually calling the C compiler and rather let ECL handle this itself, this will be much simpler.
I would say cross-compilation is a bit of a fool's errand, you can't provide proper support without testing on the target environment.
yes, but one thing is to test, another is to develop. Besides, minor fixes might not require tests or a test on a single platform or automated testing might be enough. Last but not least, one can make use of virtual machines and automatically deploy at building time in their hard disks. After all, which the worst framework [available today](https://medium.com/commitlog/electron-is-cancer-b066108e6c32)? Written with the worst language and worst tools? But people still use it, just because it is the only one cross-platform.
I didn't say anything contrary to what you are saying. I merely said that it is not "cross compilation". It is "cross platform compiling", which are two very different things.
&gt; apple-darwin-osxcross' I am on Arch as well. Have you used it? Is it a drop in replacement for gcc? Or should I adapt the code and the switches?
You should push this upstream, it is a conservative enough edit to include in lisp-mode.
On this page they list mac: https://webserver2.tecgraf.puc-rio.br/iup/en/toolkits.html
bottom: &gt; Why Not Mac? The first Mac driver was developed for MacOS 9 and had several memory limitations so it was abandoned. With Mac OS X we have the opportunity to do something better. Today IUP runs on Mac OS X using X11 with Motif or GTK. We plan for the future to build a native driver, but it is not a Tecgraf priority.
&gt; Today IUP runs on Mac Thank you ponting out this, but I miss something here: If it is available and even "something better", why it is not listed in the available operating systems?
I've not tried it, I'd assume it's the/a-close version of clang that apple ship.
In the old days of the wild wild ~~west~~ Maclisp, there was a function called EXPLODE which would do that. That's not a thing now, because there are characters (and more importantly, strings) to hold text that is just text. You can coerce a symbol's name to a list to do that: `(coerce (symbol-name 'hello) 'list)` is `(#\H #\E #\L #\L #\O)`.
If you have a quoted symbol `'hello`, then you can get its name as a string. `(symbol-name 'hello)` =&gt; `"HELLO"` Then you can turn it into a list. `(coerce (symbol-name 'hello) 'list)` =&gt; `(#\H #\E #\L #\L #\O)` Since you want symbols and not characters, you can turn it into a list and process it at the same time with `map`. This will create strings of length one for each character and then `intern`s them: ``` (map 'list (lambda (character) (intern (string character))) (symbol-name 'hello)) ``` =&gt; `(H E L L O)` If you have a list of symbols and want it flattened into one list at the end, then you do this to each element (e.g. in a `mapcar`) and then you can use something like `alexandria:flatten` on the final result. If you're talking about another Lisp language other than Common Lisp, then the principles will be similar, but the details will differ.
The Lisp FAQ: [What is the equivalent of EXPLODE and IMPLODE in Common Lisp?](https://www.cs.cmu.edu/Groups/AI/html/faqs/lang/lisp/part2/faq-doc-3.html)
I think you should clear up your terminology a bit if you want to get better. `(hello)` is not an atom, it's a list containing one element. Sent to the reader, it will be interpretted as a call to the function `hello` with no arguments. If you quote the list like so: `'(hello)` the reader will interpret this code as data: as simply a list with one element (the symbol `hello`). The word 'atom' is an old term from Lisp's history that isn't so useful anymore, but it generally refers to anything that isn't a list. Something like `hello`, i.e. a non double-quoted, non-whitespace containing alphanumeric sequence is called a "symbol" in Lisp parlance. When the reader sees a symbol it will try to look for a variable in the current environment with that name - _unless_ you quote `'` the symbol (or the list that contains it), in which case it will simply read the symbol without evaluating it.
ok. I invite /u/CelloAxeMurder to the discussion. Does IUP run on Mac ? thanks.
Sent to the reader, `(hello)` is just interpreted as a list of one element. Not until it's sent to the evaluator is it interpreted as a function call
Sent to the reader, `(hello)` is just interpreted as a list of one element. Not until it's sent to the evaluator is it interpreted as a function call
found this: (string 'hello) ;; "HELLO" (coerce * 'list) ;; (#\H #\E #\L #\L #\O)
Thanks for those clarifications, especially surrounding the use of "atom". I may need to look into a newer book to go through. I guess a better way to ask my question would be: how do I take an element in a list, break it down to smaller elements, and make a new list containing those.
Thanks! I'll look into that.
Thanks!
Thanks!
Thanks!
Fantastic! I will look into this. Thanks for the help!
I think you should revise your thinking. Your guess that it is "contrary to how Lisp works" is a pretty good one. It's similar to the idea that you take the number 123 and break it into the digits 1, 2, and 3. Some people have given examples using \`SYMBOL-NAME\`, but that is ignoring an important issue by blurring the crucial distinction between a "thing" and "the name we call the thing." Symbols in Common Lisp are called atoms because they are objects on their own, and are usually "interned" so that the name of the symbol (including the package name) refers to one and only one symbol. \`HELLO\` as a symbol is an object. It is called an "atom" because it does not really have component parts. You can't open this object up and see letters inside. Under the covers it is more like a unique memory address in your Lisp image: a 64-bit number. You can only get the letter "H" by finding that it is an element of the \*string\* which is the \*name\* of the symbol. That's a kind of weird thing to do. The characters that the programmer typed to refer to this symbol object have gone away by the time your program runs.
The macOS (cocoa) support was very recently merged into trunk (along with android, cocoa-touch and emscripten) [https://sourceforge.net/p/iup/iup/HEAD/tree/trunk/iup/src/](https://sourceforge.net/p/iup/iup/HEAD/tree/trunk/iup/src/) I have not tried any of it personally, and latest 3.27 release doesn't include it. Looks promising though.
Thanks for that information! Its really helpful.
I wouldn't bother with that. There's plenty of CI/CD services it there that can build multiplatform artifacts for you.
On the subject of cross-compilation: after you have MinGW or something like that on your Linux, you will have to find out what version of MSVCRT.DLL you will need, and if you can hope to maybe not need it, or maybe you will have to distribute the version you need with your program. I've been bitten by this once, and... truth be told, I'm not looking forward to doing this again.
And even then, these things still depend on context
- The (default) colors for Python are more muted, pastel. - Why is Vim showing [Lisp] and [the] in Yellow ? - Can i get more colors ? (by using other data types) --- i can get Orange in Python for \n\r\t
Instead of this: (call/cc (call/cc #'(lambda (c) (c "Another string") ) ) ) I should 've written : (call/cc (call/cc #'(lambda (c) (c #'(lambda (c) (c "Another string") ) ) ) ) )
Just...a few things. - `'{'` doesn't notate a string. I'm not sure why they're cyan. - What's up with the title? It should be `(when (writing-using-p 'lisp 'vim) (are 'colours 'dazzling))`, or maybe you should use a Prolog-in-Lisp because that's a declarative sentence. Something like `(:- (dazzling neon-colours) (writing lisp vim))`. No excuse for the space in `( when` either. - That's going to hurt your eyes probably. Staring into the very high contrast void of emulated CGA isn't that nice really. - I would highly recommend you use some kind of IDE-like extension to let you interact with a Lisp process if you don't already, the gold standard (that exists today without a $5000 Genera license) is probably [SLIME](https://common-lisp.net/project/slime/) but Vim heretics like yourself can probably get away with [SLIMV](http://www.vim.org/scripts/script.php?script_id=2531).
&gt;( writing Lisp code "using Vim" ) (why? you-doing-this)
- ( i think ) '{' is a symbol in GCL --- i'm pretty sure it's standard CL. - When writing Lisp code using Vim, i sometimes find that the "Neon Colors" are a bit distracting.
- No it's not, and GCL is dead. There's a nice list of implementations on the sidebar. - Right, I think that's a vim problem then.
At least none of use Atom to write lisp hahah right guy? It would be so dumb right ? Hahaha
`the` is a special operator. I'm not sure about the `lisp`; however, there are `lisp-implementation-type` and `lisp-implementation-version`.
A variant of emacs is the right answer.
Maybe Python vim module integrates an own syntax color scheme and Lisp filetype falls back to the original one, because no colors are defined. If you ask why the colors are so much different, it's "efficience over stylish look". Most people these days like minimalistic color palettes (reduced saturation, number of colors, differences in colors). This is a risk that you cannot distinguish syntax elements visually and it takes more context to find out what element it is (same as no syntax highlighting at all). Vim has great color highlighting, because even with 16 colors it tries to make syntax as obvious as possible.
&gt; ( i think ) '{' is a symbol in GCL --- i'm pretty sure it's standard CL. Incorrect. `'{'` gets understood as `'{` plus `'` which means `(QUOTE {)` and then a quote without a quoted object, which is an error.
Well... you might want to start with a better terminal... The one you are using supports too few colors / has bad defaults (and probably impossible to configure) space between lines etc. Even on Windows you can get a better terminal. MinTTY for example. I'm not sure about it, but maybe PoSh comes with a better terminal too? Had anyone tried that? But, if you really wanted good experience with terminal, you'd go with MSYS2 / Cygwin and got yourself something like Konsole?..
But even though I can't stand tying into it for more than 36 seconds at a time, at least it can parse a docstring, unlike shit fucking emacs after all these years.
The combination of words in your last bullet point, triggers this cult of Lisp adherent, who should be working on the `(expt 2 most-positive-fixnum)` prostrations of the conses, to scramble this stupid analogy in a convenient nearby textbox. "the gold standard" and $$$$ and "license" : SLIME greed : 1. Guile 2. suffering 3. highlighting 4. present/accept syscall
It would be more useful to color the parens and params by position and nesting level. That way all the sibling args are colored with the same text/paren color.
probably thanks to the cygwin(?) terminal you're using. If you're on windows 10 you can use windows subsystem for linux and get MUCH better support for terminals
I have decent Lisp hacking credentials and use Vim.
Try different colorschemes. E.g. `:colorscheme desert`.
Depends on what your goals are I suppose! The Seasoned Schemer has extra concepts that could be useful. If you're interested in programming languages theory you can move to The Reasoned Schemer (sort of an introduction to Prolog and relational programming) or The Little Typer (dependently typed languages). Both use a Scheme like language to develop more concepts.
I did SICP afterwards. You'll be fine, ahead like a chapter actually. I recommend reading ASAP. It's quality. You'll love it.
Timely, I just started reading it to start the whole Dan Friedman book series. Few hints out of my ~newbie head: - well, all friedman's the &lt;adj&gt; schemer books - papers about minikanren - I'm reading Queinnec's Lisp in small pieces, I see there are other books of this kind - https://github.com/scheme-live/library.readscheme.org tons of papers
Am I really the only one bothered by the mismatched parens in the title?
Any order will do. But after first read is over, you should re-read to gain further insight. And most importantly, actually do every exercise!
Like @TheWass said: it depends on your background/what else you already know, and also what you want to do with your knowledge next. If you understood TLS, you know enough Scheme to get through SICP [(although your other background knowledge is an open question!)](https://en.wikipedia.org/wiki/The_Structure_and_Interpretation_of_the_Computer_Science_Curriculum) Depending on what kind of things you interest you, you're ready to go any number of places. Which is great!
You don't need any more scheme for SICP. SICP will be good for you. How much you understand will depend on too many factors known to yourself but not to me.
Quick glance at your history - dive in you'll love it and it'll change you forever. After that have a look at Forth btw. I only use lispy\Forth stuff for fun - but WOW do I wish I was a bit clever.
You'll definitely know enough scheme to work through SICP. Another book that I highly recommend to anyone learning any lisp is Peter Norvig's Paradigms of AI Programming. It's a perfect balance between writing interesting programs and teaching lisp. It might be easier to work through using common lisp as some of the utility functions aren't defined in some lighter weight lisps, but it's definitely doable in scheme.
Because evil just isn’t vim
I've started reading SICP without any prior experience of LISP and it's completely accessible, it was written as an introductory computer science text after all. I can't comment on the other texts at all I'm afraid, but I guess as others have said it depends on what your goals are. SICP is good for computer science fundamentals like what O(n) notation means, and interesting bits such as the difference between recursion as a semantic feature (a function that can call itself) and a recursive algorithm vs an iterative one (where in scheme you can implement the latter using the semantic feature of recursion). There are some points about writing idiomatic and well-structured scheme too though.
I'm a fan of Hyper terminal.
`slate` is my favorite built-in vim theme. I usually download Nord though.
Here's what the tape looks like. &amp;#x200B; https://imgur.com/DpcFnN6
&gt; minor incompatible change: hash tables on 64-bit machines consume roughly 20% less memory but can only grow to hold 2^31 entries (theoretically) due to use of 31-bit indices internally. Huh, I wonder what's the old limit, and what will happen if I try to add new item to a hash table that is fulled.
&gt;S-Expression are much more readable and most people will be kind of comfortable with them, but when you get to the end of the definition you cant distinguish which parantheses belong to each other. &amp;#x200B; at least in my editor matching parentheses are highlighted and selecting s-expressions is a key or mouse click away...
Hi there! Great to see I-expressions get some love. I am a big fan of I-expressions, and think the later sweet expressions iteration was a step backwards because it added unneeded complexity. I created a thing called Tree Notation which is very similar to I-expressions. I think their could be a lot of applications of your code. Nothing much has been written in i or sweet expressions but I think that’s just because you need to make sure you are utilizing some of the unique properties that they have, and people haven’t done that yet. Specifically around program synthesis, visual programming, or other areas where there are things you can do with i expressions that you can’t do with others. I think your hackage library could be a hit and would love to help you if you’re interested in making that happen. If you ever want to chat, shoot me an email- breck7@gmail.com.
I dont want to shame on S-expressions! They are awesome in their own way. I am just trying to fix the good old parens problem ;)
If you have any suggestions on extensions or improvements in the source let me know or create an issue/pull request on github. One thing that will be necessary to implement is a marker that marks lines that should not be wrapped inside parens. Consider: if null? ls : #t fac 3 Instead of: if (null? ls) #t fac 3
That would help with using CL's LOOP macro readably, but building it as a separately-compiled Unix program instead of a reader macro (or a reader function since Scheme doesn't have readtables) takes away the REPL, which to me is a complete loss. I took the following example from the Common Lisp Cookbook: ;; Original: (loop for x in '(a b c d e) for y from 1 when (&gt; y 1) do (format t ", ") else do (format t "~A" x) ) ;; Translation to I-expressions, while attempting to ;; maintain the original readability: loop for x in '(a b c d e) for y from 1 when (&gt; y 1) do (format t ", ~a" x) else do (format t "~a" x) ;; Haskeme's translation into S-expressions (loop for x in '(a b c d e) (for y from 1) (when (&gt; y 1) (do (format t ", ~a" x))) (else do (format t "~a" x))) ;; What you'd have to type to get a correct expansion: loop for x in '(a b c d e) for y from 1 when (&gt; y 1) do (format t ", ~a" x) else do (format t "~a" x)
Wow, _Digitiser_ covered Lisp?
In Scheme: (string-&gt;list (symbol-&gt;string 'hello)) It wouldn't surprise me if CL had an equivalent.
&gt; *building it as a separately-compiled Unix program instead of a reader macro [...] to me is a complete loss.* Oh, I don't know. I suspect that a very sizeable intersection can be found between the set of people who want to fuck their Lisp code with indentation sensitivity, and the set of people who think it's okay to pass their Lisp source through an external preprocessor. The two might even coincide down to the last pinhead.
There are also [sweet expressions](http://wiki.c2.com/?SweetExpressions)
The index vector used to be an (unsigned-byte 64) vector, now it's (unsigned-byte 32) , so, that vector itself can take up 8GB, then that vector indexes into a twice as large vector with keys and values, so, that would be 32GB. Then there's yet another vector with indexes, an additional 8GB. That makes 48GB in total, which is doable, but will probably take some time to fill that.
Good luck with this, but I will point out a few problems that you may face in the future. Other have pointed out not having the REPL with this type of system. The devil will be in the details... As your posts indicate many have been down this road before, including McCarthy. The Common Lisp Standard Syntax was designed by a committee of experienced LISP programmers, who solved a series of complex problems in the syntax of the language. I don't know how Scheme addresses the issue below. The Common Lisp syntax (see Hyperspec http://www.lispworks.com/documentation/HyperSpec/Body/02_.htm ) defines a more complex syntax in the Reader including a way to define recursive structures with numeric labels in the tokens. Said an other way, Common Lisp syntax is little more complex than the tree structure you first see. The Common Lisp spec covered many of these type of edge cases, many of these cases come up when debugging code.
I have not much experience with CL, but wouldn't it be possible to call a binary from CL code? Then you could write a wrapper and pass everything through Haskeme to have it on the REPL. This would break stuff tho. The problem with the loop-syntax doesn't really occur in Scheme as it is not as overly expressive as CL. I really do see the problem tho! I am not planning to make changes to the implementation of functions like loop.
I am also seeing more and more problems with CL. It will be kinda hard to cover all the special cases with CL, so I will probably continue with just keeping Scheme in mind as there are a lot less deviations from the tree structure. If someone in the future wants to pick up where I stopped and try himself on Common Lisp he is free to do so ;)
And wisp: https://srfi.schemers.org/srfi-119/srfi-119.html
Sweet! Thank you for a very detailed explanation!
I don't understand. What's the "parens problem"?
[http://maclisp.info/pitmanual/charac.html#11.3.4](http://maclisp.info/pitmanual/charac.html#11.3.4)
Amazing! This is something that could really grow to an impressive counterpart to Julia and the numpy/scipy ecosystem.
All of these efforts seem completely pointless to me. S-expressions are an optimized maximum and everything else is at least a single step away from this. Are you sure you aren't looking to implement code folding on a per form basis?
The way I implemented it it really is very close to code folding. But that's because S-expressions themselves are already a tree structure. I don't care if there is no use for this. It's just a fun little project for me. Since there are some curious people out there considering I-expressions, they can at least try it out easily and then see whether they like it or not. Also programming languages are not always about programming itself, sometimes it's about learning about the design of said language.
Oh! Haha! Okay cool. Right I am being too serious, great point.
&gt;wouldn't it be possible to call a binary from CL code I suppose that's possible, but you'd have to read the original S expression first and then serialize it to the pipe. There'd be no using it with SLIME presentations, though. &gt;The problem with the loop-syntax doesn't really occur in Scheme as it is not as overly expressive as CL. You can implement LOOP on any Scheme implementation that supports `syntax-case` or `defmacro`. There exists a version for Racket.
Nice timeline! As the author of “Action!”, I’ve mused over the years at the poor quality of interface tools / environments. I’m happy to say that Apple is on to something with “SwiftUI’. They have completely rethought out a declarative UI, kept it quite interactive, and made it much easier to build quality IOS applications. Denny
[Action!](https://en.wikipedia.org/wiki/Action!_(programming_language\))...?
As a Swift compiler engineer, it’s so gratifying to hear you espouse this viewpoint. Do you have any stories from the development of Action!, or thoughts on its evolution and integration into Apple’s developer ecosystem?
Is Apple creating their own lisp system with Swift?
[How To Design Programs.](https://htdp.org/)
 You are awesomeness personified :)
No matter how hard I try, I cannot deny it.
They had the opportunity after Obj-C and threw it away. Swift couldn't be further away from Lisp (or Smalltalk).
What about debugging the code, which is very important in professional software. I find it difficult, if not impossible, to step through code in SBCL.
Snake games go back to the 1970's, long before Nokia cell phones. The first one was called [*Blockade*](https://www.arcade-museum.com/game_detail.php?game_id=7160), appearing in 1976.
Damn, didn't know this game goes all the way back to the 70s. Even had multiplayer. Impressive.
The idea that won't die. You can pry the s-expressions from my cold, dead hands.
&gt; " Turn off your mind relax and float down stream . . . " ( Thanks, all, for the CL help (and other comments) in the past few weeks ) - i had a vague concept about a Game based on the idea of Moving and colliding (((( Paren Blocks )))) --- like in TRON. - sort of like [RobotWar] on APPLE2 which lets players program their Robots - Lisp expressions collide and mutate. - We can go to a different SubR to throw ideas around and BrainStorm. ----- but where ?
[It's time to stop.](https://www.youtube.com/watch?v=2k0SmqbBIpQ)
This^
Hey there. Sorry about this but I've removed this submission because you put the link where the title is supposed to be. You should repost this submission with a meaningful title.
Thanks, I'll do that now.
Interesting approach. Would you mind taking a bit about some pros and cons of this, vs importing the individual symbols? This is more fine grained, but can I eg bring in a slot designator?
It looks like it's designed for importing symbols from optional dependencies and importing symbols under a different name.
q: why a: why not?
I don't understand why I would write a Lisp program which doesn't know where its "gensymmer" is coming from. It's not a good motivating example. However, it could be useful for things that come from Lisp implementations, like say an "expand-all" function that fully expands a form. (defsl expand :fn sb-cltl2 macroexpand-all ext expand-form ;; CLISP ...) Problem is, whereas expand functions probably all take a form and environment, some of the functions we might want to switch may have different argument conventions. Here, we can look to `defsetf` for inspiration. `defsl` can have a short form, like the above, and it can have long forms: it can define a lambda list, and then for each implementation, a template of code can be specified. ;; proposed long form (defsl whatever (foo &amp;optional blarg) xycl ^(sys:blah ,blarg ,foo) rtcl ^(internal:blat ,foo ,blarg)) Problem is, we have no way of indicating if we want a macro or function. `defsl` crams everything into a single operator; it would benefit from a breakup into `defsl-fun`, `defsl-macro`, `defsl-variable`, ... That `gensymmer` example could just be `(defsl-macro gensymmer utils with-unique-names alexandria with-gensyms)`. Keep the general `defsl` "mother" operator for handling unsual namespaces with their own binding places and boundp tests, but provide "baby" operators for the common cases.
Looks like LCL is from 1996, and only supported in maintenance mode and for porting applications from LCL to LispWorks now.
I did the same. Can confirm.
Lisp FAQ: Lucid Common Lisp: Lucid Common Lisp runs on a variety of platforms, including PCs (AIX), Apollo, HP, Sun-3, Sparc, IBM RT, IBM RS/6000, Decstation 3100, Silicon Graphics, and Vax. Lucid includes native CLOS, a foreign function interface, and generational garbage collection. CLIM is available for Lucid as a separate product. See also the comments in question [1-2] on the wizards.doc file that comes with the release. [Note: Lucid encountered financial difficulties because of forays into C-related products; the Lisp end of the company remained strong. Harlequin announced on 23-NOV-94 that they have acquired the rights to the Lisp-related technology of Lucid, Inc., that they will market and support Lucid Common Lisp alongside their LispWorks products, and that they have hired several former Lucid employees for this purpose.] For further information, contact by e-mail worldwide: lispworks-request@harlequin.com (OR @harlequin.co.uk) or in the US: FAX: 617-252-6505 Voice: 800-WORKS-4-YOU (800-967-5749) or 617-374-2400 or 617-252-0052 Mail: Harlequin Inc., One Cambridge Center, Cambridge, MA 02142 or in Europe: FAX: 0223-872-519 (OR 44-1223-872-519 from outside UK) Voice: 0223-873-800 OR -872-522 (OR 44-1223-873-800 from outside UK) Telex: 818440 harlqn g Mail: Harlequin Ltd., Barrington Hall, Barrington, Cambridge, CB2 5RG Lucid Common Lisp was then renamed to Liquid Common Lisp. The LispWorks IDE was ported to it and it was sold for a while. It's no longer available, though. As Lucid Common Lisp it was developed by Lucid, Inc.. It was a competitor to Allegro CL and LispWorks. Generally it was quite successful in the commercial world, especially due to its excellent compiler and a lot of contracts with various large companies reselling it under their name (Sun Common Lisp, ...). Richard P. Gabriel, a founder of Lucid Inc. wrote about the company and its fate here: [https://www.dreamsongs.com/Files/PatternsOfSoftware.pdf](https://www.dreamsongs.com/Files/PatternsOfSoftware.pdf) Rumor: I heard some years ago that the project actually originated at Symbolics as a 'Portable Common Lisp' project (or similar named), but Symbolics did not want release that one to the market, to not create competition to its Lisp Machine systems. Thus Lucid Inc was founded independently to develop and market exactly that...
http://vimeo.com/62618532 In Action! The environment was so interactive, you could pause, modify the interface, keeping all state, and continue running. Same for the lisp code - you could debug and make changes in the middle of execution... Rebuilding an app in SwiftUI now. I can’t express the increase in productivity strongly enough. Great work! It will improve the quality of apps immensely.
Funny, I cross posted on /r/Common_Lisp and had a similar "Can you improve the docs" style response. &amp;#x200B; I made it since \`asdf\` was not enough abstraction for what I needed: to arbitrarily choose dependencies and renames for any function, variable, macro, etc. etc. I'd like to make it as accessible as possible, rather than merely as formal as possible (which is how it is right now). &amp;#x200B; /u/neil-lindquist is right, that is exactly what it is for. &amp;#x200B; At the moment I am dealing with the problem of wanting to support two similar forks: Sly and Slime, with lots of shared codebase between them. I could write what I am doing twice, or I could write the compiler for \`SL\` (ie. the first two letters of SLy and SLime). Once I have that, I can bend that fork until I have a coherent set of names for all the functions I need, and which work on both (in principle). &amp;#x200B; Pull requests are appreciated. Hopefully that helps? Do send more questions.
But is it an available Vim plugin ? where's the source ?
- ( i didn't write any code for it. ) - i think one'd call it a standard (plugin?) of Vim . . . I just have these 3 lines in my _vimrc file. syntax on set lisp let g:lisp_rainbow = 1
Back then I made a similar thing for CL: [`cl-2dsyntax`](http://ql-goheecus.goheeca.ga/lisp/cl-2dsyntax/).
Just wanted to notify everyone, that /u/stassats has made a workaround recently. So now the library does not crash on Linux while running inside SBCL. [https://github.com/sbcl/sbcl/commit/b656602a309fc9647dd01255154c1068305f12f7](https://github.com/sbcl/sbcl/commit/b656602a309fc9647dd01255154c1068305f12f7) The workaround is to reestablish SBCL original signals right after .Net Core initialization. Interesting enough, is that is does not break dotnet runtime in any noticable way, neither in the field of Exception, nor in the field of GC. We need to investigate that further, however, and maybe cooperate with .Net team.
does it support wayland on linux? I see xfce4 screenshot in the readme, which means that there's Xorg running.
I don't think a color picker app could support "Wayland," as a single entity. Because Wayland is so minimal, every Wayland compositor (i.e. Weston, Kwin, wlroots, etc.) has a different way to go about screenshots or color picking. I could be wrong though.
Nice work!
Thank you for this kind of information, it would be next impossible to find anywhere. For some reason, Lisp varierty and richness inspires me to no end and motivates me to learn more. Thank you.
It depends on CLX on Linux so no
Cool. You've got the beginnings of useful cross-platform root window accessing library there too (\`x-screenshot\` in \`win32.lisp\`, \`linux.lisp\` and \`darwin.lisp\`). If you FFI out to GTK/GDK you might be able to sidestep the X11 vs. Wayland stuff btw.
"mechanism, not policy"
CL-USER&gt; (defun sign-extend (bits width) (logior bits (- (logand bits (ash 1 (1- width)))))) SIGN-EXTEND CL-USER&gt; (loop for i below 4 collect (sign-extent i 2)) (0 1 -1 -1)
Yes, ( as the file name says ) , pretty to look at. http://www.micahelliott.com/img/annoyances/pretty2.jpg http://www.micahelliott.com/img/annoyances/pretty1.jpg there's a line that looks similar to Python 's [ for x in range(3, 7): ( / x x ) ] i mean : [ ( / x x ) for x in range(3, 7) ]
Thanks!
Thank God for this. Good post.
Have you written any programs in Lisp yet? Seems all you do is put LSD mode on Vim, smash in some parens and record it.
Experimented witb caveman.. and then lucerne wich I prefer but I think I should just use hunchentoot in itself. No offense to the others.. but hunchentoot just looks like its more... I don't know, it does less but how ir works seems more fun to work with. Anyway, still prefer lucerne to caveman even though nobody touched the source codes in years. The source is still easier to understand than caveman but maybe its due to me being still being a young programmer without much experience. (Drunk, if its a stupid comment tell me I'm gonna delete)
you seem to know enuf Lisp to know What i'm getting at with these lines : (call/cc (call/cc #'(lambda (c) (c .... (apply #'append (mapcar ....
There is no call/cc in Common Lisp, and there aren't very many reasons to call/cc twice like that. (Then you just use it as an explicit return for a value that would already be returned.) Let's not go over your random choice of formatting (parens always hug their inner atoms, like `(defun f () 2)` instead of `( defun f () 2 )` as you keep writing) and random use of camel and snake cases. Let's also not mention that `=` is only applicable to numbers (not lists or strings), `'{}` is just a symbol with the name `{}` and so on.
It was about time, wasn't it ? I kind of took two years to learn stuff, find and gather information, try frameworks, develop simple apps, and put this together.
Saved me all that time. Appreciated
Lisp Is Simply Perfect
Great ! - ( LISP Is Sure (to) Please ) or ( LISP Is Surely a Pleaser ! ) - ( LISP Is Scarcely Python ) ----------- using the ("Pine Is Not Elm") idea
I don't think I agree with the author here very much. &gt; Lookups are a bit more terse than in Racket -- (v 0) instead of (vector-ref v 0). This complicates function application quite a bit, how can I be sure I'm calling the function V with the value 0 or if I'm taking the 0th value in the vector V? &gt; Hash tables are sufficiently lightweight in Clojure that you can use them where you'd use Racket's structs And then you lose out on any guarantees you've been given a valid structure. &gt; Speaking of for loops, why on earth did they decide to make the parallel for loop the common behavior, and require a longer name (for*) for the more useful nested loop version? A lot of common behaviours are parallel in Lisp, eg let and let*. This is also how CL's LOOP works too.
&gt; This complicates function application quite a bit, how can I be sure I'm calling the function V with the value 0 or if I'm taking the 0th value in the vector V? Having made use of these constructs many times in production code, I can say the construct of “collection as function” is quite nice, and easy to reason about. Especially when combining it with threading macros. It makes code extremely easy to read and reason about later. Of course, it’s made easier when combining with spec or schema, which give hints about the kinds of things you’re passing around in function signatures. &gt; And then you lose out on any guarantees you've been given a valid structure. I’m with you here. As a professional Clojure developer over the past year I’ve learned my lesson about passing maps around without sufficient schema validation. It’s a mess for sure! I miss required type safety.
&gt; ( defun f () 2 ) - if you look more closely, you'll see that i don't have an extra space before the DEFUN ( or DEFUN's ). &gt; (apply #'append (mapcar .... - You've never used this "idiom" ? --- my familiarity with such idioms is one of the hints (clues) that should suggest the possibility that i've written thousands more of Lisp lines than you have.
&gt;This complicates function application quite a bit, how can I be sure I'm calling the function V with the value 0 or if I'm taking the 0th value in the vector V? I don't really follow this. If you don't know what `v` is, you can't do anything meaningful with it anyways. &gt;And then you lose out on any guarantees you've been given a valid structure. Clojure provides plenty of ways to describe the structure for cases where you need to. You can add a spec for any structure, or if you wanted to you could use stuff like [defrecord](https://clojuredocs.org/clojure.core/defrecord). The fact that majority of code in the wild uses maps directly though clearly indicates this is not a problem people are actually having in practice.
My team uses spec for defining the structure at component boundaries, and it works pretty well. I've been working with Clojure professionally for nearly a decade, and I don't miss type safety at all. I suggest that you might want to look at how you structure you code if you find it to be a mess.
You can change racket's %app macro to do lookups when the "function" is a hash table or vector. I thing the rackjure language does this.
Curiosity — how long did it take you not to miss static typing? I’m definitely getting used to having to figure all this stuff out, especially on large project. However, it’s a bit tougher to have to remember to bolt on the safety in the beginning, when I’m used to simply having it baked into the language. I’m still convinced it’s a useful trade off given how much power the language gives me. However, it is still sometimes painful when on a large-ish team and not everyone knows the codebase equally well. Frankly, though, the fact folks have to offer advice to look at how we structure code is precisely the reason I miss type safety. It is just another reminder that there is a trade off. Power for safety. And I want both. Ha! As an aside.. I rarely read about patterns you need to learn to safely move from type-oriented to function-oriented programming without sacrificing code maintainability. I still sometimes wish there was a book on it... so I don’t have to learn the hard way.
&gt;And then you lose out on any guarantees you've been given a valid structure. Just to be clear, this is not globally lost, just locally, because, as you mentioned, you still have schemas for your maps, but the two are decoupled, allowing your map to exist on the entire spectrum of structural flexibility to inflexibility, allowing it to reflect the state of your program; early in a program, when you are still iterating and working out the shapes of things, similar to the red hot phase of a sword being smithed you may want a higher degree of flexibility and less commitments, and as pieces become adults more stable in their identities, then you can start locking their shapes down, dipping the sword into cool water. Or, if you're confident in a very static approach first, you can start off right away with proper schemas and contracts and other validation. Or there's a mix. For me, there is often a mix with pieces I know intimately from the start, at least in part. And the way I worded all that it may sound like adding guarantees is verbose or cumbersome or 'extra', and if so that's a failure of my own communication skills, because so far in my experience, adding inflexibility has always worked nice and concise.
Lisp Irritates Slow Programmers
&gt; how can I be sure I'm calling the function V with the value 0 or if I'm taking the 0th value in the vector V? With immutable vectors, could you tell a difference? ;)
I don't find any of pointed things as an issue that cannot be easily solved. And something not an issue at all. I don't agree on luck of data structures in general. I also see problems in another plane. Poor quality of standart library for example, date functions specific. Poor typed racket support. Buggy IDE (it crashes on attempt of debugging typed code), and also sometimes really slow. Luck of some OS level things support, as signals. And yes, luck of consistency of functions for iterable data types. So in general, your problems is just a subset of luck of consistency.
You can get type oriented and functional programming all together by using typed racket. The types is what naturally and inseparable present in any language. You cannot write anything without them. And specifying types is just like providing documentation with contract, so basically making sure that specific term will be understood correctly by whatever ever gonna read it.
It took me about a year or so to figure out patterns that work. A few things I can recommend would be to keep data flat when possible, keep the names consistent, and validate data at the edges to ensure that you're not getting surprises in core business logic. It's definitely a trade off but I also find it to be worth it overall. The editor integrated REPL and immutability go a long way here as well. Being able to work with the code interactively greatly reduces the mental overhead since you don't have to keep as much stuff in context. I always evaluate code as I write it, so in most cases I only need to consider the function I just wrote and the function I'm writing. So, I don't typically have to remember types outside that context. Meanwhile, immutability mean that all the changes are guaranteed to happen in a local context, and the data won't change from under me because somebody updated it via a side effect elsewhere. One area that could be explored more in my opinion is linting as seen with Erlang dialyzer. The idea behind it is to find cases where something is obviously wrong as opposed to forcing you to formally prove that everything is correct. I find this approach gives you a lot of bang for your buck without forcing you to structure your code around the type system. I started using [clj-kondo](https://github.com/borkdude/clj-kondo) recently with Intellij, and while it's not nearly as comprehensive, it does help catch stupid mistakes. [Elements of Clojure](https://leanpub.com/elementsofclojure) is actually an interesting book that I can recommend on the topic of general patterns and design.
You can use the same approach with core.typed in Clojure which is heavily influenced by typed Racket incidentally. Spec tends to be a lot more widely used though from what I've seen. And it's also borrowed from Racket contracts. So, Racket has definitely been quite influential on Clojure in this regard.
Thanks for the suggestions!
Cool. I’ll take a deeper look. Thanks!
Typed racket sounds very promising. I’ll have to check it out! Thanks!!
This is very nice, thanks! Would you consider mentioning easy-routes somewhere perhaps?. It's a very thin routing library on top of Hunchentoot, with support of decorators, arguments parsing, url generation from route name, etc. I've used it successfully in two Lisp projects at work, and I think it is a bit better than Hunchentoot's simple-routes. [https://github.com/mmontone/easy-routes](https://github.com/mmontone/easy-routes)
Just a reminder that this article is from the year 2010. How much have Clojure and Racket changed in that time?
Hey ppl, did you notice the article is from 2010, right? Basically all of the arguments against Racket are false today. You can get all sorts of fancy data structures in Racket, you can get nice and short fns to work with them etc... The only thing Clojure beats Racket in (and will probably do so forever) is hardcore parallelism and performance under heavy load, especially in networking. And that's not even a Clojure thing, that's provided by the JVM. Oh, and of course library availability (for example I'm sorely missing a RabbitMQ client). But that can be fixed over time.
I don't think the author is convoluting structs vs. hash maps, but saying that what programmers often want are hash maps but they reach for structs in Racket.
&gt;I don't really follow this. If you don't know what &gt; &gt;v &gt; &gt;is, you can't do anything meaningful with it anyways. (Not the OP) I'd argue that it hurts readability - especially for other readers, which of course could be yourself at a later date. In fairness, it's probably obvious in many scenarios what's going on, but for the sake of typing the extra characters I'd rather have the extra clarity - that is, knowing that I'm doing a **vector-ref** or **hash-ref** immediately just by glancing. I think having a little more verbiage can be beneficial in situations like these. This point is less relevant, but if you're writing an interpreter it's just nice to have one rule for applications: If the car doesn't return **#t** when **procecure?** is applied to it, something went wrong. Sure it's only an extra rule for each data type, but I still think adding those extra cases (to something which is otherwise clear-cut) is not worth shaving off a few characters.
I never brought up the latter because there was pretty much nothing wrong with it, except that you better not apply more than 20 lists because the minimum function argument limit is 20.
The reader has to be able to tell the difference when reading your hack to know if it's referencing a vector.
&gt; and I would guess it's more work for the compiler too. Your guess is wrong. Anything that implements an invokable interface can work as an applicable function. The compiler just has to ensure this holds true (aside from normal macro-expansion stuff). Clarity is in the eye of the beholder. In this case, vectors are mappings of integer keys to values....so they are fine as functions; functions are data anyways...
&gt; but I don't think that should have any bearing on the semantics of function calls. Well...they are pure mappings. So they are functions. If anything, they better conform to the semantics of function calls. If you don't want to allow a datastructure to be applicable, then it's trivial to just "not" implement the relevant interface. Nothing stops the author from using more verbosity to describe the inputs. Conventions arise to enable short-form interpretation of this kind of style as well, which - to those readers - improves readability. Similarly, there's the longer-form polymorphic `get` if you prefer to communicate the argument is an associative datastructure.
The interface here doesn't seem too consistent though. If I can update values in a vector or hash table, can I update them in a function? One implementation could look like (defun binding (key value function &amp;key (test #'eql)) (lambda (key2) (if (funcall test key key2) value (funcall function key2)))) And then it makes the language semantics more complex, because any objects can be used as functions. This isn't bad (see funcallable-standard-object) but the user has to be able to do it too.
Python `append` is `vector-push-extend`. You can't RPLACD on the empty list, and Python lists are really arrays.
Lisp in Small Pieces. or Lisp (sure is a fantastic language, but nonetheless) it should (not inspire people to use it as some kind of vehicle for ego-inflation because it does less in aid of that and more in aid of making the individual using it as such to appear rather) pretentious. The first, admittedly, is more catchy - and a great book! Shame about the price/out-of-printness, though :(
All I can say is that I've been working with Clojure for about a decade professionally now, and I can't think of a single time when this was an actual issue in practice.
There's a big difference between having data structures available, and them being language defaults.
Every. Single. One. Of. You. Please stay the fuck away from marketing. Holy fuck.
For reference and to show concretely that the principles are similar, in clojure the process would be similar. Assuming you have the quoted simple \`'hello\` you can get its name as a string with \`name\` \`(name 'hello)\` =&gt; \`"hello"\` Then to split that string into a list of single character strings you can use the \`clojure.string/split\` with an empty regex \`#""\` \`(clojure.string/split (name 'hello) #"")\` =&gt; \`\["h" "e" "l" "l" "o"\]\`
&gt;CL's LOOP works too What do you mean? AFAIK Loop evaluates clauses sequentially &gt;how can I be sure I'm calling the function V with the value 0 or if I'm taking the 0th value in the vector V? &amp;#x200B; Recently (last year's conj maybe?) Hickey explaned the reasoning behind it . IIRC it is that a map is precisely the moral equivalent of a function mapping from the key to the value. Even in mainstream languages you run from time to time into a function that is just a switch statement w/o any side-effects. That is the moral equivalent of a map. So the point is they don't want to make a difference between the two cases
&gt;What do you mean? I think the complaint was that `(for ([x xs] [y ys]) ...)` will step through XS and YS sequentially, and `(loop for x in xs for y in ys ...)` will do so too. &gt;IIRC it is that a map is precisely the moral equivalent of a function mapping from the key to the value. The sequence and function protocols are probably very different though. To make it "just work" if we really have to make sequences look like functions, I would suggest that sequence operations also work on functions. I gave an example implementation of binding a value in a map using functions somewhere else in the comments.
Why is big? Many problems and algorithms require certain specific data structures and descard the defaults.
&gt; If I can update values in a vector or hash table, can I update them in a function? You are certainly welcome to use mutable stores to express the mappings of inputs to outputs. In this case - e.g. the convention for Clojure - the mapping is immutable. vectors or hashmaps aren't "updated," rather new values (and transitively applicable functions) are computed. The semantics are simple and preserved, at least in the notion of pure functions and persistent vectors/hashmaps/hashsets being manifestations of pure functions. That doesn't stop anyone from injecting mutable semantics (e.g. through references) or using mutable structures though (I've done both) while retaining a functional facade parallel to the underlying data leveraged by the function implementation. This isn't a new thing either...you can already create complex semantics just by closing over local mutable state for your functions, exposing that state elsewhere, etc. The backdoor already exists in common lisp with funcallable objects and mutable slots (as you mentioned), or with simple lambda and extensions like Doug Hoyte details in Let Over Lambda (or even the primitive closure-based object system in SICP). &gt;And then it makes the language semantics more complex, because any objects can be used as functions. You say complex, I say expressive and leverage-building. From the language's point of view it's still trivial: can I apply the first thing to the other things? The language designer just opened the space of what can be applied to allow the consumer/user to decide. I appreciate that decision, since I've been able to leverage it with built-in stuff as well as custom types and structures that I want to provide an applicable facade for while still being able to deal with or refer to the data inside the function.
&gt; To make it "just work" if we really have to make sequences look like functions, I would suggest that sequence operations also work on functions Sequences are totally orthogonal to functions. The sequence abstraction is a projection into a lazy proper list. Collections participate in the sequence abstraction (again, via an interface) and efficiently provided semantic sequence views according to their underlying semantics (e.g. maps are sequences of pairs, while vectors, lists, etc. provide sequences of items in the original collection). Sequences are not applicable, since they intentionally don't support the function interface. Nothing stops you from coercing to and from sequences, leveraging the breadth of the generic sequence libraries, and then efficiently coercing a final resulting data structure that is applicable. The distinction is intentional (namely since non-indexed things like sequences and lists would induce linear lookup for the arguments....which in practice is undesireable).
I think, if you think about it, Clojure’s decision makes sense: a function maps values its domain to values in its codomain, and so one can conceive of a map as a piecewise-defined function that maps from a domain (the map keys) to a codomain (the map values).
Don't forget the Frenchness of the second edition.
I was inspired by the other post in this subreddit to write this this morning.
Vast majority of Clojure code in the wild uses the default data structures. I can count the number of times I had to use non-standard data structures myself on the back of my hand. Typically, the reason to use a custom data structure would be because you need specific performance characteristics. In those cases you can adapt the custom data structures to the existing protocols, and it's going to be an implementation detail. For example, say you wanted to make a red-black tree, then you could implement the `clojure.lang.IPersistentSet`: (deftype RedBlackTree [tree] clojure.lang.IPersistentSet (cons [self v] (RedBlackTree. (insert-val tree v))) (empty [self] (RedBlackTree. nil)) (equiv [self o] (if (instance? RedBlackTree o) (= tree (.tree o)) false)) (seq [this] (if tree (rb-tree-&gt;seq tree))) (get [this n] (find-val tree n)) (contains [this n] (boolean (get this n))) ;; (disjoin [this n] ...) ;; Omitted due to complexity clojure.lang.IFn (invoke [this n] (get this n)) Object (toString [this] (pr-str this))) And any functions from the core that work on a sets will also work on your rb tree. [Here's](http://www.rkn.io/2014/02/20/clojure-cookbook-rbt/) the fill example if you're interested.
I am ok with this mindset in niche like web development.
How is this related to luck?
I think the difference (in real usability and PITA level) isn’t as big as Clojure hardliners would like the rest of the world to think ;)
* Snake game in Common Lisp: https://www.reddit.com/r/Common_Lisp/comments/c8chcx/lisp_adventures_004_drawing_in_mcclim_and_a_snake/ * Another snake game in Common Lisp: https://www.reddit.com/r/Common_Lisp/comments/bu71uf/clsnake_play_snake_in_the_terminal/ * Snake game in Clojure: https://www.reddit.com/r/lisp/comments/c87jt5/a_clone_of_the_nokia_snake_game_in_clojure/
Lack I ment. Sorry for my runglish.
This mindset works for plenty of domains in practice. A couple of big use for Clojure outside web dev are data analytics and machine learning.
My experience is that bolting things onto a language only gives you limited mileage in practice because you end up with lots of different islands doing things their own way. This is similar problem with using immutable data structures in a language like Java. Everybody you work with has to agree on how to use them, and you'll often run into situations where you're working with code from others, such as libraries, that follow different patterns. So, it's less about usability and PITA levels, and more about having things work the same way consistently and throughout the language ecosystem. With Clojure, any library I work with or contribute to will follow a common set of patterns that the community agrees on. I found this to provide quite a bit of value.
No worries! Just had me very confused haha.
I might be mistaken but I believe Clojure has basically missed all the ML job market growth, and that Python has basically captured 95% of it, with the rest going to Scala and a few others.
What with all the Clojure posts lately? Is not even a Lisp.
Hey, happy cakeday mate. And yes it is.
&gt; how can I be sure I'm calling the function V with the value 0 or if I'm taking the 0th value in the vector V? What's the difference; a vector is a function from indices to values.
With mutable vectors, can you tell the difference? Functions are not all pure; (func 0) can return different values on different invocations. (It may be a wrapper for vector access, in fact).
It's less clear what data types we're working with, and functions and vectors have distinct protocols (unless you can replace values in a function).
It's niche compared to Python obviously, but it is used especially in the fintech sector. [Here's](https://www.youtube.com/watch?v=u-4FiFpkPlQ) a talk from a company doing ML with Clojure.
&gt;My experience is that bolting things onto a language only gives you limited mileage in practice because you end up with lots of different islands doing things their own way. Ex: javascript, a language I use daily (with lament)
Function application isn't implemented for mutable vectors (since there isn't a mutable vector type aside from transients, which are a special case with some additional gaurantees to isolate mutation). If you try to apply your mutable thing, you'll get an error telling you that thing doesn't implement the function interface and can't be applied. The convention is to allow persistent data structures to provide a functional mapping, since they are pure. Users are free to break the rules though and create mutable mappings leading to impure functions. This is about as desirable as funcallable objects with mutable slots, or impure functions with accessible state (via lexical closures or other means). Up to the programmer to choose when and how to conform or deviate (e.g. deviation from the persistent collections providing a pure functional invocation implementation is uncommon if it even exists in the wild.)
indeed it seems better, thanks for that. I'd like to see it on the Cookbook too (I already pushed it to https://github.com/CodyReichert/awesome-cl#hunchentoot-plugins)
I'm so very glad I get to use ClojureScript on the front-end nowadays.
One could hope, I at least get to enjoy it on my free time. I don't dare touch js outside of work.
cool. thanks!
&gt; this last dictum may be referring to how clean (functional) and uniform Lisp (CL) is, compared to Python I don't think any Lisper is concerned with comparisons to Python.
Do you recall anything at all about the contents of the book? That would help narrow it down.
The last page ended in: )))))))))))))))))))))))))))) )))))))))))))))))))))))))))) )))))))))))))))))))))))))))) )))))))))))))))))))) That should narrow it down to several dozen.
In particular, did the last page look like this? )))))))))))))))))))))))))))) ... )))))))))))))))))))))))))))) )))))))))))))))))))))))))))) )))))))))))))))))))) That should narrow it down to one of several dozen.
Tried russian libraries yet ?
(Bernard) Babani press did a series of programming books in the UK that were paperback and featured different 'non-mainstream' (for home computing) languages. But afaik they only did Fortran 77, Forth, LOGO, COBOL and Pascal, no lisp book. Collins did a Lisp programming book around that time, and while I can't find a good photo of the cover, there is a faint image of the cover in this magazine review of the book: http://live.worldofspectrum.org/infoseek/magazines/sinclair-user/39#118 almost edit: Here's a page with the cover of the Collins book in nice hi-res colour: http://www.computinghistory.org.uk/det/10180/LISP-The-Language-of-Artificial-Intelligence/ (be aware that there was also a 'TAB books' book on lisp from around the same time period, with the exact same title, published in the US This is the TAB Books one: https://www.amazon.com/LISP-Artificial-Intelligence-Frederick-Holtz/dp/0830603204
Well, as far as I can recall it was a LISP "basics" book.
I spent my childhood in the 80s reading books like that from Luton library :-) I did learn Lisp from a paperback book, but I can't remember any details... may well have been the same one!
That is one of the things I love about Lisp, it's beauty is so charming that anables its power and inspiration to act through decades of life and other experiences. I know, I have been there too. Best of luck in finding it.
Could be "LISP on the BBC Micro". Black cover, some blue text, although also a huge portion of green/yellow/orange. Basic LISP book, published in the UK in 1983. Google it, there are lots of images on the web.
That's actually a good idea. OP, did you get the reference?
I was similarly inspired by your post. I hadn't looked at the original source until after examining yours, and decided to refactor it into immutable, idiomatic clojure/script. Compared with the Racket version, the [Clojure/Script version](https://github.com/joinr/clj-snake): is slightly shorter, has no mutability, runs on either the JVM or in the browser with 99% shared code (aside from a minor reader conditionals), and can build native executable distributions via GraalVM (currently building, need an xwindows box to play on).
Sure it was LISP? Possible it was [Scheme](https://www.amazon.com/Programming-Scheme-Michael-Eisenberg/dp/0894261150)?
Sweet! &gt; is slightly shorter Mine is still a little bit shorter when you take out the unit tests: 214 sloc for mine and 230 for yours (not including `main.clj`; counted with `cloc`) though the feature sets are not exactly 1-to-1 (my version has an increasing difficulty curve, whereas yours loads/saves the high score and has screens for the paused and game over states) so this comparison isn't that meaningful. I felt a bit dirty making it in the first place. Like you, I hadn't looked at the source code for the Clojure version until I finished writing mine and I couldn't play it due to some exception when I ran `lein run` so I just based my game on what I remembered the old Nokia games and those "brick game" handhelds being/feeling like. &gt; has no mutability It looks like we have the same amount of mutability (i.e. that one `set!` -- I'm intentionally ignoring the mutable drawing contexts because both our games rely on those). It's just that yours is abstracted away by quil: https://github.com/quil/quil/blob/9aa50856182ce33d15e6beac9ca7f8c637b30da7/src/cljc/quil/middlewares/fun_mode.cljc#L9-L19 &gt; either the JVM or in the browser with 99% shared code That is one thing I am envious of wrt Clojure. Both Whalesong and Racketscript have stagnated so the Racket-&gt;JS story is not currently very good; though it may improve now that support for multiple backends is being improved via the RacketCS work.
This cover is more greenish, but has some dark blue to it. https://www.amazon.com/Object-Oriented-Programming-COMMON-LISP-Programmers/dp/0201175894
I am pretty certain it was LISP. Scheme I didn't hear about until university.
No, this is a very advanced book
Were the functions all in UPPERCASE? I vaguely remember one of those old basic one, all in annoying uppercase. Winston-Horn (in gray) was nicer then.
Try books.google.com and search for Lisp. There are several results for books from the 60s to 80s. Maybe the name will ring a bell. Also try archive.org. With any lycj there wulk be a free download. However, it's possible it didn't have Lisp in the title. Could it have been Structure and Interpretation of Computer Programs? This book had a blue or purple cover with a magician on the cover.
Is it this book by any chance? https://www.chapters.indigo.ca/en-ca/books/lisp-lore-a-guide-to/9781461291893-item.html The first edition came out in 1988.
Perhaps you are talking about the first book I wrote for Springer Verlag? “Common Lisp Modules. Artificial Intelligence in the Era of Neural Networks and Chaos Theory”? Your description of the book, small with the simple cover, matches.
Why Russian libraries?
Googling might help
Ohhhhhhh. Thaaat Russian library. You were a mite too subtle for me. For what it's worth, if you Google Russian library, it pulls up the national library of Russia.
try ddg.gg And yeah I was aiming at subtle
Could it have been a Scheme book? I'm pretty sure The Little Schemer was available in paperback with a blue cover.
&gt;whereas yours loads/saves the high score and has screens for the paused and game over states) so this comparison isn't that meaningful. Ah....so I ported the OP's implementation (the "Nokia" snake from another thread), which is what your comparison referred to originally. Perhaps the features diverged there. I also generalized the apples so that more than 1 could be added, etc. Didn't go beyond that since I was veering away from OP's port. &gt;has no mutability Ah yes, the atom quil uses internally. Could replace that with a reduce or functional loop; conceptually it's equivalent to an ongoing reduction over the game state with fun-mode. Then again, we're doing IO with the high score file and input from the ui, so...impurities. If you're going to ignore the effectful rendering framework, might as well ignore the state shuffling framework IMO. None of the "game logic" requires mutation, e.g. this code would work equally inside an `iterate` sequence of game states, a reduce, or a loop without needing any reference types.
&gt; If you're going to ignore the mutable rendering framework, might as well ignore the state shuffling framework inside IMO. None of the "game logic" requires mutation, e.g. this code would work equally inside an iterate sequence of game states, a reduce, or a loop without needing any reference types. Yup. I just meant to point out that our two programs essentially perform the same amount of mutation.
Ah, understood.
No, this wasn't an academic level book. It was a basic fundamental level programming but I was middle-school age with not yet that fluent English.
YES IT WAS DEFINITELY CAR AND CADR ALL THE WAY.
Everyone uses them notwithstanding the deprecation notice. Some convenience libraries offer the inverted semantic with *keep-if* and *keep-if-not* (e.g. provided by [CL21](https://github.com/cl21/cl21)), or *filter* which is the name used in some functional languages (e.g. provided by [Serapeum](https://github.com/ruricolist/serapeum)). Then you can say what to keep rather than what to remove; i.e. you can drop the "not" from the idea. I tend to import [Alexandria](https://common-lisp.net/project/alexandria/) wholesale and the occasional item from CL21 and Serapeum in my CL code for low-level language improvement.
I have no idea what you two are talking about.
I've emulated Algol call-by-name with a `defun-cbn` and `labels-cb` in in the Rosetta Code solution for Knuth's [Man or Boy Test](https://rosettacode.org/wiki/Man_or_boy_test#TXR). Even the detail of assigning to the function name to produce a return value is there.
That's an interesting idea. I'm personally satisfied with rainbow-delimiters-mode, but changing sizes could be interesting.
Wow, it's interesting that no one even seemed to indulge the thought that it might help.
They already had two Lisp systems, Macintosh Common Lisp (now Clozure) and Dylan.
Some thoughts from the ever-so-handy lambda.txt: &gt;Parentheses? What parentheses? I haven't noticed any parentheses since my first month of Lisp programming. I like to ask people who complain about parentheses in Lisp if they are bothered by all the spaces between words in a newspaper... &gt;Did Lisp kill your father or something? Was your father driving along in his sports car along the sea cliff road when a pair of giant evil sweaty parentheses loomed up out of the rough dark sea and munched him, dragging his corpse back to their dark chasm beneath the waves? Will there be an ironic twist at the end of the movie when you eventually discover, after finally slaying them, that the evil parens from the depths were actually the ones Java programmers use to sort out their messy infix expressions?
yea, some (most?) lispers and schemers seem terrified of any evolution. lisp and scheme are great, but the parentheses do get in the way sometimes. it is true they disappear a little after the honeymoon period, but they mever completely disappear. hpw could they? as the first answer says, they are important structural elements. however, the answer doesn't even address the question. how does changing the size of paratheses imply they should be removed? mathematics and physics uses different sized parantheses all the time to better communicate grouping information.
Don't shrink them, make 'em bigger! There's a reason we typeset math equations with big parentheses. (As opposed to hiding them and... hoping?)
how is that in anyway a productive answer?
Because I (and the people in lambda.txt) think the question is bogus and that parentheses aren't really a problem.
and? is everyone you? that excuse is what every programming language zealot uses, so it isn't useful. c programmers don't think there's anything else needed. it's not a useful stance to just say "it's not a problem". the parentheses aren't as big of a problem as people make out but they aren't as little of a problem as people make out either. it is fruitful to go through a gauge new ideas. it isn't fruitful to flat out reject them.
Discussions concerning readability or difficulty of parentheses should be banned from /r/lisp . Seriously.
I'd be interested to see an editor/IDE where parenthesis matching, instead of highlighting pairs or coloring them, is simply making text smaller every parenthesis or two. As your code gets more nested, it gets smaller.
&gt;Please stay the fuck away from marketing [Too late... resistance is futile, join the CLESF today!!](https://www.reddit.com/r/LispMemes/comments/b8zf3d/common_lisp_evangelism_strikeforce/?utm_medium=android_app&amp;utm_source=share)
No, everyone is not me but most Lispers agree that the parens become a non-issue with some practice and a good editor. You could well have a Lisp without s-expressions (and thus without parens), but then writing macros would be more difficult and editors would become more convoluted. I would also argue that having little syntax makes Lisp easier to learn than if it had, say, C-like syntax, simply because there is less to remember.
Because if you spend any time with the language at all it won't even be an issue? Who complains about the braces and brackets in C and other languages? You can learn basic Common Lisp syntax in minutes and then get on with forgetting about it.
Can Clojure posts be banned? They are not about Lisp.
i have spent some time with the language, particularly scheme and racket. they do get in the way sometimes. that sometimes is enough to wonder if there's a better way to at least *view* them, not replace them. people say they go away, then you watch someone (i.e., an expert) live code, and there is plenty of "paren management" going on. so don't kid yourself that they "disappear". and why do lispers always bring up other languages? no one is talking about them or bringing them up but you (the royal you). who cares about c or java? i don't.
I think changing the *colour* helps more than the size. I really like [paren-face mode](https://github.com/tarsius/paren-face) in emacs for that reason: it changes the colour on the parens so they're lower-contrast than other text, so that it's almost like reading an indentation-based language. I have no issues with the lisp syntax itself, I just find code easier to read with the parens dimmed alongside other syntax highlighting.
I believe that "outsiders" grok the parentheses just fine, and in fact those parentheses are their lifeline to being able to understand anything at all. The "outsider understandability issue" in Lisp is that the syntax is mostly obvious; what is unfamiliar is the vocabulary: what is in the parentheses. People who are familiar with programming and know a few languages already can correctly answer most the questions in ["Learn You a Lisp in 0 Minutes](https://wordsandbuttons.online/learn_you_a_lisp_in_0_minutes.html). They would probably struggle if the questions were loaded with *cons*, *car*, *pairlis*, *labels*, *destructuring-bind*, *member*, and whatever not. Not only are Lisps vocabulary-based, but if you're not familiar with a dialect, then you don't know which forms are from the dialect, and which are defined elsewhere in the program. None of the forms inherently "speak up" to say, "I'm built into this language". In many other languages that are in popular use, this problem appears also, but is restricted to functions and variables (is that function in the language, or in the program?) but when it comes to Lisps, the question applies to everything you see. One source of struggle is evaluation: what is evaluated and what isn't. And also how quote works, and why. What is the difference between `'(1 2 3)` and `(1 2 3)`. That's one of the most common questions from utter newbies. Newbies also struggle with pass-by-value: how come after `(append mylist '(1 2))`, `mylist` has not changed? The parentheses are a red herring. You will not help introduce Lisp to more people by doing anything with the parentheses. With smaller parentheses, or no parentheses, newbies will still struggle with the unfamiliar vocab, and their *append* not doing anything, and all the rest. Fiddling wit the parentheses just means you're caving in to some trolls; don't feed them! The parentheses are pedagogically good. They introduce consistency, discipline and remove ambiguity, so that evaluation semantics, scopes/environments and vocabulary are the only struggles, not trivial matters like operator precedence.
We can answer that in several ways, one of which is that it produced a score of +12, compared to your -1. (At my time of writing, needless to say.)
&gt; *and? is everyone you?* (all (lambda (they) (eq they me)) others) NIL Guess not?
do you plan on responding in a useful way or are you just going to make vapid arguments?
for some reason, my earlier reply didn't make it through. the question in the post isn't asking to remove them. both you and the first answer in the quora page are making that assumption. the question is asking how to minimize their distraction and/or increase/highlight their meaning in a visual way. bringing up other languages isn't useful but is for some reason a common defense mechanism of lispers. who cares about c or java? i certainly don't. again, the question is not arguing how to get rid of them or about other syntax. it's a question about what i mentioned earlier. it's a valid question.
You should be reading by indentation and using the parens where that fails, but if you must change how the parens look, [rainbow-delimiters](https://github.com/Fanael/rainbow-delimiters) helps me recover when I get lazy and forget to indent.
This is an underrated idea.
I don't care if it is useful or not - that's funny as hell!
No. If you actually need to count a string of trailing parentheses, smaller ones would make that harder. Also, sub^aesthetics. The real problem with Lisp syntax is that tics/backtics are too small. They look like dirt on the monitor even though they carry important semantic information. In other languages they are usually a formality that can be safely ignored similarly to how Lispers ignore parentheses. In Lisp they make such a difference that I'm tempted to use keywords instead.
Probably libgen.is
&gt; how is that in anyway a productive answer? Some questions can only be answered by a variation of "I reject your premise". *Have* you stopped beating your mother?
I see you didn't find my top-level response.
New to lisp, only done light Java before. The parentheses don't bug me at all but I do like the different color for different layers thing you got there, is there anyway to set that up for Dr. Racket?
short answer: no. long answer: this subreddit tries to be inclusive and considers clojure to be part of the lisp family of languages. Given there are only 1-3 posts a day, users can self-filter themselves.
Tough to swallow you calling out people for being assholes while yourself being such asshole. You made some points, why all the anger too?
Is not part of the Lisp family regardless of how is being sell. Moreover, there is already r/Clojure which is pretty active on its own and mods from there are basically just re-posting from there.
Here's a sneak peek of /r/Clojure using the [top posts](https://np.reddit.com/r/Clojure/top/?sort=top&amp;t=year) of the year! \#1: [Rich Hickey: Open Source is Not About You](https://gist.github.com/richhickey/1563cddea1002958f96e7ba9519972d9) | [215 comments](https://np.reddit.com/r/Clojure/comments/a0pjq9/rich_hickey_open_source_is_not_about_you/) \#2: [Clojure 1.10 release!](https://clojure.org/news/2018/12/17/clojure110) | [19 comments](https://np.reddit.com/r/Clojure/comments/a71v25/clojure_110_release/) \#3: [Maybe Not - Rich Hickey](https://www.youtube.com/watch?v=YR5WdGrpoug) | [83 comments](https://np.reddit.com/r/Clojure/comments/a1n962/maybe_not_rich_hickey/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/afd0dd/blacklist/)
u/yogthos is the only mod of /r/clojure to post regularly and recently (once in the last 4 months). There is also /r/Common_Lisp, /r/scheme, /r/Racket, etc. even though this sub is dominated by common lisp posts we try to be inclusive.
Not that I know of, but you could ask [the Racket forum](https://www.reddit.com/r/Racket/).
I think the point is not that they disappear but that managing them becomes instinctive and subconscious because the rules are simple and because they govern everything you do. Other languages are brought up because in other languages precedence rules and different types of parens, brackets and braces make the syntax something you have to actively think about. You shouldn't have that problem with Common Lisp (or most Lisps).
I've been working with JavaScript lately due to my job, a friend said that YAML was the Python like version of JSON, which may be simplistic, but it got me thinking about my code in JavaScript and the tons of parenthesis it uses (I am not making a distinction betwe ( ), {}, \[\], &lt;&gt;, to me all of those are parenthesis, I eve would go as far as counting some .methods as parenthesis. I've run ito cases where you have a bunch of }); }\]}).method(()=&gt;{x}) things in my code which also require the software to be aware of parenthesis and help with indentation, otherwise you get lost within the sea of parens, I think I may be too fod of Common LIsp, but give me regular old round parens and paredit any day. All of the parens we have in LISP are there in other languages either as indentation, . methods, or boiler plate leading to a call, but the syntax is working to hide them, which may be counterproductive.
Yay ! Welcome back, mate !
same sorta concept, stupid execution: [https://github.com/alimpfard/dem-parens](https://github.com/alimpfard/dem-parens)
[Could it be this?] (https://web.archive.org/web/20190710223150/https://i.ebayimg.com/images/g/e0kAOxykMpTJc0e/s-1640.jpg) THE ELEMENTS of Artificial Intelligence. An Introduction Using LISP Steven L. Tanimoto Computer Science Press That isn't a photo of the book I own, but I have a copy just like it, and I believe the copyright date on this edition is 1983 or so. (The EBay like I got it from says 1987, though.)
I just searched on abebooks - title containing "lisp", paperback, publication 1980 - 1990. I got 395 results (many are duplicates, of course). You might take a look and see if you recognize it: https://www.abebooks.com/servlet/SearchResults?bi=s&amp;bsi=0&amp;bx=off&amp;ds=30&amp;recentlyadded=all&amp;sortby=17&amp;tn=lisp&amp;yrh=1990&amp;yrl=1980&amp;prevpage=2
I sometimes think the problem with parens might be one of anchoring. E.g. if you've seen Perl or APL, then Python or JavaScript looks like a moderate amount of syntax. But for a programmer looking at Lisp for the first time -- that's the most parentheses they've ever seen.
`quux` is a cons cell containing functions. The big `cons` expression destructures it, and constructs a functionally equivalent `cons` cell containing functions which uselessly wrap the original function.
I'm so glad the "lambda, the ultimate" phrase lives on.
I never heard it, where is it from?
I think it came from the original Scheme papers, which were of the form "Lambda: The Ultimate &lt;noun&gt;".
Thanks for the ultimate explanation
Are you sure you don't have another server running in the background somewhere?
I don't think so because the database errors I see in emacs, which suggests it's the instance running there.
Thanks for all the suggestions so far! Have learned of some great books I wish I had read. The best cover so far found: [https://www.abebooks.com/servlet/BookDetailsPL?bi=30260342624](https://www.abebooks.com/servlet/BookDetailsPL?bi=30260342624) But sadly, so far no luck. Starting to think I have imagined this book.
In this video: [https://youtu.be/GxouWy-ZE80](https://youtu.be/GxouWy-ZE80) Brendan Eich talk about A Brief History of JavaScript. JavaScript was created by Brendan Eich in 1995 during his time at Netscape Communications. It was inspired by Java, Scheme and [Self](http://handbook.selflanguage.org/4.5/). The idea was ‘Come and do Scheme in Netscape. Put this programming language into the browser.'” He later calls Scheme “that beautiful research language I was tempted with.” What was meant to be a Scheme for the browser turned into something very different. The pressure to close the deal with Sun and make Mocha a scripting companion to Java forced Eich's hand. A Java-like syntax was required, and familiar semantics for many common idioms was also adopted. So Mocha was not like Scheme at all. It looked like a dynamic Java, but underneath it was a very different beast: a premature lovechild of Scheme and Self, with Java looks. &amp;#x200B; The question is: If Schema is a Lisp dialect, is Lisp part of the Javascript source?
I use ClojureScript with [re-frame](https://github.com/Day8/re-frame), so far it's great!
JavaScript isn't a Scheme: http://journal.stuffwithstuff.com/2013/07/18/javascript-isnt-scheme/
&gt; LOGO is not a language. It's a way to simulate 'skid marks' made by turtles with serious bowel control problems. OMG, I've never thought of it this way! I used to make that little turtle draw all kinds of stuff for me.
Re-frame FTW!!!
Cheers!
\[OT\] Brave is actually a very clean browser, one of the very few that doesn't spy on you (because even Firefox is not really safe in this regard). (And your political viewpoint is of no value here. We Are the News Now, not MSM.)
So Eich's plan to replace any other ad systems with his own which require his own process isn't an issue? I did expect someone to complain that my examples were pseudo-political, but shitty people tend to continue to be shitty.
&gt;News now not MSM That's a political viewpoint nerd
That's the Truth (which is not political at all).
So where is your Scheme code and what runtime/library/framework are you using to build this? I see a reference to Chibi scheme in the page code.
So the author of JSLisp talks a lot about "compiling" but to me this seems to be more of a transpiler. Or can I write any CL code using whatever libraries I want and it will essentially use JS as a bytecode, similarly to what https://github.com/vishesh/racketscript was doing...?
How about emacs on termux?
CL Repl is really good. It also allows saving and loading files and comes with quicklisp. You should try it!
SBCL, CCL worked for me on GNURoot Debian.
CL-REPL is full ECL (and supports quicklisp) and is quite good. As for using an external editor, it can load files from the filesystem, if that's what you're asking? You can edit those files with whatever text editor you want.
picolisp is *far* from a common lisp, it's a 'new' lisp dialect with some similarities to arc and clojure.
&gt; CL-REPL is full ECL [This](https://github.com/koji-kojiro/cl-repl) CL-REPL? &gt; only SBCL supported
No, the Android app [CL REPL.](https://play.google.com/store/apps/details?id=org.eql5.android.repl&amp;hl=en_US)
Ahhh, I see.
https://lispcookbook.github.io/cl-cookbook/
Check out land of lisp. I’m currently working my way through it. Besides the fact it uses clisp it’s a good book.
Common Lisp Recipes by Edi Weitz https://www.amazon.com/Common-Lisp-Recipes-Problem-Solution-Approach/dp/1484211774/ref=mp_s_a_1_1?keywords=common+lisp+recipes&amp;qid=1562954309&amp;s=gateway&amp;sr=8-1
I second this suggestion: start writing CL code and you will find lots of useful snippets to get stuff done. Later, reading Edi’s Common Lisp Recipes would also be good.
It is chibi scheme compiled to webassembly the code can be found here https://github.com/scheme-live/ff.scm
(upvote \*)
Sorry to hijack the thread, but FYI I have found source code, assembled, and run several version of Logo: - BBN Logo ~1970. - MIT PDP-11 Logo ~1972. - MIT Lisp Logo ~1975. - MIT Apple II Logo ~1981.
Ahh, thank you. So, if I'm getting this right, we can assign to a call-by-name QUUX like so: ((CAR QUUX) NEW-VAL) and to illustrate the point, we would do that because it's pointless to do this: ((CAR (CONS (LAMBDA (NEWVAL) ((CAR QUUX) NEWVAL)) (LAMBDA () (CDR QUUX))))) NEW-VAL) Thanks again :)
If you are looking for fun ways to get back to CL, implementing [Nature Of Code](https://natureofcode.com/) examples in it could be the way. For hints you can have a look at https://github.com/mark-gerarts/nature-of-code
Look at the Atlanta Functional Programming Youtube Channel for Youtube Livestream link
learn racket. :)
Why?
they mentioned they learned common lisp, but it's obvious it didn't stick. so for one, why not try something new? secondly, common lisp hasn't changed much from when they first learned it probably, but racket is a whole new thing these days. so secondly, it could give them a new perspective. and lastly, although there are probably (?) more commercial projects using common lisp, racket is much more active these days it seems. racket has still not broke into the industrial space yet, but it presents some ideas that are very different but very evolved and extremely modern and cutting edge. they didn't present a strong reason why to return back to common lisp. so it seems a good fit to try something new. if anything, they could try the land of lisp and the realm of racket at the same time.
Especially these days
- Where can I find the most tasty bananas? - Go to the apple store, they have a fruit in their logo and their hardware is excellent!
I've preparted some notes for myself, so if you want to know what I'm going to talk about here is an outline (exported from the org document): http://hellsgate.pl/files/aa68c0b0-presentation.pdf
Such a thing exists?!?!?!
how is that in anyway a productive answer?
that is really cool. thanks for the link.
What do we have here, the attack of the SJWs? What do his social views have to do with the technical merits of the Javascript language he wrote? In any case being a massive shitbag has constitutional protection, unless you have problems with the constitution.
Done in TEX. What a boss!
To be honest it was org-mode with org-export-to-pdf (which goes through pdftolatex).
Cant wait!
&gt;What do his social views have to do with the technical merits of the Javascript language he wrote? I was pointing out that he's a conman and that he's probably not worth listening to, and he would have reasons to pretend JS isn't a massive kludge. &gt;In any case being a massive shitbag has constitutional protection, unless you have problems with the constitution. Well, the prison labour part of the 13th amendment has to go at least, but legality and morality are different things and I believe I'm still allowed to call him out for doing stupid things. &gt;What do we have here, the attack of the SJWs? Yes you do. We're coming for your toothbrushes too.
https://www.reddit.com/r/lisp/comments/ccd332/z/etnscth
???
Yes, you can get books off it. You enter a name on libgen.io, it gives you a list of files with their mirrors, pick one and you [get a download page something like this](http://booksdescr.org/ads.php?md5=565FCE4885FB72247A96F433FDB98EEA).
Any place you need to run JavaScript, like browsers, but don't want to touch the metaphorical poop.
People may use Parenscript when they want to compile Common Lisp code to Javascript. That's what it's for. So, the domains people use it in are limited to the domains in which they might use Javascript. I'm not sure whether it does find "much" use. It certainly finds some use. Turning Common Lisp into Javascript is a somewhat niche interest, it seems to me. There are many similar projects targetting Javascript from other language. Clojurescript is another well known one for compiling Clojure to Javascript.
Maybe a more direct question -- which companies and/or non-trivial websites are implemented using Parenscript?
Expanding on what /u/theangeryemacsshibe says, Parenscript is a lovely JS [hazmat suit](https://www.google.com/search?client=firefox-b-1-d&amp;q=hazmat+suit). * Using it to generate views for CouchDB from a class. * Using it and a websocket to remote-control a browser for quickie UI's where you maintain the state of the UI in a data structure on the lisp side and "paint" it to the browser by sending clumps of javascript to be evaluated, possibly sending back a response over the same websocket. This is more fun than practical, but I've spent hours playing with this and some of the "web desktop" JS libraries like [jspanel](https://jspanel.de/). * PS + Selenium to aid in testing web sites or scraping information where an xpath selector isn't giving you what you want.
I suppose these are the correct livestreams https://www.youtube.com/channel/UCYg6qFXDE5SGT_YXhuJPU0A Thanks a lot (even though I forgot to attend online)
Yes, for example you'll find a lot of Parenscript in Next ([https://github.com/atlas-engineer/next](https://github.com/atlas-engineer/next)). We have a macro we use to run Parenscript in Next: [https://github.com/atlas-engineer/next/blob/master/source/macro.lisp#L8](https://github.com/atlas-engineer/next/blob/master/source/macro.lisp#L8)
Why is it fun but not practical?
A couple of years ago, a person I know saw the video and conveyed to us the idea that Javascript had its origin in Schema. At that time I had been learning Lisp and had heard about Schema. During these years I have been using Javascript but I did not find any similarity with Lisp, I had my doubts about this statement. Thanks for the information, I already have a clearer view of the matter.
It's used in the heart of the Weblocks framework, though not visible for the developer: https://github.com/40ants/weblocks (example: http://ultralisp.org/). It's used to generate ajax dynamic calls transparently for the user. ps: see also trident-mode, an emacs mode for live ParenScript manipulation. Like Clojure's Feeghwhil, but not much developed. https://github.com/CodyReichert/awesome-cl#javascript
I once tried Emacs/Slime on **Termux** with ECL, it could even compile ECL code natively! Of course you'll need a better keyboard for Emacs, like the **Hackers Keyboard**. Here the description: [Emacs + ECL on Android](https://blog.teknik.io/phoe/p/1633).
I don't understand. How is this even related to Lisp other than having a single `Lisp` tag on the bottom?
Come on, everyone knows that balanced ternary is the way to go.
If people spent half the effort they spend on complaining about lisp syntax into either, actually learning lisp and reaching the breakthrough so many people have, or into implementing their ideal syntax and getting on with it, maybe we could reach world peace.
\&gt; into implementing their ideal syntax This is a great point, and rest assured that of the time I invest in this stuff, I spend about 99% of my time on implementing it, and about 1% of my time complaining about parens. It's actually helpful though to spend an hour once in a while and write something like this to get feedback from the community, because often times people will share a link or thought that saves me tens of hours of work "implementing my ideal syntax".
Luckily lisp is made for syntactic abstraction and there are decades worth of resources for implementing languages in lisp.
Exactly--luckily we don't need parens because we can just use parens to not use parens.
I'm guessing this is taking the piss of people that say the parentheses disappear in Lisp somehow.
Interestingly enough, the article fails to offer any real reasons to switch to binary from ternary. Similarly, all the people that I've seen suggesting that Lisp could drop the parentheses in favour of some other system also fail to explain why this would be desirable, simply offering some sophomoric solution as if they had finally "fixed" some long-standing misfeature of the language.
One thing I've used it for in the past is to use trident-mode to write programs that draw in real time in a canvas, similar to [Processing](http://processing.org/), or [p5.js](https://p5js.org/), or [Sketch](https://github.com/vydd/sketch), since it is animation on a canvas it could even be used to write browser games, since it provides you with a simple environment a la [Pico8](https://www.lexaloffle.com/pico-8.php). [Here is an example](https://gist.github.com/maufdez/5a420948a1fdcfb7b6cf33bdead61ccc) I wrote in Parenscript, I planned to made a video on it, but I kept postponing it, I guess because I don't like my recorded voice and my accent.
This article doesn’t address it, but check out TreeNotation.org and ohayo.computer to get a taste of what the future holds for parenslessness. Much more work to be done, but I think come 2020 there will finally be a compelling reason to not use parens anymore.
I was going to write something snarky, but I think you probably deserve a serious answer. First, I want to explain why I originally felt the need to be snarky: you come across as making some really arrogant claims. You say your tree notation is "what the future holds for parenslessness". Lisp has existed for 60 years. Python, YAML and other indentation-based languages have existed for a while now. I don't mean to sound rude or dismissive, but you're coming across as claiming that indentation-based syntax is some sort of radical new game-changer, when it has been around for quite some time (and it's worth mentioning that [quite a few people dislike it](http://wiki.c2.com/?SyntacticallySignificantWhitespaceConsideredHarmful), so it's at the very least questionable whether it's an improvement over parentheses). &gt; there will finally be a compelling reason to not use parens anymore Here's the thing again: you have shown (as have many, many others before you and, no offence, anyone who has thought about programming language syntax for more than 10 minutes) that parentheses can be avoided. You haven't shown why this is desirable, other than your own personal aesthetic preference. The example you have at TreeNotation is that you can write `(* (+ 1 1) (+ 2 2)` as: * + 1 1 + 2 2 Whether the second is better than the first really is up to personal debate, I certainly don't like it too much. One thing you might not have considered is that, while the Lisp code can be written in a bunch of different ways (I can split it into multiple lines if every term gets too long, compress it down to one if they're simpler, etc.) whereas your tree notation can only be written in one way. Another problem is expressions like `((get-operation) 1 2)`. How would this be written in your language? get-operation 1 2 would get translated into `(get-operation 1 2)`, which isn't right. get-operation 1 2 would get translated into `(get-operation (1) (2))`, which isn't right either. So what then? I guess you could write it as get-operation 1 2 and use the extra indentation to symbolize the extra layer of parentheses, but wouldn't that get translated as `((get-operation 1 2))`? You can fix all of these details, of course, by adding more syntactic complexity. But at that point, aren't you the one trying to go from the binary of Lisp syntax to the ternary of some cumbersome, ad-hoc, arbitrary syntax?
At a certain point, I genuinely only see left parens unless I'm specifically looking for where the boundaries are.
Thanks for sharing the feedback. Very common questions, and they are handled at a higher level -- see [http://treenotation.org/faq.html](http://treenotation.org/faq.html). But more importantly your comment made me realize that it's stupid of me to not show any of the best demos of why Tree Notation is better in the readme. The examples in the readme are too basic. I should put the compelling examples front and center. I created an issue for this: [https://github.com/breck7/jtree/issues/22](https://github.com/breck7/jtree/issues/22) and will get it done soon. probably putting some of the visual programming, programming synthesis, and ad hoc parser examples up there. Appreciate the feedback!
What's wrong with parens?
That doesn't answer anything. All it says is "this is basically Lisp without parentheses, but because we got rid of the parentheses, it's super awesome now." What concrete benefits does this provide?
Would've been nice to have more notice. I just saw this, and it was yesterday.
Of course they do, but it's something the non-enlightened don't realise it's possible to learn to ignore them. It's like not having to think about tying shoe laces.
That article burned the last 3 remaining neurons I had left within the second paragraph
You're aware that s-expressions are already trees, right? This is just lisp with significant whitepsace. In You've isolated one of the things hate most about Python (after threading and variable scoping)...and declared it the next big thing?
I happen to like sexpr notation. One way to look at things is that there is a spectum of syntactic complexity. Lisp it's very close to one end, choosing a postage stamp description but shifting all the complexity into the library call arguments. Let's say C++ is at the other end. In the lisp case you have to remember the how to form a tree acceptable to COND with it's exprs and bodies. In c++ you have to remember about braces, parents, colons, semicolons and keywords. Only one can be done at runtime, and it's also homoiconic.
Its bad! You can't say `(apply #'+ (list 1 2 3))`. Its the thinnest, most brittle veneer on top of JS and it makes all sorts of implications that it can't keep. You'd be better off using Clojurescript. Or just writing JS. I've used it in a commercial product and it was more trouble than its worth. That was a few years ago, so it could be better now.
Thanks! I was away camping and am now glad I didn’t completely miss out.
Hooray, awesome! Can't wait to see more parentheses! :D
[Technical Issues of Separation in Function Cells and Value Cells](https://www.dreamsongs.com/Separation.html)
You are quite correct, CL has different namespaces for functions. The common term for this is that scheme is a “lisp-1” (because it has one namespace) and CL is a lisp-2 (two namesaces). This is an interesting subject actually. For a really in depth treatment of why this is an interesting design choice check out the book “Lisp in Small Pieces” The really quick summary is that having a separate function namespace makes it a bit easier to write macros because syntactically manipulating variables and functions is quite different there is less possible name collision, but it makes functional programming idioms more verbose. And a single namespace has the opposite characteristics (functional is easier at the expense of more possibility of name collisions in macros). Personally, I don’t really see the benefits of a lisp-2 because if your macros are properly hygienic name collisions shouldn’t be possible. And I am a fan of functional programming.
Using the same name in different namespaces allows you to do something like this: (defun list-of-list (list) (check-type list list) (list list)) This is a useless function, but it's probably one of the simplest functions that demonstrates using the same name for a type, a local variable, and a function, which is very common in Common Lisp. On the other hand, Scheme usually uses names like `l` or `lst` instead of `list` for variable names of procedures operating on lists to avoid a name conflict, especially if the procedure `list` is going to be called. The equivalent in Scheme could look something like this: (define (list-of-list l) (if (list? l) (list l) (error "An item that satisfies list? was expected"))) Of course, the downside is that higher-order-functions in Common Lisp require `funcall`, unlike in Scheme. Every design decision has tradeoffs.
&gt;Technical Issues of Separation in Function Cells and Value Cells Context aside, this quote does it for me: "In the end, practical considerations favor the status quo for Common Lisp. There is a large number of improvements beyond a single namespace that could be made to Common Lisp that would clean it up and simplify it. We feel that the time for such radical changes to Common Lisp passed, and it would be the job of future Lisp designers to take lessons from Common Lisp and Scheme to produce an improved Lisp." I think that could almost paraphrase down to, "Let's leave it for practical reasons. Sure, there's a lot we could improve about CL, but it's too late, someone else will have to get it right next time."
Skimming through the chapter I mentioned, the discussion there is actually completely different from my summary. The book talks more about the differences in terms of ease of implementation and optimization of the resulting code rather than talking much about what coding in the different styles is like. A very rough explanation of that discussion is that having multiple explicit namespaces makes it easier to evaluate code that interacts with different the namespaces differently, typically so that the resulting code can be more efficient. However the gains are probably small, because a sophisticated lisp-1 can do much the same differentiation automatically at the expense of a more complex language implementation.
&gt; *bound in an entirely different table* Not only globally, but in lexical scopes also. `(let ((a 42)) (flet ((a ())) #| function a does not hide variable a |#))`.
Isn't the other downside that someone might use the same name for a type, a local variable, and a function?
Yes, but you won't mistake a type, variable or function for one another. Functions in variable positions have to be called using `funcall`, and using a function as a value requires a `#'` prefix for example.
there's a pedagogy in programming where they aim to teach functional languages first. I'm learning programming through this: https://github.com/ossu/computer-science the first class is in python, but after that there's a heavy focus on functional languages, or at least using languages functionally. (BSL, racket, SML, Haskell), but my into to programming was in C. I really like the lisp-family though and hope I can eventually find a job working with those languages
&gt; if your macros are properly hygienic So all you have to do to avoid name collisions in a lisp-1 is use a macro system that makes non trivial cases (anything beyond simple template substitution) 10x harder.
I don't doubt that this usage is technically unambiguous, but surely it would help the next person who will look at this code if it used different names for different things.
I don't really think either choice is better than the other, but I don't think Lisp-n is ambiguous. In many human languages, some words are verbs and nouns, and humans interpret them fine.
Exactly what I was thinking. This hygiene evangelists are dangerous.
thought of that... then thought of that again.
The C preprocessor is a widely know*N* way of The n is missing. Nice essay!
For those who read L.i.S.P, what other books do you know of similar topic and substance ?
interesting project. How is this program/set of functions meant to be used? For example. I don't see pomodoro referenced in holon.asd. Has anyone else used your program? Are you a psychologist, working in collaboration with any psychologists?
I agree. Other Javascript sugars like Coffeescript eventually suffered the same fate. Unfortunately (at least until WebAssembly is commonplace) bare JS is usually the best tool for the job. I actually have some CL-generated JS code in my webapp, but it comes from using [closure-templates](https://github.com/archimag/cl-closure-template) library, not Parenscript.
Buffalo buffalo buffalo buffalo ....
Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo
Only the first one is capitalized, so even this is entirely unambiguous. Though your grander point is clear.
Personally, I use this: [https://github.com/marcinkoziej/org-pomodoro](https://github.com/marcinkoziej/org-pomodoro) A simple pomodoro timer is, well, a pomodoro timer. I have one of these as well, for when my tasks are not at or near my computer. I have been using the basic (25+5)\*3 + 25+20 technique for just over a year now, it is has enhanced my productivity quite a bit!
It's not just functions and variables that are namespaced. Common Lisp has at least 7 namespaces (PAIP page 836): functionss (shared with macro functions), variables, special variables, types, tagbody labels, blocks, and symbols within a quoted expression.
I think there can be good JS-Lisps (I wrote one, but ran out of time to maintain it) but the only way to really do it is to make sure the semantics of the language remain the semantics of Javascript. The problem with Parenscript is that it absurdly tries to kinda look like Common Lisp but simply cannot deliver on that promise.
The article “Technical Issues of Separation in Function Cells and Value Cells” by Richard Gabriel and Kent Pitman also has some good discussion of this, as well as a bibliography for even more sources. Currently you can find that article at https://www.dreamsong.net/Separation.html
Weird, firefox flagged the site and I can't find an archive in wayback machine, if you can back it up that would be lovely Thanks anyways
Search for the title I found it a couple other places too
Technically, I was working with a pop psychologist (Dr. Jordan B Peterson) when I started developing this, but I was working on a separate project for him, while using this software to help drive my personal performance. This software is just for self exploration ATM. The tasks module is the central module. It loads in daily tasks which reference various fn's that I will manually run in the REPL. At some point, I will orchestrate and automate the entire process a little better.
aight, finally found some cached version https://webcache.googleusercontent.com/search?q=cache:0e6KZ76zc9oJ:https://www.dreamsongs.com/Separation.html+&amp;cd=1&amp;hl=en&amp;ct=clnk&amp;gl=fr
the original "classic" parenscript was like that. It was really just an s-expression javascript with CL words (defun, defvar, let) but not really compatible with CL. But then it went through an iteration where `let` worked like you expected in CL, Defun could return multiple values, etc. The advantage of parenscript is the ability to work within emacs, use macros to cut down on js verbosity, and you can generate js code in real time.
I've tried it and while it's nice, my only problem is that JS object creation (in Parenscript) involves more ceremony than just using straight JSON notation (in javascript)
&gt; and CL is a lisp-2 (two namesaces). Actually CL is lisp-n, because it has separate namespaces for many stuff: classes, keywords, functions, symbols, etc etc. &gt;The really quick summary is that having a separate function namespace makes it a bit easier to write macros It also makes easier to name things like function arguments, and this gives me happiness.
Good points!
&gt; Technically, I was working with pop psychologist, Dr. Jordan B Peterson, ..... while using this software to help drive my personal performance. You might get outperformed by some guy talking about trashcans and ideology. I mean, that debate went pretty terribly for Peterson.
Not if the substitute name isn't as good as the one you would have used, had the language not clobbered it. Granted, there's no reason you couldn't call your variable "list" if you don't need to call the function in that scope. But naming variables like system functions in a Lisp-1 is even trickier than doing it in a Lisp-2, because in a Lisp-2 you're not going to look at that variable and think it's a system function being passed to a higher-order function, while that's a reasonable reading in a Lisp-1.
I wish it was called something better... talking about "hygienic macros" makes everybody think about macros, without considering that a single namespace could well be called unhygienic. It's like how the Unix philosophy is a bunch of generally applicable advice, phrased in such a way as to normalize the Unix way of isolating programs from interoperating.
Didn't watch it.
[tl/dr](https://i.imgur.com/Dql27Lu.png)
Hi Baggers - Thursday, according to the text or Wednesday, according to the title - I guess you mean Wednesday based on previous streams?
You are supposed to not want to do that. More seriously, Common Lisp uses a dynamic, open-world approach to object-oriented programming. If you add multiple inheritance to that, your question is even harder to answer. Should the compile error be thrown right after the defclass form that introduces the subclass? what if you remove a class? someone's compile-time is another one's runtime, how do you know when the checks should happen? With MOP introspection, you can check at some point ahead of time if all your classes/methods satisfy your requierments, and this could be packaged in a way that works at compile-time. However, your underlying problem might be better served with a custom and more static macro. Or just embrace the dynamic nature of it all. What is your use-case?
fixed, thank you. At least I got the title right this time :/
My pleasure! Sadly I won't be able to join this evening, but I will catch up on YouTube.
The protocol part of https://github.com/phoe/protest has a thing that I've written exactly for that. You write a protocol that contains a protocol class that must be subclassed, and a protocol generic function that mentions the protocol class in its argument list. For each subclass that you create of the protocol class, the function `PROTEST/PROTOCOL:VALIDATE-PROTOCOL` will warn you if the generic function does not have any method specializing on that subclass. But then - this is an optional module made solely for checking completeness. See /u/anaerobic_lifeform comment for the rationale.
That makes sense. I don't have a specific use case. I was just thinking about if that could be achieved.
Update: I've rewritten the README to try and put the main points up front, [http://treenotation.org/](http://treenotation.org/), and moved the simpler examples down the page. If you had a minute to take a look, I'd love to get your feedback!
Disclaimer: I don't like being negative. If this is a project that you enjoy, by all means invest your time and effort in it! That being said, I don't think there's much to it that is original, new, or valuable. You've re-invented s-expressions, which would be ok **if you didn't insist on making bombastic, self-aggrandizing claims**. &gt;Tree Notation code is noiseless, clean data, which I posit will enable at least a 10x improvement in the performance of programs that write code and/or assist users in writing code. This is an unclear claim. What do you mean by "10x improvement in performance"? That tree notation can be parsed 10x faster than, say, C? This is a big claim, and even if it is true (which I doubt), can it be parsed 10x faster than S-expressions? The answer is no, but even if it were true, the overhead of programs that write code is rarely in the parsing process. &gt;Tree Notation offers a number of breakthroughs that will solve that 80% dilemma once and for all. What are these breakthroughs exactly, other than your own aesthetic preference? There's nothing particularly innovative about representing data by trees. Lisp has been doing it for ages. &gt;Visual programming. Tree Notation is the first notation where a visual design tool can generate code as good as someone can write by hand. The languages listed above have a critical flaw–there are infinite ways to represent any given structure. I strongly disagree that "many ways to write the same program" is a "critical flaw". On the contrary, I consider it to be a feature. The flexibility lets me, the programmer, choose. As I said in my previous post, (I can split \[an expression\] into multiple lines if every term gets too long, compress it down to one if they're simpler, etc.). As an example: consider the following common lisp program that computes the average of a list: (defun average (list) (/ (apply #'+ list) (length list))) Simple, easy. Two lines. Now here's the best implementation that I can give in tree notation: defun average arguments list / apply #'+ list length list (I had to introduce a new keyword `arguments` since I don't know how to represent the difference between `list` and `(list)` in tree notation - this is *not* a good sign). It's more than twice as long, and *its meaning depends on the amount of spaces*. This means that if I'm in the middle of some heavily indented tree notation code: doSomething x y z doSomethingElse p q To know the scope of `doSomethingElse` now I have to count *spaces*. It's like having to count parentheses, *except worse, because spaces don't actually show up*. There's also the fact that visual programming has never really taken off, and the reason for that isn't because we didn't have a good text format to represent visual programs, but the opposite: it turns out that text is a really, really good way to represent programs, much better than graphical blocks. The commercial failure of every single visual programming language (with rare exceptions like SimuLink and Pure Data, which are very domain-specific) should attest to that. Finally, my last gripe with this project is this paragraph: &gt; It is largely accurate to say Tree Notation is S-Expressions without parenthesis. But this makes them almost completely different! Tree Notation gives you fewer chances to make errors, easier program concatenation and ad hoc parser writing, easier program synthesis, easier visual programming, easier code analysis, and more. Literally none of these claims is true. - Fewer chances to make errors Not true: you're just replacing counting parentheses with counting whitespace. I think I'd much rather count parentheses - at least I can see them. - Easier program concatenation Program concatenation in lisp is literally just string concatenation. If you care about readability, you can add a newline. Things get even worse if you want to copy a code chunk and paste it inside a different context. Example in tree notation: someCodeChunk operation1 operation2 ... aFunction ... while true &lt;= insert someCodeChunk here ... To do the insertion, I need to count the layers of indentation at the point of insertion (counting whitespace again?!), copy the chunk of code and insert it at the right place. Compare the s-expression equivalent: (someCodeChunk operation1 operation2) ... (aFunction ... (while true &lt;= insert someCodeChunk here )) All I have to do is copy and paste the code chunk in the right line. Then, I tell my editor to reindent it: thanks to the parentheses, my editor knows exactly how deeply it should be indented, and formats my code for me! So it seems to me like "program concatenation" is easier in Lisp! - ad hoc parser writing You don't have to write ad hoc parsers for lisp, 99% of programming languages already have a s-expression parser written for them. Even if you did, can you explain to me in concrete terms how parsing tree notation is any easier than parsing s-expressions? I can write a moderately efficient s-expression parser in about 20 lines. With a parser generator, I can probably do it in 5. - easier program synthesis Program synthesis is done at the AST level, so text formats are irrelevant. If you're doing program synthesis by manipulating text then the specific format you use is the last of your problems. - easier visual programming The point of visual programming is precisely avoiding the textual representation, so I'm not entirely clear on what difference tree notation makes. - easier code analysis Again, code analysis is done on ASTs directly, so after you've parsed the code the point is moot. Gosh, I hate being such a Negative Nancy, but honestly claims this big deserve some strict scrutiny.
I love stuff like this. Reminds me of why I started programming. Solving bullshit daily problems.
Thank you so much for the comment! Don't worry about being negative. I'm just trying to get to the truth and make this thing better, so I don't want you to waste time worrying about niceties (the most negative comments are the ones that just ignore it :)). \&gt; **if you didn't insist on making bombastic, self-aggrandizing claims**. I do struggle with this. When Elon Musk says he's gonna go to Mars, what would you say about those claims? I'm not trying to compare myself to Musk, but I am making a parallel that I do think this is an opportunity to make an order of magnitude leap in programming and data science, which is generally the thing that he does in all the areas he goes in. If I didn't think there was a very high likelihood that we could do that, I wouldn't be investing so much time and effort into that. How do I state that without it being "bombastic"? I'm not saying this will be an incremental improvement. I don't believe it will be. I believe it will be a major improvement. If I thought it would be an incremental improvement then it would be crazy to invest so much into it. &amp;#x200B; \&gt; "10x improvement in performance"? I mean a non-incremental jump in the performance of the program synthesis models in programming synthesis benchmarks. Not in computing performance, but in the scores achieved by the models at accurately predicting and writing the code to solve a given problem in programing synthesis competitions. &amp;#x200B; \&gt; What are these breakthroughs exactly, other than your own aesthetic preference? &amp;#x200B; Easy mutations from one format to the next, strongly typed collaborative type hierarchies, other things coming. More to come once "TreeBase" goes live. &amp;#x200B; \&gt; that computes the average of a list: It might be easier to see by creating a Tree Language with an average method: [http://treenotation.org/sandbox/build/#standard%20numbers](http://treenotation.org/sandbox/build/#standard%20numbers) &amp;#x200B; \&gt; To know the scope of doSomethingElse, now I have to count *spaces*. &amp;#x200B; But you don't. The tools take care of that for you: [http://treenotation.org/sandbox/build/](http://treenotation.org/sandbox/build/) &amp;#x200B; \&gt; Fewer chances to make errors &amp;#x200B; This is 100% true. You don't have closing delimiters in Tree Notation, so it's true with that alone. &amp;#x200B; \&gt; Program concatenation in lisp is literally just string concatenation. &amp;#x200B; Often, but not always. What if you want to concatenate to S-expressions into 1 parent tree? &amp;#x200B; \&gt; copy the chunk of code and insert it at the right place. &amp;#x200B; The editor does this for you. &amp;#x200B; \&gt; Even if you did, can you explain to me in concrete terms how parsing tree notation is any easier than parsing s-expressions? &amp;#x200B; If I have a Tree Language with a root "teammate" node, and I want to change that term to "person", I can just do it with an ad-hoc parsing regex: /\^teammate/person/. This would be type safe. I cannot do that with Lisp. &amp;#x200B; \&gt; Program synthesis is done at the AST level, so text formats are irrelevant. In TreeNotation the AST == the text. &amp;#x200B; \&gt; The point of visual programming is precisely avoiding the textual representation, &amp;#x200B; You can try the Ohayo demo (or wait til version 15, when it should be significantly better). &amp;#x200B; \&gt; easier code analysis &amp;#x200B; Tree Notation programs turn into neat TSVs or CSVs with 1 method call. See some of the code in Jtree for examples. &amp;#x200B; &amp;#x200B; Thank you so much for the questions!
Holy shit
&gt;in the scores achieved by the models at accurately predicting and writing the code to solve a given problem in programing synthesis competitions You keep dancing around my points. How does a different *textual* representation help at all with program synthesis? &gt; Easy mutations from one format to the next What is this necessary for? Program analysis and synthesis tools spend most of their time manipulating abstract ASTs in memory, not text. The textual representation makes zero difference except when you finally print it to text. &gt; strongly typed collaborative type hierarchies What does this even mean? &gt; It might be easier to see by creating a Tree Language with an average method You're missing the point entirely. Let's say I make a lisp dialect that uses Tree Notation instead of parentheses. In that dialect, writing an `average` function will take more than twice as many lines as the s-expression version. &gt; But you don't. The tools take care of that for you: http://treenotation.org/sandbox/build/ What I'm asking is something like highlighting the scope of a node when the cursor is over it, which this tool doesn't do - I'm sorry if this comes across as rude but I'm going to have to ask you to make a better effort of understanding exactly what my criticisms are before just throwing a link at me. &gt; You don't have closing delimiters in Tree Notation, so it's true with that alone. Let's say I'm writing some code in Tree Notation myFunction name arguments x y z ... while someCondition ... if ... ... set i + i 10 # MY CURSOR IS HERE # I WANT TO WRITE HERE Now I want the next line I write to still be part of the `while` loop. When I hit return, the cursor will probably be at the same level of indentation as `+ i 10`, so I need to manually erase spaces until I'm at the right indentation. *Your tool will never be able to do this for me, because your tool doesn't know what indentation level I intend to move to*. So yes, I do have to count spaces, and counting spaces is just as error-prone as counting parentheses (more, in my opinion, since parentheses are more visually distinct). &gt; What if you want to concatenate to S-expressions into 1 parent tree? Simple. (my-parent-s-expression) (s-expression-1) (s-expression-2) (my-parent-s-expression (s-expression-1) (s-expression-2)) It is slightly inconvenient that I have to move around the closing parentheses of `my-parent-s-expression`, but this only ever happens if I want to insert a s-expression at the end of a block. Of course *this only matters when editing text manually*. If I'm manipulating Lisp code with a program (for example, for program synthesis), it's just `(append parent-s-expression (list s-expression-1 s-expression-2))` of course, which just reiterates my point: textual format has zero impact for program synthesis tools. &gt; The editor does this for you. It doesn't. I don't think you've understood my point: you still need to count indentation layers and make sure your block has the right indentation level. Your tool certainly doesn't do this. &gt; If I have a Tree Language with a root "teammate" node, and I want to change that term to "person", I can just do it with an ad-hoc parsing regex: /^teammate/person/. This would be type safe. I cannot do that with Lisp. I think the problem here is that when you speak about Tree Languages, you're actually speaking about two different things (correct me if I'm wrong). First, there's the broad idea of a language that uses indentation to convey scoping. This is what (you claim) is more or less equivalent to S-expressions. Then, there's a concrete set of schema definition and analysis tools that let you specify concrete subsets of that, which would be your IDE tool - this is basically a more readable XML (incidentally, I think you will be a LOT more successful if you market your Tree Languages as "readable XML", perhaps make a translator to and from it). The point you're making about "teammate" nodes threw me off because it conflates these two. What you're saying is, Lisp is a *concrete* language with a *concrete, fixed* parser, whereas your tool allows you to define *new* tree languages. This is true, and a good point. *However*, there's nothing about it that is particularly related to the indentation idea, and one can easily make a similar tool for S-expressions. Incidentally, I've been playing with your tool and I'm slightly confused. I thought this was supposed to be a uniform syntax that mapped more or less 1-to-1 to s-expressions (as you yourself have claimed). But it seems like it distinguishes between nodes and cells (I imagine cells are the leaves of the tree). &gt; In TreeNotation the AST == the text. If I take this literally, it's just not true. An AST is a set of hierarchical data structures in memory. Text is a linear sequence of characters. You still need to parse tree notation into an actual tree. On the other hand, if what you mean is "in tree notation, the text looks exactly like the AST", this is true, but that's also true of S-expressions. And for many people this is a disadvantage: they expect the text to look *nicer* than the AST. &gt; You can try the Ohayo demo (or wait til version 15, when it should be significantly better). This isn't what people usually mean by "visual programming" - here's the [wikipedia page](https://en.wikipedia.org/wiki/Visual_programming_language) for reference. This is usually called interactive computing, and there have already been some extremely successful projects in this space. What distinguishes Ohayo from IPython? And why is tree notation special? You could have used any other language for it. &gt; Tree Notation programs turn into neat TSVs or CSVs with 1 method call. No code analysis tool that I'm aware of works on TSV or CSV files. I'm not sure what your idea of "code analysis" is, but I don't see the relation to CSV at all. Furthermore, there's nothing about tree notation that makes it intrinsically easier to turn into CSV. And [the example that I've been able to find](http://treenotation.org/sandbox/) does not in fact allow me to turn tree notation into CSVs, only one specific example. How do you turn a general tree notation expression into a CSV? Finally, a general comment: it seems to me that you've developed a series of fun tools to work with a specific data format. I think you'll be far more successful if you advertise these *tools* instead of the format itself, which is nothing special. I have to say I'm not really thrilled with your responses so far - I'm investing a lot of time into providing the most detailed criticism and comments that I'm able to offer, but you often seem to miss my point or talk around the issues.
Doesn't meet the time frame but: &amp;#x200B; [https://www.amazon.co.uk/Art-Lisp-Programming-Robin-Jones/dp/3540195688?SubscriptionId=AKIAILSHYYTFIVPWUY6Q&amp;tag=duckduckgo-ffab-uk-21&amp;linkCode=xm2&amp;camp=2025&amp;creative=165953&amp;creativeASIN=3540195688](https://www.amazon.co.uk/Art-Lisp-Programming-Robin-Jones/dp/3540195688?SubscriptionId=AKIAILSHYYTFIVPWUY6Q&amp;tag=duckduckgo-ffab-uk-21&amp;linkCode=xm2&amp;camp=2025&amp;creative=165953&amp;creativeASIN=3540195688) &amp;#x200B; Or perhaps: &amp;#x200B; [https://www.flickr.com/photos/nathanchantrell/5540390072](https://www.flickr.com/photos/nathanchantrell/5540390072)
That seems rather difficult due to the open nature of CLOS classes. At what point would you detect the absence of a method when one might very well be defined later on?
&gt; Elon Musk can make those claims without being laughed at But a lot of people laugh at him, and lots have even bet billions against him, despite his track record of executing on game changing technologies. I think it just comes with the territory. If you say you are going to do something 10x better, then a lot of people are going to doubt you and call that grandiose, until you do it. It's actually very helpful though, as the doubters often point you quickly to the potential problem spots where you need to invest. &gt; presenting zero evidence for your claims There's quite a lot of evidence now. 2 years ago I presented very little. Now we have over a dozen tree languages, a grammar language that gives you instant cell checking, syntax highlighting, autocomplete, and more; we have the world's largest database of programming languages and programming language patterns (over 10k languages and over 1k columns)--though only a tiny bit of that has been published, I'll admit; but still way up from the 500 languages it had 2 years ago; the Ohayo demo is finally getting interesting; and perhaps most important evidence which has increased my confidence is that no proof by contradiction or flaw has been found in the original paper published over 2 years ago after thousands of unique readers. I'll grant you that you still cannot see the benefits of this without using your imagination and thinking a year in the future, of what it will look like once there are 10 people working on it full time and 1000 part time (versus the 1 full timer now and ~10 part timers). But it's a lot further than it was 2 years ago. If people think Tree Notation is hard to use now, they should have tried it 2 years ago! So saying zero evidence is far off the mark. It would be like saying SpaceX has zero evidence they are going to reach Mars. &gt; How does a different textual representation help at all with program synthesis? Do you have experience training programming synthesis models using deep learning? Very few people have. You need to have a deep learning background and a programming language background, and then you need to have the time to do it. I don't want to make an assumption, but it sounds to me like that's a domain you haven't tried yet (almost no one has), because in reality you are training your models using text and they are outputting text, even if the text represents something else. &gt; Easy mutations from one format to the next This is for data science. Your data constantly needs to go between forms like FASTQ to Apache Arrow to JSON to XML to NUMPY etc. TreeBase and Tree Notation make this much easier to do in a less error prone way. But this is another area where you have to envision it, as I haven't published the best stuff on this yet. &gt; strongly typed collaborative type hierarchies Again this will be easier to envision once TreeBase is live. But you can now look at how easy it is to combine TreeLanguage Grammars (Hakon + Stump + Fire == CSS + HTML + Javascript all in one language!). The idea is "world wide tree". This is at the idea stage--how'd you do the equivalent of DNS is a community organizing problem I'm not an expert in. You can think of it as Semantic Web, except done well. I pitched it for years to Tim and the W3 but they ignored it so far. I hope they start to explore it, as we've got a lot on our plate already, but if not we'll build it ourselves. &gt; You're missing the point entirely. Let's say I make a lisp dialect that uses Tree Notation instead of parentheses. In that dialect, writing an average function will take more than twice as many lines as the s-expression version. My point is you can define a new higher level language where in writing an average function takes fewer lines than even the S-Expression version. There is the base Tree Notation and then there are Tree Languages. &gt; What I'm asking is something like highlighting the scope of a node when the cursor is over it, which this tool doesn't do I get it. We've got about 30 improvements we would like to make to the editor, and are getting there. But everything you've stated is either done or easy to implement with tests, we just haven't got to it yet. &gt; So yes, I do have to count spaces, You will not have to count spaces. There are lots of ways the editor can help you do what you want to do, and those will be implemented. There is no reason that it will take more keystrokes than the same problem in Lisp, and in fact we'll do it better. &gt; but this only ever happens if I want to insert a s-expression at the end of a block. Which happens quite a lot. Think log appending. &gt; I think the problem here is that when you speak about Tree Languages, you're actually speaking about two different things (correct me if I'm wrong). Yes, and perhaps this is a point of confusion. There's Tree Notation, which just gives you nodes, hierarchies (parent/children/scopes/recursion/etc), and words. But most of the action happens at the DSL level. Like Racket or Rebol or Red-Lang. &gt; incidentally, I think you will be a LOT more successful if you market your Tree Languages as "readable XML", I think it will be, eventually. But marketing it to the XML folks doesn't get the kind of very intelligent feedback like this that we need to more rapidly improve things. :) &gt; one can easily make a similar tool for S-expressions. How would you do it though? Tree Notation allows you to do "some" (not all) parsing and editing operations in a type safe way using simple regex. It seems like you cannot do that with S-Expressions. &gt; But it seems like it distinguishes between nodes and cells (I imagine cells are the leaves of the tree). The Cells/Words concept (space delimited words in a line) is included in the library, but the base Tree Notation really only defines TreeNodes to have a line string and child TreeNodes. In practice the cells/words concept has been critical, but I'm not 100% convinced that it's currently done correctly as is. The cells are not the leaves. They are just properties on nodes. &gt; If I take this literally, it's just not true. We defined a Tree in geometric terms. And the AST and Text in Tree Notation is the same geometric shape. This is not the case with Lisp, unless you "prettify" it, but at that point you just arrive at Tree Notation. I have a proof somewhere online. &gt; This isn't what people usually mean by "visual programming" This is the best list I've seen to date of Visual Programming implementations: https://github.com/ivanreese/visual-programming-codex. Ohayo has a few flavors of visual programming, some of which implement the common patterns. &gt; What distinguishes Ohayo from IPython? And why is tree notation special? You could have used any other language for it. The visual program is the same one you'd write by hand. We could have used another language for it, but it would have been too hard and expensive (probably 100x). &gt; No code analysis tool that I'm aware of works on TSV or CSV files. This is a good point. I've been surprised that data science hasn't been more embraced in the programming world. However, a lot of ad hoc analysis was done at Microsoft using Excel, with code painfully converted into tables first. &gt; How do you turn a general tree notation expression into a CSV? Try the `app.grammarProgram.getParseTable()` method in the Grammar Builder. &gt; I think you'll be far more successful if you advertise these tools instead of the format itself, which is nothing special. The problem is it's been hard work to get everything working to the point where we can confidently recommend it to our friends. Until we hit that, getting feedback from the Lisp community has been invaluable. Thanks for the comments and time! I really appreciate it.
I'm going to be very straightforward: I keep asking concrete questions and you keep dismissing them, avoiding them, or talking around them. It's clear that you're convinced that what you've come up with is the best thing ever and nothing I can say will change your mind. Good for you, but I refuse to keep wasting my time with this.
I appreciate the time you have given! Your perspective as a sophisticated user with fresh eyes helped me clean up the readme. I think it’s fine for you to not put more time in this. I was responding to all your points, even though there was nothing new about your arguments(great points—but have all been made before in the past 2 years by numerous of the over 1k folks who have provided feedback), as a thank you to you to try and do you a favor and convince you that this will be big, and you might find t rewarding to use the ideas here in your own endeavors. Just like I convinced a lot of people to get into Bitcoin when it was $6, and many more other correct predictions of black swans I’ve made years before they took off. I’m sorry to burst your bubble but while you may be on of the most knowledgeable person in this subreddit now about Tree Notation, I would not put you in the top 100 people in the world most knowledgeable about it. At this point, myself and our lab are trying to accelerate it, but enough people (some famous names) are working on their own versions or applications of this now—-just that I know about and am assisting with l—that I’m afraid to say your opinion doesn’t matter, my opinion doesn’t matter, the cat is out of the bag, the die has been cast, all that matters is the theory is correct and the code works. The rest can only be accelerated, not stopped.
Parenscript isn't so much a good way to write JavaScript as it is a good way to write programs that write JavaScript.
2 things. 1) I added a few FAQ based upon some of your questions: https://github.com/breck7/jtree/commit/bebaea79c54fdeeae52bd329dc749d3c92b0321c 2) one can actually prove that tree notation cannot be parsed by a context-free grammar, so in an extremely precise, technical, well-understood sense, it's actually literally harder to parse than S-expressions. Now THIS is the most interesting comment you've made yet. Care to elaborate?
At any point one would want - either explicit (by calling a check) or implicit (by the object system itself). For example in Flavors (an influence on CLOS) one could define a list of :required-methods which must be available when an instance is created.
The most sensible idea that I could come up with in the past was to simply make it a part of your automatic tests. If the definition of a class could be annotated with method definitions required from subclasses, it turns into a simple matter of enumerating classes and checking this condition for every one of them. That way you're still testing it without executing any code but at the same time, you're not forcing any major modifications to the object system itself.
http://blog.rongarret.info/2015/05/why-lisp.html
https://www.reddit.com/r/lisp/comments/c2xef1/why_should_i_learn_lisp_in_2019_or_future/
[https://www.google.ca/search?q=why+lisp](https://www.google.ca/search?q=why+lisp)
So, with almost every language I reach this point which I call abstraction failure. The idea I want to express is not expressable with what the language has given me, so the code balloons into boilerplate and such. LISPy ideas get around this. Scala is pretty good, even without its sorta-annoying macro system. C++ + template fun is pretty good too.
&gt; In the spirit of those videos, my question is why specifically did you choose a lisp like language as your main language? Because the language doesn't have any limitation that gets on the way of what i'm doing, thus, i don't lose valuable time in workarounds. This also means a productivity increase. &gt; What specifically is unique about lisp that made it suitable for your line of work? Be able to correct the program as it runs. &gt; “Why Lisp” what would you say? - fearless interactive programming - zero-cost lisp implementations - efficient C bindings - metaprogramming-based generics - clear semantics
Wrong sub
&gt;why specifically did you choose a lisp like language as your main language? I didn't. I always pick the most suitable language for a specific job, constrained by whatever languages my coworkers know and what kind of libraries are available.
The reader.
hush hush don't disclose the esoteric meaning of the bullet ponts
&gt;The idea I want to express is not expressable with what the language has given me, so the code balloons into boilerplate and such. Upvoting. I have been in this situation many times.
I've been coding as a hobbyist for about 2 years, but I've never used Lisp. Is it possible for you to provide an example of what you are describing in this post? What are things that are easier to Express in Lisp than say Java (because I'm familiar with Java)?
Otherwise known as 'Greenspunning'
For me, it's the Pareto optimum of all languages I've seen so far: There's no way to overall stuff from switching to another language without losing in one or more aspects.
One simple example would be to implement a nice functional programming API. Even getting the basic objects going is full of boilerplate.
The only good thing about programming languages is transcending them.
Functions are first class citizens, so you can pass a function as an argument. Java would use Strategy pattern to achieve the same thing, which is more complicated. In CL we use multimethods so we're good. In Java you need visitor for multimethods. In Java you don't have LINQ. In C#, the compiler guys implemented LINQ. In CL, you can implement LINQ yourself if you like it using reader macros.
In fairness to Java, [lambda expressions](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html) were introduced in Java 8. They are not quite as flexible as Lisp functions, but you can pass them as arguments.
That's true, but it also shows that you need to wait for the language to add such features. In common lisp, oftentimes you can add it yourself. (and adding things is easier and the end result is often neater)
Lisp (specifically Common Lisp with reader macros) is a meta-language, so it can become literally any language you want it to just by defining macros. Literally any computer language can be implemented in lisp with macros. Like python? This can become valid Lisp code with the proper macros (python-mode def foo(): return 1 + 1 print(foo()) ) What about C++? The following can become valid Lisp with proper macros (c++-mode void count_to_100(){ for(int i=0; i&lt;100; i++){ printf("%d bottles of beer on the wall", i); } } ) &amp;#x200B; After understanding how powerful this is, literally every language that isn't Lisp feels incomplete.
Lisp is great for when you're trying to write some code and you don't really understand what you want yet, or how to implement it even if you did. You start by building the functions that you know you'll need, passing them to the REPL and testing them, then slowly begin stitching them together and experimenting. Being able to recompile live code is a godsend.
But other languages have macros too now, so this is no longer a unique advantage.
S-expressions are pretty. I am a simple man.
Most languages have a subset of the macros available in lisp though. They’ll get there in the end.
And nothing makes me happier. I just wish my work language C# had them. For now I do compile time and runtime code generation, and it sorta works.
Are there other equivalent Common Lisp compiled to JS besides Parenscript? Is Parenscript the best of the bunch? Thanks guysfor all the answers.
Yes, very good point. Ultimately I think that's the best "Why Lisp?" answer: there's effectively nothing that you can't make the language do (with a reasonable amount of effort).
It's literally the fourth word in your sentence.
There are macro systems, and then there are macro systems.
In between the beautiful and simple Binary Notation and the many variants of Brainfuck that we all use at our day to day jobs, lies the beautiful and simple Tree Notation. That is too beautiful for some people, so throw some parentheses on it, and you get Lisp, which is still pretty awesome.
Imagine you're programming and you keep seeing a pattern: Resource r = null; try { r = getResource(); r.doStuff(); ... } catch (Exception e) { ... ... } finally { if (null != r) { r.release(); } } You get a resource, and try to clean it up, even on failures. You write this *over and over* again, with huge, nested blocks of complicated failure and cleanup handling. Wouldn't it be nice if you could abstract this somehow? A method call, maybe...? Or something like: try (Resource r = getResource()) { r.doStuff() } // or even try (Resource r = getResource(); Resource2 r2 = getResource2()) { r.doStuff(); r2.doStuffToo(); } What are your options? In a language like Java, you don't have many options. Just buckle down and write the code. You could fork the language, or wait for the next version of Java and hope they add something similar -- in this case, 'try-with-resources' was added in Java 7 -- but your ability to do this from within the language itself is limited. In a lisp, this is solved trivially: you write a macro. Lisps put the power in your hands to totally redefine the syntax and semantics to precisely what you want. What might be compiler magic or hardcoded in another language, is something first class you can manipulate and work with in a lisp. Examples of this: - Type systems as macros: https://www.ccs.neu.edu/home/stchang/pubs/ckg-popl2017.pdf - Entire languages on implemented on top of Racket: https://beautifulracket.com/ - Redefine the semantics of the language from strict to lazy: https://docs.racket-lang.org/lazy/ - Redefine the language to use whitespace: https://dwheeler.com/readable/
I'd say the following, where either a point is unique to lisp either the union of them is unique: - the syntax is simple, it doesn't change, you don't have to upgrade your code. Yet, if you want to add syntax (pythonic decorators, string interpolation,…), use a library. Pick the language feature you want. Every other language has an evolving syntax. - the parentheses allow for editing code intelligently by semantic units, with an editor plugin (I use lispy-mode for Emacs). Editing code character by character, word by word or line by line is so boring. - the language is stable. No need to cope with new versions. Yet, new implementations are being developed (Clasp, CL on LLVM), existing implementations are refined, libraries evolve. - it's a compiled language. SBCL gives many type warnings at compile time (function by function), we can build a binary of our program. It's much simpler to deploy (think web app) or ship to users than many languages out there (like Python). - it's efficient, and still being optimized. - the REPL is great. It's more fun, and it's a gain in productivity. I am tired of fixing a typo and re-compiling my program, or re-running the whole interpreter. In CL, we just compile *one function* (it's instantaneous), and we try it right away in the repl. - we can connect to a remote running image. It's so cool :] (and allows for hot code reload for runnning apps) - CL has libraries for many domains, including web and GUIs. - I am excited by Ultralisp, Weblocks, the IUP bindings (GUI library), numcl, Coalton (a ML type system on top of CL), the Next browser,…
I don't like it when people ask what's so good about lisp and the majority of the answers are just macros. There's so much more to lisp and even s-expr than just macros and it gives beginners the idea that you should be using macros a lot cause it's what makes lisp good when they should be used sparingly
They make you manipulate an AST, when Lisp macros just look like code.
Pragmatically this hasnt been an issue. Though, C#'s Roslyn manipulation code is pretty wordy when they could really simplify it. Luckily theres some solid string interpoloation. var statement = SF.ParseStatement( $"var {f.Key.Identifier}New = {f.Key.Identifier}Opt.Or({varPrefix}{f.Key.Identifier});" );
Racket is pretty cool. I def want to implement something big in it. Though, the siren call of Idris 2 is getting louder.
In addition to the macros, there's a wider design philosophy in Lisp that I find appealing. It's an open design philosophy where if the implementation needs to provide a feature X, it provides a more general feature Y for implementing X (and then, internally, most likely uses Y to implement X.) Examples of this in Common Lisp include macros (for syntax extension), setf expansion, user defined method combination, and the reader. One of the more fruitful (in my opinion) ways to expand Common Lisp is to provide more such general implementation features. For example, provide ways for users to specify and control propagation of type information, as is done internally in SBCL.
Sorry for redirecting to another site. [https://stackoverflow.com/questions/44596132/use-package-shadowing-symbols](https://stackoverflow.com/questions/44596132/use-package-shadowing-symbols) This has related answers.
Just because you use a package doesn't mean you "use" a package. When a package is in the "use" area of a defpackage, it's symbols become a part of the global namespace. In other words, instead of typing "foo:bar" for package "foo", you just type "bar". In modern common lisp, the only package most people "use" is common-lisp. This usually makes code more readable because you can tell what functions and methods come from what packages. Here, "COVER-TOPPER" is a symbol defined by multiple packages. Conflicts like this are common. That's why you don't put that many packages in the "use" area... It pollutes the global namespace.
 (defpackage :cover-topper (:use :cl :drakma :imago :opticl) (:shadowing-import-from :imago :draw-circle :rgb-image :image :do-region-pixels :draw-line :draw-rectangle))
This is wrong. CL has no "global" namespace. Each symbol has a name and a package (though technically you can make a symbol without a package). `Use` just in this case means that `cover-topper::car` is `EQ` to `cl:car`. that is CL-USER&gt; (symbol-package (find-symbol "CAR" "COVER-TOPPER")) #&lt;PACKAGE "COMMON-LISP"&gt;
It's hard for me to put in words right now -- I'm still exploring dependent types -- but I'm finding that I feel Agda and Idris are either just as or even more expressive than lisps. They've been quite mind-bending! They appeal to me for similar reasons that lisps do: their core is *incredibly* simple and all of their power comes from those base principles being so sound; everything can be derived from those. Above where I said: &gt;What might be compiler magic or hardcoded in another language, is something first class you can manipulate and work with applies to Agda and Idris too mostly ♥
Is there any simpler solution in case I don't want to list out every function I may need? Can I not use the foo:bar syntax__random_account__ mentioned?
I think you do not understand. This will import every exported symbol of the package imago. It will import every symbol from opticl except those that are shadowed that is listed above.
As for `foo:bar` this references directly the symbol `bar` in the package `foo` whether or not the current package `use`s the package `foo`.
Yep yep. I come from games, so the big test for me is how complex is the code when Im building game rule sets. Those have a lot of interacting state, and you want to data drive it as much as possible, and just simply provide interesting features in general.
I meant if I could just avoid the issue altogether by explicitly writing out the package name each time like the other guy said. I understand what you mean now, I sort of misspoke in my original reply.
Yes you could remove the packages imago and opticl from the `use` list. Then you would need to explicitly include the package in the symbol in this case `imago:draw-circle` or `opticl:draw-circle`
But how do I know when to use : vs ::
: is for only exported symbols of the package, `imago:draw-circle` is exported. :: is used to access any symbol of the package. you could write `image::draw-circle` but `read-msb-integer` is an internal (not exported) symbol of imago. To access it you must write `imago::read-msb-integer`
Interestingly enough, JavaScript is on the list of languages that approach this point: there are some syntactic annoyances, but arrow functions make it possible to express a lot of abstractions in a macro-like fashion (the CALL-WITH pattern sometimes used in Common Lisp)
Accurate
Macros.
I seem to remember reading that the creator of JS wanted to do a LISPy language. I wish more languages opened up the **.** and **-&gt;** operators and such.
Yeah, according to wikipedia at least, when he was hired at Netscape, he intended to put scheme in the browser (incidentally, another person from the early Netscape days, Jamie Zawinski, worked at Lucid which was a company that produced an implementation of Common Lisp)
Just don't use packages in your package and keep using packagename:exportedsymbolname to call the functionality.
macros don't support changing token syntax in useful ways. That would need to be done in a different way. A macro sees data which has been read by the Lisp reader. That means the current state of the readtable functionality determines which kind of s-expression and token syntax is valid: numbers, symbols, strings, etc.
With all due respect, [you are wrong](https://github.com/y2q-actionman/with-c-syntax). &amp;#x200B; (ql:quickload "with-c-syntax") (with-c-syntax:use-reader) #{ int i, sum = 0; for (i = 0; i &lt;= 100; i ++) sum += i; return sum; }#
It was a radically different family of languages that what I was used to (all of my previous experience was with Fortran and the various descendants of Algol), I hate dealing with operator precedence rules, I like how pretty much everything in lisp returns a value, and S-expressions looked pretty interesting to work with. I originally chose scheme because I wanted to learn and it was small, so it didn't have to be particularly suitable for some problem or another though I did work on a few. Eventually, I got into Common Lisp and have more or less switched to it for doing hobby projects. I wanted something that had more things in its standard and a better portable library situation. Though I still miss some things about scheme and would like to return some day.
You're probably right about how it gives beginners wrong ideas. That's unfortunate. But it's still true! If you took away my pattern matching macro, I'd jump ship to OCaml in a heartbeat. (Sorry, `destructuring-bind` is no substitute. Not even close.)
&gt; lies the beautiful and simple Tree Notation Which has nothing to do with the question that the OP asked or Lisp in general. Please stop trying to (not so covertly) push your toy language, which is just another nth attempt to re-implemented S-expression with worse syntax, on /r/lisp.
Generally, you can write almost anything in any language you choose. It is possible to write everything in python, if you want. I chose Lisp, because not only I can write anything, I can write it in any way I want. I want object oriented? There is any kind of object oriented I can imagine. I want functional? It has everything I need! I want procedural? Ofc I can! I miss some specific construction? Lemme just implement it in 3 lines of macro. So tldr is Whatever solution for your problem comes to your mind, you can write it. There is no Lisp way, there is your way.
At this point, I'm trapped in Lisp man. It's no longer giving me that strong mojo (well, maybe slowly) but I can't program in anything else. No other language has that taste of interactiveness, flow, terseness, finger-lightness, liveness and not forgetting history, only mock-ups that are not even comparable, so what can I do? To be fair, this is not all Common Lisp, Emacs (surprise surprise, also a Lisp) is a critical part of the experience.
My favourite example is "return-if" - so many times I've wanted to say "if x has a value, return it, otherwise carry on". Which, sure, can be done with "if (x) { return x; }" or "return x if x" in any standard language. But I want to be able to just write "return-if x", and that's something I just can't do in a language that doesn't allow me to add new syntax.
How do you log in to Reddit?
The spell of the bullet poins is not to be invoked lightly.
`::` is for debugging. run it in the repl, but never ever write a `::` in a file that gets saved to your hard drive. only use `:` in code.
while we're nitpicking, i think it's actually correct and more descriptive in this context to say "the global namespace" instead of "the package denoted by `*PACKAGE*`". not everyone on reddit understands how packages work, but `*PACKAGE*` *does* actually act as a global namespace for the lisp reader.
I dislike syntax. I was searching for a language I could grok to write the language I had always envisioned myself coding in. I stumbled on lisp and realized someone already wrote it for me... with a few hundred caveats of special forms...
I first learned lisp from Winston and Horn, and always appreciated the clarify of the writing. Never had a chance to take a course from him at MIT, but I remember that he was very highly regarded as a teacher
there is a big difference between the meaning of "global" and "default"
RIP My first language book that actually taught something besides the syntax and semantics of the language. https://imgur.com/a/yuaylWc
 (life:rest :where peace)
I took Prof. Winston's Artificial Intelligence class in about 1985, and that was a great experience. However, what I really remember fondly is his How to Speak class. He conveyed, in one short lecture, many effective ideas about how to speak in front of groups. He did it both by teaching the material and by modeling the techniques. His lectures always seemed absolutely natural, as if he had just thought them up, but when you listened to his advice, it was clear that he had prepared and prepared and prepared. Just a few years ago, I visited MIT in January and attended that class again. The classroom was packed, just as it had been decades ago, and his delivery was just as engaging. &amp;#x200B; Earlier this year, he gave a fantastic talk about the history of the MIT AI Lab: &amp;#x200B; [https://www.youtube.com/watch?v=vCyZUiBr\_ds&amp;start=1928](https://www.youtube.com/watch?v=vCyZUiBr_ds&amp;start=1928) &amp;#x200B; Thank you, Prof. Winston. RIP.
It is learning to program all over again. If the world had stuck with lisp instead of Algol/FORTRAN we would be in a very different place. I doubt we would have so much buggy software. Viruses wouldn’t be nearly as vicious either. Sigh.....
\&gt; Which has nothing to do with the question that the OP asked or Lisp in general. Au contraire, my answer is perhaps the \*only\* correct answer to the OP's question. He asked, \*why\* lisp? Most of the answers, although definitely positive contributions to the discussion, still don't explain the \*why\*. Almost no one I've seen in the Lisp world understands the \*why\*. With Lisp there is a deeper love than you'll find with other languages, and the OP is wondering, \*why\*? People \*like\* other languages, but they \*love\* lisp. \*Why?\* And the reason why the OP is wondering \*why\*, is because no one in the 60+ years of Lisp's existence has been able to explain it. I can't yet myself, although we are coming dangerously close with Tree Notation. Tree Notation, which Lisp is very close approximation of, is something simple, beautiful, universal, and almost on par with, but still much less important than, binary notation, which is one of the most beautiful ideas in the world. Sure, that's my opinion about binary notation, but I hope as a fellow programmer, and by virtue of the fact that this conversation we are having right now depends on binary notation all the way down, you'd agree with me on the virtue of Binary Notation. \&gt; Please stop trying to (not so covertly) push your toy language I will not. I thank you very much for calling it a toy( "imagine know-it-alls on forums dismissing as toys. To us that's positive evidence an idea is good.")--it is certainly a toy at this point and I encourage you to play with it! \&gt; which is just yet another nth attempt to re-implemented S-expression with worse syntax (significant white space instead of parenthesis), on [/r/lisp](https://www.reddit.com/r/lisp/). Here's the thing. I have notes on over 10,000 computer languages, including at least 364 Lisp implementations, dialects and derivatives. Before the OP should listen to you over me, can I ask how many do you have notes on? I don't mean that as an attack. I have no idea who you are ta\_400000, for all I know your last name is McCarthy, but even if you were the nephew of John himself, I think there's potentially an \*objective\* case that I know more about Lisp than \*you\* or \*anyone in the world\*. Simply because I've put in the time and money over 7 years to collect the data and do the research in the most scientific and objective a way as I can. And here I am, looking at all that data, trying to find flaws in Tree Notation, and cannot. And here I am stating that there's something very interesting here. I've been stating this for 6 years. Back then I had notes on maybe 100 languages. 4 years later I had notes on about 500 languages and started talking a little louder. 2 years later I have notes on over 10,000 languages and here I am, stating roughly the same things. I'm either one of the dumbest, most misguided people in the world (not out of the question, I'll admit), or I am right, and that Tree Notation is a great "toy", and will become far bigger than Lisp ever has. I love lisp. I love the Lisp community. But I also love the world, and so I'm trying to bring the beauty of what the Lisp community has been in love with for decades to the rest of the world. But we need to do a better job of explaining \*why lisp\*. To explain \*why lisp\*, we need to stop talking about Lisp, because Lisp got some things wrong, and we need to look at the refined version, which is Tree Notation, and go from there. We need a lot of help to do that, and especially the help from the /r/lisp community, which has been instrumental in advancing things the last 2 years.
Thanks for proving my point that you're intentionally being off-topic. Again, this is a subreddit about Lisp, and is neither a place to discuss your pet project, nor for you to recruit people to help you push your language.
If you understood Lisp, you would know why this is the exact place to discuss this project.
Why? Because your language took ideas from Lisp? If so, then that means we must allow people to discuss almost all programming languages here, because it is almost impossible to find a programming language that has not been influenced by Lisp. With that said, I don't see [Dylan](https://en.wikipedia.org/wiki/Dylan_(programming_language)) people, for example, posting here, despite the fact that Dylan is a language that is known to be heavily influenced by Lisp. Last I checked, they are fine having their own subreddit. If you want people to take you seriously, then stop violating the rules to advertise your project. Heck, you do realize that you're doing more harm than good to the image of your project and yourself, right? There are millions other places on the Internet that are much better to hawk your better-than-lisp language than this tiny subreddit. You can even make your own subreddit, for crying out loud.
Lmfao, you're delusional, go back to r/IAmVerySmart
Lol, that's a pretty good thread. Sorry just sometimes I get emotional. I'm fine if people don't like Tree Notation, and I'll admit it's still very bad today BUT it was pretty terrible 2 years ago, has improved a lot, and if you squint I think you can start to see that next year it will be pretty solid. And I'd love more help from Lispers, because years ago I too was one of those wondering \*why\* people were so in love with Lisp, and in my thinking and hunt for the why I found something better.
Link to your 10k+ language notes?
Good point. In the process of open sourcing it. I should refrain from mentioning it until I’m ready to share the link. Should be 2 weeks.
Very interesting. Why McCLIM guts, though? Today, I'd go all fancy with something new, like a Vulkan backend with code generation or something.
You could have a look at [JSCL](https://github.com/jscl-project/jscl).
{ Are you done whining yet?
But mommy, why are the kids still using parens??!! But I'm curious, what does your \`{\` mean?
Was that written by a markov chain?
?
Thanks! Because McCLIM provides very good abstraction. I could make a barebones toolkit in 252loc. Nothing prevents writing a vulcan backend (or whatever is trendy now) for McCLIM. I plan to refactor lower abstractions from it into a separate library called dragonstone, that will allow reusing common core for an ecosystem of varying lisp gui paradigms and toolkits. Sharing backends will benefit everyone, even if they don't "buy" CLIM paradigm. Check out article about silica (linked on CLIM wikipedia entry).
That sounds cool. Just as a side note, I wonder, have you seen the VPRI approach to GUIs?
If “nothing prevents” writing a backend then why does nobody do it? The only McCLIM backend that sort of works is the CLX one, which also manages to looks and feel like absolute crap on Windows, macOS and Linux. Let’s face it, McCLIM is a disaster in every way, an example of how not to run a software project. Instead of trying to rectify the issues that really matter, I’ve seen all of you over the years focus on entirely the wrong things. How are these backend-writing-docs that you promised to write years ago coming along btw?
If nobody does it then it means there is no interest from people capable doing so. My platform is Linux, so I don't feel strong incentive to actively work on other platforms. Regarding backend writing docs, they are still planned, nothing has changed. I've said it before (answering your remark written in a very similar manner which is not very nice btw), if you feel you can contribute time and skill to show us how software projects should be run (first as a contributor, maybe later as a project leader if you are not all talk), then do so. Acting as a peanut gallery troll does not make you look good. It is worth noting, that this post is about sharing a cool hack and I've answered, why I didn't whip this hack on top of something else than McCLIM, so your hateful speech was totally uncalled for.
First time I hear about it. Do you have some references I could use? Naive typing VPRI gui in the search engine yields nothing relevant.
If you don't care about portability (the error object type and restart names are unique to SBCL) or good style, you can do this: (ql:quickload :simple-actors) ;; HANDLER-CASE* is also in Quickutil if you can get that to work. (:use-package :simple-actors/better-handler-case) (handler-case* (ql:quickload :your-system) (sb-ext:name-conflict (exn) :before-unwind (invoke-restart 'sb-impl::take-new))) Or without the `handler-case*` macro: (handler-bind ((sb-ext:name-conflict (lambda (exn) (declare (ignorable exn)) (invoke-restart 'sb-impl::take-new)))) (quicklisp-client:quickload :your-system))
Somewhat on-topic: Practical Common Lisp has parts it calls *practical* - which shows simple applications written in Lisp. While it doesn't utilize ASDF or Quicklisp, you could perhaps take a look at those.
"My platform is Linux, so I don't feel strong incentive to actively work on other platforms" - You promised to write backend docs years ago, so that others could be enabled to work on the platforms that interest them. You haven't done that. Time wasted. "if you feel you can contribute time and skill to show us how software projects should be run (first as a contributor, maybe later as a project leader if you are not all talk), then do so." - This is the wrong attitude to have. The onus is on you to attract developers, not on others to start spending their personal time on a project that seems to make one wrong decision after another. Dropping down to personal attacks and calling me names is totally uncalled for. Learn to take criticism and look at yourself objectively.
Someone linked me to http://stevelosh.com/blog/2018/08/a-road-to-common-lisp/ on the Lisp Discord. It's also available from the sidebar.
I've said I plan to work on this. If you feel that a promise to you has been broken I'm sorry to hear that. All I can hear you saying is that project is a "disaster" and that it is a "wasted time". I'm not sure how this kind of unconstructive feedback can be called if not trolling. It is not calling names but observation. If unjust, then I'm sorry for that. Regarding attracting developers: we do that with quite a success, so this point is checked. I take that your criticism is meant to be "objective", but I don't see how could it help me to make things better except maybe encouraging me to drop working on this software. That's why I encourage you to put your hands where your mouth is and show us how things may be improved - maybe it is a communication problem not trolling after all. To avoid further heating up the discussion I won't respond to further message if I'll take it emotionally :).
Turn out compiling originally meant transforming program code in one language to program code in another language
Coding a little text is a great exercise ! Here is a tutorial to do so in C https://viewsourcecode.org/snaptoken/kilo/ While it is not lisp it may be of great help to identify different parts to implement.
I think my point is clear. Documentation is a pre-requisite for new blood to come in and start working on backends. I’ve lost count of how many people I’ve seen on IRC, here or HN ask about how to write a McCLIM backend. So from the point of view of a project manager with decision making power, documentation *that enables new developers* should be top priority. Since this issue has been brought up time and time again, and I don’t see anything happening on that front, I think I’m well justified in my criticism. The failures of McCLIM are primarily failures on the project management, prioritization and decision making front. I gather that having a bunch of people work on things that they like is fun but of course it’s not really a wise way to lead a project, at least if you aim to build a community around it and attract new people. Sometimes people have to grit their teeth and do tasks (like documentation) that are not “fun”, looking at the big picture.
You can take a look at the relevant pages at The Common Lisp Cookbook: [Defining Systems](https://lispcookbook.github.io/cl-cookbook/systems.html). For adding systems to quicklisp, take a look at its [github page](https://github.com/quicklisp/quicklisp-projects). For adding systems locally (when they are not available on quicklisp), you just need to [download them to somewhere asdf can find](https://common-lisp.net/project/asdf/asdf/Configuring-ASDF-to-find-your-systems.html). From the same link, take a look at the (excellent) ASDF manual.
&gt;Documentation is a pre-requisite for new blood to come in and start working on backends. How did OP learn McCLIM well enough to start extending it and hacking on it? Presumably by self initiative, which is perhaps lacking in your case. If your passion for implementing equals your passion for criticism, perhaps you could demonstrate some initiative as well. You've identified a need, with repeat justification, so maybe you should go try to fill it.
Can you point at something inaccurate in my argumentation? Saying “do it yourself” is deflecting and taking the easy way out. I am not part of the McCLIM project and my critique is aimed at those with decision-making power. I’ve basically said what I (and I believe others) would like to see **before** we try to invest time and money. My consulting rate is ~1000$/hour. You have to entice me to contribute my time (which is worth real money) by convincing me that I’m not going to waste it.
First of all you make some assumptions which are wrong (and some which are debatable). - McCLIM is a community project, so there is no "steering commitee" which decides what we are working on; people work on things which they find interesting to their projects and needs, if contributions pass peer review they are accepted disregarding my or someone else plans - Prototype backends has been written without a separate documentation, what takes most time is to make a backend which is not beta quality and be it clx or opengl there will be plenty of bugs with it - Having documentation does not guarantee that "independent developers" will chip in their costly time, and even i they do, it doesn't mean they will create something of good quality - CLX bug-fixing fiesta takes little time. Most changes to McCLIM during this and last year was revolving around core abstractions which are common to all backends $1000/h? wow, you must be really smart then!
To add to what jd said, I'm already looking into writing a new backend. Will it be usable? I have no idea, but I'm not sitting around waiting for documentation before I'm starting. Perhaps my code will be a useful prototype for someone else wanting to build a backend? It's possible, but at least I'm doing more than yelling at others what they are supposed to do with their free time. And yes, I do put my money where my mouth is. I have both contributed money as well as my code to the project.
It's not just fixing the CLX backend though- it's about both fixing the CLX backend *and* fixing the backend API to properly support the features that are needed. The interface between McClim and the backends is still a moving target as the codebase gets fixed up, polished, extended, etc. Documenting that interface would be a time intensive task that would likely obsolete itself quickly, and deciding to stop adjusting that interface may also be a huge mistake. It's still unclear exactly what is needed by that interface. The current strategy to determine that seems to be both cleaning up the codebase and trying to implement larger example programs in it to see where it falls short, which I think is perfectly reasonable.
the project seems to suffer from being a group implementation of a protocol instead of the implementation of one persons coherent vision.
Don't you think McClim is a bit overkill to build a simple toolkit? Though perhaps when I'm finished I'll have something as monstrous.
The tooling around lisp is really good. Smalltalk and Lisp seem to be the only two dynamic language communities that really care about tooling.
Oh, you are working on immediate mode gui for lisp? Can I track progress somewhere? &amp;#x200B; Answering your question: I'm McCLIM maintainer and I plan to separate windowing abstraction from it. This toolkit when made complete will use only these lower abstractions and will illustrate how to create arbitrary toolkit based on them. It will be similar to what has been defined in [Silica](http://extras.springer.com/2000/978-3-540-67660-7/papers/0512/05120251.pdf). In ideal world it will be a shared core abstraction for all kind of toolkits which would share backends and windowing protocols. In other words McCLIM was direct inspiration for the hack presented on this thread.
&gt;My consulting rate sits at ~1000$/hour. You have to entice me to freely contribute my time (which is worth real money) by convincing me that it’s not going to be squandered. Yet here you are, braying for free (unless someone else is paying you to be a reddit ranger). Amazing.
&gt; I'm already looking into writing a new backend. How can this be? :)
I'm still trying to pin down nomenclature in some of my underlying libraries, it's very, um, weird, to say the least. I'm trying to break it down into the simplest parts, surfaces, which is anything that can be drawn to, and views which are reactive/interactive semi-autonomous graphical views upon a piece of data, displayed on surfaces. I have already separated out the basics of surface and the layout organizer on my github, i'm hoping to add the view package soon. I've still got a lot of decoupling to do. They might look like simple packages, but that's the point. Should be something easy to grasp to inspire experimentation. For example, that simple layout program handles justifying text and doing the nine-slice calculations for window decorations. I read through that silica document and it's similar to what I have envisioned, but not entirely. I'm all about reuse. That layout package is what my window manager uses. The 'window-manager' is the same as the app-interface-manager. In similarity to contracts, views can abdicate responsibility, for self-management(the default when just calling (view "image.jpg"), for screen updates, for input. Surfaces can be pixmaps/arrays(i.e. offscreen storage) so that same code to layout x11-windows, can do the layout and rendering of pixmaps, so easy lightweight 'windows' like in their spreadsheet example, an empty sheet uses just 1 pixmap acting as backbuffer for the whole thing. Change the symbol in the autogenerated grid layout to point to say a pngload:png-object, and now you've got an 'embedded' image view, whose ability to respond and act(i.e. resize, move, zoom) may or may not be restricted by the manager. My system does seem to have more responsibilities than just their contracts, or maybe they're subsets. For example, views have the responsibility of choosing an appropriate display size and graphical representation based on the data they've been given and any output-size constraints imposed by the immediate environment.
Shameless plug, but you can take a look at my project, cl-trie: https://github.com/MatthewRock/cl-trie I tried to follow good practices etc. So you have unit tests in a separate asdf system, CI integration, documentation etc. I find it useful to go back to this project when creating a new one.
Without documentation? Yes. It's completely impossible, and I must wait for jd to hand it to me. Jokes aside, the actual reason for me wanting to do it is because there are people who want to see Climaxima useful on Windows. I'm not a Windows user myself, so my plan is to reimplement the SDL backend in an as simple way as possible. That way, even if it fails as a project, it may be helpful for someone else who want to work on backends.
A bit further away from what you asked, but if you weight "editor" more heavily than the Common Lisp bits, what about hacking within Emacs? That's a Lisp, a very close cousin of CL, and potentially give you useable tools you may keep for a long time? To get closer to CL, you could hack on Slime or Sly perhaps?
Imago provides example code that uses internal symbols. Is that just bad design then?
without having seen the code you're talking about, i'd say, probably that is just bad design. i could be wrong, tho, and they might have a good reason
If you are going to implement an Emacs-like editor, the basic of implementing it are described here: &amp;#x200B; [https://www.finseth.com/craft/](https://www.finseth.com/craft/) &amp;#x200B; The Craft of Text Editing or Emacs for the Modern World, by Craig A. Finseth
This seems quite interesting, I will look forward to the weekly posts.
Sounds like yeoman work. Good job taking the initiative.
I find this very puzzling. [Do we have different Googles?](https://i.ibb.co/DQGYKKJ/VPRI-GUI.png) In any case, [their 'writings' page](http://vpri.org/writings.php) has some papers detailing on the [LBox/Lesserphic](http://www.vpri.org/pdf/m2011002_lesserphic.pdf) GUI foundation, the [Gezira](https://github.com/damelang/gezira/tree/master/nl) graphics library, the [Nile](https://github.com/damelang/nile) DSL used for programming Gezira, etc. It's also useful to read their annual reports in sequence to get a broad picture of how all those things fit together.
Apparently so. I'm not using Google products, but I've checked in private mode to compare notes, indeed Google gives you different results than me. https://imgur.com/a/snpMJrw I'll read about it, thank you.
Related discussions: https://www.reddit.com/r/lisp/comments/119v64/google_common_lisp_style_guide/ https://www.reddit.com/r/Common_Lisp/comments/8n0ia7/the_norvigpitman_style_guide_and_read_macros/ https://www.reddit.com/r/lisp/comments/6nf3g4/which_lisp_style_guides_should_be_on_top_in_this/
How do you write the S-expression ((a b) c) in Tree Notation and Binary Notation?
Apparently you should have clicked on the "Zamiast tego wyshukaj **vpri** gui". (Hehe, "vyšukaj"... :D)
&gt;Before starting a project, think about its structure: Does *every* component have to be implemented within the project? This sounds wrong. Shouldn't this be a constant consideration throughout project development? &gt;Indentation is two lines per form I think you meant "spaces", not "lines" here. &gt;Comment Hierarchy This section seems incongruent with… uh… something I read somewhere? Don't remember the source. I learned it like this: 5 semicolons for file-level comments, 4 for sections, 3 for whole toplevel forms, 2 inside forms on their own line, 1 for comments on the same line as a form. &gt;Slot options I don't understand the reasoning here. Why this particular order? I always put `:type` first, since this is the most important information not already covered by the slot name itself. Minor nitpick: `:initform` is not the initial value, it's the form that gets evaluated to compute the initial value. Giving accessors names of the form `[class]-[slot]` seems… weird. I now use `[slot]&lt;-` to differentiate from generic functions that might take multiple arguments. Hmm, now thinking of switching to `[slot]←`… &gt;One Package Per File No, this is not acceptable. I use one package per project (or two, if I've got a logic and a ui part) and I see no reason for using one package per file instead. Seriously, what is the reasoning here? This seems like a whole lot of boilerplate for what gain exactly?
Looking forward to it, but I hope the code snippet contains a typo and not an example of using an operator named by a keyword. Naming aside, a nonstandard meta-operator that takes another operator name like this creates a "my private Lisp" aesthetic that may not be shared by a subset of your target audience. Supposing it to be a variant of the `_f` macro described in On Lisp, I think in this case `(setf foo (max foo ...))` or `(maxf foo ...)` would be better alternatives.
 [How to write a modern Lisp library with ASDF3 and Package Inferred System](http://davazp.net/2014/11/26/modern-library-with-asdf-and-package-inferred-system.html) which is the one package per file and one file per package style. I am not a big fan of the approach. Caveman uses it and assumes you will too when it sets up the project. see also: https://www.reddit.com/r/lisp/comments/8j9ing/how_do_you_go_about_starting_a_common_lisp https://www.reddit.com/r/Common_Lisp/comments/8r9jfc/one_package_per_or_file_project_somethingelse/