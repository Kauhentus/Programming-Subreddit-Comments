Thank you for the pointer, but this was not really what I was asking for. I have also had a semester where we implemented many concepts of PLAI, which was really interesting. Right now I am implementing a paper by using #redex. What I am talking about is the power of Lisp that yielded so many quotes from programmers I regard highly. Building Interpreters is neat, but I don't think this is what caused to much awe.
Perfect! This looks exactly like what I am looking for. Excerpt: "This book is about macros, that is programs that write programs. Macros are what make lisp the greatest programming language in the world. When used properly, macros enable amazing feats of abstraction, programmer productivity, and code efficiency and security that are unheard of elsewhere. Macros let you do things you simply cannot do in other languages."
I second that. Common Lisp is, for me, about metaprogramming as OP outlined since for the functional programming I've just defected to Haskell. And not only _macros_ (Turing complete code transformations) but I also have _reader macros_ (Turing complete source code parsing) in mind. I also like that everything in CL is allowed so I think it fits that macros in CL are unhygienic. For more concrete things, I'd take a look on CLOS (e.g. multimethods) and perhaps noticed that MOP (_metaobject protocol_) exists.
Thank you for your input. I've already read that CL has the highest potential for metaprogramming, while Racket prevents the developers from making errors by providing only hygenic macros. Is the difference really noticable in everyday programming?
One of the most useful aspects of unhygenic macros for everyday programming is [anaphoric macros](https://en.wikipedia.org/wiki/Anaphoric_macro). The topic is covered in-depth in the book I recommended.
Thank you for the further reading, I will save that for another day :)
Will remember, thanks :) Btw, going to Prague tomorrow for two weeks! Dobrý den!
Ahoj! Can do nothing but wish you to have a nice stay. :-)
&gt; Yes, C offers full flexibility in referencing things and accessing memory whereas Java restricts this flexibility. I think that's a bigger point than you give it credit for. Things like addressing memory or manipulating pointers aren't historical quirks that were left in because OO or cross-platform wasn't a thing at the time - those things are *what it means* to program in C. I really think that your stated goals are pretty awesome, though - I just disagree with the implication that Java is sufficiently like C to justify skipping it. I hate programming in C, and I'm bad at it, but I'm glad I've given it a go - you should too!
Guy's gotta eat? I'm sure his paid version takes priority since it's a single developer working on the language IIRC.
&gt; &gt; I have built an Interpreter in Racket before and agree that it is a good exercise. However, I still don't feel that leads me to the full power of Lisp. Don't underestimate it - I think that 'the power of lisp' is that, in lisp, building an interpreter like this is an introductory exercise. If there's any 'eureka moment' inherent in lisp it's that it makes it easier to realise that your interpreter, compiler, environment is just another piece of software. 
&gt; while Racket prevents the developers from making errors by providing only hygenic (sic) macros As far as I know, Racket provides non-hygienic macros. While syntax-rules based macros are hygienic (though I seem to remember reading it's possible, even using syntax-rules, to break hygiene), general syntax transformers may break hygiene. See https://docs.racket-lang.org/guide/proc-macros.html for documentation of general syntax tranformers. While Racket is its own language, it was originally scheme, and Guile's documentation has an example of a non-hygienic macro. See https://www.gnu.org/software/guile/manual/html_node/Syntax-Case.html#Syntax-Case.
&gt; I think that's a bigger point than you give it credit for. Things like addressing memory or manipulating pointers aren't historical quirks that were left in because OO or cross-platform wasn't a thing at the time - those things are what it means to program in C. Hey, no doubts about that! I have written assembly before (MIPS), so I know why one would leave the memory-fiddling to the programmer ;) &gt; to justify skipping it Ah, this is where we misunderstood each other! By no means do I want to restrict myself to these four languages. These just happen to be the languages I have some experience with - enough to have an idea about their limits and power. You on the other hand are concerned about skipping a potentially valuable learning experience - while valid (!), that is another concern. I appreciate it, but I am not interested in that experience. I can write a compiler if needed in the future (so like... never) and judge if the compiler is doing a better job than me at optimizing things by looking at the resulting assembly. That is all the low-level I ever want to know: My life is short, and I'd rather write applications in higher-level languages rather than talk to much to the metal ;)
You should be aware that SBCL is a lot faster than Racket. If that's a consideration. I haven't actually used Racket, but have seen benchmarks comparing them. SBCL also has very fast startup speed. You can write scripts for it, with shebang lines such as "#!/sbcl/sbcl --script", and can run them from your shell command line, in a tiny fraction of a second, or however long they take to do their work, which can be done a lot faster than with some other lisps. 
At this point that is not a consideration, but thank you for putting that out!
The Common Lisp Hyperspec is a very extensive and exhaustive document, but is not for beginners. There are a lot of good Lisp tutorials, textbooks, etc., which can be found by googling for them. I would start by following some of the online tutorials, and reading some of the reviews of the books to decide which books you want. Or if you don't want to spend money, some of the books are available online, and you can also learn a lot of Lisp by just playing with it. 
The limitations of Common Lisp are (1) that it's very old, which causes it to be disrespected, (2) that it has excessive features, some of which you can safely ignore, (3) that it's very easy to make a huge mess of Lisp code, making it hard for other people to understand it and maintain it, (4) that it uses its own garbage collection, making it unsuitable for systems programming, (5) that Lisp code uses a lot of parentheses, causing beginners to perceive it as a joke, (6) that to make the code clearer, people tend to make the names longer and more descriptive, making the language seem more verbose, (7) that you can program the language itself, which causes every serious Lisp programmer to have their own version of the language, by programming it to their own tastes. But the advantages outweigh the disadvantages: (1) the language is very old, and has gone through generations of refinements, which have been argued extensively, and tend to be very well thought out compromises, (2) the compilers, etc., have been refined for so many years, they're now extremely powerful and efficient, (3) so many years of debugging have made the quality of a typical Lisp development system much higher than those for a lot of other languages, (4) the language is extremely powerful and expressive, such that you can be a lot more ambitious about your development goals, (5) it's so powerful that a single good Lisp programmer working alone can get more done than a large team of programmers using a different language. 
Thank you for that response! &gt; that you can program the language itself, which causes every serious Lisp programmer to have their own version of the language, by programming it to their own tastes. I imagine this causes problems when collaborating. How are these handled? 
I'm afraid you have been reading too much into the whole business of "the power of Lisp" then. The possibility also exists that the perception is highly subjective as well. Metaprogramming is nice, but it's not the be all and end all. 
It is not. The incudine files you see in the repo are works in progress and aren't functional yet. I do want to add Incudine support (and keep the library as backend-agnostic as possible in general) but I only found out about Incudine recently and haven't really gotten around to digging too deeply into it yet.
far from being a serious problem, but why does the video show the photo of Kurt Gödel at 2:08 when it talks about Gerhard Gentzen and the sequent calculus?
&gt; I'm afraid you have been reading too much into the whole business of "the power of Lisp" then. The possibility also exists that the perception is highly subjective as well. That is absolutely possible! I just hope it is not the cases because of the persons that made these quotes. &gt; Metaprogramming is nice, but it's not the be all and end all. However, that and "Data=Code" seems to be the distinguishing factor for the Lisps. Much of the other powerfull stuff can be found in other languages aswell (coding in a live environment =&gt; Smalltalk, functional programming =&gt; Haskell). I am interested in how the unique features of Lisp add something that other languages don't offer.
Yeah the [API](https://docs.racket-lang.org/reference/Reader_Extension.html) in Racket looks rich at first glance, does it allow you to do a really arbitrary thing^* as I'm assuming? Then I think Racket does it better. *Like connecting to the internet and determining the weather and on that basis deciding how to read the code.
Thank you for this tipp, if I one day decide to dive into the C (ha!), this is my starting point. However, I still stand by my categorization of putting these languages together. They are file-based and not truly OO (as opposed to Smalltalk), they embrace side effects (unlike Haskell), they are not dynamic (unlike Lisp).
can you expand on this?
Instead of RPLACA und RPLACD one would use SETF: CL-USER 147 &gt; (let ((a (cons 1 2))) (setf (car a) 3) (setf (cdr a) 4) a) (3 . 4) CL-USER 148 &gt; (let ((a (cons 1 2))) (setf (first a) 3) (setf (rest a) 4) a) (3 . 4) Instead of using specialized functions set-car!, Common Lisp provides the more general idea of places.
Is there any introduction to OpenGL you can recommend?
Excerpt from [Let Over Lambda](http://letoverlambda.com/index.cl/guest/chap3.html) &gt; Some lisps other than COMMON LISP, like Scheme, have the unfortunate property of combining the variable namespace with the function/macro namespace. Sometimes these lisps are termed lisp-1 lisps, while COMMON LISP, with its separate namespaces, is termed a lisp-2 lisp. With a hypothetical lisp-1 COMMON LISP we would also be obliged to follow these two additional rules when constructing macros: &gt; Verify that intentionally introduced lexical or dynamic bindings do not collide with intentionally introduced function or macro bindings, or any of the special forms, macros, or functions defined by the standard. &gt; Verify that intentionally introduced function or macro bindings do not collide with intentionally introduced lexical or dynamic bindings. &gt; COMMON LISP's wise design decision to separate the variable namespace from the function namespace eliminates an entire dimension of unwanted variable capture problems. Of course lisp-1 lisps do not suffer any theoretical barrier to macro creation: if we follow the previous two rules, we can avoid variable capture in the same way as we do in COMMON LISP. However, when programming sophisticated macros it can be hard enough to keep track of symbols in a single, isolated namespace. Having any cross-pollination of names to consider just makes macro writing more difficult than it needs to be. &gt; More so than any other property except possibly its incomplete standard12 Especially as it relates to macros and exceptions. , it is this defect of a single namespace that makes Scheme, an otherwise excellent language, unfit for serious macro construction13 Though as we will see throughout this book, there are many reasons to prefer COMMON LISP over Scheme. . Richard Gabriel and Kent Pitman summarise the issue with the following memorable quote[LISP2-4LIFE]: &gt;&gt; There are two ways to look at the arguments regarding macros and namespaces. The first is that a single namespace is of fundamental importance, and therefore macros are problematic. The second is that macros are fundamental, and therefore a single namespace is problematic. 
OpenGL is a library with two very different paradigms contained within it. There is old style OpenGL (which uses gl-begin and gl-end) and new style OpenGL which is based on shaders is probably what you want if you want to do fancy effects in the future. The pain is that a lot of tutorials online are still for old style OpenGL or mix the two in a way I found super confusing. The best two resource I have found are http://www.arcsynthesis.org/gltut/ &amp; https://learnopengl.com/ Arcsynthesis is down but you can go here https://bitbucket.org/alfonse/gltut/downloads/ and download `Tutorial 0.3.8.7z`. It is a great tutorial as it forces you to deal with some of the tricky stuff earlier that you may do otherwise, it explains some of the weirdness of GL in a way that other resources just have you accept. Great resource LearnOpenGL.com is still alive and growing, it's well written and covers many techniques you will be interested in. I think for folks really interested in getting into GL I'd say do the first 4 chapters of Arcsynthesis and then you will have enough knowledge to dive into anywhere in LearnOpenGL and be able to use the OpenGL Wiki more comfortably. I hope this helps
Clarity and brevity. Some time back somebody wrote as an experiment a program in Qi (CL specific Shen) and coded the same program in O'Caml and in Qi. From memory the CL came out as 1000 lines and the Qi and OCaml versions as 300-400. You can also see some comparisons wrt LOC and performance here. http://shenlanguage.org/lambdassociates/htdocs/studies/study10.htm Pattern-matching leads to shorter and clearer programs which is one reason why many modern FPLs use it. The second reason is the isomorphism between Shen syntax and sequent notation The S-level syntax still exists in Shen (define find-extension {string --&gt; (list record) --&gt; natnum} _ [] -&gt; (error "name not found") Name [[Name Extension] | _] -&gt; Extension Name [_ | Records] -&gt; (find-extension Name Records)) can be entered as (define find-extension {string --&gt; ((list record) --&gt; natnum))} _ () -&gt; (error "name not found") Name (cons (cons Name (cons Extension ())) _) -&gt; Extension Name (cons _ Records) -&gt; (find-extension Name Records)) but nobody writes Shen that way. It compiles into (1st pass) KL (the native Lisp of Shen) as (defun find-extension (V1792 V1793) (cond ((= () V1793) (simple-error "name not found")) ((and (cons? V1793) (and (cons? (hd V1793)) (and (cons? (tl (hd V1793))) (and (= () (tl (tl (hd V1793)))) (= (hd (hd V1793)) V1792))))) (hd (tl (hd V1793)))) ((cons? V1793) (find-extension V1792 (tl V1793))) (true (shen.f_error find-extension)))) and you can enter that but nobody writes in KL. Historically McCarthy wanted S-expression syntax to be for machine consumption only and an M-level syntax was supposed to be what people wrote in. But the M-level stuff was dropped although some people did try to keep it up (https://en.wikipedia.org/wiki/MLisp). 
Not really, I'm mostly repeating folklore. It looks like Richard P. Gabriel and Kent Pitman talked about it here http://www.nhplace.com/kent/Papers/Technical-Issues.html Although I think Richard and Kent think very long and carefully about things generally, and also in this paper, I'm not sure it is actually on point: I think their examples are not actually conformant in Common Lisp as it was standardized. They use `FLET` to rebind the definition of `CL:CONS` which I don't think is permitted.
100% AGREE WITH THIS PERSON RIGHT HERE
Can always use [Spacemacs](http://spacemacs.org/), which is an emacs setup that focuses on vim keybinds and using mnemonic keybinds with the spacebar.
+1. I wish I could be there. 
Good to know. Keep up the good work!
You should have a look at [MAL](https://github.com/kanaka/mal) which is a project all around creating a small Lisp dialect in another language with the intent of learning to use that language through the implementation process.
hylang is slow, not a lot, but you know, python slow. What I mean is, that it won't run at the speed of Pixie
So it's like every other programming language ever developed?
[removed]
I've often seen code that compiles on LispWorks be rejected by the SBCL compiler on the grounds of inferred type checking.
It's slow indeed, but not much slower than Python itself. People who can accept the runtime speed of Python can accept hylang for sure. So your new lisp may also succeed, who knows? :)
I've written one, Emblem, in which I'm implementing [Full Metal Jacket](http://web.onetel.com/~hibou/fmj/FMJ.html), a visual dataflow programming language. Emblem is close to being a subset of Common Lisp. The main differences are that read is case-sensitive, and it's a Lisp 1 (like Scheme). The stack-based virtual machine is written in C/C++, the interpreter is written in C macros and is similar to Forth, and the rest of the system, including the incremental compiler, is written in Emblem. I've added various libraries to do (symbolic) AI, statistics, 2d (X11) and 3d (OpenGL) graphics, and a variety of other things. Still to do: write a decent garbage collector for variable-size objects (arrays, objects, strings), and (if I get around to it) write a native-code compiler which generates stand-along executables, probably as a second pass, translating from virtual machine code to X86-64. I might move to a statically typed Lisp with type inference if I get that far. Working but not well: returning functions which capture data from their environment. This is easy to do in an interpreted Lisp but difficult when the code is compiled. It's called the [upwards funarg problem](https://en.wikipedia.org/wiki/Funarg_problem#Upwards_funarg_problem). So implementing Lisp is, to me, a (mostly) solved problem. There are standard texts (The Anatomy of Lisp by John Allen and the more recent Lisp In Small Pieces/Les Langages Lisp by Christian Queinnec), and Lisp runs adequately on commodity hardware, level 1 caching notwithstanding. Visual dataflow is another matter. That's a lot more challenging, as unlike Lisp there are no suitable textbooks, it involves language and IDE design, and there's a poor match between commodity hardware (SISD or at best SIMD) and dataflow (MIMD). 
That's good to hear. If you have more details, be my guest.
Pixie is discontinued :/ [author's words](https://github.com/vindarel/languages-that-compile-to-python/issues/7)
oh no, why? I liked the project
looks very interesting, what is its main use-case?
I heard of Full Metal Jacked, but its not what I am looking for, I would like it to be more Lispy. But Emblem sounds damn interesting!
[removed]
&gt; Though a Lisp-2, it supports Scheme-like slick higher order &gt; programming (way to code with no visible funcall or function &gt; operators). I've made function definitions bind in both namespaces in a Lisp-2-oid language design, so that you could refer to #'foo as foo, as long as you hadn't shadowed foo in the non-function namespace. Then add something like [...] as syntax for (funcall ...) and you can write pretty Scheme-y code. My experimental result: I liked it all at first, later disabled the "bind in both namespaces" feature but retained the funcall syntax. The problem with the former was that I came to dislike the "more than one way to do it" aspect of it. There would be a (foo bar baz) here, a (foo #'bar baz) there, and eventually I found the inconsistencies more irritating than the function "sigil" and went back to pure Lisp-2. (The other way I could have enforced consistency is pure Lisp-1. Doesn't work for me, but obviously works for many designers of new Lisp dialects.) 
&gt; In short he didn't get how open source can work Assuming that his goal is to turn effort into income, what should he have done?
Be as open and collaborative as possible on the language. Maybe sell consulting and tools. Rich Hickey has made a pretty penny from Clojure. I can't think of a successful proprietary language in the recent past. Not saying that there aren't any, or that it's impossible.
[removed]
The only reason not to use TXR over any other scripting language for any task (Perl, Ruby, Python, ...) is library support. I use TXR for all "data munging" in my daily workflow, especially anything involving scanning through complicated file formats in a robust way (without spending days or weeks making a formal parser). I have scripts running on my server which scan logs, looking for intrusion or abuse attempts. I use it in the mail delivery pipeline. I have a web application written entirely in TXR called Tamarind which provides an interactive manager for throw-away mail aliases. I use a TXR program for backing up some Windows PC's. It parses an *ad hoc* language which defines back-up rules associated with the PC's host name, and transforms them into an invocation of `xcopy`. 
Except for this lovely snippet of its license: &gt; Permissions related to performance and to creation of derivative works are expressly NOT granted. It might then be a better idea to [join forces with the CLUS initiative](https://www.reddit.com/r/lisp/comments/5xcafp/common_lisp_ultraspec_the_glossary_is_operational/deje13k/).
Has it not been discussed with the rightsholders[1] of the CLHS to change the license given the modern age of open documentation? [1] Anybody know who the rightsholders of the CLHS are?
Yes, I don't mind this. Right now, I am using DokuWiki because it works, so I use DokuWiki markup because it works. Though, parsing the DokuWiki markup is relatively trivial; the harder part is, I will need a rendering engine for this kind of lispy syntax, and it will be the best if it will render straight to XHTML. I don't want to think about this for now because I want to focus on translating the TeX sources; if you want to pick up this task, you're free to do so - you'll get all the associated glory.
Glory-schmlory. I won't be able to make it as *pretty* as it is now, but I hope some CSS-guru can pick that up :) As I mentioned on GitHub, I've got a working Elisp POC. As long as there's a build step to generate the HTML from Make/etc., do you care that it will require a recent emacs?
Thanks.
It's misleading to describe TeX as the home format of the CLHS. The CLHS is derived from the TeX sources, but the license applies only to the derivative, not the TeX sources. I asked Kent Pitman specifically about creating derived works of the TeX dpans3 documents, and his stance was that it was available and possible for anyone to do anything they wished with the sources.
Do you have a link to the appropriate license?
Alright, but is that written down anywhere? I did find [some related discussion](https://www.reddit.com/r/lisp/comments/36kkdc/copyright_on_hyperspec/), but there are no sources there, either :( Sorry to be a butt :(
The TeX sources for the draft ANSI CL documentation are, well, freely available. The final ANSI CL documentation is proprietary to INCITS / ANSI. https://standards.incits.org/apps/group_public/project/details.php?project_id=1012 http://webstore.ansi.org/RecordDetail.aspx?sku=INCITS%20226-1994[S2008] Some of the draft ANSI CL documentation sources are here: https://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/lisp/doc/standard/ansi/0.html The CLHS has been compiled from the ANSI CL documentation sources. The CLHS itself belongs to LispWorks. http://www.lispworks.com/documentation/common-lisp.html Another derivative work of the ANSI CL docs is from Franz Inc.: http://franz.com/support/documentation/10.0/ansicl/ansicl.htm There is also a converter to TeXInfo: https://github.com/RobBlackwell/dpans2texi &gt; dpans2texi.el converts the TeX sources of the draft ANSI Common Lisp standard (dpANS) to the Texinfo format. 
It's taken me quite a bit of research to discover that the license of dpans3 is… ill-defined. This isn't exactly common knowledge and would've been nice to know right off the bat :) Sorry for the confusion.
[removed]
I've been slowly writing a lisp interpreter using the language SETL. It's a basic Common Lisp syntax extended to include sets. It's been fun, almost at a finished-enough-to-post stage. Best thing I learned was the powerful relationship between internal lisp printer and read functions.
he also said, that some others are continuing the work, so no problem for end users, but the community might change.
[removed]
The degree to which this is true varies dramatically by language. C++ is a kitchen-sink known for it, where canny coders use only a subset, while C is a much more spare language where there isn't nearly so much room for personal idiom. 
every programmer should develop a non toy common lisp package 
Slots can store anything. You should always show the line of code that produces an error when you're asking for help - even if you think it's obvious. You may have a typo that you're not seeing. This is error is probably due to how you are calling the value in the slot. You need to ``` (funcall (slot-value o :invoice-name)) ```
Do you know whether one would be allowed to buy a copy of the standard and generate lisp data from that?
The LET expression is quoted: `(let ((shn showname) ...) You can't funcall this list with the LET as the first element. This is shown by the error message. You probably want to remove the quote and have the LET expression evaluate to the return function. This will then be stored in the slot and then you can funcall the slot content. 
You're totally right. I tried to edit it out of the pastebin; that was a mistake I left when I was experiementing with how to get this to work. Apparently I have to use the slot-value function for it to work as a function.
It's not so much CLOS as how common lisp binds values to symbols. There are 2 bindings associated with each symbol (think of them as storage areas): a value-binding and a function binding. You access them like this: ```(symbol-value 'mysymbol)``` ```(symbol-function 'mysymbol)``` When you write ```(mysymbol 1 2 3)```, it means ```(funcall (symbol-function 'mysymbol) 1 2 3)```. The **only** way to call a function which has been stored in the value binding is to do ```(funcall (symbol-value 'mysymbol) 1 2 3)``` or ```(apply (symbol-value 'mysymbol) '(1 2 3))``` 
Ok
Awesome! This is going to be really helpful when I start poking around with vlime. Thanks!
I also had this idea. But I strongly recommend you to use [racket scribble](http://docs.racket-lang.org/scribble/). There are [cl](https://github.com/fare/scribble) [ports](https://github.com/CommonDoc/codex) if you don't want to write racket, but I don't know how mature they are though.
Which parts are left out? Could you give some examples?
CLOS is treated shabbily (an elephantine, structured way to write spaghetti code). Packages are not covered. Loop is ignored. Etc. I think it's a good book to read if you have other books to round out coverage of Common Lisp features. I don't think it's a good book to start with, or a good book to use exclusively.
I suspect the seller is David K. Schmidt.
I mean, you can easily write a [scribble renderer](https://docs.racket-lang.org/scribble/renderer.html) according your needs. For example, in your initial _lispy_ example, you _could_ write it in scribble as: #lang scrible/base @defform[setf]{ @syntax{ @codeblock{ setf {pair}* =&gt; result* } @codeblock{ psetf {pair}* =&gt; nil } @arguments{ @; ... } @; ... @description{ @lisp[setf] changes the @lisp[value] of place to be newvalue. } } and create a _lispy_ renderer that transtate it to s-expressions for to be `read` by Emacs (doc :form setf :syntax ("setf {pair}* =&gt; result*" "psetf {pair}* =&gt; nil ") ;; ... :description "setf changes the value of place to be newvalue." ;; ... ) and the same goes for vim helpfiles, texinfo, html, etc. 
You can also do interesting things like make the class funcallable and dispatch to whatever function is in the indicated slot (the below is SBCL specific though most implementation should be able to do this): (defvar *self* nil) (defclass funcallable () () (:metaclass sb-mop:funcallable-standard-class)) (defmethod initialize-instance :after ((fn funcallable) &amp;rest initargs &amp;key &amp;allow-other-keys) (declare (ignore initargs)) (sb-mop:set-funcallable-instance-function fn (lambda (slot-name &amp;rest args) (let* ((*self* fn) (func (slot-value fn slot-name))) (apply func args))))) (defclass thunkerific (funcallable) ((thunk :initarg :thunk)) (:metaclass sb-mop:funcallable-standard-class)) (let ((thunker (make-instance 'thunkerific :thunk (lambda (&amp;rest args) (format t "; ARGS: ~{~S~^ ~}~%" args) *self*)))) (funcall thunker 'thunk 1 2 3)) ; ARGS: 1 2 3 #&lt;THUNKERIFIC {10048654CB}&gt; 
When I had enough of the community (I sponsored the BSD transition and did an implementation of Shen but could not stand the anger and the (unfounded imho) OSS hatred) people kept coming up with k/q/Kdb+ as 'recent' proprietary language. There is Xojo, but not sure how popular it is. Livecode was open sourced. Not very recent and it's a very particular and well funded niche that kx is in. Shen would not really have that chance as you need contacts / first movers in the space. I don't think making money with 'a language' now has much to do with closed source or not; that's what I argue(d) anyway but it doesn't happen overnight and you need to be an advocate and explain why not how. Politics with CTO's and good SLA/support contracts. 
Understood. Thanks.
Anything for doing interactive repl type experimentation with GPU?
Overall security. How breachable they are, how securable they are, can they crypted and still run, can they be locked down and how hard in short.
Mezzano is close, but, at least the last time I tried it, it still required an external service for loading files, or at least the initial packages. This might have changed - it's been a month or two since I last built it.
What does it mean to breach or secure a core?
What would you do if you had a Lisp OS?
No more or less secure than a source file or ELF executable. None of the major CL implementations has core signing or related features. The JVM-based implementations might be able to leverage the Java class loader's mechanisms. Operating systems provide varying levels of support for installing and verifying signed files. These capabilities can be used to protect core files.
magic.
This sounds like you're looking for security against reverse-engineering of a local copy by a hostile attacker, correct? Server-side things are entirely different. 
&gt; that's not an easy feat. Yet one author accomplished it alone, and in a surprisingly (or not) short number of lines of code. The hardware support and the IPv4 networking is quite basic so far, but you can boot it up in your choice of virtualization and use the GUI to IRC. At least three vendors shipped an OS entirely in Lisp -- Symbolics, LMI/TI, and Xerox -- although I'm not sure which of the code bases might potentially have forked from MIT. 
&gt;Symbolics, LMI/TI, and Xerox -- although I'm not sure which of the code bases might potentially have forked from MIT All of them but Xerox. Xerox's Lisp system was derived from BBN-LISP.
I, too, am skeptical that the OS layer was the main contribution to Genera's value. As I understand it, the main OS-like benefits were things like good integration of the VM and GC systems and microcode assistance for maintaining GC invariants. If x86-64 hardware can be better exploited for Lisp GC, I'm pretty confident you could hack a Linux/BSD variant to provide that support. But nobody has done it. If x86-64 hardware is already supporting Lisp GC about as well as could be expected, reimplementing the OS kernel in Lisp is not going to win anyway. And, finally, if the problem is the cost or effort in upgrading Linux kernel behavior, I think the cost or effort of implementing a kernel in Lisp that gets similar GC performance would be as great or greater. The user land improvements are also a lot of work, of course.
Thomas Hintz, the author of 3L, just gave a talk about it to the Bay Area Lisp and Scheme Users Group: https://www.youtube.com/watch?v=bVlR7ug074Q If you're interested in other talks from our group, please check: http://balisp.org/videos
Thanks, I thought the project was interesting when I first heard about it, I will take a look into the videos.
[cbaggers/cepl](https://github.com/cbaggers/cepl) looks very promising and is a very active project that I recommend.
I know it was asked for earlier, thank you for putting it together!!
Aww yiss, some afternoon entertainment!
It seems like investments in improving GC should pay off in general, hopefully in multiple implementations. I look at the [SBCL results from The Benchmark Game](http://benchmarksgame.alioth.debian.org/u64q/lisp.html) and I suspect they haven't improved over themselves in a long time, whereas many other runtimes and compilers are actively investing.
I want to do this eventually when my webdev projects are finished. I already spend most of my time in emacs
So far my thoughts from the first video (I'll watch the second later): This is a really cool idea, and well implemented. Congrats and thanks! What's working great already: - I love the visuals - Great and helpful analogies - Clear speaking and good mic control - I like that you didn't try to write code as you were going, and didn't cover every detail. having made programming videos in the past, I think it's less interesting to write and explain everything than just having the code be present, and cover the main points. - You did a good job guiding me to where I needed to watch or look before things happened. - Your ptrace interface is really neat. What I think may benefit from more attention: - I think there was room for fonts to be bigger. - I had a hard time seeing the result of "top" because of font size and color; BUT you did say everything verbally, so really not much of a problem. - For printing out hex, you can use %x (or something) in your printf statement. It would help drive home the point that flagg does not change. - The music section jarred me a bit because the volume of the music was much louder than the volume of the voice. I needed to adjust my volume down and up. I'm looking forward to watching part two when I get some more time! Thanks again for sharing. I'd encourage you to share in more places than just /r/lisp if that sounds like something you want to do.
I'm working on a Lisp in rust, following this guide http://norvig.com/lispy.html Currently I'm trying to work out a decent solution to dealing with recursion, since I easily hit the limit of the stack. At the moment I'm trying to put everything in a queue and then popping through it, but it feels really slow now, and the code is a mess, so I'm going to rethink and rewrite it, focusing on dealing with trampolining tail calls, instead of trying to eliminate the use of the stack completely. I feel like I've learnt more about Rust's different ways to deal with pointers (e.g. apparently you can return a derefed box but as long as you wrap it up immediately it keeps being boxed, which in turn leads to functions [not having to care whether to return a boxed value or not](https://doc.rust-lang.org/book/box-syntax-and-patterns.html#returning-pointers)). I've also started to realize that Rust seems to need a lot more words than other languages. The python interpreter that I linked earlier is something like 100-150 lines of code, while my little monster is weighing in at 1042 (with blank lines, but still). I've also learnt more about macros in rust, which is neat.
It's still using this (a file server) yet. I tried yesterday.
Also check out the whole book: http://beautifulracket.com. Very nice, if not inspiring.
+ very smooth and pleasant voice + actually explaining the *important* things + old memes, all the old memes, ah the sweet trips down memory lane ;_; - Fonts are hard to see on a non-HD screen Keep it up! It's pretty awesome.
Talking about macros he mention: [...] a Racket macro can be more sophis­ti­cated than the usual Com­mon Lisp macro. A macro in Com­mon Lisp is a func­tion that runs at com­pile time, accept­ing sym­bols as input and inject­ing them into a tem­plate to pro­duce new code. Macros in Racket, on the other hand, rely on the con­cept of hygiene. They can han­dle Com­mon Lisp-style macros, but also more elab­o­rate syn­tax rearrange­ments. I though Common Lisp macros have been claimed to be superior to hygienic macros?
depends on what you mean by superior. there are benefits to each of the systems.
What are the benefits of hygienic macros or racket macros (besides not needing to worry about unintentional capture)?
I generally agree that the benefits of hygienic macros don't adequately pay for the costs, largely for the reasons you state. still, I think it is more intellectually honest to be cognizant of the benefits.
I don't want to join "which is superior" discussion, and this is just a question, but does scheme also allow something like this? (defun primep (n) #+sbcl (sb-int:positive-primep n)) ;; (primep 4461926290642603313185756658254841232481376192090294129197) ;; .... (define-compiler-macro primep (&amp;whole form n) (if (integerp n) (and (ppcre:scan "is a prime number" (drakma:http-request (format nil "http://www.wolframalpha.com/input/?i=~D" n))) 'T) form)) (defun prime-test () (list :primep 4461926290642603313185756658254841232481376192090294129197 '=&gt; (primep 4461926290642603313185756658254841232481376192090294129197))) (prime-test) ;⇒ (:PRIMEP 4461926290642603313185756658254841232481376192090294129197 =&gt; T) ---------- Evaluation took: 0.000 seconds of real time 0.000000 seconds of total run time (0.000000 user, 0.000000 system) 100.00% CPU 2,448 processor cycles 0 bytes consed code is from http://qiita.com/g000001/items/0b43e3839dd6ca1a50a6
No, the environment is not sufficient. The meat of the difference is how you represent identifiers. Interned symbols don't do because you can't distinguish between identifiers "foo" and "foo" based on where in the source they were introduced. Hygienic macro systems don't use interned symbols to represent identifiers. 
Non-ancient hygienic macro systems can break hygiene.
I didn't know that hygiene enables "*more elaborate* syntax rearrangements", and I don't believe it :-)
Very good article. Thank you. I am currently studying lisp but found a bit lack of motivation. This motivates me to study Racket :D 
It's rubbish because Common Lisp macros can (i) take arbitrary Lisp objects as input and (ii) perform any arbitrary computation to produce an output.
Could you point me to an example (or documentation)? Edit: Is [this](http://www.phyast.pitt.edu/~micheles/scheme/scheme29.html) what you mean? I stand corrected then. It's not nearly as straightforward, but it's not impossible.
You could also just use cl. The only thing I've found from matlab was their syntax for referring to rows and columns of matrices. which is easily replicated.
A nice gem by /u/orthecreedence. It also support paren-matching, [try overing a parentheses](http://orthecreedence.github.io/highlight-lisp/), and it is themeable. It would be nice if more sites would use it. Especially significant common resources like the [Common Lisp Cookbook](https://github.com/LispCookbook/cl-cookbook). 
It would be great if this meshed with org-mode html export, which can transmute the colors used in an Emacs theme to CSS. A fast way to implement this, would be to make the 'theme' part of highlight-lisp optional.
Not a linter, but you may find this interesting: [Editing Lisp and Scheme files in vi](https://ds26gte.github.io/scmindent/index.html)
SBCL is working on a new mark sweep garbage collector. At least last release they mentioned it. I think it either needs to be compiled in or enabled with a command line switch.
I really like the drawings and analogies as well! I learned a lot also from the way you were navigating around as well! Thanks for making this and really look forward to more of these!
* You can type "Lisp" it's easier, and the all-caps LISP is old-fashioned. * The two living lisp standards are Common Lisp and Scheme. * There are many other languages in the lisp family (notably Clojure and Emacs Lisp), but those are the two big standards. * Guile and Racket(Originally PLT Scheme) are both scheme implementations (each with many extensions). Guile was designed specifically to embed in programs as a scripting language. Racket is more of a stand-alone language. * There are a lot of little differences between Scheme and Common Lisp; imagine having to describe the differences between Objective C and C++ to someone who doesn't know any C-like language. * That being said, one big difference is that scheme is more minimal in it's aesthetic compared to Common Lisp; the latest scheme standard is starting to approach the size of Common Lisp, but it also defines a subset for small implementations. * Another historic difference is that Scheme was somewhat more strongly associated with PL theory and research while Common Lisp was more associated with commercial endeavors. That's a bit more of a stereotype than actually true these days though. * I know a little scheme, but am primarily a Common Lisp programmer. A great free book for learning Common Lisp is Practical Common Lisp[1]. To get quickly setup with a lisp development environment, I recommend Portacle[2]; this is recently updated and easier to setup than what the book recommends (it didn't exist when the book was written). * Yes you can call C functions from pretty much any lisp implementation. The usual lisp term for this feature is "Foreign Function Interface" (FFI). I use this primarily to leverage existing libraries and make OS system calls, contrasted with python where C is used as a performance optimization, as my preferred implementation (SBCL) compiles down to fairly tight machine code. 1: http://www.gigamonkeys.com/book/ 2: https://shinmera.github.io/portacle/
Very exciting talks this year. I am very much hoping that there will be video recordings similar to past years.
Hey, What ticket do I need to buy for the conference? Is it full conference ticket or "workshops only" ticket that is valid for the 3rd and 4th of April? I'm asking because all tickets are probably tailored for Programming conference not the ELS2017
Hi! Welcome to the world of Lisp. I'd second the vote for Practical Common Lisp. Regarding implementions, three well-known Lisps are SBCL, clisp, and ccl. I tend to use SBCL, as it can be fairly high-performance and has some useful extensions. In terms of operating systems, I believe clisp is reasonably portable, but have little experience there. If you stick to OS-independent stuff, and move source instead of compiled files around, a lot will just work, in any Lisp. For architectures, all I know is that SBCL has a number of implementations for different ones, including ARM as of version 1.3. Lisp is not nearly as widely used as some other languages so it's harder to say things about what is generally done, from what I've seen. Once you've got the basics, check out Quicklisp, a package management system that won't be mentioned in the older books, which gives you some abilities akin to CPAN, pip, gem, and so on. I recommend the alexandria package for a bunch of useful tools not in the standard library. If you want to go particularly far down the "portable" road, there are a few Lisps which compile to the JVM. ABCL is the main one I know for Common Lisp, and Clojure and Kawa (a GNU project) are two very different takes on this for Scheme. I've poked a little at making them work for Android, but haven't gotten beyond the most basic apps, using Kawa. I hope this helps! Any further questions?
Are you sure about this? I've search through the programming-conference.org website and did not find any evidence of that, it's called symposium everywhere
Just noticed the 3rd link is up! Yay! :) (BTW, the ID is there, but you're actually linking to the "edit the video" page) Fast link for now: https://www.youtube.com/watch?v=UZf1DzJYO8o Thanks again!
I tried so hard to go. Unfortunately, with travelling, ticket and all, it is a bit too expensive. Brussel is quite an expensive city, too. Let's hope next year the organisers will think of low-income lispers.
Did you contact the organizers? I heard that they were planning for financial support for students. From the ELS twitter: &gt; We’re planning to partially refund students attending the 2 days of #ELS2017 in order to compensate for the higher cost this year. #lisp Not sure if something had been figured out. If you haven't, it might be useful to ask...
If you're just getting your feet wet with Lisp/Racket/Scheme, the Little Schemer will teach you how to "think Scheme". I went through it while getting a better grasp on Lisp, and did all the problem in Lisp rather than Scheme.
ah! thanks a bunch!
Thank you, I will try.
Just a small correction: in contrast to Kawa, Clojure is by no means a Scheme, even though it's arguably closer in spirit to Scheme than to Common Lisp.
Nice video, already waiting for the next oneS ;) Makes me remember some older days when I was rudimentarily "hacking" some DOS games, with a hex editor, to brag about high scores. And a friend of mine, similarly solved minesweeper in 1 second ... 
I just saw /u/k-stz updated his old post with the new video, but I thought this video was good enough to deserve its own post. All credit goes to him!
What about that dataset are you trying to train any kind of system? The purpose of the training?
Good idea :)
thanks for sharing ! ;)
Hoi, thank you for this answer it clears many boulders I had in my way. I have one follow up questions regarding your recommendation for now: If i just rely on the system libraries (libevdev for example) and don't write my own C wrappers what should be in the 'lib.h' file? An include of the headers i want to use (eg. 'libevdev.h')? Thanks again! Edit: one more: To get this straight, I just look in the header file of the lib i want to use and handpick the definitions I need (but not function prototypes) and write a mapping-lisp file for the groveller (when not relying on SWIG for extraction)? This seems more straight forward then I thought.
Might be nicer to use this instead: https://github.com/rpav/cl-autowrap
I edited the original comments. In your case yes, `lib.h` is `libevdev.h` itself or a file that #include `libevdev.h` (if PATH to libevdev.h is guaranteed to be resolved). You should then use `(include "lib.h")` in the groveller, which includes `lib.h` in the autogenerated C code, which then includes `libevdev.h`, and so on. &gt; write a mapping-lisp file for the groveller Yes, if the number of structs/variables are small enough.
Thanks again. Highly appreciated :)
I've never deployed with cl-autowrap, but it does use c2ffi and you do need to build it on your machine to make it work. For deploying though, cl-autowrap claims that: "This calls c2ffi and generates architecture-specific .spec files you can distribute with your project. Neither c2ffi, nor any compiler (or even .h files!) are necessary for your users!" I'm not really sure how this works, though.
So if I understand correctly, it parses out the #defines for all possible architectures and generates the correct Lisp code for each one? That's actually really neat.
Download the epub from their github page and use an e-book reader. 
I thought for typed Lisp, http://www.shenlanguage.org/ is supposed to be the most sophisticated (the author mentions static typing as being a virtue).
as a CL beginner I agree. It is hard to resist Clojure :p and it's hard to start wit CL. At least CL has one appealing website: http://lisp-lang.org/
Using Firefox?
Doesn't common lisp offer ways to allow static typing?
Nope, Reddit is Fun on Android, which uses embedded chrome.
Follow the discussion in /r/emacs: https://www.reddit.com/r/emacs/comments/61p5nd/the_emacs_lisp_programming_environment_elpe_now/
I'm 71% sure that "ELPE" is literally just another name for "Emacs".
The quality of implementation is such that i can run a SBCL-based webserver for a year without ever restarting it. Its speed and stuff like type inference are pretty much unmatched among free Lisps. Then there's threading support (including on Windows), perfect Unicode support and so on. I switched from CLISP and yeah, a lot of my not perfectly ANSI-compliant code broke, but it was worth rewriting it. In fact, I discovered some bugs in my code thanks to SBCL's type checker.
Probably related to https://bugs.launchpad.net/sbcl/+bug/1533685 from your list. The first comment offers a plausible diagnosis: *"KEYWORD is a deftype for (and symbol (satisfies keywordp)), and subtypep can't reason well about satisfies."* 
What got me off in Racket was macro definition and use, for me was too confusing. Perhaps the racket way of defining sintax macro and related is better but for me was difficult to employ, I gave up using racket because that. 
Aren't Apple's online stores hostile to the GPL?
To comply with the GPL I have provided the full sources on github linked from the product page. Apple made no comments during the approval process with regards to the license, and I understand that my rights as a Free Software user are that I can create, modify and (must) distribute the modified sources, which I have done. I see little correlation between Apple's stance on the GPL and the stance of my company which is willing, able and ready to meet any further requirements that must be met to meet the terms and conditions of the GPL.
The CL standard requires that declared types be enforced at run-time. "Sufficiently smart" compilers will issue warnings at compile time about type mismatches if they can be detected, but these aren't required by the standard. Since dynamic typing is allowed, the CL type system is trivially Turing-complete, so it isn't always possible to detect type-mismatches at compile-time.
I'm an inconsequential dabbler in common lisp (not even a programmer) but the Common Lisp community will be a lot poorer if Fare leaves. 
A couple of thousand probably.
&gt;Without some low-level hardware knowledge and spare parts it just makes no sense to spend any money on a 3640. What about lisp community cred? 
5% faster gc. Nice!
Speaking of inlined-generic-function, is there any way to use it to speed up gray streams?
Such a machine (3640) makes slightly more than one VAX MIPS (million instructions per second on a 32bit CISC architecture). Lisp on a typical Intel machine can be a thousand times faster. A full GC over virtual memory may take 30 minutes. It uses over a kilowatt electricity.
These days even surviving a power-up without careful testing and inspection of an original power supply is a risk. If someone has a Symbolics 3640 with an original power supply, they should not power it up.
Does it have Symbolics Ada on it? (I'd be very interested to get my hands on a copy of that software/codebase.)
I've had [easy-gnuplot](http://guicho271828.github.io/eazy-gnuplot/) bookmarked for a while, in case I ever wanted to do notebook style programming with plots.
SBCL is fine. I think the warning is old and does not apply. CCL is a good alternative. Haven't tried CLISP.
SBCL worked well enough despite its warning. I have had a bit of Unicode problems when it came to SBCL/Emacs integration on Windows, but using CCL had them fixed.
I've had a good experience implementing tools with CCL on Windows.
I love Racket but I haven't written resource demanding programs with it. If someone has I'd like to read about the experience.
From what I hear Clojure works great on Windows.
ACL and LW work great.
I've had issues with SBCL on Windows a number of times. CCL seems to work more reliably, though. If you have the money, go for LispWorks.
Do you remember your Unicode problem? I just worked with utf-8 on a project back in December and had no troubles with SBCL. I used trivial-utf-8.
Fukamachi is deploying CL applications to windows https://www.slideshare.net/fukamachi/building-gui-app-with-electron-and-lisp 
I would buy it for a birthday present (of mine)
$20 the hardcover and I buy it.
Original link of image is from https://news.ycombinator.com/item?id=13981959
Bought "Land of Lisp" by Conrad Barski, M.D. from Humble Bundle. "Common Lisp Recipes" will be a great addition.
Hi this is still an early and incomplete draft; I wasn't expecting it to get posted so soon. PRs, and suggestions for improvement are welcome. Also see https://jasom.github.io/clack-tutorial/pages/getting-started-with-clack/ for the html version.
https://jasom.github.io/clack-tutorial/pages/getting-started-with-clack/
These are pretty, but would be more useful if either the "fast" and "slow" implementations were split into separate graphs, or if a logarithmic Y-axis were used.
As an update, I have purchased this machine for my Lisp Machine Sanctuary. This is system #12, and the fourth 3640. I hope to arrange freight today. Thanks to the recycler for saving the machine from being parted out when I contacted them on Monday. It has no disks which is typically a challenge with the 36xx machines, but I do have a way to breath-of-life and IFS it with a new disk thanks to having running sibling machines. It will be available for visitation in the Seattle area when restoration work completes. I'm targeting June. - Ian - @tr1nitr0n on Insta and Twitter
Yeah, I understand that; I'm just wondering what the inherent latency is with local JSON RPC over websockets; Using LTK on localhost, I found the latency to be too high for some applications.
cool
Tankan (a Windows tool for memorizing Japanese characters) is written in Common Lisp, compiled with CCL. http://www.kylheku.com/tankan/ I found CCL very robust. And fast. The way I use Tankan myself, I sometimes generate tests containing more than 1000 kanji in one page. The HTML is generated by a giant Lisp backquote expression that constructs a nested list structure, which is then HTML-ized and fed to the browser. Tankan relies heavily on the Common Lisp circle notation to save the user's state to a file in a detailed way (when the user uses the save state button). Not only does it record all the object relationships but also saves space. Custom CLOS print methods help to further save space by printing only the relevant parts of certain objects. With the exception of some onLoad handler to focus the keyboard to the first item of a test, the Tankan UI uses no JavaScript whatsoever. Yet it has features like collapsible sections. These features work by form submission: when you click a `[-]`, the form is submitted to the web server running inside the CCL executable. It recomputes the entire page, with that section of the UI rendered out and the `[-]` replaced by a `[+]`. This happens so fast, you're almost fooled into thinking it's just in the browser. This approach has the advantage that since aspects of the UI state are in the application, and the web page rendering is dumb, it gets properly persisted. Also, if you just close the browser window (or the entire browser), re-open and re-navigate to the application, the UI is exactly how it was before. Not all of Tankan is in Lisp. The tiny System Notification Area ("Tray") control program was developed in C++ with Visual Studio. Not that it couldn't be done in Lisp, but it was a good refresher to work in that environment a little bit again after many years. The control program launches the main Lisp executable using `CreateProcess`, using Win32 pipes for its standard input and output. There is a thread which parses the output of the executable coming out of the pipe (all low-level Win32 calls), which is how the control program learns about the URL which it can then use to launch the browser (using `ShellExecuteEx` IIRC). We don't always get the preferred port number, so this can't be hard coded. Speaking of Win32, Tankan makes some raw Win32 calls. For instance, the licensing code uses `GetAdaptersInfo`, which is not an easy API to use even from C (look at the MSDN sample: you get a buffer full of structures which form a C linked list you have to walk, and the buffer may not be big enough to hold them all, etc). I transliterated this logic into CCL. 
Yeah, could very well be more trouble than it's worth. I was just exploring the possibilities. In this way the CL part would just be like an other C shared library to use from Python, but oh well. On my own I would just use CL, but I'm working with someone that uses Python. I know some Python and like it, but have been really obsessed with lisp and love programming with it.
Land of Lisp is a lot of fun, very enjoyable book! This one looks to be aimed at a higher level, so should be a great followup.
He never said it was stated, but rather unstated. I.e. "No, I have no such requirement, which is the main reason it is not stated". :)
http://zeniv.linux.org.uk/~ober/report.html is the raw values. 
What is the y-axis supposed to be? All my guesses were defeated by the presence of negative y values!
If you look at the above link you'll see the -1 appears to be the cases where the test did not complete.
That explains what the negative values are. Does the link say anything about what the positive values mean? I couldn't find any information. I'm guessing it's either runtimes in some unit of time, most likely seconds or minute, or it's a multiple of the runtime of some reference implementation not included in the charts.
Probably, you should look at Hylang. It has amazing interoperabilities with Python. 
game-print2 should use tweak-text2, otherwise the arguments are out of order. tweak-text2 should make recursive calls to tweak-text2. this probably wasn't your problem, but it's the only thing I saw. EDIT: include the error message for more helpful feedback.
I don't really see a difference, could you elaborate?
&gt; The function COMMON-LISP-USER::TWEAK-TEST is undefined. TWEAK-TEST? Shouldn't that be either TWEAK-TEXT or TWEAK-TEXT2?
It should, that was the error all along. Sorry for wasting your time.
I've deployed a couple of GUI applications with [Qtools](http://shinmera.github.io/qtools/) on Windows before. SBCL tends to work just fine, but there have been rare occasions of strange bugs and problems with it that CCL did not have. CCL is a fine implementation that is quite fast, and especially shows its strength when it comes to compilation speed and compilation memory usage. However, SBCL offers core compression, which can significantly reduce the size of the resulting binary, and usually compiles to faster code, which may or may not be an issue. Thus my recommendation is to work as follows: develop with CCL if you have to work on Windows directly, and deploy with SBCL if it doesn't show any strange behaviour with your application. I cannot recommend CLISP, simply because my very limited experience with it has not been great when it comes to features that are outside of what the standard defines.
Lol. Rpc. Fuck u and your RPC.
Exciting times. "...we discuss the most important improvements in ASDF versions 3.2 and 3.3. ASDF’s ability to deliver applications as a single executable le now allows the static linking of arbitrary code written in C..." Thanks. Let's hope they will offer good quality video afterwards.
If you have problems with it, especially when it comes to viewing it on mobile, please let me know or [file an issue](https://github.com/european-lisp-symposium/els-web/issues).
Looks jolly good. Thanks!
Dude. Thanks for writing a tutorial on this
To effectively obtain help with a piece of code, always include: * the code itself, required to reproduce the problem. * the input cases which reproduce the problem. * the desired output, described as precisely as possible. You've changed the code relative to the book, so the original requirements don't apply. When you say it doesn't work, you mean "it doesn't meet my changed requirements". Unfortunately, nobody knows what they are, short of guessing, and nobody has the input that you're feeding to the code which causes it not to meet your unstated requirements. You have some mingling of the book's code and your own. To isolate this problem, start with a blank Lisp image and load only your own code. Then fix the references to nonexistent functions. You can avoid this sort of problem by avoiding the scatter-brained Lisp approach of just sitting in an image and throwing new dollops at a ball of mud. Always put code into files and have a load procedure that re-starts a fresh image and loads your files, so that you have a known state. Software engineering is all about image, like Hollywood. Don't you watch Entertainment Tonight? Use version control on the files so you can do a diff at any time to see what you have changed. 
Eager to attend ELS, had I much allowable research funding...
The [SageMath](http://www.sagemath.org/index.html) project does exactly this. They use ECL to run macsyma, and it is all controlled via python. The [manual](http://doc.sagemath.org/html/en/reference/interfaces/sage/interfaces/lisp.html) describes how to call ECL from sage.
&gt; ASDF 3 can reduce this latency by **delivering a standalone executable that can start in tens of milliseconds**. However, such executables each occupy tens or hundreds of megabytes on disk and in memory; this size can be prohibitive when deploying a large number of small utilities. One solution is to deliver a “multicall binary” à la Busybox: a single binary includes several programs; the binary can be symlinked or hardlinked with multiple names, and will select which entry point to run based on the name used to invoke it. Zach Beane’s buildapp has supported such binaries since 2010, but buildapp only works on SBCL, and more recently CCL. cl-launch, a portable interface between the Unix shell and all CL implementations, also has supported multicall binaries since 2015. &gt; By ASDF 3.1 run- program provided a full-fledged portable **interface to synchronously execute commands in subprocesses**: users can redirect and trans- form input, output, and error-output; by default, run-program will throw CL conditions when a command fails, but users can tell it to :ignore-exit-status, access and handle exit code themselves. &gt; ASDF 3.2 introduces support for **asynchronously running pro- gram**s, using new functions launch-program, wait-process, and terminate-process. These functions, available on capable imple- mentations and platforms only, were written by Elias Pipping, who refactored, extended and exposed logic previously used in the im- plementation of run-program. With run-program and now launch-program, CL can be used to portably write all kind of programs for which one might previously have used a shell script. Except CL’s rich data structures, higher- order functions, sophisticated object system, restartable conditions and macros beat the offering of its scripting alternatives &gt; Fixing the build model in ASDF 3.3 led to **subtle backward- incompatible changes**. Libraries available on Quicklisp were in- spected, and their authors contacted if they depended on modified functionality or abandoned internals. Those libraries that are still maintained were fixed. &gt; Finally, a concern for users with a large number of systems avail- able as source code was that ASDF could spend several seconds the first time you used it just to recursively scan filesystem trees in the source-registry for .asd files — a consequence of how the de- centralized ASDF system namespace is overly decoupled from any filesystem hierarchy. Since 2014, ASDF provides a script tools/cl- source-registry-cache.lisp that will scan a tree in advance and create a file .cl-source-registry.cache with the results, that ASDF will consult. Power users who use this script can get scanning results at **startup in milliseconds**; the price they pay is hav- ing to re-run this script (or otherwise edit the file) whenever they install new software or remove old software. &gt; In the future, there are many features we might want to add, in dimensions where ASDF lags behind other build systems such as Bazel: support for cross-compilation to other platforms, repro- ducible distributed builds, building software written in languages other than CL, integration with non-Lisp build systems, etc. and there is more. Actually all the 2 pages are interesting :)
&gt; Just so you know: there's no reason that EQ would return T for character comparison Umm well it does, unless I'm misunderstanding you.
'An implementation is permitted to make "copies'' of characters and numbers at any time. The effect is that Common Lisp makes no guarantee that eq is true even when both its arguments are "the same thing'' if that thing is a character or number.' -- http://www.lispworks.com/documentation/lw51/CLHS/Body/f_eq.htm Just because a flipping a coin 3 times turns up tails does not mean the 4th one will be tails. Learn to read the manuals and specification instead of shooting from the hip. Just so you know: there's no reason that EQ would return T for character comparison. 
Because of something specific to the Symbolics PSU or just the aging of electrolytics in general?
"Easy Mode" is true freedom. We will be running the first "Hard Mode" jam towards the end of the year, which will have a theme (and less time allotted)
Sure, if it is a Lisp. Consider joining the #lispgames Freenode IRC channel if anyone has anymore questions.
Cool, I'll join! Seems like a super fun event, I'm happy I saw this post. :)
The point is that it's not *required* to. Just because it works for you right now doesn't mean it won't stop working for you if your Lisp implementation gets updated or you switch to another one.
According to https://wiki.qt.io/Qt-Version-Compatibility minor releases are backward compatible with both API *and* ABI. If ABI is compatible, then there is no reason, why they wouldn't be incompatible I suppose.
Are you guys aware this clashes with Ludum Dare?
Yes, and while unfortunate, we don't believe it affects LGJ much, especially considering how long "Easy Mode" runs.
The values are from cl-bench. It appears to be time. The results have been rerun on linux with latest releases.
Really beautiful piece of art :-) I like all of them. Also very happy to see JSCL in that list! Does anybody know how to contact the author? I would be interested in adopting the logo as the official JSCL logo.
Wow, very nice! Is is published anywhere? instructions to build it? 
These are excellent. The MKCL logo makes me want to use MKCL.
Do you have any kind of sources? svg perhaps? I suppose I can just extract SVG from the pdf as well.
And - if you mean just the JSCL logo, I will be able to recreate it in SVG if you want me to.
Btw, guys, I've rasterized this lizard to SVG here: http://40ants.com/projects.html
Site not responding for me. Reddit hug of death? EDIT: just got "Failed to load PDF document" after a long time.
No problem, I can also use the raster graphics. Thanks.
https://kek.gg/i/5Npz6g.png 4000x4000, that's as high-res as I got it.
currently, I works to 'cl-shadertoy'(clone shadertoy based cl), then I will post here :-)
Sort of old news at this point.
`#lisp` is pretty good for trivial questions in my opinion despite there existing a `#clnoobs` alternative, there's `#lispcafe` that's pretty good for socializing and sharing links, but I totally agree that Discord has superior voice chat qualities when compared to IRC. Count me in!
Could be interesting but need more context to know if it's worth downloading. What makes it different?
Great, it's always nice to see someone willing to target the 'less glamourous' lisp dialects.
It's 403 Error - Forbidden for me.
Cool. Source code was rather readable.
What's wrong with Discord? I've only just learnt of it. Seems like an MTV-generation IRC...
So I gave it a spin, but like Slack it hits my CPU *way* too hard.
Skimming the [spec](http://www.islisp.info/Documents/PDF/islisp-2007-03-17-pd-v23.pdf), here are a couple of salient things ISLisp does differently than Common Lisp: **+** everything is lexically scoped by default. You have to use `defdynamic`, `dynamic-let` to define dynamic variables, and even `(dynamic x)` to access them **+** sane `equal`. In ISLisp, `(equal #(1 2 3) #(1 2 3))` → `t`. There is no useless `equalp`. **-** no `&amp;optional` or `&amp;key` in lambda lists **-** no `defsetf` &amp; Co., `macrolet` or `symbol-macrolet` **-** no reader macros **-** no packages or any kind of module system Besides that, they are quite similar, with ISLisp missing a lot of functionality Common Lisp has built-in but doesn't need to. Some of the missing things are `loop` (it has `while` and `do` (named `for` here)), association &amp; property lists, structs (but it has an object system like CLOS), hashtables, sequence functions (some are defined just for strings), a `format` with more features... 
https://about.mattermost.com
...or this one. Not sure if it has clients for iOS or Android though.
One very minor problem I noticed with Clisp and CCL when run on the Windows command line is that if they output anything to the command line window, leaving it at a character position other than the beginning of the line, they output a newline on exit from the program. So you can't use a Clisp or CCL Lisp program to output part of a line of text to the command line window, but only whole lines of text. SBCL on the other hand works fine for outputting part of a line of text, and letting other programs output the rest of the line. This is for usage in a script that invokes various programs in addition to the Lisp program. But this was some time ago, and, for all I know, the present versions might behave differently. Overall, I'm impressed with the quality of SBCL's operation on Windows. But I saw a rumor, which might or might not still be true, that you shouldn't use SBCL for multithreaded programs on Windows. But one thing that seems to work very well is using it for scripting. You can write scripts that start with "#!sbcl --script" or something like that, and they run fast when invoked from Cygwin Bash. If the script doesn't do a lot of work, you can invoke it in a loop, about 25 times per second, on a typical PC. Most of the time spent by a short script is in starting up SBCL. Compiling the script is a small fraction of the time consumed by starting up SBCL. (SBCL compiles everything, even when using it interactively, but it compiles very fast.) But since you can typically start up SBCL 25 times per second, the startup time not a problem for most usage. 
Make sure you get the 64-bit version of Lispworks, to take advantage of the memory available in modern PC's. What specific problems have you had with SBCL on Windows? 
Have you had any problems with it that you've had to work around?
[Yes](https://bugs.launchpad.net/sbcl/+bug/1267540), when porting my file sync app. Things that aren't OS-specific work pretty much the same.
I know that they posit that safe macros are pointless, but I find them legitimately great for productivity and they provide a simpler semantic model - even to humans, we recognise these values by what they are, and names are just necessary for the computer to understand it. Hygienic macros preserve that model.
https://news.ycombinator.com/item?id=14063664
You will never really grow to your potential potential (yes), if you put "hygienic" (read: arbitrary or "beautiful" just for the sake of being beautiful) limits to what your mind is capable of! Don't limit yourself beforehand this way, because you'll never know what you are able to learn, since our mind is capable of expanding itself continuously as we learn; it's basically a never-ending process, only limited by Time...
Very interesting, I will try it thoroughly. Thank you.
In my opinion, syntactic sugars like that only adds mental burden because you have to keep thinking what your code translates to.
People have been asking this for 50+ years ever since M-expressions did not take. My guess is that for the serious lisp programmers the advantages of s-expressions outweigh disadvantages. Emacs can automatically indent my code and can re-indent when I copy or screw-up. I can move up, down, over, back-over, swap, delete, insert s-expressions very easily without even looking at the code. You two examples look the same to me. I can filter parentheses in or out. Sometimes there are extraneous noise that I filter out in my mind and other times I can turn off my parenthesis filter to examine more closely the code and its structure.
But has Corman Lisp had any improvements since 2006? How does it compare with SBCL and CCL?
Thanks for that, I often find myself thinking why people like riding with training wheels in the programming world, yes you can more easily fall from your bike, but without them you can take sharper turns, and ride faster. I think that, trhough time, a lot of programmers get stuck into safe practices and safe programming languages because they want the systems to prevent them from making mistakes, the sad thing is that the systems don't guarantee that you won't make mistakes, but might be an obstacle you have to overcome to do achieve greater things. Edit: Improving readability, and completing one idea.
It doesn't matter, as long as it's consistent. Also, two-character space indentation is the future.
It's very hard to imagine a Lisp​ program with a missing paren style bug; your indentation will go completely to whack. Of course you need to use an editor that can auto indent Lisp​, but unless your preferred editor is notepad or ed I can't really see that as a real issue. The parens don't get in the way at all. Since Lisp gets indented automatically to reflect nesting, you learn to ignore closing parens at the end of a line. If it really bugs you that much, you can have your editor hide them. The advantage of having parens is that you don't have to worry about formatting at all. You can insert newlines anywhere or remove them and the code automatically gets indented to reflect the nesting. Using sweet expressions would make me responsible for formatting the code. That's the mindset of inferior programming languages; in Lisp, we make the computer do the dumb work. 
This is a ridiculous train of thought. You're basically advocating for leaking implementation details of a macro to the macro user - they can no longer treat it as an abstraction because if a variable is in scope that happens to have the same name as a variable used in the body of the macro then they can get compilation exceptions or worse - subtle bugs. I agree that you shouldn't bake hygienic macros into the language, they should be implemented in user-space on top of unhygienic macros (as they are in Racket), but saying that _no-one should use hygienic macros_ is absolute crazy-talk.
As I said, hygienic macros can only be useful in a domain where you're likely want to avoid using any macros at all. Honestly, I never had a singe case where I wanted a hygienic macro. Sharing the name scope with an outside code is a feature, and users always expect it to work.
&gt;rearranging scopes taking more keystrokes It takes less keystrokes because of the parens (although of course I am assuming a reasonably powerful editor). For example, all of the following take one keystroke (possibly with some configuration of your editor): "Invert" (if a (if b thing)) (if b (if a thing)) "Raise" (if a (if b thing)) (if b thing) "transpose" (thing a b) (thing b a) "slurp" (thing (foo a) b) (thing (foo a b)) "barf" (thing (foo a b)) (thing (foo a) b) "unwrap" (thing (foo a b)) (thing foo a b) Can you do the same with sweet expressions? Sure! Just parse the sweet expressions into a parse tree (also known as sexps), do the same transformations on the sexps, and reformat the sexps back into sweet expressions. &gt;I would say the readability improvements are worth it Subjective, I find sexps to be more readable because they're simpler. More syntax is harder to read; just ask Perl. &gt;arbitrarily being able to use any function in infix notation allows for making code that reads like English Code isn't English. I see that as a huge negative. &gt; and the indentation formatting allows anyone to instantly be able to read most code S-exps are indented intuitively. As you say, semantically s-exps and sweet expressions are equivalent, sweet expressions just add a lot of syntactic overhead for questionable gain. &gt;Also, your automatic formatting comment could also apply to C-family syntax. Sort of; non-Lisp languages are much more semantically limited than Lisp so it’s kind of comparing apples to oranges. (foo (if a b c) (if spam eggs (mapcar #'cook food))) vs foo(if (a) {b} else {c}, if (spam) {eggs} else {map(cook, food)}) Yeah, that doesn't really work, does it? (Ternary expressions doesn't count since control structures in C-like languages aren't expressions, unlike Lisp.) 
I like to use macros to make Lisp syntax shorter and neater. E.g. to reduce the number of levels of code nesting that cause code to go across the page, by combining some of those levels into macros with shorter, neater syntax. I also used macros with CLOS objects for invoking the Microsoft Windows API with much simpler, shorter, neater code than implied by the details of the API. People new to Lisp see a lot of verbose complicated Lisp code and are put off by it. But once you learn how to use macros you can make the code simple and beautiful to your own standards, whatever those standards might be. I also make my code easier to maintain, to the point where I hardly ever have to look at a backtrace or do any run time debugging, but just look at error messages generated by my own kinds of assertions etc., and can usually tell what to fix from those. I usually keep backtraces turned off, but can turn them back on any time I need them. 
The thing to remember is that you can probably read both right away because you are used to s-expressions, but to somebody that is just learning, and is thaught with sweet expressions it he has to make the mental switch, which of course becomes increasingly easy, but you have to learn both. I could write my code using [cl-2dsyntax](http://hyperprostor.g6.cz/lisp/cl-2dsyntax/), too or anything anyone else can cook, and teach someone to write like that and she would need to get used to s-expressions too if he needs to edit an exising library. So you can use those things, but since you took the time to learn sex-p first, and it became second nature, then there is no need to go to a different syntax. Of course that is debatable, but that is the point I was making about "already written code" which also applies to "already written literature". If you don't learn with sweet expressions since the begining, and you have to move back an forth, that is a **possible hypothesis** of maybe why it did not become wide spread. 
I didn't notice the first time so… it's a comment on the post about Radiance: https://news.ycombinator.com/item?id=14063664 
I don't really think parentheses are a barrier. I know people say they are, but I think the real barrier is expression-oriented programming. The parentheses are accused of being the problem because they are used to define the expressions. Anyone coming from a language that has distinct statements and expressions (myself included) takes a long time to get used to it - assuming they persist. But then something magical happens and you realise that statements are a wart and having everything be an expression makes it so much easier to express your program. Once you 'get' expression-oriented programming the idea of sweet expressions seems pointless, and beginners don't benefit from sweet expressions because it's still programming with expressions.
I don't know if I agree, I was already familiar with expression-oriented programming from Haskell and it still took me a while to percolate into using Lisp because every time I looked at code it seemed like line noise. Of course, once I started writing it it became second-nature, but I still find complex expressions hard-to-read as sexps that are much clearer with indentation sensitivity
That's a really good point, and in fact sweet-exps require just as much editor support (in vim, `d%`/`p` is replaced with `dd`/`p` and `&gt;&gt;`/`&lt;&lt;`). C-style function application syntax is the worst though 
FWIW, caveman2 worked perfectly for me on a Windows machine under SBCL (a few years ago). What are your actual error messages? There's basically zero information for anyone to help you.
People always say "readable" when they mean "familiar." I don't have the world's best eyesight. I'm pretty sure that Lisp is, objectively, the most *readable* family of programming languages. Sure, Lisp uses lots of parentheses. But, more importantly, Lisp favors named functions over cryptic symbols, it favors long names over short names, and it uses nesting to show structure. By contrast, Haskell uses whitespace. But it also uses cryptic symbols everywhere, it favors short names, and it bends over backward (monads) to avoid nesting. Parentheses are just information. If they bother you, you should be able to set your editor to hide them. Just like sometimes, when I'm editing or reading Makefiles, or Python, or Haskell in Emacs -- sometimes I turn on whitespace-mode.
I JUST FOUND OUT THAT IT HAS DOOM AND QUAKE WOAH
of course, why not?
Cool! I really like that one of the first examples is a game, and not "guess a number", but a more complex one with graphics using SDL and input, embeddeding Dern into C, etc.... keep it up mate! BUT: why did you choose brackets instead of quotes for strings? 
'llvm 3.2 to 3.5' *rolls eyes*
Systems programming language... not used to implement its own compiler. I'm just slightly skeptical.
It's more of a VECP
Thank you for the kind words :-) Brackets [ ] were chosen as string delimiters instead of double quotes " " so that Dern code can be embedded in C-strings without escaping. Single quote ' was already "reserved" for quoting values; and because characters in Dern are delimited with | | (for example |h| and |newline|) the resemblance between [ and | led me to choose [ and ] for strings. As a mnemonic, to remember which of [ and | is for strings, I use this: "strings can be much larger than characters and need a stronger cage" :-)
Check out this part of the release notes: "Trentino, a media player, has been implemented by Eugene Zaikonnikov. Further improvements to conformance, stability and performance. The CLOS implementation follows the MOP much more closely. More traditional window management. Booting from CD/USB on real hardware is now possible. Driver support for Intel HDA audio devices. VirtualBox guest (mouse &amp; display) integration." Notice especially the part about booting to raw hardware via cd / usb? *EYES POP* Froggey is the best. Kudos to everyone that contributed to this, it is very impressive. 
I would like to know what the dependencies are, separated by build time and run time: what environment does a Dale program need to process the S-exp stuff, what do Dale programs need at run-time, and is there an intermediate form (like, say, generated C) that can be built with fewer dependencies (and what are they?).
I could see it via the C api... but doing it via the c++ one would be a nightmare.
I think you opened that in an unnecessarily hostile way. I agree that they _shouldn't_ be a barrier to entry, but there's no doubt that they _are_. Don't get me wrong, I do like using sexps too, but I would say that at this point, on balance, I prefer whitespace-significant syntax. There is absolutely a doubt as to which sexp an atom belongs to, I can always read sexps just fine in my editor with rainbow parentheses and bracket matching, but when I read code samples in blog posts which have no syntax highlighting it's often the case that I have to stare at it for a couple of seconds before understanding it.
Hylang deserved my attention, because it has great interoperability with the Python — my main language on a day job. So, why do you think yet another, written from the ground lisp deserves people's time?
you worry about games? PicoLisp have chess engine and fly simulator in distro.
I would be more impressed if this was mature up to the point to leave out this childish, killler-masturbation stuff... edit: is it really so hard to understand what I mean? "First person shooters" are the worst computer games ever; Mezzano is great and all, but showing off a demo which main part is a... "first person shooter" stupidity, really makes me sad about the current youngster Lisp generation...
&gt; this childish, killler-masturbation stuff... What?
You're right that RMS initially was trying to use a compiler written in Pascal as the base for his GNU compiler. But apparently he gave up on that, and wrote his own. https://gcc.gnu.org/wiki/History#The_Early_Days
L++ | https://bitbucket.org/ktg/l
It's just trolling, no need to pay attention. Mezzano Demo 3 is really impressive
inb4 Lisp syntax with Lisp semantics
It doesn't have to do anything special, it's not forcing you to use it, or not use any other language, it can exist for no reason other than 'the author wanted a language that started with the letter D' and it's still got a right to exist.
Sorry if it was inappropriate. I wanted to point out some interesting project similar to another one that was posted recently.
While it's technically correct to use the phase "Lisp syntax with C semantics" to describe C-Mera, it is a bit too oversimplified and vague. First, it might be worth emphasizing that C-Mera is **not** a new programming language, nor a Common Lisp-to-C compiler that automagically compiles any Common Lisp programs into C source code. Rather, it is a compiler that transforms a set of s-expression-based, C-like **domain-specific languages** (DSLs) to the native syntax of that language. The primary usecase of C-Mera is for code generation, i.e. you use the DSLs to define a pattern/template of C/C++ code that you wise to generate. I've tried out C-Mera before, and really like it. Since the DSLs are all s-expression based, you can use CL macro to do some really fancy thing with it.
Reminder: The game jam is set to begin this weekend. Enjoy :)
It's been open-sourced since. Look on github :-)
froggey has made an emscripten-like transpiler that takes the LLVM IR produced by clang and translates it to Common Lisp. That's then run through a Mezzano-based equivalent of SDL that provides a framebuffer and handles key events.
[removed]
Ok. No one except author, will use the language with such approach. Good luck. 
No real worries, it was only 3 link-only reposts in quick succession. which made me curious. Have there been any developments you have found interesting in the year since it was last on r/lisp?
Yes, sure, if I am redefining `car` locally I absolutely expect things to break. It's a feature. In extreme cases I will redefine fully qualified function names (which is exactly what macros must expand into).
Non-hygienic `push` or `pop` macros, or other syntactic sugars, will not necessarily just break on `car` or whatnot being redefined. How about `(pop (aref x y))`; what if that just expands to: (LET* ((CELL (AREF X Y))) (PROG1 (CAR CELL) (SYSTEM::AREF-SET X Y (CDR CELL)))) Screw anyone who has an occurrence of `CELL` in either the `X` or `Y` expression. Screw anyone who has side effects in `X` or `Y`; let them happen twice. If the value of expression `Y` changes such that it references a different slot of the array, too bad. And why are we being so nice with the single evaluation of `aref`. Might as well be: (PROG1 (CAR (AREF X Y)) (SYSTEM::AREF-SET X Y (CDR (AREF X Y)))) Hey, `CELL` is now gone, so one problem is solved. The more evaluations of `X` and `Y`, the merrier. The `car` being redefined problem, the one problem not solved by the typical macro writing in a Lisp-2 dialect like CL, is the least of our problems. We can have the implementation issue a diagnostic when `car` is redefined, locally or otherwise. For user-defined functions, namespaces solve that problem. I'm calling `kaz:foo` in my code; your macro expansion uses `combinatory:foo`. All is cool. 
That is indeed how you might implement syntax sugar macros if you do not have hygiene as a requirement whatsoever. What's the problem? You don't want hygiene, and the above doesn't deliver it. 
Sometimes we want a macro to be documented as binding specific identifiers. Other times we want a macro to refer to some documented identifier which doesn't appear in the macro call, but is implicit in the expansion. Those are features. That very same macro might have other identifiers for its own use which must be hidden. That is also a feature. You cannot write non-hygienic macros properly without control over hygiene, because deliberately non-hygienic macros only make certain specific references or definitions non-hygienic, not *everything*. Whether or not they have documented non-hygienic features or not, you cannot properly develop complex DSL's without hygiene. You may be able to prototype them that way, but it's not production quality.
Macros are only usable at compile time. When a macro is called, the compiler provides an additional implicit context argument, which can be used by the macro to allocate memory and to call the introspection functions made available by the compiler. Since macros can't be called at run time, no additional support is needed during execution. There is no intermediate form that can be built with fewer dependencies.
Thanks for the article! It's very cool to see the implementation explained in such a detail
Hey again, you may find this very interesting: https://shaunlebron.github.io/parinfer/#editor-plugins it's a new mode to help write lisp, and it exists for various editors.
I think continuations are meant to be a primitive of the language which things like exceptions, green threads, and conditions could be built off of. Continuations store things like the call stack, the environment, etc. Promises are more meant for handling asynchronous communication. They seem like a reorganization of callbacks from what I can tell.
I did a toy implementation of shift and reset in CL a long time ago: https://gist.github.com/ruricolist/4506465 I only mention it because I did it so I could implement monads. You can start from either end. Incidentally, the implementation linked to makes a mistake a lot of Scheme implementations make: it fails to implement the correct "small-step reduction semantics." E.g. ``` (reset (with-output-to-string (*standard-output*) (shift k (print "Hello")))) ``` Should evaluate to `"Hello"`, because the function should be evaluated directly in the dynamic context of the nearest enclosing `reset`. The linked implementation evaluates to `""`. You can read about the problem at [okmij.org](http://okmij.org/ftp/continuations/against-callcc.html#traps).
[Discussion on r/programming](https://www.reddit.com/r/programming/comments/65jol7/iota_common_lispemitting_backend_for_llvm_xpost/) [Discussion on Hacker News](https://news.ycombinator.com/item?id=14120802)
It was used to compile Quake and Doom to run on Mezzano, a Common Lisp operating system.
The scripting language TXR Lisp is a Lisp-2 heavily influenced by Common Lisp, which has delimited continuations as a feature: http://www.nongnu.org/txr/txr-manpage.html#N-01C4E6B4 TXR Lisp introduces an innovative, pragmatic way to integrate unwinding with continuations, without replicating the `dynamic-wind` operator from Scheme.
A promise is basically a function (perhaps a sugared-over lexical closure) along with a caching mechanism so that the closure is only called once, and then the same value is just replayed if the promise is queried for the value. Here is what you can do with a delimited continuation: This is the TXR Lisp interactive listener of TXR 174. Use the :quit command or type Ctrl-D on empty line to exit. 1&gt; (defun lower () (let ((val (suspend my-prompt my-cont my-cont))) (put-line `returning @val from lower`) val)) lower 2&gt; (defun middle () (prog1 (lower) (put-line "returning from middle"))) middle 3&gt; (defun higher () (prog1 (middle) (put-line "returning from higher"))) higher 4&gt; (block my-prompt (higher)) #&lt;intrinsic fun: 1 param&gt; 5&gt; (call *4 42) returning 42 from lower returning from middle returning from higher 42 Why does `(block my-prompt (higher))` return a function? Because that's what the `suspend` form in the `lower` function does. It captures the continuation into the `my-cont` variable, and then that is specified as the result of the `suspend`. Then `suspend`takes this value and throws it up to the `my-prompt` block. When we call the function via `(call *4 42)`, we resume the continuation. What immediately happens is that control passes back to the `suspend`. This time, all that the `suspend` does is appear to terminate normally (inside the resumed continuation), and return the value `42` which initializes `val`. The continuation keeps merrily executing. It returns from all three functions all the way to the `(block my-prompt ...)` prompt, from which the `42` value bubbles up. We could build a "delimited-continuation-empowered" promise mechanism. Instead of sugaring a caching mechanism over a closure, we could do it over a delimited continuation. Both are functions, after all. Definitely, if we have some task that is split into two steps (for instance because it has to wait for I/O to complete), we could apply continuations to it to be able to do things we cannot do with closures. "I promise you a value returned by later resuming a slice of my computational future" versus "I promise you a value returned by later evaluating this expression in the original scope here". 
thanks for the post, good demonstration.
What kind of security/privacy features does it have?
This looks good! There is a lot of value in projects like this, not only in the complete application, but also in code examples for front end to back end communication, using S3, Solar, etc.
It's open source, and you can self-host it. So the system certainly doesn't do anything with your private data (other that storing it on the server, of course). That said, we have had plans to add encrypted conversations to the system, but it's complicated. The whole concept is based on all conversations being recorded more like a shared document, which can be searched. Adding encryption would defeat this, and for that I'm not sure Potato would be the best solution. If you can explain in more detail what you expect I'd be happy to explain things in as much detail as you wish.
Hi ! So you went with ClojureScript. How has it been going ? Did you consider Parenscript ? What were the pros and cons ? (that would make a super useful blog post IMO :) In general I hope you'll write more blog posts, they're super welcome).
&gt; Whether or not they have documented non-hygienic features or not, you cannot properly develop complex DSL's without hygiene. What?!? Hygiene makes it nearly impossible to develop complex DSLs. It's too big a limitation. 
You seem to be replying to a statement which asserts that DSL's must be totally hygienic. This part of my quoted sentence was intended to to make it clear that no such statement is being made: *"[w]hether or not they have non-hygienic features or not ..."*. 
No, I'm explicitly claiming that hygienic macro expansion *in the host meta-language* makes development of even a mildly complex DSL nearly impossible. No matter what the nature of this DSL is - just by limiting the expansion options.
The usual use of `gensym` in macro in fact constitutes an attempt to improve the hygiene. The programmer wants hygiene and is using `gensym` to get some of the way there. Such a partial attempt counts as some sort of substitute for hygiene, since some is often better than none. When you're using gensyms, you're "doing" hygiene. Assiduous use of gensyms, together with some additional tricks, can in fact implement complete hygiene, across both the function and variable namespaces. Gensyms only fail to be a substitute for hygiene to the extent that they not used, or incorrectly used, either of which is not a problem with gensyms *per se*. 
You seem to have a far too broad definition of a hygienic macro expansion. What I refer to is a system which demands that each s-expression origin is known (i.e., marked with its expansion stage), meaning that no macro expansion can end up in a non-canonical AST form, limiting severely what you can do with macros. Gensym and alike totally irrelevant, this is just a macro implementation detail which does not enforce anything on a macro *expansion* engine. If you have a bailout route with a hygienic engine, it still enforces its limitations - e.g., you cannot have an unusual expansion order (and it is often very useful to expand selected macro arguments first before expanding the outer macro).
Nope; I simply have **everyone else's** definition of "hygienic", rather than your personal one. https://en.wikipedia.org/wiki/Hygienic_macro "Hygienic macros are macros whose expansion is guaranteed not to cause the accidental capture of identifiers." 
Hiello again! Any news on the next (4th) video of the series? Thanks! :)
I recommend the alt.folklore.computers Usenet newsgroup.
Thank you! That could become a great resource, especially since you can refer to the sources by their names.
cool. does ABCL has succeed stories?
it has - ELS'16 has such a story in its lightning talks.
See http://www.european-lisp-symposium.org/static/2016/lt2.pdf "Illithid" by Mark Evenson
&gt; Native GUI apps: Difficult Depends. The author seems to have a *slightly misadjusted* definition of "native". As far as I know, there are no maintained native GUI toolkits for e.g. Python as of now, only *natively looking* ones. If we drop the "native" aspect, GUIs in Common Lisp are [not "difficult"](https://common-lisp.net/project/mcclim/) at all.
Those are slightly more *difficult* to use though (at least according to my own perception).
I'm a Common Lisp fan, but I feel the author's stated reasons for dismissing Ruby and Python are weak. &gt; "I disqualified Ruby and Python because of two issues. First is that building standalone executables is not a viable option." I admit I've never needed to package my `.py` and `.rb` applications this way, but a quick Google suggests there are several options for creating standalone executables (and installers). Is this wrong and truly "not viable"? &gt; "Second is that perfectly working code will eventually need major modifications just because the language standard has changed." Well that's just false. Perfectly working code, particularly if it was bundled as a standalone executable (see above!) remains just that: *perfectly working code*. This is independent of new versions or changes to a language standard. The author is a C expert. Would he ever say that his C99 codebase is broken and requiring "major modifications" just because C11 is now available?
Every few years when I write Ruby on Rails code, I have to relearn all the libraries. I don't know if Ruby itself changes that much, but its libraries change way too frequently
The author states this project requirement: &gt; 4) The client-side program must be a single, standalone executable binary or shared library. Multi-file distributions will complicate the installation procedure and increase support issues.
Screenshots! http://i.imgur.com/D0sJJKR.jpg
If anyone's interested I've wrote an [MQTT client implementation](https://github.com/ivan4th/cl-mqtt) in CL some time ago that doesn't need Java. It uses cl-async. Well, it probably has some bugs, and I didn't update it in a while, but it works most of the time from my experience
Not only are pyinstaller, py2exe, cx_freeze etc. hard to use, but they also have little to zero support for when things don't work. The pyinstaller IRC has been dead for months now.
c99 is valid c11; python 2.3 is not valid python2.7 is not valid python 3.0
Wow, that's one heck of a comment! This gave me a lot of inspiration (and sources) for writing about. Especially deviating from the typical mainframe and to the minicomputer is a great idea!
I used pyinstaller with Qt to deliver single executable GUI application. Zero problems.
From my experience racket memory footprint is roughly the same as sbcl. 
I should have mentioned it in the recipe, I'll add it. This article uses some code which I had made some time ago and at the time I hadn't found anything in CL; still, the idea was to use an example and I have something lined up that shows how to use Jetty using ABCL, something redundant since we have huchentoot, clack, etc, but there are some interesting points which are easier to explain with such examples.
Technically, c11 made c99's requirements for Variable-length arrays and &lt;complex.h&gt; library optional, and removed `gets`
and I suppose it is that easy with webapps too (that will run locally), nothing more complicated like it is with pyinstaller with django, because launching a webapp is something like `(clack:clackup :port 8000)`. Real world examples would be nice though.
build sbcl with --with-sb-core-compression then save your executables with something like: `(save-lisp-and-die "my_executable.exe" :executable 't :toplevel #'my-entrypoint :compression 't)` Drops a 45MB executable to 13MB here upx could, in theory, get the same image to 11MB, but it fucks with the core image too much for sbcl to work, I haven't tried any other executable packers, but I imagine they cause the same problem. edit: gzexe doesn't destroy the sbcl .core integrity, and gets the 45MB executable to 11MB (but can only get the 13MB --sb-core-compression image to 12MB)
hey, I started working on them again today, so shouldn't take too long now ;)
I read the article and liked it, but I think that there is always an unconscious bias when you are taking these types of decisions. I remember that when I started learning Common Lisp I was just looking to learn another programming language, unconsciously I wanted to learn Python (which I haven't done yet), but the more I read the more I heard comparisons to Lisp, and without even knowing what Lisp was I decided to learn that instead of Python. In my case I ended up not going with my feeling, but most of the time when you have an unconscious bias you need very good arguments against it or in pro of something else to change your mind. Just my two cents, I might be completely wrong. Edits: Weird phrasing LISP to Lisp.
You are correct; for some reason I thought that 2.7 no longer supported the `except Foo, e` syntax (replaced by `except Foo as e`), but they got around that by requiring parentheses for catching multiple types.
http://www.sbcl.org/manual/#Function-sb_002dext_003asave_002dlisp_002dand_002ddie `(save-lisp-and-die ... :compression 9)` There's a hit to startup time (~100ms on a modern 86oid, so no big-deal for interactive programs, but a big deal for e.g. something that will be called repeatedly in a script).
Great example. Is it really necessary to create a new client and topic for every pass through the send-loop?
&gt; The server code is Java. The front-end code is Emacs Lisp. Those two communicate via JSON. We want to incorporate Eta, a flavor of Haskell that compiles to the JVM. Isn't it more suitable for r/emacs than for r/lisp?
If I want to whip up a quick UI to test out an idea I usually use Python and PyQt because it is so easy to install and set up sudo apt-get install python2.7 sudo apt-get install python-qt4 vim myidea.py # go nuts CommonQt is very usable but feels more fiddly to setup. 
80s actually. Founded in 1984.
thanks again for the input. I demand again more feedback from an experience dev :) I just discovered [trident-mode](https://github.com/johnmastro/trident-mode.el), which aims to offer live browser interaction for Parenscript. Does it seem to you it offers the same experience as Figwheel ? 
Eh, I see racket stuff posted constantly, and that's further from common lisp than emacs lisp. This is after all of those weird little languages written by people who wanted to implement a language.
I'm using QTools right now - they're much better since many things are abstracted away.
To use it, you don't need to already be an Emacs user. smsn-mode is far simpler than Microsoft Word. To code it, you don't need to already be an Emacs coder. I wasn't. And Lisp is so intuitive that, honestly, I don't even think you need to know that, as long as you know *some* programming language.
The sheer density of brains and experience at Franz blows me away.
I'm not a Python fan, but casual testing has shown [Nuitka](http://nuitka.net/pages/overview.html) to do what it claims: &gt; Nuitka is a good replacement for the Python interpreter and compiles every construct that CPython 2.6, 2.7, 3.2, 3.3, 3.4 and 3.5 offer. It translates the Python into a C program that then uses libpython to execute in the same way as CPython does, in a very compatible way. The C pulls in all of the Python dependencies, though, so the C code is *ugly*. 
A well written article. I chose Common Lisp for some of the reasons listed by the author too. But I think the article didn't address another major problem in choosing Common Lisp: It's quite hard to scale your team. Not that I have done the scaling, but I just can't find many serious CL developer around, here in my city at least. &gt; Common Lisp’s design philosophy is expansive and leaves very little for implementors to decide. And I can hardly agree with that nowadays.
&gt; I think it's tough to generate/transpile code that isn't ugly, C or not. :-) I live in hope. Or at least code that isn't dependent on transpiler-specific libraries and headers. But that's a lot to ask, especially in the case of a dynamic language with dependencies, or libraries beyond the standard lib. In other words I'm looking for transpilers that transpile (from a variety of languages) to *maintainable* C , not just *compilable* C. But that's a big ask. Haven't looked at ECL yet, etc. 
Keep the faith. You're not alone! What you're dreaming of is smart for medium/long-term goals. But I think we live in a software world where organizations/projects think they can't afford to pay for *medium/long-* term maintainability/portability when they're faced with "critical" and "urgent" *short* term goals. So they end up with something that *works* right now but is a steaming pile of useless when your tools or platform shears away over the years. "Just rewrite it." Sigh.
Woo-hoo! ))
The dpans2texi repo link returns a 404. I've found these two alternatives, please feel free to suggest better ones: (newest commit) https://github.com/rebcabin/dpans2texi https://github.com/emacsattic/dpans2texi
Coders at Work is really good on oldskool programming and compsci with many titans of the past interviewed.
Coders at work yeah :-)? I've got that one, it's really awesome!
Indeed it is! I'm grateful to have sold Lisp's numerous advantages to management where I work at a 3rd party inspection company with deep ties to aerospace so windows is abundant. LispWorks and CCL (Emacs/SLIME) are where another programmer and I spend most of our time. We use Lisp to automate as much of our workflow as possible. One project has been successful at turning what used to be 2 weeks of painful, error-prone, human driven work across multiple programs into a program which automates most of this into more reliable results in less than one day. Lambda FTW.
What do you mean compile performance? Clozure Common Lisp is faster *at* compiling code. SBCL might have faster *compiled* code.
SBCL and CCL have best support from libraries and you should pick one of them. As jaked122 pointed out, there are two factors - compilation speed and compiled code speed. If you write in portable Common Lisp or use portability libraries[1] for things not defined in the standard, it doesn't mean much which implementation do you use for development (except mentioned support – more popular implementations gain more focus). [1] https://common-lisp.net/project/ecl/#orgheadline36
How much difference is there in the compile speed and run speed between SBCL and CCL? If it's only a few percent, it might not be worth taking into account. But other factors, such as the quality of the error messages, etc.
It's hard to get all the performance you might want out of these things. The Common Lisp type-system is complex enough that it really makes a huge difference when you declare that the arguments are a certain type. That being said, you really ought to get comfortable with the language first, and don't annotate your types until you're done making the code work in the first place.
It's also not just a few percent in the other dimension, compilation speed. My experience is that CCL has a significant advantage in both speed and memory use when compiling large functions.
Another thing to consider: SBCL's debugger has better support in SLIME, allowing restarts and jumps. Whereas CCL's debugger just shows the stacktrace. (That is, the last time I checked, it might be better now)
So for things like code that recompiles itself on the fly frequently to adapt to changing requirements, CCL might actually be preferable?
Racket is a good choice.
I just watched the video, great as expected! Interesting point that we have great tools and procedures for handling code but not so great for handling data.
Prolog? maybe not too "modern", but built around the idea of backtracking.
 (defun iterate (fn arg count) (loop for i below count collecting (setq arg (funcall fn arg)))) (iterate #'1+ 0 3) ; =&gt; (1 2 3) If you want laziness, you can check out SERIES, but that's probably overkill.
You'd have to use a lazy sequence/calling library for that. CLAZY contains an implementation of lazy lists and its associated functions. In fact it includes ITERATE in a more general form, called REPEATEDLY. https://www.quicklisp.org/beta/UNOFFICIAL/docs/clazy/doc/intro.html EDIT: To use repeatedly I had to redefine it from using DEFUN to using DEFLAZY then it worked as thus: CL-USER&gt; (repeatedly #'print "hello") #&lt;LAZY-CONS [(LAMBDA () ...) ...] {1004BBAEE3}&gt; CL-USER&gt; (take 10 *) "hello" "hello" "hello" "hello" "hello" "hello" "hello" "hello" "hello" "hello" ("hello" "hello" "hello" "hello" "hello" "hello" "hello" "hello" "hello" "hello") CL-USER&gt; (repeatedly #'random 10) #&lt;LAZY-CONS [(LAMBDA () ...) ...] {1004C6D283}&gt; CL-USER&gt; (take 10 *) (3 5 4 0 7 4 9 1 1 3) CL-USER&gt; 
CL has no lazy sequences by default, but you can emulate the taking behaviour with `DO`. http://paste.lisp.org/display/345598 Credits to shka for coming up with the code.
Wow, amazing! Thanks!
Of course [muLISP 86](http://www.din.uem.br/ia/ferramen/monoparadigmas/lisp/implementacao/mulisp/mulisp86.zip) won't qualify, would it?
Thank you! :) Do you have a user manual for it, too? muLisp86 is not bad, but mulisp-90 is more "modern", with more library functions and is more like common lisp in syntax! If someone can find mulisp-90 it would be really nice - it's always cool to preserve old software, especially old lisp variants! Interestingly, that lisp once was a Microsoft product. 
That is amazingly short for the functionality!
does that do the same thing? I thought cl iterate was something to replace LOOP.
Nothing built-in, but here's some functions for Series that do it. I didn't call it ITERATE because Series already uses that name. (defun scan-calls (function arg) (declare (optimizable-series-function)) (scan-fn t (lambda () (funcall function arg)) (lambda (a) (funcall function a)))) (defun take (number series) (declare (optimizable-series-function)) (cotruncate series (scan-range :below number))) (take 5 (scan-calls (lambda (a) (* a 4)) 1)) EDIT: I guess I solved the wrong problem... ignore my TAKE. You'd use collect-nth instead. (collect-nth 5 (scan-calls (lambda (a) (* a 4)) 1))
Does it support macros?
Agreed, maybe there's still a sweet spot for something a bit simpler than CLHS.
+ It's faster, it has optional static type annotations, it has libraries going back years, it has proper tail recursion, it has more resources, it's standardised +/- It has multiple implementations, it has reader macros \- It's a Lisp-2, it has no Java interop, it's a less finely-crafted language (it has a lot of cruft from decades of updates), there's less of a JS cross-compilation ecosystem
It's the first time in many years I see someone caring about the stillborn Arc language.
I appreciate all of your Lisp books. I just finished re-reading Common LISP Modules the other day.
2009 called...
It's not. There is an Anarki fork and few lisps, inspired by Arc. 
Proper tail recursion appears unlikely in full Common Lisp.
Introduction sounds like a bullshit. Why it is better than existing lisp implementations? What problems does it solve? Why somebody would use it? Are there practical examples?
Thanks for the suggestions!
That guy who embedded ECL to OpenFramework would have love this. :)
This is interesting, thanks. [Also of interest](http://www.genetic-programming.org/gplittlelisp.html).
Experimenting, it turns out that as long as one has maven installed and has loaded the ```abcl-asdf``` extension via ```(require :abcl-contrib)``` Then you can just write something like (defsystem :dl4j :defsystem-depends-on (:abcl-asdf) :components ((:mvn "org.deeplearning4j/deeplearning4j-core" :version "0.8.0"))) And ASDF will load deeplearning4j and all its dependencies into a loaded abcl image without needing to make a jar file in advance!
Nice work, thanks for sharing ! Maybe you can advice [Portacle](https://shinmera.github.io/portacle/) since it's the easiest way to get a working dev environment. It ships Emacs, SBCL, Slime, Quicklisp and Git in a portable and multiplatform way. 
How so? Many common lisp implementations do have proper tail call optimization whether you think it is likely or not.
You spent more time writing an inaccurate comment than actually reading the article. Most posts here are not particularly well written, so it does require some patience. Getting to the second paragraph would have helped! 
the goal is to implement one thing following the given api, so than we can compare the implementations (and optionally run the entire app with a backend and frontend of choice). &gt; We have many Front Ends and Back Ends in Common Lisp, so including all would be really laborious, to say the least. so the goal isn't to include "all", but to implement at least one example. Say, implement the backend with Caveman. And this is the (big) interest to me. Or the front with Parenscript that will talk with the api served by the Django backend. IMO CL lacks examples and success stories *in web dev*. I don't even know one little web app example using Parenscript (if someone does, please add it in an awesome list and wiki !). We may have some frameworks but they are not as full featured as the others around, and they all have few to no documentation. And getting going in CL web dev isn't straightforward (and more difficult than everything else).
Very cool. Thanks for sharing!
Have you noticed the function press-enter-to-continue not working? It looks for a zero length return to decide if enter was pressed, but it also needs to look for a carriage return character. So if someone installs quicklisp and wants it to add its stuff to .sbclrc, it doesn't actually add it, because it thinks the carriage return indicates the person did not press enter to continue. 
The *language* standard way is to put the actual control character into the string. E.g., if using Emacs, type C-q C-d to insert Ctrl-D. 
I will look at that. Is it very commonly used?
That sounds reasonable but a little messy. Do you know if there is also a standard way to concatenate literal strings so they can be on more than one line but exclude the leading whitespace of each line?
old (from 2010), but insightful: https://common-lisp.net/~dlw/LispSurvey.html
You can use format for that. (format NIL "foo~ bar~ baz") ; =&gt; "foobarbaz" If you want to retain the newlines: (format NIL "foo~%~ bar") ; =&gt; "foo ; bar"
And hey, it's smart enough to tell you what it is going to add to .sbclrc): * (ql:add-to-init-file) I will append the following lines to #P"/Users/quicklisp/.sbclrc": ;;; The following lines added by ql:add-to-init-file: #-quicklisp (let ((quicklisp-init (merge-pathnames "quicklisp/setup.lisp" (user-homedir-pathname)))) (when (probe-file quicklisp-init) (load quicklisp-init))) 
Yes, I did and it works.
On macOS and Linux, I usually use SBCL, but for one code base I work on with a ton of code, I like Clozure CL because the compiler compiles code very fast. If you don't need a lot of heap memory, the free version of Allegro CL from franz.com is very nice also.
The standard reader doesn't do that. If your happiness depends on such a feature, there is of course a *standard* way to add *nonstandard* syntax. Look into "readtables". 
My personal opinion: - Windows - CCL/SBCL - Linux - SBCL/CCL - OSX - CCL - Linux (limited memory) - ECL - FreeBSD - SBCL/CCL - OpenBSD - ECL - NetBSD - ECL - JVM - ABCL - HaikuOS - ECL - Androd - ECL Also okflo suggestion regarding Lisp Survey – great resource. 
Linux (limited memory) ARM RPI - CCL
The printed format of the CLQR (a folio folded lengthwise) is a pure joy to interact with physically. True CL samizdat. Tucks in a back-pocket! Arguably more complete than the last forty-odd pages of Paul Graham's _Ansi Common Lisp_; certainly less opinionated and more concise.
Do you mean SBCL running on Windows directly, or SBCL running in WSL?
On Windows directly, with Cygwin. The reason why I thought it might not be used was because the installation runs into the bug mentioned above. But it's easy to fix and not a problem.
If you use cygwin "bash" to compile sbcl, then you use cygwin gcc and their compatibility layer with all the deps.
Oh I get it, you may not compile sbcl itself from source using cygwin. Anyway, just throw cygwin away) And maybe this is the source of your "bug". Try installing quicklisp from windows command line (cmd.exe). Cygwin is bullshit.
I had no idea this existed, gonna have to give it a whirl this weekend.
The source of the bug is that Microsoft considers a newline to be two characters, a return followed by a newline. The bug fix is to recognize the return as an indication that the user pressed the enter key. It's a very simple fix, shown above. Cygwin is not bullshit. It makes Windows a lot more usable for someone who used Unix in the past. And in any case I already installed Quicklisp, so this issue is no longer relevant to me. 
I would prefer to check for whitespace.
Awesome work ! Please be sure to add this in the documentation out there (cliki, awesome lists,…) :)
Yes, because they might think they can use the space bar to continue, and when that doesn't work, they might then press enter and wonder why it doesn't work.
Yes. I did and it worked, if I remember correctly ?
but I did it via sublime repl because I'm yet too noob to use emacs 
I remember having a lot of problems but I feel like most of it where due to fact I never programmed before except for php and js for what I'm studying. I did not have to install quicklisp on windows 10 for a while, maybe it is a problem and I don't remember ( I drank a bit XD sorry if my comment is badly worded)
I'd do something like this `(concatenate 'string (string (code-char 27)) "[36;1m Magenta" (string (code-char 27) "[0m"))`. I don't think there's an easy syntax way to do it though. Should also be able to coerce a byte array to a string too.
I would usually build something on top of FORMAT, if using format control strings would be useful: (format nil "~C~C" (code-char 15) (code-char 7)) ~C writes characters.
BTW, I've created an TodoMVC version in parenscript some time ago. It was very fun. 
I used cygwin for a while in the past (and MKS at work). It's ok if what you need is bash, scripts, automate things, stuff like that. But if you need free tools instead of M$VC to build and *distribute* software for windows for others, everybody use mingw. So I dropped cygwin. &gt;I might dump Windows and just use Linux Probably not a bad idea in this Internet era). I am UNIX guy also, and just use windows at home historically (for games). 
You might be confusing Usenet and Google Groups.
thanks and best of luck in Weblocks' reanimation. Looking forward to hearing from you.
Thanks to RME for setting this up. I haven't done anything with Lisp Seattle since I moved away, and it always attracted a good group.
I think I'm being a noob here, but what actually is this? It claims to be an OS while having to run... on an other OS, which really makes it a userland suite of programs I'd guess. It's a network simulator with a C-like scripting language and a Lisp interpreter that runs on OSX or Linux. That's not an OS by any definition that I've heard. I think I might be being dense.
I get it a bit better now, your very first phrase was what mad it click. I must confess that I normally don't use any standard frameworks for web development, I tend to duck-tape HTML, CSS and JS manually written with some PERL CGIs on top of Apache, I may be an old dog, because I take long to learn new tricks. When I was trying to get into Common Lisp web development I found [Lisp for the Web](http://www.adamtornhill.com/articles/lispweb.htm) and the subsequent [Lisp for the Web part II](http://msnyder.info/posts/2011/07/lisp-for-the-web-part-ii/) interesting, the author of the first one eventually wrote [a book on Leanpub](https://leanpub.com/lispweb). I also think [Lisp Web Tales](https://leanpub.com/lispwebtales) interesting, the author does implement a Blog, I have not fully read any of the two books but they seem very didactic. I think these could be a good lecture if you want to take a stab at this.
https://common-lisp.net/project/trivial-garbage/ For Quicklisp, `(ql:quickload :trivial-garbage)`
Being able to call the GC manually in-between levels (or deaths) would indeed be useful. However that doesn't mean that the GC **won't** be called while playing. EDIT: You might find the GC apis from CCL (for exmaple) interesting. You could use CONFIGURE-EGC to put the threshholds for young generations very low and for old generations very high for example. https://ccl.clozure.com/manual/chapter16.7.html
Lisp Web Tales is free, you can pay something if you like to, but the author is not charging for it.
That's right thank you ! I might as well give a bit then ! :)
That was a typo. I meant C-M not C-D. Also, putting the actual control character in the literal string works fairly well, if you use an editor that shows it as ^M instead of an actual return character. As oldretard mentioned, you can use Ctrl-Q to quote the character in emacs, to make it a literal part of the string. The only problem is if you try to read your code with an editor that executes the C-M, causing it to overwrite all the text before it on the same line. 
That's not a comment.
Terse code at ~70-ish lines, very cool, and inspires me to learn more about monads.
In general, Common Lisp (and most Lisp) functions that operate on lists return copies of the list with the modifications made, rather than modifying the actual list. This is the case with `substitute`. There's a version called `nsubstitute` which is *allowed* to modify the list, but not guaranteed to (it's mostly there as a performance consideration). It's not possible to modify something that is passed into a function, only something it references. So in a list (I trust you know how singly-linked lists work) what gets passed in is a reference to the first cons (or `nil`). So you could modify anything in the first cons, second cons, etc, but not *what the first cons is*. That path leads to madness. That should explain why `substitute` doesn't actually change the list. It's not exactly relevant to your problem, but useful to know. What you're experiencing is what's called shadowing. When you declare a variable, and then later give a function a parameter with the same name, what happens while that function is running? Should uses of the name refer to the parameter or to the global variable? Common Lisp takes a "best of both worlds" approach: when the function is entered, the value of the global variable is saved somewhere, then it is restored after the function finishes. In this way it acts like a parameter in the ways you want - it's an explicit input which can't be changed from the perspective of anything outside of the function - and like a global variable in the ways you want - any other functions that refer to the global variable will still work correctly. So yes, any changes made to that global variable will not stick during that function. If you *want* them to stick, just make the global variable and the parameter have different names. A convention some have taken to using is to put asterisks around global variable names (like `*board*`). 
I am not the author, but I thought `pml` is an interesting, non-trivial example of using CL as script.
There's no need to ``LOAD`` stuff yourself. Just write a system definition file like any other project. Then you can have this as script: #!/path/to/mysbcl --script (ql:quickload "pml" :silent t) (pml:main) ;; could pass parameters here Where mysbcl is a shell script to launch SBCL with your own core file, that includes Quicklisp and perhaps other commonly used systems.
I completely disregarded that point, thank you.
To be fair and complete, this was inspired by an amazing CL project: [pgloader](https://github.com/dimitri/pgloader) 
As far as I know, there's no reason why those hardware features couldn't be emulated with today's stupidly powerful machines. I'd dearly love a Lisp OS I could run.
Well, you won't have to wait 60 seconds for a Lisp program to do the first calculation...
nice ! This is the blogpost by the author explaining the gains from switching from Python: http://tapoueh.org/blog/2014/05/14-pgloader-got-faster.html (among which a 20 to 30x speed gain!)
CL doesn't have convenient abstraction out of the box for work with matrices. There are good libraries providing that though (I know you don't want to sue them, but you may learn from them how to implement things): https://common-lisp.net/project/lisplab/ for instance. See: http://www.cliki.net/linear%20algebra Maxima (math software) is written in Common Lisp too.
* I am not familier with Racket/Scheme so I cannot comment on it. * [Common Lisp supports multi-dimensional array by the standard.](http://clhs.lisp.se/Body/f_mk_ar.htm) * [There are also many libs for matrix operations using BLAS/LAPACK.] (http://quickdocs.org/search?q=matrix) * [There are even GPU libs.](http://quickdocs.org/mgl-mat/) Whichever lib you take, only try quicklisp-available libraries if you are new to common lisp. 
Representing matrices as lists [is literally one of the examples (2.2.4)](https://www.dreamsongs.com/WIB.html) for why Lisp lost to C and Unix in the Worse is Better essay from 1991. Arrays exist. Use them where appropriate, such as for matrices, vectors, quaternions, etc.
The following blog posts should be of interested to you. * [Optimizing Lisp Some More](http://nklein.com/2009/06/optimizing-lisp-some-more/) * [Trying to Unconfound Lisp Speeds](http://nklein.com/2009/06/trying-to-unconfound-lisp-speeds/) * [Speedy Matrix Multiplication in Lisp, Again…](http://nklein.com/2009/06/speedy-matrix-multiplication-in-lisp-again/) In these posts, the author documented how he implemented and optimized a small matrix multiplication operation from scratch in Common Lisp, using only built-in data structures and no external third-party libraries. The blog posts serve as a great example on ~~how to use multi-dimensional arrays (as mentioned by /u/guicho271828) to represent matrices~~ **edit:** sorry, my bad. I remembered it wrong: the author used a single dimension vectors to represents matrices; how to use the loop macro to implement matrix multiplication using the aforementioned multi-dimensional array representation of matrices; and how to use declare and declaim to provide type declarations that provide hints to compiler to further optimize the code. **Edit:** &gt; In Lisp you're generally thinking in terms of lists Just in case you aren't aware, Common Lisp is a practical programming language and has built-in support for the common data structures you'd come to expect from most programming languages: the aforementioned single/multi-dimensional arrays/vectors, hash tables, etc. (more info [here](http://www.gigamonkeys.com/book/collections.html)). So you are hardly confined to just using lists. Just choose the most appropriate data structures for your application.
vectors are one-dimensional arrays.
From an abstract point of view, yes, but a vector also has to be resizable usually, so carries a bit more metadata than an array does. CL has a native array type that is distinct from vectors, and you can declare them as static sized, which (as expected) carries a performance boost.
Being able to redefine a class and have existing instances of the class automatically reflect the new structure and behavior is awesome.
A vector is no more likely to be adjustable than any other kind of array.
fwiw, racket seems to have a decent [array package](http://docs.racket-lang.org/math/array_quick.html?q=arrays) -- a bit generalized, but written with efficiency in mind, I believe. Definitely has the things you mentioned (getters for rows as well as columns, slices/shapes, etc). (Also, if needing efficiency and lots of math, [typed racket](http://docs.racket-lang.org/ts-guide/beginning.html?q=typed%20racket) removes all the type-checking/wrapping when it can prove it's safe. I think this requires declaring your types, and guessing from traffic on the newsgroup, sometimes it's confusing to get polymorphic, higher-order types declared correctly.) Disclaimer: I haven't actually used either of these. 
Thanks - maybe that's a good reference interface to work off of to do something in elisp :)
No problem. Sorry that I couldn't be much of a help regarding Elisp. I'm not really familiar with it.
If you want to really "get" Lisp and blow your mind in the process, read [SICP](https://mitpress.mit.edu/sicp/full-text/book/book.html) and do *all* the exercises. Then move on to Common Lisp with Quicklisp.
[here](https://gist.github.com/chebert/f6c96f7c3edfd45c27ce6bd7a4587dff) is an example of how I tend to do matrices in lisp. In this case a matrix is a list of (num-rows num-cols element-vector). I tried to avoid CL specific things. The big exception is #(1 2 3) is shorthand for (vector 1 2 3). A 2x2 and 3x3 matrix are defined. The advantage of having a vector is that it interoperates well with C libraries including OpenGL.
I really like closures. They are not unique to lisp, but that's the first language where I have encountered them.
I would advice against using elisp for such applications. This language is specially tailored to be used with buffers and Emacs stuff. Most importantly you wont gain acceptable performance and language support for any kind of non-trivial computation related to matrices.
Thanks for the links! [Here](https://github.com/lepisma/mpm) it is. Nothing working as of now, just playing around with macros.
Yes, the community is surprisingly (in a pleasant way) alive for such an old language.
My exact plan for the summers!
Newbie here, honest question: is "pml.lisp" a good example on how to write scripts in Common Lisp that use QuickLisp with SBCL? Without having to write a system definition file.
added [on cliki](http://www.cliki.net/pml) !
A few months ago, somebody posted a Linux port of Open Genera on this sub. 
Just what I needed! (Back in 1998.) /snark 
~~It dynamically finds and loads the shared lib (.so file) from LD_LIBRARY_PATH, as is done by any other C or C++ programs which is dynamically linking to the lib. https://en.wikipedia.org/wiki/Dynamic_linker (it may not be using the standard ld.so, but instead some impl-specific hack may be used.)~~ Sorry, the question was about reloading images... Supplementing other's comments, In lisp images the code is already read/compiled/loaded (here "load" is not in a general sense of loading a blob into memory, but is regarding the common lisp LOAD function) so eval-when has no effect. 
CFFI shouldn't have anything to do with that particular part, and it's instead a feature of your implementation of choice. It is perfectly plausible that an implementation may not keep library handles active across a dump and it may instead be your job to ensure that they're properly unloaded and reloaded as necessary. You should refer to the documentation and foreign interface code of your implementation to see what you can expect of it. Whenever I deploy one of my own applications, I always do the loading manually regardless, because I want to have full control over where and how foreign libraries are loaded. I do this to avoid running into version mismatches or other kinds of clashes that are prone to happen when you run your application on another system that you have no knowledge or control of.
One thing you might do is study cacl.el which comes with your emacs, you can do "C-h f calc" and then click on the calc.el. The calculator in EMACS does matrix calculations, and of course all the elisp code can be reached even if it expands trough several files. I have not sudied the code myself but I have used the calculator a lot and it works very well.
Main page: http://www.nongnu.org/txr/ Manual: http://www.nongnu.org/txr/txr-manpage.html
Heh, I keep looking for a project that smalltalk is just right for because I want to be a smalltalker. Sigh. 
Nothing is stupid when it scratches yer particular itch, but all such "allergies" may be said to be highly idiosyncratic. Perhaps studying [Ioanna Dimitriou's CL/Graphiz utility for visualizing ASDF dependencies](https://github.com/ioannad/asd-graph) might give you some ideas to crib. Her [Grapher for implications of the Axiom of Choice](https://github.com/ioannad/jeffrey) is a much more sophisticated in-browser application of a similar rendering pipeline.
Maybe you should have a look at Pharo these days, they have a lot of good stuff too... GUI programming via spec, web programming via seaside, parsers via petitparser, code analysis via introspection and roassal, voyage for mongo etc, database driver... and of course the dev tools 
One-armed? As in not seeing else-statement and not having else-if ability? Yeah that also kinda sucks.
I don't get it. How can an implicit progn frazzle a train of thought any more than an explicit progn could? 
It changes how code behaves inside the block unexpectedly. Explicit progn changes it expectedly. 
You can put an explicit progn there. But which is better: (when (isdawn) (ring-alarm-clock) (start-coffee)) or (when (isdawn) (progn (ring-alarm-clock) (start-coffee))) 
 defparameter x t (defun f () (setf x (not x))) (loop repeat 3 collect `(1 2 ,@(when (f) `(3 4)))) ==&gt; ((1 2) (1 2 3 4) (1 2)) Seems ok to me. Maybe an example showing what you don't like about it.
it fires me, when I see `#+nil something` instead of correct `#+(or) something` on the other matter, having NIL and T being symbols, logical values, types, class names, in case of NIL list and "nothing" isn't convenient at all to me, just clobbering semantics.
Not an anathema, but it could be nice if `#X` (or rather `#R`) could take a list (or an array), so you could write stuff like `#X(DE AD BE EF)`.
I hope I don't have to read your code with PROGNs everywhere.
The code works perfectly fine and appears commonly. The reason I chose it as an anathema is that the code does not sufficiently reflect the purpose and yet there are not many alternative ways to write it. The meaning of frequently appearing `(.... ,@(when flag '((code)) ))) ; A space for emphasizing double-parens pattern is to put `(code)` in the list if `flag` is non-nil, and otherwise "leave nothing" by splicing a NIL. This little trick of using `(())` is however not that intuitive, as it is not symbolized by any macro. I could rather have a variant of `,@`, something like `,&amp;(when flag '(code))` , which always removes NIL when splicing. But the implementation of quasiquote has been dropped from the spec, so it is not feasible. You can achieve a similar code by `(.... ,(when flag '(code) )) but that still leaves a NIL in the code when `flag` is false. In a normal progn-like environment this does not affect the compiled code, but that's not always the case. For example, you cannot leave NIL in the arguments: (list (somecode....) NIL (somecode....)) The above NIL will accidentally include NIL in the resulting list.
In TXR Lisp, I came up with #; (hash semicolon). The mnemonic for this is obvious: it "comments out" the next object. 
"One armed if" should be replaced by WHEN/UNLESS/AVER clauses. This comes from the JPL style guidelines.
oops, you are right. should come up another example...
&gt; `(.... ,@(when flag '((code)) ))) The information is contained in `'((code` already: we know two parens have to be closed, and we know that they are in that flurry of closing parens. Stacks of closing parens are just fluff nobody should be looking at, except to fix it when it's wrong. Please don't attract the eyes there with gratuitous whitespace. 
To work with the latter all the time, we would need a read macro: {forms ...} -&gt; (progn forms ...) That's mostly a waste of curly braces that could do more creative things, like implicit lambda or what have you.
Note that you can have `yourpackage::t`. Only `cl:t` is reserved. I briefly toyed with the idea in TXR Lisp to have only keyword symbols be self-evaluating, and the false/empty would be `:nil`, complemented by `:t`. That extra punctuation wherever you need `t` or `nil` is too ugly, though. 
I think #| ... |# stand out to me. Clojure has (comment ... ) 
In my coding style, a lot of code uses macros whose purpose is to reduce the syntax. In such macros, there are often opportunities to use implicit progn's, which I find useful. In other words, I want more implicit progn's, not fewer. So my coding-style macros add more implicit progns, which totally contradicts what Friendeee wants.
For something without side effects, `and` is better than `if`: (and q a) 
And? Why is and better than if? Maybe it's not so iffy?
&gt; Nock ... is a language that powers the Urbit virtual machine; its specification can fit on a t-shirt LOL. The reason that "spec" fits on a t-shirt is that the vast bulk of their virtual machine's "spec" is hidden inside an extension mechanism conveniently omitted from the t-shirt. 
If you fart world won't cease to exist. If you indent your code improperly it will still work. These are just "theoretical" practices, nonetheless I'd say that writing bad code is a practical problem (just like farting when people are around). edit: not knowing about potential problem is an acceptable justification, but knowing about it, having proper alternative and still writing a bad code (due to some cargo cult reasoning) is plain wrong imho.
Did you try to push `nil` on `*features*` ? Doesn't change a thing.
We will have to stop using C, then... CL is similar to C in many choices! If you don't like it, switch to Scheme!!
`T` is perfect to me. Like the number `1` (which all the other numbers are composed of, if you think about it). CL is much more wise than most users recognize (well, at least not the first decades using it...).
Even if it fits on a T-shirt, will the specification still fit on a T-shirt if it has to include all the code needed to build up something useful, like, oh, IEEE 754 double precision arithmetic ... Why not just say that the spec is a NAND gate and two logic levels; the rest of the virtual machine is just a "library" built up of those and can be omitted from the T-shirt. 
Ahhh I meant to ask you to record this one too and kept forgetting. THANK YOU
Thankyou for the bugs! It's a big help to have people trying this stuff out
I kind of skipped around a bit, but I was *really* impressed with all of the cool utility functions you had (graph was one that stood out), and how slick cepl graphics pipelines are. Super inspiring stuff! Thank you so much for sharing with the community
In what way is T like 1? Are other names composed of T, like other numbers are composed of 1? In what way does this imply CL is wise? The way I see it, the names we use the most should be the shortest. And we use NIL a lot more than T. 
This is... different. Imagine a new Intel machine with *extremely* reduced instruction set. Almost no arithmetic operations at all, certainly no floating point instructions. At least they provide a ready-made software floating point library. You run some tests. Their library is quite fast... faster than any software floating point library you've ever used, almost *hardware* fast. You stand in awe. You compile other floating point libraries, but none of them perform like the Intel one. In fact, they *crawl* through the calculations. It seems only Intel's wizard programmers know how to really program this new machine. One day you accidentally overwrite half of the library in memory, but the machine continues to churn out out correct floating point results at almost hardware speed. Impressively robust software! New versions of the original floating point library always come with new microcode blobs. Mismatching the two invariably drops performance to near-zero. It's not just floating point. After some time with the machine, you find you can't get anything done without going through the right version of vendor-provided libraries. Trying to come up with anything coded just to that impressively small instruction set has *never* worked for you. You're just no match for the wizard programmers of Intel who seem to be the only ones who know how to actually use that wonderfully small instruction set. Intel marketing announces that everything will migrate to their super-RISC instruction set. Because the small spec will never change, all your software is completely future-proofed—and the spec is open, too! (Just make sure any actual work goes through original Intel software matched to the exact CPU model and microcode version.) 
For some advantages you can take a look at the places special vars are used in the spec. For example [input/output/etc streams](http://clhs.lisp.se/Body/v_debug_.htm) &amp; [current readtable](http://clhs.lisp.se/Body/v_rdtabl.htm). You can imagine what it would be like to pass around the standard out stream everywhere you wanted to print, or if it were global and the problems that could cause.
This is the pattern used in the Racket stdlib and it's really nice
I think your structure-vs-arguments example is orthogonal to use of dynamic variables. Dynamic variables make most sense when otherwise they would be not used but passed down the call chain to other functions. Like the I/O streams: very low-level routines might log output, so redirecting that output would require every part of the call chain to worry about the proper state of the I/O streams, even routines which don't care at all about I/O. It's better just to make that effectively global.
I see, but if you use the parameters all over the place (not all in the same lexical scope), the cost will be more. I don't tend to reference a lot of parameters all in one place, so from my point of view it seems like more work for less efficiency.
Adding to jsjolen's comment, this is one of the reasons why all 'future lisp' articles always list 'a standard MOP' as something missing from CL
You do not. **Why:** There is no standard way of accessing slot names from structures. **Why not MOP:** MOP only works for CLOS objects, which are `standard-object`s, where structures are `structure-object`s. **Why it might work:** Some implementations implement structures as CLOS objects and you will be lucky to have the CLOS way work on them.
Aha, I assumed they had a common parent type :-P
TXR Lisp: 1&gt; (slots 'time) (time-local time-utc time-string time-parse year month day hour min sec dst gmtoff zone) 2&gt; (static-slot-p 'time 'time-string) t 3&gt; (static-slot-p 'time 'year) nil 4&gt; (time-struct-local (time)).(time-string "%Y-%m") ;; why that is a static slot: it's a method! "2017-05" 
Please, having someone spam examples of different lisps than the ones asked about is not good PR for those lisps, just stop.
OP didn't specify which Lisp they're using - they might even decide to use some particular language/implementation because it has a feature that they need. This is /r/lisp, for The Lisp family of languages. TXR is certainly a member.
That's probably the best overall solution, for best portability, etc. I was actually leaning that way, but wanted to make sure there wasn't some standard way I didn't know about. 
In general I would agree but the posting pattern from above is very similar to what happened a lot at comp.lang.lisp where people would re-implement everything in whichever lisp dialect they preferred. I don't have a problem with people posting about TRX lisp.
special variable lookup incurs a runtime overhead, but it's negligible for any but most resource demanding programs. i made an empty package, created a 1000 dynamic variables in it. and then i ran a loop of 1000000000. on my machine, empty it takes 28.5 seconds. same with lexical var access (i checked that the compiler didn't optimize away the relevant assembly), same with dynamic var access. so i added explicit `(symbol-value '*foo*)` which is the worst case method of dynamic variable value lookup. that brought the loop up to 29 seconds. which means that *the worst possible way* of the dynamic variable lookup incurred 0.0000000005s worth of overhead. (this is totally back of the napkin kind of benchmark, but it should give you a general idea of relevancy of this particular point)
fyi `and` in common lisp is usually implemented in terms of `if`, the later being a special operator, and in that sense "atomic"
In terms of speed and scalability, how would Lisp rank for web development? That's not an end-all-be-all for me but it's good to know....also I'm having trouble finding any benchmarks online.
&gt; In terms of speed and scalability, how would Lisp rank for web development? You're worrying a bit too much about that, especially considering you've been learning things like Ruby (slow) and Python (GIL = concurrency nightmare). Speed is about more than just "I picked the language that's got the fastest benchmarks!" and is often affected more by *how* you solve a problem than *what language* you solve it in. If you want a lisp that will be useful for web development, do what /u/lazyklimm said and check out Clojure(script). Clojure's a hosted language that can be run on the JVM, CLR (.NET), or compiled to JavaScript, with the ability to interop with whatever platform it's on. You could use the ClojureScript (the JS) version on the front end and on the backend use either standard Clojure, or the JS-hosted version (ClojureScript) on node. Also, something to consider here is that learning a language can be useful and relevant, not because you can use it directly on the task you're interested in, but because it teaches you things that make you better at what you do. Learning a lisp, especially one that's more opinionated toward functional programming, like Racket or Clojure, will teach you things that can be useful even if you end up writing JavaScript directly later on. JS has all the things you need for functional programming, and there's currently a big push toward using FP concepts with it, so FP knowledge could be a win for you. You already have experience with a bunch of OO-focused languages, so it's not like picking up yet another OOP language is going to be hard; try something new. &gt; Lisp Flavoured Erlang (not really Lisp, but yea) LFE is a lisp as much as Clojure, Racket, or Scheme is. There's a minority that basically considers Common Lisp to be the only real lisp, but most definitions are a lot looser than that and count anything Scheme- or CL-like. 
In a word: Yes. Learn Lisp. Then whenever you look at another programming language, you'll find it a subset of Lisp with an (arguably) nicer syntax. You'll be able to pick up other languages in no time. Read [SICP](https://mitpress.mit.edu/sicp/full-text/book/book.html) and do *all* the exercises. A warning though: Once you *get* Lisp, all the other languages will start to look like toys to you. Some of them expensive toys, but toys nonetheless.
Yes. All lisps come with different ecosystems and uses. Clojure has a nice modern suite of libraries developed for it. Common Lisp is a swiss army knife of a language with all different paradigms playing nicely together, but with much less traction in the web dev, thus much less and mostly stagnant libraries (same goes for GUI). If I were you I'd go with Clojure which is a practical and solid choice for webdev, and than there's ClojureScript which can save you from touching JS. It also depends on where you are, in some countries its MS all the way down, but the industry is open to New Things ^tm in some other places. Nevertheless, learning it takes so little, and is really rewarding.
Lisp is like magic - it's the programmable programming language - if you learn it, everything else kind of pales in comparison :P One fascinating aspect of lisp is that it's based on lambda calculus, which is basically a cleaner alternative to Turing machines (Turing machines are basically a mathematical way to describe computable problems). After learning about lambda calculus, Turing machines looked like a hack to me. A decent non-mathematical guide I found introducing them was this: http://palmstroem.blogspot.com/2012/05/lambda-calculus-for-absolute-dummies.html Even though lisp allows for a lot of functional programming, it's not purely functional, and can be used to write object oriented code, or anything else really. The books I'd recommend to learning it are: * [The Little Schemer](https://www.amazon.com/Little-Schemer-Daniel-P-Friedman/dp/0262560992) - a lovely, beginner friendly book that introduces Lisp and computation in a rather unique way. * [Structure and Interpretation of Computer Programs](https://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/dp/0262510871) - this is the book that was used to teach a bunch of programming classes at MIT, and is a classic text for computer science. Despite its advanced topics, it's still rather approachable, especially if you have a decent amount of programming background. 
&gt; LISP is worth learning for a different reason — the profound enlightenment experience you will have when you finally get it. That experience will make you a better programmer for the rest of your days, even if you never actually use LISP itself a lot. From http://www.catb.org/esr/faqs/hacker-howto.html 
Good question, because I've met some web devs who optionated on what language(s) are "best for everything" (as if that was really a thing) like it was government politics.
Yea part of me has worried too much about the "speed" of a certain language. Maybe it has to do with me being younger and inexperienced. :P
I wish I was told about the lisp when I was a teenager at 199x. I couldn't waste time learning basic, pascal, java, C, C++ Python and Javascript. If I have a one chance to into the past on the time machine, I would pass younger me an ANSI Common Lisp book, not the sport almanac.
Thanks for the recourse! I'm going through [Derek Banas 1 hour tutorial](https://youtu.be/ymSq4wHrqyU) to get familiar with the syntax while expanding on examples he uses in Eclipse with the Lisp plugin. 
https://www.youtube.com/watch?v=1e0aBCmdRAE Just to reinforce to what /u/ws-ilazki said about performance &amp; language of choice, which is really important, check the video above. Clojurescript has a bigger community which results in more libraries. Not only that, their approach to web dev is more entuned with 'mainstream' JS. For example, redux is more or less offering what OM offered back when react was first released. So if you want to apply lisp right away for web dev Clojurescript is the way to go by far. &lt;plug&gt; That said, Common Lisp is definitely worth the learn, it is the less opinionated of the current lisps. "Lisp has jokingly been called the most intelligent way to misuse a computer. I think that description is a great compliment because it transmits the full flavor of liberation: it has assisted a number of our most gifted fellow humans in thinking previously impossible thoughts." &lt;/plug&gt; But again if you want to start with web dev, go clojurescript
First of all, LISP (which we better know as Lisp) is in fact looked down upon by programmers of all experience levels, including many decades. What I'm saying here is that the *lower bound* on the amount of experience for saying discouraging, ignorant garbage about Lisp is likely quite low.
I noticed Elm over on [exercism](http://exercism.io/languages) but my first thought was "looks cool but I doubt many people use this." I mean in regards to web development, I'm already getting tools under my belt to use for what employers are going to want (I know Python, Ruby, and PHP. I know a decent amount of JavaScript already, I'm learning Elixir and Scala, and I need to get SASS/SCSS down at some point). While I'm not 100% on some of the language choices companies have around my area (it's just all Java and .NET. Java isn't bad but I like Scala/Clojure/Kotlin/Ceylon better. Plain-jane Java just isn't my cup of tea) I still need some experience before I could sway a company to choose to switch over languages or build a project on a language that I prefer.
To highlight a couple of points here 1. Lisp is a multi-paradigm language. You can do OO, functional, procedural, spaghetti gotos (for generated code ;-)), whatever you want. A lot of people are indoctrinated into thinking e.g. OO is the one paradigm to rule them all, but it ain't so. 2. The ability to make your own domain specific language, and build up your system in layers of abstraction. This is very powerful. Again this runs against the phobia about macros and whether they are 'hygenic'. 3. The ability to write code fast, or to write fast code - entirely at your discretion. You only pay the price for optimizing when you choose to do so. Similarly with type definitions. You can put them in and have the compiler check everything (on top of the inference it does automatically) or be loose and free - your choice.
Or, to word it a bit differently, as long as you're not writing absolutely terrible code, language performance doesn't matter much for *most of the code*. Rather than waste time optimising things that don't matter, profile and look for the bottlenecks, then find ways to improve them. Then, if it turns out your language of choice *still* isn't fast enough for that critical section, you can usually rewrite *that one part* in another language and call it instead of having the entire program written in that language. It's tempting to want to pick the best/fastest/shiniest thing, but there are always trade-offs. A language that's faster might take longer to write programs in, or be more susceptible to programmer error, for example. If speed were the only important factor, then everyone would be writing everything in C, but it's just not that simple. 
but a decreasing traction, as it seems https://www.indeed.com/jobtrends/q-scala-q-clojure.html
That sounds good, but do you have experience with any backend and frontend framework ? You'll need those at some point, not necessarily both for a first job, but a little experience is nice. So did you build a little project of yours in django and vuejs for instance ? (IMO Django is great to learn web dev, stay away from Flask). 
This is really interesting, thanks for sharing it.
Well two wiggly lines don't tell much, it may also be a saturation of positions that cause the decrease in job offers, or maybe the market for Clojure developers is not online job portals but the community and word of mouth. That said it may well be that that trends are correct and it is indeed decreasing (that it decreased until now does not mean much without context), that's sad, Clojure is really nice and ClojureScript looks very nice too...
...but even if you become spoiled and not desire to use other languages, learning lisp can make you a better programmer in any language. It. Will. Change. Your. Life!
Yes it is worth to learn, why not? From the other side, looking at your experience (less than year) I would recommend not to spread your focus and time learning all the stuff you've read on internet, rather concentrate on one thing, master it, use to solve real world problems (and find a job of course), get into the community, understand the limitations etc. You can still learn lisp in background though, solving exercises from SICP and reading ANSI CL.
Clojure is not mainstream either.
I don't see anything in my comment suggesting it is, so what's your point? I was calling bullshit on a bad graph with worthless statistics. Do you just like replying to random people with statements completely unrelated to what they said? 
all those ad-hoc languages relying on communities or this or that implementation pale in comparison to Lisp learning Lisp is like learning Latin: a classic language that is both dead and alive for ever
So are languages that are Schrodinger's cats good to learn? :P
I will not post others' people graphs without context or comments, fair. I like your graph though, it's also putting into perspective the sentence I was refering to, "Clojure has some traction in the industry".
&gt; Going off-topic from the original question a bit, but it sounds like you haven't looked into Clojure lately. Emacs is still a good way to go in general, but you can use Cursive for IntelliJ, Light Table, or Nightcode if you want something vaguely DrRacket-esque. There's also Clojure support for VS Code, Atom, and I've heard of people using fireplace for vim. In an effort to better understand AI, I'm also considering learning Lisp in the future. I was thinking of starting with Peter Norvigs books ( Paradigms of AI Programming, Modern Approach to AI). Would that be a good place to start? Also since they refer to Common Lisp, would light table, Sublime, AllegroCL or LispIDE be a good editor to begin with? I tried Emacs but the learning curve was too frustrating. Or is the SLIME+EMACS combo the best way to go?
Just remember to take the "secret sauce" with a grain of salt. Paul Graham has written a lot of blog posts on his use of Lisp before he sold his company. Joel on Software is highly respected in the software industry (his company wrote StackOverflow &amp; Trello) and he has a retort to the "beating the averages" article. Sure some companies win with obscure tech like "Lisp" and I read an awesome article on "D" usage in Tel Aviv this morning. Just remember that this stuff sounds like dark witchcraft to most IT departments, so I'm willing to bet very few companies use this in their production stacks. There are quite a few users on here who make their living from Lisp (and I'd love to hear more about that), but out of the hundreds of programmers I've met, only one knew what Lisp was and that was because he was a grad student working in the same department as one of the authors of SICP. Now I'm gonna pull out a Lisp text :)
Thanks for that. I've just found code repositories for both books - rewritten in Python, so that may be an easier transition into Common Lisp. 
Cute idea. I think about 10 years ago, after I read ANSI Common Lisp and Practical Common Lisp, I wrote a "customizable defun" hack that lets you define new lambda-list keywords. It wasn't as powerful as your macro approach, but it was OK for, say, defining `&amp;REQUIRED-KEY`.
By the way, the `define-parameter-macro` form which provides the `:key` macro for keyword argument support is found here: http://www.kylheku.com/cgit/txr/tree/share/txr/stdlib/keyparams.tl Legend: `^` is backquote, `:` return in `tree-case` means "fall through to next case". You can use this anywhere: `defun`, `defmacro`, `flet`, `labels`, `macrolet`: even exception handling clauses. 1&gt; (catch (throw 'foo :a 'b) (foo (:key -- a) ^(caught foo ,a))) (caught foo b) 
How do you define outdated dialect?
It's difficult to say. I would call a language modern, if it keeps up with other commonly used languages. Maybe I should have used the word "lively" instead of "modern" . I don't think much people would describe Common Lisp - by which I mean the community around it - as "lively", then again I am in a Lisp subreddit.
I'd love clojure if it wasn't for the startup and other JVM-related annoyances, for a SaaS situation where you can have a permanently running JVM it would be fine though. A native clojure would be awesome. Picolisp is interesting, but it's lack of real string handling (unless I've missed something, string handling is pretty much 'convert the string to a list of chars, deal with it as a list, and convert back' seems counter to it being a valid language for most purposes. LFE is interesting, but every time I try to get into it, I get put off by the fixed arity functions and having to think about which version of a function I need. I wanted to try the lisp-flavoured haskells, but they all seem to be dead end unsupported code that predates haskell 2010 and thus won't even compile today. Which leaves scheme.
I would describe it as lively. The community around CL has been picking up a lot of steam in recent years. A lot of new libraries and projects are published in Quicklisp every month, and the number of users is increasing continuously as well. I don't understand what more one would want in order to deem a community "lively".
Many things which are in libraries in other languages are built into Common Lisp. There are also various third-party libraries, which you can install using the package manager, QuickLisp. Common Lisp is good for pretty much everything, including string and text processing. There's no built-in web-processing, so you'll need external libraries for that. Others will have more information on Racket/Scheme and Clojure. I use my own Lisp dialect, Emblem, which is syntactically like Common Lisp but also has Scheme-like features. Many programmers find Lisp strange, but it has similarities with Python, and Matz was influenced by Lisp when he designed Ruby. 
In about 5 mins. I'm make a new thread on #lisp right now :)
second racket
Javascript is in the same neighbourhood of bad as the JVM IMO. Can't decide which one I dislike more.
Not to mention that Common Lisp has [SLIME](https://common-lisp.net/project/slime/), arguably the best IDE of any Lisp dialects (and of course, it's still in active development). I'll even say that the combination of Common Lisp + Emacs + SLIME + Paredit is, IMHO, the best development environment bar none (even when compared against other languages/IDEs). **Edit:** added Paredit to the list.
Lisp was my third language, and it made me question my decision to learn Python (and R before that) quite a bit. That being said, most of my daily job is in Python and Ruby.. so..
As Shinmera pointed out, community is very "lively". I think that you might have confused age of the standard with "dating" - CL has number of warts of course, but many implementations are under active development (with needed features not being part of the standard - for instance threading, networking and foreign function interface) and the userbase grows in a decent pace (where many of them can't remember lisp machines and such due to their age - I myself have started programming in CL after 2010).
🤔
Hahaha! I've got to get this as a bumper sticker.
I was on a review for an implementation of Common Lisp for a CDC big-iron machine. 72-bit words which could hold 3 24-bit pointers. So, naturally, every "cons" node had three pointers, accessible as: CAR CDR CCR 
My other `car` is `first`.
My other car is everything that comes after the car It doesn't make much sense, but hey, at least it's a lisp bumper sticker :P
and my other cdr is a cddr 
I wish I was there for the stream, I would have said "that is (/ (sqrt 2) 2)" ;), I have seen about half this new stream on You Tube, I pre-liked it, it is very entertaining and educative. I would like some GLSL basics to be able to better understand, maybe you will manage to do some basic GLSL tutorial using Varjo/CEPL at some point.
I tried Clojure, Common Lisp, Scheme, Racket and then went straight back to Clojure. Clojure as a Lisp dialect for the JVM is too good to ignore.
there is no "awesome racket" because racket comes with most of commonly used libraries although some of them may not have the same "quality" as the CL counterparts. 
Common Lisp is not modern because it is still ahead of its time. Too many features from it aren't implemented in commonly used languages yet. :)
That sounds great, I will try to be in the twitch live broadcast, I keep arriving too early or too late. I have to find the right time and program it on my google calendar.
TLDR; While the standard is dated (Not that that there is any thing wrong with that) the platform is not. Well it has some advantages, one of which is being able to run code that is 30 years old is impressive and sometimes useful. You might have heard the expression there is nothing new underneath the sun... So it has a standard and that is an extremely good thing and the standard may be dated but that does not mean Common lisp is as a platform. One and possibly the most important advantage is the malleability of Common lisp. The ability to extend and implement "modern" techniques and concepts is generally simpler than in other languages. The other advantage is the community in concert with the Quicklisp package manager. The community has been very active and the scope of code, extensions and tooling made easily available through Quicklisp. 
It's not opening parens they are afraid of, but closing ones, put together. So, if they expose themselves daily to this picture, for a period of a few weeks, they can slowly learn that parens are harmless, don't hurt the brain, and don't reduce your IQ (on the contrary!!): 1 ) 2 )) 3 ))) 4 )))) 5 ))))) 6 )))))) 7 ))))))) 8 )))))))) 9 ))))))))) 10 ))))))))))
They're afraid because they're all idiots programming in notepad, the scum of bare text editors, opening and closing parentheses by hand. Thus, they can't enjoy the benefits of hierarchical structured editing parentheses provide.
I like to demonstrate how easy it is to deal with parens by loading some Lisp source and randomly chopping some parens off the end of a defun. "oh no!" then I just whack them back in, bang, bang, bang - showing how Emacs highlights the matching paren. Then I compare it to Javascript where you regularly have things like: ])};}); - Which is much harder to change or restore compared to Lisp, even with editor help. I try to get people to look over my shoulder when I'm doing some repl coding just to show how fast you can code in Lisp, and how ergonomic and manageable it actually is. I think its one of those things you have to see and experience to understand.
We need more screencasts or twitch translations to show world the truth!
Don't understand why this comment was down voted. Completely agree :)
I find that's true with special forms like let, do, and loop. It was tough to internalize the shapes of those, so I can see how it'd be tough for beginners.
going up, down or next or previous are all common bindings in usual Lisp editors. That and a single stroke to open and close a pair of parentheses and put you right in. How can that be confusing?
Ah, that makes more sense :) In any case it looks interesting, to say the least.
Always felt the haskell method of literate programming was the most sensible - simply reverse the way comments work so that a line starting with -- now is one that contains code. This would naturally work easily for ; comments, but probably be trickier to implement for block comments (#| ... |# style), there again, literate haskell supports the {- ... -} style comments, I think so maybe not that hard. Seems more of a natural system than hijacking the markdown syntax, to me anyway.
I think Erudite implements what you describe: https://github.com/mmontone/erudite You can also choose a comment prefix, say "--", for indicating which comments should be considered by the literate tool system. 
I may be wrong, but the main problem is that I haven't found out how to have org-mode plus full Common Lisp interactivity via SLIME and ASDF. I want to be able to load a project from SLIME+ASDF as I normally do, but don't know how to integrate org-mode into that. So, having the literate documentation be source code comments allows the interactivity. That, plus the Eurudite tool org-mode syntax, and Emacs outshine and navi modes, I get all org-mode like files outlining, folding, navigation via outshine and navi; literate programming via org-mode syntax and erudite; and full interactivity via SLIME. https://github.com/alphapapa/outshine https://github.com/alphapapa/navi
One possible factor to consider is that when a language seems lively, the liveliness might be from extensive discussions of problems and obstacles people meet when using that language. If a lot of the problems and obstacles of a particular language are already resolved, and people can work at full speed without much discussion, it might almost seem like a dead language. The above is just one possible factor to consider. I'm not arguing in favor or against that factor, but just suggesting it as something to take into account. Another thing to consider is what it means to be outdated. Is our planet Earth outdated? Is the human race outdated? Are wheelbarrows outdated? Does your kitchen have a dishwasher installed? How often do you replace it, to make sure it doesn't get outdated? One thing to consider about Clojure is that it's for the JVM. Therefore, your desire to use the JVM is probably the single biggest factor in selecting it. 
It's possible with a reader macro: (defvar *hex-reader* (get-dispatch-macro-character #\# #\X)) (set-dispatch-macro-character #\# #\X (lambda (stream c n) (if (char= (peek-char nil stream) #\() (let* ((as-list (read stream)) (as-string (apply #'concatenate 'string (mapcar #'symbol-name as-list)))) (with-input-from-string (in as-string) (funcall *hex-reader* in c n))) (funcall *hex-reader* stream c n))))
Original post: https://www.reddit.com/r/programming/comments/6e6zwn/i_had_no_idea_common_lisp_had_actually_been_used/
The developers of Crash Bandicoot have an absurdly fantastic blog post series on its development, they wrote a custom lisp for the gameplay logic. http://all-things-andy-gavin.com/2011/02/02/making-crash-bandicoot-part-1/
How does lisp make you a better programmer in any language?
What perspective does lisp give you on programming?
Why is lisp so powerful?
There are a couple, lux for one, but this has some interesting objectives. For one thing, since the typechecking is embedded in the macroexpander, it should be possible to use type information to direct macroexpansion. 
Great stuff, I missed the Twitch stream again, thanks for making them available in Youtube.
I'm not fan of parens myself despite having all the goodies (Emacs+SLIME+paredit+rainbow). Especially when refactoring and suddenly autoindent signals somewhere between here and X should be closing paren. It takes too long to spot those trivial syntax errors compared to C and Pascal style languages where you spot them quite immediately.
Then we can rewrite all the Common Lisp parsers using asychronous I/O !
paredit is good https://www.emacswiki.org/emacs/ParEdit and parinfer is good https://github.com/shaunlebron/parinfer
I'd recommend browsing http://cliki.net/ until you find the easiest resources to learn. Or trolling on #lisp on freenode, and Paul Graham's Lisp essays and OnLisp. OnLisp and the Hyperspec were enough for me to learn CL over the span of one year.
I hope you do posts on this stuff from time to time. It's very interesting even though I know next to nothing on the subject right now.
Not tree-shaker but, do you know that SBCL support compression for core files? This would reduce the size quite a lot http://www.sbcl.org/manual/#Saving-a-Core-Image
I’m still here. :-)
&gt; Why doesn't papyrus have something like &lt;&lt;foo&gt;&gt;= ? Because CommonLisp already has the great, flexible macro system. You have to use it. Is it really equivalent? With the usual kind of tool you get as part of your output a "fair copy" of the code with chunks substituted in. Using macros as a substitute for chunks you don't get any fair copy, which means that you'll be turning "straight line code" into a harder to read set of macro invocations.
It totally is!
Hmm. Is there a good summary of what has happened in the last five years to this approach, i.e. was there any consensus on what it would take to add to the ANSI specification to make a cross-implementation co-routine approach possible? &gt;What’s next? &gt; &gt;Good question. The next step would probably be for me to probe the maintainers of a few open-source lisp distributions and see what kind of problem I’m up against. OpenMCL (now Clozure CL) used to have a concept of “stack groups” (see “Processes &amp; Stack Groups: Juggling multiple tasks”) which I’m assuming was the DIY threading method exposed when OS threads weren’t mainstream. Apparently, stack groups have since been removed (most likely in favor of pure OS threads). &gt; &gt;In other words, unless there’s a portable way in C/CFFI to expose an interface for coroutines/continuations/direct stack control across implementations, we’re at the mercy of the already busy lisp maintainers to include them. Or I can always roll up my sleeves and dive in, but let’s be realistic…this is a fairly low-level feature, and I’d have to get to know the internals of all the open source implementations fairly well. 
Cool. Some systems hold on to a bunch of data to help aid the developer experience that could be flushed once you know the program is being shipped. Maybe provide a hook so that systems can be informed that it is ok to free anything they will no longer will need.
Does it decrease performance and if so, how much?
 [guicho tree-shaker]$ time ./u-baseline.bin hello world! real 0m0.017s user 0m0.004s sys 0m0.012s [guicho tree-shaker]$ time ./c-baseline.bin hello world! real 0m0.209s user 0m0.184s sys 0m0.024s
maybe I'm gonna stick with scsh though.
awesome !
Uh that site just states &gt;scsh is the 2017 "Shell Of The Year". Congratulations ! Voted who when what where?
Is this the same as https://scsh.net/? Does it compile on modern systems these days?
No, but where was the vote which chose best shell of the year. By all means the winner of that should have been fish or zsh or something similar; does anyone actually use scsh as their shell?
I presume the only effect of compression is the bootstrapping time, and the binaries above (uncompressed vs compressed) are both simple hello-world programs. Bootstrapping time for the compressed binary is x10 slower than the uncompressed binary due to the amount of time to decompress itself. For long-running processes this should not matter.
while this is an incredibly silly submission i would've loved for scsh to become a thing. i used it extensively for 5 years or so for all my unix shell scripts. unfortunately i think there's no longer any talent around it. current maintainer, while probably is well meaning, doesn't seem to have expertise to do anything but shuffle the code around, and introduce insubstantial fixes. one of the problems is that underlying distribution, scheme48, while in my opinion is the best scheme available, is equally under appreciated. who's even using it in production at this point? a decade ago most activity around it was generated by riastradh, but the kind of excellence scheme48 demands is not in vogue among schemers any more, and most attentions has shifted to racket. scsh/scheme48 would maybe grow if some project adopted it in a similar role to guile, i.e. a systems scripting language, a package description format, a pid 0 process manager, etc. but this is unlikely to happen.
In web development in general. Client-side applications can be very large and any reduction of what client has to download &amp; run is beneficial for both client and server. 
the scsh tree mostly builds. what breaks is scsh-ncurses, required by "Commander S". The C portion does not compile because the Makefile remains incomplete. sad state of affairs.
yes, the god of Scheme told us so. He must be right, right?
Will it be released as a package, without roswell ?
6pm UTC happens when this comment is 20 hours and 48 minutes old. --- I'm a bot, if you found my service helpful please consider upvoting. If you want to send feedback, please send a PM or reply below.
Thanks for the videos and cl-ptraces, Process Hacking is fun.
A question for the mods here: Can we start banning users like bitwiggler who contribute nothing and only wish to inject vitriol, politics and derision into the conversation? We have enough of this crap in the rest of reddit, we should be severly filtering out politicos wherever possible. There is a time and place for politics, but it isn't on a technical sub.
Here's the link to the project: https://emina.github.io/rosette But I recommend watching the video for a very good introduction.
https://www.reddit.com/r/lisp/comments/63pox8/lisp_discord_server/dfwyujw/ Are you really sure you are ready to throw stones?
But the object being shrunk, the SBCL core, lives and runs on the server, and furthermore is very platform dependent. Shrinking the Lisp core may save on memory/load time on the server end, but it should have no effect whatsoever on the quantity of data transferred to a web client.
Aw that's a bummer, you had a nice update, looked cool, but then threw it away on slinging insults. True there are probably folks here who you've had these kinds of arguments with but there also us newer folks who have not been involved in these wars who are only judging ISLisp (and the community) based on posts like these. Can't say I feel to optimistic being welcome so far.
It's based on many comments to the effect "This is for Common lisp discussion only" in places labelled "Lisp".
So it's ok to recommend to force things up our anus? But not critique the fact lisp has been hijacked to mean only Common lisp?
Great! I'd love to hear how you get on with it.
From MIDI example: (defun sleep (n) (for ((i (* n 1000000) (- i 1))) ((&lt;= i 0) t))) Ouch, CPU busy loop! why not just `c-lang` a call to Win32 `Sleep`? (c-lang "midiOutShortMsg(hMidiOut,MIDIMSG((BYTE)(INT_MASK &amp; ST),(BYTE)(INT_MASK &amp; CH),(BYTE)(INT_MASK &amp; D1),(BYTE)(INT_MASK &amp; D2)));") I would move the casting and masking into the `MIDIMSG` macro, so this can just be `MIDIMSG(ST, CH, D1, D2)`.
As you say. Sleep API is better. I had forgotten it. Please improve freely. Kenichi Sasagawa
As well, good point. You are correct, I am wrong.
By RTFM, I found this: http://www.echolalie.org/echolisp/echolisp.zip 
There's also an email address if you'd like to contact the authors, Georges Brougnard and Jacques Tramu. It's at the bottom of the manual: http://www.echolalie.org/echolisp/help.html
How do you handle situations where some variable or function is only referenced dynamically? i.e. something like (defun foo (next) (funcall (symbol-function next))) 
So not all features can be used at any time. Each reduction method should be turned on/off based on your need. https://github.com/roswell/roswell/blob/master/documents/ros-dump.md#image-reduction-options 
https://github.com/trivial-gray-streams/trivial-gray-streams
Besides Gray streams, Allegro CL has its own set of stream classes, simple-streams, another interesting design: https://franz.com/support/documentation/10.1/doc/streams.htm
The purpose of gray streams is to integrate with Common Lisp, and to allow you to pass them around between applications transparently. Thus the support is geared towards the CL standard read-char/byte/sequence. There wouldn't be any point in introducing an additional "read-element" construct if you had to depend on an extra library to get it. Might as well get a lazy sequence library in the first place then.
Yeah, but the original plan was for Gray streams to be part of ANSI, right? I would've preferred read-char/byte/sequence to have been a special case of a more generic stream API. Does that make sense?
I guess so. I just don't see too much value in that, since streams are primarily used for exchange between the "outside world" and Lisp, for which usually only bytes and characters are somewhat well specified. For lazy sequences within lisp you could simply pass around closures or lay out a more specific protocol that fits your problem.
I think a direct implementation of delimited continuations as an extension to some of the CL compilers would be the solution for this. https://sourceforge.net/p/sbcl/mailman/message/32755039/ [1] Kiselyov, O. (2012): Delimited Control in OCaml, Abstractly and Concretely [2] Gasbichler, M. and Sperber, M. (2002): [Final Shift for Call/cc: Direct Implementation of Shift and Reset](http://www.deinprogramm.de/sperber/papers/shift-reset-direct.pdf) [3] Flatt, M., Gang, Y., Findler, R. and Felleisen, M. (2007): Adding Delimited and Composable Control to a Production Programming Environment But I'm not up to the task. 
Thank you. As a side note: therefore RESTAS doesn't use "standard" GET parameters, like `/users/home?username=Taikal`, right?
To me the value is primarily to have a unified way of saying "here's a thing that gives out things" without having that being defined further than that. I just like having a language define a broad and easily extensible way of doing certain things, and I think streams could have been broader without introducing a weird/leaky abstraction.
##CDR coding In computer science CDR coding is a compressed data representation for Lisp linked lists. It was developed and patented by the MIT Artificial Intelligence Laboratory, and implemented in computer hardware in a number of Lisp machines derived from the MIT CADR. CDR coding is in fact a fairly general idea; whenever a data object A ends in a reference to another data structure B, we can instead place the structure B itself there, overlapping and running off the end of A. By doing this we free the space required by the reference, which can add up if done many times, and also improve locality of reference, enhancing performance on modern machines. The transformation is especially effective for the cons-based lists it was created for; we free about half of the space for each node we perform this transformation on. It is not always possible to perform this substitution, because there might not be a large enough chunk of free space beyond the end of A. Thus, some objects will end in a real reference, and some with the referenced object, and the machine must be able to tell by reading the final cell which one it is. This can be accomplished with some inefficiency in software by the use of tagged pointers, which allow a pointer in a final position to be specifically tagged as such, but is best done in hardware. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^] ^Downvote ^to ^remove ^| ^v0.2
Congrats! This is great news.
I said: in web development in general. Obviously tree shaking is beneficial for desktop applications as well for same reasons.
We're discussing the tree shaking of a *lisp image*, a platform specific binary, which provides a web service; this is *not* the data sent over the wire. This will change a binary on a server, but it will have *no effect whatsoever* on the data sent assuming the tree shaker does the job correctly. Why is this simple concept so hard to convey to you? Are you trolling me? If so, please stop!
Great! Looking forward to it
I use Clojure on JVM. Haven't used ABCL, but used other CL implementations. So, what I say is going to be a bit speculative. AFAIK, ABCL, as it tries to adhere to CL standard, is a bit slow. Especially its CLOS implementation as JVM doesn't natively support all what is possible with CLOS: multi-methods, on-the-fly class change, etc. Clojure is a different kind of a beast. It doesn't support OOP. It has built-in efficiently implemented immutable data-structures (vectors, maps and sets). Clojure functions compile down to JVM classes with a single method. It has multi-methods similar to CLOS, but they are used extremely sparingly as they are also slow. It does support fast generic method dispatch on the first argument (via protocols, essentially compiles to JVM interfaces). It is more constrained as a language compared to CL: no reader-macros, no OOP, no direct assignment and mutation etc. Also, tooling is a bit worse: debugger (via CIDER or SAYID) is crippled, profiling... well almost non-existent (not sure how good it is in ABCL, in SBCL it is great), no `TRACE` analog... Having said this, I find I get things done faster in Clojure than in CL.
I think the intent was to point out that CL's object model isn't compatible with Java. This is obvious since CLOS is so much more capable. That does mean that if you integrate with Java you have two different models at the same time. This can make integration a bit less smooth than with Clojure. That said, I don't think this is a strong enough reason to choose Clojure. I definitely prefer ABCL for many reasons
&gt; I think the intent was to point out that CL's object model isn't compatible with Java. That's true. I kind of missed that he was talking about the slowness and not about the feature completeness. In the implementation we can see that a CLOS instance is a Java instance, but the CLOS slots seem not to be Java attributes. Instead the Java instance has a vector for the slot values. This means that there are added indirections and not a direct mapping of CLOS concepts to corresponding Java facilities (classes, inheritance, attributes, ...). That makes it slower than a full instance to instance mapping. But any CLOS implementation will be slower than single-inheritance OOP with fixed classes for instances. Though I would expect that most of the CLOS+MOP features would be implemented somehow. It could also be that some further implementation speedup would require more effort. Would be interesting to hear from the implementors what they think about optimizing their CLOS implementation.
&gt; be aware that many parts of RESTAS's English documentation are outdated. Thanks for having warned me. This is bad news. Then I will stick to bare HUNCHENTOOT:DEFINE-EASY-HANDLER.
That's one of those comments most wanted by us poor souls, which first language is not the English one. Thank you.
Second Amendment to the U.S. Constitution: &gt; A well regulated Militia, being necessary to the security of a free State, the right of the people to keep and bear Arms, shall not be infringed. The first ten amendments are commonly called the Bill of Rights.
You're not wrong on those points, but never having used ABCL, I have no idea what the answers are.
To clarify, the English documentations I was referring to were those in this [doc](https://github.com/archimag/restas/tree/master/docs) folder inside RESTAS source. The dev has also acknowledge this, and new documentations is a WIP. To prevent confusion, the dev has taken the outdated documentations down from RESTAS site. Even so, most of the stuffs in the old documentations about routes and parameterized routes are still relevant (and that's why I referred you to the above link in the first place). It's the more "advance" stuffs (e.g., how to use RESTAS modules) that's problematic. The docstrings inside the code itself (where Quickdocs used to generated the API references) should be up-to-date.
In ABCL, Lisp may call into Java code and vice versa, see [chapter 3 of the User Manual](http://abcl.org/releases/1.5.0/abcl-1.5.0.pdf) for the extensive details of Java/Lisp interoperability. [ABCL-ASDF](https://gitlab.common-lisp.net/abcl/abcl/blob/master/contrib/abcl-asdf/README.markdown) provides integration with the distributed Maven POM graph so that Java libraries may be easily downloaded and used. So, for a system defined in `log4j.asd` as follows: (defsystem log4j :components ((:mvn "log4j/log4j/1.2.13"))) the following would output the message "Kilroy wuz here" to the log4j logging system. (asdf:make :log4j) (let ((logger (#"getLogger" 'log4j.Logger (symbol-name (gensym))))) (#"trace" logger "Kilroy wuz here.")) For "real" native libraries, ABCL can link to arbitrary shared object/dlls via [CFFI](https://github.com/cffi/cffi).
&gt; have not used ABCL, since it took way to long to start for my taste, with roswell it works out of the box. just to note.
The lack of cross-platform support is one of the major factors that have kept me from looking into McCLIM. I'd rather use a foreign system like Qt and have to bear all the warts that come with it, than sacrifice being able to distribute my applications to most users.
&gt; better recursion semantics I'm not sure I knew that they were different. Isn't it as simple as a function call in both languages?
What is mcclim?
McCLIM is a Common Lisp Interface Manager implementation. Basically GUI toolkit for Lisp. For more information please consult project web page located at https://common-lisp.net/project/mcclim/ .
Clojure uses `recur` to get around limits on recursion optimization built into the JVM. 
Note that when you `apply` arguments to a function, you will run into a limit on number of function arguments. The recursive version, if not tail optimized, can "blow the stack" for a sufficiently large input. It won't be tail optimized even if that optimization is available, because it isn't tail recursive; first you have to rewrite it to tail recursion: (defun sum-list1 (L &amp;optional (accum 0)) (if (null L) accum (sum-list1 (rest L) (+ (first L) accum)))) ;; Also, please close the parens like this, for the love of all that is Lisp! I would benchmark these contenders: (loop for x in list summing x) (reduce #'+ list) plus the accum recursive version, if tail optimized. 
That investigation speaks nothing about whether `+` is recursive; it just says that SBCL has done a good quality job in the area of function argument limitations, far exceeding the minimum requirements required by ANSI CL.
That sounds nice. Thank you.
Clojure can be performant, but it's also a bit too easy to write code that runs like a three legged dog. :-(
Ah that makes sense. thanks for explaining. 
I believe you didn't read my previous post carefully, so I won't bother answering some concerns I have already answered.
heheh, I like the term "pringles" :)
That sounds sooo dangerous. What's wrong with paredit?
It's a respectable old idea, all the way from Interlisp. In these days of interactive editing, it's better to have an editor command for that, so you can see exactly which parentheses you are closing.
&gt;Latest commit c36644f on Jan 5, 2016, 7 contributors I don't. 
Ick - breaks the visual balance of a bunch of closing parentheses. Why do people have such a problem with parentheses?
This could change what LISP acronym stands for (lots of irritating superfluous parentheses -&gt; ????)
I think most people when they try common lisp , use a simple editor like notepad. I can see them counting parens and getting frustrated . They start bitching even before getting to any of the good stuff and quit. There must be a beginner's editor which does structured editing (not emacs /paredit/slime, that learning curve will drive them away faster) to protect noobs from paren counting hassle. Dr. Racket like, noob friendly and cross platform ?
I have experimented with that C style, and, no it doesn't. Here is the example `malloc` from the K&amp;R2, reworked into this style: void *malloc(unsigned nbytes) { Header *p, *prevp; Header *morecore(unsigned); unsigned nunits; nunits = (nbytes + sizeof (Header) - 1)/sizeof (header) + 1; if ((prevp = freep) == NULL) /* no free list yet */ { base.s.ptr = freeptr = prevptr = &amp;base; base.s.size = 0; } for (p = prevp-&gt;s.ptr; ; prevp = p, p = p-&gt;s.ptr) { if (p-&gt;s.size &gt;= nunits) /* big enough */ { if (p-&gt;s.size == nunits) /* exactly */ prevp-&gt;s.ptr = p-&gt;s.ptr; else /* allocate tail end */ { p-&gt;s.size -= nunits; p += p-&gt;s.size; p-&gt;s.size = nunits; } freep = prevp; return (void *)(p+1); } if (p == freep) /* wrapped around free list */ if ((p = morecore(nunits)) == NULL) return NULL; } } /* none left */ 
"pringles" is easy; I love the crunchy softness of sfogliatelle. My vote goes towards the Italians.
That's your opinion; the style is perfectly workable and logical. All the code is nicely indented, so that even if we white-out all of the braces we still see the structure. The brace placement follows simple rules. I think what makes the example look ugly is the largely useless, cluttering comments on the right. Let's remove them. Start with this pseudo-C: indentation indicates structure, like in Python: for (p = prevp-&gt;s.ptr; ; prevp = p, p = p-&gt;s.ptr) if (p-&gt;s.size &gt;= nunits) if (p-&gt;s.size == nunits) prevp-&gt;s.ptr = p-&gt;s.ptr; else p-&gt;s.size -= nunits; p += p-&gt;s.size; p-&gt;s.size = nunits; freep = prevp; return (void *)(p+1); if (p == freep) if ((p = morecore(nunits)) == NULL) return NULL; Add braces, mechanically: for (p = prevp-&gt;s.ptr; ; prevp = p, p = p-&gt;s.ptr) { if (p-&gt;s.size &gt;= nunits) { if (p-&gt;s.size == nunits) prevp-&gt;s.ptr = p-&gt;s.ptr; else { p-&gt;s.size -= nunits; p += p-&gt;s.size; p-&gt;s.size = nunits; } freep = prevp; return (void *)(p+1); } if (p == freep) if ((p = morecore(nunits)) == NULL) return NULL; } } The rules are very simple. Every indented block consisting of more than one line needs an opening and closing brace. That is to say: line; // lone line is left alone // But this is transformed: line line; line line; line; line // like this: { line // first line of indented block gets { line; line; line; line; line; } // last line gets } We apply that recursively at every indentation level: { line line; line; { line; // thus we need it here line; } line; } Closing `}` get pringled, so if we delete the last line: { line line; line; { line; line; } } // closing bace moves up I put spaces between the closing curly's when using this style. One reason is that if two braces ever open consecutively, there is a space: if (...) { { little block } ^ statement; ^ statement } ^ consistent indentation level of two spaces That's it; you could easily now code with this all day. 
To me it looks simply familiar (Python style): [ecl_fun.cpp](https://gitlab.com/eql/EQL5/blob/master/src/ecl_fun.cpp)
&gt; I think most people when they try common lisp , use a simple editor like notepad. Literally had a professor that thought printing out the program and counting the number of parens with a pencil was the right way to go. But it's 2017 - even the most basic text editor meant for coding will show you when your brackets match. And if you have basic lisp indentation for your editor, you're golden. I'm a vimmer so I like the power you get with vim-sexp (basically vim's ripoff of paraedit), and I miss the powerful code manipulations in other languages, but you can totally get by without paraedit. I was fine with vanilla vim for a while before I found vim-sexp.
&gt; It's not K&amp;R and it's not kernel. It's not even GNU It's neither the Father, the Son, nor the Holy Spirit, amen. &gt; *The reason people don't like pringles at the end of code because it just doesn't look pleasant* There has been a study of this? Most C programmers **have not seen this**. We have no idea how many would or would not warm up to it. 
Don't get me wrong -- I love Lisp, and I've been an enthusiast for about 20 years now. But my fun language *du jour* is Forth, and I'm really enjoying the world of minimalism right now. Reading Chuck Moore's material on software bloat is very thought provoking. It just infuriates me when I touch a button on my smart phone, which has 4 cores running at 2.1GHz, and it takes multiple seconds to respond. My Windows tablet has an on-screen keyboard which is not, somehow, the highest priority process at all times. I just don't understand. If everybody spends a a few percent of waste at whatever layer of abstraction where they're working, it all adds up eventually. What I figure is that every little bit of conservation helps. You can write svelte code in Common Lisp, but the size of the base image is still unbelievably large. 
I think procmail was written in that style, at least originally. That's at least one once decently popular potential source of memetic infection. It didn't seem to have spread. My guess is that it never spread because the style breaks line-oriented editing.
I never said there aren't other backends, pay attention to what I'm writing. Moreover, I suggest you actually try using those "other backends" and come back to me. Just because other backends exist, in some sorry state of affairs, doesn't negate what I said. Realistically, McCLIM is unusable on anything but Xwindows. For users who might be willing to put up with the general miasma of X and are used to other platforms (OSX, Windows), McCLIM comes across as a bad joke. For those who can't stand Xwindows, McCLIM doesn't even exist. Good luck attracting users with that. 
Good point; you can't swap any two lines of a compound statement just by doing `ddp` in your Vi. Or, more importantly, start adding a new statement just by opening a new line below the last one, the same way as adding a statement anywhere else in the compound. I wouldn't expect that the procmail internals would be influential, though. 
I would be really interested in a comparison of Qt/QML and McCLIM. Anyone?
Well it is not so infortunate as gray-streams can always be implemented on top of cl-stream. The main concern here is with asynchronous reads and writes which are consistently allowed by cl-stream. Also cl-stream streams can have any element type, not just characters and bytes. I still do not understand this limitation from the Common Lisp standard. Gray streams only have listen and read-char-no-hang which are quite insufficient for many purposes.
&gt; I just prefer lisps inspired by Scheme to ones with CL heritage Are you aware that CL was inspired by Scheme? 
Here is me going over your short term goals list and commenting accordingly: * Fix the issues from the tracker = Good, I guess, for those issues that are not relevant to X * Improve current CLX backend (visually and internally) = Total waste of time. It does not inspire confidence to see resources squandered in such dead-ends as X. * Replace clim-mop with closer-mop portability layer = Good but can be postponed. * Identify utilities used in all util.lisp files and if applicable replace them with the counterparts from the alexandria library = Good but can be postponed. * Provide more learning material for the new users = Pretty much a waste of time right now. It's not lack of learning material that drives users away. * Revise the manual draft and the documentation = See above * Identify which features from the "traditional" GUI libraries McCLIM users miss and implement them as an extension = See above * Check feasibility of implementing asynchronous usage from the outside of event and command loops (for instance from the Slime REPL) = Might be useful but other things more important. So from your short-term goals, almost nothing helps to attract new users. Your long term goals (especially the first 3) are the ones you should be focusing 100% on. Not long-term, not "in the future", but right now. It boggles the mind that you don't see this. 
&gt;APPLY is subject to CALL-ARGUMENTS-LIMIT which can be as low as 50. If it is that low, you're better off switching to another Lisp. SBCL&gt; call-arguments-limit 4611686018427387903 Reduce adds by 2 arguments each time, which is slow. Even if you have call-arguments-limit 50, it's better to add up by 50 arguments to avoid function call penalty as much as possible.
Absolutely love your videos... keep them coming..... I have a big question about this video though. You said a variety of times (especially with regards to stemcells and such) something like "...this is not something you want to expose to your users...". Who are you thinking of as my users in this case? Are you assuming that I would be making a game-engine or framework on top of Varijo that other people would use? For my purposes, I am looking to make a game. My users should have no interaction at all with the shaders let alone to the level of stemcells. So, when you say, "my users", should I be translating that to mean "myself in coding the layer of my application right above Varijo"?
I can't keep up with your video output. I'm partway through your second video lol
thanks! Ah yeah this is my bias showing, I forget that people would use this in a game 'as is' and assumed anyone interested would also me making as a engine or framework. Sorry about that! Also super dumb on my part as one of the coolest uses of Varjo so far has been by 박성민 https://www.youtube.com/watch?v=Tsc5AjHZR2Q
I've worked on encryption tools built in to the Quicklisp bootstrap and Quicklisp client. The primitives are done - I can verify PGP-signed bootstrap and library files fetched over insecure HTTP. It has to be rolled out so that publishing the dist publishes the proper signatures, and the client has to be updated to actually do the verification. This is on a branch and hasn't been pushed to github yet. I've also started working on a user manual and a developer/internals manual. I've also been working for another company on a CL project, so I haven't been able to push QL forward as much as I want, but it's progressing.
So, lexical scope does not matter to you? Have you met with the standardising crew? There is a lot more scheme in CL than you are saying. If you think that Lua, inspired by scheme, is the same as CL being standardised as a Common Lisp, including a major thing brought in by Scheme (lexical scope), I will let you win your battle because I won't fight in that war. :)
I know there are some SBCL and CCL maintainers on this reddit: can you characterize how hard it is likely to be to add this feature?
&gt; Finally, Clojure's closeness to the platform it's hosted on — JVM, CLR, or javascript — is both a pro and a con. This is the big deal killer for me. Clojure feels like a thin syntax wrapper not unlike the dozens of amateur "Scheme in JavaScript" projects out there. *This* is supposed to be a modern Lisp?
[Arcadia](https://github.com/kimtg/arcadia) is Arc written in C.
and how is this related to the topic?
yes that's true. but it shows that arc can indeed be used for practical development.
But that means you can't just grab a bunch of libraries other people wrote to avoid coding the boring parts yourself. It's pretty hard to build non-trivial software from scratch and just because Paul Graham can do it doesn't mean anyone can.
you are not a tacit programming fan eh? :D
I hang out on the [Arc Forum](http://arclanguage.org/forum). There's still a few of us there, but none of us seems to be programming Arc on a daily basis, as far as I can tell. I'd say it's super useful as a gateway drug to Lisp, but if you're already productive with some other Lisp there isn't much point to learning Arc anymore. Given the lack of community it's not as polished, so if you try it out expect to put some time in figuring out simple things or waiting for responses on the Forum. That can be very rewarding over long periods, but it can also be frustrating if you're just trying to build something in a short period.
Right; conciseness is good in `rplacd`, but not necessary in `(mutiple-value-bind (x y z) ....)` or `(open ... :direction :output :if-does-not-exist :create :if-exists :overwrite ...)`. Speaking of that one, if there is `:direction :io`, why is there `:direction :input` or `:direction :output` rather than `:direction :i` and `:direction :o`. Also, `:in t :out t` is shorter than `:direction :io`! Two keys could have been provided, at least one of which has to be `t`, and which default to `nil`, providing conciseness without reducing "input" to "i" and "output" to "o".
Thanks for the heads up! Lots of interesting topics this year.
Op here, i'm working on a project for my job that requires a poc involving text-to-speech/speech-to-text layers over my core system. I've finished my portion and i've got some time to kill, so I thought it'd be cool to show a build that involved hardware, but i've NEVER worked with hardware before. My question is, would this be a viable starting point? I'm also worried that there won't be enough memory if the microprocessor had to load my entire system, is there any way to link between ulisp and say, common lisp?
I'm confused, when you say Hardware, are you referring to Raspberry Pi, or Arduino, of something like that?
ssyntax. Not sure how user extensible it is, but that would make it even better.
I used EMACS in ITS some years ago to edit MacLisp files. There was an inferior Lisp process. The experience was similar to using SLIME today, but not with as many features.
From what I understand SEdit was developed later than DEdit. SEdit is documented first in the 1987 Lyric release of Interlisp-D, see Appendix B: http://bitsavers.trailing-edge.com/pdf/xerox/interlisp-d/198706_Lyric/198706_3102434_Lyric_Release_Notes.pdf SEdit is expanded in the virtual machine version of Interlisp-D, called Medley. See the Medley 1.0 release notes, appendix B: http://bitsavers.trailing-edge.com/pdf/xerox/interlisp-d/198809_Medley_1.0/400006_Lisp_Release_Notes_Medley_Release_1.0_Sep88.pdf Some hints for using SEdit http://bitsavers.trailing-edge.com/pdf/xerox/interlisp-d/hotline/04_19871002.pdf If you want to try it out, maybe this contains the editors: http://www2.parc.com/isl/groups/nltt/medley/ Here is a demo: http://people.csail.mit.edu/riastradh/InterlispSEdit.mov.bz2 
SECTION | CONTENT :--|:-- Title | Mecrisp Forth on STM32 Microcontroller (blue pill) Description | Maybe a little different from your usual microcontroller video -- I show some of the fun I've been having with the interactive programming environment provided by Mecrisp on a cheap ($2) microcontroller dev board. I tried big font sizes, but it's perhaps only really readable in HD -- sorry! (OK, looks readable in 480p... *whew*) Length | 0:30:54 **** ^(I am a bot, this is an auto-generated reply | )^[Info](https://www.reddit.com/u/video_descriptionbot) ^| ^[Feedback](https://www.reddit.com/message/compose/?to=video_descriptionbot&amp;subject=Feedback) ^| ^(Reply STOP to opt out permanently)
@1:33 "I'm good at ugly, we can do this" haha
The uLisp link should've make it clear, but in any case uLisp is a language targeting Arduino microcontrollers.
They'd be second-hand accounts. I was a lad when they were full-throttle already and a peasant when primitive text-only java was beginning to displace them.
Thanks for reply. I do know what the types are in each case. HyperSpec code examples stick to (:key value) arrangement, but then again browsing other people's code I find a lot of (:key :value) pairs which I can convert to (:key value) without any errors. I'm very curious why people use (:key :value) so much because it makes things insanely different to understand. Case example: I was showing some such lisp code to non-lisper and he asked "oh whats that double-dot thingy?" "it signals key value" "is that key referencing another key?" and I was liek "....that's a very good question". And here I am. Their wide usage signals to me there is some inherent value to using them which I haven't figured out. Or that's my train of thought on this matter in any case. EDIT: here is common code example (with-open-file (stream file :direction :output :if-exists :rename-and-delete) 
I totally do this when I have to write in see or javascript. I think it looks silly having all the extra whitespace.
A few more hints on how to play with Interlisp-D and SEdit: The LFG Grammar Writers Workbench application above is actually at [this FTP site](ftp://ftp.parc.xerox.com/pub/lfg/). It's in an Interlisp-D sysout image file, and there are many D-machine emulator programs there for different platforms. The emulator for linux can be run under a back version of Debian (see [here](https://stackoverflow.com/questions/11495523/run-a-very-old-interlisp-program) for details). The sysout above actually contains both Interlisp-D and Xerox Common Lisp, and you can use SEdit with Common Lisp (see [here](https://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03457.html)).
what a load of crap..
STOP
Just like today, many would use emacs. Emacs is ancient. 
A good answer that I stumbled upon on `#lisp` on Freenode is "it's a keyword, it's basically an enum that you don't need to declare". Keywords are handy because they're easily accessible from each package because of the colon shortcut. If you used symbols from a different package, you would need to use their fully qualified names, such as `foo:bar` (symbol `BAR` from package `FOO`) or keep them imported, which might cause conflicts.
&gt;not even as a local function technically you can make a CL-package symbol a local function. Just need to be slick. CL-USER&gt; (defpackage foo) #&lt;PACKAGE "FOO"&gt; CL-USER&gt; (in-package :foo) #&lt;COMMON-LISP:PACKAGE "FOO"&gt; FOO&gt; (cl:defun car (x) x) CAR FOO&gt; (car '(1 2 3)) (1 2 3) FOO&gt; (cl:car '(1 2 3)) 1 FOO&gt; (cl:in-package :cl-user) #&lt;PACKAGE "COMMON-LISP-USER"&gt; CL-USER&gt; (defpackage bar (:use :cl) (:shadow "CAR")) #&lt;PACKAGE "BAR"&gt; CL-USER&gt; (in-package :bar) #&lt;PACKAGE "BAR"&gt; BAR&gt; (defun car (x) x) CAR BAR&gt; (car '(1 2 3)) (1 2 3) BAR&gt; (cl:car '(1 2 3)) 1 BAR&gt; 
&gt; Don't use symbols for arbitrary values, use strings. Interesting statement. Could you elaborate on why? In Erlang for example representing arbitrary values with atoms (symbols) is the norm. I also believe much focus was given to Lisp being a symbolic language earlier on in our history, and early examples often use lists of symbols to represent actual text (like in "Paradigm of Artificial Intelligence Programming"). So what main drawbacks do you base your general advice on?
Symbols are strings with a package attached. If you want to represent values you should use strings directly, faster, less space, they get to be garbage collected (since the package doesn't hold them), which is a safety concern, e.g. an API parsing JSON into symbols, it can quickly accumulate a lot of symbols that are never collected. Sometimes symbols are useful, usually when there's a limited set of values, something like :on/:off etc, since that makes things faster to compare and since they are interned, less memory is used.
Valuable insights, thanks. I had not considered the GC aspect. I guess the way I've typically been parsing arbitrary JSON with cl-json, making all field names into keywords, could be suboptimal and even a dangerous "memory leak" in some scenarios. Think it makes sense to profile important cases though.., if you then do a lot of lookups based on strings for instance, instead of keywords, intuitively I think that should have a higher cost. Always tradeoffs :)
"Peasant" programmers?
You know the type: basic, pascal, c barbarians...
One other advantage to keywords that I didn't see called out when I browsed through the replies here are that keywords evaluate to themselves. So, the value of the keyword :foo is :foo. If you use a symbol that is not a keyword, then you would have to explicitly give it a value or be careful to always use it in contexts where it won't be evaluated (e.g. after a single-quote or in a lambda list).
Being a long-time lisp fan, I've always been curious about Hy. I've installed it via pip several times but I've never really dove in. I'll take a look at it tonight to see if it can fit into my development process. Any tips? I've been programming in Python for ~10 years and I maintain several Python tools centered around machine learning, plotting and data analysis. 
Coincidentally, data analysis is my day job. There are some macros you might want to crib from [my personal utility library](https://github.com/Kodiologist/Kodhy/blob/master/kodhy/macros.hy) for working with Pandas and NumPy objects (`geta`, `getl`, `$`, `ss`, `wc`, etc.).
The Little Lisper calls them "aggravation parentheses". Which I've become attached to.
I got Debian 3 running in virtualbox with this [video tutorial](https://www.youtube.com/watch?v=zxqCyNyoQG4), but I still can't access the internet from it. I'm at the last step of trying to get the two LFG files onto the VM, but can't seem to make that happen without the network bridge working.
It would be nice if everything that was convenient in Python was also convenient in Hy. Every time I see a release announcement I check to see if they've added Python-style comprehensions to Hy. So far it's still only a limited form that allows only one for-clause and one optional if-clause. I feel as if they've added support for exactly those comprehensions that don't need it: the simple ones where rewriting in terms of map and filter is just as readable as the comprehension.
Is the Hy macro system not up to making comprehensions? Or are you just waiting for the benevolent dictator to make one for you, out of learned helplessness? 
7 part series actually...
I really love this project, one quick question,would it be possible to use this with WebGl?
Afraid not, CEPL is a common lisp project and I'm not aware of anything that could make it run 'as is' on JS. Varjo, the lisp-&gt;glsl compiler could be used for generating glsl that is compatible with modern WebGL. However to make it a proper target for the compiler someone would need to go to [glsl-spec](https://github.com/cbaggers/glsl-spec/blob/master/functions.lisp) and update all the `:version` data to say what functions/variables/etc are available on what version of WebGL. 
MOCL is being maintained and the author responds to mail.
[Watch this](https://www.youtube.com/watch?v=HB6HvhOw_MY&amp;feature=youtu.be&amp;t=15s). I made it in 1979 and some people used it until 1995 (But not me :-).
SECTION | CONTENT :--|:-- Title | Nokolisp Editor and other Tools Description | Watch the operation of Nokolisp S-expression editor, written in 1978. Nokolisp had no strings and symbols could have any character, except parenthesis and white space. http://timonoko.github.io/Nokolisp.htm Nokolisp codebase now in Github: https://github.com/timonoko Length | 0:03:03 **** ^(I am a bot, this is an auto-generated reply | )^[Info](https://www.reddit.com/u/video_descriptionbot) ^| ^[Feedback](https://www.reddit.com/message/compose/?to=video_descriptionbot&amp;subject=Feedback) ^| ^(Reply STOP to opt out permanently)
I just spent the weekend watching your videos, I had to catch up, I will like to thank you because you took the time to do something from scratch which gave me the opportunity to see how all the pieces are put together. I am curious about skitter based on your latest stream, and doing something "Playable" seems like a good way to combine what you have been streaming with skitter. Your idea sounded like 3D Galaga, which might be cool. 
TLDR; https://github.com/shaunlebron/history-of-lisp-editing we saw this link this week since he asked a question here.
Do just the lambda.
I concur. https://www.youtube.com/watch?v=gjsQdV3VDUs
https://github.com/blakemcbride/LispEdit http://dl.acm.org/citation.cfm?id=16255 http://dl.acm.org/citation.cfm?id=356754 http://www.informatimago.com/develop/lisp/com/informatimago/small-cl-pgms/sedit/index.html.in https://www.fbi.h-da.de/fileadmin/personal/b.humm/Publikationen/Gomolka_Humm_-_Structure_Editors__Springer_ENASE_.pdf http://cheery.github.io/lisp-editor/ https://boxbase.org/entries/2014/aug/25/back-to-visual-programming/ https://www.cs.ox.ac.uk/files/3299/PRG32%20vol%201.pdf https://devhub.io/zh/repos/robert-strandh-Climed http://www.rwapadventures.com/ql_wiki/index.php?title=METACOMCO%20LISP https://www.youtube.com/watch?v=nHh00VPT7L4 
Just FYI the lambda tattoo's often used as a gay symbol. There's nothing wrong with that and I'm not discouraging you from getting one but YSK that before you take the plunge. 
[its been used as a gay rights symbol since the 70s.](https://en.m.wikipedia.org/wiki/LGBT_symbols#Lambda) You may have heard of Lambda Legal, one of the largest gay rights lobbying groups in the US.
**LGBT symbols: Lambda** In the early 1970s, graphic designer Tom Doerr selected the Greek letter lambda to be the symbol of the New York chapter of the Gay Activists Alliance. The alliance's literature states that Doerr chose the symbol specifically for its denotative meaning in the context of chemistry and physics: "a complete exchange of energy–that moment or span of time witness to absolute activity". Within the STEM field, the lambda symbol is associated with the half-life parameter of exponential random variables, which describes the time it takes for a state to change. In December 1974, the lambda was officially declared the international symbol for gay and lesbian rights by the International Gay Rights Congress in Edinburgh, Scotland. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
Non-Mobile link: https://en.wikipedia.org/wiki/LGBT_symbols#Lambda *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^85170
A very sexy butt.
how about recursive? (λ λ) :)
Words always have multiple meanings, so if OP wants a tattoo because they love lisp that's great. It's not like they're gonna get jumped by a bunch of guys (or girls) in the street or anything. 
haha that's awesome! I had exactly the reaction you did. &gt; Me: Mentioning a lambda tattoo when I was deep into OCaml and lisp &gt; friend: explains gay symbol status &gt; Me: Oh sweet.
they might get hit on a bit more :P
if you say IO to a programmer he knows what it is. If you say I or O, you're being vague. and i love :in t :out t that's hilarious
It doesn't make any difference to anyone what they "really mean", and people's beliefs about them are completely irrelevant with regards to how intuitive they find them.
never thought about the musical origin for the symbols. I play the piano, I know them, but never thought they might have preceded their math usage. I know Euler was probably the one to use them, as he was pretty much the originator of modern symbolic math notation. He's born in 1707, more than 20 years after Bach, thus. But weirdly enough, baroque performance practice had terraced dynamics: either forte or piano or normal. Not so sure if crescendo and decrescendo were part of standard musical notation then. Then again, I only know notation for keyboard music for the period and, as the pianoforte was just about to be invented and harpsichord without dynamics was king, alas, no crescendo in the sheets... anyway, fascinating...
&gt; *people's beliefs about them are completely irrelevant with regards to how intuitive they find them.* Are you positing that as a fact of cognitive science? (It perhaps does hold for values of *people* being elements of the "set *engineers afflicted with Asperger's syndrome.*") 
Learning lisp will alter the way you solve problems. At first it may seem counter-intuitive or difficult but if you work at it enough learning lisp allows you to make your programming language fit your specific problem rather than trying to craft your problem to fit your chosen language, especially if you remain in lisp. "Lisp is worth learning for the profound enlightenment experience you will have when you finally get it; that experience will make you a better programmer for the rest of your days, even if you never actually use Lisp itself a lot." -Eric Raymond, "How to Become a Hacker" This is true and I encourage you to explore why. A gripping story that got me to explore lisp was of how NASA debugged a live, running system on deep space one after it encountered an error...100 million miles away in space never to be recovered by humanity, and let it go it on its way after fixing it as if no problem ever occurred (look it up, it's worth reading). This and many other stories impressed me to a point of looking into this language. I hope you look into it too as well as learn how to hack better than ever because of it.
Can you give any examples from your personal experience of the power of lisp?
How about SICP's [Eval/Apply](https://i.warosu.org/data/sci/img/0070/22/1421815315289.jpg) logo? It's more unique to Lisp than a lambda.
It's probably a safe bet that someone using `#+` already understands that this is a build-time mechanism and not a run-time check. 
I wouldn't lose any sleep over it. Consider that, compared to a Lisp programmer pushing a custom identifier into `*features*`, a C programmer takes a far greater portability risk each time they define a new file scope identifier (variable, function, struct/enum tag) or macro. They usually don't even know, and it hasn't put a dent in the rampant spread of C programming.
Back in the 80's using Symbolics Lisp Machine, the editor was pretty much EMACS (although technically distinct). Single keystrokes could do huge numbers of different things, and you could write your own keymaps. In addition, you could do many of the same keystrokes outside the editor, in the CLI. Many happy hours were passed doing the same kind of thing in the Cold Load Stream. Slime and other Emacs based things used today pale by comparison. When people moved to (cheaper) Sun Workstations and pc's, much of this was lost, and people used Emacs, with an impoverished environment.
So I can only really speak from experience using sbcl's "save-lisp-and-die", but it is my understanding that si:save-system is similar. When you distribute a binary file, it's platform dependent. That means OS and processor architecture. Java gets around this by distributing .jars, which doesn't run on hardware but rather on the VM. The .exe files don't depend on the user to have any VM installed though, which is a plus. If the user had lisp installed you could just send them source code, but otherwise the easiest thing to do right now (unfortunately) is to get access to a few different computers to compile the code on, and just let people download the correct one. You should only need to compile for a few different os/architecture combinations. You could also write an installer that installs lisp, compiles your project natively, and runs it. As far as your final question, with save-lisp-and-die one can specify a function to run when the executable is opened. Just specify a function that does not contain a REPL and you should be good!
**DO NOT USE** GNU Common Lisp. It is an incomplete, non-compliant, unmaintained implementation. Two popular and well-supported choices are SBCL and CCL (Steel Bank Common Lisp and Clozure Common Lisp). They are single-platform. If you want a Linux binary, build with Linux CL. If you want a Mac OS binary, build with Mac OS CL. Yes, CL images bundle the whole Lisp with the application, so the resulting binary is self-contained. Yes, there is a way - `UIOP` has a `DUMP-IMAGE` function. See https://github.com/fare/asdf/blob/master/uiop/image.lisp for details.
Someone who is already using GCL might find ECL easier to switch to, as they share a common ancestry.
I don't find `(&lt; 2 3)` confusing, but when there is currying with a partial application operator; `(op &lt; 3)` there is that nagging voice in my head which just wants to read that symbol as "less than", leading to "less than three"; i.e. "anonymous function testing for less than three", oops! Nope: it's testing for greater than three. If I replace that reading of the symbol with something else like "crescendo", that goes away for me. The absence of the second operand leads to the ambiguity for me; when you just see `&lt; 3`, the "cognitive pull" of the mathematical infix operator starts to overpower the Lisp framing as a prefix function and the fact that ti's placed between the `op` partial applicator and the `3` reinforces the infix framing. Breaking the mental association with the math symbol entirely is the way to go. Symbolism resembling the crescendo is sometimes used on volume controls: a wedge-like shape sometimes appears on volume knobs both physical and on GUI volume controls. If you don't know crescendo, and find it hard to memorize the Italian music term, you can think "volume up": `(op &lt; 3)`: "volume up from 3". 
[instructions to install roswell](https://github.com/roswell/roswell/wiki/1.-Installation)
Question has some clues that OP may be confused about *features* functionality. First thing - if he knew it well, he wouldn't ask that. Second - he gives multiple GUIs as an example - if you build software once (say - with ASDF) then source code is already read, nothing has changed, so ASDF's cache will take this very build, even if new load-system will be invoked in a system with different features. OP will be confused - he has pushed new flag to *features*, but he has old GUI. Switching GUIs is exact example where OP shouldn't use features (unless he really knows what he's doing – i.e provides a few different flavors of his software each build with a clean cache).
&gt; the #+ just takes the symbol name without the : for keyword. According to spec, "while reading the test, the current package is the KEYWORD package." This means you can use explicitly qualified symbols from one of your own packages and not worry about collisions: #+my-package:guix
After I taught myself a little trick to read these, I find it easier to read than infix notation. Before, I would always get confused if there are 2 operands, like: `(&lt; 1 2)`. What was most confusing was that the number following the less than operator was actually on the wrong side of the operator. But if you consider `(&lt; 1 2 3 4)`, each operand is in increasing order, or `(&gt; 4 3 2 1)` for decreasing order. Thinking in terms of sort order did the trick for me.
Oh... LOL
I copied the beforementioned Nokolisp editor to Symbolics in 1985. I had to do some stupid demo fast, and this solution took only a day. I was not a real Nokolisp code-in-code-editor, but allowed me to edit source code as S-expression data. Those people who saw this and understood the issues, were appalled by the blasphemy. 
It somewhat depends on whether you use the FFI. I’ve seen images dumped on one Linux distribution fail on another because they had differing versions of OpenSSL and the resulting executable was looking for the version it was built with. So you if you use shared libraries via a FFI, expect to have to bundle these with your application.
please define easier?
&gt; *if he knew it well, he wouldn't ask that.* I know `*features*` well, yet I can't claim with authority that there is or isn't some portability problem with pushing random symbols onto it. It's a very good question. (I don't suspect there is a problem, from a pragmatic viewpoint; I wouldn't lose any sleep over it.) The main reason that I think that pushing your symbol onto `*features*` can be GRAS (generally regarded as safe) is this: it influeces the *reading* of code. But your Lisp implementation consists of compiled code. Nothing you push into `*features*` should have any effect on those parts of your Lisp environment, which come to you compiled. This is in stark contrast to something like C, where if you `#define` some identifier, you do have to worry about interfering with your implementation, because when C programs are processed, they pull in the raw text from implementation header files. If you modify `*features*` and then process some third party source code, then there is a risk that the code is testing for the presence or absence of the very symbol you pushed onto `*features*` (giving that symbol its own meaning, of course). However, you have that code in plain sight, so you can examine what, if anything, it happens to be testing using the `#+` or `#-` syntax. &gt; *Switching GUIs is exact example where OP shouldn't use features* In Lisp we could design things so that we can switch between GUI toolkits without stopping the application, but I don't suspect it's a common practice. Usually the GUI toolkit and its API are hard-coded into the application's build. "Version X of program Y on platform Z uses the W window toolkit" and that's it. Someone whose code targets a particular GUI interface at build time rather than when the application is running has made a justifiable technical decision; we cannot reasonably suspect that the developer is one who doesn't know when it is appropriate to use a build-time switch versus run-time. 
SEdit's main reason for existing was to make it possible to write Common Lisp code using the Interlisp-D file manager. For the Interlisp-D file manager to work, code has to be really homoiconic. Idiomatic Common Lisp code isn't - the reader throws away comments, #|... |#, #+, #-, and it transforms things like #. and #B. Interlisp-D Lyric and Medley made this work with: * A very special read table used to read/write code to/from source files * Support in SEdit for the structures created by that read table * Compiler support for those structures For example, if you typed ;; This is a comment into SEdit, it would show it to you as an indented comment, and create a list like this: (* |;;| "This is a comment") In Interlisp-D, comments are lists beginning with IL:* (the symbol * in the INTERLISP package), and they evaluate to NIL, so you have to be careful where you put them in code. You could put comments in Common Lisp code anywhere you wanted - the compiler would strip them out before compiling code. SEdit and the file manager used similar tricks to handle the rest of the standard reader syntax. Typing #+ in SEdit would get you something like #+ [] [] where the [] represents a space that must be filled in. If you typed "FOO (BAR)", SEdit would create an underlying list like: (IL:|#+| "FOO" (BAR)) IL:|#+| was a macro that the compiler would expand into (BAR) or nothing depending on the conditional setting for FOO. SEdit and DEdit were decent as code editors, but they really shone as data structure inspectors - you could select just about anything in the debugger, pop up an SEdit window on it, and modify that structure in-place.
&gt; I don't see evidence in the question that OP is confused on this manner i am not op. i was confused on this matter, and being a newb trying to learn more by reading forums, wouldnt even have known what question to ask to get this info. keep in mind there are people besides op that can benefit from information
thanks for this context! really interesting. faced similar problems with these types of "non-normalized" tokens in parinfer. interesting seeing its implications on other things like in the context of this structure editor. all ears if you have any other interesting tidbits. will add to the history repo
Thanks, I updated to the most recent version, but hit more errors. Realized that it was the corporate firewall causing the problem and so I need to set the proxy flag, which seemed to correct the error. Thanks for the help though, didn't realize I had grabbed that old of an installer. 
Absolutely. I work in an R&amp;D department and was able to convince management that by using lisp we can gain competitive advantage for a long list of reasons which I'll spare you from for brevity. If you like I'm happy to go into detail. The short answer is that I've used lisp with one other programmer to outdo the efforts of a team of 15 who were dramatically better funded than we are by millions of dollars and in less than half the time. They were using C/C#. We use lisp with some bits of C and C++ where unavoidable/makes more sense such as GPU programming and other stuff. Another way I've used lisp at work were for data munging/formatting various types and sources of data into one cohesive report. We use lisp to coordinate and automate many operations now. We'll have a need for distributed processing soon and so I'll be incorporating lisp flavored erlang into the mix. Any other way I can use lisp is now encouraged at work and the use of other languages requires a good reason to use it and approval. This is a lucky and rare scenario but not impossible to achieve. I hope this helps to convince your to try lisp out as it's a rewarding adventure. Happy hacking!
Video replaced. new link here https://www.youtube.com/watch?v=fNyEgwCaHI4
I have read that lisp is the programmable programming language. So, if lisp does not have a feature that you want, then you can just extend lisp so that now the feature is a part of the language. But can't you do basically the same thing in other languages? I would love it if you could talk specifically about how you used lisp to solve a challenging problem. 
You don't need to dive into details how to make executable on different lisps. With Roswell you can make a binary using SBCL, then switch to CCL and have a binary built with it in a minute. Few other implementations are supported as well. 
I actually wish they would've done what k/q did here instead; x, y, z instead of the `_` stuff.
&gt;bug fix: align the stack in callback wrappers to defend against C compiler over-aggressive use of SIMD. What does this mean actually? I can read the text and know what words mean but don't understand.
It used to not work, now it works.
oh, I see that's why MIT MERS team is using SMT solver for planning.
I'm curious about this too. Can someone break it down for us?
https://bugs.launchpad.net/sbcl/+bug/1697528
https://github.com/sbcl/sbcl/commit/674ae94cefd465e593b7ae25d019a8f9db1ba73e
https://en.wikipedia.org/wiki/Sfogliatella
**Sfogliatella** A sfogliatella (Italian pronunciation: [sfoʎʎaˈtɛlla], also common in plural form: sfogliatelle), sometimes called a lobster tail in English, is a shell-shaped filled Italian pastry native to Campania. Sfogliatella means "small, thin leaf/layer", as the pastry's texture resembles stacked leaves. There is a distinction to be made between lobster tail and sfogliatella, as they do not refer to the same pastry. The lobster tail exists only in the United States and generally refers to a cream filled, larger pastry. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
This is really awesome. Thank you so much for the write up. I look at it about a year ago, and gave up because there was almost no documentation. This series helped get me started on it!
Modern C ABIs require that C functions be called with the stack aligned. The intent is that with an aligned stack C compilers can use (slightly) cheaper instructions to manipulate SIMD values that have been spilled. If a function compiled under one of these ABIs is called without the stack aligned, and the compiler has elected to use aligned vector instructions that touch the stack, bad things can happen. Thus to call C functions safely, stack alignment has to be maintained (or temporarily fixed up with a mask across the C call).
Ah this is perfect, thanks so much. I get most of this now and the rest will be easy too google.
Wow, thank you! I *always* find these confusing to read and now suddenly it seems a lot easier. I also liked /u/le_cuck's comment about `&lt;` meaning ascending and `&gt;` meaning descending (which is, basically, the same idea).
McCLIM[1] has ways to do that, but they are hard to grok and I wouldn't try it before some documentation is written for the interactive development. For cool stuff with interactive graphics (not necessarily user interface), check out CEPL[2], CLinch[3] and Xelf[4]. Xelf has some cool videos about building applications interactively. EQL[5] is a very neat ECL+QT based project with possibilities to do the interactive development. There are also CommonQt[6] and Qtools[7], but I'm not sure how interactive they are. [1] https://common-lisp.net/project/mcclim/ [2] https://github.com/cbaggers/cepl [3] https://github.com/BradWBeer/CLinch [4] http://www.xelf.me/ [5] https://gitlab.com/eql/EQL5/ [6] https://common-lisp.net/project/commonqt/ [7] http://shinmera.github.io/qtools/
&gt; Since keywords evaluate to themselves, they cannot be used as variables; however, they can be used as function names. I believe ANSI CL allows that. (I just tried using nil and t as defun function names CLISP and it worked; don't know whether ANSI CL allows these.) Every time I hear something like this, I try it in my own (shitty) Lisp interpreter and it always works. 
You can try cells-gtk: ; SLIME 2.19 CL-USER&gt; (ql:quickload "cells-gtk") To load "cells-gtk": Load 1 ASDF system: cells-gtk ; Loading "cells-gtk" ................ ("cells-gtk") CL-USER&gt; (defpackage #:test (:use #:cl #:cells #:cells-gtk)) #&lt;PACKAGE "TEST"&gt; CL-USER&gt; TEST&gt; (defun run () (cells-gtk-init) (start-win 'example)) RUN TEST&gt; (defmodel example (gtk-app) ((a-message :initform (c-in "hello world") :accessor a-message)) (:default-initargs :title "Example" :width 400 :height 400 :position :center :kids (kids-list? (mk-label :text (c? (string-upcase (a-message (upper self)))))))) WARNING: Implicitly creating new generic function (COMMON-LISP:SETF TEST::A-MESSAGE). NIL TEST&gt; (run) "----------UTILSRESET----------------------------------" "----------UTILSRESET----------------------------------" EXAMPLE1258 TEST&gt; (setf (a-message *) "some random text") "some random text" (Edited to better demonstrate the value of cells.)
What about cl-cffi-gtk ? I have tried it on Linux working on sbcl. Another option was ltk working on both linux and dos. I am planning on retrying cl-cffi-gtk on a WIN64 environment with MSYS2 and sbcl. It is said to freeze sometimes on DOS. It was indeed the case on an old Win7 on 32bit machine. I am very interested as well in others comments about this. :-)
Prolog and/or Lisp? I'm sorry, but is this a school project :-)?
Yeah this month I'm fed up of exams, I could really use a help
It's a non-deterministic finite state automaton, you won't pass your exams if you don't know the name of the thing you're buying...
Yeah, I've seen it fairly regularly. Most often it is compiler specific code but there's no reason not to do it yourself if you know how the reader macro works.
Here is one written in C, using Lisp data structures as input: http://www.kylheku.com/cgit/txr/tree/regex.c#n976 
Sorry for the typo, i writed that translating while doing other stuff, my bad
Why don't you just skip the middleman and ask your professor what his fee would be to ignore your non-performance on the project?
Lol
I've done something like that before with Clojure and Java Swing. I've not used [ABCL](https://common-lisp.net/project/armedbear/) before but perhaps you could use ABCL and one of the Java GUI toolkits?
I really like those episodes. I save the link until I have more time doing lisp.
Interesting and I hope they will be referenced somewhere.
You will get lots of envy :) Enjoy! (PS. SICP is my favourite)
Some context, I've been living in this house for about 3 years now, my girlfriend and i moved in to take care of the owner of the house. Turns out that he was a big lisp / scheme hacker back in the 80s-90s and had developed a lot of cutting edge tech in his hay day. Anyway, these books have been hiding in his library downstairs... It was like finding a bunch of hidden magical scrolls of lost knowledge :) edit: I will compile a list of the books later. I'm out doing 4th of July things. update: List of books * Lisp: Style and Design by Molly M. Miller and Eric Benson ISBN: [1-55558-044-0](https://www.amazon.com/s/ref=nb_sb_noss/142-4050301-3399664?url=search-alias%3Daps&amp;field-keywords=1-55558-044-0) * Common Lisp The Language Second Edition by Guy L. Steele ISBN: [1-55558-042-4](https://www.amazon.com/Common-LISP-Language-G-L-Steele/dp/1555580424/ref=sr_1_1?ie=UTF8&amp;qid=1499193007&amp;sr=8-1&amp;keywords=1555580424) * The Little LISPer Trade Edition by Daniel P. Friedman and Matthias Felleisen ISBN: [0-262-56038-0](https://www.amazon.com/Little-LISPer-Daniel-P-Friedman/dp/0262560380/ref=sr_1_1?ie=UTF8&amp;qid=1499193103&amp;sr=8-1&amp;keywords=0262560380) * Common LISPcraft by Robert Wilensky ISBN: [0-393-95544-3](https://www.amazon.com/Common-LISPcraft-Robert-Wilensky/dp/0393955443/ref=sr_1_1?ie=UTF8&amp;qid=1499253666&amp;sr=8-1&amp;keywords=0393955443) * Object-Oriented Programming in Common Lisp by Sonya E. Keene ISBN: [0-201-17589-4](https://www.amazon.com/Object-Oriented-Programming-COMMON-LISP-Programmers/dp/0201175894/ref=sr_1_1?ie=UTF8&amp;qid=1499253773&amp;sr=8-1&amp;keywords=0201175894) * Structure and Interpretation of Computer Programs by Harold Abelson, Gerald Jay Sussman w/Julie Sussman ISBN: [0-07-000-422-6](https://www.amazon.com/Structure-Interpretation-Computer-Electrical-Engineering/dp/0070004226/ref=sr_1_1?ie=UTF8&amp;qid=1499253906&amp;sr=8-1&amp;keywords=0070004226) * ANSI Common Lisp by Paul Graham ISBN: [0-13-370875-6](https://www.amazon.com/ANSI-Common-LISP-Paul-Graham/dp/0133708756/ref=sr_1_1?ie=UTF8&amp;qid=1499254145&amp;sr=8-1&amp;keywords=0133708756) * Programming Paradigms in LISP by Rajeev Sangal ISBN: [0-07-054666-5](https://www.amazon.com/Programming-Paradigms-McGraw-Hill-artificial-intelligence/dp/0070546665/ref=sr_1_1?ie=UTF8&amp;qid=1499254233&amp;sr=8-1&amp;keywords=0070546665) * The Art of the Metaobject Protocol by Gregor Kiczales, Jim des Rivieres, and Daniel G. Bobrow ISBN: [0-262-11158-6](https://www.amazon.com/Art-Metaobject-Protocol-Gregor-Kiczales/dp/0262610744/ref=tmm_pap_swatch_0?_encoding=UTF8&amp;qid=1499254339&amp;sr=8-1) * Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp by Peter Norvig ISBN: [1-55860-191-0](https://www.amazon.com/Paradigms-Artificial-Intelligence-Programming-Studies/dp/1558601910/ref=sr_1_1?ie=UTF8&amp;qid=1499254541&amp;sr=8-1&amp;keywords=1558601910) * Practical Common Lisp by Peter Seibel ISBN: [1-59059-239-5](https://www.amazon.com/Practical-Common-Lisp-Peter-Seibel/dp/1590592395/ref=sr_1_1?ie=UTF8&amp;qid=1499254613&amp;sr=8-1&amp;keywords=1590592395) * Common Lisp The Language by Guy L. Steele ISBN: [0-932376-41-X](https://www.amazon.com/Common-LISP-Language-Guy-Steele/dp/093237641X/ref=sr_1_1?ie=UTF8&amp;qid=1499254705&amp;sr=8-1&amp;keywords=093237641X) * Anatomy of Lisp by John Allen ISBN: [0-07-001115-X](https://www.amazon.com/Anatomy-Lisp-McGraw-Hill-computer-science/dp/007001115X/ref=sr_1_1?ie=UTF8&amp;qid=1499254779&amp;sr=8-1&amp;keywords=007001115X) * Lisp Objects, and Symbolic Programming by Robert R. Kessler ISBN: [0-673-39773-4](https://www.amazon.com/Objects-Symbolic-Programming-Robert-Kessler/dp/0673397734/ref=sr_1_1?ie=UTF8&amp;qid=1499254847&amp;sr=8-1&amp;keywords=0673397734) * Performance and Evaluation of Lisp Systems by Richard P. Gabriel ISBN: [0-262-07093-6](https://www.amazon.com/Performance-Evaluation-Lisp-Systems-Computer/dp/0262070936/ref=sr_1_1?ie=UTF8&amp;qid=1499254910&amp;sr=8-1&amp;keywords=0262070936) * A Programmer's Guide to Common Lisp by Deborah G. Tatar ISBN: [0-932376-87-8](https://www.amazon.com/Programmers-Guide-Common-Deborough-Tatar/dp/0932376878/ref=sr_1_1?ie=UTF8&amp;qid=1499254997&amp;sr=8-1&amp;keywords=0932376878) * Understanding CLOS The Common Lisp Object System by Jo A. Lawless and Molly M. Miller ISBN: [0-13-717232-X](https://www.amazon.com/Understanding-CLOS-Common-Object-System/dp/013717232X/ref=sr_1_1?ie=UTF8&amp;qid=1499255075&amp;sr=8-1&amp;keywords=013717232X) * The Common Lisp Companion by Tim D. Koschmann ISBN: 0-417-50308-8 * Symbolic Computing with Lisp and Prolog by Robert A. Mueller and Rex L. Page ISBN: [0-471-60771-1](https://www.amazon.com/Symbolic-Computing-PROLOG-Robert-Mueller/dp/0471607711/ref=sr_1_1?ie=UTF8&amp;qid=1499255264&amp;sr=8-1&amp;keywords=0471607711) * Scheme and the Art of Programming by George Springer and Daniel P. Friedman ISBN: [0-262-19288-8](https://www.amazon.com/Scheme-Art-Programming-George-Springer/dp/0262192888/ref=sr_1_1?ie=UTF8&amp;qid=1499255564&amp;sr=8-1&amp;keywords=0262192888) * Programming In Scheme by Michael Eisenberg ISBN: [0-262-55017-2](https://www.amazon.com/Programming-Scheme-Trade-Michael-Eisenberg/dp/0262550172/ref=sr_1_1?ie=UTF8&amp;qid=1499255625&amp;sr=8-1&amp;keywords=0262550172) * The Schematics of Computation by Vincent S. Manis and James J. Little ISBN: [0-13-834284-9](https://www.amazon.com/Schematics-Computation-Vincent-Manis/dp/0138342849/ref=sr_1_1?ie=UTF8&amp;qid=1499255696&amp;sr=8-1&amp;keywords=0138342849) * The Joy of Clojure by Michael Fogus and Chris Houser ISBN: [1-935182-64-1](https://www.amazon.com/Joy-Clojure-Thinking-Way/dp/1935182641/ref=sr_1_1?ie=UTF8&amp;qid=1499255779&amp;sr=8-1&amp;keywords=1935182641) * Clojure For The Brave and True by Daniel Higginbotham ISBN: [978-1-59327-591-4](https://www.amazon.com/Clojure-Brave-True-Ultimate-Programmer/dp/1593275919/ref=sr_1_1?ie=UTF8&amp;qid=1499255854&amp;sr=8-1&amp;keywords=9781593275914) 
I read some of the Practical Common Lisp, particularly enjoyed the little story about macros. Love programmer stories like that. Definitely recommend that book But god damn, that's a lot of good books, you really went all out. Have fun, I know I would.
I love that The Joy of Clojure is sitting on top of Norvig's book. I've been slowly working through the Norvig book translating the exercises to Clojure as I go. 
I think pcl is on of the best "computing" books I've ever read!
This should be in the custom CSS of /r/lisp.
Yeah, I agree PCL is a great book, I read thru most of it. I would say that once you get thru PCL, it's much easier to understand the classics
What a treasure! I recognize many of the books but not all of them. Is it possible to make a list? Thanks!
You can try CAPI from LispWorks, you can follow manual/tutorials in personal edition.
That's like winning the lottery. I have my eye on On Lisp myself (pretty darn expensive, lucky it's available online though a hard copy is nicer). And PCL was my very first Lisp book. Really enjoyed it. Enjoy your treasures! :) 
I remember scoring a copy of *The Anatomy of Lisp* in the mid 90s, and it was already a living fossil then. You have some treasures in there. You'll want to start with *The Little LISPer*.
[These](https://imgur.com/A8rdhem.jpg)
For what it's worth, I have this very tattoo - the only difference is the font I used to make the template for the artist. No one has ever said anything about it looking like a butt. I'll take a picture of it and you can judge for yourself if the font makes enough difference. [Here you go](http://imgur.com/a/Kk5fL) It's been a few years since I got this, but I do remember messing with the fonts and making the parenthesis one or two points larger than the lambda to get it to look like what I was imagining.
This obviously depends on the state of the health of the owner but I am sure that an AMA would be much appreciated (if he's up to it of course).
That's PAIP and Common Lispcraft.
Holy canoli, that's awesome! Looks great :D Thanks for your feedback friend!!
I had sworn off getting any more tattoos after I got the lambda on my arm (pic in another reply to this thread) but since I started a company that uses both Common Lisp and Haskell almost exclusively, and how good that can look on skin, I think I'm going to have to weaken... one more time. 
Glad I gave you a different perspective on it :)
I also loved reading On Lisp. It was one of the more formative programming books of my youth.
If you really want a dead-tree copy, there are some websites which can print a PDF as a book. So it's possible to make a bootleg copy.
Ah yes. I did not think of that. Thanks for the tip. 
I grabbed a copy on Amazon a few years ago. It was cheaper than the other offers, but I think On Lisp is still the most expensive book I own. And I own quite a few. :)
Imagine the kind of ancient spells you'll be able to cast once you've read all of those :O I've heard of someone who managed to conjure a mythical beast. Best of luck to you op!
Maybe worth noting: QWidget stuff will work too, you're not required to use QML (I just added the "clock" example, without modifying the Lisp code, and it "just works"): [android examples](https://gitlab.com/eql/EQL5-Android/tree/master/examples)
At least in SBCL you can define application entry point, ie. what to call the first time saved Lisp image is started. I always use MAIN function for that purpose for sake of clarity, but it could be anything. http://www.sbcl.org/manual/#Saving-a-Core-Image Also, don't use GCL for reasons flaming_bird said. Use SBCL.
I actually did this and got myself a spiral-bound copy of On Lisp for abou $20.
For my limited needs and in my limited experience, I have only needed to look up CCL's and SBCL's methods for saving out the heap and specify a toplevel main loop. What else does ros provide outside of perhaps unifying those interfaces, which I believe uiop also now does?
Lisp is indeed the programmable programming language. Here's a good example of how I've used it to solve a problem some 20 robotics specialists said was "impossible". I used Lisp to create a Domain Specific language or DSL. [See Wikipedia and others](https://en.wikipedia.org/wiki/Domain-specific_language) I used my custom language to coordinate motion of our prototype robot with software which was not intended to be interfaced with at all. Essentially I tricked other software programs into thinking that our robot is simply a hyper-accurate human. Without my custom language to control motion as well as the other programs with some fairly complex logic behind the scenes, I would not be able to achieve my goal. There is no more sensible language to reach for than Lisp in that scenario as it's the fastest way to iterate towards your goal. Basically you can build DSLs and actually change the way Lisp works (lookup reader macros to start) such that you fit Lisp to your specific problem rather than try craft your problem to be solved in your other language of choice. Lisp will turn your problem solving inside out and then into a mobius strip. Happy to answer any other questions.
Thanks! you can find the actual recording over here https://youtu.be/9lOMia8FjTk
You could start with the Strong On Defense book on the bookshelf ;)
I should watch what you're doing. I've started lisp recently, paused it for reasons of depressions (probably) but noob me already had a basic game engine with lispbuilder-sdl that I was very proud of. what you are doing seems very educational for me to look at ( Lisp is the language taht made me make things I never thought I would be able to make, almost by accident(I sould continue and show the results once its really somethings, I really know my abuse of macros will be the critic))) 
 What do you mean by "hope they will be referenced somewhere"?
I mean, it would nice and helpful if they were referenced in a wiki and other resources, that would make the CL ecosystem easier to discover. They'll be on quickdocs, that's cool but not that user friendly to discover (a few categories, no human summaries or sorting,…). 
Can you provide a APK for ARM?
~~Here you find the tic-tac-toe example~~ (please see "ministro" version below); I didn't upload the "clock" example, because it looks exactly like the desktop version using `showFullScreen()`. A few notes: * with all the needed ECL/Qt5/EQL5 libs included, it's 13.5 MB * using the "ministro" service for Qt5, it's down to 3.5 MB (no Qt5 libs included); see [tic-tac-toe (ministro)](http://www.lights-of-holiness.eu/tmp/tic_tac_toe%20\(ministro\).apk) (built with Qt 5.7) Please report back if it works on your device (I only tested on a tablet with Android 6). edit: added link to version using ministro. edit 2: the ministro version now uses QML `Button` (that is, modern QML, not custom drawing) edit 3: the ministro version now has a "splash text" (because startup takes a few seconds...) edit 4: see also [screenshots](https://gitlab.com/eql/EQL5-Android/tree/master/screenshots)
&gt; already had a basic game engine with lispbuilder-sdl that I was very proud of Cool! &gt; (I sould continue and show the results once its really somethings Dooo it! but show it sooner than that (if you feel like it), it's exciting to see these things as they grow. 
I showed it to someone here once before. But I should get a github to show it to all of you (even if I abused macros.. I have an overly complex maceo to write everything to generate a level. The idea is maybe not that bad but a good part of it should be a class and method, some of if though, I feel very proyd of having the code writen for me)
Homoiconicity?
A reminder that /u/JuanitoJons is a spam account that was created to promote/push huuii.com by astroturfing. An [example](https://www.reddit.com/r/lisp/comments/5w01oq/mathematics_with_common_lisp_maxima/) of one of his previous attempt to astroturf /r/lisp. Backgrounds: You can see that the domain huuii.com started to appear on Reddit on February 21, 2017: https://www.reddit.com/domain/huuii.com/ All of the links to huuii.com were posted by 3 accounts; all of which were also created on February 21, 2017 as well: https://www.reddit.com/user/Yarentzy https://www.reddit.com/user/jesmcg https://www.reddit.com/user/JuanitoJons Therefore, please kindly ignore/downvote this post to prevent /r/lisp from being spammed by spammers. 
Quite a wordy article about shipping lisp binaries for major OSes: [Delivering games written in Common Lisp](https://borodust.org/delivering-common-lisp) It is a bit on the advanced side and talks mostly about delivering a game, but the process is totally the same if you need to package some native libraries and additional resources. For just the lisp code #'save-lisp-and-die is totally enough though!
I'm the author so AMA. Primary objective has been making quicklisp-client more developer and user-friendly.
Good luck!
Thanks but I don't need luck, I forked this off your quicklisp-client.
What problems does QL not solve for you that this solves?
Better compression maybe? https://github.com/quicklisp/quicklisp-client/pull/141/files/90eb56f35651f49e66a5ef40a2c209d3446418b7..4fea3b8d3a288c49be5c9456b4e86abbefc4af75
I wanted to have a client that is more user-friendly and more familiar in its conventions. For example, you had to search with (quicklisp:system-apropos "foo") and if you forgot argument, you got big nasty Lisp error message that required two backsteps to get back to toplevel CL-USER. Now, you get to search with (cpm:search 'foo) and if you forget argument, you get helpful message telling you correct syntax for command. Things like that.
That is also a big one. There has been a lot of refactoring and if you want to contribute to this Quicklisp client, I'd appreciate descriptive docstrings very much.
Seems like /u/xach has already contributed quite a bit to this Quicklisp client...
Just most of it. In its current state. And there is always path forward.
&gt; Q: Why not just contribute to quicklisp-client? &gt; A: I tried. ¯\(ツ)/¯ what was the problem?
Commits did not match Xachs vision for the project. It was he who gave me the idea to fork it by pointing out it is MIT licensed.
That was "Hexstreamsoft", not me. But I think it is fine to fork to make what you want. 
"Compression" isn't a problem. It's potentially a solution to a problem. What's the problem?
Better error messages / UI seem like reasonable things for Quicklisp. Were issues not filed? Or when you suggested a change, did you require a big heap of them, like adding new function names?
Just saw this via Hacker News: https://news.ycombinator.com/item?id=14725878
One of the things I wish to see happen in this fork is easier contribution from other developers, which is why I have done a large amount of refactoring, most notably I moved all files with same in-package into a single file having the same name as said package. Clarity is essential. Achieving command/feature parity with npm is one of my ambitions with this one and I can't do that alone within any sensible time frame. By the time I had implemented some comfy factors and realized this could very well be npm-equivalent it was already way too late to be even remotely acceptable for quicklisp-client to merge.
&gt; For example, you had to search with (quicklisp:system-apropos "foo") and if you forgot argument, you got big nasty Lisp error message that required two backsteps to get back to toplevel CL-USER. What? Running ```(quicklisp:system-apropos)``` without an argument raises the standard error of not enough arguments for a (generic) function. Why would it do anything else? It behaves exactly like CL's built-in ```apropos```. 
I for one think having everything that belongs in the same package in the same file is everything but clear. If anything, having overly large files is a tremendously off-putting factor.
&gt;Why would it do anything else? You get helpful message telling you correct syntax for command. 
https://i.imgtc.com/zkw40lE.png The correct syntax for the command is on the bottom of this screenshot, automatically suggested by SLIME, just like for all other functions/macros.
&gt; For example, you had to search with (quicklisp:system-apropos "foo") and if you forgot argument, you got big nasty Lisp error message that required two backsteps to get back to toplevel CL-USER. If you forget a required argument to **any** function or macro, you get an error. That's not a bug, that's a feature.
&gt; easier contribution from other developers I see this point. This is a community issue &gt; all files with same in-package into a single file This does not sound good :( &gt; Achieving command/feature parity with npm This is good. We need more people thinking this way
Would it be possible/desirable to create a CL package manager which runs outside of the CL environment? I guess sort of like how pip works for Python. Although it's possible to use pip from within a python REPL, I typically use it directly on the command line.
I think he's joking. the pull request removes some blank lines and reduces the number of semicolons in many of the comments.
Is term a string, symbol, list, number, boolean or vector? What if you are for some reason operating directly within SBCL or ECL prompt?
I've been asking around and it doesn't seem to be possible. At least not in any obvious way. That would be great, I agree and wanted to do that.
Yes, it is a language feature, just like combination of &amp;optional parameter and a simple if-clause which causes program to not throw gibberishly error stack on your face for mistake. 
I fail to see how that can be seen as a joke considering file size does get smaller like Xach stated. Check out source of this webpage. Most of it is minified: having spaces, newlines and comments removed altogether to make client waste less server processor cycles. Now consider you are supposed to have quicklisp-client loaded and carried around in session lisp image among with whatever you are working with.
&gt; Check out source of this webpage. Most of it is minified this web page is minified because it is a web page. minifying web pages reduces burden on servers and decreases page-load times. web pages are loaded very frequently: many times per day by thousands of users. contrast this with quicklisp-client. quicklisp-client is loaded once or twice ever per user. removing 100 bytes of text is not going to have any perceptible impact on anyone. now if you _were_ to compress quicklisp-client to make it faster to download, why not go all the way to minify it? why not remove all comments. change all variable names to single letters. remove all newlines. remove unnecessary spaces. this would be very unnecessary, but the point is you could actually compress it much further. &gt; Now consider you are supposed to have quicklisp-client loaded and carried around in session lisp image the text is not part of the lisp image. even if it were this would have a negligible impact, since quicklisp is already so small. now adding new functions to the package (like CPM does) really does make the image a teency tiny bit bigger. &gt; I fail to see how that can be seen as a joke considering file size does get smaller By removing the vertical spacing, the flow of code become more difficult to read. By removing the number of semicolons types of comments become harder to distinguish. See [the google style guide](https://google.github.io/styleguide/lispguide.xml#Comment_semicolons) for advice on how many to use. This change damages readability, which makes it less developer-friendly and does serve any perceptible, positive benefit to the end user. hope this helps.
"Removing newlines saves cycles". Seriously? This is 2017, not 1950. 
you may put your own system in ~/quicklisp/local-projects . Then simply calling (ql:register-local-projects) ; called once only, cache is persistent (ql:quickload 'my-app) that should download and load all my-app dependencies and my-app itself.
&gt;now if you were to compress quicklisp-client to make it faster to download, why not go all the way to minify it? why not remove all comments. change all variable names to single letters. remove all newlines. remove unnecessary spaces. Indeed, and further still. Concating all files and compiling a single .fasl as a distributable is 1.0.0 partyday program.
First let me say that I appreciate that you've taken time from your leisure time to work on a Free Software project with the intention to serve the CL community. &gt; Primary objective has been making quicklisp-client more developer and user-friendly. Although your goals are certainly desirable your interpretation of what is more developer and user friendly is wanting You claim the you want the code to be more familiar in its conventions and yet you have a [commit](https://github.com/quicklisp/quicklisp-client/pull/141/commits/4fea3b8d3a288c49be5c9456b4e86abbefc4af75) where you remove 'redundant' characters, where you literally making the code less familiar. The convention in Common Lisp is &gt; - Use a single semicolon when commenting on code on the same line &gt; - Use two semicolons when commenting on code on the next line &gt; - Use three semicolons when commenting on the following block of code &gt; - Use four semicolons when commenting on the next section of code How does one package per file helps with clarity? Splitting a packages into small files helps with grouping the relevant parts together. One package per file does nothing for making the code more developer friendly. Most of the lisp programmers don't like that scheme. With with xrefs, one doesn't have to jump through files, just *M-,* and *M-.* How does calling systems packages, which already refer to another concept helps with clarity? Also in the tl;dr you are misleading users. Systems are a collection of *files*. They are orthogonal to packages. If you want to improve the user experience, but do so by aborting and printing a usage? That is fine in the context of a CLI tool. In Common Lisp we have interactive restarts. You can ask the user to input the missing argument! Some other tidbits &gt; Commits did not match Xachs vision for the project. - Submitting a +3000 Line PR is *not* OK. Especially if its made of 3 unrelated changes. - Why do you wrap the ifs in interface.lisp with *progn*s? - Why do all the functions in interface.lisp have the same template and haven't been macro-ed away? - You can exit an error just by pressing Q no two steps necessary - AFAIK NPM is not considered an example of a good package manager 
I think the problem is that you already had ```my-app``` loaded. Loading it twice is a no-op. Since you're writing my-app, it's simple for you to do ```(quicklisp:quickload :vecto)``` and so on as you go. If you start a fresh Lisp session doing ```(quicklisp:quickload :my-app)``` will load your app as well as vecto.
Thanks for input. Please contribute. Especially docstrings are much needed. 
Did the way microprocessors operate change somewhere inbetween? 
Quicklisp automatically loads dependencies that are locally present. It does not automatically download ones that are not locally present. So, yes, you must manually quickload each dependency once, the first time, in order to get them locally present. After you've done that the first time, your asd file will automatically load all its dependencies without needing to manually quickload any of the dependencies (unless you add a new dependency). My habit when creating a new proect is to write the :depends-on line, then ql:quickload each of those dependencies to ensure that they are locally present. Then I never have to think about it again (unless, as I mentioned, I add a new dependency). 
I'll just note that this isn't a "fork" in the GitHub sense. The working directory of the Quicklisp client at some point in time (clean or dirty, I didn't bother to check) was taken as the initial commit to the repository, thus losing all history.
I don't think that's correct. Quicklisp automatically downloads dependencies that are not locally available, when you use `ql:quickload`. It's pretty much the point of Quicklisp. A quick test confirms: CL-USER&gt; (ql:quickload :cepl) To load "cepl": Install 1 Quicklisp release: cepl ; Fetching #&lt;URL "http://beta.quicklisp.org/archive/cepl/2017-05-16/cepl-release-quicklisp-100d53bd-git.tgz"&gt; ; 357.72KB ================================================== 366,304 bytes in 0.72 seconds (498.91KB/sec) ; Loading "cepl" To load "fn": Install 1 Quicklisp release: fn ; Fetching #&lt;URL "http://beta.quicklisp.org/archive/fn/2017-05-16/fn-20170516-git.tgz"&gt; ; 3.90KB ================================================== 3,995 bytes in 0.00 seconds (0.00KB/sec) ... This is for a system that has to be downloaded entirely, but it also works for dependencies of local projects: ;;;; blatest.asd (asdf:defsystem :blatest :depends-on (#:cl-emoji)) CL-USER&gt; (ql:quickload :blatest) To load "blatest": Load 1 ASDF system: blatest ; Loading "blatest" To load "cl-emoji": Install 1 Quicklisp release: cl-emoji ; Fetching #&lt;URL "http://beta.quicklisp.org/archive/cl-emoji/2017-05-16/cl-emoji-20170516-git.tgz"&gt; ; 101.96KB ================================================== 104,406 bytes in 0.32 seconds (315.66KB/sec) 
Nice! Thank you.
&gt; Check out source of this webpage. Most of it is minified [...] to make client waste less server processor cycles No, its done to waste less bandwidth, it does nothing to save cycles. One way to save processor cycles, if one so desires, is to use web-assembly which reduces parsing time. Something that does consume significant processor cycles. &gt; Now consider you are supposed to have quicklisp-client loaded and carried around in session lisp image among with whatever you are working with. Lisp is not a source only language. You can load the code w/o the source and comments are not loaded into the image. Removing ; characters does nothing towards your goal. Docstrings on the other hand, are loaded into the image, that is why applications that care about their final image size, like SBCL, don't use doc-strings but stick to comments. Most importantly, if one isn't measuring one isn't optimizing. What makes you believe that 'redundant' comment lines are a performance problem? As others have said, this isn't 1950.
Another poorly made decision
I did, by trying to explain to you why your changes don't help towards your goal. Even if Quicklisp client could be improved (and Xach is working towards that) it is more developer and user friendly to me.
I don't understand what you mean. what about my make makes you or is sad?
All these valid points you list make me sad. 
What I meant by "manually downloading" a dependency is apparently what you mean by "automatically downloading" a dependency. I call it "manually downloading" because I must manually type and eval "(ql:quickload :cepl)" in order to get :cepl downloaded; simply including it in an ASDF dependency is not enough to get it "automatically" downloaded. As I said, you must--"manually" or "automatically", but in any case, by positive, explicit intervention on your part--execute a ql:quickload of a library dependency in order to get it onto your local machine before including it as an ASDF dependency can cause it to be loaded. You cannot simply list it as an ASDF dependency and expect it to be "automatically" downloaded for you. 
I'm still not sure what you are really trying to say. In my second example, I created a simple system called "blatest" that depends on cl-emoji. I did not have cl-emoji downloaded anywhere. Then I `ql:quickload` blatest, and Quicklisp downloads cl-emoji. Thus, including it as an ASDF dependency caused it to be loaded without ever calling `(ql:quickload :cl-emoji)`. Same for the dependencies of CEPL, which you can see in the snippet. I call `(ql:quickload :cepl)` and, because it is a dependency of CEPL, the system "fn" is also downloaded and loaded. (There were quite a few other dependencies I cut out of the log.)
Here's what I mean (and what I believe the OP is referring to): (require :asdf) (asdf:defsystem #:foo :serial t :depends-on (:cl-emoji)) (asdf:load-system :foo) Component :CL-EMOJI not found, required by #&lt;SYSTEM "foo"&gt; [Condition of type ASDF/FIND-COMPONENT:MISSING-DEPENDENCY] Restarts: 0: [RETRY] Retry loading CL-EMOJI. 1: [RETRY] #&lt;error printing RESTART #x3E18F6D&gt; 2: [CLEAR-CONFIGURATION-AND-RETRY] #&lt;error printing RESTART #x3E18FBD&gt; 3: [RETRY] Retry SLIME interactive evaluation request. 4: [*ABORT] Return to SLIME's top level. 5: [ABORT-BREAK] Reset this thread --more-- Backtrace: 0: (ASDF/FIND-COMPONENT:RESOLVE-DEPENDENCY-NAME #&lt;SYSTEM "foo"&gt; :CL-EMOJI NIL) 1: (ASDF/PLAN:MAP-DIRECT-DEPENDENCIES #&lt;ASDF/PLAN:SEQUENTIAL-PLAN #x30200116F06D&gt; #&lt;PREPARE-OP &gt; #&lt;SYSTEM "foo"&gt; #&lt;COMPILED-LEXICAL-CLOSURE (:INTERNAL ASDF/PLAN::VISIT-ACTION ..)) 2: ((:INTERNAL ASDF/PLAN::VISIT-ACTION (ASDF/PLAN:TRAVERSE-ACTION (T T T T))) T) ... etc. etc. The above example uses (asdf:load-system :foo), but I can instead use (ql:quickload :foo) and get the same result. 
Common Lisp provides a macro binding for the `lambda` symbol. The macro performs the transformation `(lambda (...) ...) -&gt; (function (lambda (...) ...)`. It provides compatibility between Common Lisp and Lisp dialects which don't have `function` or the `#'` sugar for it. This transformation takes place when a lambda expression appears as a *form*: Common Lisp jargon for an expression which is in a context where it is evaluated. A lambda expression which is already the argument of `(function ...)` is not a form, so isn't expanded as a macro call. That's what ensures that the above transformation doesn't recurse; it takes one step and is done. Some Lisp dialects, instead, might choose to have `lambda` as a special operator which implements the semantics of lexical capture and producing a function value. Well, Common Lisp almost has that operator, but it's spelled `(function (lambda ...))` and not just `(lambda ...)`. Common Lisp's `function` operator also captures lexical scopes for named functions. If `foo` is a lexical function then `(function foo)` gives you that function, together with the apparent lexical environment captured in it: (let ((a 42)) (flet ((foo () a)) #'foo)) ;; produces a function which, when called, returns 42. In Common Lisp, the unifying principle is that a lambda expression is considered to be a *function name*, and can be used as such. (Except, of course, not for *defining* a function: it's not the kind of name which can denote whatever we want; it denotes the function that is literally encoded in it!) For instance, because a function name can appear in the first position of a compound form, denoting a call to that name, such as `f` in `(f x y)`, a lambda expression can be used in the first position also: `((lambda (x y) (+ x y)) 3 4) -&gt; 7`. 
Thank you for the good explanation. It is an old book written before the ANSI standard was defacto, so this makes sense. Telling me it is macro made it make sense. I then looked at the CLHS docs for it.
Worked with the latest roswell and needed libev-dev on debian.
Where is the repo now ?! It is a very valuable work, please let us see it. 
The funny thing is Steele's *Common Lisp, The Language, 2nd Ed.* (a.k.a. "cltl2") makes no mention of the `lambda` macro! I'm looking at another even older CL book from 1986: Wilensky's *Common LISPcraft*; it dedicates a whole bunch of pages to the lambda topic, yet no mention of any macro. Moreover, he explicitly discourages the reader from trying to evaluate a lambda expression with these exact words: "Do not type a lambda expression into LISP to evaluate it, though, *because lambda expressions are not function calls.*" (Emphasis author's, as is the LISP spelling). Wilensky goes through examples in which lambda expressions are passed as quoted lists, then introduces the `function` operator. A lot of programmers around that time would have been referring to cltl1 and later cltl2 as their reference manual. Indeed, for example, if we look back in the Wilensky, he says in the Preface: "While this document is self-contained, it does not exhaust or fully describe every aspect of Common LISP. The reader may consult *Common LISP: The Language* by Guy L. Steele, Jr., the bible of specification for all Common LISPs." And that's referring to the first edition; the second didn't even exist, and still doesn't mention the `lambda` macro, as noted above.
Quoting CLHS, **Macro LAMBDA**: http://www.lispworks.com/documentation/lw51/CLHS/Body/m_lambda.htm See description.
&gt; The above example uses (asdf:load-system :foo), but I can instead use (ql:quickload :foo) and get the same result. It actually doesn't: CL-USER&gt; (require :asdf) NIL CL-USER&gt; (asdf:defsystem #:foo :serial t :depends-on (:cl-emoji)) #&lt;ASDF/SYSTEM:SYSTEM "foo"&gt; CL-USER&gt; (asdf:load-system :foo) ; Evaluation aborted on Component :CL-EMOJI not found, required by #&lt;SYSTEM "foo"&gt;. CL-USER&gt; (ql:quickload :foo) To load "foo": Load 1 ASDF system: foo ; Loading "foo" To load "cl-emoji": Install 1 Quicklisp release: cl-emoji ; Loading "cl-emoji" [package cl-emoji]. ; Loading "foo" (:FOO) CL-USER&gt; 
The same thing failed on my sytem, producing the same result that I reported before, so I investigated further. My distribution was out-of-date and didn't know about cl-emoji. So I performed an update-all-dists, and got the result that you reported. For what it's worth, asdf:load-system does not fetch the remote download; you must use ql:quickload to load your system. If you do, and if you are using a dist that knows about the system you want downloaded, then quicklisp will in fact download it for you. So I was wrong: if you ensure that quicklisp is up-to-date and if you use the right commands, it will automatically download dependencies for you. 
AFAIK static linking of foreign libraries with the Lisp image is possible. ASDF and SBCL are capable of doing this in most cases. Never done that before myself, but I saw a presentation where that was done live.
Is it in App Store now?
Seems to be yes for me. Successfully downloaded the app. https://itunes.apple.com/us/app/shen-programming-language/id1256936517?mt=8 
You could do that with ECL. Having such prebundled shared object work with iolib would require fixing cffi's load-foreign-library, so it can recognize, that the object is already loaded. ECL native fasls are shared libraries.
More info would definitely be appreciated.. :)
First, thanks for answering! :) Do you have more info? That sounds like a trail worth following, but I'm not sure what needs to be done. ECL native fasls sounds like the opposite of what I want? I want a single statically-built binary, not shared libs.
Baggers maybe you would like to try [Synergy](https://symless.com/synergy) useful it allows you to share your keyboard, mouse and clipboard between computers, even with different OSs, I used it in the past (when it was free) and it worked ok, it is not expensive but is closed source. There are some [alternatives](http://alternativeto.net/software/synergy/) but I cannot recommend them because I never used them. Edit: Correcting a typo.
Then you might want to chagne topic of this reddit thread. ECL application may be build with static library linked. You may check https://common-lisp.net/project/ecl/static/ecldoc/Extensions.html#System-building and examples/ directory in ecl source code tree. Still, you have to make cffi aware of such library being "preloaded", so load-foreign-library returns true for iolib. If you are interested in ASDF way of doing things, read: https://www.european-lisp-symposium.org/static/2017/rideau.pdf
Update: here is the APK (ARM) of the (ported) "sokoban" example (designed for tablets, not the phone): [sokoban](http://lights-of-holiness.eu/tmp/sokoban.apk) / [screenshot](https://gitlab.com/eql/EQL5-Android/blob/master/screenshots/sokoban.png)
I recently took a shot at making a couple of [screencasts](http://wispym-home.no-ip.org:8082/protected/cl_tute1/index.html) explaining these ideas. They are neither polished nor as clear as they could be, but I hope they'll provide some insight nonetheless.
Thanks! I'll check those out :) What's with the captcha btw?
I sadly have none. Ask `#lisp` on Freenode - it should be able to help you.
source code: https://github.com/symless/synergy Edit: from the ReadMe on that page: &gt; free and open source
I think we went off wrongly. In the title, when I say "image", I mean "executable", as in, sbcl's `save-lisp-and-die`. (Which it calls "Saving a Core Image" in its documentation.) My original problem is that I want to write an application, and distribute painlessly this application to users. A static binary -- aka an image -- is the easiest way to provide this. The PDF mentions a few related things, but is unfortunately not very complete. The ECL documentation mentions this: https://common-lisp.net/project/ecl/static/ecldoc/Extensions.html#Executable But it doesn't say if it will bundle the C shared libraries into the executable. I don't think it will, will it? Is there a way to statically build it? Cheers
Ok, thanks.
As I have mentioned, shared library can't be compiled-in. You may compile your application with static library included. Afair you may add static library (*.a object) in build-program, like that, but you'd have to check that. (c:build-program "hello-goodbye" :lisp-files '("hello.o" "goodbye.a")) As I have mentioned, making iolib work with statically linked libfixposix (it would have to be build as a static library), you'd have to patch cffi as well.
I'm sorry this isn't a solution for your problem but why can't one simply read the .so file as a global variable and dump it to disk when the application starts?
I wish I could get more into Shen. I read the book, it sounds awesome, but as for getting stuff done, the Shen OS vs. Shen Professional stuff is confusing as hell.
It's confusing and needs more documents. I heard that in the end both will be merged and become OS, but until then somebody has to support Tarver for the development.
Thanks! I used to use synergy but I ended up switching to a usb switch as it was more reliable (on macOS synergy was performing very poorly) the shared clipboard is very tempting though.
Thanks for the information, I thought they had closed source it, I currently don't have a use for it but is nice to know the source code is still open. Edit: Correcting typo, I always have at least one :(
A simple solution I found for a text based copy/paste [cl1p.net](https://cl1p.net/), at least you can move text from one computer to the other that way without much trouble.
I'm not saying that embedding wouldn't be good to do, but can't you also address it by distributing your shared library file along with your image?
I've used synergy. It is alright, but on mac it can experience problems. I am not on mac anymore, so this is no longer an issue. :)
Erf, I'm so far behind.... gonna have to binge-watch
Which Lisp guide at this repo should be the top one? Should we also add Norvig slides there?
It is definitely the Google style guide, because it is the most comprehensive one. 
The google one is too long and too prescriptive. It is fine if you have a giant codebase and large team with lots of turnover. That doesn't describe most of us, which means it shouldn't be on top. The other two are overly opinionated. They're fine for their creators, but not for everybody, which means they shouldn't be on top either. There *is* a useful "CL pitfalls" document lurking inside the google one, straining to get out. 
Ariel doesn't have very good English writing.
I love Google's lisp indentation convention &gt; Indent your code the way a properly configured GNU Emacs does. compared to its other languages: [c++ for example](https://google.github.io/styleguide/cppguide.html#Formatting). tools like clang-format and go-fmt make format wars less of a big deal, but nothing's like emacs' 'tab-and-forget' approach to formatting.
Whichever style guide says **write more Lisp**. 
Is there a similar pretty printer/formatter for Common Lisp?
The formatter I'm talking about comes bundled with SLIME and is specifically for Common Lisp. Pretty much all major languages have an emacs auto-indent package.
I love SLIME but ease of use outside of Emacs is a problem. Making it a commit hook or using it in build integration is then difficult. I see the main edge of go-fmt. SLIME can be done this way, its just a lot of work. Back to getting org-mode blog with CI working ... (Before flaming begins, I definitely side with people here.)
ros fmt is coming in the next release, it uses a function in lem (cl-based emacs-like editor) to reformat a file.
I'm familiar with Ros. Very interesting.
Is [this](http://www.aiai.ed.ac.uk/~jeff/lisp/cl-pitfalls) the document you’re referring to?
I've been using SourceForge lately for downloads on Windows and I had no problems, well none except for Filezilla, which you have to specifically avoid the "bundled offers" version from the official website.
1) Sbcl binaries via SourceForge are OK. 2) You can build it yourself from source if you want. It's not that hard. Install [msys2](http://www.msys2.org/), then install gcc via pacman, the package manager. Then build sbcl as described in docs, voila.
That's a good one. It actually covers an obscure pitfall that had me scratching my head a while ago: &gt; A FUNCTION special form may construct a new function object each time it's evaluated, and therefore even (flet ((f ...)) (eq #'f #'f)) can return false. Like me, it seems the author couldn't find any explicit permission for this behavior in the standard. However: &gt; e-mail discussion within X3J13 showed substantial support for the view that FUNCTION should be allowed to always create a new object. 
Thanks - just need some SBCL goodness, so the binaries are grand for now. If I run into issues, I'll bear your suggestion in mind.
Thanks - will progress with SBCL from SF. I've been nervous about Source Forge since the issue with GIMP was publicized, I think this is the first time I've needed them for anything in the meantime. Perhaps I was just caught up in all the FUD. 
&gt; I recall not so long ago SourceForge had a bad rap for packaging additional 'features' within installers. Is this still the case? As of now it's no longer the case. &gt; loganabbott 57 days ago [-] &gt; &gt; &gt;FYI my company acquired SourceForge in 2016 and have been improving significantly. No more bundled adware, eliminated deceptive ads, all projects are scanned for malware, https downloads and project web hosting, 2-factor auth &amp; more. Big redesign coming soon too. This is a great thread, but I just wanted to let everyone know the shady practices in the OP are no more. &gt;For those interested in more information I did an AMA here: &gt;https://www.reddit.com/r/sysadmin/comments/4n3e1s/the_state_... &gt; &gt;And Ars coverage here: https://arstechnica.com/information-technology/2016/06/under... from https://news.ycombinator.com/item?id=14381076 
Thank you! Good info to know
Out-of-the-box Windows binaries show a warning about the implementation not working perfectly on Windows. &gt; WARNING: the Windows port is fragile, particularly for multithreaded code. Unfortunately, the development team currently lacks the time and resources this platform demands. Does installing it though msys2 fixes that issue? 
1) SBCL developers decided to issue this warning on Windows in the past, when the port was indeed fragile. Nowdays it's not true, SBCL on windows is *very* stable, I used it for years (in sophisticated ways - threads, CFFI, OpenGL) and had zero problems, and I think this message can be removed. But this is a question to sbcl devs, not to me. 2) If you badly want to remove this message when you build sbcl yourself, edit print_banner() function in src/runtime/runtime.c and make it empty: void print_banner() {} 
Well that's nice to know. I don't really care about the message, I just wanted a stable version. Glad to know I don't have to do anything! 
You won't regret, SBCL rocks! :)