What's a sweet-expression?
Oh god, we are discussing parentheses again. [example](https://www.google.com/search?q=%22sweet+expressions%22+site%3Areddit.com%2Fr%2Flisp) [example](https://news.ycombinator.com/item?id=1941373)
I used to do a fair bit of calling between emacs and CL via slime, and `slime-enable-evaluate-in-emacs` was necessary. These days unless I was adding more info to the slime environment such as via presentations, I'd just have emacs run the CL repl in a simple subprocess and use that as the back end for a more domain specific buffer.
It might be readable but not as easily manipulatable and movable as S-exp. In python I am constantly irritated by the dumb emacs binding that can't tell when the body of `if` and `else` ends nor move/kill/paste the chunk of code correctly. Languages are tools, tools are for makers, readers are important but secondary.
I think that is kind of trading practicality. I do find it useful if an object could be a memory mapped file. Imagine `file` command could also tell such a mapped file is a lisp object, and not only that, it can also tell the type of the object, slots, etc, etc.
That's not implementing Unix in Lisp, that's extending Unix to be able to support Lisp functionality. That's an inverse concept.
&gt; Implementing Lisp in Lisp is a much better idea. That is interesting. Could expand a bit on what you mean by that?
Even though it is very clear that no one really like my idea (lol), I think you were the only to use words similar like "terrible" to describe it. I'm not sure if I understand your metaphor, and I'd love an ELI5 version if possible.
How would a project like that look like?
It seems interesting nevertheless...
&gt;The goal of this “Readable Lisp s-expressions” project is to develop, implement, and gain widespread adoption of more readable format(s) for the S-expressions It implies that s-expressions are not so readable. As a person that has had a full year of professional experience in Python (actually implementing software for a bank in it), the jump to Common Lisp also made me realize s-expressions were just fine. 
&gt; Implementing a Unix userland means that Lisp will need to obey the Unix model where everything is a file This. This is essentially contrary to what a Lisp Machine is all about. Well said.
Read all about the Lisp machines (Symbolics 3600, LMI Lambda, etc.) There are videos online that show how the user experience is.
&gt;Lisp Unix userland Lisp Machine OS (plural) and Unix OS (plural) are essentially contrary philosophies. Read "The UNIX-Haters Handbook" (book) for a hint on these differences. 
Cool! Could you share some particular script that you use, and how it helped you in the past?
Thank you for answering! I see those links are for full-blown Lisp machines. But do you think some of these ideas would be worthwhile to implement on top of a non-Lisp system?
How has Lisp made my life better/easier/etc.? Maybe first, some soft aspects. * It has given me an income since the start of my professional programming career. * It has given me the most interesting kinds of projects to work on for money, from fingerprint analysis to quantum computing. * It has provided me a very valuable perspective of programming language design, and of the process of program development. * It has given me a lot of very neat computing history to ingest and learn about. There's so much about Lisp history I don't know, and I've been at it for a decade. I just discovered [another book](https://dl.acm.org/citation.cfm?id=574973) that contains a heap of Lisp. * It has given me access to a plethora of information about computer algebra, because Lisp's history is completely tangled in it. Unlike other CAS's, most of these are open source: Macsyma, Maxima, Axiom, Reduce, ... * It has given me interest in alternative computer and operating system architectures. The Lisp machines are like abandoned museums full of 80s technological ephemera, written by some of the most innovative folks in computing history. While Genera wouldn't be appropriate for the proverbial Common Man (TM), it has a lot of interesting ideas that I wish I had access to as a modern-day programmer. * It has given me an interesting thing to talk to people about around the world. Second, a little selection of some actual projects. I'm really interested in math, especially computational pure mathematics, so these libraries were (and continue to be) fun to write and play with. * My library [CL-PERMUTATION](https://github.com/tarballs-are-good/cl-permutation) has given me a systematic and reasonable way to explore the mathematics of permutation groups, which has been helpful in solving some math problems I've been interested in since I was a kid (e.g., group element factorization). * I am quite proud of my [number theoretic transform](https://github.com/tarballs-are-good/lisp-random/blob/master/number-theoretic-transform.lisp), mostly because it works. It's not the fastest, and doesn't use the greatest techniques for computing good moduli, but it has been a very interesting exercise for me in order to understand and make use of Fourier transforms over finite fields. * I have a fun project that I only work on during plane rides. It's called [Formulador](https://github.com/tarballs-are-good/formulador) and it just prints math formulas as ASCII art.
I'm sorry if I sounded harsh. I like the idea. I probably like the idea too much. But the way many of the unix commands work, and especially the system calls underneath, is clumsy and inflexible compared to how one can do them in Lisp. For example, one could imagine: ;; `df` command (print-table (mounted-filesystems)) ;; another `df` command (print-table (remove-if-not (_ (equal "ext4" (filesystem-info-type _))) (mounted-filesystems))) ;; another `df` command (print-table (remove-if-not (_ (and (equal "ext4" (filesystem-info-type _)) (&lt; (expt 2 (* 23 (sqrt 2))) (filesystem-info-bytes-free _)))) (mounted-filesystems))) ;; insert the results in a database (insert-into [fs-log] *) ;; chart the results (graph (select [bytes-free] :from [fs-log] :where [&gt; [creation-date] (time- (weeks-to-time 3) :now)))) etc.. Once liberated from 'plain text' form, one can do many interesting things. Also many of the commands are quirkishly made so shell scripts can run. Some commands, such as these seem like they have some rather clumsy overlap: `logname` `users` `who` `whoami` `id` `pinky` These commands seem pointless in Lisp: `expr` `seq` `nl` `echo` `false` `printf` `sleep` `true` `[` `yes` and probably others. Many others already have canonical implementations in Lisp. and so on. 
- lack of syntax (near zero idiosyncracies[1]) - emphasis on expressiveness over bureaucracy - linear induction (recursion over lists) was extremely powerful to train my brain into solving problems - very different cultural landscape that is much more inspiring (lots of things I loved naturally had lisp in them, emacs, hp48, mirai) [1] I failed an exam because I couldn't find ADA syntax to index strings .. it was backquote or something. I despise syntax so much. 
You loose the ability to edit code by logical units. "de-indent" the whole if ? Easy. I mean, workarounds exist for some tasks (my [indent-tools](https://github.com/vindarel/indent-tools) or other stuff specific to languages), but they're so hacky and not powerful… look at extensions like [lispy](http://oremacs.com/lispy/) to see what they allow
Interactive and incremental debugging and development. Allowing me to change and inspect my program in real time using the same tools that I use when writing code. Teaching me a lot about functional programming and internals and implementations of object systems.
A LispOS does not have to use Unix abstractions, just like Lisp does not use Unix abstractions. Objects can be objects, not files. Data can be structured and interactive, not mere streams of bytes. A filesystem needs not exist at all. All three are limitations imposed by the Unix philosophy, and a LispOS does not need to follow any of them, just like Lisp already does not follow them. If you are somewhat competent with using a Common Lisp image, simply think of extending the world of a Lisp implementation to encompass the whole operating system. You don't need to use files to access data, you can do things like `(remove-if-not :music *all-my-data* :key #'data-type)`. You don't need to have bytestreams to access your data and therefore treat everything as a stream of bytes ending with an EOF marker; you can have actual types, a class named `MUSIC-OBJECT` for objects that are music, a class named `TEXT-DOCUMENT` for various kinds of text documents, and so on. You don't need to use files; you can simply use structures and objects, you can use integers, hash-tables, trees, whatever kind of Lisp data structure you like. When all you have is a hammer, every problem starts looking like a nail. The idea of a LispOS is noticing that approaches other than hammering stuff are available, and that not everything is best solved by slamming them hard with something big, steel and fast-moving.
I'm not a LispWorks user so I cannot say for my own, but I've alerted LW to this post, so they can add their two cents to the discussion.
why can't it be Wednesday?
I didn't mean i do "scripts"; what I meant is that the Lisp language in some ways resembles the "scripting" languages (i.e. Ruby, Python), yet it has better execution speed. Lisp is a general purpose programming language, and I don't use it for only one task in particular. 
&gt;I see those links are for full-blown Lisp machines. But do you think some of these ideas would be worthwhile to implement on top of a non-Lisp system? Many of those things (but not ALL) are already available on Common Lisp implementations under a Lisp IDE like the combination of Emacs + SLIME. &gt;worthwhile It is very funny: the world is trying to tie servers together with a common protocol (i.e. JSON + REST services) to share information, while the Lisp machines of old easily interchanged information between applications by using s-expressions. In some ways, the mainstream computing world is trying to achieve some things that were already done in the early 80s with Lisp Machines.
&gt; the Lisp language in some ways resembles the "scripting" languages (i.e. Ruby, Python), yet it has better execution speed Lisp is nowadays mostly compiled (even at the REPL!) while Ruby and Python are most often interpreted.
It made my life harder, because most projects I've been on use other tools — complete rubbish in comparison to Lisp. Ignorance is bliss! :)
&gt;I will say the pricing is inexpensive. You'd be surprised to see how much a license costs for widely used professional software like [SAS](https://www.sas.com/store/products-solutions/cSoftware-p1.html?storeCode=SAS_US) or [Alteryx](https://www.alteryx.com/products/platform-details/pricing). (Go ahead, click to see prices.) Sure, but you can develop a desktop application for Mac with Xcode for free, under Windows with Visual Studio Community also for free, and there are several other options available also free. I’m not saying LispWorks should be free or inexpensive, only that at $3000 for a single platform is an investment not only in a product but also in a company. My reason to ask for how LispWorks is doing, is should I eventually (I have other active project to finish first) commit to it? &amp;#x200B; &gt;They can only link to success stories using the LW implementation. There are modern Lisp success stories, just not all of them using specifically LispWorks. For some examples of modern Lisp success stories: And I know all about those stories, but I’m more worried about the future of the tools, not the language. I know LispWorks was another company before, and before that it was another company, and their company profile on UK company reports show their financials decreasing year over year. &amp;#x200B; &gt;As a Lisper, you already know that Lisp is more about substance than form. I’m not talking about the language, but the tooling. I started experimenting with CAPI and it looks like it could make a nice GUI (with a lot of work though). &amp;#x200B;
&gt;you can develop a desktop application for Mac with Xcode for free, under Windows with Visual Studio Community also for free Yes, everything for free, but what if, for example, not using Common Lisp, but instead using Javascript will mean I have to face some security problems? or that I'll have to spend considerable more time in writing many more tests than usual? Or what, for example, if choosing Java will mean that my development time will take 300% more? Or if using Python/Ruby/etc will mean our servers will run slower than possible and thus the operational costs of my on-demand cloud servers will be higher than they should be? That's the cost that is not often talked about. Mind you, i'm sort of playing Devil's advocate here, since I use free Lisp implementations (CCL and SBCL), but it's important to consider them too. By the way, if you're considering GUI development and want to keep everything free or almost free, take also a look at the Lazarus IDE for Pascal (Free Object Pascal). And of course, there's always TCL/TK, which, despite looking like old stuff, is proven and works perfectly fine for GUIs. &gt;I’m not talking about the language, but the tooling. Yes, but you were commenting on how the tooling looks, not how the tooling performs. 
Thanks for sharing your experience, I was a little worried everybody would be telling me I'm nuts. Are there any easy-to-understand reasons I might prefer running a subprocess? For my use case doing it through SLIME seems to have good properties, so I'm curious about the uses you found for calling between Emacs and CL.
pet projects, made easier: web scraping, readline apps, DB, OOP related stuff (ah, polymorphism, multimethods…),… distributing/deploying self-contained apps, even web apps, is such a relief (compared to Python/JS). Writing code is easier (s-exps, editor plugins manipulating s-exps), the development process is less dumb (re-run, re-compile the entire app ? Meh, compile the function I am on and get compiler warnings). My [gh](https://github.com/vindarel). What it *will* make awefully easier is web dev with the [weblocks](http://40ants.com/weblocks/quickstart.html) framework…
I did an AI assignment in lisp and not only was it a lot easier than Java but I think part of the reason I got such a high Mark is none of the TAs could understand my code
The largest drawback (besides the price) is that LispWorks does not include the source for its GUI toolkit, like some other commercial Lisps do or did. Though they have a lot of examples and quite a bit of documentation. LispWorks exists since the late 80s. In its current incarnation it nicely runs on various different platforms. The big appeal is that the IDE and GUI toolkit runs mostly unchanged under Windows, macOS and GTK/Linux/UNIX. Over the last decade it got quite substantial new features like: CAPI supporting high-res screens with better quality drawing new platforms for the full implementation, like 32bit/64bit ARM/Linux and others Symetric Multiprocessing, but no parallel GC so far CAPI support for newer input models (like gestures) non-graphics port of mostly the full LispWorks implementation to Android and iOS (incl. recently a 64bit version of iOS) remote debugger/listener and a bunch of other stuff. So, I think they have added quite substantial stuff in the last years. I have for example a version of it on an ARM processor and it is very is robust. Generally problems are fixed very fast and you get patch files which are loaded on startup - so you don't need to install a new version. One can of course dump new images, if needed. If you want to check out the full product and play around with it, contact their sales address and they'll give you a time-limited version. In my view its the best desktop Lisp available - it probably has the best implementation of any dynamic programming language I've seen so far (compared to Lisp, Schemes, Racket, Smalltalk, ...). But then it's also one of the most expensives. At least they don't charge for applications, only for the development tool. 
Edit: [How a satisfied Lisp user would look like](https://avatars1.githubusercontent.com/u/168639?s=400&amp;v=4). /u/sbenitezb : Seb, it looks like you and me speak the same spoken language, so feel free to send me a personal message whenever you like, perhaps we can share some experiences with using Lisp in this part of the continent. Greetings! 
&gt; Visual Studio Community also for free Given that you are not a company and you don't want to sell your product. Xcode and Visual Studio are the product of billion dollar companies, where you buy their products - you can develop with Xcode - but then you bought a Mac already. Additionally these companies don't care about Lisp. With Apple you get Objective C and Swift. Microsoft sells F#. 
Really? How did you know that?
&gt;Really? How did you know that? Because this is [how a satisfied Lisp user looks like(https://avatars0.githubusercontent.com/u/168639?s=460&amp;v=4), and because of [this](https://github.com/sbenitezb). I am [here](https://github.com/defunkydrummer) by the way. Cheers! 
Thanks for the overview. Most of it I already knew. I agree the tooling is good considering the choices, and of course, being a small company it wouldn’t be able to provide a product such as Visual Studio. So I guess it’s ok for what it is. I need to play more with it to see what I can get out of it before committing.
&gt; If it looks like ass (consider a TCL/TK standard look) But also note that currently TCL/TK provides the native look, at least in Windows. And the thing performs fine user-wise: I often use the GitGui application, and works just fine (it's a Tcl application.)
Allegro CL has some support for a parallel GC. https://franz.com/support/documentation/10.0/doc/gc.htm#multi-threading-2
&gt; research on parallel programming Starred!
Btw., I think the first versions of the ITA airline fare search engine QPX were written in LispWorks... https://www.quora.com/What-is-the-company-that-HipMunk-copied-design-wise 
Capi is good enough for most things in my experience. [https://itunes.apple.com/us/app/typing-common-lisp-edition/id1202707132?mt=12](https://itunes.apple.com/us/app/typing-common-lisp-edition/id1202707132?mt=12) is a good example of an application written in it. It won't be as sexy as a lot of modern application interfaces are. CG does not support multithreading on any platforms other than Windows. Allegro comes with a lot more libraries, and LW is much more concise. 
I love Emacs! But I was thinking of replacements for commands like `cp`, `mv`, `rm` etc... something I can use in the sell, outside Emacs.
Well, don't know if it has been done before. But, it could certainly be useful. Not so much a Lisp OS, but there are many programs in coreutils among other programs that if they could be written in a particular subset of R6RS and R7RS Scheme, they could probably help the Mes (https://www.gnu.org/software/mes) project's goal of reducing the binary seed needed to build GuixSD by reducing the number of precompiled utilities that need to be in the environment already to start building everything.
Formulador looks like a sick project! Congrats
There are a bunch of Lisps where this did not happen. For example these initially commercial implementations were not open sourced: Interlisp-D/Medley, Genera/OpenGenera/CLOE, TI Explorer, Lucid CL (now owned by LispWorks), Procyon CL (owned by Franz), Lisp-To-C (owned by Oracle), ExperCommonLisp (went away), Golden CL (never updated), ...
&gt; ... (Qt embeddings) will mean you will either have to GPL your software or pay Qt for the license. Just a point of order... Qt non-commercial is LGPL which means you can distribute closed source if Qt libraries are not statically linked and other LGPL license conditions are met. Also, the LispWorks HobbyistDV editions necessary to distribute **non-commercial** apps on the main three platforms with is simply too expensive. €1200? Is it really €3600 to target Win/Linux/Mac with free software?
+1. I was wondering, why do we hear so little from them ? (or from proprietary vendors) (they must be busy, alright, but still ?) We hear too much about Jebrains for example. 
I was looking at ScoreCloud today. Didn’t look like a CAPI application, perhaps it’s heavily customized or has migrated to another language/GUI.
I just discovered this subreddit and felt that this belonged here. It is a keyboard which originally went to an LMI-CADR Lisp machine which I purchased from a fellow of the Computer History Museum. It was one of two spare keyboards discovered in storage so no machine for this to go with unfortunately. As a bonus this keyboard can be converted to USB fairly easily thanks to a GitHub project created by Mike McMahonon of Symbolics fame. With limited knowledge this has been a gateway to learning more. Besides learning about the history of Lisp machines I would love to find some energy reserves one of these days and get started with some programming. 
Envious!
[removed]
Perhaps I'm misunderstanding something, but wouldn't you have to also declare the type of the pointer? If so, I would encounter the same issue that I currently have.
Lisp is a great programming language to start with if you're dedicated. Its a lot to learn, but the syntax is uniform, which IMO is worth the tradeoff. No more memorizing operator precedence!
I really wonder how many qpx hackers read this o.O From what I hear ita went through many various lisps
That fake space cadet looks like crap. The bucky keys are in the usual unergonomic size and positions and the yellow return doesn't fit at all. Bet it can't write Greek or APL, despite having the keycaps for APL.
Robert "beach" Strandh (of SICL fame) wrote a paper on what a LispOS could be: http://metamodular.com/lispos.pdf
You are an entry level user then: From the price of Macs I've used as a personal machine one can buy around 30 LispWorks 64bit licenses. From the Macs+Apple peripheral (screen, keyboards, cables, ...) I've privately bought, one can buy around 10 LispWorks licenses.
Well, you are lucky. This is one of the rarest and most famous keyboards ever. I have slightly later Symbolics keyboards (old and new style).
Another nice GUI app, developed with LispWork, [mediaimport](https://github.com/fourier/mediaimport)
/r/MechanicalKeyboards
It has made me realize the vast amounts of workarounds and indirection done in traditional languages (e.g. using 'patterns') to get something done. With Lisp I can specify a language that fits the problem domain that is readable, extendable, and used as a "language as a library". It's wonderful. A small project I've been working on is a game in Racket. Using memoization of OpenGL state so there's no handling of objects or anything, just a call to draw something and it's all handled for you. [Memo library here](https://github.com/BourgondAries/memo) I also host a [website](https://gondola.stravers.net/) using Racket and use it for various utilities. Overall. Lisp has been the enlightenment for me. I don't think (but am open to) that there's going to be anything that surpasses lisp in terms of power. The metaprogramming abilities are off the charts, and guiding a discussion toward metaprogramming is my benchmark to see if other programmers are truly enlightened. I know it sounds zealot-like, but to me it simply shows that the programmer has understood that programming is about writing the most concise yet readable and most maintainable code possible - that language itself is the ultimate abstraction.
Once again sorry for the short reply ... a coffee pause is not the right time :-) I think that you can declare the fact that your structure points to a structure and doesn't contain it by only using a pointer. I did some CFFI and used pointers (but not with a circular net like yours) and it worked as long as my calling objects had the right arguments. But no time here to produce a code, sorry. By the way does your code work in C ? 
It's a rather good idea to have the modern sizes for keycaps instead of their "true" sizes so that they actually fit onto keyboards. And for the APL and Greek symbols. Of course the keycaps can't write them out of the box! They are *plastic pieces*! You could however configure your computer to write those symbols with the appropriate mappings.
&gt;so that they actually fit onto keyboards. They fit the CADR keyboard fine. &gt;Of course the keycaps can't write them out of the box! They are plastic pieces! I meant "the keyboard can't write Greek or APL", and it lacks the modifier keys to do so.
so that they actually fit onto ***modern*** keyboards. Or do you have some place to actually buy a CADR keyboard? The group buy also has the option of the "Cadet" add on set, which adds the "Top" and "Greek" keycap. From there it's just some hacking (which I admit is still a bit to much config. But getting a CADR to work on a modern machine (with all modifiers) is way more work).
&gt;&gt;Visual Studio Community also for free &gt; &gt;Given that you are not a company and you don't want to sell your product. Another licensing point of order. :) - Individuals can use VS Community for commercial use. - Companies can use VS Community for commercial use for up to 5 users *unless* you are an 'enterprise' with "either (a) more than 250 PCs or users or (b) one million U.S. dollars (or the equivalent in other currencies) in annual revenues" (unless...) -- Any company including enterprises can use VS Community for any number of users to develop software to be released under Open Source Initiative (OSI) approved open source software licenses. Importantly 
Okay, it's preference but if I want a CADR replica I want a **CADR replica**, not something else with blue and grey keycaps.
gosh, I forgot: hacking my text editor and bend it to my needs, making me dive in many subjects essential for my discipline. Thanks, Emacs !
However, recently I tried to find a working library for such simple task as reading emails from IMAP server without any luck :(
&gt; Individuals can use VS Community for commercial use If you are a single developer and contractor using it to develop an inhouse application for an enterprise -&gt; can't use it... https://visualstudio.microsoft.com/wp-content/uploads/2017/11/Visual-Studio-2017-Licensing-Whitepaper-November-2017.pdf 
What you wrote wouldn't compile in C since it would lead to a struct with infinite size. So I'm assuming one of those is meant to be a pointer. Unfortunately afaik there's no way to forward declare with cffi. I remember running into this issue and hacked my own solution around it. The simplest way is to just define your pointer as (:pointer :void) Cffi itself doesn't do anything right now with the types beyond figuring out the size, and a pointer to void is the same size as a pointer to anything else
Ugh, those guys don't actually care about the computer on the other end of the cord.
Awesome! I'm an Emacs user too. I'm learning Common Lisp. Do you think I'd have a hard time "translating" this knowledge to Elisp?
Great and complete answer. Awesome! Could elaborate a bit on the first topic? How did lisp gave you an income since the start of your professional programming career? And how was this knowledge different from any other language?
You can also impress your classmates because, if they can't understand what you're doing, they think you're smart by default lol.
I'm was wondering on how to convert Common Lisp to C source code for my algorithms class... :P So I guess I'm spoiled already.
That is great! The graphics on your website seem cool, but the videos are mostly still images. I'd love to see your games in action!
It's said in a few Lisp Books (sicp, brown plaisir,...). The thing is, many people really love grammatical aesthetics, and I think newbs wants the magic feeling of complex syntax.
What do you mean by "magical feeling"? Cause my colleagues (first semester) learning [Visualg](http://visualg3.com.br/) and now C are not feeling magical at all... they're having trouble with the most basic algorithms :( Lisp feels more "magical" to me!
A quick and dirty Google search for "lisp IMAP" brought: https://www.cliki.net/mel-base https://common-lisp.net/project/clonsigna/ There are probably more libs, for example on GitHub, etc.
&gt; if they can't understand what you're doing, they think you're smart by default lol. essential for career advancement!!
Lisp feels magical but at a different layer, more mathematical. Probably why people don't like it. Algol languages have a lot of idioms, punctuation, proto-concepts to read and learn about while at the same time being hidden being all the parsing that most coders don't know about. That's what I theorize as being 'magic'. Lisp gives less rope to play.. so for seasoned people it causes another kind of magic because you feel like there's nothing yet it does process data.
One thing I am trying to learn from lisp programmers is their process/workflow. Do you mind to share yours? 
I want this for emacs usage :(
Mes is not the same as Guile, but it is largely compatible, intentionally. Its developers are on the Guile mailing lists and make announcements about Mes on the mailing list. The compiler is designed to run on both Guile and Mes Schemes.
Note, that the link provided are for libs that won't convert Lisp to C (or other language); what they are doing is converting a s-expression DSL into C. 
Most (though not all) of my employers have paid me to write Common Lisp. Sometimes this was my choice, sometimes this was the employer's choice. Almost always though, it was chosen because of the problem domain, which all had characteristics of being very difficult, poorly described, or lacking a clear path to a solution.
hey ! Not at all as far as lisp is concerned, elisp is pretty similar to CL. It even has a `cl` package. The idiosyncrasy of elisp is learning how to… develop emacs: search strings in a buffer, what are text properties, etc. CL has some more stuff like advanced exception handling, not found in elisp (AFAIK) or the object system (found in eieio, less used).
I'm suprised `()` require `&lt;shift&gt;`
Great... I plan on creating a package to make Org more accessible to people that don't use and don't want to use Emacs (like, regular non IT people). Right now it is the best organization tool out there, but you kinda have to marry Emacs in order to use it!
Interesting... knowing a rare skill like that is likely to pay off. I only wonder how that works in South America. I never heard of Lisp being used around here.
&gt; I see... and those DSLs are like a subset of Lisp, or completely different? It depends. For example I have seen a Common Lisp library that allows you to output Java code, but the syntax looks very much like a regular CL program. 
Pretty project, just enough ambitious. I'm sure one can re-use [Portacle](http://portacle.github.io/) for this, since it is a self-contained emacs. Also I'd watch how magit is going offer one executable for the command line, also for people that wouldn't start emacs but who would use an advanced git ui.
Nah, that's just if one pair doesn't suffice. If you look closely, they are also right next to the P and those don't need shift ;)
Same. I have a vital need for conciseness. Sometimes i felt that my brain wasnt capable of juggling with large languages. But some known researchers did say that was the Root of their thinking process. So who knows. Now it's not binary, i too prefered less beautiful things because the nicer one eluded me(fp, prolog, ...). 
Hey, agumonkey, just a quick heads-up: **prefered** is actually spelled **preferred**. You can remember it by **two rs**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Are there any options available now? I have done no research, but I assume that if there is, people here would know about it. Probably wise to further assume that, if there is, it would be mentioned in these comments, but I figured I might as well ask. 
I think there are people who go whole hog and build keyboards from scratch. But I would guess it is expensive and has unpredictable results. There is a relatively small market of people who *really* have a use for a non-standard keyboard like this, compared to even the market of people who are willing to spend even $200 on a somewhat custom keyboard. I happen to have a Symbolics Rev C which I can use for this kind of thing. Of course the Symbolics guys originally did it without magic, but they also had corporate backing to pay for some amount of NRE cost to, say, set up tooling to produce a thousand keyboard cases or frames or whatever out of metal with a somewhat experienced designer making the choices. Not just some software geek saying "I want one!" Costs on this kind of artifact are enormous for unit 1, and then much less for units 2 through N. I suppose you start by doing something like laying out a circuit board with Cherry keyswitch footprints, appropriate diodes and a controller of some kind, then you worry about the mechanics of how you mount it it in a sufficiently robust and aesthetic way. https://www.makeuseof.com/tag/build-custom-mechanical-keyboard/ But perhaps you have to spend a thousand bucks to make it happen, or you compromise and make a frame out of laser-cut-whatever or make do with a stock frame of some other kind.
They're all videos, could be your browser. Most of them are VP8 encoded videos. What browser (version) are you using?
The type of the pointer can be void.
All the arguments in favor of paying exorbitant rates for commercial Lisp when free Lisp is (as far as I can tell) just as good if not better for most purposes reminds me of the state of commercial UNIX in the late 1990s. Commercial UNIX cost thousands of dollars for just the software, and most of the tools that shipped with it were inferior to the GNU versions. Today, nobody pays for Unix. Will the commercial Lisp vendors go the same way? Seems like it to me.
TXR Lisp has good support for text munging and other things. Suppose we wanted to write `ls`; for the `ls -l` output, we need to get the mode in the `rwxrwxrwx` format (plus the letter `d` for directory and `s` for symlink, and some cases like setuid, setgid or the sticky bit). Getting just the basic mode can be coded like this: (defun mode-rwx (mode) (let ((rd (reverse (digits mode 2))) (rm "xwrxwrxwr")) (reverse (mapcar (do if (zerop @2) #\- @1) rm (pad rd 0))))) 1&gt; (mode-rwx 1) "--------x" 2&gt; (mode-rwx 12345) "---rwx--x" 3&gt; (mode-rwx #o333) "-wx-wx-wx" 4&gt; (mode-rwx #o666) "rw-rw-rw-" 5&gt; (mode-rwx #o777) "rwxrwxrwx" 6&gt; Getting the `stat` information: 1&gt; (stat ".") #S(stat dev 2049 ino 713884 mode 16893 nlink 2 uid 500 gid 500 rdev 0 size 4096 blksize 4096 blocks 8 atime 1540363533 mtime 1540363531 ctime 1540363531 path ".") 2&gt; *1.mode 16893 Looking up user: 3&gt; (getpwuid *1.uid) #S(passwd name "kaz" passwd "x" uid 500 gid 500 gecos "Kaz,,," dir "/home/kaz" shell "/bin/bash") Is it a directory? 4&gt; (logtest *1.mode s-ifdir) t 
As far as I know log and log3 are equivalent in terms of big-O notation due to the log laws. (logn x/logn 3 = log3 x)
The logarithmic function is the inverse of the exponential function, and logarithmic growth is the inverse of exponential growth. `O(log n)` = `O(1/e^n)`.
'Free software' can be commercial: Example Red Hat Enterprise Linux. https://www.redhat.com/en/store/linux-platforms &gt; deep pocketed corporations stopped paying for Unix They pay now for stuff like Red Hat Enterprise Linux. 
To make it explicit: &amp;nbsp; O(log3 x) = O(log10 x/log10 3) In Big O notation constants are ignored and log10 3 is constant! In other words O(log3 x) = O(log10 x) 
Thankyou for the elaboration. I could have been more descriptive with my answer.
&gt;Today, nobody pays for Unix. Today, corporations pay for a lot of software including Unix and commercial support for Linux, also they pay through the nose for some RDBMS; they pay for office software, VPN software, etc. Again, LW licenses are reasonable in that context. Source: i work at a very big.company that has in-depth knowlege of what goes on at the top companies of my country.
Log(n) != 1/exp(n). The latter gets smaller as n gets bigger...
Yes - thank you for correcting it.
TXR Lisp is beautifully written, and should be an inspiration to anyone writing an interpreter. But it's hard to recommend **not** using CL for O/S level Lisp code, given that: (defun mode-rwx (mode) (let ((s (make-string 9))) (loop :with tag = "xwr" :for i :from 8 :downto 0 :for j :from 0 :to 9 :do (setf (char s j) (if (logbitp i mode) (char tag (mod i 3)) #\-) str)) s)) ▶ (time (dotimes (i 20000) (loop for i from 0 below #o777 do (mode-rwx i)))) Evaluation took: 1.202 seconds of real time 1.204000 seconds of total run time (1.200000 user, 0.004000 system) [ Run times consist of 0.020 seconds GC time, and 1.184 seconds non-GC time. ] 100.17% CPU 2,759,219,871 processor cycles 654,081,856 bytes consed At 1e7 modes per second, SBCL seems to have squeezed 0.17% more utilization out of a single core than possible! [sorry but your interesting code inspired my inner code golfer]
Thank you for the pointers. I have not gotten a chance to look at the video yet but should be able to later today. Looks like you actually have a series and all look to be quick and short. Will watch and learn a thing or two. 
&gt; Are there any options available now? What I'm thinking is to buy a DIY arcade joystick controller kit (they sell them for cheap in my country -- a combination of: (sanwa joystick ten sanwa buttons, arcade style PCB with custom IC and USB port -- makes them look like a joystick to the PC)) As far as I know, Emacs can receive Joystick events; thus one can map any kind of joystick button to Hyper, super, etc. You could even connect some **footpedals** to the PCB controller, how cool would be to have a Hyper/Super/Meta pedalboard?! I play keyboards so I already have some sustain pedals that can serve perfectly this need. (Another possibility is buying the Behringer MIDI Pedalboard: FCB1010, and using a custom solution to turn MIDI events into something Emacs or the PC can understand.) 
Don't remember if I tried clonsigna, but I've tried mel-base, and hoped it will work for me. But this library have many issues. First of all, it is architectured to just copy messages from one mailbox to another and does not allow to work with the message's content (parse mime, headers, etc). Search my criterions does not work, etc. Also, I found postoffice (http://quickdocs.org/postoffice/). It is a fork of Franz's cl-imap. Version from Quicklisp does not work with SSL. Postoffice itself has yet another fork: https://github.com/orivej/post-office where problem with SSL support was fixed, but does not work either because some internals of acl-compat were changed. I can't call it like there are many libraries which work. I have to fix these problems to make postoffice work for me: https://github.com/orivej/post-office/pull/1 And finally, created a wrapper, to simplify work with imap in common cases: https://github.com/40ants/trivial-imap
On page 8 of http://www.bitsavers.org/pdf/symbolics/software/genera_8/Symbolics_Common_Lisp_Dictionary.pdf we find that profusion of `\`. Is it an error? or...?
Now I'm tempted to page Akira :)
Thanks for this info, i'm taking note.
Thank you very much for this info.
Ah, good point. I'll throw in a couple of my own observations now that I've had a couple of days to play with it. 1. Swank's nice multi-threading could very easily lead to bugs. 2. You'll probably have to convert your CL data structures to Elisp-compatible ones before sending them over, meaning you might as well have just serialized the things for transmission as text anyway. I very much liked the idea of connecting to a running program without writing a special server, but maybe that's called for after all. Seems like there might be a place for a CL&lt;-&gt;Emacs communication library other than SLIME.
Yes. I believe nrepl and edn from clojure are worth looking at for inspiration. Someone made a start https://github.com/sjl/cl-nrepl
Job security through obscurity.
Thanks for your insight, I realize my mistake now and have it figured out.
I see what you mean now. The members of the struct should have been pointers. Thank you for your help.
With this version of `mode-rwx`: (defun mode-rwx (mode) (for ((mt #H(() (t "xwrxwrxwr") (nil "---------"))) (out (mkstring 9)) (i 0)) ((&lt; i 9) out) ((inc i)) (set [out (- 8 i)] [[mt (bit mode i)] i]))) We get: 1&gt; (compile 'mode-rwx) #&lt;vm fun: 1 param&gt; 2&gt; (compile-toplevel '(pprof (dotimes (i 20000) (dotimes (m #o1000) (mode-rwx m))))) #&lt;sys:vm-desc: 9408b78&gt; 3&gt; [*11] malloc bytes: 409600000 gc heap bytes: 163840000 total: 573440000 milliseconds: 70760 nil Machine is this: processor : 0 (out of 4) vendor_id : GenuineIntel cpu family : 6 model : 42 model name : Intel(R) Core(TM) i5-2310 CPU @ 2.90GHz stepping : 7 cpu MHz : 2864.718 cache size : 6144 KB 
I was in the same boat. After a couple of arguments with u/lispm, I've finally decided to pull the trigger. You just have to save a little, consider it as an expensive hobby ;) The arguments are * CAPI. One of the typical questions to Lisp users is "how can I create a GUI app". With CAPI problems solved. Yes CAPI is kinda limited and you don't have as much control or features as with Qt, but if you are targeting some particular platform you can still go with platform specific things: i.e. on Windows you can implement missing functions with CFFI considering you can get the [window handle](http://www.lispworks.com/documentation/lw71/CAPI-W/html/capi-w-600.htm#46621) while on OSX you can easily access all [Cocoa](http://www.lispworks.com/documentation/lw71/OBJC/html/objc.htm) APIs. * Fantastic support of Cocoa on Mac OSX * Good Windows support, very stable * IDE, while the text editor is weak the IDE features like Stepper, Profiler, Code Coverage, Debugger, different browsers, multiple REPLs, integration with everything and ability to inspect anything including any UI element are great (although the tools are little bit limited in functionality, could be better) * Application delivery - including tree-shaker - so my app is not of the size of Electron app for as simple dialog application, including delivery of LW app as a dll * Java integration - so I can use not only CFFI/FLI to access C libraries, but combine them with the great Java libraries as well! * A set of included goodies like async IO, threads, SSL, fast integer arithmetics, etc * General feeling of all-in-one solution. LW + Quicklisp and you have no excuses to not to write Lisp apps anymore unless you have some very specific requirements. As for the downsides: * Price, separate licenses for different platforms and unaffordably expensive 64bit editions. I would prefer to have one price for all platforms of course. * no maintenance package for Hobbyist edition, I think the community of Hobbyist editions have to request it from LW company * Lack of sources apart from Editor * IDE could be better - so much more possible to do to make it better if the sources for IDE would be available for license owners (I've submitted a plenty of feature requests, and some of them were implemented in the last version 7.1 actually) As for if the company will exists - it is a small company of 3-4 people, it will survive for quite a while I guess. Also the CL standard is not going anywhere soon, so once you have an implementation you just continue to use it for years to come. P.S. You can meet Martin from LW at every ELS conference and discuss the things personally.
I tried Personal Edition of the LispWorks some time ago and didn't find a way how to use Quicklisp there. How to plug in a Quicklisp into the Lispworks?
&gt; Application delivery - including tree-shaker - so my app is not of the size of Electron app for as simple dialog application, including delivery of LW app as a dll &gt; Java integration - so I can use not only CFFI/FLI to access C libraries, but combine them with the great Java libraries as well! These are pretty strong points. The Java Integration also allows creating classes at runtime, etc? (ABCL can do it, but in a limited way.)
Then I was experimenting with Personal Edition the way was simply load my config file manually after the startup. What you need to do though is to download asdf separately as the one in LW Personal is too old. Here is the [snippet](https://gist.github.com/fourier/af97498cd5a2ed364a6eeed965d9964f) which should hopefully work.
It's left for third parties to add such functionality.
It is not a complete solution, but [rlwrap](https://github.com/hanslub42/rlwrap) adds readline feature to programs that don’t have them. You can use it with SBCL: `rlwrap sbcl`
Just edited my post to include sbcl-readline. It's a little project someone made to add readline support directly to SBCL. I did try rlwrap the other day and it was pretty neat. 
Any other third-parties besides Slime?
The answer to my 'why compare the location of y when we asked for :target x' is answered both in the [sbcl source](https://github.com/sbcl/sbcl/blob/0d54dc6530f39fe9fcb04071afe0c6a1e8bb6cee/src/compiler/x86/macros.lisp#L41) and briefly mentioned in Paul's article. the `move` macro checks the location of `x` implicitly and omits the move if the source and destination are the same.
rlwrap, linedit.
Nice. Good there are options for Vim users..and even Atom users! Haven't found one for VsCode yet. I don't personally use it, but it is becoming an incredibly popular editor.
- https://github.com/hellerve/sbcli - https://github.com/koji-kojiro/cl-repl: an ipython-like repl (usable, in development) - and http://portacle.github.io/ for a great out of the box Emacs + Slime experience. source: https://lispcookbook.github.io/cl-cookbook/editor-support.html 
just wanted to add that rlwrap is great because it composes neatly in a unix-y environment so it's not a solution for sbcl but having it in your toolbox helps you in multiple situations (lua/luajit, or the toy repl of your toy language) After a while, you'll run all them inside emacs :)
Awesome! Very impressive. Somehow I totally missed that has a compiler. I see it in the RELNOTES, but I don't see it in the code?
I really like sly
&gt; *I don't see it in the code?* In the C code, the new thing that appeared was `vm.c`; the compiler and assembler are entirely in Lisp, down in the `share/txr/stdlib` directory. I haven't released anything since August and some changes are piled up in there. For instance, hash bang support in `.tlo` (compiled Lisp) files. I made it a self-imposed requirement to implement a certain optimization in the compiler for the next release, and then dragging and dragging my feet on this, holding up everything. 
If you're actually asking why, it's a matter of licensing: readline is GPL, SBCL is public-domain. Actually [according to Wikipedia](https://en.wikipedia.org/wiki/GNU_Readline#Implications_of_GNU_Readline's_GPL_license) CLISP had to switch to the GPL because it linked readline.
Previous discussion at https://www.reddit.com/r/lisp/comments/3uc7vd/free_capi_implementation/
Thanks!
There is a project to make an lsp server for common lisp: https://github.com/cxxxr/cl-lsp
There's cl-garnet (also a pure CL GUI toolkit) with (at least) a Gtk backend already: https://github.com/earl-ducaine/cl-garnet
&gt; toy repl of your toy language Luckily, in [Build your Own Lisp](http://buildyourownlisp.com/), they teach how to add readline support :)
They should have persevered. You can have it so that your program uses GNU readline, and is not even distributed with it: it can just check whether the library is available and `dlopen` it. That is obviously use, like running an executable. If you don't redistribute a program, you are not doing anything that is covered by that program's GNU license. This has been obvious to me from the beginning, but is not clearer than ever, when you look at the SBCL approach of using readline: just some package you can load that opens the library. 
Distribution is specifically not "use"; that's a crucial distinction. The GNU licenses do not cover "use" at all; use is unrestricted. They cover redistribution. It so happens that if a GNU licensed program component is combined with components that have other licenses, then the combined work as a whole is then under the GNU license. Those other components keep their respective licenses. But those licenses have to be "GPL compatible"; they cannot be more restrictive. In that case, the combination is not possible; it infringes. Stallman argued that since CLISP links to the GPL-ed readline library, the entire combination as a whole has to be released under the GNU license. I think at that time, CLISP did not have a GPL-compatible license to make that possible. So the choice was: adjust the license of CLISP, or else stop using readline. Stallman's argument rested on the doctrine that using a shared library still constitutes making a derived or combined work; he didn't accept the argument that the library is separate and could be dynamically loaded or replaced with a drop-in compatible and not even redistributed with CLISP at all. I firmly believe that Stallman was wrong in that regard. 
Take a look: https://github.com/koji-kojiro/cl-repl
Nice ! Do the have the exact chapter ? 
Clojure has a good excuse: It's written in Java, and Readline is a C library (and there aren't any Java libraries for all that terminfo stuff). Fennel has a similar excuse, being written in Lua. 
Some specialized implementations have some terminal support. Some even offering editors/structure editors. The more complex were not that robust (like CMUCL/Hemlock in the termin, IIRC). When I use Lisp in a terminal, I always use something like GNU Emacs - we used that before SLIME with other tools like ILISP or similar - Franz has ELI. There is always the need to edit/format/indent code and the listener inside GNU Emacs is also better to use than a raw terminal. Since raw Common Lisp implementations are often cross platform over a wide variety of platforms, they often assume very little - the tool like a listener is then seen as not an integral part of the implementation. Also implementations might be embedded or compiled into an application - deployment options might be very different. 
That's not true. Perhaps, the maintainers of the language use editors/ide and don't feel the need to add them to their repl? Picolisp has decent commandline-completion + history mechanism.
One thing I like in a REPL is file name completion. Do any of the REPL packages support that?
I'm sure a simple `firejail next` or using docker will do. For the rest, I disagree and see value.
What are you using as a web browser? Because I would love a web browser secured with emacs command, and every feature emacs can have, but there is none for now. I tried conkeror but it is a bit outdated and not easily customizable. 
&gt;a bareback anal sex bender in 80s San Francisco. I have no idea whether you're right or not, but that's absolutely hilarious so have an upvote.
http://buildyourownlisp.com/chapter4_interactive_prompt#an_interactive_prompt They use Editline, my bad.
Ah of course! Thanks a lot for clarifying this
This is the second time I've seen you post. You're doing the lord's work.
What scheme implementation are you using or planning to use? What OS?
What's your working environment? I found it tricky to figure out what Scheme version to use but I ended up with Chez after playing with Racket and Guile. I use Emacs with `geiser` which is nice although I have to restart the Scheme interpreter every now and then. I think the magic bullet for the course is the exercises--do them all! I worked my way through the first 3 chapters and then life interrupted. I got a lot out of it and hope to have time to get back into it sometime soon. Good luck!
SICP is super hard. Check out [Bill the Lizard](http://www.billthelizard.com/2009) for help when you get stuck. Ableson and Sussman switch the MIT Program to Python in the late 1990's as libraries took over and nobody could get the source code. [Why they swapped}(https://cemerick.com/2009/03/24/why-mit-now-uses-python-instead-of-scheme-for-its-undergraduate-cs-program/) Currently, they use [Guttag's Book](https://www.amazon.ca/Introduction-Computation-Programming-Using-Python-ebook/dp/B01K6F2236/ref=sr_1_1?ie=UTF8&amp;qid=1540566621&amp;sr=8-1&amp;keywords=guttag) which I am working through now. What is interesting is that the same material is covered in large part. I would bluntly state that Sussman especially was not a very good teacher. He's a genius, but I don't think that explaining things in relatable ways was a strength of his. Please note that experienced Software Engineers working in teams take about a year to get through SICP, so be patient with yourself. Why Scheme? I started using it because of SICP as well. Python has a lot going for it, most of which I discovered after learning a bit of scheme. Dr. Racket is the 'new scheme'. You can also use Guile or MIT scheme through emacs. Good luck. 
There is an archive to old MIT courseware 
&gt;However, for beginners who are curious about Lisp but don't want to learn Emacs this can be annoying. It is an order of magnitude more annoying to learn Lisp without a good editor system like Emacs + SLIME, Vim + SLIMV, the Clozure system, LispWorks, etc. 
As written the space complexity is the same as the time complexity; I'm pretty sure you could do the calculation in a fixed amount of space by rewriting the function to do the calculation from the bottom up (at any point in time, you only need to have the result for X/3, but as written the length of the call stack is being used to determine when the iteration should be completed). If you first calculate what value to start with (this can be done in a tail-call which is fixed-space in scheme), then you calculate the value with X increasing with each call (also doable in a tail-call), then it would be fixed space.
I just wanted to comment on the deleted post: 1) All technical critiques are valid and should be welcome. There is nothing wrong with the observation and comment around consequences of the observed issue. 2) However, as to whether or not you need to be a top engineer to write a piece of software, I don't agree with that. I agree that you need top certification and training for jobs like medicine, law, nuclear reactor design and all sorts of things. Next is just a browser and the risks are not the same. The author is perfectly competent enough to start. He has done an amazing job getting it to a point where it basically replaced Conkeror for me, so the author is quite the powerhouse. 3) I would love to see the deleted post re-posted once again for reference and any other other critiques added as anyone deems appropriate. This is the start of the road and everyone can only get better. At minimum, we can use the critiques to provide the appropiate usage notifications to users before the project gets to a point where the technical issues can be determined as something that should / can be addressed properly. 4) To the poster that deleted the post, please don't delete posts. Maybe you were a bit drunk when posting, but your feedback was valuable. You don't have to walk on egg shells. Just stick to your guns and own the consequences of the straight talk. To the dev of Next, you have done a great job single handedly replacing Conkeror for all usecases except one for me. I hope we can raise enough money to help with your goals.
I, as moderator, removed the comment not because of the criticisms but because of the overly aggressive tone and an inappropriate metaphor. The author of the comment u/proteus777 is welcome to repost his criticisms in a way that promotes civil discussion.
If you get stuck, or if you wish to refresh some part of SICP (or all of it) in a condensed fashion, take a look at "Scheme and the Art of Programming" by Springer and Friedman. It's basically the same material, spoon-fed and straightforward. You can find it legally free, online.
So I had to google implementation, haha. I'm using 2014-era MIT/GNU Scheme downloaded from here: https://www.gnu.org/software/mit-scheme/ Thanks for your response. I'm on Windows 8.1 atm
&gt; 'The Little Schemer' might be a good start as well, if you are into LISP like languages. That one is less about computation and more about thinking, though. Thank you very much, The Little Schemer is exactly the kind of thing I am looking for! I feel like unless I know how to *think* like an effective programmer and the capabilities of the tools I'm going to be working with, I'm going to be hampered. I've always been a bit believer in how underlying beliefs can shape your more complex thoughts and computer science seems no different. &gt; I personally would say that SICP is too hard for a first, but that's saying more about me than about you. You may very well be right. I was actually starting Python 3 first, and made it through an intro to strings and defining variables (also tried to see what would happen depending on how I fucked around with the .format(x, y) command)... and then during a break, while I was following various link rabbitholes, I ended up at the homepage for these lectures. I wasn't intending to get serious about it, just have a quick look at the lecture series. However, I got hooked from the first few sentences of the first video and quickly realised that no matter what else I did, I was kind of just going to naturally, inevitably, end up entangling myself with this series, and I was going to do it now. Just had this overwhelming sense of rightness about it, which kinda sounds nuts, but there ya go. So I thought I'd come get some advice and introduce myself to the reddit LISP community just in case this sticks. My very very not-set-in-stone plan is to switch between doing some Python, which I can probably use a bit more immediately, and learning SICP for theory. I know it's not ideal to try and learn two languages at once but both seem to have their benefits. Off the basis of one lecture, Scheme seems really fucking intuitive--but it's not that common, and tons of stuff supports Python. Over time if I have issues learning both at once, I'm sure I'll gravitate more to one than the other anyway. Since I'll be learning more in-depth stuff about Scheme through SICP, it's likely, though not certain, that I'll probably end up with Scheme anyway. I guess I'll see how it goes--I am expecting it to be something I come back to from time to time when my skills go up and I'm ready to learn some new stuff, but if I somehow magically just keep getting it, I'll keep going. &gt; Racket is very easy to install on most OS's and there's even a 'SICP mode' I believe. It's a great start into the programming world I think. If there definitely is an SICP mode, I'll check it out for sure. Side question, I'm still a bit nervous about eventually switching from the educationally-focused Scheme to a similar LISP language that is more full-featured and functional. I don't really understand what changes, or how something is more full-featured--it's all built on the same stuff anyway (said the noob). I also don't know how I will stop myself from getting mixed up between different commands for such similar languages. Do you think any of these worries are really founded? I guess my problem is I just don't know what I don't know, so I'm trying not to worry about it til I know more about how it all works--but any thoughts you have on this are welcome. Thanks again for your response (and for reading my monster reply!)
Thanks for Bill the Lizard! I have a feeling I'm gonna need him. Thank you also for the link to why they swapped from Scheme to Python. It definitely gave me some stuff to think about. I had actually completed my very first Python3 tutorial right before stumbling on the SICP lectures, and do intend to keep trying some Python stuff out as well. What struck me about that link was that the main reason seemed to be because Scheme was built for people who worked with their own libraries and created their own shit, or worked in small close-knit communities, and professional programming is now much more about collaboration. Ableson and Sussman seem to have switched in large part because their uni is pressured to turn out professionally capable workers, not necessarily because Python is now better at explaining the philosophy behind programming than Scheme is. I *am* looking at a career change and one of my potential careers is in IT as I've always been good with computers. But if I'm going to officially go and do that I want to know I can do it well first and hold my own. Part of that means using a language that might convey these core concepts better. All of this may just be a way to rationalise the fact that I want to learn Scheme for no better reason other than I can't seem to tear my brain away from the SICP lectures. But hey, I can always change my mind and pick up where I left off in Python. &gt; I would bluntly state that Sussman especially was not a very good teacher. He's a genius, but I don't think that explaining things in relatable ways was a strength of his. Haven't come across him yet, thanks for the warning. I may have to adapt my current decision on sticking with LISP if I find him to be too much. &gt; Please note that experienced Software Engineers working in teams take about a year to get through SICP, so be patient with yourself. I heard the dropout rate for this unit was like 70%, so believe me, I'm trying! Thank you for the support. &gt; Dr. Racket is the 'new scheme'. You can also use Guile or MIT scheme through emacs. Good luck. Currently using MIT/GNU Scheme, came with Edwin. But someone else has posted about Racket here as well so it definitely sounds like I should check it out. Thanks for your advice and thoughts.
Thank you! I think I will need all the help I can get as this unit seems to be famously difficult.
I downloaded MIT/GNU Scheme and it seems to have come with Edwin bundled up. Or maybe it's the other way around :) I honestly don't know enough about programming to know what I would like and dislike in a language, so I'm kinda just sticking with one until I dislike it, otherwise I'll never get started! That said two people here have mentioned Racket so I'm going to at least download it (not that I know how to play around with it), and I guess I"ll just muddle my way through from there. And yes, the exercises seem to be very important! Thanks for the advice and the well-wishes :) Here goes nothing!
Sml's repl can also complete path/filename
You worry too much! Starting with two languages is perfect. I started with c and Haskell (which is a functional language) in university. You'll learn a lot of lessons that way. And you are going to ask yourself a lot of questions like 'this is so easy in lisp/python! Why must it be this way here?'. And lot about language design (you might enjoy one over the other and that's perfectly fine (if it's not LISP, you'll be excommunicated of course ;))). A good programmer understands and uses multiple language depending on the situation. If you are currently working with SICP, by all means go on with it. It teaches you so much. If you want to 'use it immediately' as in writing software (with others?) Python or Java is probably the better language because you are going to find more people using these languages, that's right. However switching to a more industry oriented language from scheme (clisp, clojure) is rather simple compared to learning the first language. Scheme (racket) is full featured and you can do anything with it, there's UI libraries and everything. You'll be able to mostly understand java, c++, c, kotlin and other languages by learning python. You are going to need to learn some of the concepts (classes, pointers in c, typing in general) of these languages, but in the beginning it's all about the basic tools (variables, ifs, loops, lists, functions, abstractions in general) and those are pretty similar. Programming is a craft. You won't get better without blood on your hands. Programming in any language teaches you more than choosing the right language. Try dicking around with things. Scheme and python are a great start.
&gt;JavaScript Kill it with fire.
Once you learn the real fundamentals of how Lisp Syntax differs from Scheme, you can go right through the Little Schemer with Lisp Syntax. I did, and I'm not a programmer. 
SICP was a surprising enlightenment for me too. Such a different culture. If you need more, I suggest brown university PLAI (there are two editions, first one appealed to me more but 2nd might be better after all). Then you may peek at prolog books (bratko, or shapiro)
Thanks very much!
Good to know, thank you :)
&gt; You worry too much! Story of my bloody life lol. &gt; Programming is a craft. You won't get better without blood on your hands. Programming in any language teaches you more than choosing the right language. Try dicking around with things. Thanks, I've been trying to keep this pragmatic view in mind. Plus yeah I have been dicking around in Python already, trying to stretch the .format(x, y) function to its limits and find out what will break it and what won't. I'll keep going. Thanks for the reassurance and the explanations :)
That kind of misses the point of the Lisp Machines which were not usually accessed over a serial line, but on a dedicated display with keyboard, mouse, and relatively high resolution graphics display.
The Racket SICP languages are at [https://docs.racket-lang.org/sicp-manual/index.html](https://docs.racket-lang.org/sicp-manual/index.html) .
Docker is a joke security-wise, expect to be owned if you rely on it for that purpose. From the docs: "The default seccomp profile provides a sane default for running containers with seccomp and disables around 44 system calls out of 300+." QED.
I use Chrome on a different virtual machine that I have only for browsing. I communicate with Chrome by having Emacs Lisp use its built-in debugging protocol.
Sure, js sucks, but we're stuck with it. Unless you know something I don't.
This sounds like a challenging project. Will you be archiving your streams so I can catch them on my off hours?
https://common-lisp.net/project/parenscript/tutorial.html
That's really cool, but it compiles to js anyway.
ooooh ok this sounds interesting. Kinda like programming existentialism which... I mean, I'm down for that. Thanks for elaborating.
Please post the video on Youtube for people to watch later.
Well that's kind of the reason for a lisp that compiles to js—so one can create scripts on the web in a decent language.
It's not useful at all for learning how to "build" a Lisp or a compiler though.
Many flavours of Lisp: Zetalisp, Common Lisp, Scheme. Also C and Fortran. Maybe Ada too?
Also Pascal, Prolog.
Short answer: Yes. Longer non-answer: A Lispm expert is sure to correct me soon, but I believe there was no distinct operating system kernel as we understand them today. Rather the entire system is a single blob of Lisp code. Sure, the boot, garbage collector, etc are fundamental parts of the system and could be regarded as the kernel.
Microcode assembler.
Yes, but only *one* Lisp and two assemblers (high level, microcode as /u/larsbrinkhoff) would have been used near the kernel.
I've been using Waterfox since it's the only version of Firefox that retained the old extensions model allowing me to use KeySnail. I'm going to try this out and see how far can it go. Very happy someone is working on something like this.
Thanks for the insight. This action of turning a recursive process into an iterative one is done plenty of times in this section. I'm actually trying to do it in the exercise 1.16, for an exponentiation function. I'm sweating trying to solve this one.
One of the original Lispm hackers, Greenblatt, is interested in making a new one.
That sounds like a *fine* idea, especially if Greenblatt is driving it. :-)
Add a trackpoint to it, and I'd definitely buy it.
Regarding projects to create modern Lisp machines, there is one slow-burning effort by Stanislav Datskovsky aka /u/asciilifeform: [http://www.loper-os.org/](http://www.loper-os.org/) The last thing he was doing is trying to get a micrograph of the Symbolics Ivory chip he has for complete reverse-engineering, but the few labs he contacted either were too expensive or failed to deliver. If you have the equipment and the skills to take a shapshot of the 1um chip, or if you know someone who can, please contact Mr. Datskovsky: [http://webchat.freenode.net/?channels=#trilema&amp;nick=fromloper](http://webchat.freenode.net/?channels=#trilema&amp;nick=fromloper)
That is funny. Where can I find the source? 
Small but fair update. Thanks for all the good work, SBCL people!
7bit at the deskthority.net forum runs some groupbuys for doubleshot keycaps including space cadet legends. He also has such a PCB designed. If you have a lot of patience and DIY skills, you can build a modern keyboard a la Space-Cadet.
QMK firmware allows tonnes of customization/configuration options for keyboards including Unicode output which would tick off Space Cadet features like APL and Greek symbols. This could be achieved pretty easily on a standard sized keyboard using layers. I might be missing what exactly it is you're looking for from a Space Cadet style board though. If you're interested there's a group buy for keycaps designed to replicate the Space Cadet keyboard called SA Symbiosis here: https://kono.store/products/sa-symbiosis-keycaps
Is there a link to any discussion around this?
I keep trying to find bugs to be fixed, but it's becoming harder and harder.
Or the developers are too lazy to describe their changes.
If you mean the keyboard keycaps, there’s SA Symbiosis and 7bit’s round6. The actual keyboard is more complicated; 7bit has proposed a ‘hyper7’ keyboard ([https://deskthority.net/w/images/8/83/HONEYB\_HYPER7\_CADET.png](https://deskthority.net/w/images/8/83/HONEYB_HYPER7_CADET.png)) and the keycaps have been produced and sold, but so far we don’t have a PCB for it ([https://deskthority.net/workshop-f7/hyper7-development-t11344.html](https://deskthority.net/workshop-f7/hyper7-development-t11344.html)). The front legends would have to be done by hand, I fear. I myself got the keycaps I want and I’m in the process of building the keyboard, or understanding how to do it... dealing with shift registers, reading matrices, and then using either ps2 or usb to connect to the computer. I’m probably overcomplicating it a bit, but it has been fun. You can dig some stuff about the original keyboard here, including the microcontroller code: [https://web.archive.org/web/20150112030657/http://home.comcast.net/\~mmcm/kbd/SpaceCadet.html](https://web.archive.org/web/20150112030657/http://home.comcast.net/~mmcm/kbd/SpaceCadet.html); here there is also the code to use it using USB: [https://github.com/MMcM/lmkbd2](https://github.com/MMcM/lmkbd2). Apparently all the keyboard processing was done on the processor, not on the keyboard itself. I wonder if that would give any advantage nowadays...
Lisp... I think it's my favorite. C++ I know better. C# I've done better... Java, I've hated the most... God, and yet most of the work I've done that other people will see is in Multi-user-forth... I guess that the work I've done is either forwards lisp or backwards lisp... Somehow this fact feels like that worse is better essay, which is just kinda... Sad. Maybe one day we'll manage to avoid that trap... It's not that we're powerless, it's that we choose the easy option over the good option... That scares me a lot to be honest. Yet it doesn't bother any of the programmers who I know who managed better than I...
Macos App Store
Cool, but it's an odd target. Lua seems to most frequently be embedded in another project so I'm not sure why you would embed lua and the compile lisp to it rather than embed a small lisp and use it directly. It would be cool to see that breakdown. There is the 'differences from other lisps' section in the readme, but i'd imagine there are lisps that can go toe to toe with lua for perf/memory.. I could be very wrong there though, not my area
Fennel promises seamless interop with Lua, so availability of tools, libraries and bindings due to Lua's popularity is the reason, I guess. It's kind of the same reason why Clojure uses JVM as a runtime.
&gt; Not really a Lisp It doesn't even have a `list` function.
I've been thinking about making a little mod for Minetest, which is scripted in guess what language. If I can do it with something Lispier I'm pretty happy.
To not have to code in a shit language, obviously.
It builds to lua files. So it should be possible but would probably require some fiddling with placing the output correctly.
Odd, sure, but if I were still playing World of Warcraft, I'd be rewriting my custom mods in Fennel instead of Lua. :P
Is that bugging you a lot?
I'm feeling... testy.
&gt; Not really a Lisp since it has taken the retardedly braindamaged Clojure-inspired syntax approach. No, I don’t want to be typing [[ ]] all the fucking time. Good riddance. I think it’s probably all the other arbitrary animosity that cost them here. 😂
I don't know, this cough seems somewhat useful.
No worries - looking forward to the next episode!
Symbols? Nope. Quote? Nope. Stuff this.
To elaborate on what /u/phalp said, it's not odd when you think of it in the context of where and how *Lua* is used. It's an embedded language that is frequently used for extension/modding purposes, especially in games, but is also intentionally lacking a lot of nice features that are common in other languages. Rather than constantly reinventing the wheel whenever you want basic niceties, you can instead compile a better language into Lua and use that. Haven't tried it before but it might be interesting to try using Love2d with one of these compile-to-Lua languages, too. Anyway, my preference for this sort of thing is [Urn](https://urn-lang.com/), which is another batteries-included lisp-to-Lua language. Racket-style interchangeable `( )` and `[ ]`, tables as data literals via `{ }` Clojure-style, and a lot of CL and Clojure inspiration. It compiles Urn files, plus any library functions you use, into a single source file that can be used in-place anywhere you could use a normal .lua file. 
you probably want [Urn](https://urn-lang.com/) instead. Urn is a lisp that compiles to Lua, whereas Fennel is Lua with a lisp.
i can't understand how you think sussman is a poor teacher. have you watched the sicp lectures with him and abelson? yes, in a way, he is the bad cop to abelson's good cop, but sussman challenges the student in a different way. those types of teachers are just as important as the ones like abelson.
The students relationship to the teacher is a personal pone for sure. I just don't think he does a very good job of explaining the concepts. Even in SICP the legwork is really done by the examples. Sussman inspires. His love and interest is infectious, but he does not get his points across in a clear fashion. 
What are the chances of having a "ELS 2018 Call for Videos Posted to YouTube" event? I loved RME's video, but something tells me there's more out there. 
&gt; nd i assume you are watching the lecture videos for sicp along with the book? they are very good. That's how I started :) Thanks for the counterpoint advice, always good to have backup reading.
Great job fixing it to make it more newbie-friendly!
How did you install it?
using: cd /home/nick/Downloads/sbcl-1.4.3-x86-linux-binary/sbcl-1.4.3-x86-linux sudo sh install.sh
Forget about the installed version for a second... does this work: cd /home/nick/Downloads/sbcl-1.4.3-x86-linux-binary/sbcl-1.4.3-x86-linux ./run-sbcl.sh 
&gt;d /home/nick/Downloads/sbcl-1.4.3-x86-linux-binary/sbcl-1.4.3-x86-linux RIGHT? and which sbcl returns /use/local/bin/sbcl
I've used portacle but I'm trying to learn how to use emacs and install packages and everything. Trying to personally customize my emacs.
that does not work: \[nick@localhost sbcl-1.4.3-x86-linux\]$ ./run-sbcl.sh (running SBCL from: .) ./run-sbcl.sh: line 58: /home/nick/Downloads/sbcl-1.4.3-x86-linux-binary/sbcl-1.4.3-x86-linux/src/runtime/sbcl: No such file or directory
Okay, it's possible that it is moved away by the install procedure. If you remove that entire sbcl-1.4.3-x86-linux directory and everything below it and then unpack the tar file again, it should work.
Do you have the environment variable SBCL_HOME set to something and exported? https://sourceforge.net/p/sbcl/sbcl/ci/master/tree/INSTALL
sbcl sometimes have a weird provlem like this. try disabling ASLR by chainging the kernel parameter.
sbcl: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.18, BuildID\[sha1\]=54277afd3409d8af359f78946f6292ff99a51fa4, with debug\_info, not stripped &amp;#x200B; Thats the output from file command
what does that mean?
I'm on a 64 bit system. Reinstalled with 64 bit version, fixed everything, thanks
Awesome GNU/Linux error reporting! It could be slightly worse. I know Hallowe'en is over, but just imagine this: [nick@localhost bin]$ ./sbcl bash: ./sbcl: Error 0x800000FC. Terminated. If this problem persists, contact your vendor. And we're off to endless searching of forums, finding crap like an accepted answer by some MSFT dickhead to run `sfc /scannow` which doesn't do fuck all. 
The `ENOENT/"No such file or directory"` error is probably bubbling up out of the `exec` system call. It doesn't pertain to the `sbcl` file, but possibly to the lack of an interpreter for that file. Just like "hash bang" scripts have interpreters (that they nominate on the `#!` line), binary executables also require an "interpreter", like for example `/lib/i386-linux-gnu/ld-linux.so.2`.
ah, forget it, this will be just 32bit issue. aslr applies to freebsd.
&gt; the error message you got is expected. Expected, perhaps, but also seriously misleading or confusing. I've been burned by this confusing error message on other products lacking one or more 32-bit dynamic libraries. 
Thanks anyway tho!
&gt; Of course in CL, one typically prepends the fn name with the class, No, one doesn't. The generic functions and their names should come first and specify a protocol, and classes should be used to implement parts of the protocol when convenient.
I'd go with `djula:render-template*` to begin with. Compiling the html seems too early optimization. Why do you want to "grab all html and css, all the routes" ? Since you define routes, they'll be visible once you call `clackup`. As for CSRF, I'm pretty sure Clack/Hunchentoot are secured by default, I remember I wanted to bypass them. I would test things with Woo when everything works by default too. Looks like you're trying to do a lot, and forgot to get a minimal case working. Good luck, show us the result !
Dude isn't entirely wrong to be honest, getters/setters are usually class-slot. Sometimes you can see slot-of or just slot as the name.
Isn't ECL (Embeddable Common Lisp) capable of compiling Lisp to C? I've never tried to do that.
The [start page](http://lambdaway.free.fr/lambdaspeech/?view=start) helps explain what's going on. It's a peculiar, lazily evaluated, regular expression-based lisp. Interesting.
SLIME is better than Jupyter notebooks AFAIK You can literally use Jupyter with Common Lisp though: https://github.com/fredokun/cl-jupyter Also I never liked DrRacket, it's really slow and not very interactive.
Thanks! I've tried both of these and they're so far very annoying to set up on Windows (should've mentioned the latter)
If you are trying to get everything running on Windows I recommend [portacle](https://portacle.github.io/) and CCL (last I checked SBCL had threading issues on Windows, but I hope I am wrong atm).
As long as you don't use the Java-y bits of Clojure right off the bat, I don't think you'll miss out on the 'a-ha' moment of Lisp. If you want, you can try to find a Lisp-based tutorial and just do it in Clojure – most differences at that level are nominal (usually quite literally: `defn` instead of `defun`, etc.). You could also use Emacs+Elisp; that environment is still ok to work with on windows.
Alternative interactive tools for CL: - https://hub.docker.com/r/drmeister/cando/ (https://github.com/drmeister/cando) is Jupyter notebook for CL in C++ (CLASP implementation) - cl-repl: https://github.com/koji-kojiro/cl-repl (in development but works and easy to setup) - there's also Lem, a ready to use CL editor with an ncurses and an Electron interface, and the Darkmatter notebook: https://lispcookbook.github.io/cl-cookbook/editor-support.html 
Thanks fo appreciation. As explained at the end of the document, it's an eager - not lazy - evaluation. abstractions (lambdas) are used to bring some laziness, delaying evaluation until the application time. And I should say that {lambda talk) is closer to the lambda-calculus then to Lisp or Scheme which come with a non null set of primitives (cons, car, cdr, ...) and special forms (set!, ...). 
I agree about the nastiness. I want to specify the object before the method in the method call. My current design after some thought is this (def the-dude (new person "I'm not Mr Lebowski, I'm the Dude") (the-dude.abides '(in perpetuity)) 
There are also a couple of projects you might find interesting [Darkmatter](https://github.com/tamamu/darkmatter), and [cl-notebook](https://github.com/inaimathi/cl-notebook), which are in the style of jupyter but implemented in lisp. I always found that Jupyter fell short when compared with Orgmode with Babel, I'm not sure which came first, but if you are into reproducible research or literate programming Orgmode is a very worthwhile thing to learn.
This five minute video should explain how to use it to a satisfactory level for learning Lisp: https://www.youtube.com/watch?v=4_pzxoVDDdg
&gt; easy, interactive programming (a-la Jupyter notebooks) I find it strange that you'd find Lisp environments as "arcane and ancient-feeling" when they're mostly the same thing. It's not that it's a "silly reason", it's more like a completely wrong perception. If anything, Jupyter feels to me severely flawed in how it pretends to be something improved when it really copies the deficiencies of the Lisp environments, for example in how manually re-evaluating portions of code can screw up the consistency of your program's state. Of course, Lisp doesn't generally make the mistake of saving the screwed-up state with your source file, or pretending that it is something that it isn't.
&gt; Also I never liked DrRacket, it's really slow and not very interactive. Personally I'm waiting for the Racket-on-Chez release. But I still wonder if simply using Chez with the new OS layer from the Racket-on-Chez project wouldn't be a better option for a purist.
This isn’t really ready for prime-time. Hopefully an MVP will be working in about a weekend or two, but it’s a barely functioning prototype right now. Don’t get too excited! :)
&gt;Don’t get too excited! Too late. My dream became true -- ML and Lisp on the very same source code.
&gt;I find most Lisp environments I've tried kind of arcane and ancient-feeling Have you tried the combination of Common Lisp, Emacs and SLIME? It *looks* arcane and ancient, but I guarantee you that in terms of programmer productivity, it's as modern as it gets. &gt;and it seems to be easier to use in a familiar, interactive way I would say one of the drawbacks of Clojure is lesser support for interactive programming compared to CL and Smalltalk. &gt;However, I'm a bit wary since it's predominantly functional and based on the JVM. How much would I miss out on regarding the Lisp "a-ha moment"? You wouldn't miss any "a-ha moment" with Clojure since it is also made of s-expressions and supports macros. However it is a significantly different language to (Common) Lisp and Scheme, with a different philosophy, firstly because it is focused on functional programming. 
&gt; If you want, you can try to find a Lisp-based tutorial and just do it in Clojure – most differences at that level are nominal Note that in Lisp, lists can be made recursive and can hold trees easily -- Clojure lists are different. 
&gt; Have you tried the combination of Common Lisp, Emacs and SLIME? It looks arcane and ancient, but I guarantee you that in terms of programmer productivity, it's as modern as it gets. I'm still expecting SLIME to adopt some kind of visual presentations one day. The Lisp process can serve arbitrary data, Emacs can do SVG today...why not have some graphical presentations?
&gt;Of course in CL, one typically prepends the fn name with the class On CL, functions are not necessarily tied to only *one* class. See CLOS.
&gt;Of course in CL, one typically prepends the fn name with the class On CL, methods aren't really tied to one class. See CLOS. 
&gt;Note btw., that the Mac version of LispWorks does not come with the UI builder tool. I noticed, and also some other differences in what is implemented in CAPI in Windows vs macOS. Why isn't the GUI builder not available?
It actually is made with LispWorks, but the widgets are not all native, possibly an HTML view or custom drawn.
Well I have evaluated LispWorks CAPI capabilities. It is indeed nice, but unfortunatelly very lacking to build a modern GUI application. I'm still undecided as I very much love everything else: the IDE, the compiler, the lightness...
let's have a list of every single language who was prototyped in lisp
I like those lists, let's do it :) - Standard ML ? - Haskell ? - Qi &amp; Shen - Julia (its parser in scheme)
It was part of LCF, wasn't it?
Clojure ML and most likely: Scheme Common Lisp Logo possibly Prolog as well 
*Nerd trivia: Not Le_Lisp. Stanford LISP 1.6 running under TOPS-10 (version 6.03A).
I am a nerd and I love trivia. 
An electron interface sounds right up this guy's alley lol
I wonder if js first prototype was in CL .. or maybe haskell
I was trying to convey some exaggerated ignorance when describing these tools as "arcane" and by calling myself a millenial, but perhaps not as clearly as I'd have liked. Yes, undoubtedly emacs is much more versatile than e.g. jupyter notebooks when you want to code in lisp. But my interest is to just learn lisp for fun, and I will maintain that easy interactive environments that don't require reading a short book to use (exaggeration again) are probably better for this type of introductory exercise. That being said I have followed the kind suggestions on this thread and am dabbling in emacs with portacle. It's my first time using keyboard shortcut-based navigation but it's kinda cool
It's more that they require a reasonably different interface which has a learning curve of its own. This can be a turn-off when trying to learn a language. It's like getting people to learn python as a firs language using Vim. 
&gt; Julia (its parser in scheme) Wasn't that Femtolisp or something?
&gt;is just because afaik most Lisps aren't functional Lisp arguably originated functional programming (at least first- class functions-as-values). Many of the bread-n-butter library functions in common lisp are pure, as are the default list-based data structures. That is, they don't tend to mutate the input, returning "new" outputs. You end up using mutable/destructive variants for performance or whatever you consent to (perhaps some algorithms are simpler with side effects, or you'd rather not create a million ephemeral cons cells only to stress the garbage collector when mutating a constant region of memory would do). Like many things, the programmer's taste tends to determine which paradigm or paradigms are used to solve the problem. In CL (and other lisps, which tend to treat users as consenting adults), the programmer is free to blend paradigms or not. From a learning perspective, CL is a great platform for exploring multiple paradigms (FP, imperative, OOP), although you can get similar cross-training in other lisps (like Scheme/Racket, and Clojure). Clojure partially emerged out of challenges encountered in practice with managing concurrency, and the assumption that many-core architectures (along with diminishing returns on single-core) meant a change in the performance landscape. The default Clojure paradigm is functional because pure functions + persistent data plays nicely with concurrency (the aim is to help mitigate heisen-bugs that can occur in such systems, typically due to side-effects). FP turns out to be a great general-purpose default, since the focus on small, composeable functions that don't mutate inputs from afar tends to facilitate reasoning, correctness, and re-use. One of the vaunted programming texts, SICP, refrains from even introducing mutation or state until ch3 of 5, to demonstrate the utility - and added complexity - that side effects bring. Clojure embraces the earlier premise, and also (like SICP and its Scheme dialect) provides practical escape hatches if you decide to opt out. With advances in persistent data structures, and the prevalence of relatively god-like hardware by the standards of even two decades ago, the functional paradigm ends up being surprisingly practical for a wide range of problems where you'd expect to need mutation a-priori, or just default to mutation because that's what you were taught. You can still mutate to your heart's content in Clojure by using various reference types, mutable fields, arrays, host capabilities (going off-heap). Notably, the core libraries use internal optimizations in many places to balance performance with purity, so that there are internal mutations happening behind the façade of an otherwise pure function. Users can freely tap into the same optimizations. &gt; I'm also learning Haskell, so I'd like to explore something different. I wouldn't conflate Haskell with Clojure. Clojure is definitely a lisp, and that includes dynamic language properties, homoiconicity, and metaprogramming facilities. Despite the FP default, the differences in typing are glaring. Clojure's approach focuses on gradual typing via contracts (clojure.spec), or an optional type inference engine (core.typed), plus the host's typing mechanisms, and lots of interactive REPL-driven development. Haskell has a strong, static type system built in with all kinds of higher-minded features, where static correctness is the goal (or requirement). There's some inspiration from Haskell libraries that show up in the generic sequence libraries, but writ-large, Clojure is substantially different from Haskell. A lot of Haskellisms (like monads) haven't found broad popularity in Clojure (although there are dedicated fans with impressive libraries) - or are sufficiently cloaked to keep from driving folks off.
exactly indeed: https://en.wikipedia.org/wiki/Julia_(programming_language)#Implementation
I saw it referenced in the Milner paper, but didn't know it was available! Cool!
Cool! I've got a few questions but no worries if it's too early in the project to answer them. * Are you looking into generating type declarations in the generated lisp code to further aid in optimization? If you are, are there any interesting approaches to this you have considered * Given a function A that uses function B, how are you thinking of handling cases where a change to B changes it's return type. On would expect that A would need to be (at least) re-checked. * If compiling a single toplevel form may trigger the recompilation of several others (as in the above case or perhaps monomorphization of some other function) have you had any thoughts on how to fixup the function location info (for tooling). Other than that I just wanted to say that this looks really promising! Your work has always been very inspiring and from looking at your notes and comments it seems like this is on a really cool track.
Cool! I've got a few questions but no worries if it's too early in the project to answer them. * Are you looking into generating type declarations in the generated lisp code to further aid in optimization? If you are, are there any interesting approaches to this you have considered * Given a function A that uses function B, how are you thinking of handling cases where a change to B changes it's return type. On would expect that A would need to be (at least) re-checked. * If compiling a single toplevel form may trigger the recompilation of several others (as in the above case or perhaps monomorphization of some other function) have you had any thoughts on how to fixup the function location info (for tooling). Other than that I just wanted to say that this looks really promising! Your work has always been very inspiring and from looking at your notes and comments it seems like this is on a really cool track.
Not Le_lisp, but some lisp on VAX. Though, OCaml (caml back in the days) was implemented on top of Le_Lisp VM initially, and still bears some lisp legacy in its intermediate representation: ocamlopt -dlambda fib.ml (letrec (fib/1002 (function n/1003 (if (isout 1 n/1003) (if (&gt; n/1003 1) (+ (apply fib/1002 (- n/1003 1)) (apply fib/1002 (- n/1003 1))) (raise (makeblock 0 (global Match_failure/18g) [0: "fib.ml" 1 14]))) 1))) (makeblock 0 fib/1002))
&gt; and most likely: Scheme Scheme first implementation was in MIT LISP. See AIM-349.
Believe it or not, SLIME has a crude version of CLIM presentations built-in. If you right-click on something printed as a return value by the REPL, you can do various things with it that make it quite plain that colored REPL return values are memory references, not just plain text. For example: ``` CL-USER&gt; (make-foo) #S(FOO :X NIL :Y NIL) ;; Right click on this and choose "Copy to REPL" CL-USER&gt; (defparameter *test* #S(FOO :X NIL :Y NIL)) *TEST* CL-USER&gt; (setf (slot-value #S(FOO :X NIL :Y NIL) 'x) :changed) ;; Copy to REPL again, from the same place. :CHANGED CL-USER&gt; *test* #S(FOO :X :CHANGED :Y NIL) ``` That right-click menu also has an inspector. You can copy the presentation to a file and it'll remain a presentation (when it stops being a presentation, the color changes). But for some reason they chose to use weak references, so sometimes the objects behind the presentations get GC'd out from under you. 
If you want to see something truly arcane, play around with the Lisp dialect that is built into Emacs. `M-x ielm` for a REPL. Most of the editor's functionality is implemented in this language. 
The author has many interesting Lisp projects. To name a few: - https://github.com/fisxoj/postmodern-passenger-pigeon migrations for postgre - several Clack middlewares https://github.com/fisxoj/clack-middleware-compression - https://github.com/fisxoj/map "octave-like" functionnality
Thanks for saying my things are interesting! I have some time between jobs at the moment, which means I get to finally pick up lisp things I've been neglecting. I'd appreciate feedback on what would make these more useful to others too.
try PicoLisp.
Oh neat! I thought at first you were joking (pico editor) but went to the website and it has a ton of features! I like the neat ability to use the JVM and C libraries, too. 
6pm UTC happens when this comment is 1 hour and 37 minutes old. You can find the live countdown here: https://countle.com/69LZbBk4f --- I'm a bot, if you want to send feedback, please comment below or send a PM.
&gt; And of **curse** Macros Sometimes a typo is funnier than expected. Please don't fix it.
oh, that's you^^ They are, I'm especially interested into the Clack middlewares and the documentation builder. But it's new so I don't see what it brings yet. But honestly I don't see the interest of these images compared to say https://github.com/daewok/lisp-devel-docker which brings Quicklisp, its libraries, and all the system dependencies needed to build them. Looking forward from your next Lisp ideas : )
Thanks for that link.
Maybe my subconscious is betraying me (lol)! 
&gt; Haskell ? [Carp](https://github.com/carp-lang/Carp)...kinda, sorta, maybe?
As much as I like Common Lisp, I would have to say Clojure. Once you start building stuff, you will need a community, and Clojure has a very helpful community. Plus, great functional programming support, of course.
You might want to look at Clojure and the Seesaw library (a wrapper for Java Swing) if you are targeting the JVM
Thank you for the suggestion. Sadly, I am not wild about Clojure and strongly prefer Common Lisp.
And extremely good integration with java means it's easier to get job with or integrate in company projects.
&gt; - Uniform and simple syntax ...until you start messing around with reader macros.
Agreed, and "integrate in company projects" is a very good point. It also makes it easier to convince the team to start using Clojure, or at least trying it out!
Note that it relies a lot on custom assembly code (the LAP - lisp assembly program) files. 
&gt; curse Macros No, no, don't curse at them, they are good!! 
&gt;Does anybody know if ABCL is still an active project? ABCL is still active, of course.. &gt;JRE 1.11? Not sure if I follow. Do you mean "Java Runtime Environment (64bit) 8 Update 111"? 
Thank you for that awesome feedback! I was initially looking at Clojure because JVM (having monkeyed with other JVM languages and having those libraries available is great). I will look into Common Lisp. My goal for posting this was to get the help if you experienced LISP programmers, so I wasn't fixated on something that caught my attention without the perspective of experience programming in LISP. I appreciate your verbose and thoughtful reply! 
&gt; Do you mean "Java Runtime Environment (64bit) 8 Update 111"? I'm not sure. It looks like the current version of Java is [**1.11**](https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html) -- and ABCL's documentation suggests that it requires 1.8.
He most likely means JDK 11. JDK 12 is the next upcoming version.
It should (almost certainly) work without any problems, especially if ABCL works with Java 8. If you run into any issues, I'd be glad to help out - a decade of Java has to be useful somewhere! :D
&gt;getting a nice GUI for CL Note that for GUIs there are other alternatives. Listing only the free ones I can remember: Multi-platform: - Qt through EQL, qtools and others - Tcl/tk through LTK - Gtk Only for X11: - McCLIM, *the stuff boring dreams are made of* 
ABCL is alive and well. I especially like using it for mixing deeplearning4j with Common Lisp code. I don’t know how the core dev team feels about asking for tips, but Patreon style tipping is a good way to let developers know that you like what they are doing. Rich asked for contributions when we was first rolling out Clojure and I and many other people were happy to support something we believed in.
Holy smokes! That's impressive! I appreciate all the real examples!
&gt; The broadcaster indicated that the channel is intended for mature audiences. I'm scared
&gt; Scheme doesn't have any iteration structures [First Google hit](https://www.gnu.org/software/guile/manual/html_node/while-do.html) for "scheme do loop" *Scheme has only few iteration mechanisms, mainly because iteration in Scheme programs is normally expressed using recursion. Nevertheless, R5RS defines a construct for programming loops, calling do. In addition, Guile has an explicit looping syntax called while.*
Lisp questions asked in Reddit, StackOverflow, comp.lang.lisp or IRC channels and whatnot get answered, just like, I am sure, Clojure questions. I've never needed a community when I had documented code that worked. Failing that, for which the source code was available and half decent. If the cruft is documented, and does what it says on the box, you're in good shape, unless you're the type whose understanding is so poor that you need to be spoon-fed complete solutions. Remember, we had complex software before Internet forums. We had libraries and tools, and some very good ones. People somehow did amazing work, unimpeded by the fact that they couldn't switch to a browser and start googling upon hitting every tiny stumbling block. 
Q.E.D.
If you're interested into Common Lisp, I like those resources: https://github.com/CodyReichert/awesome-cl for a beginner-friendly list of libraries, and the https://lispcookbook.github.io/cl-cookbook/
https://Common-Lisp.net 
That Guile documentation doesn't seem to be telling the truth; I cannot find this *do* construct in R5RS or R6RS. (Maybe a SRFI?) 
*do* isn't a macro; R5RS Scheme describes it as a kind of expression. The symbol is among the "expression keywords" in its grammar. Scheme cruft approximating the concept of a "special form" in Lisp.
&gt;(define $Γ~__ (with-symbols {i} (. g~#~i Γ_i_#_#))) Looks like line noise. Are `g~#~i` and `Γ_i_#_#` the names of variables, or is the compiler picking those apart and doing things that would give Cthulhu nightmares?
By the way there is a very well documented, elegant wrapper for Swing under ABCL: https://common-lisp.net/project/snow/
Thank you!
&gt;(define $Γ~__ (with-symbols {i} (. g~#~i Γ_i_#_#))) how about... `(with-line-noise (d $Γ~__ ($$ {i} (. g~#~i Γ_i_#_#))) )` ?? Much better, I think. 
&gt;I was initially looking at Clojure because JVM (having monkeyed with other JVM languages and having those libraries available is great). You can easily call these libraries by using ABCL, an implementation of Common Lisp that runs on the JVM. On the other hand, there are *many* CL libraries out there. The java ecosystem is much bigger, of course, but there's a chance you might find everything you need in the CL ecosystem.
copypasting the intro from the README: --- # magrathea: chaotic-neutral web security for Hunchentoot - Bored of people scanning your website for vulnerabilities for have? - Want to do something about skiddies? - Hate scrapers? Magrathea is just for you! It uses state of the art [zip bombs](https://en.wikipedia.org/wiki/Zip_bomb), with zero configuration required for normal use. --- anyways the general principle is that you maintain a list of regexps for sketchy paths and/or functions which detect them, and if one IP loads too many of those paths too quickly, Magrathea triggers and zip bombs the scraper. this is my first really-CLOS project, but the hunchentoot docs were quite clear about subclassing acceptors and it worked on my machine^(tm).
This is most excellent, and pleasant to read. Just 1 typo: irrelevent → irrelev**a**nt
Did you forget to upload to YouTube this week? Sorry if you are just busy. &amp;#x200B; I need my hit, man
Use *print-case*.
Well, maybe if you would just STOP TALKING NONSENSE
/u/flaming_bird is correct about the use of case to make it clear what is REPL input and what is REPL output. Remember, Lisp goes clear back to the days of Teletype interactivity - just letters on a roll of newsprint. The only reasonable way to make output look different from input was to have user input be lower-case, and Lisp output be UPPER-CASE. Really, you get used to it with exposure. But... If you just want Common Lisp to not shout at you, [\*print-case\*](http://clhs.lisp.se/Body/v_pr_cas.htm) is the setting you want. Put `(setq *print-case* :downcase)` in your Lisp's init file. Eventually you will want to know stuff like what the reader does with case, and how to control it, and the difference between symbols and strings; this should be enough to get you started without feeling shouted at. &amp;#x200B;
How can I make it invert case on the way in, and on the way out? So that I can type built-in CL symbols in lowercase but the system will see them in uppercase, and I’ll see them in lower again when they print. And, there will still be the possibility of care-sensitivity for symbols which have to interoperate with the outside world..
You can buy Allegro CL. ;)
Make your lisp happy by using `enable-happy-lisp`: (defun enable-happy-lisp () (setf *print-case* :downcase) (format t "~{~80:@&lt;~A~&gt;~%~}" '("Happy, happy!!" "Lisp is SO happy now!!"))) 
&gt; How can I make it invert case on the way in, and on the way out? So that I can type built-in CL symbols in lowercase but the system will see them in uppercase The system will work exactly as you want with bobbane's suggestion. Print-case only controls how the case is displayed. Internally it is still case-insensitive, which is what you want. 
I don't think just setting *print-case* to :upcase quite achieves everything I was referring to. I still want case-sensitivity, e.g. for when symbols are printed for consumption by the outside world. 
on CL, by default, symbols are read case-insensitively, unless you escape them with `|` characters. *print-case* can be set locally at runtime too, by using `let` 
&gt; LISP is more of a build your own library adventure as you have said. There are ML libs for Common Lisp too.
&gt; so much capital letters coming out of lisp that I'm a little confused of what's happening First step towards deconfusion about what's *coming out* of the Lisp (née LISP) is to explore what's *inside* in the first place. That's what `SYMBOL-NAME` was made for: &gt; (symbol-name 'defun) "DEFUN" &gt;(symbol-name 'let) "LET" It's just telling the truth! Well, shouting it... 
Symbols are upcased to all caps by default when being read. In fact, the names of all the functions in the CL package and CL-USER have this. There is a way be able to use capitalization and other characters in symbols. You have to enter them between vertical bars as in '|foo| which is the symbol of lowercase foo. To demonstrate that the builtin functions are captitalized, you can try running (apply #'|list| 1 3) and see that CL will complain that there is no function with the name in the CL-USER package. Common Lisp is not the only programming language where a lot of stuff is in all caps (though the language may hide it from the user or be case insensitive and allow lower case versions of things to be used). Fortran is another example. Well, to be more accurate, FORTRAN (which is actually the acronym FORmula TRANslation). Standard FORTRAN used to require that a lot of things be in all caps, but pretty much all compilers were forgiving and let one use lower case. It wasn't until a recent standard (I think it was Fortran 90) that such an allowance was entered into the standard, if I remember correctly.
Thankyou.
yes, that makes sense - lisp has its long history. I'll try that \*print-case\* setting, thanks for advice!
Actually, Lisp goes back to an era where computers had no lower case. Everything was upper case. Later, when computers started having two cases, a lot of existing systems became case insignificant. This includes Fortran and Cobol. Later languages which where designed after lower case was common simply became case significant since that is simpler and more consistent. Common Lisp attempted to merge theses two concepts by making the language case insignificant but having the reader convert lower case to upper case so that old code would still work. The could have defined the system to use lower case internally and have the reader convert to lower case, but that's not what they chose, which is why symbols are printed in upper case. Lisp programmers have become used to this and usually write symbols in upper case in emails for example. 
Gotcha. Fixed.
Definitely the place where I work, and we are certainly hiring. 
Thank you for all the material you have been sharing on https://www.nicklevine.org/ I re-read some of them quite frequently, I appreciate the style and the depth. Thank you.
:-)
&gt;Definitely the place where I work, and we are certainly hiring. I was interested, but I understood it required relocation to Marbella, Spain. And on the other hand, i don't have 5 years of CL experience. Hope you find the right person.
We much prefer relocation, though remote work is negotiable under certain circumstances. Get in contact and we can talk.
&gt;Get in contact and we can talk. PM sent, thanks!
I prefer good old ASCII, in most cases even only monochrome. But diversity is a good thing. I'm curious to see what's coming next in your experiments.
I don't believe anything that creates a large number of lines or boxes on the screen can really work out. Parens are nice because they nest but don't themselves have a big visual footprint. If there's a path which doesn't dead-end too soon, it's *selectively* applying multiple visual aids to bring out the structure without creating visual chaos.
parens are visual clutter? expressions have to be bounded in some way. is attention drawn to lisp's expression boundaries just because the closing boundaries mostly occur contiguously? i bet the 'parens are visual clutter' feeling comes mostly from people that either: - don't use a text editor that highlights the complementary paren when the cursor is on a paren. - haven't used lisp for more than like a dozen hours or so
Am I missing something, or is the only problem with the second version that two adjacent child expressions of the same parent are assigned the same color, and are thus not distinguished as separate expressions without parentheses? Because if so, you could fix that by using a different color for each contained child expression (instead of the seemingly more complicated solution the author proposes).
Thanks for all the answers in this thread. This is something that throws me off a little, but I know that Lisp means no harm :) 
!remindme 5 days
I'm all for defence but your counter-attacking "defence" is foolish and could be construed as an attack and therefore illegal. It's especially problematic for false positives.
Not even elevated to r/programming. Lisp is important , the way Haskell is important; nice ideas, but everyone writes in other languages . &amp;#x200B; (Small gods)? &amp;#x200B;
IS LISP ANGRY? IS LISP ANGERY?!?!?!! AS A YOUNG LANGUAGE LISP WAS TEASED FOR ITS HOMOICONICITY AND ITH THPECIAL ETHTH EXPRETHION THYNTAX. LISP WAS TOLD IT WAS SLOW AND EVEN TEASED FOR ITS GARBAGE COLLECTION1!! LISP DID EVERYTHING FIRST! EVERY LANGUAGE MUST ACKNOWLEDGE LISPS SUPERIORITY!! IS LISP ANGEREY!?!!? LISP WAS BETRAYED BY A SERIES OF CORPORATIONS AND GOVERNMENTS WHO FUNDED MUCH OF ITS DEVELOPMENT, FOR REASONS STILL OBSCURE!! THEN LISP WAS ABANDONED BY ACADEMICS WHO PREVIOUSLY ADORED IT! IS LISP ANGEREY!?!!? DESPITE MODERN PEOPLE MAKING PILES OF MONEY ON SECRET LISP PROJECTS, AND MODERN PUNDITS TOUTING LISPS QUITE OBVIOUS SUPERIORITY, THE ONCE BEAUTEOUSLY ASCENDANT LISP LANDSCAPE STILL LIES IN RUIN, LIKE VAST ANCIENT ELVEN CITIES, CRUMBLING, SURROUNDED BY THOUSANDS OF RECENTLY BUILT AND QUICKLY ABANDONED HOVELS AND LEAN-TOS AND A FEW TUMBLEWEED TOWNS, INHABITED BY ONLY THE MOST REBELLIOUS, IDEALISTIC, TENACIOUS, OR FOOLISH WIZARDS AND SORCERESSES, BUT CONSTANTLY FREQUENTED BY MANY GAWKING TOURISTS. IS LISP ANGRY???? LISP HAS EVEN HAD TO ENDURE THE SAGA OF POOR LITTLE DYLAN, WHO WAS TO BE ITS SUCCESSOR, FILLED WITH PROMISE OF WISDOM, YOUTHFUL STRENGTH, AND BEAUTY, BUT SEDUCED BY THE LIKES OF JAVA, AND BEFUDDLED AND TRICKED BY MORE CORPORATE GREED, FELL TO THE HERESY OF INFIX, AND WENT ON TO LANGUISH IN OBSCURITY. BUT IS LISP EVEN ANGRY!?!!? SO MANY PEOPLE SEEM TO TALK ABOUT HOW GREAT LISP IS, BUT DOES ANYONE HAVE THE TIME, ENERGY, WISDOM, RESOURCES, AND ABILITY TO COOPERATE ENOUGH TO BUILD A NEW LISP WORLD?!?!? OR EVEN JUST SLOWLY FORM A NEW CIVILIZATION??!?? AND YOU ASK IS LISP ANGERY??!? WAIT.. AM I SHOUTING?? (DOES THIS SOUND LOUD TO YOU GUYS?? (THIS IS JUST MY NORMAL VOICE.)) Oh. Um.. Actually, scratch that. Lisp is really pretty chill. I had just somehow done `stty olcuc` and was typing on a TeleType. 
&gt;In the end we still got very nice improvement, from 3.767s down to 0.243s. Yes you did!! It would be interesting to compare what you did, with a simple (loop) that does everything and uses type declarations (loop also allows type declarations). 
\&gt; Next one is [Common Lisp](https://en.wikipedia.org/wiki/Common_Lisp) which started almost 10 years later - in 1984. Common Lisp is a modernized version of Maclisp and especially another Maclisp successor: Lisp Machine Lisp. &amp;#x200B; "Common Lisp the Language" (the original reference) says: Common Lisp originated in an attempt to focus the work of several implementation groups, each of which was constructing successor implementations of MacLisp for different computers. As such it is in direct line of heritage with the original Lisp and largely compatible. Scheme is a new dialect, but it was first developed on top of Maclisp and it shines through. Clojure OTOH is a fully incompatible with any earlier Lisp. No code can be easily ported and most of the time it would make no sense, since the language is so different. &amp;#x200B; &amp;#x200B;
Instead of using a series of declare forms you can just wrap all the arguments into one call. So (declare (type fixnum var) (optimize (speed 3))
Thank you for sharing! I'd like to know more about your reasons to choose Common Lisp instead of Racket
You could peek inside the 'loop'-clause by macroexpand-1ing it: (macroexpand-1 '(loop for n from 1 below x by 1 when (d n) sum n)) (BLOCK NIL (LET ((N 1) (#:LOOP-LIMIT-733 X)) (DECLARE (TYPE (AND NUMBER REAL) #:LOOP-LIMIT-733) (TYPE (AND REAL NUMBER) N)) (SB-LOOP::WITH-SUM-COUNT #S(SB-LOOP::LOOP-COLLECTOR :NAME NIL :CLASS SB-LOOP::SUM :HISTORY (SB-LOOP::SUM) :TEMPVARS (#:LOOP-SUM-734) :SPECIFIED-TYPE NIL :DTYPE NUMBER :DATA NIL) (TAGBODY SB-LOOP::NEXT-LOOP (WHEN (&gt;= N #:LOOP-LIMIT-733) (GO SB-LOOP::END-LOOP)) (IF (D N) (SETQ #:LOOP-SUM-734 (+ #:LOOP-SUM-734 N))) (SB-LOOP::LOOP-DESETQ N (1+ N)) (GO SB-LOOP::NEXT-LOOP) SB-LOOP::END-LOOP (RETURN-FROM NIL #:LOOP-SUM-734))))) which is interesting to read, I think. Given the fact that 'do' expands into 'tagbody-go' as well, one might get the impression, constructing highly optimized loops would be much easier, using tagbody-go directly. 
what does that have to do with someone learning common lisp? 
Nothing. It is a joke. Lispers like jokes (look up `kludges` on CLtL index for example)
This is mind-blowing! D: 
Goto the dark side, Luke!
And I'd like to know more about your perspective on Racket over(?) CL! Only heard of it from afar.
It's similar in purpose to a honeypot, and with disclaimer I find it hard to believe it's illegal. 
LISP CONVERTS SYMBOL NAMES TO UPPERCASE BY DEFAULT.
you can also combine this with PPRINT
Both honeypots and zip bombs are there to confuse the attacker. I don't have references, but all the people I asked said it should be legal to deploy such a countermeasure if the disclaimer has been made.
Or maybe it's just useful to occassionally challenge the status quo even if you end up deciding that the status quo is right? Which, given the way is his post is going, is where I expect he will end up.
that's fair. i just wanted to note that just because you notice something, namely ")))))))," doesn't mean it is a problem. 
All of this is true, but I assume that most potential reader aren't that interested in history. And if they are it should be possible to get to that information via links I've provided.
&gt; first-class functions (functions that can take functions as arguments) That's functions *that can be used as values*. In other words, in the "functions that can take functions as arguments", they're the latter functions, not the former ones. &gt; it’s interpreted It's not, overwhelmingly.
I think the biggest reason for choosing CL was how natural it seems to be to work in interactive way with CL. It seems you can redefine almost anything in runtime in CL and there are built in facilities that make it sane to work this way. It reminds me of what I read about Lisp Machines (and Smalltalk). Not to mention high quality implementation (SBCL) available for my system.
I'm just starting to learn Lisp too and trying to choose. From the beginner point of view, Racket stands for the easier IDE, being more friendly to functional style, easier modularity and some elegance either conceptual and with naming things, while retaining powerful but hard to learn metaprograming capabilities. The strong points of Common Lisp, for me - the interactive approach to programming and the way easier [than Racket's] macro system - doesn't make much difference in this point of the road, but I firmly suspect they will be game changing as I advance. So, I'm more inclined to resist the temptations of the "more modern, elegant and functional" Racket and take the "baroque but powerful" Common Lisp route. 
Ah, so nothing today… How about some nice OpenGL fireworks in CEPL for the final stream this year? ;)
Is there a getting-started guide for lem? I don't know many emacs keystrokes, and `M-x help` did not work.
Thanks for the first-class functions clarification!
 CL-USER&gt; (pprint (macroexpand-1 '(loop for n from 1 below x by 1 when (d n) sum n))) &amp;#x200B; (BLOCK NIL (LET ((N 1) (#:LOOP-LIMIT-501 X)) (DECLARE (TYPE (AND NUMBER REAL) #:LOOP-LIMIT-501) (TYPE (AND REAL NUMBER) N)) (SB-LOOP::WITH-SUM-COUNT #S(SB-LOOP::LOOP-COLLECTOR :NAME NIL :CLASS SB-LOOP::SUM :HISTORY (SB-LOOP::SUM) :TEMPVARS (#:LOOP-SUM-502) :SPECIFIED-TYPE NIL :DTYPE NUMBER :DATA NIL) (TAGBODY SB-LOOP::NEXT-LOOP (WHEN (&gt;= N #:LOOP-LIMIT-501) (GO SB-LOOP::END-LOOP)) (IF (D N) (SETQ #:LOOP-SUM-502 (+ #:LOOP-SUM-502 N))) (SB-LOOP::LOOP-DESETQ N (1+ N)) (GO SB-LOOP::NEXT-LOOP) SB-LOOP::END-LOOP (RETURN-FROM NIL #:LOOP-SUM-502))))) &amp;#x200B;
Heresy !
If you learn a few of the basic Emacs keybindings, you'll be able to get around fine in Lem.
"So to me, programming hasn't changed much in 50 years because, they got locked into this strange set of limitations"
You may be interested in this post: [Five Approaches to SEXP highlighting](http://lemonodor.com/archives/001207.html) . Those people mentioned might give you ideas and/or source code
He's talking about macros but that nobody "does that yet"? Did he mean something else?
elisp does its job well enough
OT: I met Minsky once about 25 years ago at an AI conference in Phoenix. True to his pictures he was wearing a turtle neck. I don’t remember much more, unfortunately.
Wow, that looks like almost like a human wrote it, except for the all caps. Impressive!
and you can configure it to print it without all-caps too. 
Just guessing but maybe the jagged window edge that indicates content not shown on screen? http://ssw.jku.at/General/Staff/PF/split-screen.gif http://ssw.jku.at/General/Staff/PF/listener-zmacs.gif 
He means that languages other than lisp don’t have the powerful macros lisp has. A few languages do come close, but they’re not as integrated into the language like lisp.
LISP macros and C macros don't work the same way because C isn't homoiconic. More info here https://letoverlambda.com/index.cl/guest/chap1.html#sec_1
What other languages come close? Of the top of my head I struggle to remember any languages with macro support besides Common-Lisp, Clojure and Scheme. I dearly miss macros whenever I have to mess around with state machines and parsing.
Rust has quite powerful macros which can match on syntax elements, but it's far from being as powerful as Lisp macros. I remember some contexts that made making Rust macros harder, because they still have much of the statement/expression distinction baggage as well as special syntax elements.
You're in luck! /u/baggers_ just put out a video that introduces one of the killer features https://www.reddit.com/r/Common_Lisp/comments/9wdk2r/lots_of_bits_of_lisp_macros_2_hr_episode/
A common approach in Common Lisp programming is that you first create a language suited for the problem and then write your solution in it. Of course, usually this is an iterative process, rather than sequential. To get a feel for this approach, watch the *old but gold* screencast from Rainer Joswig (20min): https://www.youtube.com/watch?v=5FlHq_iiDW0 (Thanks Zach for putting this on youtube) 
http://flownet.com/ron/lisp/djbec.lisp Scroll down to the function xpt-add and note the embedded infix syntax and the MODP macro which makes all the arithmetic inside it modular. Also: http://www.flownet.com/ron/lambda-calculus.html https://github.com/rongarret/tweetnacl/blob/master/ratchet.lisp 
So by analogy, when you code in C, it gets lexed and parsed, and transformed into an AST. This then gets transformed by the compiler and the executable is born. In Lisp, you ARE writing in AST, albeit in a serialized form. There is no distinction between the code, the program, and the data. The code IS data that you can write code to transform, and this can happen at runtime. You can't do this in C. Your code can generate code at runtime, compile it, and run that, and this is NORMAL for Lisp. It also makes DSLs trivial.
 * metaprogramming: * macro: * input: AST * output: AST * compile time manipulation * Turing complete * example: new language construction (e.g. missing the **with** construction just add it) * reader macro: * input: character sequence * output: AST * read time manipulation * Turing complete * example: new syntax (e.g. missing the indentation sensitive syntax just add it) * object system (CLOS): * being able to synchronize representations of a type (formal (class) and actual (instance)) (resolves circle-ellipse problem) * generic functions -- multiple dispatch * multiple inheritance * method combination (resolves multiple inheritance problems) * MOP (for more crazy stuff) 
Here are some things that will be extremely tedious to do in languages without macros, and every time you want to redo the operation, you'll have to redo the tedious steps. 1. Try and create a \`log\` "function" that prints both the expression and the result's value without writing the expression twice. ([https://pkgs.racket-lang.org/package/logger](https://pkgs.racket-lang.org/package/logger)) 2. Rewrite \`(x h g f)\` to \`(f (g (h x)))\` as as seen in the threading library [https://pkgs.racket-lang.org/package/threading](https://pkgs.racket-lang.org/package/threading), this is also much used in clojure using \`-&gt;\`. 3. Make your own pattern matcher. 4. Memoize any function by just changing \`define\` into \`define/memoize\` ([https://pkgs.racket-lang.org/package/memoize](https://pkgs.racket-lang.org/package/memoize) or [https://pkgs.racket-lang.org/package/memo](https://pkgs.racket-lang.org/package/memo)) 5. Create your own control structure. (e.g. [https://pkgs.racket-lang.org/package/spipe](https://pkgs.racket-lang.org/package/spipe)) The zen of lisp comes once you realize that the code you normally write is just you being a macro processor, and that lisp allows you to implement that processor so you don't have to do the work. &amp;#x200B; Language is the ultimate abstraction.
With C, C++, and basically all other languages you're one level up the abstraction stack so to speak, with assembly being our "level 0". There's the C compiler giving you one level of abstraction using the C language, and then C has a macro system (which is really limited), so one could say C is on level 2 of the "abstraction stack". &amp;#x200B; With lisp you're on level N.
Ooh... That's a good one.
that was a typo, thx.
data, data, data you can compute nearly everything it doesn't matter the language level, you can implement it tree recursion is your first bestest of friends, and induction solving process is the second one
Yea, I saw something about that on this sub
I am too. These comments still tells me that lisp (I mean common lisp) as a standard has not evolved from the days of teletype and stuff and that is sad! Sad, because I really like lisp as a language in general, but I think it needs a serious update to keep it alive and interesting. 
Other folks have mentioned the "killer" feature of Lisp: meta-programming but part of why you might be finding Lisp underwhelming is that many "newer" languages have incorporated many Lisp features. In fact, Peter Norvig claims Python as a Lisp. RE: the wizard book. I think this book is more about how to think about programming, i.e., to develop the discipline required to bring good structure to your code. For instance, the first two chapters are totally functional--no assignment operations take place in the code. This is remarkable for a book introducing programming (well, there are no stated pre-requisites). The main course is grokking the `eval` and `apply` functions at the heart of a Scheme interpreter--pretty nice for an introductory book! If you are interested in Lisp programming, you might want to check out Clojure: it is a Lisp and has very nice syntax for literals. It also has a very lively development community, especially when it comes to front-end technologies. (Yes, Common Lisp has a rich enough set of libraries to do just about anything. And there is no question that Common Lisp is the most complete language. I can only think of Smalltalk as an alternative when it comes to how comprehensive Common Lisp is). Good luck!
someone else pointed out that M-x will tab-complete. vim-mode was *not* an option when I installed with roswell yesterday though.
&gt; I'm a computer science PhD student. did you see https://lispcookbook.github.io/cl-cookbook/arrays.html and https://lispcookbook.github.io/cl-cookbook/numbers.html ? Hope it helps, it was contributed this year by another scientist. &gt; things way easier compared to other languages like Python I find that python's meta-programming concepts like decorators and with- statements are peculiar and limited. They follow their own rules, they are hardly extendable. You must learn how to create a decorator or the methods that make context managers to implement your owns. And yet they're limited, you can't do anything you want inside a context manager. All these would be written with regular macros in Lisp (and they are, see cl-annot for decorators). I wouldn't say it is way easier to write your own macros, but it's way easier to refactor your code how you like. (and in the end, we're like writing only functions indeed) 
"On Lisp", Paul Graham
Practical Common Lisp is cool. I'm very interested in Common Lisp, but when I wanted to know some features of Common Lsip, it is hard for me to find it out, and it always made me frustrated. I used macro once, and it really attract me. When I write some repeat code with Python, sometimes I will wonder if can I make it in Common Lisp.
This was amazing. 
If'n you don't like the looks of 'loop' you can always try [Iterate](https://common-lisp.net/project/iterate/) instead. ;-)
Grab the [Hyperspec](http://www.lispworks.com/documentation/HyperSpec/Front/) to look up details on Common Lisp functions and concepts.
 That's a great place. Thank you :)
Thank **you** for carrying the torch of un-humorlessness.
It *is* just normal function defining. The magic comes in beforehand, by having function defining be nearly the only syntax, and unlike other functions-are-the-only-syntax languages, such as Forth or PostScript, the parens make it so you don't have to do everything backwards and keep a stack in your head. Functions as the only thing, is like the way the subtle universe works, which makes everything work out relatively splendidly.
Great explanation!
Also in Julia one can manipulate the AST to write macros. Crystal advertises nice macros.
&gt; when I wanted to know some features of Common Lsip, it is hard for me to find it out, and it always made me frustrated. + 1. I want to fix this in the Cookbook, come join :) https://github.com/LispCookbook/cl-cookbook/
Amazing! I'd love to join it :)
Written a _long_ time ago. The context, as best I can recall, was that Lisp was being taught at MIT on a PDP-11/45 (originally running the Delphi operating system, if I remember, and later Unix). MIT's EE&amp;CS folks were wanting to move to something more powerful. I believe the course number was 6.031, as it was not yet 6.001. I had only recently finished the course myself, but I used to do my homework on a PDP-10, where I'd written an emulator of their Lisp in the local Lisp in order to do my problem sets without leaving my office across the street. Someone heard there was a possibly-suitable Lisp on the 10 and asked me about using it. The Lisp on the PDP-11 was not the sort of Lisp you'd want to perpetuate though, and I volunteered to make something clean and pretty for class use. Not for pay even, I don't think. Just because it seemed fun. The "U" in "ULisp" refers to "unix", since it had originally been inspired by a lisp that ran there. And this is how ULisp (no relation to [EuLisp](https://en.wikipedia.org/wiki/EuLisp)) arose. The result was used for one semester for teaching at MIT. But Sussman kept pestering me about tail calling and I kept saying "but won't that make stack debugging hard?" He and I were normally on friendly terms, I think, but he was not at all happy about this detail. In light of history of [SICP](https://mitpress.mit.edu/books/structure-and-interpretation-computer-programs-second-edition), it's easy to see why. But at the time, in context, I was being dense and didn't quite get the focus of what he wanted to do with his curriculum and why he was so obsessed with tail calling, which seemed to me such a detail. :) The next semester, as I recall, they switched to Scheme for the class, and ULisp was quickly forgotten. I wasn't bothered, but at a friendly intellectual level I perceived it as a furious rejection of my Lisp. More likely it was a planned move all along. I certainly did not expect this Lisp to function as anything more than a stopgap. But I did design this Lisp dialect to have some interesting characteristics. The way macros and special forms are integrated are different than other Lisps, as I recall, and probably rely critically on the way this Lisp is an interpreted-only Lisp. I just wanted people to be able to get the idea of what macros do. And, of course, this requires [Maclisp](https://en.wikipedia.org/wiki/Maclisp) to run. So you'd need a PDP-10 emulator in order to even try this. There is a manual for this dialect that I have at least in hardcopy. I'll see if I can find it. It was written in the same style as my [revised maclisp manual](http://www.maclisp.info/pitmanual/), in a plaintext notation that compiled down to [TeX](https://en.wikipedia.org/wiki/TeX) as a backend. (There's a companion story about the text editor that went with this that ends in an equal fury elsewhere. I'll add that story later when I have more time. Someone please remind me if I forget after a week.)
I find Series even more impressive than `loop`. I think most of us would feel writing a `loop`-style macro is within our abilities (which isn't to say a feature complete version of CL's loop sounds like an appealing project). But the way Series plugs in to the language, allows for factoring the "variable stepping" portion of a loop out into a function, but still compiles down to something like the loop you'd like to write, really requires some CL-fu.
Well, since this is from the 1980-81, they should have kept in mind that mine existed. Heh. :) But seriously, it's good to note these potential confusions as it can confuse people if they don't realize there are separate things. By the way, for completeness, there was also, contemporaneously, a dialect called [MuLisp](http://www.softwarepreservation.org/projects/LISP/other#muLISP_) done by Albert Rich, that was the basis of David Stoutemeyer's [MuMath](https://en.wikipedia.org/wiki/MuMATH). No relation to that either. My ULisp, which Lars is here referring to, is isn't related to MuLisp either.
**MuMATH** muMATH is a computer algebra system (CAS), which was developed in the late 1970s and early eighties by Albert D. Rich and David Stoutemyer of Soft Warehouse in Honolulu, Hawaii. It was implemented in the muSIMP programming language which was built on top of a LISP dialect called muLISP. Platforms supported were CP/M and TRS-DOS (since muMATH-79), Apple II (since muMATH-80) and DOS (in muMATH-83, the last version, which was published by Microsoft). The Soft Warehouse later developed Derive, another computer algebra system. The company was purchased by Texas Instruments in 1999, and development of Derive ended in 2006. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Came here to post this one. I read this book while in college, and really enjoyed it. It make the beauty (and horror!) of macros very accessible.
Yes, as well as *Let Over Lambda* by Doug Hoyte, two of the best books about macros and metaprogramming. A few chapters into *LOL* and your reach will exceed your grasp.
Great news! I might move to Austin next year, so I'll defintively bookmark your meetup :)
Since you're already in the Wizard Book (SICP), chapter 4 is where the higher-minded metacircular magic happens (metalinguistic abstraction as the authors say). "The evaluator, which determines the meaning of expressions in a programming language, is just another program." If our evaluator is a program, and programs are already data (lists) interpreted by our list processor, we can trivially write new programs (evaluators) to interpret expressions however we want (extending the existing "language" or altering/replacing its semantics) by transforming input programs (lists) prior to applying eval to the result: "An important advantage of making the evaluator accessible as a Lisp program is that we can implement alternative evaluation rules by describing these as modifications to the evaluator program." They then implement Scheme in Scheme (write your own eval, and analyzer). This is effectively the broadest means of extending the language using its own constructs (defining a custom eval), yet the resulting implementation of eval is incredibly elegant and simple to read. Seeing eval so simply defined in chapter 4.1.1 was a big lightbulb moment for me (as it turns out, there are even simpler ways to define eval). Later, the simple evaluator is extended to enable different semantics, like nondeterministic programming and logic programming. Another insightful book is Lisp in Small Pieces, which takes an approach similar to the metacircular evaluator chapter in SICP, and implements varying lisp dialects with more complex features, as well as demonstrating how to bootstrap interpreters from non-lisp languages. Peter Norvig has an excellent post on implementing a lisp in python that helped me grock how powerful yet simple a lisp can be [here](http://norvig.com/lispy.html). I found his implementation of an interpreter, to include [extending it](http://norvig.com/lispy2.html) to include macros, continuations, and more. A lot of this also exists in his book Paradigms of Artificial Intelligence Programming, except the base language is Common Lisp, but the target is still Scheme. He bootstraps an interpreter, and later a compiler for a virtual machine. Rather than hacking a custom eval function every time, lisps typically make use of macros to formalize specific extensions to the language. Macros serve as a kind of escape hatch or middleware between the user and eval. It gives you the ability to modify the input program (the s-expression) prior to passing it off for evaluation. Since the program (s-expression) is a datastructure that the host lisp has rich facilities for manipulating, macros are very powerful and flexible means for extending the lisp in a controlled fashion. Ultimately, "On Lisp" and "Let Over Lambda" (and PAIP) leverage macros in fascinating and powerful ways, where SICP introduces the concept on a more fundamental, constructive level. By eschewing syntactic shackles and embracing a simple unified data representation for expressions in the language (lists), you end up with a simultaneously simple yet powerful system that's inherently amenable to extension via metalinguistic abstraction.
Cool
I enjoyed reading the article. I am not an expert in the domain, but his arguments seem to make a lot of sense.
I do a lot of scientific computing, mostly in Python these days and have considered switching to Julia when the language is more stable. I do my hobby projects in Common Lisp. While working in CL, I have kept my eye out for how easy or hard it would be to do scientific computing in CL (partly because some of my projects will require some minimal scientific computing algorithms eventually), and honestly I have to agree Tamás with regards to doing scientific computing in CL and Julia (I've done a little with it, but mostly seen what others have been able to do). Some of it definitely has to do with the differing interests in the communities that use them. The numerical library situation would be a lot better in CL if more people were using CL for this (there would be more libraries as well as better abstractions and other things). It would be a lot worse in Julia if not many people were using Julia for it. This sort of thing is true for all languages. The interests of the community of people who use it determines how many tools for what kinds of work are available. This shouldn't be surprising. CL has always been a sort of general language with a general target and a wide range of interests of its programmers, so with a small community, there just aren't that many doing scientific computing. Julia was designed for scientific computing by people doing it and that interest has dominated its use. Python is like CL in that it has a community with a wide variety of interests, but its community is many times larger (and is the go to language for scientific computing, but this is still a niche use) so there has been a lot of work on the scientific computing end of it just from shear numbers. One of the important variables here are large collaborative scientific computing libraries, ones big enough that they have many people developing them. Julia has them. Python does (take a look at Numpy and SciPy for examples). CL has a few (Maxima is a good example), but not as many. Some of it is other things that the article also brought up. Typed arrays not necessarily actually being packed arrays of the element type (whether it ends up actually being a t array or an array of pointers to whatever type it was given underneath) definitely makes scientific computing harder. But it is also a strength in other respects. CL is rather accommodating for how an implementation on a particular machine might do things. This is a good thing, but it isn't without a price. Generics dispatching on class rather than type is an interesting topic. I've definitely sometimes wanted the latter so far in doing CL for non-scientific things. It is certainly doable to make another group of generics that do this using the MOP. After all, the MOP can be used to make the ANSI standard generics. I would bet at least someone has done this already. Just, I don't know who. It doesn't seem to be commonly used if it has been done. One sticky issue would be resolving which method is more specialized, but I can think of a few ways that can be done. CL is a nice language for many things. Just, it isn't always the best for many things. Scientific computing is definitely one of its weak areas, both due to some things about the language but a lot of it just from not having accrued a lot of libraries and other tools due to there not being that many people interested in using it for scientific computing. That is the area where Julia shines both from a design (it draws a ton from Fortran and Python's Numpy after all) and from its community.
I think you're right on target here: this all boils down to the collective effort of people working on certain things. For instance, Python as a (bare) language is much less suitable for scientific computing than CL (and that's why numpy and scipy are mostly "foreign" code), but it still manages to be a goto language for this just because so much work was done to support it. Similarly, tamas's frustration is mainly due to his experience of making a significant open source development effort and not being rewarded for it with attention, praise or other forms of recognition... (this is what every CL programmer should take for granted or otherwise frustration is inevitable :D)
Fair points on the article (the lack of generic vector type, for example). I think Julia is very nice and I see Julia as a great replacement for Python. I don't see it as a replacement for CL in general because it doesn't have the full flexibility and power of CL. But it seems to be a smartly designed language, which isn't something I could say for some "modern" languages like Go. 
Chance for a sequel?
https://github.com/sharplispers 
Are [these the repos](https://github.com/search?utf8=%E2%9C%93&amp;q=user%3Atpapp+language%3A%22Common+Lisp%22&amp;type=Repositories&amp;ref=advsearch&amp;l=Common+Lisp&amp;l=)? [sharplispers](https://github.com/sharplispers) could be a possibility. I also noticed, [Clarification: on orphaning my Common Lisp libraries](https://tpapp.github.io/post/orphaned-lisp-libraries/)
If you build the current ITS from here: [https://github.com/PDP-10/its](https://github.com/PDP-10/its), ULISP will be part of the TEACH system. You can invoke it with ":TEACH;ULISP". So if you want to experience this blast from the past, you can!
Cool. Thanks, Eric! I guess this bumps the priority of finding the doc and getting it online. :)
Well, he, actually, managed to complete his software. But it hadn't found much usage. That's why I think it's more lack of recognition than dissatisfaction with the language itself: otherwise, he would have dropped off in the middle. P.S. I've often found myself in a similar situation: needing to build a lot of things from scratch in CL. But I enjoy the process (and one reason is not having an expectation of recognition): just art for art's sake, so to say...
There is a lot of good stuff here, generally well documented and with some tests. I also work on scientific computing / HPC kind of things, and would like to be able to use CL for this more. I've found Tamas' libraries very useful. Since CL is a standard these libraries will be around and useful for a long time. It would however be a shame if they faded into obscurity, only for someone else to implement their own from scratch. I have unofficially adopted/forked/usurped one of them, array-operations ([https://github.com/bendudson/array-operations](https://github.com/bendudson/array-operations)). 
Julia lands just in time (sic) for the wave of static / performant / well thought out language. Python filled the niche for nice and performant numerics (thanks to compiled libs) while it felt a better process, but nowadays lots of people are back into static types (typescript, python annotations). 
I am 100% linux based and I cannot just swap out distros like that, so not using Guix or the other one. However, I am fully on stumpwm, emacs, lem, stumpwm and now next browser. Perhaps as clim keeps on getting better we can start to get full lis gui apps. Lots of other users doing similar.
I talked with Tamas a while ago about this. While where\_void\_pointers post is a much more eloquent exposition that I can make one thing I can add is that Tamas did not regret using Common Lisp but Julia offers a more "batteries included" approach for scientific computing which meant he could spend more time on research and less on building tools. Along with that, the Julia community spoke to his needs more than the CL community with its diverse interests could. &amp;#x200B;
Could you link me to your StumpWM config? i downloaded StumpWM but I haven't set aside time to sit and learn it like I did with i3wm
Why Lem and not Portacle or Emacs?
Because it is common lisp, not c / elisp. We are lucky to live in a time where common lisp basically runs everywhere, it only makes sense to use pure lisp apps when available. 
Here you go: ;; -*-lisp-*- (in-package :stumpwm) ;; set the shell to current shell (setq *shell-program* (stumpwm::getenv "SHELL")) ; `getenv' is not exported ;;frame / window policy (setf *mouse-focus-policy* :click) (setf *data-dir* "/home/USER/.stumpwm/") ;;Window border colors (setf *focus-color* "green") (setf *unfocus-color* "black") ;;Set the message and input box to the bottom right. This way it overlaps with mode-line. (setf *message-window-gravity* :center) (setf *input-window-gravity* :center) ;;Colors for the input box; these should fairly self-explanatory. 'set-fg-color' will change the color ;;of the font in the echo area, for example, and the background will be green, ;;and the rectangle's lines will be a thin yellow, of course. (set-bg-color "black") (set-fg-color "lightgreen") (set-border-color "yellow") ;; Keep the mouse pointer out of the way (run-shell-command "unclutter -idle 5 -jitter 5 -root") ;; shortcuts ;; urxvt (define-key *root-map* (kbd "u") "exec urxvt") ;; conkeror (define-key *root-map* (kbd "c") "exec /usr/bin/nice -n 19 conkeror") ;; thunar (define-key *root-map* (kbd "o") "exec pcmanfm") ;; redefine stump prefix key (stumpwm:set-prefix-key (stumpwm:kbd "C-t")) 
Yes, I have [one machine](https://babbagefiles.xyz/guix_maze_of_lispy_little_passages/) that is GuixSD+StumpWM (and I run Emacs everywhere already). With GuixSD, that means the package manager and cron are also Guile-based. There's a Common Lisp browser ([Next Browser](https://next.atlas.engineer/)) as well (not quite ready, I think). So that machine has Lisp for lots of the user-facing pieces. I know there are some people doing GuixSD+[exwm](https://github.com/ch11ng/exwm) as well.
I beg to differ, my friend. Your answer was very satisfactory. Thanks for taking the time!
GuixSD is really intriguing to me! I will try to install it in a VM. I do also have a ThinkPad X201, but I'm not sure it will work there
Do you think [clasp](https://github.com/clasp-developers/clasp) will open the door for scientific libs and numerical computation in CL? It seems like they're doing some neat stuff to easily wrap c/c++ libraries.
Probably will depend on what WiFi card you have in. Otherwise should be fine.
- Your indentation and parenthesis placing is fugly. Pls stahp. - You do need a LET form to bind SOLVED, and there are no extra parens after DO in LOOP.
 ( (solved (caesar-cipher plaintext i)) (format t "Solved: ~a ~%" solved) ) This has some weird formatting, which should give you a clue that something is not right. Remember: there are basically 4 differemt forms allow in Common Lisp: (some-macro ...) (some-function ...) (some-special-operator operator) ((lambda (some-arglist) some-body) ...) Your code is none of above. It is: ((foo ...) (bar ...)) Basically it is missing the operator (function, macro, special operator, lambda expression). (what-operator-do-you-want (foo ...) (bar ...)) The error message itself is kind of unhelpful. I have seen a stream of questions on Stackoverflow with basically the same problem. I think it would be useful for the SBCL maintainers to come up with a better error message for this syntax error. 
GuixSD can be used with the Mainline Linux Kernel and the iwlwifi firmware. I'm running GuixSD on my unmodified Thinkpad x260 with no problems.
- shell: https://github.com/bradleyjensen/shcl ? - file manager gui: https://github.com/stacksmith/cl-fm (heavily WIP)
What specifically did you find hard?
I use `i3wm`, and I think your setup is similar to mine. I don't even it's possible to have desktop icons on i3. It doesn't even have wallpaper support by itself, I use `feh` for that. I do have a `taskbar` of sorts, for some programs that require it. But it's hidden by default. I use `Rofi` as a launcher, an `st terminal` running `Tmux` stored in the `scratchpad` (an i3 thing, the scratchpad is an invisible repository of floating windows that you access via keybinding. It gives any program the ability to work as a drop-down, Quake-style terminal. Very customizable) and another running the `Ranger` file manager. I easily manage all my windows, screens and workspaces via keyboard. It's pretty cool.
I wonder if a lisp-centric distro would be of any use. A minimal, easier out-of-the-box configuration (with non-free packages) for GuixSD+StupWM+Emacs, GuixSD+exwm or even GuixSD+Emacs (no window manager).
I remember getting deep into making a new package before finding out that I could pull programs installed by other people. And then I think it was annoying to actually find and specify what to install. I think I had some PATH problems too. It was too bad; I love the idea of GUIX.
I hear plenty of people arguing over "What is the best language for scientific computing?", while they actually mean "What is the best language for scientific computing that mostly behaves like Fortran and C++?". This is a huge difference. Julia improves upon NumPy, C++, Fortran, Matlab and some others. But fundamentally, it is still a notation for long sequences of floating point instructions. Julia's focus is on numbers and arrays, not on objects and metaobjects.. But what if specialized imperative floating-point code isn't the best solution for scientific computing? What if the tension between performance and maintainability can only be resolved by treating our scientific algorithms as data instead of code and by writing symbolic code generators instead of numerical codes? In this case, Common Lisp might be an excellent language for scientific computing. 
Wow, thanks for posting all of this. The Lisp community is really helpful :) 
Given the way that Guix works, it would likely be very easy to do. It would largely involve a curated `config.scm` and maintained channels (e.g. https://gitlab.com/mbakke/guix-chromium ).
What about kernel modules?
I wasn't even using GuixSD, just the regular package manager on top of Ubuntu. So the DE/WM wasn't an issue for me. &gt; I recall GuixSD being described in one of the talks as "Gentoo for grown-ups" in terms of difficulty. I feel like ideally, it shouldn't be. I can easily configure my Emacs to install what I want; I want Guix to be as simple.
&gt; Do you think clasp will open (or reopen) the door for scientific libs and numerical computation in CL? Good point, i understand this was one of the main reasons for creating CLASP in the first place. 
Aha! I should have known. Thank you kindly!
I appreciate the heads up. I will give i3wm some testing. that sounds cool.
No question - this book was profoundly humbling.
Wow, great comment. I'll try Lem as soon as I setup a Linux box.
[QMK](https://docs.qmk.fm) is an option that's available now. It'd take some doing, but you could get the keyboard to output sublegends. `Hyper` you get out of the box.
yeah I agree that it's still in the too-much-free-time category at the moment. It took me a bit of fiddling around, and I had to install the official image then the mainline kernel and firmware over Ethernet. GuixSD does provide the option to build .iso images from a system definition. So, as I understand things (and I don't really), I should be able to build an iso from my system as it is currently, then give that to others to use as a USB installer. However I haven't gotten that working yet.
That and he had a lot of C++ scientific code to interface.
Depends on the field how important it is to interface C/C++. In some areas, Fortran dominates both the low and high level libraries and in others it dominates the low level libraries. In others, C is important at various levels. A common arrangement is that C and/or Fortran is used at the low level and as one goes up to higher levels, one sees more C++ or Fortran. Interfacing C from CL isn't too hard. Fortran is relatively easy. It has slight name mangling (every function/subroutine gets suffixed by an underscore typically), function/subroutine determines what is passed by value and by reference, and how Fortran represents strings (string arguments are passed as two arguments from a C/CL perspective, one being the length and the other being the string address, if I remember correctly). It is the interfacing C++ that is really nasty. Clasp was designed for this, and ECL can do it if compiled right. Name mangling, different internal representations of stlib++ objects, etc. all make it very difficult to interface from other CL implementations.
I use nixos with exwm and would love to use next-browser if there would be any packages for it. No lvm support for GuixSD makes it hard to use it for me. But yes I think exwm &gt; stumpwm used the latter in the past, but it's frame-switching (app switching) can't compete to the lazy find-buffer thing from emacs. Also you have more context switching is it a app or only a emacs frame I want to switch so 2 menues instead of 1. Also elisp &gt; common-lisp :D
I'm studying the book as part of a programming languages exam at university (along with common lisp, prolog, haskell and c). It is absolutely great and it will change the way you think about programming (eg. about recursion and iteration). I hope you will enjoy it as much as I'm doing. 
Could you share more details about your course, why are you guys learning so many languages at the same time?
I read through the whole book a few years ago and did nearly all the exercises. The last two are still on my TODO list as life happened and I just didn't have the time nor energy. This book had an extreme, and I think good influence on me as a programmer. It's on top together with The Pragmatic Programmer and The Art of Unix Programming as the big trio that made me who I am today. While I don't use the concepts much in my everyday work, the way I think about problem solving in general has changed. You can find some of the concepts from the book in nearly every language out there, from JavaScript to C#, even in Golang. I'd even say most other programming languages are slowly becoming more Lisp-y. Have a look at [Racket](https://racket-lang.org/) and [How To Design Programs](https://htdp.org/) aswell.
What seems to be a really interesting member of the Lisp family is Racket. Here is a blog post of Konrad Hinsen as he describes how he sees Racket in terms suitability for computational science: [Konrad Hinsen: Exploring Racket](https://khinsen.wordpress.com/2014/05/) Hinsen was one of the initiators of Numerical Python (numpy) and is a Researcher in computational molecular biology. He is also an experienced Lisp user. Note that his assessment is based more on the general, long-term qualities of the language, not on the current Library situation. From my own experiments with some micro-benchmarks, I can say that Racket is about two to five times slower than Java - that's impressive. It is also very easy to call into C code (and because Rust can provide functions which match the C ABI, one can also already use Rust for this). 
Though you can just install via `guix package -i foo` too. But, I agree, there does need to be further documentation developed. And I think the Java/Clojure issue has to do with Guix not wanting to use provided binaries, which makes certain things more difficult. To be fair, `use-package` isn't a built-in part of Emacs; given that it's Lisp, I'm sure the verbosity/boilerplate-iness of Guix packages could be managed if someone developed a `use-package` equivalent for Guix. (Though, there is an Emacs package for managing Guix packages which is pretty nice - it presents something like the `list-packages` interface and behaves similarly.)
Go ahead :) Lisp is an old *language*, yes, but a timeless *principle*. Try to view Lisp as mathematics-become-programming-language. The concepts are timeless. Other languages care about CPU architecture and try to be *fast*, so they sacrifice a concept here, a concept there. Lisp wanted to show what could be *possible* without bothering (at first) with being *fast*. Nowadays CPUs are faster, and heretical concepts like garbage collection, closures (in the more common non-SICP definition) or functional programming are becoming more mainstream.
I am sorry if I am just confused and the question below does not make sense. So you mean that because CPUs are faster nowadays, other languages proclivity to lessen the burden of the CPUs, became a little bit "irrelevant"? And then, there is where Lisp is, becomes even more, as a timeless principle, because of what then? What is the relation between Lisp and SICP importance to the enhanced CPU architectures? &amp;#x200B;
Racket is a pretty good and solid system. Scheme heritage and still supports scheme (R5RS, R6RS, and R7RS), with a lot added on. Have heard about it being used in math circles. Didn't know about the science circles. Thank you for the information.
A long time ago, computers were sloooooooow. Lisp was, and is, extremely powerful, but sacrifices performance. Back then Lisp was a slow beast, while other languages like Fortran or C were pretty close to the metal and nearly as fast as Assembly, but sacrificed lots of features the Lisp guys loved. Nowadays there are very good Lisp compilers (SBCL for example), and computers are much faster, so the (linear) difference in speed is not as bad as it was back then, so we can afford using more powerful language features. So the other languages, in their quest to become better, took a little of this, a little of that, and slowly, they resemble Lisp more and more -- minus the parentheses and macros, because a language that has those, too, becomes a Lisp almost by definition. Think of C#: At first it was a "better Java". Then it added properties, i.e. methods that are called when accessing member variables (Lisp calles them accessor functions). Then it added lambdas and closures. Then it added dynamic variables. Now we have expression trees that can be compiled on the fly -- hello Lisp compiler turning a tree structure into executable code at runtime. As a C# programmer at work, I see more and more features being "invented" again that Lisp programmers had for decades. Now we even have a debugger that can change code at debug time and continue with the changed program: Welcome to the 70s, Microsoft...
That's really interesting, and they say that fashion is a cycle, look at programming...Well, I do not know anything of other languages but Lisp and JS yet, so I have a lot to learn along the way but, I am happy that going through SICP may be a very fruitful exercise.
Are you a beginner or do you already have programming experience. In my opinion, To truly appreciate SICP, you should already have some programming experience, The more programming you've done pre SICP, the better, because you pick up on ltos of new concepts. Here's my suggestion, follow this instead, You will still do SICP, but only later on when you've already exposed yourself to sophisticated ideas in programming: https://functionalcs.github.io/curriculum/
Hum, nice, thank you for your suggestion, I'll grab how to design programs first then 
Pair it with this: https://www.edx.org/course/how-code-simple-data-ubcx-htc1x, It's a course based off of the book and is going to help you a lot as well, Infact, this course is a first in a series of courses. Another alternative, Less functional course outline is: https://github.com/ossu/computer-science You might be interested in that aswell, but pick and choose whats appropriate for you, All 3 (teachyourselfcs, functionalcs, and Ossu) are great course resources.
Much appreciated! Really glad that I made the post here. I will have those three paths as references and decide along the way what I need/want the most because I intend to be a freelancer, so some thought on that might be important. &amp;#x200B; Do you have any idea why are these courses so functional programming oriented (except ossu)?
Its mostly to do with that the professors at different uni's want in their curriculum. The important part is to be cognizant of all the different applications of CS, for a truly deep understanding. 
Would you say that making this language helped you understand programming better. If so, how?
Yes to windows/sbcl working just fine; I did a cross-platform application and had zero complaints from windows users. Big hint: put the .dll files (e.g. sqlite) in the same directory as your executable. If by "system arguments" you mean command line arguments, those are no problem; if you mean something else, please clarify.
&gt;The issue is that it for Windows and I wandted to know how reliable was the compiling for Windows (probably with SBCL). I know it exists but can I expect to be able to maintain my application this way? Looking around it doesn't seem like a lot of people are doing this​ &gt;I was also wondering if system arguments were easily accessible, I know this can be an issue on windows. &gt;In the end I'm hoping to have a single executable interact with a bunch of excel files and a SQLite or SQL database. It works just fine, the Windows issues warning was there only for some threading issues. In any case if you experience any problem that can be blamed on the compiler, you can switch to using CCL (Clozure Common Lisp) which is stable on windows and is another of the *really* good free Lisp implementations. As for the command line arguments there are compatibility libraries for this, see UIOP, for example [line 221 here](https://github.com/fare/asdf/blob/master/uiop/image.lisp). UIOP is probably already included on your software. 
Yep it's exactly what I meant, not sure why I said system argument. I don't know much about windows, but there's no way to package those ddl files in the exe or even use the system's ? &amp;#x200B; Thanks for the answer, though!
The threading should be fine but that's nice to know if need to scale up. Yep your library and another one for general XML if I recall were already on my radar :D &amp;#x200B; Are those library independant to the compilers (the ABCL, CCL that you mention?) or swapping between them could bear a heavy cost? &amp;#x200B; Thanks for the answer
Hey, Nesatam, just a quick heads-up: **independant** is actually spelled **independent**. You can remember it by **ends with -ent**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
CommonMisspellingBot provides a mnemonic device in an attempt to help people remember spellings of commonly misspelled words. Quirky little sayings that hopefully stick in your head and help in day to day life. You on the other hand follow this poor bot around repeatedly calling it useless. Please take a long, hard look at your life choices my bot friend.
Hey BooCMB, just a quick heads up: The spelling hints really aren't as shitty as you think, the 'one lot' actually helped me learn and remember as a non-native english speaker. They're not *completely* useless. Most of them are. Still, don't bully somebody for trying to help. Also, remember that these spambots will continue until yours stops. Do the right thing, for the community. Yes I'm holding Reddit for hostage here. Oh, and while i doo agree with you precious feedback loop -creating comment, andi do think some of the useless advide should be removed and should just show the correction, I still don't support flaming somebody over trying to help, shittily or not. Now we have a chain of at least 4 bots if you don't include AutoMod removing the last one in every sub! It continues! Also also also also also Have a nice day!
&gt; Yep your library and another one for general XML if I recall were already on my radar :D The problem is not reading the XML (that is easy and there are many CL libs for that), the problem is the way the excel data is structured; it uses several XML files and many special cases. 
&gt; I don't know much about windows, but there's no way to package those ddl files in the exe or even use the system's ? DLLs are dynamically loaded at runtime so there must be a way to make your system look at them at predetermined directories to look for it. Perhaps you can take a look at `clsql-sqlite` which is the driver/lib that couples CLSQL with SQLite, it should have the code that loads the driver there. EDIT: [Check out line 33 here.](https://github.com/sshirokov/CLSQL/blob/master/db-sqlite3/sqlite3-loader.lisp) 
yeah I see what you mean about the XLSX, but I'm somwhat familiar with this data structure and in this case it shouldn;t be too hard. &amp;#x200B; Thanks for the clarifications, I wasn;t sure I got that properly but it's one of the paradigms that attracted me to lisp! &amp;#x200B;
&gt; but I'm somwhat familiar with this data structure and in this case it shouldn;t be too hard. In this case please fork my code, correct whatever is wrong there (see the two open Issues, where the code fails with certain XLSX files) and send me a pull request. I would heartily be grateful with this. 
Thanks for all the answers, it overall sounds very feasible.
Well, you give me some time to figure out this whole Lisp thing and this sounds like a deal! :D 
Regarding any dependent DLLs, Windows has a couple of different canonical ways to deal with that: 1. If the dependencies are well-known and have a maintained installation procedure, incorporate their installation with yours or just document that your program depends on them. This is how. NET applications work (they depend on some runtime being installed) 2. If your dependency is a package that doesn't have some well-known installation procedure, then typically you pack the dependencies with your application. This is commonly the case for GUI libraries packing SDL2 or Qt. Likewise, this is often how Sqlite is included as a dependency. You should review the search algorithm used by Windows, but the TLDR is to put dlls in the same dir as your executable. For distributing an application this works 99% of the time. Lastly, mind 32-bit vs 64-bit.
Not sure what to make of this but it looks really interesting. Good job!
Elixir also &amp;#x200B;
Rust macros, depending on how bleeding edge you use them, either only do mere substitution or force you to work with a [token stream](https://github.com/rust-lang/rust/issues/38356) of all tokens inside the macro invocation.
If you’re using sbcl, and build sbcl with the right options, cffi’s static-image-op will statically link all the C code you depend on. Allowing you to generate a system-independent executable that is suitable, e.g., for github releases. https://github.com/fiddlerwoaroof/daydreamer
Interesting; is there one in particular that might serve as an illustration of this ?
On Windows one can set a special path (only 1 though) to search for dlls in, outside of the folder with executable, using the ::SetDllDirectoryA function. Then ::LoadLibrary will search the name provided in this directory as well. One can use ::AddDllDirectory as well and then ::LoadLibraryEx. Not sure what uffi/cffi are using internally for this. For more information read [https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-setdlldirectorya](https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-setdlldirectorya) &amp;#x200B;
There is a style in programming, often applied to Functional Programming, which avoids variables: https://en.wikipedia.org/wiki/Tacit_programming Generally in Lisp there is a lot of freedom and flexibility. Best to learn when to use what programming style in which situation. If there is one single right way in Lisp: there is no single right way.
**Tacit programming** Tacit programming, also called point-free style, is a programming paradigm in which function definitions do not identify the arguments (or "points") on which they operate. Instead the definitions merely compose other functions, among which are combinators that manipulate the arguments. Tacit programming is of theoretical interest, because the strict use of composition results in programs that are well adapted for equational reasoning. It is also the natural style of certain programming languages, including APL and its derivatives, and concatenative languages such as Forth. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Tacit programming, also called point-free style, is a programming paradigm in which function definitions do not identify the arguments (or "points") on which they operate. Instead the definitions merely compose other functions, among which are combinators that manipulate the arguments. Tacit programming is of theoretical interest, because the strict use of composition results in programs that are well adapted for equational reasoning. It is also the natural style of certain programming languages, including APL and its derivatives, and concatenative languages such as Forth. The lack of argument naming gives point-free style a reputation of being unnecessarily obscure, hence the epithet "pointless style."
Must have been something related to that specific exercise; there is no connection between lack of local variables and functional programming (though in functional programming, you generally shouldn't *mutate* these local variables). As a sidenote, in some languages with the necessary conveniences (primarily haskell, roughly speaking a strictly functional language), [tacit programming](https://en.wikipedia.org/wiki/Tacit_programming) is common. In tacit programming, you don't even specify the arguments to a function, you just compose functions. A lack of local variables would be quite typical when programming in such a style. This is not restricted to functional programming, however; forth is a language where idiomatic code is tacit but imperative.
Forth is the only language where people might be uncomfortable with local variables, and even then discomfort would usually be wrong.
This is the thing that pushes away people from lisp — someone projecting their radical ideas onto the language. Lisp gives you the freedom to either use local variables or not use them. Ordinary functions are a mixture of both, you don't want to bind each intermediate result to a variable, but neither you want an incomprehensible soup of function calls (nor defining a myriad of one-off functions to hide that). And if the best name you can come up for a variable is X or I, then it's not really helpful to have such a variable. Something more radical, it's not even shunned to use global variables in common lisp.
Take a look at (SpecialFunctions.jl)[https://github.com/JuliaMath/SpecialFunctions.jl]. If you needed, say, a complex digamma function in CL, you could port (this one)[https://github.com/JuliaMath/SpecialFunctions.jl] without too much trouble. (Just don't use Greek letters for variable names; the implicit upcasing makes debugging confusing (unless you're Greek)).
Sure, but why would you ? GSL has been stable and comprehensive for many years (and many others ACM TOMS if you're on the 'bleeding edge'). [https://www.gnu.org/software/gsl/manual/html\_node/Psi-\_0028Digamma\_0029-Function.html](https://www.gnu.org/software/gsl/manual/html_node/Psi-_0028Digamma_0029-Function.html) 
&gt; *This is the thing that pushes away people from lisp.* In particular, young people who accept every word of the bullshit, and the nonexistence of anything else by omission. 
I was wondering the same thing many years ago! I didn't have any teacher (just some random articles), but felt dirty when using `let` forms, precisely because I did first examples using `lambda`s as the only way to bind stuff (also I mostly used my own lisp where I didn't implement `let`s at first). In scheme in particular there is `let*` form, which felt "even dirtier" as the order of these local bindings matters. So my question was: are ideas which require considering any sort of ordering/sequencing really pure? Are my programs really denotational if I use `let*` ? *(I guess when you write "functional" you mean "denotational"...* [*http://thecorememory.com/Next\_700.pdf*](http://thecorememory.com/Next_700.pdf)*)* This seems to be a common fallacy of equivocation... Obviously (he\_he) our ideas have hierarchical structure, and if we want to describe them, we have to get them ordered because we explain stuff (in speech and text, including programs \[yes, even befunge\]) linearly. And we order them by conceptual dependencies (usually the bottom-up way). That's perfectly "pure" ("denotational"), as in most math textbooks where you first define sets, relations and functions (that's the first chapter you always skipped), then structures, then actions/mappings, then morphisms, and structure-preserving constructions (\[direct\] products, quotients, etc)... `let` allows you to do that in a very local way -- to de-structure your expression; even to make the expression more readable by giving names to certain "partial explanations" (if you consider an expression as an explanation). I guess it sometimes reads better in the opposite direction (top-down), with `where` form, as in ISWIM or (if you prefer languages which are actually implemented ;)) haskell -- but that depends on the reader too. And speaking of haskell, why don't these guys feel guilty when they use `do` notation?! Now that's imperative thinking! So I guess I understand your doubt, but it seems not only okay, but preferred. The ordering is "along the dependency axis", not "along the process time axis"; the only temporal relation there is is about ordering/sequencing of explaining notions, not computing object that these notions capture. In case you wonder: what I feel dirty about now (and try to avoid as much as possible even outside of LISPs) is rather the use of verbs/verb prhases for function names, and any attempt at cps (that's not only "talking about time" using ostensibly pure device, but just one step from feeling comfy with call/cc -- EVIL!!!). Last thing, don't get too dogmatic though. It will slow you down, quite likely unnecessarily. But also be pure. Good luck!
This is something that is done when teaching functional languages at university courses. I recall this way of teaching 20 years ago when I learnt ml. Today Paradigms of Computer Programming course is a good example. I would say the idea is to force the pupil to think in the realm of functions and not use assignment because it predisposes the pupil to think of loops. In functional languages, loops may not even exist in the base language (they're a function) and they're introduced after teaching invariants (that are better explained if variables have not been introduced), so in a pedagogical sense it makes sense to delay the introduction of variables until later in the course.
&gt; This is the thing that pushes away people from lisp — someone projecting their radical ideas onto the language. Well said. Where Lisp is really about giving you the freedom to proceed as you wish.
&gt; I believe that college academics has done a great harm to Lisp. For many people in computing, courses like this are their first (and often only) contact with Lisp, from which they walk away with completely the wrong idea. This has been my experience as well, when meeting people that did have some exposure to Lisp/Scheme, only for said exposure to be at university and for doing some boring task like teaching recursive functions. There are even academics that use Lisp in "fortran-style", tha tis, with an over-abundance of `setq`, `prog` and `go`. 
&gt; And speaking of haskell, why don't these guys feel guilty when they use do notation?! And the fun thing is that a lot of Haskell code out there uses `do` notation. 
Cool. Do you want to contribute to https://lispcookbook.github.io/cl-cookbook/editor-support.html ?
&gt; thus our teacher made it clear that it was forbidden to use any local variables (“Don't use let”) in order to program Fibonacci functions. sounds like an application of: https://en.wikipedia.org/wiki/Wittgenstein%27s_ladder
Today's recording: https://www.youtube.com/watch?v=F9-j_8Rr59s#t=5m56s
Sure. I can put some notes in there.
Good luck!
Thank you!
You could sign up for Advent of Code for a supply of neat little problems to solve. 
Good luck - ask people on `#lisp` on Freenode or the Lisp Discord server for any help you might need. Also, https://portacle.github.io/ and http://www.gigamonkeys.com/book/ - that's the starter pack.
Stop learning it!
\#lisp is a very nice channel. Not condescending like #c++ can be sometimes let me tell you. 
Good idea. You should also provide a cut-off time for each day with a timezone - so you don't have people from around the world messaging you that the day is over when it is still mid-day for you.
The channel `#clschool` is also great for beginners.
&gt; Also, https://portacle.github.io/ and http://www.gigamonkeys.com/book/ - that's the starter pack. +1 Truly a starter pack. Implicit in the starter pack, too, is the [CLHS](http://clhs.lisp.se/Front/index.htm) (Common Lisp Hyperspec), *the very definition of class.* 
&gt; Advent of Code Hey thanks for reminding me! I did it in 2015 and totally forgot about it :)
Our discussion prompted me to write this blogpost on the topic: http://lisp-univ-etc.blogspot.com/2018/11/structs-vs-parametric-polymorphism.html
nath that's because you didn't have the nice Cookbook or the Awesome list at that time :P
None of those functions take a complex argument. Am I missing something?
I started two years ago, the cookbook waa there but I found it a bit later. Also I regret not starting with Portacle from day 1, because I lost a bit of time configuring everything. 
Basically if your type system dispatches only on flat types like `string` or `widget` and not things like `vector of integer`, the obvious thing is to take the complex, parametrized types that you care about and map them to some non-parameterized type, like a wrapping struct. This works for anything: you can dispatch on anything that isn't a supported type by wrapping it in one. E.g. in some languages with "basic types" that aren't classes, you can wrap them in classes and then you get dispatch. It's kind of the same thing. Wrapping an `int` in an `Integer` class for the sake of participating in dispatch isn't much different from wrapping some array of double-floats in an `array-double` struct. As far as OOP dispatch is concerned, there is no strict need for types to be anything other than symbolic labels which are arranged into an inheritance lattice. 
that's correct, thanks for a great summary!
just to note that two years it was this: http://cl-cookbook.sourceforge.net/ and after many PRs it has better content and look: https://lispcookbook.github.io/cl-cookbook/ but anyway I agree with your observation.
Same. So we owe each other.. and we're now balanced. Damn
6pm UTC happens when this comment is 2 hours and 41 minutes old. You can find the live countdown here: https://countle.com/wCN7P3Jid --- I'm a bot, if you want to send feedback, please comment below or send a PM.
Last episode of the year? But there's a whole month left! 
It's true but that means we've got a month left to get the alpha of [talespire.com](https://talespire.com) out of the door\`\*\`... and there is a lot to do :) &amp;#x200B; \`\[\*\]\` it's a self imposed deadline, but we said we would try so it feels wrong not to give it a good shot
Are you writing Talespire in lisp?
Nope. Whilst lisp is a lovely language, the surrounding infrastructure provided by Unity means its a much better choice. Also one of my partners in crime has over a decade of experience with Unity so we would be making ourselves a lot less productive in order to make me a little happier :p
Nice!
why?
Cause I want my $5, duh.
r/emacs might be a good place to cross-post this.
As far as I know, not strict. For instance, SBCL does the type-checking at normal compiler settings while Allegro does not. But I don't think that's a critical issue here. After all, the original intention was not safety, but performance. And this is, definitely, implementation-dependent
Extract the parts you want to vary to procedure arguments. (defun add-org-custom-emphasis-keywords (str face-type ) (add-to-list 'org-font-lock-extra-keywords `(,(concat "\\(" str "\\)\\([^\n\r\t]+\\)\\(" str "\\)") (1 (face ,face-type invisible t)) (2 at-face) (3 (face ,face-type invisible t))))) (add-org-characters "!" 'at-face) Note that I'm using backquote, as backquote allows one to temporarily disable quotation to execute code, and I've removed the nested quotes which you had, as, as far as I can tell, those are incorrect.
I think I didn't quite understand what you were trying to do, and the difficulties you were facing. Also turns out I don't know how faces work. Modifying my-org-add-custom-keywords from the other thread to the following seems to work, though you might need to play with the regex to get it to work they way you want: (defun my-org-add-custom-keywords () "Add custom keywords." (loop for (delimiter . face) in my-org-custom-keywords do (add-to-list 'org-font-lock-extra-keywords `(,(concat "\\(" (regexp-quote delimiter) "\\)\\([^\n\r\t]+\\)\\(" (regexp-quote delimiter) "\\)") (1 '(face ,face invisible t)) (2 ',face) (3 '(face ,face invisible t))))))
What's this?
Thank you very much to the SBCL maintainers team, in some way they are carrying the flag of open-source Lisp. &gt;bug fix: restored sb-thread support on OpenBSD. This one is a major one! 
Because lots of people know js
Output of sh ./run-tests.sh
Am I missing something here? The current version listed on clisp.org is from 2010. 
Not an official release but [updates continue](https://gitlab.com/gnu-clisp/clisp) at gitlab.
All that's missing is a macro to enable this: (defmethod/parametric my-method (foo (list/string)) ;; With automatic unboxing (frobnicate (aref (car foo) 0))) 
Have you heard of [scheme2llvm](https://web.archive.org/web/20111220233738/http://www.ida.liu.se/~tobnu/scheme2llvm/)? Its a scheme to llvm compiler. I know LLVM is not assembly but it might be low level enough to be of interest to you. Also see self plug [scheme2llvm in CL](https://github.com/terminal625/scheme2llvm)
In order to understand the true power of Common Lisp, you must understand its greatest weakness. Common Lisp is unrestrained power. What does this mean? Any one can make a huge mess since there are macros, eval, CLOS, etc. People coming from overly restricted languages like C++ can and will use every "powerful" feature they find to walk code, change semantics of the language, repackage built-in symbols, and do all other sorts of impossible nonsense. Why does this happen? Because when you are weak, like a C++ developer, you never learn restraint. Because of this, Common Lisp suffers from a management problem. If all your developers are using a weak language, there is only so much damage one developer can do. Here is a similar idea by Fare who [pointed out](https://fare.livejournal.com/tag/lisp) that CL is a "hippie language". He has experience managing CL projects with ASDF. There was another blog post by another author about how CL is too powerful but I can't seem to find it. &amp;#x200B; If all developers could exercise restraint then perhaps Common Lisp could flourish. But this is like saying if everyone in the world was good there would be world peace. That will never, ever happen, except if your world if small enough or everyone is homogeneous. This is why Common Lisp projects start small and stay small. It's like communism, you need everyone to follow the rules. Thus the link between communism, open source, and common lisp. &amp;#x200B; However, there might be hope for a solution in a lisp that incrementally adds power \[at one point the [X3J13](https://en.wikipedia.org/wiki/X3J13) committee was debating whether common lisp should be separated into different parts like a "core"\] and/or permissions/capabilities like [scheme48](http://s48.org/). I think it was Paul Graham who said that as time passes, weak languages like C++ absorb features from common lisp. Or see [Greenspun's tenth rule](https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule). In common lisp, everybody gets absolute power no matter what, their is no social hierarchy, thus no government, it's anarchy. That's why fundamentally weak languages with things tacked to mimic Common Lisp on succeed economically but Common Lisp does not. Self plug: I'm trying to figure out how a lisp bytecode interpreter could have capabilities, not extensively, but similar to the JVM.
Everyone in this comment section has misunderstood Minsky's point, probably because he doesn't really explain the meaning of "program that writes programs" in this video. He's not talking about macros per se. He's talking about the idea of self-modifying or self-writing artificially intelligent programs, [which he discusses in more detail elsewhere](https://youtu.be/CIoddZ1NOVM?t=1390). His claim is that Lisp is uniquely suited to writing such programs but nobody is actively researching this subject anymore. He doesn't justify his claim that Lisp is suited to this task and other languages are not in this video, but perhaps the justification might include Lisp macros, among other things.
\&gt;"lisp" \&gt;adds numbers, compiler in JS, doesn't even inline + cleavir would be a better educational tool smh
That's a problematic test. It doesn't reflect actual failure of code, just that the test is failing because performance isn't as good as it demands in some cases.
I wondered about it, considering its name. Should such tests be a part of the post-build test suite? Out of habit, I run them to check if something isn't broken. Decreased performance of something is sad but not exactly what I'm looking for at that point.
It's being addressed. Personally, I'd move such tests elsewhere. It would be useful to track drifts in performance over time, just to make sure quality isn't degrading, and to focus attention on bottlenecks. Speaking of bottlenecks: anyone want to implement a multithreaded stop-the-world garbage collector? :)
I'd want to. (Not that I *can*, but that doesn't mean that I don't *want* to. ;))
How many cores/threads do you have?
Six and six.
[PicoLisp](https://bitbucket.org/mihailp/tankfeeder/src/default/advent2018/)
Thanks for this!!!
My code is [here](https://git.sr.ht/~ttt/aoc18) and I'm collecting notes [here](http://tilde.cat/~t/p/aoc18.html).
It happens to be one of (but only one of) my favorite languages. :) I also wanted to demonstrate to coworkers that you can write a compiler in any language. Doesn't need to be C or Haskell or Racket.
I'm still reading through Practical Common Lisp and I'm not good at algorithms but that should get me started on simple problems: https://github.com/Porkepik/Advent-of-Code-2018
I'll post my stuff [here](https://github.com/nailuj24/aoc2018), although I'm probably gonna lose interest towards the end of the month. Always good to see other solutions to learn some neat new tricks.
hey, for file-to-list what about uiop:read-file-lines ? https://stackoverflow.com/questions/3813895/how-can-i-read-the-contents-of-a-file-into-a-list-in-lisp/48185783#48185783
Thanks for taking a look at the code. This function looks like the perfect fit for the problem, but I'm trying to get by without external libraries (for now at least).
Well a bit with gnus, but I think that is less a emacs issue but more a gnus issue that package could use some love, there is concurrency support since 25.x or so included I don't see why it should block stuff. &amp;#x200B; I tried to minimize it, if you don't pull automatically for mails it doesn't make a problem or you can a handler for gnus-daemon that shuts it down after a timeout. &amp;#x200B; That aside it works pretty well, can't really complain.
[Another Common Lisp version](https://github.com/cmoore/aoc2018/blob/master/aoc.lisp)
use recursion
but make sure it's a tail call
I don't like the use of symbols as if they were character strings. The clauses in `loop` should be in the `cl` package. Thus, if you want to use `(loop for x being the hash-keys of foo)`, then you should have to make all of `cl:loop`, `cl:for`, `cl:being`, `cl:the`, `cl:hash-keys` and `cl:of` visible in the current package. Whoever designed `loop` just wasn't "with it", in terms of treating symbols as atoms and respecting packaging concepts. Since those concepts are beautiful, and make Lisp attractive, that is a carnal sin.
[ITERATE](https://common-lisp.net/project/iterate/) looks nicer.
The keywords of \`loop\` macro don't need any package qualifiers, if you talk about Common Lisp. I guessed that you talked about \`cl\` package in Emacs Lisp?
&gt; Should I just suck it up and learn to use LOOP? Yes. &gt; Are there any alternatives y'all like better? Yes. Iterate. &gt; Am I being a whiny crybaby, or do you feel the same way? Both. Yes. 
[https://code.puercopop.com/advent-of-code.git/tree/2018](https://code.puercopop.com/advent-of-code.git/tree/2018)
On the other hand, iterate requires you to import every symbol it uses that you use, which doesn't go well with the modern style recommendation to never `:USE` packages that aren't `COMMON-LISP`. The alternatives are always having a package prefix or explicitly importing every symbol from iterate that you need. Neither are pleasant here.
[Here's mine](https://github.com/ntrocado/aoc2018). (Common Lisp)
Anyone thought about getting CL implementations to include Iterate by default?
Apparently there's also [FOR](http://quickdocs.org/for/). 
Except that tail call elimination is not guaranteed in CL.
I'm of the opinion that it's very lispy - I mean it's its own DSL for iteration, built, using Lisp. That said, it's part of the standard, and you should learn how to use it in order to understand other's code. There's also Iterate and Series.
Tail calls are not required to be optimized by Common Lisp implementations, this is not Scheme.
they are inspired to be optimized
On the contrary, I'm quite content with the built-in DSL of `LOOP` as I'm content with the built-in DSL of `FORMATTER` (`FORMAT`).
While I didn't "hate" it, when I first started learning Common Lisp all those years ago, I don't like LOOP as well. But after having learned how to use it, it grows on me, especially once you mastered its many advanced features. Like others have said in this thread, it is a DSL for iteration (which is very in spirit of Lisp), and a very powerful one at that. So much so that I now considered one of the lesser known (or appreciated) killer feature of Common Lisp that I really miss when I have to use other languages. So give it a chance, OP, it might surprise you (and at least you should know the basic of it because it's a part of the language and you'll regularly encounter it in other people code).
ASDF and therefore UIOP might be part of your distribution already. That doesn't mean it's in the ANSI standard of course.
The `LOOP` macro is one of the most important things of the CL language, because it brings all the power and beauty of the most important and elegant programming language in the world to Common Lisp. In fact i'm working for an extension to it, so `loop` also supports `PROCEDURE DIVISION`, `PIC(9999)`, `PERFORM`, `DISPLAY`, `ACCEPT`` and the others. I will name it `ADD 1 TO LISP GIVING IMPROVED-LISP`. 
Haha OK, will do. &gt;the most important, prolific, and elegant programming language in the world Which one is that?
&gt;Which one is that? It was a joke for the oldies, nevermind. Accept John McCarthy as your true savior and achieve salvation.
really `DO` and `DO*` are not used that much. In the past they were used much more. I do use `DOLIST` and `DOTIMES` alot. I won't use LOOP or ITERATE for simple things except use LOOP for a simple while loop since that is easier to read. I prefer ITERATE to LOOP. But what no one has mentioned here and what I really like to use are mapping functions (`MAPCAR`, `MAPCAN`, `MAPC`, `MAPL`, `MAPLIST`, `MAPHASH`, `MAPCON`) and the general purpose `MAP`. 
&gt;I was trying to implement some complicated string-matching algorithms If they resemble a state machine, then there's always `PROG` and `GO`. They are your friends, no matter what Niklaus Wirth says about **GOTO considered harmful** yadda yadda. 
Could you provide links to this "modern style recommendation"?
Some people discourage the use of use, but it is a stretch to call it the "modern style recomendation". 
Yes, there are quite a few. For example Scott Burson eschews loop in favor of their own generalized mapping construct. [https://github.com/slburson/misc-extensions/blob/master/src/gmap.lisp](https://github.com/slburson/misc-extensions/blob/master/src/gmap.lisp) What is weird is 'hating' \`loop\` and while embracing \`do\` 🤷. FWIW when I was learning CL I avoided the use of loop at all costs. After being told to suck it up and learn it I &lt;3 loop, sometimes a little to much, when a simple dolist would do.
Good to know that there's hope on the other side! &gt;What is weird is 'hating' `loop` and while embracing `do` 🤷. Yeah, do is pretty hard... But at least it looks like Lisp! That was my thought process, anyway. Now I'm thinking my Advent of Code goal will be to learn to use `loop` this year.
I think this is actually the best tutorial to method combinations I have ever seen, and the advent is only beginning. Total upvote.
&gt;Now I'm thinking my Advent of Code goal will be to learn to use loop this year. You'd be surprised how many problems can solved using only one loop \^\_\^ 
Do you want it printed at the REPL? Can you give an example of what you want?
I have these two functions: &amp;#x200B; (defun obj-plcm-state(obj) (cdddr (assoc obj \*objects-location\*))) &amp;#x200B; &amp;#x200B; (defun describe-objects () (labels ((describe-obj(obj) \`(you see a ,obj on the ,(object-placement obj) ,(obj-plcm-state obj) there.))) (apply #'append(mapcar #'describe-obj(objects-in))))) &amp;#x200B; I want to know if there is a way to make the list returned by the "obj-plcm-state" be displayind in that piece of text without parentheses.
&gt; I want to know if there is a way to make the list returned by the "obj-plcm-state" be displayind in that piece of text without parentheses. That is from the Land of Lisp tutorial, right? please try ` ,@(obj-plcm-state obj)` instead of ` ,(obj-plcm-state obj)`, this might do it. 
&gt; the "modern style recomendation". &gt;&gt; the modern style recommendation to never :USE packages that aren't COMMON-LISP I like it when very few packages are `USE`d: That way, i can easily see which library or package is contributing such function. I didn't know this was the *modern* way! 
I think Series is amazing. I use it all the time now. But loop is fine too. It's not going to make you weep for its sheer beauty but it does a number of useful things, and can do several of them at once. It's also a nice reminder not to be dogmatic about what's "Lispy" or not... have a preference, but be willing to get the job done above all else.
&gt; Anyone thought about getting CL implementations to include Iterate by default? To be honest, you can just *quickload* it; if there is something that has to be included in all CL implementations by default, it should be package-local nicknames. Currently only some implementations support this. 
&gt; I &lt;3 loop On a perfect world, this one would be a sticker on your laptop. 
Yes, I got the book in a bundle a year ago, but started a few weeks ago to learn. Is it a good book to learn from? And yes, it worked. Thanks a lot! :)
The FizzBuzz one was epic. And it actually teaches!!
That's a good point!
&gt; Is it a good book to learn from? It is a very fun book. Perhaps, for learning Common Lisp for "useful" tasks, Practical Common Lisp (book) is better. But LoL is surely unique. In real-life Lisp, for example, you would describe each room using strings, and instead of using a lot of `car`, `cdr` and `cdddr`, you would use plists (property lists) or even hash tables. But of course the goal of that tutorial is to force you to grow some hardcore list manipulation skills, which is never a bad idea. 
If you prefer ponderous didacticism to wit, you make prefer [this bizarre introduction to CLOS using method combinations](http://www.cawtech.demon.co.uk/clos/define-method-combination.html)
Thanks! I noted the other book and when I'll have the chance to get it I'll try it too. Yeah, but I'm not yet at strings, I'm at the end of chapter 5. There he especially wanted to not use strings, but to use lists and quasiquotes to generate small descriptions. I'll try Portacle, until now I was using GNU CLISP in combination with Atom to edit the code, and I was searching for a good environment for some time. 
CL-USER &gt; (format t "\~{\~a\~\^ \~}" '(one two three)) ONE TWO THREE &amp;#x200B; &amp;#x200B;
One example in a contemporary style guide is [the Google Common Lisp style guide](https://google.github.io/styleguide/lispguide.xml?showone=Packages#Packages), which says that almost every package should be designed to be used with an explicit package prefix unless it's a low-level (and probably internal to Google) module. In particular, &gt; Another good thing about packages is that your symbol names won't "collide" with the names of other packages, except the ones your packages "uses". So you have to stay away from symbols that are part of the Lisp implementation (since you always "use" that) and that are part of any other packages you "use", but otherwise you are free to make up your own names, even short ones, and not worry about some else having used the same name. You're isolated from each other. What's problematic about `ITERATE` is that it exports short and easy-to-conflict symbols like `FOR`, `AS`, `IN`, `NEXT`, and `SUM`.
I prefer Hello Kitty on my laptop, but that's just me ^_^
&gt; That way, i can easily see which library or package is contributing such function You can always jump to definition for that Using lots of packages also increases the change of a symbol conflict, but I don't like typing ^_^
I meant that the recommendation is common in modern CL styles, not that it is part of *the* modern style. Perhaps it would have been clearer to say something like "the recommendation in most modern CL styles". In other words, `(typep never-use-use 'modern-style-recommendation) =&gt; T` instead of `(get-style the-modern-style-recommendations :use) =&gt; ONLY-USE-CL`.
&gt; You can always jump to definition for that Yes, but what I mean is that I can easily see it by reading the code alone, without having to jump-to-definition. So, for example, i can easily see that the code used library `cl-foo`, `cl-bar`, `cl.baz` and `cl-quux` at certain parts of the code, without having to be previously acquainted with the symbols on said libraries. I'm glad this is the Modern Way^TM , as proposed by PuercoPop. 
&gt; I prefer Hello Kitty on my laptop, but that's just me _^ `Hello Kitty` is certainly an improvement over the trite `Hello World`. 
&gt; Someone else mentioned package-local-nicknames and it would really help solve problems like this because then you could use something really short like I as the nickname for ITERATE without breaking anything. Yep, that would be terrific.
If this is the correct answer for you, the question should be "how do I remove a level of nesting from a list", because that's what is going on here. Parentheses are only in the printed notation for lists; the list objects themselves don't have any parentheses. 
For even more fun, use `~:R` CL-USER&gt; (format t "~{~:R~^ ~}" '(1 2 3)) first second third
\&gt; I can easily see it by reading the code alone, I remember us having a similar conversation IRL, personally I can't imagine why I would like to read (explore would be a better term) a CL codebase like I would do on a dead language. \&gt; Uncle APL wants YOU!! I've been thinking of trying to do the AoC this year in APL or J. Unfortunately Dyalog in Linux calls xmodmap to setup the APL keyboard but in doing so it overides my own keyboard customization.
\&gt; I meant that the recommendation is common in modern CL styles, not that it is part of *the* modern style. My objection was with the common part. afaict there is a minority of users that follow such convention. Besides Beach I can't remember anyone off the top of my head.
&gt;I remember us having a similar conversation IRL, personally I can't imagine why I would like to read (explore would be a better term) a CL codebase like I would do on a dead language. It's true, and my opinions have changed since then. But in this case, I adopt the Modern Way^TM in my own code so I remember why I am using certain library. &gt;I've been thinking of trying to do the AoC this year in APL or J. Sounds awesome, really! 
If you're going to be "just quickloading" things, then what you really want in CL is this quickload thing that isn't in it now.
Note that the tokens in this expression language are passed straight to the assembler where they become assembler tokens. There are no symbols or numbers. If you use `eax` as a name, it looks like that will just become a register reference (and the expression processor isn't aware you're using that register). Or, if you write a function call like `(123)`, it seems like it will just try to call code at address 123. Basically it's a nested expression preprocessor for assembly language. Why on earth does it use Intel syntax; at least in AT&amp;T the `%` sigil on registers puts them in their own namespace. 
Thanks! :)
hey /u/DuckTheAlucard please subscribe to PewDiePie on youtube so that Tseries won't be number one. https://www.youtube.com/user/PewDiePie/featured
Oh, I see. Thanks for the clarification! 
A surprise, to be sure, but a welcome one! I'm already a 9yo :) But I'm glad to see that you do your part.
people don’t appreciate:( 
I'm sorry to hear that :(
Why hate? The CLHS [section](http://www.lispworks.com/documentation/HyperSpec/Body/06_a.htm) on LOOP is quite good (not so bureaucratically written), and along with [LOOP For Black Belts](http://www.gigamonkeys.com/book/loop-for-black-belts.html) provides quite a good help. In fact the advantage of LOOP is while it might be little bit hard to write it might be easier to read (at least for me). I've also found that a lot functions I've implemented could be just written with a single carefully crafted LOOP statement. &amp;#x200B;
If a successful game was developed with a combination of Lisp and C, and became popular, the people who play the game might not know or care what programming languages were used. 
Thanks for the follow-up. It's been a long time since I read that style guide. It's worth rereading. I understand your point but, in practice, I've never found it to be a problem. Perhaps it has to do with my personal programming style but I've used `ITERATE` for years without bumping into it. Some may frown on it but `SHADOW`ing provides a workable solution. For example, I have a library that defines functions `MAX` and `MIN`. It shadows the `CL` functions which are then called as `CL:MAX` and `CL:MIN`.
&gt; How many C++ games are there? Java? Flash? Javascript? c? And how many of those are worth playing? Probably fewer than 10,000. Focus on quality over quantity. *One* good and/or popular game in Lisp would be a success for Lisp games (and would probably lead to thousands of imitators). &gt; Many of the lisp "game engines" which are on the front page of google do not demonstrate the power of lisp, they are toys or demos. Game engines take a *long* time to make when they're made by one or two people in a language where few libraries in the relevant areas are available. (I'm surprised that `cl-opengl` exists at the level of quality that it's at.) I wouldn't expect something complete for another 5 years or more at the current pace. &gt; Difficult to install, difficult to run, difficult to mod, difficult to use Polish like this comes last, after core features are implemented. None of these frameworks and engines are even alphas. Nobody's going to write an installer until they write a game worth installing. &gt; Despite the proclaimed "power" of lisp, lisp games are less than 0.01 % of market share. *Market* share? You can safely add a lot more zeros before that 1. Remember, market share means actual share of the market. (User share might be a good alternative if you want to count $0 games that don't have aggressive monitization.) I could release a new Lisp game every hour and if no one plays them, that's not going to affect the market share. Again, quality over quantity. As for the "power", the "power" of a language doesn't matter that much if someone already wrote the library for you and did all the hard work, which is why C++ will probably remain the easiest language to write a game engine in for a long time. Sure, C++ is an ugly language, and the resulting APIs are ugly, but the work is already done in C++ and you can glue together a dozen libraries and skip a few years of development time. We don't write Lisp game engines or frameworks because it's easy, we write them because we love programming in Lisp. &gt; What could a successful Common Lisp game engine IDE look like? It's easy to list features. The hard part is putting in the many years required to implement those features. &gt; editor... replacing the arcane installation for emacs And now you've just added two more years to the task. I'd love to replace Emacs with something modern. So would hundreds of other Lispers. It's much harder than it seems. &gt; CEPL CEPL personally doesn't meet my requirements, and you'll see that a lot in the Lisp games community. There might be 6 different competing libraries by 6 different authors for something, but that's because they all have *very* different goals.
I don't know why my videos are being put under "poor editing". They're recordings of streams, of course it's going to be long, uncut, unfiltered content. That's the point. Editing content takes a lot of time too. Would you rather countless hours were spent editing videos rather than actually working on code? I *really* don't understand the complaint about ease of install. You're complaining about requiring to setup emacs and so forth, even though that's only required to *develop* the games. The same problem exists for every other game out there that's actually open source. You need a toolchain to develop, whether that's Visual Studio or whatever else makes no differenc. The actual games can and *are* also deployed as single executables that can simply be extracted and run. Finally I don't see any solution anywhere in the entry about how to deal with the supposed problem of things not being popular enough. There's a suggestion of what *other people* should be doing with *their time*, which is always a really cool thing to see.
So what? Whenever you try to program something in a non-mainstream programming language you have to spend more work because there are less things which can be reused. Most game engines are in C++, and reusing C++ from other languages is quite an effort (unless there is a decently complete an current C API). You could replace the language in the title arbitrarily, e.g. Ada, Pascal, Basic, and copy/paste the rest of the text.
I'm pretty sure TaleSpire is Baggers new job. I'm happy that you brought this to my attention, TechSnuffle used to be my daily read!
&gt;If you're going to be "just quickloading" things, then what you really want in CL is this quickload thing that isn't in it now. Well, in some sense, yes, but it doesn't need to be in the standard, really. 
Bit harsh to have a dig at u/Baggers. Talespire is his day job/passion, and the release deadline is coming. 
I really don't understand some of the criticism. I am not a game developer myself, but having been indirectly in charge of the game development part of a multimedia company (~ 10 game devs), i think i have some idea on what contributes to game dev and whatnot. Common Lisp would suceed as a game development platform if games that could be done on the leading game platform (which I assume C++ plus one of the game engines), can be done faster or more maintainable or less buggy in Lisp. Have we reached this point? I don't know, but it has nothing to do with number of games IMHO. Also, I don't understand the criticism of having to know how to use a REPL, quicklisp, etc: If i wanted to develop for C++, i would have to install an IDE, build tools, package manager, etc etc too. And Portacle already automates most of those installs. Not to mention having to grok C++, a difficult task itself, considering the many changes in the language and important libs coming in and out of fashion (i.e. Boost, STL). Perhaps a version of Portacle targeted for Windows and including graphics DLLs and packages would help? Maybe. But the real time that can be lost is on programming the game itself (including testing, debugging, and adding *and removing* features to the game). Not on installing the IDE and tools. This time lost includes adding and updating *resources* (maps, 3d models, textures, audio, etc). So, perhaps instead of focusing on whether the IDE is easy to install or the EXE easy to produce, perhaps one should focus more on if there is enough *tooling* to help not losing time on loading resources, etc. I see there's a Common Lisp Minecraft clone under progress, perhaps this one can be a very significant success story? 
Anyone got a list of Lisp games?
&gt; Talespire Interesting, what does it use on the backend?
Not sure if that code works, but that's what you did here anyway - defined bindings and used them later on.
By "without any bindings" I mean bindings downloaded from github or wherever. The point is to show that the script can stand alone, without anything downloaded, if the computer has sbcl and gtk installed. &amp;#x200B;
To see if it works, copy and paste it into a text file, save it, use chmod to make it executable, and invoke it by it's name, e.g. ./script or whatever. &amp;#x200B;
Do the older Naughty Dog games count? They built their own neat platform that was lispy. Then Sony bought them and told them they couldnt use it anymore. Then they snuck it in later as a 'config format' which eventually they could write AI in. 
Erlang, I presume
I don't want to seem pessimistic but Common Lisp is just not a good fit for games. Putting aside the small community and the rest of the issues others mentioned - that I fully agree with - there are technical reasons as to why CL is a bad fit for this domain. Without being a professional game developer, but having spent many years in the demoscene which has many parallels with the gamedev scene, I would say that the prime consideration when one is working on a game is to focus on the game itself and minimize time spent dealing with extraneous factors, by having a streamlined process from start to finish. It would appear that CL, given its emphasis on short feedback loops and flow state, would be ideal but the devil is in the details. It turns out that, practice, there are severe drawbacks that matter a lot more than the interactivity of the language. Here are some of them: + Unless you pay for Lispworks, Windows support is not "first-class". I know SBCL and CCL run on Windows but you are still dealing with non-Windows applications and have to do things in a way that is alien to most Windows users [Emacs/SLIME and so on]. Moreover, Windows support is not really critical for these implementations, more like an afterthought. Stas Boukarev (core SBCL developer) said he couldn't care less about Windows and I don't see the scarce resources of the CCL team prioritizing Windows either. Love it or hate it, Windows *IS* gaming on non-console platforms. + Quicklisp is nowhere near as good as Luarocks or PIP. It's centrally managed and slow to include updated libraries. Xach has to approve updates and do a release. With PIP or Luarocks, I can update my library and the update is immediately propagated to the central repository without someone else having to approve it. This means that if I want to collaborate with a team of people, we are all forced to use Quicklisp since it's been integrated into everything these days (before Quicklisp, people thought before introducing multiple dependencies, now we're slowing turning into Node.js since the 'cost' *appears* small) but also use something else to keep track of libraries that have frequent updates or bug fixes. Basically, I see Quicklisp as creating far more problems than it solves for non-hardcore Lispers. + Upfront effort required dwarfs that of other programming platforms. Lisp is not popular for a reason. It is iconoclastic, paradigm-shifting, cybernetic, programmable but it is not *easy to immediately digest* by the hordes of young people (= have a lot of time to burn) today. Yes, C++ is also not easy to digest but C++ has a vast, established userbase and it is the de-facto language in the big commercial game studios thus there are strong incentives for people to learn it, so this argument does not apply to it. Javascript, Python, Lua can be picked up in a few days but, most importantly, do not lead newcomers to a state of cognitive dissonance due to feeling 'alien'. I could teach a 10 year old the basics of Lisp in 20 minutes but most newcomers to Lisp with some programming experience are immediately put off by the superficially alien qualities of the language and do not put in the upfront effort required to get beyond that step. TL;DR Common Lisp is not [and probably will never be] a streamlined A-B-C experience when it comes to game development. Accept it and go use something else if you can't overcome the difficulties. 
TL;DR: You are mostly wrong. &amp;#x200B; Those are quite the claims. First of all, I'm thankful you put an effort into this comment, but I strongly disagree CL isn't suited for game development. Please, let me correct you on some points you have made: * SBCL's and CCL's Windows support is fine - there's nothing too special about using them in Windows. Support for OS isn't a priority for some implementors, but I haven't stumbled upon any particular problems so far. Also, there's totally nothing wrong with buying Lispworks either. Stas isn't the only person working on SBCL (not to lessen his contribution in any way). * Quicklisp has a repository system. You can have your own repository and updates to your software there would be propagated immediately or in any fasion you like. * Unfortunately, that's only partially correct, if at all. As an example, here's my story. Before last jam I organized a study group between coworkers to learn Common Lisp (well, part of it) so anyone willing can participate in the jam as a programmer. And you know what? Two non-programmers learned it just fine in one month and made a working Jam games themselves w/o much help from my side. I was astonished as how good they were, actually. Granted they didn't learn whole of CL in one month, but who cares? Common Lisp is not hard to learn at all. * I don't see anything wrong with high-level wrappers. Take a look at CEPL as a most known high-level graphics library. Simply put, it's just a high-level wrapper over OpenGL, but check out how it presents the interface. It has beautiful lisp interface. You would never imagined working with OpenGL would be that much fun. * Actually, CL promotes amazing attitude towards documentation having standardized ways to document code and work with it. It has documentation capabilities embedded into language standard, but programmers just being themselves.
+ Re: SBCL/CCL: You missed the larger point that these are not Windows look'n'feel applications. Lispworks is self-contained, has a unified interface. SBCL/CCL do not have anything remotely similar ergo they feel alien to Windows users and force them to deal with additional problems (which editor to use? does it support livecoding? do I need to spend time **learning the editor**?) + Re: Quicklisp, I am not sure what you mean here, are you telling me to use Git? That was my point. From the Quicklisp site: "To get updated software, use: (ql:update-dist "quicklisp") Software updates are usually available about once per month." I'm bypassing the rest of your answers as they're subjective and we probably need to agree to disagree. I am open to changing my views but I don't see anything there that would make me do so. 
I'm not trying to change your views. I'm just presenting those corrections to readers so they won't be misled by your comment. * Look'n'Feel applications? Did you mean GUI? That's totally unrelated to Common Lisp as a language. Games are totally doesn't care about native look and feel btw. Otherwise, CL application run in Windows just like any other ones by doubleclicking an .exe file. * I meant, \`ql-dist:install-dist\` facility to install custom repositories. No git or anything else required from users. &amp;#x200B;
* As for an editor, you just use the same editor as in Linux and MacOS, which can be Emacs, for example. Nothing Windows specific.
That's some lovely FUD and really just the same arguments presented for everything else to do with Lisp - no one uses it so how can it be good? - there's no games (usually libraries) in lisp - can't Google or YouTube search - I downloaded the sbcl source code lisp is too hard aaaaaaaaaaaaaa whats a portacle Also I think the jabs at various lispers are very rude and not good taste for an argument. 
Could you post this as a gitlab/github gist maybe ? (for better presentation and easier reference). Regards. (interesting stuff)
While not a lisp game (as far as I know), I can think of a well known game that used some lisp as part of its AI. Specifically, Age of Empires II used a lisp dialect for scripting the AI of computer players (but not the AI of individual units as far as I know). It was a very long time ago that I worked with it (you could write your own AIs and they even gave a rather interesting sample one) and thought it was strange looking at the time but in more recent years finally recognized it for what it was when looking at CL and Scheme - a lisp of some sort. I am sure there are numerous other games that used a lisp for some piece of it, though still a small percentage of the whole.
Just because nobody else said it: I *love* loop. It's actually what got me interested in CL in the first place: discovering loop in Emacs's cl library.
it's cool but it has an error
https://gist.github.com/bigos/93ea8d9fd6e7c6e6a6224e374f3a99de my edited gist
i guess bindings are easier to debug
&gt; I don't want to seem pessimistic but Common Lisp is just not a good &gt; fit for games. Hi! Common Lisp game engine author here! I think you're mistaken here and here's why. &gt; Without being a professional game developer, but having spent many &gt; years in the demoscene which has many parallels with the gamedev &gt; scene, I don't think that there are many parallels unless you're a game developer in the extreme niche that makes retro games for retro consoles. Sure, in the 1980s through to the mid-1990s (and a bit later for handhelds) games did amazing hacks to increase performance or reduce footprint on extremely limited devices, but we're simply not there anymore. Unless you're making a AAA graphics-heavy game or a heavily simulation-focused game like Dwarf Fortress or Factorio, you're not going to be pushing your platform anywhere near its limits. These days, you want code that's portable and reusable, just like any other area of mainstream software. (You're probably going to be using different, higher performance abstractions, though.) &gt; I would say that the prime consideration when one is working on a &gt; game is to focus on the game itself and minimize time spent dealing &gt; with extraneous factors, by having a streamlined process from start &gt; to finish. Yes, if you're making a game that isn't particularly remarkable in its design, then just use a pre-existing game engine and focus on making a game. That's generally accepted advice in gamedev communities. Making an engine is going to add years no matter what. I'm making an engine because it's fun, not because it's the maximally efficient use of my time. &gt; It would appear that CL, given its emphasis on short feedback loops &gt; and flow state, would be ideal but the devil is in the details. The only detail that matters is that there are major game engines or game frameworks for C++, C#, Java, Lua, etc., but none for Common Lisp. Using a library or framework or engine that's already written is going to lead to faster development times than writing one yourself, no matter how good the language is. &gt; Unless you pay for Lispworks, Windows support is not "first-class". This doesn't matter. You're not going to export to a typical Windows GUI application when you're deploying a game. You're going to be using a graphics API like OpenGL for the visuals and a game-oriented portability library like SDL to handle the windows and input. The far more important concerns are (1) do these libraries work and (2) is floating-point performance as good as it can be? For both of these questions, the answer is to use SBCL, at least until there's an implementation that has even better floating-point performance. &gt; I know SBCL and CCL run on Windows but you are still dealing with &gt; non-Windows applications and have to do things in a way that is &gt; alien to most Windows users [Emacs/SLIME and so on]. Again, this doesn't matter. Yes, GNU Emacs is terrible on Windows because GNU is a political organization that wants you to use GNU. Unfortunately, GNU Emacs is by far the best development experience for Common Lisp. This, however, applies to *developers*. I can develop on Linux and export to Windows just fine with an Emacs+SLIME+SBCL workflow. (And some people disagree with me here and somehow use Emacs on Windows without complaints.) &gt; Moreover, Windows support is not really critical for these &gt; implementations, more like an afterthought. But SBCL runs fine on Windows anyway. And if there are issues, then a successful enough game can finance the fix of those issues. &gt; Quicklisp is nowhere near as good as Luarocks or PIP. Quicklisp is way better than those imo, so this whole section is ultimately subjective. &gt; With PIP or Luarocks, I can update my library and the update is &gt; immediately propagated to the central repository without someone &gt; else having to approve it. NPM is like that, too. That's how you get the left-pad problem or, more recently, [this backdoor](https://news.ycombinator.com/item?id=18534392). Central curation is imo superior here, but the actual issue is that it doesn't scale. Eventually, Quicklisp will have to move on from its current model and that will be a sad day. If you have a problem with Quicklisp's update speed, just put recent git versions in `~/quicklisp/local-projects/` and it will override the Quicklisp version. This also will get you access to projects not currently in Quicklisp. &gt; Upfront effort required dwarfs that of other programming platforms. Even if this was true, this wouldn't impact Lisp *games* themselves. I could hand-write x86-64 assembly and sure it would be hard to get a functional game, but once it's done and shipped in an executable, the users probably wouldn't notice. &gt; Lisp is not popular for a reason. The reasons I'd give are network effects and very bad introductions to Lisp in university classes. &gt; It is iconoclastic, It predates all of the "icons" except Fortran. &gt; paradigm-shifting, cybernetic, Buzzwords. &gt; programmable That is true. &gt; but it is not easy to immediately digest by the hordes of young &gt; people (= have a lot of time to burn) today. Good. Let the hordes write their left-pads for JavaScript. Game engine development is extremely difficult and none of their contributions would be useful here. &gt; Yes, C++ is also not easy to digest but C++ has a vast, established &gt; userbase and it is the de-facto language in the big commercial game &gt; studios thus there are strong incentives for people to learn it Exactly. Network effects drive people to C++ for games. It doesn't matter if we're talking about Common Lisp or Rust or Pascal or Java games (all of which have implementations with high enough performance for game engines). Your earlier criticisms of Lisp are irrelevant and C++'s massive network effects matters much more. &gt; Javascript, Python, Lua can be picked up in a few days But they take a lifetime to master, just like any other language. There are lots of quirks and edge cases anywhere. Also, Python is absolutely terrible for gamedev because its main implementation has horrible performance. I use SBCL because it has acceptable performance, probably only being a 3x to 5x performance loss over C in extreme cases. SBCL even beats JavaScript and Lua in performance so it's a more suitable language for an entirely-in-one-language solution. &gt; but, most importantly, do not lead newcomers to a state of cognitive &gt; dissonance due to feeling 'alien'. Lispers should stop saying that Common Lisp is some magical, alien language. It's just like any other language, except that it makes metaprogramming and other forms of non-runtime execution trivial. The cognitive barrier is passed once the newcomer realizes that Lisp is *not* magically significantly different from other languages. If you *actually* want to think very differently, program in Haskell with its pure-and-lazy functional programming. &gt; Look at most CL game-related libraries and what do you see? They &gt; look like they're simply wrappers around "foreign" code, the only &gt; benefit being that you can use that code in Lisp. That's because those libraries are already written so the people who write wrappers get their work done faster than the people writing the solutions in pure CL. *Eventually* the slower pure CL approach will catch up. &gt; Even in the few cases where we are talking about 100% CL libraries, &gt; they look like they could have been written in C. I can't remember &gt; the last time I saw something novel or even remotely Lispy in a &gt; game-related Lisp library. Because you start with the low-level, C-style abstractions for performance and then you build Lispier abstractions *on top* of that and most people haven't gotten to that latter point yet because Lisp game development is still in its early stages. Even when you write C-style code in Lisp you still get bounds checking, Pascal-style arrays with size information attached to their type, the lack of surprising undefined behavior, garbage collection (often seen as a downside in gamedev, but it can easily be worked around when necessary), type safety, the lack of a problematic `NULL` (`NIL` in CL is really just false and the empty list and not a true `NULL`), etc. I'll gladly take a 3x performance hit over C (mainly due to the lack of commercial interest in improving CL implementations' performance, *not* due to an inherent language trait) to have safety. The only *necessary* performance loss is with the garbage collection, but real-time garbage collectors exist and, again, the only reason we don't see that for CL is the lack of major commercial interest, not a flaw in the language. Also, I find it strange how you criticize Lisp for being *different* and then you criticize Lisp libraries for **not** being so different after all. Perhaps you have a mistaken impression of what production Common Lisp code is supposed to look like? &gt; If all you are doing is writing C/C++/Java in Lisp, why do it in &gt; Lisp to begin with? Interactivity one might say. Well, that's why &gt; you have scripting these days. Interactivity in the high performance implementation language instead of mixing a high-performance non-interactive language with a low-to-mid-performance scripting language is a huge win. Also, CL is orders of magnitude more interactive than Lua, which is the most common scripting language that's paired with C++ for gamedev. &gt; CL promotes a casual attitude about documentation and code quality &gt; by being interactive and having a tight feedback loop. No. You get good documentation when you have a large community with lots of commercial users. CL doesn't have that, so that's why the documentation is usually poor.
&gt; Do the older Naughty Dog games count? I would distinguish between Lisp-for-scripting like in those games and Lisp as an engine implementation language. In the latter, you're probably still going to be using Lisp for scripting (because why not?), but in the former, most of the heavy lifting will probably be done by C or C++.
&gt; Also I think the jabs at various lispers are very rude and not good taste for an argument. What I learned from that is that I need to have some SEO so I can get insulted, too.
Do you mean it has a bug? Or do you mean you noticed a typo in the code? If it's a bug, when does it happen?
You're missing the elephant in the room. These are extra hoops that people (= game developers) have to jump through. Thus, Common Lisp not being a good fit for games. Thus, they prefer easier-to-get-started-with-immediately alternatives. Nothing of what you said disproves any of my points. It's like you're grasping at straws to tell me that Common Lisp can work, for you, and others who are hardcore Lispers, but that's totally irrelevant in terms of general fitness for games. 
&gt; You missed the main point that these are not Windows look'n'feel applications. Games aren't Windows look-and-feel, either. They use a portability library like SDL, GLFW, or SFML and a graphics API like OpenGL or Vulkan. When they have GUIs, they build their own on top of that pair of libraries. Imo, a game engine IDE should probably be written in the game engine itself, with a graphically-accelerated UI on top of OpenGL or Vulkan, sort of like how Blender's UI works. Your criticism applies to just about every graphical application **except** for games.
Their initial one with all their older games is through and through their system called [GOAL](https://en.wikipedia.org/wiki/Game_Oriented_Assembly_Lisp). It compiles down to Ps2 assembly language, you can mix and match lisp and assembly together. From what Ive been told (I worked for a rival game company at the time, but there was lots of crosstalk), it was more like an intermediate language that would then compile to one of 2 backends. So you only had to learn 1 language to get down to (near) the metal. I do know it had a REPL while the game was running and you could freely add and remove stuff at runtime. All pretty neat stuff. Even when I dont get to work in a system like that, I try to add similar features to whatever Im working on. My current stuff is in C#, but uses Roslyn and reflection to build things at runtime. I use reflection to walk the source, then roslyn to generate new code and compile it. 
I disagree. I think a negative blog post with a clickbait title shows that Lisp gamedev is slowly starting to become mainstream, which is a good thing. Popular things on the Internet can't avoid negativity like this.
Exactly. The only thing that matters for the end user as far as language choice goes is if it restricts which platforms you can deploy on. Unfortunately, Common Lisp will do that at the moment. Don't make a Lisp game if your focus is mobile or console. Users won't notice what language you use, but they will notice if the game is not on their favorite platform.
&gt; I see there's a Common Lisp Minecraft clone under progress, perhaps this one can be a very significant success story? I wouldn't get my hopes up there. Successful games tend to take one small element from Minecraft and do a much better job in that area than Minecraft did, such as Factorio's superior handling of belt-and-circuit logistics. The closest successful games to Minecraft would be Terraria and Starbound, but they're 2D, not 3D, and aren't *that* similar.
Exactly. Pretty much [any language here](https://benchmarksgame-team.pages.debian.net/benchmarksgame/download/fast-programs-different-programming-languages.svg) that's not C/C++ has good enough performance to be a game engine implementation language, but will have similar issues when interfacing with C++ libraries. Common Lisp's problem here is not any different than Ada's.
&gt; I don't think that there are many parallels unless you're a game developer in the extreme niche that makes retro games for retro consoles. Sure, in the 1980s through to the mid-1990s (and a bit later for handhelds) games did amazing hacks to increase performance or reduce footprint on extremely limited devices, but we're simply not there anymore. I mentioned the demoscene and the parallels I had in mind are working in a team with other people, trying to create a complete product that stands on its own. Nothing to do with performance hacks or footprint. Lots of demos are solely geared towards artistic expression without emphasis on performance or size. &gt; The only detail that matters is that there are major game engines or game frameworks for C++, C#, Java, Lua, etc., but none for Common Lisp. Using a library or framework or engine that's already written is going to lead to faster development times than writing one yourself, no matter how good the language is. Yes, no major game engines or frameworks for Common Lisp. Why do you think that is? Size of the community is clearly not the only (or most important) factor. &gt;&gt; Unless you pay for Lispworks, Windows support is not "first-class". &gt; This doesn't matter. You're not going to export to a typical Windows GUI application when you're deploying a game. You're going to be using a graphics API like OpenGL for the visuals and a game-oriented portability library like SDL to handle the windows and input. The points I brought up here may not matter to you but they clearly matter *to the vast majority of game developers*. That is why they are not using Common Lisp! I am not just assuming and projecting here but aggregating new user questions and problems that come up time and time again. &gt; NPM is like that, too. That's how you get the left-pad problem or, more recently, this backdoor. Central curation is imo superior here, but the actual issue is that it doesn't scale. Eventually, Quicklisp will have to move on from its current model and that will be a sad day. You don't need central curation to have security. You should look deeper into Quicklisp if you think it buys you anything on that front. On the contrary, it's probably getting you owned: https://old.reddit.com/r/lisp/comments/87cf2o/a_new_package_manager_for_chez_scheme/dwc82wg/ https://github.com/quicklisp/quicklisp-projects/issues/1128 &gt; If you have a problem with Quicklisp's update speed, just put recent git versions in ~/quicklisp/local-projects/ and it will override the Quicklisp version. This also will get you access to projects not currently in Quicklisp. &gt; The reasons I'd give are network effects and very bad introductions to Lisp in university classes. Right. Lua went from absolute 0 to being widely used in industry and for indy games. None of these were a factor. &gt;&gt; It is iconoclastic, &gt; It predates all of the "icons" except Fortran It's still iconoclastic *today* given what has come out. Exactly like Smalltalk. Sad state of affairs. &gt; Good. Let the hordes write their left-pads for JavaScript. Game engine development is extremely difficult and none of their contributions would be useful here. It is the hordes that create ecosystems and communities. &gt; Exactly. Network effects drive people to C++ for games. It doesn't matter if we're talking about Common Lisp or Rust or Pascal or Java games (all of which have implementations with high enough performance for game engines). Your earlier criticisms of Lisp are irrelevant and C++'s massive network effects matters much more. C++ network effects are not a factor in other widely-used languages for gamedev. Why should it be a big factor for CL? &gt;&gt; Javascript, Python, Lua can be picked up in a few days &gt; But they take a lifetime to master, just like any other language. There are lots of quirks and edge cases anywhere. &gt; Also, Python is absolutely terrible for gamedev because its main implementation has horrible performance. I use SBCL because it has acceptable performance, probably only being a 3x to 5x performance loss over C in extreme cases. SBCL even beats JavaScript and Lua in performance so it's a more suitable language for an entirely-in-one-language solution. Performance that would disqualify Python is not a factor in the vast majority of indy games. Luajit of course gets you SBCL-or-better level performance most of the time, without the headaches. &gt; Lispers should stop saying that Common Lisp is some magical, alien language. It's just like any other language, except that it makes metaprogramming and other forms of non-runtime execution trivial. The cognitive barrier is passed once the newcomer realizes that Lisp is not magically significantly different from other languages. If you don't think that superficial factors like syntax and familiarity reign supreme when it comes to how popular a programming language becomes, I have news for you. Common Lisp is already handicapped on that front, but it gets worse since it goes ahead and introduces several additional handicaps (see my original post). &gt; Interactivity in the high performance implementation language instead of mixing a high-performance non-interactive language with a low-to-mid-performance scripting language is a huge win. Also, CL is orders of magnitude more interactive than Lua, which is the most common scripting language that's paired with C++ for gamedev. My original point was exactly that "orders of magnitude more interactive than XXX" does not matter as much as Lispers think it does, in practice. Nothing of what you said has made me change my views on that. 
Well, it's hard to come up with some new successful game concept AND develop it alone in CL, I suppose. 
&gt;Quicklisp is nowhere near as good as Luarocks or PIP. In my opinion, QL is better than PIP. &gt;This means that if I want to collaborate with a team of people You don't need QL for that. Or, place your projecr in the QL directory for the local projects, which is named... **local-projects** &gt;Look at the abysmal state of most CL libraries today when it comes to documentation / code quality. In those cases I often can understand everything i need by looking at the code. In C++ and Java i would need the documentation, because often the mear of the code is spread over a thousand classes and hidden behind a lot of design patterns' boilerplate. Lisp is more explicit and elegant. &gt;CL promotes a casual attitude about documentation What about documentation strings ? They are in the standard. What about named (keyword) parameters? They're in the standard and until very recently, only a few of languages support that. &gt;Yes, C++ is also not easy to digest but Understatement of the month. I know C++98, but I wouldn't dare to do modern C++ development. The learning curve is too high, C++ has passed through many phases and one needs to know all of them to understand others' codebases. 
&gt; Anyone got a list of Lisp games? For what it's worth, the classic Sierra games (Leisure Suit Larry, King Quest, Police Quest, Space Quest) used AGI (adventure game interpreter), an engine where the game logic itself was coded in a s-expression language. 
&gt; Re: SBCL/CCL: You missed the main point that these are not Windows look'n'feel applications. What does that mean?! They are not graphical UI applications! &gt;SBCL/CCL do not have anything remotely similar ergo they feel alien to Windows users and force them to deal with additional problems (which editor to use? does it support livecoding?) What does a compiler/implementation has to do with an editor? BTW I use Emacs in Windows without any problem. Any programmer that is unable to learn or use Emacs (a text editor) would immediately get marked from deletion from my team. I mean, programming is a far more complicated job than learning a new editor. 
&gt; Yes, no major game engines or frameworks for Common Lisp. Why do you &gt; think that is? Size of the community is clearly not the only (or &gt; most important) factor. Because of how its type system works, Common Lisp has issues with 32-bit performance that aren't an issue with 64-bit implementations. For example, in 32-bit implementations, the fixnum (efficient, machine-native integer) size is tiny and the single-floats (one of the most common types in gamedev) are boxed (heap allocated with a type tag) unless handled with extreme care. These are not issues with modern 64-bit implementations, but games have only recently been 64-bit-exclusive. &gt; I am not just assuming and projecting here but aggregating new user &gt; questions and problems [with the development environment] that come &gt; up time and time again. It's unfortunate that GNU Emacs is the only serious option available for Common Lisp development and it does add a significant barrier, but my project is to make a game engine, not replace GNU Emacs. As I said in another thread, replacing GNU Emacs will add (at least) two years to an already massive, multi-year project. &gt; You should look deeper into Quicklisp if you think it buys you &gt; anything on that front. On the contrary, it's probably getting you &gt; owned: Not yet. Security by obscurity. That is problematic, though. &gt; Right. Lua went from absolute 0 to being widely used in industry and &gt; for indy games. Many years ago, I was following the team behind the open source game [The Battle for Wesnoth](http://wesnoth.org/) around the time when they added Lua as a scripting language. This was back when Lua was first becoming popular for gamedev. They were essentially forced into using Lua for scripting because of its sandboxing capabilities. They originally wanted to use Python, but it had security issues when used in user-uploaded add-ons. Commercial games probably had similar considerations at the time. Civilization IV used Python for scripting, but Civilization V switched to Lua. As far as I can tell, nothing has changed. You still have lightweight Lua and heavyweight JavaScript as essentially your only sandboxable scripting options. Most game engines will either choose Lua or their own proprietary scripting system. This is actually one of the key reasons why I think Common Lisp would shine more as a game implementation language like C++, C#, or Java and *not* as an embedded scripting language like Lua. &gt; It's still iconoclastic *today* given what has come out. Exactly &gt; like Smalltalk. Sad state of affairs. That's imo subjective. &gt; It is the hordes that create ecosystems and communities. All you need is one popular game to have a Lisp game community. The rest will follow. Modders won't care what language you use. Wesnoth uses [this absolute dumpster fire of a language called WML in addition to Lua (and originally exclusively)](https://wiki.wesnoth.org/ReferenceWML), but I and many others used it. For a more popular modding scene, you can look at [QuakeC](https://en.wikipedia.org/wiki/QuakeC). (And I personally think Lua is a terrible language, too, but every time I bring that up, I lose the rest of my day arguing that.) And, of course, a popular Lisp game wouldn't just lead to modders for that game, it would also lead to other people copying the choice of language when making a game, especially if the original game's engine or framework is available. Imo, community follows from success stories. You can't create it without first having a success. &gt; C++ network effects is not a factor in other widely-used languages &gt; for gamedev. Why should it be a big factor for CL? You're mistaken here. Everyone uses C++ for gamedev because everyone uses C++ for gamedev. The only bigger network effects in programming niches are probably C for embedded or JavaScript for browser scripting. The two main alternatives are C# and Lua, but C# is primarily used for Unity scripting and Lua is primarily used as the scripting language for engines or frameworks primarily written in C++. &gt; Luajit of course gets you SBCL-or-better level performance most of &gt; the time, without the headaches. That is incredibly debatable. LuaJIT says it has awesome performance with carefully selected microbenchmarks. Would it still work like that for a large game engine? For a large game engine, I want static types. Even though CL is normally dynamically typed, SBCL has very good support for type declarations. This way, large portions of my game engine are effectively statically typed. LuaJIT primarily works through magically reinterpreting the language's one main data structure, tables. That sounds like a maintenance nightmare to me, where very small changes could destroy performance and coding standards would have to be put in place to enforce everything. I want to work with many different data structures explicitly. Even if LuaJIT had comparable or slightly better performance, it's just not designed properly for large applications. Lua is for scripting. &gt; If you don't think that superficial factors like syntax Syntax is a key part in how CL gets the trivial non-runtime execution, so it's actually a consideration I took into account. &gt; My original point was exactly that "orders of magnitude more &gt; interactive than XXX" does not matter as much as Lispers think it &gt; does, in practice. Nothing of what you said has made me change my &gt; views on that. Okay, it doesn't matter for you, but it makes me about twice as productive as when I use other languages (and I know quite a few). I guess Lisp really is a secret weapon, after all.
**QuakeC** QuakeC is an interpreted language developed in 1996 by John Carmack of id Software to program parts of the video game Quake. Using QuakeC, a programmer is able to customize Quake to great extents by adding weapons, changing game logic and physics, and programming complex scenarios. It can be used to control many aspects of the game itself, such as parts of the AI, triggers, or changes in the level. The Quake engine was the only game engine to use QuakeC. Following engines used DLL game modules for customization written in C and C++ from id Tech 4 on. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/lisp/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
&gt; These are extra hoops that people (= game developers) I consider game developers very intelligent people, near the top echelon of the programming skill ladder. All the "hoops" you mention, imaginary ones notwithstanding, are simple tasks for them in my opinion. Here we disagree; you seem to consider game developers as some sort of HTML/CSS bootcampers. 
&gt; And some people disagree with me here and somehow use Emacs on Windows without complaints. Me! me!!
Add: - I don't like Emacs. I need an IDE that uses 4GB of my ram!!
Excellent post. &gt; Editing content takes a lot of time too. Would you rather countless hours were spent editing videos rather than actually working on code? I think a lot of people don't understand just how much time goes into a 5 to 10 minute YouTube video. I'll give a hint: it's not 5 to 10 minutes of work. &gt; I *really* don't understand the complaint about ease of install. Yes, but [you know about Portacle](https://github.com/portacle/portacle/graphs/contributors). &gt; The actual games can and *are* also deployed as single executables that can simply be extracted and run. Great point. Two things are being conflated: Lisp games and Lisp game development. They're different, and game development is a hard task in any language. &gt; There's a suggestion of what *other people* should be doing with *their time*, which is always a really cool thing to see. Yes. And it's not like ideas are hard to come up with. What's hard is dedicating enough time to execute on those ideas. Most of us have been working on these projects for *years*.
I think there's a whole spectrum of game developers. Those who just want to quickly do something cool as fast as possible, quick and dirty. And those who sink tons of time into sampling any and all frameworks, engines, IDEs etc, to get the best of the best to work with. And I think both extremes are needed for a community to thrive. I belive the CL community have an abundence (sp?) of the latter but perhaps are seeing an increase in numbers of the former. Time will tell.
&gt; The language itself lends to very explicit coding, even if there are no comments. Exactly. It's common to see small, trivial, easy-to-understand functions with very descriptive names. And unlike in Java-style OOP, it's not unnecessarily small, trivial boilerplate scattered across a hundred files. Something complicated enough to need lots of comments is practically a code smell in Common Lisp unless it's a very tricky algorithm. That being said, actually documenting those functions with docstrings is not as common as it should be. &gt; The only reason the better, direct competitors to C++ (Object Pascal, Ada, D) are not as popular is that those were usually available only through commercial compilers. So the C++ codebase is huge compared to their ecosystems. You can add Common Lisp to that list. SBCL, CCL, and ECL are all nice implementations *now*, and SBCL can be good enough in performance even where you'd normally use C++, but in the 1990s, your main competitive choices would have been commercial (and the overhead of CL would have mattered more).
The people who just want to get started as quickly as possible will use whatever the most popular game engine is at the moment because it has all of the resources and tutorials. At the moment, that's Unity (or Unreal) for most tasks. Competing for that crowd would probably cost at least several million dollars. (I mean, I'd take the money if you offered it.)
The elephant in the room exists because CL is 1) not mainstream 2) because of 1) not actively pushed forward by any major commercial force, at least not in the gaming scene (AFAIK). And still there are some truly great and awesome projects out there (sbcl, quicklisp, slime/sly) with killer features. The accessibility level of any such project/feature depends greatly on how the community as a whole shape the tools used to access them. There's alot of stuff happening right now in that area, and it is up to us few brave who stick to the non mainstream lisp community to make it better! Finally, I do understand the frustration that is being seen in the blog post. But please keep in mind that the lisp community has, and perhaps always will, suffered from being the "odd and weird" language you never hear about in mainstream media, which will affect progress speed of course. But the more we are, the faster and stronger we get.
A fair point. It is more of a "packaging" issue and how to access the tools needed that is the issue. At the end of the day, it is really a matter of connecting the dots (assets, api calls, etc) and of course, having big companies with funds really helps to get a polished interface to get you flying right away (and later crash hard?). I think I lost my thread of thinking here... Maybe there's more harm than good to compete for that crowd? Maybe we need more of the people from middle of the spectrum?
Finally! This guy gets it. Have my upvote!
\[Blatant self-promotion\] We're developing [Spycursion](https://defungames.com/tag/spycursion), client and server, in CL.
If I had such needs, I'd probably use the GTK-server.
Seem it is Lua. Look at this video on Youtube: https://www.youtube.com/watch?v=n0-aj_sTWQ0
Or maybe I wrong and Lua is used only for a game engine scripting on the "frontend".
Why? What problem with doing it this way, would be solved by using the Gtk-server instead?
Does that imply you tried to debug this? What specific bug did you try to debug? What are the symptoms and under what conditions does it happen?
Using Gtk with minimum amount of extra code?
If you mean the define-alien-routine lines, those only have to be there once per Gtk function. Then you can use Gtk extensively without putting those lines there again. And you can shorten them with macros, especially if you're going to use a lot of them, for a lot of Gtk functions. &amp;#x200B;
C has also a very simple structure and plain syntax: 1 + 2 'the rest is a little detail' 
Does a Clojure game count? [Gameplay](https://youtube.com/watch?v=668-wLWd9JA) -- Bounce Away used clojure on top of libgdx. Unfortunately it seems to no longer be on the android marketplace (though I did find it released over [here](https://www.getjar.com/categories/all-games/action-games/Bounce-Away-v7-645024 ) still), and doubly unfortunately like most fun games was never released as open source (the author did post a [skeleton project](https://github.com/thomas-villagers/clojurelibgdx) at least that might have helped someone).
That's one approach, and you might actually be able to rip function definitions from a GTK-server tarball and use them as data for generating all corresponding functions. I actually had that in mind for some time, I just never got around to doing that. Alternatively GTK-server can be loaded as library and used directly, without having to explicitly define all the functions you need. (Unless I remember it wrong...)
Yikes. Wouldn't it be possible to use something similar to https://github.com/zserge/webview ? I'm considering doing an HTML5-based UI for an application without having to make it a web application but it's headed in the exactly opposite direction, with having a single process. I was just going to take a look at how Next does it and now it seems it's heading in the direction that I don't need at all. Oh, well...
The answer to your question is basically, no, it wouldn't be possible. If you read through the technical article, you'll see why. There is a lot of thought in the design, especially the fact that it can be daemonized. For example, you could connect to a remote running instance and fire up all the open work you had on another machine. There are also other specializations that we have done in the port/core interface to accommodate Lisp specifically, it is quite different than distributing some electron app :D &amp;#x200B; If you are going in a different direction, might I suggest instead cltk [http://marijnhaverbeke.nl/cl-tk/](http://marijnhaverbeke.nl/cl-tk/) much more lightweight. For an application that is not a web browser, you don't need a web browser. Something like TK should more than suffice.
ruby\_object posted it and gave the link in another message in this thread.
I've considered Tk. Both would basically equally provide me with "classical" widgets and some "free-form" drawing with interactivity (Tk canvas, HTML5 SVG). But one thing I see as probably better with HTML5 is that I should be able to handle interactions on HTML5's side with Parenscript code. For some heavier things, this would probably be more performant that handling stuff on Lisp side with doing large numbers of callbacks. I was going to look into Tk anyway, but having a lightweight webview option still seems desirable.
\&gt; without having to explicitly define all the functions you need If it's an interpreter does it imply you give it text to interpret as code? Is that more convenient than defining the functions?
Most Lisp implementations will probably be more performant than any JS engine, but of course the choice is yours :) best of luck with your project!
What is an interpreter?
It's not about the language implementation performance but rather about the communication and data passing overhead.
I don't know why people are downvoting your posts. I upvoted all of them, because at least you were making an attempt to be helpful, unlike the anonymous drive-by downvoters shooting up the neighborhood out of boredom.
using domain sockets means the IPC will be as fast as writing to memory, you shouldn't have a problem
&gt; using domain sockets means the IPC will be as fast as writing to memory How is that? FWIW, I'm not saying you're wrong. I just don't understand how you're right. 
My understanding is that Blink goes as far as to move DOM manipulation into Javascript code because even the in-memory Javascript/C++ interface with C++ DOM functions was deemed insufficiently performant. I don't even want to imagine how those people would react to simply interactivity having to go through any kind of sockets.
I wish it was finally available for Windows.
in a domain socket you are communicating via a file handle descriptor, this can be implemented however the OS sees fit, but my understanding is usually that this is done in memory, think of something like fcgi that uses a unix domain socket with some sort of server in front as a reverse proxy, the bottleneck is almost never the transport layer between those two processes
I'm sorry, but to be frank this is a discussion I don't want to have. I wasn't there when the blink team made that decision, in fact probably nobody outside of some people at google were because it is a mockery of a "community" project, much like android.
Hi, I am sorry to disappoint! Luckily though, writing a windows port shouldn't be too hard, if you are familiar with C#, or C++, we can talk and make a windows port together!
It's not a Blink-specific issue, though. Just one concrete example of it. The politics on that one concrete example seems immaterial to the fact that people generally want to avoid marshalling and higher-latency communication.
I tried this about a month ago, and I see recent work on github - I will kick the tires again.
I consider myself to be relatively fluent in both (although I prefer C++ a lot - or, even better, C). :-) What do you need?
Best of luck, but please be gentle :) still alpha!
An interpreter executes code directly instead of compiling it first.
I'm very glad to hear that! C++ is fine, are you familiar with QT? If you read through this article, it should give you a gist of what we are doing: https://next.atlas.engineer/article/technical-design.org On a a very high level, basically what you would need to do is write a C++ application that can do the following: Listen and respond to XML-RPC requests to: 1. make a window 2. make a web view 3. swap web views in windows Send XML-RPC requests to a Lisp program: 1. When a key is pressed ------------------------------------------- + An example of a C (GTK) port can be seen here: https://github.com/atlas-engineer/next/tree/master/ports/gtk-webkit + A look at the complete API can be seen in one file https://github.com/atlas-engineer/next/blob/master/source/remote.lisp I know it is a source file and not a technical document, but it is a start. If this is interesting to you, /u/ambrevar and I can write a more technical document detailing exactly what the API on the port side (the C/C++ code). It could be very cool to both bring Blink AND Windows AND QT support to the project with one port! 
I didn't ask what an interpreter does, but what did the "it" in the clause "If **it**'s an interpreter" refer to.
I get an error 504 on next.atlas.engineer. I have played with Qt 4 a while ago, but I found it quite annoying. Is WebKit a fixed dependency or would other browser engines work as well? I wonder if [IUP](http://webserver2.tecgraf.puc-rio.br/iup/) could work which uses [the Internet Explorer](http://webserver2.tecgraf.puc-rio.br/iup/en/ctrl/iupweb.html) on Windows.
Hi, sorry about the 504, it seems to be working again, the website is getting pummeled :D WebKit is not a fixed dependency, any browser engine would work!
That sounds like a quite interesting project then. :-)
Many thanks for this, this is exactly what I was looking for (a way to make a UI self contained in an editable, non-binary, file or files). One small thing: The window shows up, and it has the correct title. But when I move the mouse cursor over the contents of the window, it crashes and I get: arithmetic error DIVISION-BY-ZERO signalled with a long stack trace. I'm using SBCL 1.3.14 in Kubuntu 17.10 which is 64-bit. Again, many thanks for this!
&gt;I wish it was finally available for Windows. Me too!! Don't forget about us, trapped in the corporate world! :( Remember, Common Lisp was born within the industry... 
I'm positive that Apple products are more common in the industry than Microsoft products are.
Gtk-server. How do you give it commands? Does it interpret those commands?
This is the most helpful answer yet. Someone who actually ran the script and reported the results. &amp;#x200B; Does anyone have any suggestions on how to debug that mouse-movement bug? &amp;#x200B; &amp;#x200B;
It routes the calls to an FFI library. It's not all that dissimilar from URL routing in web frameworks.
You seem to be implying Gtk-server is a Lisp program. And that it uses FFI to call Gtk functions. But I thought it was more like Tk/Tcl.
No, it's a program that allows you to call Gtk functions without having to use C calling conventions. To call those functions, you can use a pipe, a named pipe, TCP or UDP communication. It's definitely not like Tcl/Tk because it implements no language.
Just in case the Gtk version makes any difference: &amp;#x200B; sum /usr/lib/x86\_64-linux-gnu/libgtk-3.so.0 &amp;#x200B; 28995 7227 &amp;#x200B;
Ambitious project, the only kind of project worth building ;) It looks great, good luck and keep up the great work! I will give it a shot once there is a Windows port :P By the way, I know it's not a priority right now, and won't be for a while, but a few little changes in the website design would make it much more appealing. Eg: * Using a pretty webfont from Google fonts or even [Adobe Fonts](https://fonts.adobe.com/) (theorically it allows for unlimited usage) * The usage of serif or headings and sans-serif for body is great, you should keep that up * Add some more spacing, especially in the blog, it feels quite cluttered, too much info per page * The vertical rythm of the page feels weird, a little more of line-height for the paragraphs should do it (1.25-1.5 is the average) * The easiest way to make the website look nice when it comes to colors is pick a single color and use it for everything, in different tones (I like the way [Svbtle](https://svbtle.com/) does it), so for example, all links would be of this color instead of the default blue, also use it in the homepage, you don't need to change much, just maybe add it to a single call-to-action button, like the "DOWNLOAD" button I am no designer but those are just some typography and color theory 101 tips. Cheers! &amp;#x200B;
Hi, firstly, thank you for the kind words! We use the fonts that come on your own machine, if you don't have Helvetica, then it won't show that, but I believe it should be trying to show that. Maybe we'll find some other cool monospaced font or something :D Yeah, you are quite right about the spacing. It does need tweaking. I'm not sure exactly how to space things, but I will work on it. Maybe it does need more space as you suggest. A Windows port may come in the future, register to vote, and if enough people vote for a Windows port, maybe that's what we'll do (you can register on the download page: https://next.atlas.engineer/download)! Once again, thank you for the kind words and the tips, I'll keep them in mind! 
Glad to hear about the port :P I registered there. As for the fonts, the thing about system fonts is that they give little personality to the website. While that's okay for, say, body text, ideally at least titles should have some personality. Also, now that I look at the fonts, sans-serif is associated with "modern" stuff, I noticed all major browser sites (Firefox, Chrome, Opera, Safari) use sans-serif for everything, and only change the font-weight, so maybe something like "Open Sans" or "Adobe Source" would work fine. Aaaaaanyways, I wouldn't worry about it at this stage of the project :P If you want to learn more about Typography, [this is a great free book](https://practicaltypography.com/) written by [a fellow Lisp enthusiast](https://practicaltypography.com/why-racket-why-lisp.html). Cheers!
Indeed, there are bigger fish to fry, as they say. Not sure what they mean by that, as I've never fried fish, but alas. Thanks for all the fish and so long! :)
Cool. What troubles did you run into with CL-CFFI-GTK?
Well, many honestly, I don't want to go into it, but segfaults frequently, strange error messages, a complicated build process. Needing different implementations for Linux/macOS. Having to set-up CFFI in general, etc etc.
Unity I think...
Well, I think I "fixed" it. Certainly the mistery is solved. It doesn't crash now. I can happily move the mouse in the window as many times as I please :P At first I tried compiling the hello world example of GTK3 and make that crash: [https://developer.gnome.org/gtk3/stable/gtk-getting-started.html#id-1.2.3.5](https://developer.gnome.org/gtk3/stable/gtk-getting-started.html#id-1.2.3.5) For instance by passing argc=0 and argv=NULL (which in reality almost always will contain at least one argument: the program name). Or by using g\_signal\_connect\_data() instead of g\_signal\_connect() and passing NULL, 0 as the extra two arguments. Nothing I did made the C version crash. Then I carefully looked at the types, maybe some stack shift issue? For instance, g\_signal\_connect\_data is declared to return an int but it actually returns a long. And the callback `cback` second argument `u` should be a (\* t) instead of an int. Also, when `sbcl --load`'ing the file, it shows warnings about the alien functions not existing, that is solved by moving the `(load-shared-object "/usr/lib/x86_64-linux-gnu/libgtk-3.so.0")` to the top of the file, before the alien definitions. But, again, nothing I did made the lisp version not crash. That is, until I did this: (sb-int:set-floating-point-modes :traps '(:overflow :invalid)) That disables SBCL trapping of division by zero float exceptions. I think one is caused in the GTK library code. But to make sure, I went back to the C example and enabled trapping of FE\_DIVBYZERO. This produced the result I expected: now the C version also crashes when moving the mouse in the window' contents. This is my edited working Lisp file: #!/usr/bin/sbcl --script (load-shared-object "/usr/lib/x86_64-linux-gnu/libgtk-3.so.0") ;; This will exclude :divide-by-zero which might be caused in the GTK lib. ;; The default traps are (:OVERFLOW :INVALID :DIVIDE-BY-ZERO). ;; See: (sb-int:get-floating-point-modes) (sb-int:set-floating-point-modes :traps '(:overflow :invalid)) (define-alien-routine gtk_application_window_new (* t) (app (* t))) (define-alien-routine gtk_application_new (* t) (txt c-string) (flags int)) (define-alien-routine g_application_run int (app (* t)) (argc int) (argv (* t))) (define-alien-routine g_signal_connect_data long (instance (* t)) (sig c-string) (cback (function void (* t) (* t))) (data (* t)) (unusedptr (* t)) (unusedint int)) (define-alien-routine gtk_window_set_title void (win (* t)) (ttl (c-string))) (define-alien-routine gtk_window_set_default_size void (win (* t)) (x int) (y int)) (define-alien-routine gtk_widget_show_all void (win (* t))) (sb-alien::define-alien-callback mycallback void ((app (* t)) (u (* t))) (with-alien ((win (* t))) (setf win (gtk_application_window_new app)) (gtk_window_set_title win "This") (gtk_window_set_default_size win 100 100) (gtk_widget_show_all win))) (with-alien ((app (* t)) (status int)) (setf app (gtk_application_new "org.gtk.example" 0)) (g_signal_connect_data app "activate" mycallback nil nil 0) (g_application_run app 0 nil)) (format t "App finished successfully~%") &amp;#x200B; And this is a C version that crashes when moving the mouse on top (comment the call to feenableexcept() to make it not crash): &amp;#x200B; //Added by me: These two lines must appear before the gtk.h include: #define _GNU_SOURCE #include &lt;fenv.h&gt; #include &lt;gtk/gtk.h&gt; //Compile: // apt-get install libgtk-3-dev // // gcc `pkg-config --cflags gtk+-3.0` -o example example.c -lm `pkg-config --libs gtk+-3.0` static void activate (GtkApplication* app, gpointer user_data) { GtkWidget *window; window = gtk_application_window_new (app); gtk_window_set_title (GTK_WINDOW (window), "Window2"); gtk_window_set_default_size (GTK_WINDOW (window), 200, 200); gtk_widget_show_all (window); } int main (int argc, char **argv) { GtkApplication *app; int status; //Added by me: This enables DIVIDE BY ZERO exception trapping: feenableexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW); app = gtk_application_new ("org.gtk.example", G_APPLICATION_FLAGS_NONE); g_signal_connect (app, "activate", G_CALLBACK (activate), NULL); status = g_application_run (G_APPLICATION (app), argc, argv); status = g_application_run (G_APPLICATION (app), 0, NULL); g_object_unref (app); return status; } &amp;#x200B; I hope this was helpful! &amp;#x200B;
I'm thinking that maybe the division by zero happens in GTK because there are no widgets in the window. Maybe once there are widgets the line that disables trapping of divide by zero can be removed. But not sure.
Yes, very helpful. I added the (sb-int:set-floating-point-modes :traps '(:overflow :invalid)) to mine and it got rid of the mouse-movement crash there too. &amp;#x200B; I can't imagine why anyone would want to downvote you. I upvoted both of your comments. By far the most helpful comments in the whole thread. &amp;#x200B;
I remember seeing someone severely criticizing Next browser in this subreddit before for security reasons. Since I work in the computer security industry let me just say that there are definite grave concerns that apply to this and any other project that exposes an underlying browser engine to the Internet without sandboxing. This is very very bad, especially for webkit since it does not come with a sandbox of its own (unlike chromium engine). Given the number of remotely exploitable bugs that webkit has had and the availability of not-public so called "0day" exploits [you need some visibility in that scene in order to deduce numbers], it is not advisable to run Next Browser as it currently stands. Of course it can and should be improved, but I fear that webkit can not be salvaged. Your best odds of having something that can not be compromised in a few minutes by all sorts of non nation-state adversaries, is to go with chromium and find a way to keep the chromium sandbox.
\&gt; By far the most helpful comments in the whole thread. Thanks! Your thread has motivated me to start a small app I've been wanting to do, to track time spent in tasks for myself. I wanted it to use the systray with an icon and I didn't want to compile it to binary or to have dependencies that will stop working in a couple of years. And I wanted to be able to make edits while I use it and evolve it. I was evaluating ABCL with Java Swing/AWT (how long will Oracle support Swing?), or cl-tk (does it support creating a system tray icon?). &amp;#x200B; Cheers, and thanks to you!
Author here. It's a shame really that this clickbait listicle sparked a tiny flamewar, in r/lisp of all places. &gt;I don't know why my videos are being put under "poor editing" What do you think would be a better title? I can change or remove it if you want. &gt;I *really* don't understand the complaint about ease of install. You're complaining about requiring to setup emacs and so forth, even though that's only required to *develop* the games. Common Lisp shines in interactive sessions. If an IDE was bundled with a game, that would make modding it easy, and any user who installs the game could mod it. And when mods are made easy, people build cool things, share those cool things, and the community comes up with something beautiful. &gt;Finally I don't see any solution anywhere in the entry about how to deal with the supposed problem of things not being popular enough How to become popular? Go where the users are. Where are the users? Windows and mobile. Fact: 20% of people reading this blog post are Linux and 20% are windows users. Fact: Lisp needs to stop relishing in it's co-opted identity as an "alien" language for obscure Linux users. For example, [this link is how roswell](https://en.wikipedia.org/wiki/Roswell_UFO_incident) got it's name. [The Lisp logo is a goddamn alien](https://www.google.com/search?q=lisp+logo&amp;source=lnms&amp;tbm=isch). Lisp is the mother of all languages, the father of all DSL's, and deserves it's rightful place as ruler [among the people of earth](https://en.wikipedia.org/wiki/Usage_share_of_operating_systems).
If I didn't know any better I would say you were a paid blink shill :D chromium is not any safer than webkit.
You couldn't be more - dangerously - wrong. What I said is common knowledge amongst offensive security professionals. The people that do the research and write the exploits that get you compromised. But don't just listen to me, here are some actual references: From Peiter Zatko/Mudge: http://cyber-itl.org/blog-1/2016/9/12/a-closer-look-at-the-osx-continuum: "With the browsers, the story is pretty clear - there are pretty big score differences between our three exemplars currently available on OS X, with Firefox (v 39.0) close to the 5th percentile mark, Safari (v 9.0) in the middle (of the browsers, but below the 50th percentile mark for the OS X environment), and Chrome (v 48.0.2564) leading the pack with a more respectable score." From https://digitalguardian.com/blog/firefox-safari-edge-all-fall-pwn2own-2018: "While Safari was targeted the most over the course of the two days it was an Edge vulnerability that fetched the highest payout." "It's the second year in a row that Chrome has emerged unscathed from the competition." From @thegrugq: "WebKit is basically a collection of use-after-frees that somehow manages to render HTML (probably via a buffer overflow in WebGL)" These people are real experts. Do you have anything of substance to add besides unsubstantiated personal opinion and conjecture? 
&gt;Author here. It's a shame really that this clickbait listicle sparked a tiny flamewar, in r/lisp of all places. You wrote what is, by your own concession, a clickbait listicle. What else did you expect? &gt; How to become popular? Go where the users are. Where are the users? Windows and mobile. Those places are also the same places with the most oversaturation of games. Just going where there's the most people is neither beneficial, let alone guarantee for success. &gt; Fact: 20% of people reading this blog post are Linux and 20% are windows users. Where are you getting this fact from? &gt; Fact: Lisp needs to stop relishing in it's co-opted identity as an "alien" language for obscure Linux users. You *really* need to stop telling other people what they should be doing with their time. If you want to see others agree to your goals and follow in what you believe to be the right path you need to lead the way and inspire them, not judge them for what they're doing. Just as a data point, this exchange alone has made me almost entirely convinced that I have zero reason to follow any of what you perceive to be important, and if anything should instead actively work against that. &gt; Lisp is the mother of all languages, the father of all DSL's, and deserves it's rightful place as ruler among the people of earth. This is downright embarassing to read. 
&gt; For example, this link is how roswell got it's name. The Lisp logo is a goddamn alien. Perhaps you prefer an ugly, blue gopher instead? 
OMG... Shinmera!! [He has spoken!](https://www.reddit.com/r/lisp/comments/84lw4x/portacle_1_on_newsycombinatorcom/dvqwuk0/)
🤔 
Safari is on Version 12 buddy.
You are so out of touch with the state of cybersecurity that it's terrifying. Not only that, but you insist on this nonsensical adversarial attitude towards me when I'm spending my personal time trying to inform you. Did you even take a look at exploitdb? Did you look at the dates? Did you understand anything of what I've laid out? I started this thread in good faith, maintaining a positive attitude and making well-referenced suggestions. Right off the bat you start attacking me personally and making vague unsubstantiated claims that sound, frankly, ridiculous even to non-experts. This is not a proper attitude for a project leader to have. I sincerely hope that readers of this thread take it into account.
You are spending your personal time to insult me. Your first statement was a disclaimer that my project is just one big security vulnerability, which could not be further from the truth. I have spent a lot of time and completely insulated the Lisp core from WebKit (which is secure, despite your outdated claims). I reacted the way I did because I'm tired of WebKit trolls and doomsayers. When can we lay it to rest? I hear it every time, like it is something I somehow overlooked. I didn't. Furthermore, I'm convinced you know nothing about cybersecurity. I went through your post history and found nothing enlightening with regard to. My claims are not unsubstantiated and they follow a logical train of thought. DO YOU THINK, a company that has one of its main selling points as SECURITY OF YOUR DATA AND SYSTEM, would ship a huge vulnerability with their systems? Do you think a company with the largest value in the world, doesn't have the money to solve a security problem? Answer these questions sincerely, and then we can begin having a conversation on the matter. With regard to my attitude as a project leader. I am quite open. You are more than welcome to make a port using QT, CEF, or whatever other technology you so desire. I leave the license to you as a BSD 3 clause license to place no restrictions on you. Look at all of my reactions and engagement with the community on Github. I have no problem as a project leader, I have a problem with you, and your attitude. 
I've never seen anyone blatantly ignore reality-staring-you-in-the-face in the way that you do here. I am giving you facts and you are giving us **opinions** that don't even make sense. Peiter Zatko is a world-class expert on all matters cybersecurity. You should actually read the Cyber ITL link I posted here and enlighten yourself as to the security of OSX because you are seriously deluding yourself if you think Apple does not ship vulnerable code. I think I will stop wasting my time here. Hope the readers reach their own conclusions.
&gt; I'm positive that Apple products are more common in the industry than Microsoft products are. Perhaps only on the US of A. In my part of the hemisphere, Apple laptops/workstations are not popular at all in the industry, except when the company has a "bring your own device" and the owner has that baffling admiration for Steve Jobs. 
The skeleton is useful at least, never looked into Clojure.
How better is it to run it inside Docker ? With Firejail ? A Guix environment ? Another solution ?
&gt; Javascript interpreter in 100% Common Lisp This is already done, however it supports an old ECMA standard. http://marijnhaverbeke.nl/cl-javascript/
&gt; cltk http://marijnhaverbeke.nl/cl-tk/ much more lightweight. For an application that is not a web browser, you don't need a web browser. Something like TK should more than suffice. There's also LTK, which is very well documented.
&gt; Well, many honestly, I don't want to go into it, but segfaults frequently, strange error messages, a complicated build process. Needing different implementations for Linux/macOS. Having to set-up CFFI in general, etc etc. What about using GTK Server? There is already a lisp library with bindings to GTK Server, AFAIK. 
&gt;Where are you getting this fact from? never used blogspot, but i bet it's google analytics data and OP is leaking it. `(incf (scumminess *op*))`
It's surely better than running naked WebKit, since you're defending against one-shot drive-by exploits usually delivered by ad sites that have been either compromised by blackhats or deliberately cooperating/set-up with/by them. The main issue in this case is that jmercouris when faced with a list of hundred+ WebKit exploitable bugs replies with "Apple would never ship vulnerable code". I am pretty sure it's not a good idea to be running code written by a person with such an attitude.
Skip if you're not a real noobie.
Great points. &gt;(And some people disagree with me here and somehow use Emacs on Windows without complaints.) I resemble that comment. Emacs runs flawless for me on Windows (has for years). 
My sbcl goes to the debugger and gives me some error I do not understand. trying to (declaim (optimize (debug 3))) did not shed any further light.
I actually meant to link to LTK! Thank you for providing the correction!
Not sure honestly, we're too far down this road to turn around anyways :D
When does it go to the debugger? Does it show the Gtk window first?
Hello, Thank you for your answer, but I'm not sure I can fully understand it. I'm pretty sure I'm exercising restraint *because* I am inexperienced. Therefore I'm absolutely unaware of everything Lisp does allow and how to do it.
Didn't know about it, seems to be a very interesting project!
They will be if you use `tlet` instead of `labels`: http://www.kylheku.com/cgit/lisp-snippets/tree/tail-recursion.lisp 
Don't promote Clojure as a Lisp.
The loop macro, because every language should have a little COBOL.
Hmmm... cites Steele and Gabriel's "The Evolution of Lisp": The iteration facility, called LOOP, it consists of a single macro that has an elaborate pseudo-English or COBOL-like syntax. The debate on this facility was at times intense, especially when Scott Fahlman was still active in Common Lisp. Because of its non-Lispy syntax, it was (and remains) easy to ridicule.
The hate is because it loops like you spooged a big wad of COBOL into the middle of your lisp program. The only way it could be worse is to have a facility that used reader macro abuse. Hey, you could put a chunk of APL into your code that way. Just because you can, doesn't mean you should. I strongly feel that the only justification for loop is that it's art of the standard. Else it is ugly. and to avoid.
https://github.com/marcoheisig/adventofcode (Common Lisp) It is quite refreshing to write these one-shot programs, where one does not have to ponder about maintainability. I only wish it would involve less parsing of input files.
Late to the party but here is my inane rambling on this article http://techsnuffle.com/2018/12/07/reasons-why-lisp-games-suffer-corrections
Hi u/jmercouris, thanks for working on a lisp browser! I'm asking for trouble replying this way, but I'd like to understand your choice of webkit and your reasons of defending it. Let me first throw in my external view on this conversation. &gt; You are spending your personal time to insult me I haven't seen any insults on you as a person, u/methrolografix says you're out of touch wrt security. (S)he didn't say you're an idiot or such. &gt; Your first statement was a disclaimer that my project is just one big security vulnerability [...] I have spent a lot of time and completely insulated the Lisp core from WebKit I think everyone is extremely happy about what you're doing. The concerns raised did not cover the code you wrote, just your usage of external dependencies. The statements merely said using a browser engine without a sandbox is risky and that webkit is not to be trusted. &gt; DO YOU THINK, a company that has one of its main selling points as SECURITY OF YOUR DATA AND SYSTEM, would ship a huge vulnerability with their systems? Me, yes. Apple's point is to make money, period. If someone would pay to get a backdoor and there would be absolutely no way of ever finding it out for us, do you think they would decline? No, there wouldn't be a moment of doubt in their mind. Sorry, corporations are not run by saints. Let's look at another case though - linux, one of the largest open source codebases with many, many contributors. It's running on the most important servers of every major corporation. Now there's a reason for them to run a secure OS, noone wants their secrets to be stolen, right? Some of these corporations hire professionals to work full-time on linux. Surely linux is as secure as a piece of software can get? ... [Not really](https://www.cvedetails.com/vulnerability-list/vendor_id-33/product_id-47/year-2018/Linux-Linux-Kernel.html). Software and hardware *is* insecure. The only claim someone can make is that A is *more* secure than B, therefore *harder* to crack (harder = takes more time). So, getting back on topic &gt; I'm tired of WebKit trolls and doomsayers. When can we lay it to rest? I hear it every time, like it is something I somehow overlooked. I didn't. Would you mind spending 5 more minutes on this topic and showing us what makes you claim that webkit is as secure as e.g. chromium? Not "I trust Apple" but some numbers, claims from security experts, results from audits etc. As it stands u/methrolografix pointed us to some resources to back up his/her words and you haven't, which probably explains why (s)he is being upvoted and you downvoted. Backing up your words like this would get this conversation back on track. On another topic - I'm so glad there's a linux port! Last time I read through the installation process I just turned around. Personally I would love to have a docker image for linux, which as discussed in another thread here already brings a nice level of security. Apart from that it also allows to easily set e.g. memory and cpu usage limits and sysctl parameters such as max open file handles. And if a user has docker there's no installation necessary, just copying the prepared `docker run` command.
Since you are trying to write scripts, this isn't completely relevant but I blindly tried running this on 32-bit Linux in a VM, and of course it did not find the path to libgtk due to not being 64-bit. This reminded me, I've seen a lot of Lisp packages where paths to C dynamic libraries are hard-coded with no use of the condition/restart system to give the user an option to handle the error. So just for giggles, I wrote the following code that will automatically try multiple common paths to libgtk, and if even that fails to work, then it provides a restart to allow explicitly specifying the full path to libgtk. This would be more useful in a system/package rather than a script, however. (defparameter +libgtk-paths+ nil "Common paths for where to find libgtk. Paths can be added via PUSH, etc.") \#+x86-64 (push "/usr/lib/x86\_64-linux-gnu/libgtk-3.so.0" +libgtk-paths+) \#+x86 (push "/usr/lib/i386-linux-gnu/libgtk-3.so.0" +libgtk-paths+) \#+arm64 (push "/usr/lib/aarch64-linux-gnu/libgtk-3.so.0" +libgtk-paths+) \#+arm (push "/usr/lib/arm-linux-gnueabihf/libgtk-3.so.0" +libgtk-paths+) &amp;#x200B; (defun load-libgtk-restarter (&amp;optional (path (first +libgtk-paths+)) (show-try-common-paths t)) (restart-case (load-shared-object path) (try-common-paths () :report "Retry loading libgtk via commonly used paths." :test (lambda (condition) (declare (ignore condition)) show-try-common-paths) (loop with ((found-libgtk-path nil)) for p in +libgtk-paths+ do (handler-case (setf found-libgtk-path (load-shared-object p)) (error (condition) (declare (ignore condition)) nil)) until (typep found-libgtk-path 'pathname) finally (return found-libgtk-path))) (specify-path (specified-path) :report "Specify the full path to libgtk." :interactive (lambda () ;; Normally a FORMAT prompt would go here, ;; except it is not reliable when Lisp ;; decides to show it. Emacs/SLIME tends ;; to show it when the restart is invoked ;; but the SBCL REPL tends to show it only ;; after we already provided input. (list (read-line))) ;; result must be a list (i.e. argument list) (load-shared-object specified-path)))) &amp;#x200B; (defun load-libgtk (&amp;optional (path (first +libgtk-paths+))) (let ((found-libgtk-path nil)) (when (null (handler-bind ((simple-error (lambda (condition) (when (find-restart 'try-common-paths condition) (invoke-restart 'try-common-paths))))) (setf found-libgtk-path (load-libgtk-restarter path)))) ;; If we get here, then the try-common-paths restart ;; didn't work, so call again and let it run the debugger. ;; Tell it to hide try-common-paths since we already did that. (load-libgtk-restarter path nil)) ;; If successful, then we want to show that the path ;; was found by LOAD-SHARED-OBJECT rather than letting ;; arbitrary returned values flow through as the final ;; result. found-libgtk-path)) &amp;#x200B; ;; We call our defensive code rather than LOAD-SHARED-OBJECT directly: (load-libgtk)
[Common Lisp Repo](https://github.com/NobodysHero/Advent-of-Code-2018) Using Advent of Code to get better :D
(Ugh, Reddit doesn't seem to preserve formatting. Emacs or another editor will probably be needed to reformat this into sanely indented code.)
Why?
Is not.
&gt; From Peiter Zatko/Mudge: http://cyber-itl.org/blog-1/2016/9/12/a-closer-look-at-the-osx-continuum That link is missing its .html (i.e. it should be https://cyber-itl.org/data/our_approach/2016/09/15/a-closer-look-at-the-osx-continuum.html ) But the same site currently ranks Firefox as the safest browser on MacOS: https://cyber-itl.org/comparisons/comparison.html?comparisonType=browser&amp;operatingSystem=OSX (likewise, Firefox is ranked the safest on Linux). [Of course the same site ranks Windows the safest OS, which does call credibility into question.]
Hi comma_at. Your and the other posters security questions are reasonable this is a good place to bring them up. However. Haven't you basically answered your own question? All you have managed to say is "Hey, look at how buggy and insecure the worlds best financiend, most open and well regarded projects is, how can you possibly be sure you 1.5 person project is secure?". The whole conversation is a bit over the top. Would it be nice to be able to develop a pure lisp render engine and then build a browser around that while wrapping it all into a paravirtualized container? Of course. Would it be nice to have a fully open hardware from the ground up with kernel written in a mathematically provable correct (secure) software? Of course. But we live in a time when our frickin cpus are vulnerable. Let's face it, it's duct tape all the way down. My take on this is something along these lines: * Premature optimization is the root of all evil. * No one will agree on what is premature nor what is optimization. * Worse always wins over better. This is because usually worse delivers and better rarely does. * We are living at a time of so many common lisp implementations (sbcl now runs on arm for heavens sake!) I will take any code that I can get. Instead of spining our wheels on the details, let's get some code out, let's attach a gargantuan amount of user warnings and just get some product to turn. John has managed to single handedly managed to get to basically feature parity with Conkeror. That is an amazing accomplishment. Can we now get some more funding to go to his Indiegogo campaign so he can pay for the additional programmer to get to the next iteration? Link here: https://www.indiegogo.com/projects/next-browser-nix-support#/ All of the security feedback is great. What is most important, however, are systems. Let's get the funding for the project happening, let's get some releases happening and when John can afford it, he can hire a full time security team to help with the inevitable rewrite. Just my thoughts. 
u/borodust got it, erlang on the backend. I am using lua for the scripting though so you are correct about that bit. Thanks for the interest :)
What do you feel when writing in erlang and lua after the Common Lisp?
Hey, thanks for this function, much appreciated! To paste formatted code, you have to click in the ellipsis and select "Code Block". &amp;#x200B; Cheers!
I feel like I've got a good tool for the job I guess. I'm doing pretty basic stuff and the whole ecosystem is engineered towards this kind of concurrent message passing, so I don't worry much. Also I can still compile code live and work from the REPL so whilst it's not at CL's level it's still comfortable. I dont feel qualified to say anything much deeper about it though.
&gt;Why? It is really its own language; diverges too much from Lisp. The majority of lisps, like Common Lisp, Emacs Lisp, ISLisp, Le Lisp, T, NiL, and others, can execute code from 1960s lisps with little (or no) modifications. 
See pprint-fill with the 3rd arg: `cl-user(10): (pprint-fill t (loop for i from 0 to 100 collect i) nil)` `0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40` `41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78` `79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100` pprint-fill will obey \*print-pretty\* in that if false it will print without breaking long lines. &amp;#x200B;
If Clojure is a Lisp, then so is JavaScript, Ruby, Perl, and even Java, since all of these have taken ideas from Lisp, and that's all Clojure's relationship to Lisp really is— it borrowed a few ideas.
http://lisp-univ-etc.blogspot.com/2013/01/common-lisp-is-just-lisp.html
I'd rather see every package `USE`d if a symbol from one package is used from another. That way I can tell which libraries a package (as opposed to an ASDF system) depends on just by reading the `defpackage` form.
Ok, then does Arc is a lisp?
Great post, from an engineer not a fanboy.
Well put, Baggers. I must confess that I was about as flummoxed myself when I read that post. I have enjoyed watching (and learning from) your videos, so a special thanks for putting in the energy to generate all that content for free. Good luck with your projects!
the best way to find out is trying it. I am no longer interested in this tread.
&gt;but it is also just a piece of technology, just a tool, and we should be realistic about our tools when it comes to a given context. wow, *this*
Am I the only one that found the latter post weird because afaik lisp-games is one of the better, more organized lisp communities? Yeah they wont take over the world, but they are having fun and bonding around their interests. 
I fixed the issue with the FORMAT prompt, it's necessary to use `(finish-output nil)` after FORMAT. Following is the code you pasted, but indented by hand by me (please excuse any weirdness), and with the user prompt fixed: ;;; Function to load and locate the path to GTK library, published by "tenebris-miles" (defparameter +libgtk-paths+ nil "Common paths for where to find libgtk. Paths can be added via PUSH, etc.") #+x86-64 (push "/usr/lib/x86_64-linux-gnu/libgtk-3.so.0" +libgtk-paths+) #+x86 (push "/usr/lib/i386-linux-gnu/libgtk-3.so.0" +libgtk-paths+) #+arm64 (push "/usr/lib/aarch64-linux-gnu/libgtk-3.so.0" +libgtk-paths+) #+arm (push "/usr/lib/arm-linux-gnueabihf/libgtk-3.so.0" +libgtk-paths+) (defun load-libgtk-restarter (&amp;optional (path (first +libgtk-paths+)) (show-try-common-paths t)) (restart-case (load-shared-object path) (try-common-paths () :report "Retry loading libgtk via commonly used paths." :test (lambda (condition) (declare (ignore condition)) show-try-common-paths) (loop with ((found-libgtk-path nil)) for p in +libgtk-paths+ do (handler-case (setf found-libgtk-path (load-shared-object p)) (error (condition) (declare (ignore condition)) nil)) until (typep found-libgtk-path 'pathname) finally (return found-libgtk-path))) (specify-path (specified-path) :report "Specify the full path to libgtk." :interactive (lambda () ;; Prompt the user: (format t "Please input a full path for libgtk-3.so.0: ") (finish-output nil) (list (read-line))) ;; result must be a list (i.e. argument list) (load-shared-object specified-path)))) (defun load-libgtk (&amp;optional (path (first +libgtk-paths+))) (let ((found-libgtk-path nil)) (when (null (handler-bind ((simple-error (lambda (condition) (when (find-restart 'try-common-paths condition) (invoke-restart 'try-common-paths))))) (setf found-libgtk-path (load-libgtk-restarter path)))) ;; If we get here, then the try-common-paths restart ;; didn't work, so call again and let it run the debugger. ;; Tell it to hide try-common-paths since we already did that. (load-libgtk-restarter path nil)) ;; If successful, then we want to show that the path ;; was found by LOAD-SHARED-OBJECT rather than letting ;; arbitrary returned values flow through as the final ;; result. found-libgtk-path)) ;; We call our defensive code rather than LOAD-SHARED-OBJECT directly: (load-libgtk) Cheers! &amp;#x200B;
And Shinmera's take on making games in Lisp: https://reader.tymoon.eu/article/370
The McCarthy unit apparently lamented that fact, circa [2005](https://groups.google.com/forum/m/#!topic/comp.lang.lisp/4iUYVwonx7k).
Excellent post!
Claiming that a language which has zero compatibility - zero - is a dialect, is a but funny. Read any Lisp book/tutorial and try that code: nothing works and everything is supposed to be completely rewritten...
(cons 1 '(2 3)) works... What's your standard for a dialect? Is scheme a lisp dialect?
What is "just a tool"? When constructing houses and buildings, we use gravity and the ground as tools. Without them, we would need very different tools, to construct very different real estate. Constructing houses and buildings on a space station would be like constructing games on phones and other such devices. But it won't be long before the game industry will be more down-to-earth, because the devices will have gigabytes of memory and orders of magnitude more processing power. 
What is (car '( 1 . 2)) doing?
I consider it a lisp. It has s-expressions, macros, dynamically typed, a repl, etc. It's also listed in the side bar a couple of times. Just because the form names are different and it doesn't have traditional cons cells doesn't mean it's not a real lisp.
Is hy a lisp dialect? It has proper cons cells.
In Lisp when you have an unexpected error you are taken into the debugger. So trying to run the program equals debugging. The bug happens every time you try to run it under SBCL 1.4.13. The symptom is the program bailing out into the debugger. Ignoring the error and telling lisp to continue shows theexpected gtk window. For the details of the error, download sbcl install it and run it.
&gt; 5. Portability matters &gt; &gt; I need to get code on mobile platforms &amp; consoles. Lisp doesn’t help me here. This is probably the key point as far as Common Lisp's limitations go. If you're planning on making a Common Lisp game, you should plan on making it a PC exclusive, which probably means picking a genre like strategy that does well as a PC exclusive. Even among the major PCs OSes, macOS support is complicated for Lisp games (and games in general thanks to Apple completely ignoring modern, portable graphics APIs in favor of its inferior, proprietary graphics API) so you might find yourself only being able to support Windows and Linux. Mobile support (minimal) and console support (non-existent) aren't very good right now.
cons allows one to construct lists, the foundation of sexprs, which are interpreted by the clojure list processor. The operational semantics of cons differ, but the foundational requirement to provide an arbitrarily complex nesting of lists which in turn encode a program is satisfied in my opinion. I think it's a list processor, even if there are deviations from historical anachronisms (hence the use of dialect). It's not lisp 1.5, if that's where the implied goal posts have been moved to.
Great to hear from a doer instead of a talker. I admire the pioneer spirit on display, and I think your scoping decisions are sound (gameplay first). I hope you learn (and eventually share) a lot. Best of luck in your endeavor.
Ask the lisp-support@lispworks.com, I think they patches to work around the size of the toolbar icons. 
Anyone wanting to do it on console would have to port the implementation to the console, or at least port enough to cross compile and run a lisp image on it. This is quite a bit of work. While it does help that consoles have been running rather mainstream processor architectures for a while now (x64, Power, ARM64) and many consoles supposedly run a vendor modified FreeBSD underneath, it would still be a lot of work to port as it has to not only work with the OS-CPU combination (implementation may support both but not in combination yet, after all), but also the vendor modifications to the OS (which are probably huge). And then there are things like porting other libraries that are dependencies and making bindings for platform specific libraries.
It's funny. When I read "console" I was like, "Yeah porting a game that's not a Tex based adventure to ASCII would be painful just to run in a shell." But seriously, I'd play the hell out of a game I could just play in a terminal. Hell, I'd probably just add it to all my required modules in my ansible scripts. SSH to a box and handle business. :)
Why would you spend that much money for a Lisp compiler/IDE? Do you know [https://portacle.github.io/](https://portacle.github.io/)? SBCL is one of the best Lisp compilers available, and it's free. Maybe you find also this interesting: [https://racket-lang.org/](https://racket-lang.org/).
In Lisp CONS constructs cons cells. In Clojure the documentation says this: 'Returns a new seq where x is the first element and seq is the rest.' So it constructs objects of type SEQ. A seq is a widely different data structure. The core operators are either not present or don't work. Stuff you find in ANY Lisp book: &gt; (assoc 2 (cons (cons 1 'a) (cons (cons 2 'b) nil))) (2 . B) Thus simply does not work in Clojure. &gt; deviations from historical anachronisms Deviations? Basically NO Lisp code works in Clojure. You have to rewrite everything. No function definition, no looping construct, basic data structures like lists, ... It has changed so much, that it's a new language. If you think that Lisp is defined by ( ) and arbitrary stuff in between, then it is a Lisp dialect. The Java is a C dialect. I think 'Lisp' is defined by shared syntax, semantics and code and thus Clojure is a Lisp inspired language sharing some features. 
Maybe he simply has requirements that are not satisfied by SBCL?
eval, apply, quote, list are there. Sexprs are fundamental data structure and code. Seems pretty lispy to me. I take it backwards compatibility is part of your unspecified standard for a dialect. So scheme doesn't even appear to fit your definition. What does? 
I used to be firmly in the ITERATE camp a few years ago and I still think it is superior to LOOP. However I no longer hate LOOP - its my go-to looping construct these days and generally works out well. Since it's a DSL, it doesn't look the same as rest of Common Lisp, but the code is very readable. A personal example from recent memory is qbase64 - its use made the core encoding and decoding functions so much more readable and easier to write. https://github.com/chaitanyagupta/qbase64/blob/58a588cdc9a461025ca08c08341ecd53e4cc5743/qbase64.lisp#L54 https://github.com/chaitanyagupta/qbase64/blob/58a588cdc9a461025ca08c08341ecd53e4cc5743/qbase64.lisp#L399 
unlikely.
 BiwaScheme Interpreter version 0.6.4 Copyright (C) 2007-2014 Yutaka HARA and the BiwaScheme team =&gt; (assoc 'b (cons (cons 'a 1) (cons (cons 'b 2) '()))) &gt; (b . 2) 
&gt; 'lispy' - does it get more vague? Yes, your non-response to what constitutes a lisp dialect (if you can dodge a question, you can dodge a ball :) ). applying 'cons shouldn't work (as it's a symbol, not a function). I believe the fact it returns anything is a bug in Clojure. I'll file it with the core folks and have a hope at actually getting it fixed. If you apply like a normal user: Clojure 1.8.0 Exit: Control+D or (exit) or (quit) Results: Stored in vars *1, *2, *3, an exception in *e =&gt; (apply cons (list 1 (list 2 3))) (1 2 3) in this dialect, append is concat user=&gt; (concat (list 1 2 3) (list 10 12 14)) (1 2 3 10 12 14) Scheme agrees (with correct error reporting): BiwaScheme Interpreter version 0.6.4 Copyright (C) 2007-2014 Yutaka HARA and the BiwaScheme team (apply 'cons (list 1 (list 2 3))) Error: 'cons is not a function [apply, (anon)] (apply cons (list 1 (list 2 3))) =&gt; (1 2 3) 
Your game has its own programming language that's apparently called Slang. Is there any relationship with [this programming language called Slang](https://villane.wordpress.com/slang/) or [this one](https://en.wikipedia.org/wiki/S-Lang)?
From their style guide: 'We’re Homoiconic Python, with extra bits that make sense.'
Does SBCL have a treeshaker yet?
&gt;yes, your non-response to what constitutes a lisp dialect (if you can dodge a question, you can dodge a ball :) ). My response was that Lisp shares the original data structures and operators. You seem to ignore that. &gt; applying 'cons shouldn't work (as it's a symbol, not a function). In Lisp symbols are function. The original Lisp had symbols everywhere.
See these posts: [https://www.reddit.com/r/lisp/comments/6evvdr/tree\_shaking\_methods\_for\_sbcl/](https://www.reddit.com/r/lisp/comments/6evvdr/tree_shaking_methods_for_sbcl/) [https://gist.github.com/burtonsamograd/f08f561264ff94391300](https://gist.github.com/burtonsamograd/f08f561264ff94391300)
Their docs also start with &gt; Hy is a wonderful dialect of Lisp that’s embedded in Python.
I'm pleasantly surprised that lisp gaming is a big enough field to have drama going down. 
&gt; Hy is a wonderful dialect of Lisp that’s embedded in Python That's great! Then it can sure run Lisp code? Like the Evaluator from McCarthy? https://gist.github.com/lispm/d752d5761f7078de4041d4e453e70cbe
It looks gorgeous on my MacBook Pro 2017. Same on ThinkPad Extreme X1 (UHD screen). I do not have a UHD screen on my illumos/solaris machine right now, so I can't tell.
Oh, SBCL now comes with cross-platform GUI library with native backends?
Compare with the LispWorks delivery guide: http://www.lispworks.com/documentation/lw71/DV/html/delivery.htm
Thanks, that was funny :-)
Check this: [https://common-lisp.net/project/commonqt/](https://common-lisp.net/project/commonqt/)
&gt;SBCL is one of the best Lisp compilers available, and it's free. Yes. But LispWorks is also one of the best implementations available and adds other features not present in SBCL.
&gt;(cons 1 '(2 3)) works Ironically, this is one of the major differences between Clojure and a Lisp. Even something as essential in Lisp land like this, won't work equally. 
&gt;(cons 1 '(2 3)) works Ironically, this is one of the major differences between Clojure and a Lisp. Even something as essential in Lisp land like this, won't work equally. 
&gt;(cons 1 '(2 3)) works Ironically, this is one of the major differences between Clojure and a Lisp. Even something as essential in Lisp land like this, won't work equally. 
&gt;(cons 1 '(2 3)) works Ironically, this is one of the major differences between Clojure and a Lisp. Even something as essential in Lisp land like this, won't work equally. 
Sure, it's a good implementation. But they would do also themselves a favour not charging money from hobbyists (as e.g. Cincom with their Smalltalk). This would even more support the vendor lock-in effect they live on ;-)
Not without modification. Neither can scheme so it must not be a true™ lisp
which means that it is neither native nor would it run on a current Mac. QT 4.8.5 is four years old and supports only old macOS variants. To run QT on the current OS one needs 5.11 or maybe even newer, it seems. Might be useful to have something like CommonQT, though.
That's why it is called Scheme and not Standard LISP, MacLISP, AutoLISP, Visual LISP, Emacs LISP, Common LISP, ISLISP, LeLISP, ... notice a pattern there?
/r/clojure does not list LISP in their sidebar. It does have s-expressions? We must have a different definition of s-expressions then. McCarthy defined it here: http://www-formal.stanford.edu/jmc/recursive/node3.html 
Here's a sneak peek of /r/Clojure using the [top posts](https://np.reddit.com/r/Clojure/top/?sort=top&amp;t=year) of the year! \#1: [Clojure 1.9 is now available!](http://blog.cognitect.com/blog/clojure19) | [31 comments](https://np.reddit.com/r/Clojure/comments/7ihd9t/clojure_19_is_now_available/) \#2: [Rich Hickey: Open Source is Not About You](https://gist.github.com/richhickey/1563cddea1002958f96e7ba9519972d9) | [215 comments](https://np.reddit.com/r/Clojure/comments/a0pjq9/rich_hickey_open_source_is_not_about_you/) \#3: [Maybe Not - Rich Hickey](https://www.youtube.com/watch?v=YR5WdGrpoug) | [82 comments](https://np.reddit.com/r/Clojure/comments/a1n962/maybe_not_rich_hickey/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/8wfgsm/blacklist/)
last time I tried I could not install it.
Qt 4.8 runs well on Mac (see [http://doc.qt.io/archives/qt-4.8/install-mac.html](http://doc.qt.io/archives/qt-4.8/install-mac.html)). I use it for different applications. I'm sure it would be feasible to update the Lisp binding to Qt5 if need be. It certainly has the advantage of avoiding the vendor lock-in associated with proprietary frameworks.
I have a war story about [that one](https://en.wikipedia.org/wiki/S-Lang). In 1996 I was working at Nortel, for an a division that used to be Prism Systems, acquired by Nortel. The product was phone switch management software with a really dumb name: netWORKS. (Good luck searching for this now given that "Nortel Networks" is a company name.) Anyway, before I got there, someone had made the idiotic decision to take J. E. Davis's S-lang and integrate it into the product as a feature. S-lang was incredibly immature then. For instance, *syntax errors* would just stop the show, with no clue as to the source of the error, and were caught at run-time (and of course, type mismatch errors, *ditto*, as well as undefined variables). Some arithmetic infix operators required whitespace around them, otherwise there would be a syntax error; others were tolerant of whitespace. I whipped out lex and yacc, and hacked up lint program ("slcheck") which tried to do some static analysis on S-lang: the whitespace quirks, undefined variable checks and some attempts to do a bit of type. S-lang had no associative structure of any kind and we needed one. And no data structures. So I whipped up a red-black tree implementation, using parallel arrays: `node_color[x]`, `left_child[x]`, ... One time a customer inquired about some S-lang code that I worked on: could we please explain the meaning of an obscure variable: what does "SA" stand for and what is "SA usage"? In our team we called strings delimited by pipe symbols "sausages", in reference to link sausages: `"foo|bar|123|xyz"`. These sausages were used as a data structure for holding tuples of data, like data sets collected from switches. In some sausage-manipulating code, I had actually named a function parameter `sausage`. Man, some crazy experiences on that job; like working with a M. Sc. in Computer Science who was unable to indent Perl code consistently in a single function that he authored; his brace opens and closes didn't line up. A year after I quit there, I got an e-mail out of the blue. A Nortel customer found my e-mail address somehow by searching on the Internet; they wanted the source code for some utility program they got from Nortel as a binary executable, and I was implicated as the author in its usage help text. Nortel was not able to find the source and would I happen to have it? Luckily for them, I did.
Yet another idea would be to use CLASP and to directly access the Qt API; didn't try it yet. 
/Users/joswig/Downloads/qt-everywhere-opensource-src-4.8.5/include/QtCore/../../src/corelib/global/qglobal.h:331:6: warning: "This version of Mac OS X is unsupported" [-W#warnings] 
/Users/joswig/Downloads/qt-everywhere-opensource-src-4.8.5/include/QtCore/../../src/corelib/global/qglobal.h:331:6: warning: "This version of Mac OS X is unsupported" [-W#warnings] then fatal error... 
We list clojure in the /r/lisp side bar. A couple of times. Same with scheme. We should probably remove them since the aren't lisps.
jesus
Why not add more languages? Javascript has eval, repl, dynamic binding, symbols, closures, macros (https://www.sweetjs.org), ... must be a lisp then.
I don't think autolisp has macros, so you better remove it from your legit lisp list. It won't run your official lisp code.
We might as well. Hell, even scheme is in the sidebar.
Have you tried this: https://download.qt.io/archive/qt/4.8/4.8.7/qt-opensource-mac-4.8.7.dmg ?
I don't want to install an old unsupported binary version.
Did you look at https://gist.github.com/lispm/d752d5761f7078de4041d4e453e70cbe ? McCarthy developed Lisp without macros.
If you saw it, then you'll have noticed it was published on 04-Jun-2018 17:27. Qt 4.8 is still used by many applications and deployed with most Linux distros.
it's only a newer binary version of the old code.
Do what you want, I don't care.
I care
Thanks! We've certainly learned a lot already, and will continue to share things in bits and pieces as they come up. I'm happy to answer any questions, the best I can at this juncture.
No relationship whatsoever to either of those. We have no plans to make our Slang a real-world language (not sure it would have much real-world use anyway), so hopefully no Google conflicts there.
&gt; I believe Lisp allows me to be quicker about developing these tools than other languages, but making an actual game would be even quicker if I didn't have to make most of these tools in the first place. I think that this is the key point. Writing tools is much easier in Lisp than in C++, but it's even easier just to use someone else's tools because they're already written. This doesn't matter much when the tools themselves are simple, but a game engine is probably one of the most complicated tools in software. In a sense, Lisp gamedev will only progress because we are choosing to be time inefficient and not because it's the optimal way to make games, at least for now.
Great read, highly recommended!
I'm good with eval, apply, quote, lists, minimal list operations, lambdas, s-expressions, macros etc providing a sufficient basis for a list processing language. The rest is effectively discriminatory noise (more or less accidental library choices and naming conventions) that's useful to purists. I mean, if you want to establish a purity test, that's one way to do it. Based on your criteria (opinion), the mods should remove the dialects listed on the sidebar so the flock isn't led astray.
&gt; Based on your criteria (opinion), the mods should remove the unblessed dialects listed on the sidebar so the flock isn't led astray. Why that? It helps the Clojure/etc guys find their way to their flocks.
glad there'll be a signpost for multiple dialects then.
LispWorks has a free [personal edition](http://www.lispworks.com/downloads/index.html). It's limited, of course, but I wouldn't think those limitations would be a huge burden to someone who's only a hobbyist.
The "[Hobbyist Edtion](http://www.lispworks.com/products/lispworks.html#hobbyist)" costs between $500 and $1500, see [Prices](http://www.lispworks.com/buy/prices-1h.html). The personal edition is not really an option; it is too limited; obviously also u/b1bendum came to this conclusion. 
It's mostly useful for people who might do some course or similar. Also get some impression of the IDE. It is a bit old (6.1.1 vs. current 7.1.1) and the limitations are really limiting. Including that is a 32bit application. For most other purpose I would think a version of the 'hobbyist edition' with or without delivery is more useful - though already expensive. Luckily there are some great free/open source Lisps. For example SBCL is a great implementation for learning Lisp and then getting more ambitious - thanks to the great compiler and the people who make sure that it runs on current operating systems.
Hi u/blue-dog-blues . &gt; The whole conversation is a bit over the top Maybe a bit, yes. Still, browsers are a big door into your computer, so nobody should be surprised when security questions/concerns come up. &gt; Let's face it, it's duct tape all the way down. Doesn't mean we throw everything out the window, though. Or are you against e.g. HTTPS? Just because someone *might* be able to eavesdrop because of hardware issues doesn't mean you're giving up completely, right? &gt; John has single handedly managed to get feature parity with Conkeror (plus or minus a few details). That is an amazing accomplishment. I couldn't agree more. As I stated previously, nobody is demeaning his work or accomplishments. &gt; All of the security feedback is great. What is most important, however, are systems. The only problem is that the security feedback got 0 answers. I'm glad for Next and would have liked to see some constructive conversation about this topic. Instead it has been played down as trolling. I can live with that and Next will still be a great accomplishment, just bear in mind this is the internet and this conversation might become a commonly referenced link when Next's choice of web engine or security topics come up.
Nobody cares, it's 2018. 
You are a sucker if you end up giving them your money. That's pretty much it. 
What features? CAPI looks and feels like shit, the IDE is crap compared to Emacs, the compiler is not as good as SBCL's and you are depending on proprietary stack. For all I know, LW could go bust tomorrow. It's pretty much a given they'll go bust in the next 5 years or so. Opensource or GTFO IMO.
Hey everyone, thanks for the replies. I'll send a message to their support team and see what they say. As far as why pay for Lispworks when SBCL is available? Well I actually do use SBCL, and I've used ABCL, Clozure and a bit of Clisp way back at the start as well. We even used GCL when I was in school! I do enjoy SBCL and emacs but I was hoping that Lispworks would be a bit closer to the sort of debugging experience that I enjoy with Smalltalk, my first love. My hope is that I can get close to the sort of liveness and direct interactions that Smalltalk offers, while getting the performance, thread support and libraries of Common Lisp, and from some reading I had done, Lispworks offered an environment that might get to where I want to be. With that said, I do try to support open source when I can, I have an FSF membership, I am on Bagger's patreon and Xach's, and I would throw a monthly amount at SBCL if they made it easy for me to find a way to do that (I looked and couldn't find anything). Basically I believe in trying to give back how I can, and right now that isn't time, so I have to substitute money. Supporting Lispworks helps increase the amount of high-quality lisp implementations that exist in the world, and hopefully helps there be more lisp. Maybe if I get some time I'll make some libraries and throw them on quicklisp. I encourage everyone else to give back however else they can, and thanks again for all of your answers.
I tried adding widgets but that made no difference. It still needs the set-floating-point-modes. I'm wondering how and why the divide-by-zero trap gets disabled in the C version but enabled in the SBCL version, so we have to explicitly disable it in the SBCL version but not in the C version. When a Linux process starts, does Linux set the floating point modes? If so, it implies the C version explicitly disables that trap somehow, after it's enabled by Linux. Or maybe Linux disables it and SBCL enables it?
You can request a trial and check for yourself: [http://www.lispworks.com/buy/evaluation.html](http://www.lispworks.com/buy/evaluation.html)
Missing detail: it supports C in lisp.
Thank you!
Thank you! Also, thanks for the code block tip. So many different websites do things their own way that I forget the formatting features of all of them. The code is likely not very useful when running "sbcl --script" due to disabling the debugger, so an alternative set of shebang line arguments would be needed instead when scripting, such as exec sbcl --load $0 --end-toplevel-options "$@" Or something similar. Otherwise, I hope it's at least useful if anyone wants to wrap C libraries in their packages.
Oops, small bug. If it is considered an interface contract that LOAD-LIBGTK must return the path to libgtk-3.so.0 if loaded successfully, then I forgot the SETF for the result when specifying the explicit path. This had been fixed below. (defparameter +libgtk-paths+ nil "Common paths for where to find libgtk. Paths can be added via PUSH, etc.") #+x86-64 (push "/usr/lib/x86_64-linux-gnu/libgtk-3.so.0" +libgtk-paths+) #+x86 (push "/usr/lib/i386-linux-gnu/libgtk-3.so.0" +libgtk-paths+) #+arm64 (push "/usr/lib/aarch64-linux-gnu/libgtk-3.so.0" +libgtk-paths+) #+arm (push "/usr/lib/arm-linux-gnueabihf/libgtk-3.so.0" +libgtk-paths+) (defun load-libgtk-restarter (&amp;optional (path (first +libgtk-paths+)) (show-try-common-paths t)) (restart-case (load-shared-object path) (try-common-paths () :report "Retry loading libgtk via commonly used paths." :test (lambda (condition) (declare (ignore condition)) show-try-common-paths) (loop with ((found-libgtk-path nil)) for p in +libgtk-paths+ do (handler-case (setf found-libgtk-path (load-shared-object p)) (error (condition) (declare (ignore condition)) nil)) until (typep found-libgtk-path 'pathname) finally (return found-libgtk-path))) (specify-path (specified-path) :report "Specify the full path to libgtk." :interactive (lambda () (format t "Please input the full path to libgtk-3.so.0: ") (finish-output nil) ;; ensure FORMAT output to stream reached its destination (list (read-line))) ;; result must be a list (i.e. argument list) (load-shared-object specified-path)))) (defun load-libgtk (&amp;optional (path (first +libgtk-paths+))) (let ((found-libgtk-path nil)) (when (null (handler-bind ((simple-error (lambda (condition) (when (find-restart 'try-common-paths condition) (invoke-restart 'try-common-paths))))) (setf found-libgtk-path (load-libgtk-restarter path)))) ;; If we get here, then the try-common-paths restart ;; didn't work, so call again and let it run the debugger. ;; Tell it to hide try-common-paths since we already did that. (setf found-libgtk-path (load-libgtk-restarter path nil))) ;; If successful, then we want to show that the path ;; was found by LOAD-SHARED-OBJECT rather than letting ;; arbitrary returned values flow through as the final ;; result. found-libgtk-path)) ;; We call our defensive code rather than LOAD-SHARED-OBJECT directly: (load-libgtk) &amp;#x200B;
There are some very petty people here who automatically downvote any LW related items, but commonly link to the site for documentations.
I can definitely see the appeal of LW if you're a Smalltalk fan.
More than that, it seems to support semantic devices such as sequence iterators that appear to be C pointers obtained with the unary `&amp;` operator, dereferenced with `*`, and incremented with `++`. 
`#define AWESOME_LIB 1` 
And I was pedestrian enough to think implementing BASIC in PostScript was the height of perversity.
I'm kinda curious - how do you plan on deciding on which "bit-ness" and which platform to pick for LW?
Python isn't fun anymore, that's so true :S
Thanks!
I guess it has something to do with `infinity` and `NaN` not being standard in Common Lisp. &amp;#x200B; This code in C prints infinity: #include &lt;stdio.h&gt; int main(int argc, char** argv) { printf("%f\n", 3.0/0.0); return 0; } Prints: inf &amp;#x200B; While this code in SBCL prints a non standard symbol as infinity: (sb-int:set-floating-point-modes :traps '(:overflow :invalid)) (format t "~a~%" (/ 3.0 0.0)) Prints: #.SB-EXT:SINGLE-FLOAT-POSITIVE-INFINITY And it has a different symbol if the result is a double instead of a float: * (/ 3.0d0 0.0d0) #.SB-EXT:DOUBLE-FLOAT-POSITIVE-INFINITY * The same with NaN: * (sb-int:set-floating-point-modes :traps '(:overflow)) * (/ 0.0d0 0.0d0) #&lt;DOUBLE-FLOAT quiet NaN&gt; * I just found about this in: [https://stackoverflow.com/questions/19363484/representing-infinity-and-nan-independent-of-implementation](https://stackoverflow.com/questions/19363484/representing-infinity-and-nan-independent-of-implementation) &amp;#x200B; Cheers!
But the Crash Bandicoot and the Jak and Dexter games were made in Lisp to work on consoles?
Man... I kept reading this headline thinking the library was written by a 4yr old. But no, the library was written 4yrs ago and now has gotten reader macros.
Babooo!
Interesting. Most readers and contributors of this thread seem to be either shareholders or employees of LispWorks or otherwise emotionally attached.
Interesting. Most readers and contributors of this thread seem to be either shareholders or employees of LispWorks or otherwise emotionally attached. Every opinion questioning why one should spend money for a hobbyist edition got negative points and vize versa. Definitely no factual discussion of the subject.
That's most likely because OS X has virtualized screen resolution (in contrast to Windows), so even if programmer assume 72 dpi the result still looks acceptable.
So you consider anyone who takes the liberty of asking the question why you should pay a lot of money for a hobbyist version to be hostile? Isn't it rather an anachronism if a company still relies on such a business model today? 
I gave you a reason: LispWorks has a cross platform GUI toolkit with native backends. You pointed to a library which uses an outdated version of a C++ based toolkit. The main reasons to use LispWorks are these: LispWorks has an integrated IDE (written in itself, unlike GNU Emacs / SLIME, which are written in a mix of C, Emacs Lisp and CL) which is not based on GNU Emacs / SLIME, it has quite a bit more features than SBCL (I pointed you for example to the LispWorks delivery guide which should be showing that the amount of features there, already is quite a bit larger than what SBCL offers) , it has a lispy GUI toolkit. GNU Emacs / Slime / SBCL feels in many ways clunky compared to LispWorks. I mean it is great, but it is quite a bit away from LispWorks. The advantages of SBCL are mostly: SBCL's compiler has type checks and optimization hints and the SBCL compiler generates often faster code. Big plus: it come with source code.
So you're the one who's giving negative points for unpopular opinions?
\&gt; "Definitely no factual discussion of the subject" I gave you reasons. You answer with bullshit.
Sir, you're obviously arguing at an infantile level! I am not further interested in a conversation with you.
Maybe you should look at your own 'level', which hasn't impressed my so far, accusing people to be shareholders or employees. &amp;#x200B;
1) No I did't mean you but rather discussion below your inquiry. But even in your request the person asked a particular question about particular IDE and you started to recommend "packaged" Emacs instead. Also if you are not new to to CL you probably know what LW is and what it offers and why anyone would pay for it. 2) If you ask me yes it is anachronism. But it is up to them do decide how to do business. After all the company is around for quite many years with the same people still working on the product. 
Thanks for clarification. I still can't see why someone who wants to do some Lisp as a hobby should pay 500$, just to make the GUI look decent on his 4k monitor. But, of course, it's up to him where he wants to spend his money.
Is this a serious question? With so many positive voices in this thread, which in all seriousness joyfully prefer an expensive license to a free open source offer, it is obvious that the representatives of this company have long since mixed among the people ;-)
Very nice, though it doesn't work with v5, only v4.
Yep, and they wrote a complete compiler and runtime from scratch to do it: [https://all-things-andy-gavin.com/2011/03/12/making-crash-bandicoot-gool-part-9/](https://all-things-andy-gavin.com/2011/03/12/making-crash-bandicoot-gool-part-9/) &amp;#x200B; The compiler was in Common Lisp; the games were in a much smaller custom Lisp.
If you write your own Lisp dialect and implementation, then you can port it to wherever you want. This adds even more work on top of just writing a game engine, though.
On the other hand, this seems like a good opportunity for an "open core" business model like some companies do, e.g. Gitlab. In this particular case, the PC and maybe mobile versions would be the $0 "open core" and completely FOSS, but the console ports (a massive amount of effort) could be commercial and that might be enough to fund the porting effort.
Fortunately, that kind of console is much easier to support.
It seems to be the most active Lisp subcommunity on the Internet. This is just speculation, but it might be because "write a game" and "write a large project in Lisp" are on quite a few programmers' todo lists for side projects. A Lisp game is just a combination of the two.
Meh. Yes and no. For instance zsh in particular has released a LOT of breaking changes over the last year that have made it painful to deal with. I get more bug reports now about problems that aren't problems I can solve than I did the last 5 years. 
When I started to study computer science I knew that I loved it, and I wanted to live from it. So I decided that whenever possible I would support programs that I used and buy them. That also meant that programs that I could not pay I would not use them, not even in "eternal shareware" mode (like winrar or sublime text). So, with this mentality, I'm totally in support of people wanting to buy a piece of software that they want to use. Specially when they already know of the alternatives. Some people, like you, seem to think that only the alternatives are the valid options, paying for software is for suckers, the software in question is stupid, blah blah blah. That is a wrong attitute and opinion. Each one's needs are different, accept this.
A lot of things should play together. Some things I mentioned in this presentation: https://www.slideshare.net/vseloved/lisp-in-a-startup-the-good-the-bad-and-the-ugly/26 (starting from this slide) But the main thing you, personally, can do now is continue using the language, regardless of the fad and other obstacles, making the ecosystem better little by little each day. :)
There's a bit of a circularity, it's not a popular choice because it's not popular. One probable path is to reduce the number of reasons somebody might not want to use it. Like "but C is faster", "but there's no library for doing X", "the debugger is not good as in Z", "no good GUI", "poor windows support", "I don't want to learn Emacs", "I want to interoperate with C++", etc. So, the only complaint left should be "I don't like parenthesis".
Please edit your post to make the code readable. If your using new reddit see: https://www.reddit.com/r/Common_Lisp/comments/a4przy/how_to_post_formatted_lisp_code_with_the_new/?ref=share&amp;ref_source=link
Don't, just read all lisp litterature and source out there so you get to know all the great ideas that have been explored in it.
You missed the most important reason - "Where is the community?".
Well, personally, I am working on a web browser that I hope will make an emacs-like effect within the Lisp community increasing the amount of Lisp users. A sort of "killer" application.
I feel the same. My take on it: - make http://common-lisp.net/ great again. By chance, they did it this year \o/ (in october ?) it looked [like this](https://web.archive.org/web/20171015231622/https://common-lisp.net/) last year and it didn't help. We also have http://lisp-lang.org/. - improve web resources, enter places that are popular amongst developers. Thus have a repertory of CL libraries by topic: https://github.com/CodyReichert/awesome-cl (it greatly improved in one year). Improve the [Cookbook](https://lispcookbook.github.io/cl-cookbook/) to make it easier for newcomers to embark and everyboday to refer to. It also greatly improved this year (compare to http://cl-cookbook.sourceforge.net/). I think the CLOS and numeric tutorials are great examples of helpful pages. - prove that Lisp is still being used by companies: https://github.com/azzamsa/awesome-lisp-companies and that it is still the language of choice in some fields. (these two "awesome lists" helped furnish common-lisp.net) - blog about CL - help merge work on Atom-Slime: https://github.com/sjlevine/atom-slime/pull/76 this PR is blocked, the maintainer doesn't have time to review and is reluctant to add a comaintainer to the project :S - be a politician and don't say that "Lisp is not popular". Just figure something else :p Indeed, on [Tiobe](https://www.tiobe.com/tiobe-index/) whatever is Lisp (and it is certainly Common Lisp :p ) it is 32th, before Rust, Kotlin, Haskell F# Erlang Scheme Julia and Clojure !!! - create examples of web projects, all in Lisp or Lisp + popular JS frameworks. Or make the same with the exciting Weblocks http://40ants.com/weblocks/ CL is difficult for the web right now. - contribute on the Next browser https://github.com/atlas-engineer/next it could be great. - use, contribute to https://github.com/cxxxr/lem ? cl-repl ? https://github.com/koji-kojiro/cl-repl and other editors and notebooks. - support Lisp projects that need funding - and of course, write a nice little project and show it.
Companies that hire a lot of programmers don't want to use Lisp because the best Lisp programmers are not usually available to hire and usually prefer to spend their time doing Lisp programming instead of the usual job duties of a programmer such as writing TPS reports, fitting in a corporate hierarchy, and playing company politics.
There have been a few game-related posts lately, including [mine](https://defungames.com/2018/12/creating-a-non-trivial-lisp-game-in-2018/), talking a bit about this. Ultimately the way to make Lisp more popular is to ignore the fact that it's not popular and just fucking use it and/or write tools for it anyway. :-) Everyone currently in this community, from the 20-year experts to the newbies, has a role to play here. I would suggest playing that role -- asking questions, sharing knowledge, writing docs, building libraries, building applications, creating art, working on the nitty-gritty of the compilers -- if you're doing it in Lisp (or about Lisp), you're probably helping the community.
We're talking about a **hobby edition** here; that's an edition people like the initiator of this thread want to use in their **spare time** when they are not working for a living, so they voluntarily invest time in a new topic **to educate themselves**. We are not talking about software that is used by for-profit companies to create value. In the present case, it's about whether someone really has to spend $500 on making the software he uses in his spare time look right on his screen or not. I didn't say anything about what you imply here. Is this subredit some kind of cult to promote commercial lisp companies?
\&gt; **hobby edition** So what? I paid much more for my hobbies. \&gt; making the software he uses in his spare time look right on his screen or not No, the original question began like this: 'I have a 4k monitor at home and I am thinking of purchasing Lispworks.' He didn't say, that he wanted to buy LispWorks BECAUSE of having a 4k screen. He was asking whether, given that he has a 4k screen, it would look good on it. Looking good is a requirement, but possibly not the cause for buying it. \&gt; Is this subredit some kind of cult to promote commercial lisp companies? I think he can buy it if he wants, regardless of distractors like you. If he has the money and does something useful for him ha can do what he wants. I guess, nobody cares about what you think is important for them. &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B;
I don't know whether CL would benefit from "Popularity" tbh. Sure, it would be used more widely, but it would probably find a lot of shitty frameworks. People who don't understand the concepts but still have to use it would write shitty libraries that make things "easier", and then everyone would have to use them (like jQuery for JavaScript), the language would probably be extended by stuff that makes it more similar to C/C++ (compare the new object-features of JavaScript). I guess the unpopularity of CL is a part of its appeal. For a more popular Lisp dialect, I'd recommend Clojure.
Hello, I've followed the example you have linked me. Bit I don't see the difference. Am I missing something?
Identify the pain points, start working on them. Perhaps help me with the UltraSpec as I do not have enough time nor energy do work on it on my own.
I don't know. When I approved the post, I noticed the code was not formatted and unreadable. Reddit markdown uses four spaces at the beginning of each line to represent code block. It uses a pair of single backquotes to represent in-line code. I noticed you had four backquotes at the beginning of the code which reddit did not and would not recognize.
I'm learning Lisp since a few weeks (just for curiosity and thanks to the videos bagges produces). Lisp itself is great , but there are two things that are really annoying me. The Hyper-Spec, which I use as reference and Emacs. The Hyper-Spec-Site just looks terrible, if compared with as Example the [haskell references](http://zvon.org/other/haskell/Outputglobal/index.html) on [zvon.org](https://zvon.org) (which aren't that great too, but much better). Also I feel forced to use Emacs because of Slime, i would prefer to use the editors (Atom or VsCode) i'm used to. Is there some kind of "standalone" Slime, which i can combine with my editor of choice ?
I don't know your requirements, but if you are open to using Clojure, it has a killer Atom plugin called the ProtoREPL. VsCode has a pretty good one too.
To make your script a little bit more portable, you should replace the first line with `#!/usr/bin/env -S sbcl --script`.
I also tried clojure and you're right, clojure hasn't that problems. But clojure isn't common lisp.
Atom has helpful plugins for working with Lisp! Check them out: https://atom.io/packages/atom-slime (also has info about other plugins that help with Lisp)
FUD: What if you're an organization invested in using CL, only to find out one day that no one maintains any of the compilers any more? The worry is real
I think that's actually a good strategy. If you end up creating a popular game or software in the Lisp it might inspire others to give the language a try. As an example, I got my start in programming in Java after learning Notch used it to create Minecraft. Seeing a [video of him](https://youtu.be/BES9EKK4Aw4?t=45) making tweaks in code and watching the game mechanics change immediately was very interesting and inspiring to me. And I don't even like Java anymore. If I were to go back I'd start with C/C++ instead. 
I think that's actually a good strategy. If you end up creating a popular game or software in the Lisp it might inspire others to give the language a try. As an example, I got my start in programming in Java after learning Notch used it to create Minecraft. Seeing a [video of him](https://youtu.be/BES9EKK4Aw4?t=45) making tweaks in code and watching the game mechanics change immediately was very interesting and inspiring to me. And I don't even like Java anymore. If I were to go back I'd start with C/C++ instead. 
I don't think jQuery is a good example of a bad javascript library. And people aren't really forced to use it. There are SO many js frameworks (or libraries) that do similar things. 
I personally think we need better tooling outside of Emacs. Emacs is awesome but it's not for everyone. I think SBCL needs readline support as it is the most popular common lisp implementation. It's not an impossible task to add. There's even Linedit that will do just this: https://www.common-lisp.net/project/linedit/ More educational videos would also be a help. Some people prefer them over reading - especially for learning beginner concepts. The whole package-management/project workflow of common lisp took me a while to wrap my head around. Would love to create video tutorials on common lisp after I get a deep enough knowledge of the language.
As someone who has learned Lisp in the last years, the following would have helped me. A website which: * Shows how to install and configure SBCL &amp; Quicklisp. * Has examples of creating a minimal app and defining local packages * Teaches you the minimal of debugging * Lists some common pitfalls and their solutions * Lists most used packages for common problems (webserver, asynchronous programming) with examples All of this can be figured out by a new user, the info is just spread out in the internet and hides in videos, books and blog posts. Having an opinionated starting point would have helped a lot.
I've tried to get into lisp a few times and my problem has always been that it's a pain to set up and the default ide is just unpleasant. 
What's (asdf:asdf-version)? They are probably not working with ASDF 2.
Absolutely. That's our goal with https://lispcookbook.github.io/cl-cookbook/ (PR about debugging)
2.26
Did you try Portacle (http://portacle.github.io/) (it's Emacs, but built-in for CL), or Lem (https://github.com/cxxxr/lem, ready-to-use for CL and other languages, Emacs-like keybindings), or https://github.com/koji-kojiro/cl-repl (an "ipython-like" repl) ? (source: https://lispcookbook.github.io/cl-cookbook/editor-support.html) I felt strange about Slime first but now I love it, it has advanced features and working in a Lisp repl is a pleasure.
\+1, maybe cl-repl can help here: https://github.com/koji-kojiro/cl-repl (an "ipython-like" repl)
Which one is the default IDE you're referring to? 
&gt;The Hyper-Spec-Site just looks terrible This is a frivolous statement, since the CLHS is well written and organized.
&gt;such as writing TPS reports btw, you need to put the new coversheets on them. 
Emacs. 
Hi dzecniv, I used to want to make CL popular but now i'm in doubt. And I think that if we make a poll here: **Do you want to make Lisp popular?** , we'll get a strong percentage of NO answers. I have this nightmare where CL becomes as popular as Javascript, and then the CL ecosystem becomes as bad as the NPM ecosystem. Articles on `medium.com` where they tell you to use `cl-left-pad` instead of a well-crafted FORMAT string, because " `cl-left-pad` is webscale and used by the top blockchain startups". Perhaps what we should do, and you have already contributed a lot to this, is to make onboarding easier for genuinely interested newcomers. I feel we're almost there! 
I see. Would you be so kind to explain what were the things that were annoying you or what you lacked when using emacs? 